{"sha": "c47277a61921d796eb8e535c4f410962ae91c2f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3Mjc3YTYxOTIxZDc5NmViOGU1MzVjNGY0MTA5NjJhZTkxYzJmMQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2007-02-15T16:40:16Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2007-02-15T16:40:16Z"}, "message": "jump.c (get_label_after): Delete.\n\n2007-02-15  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* jump.c (get_label_after): Delete.\n\t(get_label_before, delete_computation, delete_jump,\n\tdelete_prior_computation, follow_jumps): Move...\n\t* reorg.c (delete_computation, delete_prior_computation): ... here...\n\t(get_label_before, delete_jump): ... making these static ...\n\t(follow_jumps): ... and simplifying this since it only runs after\n\treload.\n\t* rtl.h (get_label_after, get_label_before, delete_jump,\n\tfollow_jumps): Delete prototypes.\n\nFrom-SVN: r122003", "tree": {"sha": "a4ecd439756c715b1fec70a7189c31aeed517c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4ecd439756c715b1fec70a7189c31aeed517c1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c47277a61921d796eb8e535c4f410962ae91c2f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47277a61921d796eb8e535c4f410962ae91c2f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47277a61921d796eb8e535c4f410962ae91c2f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47277a61921d796eb8e535c4f410962ae91c2f1/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe60528edc81e6aaccb5b49b7108853f30ea6278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe60528edc81e6aaccb5b49b7108853f30ea6278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe60528edc81e6aaccb5b49b7108853f30ea6278"}], "stats": {"total": 555, "additions": 268, "deletions": 287}, "files": [{"sha": "c83917e39f3518c8a1d7e46fe16228f0d1efdcbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c47277a61921d796eb8e535c4f410962ae91c2f1", "patch": "@@ -1,3 +1,15 @@\n+2007-02-15  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* jump.c (get_label_after): Delete.\n+\t(get_label_before, delete_computation, delete_jump,\n+\tdelete_prior_computation, follow_jumps): Move...\n+\t* reorg.c (delete_computation, delete_prior_computation): ... here...\n+\t(get_label_before, delete_jump): ... making these static ...\n+\t(follow_jumps): ... and simplifying this since it only runs after\n+\treload.\n+\t* rtl.h (get_label_after, get_label_before, delete_jump,\n+\tfollow_jumps): Delete prototypes.\n+\n 2007-02-15  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* caller-save.c (save_call_clobbered_regs): Do not process sibcalls."}, {"sha": "a82d407b6cc9196f4d06b17c56aa23510554fb48", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 283, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=c47277a61921d796eb8e535c4f410962ae91c2f1", "patch": "@@ -285,48 +285,6 @@ squeeze_notes (rtx* startp, rtx* endp)\n   return false;\n }\n \f\n-/* Return the label before INSN, or put a new label there.  */\n-\n-rtx\n-get_label_before (rtx insn)\n-{\n-  rtx label;\n-\n-  /* Find an existing label at this point\n-     or make a new one if there is none.  */\n-  label = prev_nonnote_insn (insn);\n-\n-  if (label == 0 || !LABEL_P (label))\n-    {\n-      rtx prev = PREV_INSN (insn);\n-\n-      label = gen_label_rtx ();\n-      emit_label_after (label, prev);\n-      LABEL_NUSES (label) = 0;\n-    }\n-  return label;\n-}\n-\n-/* Return the label after INSN, or put a new label there.  */\n-\n-rtx\n-get_label_after (rtx insn)\n-{\n-  rtx label;\n-\n-  /* Find an existing label at this point\n-     or make a new one if there is none.  */\n-  label = next_nonnote_insn (insn);\n-\n-  if (label == 0 || !LABEL_P (label))\n-    {\n-      label = gen_label_rtx ();\n-      emit_label_after (label, insn);\n-      LABEL_NUSES (label) = 0;\n-    }\n-  return label;\n-}\n-\f\n /* Given a comparison (CODE ARG0 ARG1), inside an insn, INSN, return a code\n    of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.\n    UNKNOWN may be returned in case we are having CC_MODE compare and we don't\n@@ -1000,61 +958,6 @@ sets_cc0_p (rtx x)\n   return 0;\n }\n #endif\n-\f\n-/* Follow any unconditional jump at LABEL;\n-   return the ultimate label reached by any such chain of jumps.\n-   Return null if the chain ultimately leads to a return instruction.\n-   If LABEL is not followed by a jump, return LABEL.\n-   If the chain loops or we can't find end, return LABEL,\n-   since that tells caller to avoid changing the insn.\n-\n-   If RELOAD_COMPLETED is 0, we do not chain across a USE or CLOBBER.  */\n-\n-rtx\n-follow_jumps (rtx label)\n-{\n-  rtx insn;\n-  rtx next;\n-  rtx value = label;\n-  int depth;\n-\n-  for (depth = 0;\n-       (depth < 10\n-\t&& (insn = next_active_insn (value)) != 0\n-\t&& JUMP_P (insn)\n-\t&& ((JUMP_LABEL (insn) != 0 && any_uncondjump_p (insn)\n-\t     && onlyjump_p (insn))\n-\t    || GET_CODE (PATTERN (insn)) == RETURN)\n-\t&& (next = NEXT_INSN (insn))\n-\t&& BARRIER_P (next));\n-       depth++)\n-    {\n-      rtx tem;\n-      if (!reload_completed && flag_test_coverage)\n-\t{\n-\t  /* ??? Optional.  Disables some optimizations, but makes\n-\t     gcov output more accurate with -O.  */\n-\t  for (tem = value; tem != insn; tem = NEXT_INSN (tem))\n-\t    if (NOTE_P (tem) && NOTE_LINE_NUMBER (tem) > 0)\n-\t      return value;\n-\t}\n-\n-      /* If we have found a cycle, make the insn jump to itself.  */\n-      if (JUMP_LABEL (insn) == label)\n-\treturn label;\n-\n-      tem = next_active_insn (JUMP_LABEL (insn));\n-      if (tem && (GET_CODE (PATTERN (tem)) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN (tem)) == ADDR_DIFF_VEC))\n-\tbreak;\n-\n-      value = JUMP_LABEL (insn);\n-    }\n-  if (depth == 10)\n-    return label;\n-  return value;\n-}\n-\n \f\n /* Find all CODE_LABELs referred to in X, and increment their use counts.\n    If INSN is a JUMP_INSN and there is at least one CODE_LABEL referenced\n@@ -1169,192 +1072,6 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n     }\n }\n \n-/* If all INSN does is set the pc, delete it,\n-   and delete the insn that set the condition codes for it\n-   if that's what the previous thing was.  */\n-\n-void\n-delete_jump (rtx insn)\n-{\n-  rtx set = single_set (insn);\n-\n-  if (set && GET_CODE (SET_DEST (set)) == PC)\n-    delete_computation (insn);\n-}\n-\n-/* Recursively delete prior insns that compute the value (used only by INSN\n-   which the caller is deleting) stored in the register mentioned by NOTE\n-   which is a REG_DEAD note associated with INSN.  */\n-\n-static void\n-delete_prior_computation (rtx note, rtx insn)\n-{\n-  rtx our_prev;\n-  rtx reg = XEXP (note, 0);\n-\n-  for (our_prev = prev_nonnote_insn (insn);\n-       our_prev && (NONJUMP_INSN_P (our_prev)\n-\t\t    || CALL_P (our_prev));\n-       our_prev = prev_nonnote_insn (our_prev))\n-    {\n-      rtx pat = PATTERN (our_prev);\n-\n-      /* If we reach a CALL which is not calling a const function\n-\t or the callee pops the arguments, then give up.  */\n-      if (CALL_P (our_prev)\n-\t  && (! CONST_OR_PURE_CALL_P (our_prev)\n-\t      || GET_CODE (pat) != SET || GET_CODE (SET_SRC (pat)) != CALL))\n-\tbreak;\n-\n-      /* If we reach a SEQUENCE, it is too complex to try to\n-\t do anything with it, so give up.  We can be run during\n-\t and after reorg, so SEQUENCE rtl can legitimately show\n-\t up here.  */\n-      if (GET_CODE (pat) == SEQUENCE)\n-\tbreak;\n-\n-      if (GET_CODE (pat) == USE\n-\t  && NONJUMP_INSN_P (XEXP (pat, 0)))\n-\t/* reorg creates USEs that look like this.  We leave them\n-\t   alone because reorg needs them for its own purposes.  */\n-\tbreak;\n-\n-      if (reg_set_p (reg, pat))\n-\t{\n-\t  if (side_effects_p (pat) && !CALL_P (our_prev))\n-\t    break;\n-\n-\t  if (GET_CODE (pat) == PARALLEL)\n-\t    {\n-\t      /* If we find a SET of something else, we can't\n-\t\t delete the insn.  */\n-\n-\t      int i;\n-\n-\t      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t\t{\n-\t\t  rtx part = XVECEXP (pat, 0, i);\n-\n-\t\t  if (GET_CODE (part) == SET\n-\t\t      && SET_DEST (part) != reg)\n-\t\t    break;\n-\t\t}\n-\n-\t      if (i == XVECLEN (pat, 0))\n-\t\tdelete_computation (our_prev);\n-\t    }\n-\t  else if (GET_CODE (pat) == SET\n-\t\t   && REG_P (SET_DEST (pat)))\n-\t    {\n-\t      int dest_regno = REGNO (SET_DEST (pat));\n-\t      int dest_endregno\n-\t\t= (dest_regno\n-\t\t   + (dest_regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? hard_regno_nregs[dest_regno]\n-\t\t\t\t\t[GET_MODE (SET_DEST (pat))] : 1));\n-\t      int regno = REGNO (reg);\n-\t      int endregno\n-\t\t= (regno\n-\t\t   + (regno < FIRST_PSEUDO_REGISTER\n-\t\t      ? hard_regno_nregs[regno][GET_MODE (reg)] : 1));\n-\n-\t      if (dest_regno >= regno\n-\t\t  && dest_endregno <= endregno)\n-\t\tdelete_computation (our_prev);\n-\n-\t      /* We may have a multi-word hard register and some, but not\n-\t\t all, of the words of the register are needed in subsequent\n-\t\t insns.  Write REG_UNUSED notes for those parts that were not\n-\t\t needed.  */\n-\t      else if (dest_regno <= regno\n-\t\t       && dest_endregno >= endregno)\n-\t\t{\n-\t\t  int i;\n-\n-\t\t  REG_NOTES (our_prev)\n-\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED, reg,\n-\t\t\t\t\t REG_NOTES (our_prev));\n-\n-\t\t  for (i = dest_regno; i < dest_endregno; i++)\n-\t\t    if (! find_regno_note (our_prev, REG_UNUSED, i))\n-\t\t      break;\n-\n-\t\t  if (i == dest_endregno)\n-\t\t    delete_computation (our_prev);\n-\t\t}\n-\t    }\n-\n-\t  break;\n-\t}\n-\n-      /* If PAT references the register that dies here, it is an\n-\t additional use.  Hence any prior SET isn't dead.  However, this\n-\t insn becomes the new place for the REG_DEAD note.  */\n-      if (reg_overlap_mentioned_p (reg, pat))\n-\t{\n-\t  XEXP (note, 1) = REG_NOTES (our_prev);\n-\t  REG_NOTES (our_prev) = note;\n-\t  break;\n-\t}\n-    }\n-}\n-\n-/* Delete INSN and recursively delete insns that compute values used only\n-   by INSN.  This uses the REG_DEAD notes computed during flow analysis.\n-   If we are running before flow.c, we need do nothing since flow.c will\n-   delete dead code.  We also can't know if the registers being used are\n-   dead or not at this point.\n-\n-   Otherwise, look at all our REG_DEAD notes.  If a previous insn does\n-   nothing other than set a register that dies in this insn, we can delete\n-   that insn as well.\n-\n-   On machines with CC0, if CC0 is used in this insn, we may be able to\n-   delete the insn that set it.  */\n-\n-static void\n-delete_computation (rtx insn)\n-{\n-  rtx note, next;\n-\n-#ifdef HAVE_cc0\n-  if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n-    {\n-      rtx prev = prev_nonnote_insn (insn);\n-      /* We assume that at this stage\n-\t CC's are always set explicitly\n-\t and always immediately before the jump that\n-\t will use them.  So if the previous insn\n-\t exists to set the CC's, delete it\n-\t (unless it performs auto-increments, etc.).  */\n-      if (prev && NONJUMP_INSN_P (prev)\n-\t  && sets_cc0_p (PATTERN (prev)))\n-\t{\n-\t  if (sets_cc0_p (PATTERN (prev)) > 0\n-\t      && ! side_effects_p (PATTERN (prev)))\n-\t    delete_computation (prev);\n-\t  else\n-\t    /* Otherwise, show that cc0 won't be used.  */\n-\t    REG_NOTES (prev) = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t\t\t\t  cc0_rtx, REG_NOTES (prev));\n-\t}\n-    }\n-#endif\n-\n-  for (note = REG_NOTES (insn); note; note = next)\n-    {\n-      next = XEXP (note, 1);\n-\n-      if (REG_NOTE_KIND (note) != REG_DEAD\n-\t  /* Verify that the REG_NOTE is legitimate.  */\n-\t  || !REG_P (XEXP (note, 0)))\n-\tcontinue;\n-\n-      delete_prior_computation (note, insn);\n-    }\n-\n-  delete_related_insns (insn);\n-}\n \f\n /* Delete insn INSN from the chain of insns and update label ref counts\n    and delete insns now unreachable."}, {"sha": "e4655d2ad3d94dd6c394f969d6347aa2e8892c91", "filename": "gcc/reorg.c", "status": "modified", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=c47277a61921d796eb8e535c4f410962ae91c2f1", "patch": "@@ -1972,6 +1972,28 @@ update_reg_unused_notes (rtx insn, rtx redundant_insn)\n     }\n }\n \f\n+/* Return the label before INSN, or put a new label there.  */\n+\n+static rtx\n+get_label_before (rtx insn)\n+{\n+  rtx label;\n+\n+  /* Find an existing label at this point\n+     or make a new one if there is none.  */\n+  label = prev_nonnote_insn (insn);\n+\n+  if (label == 0 || !LABEL_P (label))\n+    {\n+      rtx prev = PREV_INSN (insn);\n+\n+      label = gen_label_rtx ();\n+      emit_label_after (label, prev);\n+      LABEL_NUSES (label) = 0;\n+    }\n+  return label;\n+}\n+\n /* Scan a function looking for insns that need a delay slot and find insns to\n    put into the delay slot.\n \n@@ -2468,6 +2490,50 @@ fill_simple_delay_slots (int non_jumps_p)\n #endif\n }\n \f\n+/* Follow any unconditional jump at LABEL;\n+   return the ultimate label reached by any such chain of jumps.\n+   Return null if the chain ultimately leads to a return instruction.\n+   If LABEL is not followed by a jump, return LABEL.\n+   If the chain loops or we can't find end, return LABEL,\n+   since that tells caller to avoid changing the insn.  */\n+\n+static rtx\n+follow_jumps (rtx label)\n+{\n+  rtx insn;\n+  rtx next;\n+  rtx value = label;\n+  int depth;\n+\n+  for (depth = 0;\n+       (depth < 10\n+\t&& (insn = next_active_insn (value)) != 0\n+\t&& JUMP_P (insn)\n+\t&& ((JUMP_LABEL (insn) != 0 && any_uncondjump_p (insn)\n+\t     && onlyjump_p (insn))\n+\t    || GET_CODE (PATTERN (insn)) == RETURN)\n+\t&& (next = NEXT_INSN (insn))\n+\t&& BARRIER_P (next));\n+       depth++)\n+    {\n+      rtx tem;\n+\n+      /* If we have found a cycle, make the insn jump to itself.  */\n+      if (JUMP_LABEL (insn) == label)\n+\treturn label;\n+\n+      tem = next_active_insn (JUMP_LABEL (insn));\n+      if (tem && (GET_CODE (PATTERN (tem)) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN (tem)) == ADDR_DIFF_VEC))\n+\tbreak;\n+\n+      value = JUMP_LABEL (insn);\n+    }\n+  if (depth == 10)\n+    return label;\n+  return value;\n+}\n+\n /* Try to find insns to place in delay slots.\n \n    INSN is the jump needing SLOTS_TO_FILL delay slots.  It tests CONDITION\n@@ -3036,6 +3102,196 @@ fill_eager_delay_slots (void)\n       note_delay_statistics (slots_filled, 1);\n     }\n }\n+\f\n+static void delete_computation (rtx insn);\n+\n+/* Recursively delete prior insns that compute the value (used only by INSN\n+   which the caller is deleting) stored in the register mentioned by NOTE\n+   which is a REG_DEAD note associated with INSN.  */\n+\n+static void\n+delete_prior_computation (rtx note, rtx insn)\n+{\n+  rtx our_prev;\n+  rtx reg = XEXP (note, 0);\n+\n+  for (our_prev = prev_nonnote_insn (insn);\n+       our_prev && (NONJUMP_INSN_P (our_prev)\n+\t\t    || CALL_P (our_prev));\n+       our_prev = prev_nonnote_insn (our_prev))\n+    {\n+      rtx pat = PATTERN (our_prev);\n+\n+      /* If we reach a CALL which is not calling a const function\n+\t or the callee pops the arguments, then give up.  */\n+      if (CALL_P (our_prev)\n+\t  && (! CONST_OR_PURE_CALL_P (our_prev)\n+\t      || GET_CODE (pat) != SET || GET_CODE (SET_SRC (pat)) != CALL))\n+\tbreak;\n+\n+      /* If we reach a SEQUENCE, it is too complex to try to\n+\t do anything with it, so give up.  We can be run during\n+\t and after reorg, so SEQUENCE rtl can legitimately show\n+\t up here.  */\n+      if (GET_CODE (pat) == SEQUENCE)\n+\tbreak;\n+\n+      if (GET_CODE (pat) == USE\n+\t  && NONJUMP_INSN_P (XEXP (pat, 0)))\n+\t/* reorg creates USEs that look like this.  We leave them\n+\t   alone because reorg needs them for its own purposes.  */\n+\tbreak;\n+\n+      if (reg_set_p (reg, pat))\n+\t{\n+\t  if (side_effects_p (pat) && !CALL_P (our_prev))\n+\t    break;\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    {\n+\t      /* If we find a SET of something else, we can't\n+\t\t delete the insn.  */\n+\n+\t      int i;\n+\n+\t      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t\t{\n+\t\t  rtx part = XVECEXP (pat, 0, i);\n+\n+\t\t  if (GET_CODE (part) == SET\n+\t\t      && SET_DEST (part) != reg)\n+\t\t    break;\n+\t\t}\n+\n+\t      if (i == XVECLEN (pat, 0))\n+\t\tdelete_computation (our_prev);\n+\t    }\n+\t  else if (GET_CODE (pat) == SET\n+\t\t   && REG_P (SET_DEST (pat)))\n+\t    {\n+\t      int dest_regno = REGNO (SET_DEST (pat));\n+\t      int dest_endregno\n+\t\t= (dest_regno\n+\t\t   + (dest_regno < FIRST_PSEUDO_REGISTER\n+\t\t      ? hard_regno_nregs[dest_regno]\n+\t\t\t\t\t[GET_MODE (SET_DEST (pat))] : 1));\n+\t      int regno = REGNO (reg);\n+\t      int endregno\n+\t\t= (regno\n+\t\t   + (regno < FIRST_PSEUDO_REGISTER\n+\t\t      ? hard_regno_nregs[regno][GET_MODE (reg)] : 1));\n+\n+\t      if (dest_regno >= regno\n+\t\t  && dest_endregno <= endregno)\n+\t\tdelete_computation (our_prev);\n+\n+\t      /* We may have a multi-word hard register and some, but not\n+\t\t all, of the words of the register are needed in subsequent\n+\t\t insns.  Write REG_UNUSED notes for those parts that were not\n+\t\t needed.  */\n+\t      else if (dest_regno <= regno\n+\t\t       && dest_endregno >= endregno)\n+\t\t{\n+\t\t  int i;\n+\n+\t\t  REG_NOTES (our_prev)\n+\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED, reg,\n+\t\t\t\t\t REG_NOTES (our_prev));\n+\n+\t\t  for (i = dest_regno; i < dest_endregno; i++)\n+\t\t    if (! find_regno_note (our_prev, REG_UNUSED, i))\n+\t\t      break;\n+\n+\t\t  if (i == dest_endregno)\n+\t\t    delete_computation (our_prev);\n+\t\t}\n+\t    }\n+\n+\t  break;\n+\t}\n+\n+      /* If PAT references the register that dies here, it is an\n+\t additional use.  Hence any prior SET isn't dead.  However, this\n+\t insn becomes the new place for the REG_DEAD note.  */\n+      if (reg_overlap_mentioned_p (reg, pat))\n+\t{\n+\t  XEXP (note, 1) = REG_NOTES (our_prev);\n+\t  REG_NOTES (our_prev) = note;\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Delete INSN and recursively delete insns that compute values used only\n+   by INSN.  This uses the REG_DEAD notes computed during flow analysis.\n+   If we are running before flow.c, we need do nothing since flow.c will\n+   delete dead code.  We also can't know if the registers being used are\n+   dead or not at this point.\n+\n+   Otherwise, look at all our REG_DEAD notes.  If a previous insn does\n+   nothing other than set a register that dies in this insn, we can delete\n+   that insn as well.\n+\n+   On machines with CC0, if CC0 is used in this insn, we may be able to\n+   delete the insn that set it.  */\n+\n+static void\n+delete_computation (rtx insn)\n+{\n+  rtx note, next;\n+\n+#ifdef HAVE_cc0\n+  if (reg_referenced_p (cc0_rtx, PATTERN (insn)))\n+    {\n+      rtx prev = prev_nonnote_insn (insn);\n+      /* We assume that at this stage\n+\t CC's are always set explicitly\n+\t and always immediately before the jump that\n+\t will use them.  So if the previous insn\n+\t exists to set the CC's, delete it\n+\t (unless it performs auto-increments, etc.).  */\n+      if (prev && NONJUMP_INSN_P (prev)\n+\t  && sets_cc0_p (PATTERN (prev)))\n+\t{\n+\t  if (sets_cc0_p (PATTERN (prev)) > 0\n+\t      && ! side_effects_p (PATTERN (prev)))\n+\t    delete_computation (prev);\n+\t  else\n+\t    /* Otherwise, show that cc0 won't be used.  */\n+\t    REG_NOTES (prev) = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t\t  cc0_rtx, REG_NOTES (prev));\n+\t}\n+    }\n+#endif\n+\n+  for (note = REG_NOTES (insn); note; note = next)\n+    {\n+      next = XEXP (note, 1);\n+\n+      if (REG_NOTE_KIND (note) != REG_DEAD\n+\t  /* Verify that the REG_NOTE is legitimate.  */\n+\t  || !REG_P (XEXP (note, 0)))\n+\tcontinue;\n+\n+      delete_prior_computation (note, insn);\n+    }\n+\n+  delete_related_insns (insn);\n+}\n+\n+/* If all INSN does is set the pc, delete it,\n+   and delete the insn that set the condition codes for it\n+   if that's what the previous thing was.  */\n+\n+static void\n+delete_jump (rtx insn)\n+{\n+  rtx set = single_set (insn);\n+\n+  if (set && GET_CODE (SET_DEST (set)) == PC)\n+    delete_computation (insn);\n+}\n+\n \f\n /* Once we have tried two ways to fill a delay slot, make a pass over the\n    code to try to improve the results and to do such things as more jump"}, {"sha": "fdd582d5fd2b78b14ec879e5857735cdde22df4f", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47277a61921d796eb8e535c4f410962ae91c2f1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c47277a61921d796eb8e535c4f410962ae91c2f1", "patch": "@@ -1598,10 +1598,6 @@ extern unsigned int cleanup_barriers (void);\n /* In jump.c */\n extern bool squeeze_notes (rtx *, rtx *);\n extern rtx delete_related_insns (rtx);\n-extern void delete_jump (rtx);\n-extern rtx get_label_before (rtx);\n-extern rtx get_label_after (rtx);\n-extern rtx follow_jumps (rtx);\n \n /* In recog.c  */\n extern rtx *find_constant_term_loc (rtx *);"}]}