{"sha": "21f638b9b04b977159ff29ac9de97ffec40c607f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFmNjM4YjliMDRiOTc3MTU5ZmYyOWFjOWRlOTdmZmVjNDBjNjA3Zg==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2006-05-10T21:55:34Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2006-05-10T21:55:34Z"}, "message": "target-supports-dg.exp (dg-require-cxa-atexit): New.\n\n\t* lib/target-supports-dg.exp (dg-require-cxa-atexit): New.\n\t* lib/target-supports.dg (check_cxa_atexit_available): New.\n\nFrom-SVN: r113684", "tree": {"sha": "db63e8a13f99e4b2c59caa9d4a92533a7ebfd147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db63e8a13f99e4b2c59caa9d4a92533a7ebfd147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21f638b9b04b977159ff29ac9de97ffec40c607f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f638b9b04b977159ff29ac9de97ffec40c607f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f638b9b04b977159ff29ac9de97ffec40c607f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f638b9b04b977159ff29ac9de97ffec40c607f/comments", "author": null, "committer": null, "parents": [{"sha": "29e339b95aa44fa710257c2c79a64d31eb4b31d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e339b95aa44fa710257c2c79a64d31eb4b31d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29e339b95aa44fa710257c2c79a64d31eb4b31d1"}], "stats": {"total": 101, "additions": 101, "deletions": 0}, "files": [{"sha": "e21851c6613892b404eef620bb02ea99bdb40425", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f638b9b04b977159ff29ac9de97ffec40c607f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f638b9b04b977159ff29ac9de97ffec40c607f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=21f638b9b04b977159ff29ac9de97ffec40c607f", "patch": "@@ -1,3 +1,8 @@\n+2006-05-09  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* lib/target-supports-dg.exp (dg-require-cxa-atexit): New.\n+\t* lib/target-supports.dg (check_cxa_atexit_available): New.\n+\n 2005-05-10  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR fortran/27470"}, {"sha": "b361b7fe3dc7e6d3b025cfb35bf91940aea74cd2", "filename": "gcc/testsuite/lib/target-supports-dg.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f638b9b04b977159ff29ac9de97ffec40c607f/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f638b9b04b977159ff29ac9de97ffec40c607f/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp?ref=21f638b9b04b977159ff29ac9de97ffec40c607f", "patch": "@@ -140,6 +140,15 @@ proc dg-require-mkfifo { args } {\n     }\n }\n \n+# If this target does not use __cxa_atexit, skip this test.\n+\n+proc dg-require-cxa-atexit { args } {\n+    if { ![ check_cxa_atexit_available ] } {\n+        upvar dg-do-what dg-do-what\n+        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n # Check the flags with which the test will be run against options in\n # a test directive that will skip or xfail that test.  The DejaGnu proc\n # check_conditional_xfail will look at the options in compiler_flags, so"}, {"sha": "d4242e666c25268a8cb71121e379fc648ea7122e", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f638b9b04b977159ff29ac9de97ffec40c607f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f638b9b04b977159ff29ac9de97ffec40c607f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=21f638b9b04b977159ff29ac9de97ffec40c607f", "patch": "@@ -916,6 +916,93 @@ proc check_mkfifo_available {} {\n     return [check_function_available \"mkfifo\"]\n }\n \n+# Returns true iff \"__cxa_atexit\" is used on the target system.\n+\n+proc check_cxa_atexit_available { } {\n+    global et_cxa_atexit\n+    global et_cxa_atexit_target_name\n+    global tool\t\n+\n+    if { ![info exists et_cxa_atexit_target_name] } {\n+\tset et_cxa_atexit_target_name \"\"\n+    }\n+\n+    # If the target has changed since we set the cached value, clear it.\n+    set current_target [current_target_name]\n+    if { $current_target != $et_cxa_atexit_target_name } {\n+\tverbose \"check_cxa_atexit_available: `$et_cxa_atexit_target_name'\" 2\n+\tset et_cxa_atexit_target_name $current_target\n+\tif [info exists et_cxa_atexit] {\n+\t    verbose \"check_cxa_atexit_available: removing cached result\" 2\n+\t    unset et_cxa_atexit\n+\t}\n+    }\n+\n+    if [info exists et_cxa_atexit] {\n+\tverbose \"check_cxa_atexit_available: using cached result\" 2\n+    } else {\n+\tset et_cxa_atexit 0\n+\n+\t# Set up, compile, and execute a C++ test program that depends\n+\t# on correct ordering of static object destructors. This is\n+\t# indicative of the presence and use of __cxa_atexit.\n+\tset src cxaatexit[pid].cc\n+\tset exe cxaatexit[pid].x\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include <stdlib.h>\"\n+\tputs $f \"static unsigned int count;\"\n+\tputs $f \"struct X\"\n+\tputs $f \"{\"\n+\tputs $f \"  X() { count = 1; }\"\n+\tputs $f \"  ~X()\"\n+\tputs $f \"  {\"\n+\tputs $f \"    if (count != 3)\"\n+\tputs $f \"      exit(1);\"\n+\tputs $f \"    count = 4;\"\n+        puts $f \"  }\"\n+        puts $f \"};\"\n+\tputs $f \"void f()\"\n+\tputs $f \"{\"\n+\tputs $f \"  static X x;\"\n+        puts $f \"}\"\n+\tputs $f \"struct Y\"\n+\tputs $f \"{\"\n+\tputs $f \"  Y() { f(); count = 2; }\"\n+\tputs $f \"  ~Y()\"\n+\tputs $f \"  {\"\n+\tputs $f \"    if (count != 2)\"\n+\tputs $f \"      exit(1);\"\n+\tputs $f \"    count = 3;\"\n+        puts $f \"  }\"\n+        puts $f \"};\"\n+\tputs $f \"Y y;\"\n+\tputs $f \"int main()\"\n+\tputs $f \"{ return 0; }\"\n+\tclose $f\n+\n+\tset lines [v3_target_compile $src $exe executable \"\"]\n+\tfile delete $src\n+\n+\tif [string match \"\" $lines] {\n+\t    # No error message, compilation succeeded.\n+\t    set result [${tool}_load \"./$exe\" \"\" \"\"]\n+\t    set status [lindex $result 0]\n+\t    remote_file build delete $exe\n+\n+\t    verbose \"check_cxa_atexit_available: status is <$status>\" 2\n+\n+\t    if { $status == \"pass\" } {\n+\t\tset et_cxa_atexit 1\n+\t    }\n+\t} else {\n+\t    verbose \"check_cxa_atexit_available: compilation failed\" 2\n+\t}\n+    }\n+    return $et_cxa_atexit\n+}\n+\n+\n # Return 1 if we're generating 32-bit code using default options, 0\n # otherwise.\n "}]}