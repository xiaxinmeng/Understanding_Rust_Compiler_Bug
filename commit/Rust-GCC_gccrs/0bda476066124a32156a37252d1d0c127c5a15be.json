{"sha": "0bda476066124a32156a37252d1d0c127c5a15be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJkYTQ3NjA2NjEyNGEzMjE1NmEzNzI1MmQxZDBjMTI3YzVhMTViZQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-11T07:45:16Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-11T07:45:16Z"}, "message": "cpperror.c (print_location): New function.\n\n        * cpperror.c (print_location): New function.\n        (print_containing_files): Simplify.\n        (_cpp_begin_message): Simplify and use print_location.\n        * cppfiles.c (stack_include_file): Update.\n        (_cpp_pop_file_buffer): Update.\n        * cpphash.h (struct cpp_buffer): New members\n        include_stack_listed and type.\n        * cpplib.c (_cpp_handle_directive): Buffer->inc is not null.\n        (run_directive): Take buffer type.  cpp_push_buffer cannot fail.\n        (_cpp_do__Pragma, cpp_define, _cpp_define_builtin, cpp_undef,\n        handle_assertion): Update.\n        (cpp_push_buffer): Take a buffer type and file name.\n        (cpp_pop_buffer): Update.  Clear include_stack_listed.\n        * cpplib.h (input_stack_listing_current): Remove.\n        (enum cpp_buffer_type): New.\n        (cpp_push_buffer): New prototype.\n        * cppmacro.c (builtin_macro): Simplify; buffer cannot be null.\n        * fix-header.c (read_scan_file): Update.\n\nFrom-SVN: r38186", "tree": {"sha": "1cf059e8adaf7964d2336feb8095b222fd1c04cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cf059e8adaf7964d2336feb8095b222fd1c04cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bda476066124a32156a37252d1d0c127c5a15be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bda476066124a32156a37252d1d0c127c5a15be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bda476066124a32156a37252d1d0c127c5a15be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bda476066124a32156a37252d1d0c127c5a15be/comments", "author": null, "committer": null, "parents": [{"sha": "c5afc1922c0ac026bfd781289bfe5d067f19204a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5afc1922c0ac026bfd781289bfe5d067f19204a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5afc1922c0ac026bfd781289bfe5d067f19204a"}], "stats": {"total": 271, "additions": 159, "deletions": 112}, "files": [{"sha": "04abbf441786694b92e057306f55d426c56c2b26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -1,3 +1,24 @@\n+2000-12-11  Neil Booth  <neilb@earthling.net>\n+\n+        * cpperror.c (print_location): New function.\n+        (print_containing_files): Simplify.\n+        (_cpp_begin_message): Simplify and use print_location.\n+        * cppfiles.c (stack_include_file): Update.\n+        (_cpp_pop_file_buffer): Update.\n+        * cpphash.h (struct cpp_buffer): New members\n+        include_stack_listed and type.   \n+        * cpplib.c (_cpp_handle_directive): Buffer->inc is not null.\n+        (run_directive): Take buffer type.  cpp_push_buffer cannot fail.\n+        (_cpp_do__Pragma, cpp_define, _cpp_define_builtin, cpp_undef,\n+        handle_assertion): Update.\n+        (cpp_push_buffer): Take a buffer type and file name.\n+        (cpp_pop_buffer): Update.  Clear include_stack_listed.\n+        * cpplib.h (input_stack_listing_current): Remove.\n+        (enum cpp_buffer_type): New.\n+        (cpp_push_buffer): New prototype.\n+        * cppmacro.c (builtin_macro): Simplify; buffer cannot be null.\n+        * fix-header.c (read_scan_file): Update.\n+\n 2000-12-10  Robert Lipe <robertlipe@usa.net>\n \n \t* install.texi (i*86-*-sco3.2v5*): Remove information duplicated"}, {"sha": "87ef2cbc45d20c7e219a5e7f1a8492d1261e81f9", "filename": "gcc/cpperror.c", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -29,30 +29,23 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-static void print_containing_files\tPARAMS ((cpp_reader *, cpp_buffer *));\n-static void print_file_and_line\t\tPARAMS ((const char *, unsigned int,\n-\t\t\t\t\t\t unsigned int));\n-\n+static void print_containing_files\tPARAMS ((cpp_buffer *));\n+static void print_location\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const char *,\n+\t\t\t\t\t\t const cpp_lexer_pos *));\n #define v_message(msgid, ap) \\\n do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n \n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n-\n static void\n-print_containing_files (pfile, ip)\n-     cpp_reader *pfile;\n+print_containing_files (ip)\n      cpp_buffer *ip;\n {\n   int first = 1;\n \n-  /* If stack of files hasn't changed since we last printed\n-     this info, don't repeat it.  */\n-  if (pfile->input_stack_listing_current)\n-    return;\n-\n   /* Find the other, outer source files.  */\n-  for (ip = CPP_PREV_BUFFER (ip); ip != NULL; ip = CPP_PREV_BUFFER (ip))\n+  for (ip = ip->prev; ip; ip = ip->prev)\n     {\n       if (first)\n \t{\n@@ -78,27 +71,69 @@ print_containing_files (pfile, ip)\n \tfprintf (stderr, _(\",\\n                 from %s:%u\"),\n \t\t ip->nominal_fname, CPP_BUF_LINE (ip) - 1);\n     }\n-  if (first == 0)\n-    fputs (\":\\n\", stderr);\n-\n-  /* Record we have printed the status as of this time.  */\n-  pfile->input_stack_listing_current = 1;\n+  fputs (\":\\n\", stderr);\n }\n \n static void\n-print_file_and_line (filename, line, col)\n+print_location (pfile, filename, pos)\n+     cpp_reader *pfile;\n      const char *filename;\n-     unsigned int line, col;\n+     const cpp_lexer_pos *pos;\n {\n-  if (filename == 0 || *filename == '\\0')\n-    filename = \"<stdin>\";\n+  cpp_buffer *buffer = pfile->buffer;\n \n-  if (line == 0)\n-    fprintf (stderr, \"%s: \", filename);\n-  else if (col == 0)\n-    fprintf (stderr, \"%s:%u: \", filename, line);\n+  if (!buffer)\n+    fprintf (stderr, \"%s: \", progname);\n   else\n-    fprintf (stderr, \"%s:%u:%u: \", filename, line, col);\n+    {\n+      unsigned int line, col;\n+      enum cpp_buffer_type type = buffer->type;\n+\n+      /* For _Pragma buffers, we want to print the location as\n+\t \"foo.c:5:8: _Pragma:\", where foo.c is the containing buffer.\n+\t For diagnostics relating to command line options, we want to\n+\t print \"<command line>:\" with no line number.  */\n+      if (type == BUF_CL_OPTION || type == BUF_BUILTIN)\n+\tline = 0;\n+      else\n+\t{\n+\t  if (type == BUF_PRAGMA)\n+\t    {\n+\t      buffer = buffer->prev;\n+\t      line = CPP_BUF_LINE (buffer);\n+\t      col = CPP_BUF_COL (buffer);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (pos == 0)\n+\t\tpos = cpp_get_line (pfile);\n+\t      line = pos->line;\n+\t      col = pos->col;\n+\t    }\n+\n+\t  /* Don't repeat the include stack unnecessarily.  */\n+\t  if (buffer->prev && ! buffer->include_stack_listed)\n+\t    {\n+\t      buffer->include_stack_listed = 1;\n+\t      print_containing_files (buffer);\n+\t    }\n+\t}\n+\n+      if (filename == 0)\n+\tfilename = buffer->nominal_fname;\n+      if (*filename == '\\0')\n+\tfilename = _(\"<stdin>\");\n+\n+      if (line == 0)\n+\tfprintf (stderr, \"%s: \", filename);\n+      else if (CPP_OPTION (pfile, show_column) == 0)\n+\tfprintf (stderr, \"%s:%u: \", filename, line);\n+      else\n+\tfprintf (stderr, \"%s:%u:%u: \", filename, line, col);\n+\n+      if (type == BUF_PRAGMA)\n+\tfprintf (stderr, \"_Pragma: \");\n+    }\n }\n \n /* Set up for an error message: print the file and line, bump the error\n@@ -112,7 +147,6 @@ _cpp_begin_message (pfile, code, file, pos)\n      const char *file;\n      const cpp_lexer_pos *pos;\n {\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n   int is_warning = 0;\n \n   switch (code)\n@@ -171,19 +205,7 @@ _cpp_begin_message (pfile, code, file, pos)\n       break;\n     }\n \n-  if (ip)\n-    {\n-      if (file == NULL)\n-\tfile = ip->nominal_fname;\n-      if (pos == 0)\n-\tpos = cpp_get_line (pfile);\n-      print_containing_files (pfile, ip);\n-      print_file_and_line (file, pos->line,\n-\t\t\t   CPP_OPTION (pfile, show_column) ? pos->col : 0);\n-    }\n-  else\n-    fprintf (stderr, \"%s: \", progname);\n-\n+  print_location (pfile, file, pos);\n   if (is_warning)\n     fputs (_(\"warning: \"), stderr);\n "}, {"sha": "fccfab1f2f154746892551947042eced64793991", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -264,9 +264,8 @@ stack_include_file (pfile, inc)\n     read_include_file (pfile, inc);\n \n   /* Push a null buffer.  */\n-  fp = cpp_push_buffer (pfile, NULL, 0);\n+  fp = cpp_push_buffer (pfile, NULL, 0, BUF_FILE, inc->name);\n   fp->inc = inc;\n-  fp->nominal_fname = inc->name;\n   fp->buf = inc->buffer;\n   fp->rlimit = fp->buf;\n   if (! DO_NOT_REREAD (inc))\n@@ -287,7 +286,6 @@ stack_include_file (pfile, inc)\n   pfile->mi_state = MI_OUTSIDE;\n   pfile->mi_cmacro = 0;\n   pfile->include_depth++;\n-  pfile->input_stack_listing_current = 0;\n \n   _cpp_do_file_change (pfile, FC_ENTER, filename, lineno);\n \n@@ -775,7 +773,6 @@ _cpp_pop_file_buffer (pfile, buf)\n     pfile->system_include_depth--;\n   if (pfile->include_depth)\n     pfile->include_depth--;\n-  pfile->input_stack_listing_current = 0;\n \n   /* Record the inclusion-preventing macro and its definedness.  */\n   if (pfile->mi_state == MI_OUTSIDE && inc->cmacro != NEVER_REREAD)"}, {"sha": "6cd162181a0d47243f60296a364ce63822868202", "filename": "gcc/cpphash.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -122,6 +122,13 @@ struct cpp_buffer\n \n   /* 1 = system header file, 2 = C system header file used for C++.  */\n   unsigned char sysp;\n+\n+  /* Nonzero means we have printed (while error reporting) a list of\n+     containing files that matches the current status.  */\n+  unsigned char include_stack_listed;\n+\n+  /* Buffer type.  */\n+  ENUM_BITFIELD (cpp_buffer_type) type : 8;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h."}, {"sha": "74662fe635b8765254d6dc2044ae288244fea084", "filename": "gcc/cpplib.c", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -84,8 +84,8 @@ static void check_eol\t\tPARAMS ((cpp_reader *));\n static void start_directive\tPARAMS ((cpp_reader *));\n static void end_directive\tPARAMS ((cpp_reader *, int));\n static void run_directive\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t const char *, size_t,\n-\t\t\t\t\t const char *));\n+\t\t\t\t\t enum cpp_buffer_type,\n+\t\t\t\t\t const char *, size_t));\n static int glue_header_name\tPARAMS ((cpp_reader *, cpp_token *));\n static int  parse_include\tPARAMS ((cpp_reader *, cpp_token *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n@@ -299,8 +299,7 @@ _cpp_handle_directive (pfile, indented)\n \t  dir = &dtable[T_LINE];\n \t  pfile->state.line_extension = 1;\n \t  _cpp_push_token (pfile, &dname, &pfile->directive_pos);\n-\t  if (CPP_PEDANTIC (pfile) && buffer->inc\n-\t      && ! CPP_OPTION (pfile, preprocessed))\n+\t  if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, preprocessed))\n \t    cpp_pedwarn (pfile, \"# followed by integer\");\n \t}\n     }\n@@ -374,47 +373,34 @@ _cpp_handle_directive (pfile, indented)\n /* Directive handler wrapper used by the command line option\n    processor.  */\n static void\n-run_directive (pfile, dir_no, buf, count, name)\n+run_directive (pfile, dir_no, type, buf, count)\n      cpp_reader *pfile;\n      int dir_no;\n+     enum cpp_buffer_type type;\n      const char *buf;\n      size_t count;\n-     const char *name;\n {\n   unsigned int output_line = pfile->lexer_pos.output_line;\n-  cpp_buffer *buffer = cpp_push_buffer (pfile, (const U_CHAR *) buf, count);\n-\n-  if (buffer)\n-    {\n-      const struct directive *dir = &dtable[dir_no];\n+  cpp_buffer *buffer;\n \n-      if (name)\n-\tbuffer->nominal_fname = name;\n-      else\n-\tbuffer->nominal_fname = _(\"<command line>\");\n+  buffer = cpp_push_buffer (pfile, (const U_CHAR *) buf, count, type, 0);\n \n-      /* For _Pragma, the text is passed through preprocessing stage 3\n-\t only, i.e. no trigraphs, no escaped newline removal, and no\n-\t macro expansion.  Do the same for command-line directives.  */\n-      buffer->from_stage3 = 1;\n-\n-      if (dir_no == T_PRAGMA)\n-\t{\n-\t  /* A kludge to avoid line markers for _Pragma.  */\n-\t  pfile->lexer_pos.output_line = output_line;\n-\t  /* Avoid interpretation of directives in a _Pragma string.  */\n-\t  pfile->state.next_bol = 0;\n-\t}\n+  if (dir_no == T_PRAGMA)\n+    {\n+      /* A kludge to avoid line markers for _Pragma.  */\n+      pfile->lexer_pos.output_line = output_line;\n+      /* Avoid interpretation of directives in a _Pragma string.  */\n+      pfile->state.next_bol = 0;\n+    }\n \n-      start_directive (pfile);\n-      pfile->state.prevent_expansion++;\n-      (void) (*dir->handler) (pfile);\n-      pfile->state.prevent_expansion--;\n-      check_eol (pfile);\n-      end_directive (pfile, 1);\n+  start_directive (pfile);\n+  pfile->state.prevent_expansion++;\n+  (void) (*dtable[dir_no].handler) (pfile);\n+  pfile->state.prevent_expansion--;\n+  check_eol (pfile);\n+  end_directive (pfile, 1);\n \n-      cpp_pop_buffer (pfile);\n-    }\n+  cpp_pop_buffer (pfile);\n }\n \n /* Checks for validity the macro name in #define, #undef, #ifdef and\n@@ -1165,7 +1151,7 @@ _cpp_do__Pragma (pfile)\n     }\n \n   buffer = destringize (&string.val.str, &len);\n-  run_directive (pfile, T_PRAGMA, (char *) buffer, len, _(\"<_Pragma>\"));\n+  run_directive (pfile, T_PRAGMA, BUF_PRAGMA, (char *) buffer, len);\n   free ((PTR) buffer);\n }\n \n@@ -1633,7 +1619,7 @@ cpp_define (pfile, str)\n       buf[count++] = '1';\n     }\n \n-  run_directive (pfile, T_DEFINE, buf, count, 0);\n+  run_directive (pfile, T_DEFINE, BUF_CL_OPTION, buf, count);\n }\n \n /* Slight variant of the above for use by initialize_builtins, which (a)\n@@ -1644,7 +1630,7 @@ _cpp_define_builtin (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  run_directive (pfile, T_DEFINE, str, strlen (str), _(\"<builtin>\"));\n+  run_directive (pfile, T_DEFINE, BUF_BUILTIN, str, strlen (str));\n }\n \n /* Process MACRO as if it appeared as the body of an #undef.  */\n@@ -1653,7 +1639,7 @@ cpp_undef (pfile, macro)\n      cpp_reader *pfile;\n      const char *macro;\n {\n-  run_directive (pfile, T_UNDEF, macro, strlen (macro), 0);\n+  run_directive (pfile, T_UNDEF, BUF_CL_OPTION, macro, strlen (macro));\n }\n \n /* Process the string STR as if it appeared as the body of a #assert. */\n@@ -1696,37 +1682,51 @@ handle_assertion (pfile, str, type)\n       str = buf;\n     }\n \n-  run_directive (pfile, type, str, count, 0);\n+  run_directive (pfile, type, BUF_CL_OPTION, str, count);\n }\n \n /* Push a new buffer on the buffer stack.  Buffer can be NULL, but\n    then LEN should be 0.  Returns the new buffer; it doesn't fail.  */\n \n cpp_buffer *\n-cpp_push_buffer (pfile, buffer, len)\n+cpp_push_buffer (pfile, buffer, len, type, filename)\n      cpp_reader *pfile;\n      const U_CHAR *buffer;\n      size_t len;\n+     enum cpp_buffer_type type;\n+     const char *filename;\n {\n   cpp_buffer *new = xobnew (pfile->buffer_ob, cpp_buffer);\n \n   /* Clears, amongst other things, if_stack and mi_cmacro.  */\n   memset (new, 0, sizeof (cpp_buffer));\n+\n+  switch (type)\n+    {\n+    case BUF_FILE:\tnew->nominal_fname = filename; break;\n+    case BUF_BUILTIN:\tnew->nominal_fname = _(\"<builtin>\"); break;\n+    case BUF_CL_OPTION:\tnew->nominal_fname = _(\"<command line>\"); break;\n+    case BUF_PRAGMA:\tnew->nominal_fname = _(\"<_Pragma>\"); break;\n+    }\n+  new->type = type;\n   new->line_base = new->buf = new->cur = buffer;\n   new->rlimit = buffer + len;\n   new->prev = pfile->buffer;\n   new->pfile = pfile;\n-  /* Preprocessed files don't do trigraph and escaped newline processing.  */\n-  new->from_stage3 = CPP_OPTION (pfile, preprocessed);\n+\n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n   new->extra_char = EOF;\n \n+  /* Preprocessed files, builtins, _Pragma and command line options\n+     don't do trigraph and escaped newline processing.  */\n+  new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n+\n   pfile->state.next_bol = 1;\n   pfile->buffer_stack_depth++;\n   pfile->lexer_pos.output_line = 1;\n-\n   pfile->buffer = new;\n+\n   return new;\n }\n \n@@ -1738,23 +1738,26 @@ cpp_pop_buffer (pfile)\n   const char *filename = buffer->nominal_fname;\n   unsigned int lineno = buffer->lineno;\n   struct if_stack *ifs = buffer->if_stack;\n-  int wfb = (buffer->inc != 0);\n+  int file_buffer_p = buffer->type == BUF_FILE;\n \n   /* Walk back up the conditional stack till we reach its level at\n      entry to this file, issuing error messages.  */\n   for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n     cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n-  if (wfb)\n+  if (file_buffer_p)\n     _cpp_pop_file_buffer (pfile, buffer);\n \n   pfile->buffer = buffer->prev;\n   obstack_free (pfile->buffer_ob, buffer);\n   pfile->buffer_stack_depth--;\n \n-  if (pfile->buffer && wfb)\n-    _cpp_do_file_change (pfile, FC_LEAVE, filename, lineno);\n+  if (pfile->buffer && file_buffer_p)\n+    {\n+      _cpp_do_file_change (pfile, FC_LEAVE, filename, lineno);\n+      pfile->buffer->include_stack_listed = 0;\n+    }\n   \n   return pfile->buffer;\n }"}, {"sha": "18c3baa9288ab06425154f9ce45237221d6fbf14", "filename": "gcc/cpplib.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -606,10 +606,6 @@ struct cpp_reader\n      preprocessor.  */\n   struct spec_nodes spec_nodes;\n \n-  /* Nonzero means we have printed (while error reporting) a list of\n-     containing files that matches the current status.  */\n-  unsigned char input_stack_listing_current;\n-\n   /* We're printed a warning recommending against using #import.  */\n   unsigned char import_warning;\n \n@@ -634,6 +630,10 @@ struct cpp_reader\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n+/* Where does this buffer come from?  A file, a builtin macro, a\n+   command-line option, or a _Pragma operator.  */\n+enum cpp_buffer_type {BUF_FILE, BUF_BUILTIN, BUF_CL_OPTION, BUF_PRAGMA};\n+\n /* The structure of a node in the hash table.  The hash table has\n    entries for all identifiers: either macros defined by #define\n    commands (type NT_MACRO), assertions created with #assert\n@@ -729,7 +729,9 @@ extern void cpp_undef  PARAMS ((cpp_reader *, const char *));\n extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n \n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n-\t\t\t\t\t    const unsigned char *, size_t));\n+\t\t\t\t\t    const unsigned char *, size_t,\n+\t\t\t\t\t    enum cpp_buffer_type,\n+\t\t\t\t\t    const char *));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n "}, {"sha": "22900932e0ed6e3d6d36d7933f181c417f14e02e", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -148,28 +148,22 @@ builtin_macro (pfile, token)\n {\n   unsigned char flags = token->flags & PREV_WHITE;\n   cpp_hashnode *node = token->val.node;\n-  cpp_buffer *ip;\n \n   switch (node->value.builtin)\n     {\n     case BT_FILE:\n     case BT_BASE_FILE:\n       {\n-\tconst char *file;\n+\tconst char *name;\n+\tcpp_buffer *buffer = pfile->buffer;\n \n-\tip = CPP_BUFFER (pfile);\n-\tif (ip == 0)\n-\t  file = \"\";\n-\telse\n-\t  {\n-\t    if (node->value.builtin == BT_BASE_FILE)\n-\t      while (CPP_PREV_BUFFER (ip) != NULL)\n-\t\tip = CPP_PREV_BUFFER (ip);\n+\tif (node->value.builtin == BT_BASE_FILE)\n+\t  while (buffer->prev)\n+\t    buffer = buffer->prev;\n \n-\t    file = ip->nominal_fname;\n-\t  }\n+\tname = buffer->nominal_fname;\n \tmake_string_token (pfile->string_pool, token,\n-\t\t\t   (const U_CHAR *) file, strlen (file));\n+\t\t\t   (const unsigned char *) name, strlen (name));\n       }\n       break;\n \t"}, {"sha": "a02a2ce5d5a48dbf797c48b7761bcaa77c288fe2", "filename": "gcc/fix-header.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bda476066124a32156a37252d1d0c127c5a15be/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=0bda476066124a32156a37252d1d0c127c5a15be", "patch": "@@ -651,7 +651,8 @@ read_scan_file (in_fname, argc, argv)\n       int seen_filbuf = 0;\n \n       /* Scan the macro expansion of \"getchar();\".  */\n-      cpp_push_buffer (scan_in, getchar_call, sizeof(getchar_call) - 1);\n+      cpp_push_buffer (scan_in, getchar_call, sizeof(getchar_call) - 1,\n+\t\t       BUF_FILE, in_fname);\n       for (;;)\n \t{\n \t  cpp_token t;"}]}