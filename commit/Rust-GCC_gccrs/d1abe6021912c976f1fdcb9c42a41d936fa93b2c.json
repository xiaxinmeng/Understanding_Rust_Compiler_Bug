{"sha": "d1abe6021912c976f1fdcb9c42a41d936fa93b2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFhYmU2MDIxOTEyYzk3NmYxZmRjYjljNDJhNDFkOTM2ZmE5M2IyYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-23T11:56:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-23T11:56:13Z"}, "message": "(output_prologue): Delete unused var, INSN.\n\n(output_encoded_offset): New function.\n(output_epilogue): Minor changes to traceback table; call\nnew output_encoded_offset.\n(romp_debugger_{auto,arg}_correction): New functions.\n\nFrom-SVN: r4717", "tree": {"sha": "42507167a9ace760a8c24b82129c5b426cef3076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42507167a9ace760a8c24b82129c5b426cef3076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1abe6021912c976f1fdcb9c42a41d936fa93b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1abe6021912c976f1fdcb9c42a41d936fa93b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1abe6021912c976f1fdcb9c42a41d936fa93b2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1abe6021912c976f1fdcb9c42a41d936fa93b2c/comments", "author": null, "committer": null, "parents": [{"sha": "963d6142cc5339d919bccf902a53a507ba7cc3d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963d6142cc5339d919bccf902a53a507ba7cc3d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/963d6142cc5339d919bccf902a53a507ba7cc3d6"}], "stats": {"total": 139, "additions": 134, "deletions": 5}, "files": [{"sha": "65293cd66c599222554b01e9e3ace6af7c16f294", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 134, "deletions": 5, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1abe6021912c976f1fdcb9c42a41d936fa93b2c/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1abe6021912c976f1fdcb9c42a41d936fa93b2c/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=d1abe6021912c976f1fdcb9c42a41d936fa93b2c", "patch": "@@ -1076,7 +1076,6 @@ output_prolog (file, size)\n {\n   int first_reg;\n   int reg_save_offset;\n-  rtx insn;\n   int fp_save = size + current_function_outgoing_args_size;\n \n   init_fpops ();\n@@ -1123,7 +1122,61 @@ output_prolog (file, size)\n   output_loadsave_fpregs (file, USE,\n \t\t\t  plus_constant (stack_pointer_rtx, fp_save));\n }\n+\f\n+/* Output the offset information used by debuggers.\n+   This is the exactly the total_size value of output_epilog\n+   which is added to the frame pointer. However the value in the debug\n+   table is encoded in a space-saving way as follows:\n+\n+   The first byte contains two fields: a 2-bit size field and the first\n+   6 bits of an offset value. The 2-bit size field is in the high-order\n+   position and specifies how many subsequent bytes follow after\n+   this one. An offset value is at most 4-bytes long.\n+\n+   The last 6 bits of the first byte initialize the offset value. In many\n+   cases where procedures have small local storage, this is enough and, in\n+   this case, the high-order size field is zero so the byte can (almost) be\n+   used as is (see below). Thus, the byte value of 0x0d is encodes a offset\n+   size of 13 words, or 52 bytes.\n+\n+   For procedures with a local space larger than 60 bytes, the 6 bits\n+   are the high-order 6 bits.  The remaining bytes follow as necessary,\n+   in Big Endian order.  Thus, the short value of 16907 (= 16384+523)\n+   encodes an offset of 2092 bytes (523 words).\n+\n+   The total offset value is in words (not bytes), so the final value has to\n+   be multiplied by 4 before it can be used in address computations by a\n+   debugger.   */\n \n+void\n+output_encoded_offset (file, reg_offset)\n+     FILE *file;\n+     unsigned reg_offset;\n+{\n+  /* Convert the offset value to 4-byte words rather than bytes. */\n+  reg_offset = (reg_offset + 3) / 4;\n+\n+  /* Now output 1-4 bytes in encoded form. */\n+  if (reg_offset < (1 << 6))\n+    /* Fits into one byte */\n+    fprintf (file, \"\\t.byte %d\\n\", reg_offset);\n+  else if (reg_offset < (1 << (6 + 8)))\n+    /* Fits into two bytes */\n+    fprintf (file, \"\\t.short %d\\n\", (1 << (6 + 8)) + reg_offset);\n+  else if (reg_offset < (1 << (6 + 8 + 8)))\n+    {\n+      /* Fits in three bytes */\n+      fprintf (file, \"\\t.byte %d\\n\", (2 << 6) + (reg_offset >> ( 6+ 8)));\n+      fprintf (file, \"\\t.short %d\\n\", reg_offset % (1 << (6 + 8)));\n+    }\n+  else\n+    {\n+      /* Use 4 bytes.  */\n+      fprintf (file, \"\\t.short %d\", (3 << (6 + 8)) + (reg_offset >> (6 + 8)));\n+      fprintf (file, \"\\t.short %d\\n\", reg_offset % (1 << (6 + 8)));\n+    }\n+}\n+\f\n /* Write function epilogue.  */\n \n void\n@@ -1195,18 +1248,51 @@ output_epilog (file, size)\n \t  else\n \t    fprintf (file, \"\\tbrx r15\\n\\tcal r1,%d(r1)\\n\", total_size);\n \t}\n+\n+      /* Table header (0xdf), usual-type stack frame (0x07),\n+\t table header (0xdf), and first register saved.\n+\n+\t The final 0x08 means that there is a byte following this one\n+\t describing the number of parameter words and the register used as\n+\t stack pointer.\n+\n+\t If GCC passed floating-point parameters in floating-point registers,\n+\t it would be necessary to change the final byte from 0x08 to 0x0c.\n+\t Also an additional entry byte would be need to be emitted to specify\n+\t the first floating-point register.\n+\n+\t (See also Section 11 (Trace Tables) in ``IBM/4.3 Linkage Convention,''\n+\t pages IBM/4.3-PSD:5-7 of Volume III of the IBM Academic Operating\n+\t System Manual dated July 1987.)  */\n+\n       fprintf (file, \"\\t.long 0x%x\\n\", 0xdf07df08 + first_reg * 0x10);\n \n       if (nargs > 15) nargs = 15;\n-      if (frame_pointer_needed)\n-\tfprintf (file, \"\\t.byte 0x%xd, 53\\n\", nargs);\n-      else\n-\tfprintf (file, \"\\t.short 0x%x100\\n\", nargs);\n+\n+      /* The number of parameter words and the register used as the stack\n+\t pointer (encoded here as r1).\n+\n+\t Note: The MetWare Hich C Compiler R2.1y actually gets this wrong;\n+\t it erroneously lists r13 but uses r1 as the stack too. But a bug in\n+\t dbx 1.5 nullifies this mistake---most of the time.\n+         (Dbx retrieves the value of r13 saved on the stack which is often\n+\t the value of r1 before the call.)  */\n+\n+      fprintf (file, \"\\t.byte 0x%x1\\n\", nargs);\n+      output_encoded_offset (file, total_size);\n     }\n   else\n     {\n       if (write_code)\n \tfprintf (file, \"\\tbr r15\\n\");\n+\n+      /* Table header (0xdf), no stack frame (0x02),\n+\t table header (0xdf) and no parameters saved (0x00).\n+\n+\t If GCC passed floating-point parameters in floating-point registers,\n+\t it might be necessary to change the final byte from 0x00 to 0x04.\n+\t Also a byte would be needed to specify the first floating-point\n+\t register.  */\n       fprintf (file, \"\\t.long 0xdf02df00\\n\");\n     }\n \n@@ -1905,3 +1991,46 @@ init_fpops()\n   for (i = 0; i < FP_HASH_SIZE; i++)\n     fp_hash_table[i] = 0;\n }\n+\f\n+/* Return the offset value of an automatic variable (N_LSYM) having\n+   the given offset. Basically, we correct by going from a frame pointer to\n+   stack pointer value.\n+*/\n+\n+int\n+romp_debugger_auto_correction(offset)\n+     int offset;\n+{\n+  int fp_to_sp;\n+\n+  /* We really want to go from STACK_POINTER_REGNUM to\n+     FRAME_POINTER_REGNUM, but this isn't defined. So go the other\n+     direction and negate. */\n+  INITIAL_ELIMINATION_OFFSET (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM,\n+\t\t\t      fp_to_sp);\n+\n+  /* The offset value points somewhere between the frame pointer and\n+     the stack pointer. What is up from the frame pointer is down from the\n+     stack pointer. Therefore the negation in the offset value too. */\n+\n+  return -(offset+fp_to_sp+4);\n+}\n+\n+/* Return the offset value of an argument having\n+   the given offset. Basically, we correct by going from a arg pointer to\n+   stack pointer value. */\n+\n+int\n+romp_debugger_arg_correction (offset)\n+     int offset;\n+{\n+  int fp_to_argp;\n+\n+  INITIAL_ELIMINATION_OFFSET (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM,\n+\t\t\t      fp_to_argp);\n+\n+  /* Actually, something different happens if offset is from a floating-point\n+     register argument, but we don't handle it here.  */\n+\n+  return (offset - fp_to_argp);\n+}"}]}