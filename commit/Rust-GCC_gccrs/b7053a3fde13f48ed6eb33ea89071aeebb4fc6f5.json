{"sha": "b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcwNTNhM2ZkZTEzZjQ4ZWQ2ZWIzM2VhODkwNzFhZWViYjRmYzZmNQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-05-03T23:13:57Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-05-03T23:13:57Z"}, "message": "rs6000.c (scc_comparison_operator): Make equivalent to branch_positive_comparison_operator.\n\n\t* config/rs6000/rs6000.c (scc_comparison_operator): Make equivalent\n\tto branch_positive_comparison_operator.\n\t(ccr_bit): Check that sCOND conditions are actually a positive bit.\n\t(print_operand): Remove %D substitution.\n\t(rs6000_emit_sCOND): Generate complement operation to ensure that\n\tsCOND input is a positive bit.\n\t* config/rs6000/rs6000.md: Rearrange sCOND templates to be in the\n\tsame order as bCOND, and add the missing ones.  Remove the %D\n\tsubstitutions from the scc patterns.\n\nFrom-SVN: r66441", "tree": {"sha": "f054e814f62413cf6e3443cf5292aa88ea2fee42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f054e814f62413cf6e3443cf5292aa88ea2fee42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d90f9c0298713f74874d30bdf155597c33629ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d90f9c0298713f74874d30bdf155597c33629ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d90f9c0298713f74874d30bdf155597c33629ae"}], "stats": {"total": 190, "additions": 106, "deletions": 84}, "files": [{"sha": "18b1d9eb7badcc538617003a1ba3d40d9d091618", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "patch": "@@ -1,5 +1,15 @@\n 2003-05-03  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* config/rs6000/rs6000.c (scc_comparison_operator): Make equivalent\n+\tto branch_positive_comparison_operator.\n+\t(ccr_bit): Check that sCOND conditions are actually a positive bit.\n+\t(print_operand): Remove %D substitution.\n+\t(rs6000_emit_sCOND): Generate complement operation to ensure that\n+\tsCOND input is a positive bit.\n+\t* config/rs6000/rs6000.md: Rearrange sCOND templates to be in the\n+\tsame order as bCOND, and add the missing ones.  Remove the %D\n+\tsubstitutions from the scc patterns.\n+\n \t* simplify-rtx.c (simplify_relational_operation): Add case for\n \t! (fabs(x) < 0.0).\n "}, {"sha": "9ecb6c0e09969e7334bc58b97bea07400b81213d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 58, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "patch": "@@ -7049,34 +7049,15 @@ branch_positive_comparison_operator (op, mode)\n \t  || code == UNORDERED);\n }\n \n-/* Return 1 if OP is a comparison operation that is valid for an scc insn.\n-   We check the opcode against the mode of the CC value and disallow EQ or\n-   NE comparisons for integers.  */\n+/* Return 1 if OP is a comparison operation that is valid for an scc\n+   insn: it must be a positive comparison.  */\n \n int\n scc_comparison_operator (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  enum rtx_code code = GET_CODE (op);\n-  enum machine_mode cc_mode;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_RTX_CLASS (code) != '<')\n-    return 0;\n-\n-  cc_mode = GET_MODE (XEXP (op, 0));\n-  if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n-    return 0;\n-\n-  validate_condition_mode (code, cc_mode);\n-\n-  if (code == NE && cc_mode != CCFPmode)\n-    return 0;\n-\n-  return 1;\n+  return branch_positive_comparison_operator (op, mode);\n }\n \n int\n@@ -7501,6 +7482,12 @@ ccr_bit (op, scc_p)\n \n   validate_condition_mode (code, cc_mode);\n \n+  /* When generating a sCOND operation, only positive conditions are\n+     allowed.  */\n+  if (scc_p && code != EQ && code != GT && code != LT && code != UNORDERED\n+      && code != GTU && code != LTU)\n+    abort ();\n+  \n   switch (code)\n     {\n     case NE:\n@@ -7697,42 +7684,6 @@ print_operand (file, x, code)\n       /* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise\n \t output_operand.  */\n \n-    case 'D':\n-      /* There used to be a comment for 'C' reading \"This is an\n-\t   optional cror needed for certain floating-point\n-\t   comparisons.  Otherwise write nothing.\"  */\n-\n-      /* Similar, except that this is for an scc, so we must be able to\n-\t encode the test in a single bit that is one.  We do the above\n-\t for any LE, GE, GEU, or LEU and invert the bit for NE.  */\n-      if (GET_CODE (x) == LE || GET_CODE (x) == GE\n-\t  || GET_CODE (x) == LEU || GET_CODE (x) == GEU)\n-\t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - CR0_REGNO);\n-\n-\t  fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t   base_bit + 2,\n-\t\t   base_bit + (GET_CODE (x) == GE || GET_CODE (x) == GEU));\n-\t}\n-\n-      else if (GET_CODE (x) == NE)\n-\t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - CR0_REGNO);\n-\n-\t  fprintf (file, \"crnor %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t   base_bit + 2, base_bit + 2);\n-\t}\n-      else if (TARGET_E500 && !TARGET_FPRS && TARGET_HARD_FLOAT\n-\t       && GET_CODE (x) == EQ\n-\t       && GET_MODE (XEXP (x, 0)) == CCFPmode)\n-\t{\n-\t  int base_bit = 4 * (REGNO (XEXP (x, 0)) - CR0_REGNO);\n-\n-\t  fprintf (file, \"crnor %d,%d,%d\\n\\t\", base_bit + 1,\n-\t\t   base_bit + 1, base_bit + 1);\n-\t}\n-      return;\n-\n     case 'E':\n       /* X is a CR register.  Print the number of the EQ bit of the CR */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n@@ -8686,8 +8637,28 @@ rs6000_emit_sCOND (code, result)\n {\n   rtx condition_rtx;\n   enum machine_mode op_mode;\n+  enum rtx_code cond_code;\n \n   condition_rtx = rs6000_generate_compare (code);\n+  cond_code = GET_CODE (condition_rtx);\n+\n+  if (cond_code == NE\n+      || cond_code == GE || cond_code == LE\n+      || cond_code == GEU || cond_code == LEU\n+      || cond_code == ORDERED || cond_code == UNGE || cond_code == UNLE)\n+    {\n+      rtx not_result = gen_reg_rtx (CCEQmode);\n+      rtx not_op, rev_cond_rtx;\n+      enum machine_mode cc_mode;\n+      \n+      cc_mode = GET_MODE (XEXP (condition_rtx, 0));\n+\n+      rev_cond_rtx = gen_rtx (rs6000_reverse_condition (cc_mode, cond_code),\n+\t\t\t      SImode, XEXP (condition_rtx, 0), const0_rtx);\n+      not_op = gen_rtx_COMPARE (CCEQmode, rev_cond_rtx, const0_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, not_result, not_op));\n+      condition_rtx = gen_rtx_EQ (VOIDmode, not_result, const0_rtx);\n+    }\n \n   op_mode = GET_MODE (rs6000_compare_op0);\n   if (op_mode == VOIDmode)"}, {"sha": "37b88d3d256abf81d493c46096601b7f1b1e6fd1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b7053a3fde13f48ed6eb33ea89071aeebb4fc6f5", "patch": "@@ -10919,8 +10919,8 @@\n   DONE;\n }\")\n \n-;; A > 0 is best done using the portable sequence, so fail in that case.\n-(define_expand \"sgt\"\n+;; A >= 0 is best done the portable way for A an integer.\n+(define_expand \"sge\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n@@ -10929,26 +10929,26 @@\n       && (! TARGET_POWER || rs6000_compare_op1 == const0_rtx))\n     FAIL;\n \n-  rs6000_emit_sCOND (GT, operands[0]); \n+  rs6000_emit_sCOND (GE, operands[0]);\n   DONE;\n }\")\n \n-;; A < 0 is best done in the portable way for A an integer.\n-(define_expand \"slt\"\n+;; A > 0 is best done using the portable sequence, so fail in that case.\n+(define_expand \"sgt\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (! rs6000_compare_fp_p \n+  if (! rs6000_compare_fp_p\n       && (! TARGET_POWER || rs6000_compare_op1 == const0_rtx))\n     FAIL;\n \n-  rs6000_emit_sCOND (LT, operands[0]); \n+  rs6000_emit_sCOND (GT, operands[0]); \n   DONE;\n }\")\n \n-;; A >= 0 is best done the portable way for A an integer.\n-(define_expand \"sge\"\n+;; A <= 0 is best done the portable way for A an integer.\n+(define_expand \"sle\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n@@ -10957,43 +10957,84 @@\n       && (! TARGET_POWER || rs6000_compare_op1 == const0_rtx))\n     FAIL;\n \n-  rs6000_emit_sCOND (GE, operands[0]);\n+  rs6000_emit_sCOND (LE, operands[0]); \n   DONE;\n }\")\n \n-;; A <= 0 is best done the portable way for A an integer.\n-(define_expand \"sle\"\n+;; A < 0 is best done in the portable way for A an integer.\n+(define_expand \"slt\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (! rs6000_compare_fp_p\n+  if (! rs6000_compare_fp_p \n       && (! TARGET_POWER || rs6000_compare_op1 == const0_rtx))\n     FAIL;\n \n-  rs6000_emit_sCOND (LE, operands[0]); \n+  rs6000_emit_sCOND (LT, operands[0]); \n   DONE;\n }\")\n \n+(define_expand \"sgeu\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (GEU, operands[0]); DONE; }\")\n+\n (define_expand \"sgtu\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"{ rs6000_emit_sCOND (GTU, operands[0]); DONE; }\")\n \n+(define_expand \"sleu\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (LEU, operands[0]); DONE; }\")\n+\n (define_expand \"sltu\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"{ rs6000_emit_sCOND (LTU, operands[0]); DONE; }\")\n \n-(define_expand \"sgeu\"\n+(define_expand \"sunordered\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_sCOND (GEU, operands[0]); DONE; }\")\n+  \"{ rs6000_emit_sCOND (UNORDERED, operands[0]); DONE; }\")\n \n-(define_expand \"sleu\"\n+(define_expand \"sordered\"\n   [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_sCOND (LEU, operands[0]); DONE; }\")\n+  \"{ rs6000_emit_sCOND (ORDERED, operands[0]); DONE; }\")\n+\n+(define_expand \"suneq\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (UNEQ, operands[0]); DONE; }\")\n+\n+(define_expand \"sunge\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (UNGE, operands[0]); DONE; }\")\n+\n+(define_expand \"sungt\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (UNGT, operands[0]); DONE; }\")\n+\n+(define_expand \"sunle\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (UNLE, operands[0]); DONE; }\")\n+\n+(define_expand \"sunlt\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (UNLT, operands[0]); DONE; }\")\n+\n+(define_expand \"sltgt\"\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n+  \"\"\n+  \"{ rs6000_emit_sCOND (LTGT, operands[0]); DONE; }\")\n+\n \f\n ;; Here are the actual compare insns.\n (define_insn \"*cmpsi_internal1\"\n@@ -11141,7 +11182,7 @@\n \t\t\t   [(match_operand 2 \"cc_reg_operand\" \"y\")\n \t\t\t    (const_int 0)]))]\n   \"\"\n-  \"%D1mfcr %0\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n+  \"mfcr %0\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"12\")])\n \n@@ -11150,7 +11191,7 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:SI [(match_operand 1 \"cc_reg_operand\" \"y\")] UNSPEC_MV_CR_OV))]\n   \"TARGET_ISEL\"\n-  \"%D1mfcr %0\\;{rlinm|rlwinm} %0,%0,%t1,1\"\n+  \"mfcr %0\\;{rlinm|rlwinm} %0,%0,%t1,1\"\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"12\")])\n \n@@ -11160,7 +11201,7 @@\n \t\t\t   [(match_operand 2 \"cc_reg_operand\" \"y\")\n \t\t\t    (const_int 0)]))]\n   \"TARGET_POWERPC64\"\n-  \"%D1mfcr %0\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n+  \"mfcr %0\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"12\")])\n \n@@ -11174,7 +11215,7 @@\n \t(match_op_dup 1 [(match_dup 2) (const_int 0)]))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   %D1mfcr %3\\;{rlinm.|rlwinm.} %3,%3,%J1,1\n+   mfcr %3\\;{rlinm.|rlwinm.} %3,%3,%J1,1\n    #\"\n   [(set_attr \"type\" \"delayed_compare\")\n    (set_attr \"length\" \"12,16\")])\n@@ -11216,7 +11257,7 @@\n   operands[4] = GEN_INT (count);\n   operands[5] = GEN_INT (put_bit);\n \n-  return \\\"%D1mfcr %0\\;{rlinm|rlwinm} %0,%0,%4,%5,%5\\\";\n+  return \\\"mfcr %0\\;{rlinm|rlwinm} %0,%0,%4,%5,%5\\\";\n }\"\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"12\")])\n@@ -11251,7 +11292,7 @@\n   operands[5] = GEN_INT (count);\n   operands[6] = GEN_INT (put_bit);\n \n-  return \\\"%D1mfcr %4\\;{rlinm.|rlwinm.} %4,%4,%5,%6,%6\\\";\n+  return \\\"mfcr %4\\;{rlinm.|rlwinm.} %4,%4,%5,%6,%6\\\";\n }\"\n   [(set_attr \"type\" \"delayed_compare\")\n    (set_attr \"length\" \"12,16\")])\n@@ -11289,7 +11330,7 @@\n \t\t\t   [(match_operand 5 \"cc_reg_operand\" \"y\")\n \t\t\t    (const_int 0)]))]\n   \"REGNO (operands[2]) != REGNO (operands[5])\"\n-  \"%D1%D4mfcr %3\\;{rlinm|rlwinm} %0,%3,%J1,1\\;{rlinm|rlwinm} %3,%3,%J4,1\"\n+  \"mfcr %3\\;{rlinm|rlwinm} %0,%3,%J1,1\\;{rlinm|rlwinm} %3,%3,%J4,1\"\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"20\")])\n \n@@ -11303,7 +11344,7 @@\n \t\t\t   [(match_operand 5 \"cc_reg_operand\" \"y\")\n \t\t\t    (const_int 0)]))]\n   \"TARGET_POWERPC64 && REGNO (operands[2]) != REGNO (operands[5])\"\n-  \"%D1%D4mfcr %3\\;{rlinm|rlwinm} %0,%3,%J1,1\\;{rlinm|rlwinm} %3,%3,%J4,1\"\n+  \"mfcr %3\\;{rlinm|rlwinm} %0,%3,%J1,1\\;{rlinm|rlwinm} %3,%3,%J4,1\"\n   [(set_attr \"type\" \"mfcr\")\n    (set_attr \"length\" \"20\")])\n "}]}