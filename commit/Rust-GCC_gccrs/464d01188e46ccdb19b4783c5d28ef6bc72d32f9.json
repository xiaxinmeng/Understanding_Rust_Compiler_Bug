{"sha": "464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0ZDAxMTg4ZTQ2Y2NkYjE5YjQ3ODNjNWQyOGVmNmJjNzJkMzJmOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-05-23T14:39:11Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-05-23T14:39:11Z"}, "message": "Introduce symtab_node::dump_{asm_,}name functions.\n\n2017-05-23  Martin Liska  <mliska@suse.cz>\n\n\t* cgraph.c (cgraph_node::get_create): Use symtab_node::dump_{asm_,}name\n\tfunctions.\n\t(cgraph_edge::make_speculative): Likewise.\n\t(cgraph_edge::resolve_speculation): Likewise.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n\t(cgraph_node::dump): Likewise.\n\t* cgraph.h: Likewise.\n\t* cgraphunit.c (analyze_functions): Likewise.\n\t(symbol_table::compile): Likewise.\n\t* ipa-cp.c (print_all_lattices): Likewise.\n\t(determine_versionability): Likewise.\n\t(initialize_node_lattices): Likewise.\n\t(ipcp_verify_propagated_values): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(update_profiling_info): Likewise.\n\t(create_specialized_node): Likewise.\n\t(perhaps_add_new_callers): Likewise.\n\t(decide_about_value): Likewise.\n\t(decide_whether_version_node): Likewise.\n\t(identify_dead_nodes): Likewise.\n\t(ipcp_store_bits_results): Likewise.\n\t* ipa-devirt.c (dump_targets): Likewise.\n\t(ipa_devirt): Likewise.\n\t* ipa-icf.c (sem_item::dump): Likewise.\n\t(sem_function::equals): Likewise.\n\t(sem_variable::equals): Likewise.\n\t(sem_item_optimizer::read_section): Likewise.\n\t(sem_item_optimizer::execute): Likewise.\n\t(congruence_class::dump): Likewise.\n\t* ipa-inline-analysis.c (dump_ipa_call_summary): Likewise.\n\t(dump_inline_summary): Likewise.\n\t(estimate_node_size_and_time): Likewise.\n\t(inline_analyze_function): Likewise.\n\t* ipa-inline-transform.c (inline_call): Likewise.\n\t* ipa-inline.c (report_inline_failed_reason): Likewise.\n\t(want_early_inline_function_p): Likewise.\n\t(edge_badness): Likewise.\n\t(update_edge_key): Likewise.\n\t(inline_small_functions): Likewise.\n\t* ipa-profile.c (ipa_profile): Likewise.\n\t* ipa-prop.c (ipa_print_node_jump_functions): Likewise.\n\t(ipa_make_edge_direct_to_target): Likewise.\n\t(remove_described_reference): Likewise.\n\t(ipa_impossible_devirt_target): Likewise.\n\t(propagate_controlled_uses): Likewise.\n\t(ipa_print_node_params): Likewise.\n\t(ipcp_transform_function): Likewise.\n\t* ipa-pure-const.c (pure_const_read_summary): Likewise.\n\t(propagate_pure_const): Likewise.\n\t* ipa-reference.c (generate_summary): Likewise.\n\t(read_write_all_from_decl): Likewise.\n\t(propagate): Likewise.\n\t(ipa_reference_read_optimization_summary): Likewise.\n\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n\t* ipa.c (walk_polymorphic_call_targets): Likewise.\n\t(symbol_table::remove_unreachable_nodes): Likewise.\n\t(ipa_single_use): Likewise.\n\t* passes.c (execute_todo): Likewise.\n\t* predict.c (drop_profile): Likewise.\n\t* symtab.c (symtab_node::get_dump_name): New function.\n\t(symtab_node::dump_name): Likewise.\n\t(symtab_node::dump_asm_name): Likewise.\n\t(symtab_node::dump_references): Likewise.\n\t(symtab_node::dump_referring): Likewise.\n\t(symtab_node::dump_base): Likewise.\n\t(symtab_node::debug_symtab): Likewise.\n\t* tree-sra.c (convert_callers_for_node): Likewise.\n\t* tree-ssa-structalias.c (ipa_pta_execute): Likewise.\n\t* value-prof.c (init_node_map): Likewise.\n2017-05-23  Martin Liska  <mliska@suse.cz>\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Use\n\tsymtab_node::dump_{asm_,}name functions.\n\t* lto.c (read_cgraph_and_symbols): Likewise.\n\t(do_whole_program_analysis): Likewise.\n\nFrom-SVN: r248369", "tree": {"sha": "5307a5518829adcac991e9a7bab2b1ded50a7a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5307a5518829adcac991e9a7bab2b1ded50a7a3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c52831d98b00d02a3c11b46fbf80991ef0dc0fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c52831d98b00d02a3c11b46fbf80991ef0dc0fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c52831d98b00d02a3c11b46fbf80991ef0dc0fa"}], "stats": {"total": 585, "additions": 302, "deletions": 283}, "files": [{"sha": "d2e846e1a79795c8e0c733ed4fe819c63ea2fcc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -1,3 +1,75 @@\n+2017-05-23  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (cgraph_node::get_create): Use symtab_node::dump_{asm_,}name\n+\tfunctions.\n+\t(cgraph_edge::make_speculative): Likewise.\n+\t(cgraph_edge::resolve_speculation): Likewise.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n+\t(cgraph_node::dump): Likewise.\n+\t* cgraph.h: Likewise.\n+\t* cgraphunit.c (analyze_functions): Likewise.\n+\t(symbol_table::compile): Likewise.\n+\t* ipa-cp.c (print_all_lattices): Likewise.\n+\t(determine_versionability): Likewise.\n+\t(initialize_node_lattices): Likewise.\n+\t(ipcp_verify_propagated_values): Likewise.\n+\t(estimate_local_effects): Likewise.\n+\t(update_profiling_info): Likewise.\n+\t(create_specialized_node): Likewise.\n+\t(perhaps_add_new_callers): Likewise.\n+\t(decide_about_value): Likewise.\n+\t(decide_whether_version_node): Likewise.\n+\t(identify_dead_nodes): Likewise.\n+\t(ipcp_store_bits_results): Likewise.\n+\t* ipa-devirt.c (dump_targets): Likewise.\n+\t(ipa_devirt): Likewise.\n+\t* ipa-icf.c (sem_item::dump): Likewise.\n+\t(sem_function::equals): Likewise.\n+\t(sem_variable::equals): Likewise.\n+\t(sem_item_optimizer::read_section): Likewise.\n+\t(sem_item_optimizer::execute): Likewise.\n+\t(congruence_class::dump): Likewise.\n+\t* ipa-inline-analysis.c (dump_ipa_call_summary): Likewise.\n+\t(dump_inline_summary): Likewise.\n+\t(estimate_node_size_and_time): Likewise.\n+\t(inline_analyze_function): Likewise.\n+\t* ipa-inline-transform.c (inline_call): Likewise.\n+\t* ipa-inline.c (report_inline_failed_reason): Likewise.\n+\t(want_early_inline_function_p): Likewise.\n+\t(edge_badness): Likewise.\n+\t(update_edge_key): Likewise.\n+\t(inline_small_functions): Likewise.\n+\t* ipa-profile.c (ipa_profile): Likewise.\n+\t* ipa-prop.c (ipa_print_node_jump_functions): Likewise.\n+\t(ipa_make_edge_direct_to_target): Likewise.\n+\t(remove_described_reference): Likewise.\n+\t(ipa_impossible_devirt_target): Likewise.\n+\t(propagate_controlled_uses): Likewise.\n+\t(ipa_print_node_params): Likewise.\n+\t(ipcp_transform_function): Likewise.\n+\t* ipa-pure-const.c (pure_const_read_summary): Likewise.\n+\t(propagate_pure_const): Likewise.\n+\t* ipa-reference.c (generate_summary): Likewise.\n+\t(read_write_all_from_decl): Likewise.\n+\t(propagate): Likewise.\n+\t(ipa_reference_read_optimization_summary): Likewise.\n+\t* ipa-utils.c (ipa_merge_profiles): Likewise.\n+\t* ipa.c (walk_polymorphic_call_targets): Likewise.\n+\t(symbol_table::remove_unreachable_nodes): Likewise.\n+\t(ipa_single_use): Likewise.\n+\t* passes.c (execute_todo): Likewise.\n+\t* predict.c (drop_profile): Likewise.\n+\t* symtab.c (symtab_node::get_dump_name): New function.\n+\t(symtab_node::dump_name): Likewise.\n+\t(symtab_node::dump_asm_name): Likewise.\n+\t(symtab_node::dump_references): Likewise.\n+\t(symtab_node::dump_referring): Likewise.\n+\t(symtab_node::dump_base): Likewise.\n+\t(symtab_node::debug_symtab): Likewise.\n+\t* tree-sra.c (convert_callers_for_node): Likewise.\n+\t* tree-ssa-structalias.c (ipa_pta_execute): Likewise.\n+\t* value-prof.c (init_node_map): Likewise.\n+\n 2017-05-23  Martin Liska  <mliska@suse.cz>\n \n \t* cgraph.h: Move symtab_node::dump_table to symbol_table::dump"}, {"sha": "39320063c84aaa54b0012cd41c71d8f67a4966aa", "filename": "gcc/cgraph.c", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -539,12 +539,12 @@ cgraph_node::get_create (tree decl)\n       node->decl->decl_with_vis.symtab_node = node;\n       if (dump_file)\n \tfprintf (dump_file, \"Introduced new external node \"\n-\t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n-\t\t node->name (), node->order);\n+\t\t \"(%s) and turned into root of the clone tree.\\n\",\n+\t\t node->dump_name ());\n     }\n   else if (dump_file)\n     fprintf (dump_file, \"Introduced new external node \"\n-\t     \"(%s/%i).\\n\", node->name (), node->order);\n+\t     \"(%s).\\n\", node->dump_name ());\n   return node;\n }\n \n@@ -1055,12 +1055,8 @@ cgraph_edge::make_speculative (cgraph_node *n2, gcov_type direct_count,\n   cgraph_edge *e2;\n \n   if (dump_file)\n-    {\n-      fprintf (dump_file, \"Indirect call -> speculative call\"\n-\t       \" %s/%i => %s/%i\\n\",\n-\t       xstrdup_for_dump (n->name ()), n->order,\n-\t       xstrdup_for_dump (n2->name ()), n2->order);\n-    }\n+    fprintf (dump_file, \"Indirect call -> speculative call %s => %s\\n\",\n+\t     n->dump_name (), n2->dump_name ());\n   speculative = true;\n   e2 = n->create_edge (n2, call_stmt, direct_count, direct_frequency);\n   initialize_inline_failed (e2);\n@@ -1163,22 +1159,18 @@ cgraph_edge::resolve_speculation (tree callee_decl)\n \t{\n \t  if (callee_decl)\n \t    {\n-\t      fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n+\t      fprintf (dump_file, \"Speculative indirect call %s => %s has \"\n \t\t       \"turned out to have contradicting known target \",\n-\t\t       xstrdup_for_dump (edge->caller->name ()),\n-\t\t       edge->caller->order,\n-\t\t       xstrdup_for_dump (e2->callee->name ()),\n-\t\t       e2->callee->order);\n+\t\t       edge->caller->dump_name (),\n+\t\t       e2->callee->dump_name ());\n \t      print_generic_expr (dump_file, callee_decl);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  else\n \t    {\n-\t      fprintf (dump_file, \"Removing speculative call %s/%i => %s/%i\\n\",\n-\t\t       xstrdup_for_dump (edge->caller->name ()),\n-\t\t       edge->caller->order,\n-\t\t       xstrdup_for_dump (e2->callee->name ()),\n-\t\t       e2->callee->order);\n+\t      fprintf (dump_file, \"Removing speculative call %s => %s\\n\",\n+\t\t       edge->caller->dump_name (),\n+\t\t       e2->callee->dump_name ());\n \t    }\n \t}\n     }\n@@ -1295,12 +1287,10 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t\t\t\t\t\t  true))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Not expanding speculative call of %s/%i -> %s/%i\\n\"\n+\t    fprintf (dump_file, \"Not expanding speculative call of %s -> %s\\n\"\n \t\t     \"Type mismatch.\\n\",\n-\t\t     xstrdup_for_dump (e->caller->name ()),\n-\t\t     e->caller->order,\n-\t\t     xstrdup_for_dump (e->callee->name ()),\n-\t\t     e->callee->order);\n+\t\t     e->caller->dump_name (),\n+\t\t     e->callee->dump_name ());\n \t  e = e->resolve_speculation ();\n \t  /* We are producing the final function body and will throw away the\n \t     callgraph edges really soon.  Reset the counts/frequencies to\n@@ -1314,12 +1304,10 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n-\t\t     \"Expanding speculative call of %s/%i -> %s/%i count: \"\n+\t\t     \"Expanding speculative call of %s -> %s count: \"\n \t\t     \"%\" PRId64\"\\n\",\n-\t\t     xstrdup_for_dump (e->caller->name ()),\n-\t\t     e->caller->order,\n-\t\t     xstrdup_for_dump (e->callee->name ()),\n-\t\t     e->callee->order,\n+\t\t     e->caller->dump_name (),\n+\t\t     e->callee->dump_name (),\n \t\t     (int64_t)e->count);\n \t  gcc_assert (e2->speculative);\n \t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n@@ -1399,9 +1387,8 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \n   if (symtab->dump_file)\n     {\n-      fprintf (symtab->dump_file, \"updating call of %s/%i -> %s/%i: \",\n-\t       xstrdup_for_dump (e->caller->name ()), e->caller->order,\n-\t       xstrdup_for_dump (e->callee->name ()), e->callee->order);\n+      fprintf (symtab->dump_file, \"updating call of %s -> %s: \",\n+\t       e->caller->dump_name (), e->callee->dump_name ());\n       print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n       if (e->callee->clone.combined_args_to_skip)\n \t{\n@@ -2064,15 +2051,11 @@ cgraph_node::dump (FILE *f)\n   dump_base (f);\n \n   if (global.inlined_to)\n-    fprintf (f, \"  Function %s/%i is inline copy in %s/%i\\n\",\n-\t     xstrdup_for_dump (name ()),\n-\t     order,\n-\t     xstrdup_for_dump (global.inlined_to->name ()),\n-\t     global.inlined_to->order);\n+    fprintf (f, \"  Function %s is inline copy in %s\\n\",\n+\t     dump_name (),\n+\t     global.inlined_to->dump_name ());\n   if (clone_of)\n-    fprintf (f, \"  Clone of %s/%i\\n\",\n-\t     clone_of->asm_name (),\n-\t     clone_of->order);\n+    fprintf (f, \"  Clone of %s\\n\", clone_of->dump_asm_name ());\n   if (symtab->function_flags_ready)\n     fprintf (f, \"  Availability: %s\\n\",\n \t     cgraph_availability_names [get_availability ()]);\n@@ -2088,14 +2071,12 @@ cgraph_node::dump (FILE *f)\n       if (vi->prev != NULL)\n \t{\n \t  fprintf (f, \"prev: \");\n-\t  fprintf (f, \"%s/%i \", vi->prev->this_node->asm_name (),\n-\t\t   vi->prev->this_node->order);\n+\t  fprintf (f, \"%s \", vi->prev->this_node->dump_asm_name ());\n \t}\n       if (vi->next != NULL)\n \t{\n \t  fprintf (f, \"next: \");\n-\t  fprintf (f, \"%s/%i \", vi->next->this_node->asm_name (),\n-\t\t   vi->next->this_node->order);\n+\t  fprintf (f, \"%s \", vi->next->this_node->dump_asm_name ());\n \t}\n       if (vi->dispatcher_resolver != NULL_TREE)\n \tfprintf (f, \"dispatcher: %s\",\n@@ -2184,16 +2165,14 @@ cgraph_node::dump (FILE *f)\n \n   for (edge = callers; edge; edge = edge->next_caller)\n     {\n-      fprintf (f, \"%s/%i \", edge->caller->asm_name (),\n-\t       edge->caller->order);\n+      fprintf (f, \"%s \", edge->caller->dump_name ());\n       edge->dump_edge_flags (f);\n     }\n \n   fprintf (f, \"\\n  Calls: \");\n   for (edge = callees; edge; edge = edge->next_callee)\n     {\n-      fprintf (f, \"%s/%i \", edge->callee->asm_name (),\n-\t       edge->callee->order);\n+      fprintf (f, \"%s \", edge->callee->dump_name ());\n       edge->dump_edge_flags (f);\n     }\n   fprintf (f, \"\\n\");"}, {"sha": "72f9702f851bde427c4e06b3d6f298142f962e87", "filename": "gcc/cgraph.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -99,8 +99,14 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return name.  */\n   const char *name () const;\n \n+  /* Return dump name.  */\n+  const char *dump_name () const;\n+\n   /* Return asm name.  */\n-  const char * asm_name () const;\n+  const char *asm_name () const;\n+\n+  /* Return dump name with assembler name.  */\n+  const char *dump_asm_name () const;\n \n   /* Add node into symbol table.  This function is not used directly, but via\n      cgraph/varpool node creation routines.  */\n@@ -598,6 +604,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Worker for ultimate_alias_target.  */\n   symtab_node *ultimate_alias_target_1 (enum availability *avail = NULL,\n \t\t\t\t\tsymtab_node *ref = NULL);\n+\n+  /* Get dump name with normal or assembly name.  */\n+  const char *get_dump_name (bool asm_name_p) const;\n };\n \n inline void"}, {"sha": "f5e023e748812d6b61945dd416f081fb34edea90", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -539,8 +539,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n       struct ipa_node_params *info;\n \n       info = IPA_NODE_REF (node);\n-      fprintf (f, \"  Node: %s/%i:\\n\", node->name (),\n-\t       node->order);\n+      fprintf (f, \"  Node: %s:\\n\", node->dump_name ());\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n@@ -622,8 +621,8 @@ determine_versionability (struct cgraph_node *node,\n     }\n \n   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n-    fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\",\n-\t     node->name (), node->order, reason);\n+    fprintf (dump_file, \"Function %s is not versionable, reason: %s.\\n\",\n+\t     node->dump_name (), reason);\n \n   info->versionable = (reason == NULL);\n }\n@@ -1195,9 +1194,8 @@ initialize_node_lattices (struct cgraph_node *node)\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS)\n \t  && !node->alias && !node->thunk.thunk_p)\n-\tfprintf (dump_file, \"Marking all lattices of %s/%i as %s\\n\",\n-\t\t node->name (), node->order,\n-\t\t disable ? \"BOTTOM\" : \"VARIABLE\");\n+\tfprintf (dump_file, \"Marking all lattices of %s as %s\\n\",\n+\t\t node->dump_name (), disable ? \"BOTTOM\" : \"VARIABLE\");\n     }\n \n   for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n@@ -2842,8 +2840,7 @@ estimate_local_effects (struct cgraph_node *node)\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nEstimating effects for %s/%i.\\n\",\n-\t     node->name (), node->order);\n+    fprintf (dump_file, \"\\nEstimating effects for %s.\\n\", node->dump_name ());\n \n   always_const = gather_context_independent_values (info, &known_csts,\n \t\t\t\t\t\t    &known_contexts, &known_aggs,\n@@ -3656,10 +3653,10 @@ update_profiling_info (struct cgraph_node *orig_node,\n   if (orig_node_count < orig_sum + new_sum)\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"    Problem: node %s/%i has too low count \"\n+\tfprintf (dump_file, \"    Problem: node %s has too low count \"\n \t\t HOST_WIDE_INT_PRINT_DEC \" while the sum of incoming \"\n \t\t \"counts is \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t orig_node->name (), orig_node->order,\n+\t\t orig_node->dump_name (),\n \t\t (HOST_WIDE_INT) orig_node_count,\n \t\t (HOST_WIDE_INT) (orig_sum + new_sum));\n \n@@ -3798,8 +3795,7 @@ create_specialized_node (struct cgraph_node *node,\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"     the new node is %s/%i.\\n\",\n-\t       new_node->name (), new_node->order);\n+      fprintf (dump_file, \"     the new node is %s.\\n\", new_node->dump_name ());\n       if (known_contexts.exists ())\n \t{\n \t  for (i = 0; i < count; i++)\n@@ -4439,12 +4435,9 @@ perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n \t      && cgraph_edge_brings_all_agg_vals_for_node (cs, val->spec_node))\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \" - adding an extra caller %s/%i\"\n-\t\t\t \" of %s/%i\\n\",\n-\t\t\t xstrdup_for_dump (cs->caller->name ()),\n-\t\t\t cs->caller->order,\n-\t\t\t xstrdup_for_dump (val->spec_node->name ()),\n-\t\t\t val->spec_node->order);\n+\t\tfprintf (dump_file, \" - adding an extra caller %s of %s\\n\",\n+\t\t\t cs->caller->dump_name (),\n+\t\t\t val->spec_node->dump_name ());\n \n \t      cs->redirect_callee_duplicating_thunks (val->spec_node);\n \t      val->spec_node->expand_all_artificial_thunks ();\n@@ -4600,8 +4593,8 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n     return false;\n \n   if (dump_file)\n-    fprintf (dump_file, \"  Creating a specialized node of %s/%i.\\n\",\n-\t     node->name (), node->order);\n+    fprintf (dump_file, \"  Creating a specialized node of %s.\\n\",\n+\t     node->dump_name ());\n \n   callers = gather_edges_for_value (val, node, caller_count);\n   if (offset == -1)\n@@ -4642,8 +4635,8 @@ decide_whether_version_node (struct cgraph_node *node)\n     return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nEvaluating opportunities for %s/%i.\\n\",\n-\t     node->name (), node->order);\n+    fprintf (dump_file, \"\\nEvaluating opportunities for %s.\\n\",\n+\t     node->dump_name ());\n \n   gather_context_independent_values (info, &known_csts, &known_contexts,\n \t\t\t\t  info->do_clone_for_all_contexts ? &known_aggs\n@@ -4697,9 +4690,8 @@ decide_whether_version_node (struct cgraph_node *node)\n       vec<cgraph_edge *> callers;\n \n       if (dump_file)\n-\tfprintf (dump_file, \" - Creating a specialized node of %s/%i \"\n-\t\t \"for all known contexts.\\n\", node->name (),\n-\t\t node->order);\n+\tfprintf (dump_file, \" - Creating a specialized node of %s \"\n+\t\t \"for all known contexts.\\n\", node->dump_name ());\n \n       callers = node->collect_callers ();\n \n@@ -4794,8 +4786,7 @@ identify_dead_nodes (struct cgraph_node *node)\n     {\n       for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n \tif (IPA_NODE_REF (v)->node_dead)\n-\t  fprintf (dump_file, \"  Marking node as dead: %s/%i.\\n\",\n-\t\t   v->name (), v->order);\n+\t  fprintf (dump_file, \"  Marking node as dead: %s.\\n\", v->dump_name ());\n     }\n }\n \n@@ -4892,8 +4883,8 @@ ipcp_store_bits_results (void)\n \t    continue;\n \t  if (!dumped_sth)\n \t    {\n-\t      fprintf (dump_file, \"Propagated bits info for function %s/%i:\\n\",\n-\t\t       node->name (), node->order);\n+\t      fprintf (dump_file, \"Propagated bits info for function %s:\\n\",\n+\t\t       node->dump_name ());\n \t      dumped_sth = true;\n \t    }\n \t  fprintf (dump_file, \" param %i: value = \", i);"}, {"sha": "c7460caf7a9907bc8ef4740d2c9c1b8af022f1d1", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -3316,7 +3316,8 @@ dump_targets (FILE *f, vec <cgraph_node *> targets)\n       char *name = NULL;\n       if (in_lto_p)\n \tname = cplus_demangle_v3 (targets[i]->asm_name (), 0);\n-      fprintf (f, \" %s/%i\", name ? name : targets[i]->name (), targets[i]->order);\n+      fprintf (f, \" %s/%i\", name ? name : targets[i]->name (),\n+\t       targets[i]->order);\n       if (in_lto_p)\n \tfree (name);\n       if (!targets[i]->definition)\n@@ -3596,8 +3597,8 @@ ipa_devirt (void)\n       if (!opt_for_fn (n->decl, flag_devirtualize))\n \tcontinue;\n       if (dump_file && n->indirect_calls)\n-\tfprintf (dump_file, \"\\n\\nProcesing function %s/%i\\n\",\n-\t\t n->name (), n->order);\n+\tfprintf (dump_file, \"\\n\\nProcesing function %s\\n\",\n+\t\t n->dump_name ());\n       for (e = n->indirect_calls; e; e = e->next_callee)\n \tif (e->indirect_info->polymorphic)\n \t  {\n@@ -3752,10 +3753,10 @@ ipa_devirt (void)\n                   {\n                     location_t locus = gimple_location_safe (e->call_stmt);\n                     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n-                                     \"speculatively devirtualizing call in %s/%i to %s/%i\\n\",\n-                                     n->name (), n->order,\n-                                     likely_target->name (),\n-                                     likely_target->order);\n+\t\t\t\t     \"speculatively devirtualizing call \"\n+\t\t\t\t     \"in %s to %s\\n\",\n+\t\t\t\t     n->dump_name (),\n+\t\t\t\t     likely_target->dump_name ());\n                   }\n \t\tif (!likely_target->can_be_discarded_p ())\n \t\t  {"}, {"sha": "0b0c1fdfdbc1ad64737fdc137024b791c43e372e", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -195,8 +195,8 @@ sem_item::dump (void)\n {\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"[%s] %s (%u) (tree:%p)\\n\", type == FUNC ? \"func\" : \"var\",\n-\t       node->name(), node->order, (void *) node->decl);\n+      fprintf (dump_file, \"[%s] %s (tree:%p)\\n\", type == FUNC ? \"func\" : \"var\",\n+\t       node->dump_name (), (void *) node->decl);\n       fprintf (dump_file, \"  hash: %u\\n\", get_hash ());\n       fprintf (dump_file, \"  references: \");\n \n@@ -869,13 +869,9 @@ sem_function::equals (sem_item *item,\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file,\n-\t     \"Equals called for:%s:%s (%u:%u) (%s:%s) with result: %s\\n\\n\",\n-\t     xstrdup_for_dump (node->name()),\n-\t     xstrdup_for_dump (item->node->name ()),\n-\t     node->order,\n-\t     item->node->order,\n-\t     xstrdup_for_dump (node->asm_name ()),\n-\t     xstrdup_for_dump (item->node->asm_name ()),\n+\t     \"Equals called for: %s:%s with result: %s\\n\\n\",\n+\t     node->dump_name (),\n+\t     item->node->dump_name (),\n \t     eq ? \"true\" : \"false\");\n \n   return eq;\n@@ -1887,12 +1883,9 @@ sem_variable::equals (sem_item *item,\n \t\t\t      DECL_INITIAL (item->node->decl));\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file,\n-\t     \"Equals called for vars:%s:%s (%u:%u) (%s:%s) with result: %s\\n\\n\",\n-\t     xstrdup_for_dump (node->name()),\n-\t     xstrdup_for_dump (item->node->name ()),\n-\t     node->order, item->node->order,\n-\t     xstrdup_for_dump (node->asm_name ()),\n-\t     xstrdup_for_dump (item->node->asm_name ()), ret ? \"true\" : \"false\");\n+\t     \"Equals called for vars: %s:%s with result: %s\\n\\n\",\n+\t     node->dump_name (), item->node->dump_name (),\n+\t     ret ? \"true\" : \"false\");\n \n   return ret;\n }\n@@ -2398,8 +2391,8 @@ sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n       gcc_assert (node->definition);\n \n       if (dump_file)\n-\tfprintf (dump_file, \"Symbol added:%s (tree: %p, uid:%u)\\n\",\n-\t\t node->asm_name (), (void *) node->decl, node->order);\n+\tfprintf (dump_file, \"Symbol added: %s (tree: %p)\\n\",\n+\t\t node->dump_asm_name (), (void *) node->decl);\n \n       if (is_a<cgraph_node *> (node))\n \t{\n@@ -3577,9 +3570,7 @@ congruence_class::dump (FILE *file, unsigned int indent) const\n \n   FPUTS_SPACES (file, indent + 2, \"\");\n   for (unsigned i = 0; i < members.length (); i++)\n-    fprintf (file, \"%s(%p/%u) \", members[i]->node->asm_name (),\n-\t     (void *) members[i]->decl,\n-\t     members[i]->node->order);\n+    fprintf (file, \"%s \", members[i]->node->dump_asm_name ());\n \n   fprintf (file, \"\\n\");\n }"}, {"sha": "01a6833349359a7d57a1c33385557a62a915f506", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -351,8 +351,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n       cl_optimization_restore (&opts, opts_for_fn (to->decl));\n       opts.x_flag_strict_aliasing = false;\n       if (dump_file)\n-\tfprintf (dump_file, \"Dropping flag_strict_aliasing on %s:%i\\n\",\n-\t\t to->name (), to->order);\n+\tfprintf (dump_file, \"Dropping flag_strict_aliasing on %s\\n\",\n+\t\t to->dump_name ());\n       DECL_FUNCTION_SPECIFIC_OPTIMIZATION (to->decl)\n \t = build_optimization_node (&opts);\n       reload_optimization_node = true;\n@@ -412,8 +412,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \t  opts.x_flag_errno_math\n \t    = opt_for_fn (callee->decl, flag_errno_math);\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Copying FP flags from %s:%i to %s:%i\\n\",\n-\t\t     callee->name (), callee->order, to->name (), to->order);\n+\t    fprintf (dump_file, \"Copying FP flags from %s to %s\\n\",\n+\t\t     callee->dump_name (), to->dump_name ());\n \t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (to->decl)\n \t     = build_optimization_node (&opts);\n \t  reload_optimization_node = true;"}, {"sha": "674f8acb24806e90be363588ecf3965e569e8126", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -228,9 +228,9 @@ report_inline_failed_reason (struct cgraph_edge *e)\n {\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"  not inlinable: %s/%i -> %s/%i, %s\\n\",\n-\t       xstrdup_for_dump (e->caller->name ()), e->caller->order,\n-\t       xstrdup_for_dump (e->callee->name ()), e->callee->order,\n+      fprintf (dump_file, \"  not inlinable: %s -> %s, %s\\n\",\n+\t       e->caller->dump_name (),\n+\t       e->callee->dump_name (),\n \t       cgraph_inline_failed_string (e->inline_failed));\n       if ((e->inline_failed == CIF_TARGET_OPTION_MISMATCH\n \t   || e->inline_failed == CIF_OPTIMIZATION_MISMATCH)\n@@ -593,35 +593,32 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t       && growth > 0)\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n+\t    fprintf (dump_file, \"  will not early inline: %s->%s, \"\n \t\t     \"call is cold and code would grow by %i\\n\",\n-\t\t     xstrdup_for_dump (e->caller->name ()),\n-\t\t     e->caller->order,\n-\t\t     xstrdup_for_dump (callee->name ()), callee->order,\n+\t\t     e->caller->dump_name (),\n+\t\t     callee->dump_name (),\n \t\t     growth);\n \t  want_inline = false;\n \t}\n       else if (growth > PARAM_VALUE (PARAM_EARLY_INLINING_INSNS))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n+\t    fprintf (dump_file, \"  will not early inline: %s->%s, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns\\n\",\n-\t\t     xstrdup_for_dump (e->caller->name ()),\n-\t\t     e->caller->order,\n-\t\t     xstrdup_for_dump (callee->name ()), callee->order,\n+\t\t     e->caller->dump_name (),\n+\t\t     callee->dump_name (),\n \t\t     growth);\n \t  want_inline = false;\n \t}\n       else if ((n = num_calls (callee)) != 0\n \t       && growth * (n + 1) > PARAM_VALUE (PARAM_EARLY_INLINING_INSNS))\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n+\t    fprintf (dump_file, \"  will not early inline: %s->%s, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns \"\n \t\t     \"divided by number of calls\\n\",\n-\t\t     xstrdup_for_dump (e->caller->name ()),\n-\t\t     e->caller->order,\n-\t\t     xstrdup_for_dump (callee->name ()), callee->order,\n+\t\t     e->caller->dump_name (),\n+\t\t     callee->dump_name (),\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -1021,11 +1018,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n   if (dump)\n     {\n-      fprintf (dump_file, \"    Badness calculation for %s/%i -> %s/%i\\n\",\n-\t       xstrdup_for_dump (edge->caller->name ()),\n-\t       edge->caller->order,\n-\t       xstrdup_for_dump (callee->name ()),\n-\t       edge->callee->order);\n+      fprintf (dump_file, \"    Badness calculation for %s -> %s\\n\",\n+\t       edge->caller->dump_name (),\n+\t       edge->callee->dump_name ());\n       fprintf (dump_file, \"      size growth %i, time %f unspec %f \",\n \t       growth,\n \t       edge_time.to_double (),\n@@ -1231,12 +1226,9 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file,\n-\t\t       \"  decreasing badness %s/%i -> %s/%i, %f\"\n-\t\t       \" to %f\\n\",\n-\t\t       xstrdup_for_dump (edge->caller->name ()),\n-\t\t       edge->caller->order,\n-\t\t       xstrdup_for_dump (edge->callee->name ()),\n-\t\t       edge->callee->order,\n+\t\t       \"  decreasing badness %s -> %s, %f to %f\\n\",\n+\t\t       edge->caller->dump_name (),\n+\t\t       edge->callee->dump_name (),\n \t\t       n->get_key ().to_double (),\n \t\t       badness.to_double ());\n \t    }\n@@ -1248,11 +1240,9 @@ update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n        if (dump_file && (dump_flags & TDF_DETAILS))\n \t {\n \t   fprintf (dump_file,\n-\t\t    \"  enqueuing call %s/%i -> %s/%i, badness %f\\n\",\n-\t\t    xstrdup_for_dump (edge->caller->name ()),\n-\t\t    edge->caller->order,\n-\t\t    xstrdup_for_dump (edge->callee->name ()),\n-\t\t    edge->callee->order,\n+\t\t    \"  enqueuing call %s -> %s, badness %f\\n\",\n+\t\t    edge->caller->dump_name (),\n+\t\t    edge->callee->dump_name (),\n \t\t    badness.to_double ());\n \t }\n       edge->aux = heap->insert (badness, edge);\n@@ -1805,8 +1795,7 @@ inline_small_functions (void)\n       bool has_speculative = false;\n \n       if (dump_file)\n-\tfprintf (dump_file, \"Enqueueing calls in %s/%i.\\n\",\n-\t\t node->name (), node->order);\n+\tfprintf (dump_file, \"Enqueueing calls in %s.\\n\", node->dump_name ());\n \n       for (edge = node->callees; edge; edge = next)\n \t{\n@@ -1920,13 +1909,13 @@ inline_small_functions (void)\n       if (dump_file)\n \t{\n \t  fprintf (dump_file,\n-\t\t   \"\\nConsidering %s/%i with %i size\\n\",\n-\t\t   callee->name (), callee->order,\n+\t\t   \"\\nConsidering %s with %i size\\n\",\n+\t\t   callee->dump_name (),\n \t\t   ipa_fn_summaries->get (callee)->size);\n \t  fprintf (dump_file,\n-\t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n+\t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated badness is %f, frequency %.2f.\\n\",\n-\t\t   edge->caller->name (), edge->caller->order,\n+\t\t   edge->caller->dump_name (),\n \t\t   edge->call_stmt\n \t\t   && (LOCATION_LOCUS (gimple_location ((const gimple *)\n \t\t\t\t\t\t\tedge->call_stmt))"}, {"sha": "54bb5bf30018b71de4309c553fa4e4dbc7e57438", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -590,9 +590,9 @@ ipa_profile (void)\n \t\t  if (dump_file)\n \t\t    {\n \t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n-\t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n-\t\t\t       xstrdup_for_dump (n->name ()), n->order,\n-\t\t\t       xstrdup_for_dump (n2->name ()), n2->order,\n+\t\t\t       \" other module %s => %s, prob %3.2f\\n\",\n+\t\t\t       n->dump_name (),\n+\t\t\t       n2->dump_name (),\n \t\t\t       e->indirect_info->common_target_probability\n \t\t\t       / (float)REG_BR_PROB_BASE);\n \t\t    }"}, {"sha": "81fbb520938eaf2357d01c1a7b41bffd95f9b7ee", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 36, "deletions": 54, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -416,17 +416,15 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n {\n   struct cgraph_edge *cs;\n \n-  fprintf (f, \"  Jump functions of caller  %s/%i:\\n\", node->name (),\n-\t   node->order);\n+  fprintf (f, \"  Jump functions of caller  %s:\\n\", node->dump_name ());\n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n       if (!ipa_edge_args_info_available_for_edge_p (cs))\n \tcontinue;\n \n-      fprintf (f, \"    callsite  %s/%i -> %s/%i : \\n\",\n-\t       xstrdup_for_dump (node->name ()), node->order,\n-\t       xstrdup_for_dump (cs->callee->name ()),\n-\t       cs->callee->order);\n+      fprintf (f, \"    callsite  %s -> %s : \\n\",\n+\t       node->dump_name (),\n+\t       cs->callee->dump_name ());\n       ipa_print_node_jump_functions_for_edge (f, cs);\n     }\n \n@@ -2854,9 +2852,8 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t\t{\n \t\t  location_t loc = gimple_location_safe (ie->call_stmt);\n \t\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-\t\t\t\t   \"discovered direct call non-invariant \"\n-\t\t\t\t   \"%s/%i\\n\",\n-\t\t\t\t   ie->caller->name (), ie->caller->order);\n+\t\t\t\t   \"discovered direct call non-invariant %s\\n\",\n+\t\t\t\t   ie->caller->dump_name ());\n \t\t}\n \t      return NULL;\n \t    }\n@@ -2866,9 +2863,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t    {\n \t      location_t loc = gimple_location_safe (ie->call_stmt);\n \t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-\t\t\t       \"discovered direct call to non-function in %s/%i, \"\n+\t\t\t       \"discovered direct call to non-function in %s, \"\n \t\t\t       \"making it __builtin_unreachable\\n\",\n-\t\t\t       ie->caller->name (), ie->caller->order);\n+\t\t\t       ie->caller->dump_name ());\n \t    }\n \n \t  target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n@@ -2895,11 +2892,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n-\t\t     \"(%s/%i -> %s/%i) but can not refer to it. Giving up.\\n\",\n-\t\t     xstrdup_for_dump (ie->caller->name ()),\n-\t\t     ie->caller->order,\n-\t\t     xstrdup_for_dump (ie->callee->name ()),\n-\t\t     ie->callee->order);\n+\t\t     \"(%s -> %s) but can not refer to it. Giving up.\\n\",\n+\t\t     ie->caller->dump_name (),\n+\t\t     ie->callee->dump_name ());\n \t  return NULL;\n \t}\n       callee = cgraph_node::get_create (target);\n@@ -2915,24 +2910,18 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n \t  != callee->ultimate_alias_target ())\n \t{\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n-\t\t     \"(%s/%i -> %s/%i) but the call is already speculated to %s/%i. Giving up.\\n\",\n-\t\t     xstrdup_for_dump (ie->caller->name ()),\n-\t\t     ie->caller->order,\n-\t\t     xstrdup_for_dump (callee->name ()),\n-\t\t     callee->order,\n-\t\t     xstrdup_for_dump (e2->callee->name ()),\n-\t\t     e2->callee->order);\n+\t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative \"\n+\t\t     \"target (%s -> %s) but the call is already \"\n+\t\t     \"speculated to %s. Giving up.\\n\",\n+\t\t     ie->caller->dump_name (), callee->dump_name (),\n+\t\t     e2->callee->dump_name ());\n \t}\n       else\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a speculative target \"\n-\t\t     \"(%s/%i -> %s/%i) this agree with previous speculation.\\n\",\n-\t\t     xstrdup_for_dump (ie->caller->name ()),\n-\t\t     ie->caller->order,\n-\t\t     xstrdup_for_dump (callee->name ()),\n-\t\t     callee->order);\n+\t\t     \"(%s -> %s) this agree with previous speculation.\\n\",\n+\t\t     ie->caller->dump_name (), callee->dump_name ());\n \t}\n       return NULL;\n     }\n@@ -2949,13 +2938,11 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target,\n   if (dump_file && !unreachable)\n     {\n       fprintf (dump_file, \"ipa-prop: Discovered %s call to a %s target \"\n-\t       \"(%s/%i -> %s/%i), for stmt \",\n+\t       \"(%s -> %s), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n \t       speculative ? \"speculative\" : \"known\",\n-\t       xstrdup_for_dump (ie->caller->name ()),\n-\t       ie->caller->order,\n-\t       xstrdup_for_dump (callee->name ()),\n-\t       callee->order);\n+\t       ie->caller->dump_name (),\n+\t       callee->dump_name ());\n       if (ie->call_stmt)\n \tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n       else\n@@ -3155,9 +3142,8 @@ remove_described_reference (symtab_node *symbol, struct ipa_cst_ref_desc *rdesc)\n \n   to_del->remove_reference ();\n   if (dump_file)\n-    fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n-\t     xstrdup_for_dump (origin->caller->name ()),\n-\t     origin->caller->order, xstrdup_for_dump (symbol->name ()));\n+    fprintf (dump_file, \"ipa-prop: Removed a reference from %s to %s.\\n\",\n+\t     origin->caller->dump_name (), xstrdup_for_dump (symbol->name ()));\n   return true;\n }\n \n@@ -3272,13 +3258,13 @@ ipa_impossible_devirt_target (struct cgraph_edge *ie, tree target)\n     {\n       if (target)\n \tfprintf (dump_file,\n-\t\t \"Type inconsistent devirtualization: %s/%i->%s\\n\",\n-\t\t ie->caller->name (), ie->caller->order,\n+\t\t \"Type inconsistent devirtualization: %s->%s\\n\",\n+\t\t ie->caller->dump_name (),\n \t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (target)));\n       else\n \tfprintf (dump_file,\n-\t\t \"No devirtualization target in %s/%i\\n\",\n-\t\t ie->caller->name (), ie->caller->order);\n+\t\t \"No devirtualization target in %s\\n\",\n+\t\t ie->caller->dump_name ());\n     }\n   tree new_target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n   cgraph_node::get_create (new_target);\n@@ -3607,10 +3593,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n-\t\t\t     \"reference from %s/%i to %s/%i.\\n\",\n-\t\t\t     xstrdup_for_dump (new_root->name ()),\n-\t\t\t     new_root->order,\n-\t\t\t     xstrdup_for_dump (n->name ()), n->order);\n+\t\t\t     \"reference from %s to %s.\\n\",\n+\t\t\t     new_root->dump_name (),\n+\t\t\t     n->dump_name ());\n \t\t  ref->remove_reference ();\n \t\t}\n \t    }\n@@ -3648,11 +3633,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t  if (dump_file)\n \t\t\t    fprintf (dump_file, \"ipa-prop: Removing \"\n \t\t\t\t     \"cloning-created reference \"\n-\t\t\t\t     \"from %s/%i to %s/%i.\\n\",\n-\t\t\t\t     xstrdup_for_dump (clone->name ()),\n-\t\t\t\t     clone->order,\n-\t\t\t\t     xstrdup_for_dump (n->name ()),\n-\t\t\t\t     n->order);\n+\t\t\t\t     \"from %s to %s.\\n\",\n+\t\t\t\t     clone->dump_name (),\n+\t\t\t\t     n->dump_name ());\n \t\t\t  ref->remove_reference ();\n \t\t\t}\n \t\t      clone = clone->callers->caller;\n@@ -4030,8 +4013,7 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n   if (!node->definition)\n     return;\n   info = IPA_NODE_REF (node);\n-  fprintf (f, \"  function  %s/%i parameter descriptors:\\n\",\n-\t   node->name (), node->order);\n+  fprintf (f, \"  function  %s parameter descriptors:\\n\", node->dump_name ());\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n@@ -5849,8 +5831,8 @@ ipcp_transform_function (struct cgraph_node *node)\n   gcc_checking_assert (current_function_decl);\n \n   if (dump_file)\n-    fprintf (dump_file, \"Modification phase of node %s/%i\\n\",\n-\t     node->name (), node->order);\n+    fprintf (dump_file, \"Modification phase of node %s\\n\",\n+\t     node->dump_name ());\n \n   ipcp_update_bits (node);\n   ipcp_update_vr (node);"}, {"sha": "dac8f0d5f214425a0d32cedc75167b0483797c99", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -1130,9 +1130,7 @@ pure_const_read_summary (void)\n \t      if (dump_file)\n \t\t{\n \t\t  int flags = flags_from_decl_or_type (node->decl);\n-\t\t  fprintf (dump_file, \"Read info for %s/%i \",\n-\t\t\t   node->name (),\n-\t\t\t   node->order);\n+\t\t  fprintf (dump_file, \"Read info for %s \", node->dump_name ());\n \t\t  if (flags & ECF_CONST)\n \t\t    fprintf (dump_file, \" const\");\n \t\t  if (flags & ECF_PURE)\n@@ -1269,9 +1267,8 @@ propagate_pure_const (void)\n \n \t  funct_state w_l = get_function_state (w);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  Visiting %s/%i state:%s looping %i\\n\",\n-\t\t     w->name (),\n-\t\t     w->order,\n+\t    fprintf (dump_file, \"  Visiting %s state:%s looping %i\\n\",\n+\t\t     w->dump_name (),\n \t\t     pure_const_names[w_l->pure_const_state],\n \t\t     w_l->looping);\n \n@@ -1305,10 +1302,8 @@ propagate_pure_const (void)\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"    Call to %s/%i\",\n-\t\t\t   e->callee->name (),\n-\t\t\t   e->callee->order);\n+\t\t  fprintf (dump_file, \"    Call to %s\",\n+\t\t\t   e->callee->dump_name ());\n \t\t}\n \t      if (avail > AVAIL_INTERPOSABLE)\n \t\t{"}, {"sha": "45c2e3feda206be4d4367b0053538b1dfdb4713e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -599,8 +599,7 @@ generate_summary (void)\n \n \t  l = &get_reference_vars_info (node)->local;\n \t  fprintf (dump_file,\n-\t\t   \"\\nFunction name:%s/%i:\",\n-\t\t   node->asm_name (), node->order);\n+\t\t   \"\\nFunction name:%s:\", node->dump_name ());\n \t  fprintf (dump_file, \"\\n  locals read: \");\n \t  if (l->statics_read)\n \t    EXECUTE_IF_SET_IN_BITMAP (l->statics_read,\n@@ -636,8 +635,7 @@ read_write_all_from_decl (struct cgraph_node *node,\n     {\n       read_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-         fprintf (dump_file, \"   %s/%i -> read all\\n\",\n-\t\t  node->asm_name (), node->order);\n+\tfprintf (dump_file, \"   %s -> read all\\n\", node->dump_name ());\n     }\n   else\n     {\n@@ -646,8 +644,8 @@ read_write_all_from_decl (struct cgraph_node *node,\n       read_all = true;\n       write_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-         fprintf (dump_file, \"   %s/%i -> read all, write all\\n\",\n-\t\t  node->asm_name (), node->order);\n+\tfprintf (dump_file, \"   %s -> read all, write all\\n\",\n+\t\t  node->dump_name ());\n     }\n }\n \n@@ -754,17 +752,15 @@ propagate (void)\n       node_g = &node_info->global;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Starting cycle with %s/%i\\n\",\n-\t\t  node->asm_name (), node->order);\n+\tfprintf (dump_file, \"Starting cycle with %s\\n\", node->dump_name ());\n \n       vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (node);\n \n       /* If any node in a cycle is read_all or write_all, they all are.  */\n       FOR_EACH_VEC_ELT (cycle_nodes, x, w)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  Visiting %s/%i\\n\",\n-\t\t     w->asm_name (), w->order);\n+\t    fprintf (dump_file, \"  Visiting %s\\n\", w->dump_asm_name ());\n \t  get_read_write_all_from_node (w, read_all, write_all);\n \t  if (read_all && write_all)\n \t    break;\n@@ -826,9 +822,7 @@ propagate (void)\n           if (node->alias || !opt_for_fn (node->decl, flag_ipa_reference))\n \t    continue;\n \n-\t  fprintf (dump_file,\n-\t\t   \"\\nFunction name:%s/%i:\",\n-\t\t   node->asm_name (), node->order);\n+\t  fprintf (dump_file, \"\\nFunction name:%s:\", node->dump_asm_name ());\n \n \t  ipa_reference_vars_info_t node_info = get_reference_vars_info (node);\n \t  ipa_reference_global_vars_info_t node_g = &node_info->global;\n@@ -839,8 +833,7 @@ propagate (void)\n \t      ipa_reference_vars_info_t w_ri = get_reference_vars_info (w);\n \t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n \t      if (w != node)\n-\t\tfprintf (dump_file, \"\\n  next cycle: %s/%i \",\n-\t\t\t w->asm_name (), w->order);\n+\t\tfprintf (dump_file, \"\\n  next cycle: %s \", w->dump_asm_name ());\n \t      fprintf (dump_file, \"\\n    locals read: \");\n \t      dump_static_vars_set_to_file (dump_file, w_l->statics_read);\n \t      fprintf (dump_file, \"\\n    locals written: \");\n@@ -1120,8 +1113,8 @@ ipa_reference_read_optimization_summary (void)\n \t      info->statics_not_written = BITMAP_ALLOC (&optimization_summary_obstack);\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n-\t\t\t \"\\nFunction name:%s/%i:\\n  static not read:\",\n-\t\t\t node->asm_name (), node->order);\n+\t\t\t \"\\nFunction name:%s:\\n  static not read:\",\n+\t\t\t node->dump_asm_name ());\n \n \t      /* Set the statics not read.  */\n \t      v_count = streamer_read_hwi (ib);"}, {"sha": "39db923c429122a373cec2941f821c5ea9233e67", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -406,9 +406,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n     return;\n   if (symtab->dump_file)\n     {\n-      fprintf (symtab->dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n-\t       xstrdup_for_dump (src->name ()), src->order,\n-\t       xstrdup_for_dump (dst->name ()), dst->order);\n+      fprintf (symtab->dump_file, \"Merging profiles of %s to %s\\n\",\n+\t       src->dump_name (), dst->dump_name ());\n     }\n   dst->count += src->count;\n "}, {"sha": "e5b6eded690c06f30233b1312525d880cdeda116", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -230,10 +230,9 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \t      else\n \t\tlocus = UNKNOWN_LOCATION;\n \t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n-                               \"devirtualizing call in %s/%i to %s/%i\\n\",\n-                               edge->caller->name (), edge->caller->order,\n-                               target->name (),\n-                               target->order);\n+\t\t\t       \"devirtualizing call in %s to %s\\n\",\n+\t\t\t       edge->caller->dump_name (),\n+\t\t\t       target->dump_name ());\n \t    }\n \t  edge = edge->make_direct (target);\n \t  if (ipa_fn_summaries)\n@@ -529,7 +528,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n       if (!node->aux)\n \t{\n \t  if (file)\n-\t    fprintf (file, \" %s/%i\", node->name (), node->order);\n+\t    fprintf (file, \" %s\", node->dump_name ());\n \t  node->remove ();\n \t  changed = true;\n \t}\n@@ -549,7 +548,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t  if (node->definition && !node->alias && !node->thunk.thunk_p)\n \t    {\n \t      if (file)\n-\t\tfprintf (file, \" %s/%i\", node->name (), node->order);\n+\t\tfprintf (file, \" %s\", node->dump_name ());\n \t      node->body_removed = true;\n \t      node->analyzed = false;\n \t      node->definition = false;\n@@ -616,12 +615,11 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t  while (vnode->iterate_direct_aliases (0, ref))\n \t    {\n \t      if (file)\n-\t\tfprintf (file, \" %s/%i\", ref->referred->name (),\n-\t\t\t ref->referred->order);\n+\t\tfprintf (file, \" %s\", ref->referred->dump_name ());\n \t      ref->referring->remove ();\n \t    }\n \t  if (file)\n-\t    fprintf (file, \" %s/%i\", vnode->name (), vnode->order);\n+\t    fprintf (file, \" %s\", vnode->dump_name ());\n           vnext = next_variable (vnode);\n \t  /* Signal removal to the debug machinery.  */\n \t  if (! flag_wpa)\n@@ -1391,8 +1389,8 @@ ipa_single_use (void)\n \n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"Variable %s/%i is used by single function\\n\",\n-\t\t       var->name (), var->order);\n+\t      fprintf (dump_file, \"Variable %s is used by single function\\n\",\n+\t\t       var->dump_name ());\n \t    }\n \t  var->used_by_single_function = true;\n \t}"}, {"sha": "06f4d2bd7fa2ccfb694eebf16d7d8fe82df5c814", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -1,3 +1,10 @@\n+2017-05-23  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Use\n+\tsymtab_node::dump_{asm_,}name functions.\n+\t* lto.c (read_cgraph_and_symbols): Likewise.\n+\t(do_whole_program_analysis): Likewise.\n+\n 2017-05-23  Martin Liska  <mliska@suse.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Use the renamed function."}, {"sha": "9fd94861c6d456efb2056b2eae7ca91826dd736b", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -45,11 +45,10 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \n   if (symtab->dump_file)\n     {\n-      fprintf (symtab->dump_file, \"Replacing cgraph node %s/%i by %s/%i\"\n+      fprintf (symtab->dump_file, \"Replacing cgraph node %s by %s\"\n  \t       \" for symbol %s\\n\",\n-\t       node->name (), node->order,\n-\t       prevailing_node->name (),\n-\t       prevailing_node->order,\n+\t       node->dump_name (),\n+\t       prevailing_node->dump_name (),\n \t       IDENTIFIER_POINTER ((*targetm.asm_out.mangle_assembler_name)\n \t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)))));\n     }"}, {"sha": "ac35fa41129ff46bb77182a0fefcebe1950a40c0", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -3163,9 +3163,9 @@ drop_profile (struct cgraph_node *node, gcov_type call_count)\n \n   if (dump_file)\n     fprintf (dump_file,\n-             \"Dropping 0 profile for %s/%i. %s based on calls.\\n\",\n-             node->name (), node->order,\n-             hot ? \"Function is hot\" : \"Function is normal\");\n+\t     \"Dropping 0 profile for %s. %s based on calls.\\n\",\n+\t     node->dump_name (),\n+\t     hot ? \"Function is hot\" : \"Function is normal\");\n   /* We only expect to miss profiles for functions that are reached\n      via non-zero call edges in cases where the function may have\n      been linked from another module or library (COMDATs and extern\n@@ -3181,12 +3181,12 @@ drop_profile (struct cgraph_node *node, gcov_type call_count)\n         {\n           if (dump_file)\n             fprintf (dump_file,\n-                     \"Missing counts for called function %s/%i\\n\",\n-                     node->name (), node->order);\n+\t\t     \"Missing counts for called function %s\\n\",\n+\t\t     node->dump_name ());\n         }\n       else\n-        warning (0, \"Missing counts for called function %s/%i\",\n-                 node->name (), node->order);\n+\twarning (0, \"Missing counts for called function %s\",\n+\t\t node->dump_name ());\n     }\n \n   profile_status_for_fn (fn)"}, {"sha": "0145910023fefa3d128fdf99f7f249ce6b0d99ae", "filename": "gcc/symtab.c", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -522,6 +522,31 @@ symtab_node::name () const\n   return lang_hooks.decl_printable_name (decl, 2);\n }\n \n+const char *\n+symtab_node::get_dump_name (bool asm_name_p) const\n+{\n+#define EXTRA 16\n+  const char *fname = asm_name_p ? asm_name () : name ();\n+  unsigned l = strlen (fname);\n+\n+  char *s = (char *)ggc_internal_cleared_alloc (l + EXTRA);\n+  snprintf (s, l + EXTRA, \"%s/%d\", fname, order);\n+\n+  return s;\n+}\n+\n+const char *\n+symtab_node::dump_name () const\n+{\n+  return get_dump_name (false);\n+}\n+\n+const char *\n+symtab_node::dump_asm_name () const\n+{\n+  return get_dump_name (true);\n+}\n+\n /* Return ipa reference from this symtab_node to\n    REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n    of the use.  */\n@@ -751,9 +776,8 @@ symtab_node::dump_references (FILE *file)\n   int i;\n   for (i = 0; iterate_reference (i, ref); i++)\n     {\n-      fprintf (file, \"%s/%i (%s)\",\n-               ref->referred->asm_name (),\n-               ref->referred->order,\n+      fprintf (file, \"%s (%s)\",\n+\t       ref->referred->dump_asm_name (),\n \t       ipa_ref_use_name [ref->use]);\n       if (ref->speculative)\n \tfprintf (file, \" (speculative)\");\n@@ -770,9 +794,8 @@ symtab_node::dump_referring (FILE *file)\n   int i;\n   for (i = 0; iterate_referring(i, ref); i++)\n     {\n-      fprintf (file, \"%s/%i (%s)\",\n-               ref->referring->asm_name (),\n-               ref->referring->order,\n+      fprintf (file, \"%s (%s)\",\n+\t       ref->referring->dump_asm_name (),\n \t       ipa_ref_use_name [ref->use]);\n       if (ref->speculative)\n \tfprintf (file, \" (speculative)\");\n@@ -791,7 +814,7 @@ symtab_node::dump_base (FILE *f)\n     \"default\", \"protected\", \"hidden\", \"internal\"\n   };\n \n-  fprintf (f, \"%s/%i (%s)\", asm_name (), order, name ());\n+  fprintf (f, \"%s (%s)\", dump_asm_name (), name ());\n   dump_addr (f, \" @\", (void *)this);\n   fprintf (f, \"\\n  Type: %s\", symtab_type_names[type]);\n \n@@ -874,9 +897,8 @@ symtab_node::dump_base (FILE *f)\n   fprintf (f, \"\\n\");\n   \n   if (same_comdat_group)\n-    fprintf (f, \"  Same comdat group as: %s/%i\\n\",\n-\t     same_comdat_group->asm_name (),\n-\t     same_comdat_group->order);\n+    fprintf (f, \"  Same comdat group as: %s\\n\",\n+\t     same_comdat_group->dump_asm_name ());\n   if (next_sharing_asm_name)\n     fprintf (f, \"  next sharing asm name: %i\\n\",\n \t     next_sharing_asm_name->order);"}, {"sha": "6a8a0a4a4273328e0ee3dbd998d6d0b454ef5115", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -5190,11 +5190,8 @@ convert_callers_for_node (struct cgraph_node *node,\n       push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n \n       if (dump_file)\n-\tfprintf (dump_file, \"Adjusting call %s/%i -> %s/%i\\n\",\n-\t\t xstrdup_for_dump (cs->caller->name ()),\n-\t\t cs->caller->order,\n-\t\t xstrdup_for_dump (cs->callee->name ()),\n-\t\t cs->callee->order);\n+\tfprintf (dump_file, \"Adjusting call %s -> %s\\n\",\n+\t\t cs->caller->dump_name (), cs->callee->dump_name ());\n \n       ipa_modify_call_arguments (cs, cs->call_stmt, *adjustments);\n "}, {"sha": "7f1574af70d6ce01d025cfc972448c3318bb2086", "filename": "gcc/value-prof.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464d01188e46ccdb19b4783c5d28ef6bc72d32f9/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=464d01188e46ccdb19b4783c5d28ef6bc72d32f9", "patch": "@@ -1236,34 +1236,29 @@ init_node_map (bool local)\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Local profile-id %i conflict\"\n-\t\t\t   \" with nodes %s/%i %s/%i\\n\",\n+\t\t\t   \" with nodes %s %s\\n\",\n \t\t\t   n->profile_id,\n-\t\t\t   n->name (),\n-\t\t\t   n->order,\n-\t\t\t   (*val)->name (),\n-\t\t\t   (*val)->order);\n+\t\t\t   n->dump_name (),\n+\t\t\t   (*val)->dump_name ());\n \t\tn->profile_id = (n->profile_id + 1) & 0x7fffffff;\n \t      }\n \t  }\n \telse if (!n->profile_id)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file,\n-\t\t       \"Node %s/%i has no profile-id\"\n+\t\t       \"Node %s has no profile-id\"\n \t\t       \" (profile feedback missing?)\\n\",\n-\t\t       n->name (),\n-\t\t       n->order);\n+\t\t       n->dump_name ());\n \t    continue;\n \t  }\n \telse if ((val = cgraph_node_map->get (n->profile_id)))\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file,\n-\t\t       \"Node %s/%i has IP profile-id %i conflict. \"\n+\t\t       \"Node %s has IP profile-id %i conflict. \"\n \t\t       \"Giving up.\\n\",\n-\t\t       n->name (),\n-\t\t       n->order,\n-\t\t       n->profile_id);\n+\t\t       n->dump_name (), n->profile_id);\n \t    *val = NULL;\n \t    continue;\n \t  }"}]}