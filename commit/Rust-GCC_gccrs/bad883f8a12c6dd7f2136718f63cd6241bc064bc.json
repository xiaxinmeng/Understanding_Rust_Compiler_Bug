{"sha": "bad883f8a12c6dd7f2136718f63cd6241bc064bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkODgzZjhhMTJjNmRkN2YyMTM2NzE4ZjYzY2Q2MjQxYmMwNjRiYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-23T17:25:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-12-23T17:25:00Z"}, "message": "pa.c (output_move_double): Correctly identify and handle overlapping moves.\n\n        * pa.c (output_move_double): Correctly identify and handle\n        overlapping moves.\n        * pa.md (movdi patterns): Eliminate earlyclobbers in mem<->gr\n        cases.\n        (movdf patterns): Likewise.\n\nFrom-SVN: r10837", "tree": {"sha": "65ff7dd567205d9727a42906feeaa147b78f26f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ff7dd567205d9727a42906feeaa147b78f26f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bad883f8a12c6dd7f2136718f63cd6241bc064bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad883f8a12c6dd7f2136718f63cd6241bc064bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad883f8a12c6dd7f2136718f63cd6241bc064bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad883f8a12c6dd7f2136718f63cd6241bc064bc/comments", "author": null, "committer": null, "parents": [{"sha": "9151b3bf9265cb1739bf7e9144e7ed5a78ec590a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9151b3bf9265cb1739bf7e9144e7ed5a78ec590a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9151b3bf9265cb1739bf7e9144e7ed5a78ec590a"}], "stats": {"total": 36, "additions": 22, "deletions": 14}, "files": [{"sha": "c6fb1ed43418b7ff4aa87a2338712c9401611f6f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad883f8a12c6dd7f2136718f63cd6241bc064bc/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad883f8a12c6dd7f2136718f63cd6241bc064bc/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=bad883f8a12c6dd7f2136718f63cd6241bc064bc", "patch": "@@ -1373,28 +1373,36 @@ output_move_double (operands)\n   /* If the first move would clobber the source of the second one,\n      do them in the other order.\n \n-     RMS says \"This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.\"\n+     This can happen in two cases:\n \n-     but it happens on the HP-PA when loading parameter registers,\n-     so I am going to define that circumstance, and make it work\n-     as expected.  */\n+\tmem -> register where the first half of the destination register\n+ \tis the same register used in the memory's address.  Reload\n+\tcan create such insns.\n \n-  if (optype0 == REGOP && (optype1 == MEMOP || optype1 == OFFSOP)\n-\t   && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n+\tmem in this case will be either register indirect or register\n+\tindirect plus a valid offset. \n+\n+\tregister -> register move where REGNO(dst) == REGNO(src + 1)\n+\tsomeone (Tim/Tege?) claimed this can happen for parameter loads. \n+\n+     Handle mem -> register case first.  */\n+  if (optype0 == REGOP\n+      && (optype1 == MEMOP || optype1 == OFFSOP)\n+      && refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t    operands[1], 0))\n     {\n-      /* XXX THIS PROBABLY DOESN'T WORK.  */\n       /* Do the late half first.  */\n       if (addreg1)\n \toutput_asm_insn (\"ldo 4(%0),%0\", &addreg1);\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Then clobber.  */\n       if (addreg1)\n \toutput_asm_insn (\"ldo -4(%0),%0\", &addreg1);\n-      /* Then clobber.  */\n       return singlemove_string (operands);\n     }\n \n+  /* Now handle register -> register case.  */\n   if (optype0 == REGOP && optype1 == REGOP\n       && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n     {"}, {"sha": "8b23ea4d9f9a82d2d0f2fead4c8bb62d95c83d28", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad883f8a12c6dd7f2136718f63cd6241bc064bc/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad883f8a12c6dd7f2136718f63cd6241bc064bc/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=bad883f8a12c6dd7f2136718f63cd6241bc064bc", "patch": "@@ -2146,7 +2146,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=f,*r,Q,?o,?Q,f,*&r,*&r\")\n+\t\t\t  \"=f,*r,Q,?o,?Q,f,*r,*r\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n \t\t\t  \"fG,*rG,f,*r,*r,Q,o,Q\"))]\n   \"(register_operand (operands[0], DFmode)\n@@ -2164,7 +2164,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,?o,?Q,&r,&r\")\n+\t\t\t  \"=r,?o,?Q,r,r\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n \t\t\t  \"rG,r,r,o,Q\"))]\n   \"(register_operand (operands[0], DFmode)\n@@ -2375,7 +2375,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,o,Q,&r,&r,&r,f,f,*T\")\n+\t\t\t  \"=r,o,Q,r,r,r,f,f,*T\")\n \t(match_operand:DI 1 \"general_operand\"\n \t\t\t  \"rM,r,r,o,Q,i,fM,*T,f\"))]\n   \"(register_operand (operands[0], DImode)\n@@ -2393,7 +2393,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,o,Q,&r,&r,&r\")\n+\t\t\t  \"=r,o,Q,r,r,r\")\n \t(match_operand:DI 1 \"general_operand\"\n \t\t\t  \"rM,r,r,o,Q,i\"))]\n   \"(register_operand (operands[0], DImode)"}]}