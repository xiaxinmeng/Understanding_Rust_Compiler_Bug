{"sha": "0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQzZDY3NGJjYjE3M2U4ZDY5NDcxNWMxZTRmYTI0OTM3Y2NjYzBmMw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-12-19T06:51:41Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-12-19T06:51:41Z"}, "message": "[PR86153] simplify more overflow tests in VRP\n\nPR 86153 was originally filed when changes to the C++11's\nimplementation of vector resize(size_type) limited inlining that were\nrequired for testsuite/g++.dg/pr83239.C to verify that we did not\nissue an undesired warning.\n\nThat was worked by increasing the limit for inlining, but that in turn\ncaused the C++98 implementation of vector resize, that is\nsignificantly different, to also be fully inlined, and that happened\nto issue the very warnings the test was meant to verify we did NOT\nissue.\n\nThe reason we issued the warnings was that we failed to optimize out\nsome parts of _M_fill_insert, used by the C++98 version of vector\nresize, although the call of _M_fill_insert was guarded by a test that\ncould never pass: test testcase only calls resize when the vector size\nis >= 3, to decrement the size by two.  The limitation we hit in VRP\nwas that the compared values could pass as an overflow test, if the\nvector size was 0 or 1 (we knew it wasn't), but even with dynamic\nranges we failed to decide that the test result could be determined at\ncompile time, even though after the test we introduced ASSERT_EXPRs\nthat required a condition known to be false from earlier ones.\n\nI pondered turning ASSERT_EXPRs that show impossible conditions into\ntraps, to enable subsequent instructions to be optimized, but I ended\nup finding an earlier spot in which an overflow test that would have\nintroduced the impossible ASSERT_EXPR can have its result deduced from\nearlier known ranges and resolved to the other path.\n\nAlthough such overflow tests could be uniformly simplified to compares\nagainst a constant, the original code would only perform such\nsimplifications when the test could be resolved to an equality test\nagainst zero.  I've thus avoided introducing compares against other\nconstants, and instead added code that will only simplify overflow\ntests that weren't simplified before when the condition can be\nevaluated at compile time.\n\n\nfor  gcc/ChangeLog\n\n\tPR testsuite/86153\n\tPR middle-end/83239\n\t* vr-values.c\n\t(vr_values::vrp_evaluate_conditional_warnv_with_ops): Extend\n\tsimplification of overflow tests to cover cases in which we\n\tcan determine the result of the comparison.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR testsuite/86153\n\tPR middle-end/83239\n\t* gcc.dg/vrp-overflow-1.c: New.\n\nFrom-SVN: r267252", "tree": {"sha": "71989c87d7e9b5df8975f2f5b8a4912e7ae3e225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71989c87d7e9b5df8975f2f5b8a4912e7ae3e225"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/comments", "author": null, "committer": null, "parents": [{"sha": "de62200f8374e1137b20ea9c85eb690169f43449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de62200f8374e1137b20ea9c85eb690169f43449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de62200f8374e1137b20ea9c85eb690169f43449"}], "stats": {"total": 197, "additions": 197, "deletions": 0}, "files": [{"sha": "067ff3f0a3b0af2195d3054d3c335193dce56b83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "patch": "@@ -1,3 +1,12 @@\n+2018-12-19  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR testsuite/86153\n+\tPR middle-end/83239\n+\t* vr-values.c\n+\t(vr_values::vrp_evaluate_conditional_warnv_with_ops): Extend\n+\tsimplification of overflow tests to cover cases in which we\n+\tcan determine the result of the comparison.\n+\n 2018-12-19  Bin Cheng  <bin.cheng@linux.alibaba.com>\n \n \t* auto-profile.c (afdo_indirect_call): Skip generating histogram"}, {"sha": "a0d7a499342d9fa57a09817defd5d5fda2967cfb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "patch": "@@ -1,5 +1,9 @@\n 2018-12-19  Alexandre Oliva <aoliva@redhat.com>\n \n+\tPR testsuite/86153\n+\tPR middle-end/83239\n+\t* gcc.dg/vrp-overflow-1.c: New.\n+\n \tPR c++/87012\n \t* g++.dg/cpp0x/pr87012.C: New.\n "}, {"sha": "8e5794c77b6d1091381ac7190d47496fcf818e4a", "filename": "gcc/testsuite/gcc.dg/vrp-overflow-1.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvrp-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvrp-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvrp-overflow-1.c?ref=0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "patch": "@@ -0,0 +1,151 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-forwprop\" } */\n+\n+extern void __attribute__((noreturn)) unreachable (void);\n+\n+int fle22 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i - 2;\n+\n+  if (j == 7) /* A dynamic range excludes a value from j for the rest of f1.  */\n+    return -1;\n+\n+  if (i <= 2) /* This dynamic range cannot be combined or compared with that of j.  */\n+    return 0;\n+\n+  if (i <= j) /* And so we couldn't compute this result.  */\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int fle32 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i - 3;\n+\n+  if (j == 7) /* A dynamic range excludes a value from j for the rest of f1.  */\n+    return -1;\n+\n+  if (i <= 2) /* This dynamic range cannot be combined or compared with that of j.  */\n+    return 0;\n+\n+  if (i <= j) /* And so we couldn't compute this result.  */\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int flt22 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i - 2;\n+\n+  if (j == 7)\n+    return -1;\n+\n+  if (i <= 2)\n+    return 0;\n+\n+  if (i < j)\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int flt32 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i - 3;\n+\n+  if (j == 7)\n+    return -1;\n+\n+  if (i <= 2)\n+    return 0;\n+\n+  if (i < j)\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int fgt22 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i + 2;\n+\n+  if (j == -7)\n+    return -1;\n+\n+  if (i >= -3)\n+    return 0;\n+\n+  if (i > j)\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int fgt32 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i + 3;\n+\n+  if (j == -7)\n+    return -1;\n+\n+  if (i >= -3)\n+    return 0;\n+\n+  if (i > j)\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int fge22 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i + 2;\n+\n+  if (j == -7)\n+    return -1;\n+\n+  if (i >= -3)\n+    return 0;\n+\n+  if (i >= j)\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int fge32 (int a)\n+{\n+  unsigned i = a / 4;\n+  unsigned j = i + 3;\n+\n+  if (j == -7)\n+    return -1;\n+\n+  if (i >= -3)\n+    return 0;\n+\n+  if (i >= j)\n+    unreachable ();\n+\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[]) {\n+  fle22 (argc);\n+  fle32 (argc);\n+  flt22 (argc);\n+  flt32 (argc);\n+  fgt22 (argc);\n+  fgt32 (argc);\n+  fge22 (argc);\n+  fge32 (argc);\n+}"}, {"sha": "d71a703ab55010bd8aff7bf80d814ae975dfeee2", "filename": "gcc/vr-values.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d3d674bcb173e8d694715c1e4fa24937cccc0f3/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=0d3d674bcb173e8d694715c1e4fa24937cccc0f3", "patch": "@@ -2336,6 +2336,39 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n \t  op1 = wide_int_to_tree (TREE_TYPE (op0), 0);\n \t  code = (code == GT_EXPR || code == GE_EXPR) ? EQ_EXPR : NE_EXPR;\n \t}\n+      else\n+\t{\n+\t  value_range vro, vri;\n+\t  if (code == GT_EXPR || code == GE_EXPR)\n+\t    {\n+\t      vro.set (VR_ANTI_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t      vri.set (VR_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t    }\n+\t  else if (code == LT_EXPR || code == LE_EXPR)\n+\t    {\n+\t      vro.set (VR_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t      vri.set (VR_ANTI_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t  value_range *vr0 = get_value_range (op0);\n+\t  /* If vro, the range for OP0 to pass the overflow test, has\n+\t     no intersection with *vr0, OP0's known range, then the\n+\t     overflow test can't pass, so return the node for false.\n+\t     If it is the inverted range, vri, that has no\n+\t     intersection, then the overflow test must pass, so return\n+\t     the node for true.  In other cases, we could proceed with\n+\t     a simplified condition comparing OP0 and X, with LE_EXPR\n+\t     for previously LE_ or LT_EXPR and GT_EXPR otherwise, but\n+\t     the comments next to the enclosing if suggest it's not\n+\t     generally profitable to do so.  */\n+\t  vro.intersect (vr0);\n+\t  if (vro.undefined_p ())\n+\t    return boolean_false_node;\n+\t  vri.intersect (vr0);\n+\t  if (vri.undefined_p ())\n+\t    return boolean_true_node;\n+\t}\n     }\n \n   if ((ret = vrp_evaluate_conditional_warnv_with_ops_using_ranges"}]}