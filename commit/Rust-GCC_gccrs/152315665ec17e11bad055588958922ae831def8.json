{"sha": "152315665ec17e11bad055588958922ae831def8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyMzE1NjY1ZWMxN2UxMWJhZDA1NTU4ODk1ODkyMmFlODMxZGVmOA==", "commit": {"author": {"name": "Christopher D. Rickett", "email": "crickett@lanl.gov", "date": "2007-09-20T11:50:39Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-09-20T11:50:39Z"}, "message": "re PR fortran/33497 (Bind(C): C_LOC rejects interoperable arguments)\n\n2007-09-20  Christopher D. Rickett  <crickett@lanl.gov>\n\n        PR fortran/33497\n        * resolve.c (gfc_iso_c_func_interface): Use information from\n        subcomponent if applicable.\n\n2007-09-20  Christopher D. Rickett  <crickett@lanl.gov>\n\n        PR fortran/33497\n        * gfortran.dg/c_loc_tests_11.f03: New test case.\n\nFrom-SVN: r128620", "tree": {"sha": "3a4bd38fd8a97c258a4bab3eb86c6af211cd4f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a4bd38fd8a97c258a4bab3eb86c6af211cd4f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152315665ec17e11bad055588958922ae831def8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152315665ec17e11bad055588958922ae831def8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152315665ec17e11bad055588958922ae831def8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152315665ec17e11bad055588958922ae831def8/comments", "author": null, "committer": null, "parents": [{"sha": "dcf6c255cac56a748ad8335cb4fc3ecc535251d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf6c255cac56a748ad8335cb4fc3ecc535251d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf6c255cac56a748ad8335cb4fc3ecc535251d2"}], "stats": {"total": 139, "additions": 119, "deletions": 20}, "files": [{"sha": "29d8dd2debc5709f71db96605d5baa72e7e6544e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152315665ec17e11bad055588958922ae831def8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152315665ec17e11bad055588958922ae831def8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=152315665ec17e11bad055588958922ae831def8", "patch": "@@ -1,3 +1,9 @@\n+2007-09-20  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/33497\n+\t* resolve.c (gfc_iso_c_func_interface): Use information from\n+\tsubcomponent if applicable.\n+\n 2007-09-20  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33325"}, {"sha": "1b3aab61373d310b2eab3d6872e3fb62de8a431f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 59, "deletions": 20, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152315665ec17e11bad055588958922ae831def8/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152315665ec17e11bad055588958922ae831def8/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=152315665ec17e11bad055588958922ae831def8", "patch": "@@ -1754,6 +1754,9 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n   int optional_arg = 0;\n   try retval = SUCCESS;\n   gfc_symbol *args_sym;\n+  gfc_typespec *arg_ts;\n+  gfc_ref *parent_ref;\n+  gfc_ref *curr_ref;\n \n   if (args->expr->expr_type == EXPR_CONSTANT\n       || args->expr->expr_type == EXPR_OP\n@@ -1765,7 +1768,38 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n     }\n \n   args_sym = args->expr->symtree->n.sym;\n-   \n+\n+  /* The typespec for the actual arg should be that stored in the expr\n+     and not necessarily that of the expr symbol (args_sym), because\n+     the actual expression could be a part-ref of the expr symbol.  */\n+  arg_ts = &(args->expr->ts);\n+\n+  /* Get the parent reference (if any) for the expression.  This happens for\n+     cases such as a%b%c.  */\n+  parent_ref = args->expr->ref;\n+  curr_ref = NULL;\n+  if (parent_ref != NULL)\n+    {\n+      curr_ref = parent_ref->next;\n+      while (curr_ref != NULL && curr_ref->next != NULL)\n+        {\n+\t  parent_ref = curr_ref;\n+\t  curr_ref = curr_ref->next;\n+\t}\n+    }\n+\n+  /* If curr_ref is non-NULL, we had a part-ref expression.  If the curr_ref\n+     is for a REF_COMPONENT, then we need to use it as the parent_ref for\n+     the name, etc.  Otherwise, the current parent_ref should be correct.  */\n+  if (curr_ref != NULL && curr_ref->type == REF_COMPONENT)\n+    parent_ref = curr_ref;\n+\n+  if (parent_ref == args->expr->ref)\n+    parent_ref = NULL;\n+  else if (parent_ref != NULL && parent_ref->type != REF_COMPONENT)\n+    gfc_internal_error (\"Unexpected expression reference type in \"\n+\t\t\t\"gfc_iso_c_func_interface\");\n+\n   if (sym->intmod_sym_id == ISOCBINDING_ASSOCIATED)\n     {\n       /* If the user gave two args then they are providing something for\n@@ -1807,21 +1841,24 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n       else if (sym->intmod_sym_id == ISOCBINDING_LOC)\n         {\n           /* Make sure we have either the target or pointer attribute.  */\n-          if (!(args->expr->symtree->n.sym->attr.target)\n-\t      && !(args->expr->symtree->n.sym->attr.pointer))\n+\t  if (!(args_sym->attr.target)\n+\t      && !(args_sym->attr.pointer)\n+\t      && (parent_ref == NULL ||\n+\t\t  !parent_ref->u.c.component->pointer))\n             {\n               gfc_error_now (\"Parameter '%s' to '%s' at %L must be either \"\n                              \"a TARGET or an associated pointer\",\n-                             args->expr->symtree->n.sym->name,\n+                             args_sym->name,\n                              sym->name, &(args->expr->where));\n               retval = FAILURE;\n             }\n \n           /* See if we have interoperable type and type param.  */\n-          if (verify_c_interop (&(args->expr->symtree->n.sym->ts),\n-                                args->expr->symtree->n.sym->name,\n+          if (verify_c_interop (arg_ts,\n+\t\t\t\t(parent_ref ? parent_ref->u.c.component->name \n+\t\t\t\t : args_sym->name), \n                                 &(args->expr->where)) == SUCCESS\n-              || gfc_check_any_c_kind (&(args_sym->ts)) == SUCCESS)\n+              || gfc_check_any_c_kind (arg_ts) == SUCCESS)\n             {\n               if (args_sym->attr.target == 1)\n                 {\n@@ -1875,13 +1912,13 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                       /* Make sure it's not a character string.  Arrays of\n                          any type should be ok if the variable is of a C\n                          interoperable type.  */\n-\t\t      if (args_sym->ts.type == BT_CHARACTER)\n-\t\t\tif (args_sym->ts.cl != NULL\n-\t\t\t    && (args_sym->ts.cl->length == NULL\n-\t\t\t\t|| args_sym->ts.cl->length->expr_type\n+\t\t      if (arg_ts->type == BT_CHARACTER)\n+\t\t\tif (arg_ts->cl != NULL\n+\t\t\t    && (arg_ts->cl->length == NULL\n+\t\t\t\t|| arg_ts->cl->length->expr_type\n \t\t\t\t   != EXPR_CONSTANT\n \t\t\t\t|| mpz_cmp_si\n-\t\t\t\t    (args_sym->ts.cl->length->value.integer, 1)\n+\t\t\t\t    (arg_ts->cl->length->value.integer, 1)\n \t\t\t\t   != 0)\n \t\t\t    && is_scalar_expr_ptr (args->expr) != SUCCESS)\n \t\t\t  {\n@@ -1893,8 +1930,10 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \t\t\t  }\n                     }\n                 }\n-              else if (args_sym->attr.pointer == 1\n-                       && is_scalar_expr_ptr (args->expr) != SUCCESS)\n+              else if ((args_sym->attr.pointer == 1 ||\n+\t\t\t(parent_ref != NULL \n+\t\t\t && parent_ref->u.c.component->pointer))\n+\t\t       && is_scalar_expr_ptr (args->expr) != SUCCESS)\n                 {\n                   /* Case 1c, section 15.1.2.5, J3/04-007: an associated\n                      scalar pointer.  */\n@@ -1911,15 +1950,15 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                  with no length type parameters.  It still must have either\n                  the pointer or target attribute, and it can be\n                  allocatable (but must be allocated when c_loc is called).  */\n-              if (args_sym->attr.dimension != 0\n+              if (args->expr->rank != 0 \n                   && is_scalar_expr_ptr (args->expr) != SUCCESS)\n                 {\n                   gfc_error_now (\"Parameter '%s' to '%s' at %L must be a \"\n                                  \"scalar\", args_sym->name, sym->name,\n                                  &(args->expr->where));\n                   retval = FAILURE;\n                 }\n-              else if (args_sym->ts.type == BT_CHARACTER \n+              else if (arg_ts->type == BT_CHARACTER \n                        && is_scalar_expr_ptr (args->expr) != SUCCESS)\n                 {\n                   gfc_error_now (\"CHARACTER argument '%s' to '%s' at \"\n@@ -1932,21 +1971,21 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n         }\n       else if (sym->intmod_sym_id == ISOCBINDING_FUNLOC)\n         {\n-          if (args->expr->symtree->n.sym->attr.flavor != FL_PROCEDURE)\n+          if (args_sym->attr.flavor != FL_PROCEDURE)\n             {\n               /* TODO: Update this error message to allow for procedure\n                  pointers once they are implemented.  */\n               gfc_error_now (\"Parameter '%s' to '%s' at %L must be a \"\n                              \"procedure\",\n-                             args->expr->symtree->n.sym->name, sym->name,\n+                             args_sym->name, sym->name,\n                              &(args->expr->where));\n               retval = FAILURE;\n             }\n-\t  else if (args->expr->symtree->n.sym->attr.is_bind_c != 1)\n+\t  else if (args_sym->attr.is_bind_c != 1)\n \t    {\n \t      gfc_error_now (\"Parameter '%s' to '%s' at %L must be \"\n \t\t\t     \"BIND(C)\",\n-\t\t\t     args->expr->symtree->n.sym->name, sym->name,\n+\t\t\t     args_sym->name, sym->name,\n \t\t\t     &(args->expr->where));\n \t      retval = FAILURE;\n \t    }"}, {"sha": "52e2cdf778a6268f6aa739181230312ef044e5be", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152315665ec17e11bad055588958922ae831def8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152315665ec17e11bad055588958922ae831def8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=152315665ec17e11bad055588958922ae831def8", "patch": "@@ -1,3 +1,8 @@\n+2007-09-20  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/33497\n+\t* gfortran.dg/c_loc_tests_11.f03: New test case.\n+\n 2007-09-20  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/33459"}, {"sha": "197666d3091fb9ffea741984675b7ce8514ed798", "filename": "gcc/testsuite/gfortran.dg/c_loc_tests_11.f03", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152315665ec17e11bad055588958922ae831def8/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_11.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152315665ec17e11bad055588958922ae831def8/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_11.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_loc_tests_11.f03?ref=152315665ec17e11bad055588958922ae831def8", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+! Test argument checking for C_LOC with subcomponent parameters.\n+module c_vhandle_mod\n+  use iso_c_binding\n+  \n+  type double_vector_item\n+    real(kind(1.d0)), allocatable :: v(:)\n+  end type double_vector_item\n+  type(double_vector_item), allocatable, target :: dbv_pool(:)\n+  real(kind(1.d0)), allocatable, target :: vv(:)\n+\n+  type foo\n+     integer :: i\n+  end type foo\n+  type foo_item\n+     type(foo), pointer  :: v => null()\n+  end type foo_item\n+  type(foo_item), allocatable :: foo_pool(:)\n+\n+  type foo_item2\n+     type(foo), pointer  :: v(:) => null()\n+  end type foo_item2\n+  type(foo_item2), allocatable :: foo_pool2(:)\n+\n+\n+contains \n+\n+  type(c_ptr) function get_double_vector_address(handle)\n+    integer(c_int), intent(in) :: handle\n+    \n+    if (.true.) then   ! The ultimate component is an allocatable target \n+      get_double_vector_address = c_loc(dbv_pool(handle)%v)\n+    else\n+      get_double_vector_address = c_loc(vv)\n+    endif\n+    \n+  end function get_double_vector_address\n+\n+\n+  type(c_ptr) function get_foo_address(handle)\n+    integer(c_int), intent(in) :: handle    \n+    get_foo_address = c_loc(foo_pool(handle)%v)    \n+\n+    get_foo_address = c_loc(foo_pool2(handle)%v) ! { dg-error \"must be a scalar\" } \n+  end function get_foo_address\n+\n+    \n+end module c_vhandle_mod\n+"}]}