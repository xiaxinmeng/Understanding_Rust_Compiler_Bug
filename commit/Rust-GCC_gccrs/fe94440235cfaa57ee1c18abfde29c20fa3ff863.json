{"sha": "fe94440235cfaa57ee1c18abfde29c20fa3ff863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5NDQ0MDIzNWNmYWE1N2VlMWMxOGFiZmRlMjljMjBmYTNmZjg2Mw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-18T20:19:05Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-10-18T20:19:05Z"}, "message": "re PR target/82580 (Optimize comparisons for __int128 on x86-64)\n\n\tPR target/82580\n\t* config/i386/i386-modes.def (CCGZ): New CC mode.\n\t* config/i386/i386.md (sub<mode>3_carry_ccgz): New insn pattern.\n\t* config/i386/predicates.md (ix86_comparison_operator):\n\tHandle CCGZmode.\n\t* config/i386/i386.c (ix86_expand_branch) <case E_TImode>:\n\tEmulate LE, LEU, GT, GTU, LT, LTU, GE and GEU double-word comparisons\n\twith double-word subtraction.\n\t(put_condition_code): Handle CCGZmode.\n\ntestsuite/ChangeLog:\n\n\tPR target/82580\n\t* gcc.target/i386/pr82580.c: New test.\n\nFrom-SVN: r253867", "tree": {"sha": "71539ec766a5bfb60fbce3e1155fdd91d1dc7dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71539ec766a5bfb60fbce3e1155fdd91d1dc7dfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe94440235cfaa57ee1c18abfde29c20fa3ff863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe94440235cfaa57ee1c18abfde29c20fa3ff863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe94440235cfaa57ee1c18abfde29c20fa3ff863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe94440235cfaa57ee1c18abfde29c20fa3ff863/comments", "author": null, "committer": null, "parents": [{"sha": "e61a4f52126624a6fdd0c63e9f39b53095190a77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61a4f52126624a6fdd0c63e9f39b53095190a77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61a4f52126624a6fdd0c63e9f39b53095190a77"}], "stats": {"total": 159, "additions": 145, "deletions": 14}, "files": [{"sha": "9ddb3fc5724af87459db6e5276e19812bad7ef31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -1,3 +1,15 @@\n+2017-10-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/82580\n+\t* config/i386/i386-modes.def (CCGZ): New CC mode.\n+\t* config/i386/i386.md (sub<mode>3_carry_ccgz): New insn pattern.\n+\t* config/i386/predicates.md (ix86_comparison_operator):\n+\tHandle CCGZmode.\n+\t* config/i386/i386.c (ix86_expand_branch) <case E_TImode>:\n+\tEmulate LE, LEU, GT, GTU, LT, LTU, GE and GEU double-word comparisons\n+\twith double-word subtraction.\n+\t(put_condition_code): Handle CCGZmode.\n+\n 2017-10-18  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* wide-int.cc (debug) [const wide_int &]: New.\n@@ -195,8 +207,8 @@\n 2017-10-17  Qing Zhao <qing.zhao@oracle.com>\n \t    Wilco Dijkstra <wilco.dijkstra@arm.com>\n \n-        * builtins.c (expand_builtin_update_setjmp_buf): Add a\n-        converstion to Pmode from the buf_addr.\n+\t* builtins.c (expand_builtin_update_setjmp_buf): Add a\n+\tconverstion to Pmode from the buf_addr.\n \n 2017-10-17  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "16bc1d8b71a878968f03a21da15131d58ea5073e", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -39,19 +39,22 @@ ADJUST_ALIGNMENT (XF, TARGET_128BIT_LONG_DOUBLE ? 16 : 4);\n    For the i386, we need separate modes when floating-point\n    equality comparisons are being done.\n \n-   Add CCNO to indicate comparisons against zero that requires\n+   Add CCNO to indicate comparisons against zero that require\n    Overflow flag to be unset.  Sign bit test is used instead and\n    thus can be used to form \"a&b>0\" type of tests.\n \n-   Add CCGC to indicate comparisons against zero that allows\n+   Add CCGC to indicate comparisons against zero that allow\n    unspecified garbage in the Carry flag.  This mode is used\n    by inc/dec instructions.\n \n-   Add CCGOC to indicate comparisons against zero that allows\n+   Add CCGOC to indicate comparisons against zero that allow\n    unspecified garbage in the Carry and Overflow flag. This\n    mode is used to simulate comparisons of (a-b) and (a+b)\n    against zero using sub/cmp/add operations.\n \n+   Add CCGZ to indicate comparisons that allow unspecified garbage\n+   in the Zero flag.  This mode is used in double-word comparisons.\n+\n    Add CCA to indicate that only the Above flag is valid.\n    Add CCC to indicate that only the Carry flag is valid.\n    Add CCO to indicate that only the Overflow flag is valid.\n@@ -62,6 +65,7 @@ ADJUST_ALIGNMENT (XF, TARGET_128BIT_LONG_DOUBLE ? 16 : 4);\n CC_MODE (CCGC);\n CC_MODE (CCGOC);\n CC_MODE (CCNO);\n+CC_MODE (CCGZ);\n CC_MODE (CCA);\n CC_MODE (CCC);\n CC_MODE (CCO);"}, {"sha": "16cc7dbaba9df9c881319393b168764b4a72e09f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -16732,6 +16732,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n   switch (code)\n     {\n     case EQ:\n+      gcc_assert (mode != CCGZmode);\n       switch (mode)\n \t{\n \tcase E_CCAmode:\n@@ -16755,6 +16756,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n \t}\n       break;\n     case NE:\n+      gcc_assert (mode != CCGZmode);\n       switch (mode)\n \t{\n \tcase E_CCAmode:\n@@ -16799,6 +16801,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n \n \tcase E_CCmode:\n \tcase E_CCGCmode:\n+\tcase E_CCGZmode:\n \t  suffix = \"l\";\n \t  break;\n \n@@ -16807,7 +16810,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n \t}\n       break;\n     case LTU:\n-      if (mode == CCmode)\n+      if (mode == CCmode || mode == CCGZmode)\n \tsuffix = \"b\";\n       else if (mode == CCCmode)\n \tsuffix = fp ? \"b\" : \"c\";\n@@ -16824,6 +16827,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n \n \tcase E_CCmode:\n \tcase E_CCGCmode:\n+\tcase E_CCGZmode:\n \t  suffix = \"ge\";\n \t  break;\n \n@@ -16832,7 +16836,7 @@ put_condition_code (enum rtx_code code, machine_mode mode, bool reverse,\n \t}\n       break;\n     case GEU:\n-      if (mode == CCmode)\n+      if (mode == CCmode || mode == CCGZmode)\n \tsuffix = \"nb\";\n       else if (mode == CCCmode)\n \tsuffix = fp ? \"nb\" : \"nc\";\n@@ -18887,7 +18891,7 @@ output_fp_compare (rtx_insn *insn, rtx *operands,\n \n   static char buf[40];\n   const char *p, *r;\n- \n+\n   gcc_assert (STACK_TOP_P (xops[0]));\n \n   stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG);\n@@ -21469,6 +21473,8 @@ ix86_match_ccmode (rtx insn, machine_mode req_mode)\n     case E_CCZmode:\n       break;\n \n+    case E_CCGZmode:\n+\n     case E_CCAmode:\n     case E_CCCmode:\n     case E_CCOmode:\n@@ -22177,6 +22183,52 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n \t      break;\n \t    }\n \n+\t/* Emulate comparisons that do not depend on Zero flag with\n+\t   double-word subtraction.  Note that only Overflow, Sign\n+\t   and Carry flags are valid, so swap arguments and condition\n+\t   of comparisons that would otherwise test Zero flag.  */\n+\n+\tswitch (code)\n+\t  {\n+\t  case LE: case LEU: case GT: case GTU:\n+\t    std::swap (lo[0], lo[1]);\n+\t    std::swap (hi[0], hi[1]);\n+\t    code = swap_condition (code);\n+\t    /* FALLTHRU */\n+\n+\t  case LT: case LTU: case GE: case GEU:\n+\t    {\n+\t      rtx (*cmp_insn) (rtx, rtx);\n+\t      rtx (*sbb_insn) (rtx, rtx, rtx);\n+\n+\t      if (TARGET_64BIT)\n+\t\tcmp_insn = gen_cmpdi_1, sbb_insn = gen_subdi3_carry_ccgz;\n+\t      else\n+\t\tcmp_insn = gen_cmpsi_1, sbb_insn = gen_subsi3_carry_ccgz;\n+\n+\t      if (!nonimmediate_operand (lo[0], submode))\n+\t\tlo[0] = force_reg (submode, lo[0]);\n+\t      if (!x86_64_general_operand (lo[1], submode))\n+\t\tlo[1] = force_reg (submode, lo[1]);\n+\n+\t      if (!register_operand (hi[0], submode))\n+\t\thi[0] = force_reg (submode, hi[0]);\n+\t      if (!x86_64_general_operand (hi[1], submode))\n+\t\thi[1] = force_reg (submode, hi[1]);\n+\n+\t      emit_insn (cmp_insn (lo[0], lo[1]));\n+\t      emit_insn (sbb_insn (gen_rtx_SCRATCH (submode), hi[0], hi[1]));\n+\n+\t      tmp = gen_rtx_REG (CCGZmode, FLAGS_REG);\n+\n+\t      ix86_expand_branch (code, tmp, const0_rtx, label);\n+\t      return;\n+\t    }\n+\n+\t  default:\n+\t    break;\n+\t  }\n+\n \t/* Otherwise, we need two or three jumps.  */\n \n \tlabel2 = gen_label_rtx ();"}, {"sha": "57a90dbe041dffb03aa57917ae399643d9f4b1bc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -6871,6 +6871,19 @@\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn \"sub<mode>3_carry_ccgz\"\n+  [(set (reg:CCGZ FLAGS_REG)\n+\t(compare:CCGZ\n+\t  (match_operand:DWIH 1 \"register_operand\" \"0\")\n+\t  (plus:DWIH\n+\t    (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t    (match_operand:DWIH 2 \"x86_64_general_operand\" \"rme\"))))\n+   (clobber (match_scratch:DWIH 0 \"=r\"))]\n+  \"\"\n+  \"sbb{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn \"subborrow<mode>\"\n   [(set (reg:CCC FLAGS_REG)\n \t(compare:CCC"}, {"sha": "4f3f1560f458e6837b6dbb6c8bba788dbf46c22f", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -1329,14 +1329,20 @@\n   switch (code)\n     {\n     case EQ: case NE:\n+      if (inmode == CCGZmode)\n+\treturn false;\n       return true;\n-    case LT: case GE:\n+    case GE: case LT:\n       if (inmode == CCmode || inmode == CCGCmode\n-\t  || inmode == CCGOCmode || inmode == CCNOmode)\n+\t  || inmode == CCGOCmode || inmode == CCNOmode || inmode == CCGZmode)\n \treturn true;\n       return false;\n-    case LTU: case GTU: case LEU: case GEU:\n-      if (inmode == CCmode || inmode == CCCmode)\n+    case GEU: case LTU:\n+      if (inmode == CCGZmode)\n+\treturn true;\n+      /* FALLTHRU */\n+    case GTU: case LEU:\n+      if (inmode == CCmode || inmode == CCCmode || inmode == CCGZmode)\n \treturn true;\n       return false;\n     case ORDERED: case UNORDERED:"}, {"sha": "c44b420782f18575c3ec6b966788b1a3c7b4a4db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -1,3 +1,9 @@\n+2017-10-18  Uros Bizjak  <ubizjak@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/82580\n+\t* gcc.target/i386/pr82580.c: New test.\n+\n 2017-10-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/82233\n@@ -91,8 +97,8 @@\n 2017-10-17  Qing Zhao <qing.zhao@oracle.com>\n \t    Wilco Dijkstra <wilco.dijkstra@arm.com>\n \n-        PR middle-end/80295\n-        * gcc.target/aarch64/pr80295.c: New test.\n+\tPR middle-end/80295\n+\t* gcc.target/aarch64/pr80295.c: New test.\n \n 2017-10-17  Richard Biener  <rguenther@suse.de>\n "}, {"sha": "ce4bf9230a8c3380c522007379f998545309b377", "filename": "gcc/testsuite/gcc.target/i386/pr82580.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82580.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe94440235cfaa57ee1c18abfde29c20fa3ff863/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82580.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82580.c?ref=fe94440235cfaa57ee1c18abfde29c20fa3ff863", "patch": "@@ -0,0 +1,38 @@\n+/* PR target/82580 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef unsigned __int128 U;\n+typedef signed __int128 S;\n+#else\n+typedef unsigned long long U;\n+typedef signed long long S;\n+#endif\n+void bar (void);\n+int f0 (U x, U y) { return x == y; }\n+int f1 (U x, U y) { return x != y; }\n+int f2 (U x, U y) { return x > y; }\n+int f3 (U x, U y) { return x >= y; }\n+int f4 (U x, U y) { return x < y; }\n+int f5 (U x, U y) { return x <= y; }\n+int f6 (S x, S y) { return x == y; }\n+int f7 (S x, S y) { return x != y; }\n+int f8 (S x, S y) { return x > y; }\n+int f9 (S x, S y) { return x >= y; }\n+int f10 (S x, S y) { return x < y; }\n+int f11 (S x, S y) { return x <= y; }\n+void f12 (U x, U y) { if (x == y) bar (); }\n+void f13 (U x, U y) { if (x != y) bar (); }\n+void f14 (U x, U y) { if (x > y) bar (); }\n+void f15 (U x, U y) { if (x >= y) bar (); }\n+void f16 (U x, U y) { if (x < y) bar (); }\n+void f17 (U x, U y) { if (x <= y) bar (); }\n+void f18 (S x, S y) { if (x == y) bar (); }\n+void f19 (S x, S y) { if (x != y) bar (); }\n+void f20 (S x, S y) { if (x > y) bar (); }\n+void f21 (S x, S y) { if (x >= y) bar (); }\n+void f22 (S x, S y) { if (x < y) bar (); }\n+void f23 (S x, S y) { if (x <= y) bar (); }\n+\n+/* { dg-final { scan-assembler-times \"sbb\" 16 } } */"}]}