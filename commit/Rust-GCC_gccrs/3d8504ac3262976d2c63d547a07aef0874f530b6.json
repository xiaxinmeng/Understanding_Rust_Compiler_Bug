{"sha": "3d8504ac3262976d2c63d547a07aef0874f530b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q4NTA0YWMzMjYyOTc2ZDJjNjNkNTQ3YTA3YWVmMDg3NGY1MzBiNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-19T22:01:17Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-19T22:01:17Z"}, "message": "gcse.c (want_to_gcse_p): On STACK_REGS targets...\n\n\n\t* gcse.c (want_to_gcse_p): On STACK_REGS targets, look through\n\tconstant pool references to identify stack mode constants.\n\t* rtlanal.c (constant_pool_constant_p): New predicate to check\n\twhether operand is a floating point constant in the pool.\n\t* rtl.h (constant_pool_constant_p): Prototype here.\n\t* loop.c (scan_loop): Avoid hoisting constants from the constant\n\tpool on STACK_REGS targets.\n\t(load_mems): Likewise.\n\t* loop-invariant.c (get_inv_cost): Make hoisting constant pool\n\tloads into x87 registers expensive in terms of register pressure.\n\n\nCo-Authored-By: Steven Bosscher <stevenb.gcc@gmail.com>\n\nFrom-SVN: r111283", "tree": {"sha": "548133d8c92115bf18fa7c2d6f3e7800dbd456bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/548133d8c92115bf18fa7c2d6f3e7800dbd456bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d8504ac3262976d2c63d547a07aef0874f530b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8504ac3262976d2c63d547a07aef0874f530b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d8504ac3262976d2c63d547a07aef0874f530b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8504ac3262976d2c63d547a07aef0874f530b6/comments", "author": null, "committer": null, "parents": [{"sha": "c2a8530e21c7a3bc4824d00e0bb8ff39009da43a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a8530e21c7a3bc4824d00e0bb8ff39009da43a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a8530e21c7a3bc4824d00e0bb8ff39009da43a"}], "stats": {"total": 71, "additions": 71, "deletions": 0}, "files": [{"sha": "988eed4045a276ac9c959e06694b1abcbbb4b244", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d8504ac3262976d2c63d547a07aef0874f530b6", "patch": "@@ -1,3 +1,17 @@\n+2006-02-19  Roger Sayle  <roger@eyesopen.com>\n+\t    Steven Bosscher  <stevenb.gcc@gmail.com>\n+\n+\t* gcse.c (want_to_gcse_p): On STACK_REGS targets, look through\n+\tconstant pool references to identify stack mode constants.\n+\t* rtlanal.c (constant_pool_constant_p): New predicate to check\n+\twhether operand is a floating point constant in the pool.\n+\t* rtl.h (constant_pool_constant_p): Prototype here.\n+\t* loop.c (scan_loop): Avoid hoisting constants from the constant\n+\tpool on STACK_REGS targets.\n+\t(load_mems): Likewise.\n+\t* loop-invariant.c (get_inv_cost): Make hoisting constant pool\n+\tloads into x87 registers expensive in terms of register pressure.\n+\n 2006-02-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* gthr-posix.h: On Tru64, map __gthr_foo as a weak reference to"}, {"sha": "4270737377980db321af495b7350d67050d7df7a", "filename": "gcc/gcse.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3d8504ac3262976d2c63d547a07aef0874f530b6", "patch": "@@ -1170,6 +1170,14 @@ static basic_block current_bb;\n static int\n want_to_gcse_p (rtx x)\n {\n+#ifdef STACK_REGS\n+  /* On register stack architectures, don't GCSE constants from the\n+     constant pool, as the benefits are often swamped by the overhead\n+     of shuffling the register stack between basic blocks.  */\n+  if (IS_STACK_MODE (GET_MODE (x)))\n+    x = avoid_constant_pool_reference (x);\n+#endif\n+\n   switch (GET_CODE (x))\n     {\n     case REG:"}, {"sha": "3f8f6e34848a1d52be455a61c2d974cf80f0a8e3", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=3d8504ac3262976d2c63d547a07aef0874f530b6", "patch": "@@ -932,6 +932,32 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   (*regs_needed)++;\n   (*comp_cost) += inv->cost;\n \n+#ifdef STACK_REGS\n+  {\n+    /* Hoisting constant pool constants into stack regs may cost more than\n+       just single register.  On x87, the balance is affected both by the\n+       small number of FP registers, and by its register stack organisation,\n+       that forces us to add compensation code in and around the loop to\n+       shuffle the operands to the top of stack before use, and pop them\n+       from the stack after the loop finishes.\n+\n+       To model this effect, we increase the number of registers needed for\n+       stack registers by two: one register push, and one register pop.\n+       This usually has the effect that FP constant loads from the constant\n+       pool are not moved out of the loop.\n+\n+       Note that this also means that dependent invariants can not be moved.\n+       However, the primary purpose of this pass is to move loop invariant\n+       address arithmetic out of loops, and address arithmetic that depends\n+       on floating point constants is unlikely to ever occur.  */\n+    rtx set = single_set (inv->insn);\n+    if (set\n+       && IS_STACK_MODE (GET_MODE (SET_SRC (set)))\n+       && constant_pool_constant_p (SET_SRC (set)))\n+      (*regs_needed) += 2;\n+  }\n+#endif\n+\n   EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno, bi)\n     {\n       dep = VEC_index (invariant_p, invariants, depno);"}, {"sha": "dc9d3a03c1b6160ea6098725dbcc7a58ae356645", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=3d8504ac3262976d2c63d547a07aef0874f530b6", "patch": "@@ -1222,6 +1222,12 @@ scan_loop (struct loop *loop, int flags)\n \t      if (GET_MODE_CLASS (GET_MODE (SET_DEST (set))) == MODE_CC\n \t\t  && CONSTANT_P (src))\n \t\t;\n+#ifdef STACK_REGS\n+\t      /* Don't hoist constant pool constants into stack regs. */\n+\t      else if (IS_STACK_MODE (GET_MODE (SET_SRC (set)))\n+\t\t       && constant_pool_constant_p (SET_SRC (set)))\n+\t\t;\n+#endif\n \t      /* Don't try to optimize a register that was made\n \t\t by loop-optimization for an inner loop.\n \t\t We don't know its life-span, so we can't compute\n@@ -10823,6 +10829,13 @@ load_mems (const struct loop *loop)\n \t  && SCALAR_FLOAT_MODE_P (GET_MODE (mem)))\n \tloop_info->mems[i].optimize = 0;\n \n+#ifdef STACK_REGS\n+      /* Don't hoist constant pool constants into stack registers.  */\n+      if (IS_STACK_MODE (GET_MODE (mem))\n+          && constant_pool_constant_p (mem))\n+\tloop_info->mems[i].optimize = 0;\n+#endif\n+\n       /* If this MEM is written to, we must be sure that there\n \t are no reads from another MEM that aliases this one.  */\n       if (loop_info->mems[i].optimize && written)"}, {"sha": "e35c8058f7e2b9849bf0f27fded78cc86e40db07", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3d8504ac3262976d2c63d547a07aef0874f530b6", "patch": "@@ -1046,6 +1046,7 @@ extern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n extern unsigned int subreg_regno (rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (rtx, enum machine_mode);\n extern unsigned int num_sign_bit_copies (rtx, enum machine_mode);\n+extern bool constant_pool_constant_p (rtx);\n \n \n /* 1 if RTX is a subreg containing a reg that is already known to be"}, {"sha": "7c7731b7bb72388d801d8de92a012d2a60b63d52", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d8504ac3262976d2c63d547a07aef0874f530b6/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=3d8504ac3262976d2c63d547a07aef0874f530b6", "patch": "@@ -4800,3 +4800,12 @@ init_rtlanal (void)\n       non_rtx_starting_operands[i] = first ? first - format : -1;\n     }\n }\n+\f\n+/* Check whether this is a constant pool constant.  */\n+bool\n+constant_pool_constant_p (rtx x)\n+{\n+  x = avoid_constant_pool_reference (x);\n+  return GET_CODE (x) == CONST_DOUBLE;\n+}\n+"}]}