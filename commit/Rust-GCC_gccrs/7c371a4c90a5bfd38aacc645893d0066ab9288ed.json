{"sha": "7c371a4c90a5bfd38aacc645893d0066ab9288ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzNzFhNGM5MGE1YmZkMzhhYWNjNjQ1ODkzZDAwNjZhYjkyODhlZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2014-09-04T16:38:04Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2014-09-04T16:38:04Z"}, "message": "dwarf2out.c (struct die_struct): Add dumped_early field.\n\n\t* dwarf2out.c (struct die_struct): Add dumped_early field.\n\t(reparent_child): New.\n\t(splice_child_die): Use reparent_child.\n\t(gen_subprogram_die): Do not regenerate parameters if previously\n\tdumped.\n\t(gen_variable_die): Fix parent of decls that have been dumped\n\tearly to reflect correct context.\n\tDo not regenerate decls if previously dumped.\n\t(dwarf2out_decl): Add return value.\n\t(dwarf2out_early_decl): Set dumped_early bit.\n\nFrom-SVN: r214909", "tree": {"sha": "0754f0eba4ee43741814a567c96a8d6b96f4a451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0754f0eba4ee43741814a567c96a8d6b96f4a451"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c371a4c90a5bfd38aacc645893d0066ab9288ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c371a4c90a5bfd38aacc645893d0066ab9288ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c371a4c90a5bfd38aacc645893d0066ab9288ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c371a4c90a5bfd38aacc645893d0066ab9288ed/comments", "author": null, "committer": null, "parents": [{"sha": "b7af73a7192c92c06190486950ee142ad73781d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7af73a7192c92c06190486950ee142ad73781d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7af73a7192c92c06190486950ee142ad73781d1"}], "stats": {"total": 103, "additions": 64, "deletions": 39}, "files": [{"sha": "c4952e7f132896b055e2d9fe86d233514a6f0362", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c371a4c90a5bfd38aacc645893d0066ab9288ed/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c371a4c90a5bfd38aacc645893d0066ab9288ed/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7c371a4c90a5bfd38aacc645893d0066ab9288ed", "patch": "@@ -103,7 +103,7 @@ along with GCC; see the file COPYING3.  If not see\n static void dwarf2out_source_line (unsigned int, const char *, int, bool);\n static rtx_insn *last_var_location_insn;\n static rtx_insn *cached_next_real_insn;\n-static void dwarf2out_decl (tree);\n+static dw_die_ref dwarf2out_decl (tree);\n \n #ifdef VMS_DEBUGGING_INFO\n int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n@@ -2609,6 +2609,8 @@ typedef struct GTY((chain_circular (\"%h.die_sib\"))) die_struct {\n   /* Die is used and must not be pruned as unused.  */\n   BOOL_BITFIELD die_perennial_p : 1;\n   BOOL_BITFIELD comdat_type_p : 1; /* DIE has a type signature */\n+  /* Die was generated early via dwarf2out_early_decl.  */\n+  BOOL_BITFIELD dumped_early : 1;\n   /* Lots of spare bits.  */\n }\n die_node;\n@@ -4809,15 +4811,28 @@ add_child_die (dw_die_ref die, dw_die_ref child_die)\n   die->die_child = child_die;\n }\n \n+/* Unassociate CHILD from its parent, and make its parent be\n+   NEW_PARENT.  */\n+\n+static void\n+reparent_child (dw_die_ref child, dw_die_ref new_parent)\n+{\n+  for (dw_die_ref p = child->die_parent->die_child; ; p = p->die_sib)\n+    if (p->die_sib == child)\n+      {\n+\tremove_child_with_prev (child, p);\n+\tbreak;\n+      }\n+  add_child_die (new_parent, child);\n+}\n+\n /* Move CHILD, which must be a child of PARENT or the DIE for which PARENT\n    is the specification, to the end of PARENT's list of children.\n    This is done by removing and re-adding it.  */\n \n static void\n splice_child_die (dw_die_ref parent, dw_die_ref child)\n {\n-  dw_die_ref p;\n-\n   /* We want the declaration DIE from inside the class, not the\n      specification DIE at toplevel.  */\n   if (child->die_parent != parent)\n@@ -4832,14 +4847,7 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n \t      || (child->die_parent\n \t\t  == get_AT_ref (parent, DW_AT_specification)));\n \n-  for (p = child->die_parent->die_child; ; p = p->die_sib)\n-    if (p->die_sib == child)\n-      {\n-\tremove_child_with_prev (child, p);\n-\tbreak;\n-      }\n-\n-  add_child_die (parent, child);\n+  reparent_child (child, parent);\n }\n \n /* Return a pointer to a newly created DIE node.  */\n@@ -18290,16 +18298,17 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  /* ??? Hmmm, early dwarf generation happened earlier, so no\n \t     sense in removing the parameters.  Let's keep them and\n \t     augment them with location information later.  */\n-#if 0\n-\t  /* Clear out the declaration attribute and the formal parameters.\n-\t     Do not remove all children, because it is possible that this\n-\t     declaration die was forced using force_decl_die(). In such\n-\t     cases die that forced declaration die (e.g. TAG_imported_module)\n-\t     is one of the children that we do not want to remove.  */\n-\t  remove_AT (subr_die, DW_AT_declaration);\n-\t  remove_AT (subr_die, DW_AT_object_pointer);\n-\t  remove_child_TAG (subr_die, DW_TAG_formal_parameter);\n-#endif\n+\t  if (!old_die->dumped_early)\n+\t    {\n+\t      /* Clear out the declaration attribute and the formal parameters.\n+\t\t Do not remove all children, because it is possible that this\n+\t\t declaration die was forced using force_decl_die(). In such\n+\t\t cases die that forced declaration die (e.g. TAG_imported_module)\n+\t\t is one of the children that we do not want to remove.  */\n+\t      remove_AT (subr_die, DW_AT_declaration);\n+\t      remove_AT (subr_die, DW_AT_object_pointer);\n+\t      remove_child_TAG (subr_die, DW_TAG_formal_parameter);\n+\t    }\n \t}\n       else\n \t{\n@@ -19000,6 +19009,18 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   if (old_die && !declaration && !local_scope_p (context_die))\n     return;\n \n+  /* When DIEs are created early, the context is the compilation unit.\n+     Adjust the context when we know what it is the second time\n+     around.  */\n+  if (old_die && old_die->dumped_early)\n+    {\n+      if (old_die->die_parent != context_die)\n+\treparent_child (old_die, context_die);\n+      var_die = old_die;\n+      old_die = NULL;\n+      goto gen_variable_die_location;\n+    }\n+\n   /* For static data members, the declaration in the class is supposed\n      to have DW_TAG_member tag; the specification should still be\n      DW_TAG_variable referencing the DW_TAG_member DIE.  */\n@@ -19083,6 +19104,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n   if (decl && (DECL_ABSTRACT (decl) || declaration || old_die == NULL))\n     equate_decl_number_to_die (decl, var_die);\n \n+ gen_variable_die_location:\n   if (! declaration\n       && (! DECL_ABSTRACT (decl_or_origin)\n \t  /* Local static vars are shared between all clones/inlines,\n@@ -20990,17 +21012,17 @@ gen_namelist_decl (tree name, dw_die_ref scope_die, tree item_decls)\n }\n \n \n-/* Write the debugging output for DECL.  */\n+/* Write the debugging output for DECL and return the DIE.  */\n \n-static void\n+static dw_die_ref\n dwarf2out_decl (tree decl)\n {\n   dw_die_ref context_die = comp_unit_die ();\n \n   switch (TREE_CODE (decl))\n     {\n     case ERROR_MARK:\n-      return;\n+      return NULL;\n \n     case FUNCTION_DECL:\n       /* What we would really like to do here is to filter out all mere\n@@ -21037,7 +21059,7 @@ dwarf2out_decl (tree decl)\n \t or not at all.  */\n       if (DECL_INITIAL (decl) == NULL_TREE\n \t  && ! DECL_ABSTRACT (decl))\n-\treturn;\n+\treturn NULL;\n \n       /* If we're a nested function, initially use a parent of NULL; if we're\n \t a plain function, this will be fixed up in decls_for_scope.  If\n@@ -21058,7 +21080,7 @@ dwarf2out_decl (tree decl)\n \t would screw-up the debugger's name lookup mechanism and cause it to\n \t miss things which really ought to be in scope at a given point.  */\n       if (DECL_EXTERNAL (decl) && !TREE_USED (decl))\n-\treturn;\n+\treturn NULL;\n \n       /* For local statics lookup proper context die.  */\n       if (TREE_STATIC (decl)\n@@ -21069,39 +21091,39 @@ dwarf2out_decl (tree decl)\n       /* If we are in terse mode, don't generate any DIEs to represent any\n \t variable declarations or definitions.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn;\n+\treturn NULL;\n       break;\n \n     case CONST_DECL:\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn;\n+\treturn NULL;\n       if (!is_fortran () && !is_ada ())\n-\treturn;\n+\treturn NULL;\n       if (TREE_STATIC (decl) && decl_function_context (decl))\n \tcontext_die = lookup_decl_die (DECL_CONTEXT (decl));\n       break;\n \n     case NAMESPACE_DECL:\n     case IMPORTED_DECL:\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn;\n+\treturn NULL;\n       if (lookup_decl_die (decl) != NULL)\n-\treturn;\n+\treturn NULL;\n       break;\n \n     case TYPE_DECL:\n       /* Don't emit stubs for types unless they are needed by other DIEs.  */\n       if (TYPE_DECL_SUPPRESS_DEBUG (decl))\n-\treturn;\n+\treturn NULL;\n \n       /* Don't bother trying to generate any DIEs to represent any of the\n \t normal built-in types for the language we are compiling.  */\n       if (DECL_IS_BUILTIN (decl))\n-\treturn;\n+\treturn NULL;\n \n       /* If we are in terse mode, don't generate any DIEs for types.  */\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-\treturn;\n+\treturn NULL;\n \n       /* If we're a function-scope tag, initially use a parent of NULL;\n \t this will be fixed up in decls_for_scope.  */\n@@ -21114,14 +21136,15 @@ dwarf2out_decl (tree decl)\n       break;\n \n     default:\n-      return;\n+      return NULL;\n     }\n \n   gen_decl_die (decl, NULL, context_die);\n \n   dw_die_ref die = lookup_decl_die (decl);\n   if (die)\n     check_die (die, 0);\n+  return die;\n }\n \n /* Early dumping of DECLs before we lose language data.  */\n@@ -21137,8 +21160,8 @@ dwarf2out_early_decl (tree decl)\n      cgraph information, causing cgraph_function_possibly_inlined_p()\n      to return true.  Trick cgraph_function_possibly_inlined_p()\n      while we generate dwarf early.  */\n-  bool save = cgraph_global_info_ready;\n-  cgraph_global_info_ready = true;\n+  bool save = symtab->global_info_ready;\n+  symtab->global_info_ready = true;\n \n   /* We don't handle TYPE_DECLs.  If required, they'll be reached via\n      other DECLs and they can point to template types or other things\n@@ -21156,15 +21179,17 @@ dwarf2out_early_decl (tree decl)\n \t  push_cfun (DECL_STRUCT_FUNCTION (decl));\n \t  current_function_decl = decl;\n \t}\n-      dwarf2out_decl (decl);\n+      dw_die_ref die = dwarf2out_decl (decl);\n+      if (die)\n+\tdie->dumped_early = true;\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n \t  pop_cfun ();\n \t  current_function_decl = NULL;\n \t}\n     }\n  early_decl_exit:\n-  cgraph_global_info_ready = save;\n+  symtab->global_info_ready = save;\n   return;\n }\n "}]}