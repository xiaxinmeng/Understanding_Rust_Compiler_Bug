{"sha": "c819be5bb1adc344393d611e7b1bc79edf1223a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgxOWJlNWJiMWFkYzM0NDM5M2Q2MTFlN2IxYmM3OWVkZjEyMjNhOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-06-24T18:09:57Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-06-24T18:09:57Z"}, "message": "(sparc_frw_compute_frame_size): New function, for flat register window model support.\n\n(sparc_frw_compute_frame_size): New function, for flat\nregister window model support.\n(sparc_frw_save_restore): Likewise.\n(sparc_frw_output_function_prologue): Likewise.\n(sparc_frw_output_function_epilogue): Likewise.\n(sparc_frw_epilogue_delay_slots): Likewise.\n(sparc_frw_eligible_for_epilogue_delay): Likewise.\n\nFrom-SVN: r1275", "tree": {"sha": "ba14cca5eb088d9f1eb6dda9fef50763ebbc0c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba14cca5eb088d9f1eb6dda9fef50763ebbc0c01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c819be5bb1adc344393d611e7b1bc79edf1223a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c819be5bb1adc344393d611e7b1bc79edf1223a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c819be5bb1adc344393d611e7b1bc79edf1223a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c819be5bb1adc344393d611e7b1bc79edf1223a8/comments", "author": null, "committer": null, "parents": [{"sha": "0fad3b412cbe114fecb2ffdbd1311b5c83b31ab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fad3b412cbe114fecb2ffdbd1311b5c83b31ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fad3b412cbe114fecb2ffdbd1311b5c83b31ab2"}], "stats": {"total": 483, "additions": 483, "deletions": 0}, "files": [{"sha": "590f111a3bd675750a4a3fb7e348995e15143af4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c819be5bb1adc344393d611e7b1bc79edf1223a8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c819be5bb1adc344393d611e7b1bc79edf1223a8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c819be5bb1adc344393d611e7b1bc79edf1223a8", "patch": "@@ -3158,3 +3158,486 @@ handle_pragma_token (string, token)\n     }\n }\n #endif /* HANDLE_PRAGMA */\n+\f\n+/* Subroutines to support a flat (single) register window calling\n+   convention.  */\n+\n+/* Single-register window sparc stack frames look like:\n+\n+             Before call\t\t        After call\n+        +-----------------------+\t+-----------------------+\n+   high |\t\t\t|       |      \t\t\t|\n+   mem. |\t\t        |\t|\t\t\t|\n+        |  caller's temps.    \t|       |  caller's temps.    \t|\n+\t|       \t\t|       |       \t        |\n+        +-----------------------+\t+-----------------------+\n+ \t|       \t\t|\t|\t\t        |\n+        |  arguments on stack.  |\t|  arguments on stack.  |\n+\t|       \t\t|FP+92->|\t\t\t|\n+        +-----------------------+\t+-----------------------+\n+ \t|  6 words to save     \t|\t|  6 words to save\t|\n+\t|  arguments passed\t|\t|  arguments passed\t|\n+\t|  in registers, even\t|\t|  in registers, even\t|\n+ SP+68->|  if not passed.       |FP+68->|  if not passed.\t|\n+\t+-----------------------+       +-----------------------+\n+\t| 1 word struct addr\t|FP+64->| 1 word struct addr\t|\n+\t+-----------------------+       +-----------------------+\n+\t|\t\t\t|\t|\t\t\t|\n+\t| 16 word reg save area\t|\t| 16 word reg save area |\n+    SP->|\t\t\t|   FP->|\t\t\t|\n+\t+-----------------------+\t+-----------------------+\n+\t\t\t\t\t| 4 word area for\t|\n+\t\t\t\t FP-16->| fp/alu reg moves\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t|  local variables\t|\n+\t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t        |\n+                                        |  fp register save     |\n+\t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t        |\n+                                        |  gp register save     |\n+                                        |       \t\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\n+                                        |  alloca allocations   |\n+        \t\t\t\t|\t\t\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\n+                                        |  arguments on stack   |\n+        \t\t\t SP+92->|\t\t        |\n+\t\t\t\t\t+-----------------------+\n+                                        |  6 words to save      |\n+\t\t\t\t\t|  arguments passed     |\n+                                        |  in registers, even   |\n+   low                           SP+68->|  if not passed.       |\n+   memory        \t\t\t+-----------------------+\n+\t\t\t\t SP+64->| 1 word struct addr\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\n+\t\t\t\t\tI 16 word reg save area |\n+\t\t\t\t    SP->|\t\t\t|\n+\t\t\t\t\t+-----------------------+  */\n+\n+/* Structure to be filled in by sparc_frw_compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+\n+struct sparc_frame_info\n+{\n+  unsigned long total_size;\t/* # bytes that the entire frame takes up.  */\n+  unsigned long var_size;\t/* # bytes that variables take up.  */\n+  unsigned long args_size;\t/* # bytes that outgoing arguments take up.  */\n+  unsigned long extra_size;\t/* # bytes of extra gunk.  */\n+  unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs.  */\n+  unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs.  */\n+  unsigned long mask;\t\t/* Mask of saved gp registers.  */\n+  unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n+  unsigned long gp_sp_offset;\t/* Offset from new sp to store gp regs.  */\n+  unsigned long fp_sp_offset;\t/* Offset from new sp to store fp regs.  */\n+  int\t\tinitialized;\t/* Nonzero if frame size already calculated.  */\n+};\n+\n+/* Current frame information calculated by sparc_frw_compute_frame_size.  */\n+struct sparc_frame_info current_frame_info;\n+\n+/* Zero structure to initialize current_frame_info.  */\n+struct sparc_frame_info zero_frame_info;\n+\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n+\n+#define MUST_SAVE_REGISTER(regno) \\\n+ ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n+  || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n+  || (regno == 15 && regs_ever_live[15]))\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.  */\n+\n+unsigned long\n+sparc_frw_compute_frame_size (size)\n+     int size;\t\t\t/* # of var. bytes allocated.  */\n+{\n+  int regno;\n+  unsigned long total_size;\t/* # bytes that the entire frame takes up.  */\n+  unsigned long var_size;\t/* # bytes that variables take up.  */\n+  unsigned long args_size;\t/* # bytes that outgoing arguments take up.  */\n+  unsigned long extra_size;\t/* # extra bytes.  */\n+  unsigned int  gp_reg_size;\t/* # bytes needed to store gp regs.  */\n+  unsigned int  fp_reg_size;\t/* # bytes needed to store fp regs.  */\n+  unsigned long mask;\t\t/* Mask of saved gp registers.  */\n+  unsigned long fmask;\t\t/* Mask of saved fp registers.  */\n+\n+  /* This is the size of the 16 word reg save area, 1 word struct addr\n+     area, and 4 word fp/alu register copy area.  */\n+  extra_size\t = -STARTING_FRAME_OFFSET + FIRST_PARM_OFFSET(0);\n+  var_size\t = size;\n+  /* Also include the size needed for the 6 parameter registers.  */\n+  args_size\t = current_function_outgoing_args_size + 24;\n+  total_size\t = var_size + args_size + extra_size;\n+  gp_reg_size\t = 0;\n+  fp_reg_size\t = 0;\n+  mask\t\t = 0;\n+  fmask\t\t = 0;\n+\n+  /* Calculate space needed for gp registers.  */\n+  for (regno = 1; regno <= 31; regno++)\n+    {\n+      if (MUST_SAVE_REGISTER (regno))\n+\t{\n+\t  if ((regno & 0x1) == 0 && MUST_SAVE_REGISTER (regno+1))\n+\t    {\n+\t      if (gp_reg_size % 8 != 0)\n+\t\tgp_reg_size += UNITS_PER_WORD;\n+\t      gp_reg_size += 2 * UNITS_PER_WORD;\n+\t      mask |= 3 << regno;\n+\t      regno++;\n+\t    }\n+\t  else\n+\t    {\n+\t      gp_reg_size += UNITS_PER_WORD;\n+\t      mask |= 1 << regno;\n+\t    }\n+\t}\n+    }\n+  /* Add extra word in case we have to align the space to a double word\n+     boundary.  */\n+  if (gp_reg_size != 0)\n+    gp_reg_size += UNITS_PER_WORD;\n+\n+  /* Calculate space needed for fp registers.  */\n+  for (regno = 32; regno <= 63; regno++)\n+    {\n+      if (regs_ever_live[regno] && !call_used_regs[regno])\n+\t{\n+\t  fp_reg_size += UNITS_PER_WORD;\n+\t  fmask |= 1 << (regno - 32);\n+\t}\n+    }\n+\n+  total_size += gp_reg_size + fp_reg_size;\n+\n+  if (total_size == extra_size)\n+    total_size = extra_size = 0;\n+\n+  total_size = SPARC_STACK_ALIGN (total_size);\n+\n+  /* Save other computed information.  */\n+  current_frame_info.total_size  = total_size;\n+  current_frame_info.var_size    = var_size;\n+  current_frame_info.args_size   = args_size;\n+  current_frame_info.extra_size  = extra_size;\n+  current_frame_info.gp_reg_size = gp_reg_size;\n+  current_frame_info.fp_reg_size = fp_reg_size;\n+  current_frame_info.mask\t = mask;\n+  current_frame_info.fmask\t = fmask;\n+  current_frame_info.initialized = reload_completed;\n+\n+  if (mask)\n+    {\n+      unsigned long offset = args_size;\n+      if (extra_size)\n+\toffset += FIRST_PARM_OFFSET(0);\n+      current_frame_info.gp_sp_offset = offset;\n+    }\n+\n+  if (fmask)\n+    {\n+      unsigned long offset = args_size + gp_reg_size;\n+      if (extra_size)\n+\toffset += FIRST_PARM_OFFSET(0);\n+      current_frame_info.fp_sp_offset = offset;\n+    }\n+\n+  /* Ok, we're done.  */\n+  return total_size;\n+}\n+\f\n+/* Common code to save/restore registers.  */\n+\n+void\n+sparc_frw_save_restore (file, word_op, doubleword_op)\n+     FILE *file;\t\t/* Stream to write to.  */\n+     char *word_op;\t\t/* Operation to do for one word.  */\n+     char *doubleword_op;\t/* Operation to do for doubleword.  */\n+{\n+  int regno;\n+  unsigned long mask\t  = current_frame_info.mask;\n+  unsigned long fmask\t  = current_frame_info.fmask;\n+  unsigned long gp_offset;\n+  unsigned long fp_offset;\n+  unsigned long max_offset;\n+  char *base_reg;\n+\n+  if (mask == 0 && fmask == 0)\n+    return;\n+\n+  base_reg   = reg_names[STACK_POINTER_REGNUM];\n+  gp_offset  = current_frame_info.gp_sp_offset;\n+  fp_offset  = current_frame_info.fp_sp_offset;\n+  max_offset = (gp_offset > fp_offset) ? gp_offset : fp_offset;\n+\n+  /* Deal with calling functions with a large structure.  */\n+  if (max_offset >= 4096)\n+    {\n+      char *temp = \"%g2\";\n+      fprintf (file, \"\\tset %ld,%s\\n\", max_offset, temp);\n+      fprintf (file, \"\\tadd %s,%s,%s\\n\", temp, base_reg, temp);\n+      base_reg = temp;\n+      gp_offset = max_offset - gp_offset;\n+      fp_offset = max_offset - fp_offset;\n+    }\n+\n+  /* Save registers starting from high to low.  The debuggers prefer\n+     at least the return register be stored at func+4, and also it\n+     allows us not to need a nop in the epilog if at least one\n+     register is reloaded in addition to return address.  */\n+\n+  if (mask || frame_pointer_needed)\n+    {\n+      for (regno = 1; regno <= 31; regno++)\n+\t{\n+\t  if ((mask & (1L << regno)) != 0\n+\t      || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\t    {\n+\t      if ((regno & 0x1) == 0 && ((mask & (1L << regno+1)) != 0))\n+\t\t{\n+\t\t  if (gp_offset % 8 != 0)\n+\t\t    gp_offset += UNITS_PER_WORD;\n+\t\t  \n+\t\t  if (word_op[0] == 's')\n+\t\t    fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n+\t\t\t     doubleword_op, reg_names[regno],\n+\t\t\t     base_reg, gp_offset);\n+\t\t  else\n+\t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n+\t\t\t     doubleword_op, base_reg, gp_offset,\n+\t\t\t     reg_names[regno]);\n+\n+\t\t  gp_offset += 2 * UNITS_PER_WORD;\n+\t\t  regno++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (word_op[0] == 's')\n+\t\t    fprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n+\t\t\t     word_op, reg_names[regno],\n+\t\t\t     base_reg, gp_offset);\n+\t\t  else\n+\t\t    fprintf (file, \"\\t%s [%s+%d],%s\\n\",\n+\t\t\t     word_op, base_reg, gp_offset, reg_names[regno]);\n+\n+\t\t  gp_offset += UNITS_PER_WORD;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (fmask)\n+    {\n+      for (regno = 32; regno <= 63; regno++)\n+\t{\n+\t  if ((fmask & (1L << (regno - 32))) != 0)\n+\t    {\n+\t      if (word_op[0] == 's')\n+\t\tfprintf (file, \"\\t%s %s,[%s+%d]\\n\",\n+\t\t\t word_op, reg_names[regno],\n+\t\t\t base_reg, gp_offset);\n+\t      else\n+\t\tfprintf (file, \"\\t%s [%s+%d],%s\\n\",\n+\t\t\t word_op, base_reg, gp_offset, reg_names[regno]);\n+\n+\t      fp_offset += UNITS_PER_WORD;\n+\t    }\n+\t}\n+    }\n+}\n+\f\n+/* Set up the stack and frame (if desired) for the function.  */\n+\n+void\n+sparc_frw_output_function_prologue (file, size, ignored)\n+     FILE *file;\n+     int size;\n+{\n+  extern char call_used_regs[];\n+  int regno;\n+  int tsize;\n+  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+  frame_base_name\n+    = (!frame_pointer_needed) ? \"%sp+64\" : reg_names[FRAME_POINTER_REGNUM];\n+\n+  fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n+\n+  size = SPARC_STACK_ALIGN (size);\n+  tsize = (! current_frame_info.initialized\n+\t   ? sparc_frw_compute_frame_size (size)\n+\t   : current_frame_info.total_size);\n+\n+  if (tsize > 0)\n+    {\n+      if (tsize <= 4095)\n+\tfprintf (file,\n+\t\t \"\\tsub %s,%d,%s\\t\\t!# vars= %d, regs= %d/%d, args = %d, extra= %d\\n\",\n+\t\t sp_str, tsize, sp_str, current_frame_info.var_size,\n+\t\t current_frame_info.gp_reg_size / 4,\n+\t\t current_frame_info.fp_reg_size / 8,\n+\t\t current_function_outgoing_args_size,\n+\t\t current_frame_info.extra_size);\n+      else\n+\tfprintf (file,\n+\t\t \"\\tset %d,%s\\n\\tsub\\t%s,%s,%s\\t\\t!# vars= %d, regs= %d/%d, args = %d, sfo= %d\\n\",\n+\t\t tsize, \"%g1\", sp_str, \"%g1\",\n+\t\t sp_str, current_frame_info.var_size,\n+\t\t current_frame_info.gp_reg_size / 4,\n+\t\t current_frame_info.fp_reg_size / 8,\n+\t\t current_function_outgoing_args_size,\n+\t\t current_frame_info.extra_size);\n+    }\n+\n+  sparc_frw_save_restore (file, \"st\", \"std\");\n+\n+  if (frame_pointer_needed)\n+    {\n+      if (tsize <= 4095)\n+\tfprintf (file, \"\\tadd %s,%d,%s\\t!# set up frame pointer\\n\", sp_str,\n+\t\t tsize, frame_base_name);\n+      else\n+\tfprintf (file, \"\\tadd %s,%s,%s\\t!# set up frame pointer\\n\", sp_str,\n+\t\t \"%g1\", frame_base_name);\n+    }\n+}\n+\f\n+/* Do any necessary cleanup after a function to restore stack, frame,\n+   and regs. */\n+\n+void\n+sparc_frw_output_function_epilogue (file, size, ignored1, ignored2)\n+     FILE *file;\n+     int size;\n+{\n+  extern FILE *asm_out_data_file, *asm_out_file;\n+  extern char call_used_regs[];\n+  extern int frame_pointer_needed;\n+  int tsize;\n+  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n+  char *t1_str = \"%g1\";\n+  rtx epilogue_delay = current_function_epilogue_delay_list;\n+  int noepilogue = FALSE;\n+  int load_nop = FALSE;\n+  int load_only_r15;\n+\n+  /* The epilogue does not depend on any registers, but the stack\n+     registers, so we assume that if we have 1 pending nop, it can be\n+     ignored, and 2 it must be filled (2 nops occur for integer\n+     multiply and divide).  */\n+\n+  size = SPARC_STACK_ALIGN (size);\n+  tsize = (!current_frame_info.initialized\n+\t   ? sparc_frw_compute_frame_size (size)\n+\t   : current_frame_info.total_size);\n+\n+  if (tsize == 0 && epilogue_delay == 0)\n+    {\n+      rtx insn = get_last_insn ();\n+\n+      /* If the last insn was a BARRIER, we don't have to write any code\n+\t because a jump (aka return) was put there.  */\n+      if (GET_CODE (insn) == NOTE)\n+\tinsn = prev_nonnote_insn (insn);\n+      if (insn && GET_CODE (insn) == BARRIER)\n+\tnoepilogue = TRUE;\n+    }\n+\n+  if (!noepilogue)\n+    {\n+      /* In the reload sequence, we don't need to fill the load delay\n+\t slots for most of the loads, also see if we can fill the final\n+\t delay slot if not otherwise filled by the reload sequence.  */\n+\n+      if (tsize > 4095)\n+\tfprintf (file, \"\\tset %d,%s\\n\", tsize, t1_str);\n+\n+      if (frame_pointer_needed)\n+\t{\n+\t  char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+\t  if (tsize > 4095)\n+\t    fprintf (file,\"\\tsub %s,%s,%s\\t\\t!# sp not trusted  here\\n\",\n+\t\t     fp_str, t1_str, sp_str);\n+\t  else\n+\t    fprintf (file,\"\\tsub %s,%d,%s\\t\\t!# sp not trusted  here\\n\",\n+\t\t     fp_str, tsize, sp_str);\n+\t}\n+\n+      sparc_frw_save_restore (file, \"ld\", \"ldd\");\n+\n+      load_only_r15 = (current_frame_info.mask == (1 << 15)\n+\t\t       && current_frame_info.fmask == 0);\n+\n+      if (current_function_returns_struct)\n+\tfprintf (file, \"\\tjmp %%o7+12\\n\");\n+      else\n+\tfprintf (file, \"\\tretl\\n\");\n+\n+      /* If the only register saved is the return address, we need a\n+\t nop, unless we have an instruction to put into it.  Otherwise\n+\t we don't since reloading multiple registers doesn't reference\n+\t the register being loaded.  */\n+\n+      if (epilogue_delay)\n+\t{\n+\t  if (tsize)\n+\t    abort ();\n+\t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, -2, 1);\n+\t}\n+\n+      else if (tsize > 4095)\n+\tfprintf (file, \"\\tadd %s,%s,%s\\n\", sp_str, t1_str, sp_str);\n+\n+      else if (tsize > 0)\n+\tfprintf (file, \"\\tadd %s,%d,%s\\n\", sp_str, tsize, sp_str);\n+\n+      else\n+\tfprintf (file, \"\\tnop\\n\");\n+    }\n+\n+  /* Reset state info for each function.  */\n+  current_frame_info = zero_frame_info;\n+}\n+\f\n+/* Define the number of delay slots needed for the function epilogue.\n+\n+   On the sparc, we need a slot if either no stack has been allocated,\n+   or the only register saved is the return register.  */\n+\n+int\n+sparc_frw_epilogue_delay_slots ()\n+{\n+  if (!current_frame_info.initialized)\n+    (void) sparc_frw_compute_frame_size (get_frame_size ());\n+\n+  if (current_frame_info.total_size == 0)\n+    return 1;\n+\n+  if (current_frame_info.mask == (1 << 15) && current_frame_info.fmask == 0)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return true is TRIAL is a valid insn for the epilogue delay slot.\n+   Any single length instruction which doesn't reference the stack or frame\n+   pointer is OK.  */\n+\n+int\n+sparc_frw_eligible_for_epilogue_delay (trial, slot)\n+     rtx trial;\n+     int slot;\n+{\n+  if (get_attr_length (trial) == 1\n+      && ! reg_mentioned_p (stack_pointer_rtx, PATTERN (trial))\n+      && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (trial)))\n+    return 1;\n+  return 0;\n+}"}]}