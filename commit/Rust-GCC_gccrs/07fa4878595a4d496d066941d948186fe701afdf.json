{"sha": "07fa4878595a4d496d066941d948186fe701afdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdmYTQ4Nzg1OTVhNGQ0OTZkMDY2OTQxZDk0ODE4NmZlNzAxYWZkZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-12-30T13:39:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-12-30T13:39:48Z"}, "message": "cp-tree.h (THUNK_TARGET): New macro.\n\ncp:\n\t* cp-tree.h (THUNK_TARGET): New macro.\n\t(THUNK_VIRTUAL_OFFSET): For result thunks it is always a binfo.\n\t(finish_thunk): Remove offset parms.\n\t* class.c (find_final_overrider): Look through thunks.\n\t(get_vcall_index): Use THUNK_TARGET.\n\t(update_vtable_entry_for_fn): Look through thunks. Set covariant\n\tfixed offset here. Adjust finish_thunk call.\n\t(build_vtbl_initializer): Adjust finish_thunk calls.\n\t* mangle.c (mangle_call_offset): Remove superfluous if.\n\t(mangle_thunk): Adjust.\n\t* method.c (make_thunk): Adjust.\n\t(finish_thunk): Adjust.\n\t(thunk_adjust): Remove assert.\n\t(use_thunk): Use THUNK_TARGET\n\t* dump1.c (cp_dump_tree): Adjust thunk dumping.\ntestsuite:\n\t* g++.dg/inherit/covariant5.C: New test.\n\t* g++.dg/inherit/covariant6.C: New test.\n\t* g++.dg/inherit/covariant7.C: New test.\n\nFrom-SVN: r60628", "tree": {"sha": "b2f4b26dcfa4c39b16e56aaa74b284dd0dfd7bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2f4b26dcfa4c39b16e56aaa74b284dd0dfd7bbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07fa4878595a4d496d066941d948186fe701afdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07fa4878595a4d496d066941d948186fe701afdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07fa4878595a4d496d066941d948186fe701afdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07fa4878595a4d496d066941d948186fe701afdf/comments", "author": null, "committer": null, "parents": [{"sha": "5a5cccaa4e00fd06fd8e8bf4e9f731dbda799dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5cccaa4e00fd06fd8e8bf4e9f731dbda799dd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5cccaa4e00fd06fd8e8bf4e9f731dbda799dd3"}], "stats": {"total": 250, "additions": 181, "deletions": 69}, "files": [{"sha": "0ce3f11346807b733ad99b0f302b979470756e66", "filename": "gcc/cp/class.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -2299,6 +2299,9 @@ find_final_overrider (derived, binfo, fn)\n      \n      The solution is to look at all paths to BINFO.  If we find\n      different overriders along any two, then there is a problem.  */\n+  if (DECL_THUNK_P (fn))\n+    fn = THUNK_TARGET (fn);\n+  \n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n   ffod.most_derived_type = BINFO_TYPE (derived);\n@@ -2328,8 +2331,8 @@ get_vcall_index (tree fn, tree type)\n {\n   tree v;\n \n-  if (DECL_RESULT_THUNK_P (fn))\n-    fn = TREE_OPERAND (DECL_INITIAL (fn), 0);\n+  if (DECL_THUNK_P (fn))\n+    fn = THUNK_TARGET (fn);\n \n   for (v = CLASSTYPE_VCALL_INDICES (type); v; v = TREE_CHAIN (v))\n     if ((DECL_DESTRUCTOR_P (fn) && DECL_DESTRUCTOR_P (TREE_PURPOSE (v)))\n@@ -2360,11 +2363,15 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n   tree first_defn;\n   bool lost = false;\n \n+  if (DECL_THUNK_P (fn))\n+    fn = THUNK_TARGET (fn);\n+  \n   /* Find the nearest primary base (possibly binfo itself) which defines\n      this function; this is the class the caller will convert to when\n      calling FN through BINFO.  */\n   for (b = binfo; ; b = get_primary_binfo (b))\n     {\n+      my_friendly_assert (b, 20021227);\n       if (look_for_overrides_here (BINFO_TYPE (b), fn))\n \tbreak;\n \n@@ -2408,10 +2415,11 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t\t/* If the covariant type is within the class hierarchy\n \t\t   we are currently laying out, the vbase index is not\n \t\t   yet known, so we have to remember the virtual base\n-\t\t   binfo for the moment.  The thunk will be finished\n-\t\t   in build_vtbl_initializer, where we'll know the\n-\t\t   vtable index of the virtual base.  */\n-\t\tvirtual_offset = binfo_for_vbase (BINFO_TYPE (binfo), t);\n+\t\t   binfo. */\n+\t\tvirtual_offset = binfo_for_vbase (BINFO_TYPE (binfo),\n+\t\t\t\t\t\t  TREE_TYPE (over_return));\n+\t\tfixed_offset = size_diffop (fixed_offset,\n+\t\t\t\t\t    BINFO_OFFSET (virtual_offset));\n \t      }\n \t    \n \t    /* Replace the overriding function with a covariant thunk.\n@@ -2421,7 +2429,7 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t\t\t\tfixed_offset, virtual_offset);\n \t    TREE_PURPOSE (overrider) = thunk;\n \t    if (!virtual_offset && !DECL_NAME (thunk))\n-\t      finish_thunk (thunk, fixed_offset, NULL_TREE);\n+\t      finish_thunk (thunk);\n \t  }\n       }\n   }\n@@ -7739,18 +7747,12 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n       tree init = NULL_TREE;\n       \n       fn = BV_FN (v);\n-      fn_original = (DECL_RESULT_THUNK_P (fn)\n-\t\t     ? TREE_OPERAND (DECL_INITIAL (fn), 0)\n-\t\t     : fn);\n-      /* Finish an unfinished covariant thunk. */\n-      if (DECL_RESULT_THUNK_P (fn) && !DECL_NAME (fn))\n+      fn_original = fn;\n+      if (DECL_THUNK_P (fn))\n \t{\n-\t  tree binfo = THUNK_VIRTUAL_OFFSET (fn);\n-\t  tree fixed_offset = size_int (THUNK_FIXED_OFFSET (fn));\n-\t  tree virtual_offset = BINFO_VPTR_FIELD (binfo);\n-\t  \n-\t  fixed_offset = size_diffop (fixed_offset, BINFO_OFFSET (binfo));\n-\t  finish_thunk (fn, fixed_offset, virtual_offset);\n+\t  if (!DECL_NAME (fn))\n+\t    finish_thunk (fn);\n+\t  fn_original = THUNK_TARGET (fn);\n \t}\n       \n       /* If the only definition of this function signature along our\n@@ -7796,7 +7798,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n \t    {\n \t      fn = make_thunk (fn, /*this_adjusting=*/1, delta, vcall_index);\n \t      if (!DECL_NAME (fn))\n-\t\tfinish_thunk (fn, delta, THUNK_VIRTUAL_OFFSET (fn));\n+\t\tfinish_thunk (fn);\n \t    }\n \t  /* Take the address of the function, considering it to be of an\n \t     appropriate generic type.  */"}, {"sha": "6296731a080bb2047cf12c0245a8b0f833b04b47", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -1791,6 +1791,9 @@ struct lang_decl GTY(())\n     {\n       struct full_lang_decl \n       {\n+\t/* For a non-thunk function decl, this is a tree list of\n+  \t   friendly classes. For a thunk function decl, it is the\n+  \t   thunked to function decl.  */\n \ttree befriending_classes;\n \t\n \t/* For a non-virtual FUNCTION_DECL, this is\n@@ -2977,14 +2980,20 @@ struct lang_decl GTY(())\n /* An integer indicating how many bytes should be subtracted from the\n    this or result pointer when this function is called.  */\n #define THUNK_FIXED_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC (DECL)->u.f.fixed_offset)\n-\n-/* A tree indicating how many bytes should be added to the\n-   vtable for the this or result pointer to find the vcall or vbase\n-   offset.  (The vptr is always located at offset zero from the\n-   this or result pointer.)  If NULL, then there is no virtual adjust.  */\n+  (DECL_LANG_SPECIFIC (VAR_OR_FUNCTION_DECL_CHECK (DECL))->u.f.fixed_offset)\n+\n+/* A tree indicating how to perform the virtual adjustment. For a this\n+   adjusting thunk it is the number of bytes to be added to the vtable\n+   to find the vcall offset. For a result adjusting thunk, it is the\n+   binfo of the relevant virtual base.  The vptr is always located at\n+   offset zero from the this or result pointer.  If NULL, then there\n+   is no virtual adjust.  */\n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n-  (LANG_DECL_U2_CHECK (DECL, 0)->virtual_offset)\n+  (LANG_DECL_U2_CHECK (VAR_OR_FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n+\n+/* For thunk NODE, this is the FUNCTION_DECL thunked to.  */\n+#define THUNK_TARGET(NODE)\t\t\t\t\\\n+  (DECL_LANG_SPECIFIC (NODE)->u.f.befriending_classes)\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n@@ -3990,7 +3999,7 @@ extern void set_mangled_name_for_decl (tree);\n extern tree build_opfncall (enum tree_code, int, tree, tree, tree);\n extern tree hack_identifier (tree, tree);\n extern tree make_thunk (tree, bool, tree, tree);\n-extern void finish_thunk (tree, tree, tree);\n+extern void finish_thunk (tree);\n extern void use_thunk (tree, bool);\n extern void synthesize_method (tree);\n extern tree implicitly_declare_fn (special_function_kind, tree, bool);"}, {"sha": "bb842bdcae23375cfd82e32427182568d945202b", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -336,13 +336,20 @@ cp_dump_tree (dump_info, t)\n \t}\n       else\n \t{\n+\t  tree virt = THUNK_VIRTUAL_OFFSET (t);\n+\t  \n \t  dump_string (di, \"thunk\");\n \t  if (DECL_THIS_THUNK_P (t))\n \t    dump_string (di, \"this adjusting\");\n \t  else\n-\t    dump_string (di, \"result adjusting\");\n+\t    {\n+\t      dump_string (di, \"result adjusting\");\n+\t      if (virt)\n+\t\tvirt = BINFO_VPTR_FIELD (virt);\n+\t    }\n \t  dump_int (di, \"fixd\", THUNK_FIXED_OFFSET (t));\n-\t  dump_child (\"virt\", THUNK_VIRTUAL_OFFSET (t));\n+\t  if (virt)\n+\t    dump_int (di, \"virt\", tree_low_cst (virt, 0));\n \t  dump_child (\"fn\", DECL_INITIAL (t));\n \t}\n       break;"}, {"sha": "70443aab258338c23626caf2057c044caefe467c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -2545,10 +2545,7 @@ mangle_call_offset (fixed_offset, virtual_offset)\n      tree fixed_offset;\n      tree virtual_offset;\n {\n-  if (virtual_offset)\n-    write_char (virtual_offset ? 'v' : 'h');\n-  else\n-    write_char ('h');\n+  write_char (virtual_offset ? 'v' : 'h');\n \n   /* For either flavor, write the fixed offset.  */\n   write_integer_cst (fixed_offset);\n@@ -2590,24 +2587,27 @@ mangle_thunk (fn_decl, this_adjusting, fixed_offset, virtual_offset)\n   write_string (\"_Z\");\n   write_char ('T');\n   \n-  if (this_adjusting && !DECL_RESULT_THUNK_P (fn_decl))\n-    /* Plain this adjusting thunk.  */\n-    mangle_call_offset (fixed_offset, virtual_offset);\n-  else if (!this_adjusting)\n+  if (!this_adjusting)\n     {\n       /* Covariant thunk with no this adjustment */\n       write_char ('c');\n       mangle_call_offset (integer_zero_node, NULL_TREE);\n       mangle_call_offset (fixed_offset, virtual_offset);\n     }\n+  else if (!DECL_THUNK_P (fn_decl))\n+    /* Plain this adjusting thunk.  */\n+    mangle_call_offset (fixed_offset, virtual_offset);\n   else\n     {\n       /* This adjusting thunk to covariant thunk.  */\n       write_char ('c');\n       mangle_call_offset (fixed_offset, virtual_offset);\n-      mangle_call_offset (ssize_int (THUNK_FIXED_OFFSET (fn_decl)),\n-\t\t\t  THUNK_VIRTUAL_OFFSET (fn_decl));\n-      fn_decl = TREE_OPERAND (DECL_INITIAL (fn_decl), 0);\n+      fixed_offset = ssize_int (THUNK_FIXED_OFFSET (fn_decl));\n+      virtual_offset = THUNK_VIRTUAL_OFFSET (fn_decl);\n+      if (virtual_offset)\n+\tvirtual_offset = BINFO_VPTR_FIELD (virtual_offset);\n+      mangle_call_offset (fixed_offset, virtual_offset);\n+      fn_decl = THUNK_TARGET (fn_decl);\n     }\n \n   /* Scoped name.  */"}, {"sha": "f4cfe0d67f19bf973c8636aa46f345db813a8452", "filename": "gcc/cp/method.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -261,8 +261,7 @@ make_thunk (tree function, bool this_adjusting,\n   \n   /* See if we already have the thunk in question.  For this_adjusting\n      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it\n-     will be a BINFO (because of the organization of the layout\n-     algorithm). */\n+     will be a BINFO. */\n   for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n     if (DECL_THIS_THUNK_P (thunk) == this_adjusting\n  \t&& THUNK_FIXED_OFFSET (thunk) == d\n@@ -281,16 +280,16 @@ make_thunk (tree function, bool this_adjusting,\n \n   thunk = build_decl (FUNCTION_DECL, NULL_TREE, TREE_TYPE (function));\n   DECL_LANG_SPECIFIC (thunk) = DECL_LANG_SPECIFIC (function);\n-  cxx_dup_lang_specific_decl (function);\n+  cxx_dup_lang_specific_decl (thunk);\n   DECL_CONTEXT (thunk) = DECL_CONTEXT (function);\n   TREE_READONLY (thunk) = TREE_READONLY (function);\n   TREE_THIS_VOLATILE (thunk) = TREE_THIS_VOLATILE (function);\n   TREE_PUBLIC (thunk) = TREE_PUBLIC (function);\n   if (flag_weak)\n     comdat_linkage (thunk);\n   SET_DECL_THUNK_P (thunk, this_adjusting);\n-  DECL_INITIAL (thunk) = build1 (ADDR_EXPR, vfunc_ptr_type_node, function);\n-  THUNK_FIXED_OFFSET (thunk) = tree_low_cst (fixed_offset, 0);\n+  THUNK_TARGET (thunk) = function;\n+  THUNK_FIXED_OFFSET (thunk) = d;\n   THUNK_VIRTUAL_OFFSET (thunk) = virtual_offset;\n   \n   /* The thunk itself is not a constructor or destructor, even if\n@@ -320,20 +319,21 @@ make_thunk (tree function, bool this_adjusting,\n   return thunk;\n }\n \n-/* Finish THUNK, a thunk decl. FIXED_OFFSET and VIRTUAL_OFFSET are the\n-   adjustments to apply.  */\n+/* Finish THUNK, a thunk decl.  */\n \n void\n-finish_thunk (tree thunk, tree fixed_offset, tree virtual_offset)\n+finish_thunk (tree thunk)\n {\n   tree function, name;\n-  \n+  tree fixed_offset = ssize_int (THUNK_FIXED_OFFSET (thunk));\n+  tree virtual_offset = THUNK_VIRTUAL_OFFSET (thunk);\n+\n   my_friendly_assert (!DECL_NAME (thunk) && DECL_THUNK_P (thunk), 20021127);\n-  function = TREE_OPERAND (DECL_INITIAL (thunk), 0);\n+  if (virtual_offset && DECL_RESULT_THUNK_P (thunk))\n+    virtual_offset = BINFO_VPTR_FIELD (virtual_offset);\n+  function = THUNK_TARGET (thunk);\n   name = mangle_thunk (function, DECL_THIS_THUNK_P (thunk),\n-\t\t\t    fixed_offset, virtual_offset);\n-  THUNK_FIXED_OFFSET (thunk) = tree_low_cst (fixed_offset, 0);\n-  THUNK_VIRTUAL_OFFSET (thunk) = virtual_offset;\n+\t\t       fixed_offset, virtual_offset);\n   DECL_NAME (thunk) = name;\n   SET_DECL_ASSEMBLER_NAME (thunk, name);\n }\n@@ -358,9 +358,6 @@ thunk_adjust (tree ptr, bool this_adjusting,\n     {\n       tree vtable;\n \n-      /* It shouldn't be a binfo any more. */\n-      my_friendly_assert (TREE_CODE (virtual_offset) == INTEGER_CST, 20021127);\n-      \n       ptr = save_expr (ptr);\n       /* The vptr is always at offset zero in the object.  */\n       vtable = build1 (NOP_EXPR,\n@@ -392,19 +389,19 @@ thunk_adjust (tree ptr, bool this_adjusting,\n void\n use_thunk (tree thunk_fndecl, bool emit_p)\n {\n-  tree fnaddr;\n   tree function;\n   tree virtual_offset;\n   HOST_WIDE_INT fixed_offset, virtual_value;\n+  bool this_adjusting = DECL_THIS_THUNK_P (thunk_fndecl);\n \n   /* We should have called finish_thunk to give it a name. */\n   my_friendly_assert (DECL_NAME (thunk_fndecl), 20021127);\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n   \n-  fnaddr = DECL_INITIAL (thunk_fndecl);\n-  if (TREE_CODE (DECL_INITIAL (thunk_fndecl)) != ADDR_EXPR)\n+  function = THUNK_TARGET (thunk_fndecl);\n+  if (DECL_RESULT (thunk_fndecl))\n     /* We already turned this thunk into an ordinary function.\n        There's no need to process this thunk again.  */\n     return;\n@@ -414,7 +411,6 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n   /* Figure out what function is being thunked to.  It's referenced in\n      this translation unit.  */\n-  function = TREE_OPERAND (fnaddr, 0);\n   TREE_ADDRESSABLE (function) = 1;\n   mark_used (function);\n   TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (function)) = 1;\n@@ -424,9 +420,15 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   fixed_offset = THUNK_FIXED_OFFSET (thunk_fndecl);\n   virtual_offset = THUNK_VIRTUAL_OFFSET (thunk_fndecl);\n \n-  virtual_value = (virtual_offset\n-\t\t   ? tree_low_cst (virtual_offset, /*pos=*/0) : 0);\n-  my_friendly_assert (!virtual_offset || virtual_value, 20021026);\n+  if (virtual_offset)\n+    {\n+      if (!this_adjusting)\n+\tvirtual_offset = BINFO_VPTR_FIELD (virtual_offset);\n+      virtual_value = tree_low_cst (virtual_offset, /*pos=*/0);\n+      my_friendly_assert (virtual_value, 20021026);\n+    }\n+  else\n+    virtual_value = 0;\n   \n   /* And, if we need to emit the thunk, it's used.  */\n   mark_used (thunk_fndecl);\n@@ -447,10 +449,9 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n      create one.  */\n   DECL_INITIAL (thunk_fndecl) = make_node (BLOCK);\n-  BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) \n-    = DECL_ARGUMENTS (thunk_fndecl);\n-\n-  if (DECL_THIS_THUNK_P (thunk_fndecl)\n+  BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) = DECL_ARGUMENTS (thunk_fndecl);\n+  \n+  if (this_adjusting\n       && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n \t\t\t\t\t      virtual_value, function))\n     {\n@@ -502,7 +503,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n       t = a;\n       \n-      if (DECL_THIS_THUNK_P (thunk_fndecl))\n+      if (this_adjusting)\n \tt = thunk_adjust (t, /*this_adjusting=*/1,\n \t\t\t  fixed_offset, virtual_offset);\n       \n@@ -512,7 +513,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \tt = tree_cons (NULL_TREE, a, t);\n       t = nreverse (t);\n       t = build_call (function, t);\n-      if (DECL_RESULT_THUNK_P (thunk_fndecl))\n+      if (!this_adjusting)\n \tt = thunk_adjust (t, /*this_adjusting=*/0,\n \t\t\t  fixed_offset, virtual_offset);\n       "}, {"sha": "cae2b90e786e6dc54313386cff094ca8ff709f65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -1,3 +1,9 @@\n+2002-12-30  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/inherit/covariant5.C: New test.\n+\t* g++.dg/inherit/covariant6.C: New test.\n+\t* g++.dg/inherit/covariant7.C: New test.\n+\n 2002-12-29  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/2739"}, {"sha": "a46b1bf20d8cd65b6a0c8c72f1f6d2d3e384c161", "filename": "gcc/testsuite/g++.dg/inherit/covariant5.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant5.C?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 27 Dec 2002 <nathan@codesourcery.com>\n+\n+// We ICE'd\n+\n+struct c0 {};\n+\n+struct c1 : virtual c0\n+{\n+  virtual c0 &f2();\n+};\n+\n+struct c3 : c1\n+{\n+  virtual c1 &f2();\n+};\n+\n+c1 &c3::f2()\n+{\n+  throw 0;\n+}\n+\n+struct c4 : virtual c3\n+{\n+};"}, {"sha": "dc55971533ec07954a8286c18b0a80ffe74a89a0", "filename": "gcc/testsuite/g++.dg/inherit/covariant6.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant6.C?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 27 Dec 2002 <nathan@codesourcery.com>\n+\n+// We ICE'd\n+\n+struct c0 {};\n+\n+struct c1 : virtual c0\n+{\n+  virtual c0 &f2();\n+};\n+\n+struct c3 : virtual c1\n+{\n+  virtual c1 &f2();\n+};\n+\n+c1 &c3::f2()\n+{\n+  throw 0;\n+}\n+\n+struct c4 : virtual c3\n+{\n+};"}, {"sha": "596c679f2484fab2654d0afeef91afef26742f23", "filename": "gcc/testsuite/g++.dg/inherit/covariant7.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07fa4878595a4d496d066941d948186fe701afdf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant7.C?ref=07fa4878595a4d496d066941d948186fe701afdf", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 27 Dec 2002 <nathan@codesourcery.com>\n+\n+// We ICE'd\n+\n+struct c0 {};\n+\n+struct c1 : virtual c0\n+{\n+  virtual c0 &f2() volatile;\n+};\n+\n+struct c2 \n+{\n+  int m;\n+};\n+\n+struct c3 : virtual c0, virtual c1, c2\n+{\n+  virtual c1 &f2() volatile;\n+};\n+\n+struct c4 : virtual c3, virtual c0, virtual c1\n+{\n+  int m;\n+};\n+\n+struct c6 : c0, c3, c4\n+{ // { dg-warning \"direct base\" \"\" }\n+  virtual c1 &f2() volatile;\n+};"}]}