{"sha": "366099ff0823c3c9929dd7fb911f4af04e63baef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY2MDk5ZmYwODIzYzNjOTkyOWRkN2ZiOTExZjRhZjA0ZTYzYmFlZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-06T09:05:11Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-06T09:05:11Z"}, "message": "Move size time tables from GGC to heap\n\nthis patch moves size time tables out of ggc allocated memory.  This makes\nsources bit cleaner and saves about 60MB of GGC memory that turns to about 45MB\nof heap memory for cc1plus LTO build.\n\n\t* ipa-fnsummary.h (class size_time_entry): Do not GTY annotate.\n\t(class ipa_fnsummary): Turn size_time_table to auto_vec and\n\tcall_size_time_table to effecient vec; update constructors.\n\t* ipa-fnsummary.c (ipa_fn_summary::account_size_time): Update.\n\t(ipa_fn_summary::~ipa_fn_summary): Update.\n\t(ipa_fn_summary_t::duplicate): Update.\n\t(ipa_dump_fn_summary): Update.\n\t(set_switch_stmt_execution_predicate): Update.\n\t(analyze_function_body): Update.\n\t(estimate_calls_size_and_time): Update.\n\t(ipa_call_context::estimate_size_and_time): Update.\n\t(ipa_merge_fn_summary_after_inlining): Update.\n\t(ipa_update_overall_fn_summary): Update.\n\t(inline_read_section): Update.\n\t(ipa_fn_summary_write): Update.", "tree": {"sha": "b7730dd3cdfe7277dd1bec50ebc81c16a8e288df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7730dd3cdfe7277dd1bec50ebc81c16a8e288df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/366099ff0823c3c9929dd7fb911f4af04e63baef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366099ff0823c3c9929dd7fb911f4af04e63baef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366099ff0823c3c9929dd7fb911f4af04e63baef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366099ff0823c3c9929dd7fb911f4af04e63baef/comments", "author": null, "committer": null, "parents": [{"sha": "344106a966857a7d3d9109b66e0acb2efb5d1cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/344106a966857a7d3d9109b66e0acb2efb5d1cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/344106a966857a7d3d9109b66e0acb2efb5d1cd8"}], "stats": {"total": 88, "additions": 44, "deletions": 44}, "files": [{"sha": "f2781d041b95d893a60f866136f59992763ace33", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366099ff0823c3c9929dd7fb911f4af04e63baef/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366099ff0823c3c9929dd7fb911f4af04e63baef/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=366099ff0823c3c9929dd7fb911f4af04e63baef", "patch": "@@ -168,8 +168,7 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n   bool found = false;\n   int i;\n   predicate nonconst_pred;\n-  vec<size_time_entry, va_gc> *table = call\n-\t \t\t\t       ? call_size_time_table : size_time_table;\n+  vec<size_time_entry> *table = call ? &call_size_time_table : &size_time_table;\n \n   if (exec_pred == false)\n     return;\n@@ -181,13 +180,13 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n \n   /* We need to create initial empty unconditional clause, but otherwise\n      we don't need to account empty times and sizes.  */\n-  if (!size && time == 0 && table)\n+  if (!size && time == 0 && table->length ())\n     return;\n \n   /* Only for calls we are unaccounting what we previously recorded.  */\n   gcc_checking_assert (time >= 0 || call);\n \n-  for (i = 0; vec_safe_iterate (table, i, &e); i++)\n+  for (i = 0; table->iterate (i, &e); i++)\n     if (e->exec_predicate == exec_pred\n \t&& e->nonconst_predicate == nonconst_pred)\n       {\n@@ -227,9 +226,9 @@ ipa_fn_summary::account_size_time (int size, sreal time,\n       new_entry.exec_predicate = exec_pred;\n       new_entry.nonconst_predicate = nonconst_pred;\n       if (call)\n-        vec_safe_push (call_size_time_table, new_entry);\n+\tcall_size_time_table.safe_push (new_entry);\n       else\n-        vec_safe_push (size_time_table, new_entry);\n+\tsize_time_table.safe_push (new_entry);\n     }\n   else\n     {\n@@ -753,8 +752,7 @@ ipa_fn_summary::~ipa_fn_summary ()\n   for (unsigned i = 0; i < len; i++)\n     edge_predicate_pool.remove ((*loop_strides)[i].predicate);\n   vec_free (conds);\n-  vec_free (size_time_table);\n-  vec_free (call_size_time_table);\n+  call_size_time_table.release ();\n   vec_free (loop_iterations);\n   vec_free (loop_strides);\n   builtin_constant_p_parms.release ();\n@@ -804,10 +802,10 @@ remap_freqcounting_preds_after_dup (vec<ipa_freqcounting_predicate, va_gc> *v,\n void\n ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t\t\t     cgraph_node *dst,\n-\t\t\t     ipa_fn_summary *,\n+\t\t\t     ipa_fn_summary *src_info,\n \t\t\t     ipa_fn_summary *info)\n {\n-  new (info) ipa_fn_summary (*ipa_fn_summaries->get (src));\n+  new (info) ipa_fn_summary (*src_info);\n   /* TODO: as an optimization, we may avoid copying conditions\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n@@ -817,7 +815,6 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n      out that something was optimized out.  */\n   if (ipa_node_params_sum && cinfo && cinfo->tree_map)\n     {\n-      vec<size_time_entry, va_gc> *entry = info->size_time_table;\n       /* Use SRC parm info since it may not be copied yet.  */\n       class ipa_node_params *parms_info = IPA_NODE_REF (src);\n       ipa_auto_call_arg_values avals;\n@@ -830,7 +827,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       bool inlined_to_p = false;\n       struct cgraph_edge *edge, *next;\n \n-      info->size_time_table = 0;\n+      info->size_time_table.release ();\n       avals.m_known_vals.safe_grow_cleared (count, true);\n       for (i = 0; i < count; i++)\n \t{\n@@ -859,7 +856,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n          to be false.\n          TODO: as on optimization, we can also eliminate conditions known\n          to be true.  */\n-      for (i = 0; vec_safe_iterate (entry, i, &e); i++)\n+      for (i = 0; src_info->size_time_table.iterate (i, &e); i++)\n \t{\n \t  predicate new_exec_pred;\n \t  predicate new_nonconst_pred;\n@@ -935,8 +932,8 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n     }\n   else\n     {\n-      info->size_time_table = vec_safe_copy (info->size_time_table);\n-      info->loop_iterations = vec_safe_copy (info->loop_iterations);\n+      info->size_time_table = src_info->size_time_table.copy ();\n+      info->loop_iterations = vec_safe_copy (src_info->loop_iterations);\n       info->loop_strides = vec_safe_copy (info->loop_strides);\n \n       info->builtin_constant_p_parms\n@@ -1105,7 +1102,7 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \t    fprintf (f, \"  estimated growth:%i\\n\", (int) s->growth);\n \t  if (s->scc_no)\n \t    fprintf (f, \"  In SCC:          %i\\n\", (int) s->scc_no);\n-\t  for (i = 0; vec_safe_iterate (s->size_time_table, i, &e); i++)\n+\t  for (i = 0; s->size_time_table.iterate (i, &e); i++)\n \t    {\n \t      fprintf (f, \"    size:%f, time:%f\",\n \t\t       (double) e->size / ipa_fn_summary::size_scale,\n@@ -1844,7 +1841,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t    }\n \n \t  p_seg = add_condition (summary, params_summary, index,\n-\t\t\t \t param_type, &aggpos, GT_EXPR,\n+\t\t\t\t param_type, &aggpos, GT_EXPR,\n \t\t\t\t max, param_ops);\n \t}\n     }\n@@ -2595,8 +2592,8 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   memset(&fbi, 0, sizeof(fbi));\n   vec_free (info->conds);\n   info->conds = NULL;\n-  vec_free (info->size_time_table);\n-  info->size_time_table = NULL;\n+  info->size_time_table.release ();\n+  info->call_size_time_table.release ();\n \n   /* When optimizing and analyzing for IPA inliner, initialize loop optimizer\n      so we can produce proper inline hints.\n@@ -3374,7 +3371,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   if (use_table)\n     {\n       /* Build summary if it is absent.  */\n-      if (!sum->call_size_time_table)\n+      if (!sum->call_size_time_table.length ())\n \t{\n \t  predicate true_pred = true;\n \t  sum->account_size_time (0, 0, true_pred, true_pred, true);\n@@ -3385,13 +3382,13 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n       sreal old_time = time ? *time : 0;\n \n       if (min_size)\n-\t*min_size += (*sum->call_size_time_table)[0].size;\n+\t*min_size += sum->call_size_time_table[0].size;\n \n       unsigned int i;\n       size_time_entry *e;\n \n       /* Walk the table and account sizes and times.  */\n-      for (i = 0; vec_safe_iterate (sum->call_size_time_table, i, &e);\n+      for (i = 0; sum->call_size_time_table.iterate (i, &e);\n \t   i++)\n \tif (e->exec_predicate.evaluate (possible_truths))\n \t  {\n@@ -3404,7 +3401,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n       if ((flag_checking || dump_file)\n \t  /* Do not try to sanity check when we know we lost some\n \t     precision.  */\n-\t  && sum->call_size_time_table->length ()\n+\t  && sum->call_size_time_table.length ()\n \t     < ipa_fn_summary::max_size_time_table_size)\n \t{\n \t  estimate_calls_size_and_time_1 (node, &old_size, NULL, &old_time, NULL,\n@@ -3694,8 +3691,8 @@ ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n \n   sreal nonspecialized_time = time;\n \n-  min_size += (*info->size_time_table)[0].size;\n-  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n+  min_size += info->size_time_table[0].size;\n+  for (i = 0; info->size_time_table.iterate (i, &e); i++)\n     {\n       bool exec = e->exec_predicate.evaluate (m_nonspec_possible_truths);\n \n@@ -3741,8 +3738,8 @@ ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n \t  gcc_checking_assert (time >= 0);\n         }\n      }\n-  gcc_checking_assert ((*info->size_time_table)[0].exec_predicate == true);\n-  gcc_checking_assert ((*info->size_time_table)[0].nonconst_predicate == true);\n+  gcc_checking_assert (info->size_time_table[0].exec_predicate == true);\n+  gcc_checking_assert (info->size_time_table[0].nonconst_predicate == true);\n   gcc_checking_assert (min_size >= 0);\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n@@ -4099,7 +4096,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t  add_builtin_constant_p_parm (info, operand_map[ip]);\n     }\n   sreal freq = edge->sreal_frequency ();\n-  for (i = 0; vec_safe_iterate (callee_info->size_time_table, i, &e); i++)\n+  for (i = 0; callee_info->size_time_table.iterate (i, &e); i++)\n     {\n       predicate p;\n       p = e->exec_predicate.remap_after_inlining\n@@ -4146,7 +4143,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n     info->estimated_stack_size = peak;\n \n   inline_update_callee_summaries (edge->callee, es->loop_depth);\n-  if (info->call_size_time_table)\n+  if (info->call_size_time_table.length ())\n     {\n       int edge_size = 0;\n       sreal edge_time = 0;\n@@ -4181,14 +4178,14 @@ ipa_update_overall_fn_summary (struct cgraph_node *node, bool reset)\n \n   size_info->size = 0;\n   info->time = 0;\n-  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n+  for (i = 0; info->size_time_table.iterate (i, &e); i++)\n     {\n       size_info->size += e->size;\n       info->time += e->time;\n     }\n-  info->min_size = (*info->size_time_table)[0].size;\n+  info->min_size = info->size_time_table[0].size;\n   if (reset)\n-    vec_free (info->call_size_time_table);\n+    info->call_size_time_table.release ();\n   if (node->callees || node->indirect_calls)\n     estimate_calls_size_and_time (node, &size_info->size, &info->min_size,\n \t\t\t\t  &info->time, NULL,\n@@ -4452,9 +4449,9 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t    info->conds->quick_push (c);\n \t}\n       count2 = streamer_read_uhwi (&ib);\n-      gcc_assert (!info || !info->size_time_table);\n+      gcc_assert (!info || !info->size_time_table.length ());\n       if (info && count2)\n-        vec_safe_reserve_exact (info->size_time_table, count2);\n+\tinfo->size_time_table.reserve_exact (count2);\n       for (j = 0; j < count2; j++)\n \t{\n \t  class size_time_entry e;\n@@ -4465,7 +4462,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  e.nonconst_predicate.stream_in (&ib);\n \n \t  if (info)\n-\t    info->size_time_table->quick_push (e);\n+\t    info->size_time_table.quick_push (e);\n \t}\n \n       count2 = streamer_read_uhwi (&ib);\n@@ -4658,8 +4655,8 @@ ipa_fn_summary_write (void)\n \t\t    }\n \t\t}\n \t    }\n-\t  streamer_write_uhwi (ob, vec_safe_length (info->size_time_table));\n-\t  for (i = 0; vec_safe_iterate (info->size_time_table, i, &e); i++)\n+\t  streamer_write_uhwi (ob, info->size_time_table.length ());\n+\t  for (i = 0; info->size_time_table.iterate (i, &e); i++)\n \t    {\n \t      streamer_write_uhwi (ob, e->size);\n \t      e->time.stream_out (ob);"}, {"sha": "66984a96482aa0cd283c6eed5f177dfa51be2916", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/366099ff0823c3c9929dd7fb911f4af04e63baef/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/366099ff0823c3c9929dd7fb911f4af04e63baef/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=366099ff0823c3c9929dd7fb911f4af04e63baef", "patch": "@@ -72,7 +72,7 @@ struct agg_position_info\n /* Representation of function body size and time depending on the call\n    context.  We keep simple array of record, every containing of predicate\n    and time/size to account.  */\n-class GTY(()) size_time_entry\n+class size_time_entry\n {\n public:\n   /* Predicate for code to be executed.  */\n@@ -82,7 +82,7 @@ class GTY(()) size_time_entry\n      the executed code paths will simplify.  */\n   predicate nonconst_predicate;\n   int size;\n-  sreal GTY((skip)) time;\n+  sreal time;\n };\n \n /* Summary about function and stack frame sizes.  We keep this info \n@@ -129,7 +129,7 @@ class GTY(()) ipa_fn_summary\n       fp_expressions (false),\n       estimated_stack_size (false),\n       time (0), conds (NULL),\n-      size_time_table (NULL), call_size_time_table (NULL),\n+      size_time_table (), call_size_time_table (vNULL),\n       loop_iterations (NULL), loop_strides (NULL),\n       builtin_constant_p_parms (vNULL),\n       growth (0), scc_no (0)\n@@ -142,8 +142,8 @@ class GTY(()) ipa_fn_summary\n     inlinable (s.inlinable), single_caller (s.single_caller),\n     fp_expressions (s.fp_expressions),\n     estimated_stack_size (s.estimated_stack_size),\n-    time (s.time), conds (s.conds), size_time_table (s.size_time_table),\n-    call_size_time_table (NULL),\n+    time (s.time), conds (s.conds), size_time_table (),\n+    call_size_time_table (vNULL),\n     loop_iterations (s.loop_iterations), loop_strides (s.loop_strides),\n     builtin_constant_p_parms (s.builtin_constant_p_parms),\n     growth (s.growth), scc_no (s.scc_no)\n@@ -181,8 +181,11 @@ class GTY(()) ipa_fn_summary\n      accounted in call_size_time_table.  This is because calls\n      are often adjusted by IPA optimizations and thus this summary\n      is generated from call summary information when needed.  */\n-  vec<size_time_entry, va_gc> *size_time_table;\n-  vec<size_time_entry, va_gc> *call_size_time_table;\n+  auto_vec<size_time_entry> GTY((skip)) size_time_table;\n+  /* Unlike size_time_table that is initialized for all summaries\n+     call_size_time_table is allocated only for functions with\n+     many calls.  Use effecient vl_ptr storage.  */\n+  vec<size_time_entry, va_heap, vl_ptr> GTY((skip)) call_size_time_table;\n \n   /* Predicates on when some loops in the function can have known bounds.  */\n   vec<ipa_freqcounting_predicate, va_gc> *loop_iterations;"}]}