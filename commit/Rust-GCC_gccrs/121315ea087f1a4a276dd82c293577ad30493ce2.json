{"sha": "121315ea087f1a4a276dd82c293577ad30493ce2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxMzE1ZWEwODdmMWE0YTI3NmRkODJjMjkzNTc3YWQzMDQ5M2NlMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1999-02-03T20:11:56Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-03T20:11:56Z"}, "message": "reload1.c (reload_cse_regs_1): Undo Jan 16 patch.\n\n        * reload1.c (reload_cse_regs_1): Undo Jan 16 patch.\n        * reload.c (find_reusable_reload): New function, broken out of\n        push_reload.  Add code to verify that none of the involved\n        outputs are subject to earlyclobbers.\n        (push_reload): Break out new function find_reusable_reload.\n        Delete \"register\" keyword for IN, OUT args.\n\nFrom-SVN: r25010", "tree": {"sha": "ad7f7ea2dd3623e8d2f286ada1de77d4d80cd9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad7f7ea2dd3623e8d2f286ada1de77d4d80cd9c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/121315ea087f1a4a276dd82c293577ad30493ce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121315ea087f1a4a276dd82c293577ad30493ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/121315ea087f1a4a276dd82c293577ad30493ce2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/121315ea087f1a4a276dd82c293577ad30493ce2/comments", "author": null, "committer": null, "parents": [{"sha": "5ed45d4031b6ae596ac000a10cbc546a9f5a31b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ed45d4031b6ae596ac000a10cbc546a9f5a31b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ed45d4031b6ae596ac000a10cbc546a9f5a31b3"}], "stats": {"total": 171, "additions": 105, "deletions": 66}, "files": [{"sha": "aade5ed4b96de7c4cc46c4eab4c68dd3f4ff6e28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121315ea087f1a4a276dd82c293577ad30493ce2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121315ea087f1a4a276dd82c293577ad30493ce2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=121315ea087f1a4a276dd82c293577ad30493ce2", "patch": "@@ -1,3 +1,12 @@\n+Wed Feb  3 21:07:38 1999  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* reload1.c (reload_cse_regs_1): Undo Jan 16 patch.\n+\t* reload.c (find_reusable_reload): New function, broken out of\n+\tpush_reload.  Add code to verify that none of the involved\n+\toutputs are subject to earlyclobbers.\n+\t(push_reload): Break out new function find_reusable_reload.\n+\tDelete \"register\" keyword for IN, OUT args.\n+\n Wed Feb  3 15:51:04 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* config/mips/mips.c (true_reg_or_0_operand) : New function."}, {"sha": "aa16d10c64893bf9cd40c6105a18dda226347b8f", "filename": "gcc/reload.c", "status": "modified", "additions": 94, "deletions": 64, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121315ea087f1a4a276dd82c293577ad30493ce2/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121315ea087f1a4a276dd82c293577ad30493ce2/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=121315ea087f1a4a276dd82c293577ad30493ce2", "patch": "@@ -317,6 +317,8 @@ static int push_reload\t\tPROTO((rtx, rtx, rtx *, rtx *, enum reg_class,\n \t\t\t\t       int, int, int, enum reload_type));\n static void push_replacement\tPROTO((rtx *, int, enum machine_mode));\n static void combine_reloads\tPROTO((void));\n+static int find_reusable_reload\tPROTO((rtx *, rtx, enum reg_class,\n+\t\t\t\t       enum reload_type, int, int));\n static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       enum reg_class, int, int));\n@@ -744,6 +746,96 @@ find_valid_class (m1, n)\n   return best_class;\n }\n \f\n+/* Return the number of a previously made reload that can be combined with\n+   a new one, or n_reloads if none of the existing reloads can be used.\n+   OUT, CLASS, TYPE and OPNUM are the same arguments as passed to\n+   push_reload, they determine the kind of the new reload that we try to\n+   combine.  P_IN points to the corresponding value of IN, which can be\n+   modified by this function.\n+   DONT_SHARE is nonzero if we can't share any input-only reload for IN.  */\n+static int\n+find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n+     rtx *p_in, out;\n+     enum reg_class class;\n+     enum reload_type type;\n+     int opnum, dont_share;\n+{\n+  rtx in = *p_in;\n+  int i;\n+  /* We can't merge two reloads if the output of either one is\n+     earlyclobbered.  */\n+\n+  if (earlyclobber_operand_p (out))\n+    return n_reloads;\n+\n+  /* We can use an existing reload if the class is right\n+     and at least one of IN and OUT is a match\n+     and the other is at worst neutral.\n+     (A zero compared against anything is neutral.) \n+\n+     If SMALL_REGISTER_CLASSES, don't use existing reloads unless they are\n+     for the same thing since that can cause us to need more reload registers\n+     than we otherwise would.  */\n+   \n+  for (i = 0; i < n_reloads; i++)\n+    if ((reg_class_subset_p (class, reload_reg_class[i])\n+\t || reg_class_subset_p (reload_reg_class[i], class))\n+\t/* If the existing reload has a register, it must fit our class.  */\n+\t&& (reload_reg_rtx[i] == 0\n+\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t\t\t\t  true_regnum (reload_reg_rtx[i])))\n+\t&& ((in != 0 && MATCHES (reload_in[i], in) && ! dont_share\n+\t     && (out == 0 || reload_out[i] == 0 || MATCHES (reload_out[i], out)))\n+\t    ||\n+\t    (out != 0 && MATCHES (reload_out[i], out)\n+\t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in))))\n+\t&& (reload_out[i] == 0 || ! earlyclobber_operand_p (reload_out[i]))\n+\t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n+\t    && MERGABLE_RELOADS (type, reload_when_needed[i],\n+\t\t\t\t opnum, reload_opnum[i]))\n+      return i;\n+\n+  /* Reloading a plain reg for input can match a reload to postincrement\n+     that reg, since the postincrement's value is the right value.\n+     Likewise, it can match a preincrement reload, since we regard\n+     the preincrementation as happening before any ref in this insn\n+     to that register.  */\n+  for (i = 0; i < n_reloads; i++)\n+    if ((reg_class_subset_p (class, reload_reg_class[i])\n+\t || reg_class_subset_p (reload_reg_class[i], class))\n+\t/* If the existing reload has a register, it must fit our\n+\t   class.  */\n+\t&& (reload_reg_rtx[i] == 0\n+\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n+\t\t\t\t  true_regnum (reload_reg_rtx[i])))\n+\t&& out == 0 && reload_out[i] == 0 && reload_in[i] != 0\n+\t&& ((GET_CODE (in) == REG\n+\t     && (GET_CODE (reload_in[i]) == POST_INC\n+\t\t || GET_CODE (reload_in[i]) == POST_DEC\n+\t\t || GET_CODE (reload_in[i]) == PRE_INC\n+\t\t || GET_CODE (reload_in[i]) == PRE_DEC)\n+\t     && MATCHES (XEXP (reload_in[i], 0), in))\n+\t    ||\n+\t    (GET_CODE (reload_in[i]) == REG\n+\t     && (GET_CODE (in) == POST_INC\n+\t\t || GET_CODE (in) == POST_DEC\n+\t\t || GET_CODE (in) == PRE_INC\n+\t\t || GET_CODE (in) == PRE_DEC)\n+\t     && MATCHES (XEXP (in, 0), reload_in[i])))\n+\t&& (reload_out[i] == 0 || ! earlyclobber_operand_p (reload_out[i]))\n+\t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n+\t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n+\t\t\t     opnum, reload_opnum[i]))\n+      {\n+\t/* Make sure reload_in ultimately has the increment,\n+\t   not the plain register.  */\n+\tif (GET_CODE (in) == REG)\n+\t  *p_in = reload_in[i];\n+\treturn i;\n+      }\n+  return n_reloads;\n+}\n+\n /* Record one reload that needs to be performed.\n    IN is an rtx saying where the data are to be found before this instruction.\n    OUT says where they must be stored after the instruction.\n@@ -780,7 +872,7 @@ find_valid_class (m1, n)\n static int\n push_reload (in, out, inloc, outloc, class,\n \t     inmode, outmode, strict_low, optional, opnum, type)\n-     register rtx in, out;\n+     rtx in, out;\n      rtx *inloc, *outloc;\n      enum reg_class class;\n      enum machine_mode inmode, outmode;\n@@ -1179,69 +1271,7 @@ push_reload (in, out, inloc, outloc, class,\n       && (optional == 0 || type != RELOAD_FOR_OUTPUT))\n     abort ();\n \n-  /* We can use an existing reload if the class is right\n-     and at least one of IN and OUT is a match\n-     and the other is at worst neutral.\n-     (A zero compared against anything is neutral.) \n-\n-     If SMALL_REGISTER_CLASSES, don't use existing reloads unless they are\n-     for the same thing since that can cause us to need more reload registers\n-     than we otherwise would.  */\n-\n-  for (i = 0; i < n_reloads; i++)\n-    if ((reg_class_subset_p (class, reload_reg_class[i])\n-\t || reg_class_subset_p (reload_reg_class[i], class))\n-\t/* If the existing reload has a register, it must fit our class.  */\n-\t&& (reload_reg_rtx[i] == 0\n-\t    || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n-\t\t\t\t  true_regnum (reload_reg_rtx[i])))\n-\t&& ((in != 0 && MATCHES (reload_in[i], in) && ! dont_share\n-\t     && (out == 0 || reload_out[i] == 0 || MATCHES (reload_out[i], out)))\n-\t    ||\n-\t    (out != 0 && MATCHES (reload_out[i], out)\n-\t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in))))\n-\t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n-\t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n-\t\t\t     opnum, reload_opnum[i]))\n-      break;\n-\n-  /* Reloading a plain reg for input can match a reload to postincrement\n-     that reg, since the postincrement's value is the right value.\n-     Likewise, it can match a preincrement reload, since we regard\n-     the preincrementation as happening before any ref in this insn\n-     to that register.  */\n-  if (i == n_reloads)\n-    for (i = 0; i < n_reloads; i++)\n-      if ((reg_class_subset_p (class, reload_reg_class[i])\n-\t   || reg_class_subset_p (reload_reg_class[i], class))\n-\t  /* If the existing reload has a register, it must fit our class.  */\n-\t  && (reload_reg_rtx[i] == 0\n-\t      || TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n-\t\t\t\t    true_regnum (reload_reg_rtx[i])))\n-\t  && out == 0 && reload_out[i] == 0 && reload_in[i] != 0\n-\t  && ((GET_CODE (in) == REG\n-\t       && (GET_CODE (reload_in[i]) == POST_INC\n-\t\t   || GET_CODE (reload_in[i]) == POST_DEC\n-\t\t   || GET_CODE (reload_in[i]) == PRE_INC\n-\t\t   || GET_CODE (reload_in[i]) == PRE_DEC)\n-\t       && MATCHES (XEXP (reload_in[i], 0), in))\n-\t      ||\n-\t      (GET_CODE (reload_in[i]) == REG\n-\t       && (GET_CODE (in) == POST_INC\n-\t\t   || GET_CODE (in) == POST_DEC\n-\t\t   || GET_CODE (in) == PRE_INC\n-\t\t   || GET_CODE (in) == PRE_DEC)\n-\t       && MATCHES (XEXP (in, 0), reload_in[i])))\n-\t  && (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n-\t  && MERGABLE_RELOADS (type, reload_when_needed[i],\n-\t\t\t       opnum, reload_opnum[i]))\n-\t{\n-\t  /* Make sure reload_in ultimately has the increment,\n-\t     not the plain register.  */\n-\t  if (GET_CODE (in) == REG)\n-\t    in = reload_in[i];\n-\t  break;\n-\t}\n+  i = find_reusable_reload (&in, out, class, type, opnum, dont_share);\n \n   if (i == n_reloads)\n     {"}, {"sha": "cfacc78ac502f44b1ae6b11a0e2efdd397bdd126", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/121315ea087f1a4a276dd82c293577ad30493ce2/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/121315ea087f1a4a276dd82c293577ad30493ce2/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=121315ea087f1a4a276dd82c293577ad30493ce2", "patch": "@@ -8713,7 +8713,7 @@ reload_cse_regs_1 (first)\n \n \t  if (count > 0)\n \t    apply_change_group ();\n-\t  else if (asm_noperands (PATTERN (insn)) < 0)\n+\t  else\n \t    reload_cse_simplify_operands (insn);\n \t    \n \t  reload_cse_record_set (body, body);\n@@ -8770,7 +8770,7 @@ reload_cse_regs_1 (first)\n \n \t  if (count > 0)\n \t    apply_change_group ();\n-\t  else if (asm_noperands (PATTERN (insn)) < 0)\n+\t  else\n \t    reload_cse_simplify_operands (insn);\n \n \t  /* Look through the PARALLEL and record the values being"}]}