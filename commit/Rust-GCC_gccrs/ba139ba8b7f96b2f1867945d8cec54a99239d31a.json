{"sha": "ba139ba8b7f96b2f1867945d8cec54a99239d31a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmExMzliYThiN2Y5NmIyZjE4Njc5NDVkOGNlYzU0YTk5MjM5ZDMxYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-02-11T20:15:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-02-11T20:15:13Z"}, "message": "re PR c++/26988 (template constructor in template class derived from virtual base can not be specialized)\n\n\tPR c++/26988\n\t* pt.c (determine_specialization): Use skip_artificial_parms_for.\n\t(fn_type_unificiation): Likewise.\n\t(get_bindings): Likewise.\n\tPR c++/26988\n\t* g++.dg/template/spec34.C: New test\n\nFrom-SVN: r121822", "tree": {"sha": "b0daa91b6449085a518b84cd8d92e91bbad4767a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0daa91b6449085a518b84cd8d92e91bbad4767a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba139ba8b7f96b2f1867945d8cec54a99239d31a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba139ba8b7f96b2f1867945d8cec54a99239d31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba139ba8b7f96b2f1867945d8cec54a99239d31a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba139ba8b7f96b2f1867945d8cec54a99239d31a/comments", "author": null, "committer": null, "parents": [{"sha": "a31830a7cab48698868c117ba9100ec31069a91b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31830a7cab48698868c117ba9100ec31069a91b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31830a7cab48698868c117ba9100ec31069a91b"}], "stats": {"total": 93, "additions": 57, "deletions": 36}, "files": [{"sha": "b7aaff1aa4838128c15f243816a48ffb7ce20280", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ba139ba8b7f96b2f1867945d8cec54a99239d31a", "patch": "@@ -1,4 +1,11 @@\n-2007-02-06  Mark Mitchell  <mark@codesourcery.com>\n+2007-02-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/26988\n+\t* pt.c (determine_specialization): Use skip_artificial_parms_for.\n+\t(fn_type_unificiation): Likewise.\n+\t(get_bindings): Likewise.\n+\n+o2007-02-06  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR target/29487\n \t* decl.c (finish_function): Use DECL_REPLACEABLE."}, {"sha": "078d433daf8a6fac36509bd1f3e40fc43c25c03a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ba139ba8b7f96b2f1867945d8cec54a99239d31a", "patch": "@@ -1436,33 +1436,6 @@ determine_specialization (tree template_id,\n \t  tree decl_arg_types;\n \t  tree fn_arg_types;\n \n-\t  /* DECL might be a specialization of FN.  */\n-\n-\t  /* Adjust the type of DECL in case FN is a static member.  */\n-\t  decl_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\t  if (DECL_STATIC_FUNCTION_P (fn)\n-\t      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n-\t    decl_arg_types = TREE_CHAIN (decl_arg_types);\n-\n-\t  /* Check that the number of function parameters matches.\n-\t     For example,\n-\t       template <class T> void f(int i = 0);\n-\t       template <> void f<int>();\n-\t     The specialization f<int> is invalid but is not caught\n-\t     by get_bindings below.  */\n-\n-\t  fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t  if (list_length (fn_arg_types) != list_length (decl_arg_types))\n-\t    continue;\n-\n-\t  /* For a non-static member function, we need to make sure that\n-\t     the const qualification is the same. This can be done by\n-\t     checking the 'this' in the argument list.  */\n-\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n-\t      && !same_type_p (TREE_VALUE (fn_arg_types),\n-\t\t\t       TREE_VALUE (decl_arg_types)))\n-\t    continue;\n-\n \t  /* In case of explicit specialization, we need to check if\n \t     the number of template headers appearing in the specialization\n \t     is correct. This is usually done in check_explicit_specialization,\n@@ -1501,14 +1474,44 @@ determine_specialization (tree template_id,\n \t\t\t\t      (current_template_parms))))\n \t    continue;\n \n+\t  /* DECL might be a specialization of FN.  */\n+\t  decl_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+\t  fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\n+\t  /* For a non-static member function, we need to make sure\n+\t     that the const qualification is the same.  Since\n+\t     get_bindings does not try to merge the \"this\" parameter,\n+\t     we must do the comparison explicitly.  */\n+\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n+\t      && !same_type_p (TREE_VALUE (fn_arg_types),\n+\t\t\t       TREE_VALUE (decl_arg_types)))\n+\t    continue;\n+\n+\t  /* Skip the \"this\" parameter and, for constructors of\n+\t     classes with virtual bases, the VTT parameter.  A\n+\t     full specialization of a constructor will have a VTT\n+\t     parameter, but a template never will.  */ \n+\t  decl_arg_types \n+\t    = skip_artificial_parms_for (decl, decl_arg_types);\n+\t  fn_arg_types \n+\t    = skip_artificial_parms_for (fn, fn_arg_types);\n+\n+\t  /* Check that the number of function parameters matches.\n+\t     For example,\n+\t       template <class T> void f(int i = 0);\n+\t       template <> void f<int>();\n+\t     The specialization f<int> is invalid but is not caught\n+\t     by get_bindings below.  */\n+\t  if (list_length (fn_arg_types) != list_length (decl_arg_types))\n+\t    continue;\n+\n \t  /* Function templates cannot be specializations; there are\n \t     no partial specializations of functions.  Therefore, if\n \t     the type of DECL does not match FN, there is no\n \t     match.  */\n \t  if (tsk == tsk_template)\n \t    {\n-\t      if (compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n-\t\t\t     decl_arg_types))\n+\t      if (compparms (fn_arg_types, decl_arg_types))\n \t\tcandidates = tree_cons (NULL_TREE, fn, candidates);\n \t      continue;\n \t    }\n@@ -9843,10 +9846,8 @@ fn_type_unification (tree fn,\n \tTREE_VEC_ELT (targs, i) = TREE_VEC_ELT (converted_args, i);\n     }\n \n-  parms = TYPE_ARG_TYPES (fntype);\n   /* Never do unification on the 'this' parameter.  */\n-  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n-    parms = TREE_CHAIN (parms);\n+  parms = skip_artificial_parms_for (fn, TYPE_ARG_TYPES (fntype));\n \n   if (return_type)\n     {\n@@ -11394,10 +11395,9 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n \treturn NULL_TREE;\n     }\n \n-  decl_arg_types = TYPE_ARG_TYPES (decl_type);\n   /* Never do unification on the 'this' parameter.  */\n-  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n-    decl_arg_types = TREE_CHAIN (decl_arg_types);\n+  decl_arg_types = skip_artificial_parms_for (decl, \n+\t\t\t\t\t      TYPE_ARG_TYPES (decl_type));\n \n   if (fn_type_unification (fn, explicit_args, targs,\n \t\t\t   decl_arg_types,"}, {"sha": "86c4ead2dd2c6a28296f10de3e6b22b883ca6673", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba139ba8b7f96b2f1867945d8cec54a99239d31a", "patch": "@@ -1,3 +1,8 @@\n+2007-02-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/26988\n+\t* g++.dg/template/spec34.C: New test\n+\n 2007-02-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/vect/vect-intfloat-conversion-1.c: Loop gets vectorized"}, {"sha": "6c28e57fb9ff2f143df58b64dbcaf90fb9bdda60", "filename": "gcc/testsuite/g++.dg/template/spec34.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba139ba8b7f96b2f1867945d8cec54a99239d31a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec34.C?ref=ba139ba8b7f96b2f1867945d8cec54a99239d31a", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/26988\n+\n+struct B{};\n+\n+struct Bar : virtual B {               \n+  template <typename T> Bar( T const& cast );\n+};\n+\n+template <> Bar::Bar( int const & cast ) {}"}]}