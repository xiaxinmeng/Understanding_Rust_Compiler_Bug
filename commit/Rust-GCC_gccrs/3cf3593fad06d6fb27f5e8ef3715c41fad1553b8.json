{"sha": "3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmMzU5M2ZhZDA2ZDZmYjI3ZjVlOGVmMzcxNWM0MWZhZDE1NTNiOA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-05T23:42:43Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-05T23:42:43Z"}, "message": "cppfiles.c (stack_include_file): Push zero-length buffers in case of failure.\n\n        * cppfiles.c (stack_include_file): Push zero-length buffers\n        in case of failure.  Return void, as we don't fail any more.\n        (read_include_file): Check for files we shouldn't re-read.\n        Don't return an error code; errors are implied by marking the\n        file NEVER_REREAD.\n        (_cpp_execute_include): Move the recursion and in-macro checks\n        here.  Update for stack_include_file not failing.\n        * cpplib.c (cpp_push_buffer): Always succeed, since\n        _cpp_execute_include performs the recursion check.  Tidy up.\n        * cpplib.h (cpp_push_buffer): Update prototype.\n\nFrom-SVN: r38057", "tree": {"sha": "f75c0eae70e97a88004eb221f90aa6ae6175ab77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f75c0eae70e97a88004eb221f90aa6ae6175ab77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/comments", "author": null, "committer": null, "parents": [{"sha": "d53c4221afa7f4a00b7200c6d9023e1c6c5c2769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d53c4221afa7f4a00b7200c6d9023e1c6c5c2769", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d53c4221afa7f4a00b7200c6d9023e1c6c5c2769"}], "stats": {"total": 129, "additions": 72, "deletions": 57}, "files": [{"sha": "d32d01426f15b0fef6d0c80aa31aa229c08cc19d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "patch": "@@ -1,3 +1,16 @@\n+2000-12-05  Neil Booth  <neilb@earthling.net>\n+\n+        * cppfiles.c (stack_include_file): Push zero-length buffers\n+        in case of failure.  Return void, as we don't fail any more.\n+        (read_include_file): Check for files we shouldn't re-read.\n+        Don't return an error code; errors are implied by marking the\n+        file NEVER_REREAD.\n+        (_cpp_execute_include): Move the recursion and in-macro checks\n+        here.  Update for stack_include_file not failing.\n+        * cpplib.c (cpp_push_buffer): Always succeed, since\n+        _cpp_execute_include performs the recursion check.  Tidy up.\n+        * cpplib.h (cpp_push_buffer): Update prototype.\n+\n 2000-12-05  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* sched-vis.c (visual_tbl_line_length): New variable."}, {"sha": "0e924b3fc237aefb51715b3ab6824b4c8a401146", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 47, "deletions": 37, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "patch": "@@ -74,8 +74,8 @@ static struct include_file *find_include_file\n \t\t\t\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t struct file_name_list *));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n-static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n-static int stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n+static void read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n+static void stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void purge_cache \tPARAMS ((struct include_file *));\n static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n@@ -204,10 +204,11 @@ open_file (pfile, filename)\n   return 0;\n }\n \n-/* Place the file referenced by INC into a new buffer on PFILE's stack.\n-   Return 1 if successful, 0 if not.  */\n+/* Place the file referenced by INC into a new buffer on PFILE's\n+   stack.  If there are errors, or the file should not be re-included,\n+   a null buffer is pushed.  */\n \n-static int\n+static void\n stack_include_file (pfile, inc)\n      cpp_reader *pfile;\n      struct include_file *inc;\n@@ -222,45 +223,37 @@ stack_include_file (pfile, inc)\n       lineno = pfile->buffer->lineno;\n     }\n \n-  if (pfile->context->prev)\n-    cpp_ice (pfile, \"attempt to push file buffer with contexts stacked\");\n-\n-  if (DO_NOT_REREAD (inc))\n-    return 0;\n-\n-  if (inc->buffer == NULL)\n-    if (read_include_file (pfile, inc) == 0)\n-      return 0;\n+  /* Not in cache?  */\n+  if (! inc->buffer)\n+    read_include_file (pfile, inc);\n \n+  /* Push a null buffer.  */\n   fp = cpp_push_buffer (pfile, NULL, 0);\n-  if (fp == 0)\n-    return 0;\n-\n-  /* Initialise controlling macro state.  */\n-  pfile->mi_state = MI_OUTSIDE;\n-  pfile->mi_cmacro = 0;\n-\n   fp->inc = inc;\n   fp->nominal_fname = inc->name;\n   fp->buf = inc->buffer;\n-  fp->rlimit = fp->buf + inc->st.st_size;\n+  fp->rlimit = fp->buf;\n+  if (! DO_NOT_REREAD (inc))\n+    fp->rlimit += inc->st.st_size;\n   fp->cur = fp->buf;\n-  fp->lineno = 0;\n   fp->line_base = fp->buf;\n+  fp->lineno = 0;\t\t/* For _cpp_do_file_change.  */\n+  fp->inc->refcnt++;\n \n   /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n      see do_include */\n   if (!CPP_OPTION (pfile, ignore_srcdir))\n     fp->actual_dir = actual_directory (pfile, inc->name);\n \n-  fp->inc->refcnt++;\n+  /* Initialise controlling macro state.  */\n+  pfile->mi_state = MI_OUTSIDE;\n+  pfile->mi_cmacro = 0;\n   pfile->include_depth++;\n   pfile->input_stack_listing_current = 0;\n \n   _cpp_do_file_change (pfile, FC_ENTER, filename, lineno);\n \n   fp->lineno = 1;\n-  return 1;\n }\n \n /* Read the file referenced by INC into the file cache.\n@@ -278,7 +271,7 @@ stack_include_file (pfile, inc)\n \n    FIXME: Flush file cache and try again if we run out of memory.  */\n \n-static int\n+static void\n read_include_file (pfile, inc)\n      cpp_reader *pfile;\n      struct include_file *inc;\n@@ -289,6 +282,9 @@ read_include_file (pfile, inc)\n   static int pagesize = -1;\n #endif\n \n+  if (DO_NOT_REREAD (inc))\n+    return;\n+\n   if (S_ISREG (inc->st.st_mode))\n     {\n       /* off_t might have a wider range than ssize_t - in other words,\n@@ -373,7 +369,7 @@ read_include_file (pfile, inc)\n   close (inc->fd);\n   inc->buffer = buf;\n   inc->fd = -1;\n-  return 1;\n+  return;\n \n  perror_fail:\n   cpp_error_from_errno (pfile, inc->name);\n@@ -382,7 +378,7 @@ read_include_file (pfile, inc)\n   close (inc->fd);\n   inc->fd = -1;\n   inc->cmacro = NEVER_REREAD;\n-  return 0;\n+  return;\n }\n \n static void\n@@ -583,6 +579,20 @@ _cpp_execute_include (pfile, header, no_reinclude, search_start)\n   struct include_file *inc;\n   char *fname;\n \n+  /* Help protect #include or similar from recursion.  */\n+  if (pfile->buffer_stack_depth >= CPP_STACK_MAX)\n+    {\n+      cpp_fatal (pfile, \"#include nested too deeply\");\n+      return;\n+    }\n+\n+  /* Check we've tidied up #include before entering the buffer.  */\n+  if (pfile->context->prev)\n+    {\n+      cpp_ice (pfile, \"attempt to push file buffer with contexts stacked\");\n+      return;\n+    }\n+\n   fname = alloca (len + 1);\n   memcpy (fname, header->val.str.text, len);\n   fname[len] = '\\0';\n@@ -613,11 +623,13 @@ _cpp_execute_include (pfile, header, no_reinclude, search_start)\n       inc->include_count++;\n \n       /* Actually process the file.  */\n-      if (stack_include_file (pfile, inc))\n-\t{\n-\t  if (angle_brackets)\n-\t    pfile->system_include_depth++;\n+      stack_include_file (pfile, inc);\n+\n+      if (angle_brackets)\n+\tpfile->system_include_depth++;\n \n+      if (! DO_NOT_REREAD (inc))\n+\t{\n \t  if (no_reinclude)\n \t    inc->cmacro = NEVER_REREAD;\n \n@@ -630,6 +642,7 @@ _cpp_execute_include (pfile, header, no_reinclude, search_start)\n \t      fprintf (stderr, \" %s\\n\", inc->name);\n \t    }\n \t}\n+\n       return;\n     }\n       \n@@ -730,11 +743,8 @@ _cpp_read_file (pfile, fname)\n       return 0;\n     }\n \n-  /* Return success for zero-length files.  */\n-  if (DO_NOT_REREAD (f))\n-    return 1;\n-\n-  return stack_include_file (pfile, f);\n+  stack_include_file (pfile, f);\n+  return 1;\n }\n \n /* Do appropriate cleanup when a file buffer is popped off the input"}, {"sha": "26c2ece60b769bbcc2feccd2b3afc2895a327c62", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "patch": "@@ -1731,42 +1731,34 @@ handle_assertion (pfile, str, type)\n   run_directive (pfile, type, str, count, 0);\n }\n \n-/* Allocate a new cpp_buffer for PFILE, and push it on the input\n-   buffer stack.  If BUFFER != NULL, then use the LENGTH characters in\n-   BUFFER as the new input buffer.  Return the new buffer, or NULL on\n-   failure.  */\n+/* Push a new buffer on the buffer stack.  Buffer can be NULL, but\n+   then LEN should be 0.  Returns the new buffer; it doesn't fail.  */\n \n cpp_buffer *\n-cpp_push_buffer (pfile, buffer, length)\n+cpp_push_buffer (pfile, buffer, len)\n      cpp_reader *pfile;\n      const U_CHAR *buffer;\n-     long length;\n+     size_t len;\n {\n-  cpp_buffer *buf = CPP_BUFFER (pfile);\n-  cpp_buffer *new;\n-  if (++pfile->buffer_stack_depth == CPP_STACK_MAX)\n-    {\n-      cpp_fatal (pfile, \"#include nested too deeply\");\n-      return NULL;\n-    }\n+  cpp_buffer *new = xobnew (pfile->buffer_ob, cpp_buffer);\n \n-  new = xobnew (pfile->buffer_ob, cpp_buffer);\n   /* Clears, amongst other things, if_stack and mi_cmacro.  */\n   memset (new, 0, sizeof (cpp_buffer));\n-\n-  pfile->lexer_pos.output_line = 1;\n   new->line_base = new->buf = new->cur = buffer;\n-  new->rlimit = buffer + length;\n-  new->prev = buf;\n+  new->rlimit = buffer + len;\n+  new->prev = pfile->buffer;\n   new->pfile = pfile;\n   /* Preprocessed files don't do trigraph and escaped newline processing.  */\n   new->from_stage3 = CPP_OPTION (pfile, preprocessed);\n   /* No read ahead or extra char initially.  */\n   new->read_ahead = EOF;\n   new->extra_char = EOF;\n+\n   pfile->state.next_bol = 1;\n+  pfile->buffer_stack_depth++;\n+  pfile->lexer_pos.output_line = 1;\n \n-  CPP_BUFFER (pfile) = new;\n+  pfile->buffer = new;\n   return new;\n }\n "}, {"sha": "0caff3fb98ee762787e7f324474a2b2dc87eb6a2", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3593fad06d6fb27f5e8ef3715c41fad1553b8/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=3cf3593fad06d6fb27f5e8ef3715c41fad1553b8", "patch": "@@ -725,7 +725,7 @@ extern void cpp_undef  PARAMS ((cpp_reader *, const char *));\n extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n \n extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n-\t\t\t\t\t    const unsigned char *, long));\n+\t\t\t\t\t    const unsigned char *, size_t));\n extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n "}]}