{"sha": "bcff0913882cc6e70f90be3d8448ec0186d21abc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmZjA5MTM4ODJjYzZlNzBmOTBiZTNkODQ0OGVjMDE4NmQyMWFiYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-01-20T07:54:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-01-20T07:54:26Z"}, "message": "[PATCH] [target/25114] Improve comparisons against some small integers for m68k\n\n\t* config/m68k/predicates.md (pow2_m1_operand): New predicate\n\textracted from ...\n\t(reg_or_pow2_m1_operand): Call pow2_m1_operand.\n\t(pc_or_label_operand): New predicate.\n\t* config/m68k/m68k.md: Add new peephole2 patterns for GTU/LEU\n\ttests for small integers that are 2^n - 1.\n\n\t* gcc.target/m68k/pr25114.c: New test.\n\nFrom-SVN: r232601", "tree": {"sha": "5d9f7b573fc95196488974f89850d1834ebafc87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d9f7b573fc95196488974f89850d1834ebafc87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcff0913882cc6e70f90be3d8448ec0186d21abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcff0913882cc6e70f90be3d8448ec0186d21abc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcff0913882cc6e70f90be3d8448ec0186d21abc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcff0913882cc6e70f90be3d8448ec0186d21abc/comments", "author": null, "committer": null, "parents": [{"sha": "a3f69631af2a64405722a526650b96fbcf9a9373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f69631af2a64405722a526650b96fbcf9a9373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f69631af2a64405722a526650b96fbcf9a9373"}], "stats": {"total": 140, "additions": 137, "deletions": 3}, "files": [{"sha": "764b2092063c648574934b2fc2a6d35edad0bb9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcff0913882cc6e70f90be3d8448ec0186d21abc", "patch": "@@ -1,3 +1,12 @@\n+2016-01-20  Jeff Law  <law@redhat.com>\n+\n+\t* config/m68k/predicates.md (pow2_m1_operand): New predicate\n+\textracted from ...\n+\t(reg_or_pow2_m1_operand): Call pow2_m1_operand.\n+\t(pc_or_label_operand): New predicate.\n+\t* config/m68k/m68k.md: Add new peephole2 patterns for GTU/LEU\n+\ttests for small integers that are 2^n - 1.\n+\t\n 2016-01-20  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/invoke.texi (Options Summary): Add '.' after @xref."}, {"sha": "5731780631f68d4a8f5fa0c905b0b466234e2b4b", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=bcff0913882cc6e70f90be3d8448ec0186d21abc", "patch": "@@ -7634,3 +7634,88 @@\n    (set (mem:QI (match_dup 5))\n \t(const_int 0))]\n   \"operands[5] = (operands[0] == operands[3]) ? operands[4] : operands[3];\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"pow2_m1_operand\" \"\"))\n+   (set (cc0) (compare (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 3 \"register_operand\" \"\")))\n+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))\n+\t\t\t   (match_operand 4 \"pc_or_label_operand\")\n+\t\t\t   (match_operand 5 \"pc_or_label_operand\")))]\n+  \"INTVAL (operands[1]) <= 255\n+   && operands[0] == operands[3]\n+   && peep2_reg_dead_p (2, operands[0])\n+   && peep2_reg_dead_p (2, operands[2])\n+   && (operands[4] == pc_rtx || operands[5] == pc_rtx)\n+   && (optimize_size || TUNE_68040_60)\n+   && DATA_REG_P (operands[2])\"\n+  [(set (match_dup 7) (lshiftrt:SI (match_dup 7) (match_dup 6)))\n+   (set (cc0) (compare (match_dup 7) (const_int 0)))\n+   (set (pc) (if_then_else (ne (cc0) (const_int 0))\n+\t\t\t   (match_dup 4) (match_dup 5)))]\n+  \"\n+{\n+  operands[6] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  operands[7] = operands[2];\n+}\")\n+\n+(define_peephole2\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 1 \"pow2_m1_operand\" \"\")))\n+   (set (pc) (if_then_else (gtu (cc0) (const_int 0))\n+\t\t\t   (match_operand 2 \"pc_or_label_operand\")\n+\t\t\t   (match_operand 3 \"pc_or_label_operand\")))]\n+  \"INTVAL (operands[1]) <= 255\n+   && peep2_reg_dead_p (1, operands[0])\n+   && (operands[2] == pc_rtx || operands[3] == pc_rtx)\n+   && (optimize_size || TUNE_68040_60)\n+   && DATA_REG_P (operands[0])\"\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 4)))\n+   (set (cc0) (compare (match_dup 0) (const_int 0)))\n+   (set (pc) (if_then_else (ne (cc0) (const_int 0))\n+\t\t\t   (match_dup 2) (match_dup 3)))]\n+  \"{ operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1)); }\")\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"pow2_m1_operand\" \"\"))\n+   (set (cc0) (compare (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 3 \"register_operand\" \"\")))\n+   (set (pc) (if_then_else (leu (cc0) (const_int 0))\n+\t\t\t   (match_operand 4 \"pc_or_label_operand\")\n+\t\t\t   (match_operand 5 \"pc_or_label_operand\")))]\n+  \"INTVAL (operands[1]) <= 255\n+   && operands[0] == operands[3]\n+   && peep2_reg_dead_p (2, operands[0])\n+   && peep2_reg_dead_p (2, operands[2])\n+   && (operands[4] == pc_rtx || operands[5] == pc_rtx)\n+   && (optimize_size || TUNE_68040_60)\n+   && DATA_REG_P (operands[2])\"\n+  [(set (match_dup 7) (lshiftrt:SI (match_dup 7) (match_dup 6)))\n+   (set (cc0) (compare (match_dup 7) (const_int 0)))\n+   (set (pc) (if_then_else (eq (cc0) (const_int 0))\n+\t\t\t   (match_dup 4) (match_dup 5)))]\n+  \"\n+{\n+  operands[6] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  operands[7] = operands[2];\n+}\")\n+\n+(define_peephole2\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 1 \"pow2_m1_operand\" \"\")))\n+   (set (pc) (if_then_else (leu (cc0) (const_int 0))\n+\t\t\t   (match_operand 2 \"pc_or_label_operand\")\n+\t\t\t   (match_operand 3 \"pc_or_label_operand\")))]\n+  \"INTVAL (operands[1]) <= 255\n+   &&  peep2_reg_dead_p (1, operands[0])\n+   && (operands[2] == pc_rtx || operands[3] == pc_rtx)\n+   && (optimize_size || TUNE_68040_60)\n+   && DATA_REG_P (operands[0])\"\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 4)))\n+   (set (cc0) (compare (match_dup 0) (const_int 0)))\n+   (set (pc) (if_then_else (eq (cc0) (const_int 0))\n+\t\t\t   (match_dup 2) (match_dup 3)))]\n+  \"{ operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1)); }\")\n+"}, {"sha": "186436c42b77a64c1774c6018db38428f4641c6b", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=bcff0913882cc6e70f90be3d8448ec0186d21abc", "patch": "@@ -253,7 +253,17 @@\n (define_predicate \"reg_or_pow2_m1_operand\"\n   (match_code \"reg,const_int\")\n {\n-  return (REG_P (op)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && exact_log2 (INTVAL (op) + 1) >= 0));\n+  return (REG_P (op) || pow2_m1_operand (op, VOIDmode));\n })\n+\n+;; Used to detect a constant that is all ones in its lower bits.\n+(define_predicate \"pow2_m1_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && exact_log2 (INTVAL (op) + 1) >= 0);\n+})\n+\n+;; Used to detect valid targets for conditional branches\n+;; Used to detect (pc) or (label_ref) in some jumping patterns to cut down\n+(define_predicate \"pc_or_label_operand\"\n+  (match_code \"pc,label_ref\"))"}, {"sha": "dfad960b133dd052f7c37c8670ede7d0c258fc23", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bcff0913882cc6e70f90be3d8448ec0186d21abc", "patch": "@@ -1,3 +1,7 @@\n+2016-01-20  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.target/m68k/pr25114.c: New test.\n+\n 2016-01-20  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* gcc.target/arm/memset-inline-10.c: Added"}, {"sha": "bb722d9b86eb2ddee628b8e504ca3e014b64e18d", "filename": "gcc/testsuite/gcc.target/m68k/pr25114.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fpr25114.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcff0913882cc6e70f90be3d8448ec0186d21abc/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fpr25114.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fm68k%2Fpr25114.c?ref=bcff0913882cc6e70f90be3d8448ec0186d21abc", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -m68040\" } */\n+/* There should be 16 logical right shift instructions.  One for each function*/\n+/* { dg-final { scan-assembler-times \"lsr\" 16 } } */\n+\n+unsigned int bar (void);\n+\n+#define F(C) void foo##C (void) { unsigned int a = bar (); if (a <= C) bar (); }\n+#define G(C) void foo2##C (void) { unsigned int a = bar (); if (a > C) bar (); }\n+\n+F(0x1)\n+F(0x3)\n+F(0x7)\n+F(0xf)\n+F(0x1f)\n+F(0x3f)\n+F(0x7f)\n+F(0xff)\n+G(0x1)\n+G(0x3)\n+G(0x7)\n+G(0xf)\n+G(0x1f)\n+G(0x3f)\n+G(0x7f)\n+G(0xff)"}]}