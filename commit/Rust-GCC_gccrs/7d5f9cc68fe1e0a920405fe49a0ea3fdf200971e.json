{"sha": "7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q1ZjljYzY4ZmUxZTBhOTIwNDA1ZmU0OWEwZWEzZmRmMjAwOTcxZQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-12-10T21:54:42Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-12-10T21:54:42Z"}, "message": "tree-into-ssa.c (REWRITE_THIS_STMT): Define.\n\n\n\t* tree-into-ssa.c (REWRITE_THIS_STMT): Define.\n\t(mark_def_sites): Clear REWRITE_THIS_STMT for statements that\n\tdon't need any operands rewritten.\n\t(rewrite_stmt): Ignore statements that don't need to be\n\trewritten.\n\t(rewrite_operand): Validate that an existing SSA_NAME is\n\tidentical to the current reaching definition of the operand.\n\n\n\t* tree-dfa.c (mark_call_clobbered_vars_to_rename): New function.\n\t* tree-vectorizer.c (vectorizable_load): Call it.\n\t* tree-flow.h (mark_call_clobbered_vars_to_rename): Declare.\n\t* tree-sra.c (mark_all_v_defs): Also mark VUSEs for renaming.\n\nFrom-SVN: r92010", "tree": {"sha": "14bfdf7a466c4e8af2752e4d606db1e56d86b149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14bfdf7a466c4e8af2752e4d606db1e56d86b149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/comments", "author": null, "committer": null, "parents": [{"sha": "d49d090735d64081c451de95145981f9cf47ba6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d49d090735d64081c451de95145981f9cf47ba6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d49d090735d64081c451de95145981f9cf47ba6f"}], "stats": {"total": 98, "additions": 84, "deletions": 14}, "files": [{"sha": "a56d7ea615c97dd515cfc2a0da213eaa401c4fca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "patch": "@@ -1,3 +1,20 @@\n+2004-12-10  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-into-ssa.c (REWRITE_THIS_STMT): Define.\n+\t(mark_def_sites): Clear REWRITE_THIS_STMT for statements that\n+\tdon't need any operands rewritten.\n+\t(rewrite_stmt): Ignore statements that don't need to be\n+\trewritten.\n+\t(rewrite_operand): Validate that an existing SSA_NAME is\n+\tidentical to the current reaching definition of the operand.\n+\n+2004-12-10  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-dfa.c (mark_call_clobbered_vars_to_rename): New function.\n+\t* tree-vectorizer.c (vectorizable_load): Call it.\n+\t* tree-flow.h (mark_call_clobbered_vars_to_rename): Declare.\n+\t* tree-sra.c (mark_all_v_defs): Also mark VUSEs for renaming.\n+\n 2004-12-10  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* regmove.c (combine_stack_adjustments_for_block): Free"}, {"sha": "d7ccd69d7cf2235885e5856c50bf817965b2ab08", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "patch": "@@ -1032,3 +1032,18 @@ find_new_referenced_vars (tree *stmt_p)\n {\n   walk_tree (stmt_p, find_new_referenced_vars_1, NULL, NULL);\n }\n+\n+\n+/* Mark all call-clobbered variables for renaming.  */\n+\n+void\n+mark_call_clobbered_vars_to_rename (void)\n+{\n+  unsigned i;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i, bi)\n+    {\n+      tree var = referenced_var (i);\n+      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+    }\n+}"}, {"sha": "04d3c5ab25303c21a9105a8c02a02cd051b468fc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "patch": "@@ -536,6 +536,7 @@ extern tree get_virtual_var (tree);\n extern void add_referenced_tmp_var (tree);\n extern void mark_new_vars_to_rename (tree, bitmap);\n extern void find_new_referenced_vars (tree *);\n+void mark_call_clobbered_vars_to_rename (void);\n \n extern void redirect_immediate_uses (tree, tree);\n extern tree make_rename_temp (tree, const char *);"}, {"sha": "40c8d20eadd7a7c498418b6014430c0213b58a54", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "patch": "@@ -166,6 +166,12 @@ static inline struct def_blocks_d *get_def_blocks_for (tree);\n static inline struct def_blocks_d *find_def_blocks_for (tree);\n static void htab_statistics (FILE *, htab_t);\n \n+/* Use TREE_VISITED to keep track of which statements we want to\n+   rename.  When renaming a subset of the variables, not all\n+   statements will be processed.  This is decided in mark_def_sites.  */\n+#define REWRITE_THIS_STMT(T)\tTREE_VISITED (T)\n+\n+\n /* Get the information associated with NAME.  */\n \n static inline struct ssa_name_info *\n@@ -379,22 +385,27 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   stmt = bsi_stmt (bsi);\n   get_stmt_operands (stmt);\n \n+  REWRITE_THIS_STMT (stmt) = 0;\n+\n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n \n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter,\n+\t\t\t    SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTDEFKILL)\n     {\n-      if (prepare_use_operand_for_rename (use_p, &uid)\n-\t  && !TEST_BIT (kills, uid))\n-\tset_livein_block (USE_FROM_PTR (use_p), bb);\n+      if (prepare_use_operand_for_rename (use_p, &uid))\n+\t{\n+\t  REWRITE_THIS_STMT (stmt) = 1;\n+\t  if (!TEST_BIT (kills, uid))\n+\t    set_livein_block (USE_FROM_PTR (use_p), bb);\n+\t}\n     }\n   \n   /* Note that virtual definitions are irrelevant for computing KILLS\n      because a V_MAY_DEF does not constitute a killing definition of the\n      variable.  However, the operand of a virtual definitions is a use\n      of the variable, so it may cause the variable to be considered\n      live-on-entry.  */\n-\n   FOR_EACH_SSA_MAYDEF_OPERAND (def_p, use_p, stmt, iter)\n     {\n       if (prepare_use_operand_for_rename (use_p, &uid))\n@@ -406,22 +417,24 @@ mark_def_sites (struct dom_walk_data *walk_data,\n \t    \n           set_livein_block (USE_FROM_PTR (use_p), bb);\n \t  set_def_block (DEF_FROM_PTR (def_p), bb, false, false);\n+\t  REWRITE_THIS_STMT (stmt) = 1;\n \t}\n     }\n \n-  /* Now process the virtual must-defs made by this statement.  */\n+  /* Now process the defs and must-defs made by this statement.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF | SSA_OP_VMUSTDEF)\n     {\n       if (prepare_def_operand_for_rename (def, &uid))\n \t{\n \t  set_def_block (def, bb, false, false);\n \t  SET_BIT (kills, uid);\n+\t  REWRITE_THIS_STMT (stmt) = 1;\n \t}\n     }\n-\n }\n \n-/* Ditto, but works over ssa names.  */\n+\n+/* Same as mark_def_sites, but works over SSA names.  */\n \n static void\n ssa_mark_def_sites (struct dom_walk_data *walk_data,\n@@ -807,7 +820,7 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     phi nodes we want to add arguments for.  */\n \n static void\n-rewrite_virtual_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED, \n+rewrite_virtual_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t       basic_block bb)\n {\n   edge e;\n@@ -1099,6 +1112,11 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   stmt = bsi_stmt (si);\n   ann = stmt_ann (stmt);\n \n+  /* If mark_def_sites decided that we don't need to rewrite this\n+     statement, ignore it.  */\n+  if (!REWRITE_THIS_STMT (stmt))\n+    return;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Renaming statement \");\n@@ -1126,7 +1144,8 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Ditto, for rewriting ssa names.  */\n+\n+/* Same as rewrite_stmt, for rewriting ssa names.  */\n \n static void\n ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n@@ -1180,8 +1199,21 @@ ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n static inline void\n rewrite_operand (use_operand_p op_p)\n {\n-  if (TREE_CODE (USE_FROM_PTR (op_p)) != SSA_NAME)\n-    SET_USE (op_p, get_reaching_def (USE_FROM_PTR (op_p)));\n+  tree var = USE_FROM_PTR (op_p);\n+  if (TREE_CODE (var) != SSA_NAME)\n+    SET_USE (op_p, get_reaching_def (var));\n+  else\n+    {\n+#if defined ENABLE_CHECKING\n+      /* If we get to this point, VAR is an SSA_NAME.  If VAR's symbol\n+\t was marked for renaming, make sure that its reaching\n+\t definition is VAR itself.  Otherwise, something has gone\n+\t wrong.  */\n+      tree sym = SSA_NAME_VAR (var);\n+      if (bitmap_bit_p (vars_to_rename, var_ann (sym)->uid))\n+\tgcc_assert (var == get_reaching_def (SSA_NAME_VAR (var)));\n+#endif\n+    }\n }\n \n /* Register DEF (an SSA_NAME) to be a new definition for its underlying\n@@ -1509,8 +1541,9 @@ mark_def_site_blocks (void)\n \n   /* We no longer need this bitmap, clear and free it.  */\n   sbitmap_free (mark_def_sites_global_data.kills);\n-\n }\n+\n+\n /* Main entry point into the SSA builder.  The renaming process\n    proceeds in five main phases:\n "}, {"sha": "04733e3267755e2ad2a2f5f6f96d36430ec62e14", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "patch": "@@ -1417,7 +1417,7 @@ mark_all_v_defs (tree stmt)\n \n   get_stmt_operands (stmt);\n \n-  FOR_EACH_SSA_TREE_OPERAND (sym, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n+  FOR_EACH_SSA_TREE_OPERAND (sym, stmt, iter, SSA_OP_ALL_VIRTUALS)\n     {\n       if (TREE_CODE (sym) == SSA_NAME)\n \tsym = SSA_NAME_VAR (sym);"}, {"sha": "c591d48825c3ca37d2e33c06fd973624f0f53b37", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=7d5f9cc68fe1e0a920405fe49a0ea3fdf200971e", "patch": "@@ -2643,6 +2643,10 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t  new_bb = bsi_insert_on_edge_immediate (pe, new_stmt);\n \t  gcc_assert (!new_bb);\n \t  magic = TREE_OPERAND (new_stmt, 0);\n+\n+\t  /* Since we have just created a CALL_EXPR, we may need to\n+\t     rename call-clobbered variables.  */\n+\t  mark_call_clobbered_vars_to_rename ();\n \t}\n       else\n \t{"}]}