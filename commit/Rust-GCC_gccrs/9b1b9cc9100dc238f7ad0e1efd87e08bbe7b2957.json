{"sha": "9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxYjljYzkxMDBkYzIzOGY3YWQwZTFlZmQ4N2UwOGJiZTdiMjk1Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-09T10:43:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-09T10:43:57Z"}, "message": "ggc-simple.c (IS_MARKED, [...]): New.\n\n        * ggc-simple.c (IS_MARKED, IGNORE_MARK): New.\n        (GGC_ANY_MAGIC, GGC_ANY_MAGIC_MARK): New.\n        (struct ggc_any): Replace `mark' with `magic_mark'.\n        (ggc_alloc_string): Use memcpy, not bcopy.\n        (ggc_alloc_any): Set magic_mark.  Update bytes_alloced_since_gc.\n        (ggc_free_{rtx,rtvec,tree,string}): Mark inline.\n        (ggc_free_any): New.\n        (ggc_mark_string): Use IGNORE_MARK.  Calc back to struct gcc_string.\n        (ggc_mark): Use IGNORE_MARK.  Abort if magic doesn't match.\n        (ggc_collect): Re-enable collection avoidance.  Use GGC_ANY_MARK.\n        Use IS_MARKED. Use ggc_free_any.\n\nFrom-SVN: r29231", "tree": {"sha": "d16303cdd66baa43c84c23b85b60dd22943f219e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d16303cdd66baa43c84c23b85b60dd22943f219e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957/comments", "author": null, "committer": null, "parents": [{"sha": "7bfcb180702a371386c621df90269b3ee4298073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bfcb180702a371386c621df90269b3ee4298073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bfcb180702a371386c621df90269b3ee4298073"}], "stats": {"total": 98, "additions": 77, "deletions": 21}, "files": [{"sha": "f08ad94e7c6fcab75149030d08d52c1c018f6033", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957", "patch": "@@ -1,3 +1,17 @@\n+Thu Sep  9 03:37:31 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* ggc-simple.c (IS_MARKED, IGNORE_MARK): New.\n+\t(GGC_ANY_MAGIC, GGC_ANY_MAGIC_MARK): New.\n+\t(struct ggc_any): Replace `mark' with `magic_mark'.\n+\t(ggc_alloc_string): Use memcpy, not bcopy.\n+\t(ggc_alloc_any): Set magic_mark.  Update bytes_alloced_since_gc.\n+\t(ggc_free_{rtx,rtvec,tree,string}): Mark inline.\n+\t(ggc_free_any): New.\n+\t(ggc_mark_string): Use IGNORE_MARK.  Calc back to struct gcc_string.\n+\t(ggc_mark): Use IGNORE_MARK.  Abort if magic doesn't match.\n+\t(ggc_collect): Re-enable collection avoidance.  Use GGC_ANY_MARK.\n+\tUse IS_MARKED. Use ggc_free_any.\n+\n 1999-09-09  Scott Bambrough <scottb@netwinder.org>\n  \n \t* config/arm/linux-elf.h: define NO_IMPLICIT_EXTERN_C"}, {"sha": "df5c0cde5e01ee5f9431db7eb912496f768043a5", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=9b1b9cc9100dc238f7ad0e1efd87e08bbe7b2957", "patch": "@@ -36,6 +36,18 @@\n    really really lot of data.  */\n #undef GGC_DUMP\n \n+/* Some magic tags for strings and anonymous memory, hoping to catch\n+   certain errors wrt marking memory.  */\n+\n+#define IS_MARKED(X)\t\t((X) & 1)\n+#define IGNORE_MARK(X)\t\t((X) & -2)\n+\n+#define GGC_STRING_MAGIC\t((unsigned int)0xa1b2c3d4)\n+#define GGC_STRING_MAGIC_MARK\t((unsigned int)0xa1b2c3d4 | 1)\n+\n+#define GGC_ANY_MAGIC\t\t((unsigned int)0xa9bacbdc)\n+#define GGC_ANY_MAGIC_MARK\t((unsigned int)0xa9bacbdc | 1)\n+\n /* Global lists of roots, rtxs, and trees.  */\n \n struct ggc_root\n@@ -70,7 +82,7 @@ struct ggc_tree\n struct ggc_string\n {\n   struct ggc_string *chain;\n-  int magic_mark;\n+  unsigned int magic_mark;\n   char string[1];\n };\n \n@@ -79,7 +91,7 @@ struct ggc_string\n struct ggc_any\n {\n   struct ggc_any *chain;\n-  char mark;\n+  unsigned int magic_mark;\n \n   /* Make sure the data is reasonably aligned.  */\n   union {\n@@ -89,8 +101,6 @@ struct ggc_any\n   } u;\n };\n \n-#define GGC_STRING_MAGIC\t((unsigned int)0xa1b2c3d4)\n-\n struct ggc_status\n {\n   struct ggc_status *next;\n@@ -122,7 +132,11 @@ static FILE *dump;\n /* Local function prototypes.  */\n \n static void ggc_free_rtx PROTO ((struct ggc_rtx *r));\n+static void ggc_free_rtvec PROTO ((struct ggc_rtvec *v));\n static void ggc_free_tree PROTO ((struct ggc_tree *t));\n+static void ggc_free_string PROTO ((struct ggc_string *s));\n+static void ggc_free_any PROTO ((struct ggc_any *a));\n+\n static void ggc_mark_rtx_ptr PROTO ((void *elt));\n static void ggc_mark_tree_ptr PROTO ((void *elt));\n static void ggc_mark_string_ptr PROTO ((void *elt));\n@@ -290,13 +304,14 @@ ggc_alloc_string (contents, length)\n     }\n \n   size = (s->string - (char *)s) + length + 1;\n-  s = (struct ggc_string *) xmalloc(size);\n+  s = (struct ggc_string *) xmalloc (size);\n   s->chain = ggc_chain->strings;\n   s->magic_mark = GGC_STRING_MAGIC;\n+  ggc_chain->strings = s;\n+\n   if (contents)\n-    bcopy (contents, s->string, length);\n+    memcpy (s->string, contents, length);\n   s->string[length] = 0;\n-  ggc_chain->strings = s;\n \n #ifdef GGC_DUMP\n   fprintf(dump, \"alloc string %p\\n\", &s->string);\n@@ -321,14 +336,17 @@ ggc_alloc (bytes)\n \n   a = (struct ggc_any *) xmalloc (bytes);\n   a->chain = ggc_chain->anys;\n+  a->magic_mark = GGC_ANY_MAGIC;\n   ggc_chain->anys = a;\n \n+  ggc_chain->bytes_alloced_since_gc += bytes;\n+\n   return &a->u;\n }\n \n /* Freeing a bit of rtl is as simple as calling free.  */\n \n-static void\n+static inline void \n ggc_free_rtx (r)\n      struct ggc_rtx *r;\n {\n@@ -345,7 +363,7 @@ ggc_free_rtx (r)\n \n /* Freeing an rtvec is as simple as calling free.  */\n \n-static void\n+static inline void\n ggc_free_rtvec (v)\n      struct ggc_rtvec *v;\n {\n@@ -363,7 +381,7 @@ ggc_free_rtvec (v)\n /* Freeing a tree node is almost, but not quite, as simple as calling free.\n    Mostly we need to let the language clean up its lang_specific bits.  */\n \n-static void\n+static inline void\n ggc_free_tree (t)\n      struct ggc_tree *t;\n {\n@@ -387,7 +405,7 @@ ggc_free_tree (t)\n \n /* Freeing a string is as simple as calling free.  */\n \n-static void\n+static inline void\n ggc_free_string (s)\n      struct ggc_string *s;\n {\n@@ -402,6 +420,22 @@ ggc_free_string (s)\n   free (s);\n }\n \n+/* Freeing anonymous memory is as simple as calling free.  */\n+\n+static inline void\n+ggc_free_any (a)\n+     struct ggc_any *a;\n+{\n+#ifdef GGC_DUMP\n+  fprintf(dump, \"collect mem %p\\n\", &a->u);\n+#endif\n+#ifdef GGC_POISON\n+  a->magic_mark = 0xEEEEEEEE;\n+#endif\n+\n+  free (a);\n+}\n+\n /* Mark a node.  */\n \n void\n@@ -656,14 +690,16 @@ void\n ggc_mark_string (s)\n      char *s;\n {\n-  unsigned int *magic = (unsigned int *)s - 1;\n+  const ptrdiff_t d = (((struct ggc_string *) 0)->string - (char *) 0);\n+  struct ggc_string *gs;\n \n   if (s == NULL)\n     return;\n \n-  if ((*magic & ~(unsigned)1) != GGC_STRING_MAGIC)\n+  gs = (struct ggc_string *)(s - d);\n+  if (IGNORE_MARK (gs->magic_mark) != GGC_STRING_MAGIC)\n     return;   /* abort? */\n-  *magic = GGC_STRING_MAGIC | 1;\n+  gs->magic_mark = GGC_STRING_MAGIC_MARK;\n }\n \n /* Mark P, allocated with ggc_alloc.  */\n@@ -672,10 +708,16 @@ void\n ggc_mark (p)\n      void *p;\n {\n+  const ptrdiff_t d = (&((struct ggc_any *) 0)->u.c - (char *) 0);\n   struct ggc_any *a;\n-  ptrdiff_t d = (&((struct ggc_any *) 0)->u.c - (char *) 0);\n+\n+  if (p == NULL)\n+    return;\n+\n   a = (struct ggc_any *) (((char*) p) - d);\n-  a->mark = 1;\n+  if (IGNORE_MARK (a->magic_mark) != GGC_ANY_MAGIC)\n+    abort ();\n+  a->magic_mark = GGC_ANY_MAGIC_MARK;\n }\n \n /* The top level mark-and-sweep routine.  */\n@@ -692,7 +734,7 @@ ggc_collect ()\n   struct ggc_any *a, **ap;\n   int time, n_rtxs, n_trees, n_vecs, n_strings, n_anys;\n \n-#if 0\n+#ifndef ENABLE_CHECKING\n   /* See if it's even worth our while.  */\n   if (ggc_chain->bytes_alloced_since_gc < 64*1024)\n     return;\n@@ -715,7 +757,7 @@ ggc_collect ()\n       for (s = gs->strings; s != NULL; s = s->chain)\n \ts->magic_mark = GGC_STRING_MAGIC;\n       for (a = gs->anys; a != NULL; a = a->chain)\n-\ta->mark = 0;\n+\ta->magic_mark = GGC_ANY_MAGIC;\n     }\n \n   /* Mark through all the roots.  */\n@@ -803,7 +845,7 @@ ggc_collect ()\n   while (s != NULL)\n     {\n       struct ggc_string *chain = s->chain;\n-      if (!(s->magic_mark & 1))\n+      if (! IS_MARKED (s->magic_mark))\n         {\n \t  ggc_free_string (s);\n \t  *sp = chain;\n@@ -824,9 +866,9 @@ ggc_collect ()\n   while (a != NULL)\n     {\n       struct ggc_any *chain = a->chain;\n-      if (!a->mark)\n+      if (! IS_MARKED (a->magic_mark))\n \t{\n-\t  free (a);\n+\t  ggc_free_any (a);\n \t  *ap = chain;\n \t  n_anys++;\n \t}"}]}