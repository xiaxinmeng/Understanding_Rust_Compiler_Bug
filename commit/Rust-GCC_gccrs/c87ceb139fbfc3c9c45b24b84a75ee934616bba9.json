{"sha": "c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3Y2ViMTM5ZmJmYzNjOWM0NWIyNGI4NGE3NWVlOTM0NjE2YmJhOQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-09-06T19:03:44Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-09-06T19:03:44Z"}, "message": "cp-tree.h (add_binding): Remove declaration.\n\n        * cp-tree.h (add_binding): Remove declaration.\n        * name-lookup.h (supplement_binding): Declare.\n        * decl.c (add_binding): Move to name-lookup.c.\n        (push_local_binding): Adjust.\n        (push_class_binding): Likewise.\n        (set_identifier_type_value_with_scope): Likewise.\n        * name-lookup.c (supplement_binding): Rename from add_binding.\n        Return a bool.  Improve documentation.\n        (set_namespace_binding): Adjust.\n        * Make-lang.in (cp/name-lookup.o): Depend on toplev.h\n\nFrom-SVN: r71144", "tree": {"sha": "eb55c8a0bbba73aa66f5c50b4e4252818c594e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb55c8a0bbba73aa66f5c50b4e4252818c594e9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f845b302a1699cd72d8e7b4a9eb47a5566c6407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f845b302a1699cd72d8e7b4a9eb47a5566c6407", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f845b302a1699cd72d8e7b4a9eb47a5566c6407"}], "stats": {"total": 189, "additions": 107, "deletions": 82}, "files": [{"sha": "755168e59b236e5dc5365e3a450a771ea7563e6c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "patch": "@@ -1,3 +1,16 @@\n+2003-09-06  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h (add_binding): Remove declaration.\n+\t* name-lookup.h (supplement_binding): Declare.\n+\t* decl.c (add_binding): Move to name-lookup.c.\n+\t(push_local_binding): Adjust.\n+\t(push_class_binding): Likewise.\n+\t(set_identifier_type_value_with_scope): Likewise.\n+\t* name-lookup.c (supplement_binding): Rename from add_binding.\n+\tReturn a bool.  Improve documentation. \n+\t(set_namespace_binding): Adjust.\n+\t* Make-lang.in (cp/name-lookup.o): Depend on toplev.h\n+\n 2003-09-06  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/11794"}, {"sha": "1f78e81f5872c46248f750d4f86ccbec070d3192", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "patch": "@@ -282,7 +282,7 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h real.h gt-cp-mangle.h $(\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) diagnostic.h gt-cp-parser.h output.h\n \n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-\t$(TM_H) $(CXX_TREE_H) timevar.h gt-cp-name-lookup.h\n+\t$(TM_H) $(CXX_TREE_H) timevar.h gt-cp-name-lookup.h toplev.h\n \n cp/cxx-pretty-print.o: cp/cxx-pretty-print.c $(CXX_PRETTY_PRINT_H) \\\n   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h $(CXX_TREE_H)"}, {"sha": "394514df52b64b80e36cfe91d820d91c2e9e580d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "patch": "@@ -3754,7 +3754,6 @@ extern void register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n extern tree cp_fname_init\t\t\t(const char *);\n extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n-extern int add_binding                          (cxx_binding *, tree);\n extern bool have_extern_spec;\n \n /* in decl2.c */"}, {"sha": "7e87cac3f251cbcd27a220a4e5866d765011eb41", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 79, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "patch": "@@ -911,82 +911,6 @@ push_binding (tree id, tree decl, cxx_scope* level)\n   IDENTIFIER_BINDING (id) = binding;\n }\n \n-/* ID is already bound in the current scope.  But, DECL is an\n-   additional binding for ID in the same scope.  This is the `struct\n-   stat' hack whereby a non-typedef class-name or enum-name can be\n-   bound at the same level as some other kind of entity.  It's the\n-   responsibility of the caller to check that inserting this name is\n-   valid here.  Returns nonzero if the new binding was successful.  */\n-\n-int\n-add_binding (cxx_binding *binding, tree decl)\n-{\n-  tree bval = BINDING_VALUE (binding);\n-  int ok = 1;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n-    /* The new name is the type name.  */\n-    BINDING_TYPE (binding) = decl;\n-  else if (!bval)\n-    /* This situation arises when push_class_level_binding moves an\n-       inherited type-binding out of the way to make room for a new\n-       value binding.  */\n-    BINDING_VALUE (binding) = decl;\n-  else if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval))\n-    {\n-      /* The old binding was a type name.  It was placed in\n-\t BINDING_VALUE because it was thought, at the point it was\n-\t declared, to be the only entity with such a name.  Move the\n-\t type name into the type slot; it is now hidden by the new\n-\t binding.  */\n-      BINDING_TYPE (binding) = bval;\n-      BINDING_VALUE (binding) = decl;\n-      INHERITED_VALUE_BINDING_P (binding) = 0;\n-    }\n-  else if (TREE_CODE (bval) == TYPE_DECL\n-\t   && TREE_CODE (decl) == TYPE_DECL\n-\t   && DECL_NAME (decl) == DECL_NAME (bval)\n-\t   && (same_type_p (TREE_TYPE (decl), TREE_TYPE (bval))\n-\t       /* If either type involves template parameters, we must\n-\t\t  wait until instantiation.  */\n-\t       || uses_template_parms (TREE_TYPE (decl))\n-\t       || uses_template_parms (TREE_TYPE (bval))))\n-    /* We have two typedef-names, both naming the same type to have\n-       the same name.  This is OK because of:\n-\n-         [dcl.typedef]\n-\n-\t In a given scope, a typedef specifier can be used to redefine\n-\t the name of any type declared in that scope to refer to the\n-\t type to which it already refers.  */\n-    ok = 0;\n-  /* There can be two block-scope declarations of the same variable,\n-     so long as they are `extern' declarations.  However, there cannot\n-     be two declarations of the same static data member:\n-\n-       [class.mem]\n-\n-       A member shall not be declared twice in the\n-       member-specification.  */\n-  else if (TREE_CODE (decl) == VAR_DECL && TREE_CODE (bval) == VAR_DECL\n-\t   && DECL_EXTERNAL (decl) && DECL_EXTERNAL (bval)\n-\t   && !DECL_CLASS_SCOPE_P (decl))\n-    {\n-      duplicate_decls (decl, BINDING_VALUE (binding));\n-      ok = 0;\n-    }\n-  else\n-    {\n-      error (\"declaration of `%#D'\", decl);\n-      cp_error_at (\"conflicts with previous declaration `%#D'\",\n-\t\t   BINDING_VALUE (binding));\n-      ok = 0;\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n-}\n-\n /* Add DECL to the list of things declared in B.  */\n \n static void\n@@ -1040,7 +964,7 @@ push_local_binding (tree id, tree decl, int flags)\n   if (lookup_name_current_level (id))\n     {\n       /* Supplement the existing binding.  */\n-      if (!add_binding (IDENTIFIER_BINDING (id), decl))\n+      if (!supplement_binding (IDENTIFIER_BINDING (id), decl))\n \t/* It didn't work.  Something else must be bound at this\n \t   level.  Do not add DECL to the list of things to pop\n \t   later.  */\n@@ -1079,7 +1003,7 @@ push_class_binding (tree id, tree decl)\n \n   if (binding && BINDING_SCOPE (binding) == class_binding_level)\n     /* Supplement the existing binding.  */\n-    result = add_binding (IDENTIFIER_BINDING (id), decl);\n+    result = supplement_binding (IDENTIFIER_BINDING (id), decl);\n   else\n     /* Create a new binding.  */\n     push_binding (id, decl, class_binding_level);\n@@ -2336,7 +2260,7 @@ set_identifier_type_value_with_scope (tree id,\n       if (decl)\n \t{\n \t  if (BINDING_VALUE (binding))\n-\t    add_binding (binding, decl);\n+\t    supplement_binding (binding, decl);\n \t  else\n \t    BINDING_VALUE (binding) = decl;\n \t}"}, {"sha": "3a16b9c957891629c4a462ff2c0b6a2dee581e28", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 89, "deletions": 1, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"name-lookup.h\"\n #include \"timevar.h\"\n+#include \"toplev.h\"\n \n /* Compute the chain index of a binding_entry given the HASH value of its\n    name and the total COUNT of chains.  COUNT is assumed to be a power\n@@ -298,6 +299,93 @@ cxx_binding_free (cxx_binding *binding)\n   binding->previous = free_bindings;\n   free_bindings = binding;\n }\n+\n+/* BINDING records an existing declaration for a namein the current scope.\n+   But, DECL is another declaration for that same identifier in the\n+   same scope.  This is the `struct stat' hack whereby a non-typedef\n+   class name or enum-name can be bound at the same level as some other\n+   kind of entity.\n+   3.3.7/1\n+\n+     A class name (9.1) or enumeration name (7.2) can be hidden by the\n+     name of an object, function, or enumerator declared in the same scope.\n+     If a class or enumeration name and an object, function, or enumerator\n+     are declared in the same scope (in any order) with the same name, the\n+     class or enumeration name is hidden wherever the object, function, or\n+     enumerator name is visible.\n+\n+   It's the responsibility of the caller to check that\n+   inserting this name is valid here.  Returns nonzero if the new binding\n+   was successful.  */\n+\n+bool\n+supplement_binding (cxx_binding *binding, tree decl)\n+{\n+  tree bval = binding->value;\n+  bool ok = true;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n+    /* The new name is the type name.  */\n+    binding->type = decl;\n+  else if (!bval)\n+    /* This situation arises when push_class_level_binding moves an\n+       inherited type-binding out of the way to make room for a new\n+       value binding.  */\n+    binding->value = decl;\n+  else if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval))\n+    {\n+      /* The old binding was a type name.  It was placed in\n+\t BINDING_VALUE because it was thought, at the point it was\n+\t declared, to be the only entity with such a name.  Move the\n+\t type name into the type slot; it is now hidden by the new\n+\t binding.  */\n+      binding->type = bval;\n+      binding->value = decl;\n+      binding->value_is_inherited = false;\n+    }\n+  else if (TREE_CODE (bval) == TYPE_DECL\n+\t   && TREE_CODE (decl) == TYPE_DECL\n+\t   && DECL_NAME (decl) == DECL_NAME (bval)\n+\t   && (same_type_p (TREE_TYPE (decl), TREE_TYPE (bval))\n+\t       /* If either type involves template parameters, we must\n+\t\t  wait until instantiation.  */\n+\t       || uses_template_parms (TREE_TYPE (decl))\n+\t       || uses_template_parms (TREE_TYPE (bval))))\n+    /* We have two typedef-names, both naming the same type to have\n+       the same name.  This is OK because of:\n+\n+         [dcl.typedef]\n+\n+\t In a given scope, a typedef specifier can be used to redefine\n+\t the name of any type declared in that scope to refer to the\n+\t type to which it already refers.  */\n+    ok = false;\n+  /* There can be two block-scope declarations of the same variable,\n+     so long as they are `extern' declarations.  However, there cannot\n+     be two declarations of the same static data member:\n+\n+       [class.mem]\n+\n+       A member shall not be declared twice in the\n+       member-specification.  */\n+  else if (TREE_CODE (decl) == VAR_DECL && TREE_CODE (bval) == VAR_DECL\n+\t   && DECL_EXTERNAL (decl) && DECL_EXTERNAL (bval)\n+\t   && !DECL_CLASS_SCOPE_P (decl))\n+    {\n+      duplicate_decls (decl, binding->value);\n+      ok = false;\n+    }\n+  else\n+    {\n+      error (\"declaration of `%#D'\", decl);\n+      cp_error_at (\"conflicts with previous declaration `%#D'\",\n+\t\t   binding->value);\n+      ok = false;\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n+}\n \f\n /* Return (from the stack of) the BINDING, if any, establihsed at SCOPE.  */ \n \n@@ -382,7 +470,7 @@ set_namespace_binding (tree name, tree scope, tree val)\n       || val == error_mark_node)\n     BINDING_VALUE (b) = val;\n   else\n-    add_binding (b, val);\n+    supplement_binding (b, val);\n   timevar_pop (TV_NAME_LOOKUP);\n }\n "}, {"sha": "6a0917eddc9a7f4b32cd1d8c1ae3d3a3bdc85530", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c87ceb139fbfc3c9c45b24b84a75ee934616bba9/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c87ceb139fbfc3c9c45b24b84a75ee934616bba9", "patch": "@@ -107,6 +107,7 @@ struct cxx_binding GTY(())\n \n extern cxx_binding *cxx_binding_make (tree, tree);\n extern void cxx_binding_free (cxx_binding *);\n+extern bool supplement_binding (cxx_binding *, tree);\n \f\n /* True if SCOPE designates the global scope binding contour.  */\n #define global_scope_p(SCOPE) \\"}]}