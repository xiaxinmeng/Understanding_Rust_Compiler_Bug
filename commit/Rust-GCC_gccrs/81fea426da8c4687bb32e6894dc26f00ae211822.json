{"sha": "81fea426da8c4687bb32e6894dc26f00ae211822", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmZWE0MjZkYThjNDY4N2JiMzJlNjg5NGRjMjZmMDBhZTIxMTgyMg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2016-09-26T09:42:50Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2016-09-26T09:42:50Z"}, "message": "Implement -Wimplicit-fallthrough.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r240485", "tree": {"sha": "8b84b3de175727d09b7dcf1b5703e0d46b64f9e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b84b3de175727d09b7dcf1b5703e0d46b64f9e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81fea426da8c4687bb32e6894dc26f00ae211822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fea426da8c4687bb32e6894dc26f00ae211822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fea426da8c4687bb32e6894dc26f00ae211822", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fea426da8c4687bb32e6894dc26f00ae211822/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "392fa55c799358e198ca85fbea548e60359133c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392fa55c799358e198ca85fbea548e60359133c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/392fa55c799358e198ca85fbea548e60359133c5"}], "stats": {"total": 4051, "additions": 4005, "deletions": 46}, "files": [{"sha": "d30a7cfdee5d953af66a47a7904631ac68b231f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,59 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* Makefile.in (insn-attrtab.o-warn, insn-dfatab.o-warn,\n+\tinsn-latencytab.o-warn, insn-output.o-warn, insn-emit.o-warn): Add\n+\t-Wno-switch-fallthrough.\n+\t* builtins.c (expand_builtin_int_roundingfn_2): Add gcc_fallthrough.\n+\t(expand_builtin): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_builtin_vectorized_libmass): Likewise.\n+\t* convert.c (convert_to_real_1): Likewise.\n+\t(convert_to_integer_1): Likewise.\n+\t* final.c (output_alternate_entry_point): Likewise.\n+\t* genattrtab.c (make_canonical): Likewise.\n+\t(write_test_expr): Likewise.\n+\t* genpreds.c (validate_exp): Likewise.\n+\t* gimple-ssa-strength-reduction.c\n+\t(find_candidates_dom_walker::before_dom_children): Likewise.\n+\t* godump.c (go_format_type): Likewise.\n+\t* reload1.c (elimination_effects): Likewise.\n+\t* resource.c (mark_referenced_resources): Likewise.\n+\t(mark_set_resources): Likewise.\n+\t* tree-ssa-loop-ivopts.c (find_deriving_biv_for_expr): Likewise.\n+\t* varasm.c (output_addressed_constants): Likewise.\n+\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* common.opt (Wimplicit-fallthrough): New option.\n+\t* doc/extend.texi: Document statement attributes and the fallthrough\n+\tattribute.\n+\t* doc/invoke.texi: Document -Wimplicit-fallthrough.\n+\t* gimple.h (gimple_call_internal_p): New function.\n+\t* gimplify.c (struct gimplify_ctx): Add in_switch_expr.\n+\t(struct label_entry): New struct.\n+\t(find_label_entry): New function.\n+\t(case_label_p): New function.\n+\t(collect_fallthrough_labels): New function.\n+\t(last_stmt_in_scope): New function.\n+\t(should_warn_for_implicit_fallthrough): New function.\n+\t(warn_implicit_fallthrough_r): New function.\n+\t(maybe_warn_implicit_fallthrough): New function.\n+\t(expand_FALLTHROUGH_r): New function.\n+\t(expand_FALLTHROUGH): New function.\n+\t(gimplify_switch_expr): Call maybe_warn_implicit_fallthrough and\n+\texpand_FALLTHROUGH for the innermost GIMPLE_SWITCH.\n+\t(gimplify_label_expr): New function.\n+\t(gimplify_case_label_expr): Set location.\n+\t(gimplify_expr): Call gimplify_label_expr.\n+\t* internal-fn.c (expand_FALLTHROUGH): New function.\n+\t* internal-fn.def (FALLTHROUGH): New internal function.\n+\t* langhooks.c (lang_GNU_OBJC): New function.\n+\t* langhooks.h (lang_GNU_OBJC): Declare.\n+\t* system.h (gcc_fallthrough): Define.\n+\t* tree-core.h: Add FALLTHROUGH_LABEL_P comment.\n+\t* tree.h (FALLTHROUGH_LABEL_P): Define.\n+\n 2016-09-26  Richard Biener  <rguenther@suse.de>\n \n \t* dwarf2out.c (stripattributes): Remove unused function."}, {"sha": "e8559cba02383206cad0c4fafa87cc268e373390", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -218,6 +218,11 @@ libgcov-merge-tool.o-warn = -Wno-error\n gimple-match.o-warn = -Wno-unused\n generic-match.o-warn = -Wno-unused\n dfp.o-warn = -Wno-strict-aliasing\n+insn-attrtab.o-warn = -Wno-implicit-fallthrough\n+insn-dfatab.o-warn = -Wno-implicit-fallthrough\n+insn-latencytab.o-warn = -Wno-implicit-fallthrough\n+insn-output.o-warn = -Wno-implicit-fallthrough\n+insn-emit.o-warn = -Wno-implicit-fallthrough\n \n # All warnings have to be shut off in stage1 if the compiler used then\n # isn't gcc; configure determines that.  WARN_CFLAGS will be either"}, {"sha": "93cbe15ad3c40c19ccc47f772582fbadc09e7cf7", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -2586,15 +2586,15 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n     {\n     CASE_FLT_FN (BUILT_IN_IRINT):\n       fallback_fn = BUILT_IN_LRINT;\n-      /* FALLTHRU */\n+      gcc_fallthrough ();\n     CASE_FLT_FN (BUILT_IN_LRINT):\n     CASE_FLT_FN (BUILT_IN_LLRINT):\n       builtin_optab = lrint_optab;\n       break;\n \n     CASE_FLT_FN (BUILT_IN_IROUND):\n       fallback_fn = BUILT_IN_LROUND;\n-      /* FALLTHRU */\n+      gcc_fallthrough ();\n     CASE_FLT_FN (BUILT_IN_LROUND):\n     CASE_FLT_FN (BUILT_IN_LLROUND):\n       builtin_optab = lround_optab;\n@@ -5901,6 +5901,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     CASE_FLT_FN (BUILT_IN_ILOGB):\n       if (! flag_unsafe_math_optimizations)\n \tbreak;\n+      gcc_fallthrough ();\n     CASE_FLT_FN (BUILT_IN_ISINF):\n     CASE_FLT_FN (BUILT_IN_FINITE):\n     case BUILT_IN_ISFINITE:"}, {"sha": "cd3eeab02bdf699e253bc0b2ac759b12d659a6c9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,11 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* c-common.c (c_common_attribute_table): Add fallthrough attribute.\n+\t(handle_fallthrough_attribute): New function.\n+\t(attribute_fallthrough_p): New function.\n+\t* c-common.h (attribute_fallthrough_p): Declare.\n+\n 2016-09-24  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/77490"}, {"sha": "e9f619fd3af4d4ce39d83ebaa1a5a390246ff5f9", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -396,6 +396,7 @@ static tree handle_designated_init_attribute (tree *, tree, tree, int, bool *);\n static tree handle_bnd_variable_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_bnd_legacy (tree *, tree, tree, int, bool *);\n static tree handle_bnd_instrument (tree *, tree, tree, int, bool *);\n+static tree handle_fallthrough_attribute (tree *, tree, tree, int, bool *);\n \n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n static bool nonnull_check_p (tree, unsigned HOST_WIDE_INT);\n@@ -847,6 +848,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_bnd_legacy, false },\n   { \"bnd_instrument\",         0, 0, true, false, false,\n \t\t\t      handle_bnd_instrument, false },\n+  { \"fallthrough\",\t      0, 0, false, false, false,\n+\t\t\t      handle_fallthrough_attribute, false },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n@@ -9855,6 +9858,45 @@ handle_designated_init_attribute (tree *node, tree name, tree, int,\n   return NULL_TREE;\n }\n \n+\n+/* Handle a \"fallthrough\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+\n+static tree\n+handle_fallthrough_attribute (tree *, tree name, tree, int,\n+\t\t\t      bool *no_add_attrs)\n+{\n+  warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n+/* Check whether ATTR is a valid attribute fallthrough.  */\n+\n+bool\n+attribute_fallthrough_p (tree attr)\n+{\n+  tree t = lookup_attribute (\"fallthrough\", attr);\n+  if (t == NULL_TREE)\n+    return false;\n+  /* This attribute shall appear at most once in each attribute-list.  */\n+  if (lookup_attribute (\"fallthrough\", TREE_CHAIN (t)))\n+    warning (OPT_Wattributes, \"%<fallthrough%> attribute specified multiple \"\n+\t     \"times\");\n+  /* No attribute-argument-clause shall be present.  */\n+  else if (TREE_VALUE (t) != NULL_TREE)\n+    warning (OPT_Wattributes, \"%<fallthrough%> attribute specified with \"\n+\t     \"a parameter\");\n+  /* Warn if other attributes are found.  */\n+  for (t = attr; t != NULL_TREE; t = TREE_CHAIN (t))\n+    {\n+      tree name = get_attribute_name (t);\n+      if (!is_attribute_p (\"fallthrough\", name))\n+\twarning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+    }\n+  return true;\n+}\n+\n \f\n /* Check for valid arguments being passed to a function with FNTYPE.\n    There are NARGS arguments in the array ARGARRAY.  LOC should be used for"}, {"sha": "c88619b5acaf0e663b9549a5bae7ee3e0aee058d", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -805,6 +805,7 @@ extern void check_function_arguments_recurse (void (*)\n extern bool check_builtin_function_arguments (location_t, vec<location_t>,\n \t\t\t\t\t      tree, int, tree *);\n extern void check_function_format (tree, int, tree *);\n+extern bool attribute_fallthrough_p (tree);\n extern tree handle_unused_attribute (tree *, tree, tree, int, bool *);\n extern tree handle_format_attribute (tree *, tree, tree, int, bool *);\n extern tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);"}, {"sha": "642c20ca553e617529c8c99f20634f35a60fd074", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,19 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* c-decl.c (pop_scope): Add gcc_fallthrough.\n+\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* c-parser.c (struct c_token): Add flags field.\n+\t(c_lex_one_token): Pass it to c_lex_with_flags.\n+\t(c_parser_declaration_or_fndef): Turn __attribute__((fallthrough));\n+\tinto IFN_FALLTHROUGH.\n+\t(c_parser_label): Set FALLTHROUGH_LABEL_P on labels.  Handle\n+\tattribute fallthrough after a case label or default label.\n+\t(c_parser_statement_after_labels): Handle RID_ATTRIBUTE.\n+\n 2016-09-24  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/77490"}, {"sha": "9e32be2e8ed1be7eab8ab3cf5d86524a6b4913e7", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1328,7 +1328,7 @@ pop_scope (void)\n \t\tset_type_context (TREE_TYPE (p), context);\n \t    }\n \n-\t  /* Fall through.  */\n+\t  gcc_fallthrough ();\n \t  /* Parameters go in DECL_ARGUMENTS, not BLOCK_VARS, and have\n \t     already been put there by store_parm_decls.  Unused-\n \t     parameter warnings are handled by function.c."}, {"sha": "6bc42da08d64206b849db834ed1f3d6153c5d976", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 90, "deletions": 7, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -193,6 +193,8 @@ struct GTY (()) c_token {\n   location_t location;\n   /* The value associated with this token, if any.  */\n   tree value;\n+  /* Token flags.  */\n+  unsigned char flags;\n \n   source_range get_range () const\n   {\n@@ -270,7 +272,8 @@ c_lex_one_token (c_parser *parser, c_token *token)\n {\n   timevar_push (TV_LEX);\n \n-  token->type = c_lex_with_flags (&token->value, &token->location, NULL,\n+  token->type = c_lex_with_flags (&token->value, &token->location,\n+\t\t\t\t  &token->flags,\n \t\t\t\t  (parser->lex_untranslated_string\n \t\t\t\t   ? C_LEX_STRING_NO_TRANSLATE : 0));\n   token->id_kind = C_ID_NONE;\n@@ -1288,7 +1291,8 @@ static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n \t\t\t\t\t   bool, bool, tree *, vec<c_token>,\n-\t\t\t\t\t   struct oacc_routine_data * = NULL);\n+\t\t\t\t\t   struct oacc_routine_data * = NULL,\n+\t\t\t\t\t   bool * = NULL);\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n@@ -1591,6 +1595,8 @@ static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);\n    attributes; otherwise they may not.\n    OBJC_FOREACH_OBJECT_DECLARATION can be used to get back the parsed\n    declaration when parsing an Objective-C foreach statement.\n+   FALLTHRU_ATTR_P is used to signal whether this function parsed\n+   \"__attribute__((fallthrough));\".\n \n    declaration:\n      declaration-specifiers init-declarator-list[opt] ;\n@@ -1618,6 +1624,8 @@ static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);\n      declaration-specifiers declarator declaration-list[opt]\n        compound-statement\n \n+   attribute ;\n+\n    Objective-C:\n      attributes objc-class-definition\n      attributes objc-category-definition\n@@ -1652,7 +1660,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t       bool nested, bool start_attr_ok,\n \t\t\t       tree *objc_foreach_object_declaration,\n \t\t\t       vec<c_token> omp_declare_simd_clauses,\n-\t\t\t       struct oacc_routine_data *oacc_routine_data)\n+\t\t\t       struct oacc_routine_data *oacc_routine_data,\n+\t\t\t       bool *fallthru_attr_p)\n {\n   struct c_declspecs *specs;\n   tree prefix_attrs;\n@@ -1749,6 +1758,15 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n     {\n       if (auto_type_p)\n \terror_at (here, \"%<__auto_type%> in empty declaration\");\n+      else if (specs->typespec_kind == ctsk_none\n+\t       && attribute_fallthrough_p (specs->attrs))\n+\t{\n+\t  if (fallthru_attr_p != NULL)\n+\t    *fallthru_attr_p = true;\n+\t  tree fn = build_call_expr_internal_loc (here, IFN_FALLTHROUGH,\n+\t\t\t\t\t\t  void_type_node, 0);\n+\t  add_stmt (fn);\n+\t}\n       else if (empty_ok)\n \tshadow_tag (specs);\n       else\n@@ -1851,7 +1869,10 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  break;\n \t}\n     }\n-  \n+  else if (attribute_fallthrough_p (specs->attrs))\n+    warning_at (here, OPT_Wattributes,\n+\t\t\"%<fallthrough%> attribute not followed by %<;%>\");\n+\n   pending_xref_error ();\n   prefix_attrs = specs->attrs;\n   all_prefix_attrs = prefix_attrs;\n@@ -4841,12 +4862,14 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t{\n \t  last_label = false;\n \t  mark_valid_location_for_stdc_pragma (false);\n+\t  bool fallthru_attr_p = false;\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t true, NULL, vNULL);\n-\t  if (last_stmt)\n+\t\t\t\t\t true, NULL, vNULL, NULL,\n+\t\t\t\t\t &fallthru_attr_p);\n+\t  if (last_stmt && !fallthru_attr_p)\n \t    pedwarn_c90 (loc, OPT_Wdeclaration_after_statement,\n \t\t\t \"ISO C90 forbids mixed declarations and code\");\n-\t  last_stmt = false;\n+\t  last_stmt = fallthru_attr_p;\n \t}\n       else if (!last_label\n \t       && c_parser_next_token_is_keyword (parser, RID_EXTENSION))\n@@ -4963,6 +4986,11 @@ c_parser_label (c_parser *parser)\n {\n   location_t loc1 = c_parser_peek_token (parser)->location;\n   tree label = NULL_TREE;\n+\n+  /* Remember whether this case or a user-defined label is allowed to fall\n+     through to.  */\n+  bool fallthrough_p = c_parser_peek_token (parser)->flags & PREV_FALLTHROUGH;\n+\n   if (c_parser_next_token_is_keyword (parser, RID_CASE))\n     {\n       tree exp1, exp2;\n@@ -5009,6 +5037,33 @@ c_parser_label (c_parser *parser)\n     }\n   if (label)\n     {\n+      if (TREE_CODE (label) == LABEL_EXPR)\n+\tFALLTHROUGH_LABEL_P (LABEL_EXPR_LABEL (label)) = fallthrough_p;\n+      else\n+\tFALLTHROUGH_LABEL_P (CASE_LABEL (label)) = fallthrough_p;\n+\n+      /* Allow '__attribute__((fallthrough));'.  */\n+      if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+\t{\n+\t  location_t loc = c_parser_peek_token (parser)->location;\n+\t  tree attrs = c_parser_attributes (parser);\n+\t  if (attribute_fallthrough_p (attrs))\n+\t    {\n+\t      if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t\t{\n+\t\t  tree fn = build_call_expr_internal_loc (loc,\n+\t\t\t\t\t\t\t  IFN_FALLTHROUGH,\n+\t\t\t\t\t\t\t  void_type_node, 0);\n+\t\t  add_stmt (fn);\n+\t\t}\n+\t      else\n+\t\twarning_at (loc, OPT_Wattributes, \"%<fallthrough%> attribute \"\n+\t\t\t    \"not followed by %<;%>\");\n+\t    }\n+\t  else if (attrs != NULL_TREE)\n+\t    warning_at (loc, OPT_Wattributes, \"only attribute %<fallthrough%>\"\n+\t\t\t\" can be applied to a null statement\");\n+\t}\n       if (c_parser_next_tokens_start_declaration (parser))\n \t{\n \t  error_at (c_parser_peek_token (parser)->location,\n@@ -5062,6 +5117,9 @@ c_parser_label (c_parser *parser)\n    jump-statement:\n      goto * expression ;\n \n+   expression-statement:\n+     attributes ;\n+\n    Objective-C:\n \n    statement:\n@@ -5323,6 +5381,31 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_objc_synchronized_statement (parser);\n \t  break;\n+\tcase RID_ATTRIBUTE:\n+\t  {\n+\t    /* Allow '__attribute__((fallthrough));'.  */\n+\t    tree attrs = c_parser_attributes (parser);\n+\t    if (attribute_fallthrough_p (attrs))\n+\t      {\n+\t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t\t  {\n+\t\t    tree fn = build_call_expr_internal_loc (loc,\n+\t\t\t\t\t\t\t    IFN_FALLTHROUGH,\n+\t\t\t\t\t\t\t    void_type_node, 0);\n+\t\t    add_stmt (fn);\n+\t\t    /* Eat the ';'.  */\n+\t\t    c_parser_consume_token (parser);\n+\t\t  }\n+\t\telse\n+\t\t  warning_at (loc, OPT_Wattributes,\n+\t\t\t      \"%<fallthrough%> attribute not followed \"\n+\t\t\t      \"by %<;%>\");\n+\t      }\n+\t    else if (attrs != NULL_TREE)\n+\t      warning_at (loc, OPT_Wattributes, \"only attribute %<fallthrough%>\"\n+\t\t\t  \" can be applied to a null statement\");\n+\t    break;\n+\t  }\n \tdefault:\n \t  goto expr_stmt;\n \t}"}, {"sha": "b1d32fb45a25f66207378b55993eed8fee4dcdee", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -601,6 +601,10 @@ Whsa\n Common Var(warn_hsa) Init(1) Warning\n Warn when a function cannot be expanded to HSAIL.\n \n+Wimplicit-fallthrough\n+Common Var(warn_implicit_fallthrough) Warning EnabledBy(Wextra)\n+Warn when a switch case falls through.\n+\n Winline\n Common Var(warn_inline) Warning\n Warn when an inlined function cannot be inlined."}, {"sha": "d76f479d9e59fa140a8a3d6cff0ad5a40788fc6c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -5489,7 +5489,7 @@ rs6000_builtin_vectorized_libmass (combined_fn fn, tree type_out,\n     CASE_CFN_HYPOT:\n     CASE_CFN_POW:\n       n_args = 2;\n-      /* fall through */\n+      gcc_fallthrough ();\n \n     CASE_CFN_ACOS:\n     CASE_CFN_ACOSH:"}, {"sha": "8f18ee4d2477e88d926c2eecaed6e09e3c6f3fca", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -164,6 +164,7 @@ convert_to_real_1 (tree type, tree expr, bool fold_p)\n \t       -fmath-errno.  */\n \t    if (flag_errno_math)\n \t      break;\n+\t    gcc_fallthrough ();\n \t  CASE_MATHFN (ACOS)\n \t  CASE_MATHFN (ACOSH)\n \t  CASE_MATHFN (ASIN)\n@@ -184,6 +185,7 @@ convert_to_real_1 (tree type, tree expr, bool fold_p)\n \t    /* The above functions are not safe to do this conversion.  */\n \t    if (!flag_unsafe_math_optimizations)\n \t      break;\n+\t    gcc_fallthrough ();\n \t  CASE_MATHFN (SQRT)\n \t  CASE_MATHFN (FABS)\n \t  CASE_MATHFN (LOGB)\n@@ -516,7 +518,7 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t  /* Only convert nearbyint* if we can ignore math exceptions.  */\n \t  if (flag_trapping_math)\n \t    break;\n-\t  /* ... Fall through ...  */\n+\t  gcc_fallthrough ();\n \tCASE_FLT_FN (BUILT_IN_RINT):\n \t  /* Only convert in ISO C99 mode and with -fno-math-errno.  */\n \t  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)"}, {"sha": "8f12833f34fd8c94c4f4987ecc07b010fee78a99", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,33 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* parser.c (cp_parser_storage_class_specifier_opt): Add\n+\tgcc_fallthrough.\n+\t(cp_parser_skip_to_end_of_template_parameter_list): Likewise.\n+\t(cp_parser_cache_defarg): Likewise.\n+\t(cp_parser_omp_for_cond): Likewise.\n+\t* semantics.c (finish_decltype_type): Likewise.\n+\t* typeck.c (structural_comptypes): Likewise.\n+\t(cp_build_binary_op): Likewise.\n+\t(cp_build_modify_expr): Likewise.\n+\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* constexpr.c (cxx_eval_internal_function): Handle IFN_FALLTHROUGH.\n+\t(potential_constant_expression_1): Likewise.\n+\t* constraint.cc (function_concept_check_p): Check fn for null.\n+\t* parser.c (cp_parser_expression_statement): Handle attribute\n+\tfallthrough.\n+\t(cp_parser_statement): Likewise.\n+\t(cp_parser_label_for_labeled_statement): Set FALLTHROUGH_LABEL_P on\n+\tlabels.\n+\t(cp_parser_std_attribute): Handle fallthrough attribute.\n+\t(cp_parser_check_std_attribute): Add %< %> quotes.\n+\t* pt.c (tsubst_copy_and_build): Handle internal functions.\n+\t(instantiation_dependent_scope_ref_p): Return if the expression is\n+\tnull.\n+\n 2016-09-24  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/77490"}, {"sha": "bd4068e84c588b018b41f0b31ef577365a1125cd", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1303,6 +1303,7 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n     case IFN_UBSAN_NULL:\n     case IFN_UBSAN_BOUNDS:\n     case IFN_UBSAN_VPTR:\n+    case IFN_FALLTHROUGH:\n       return void_node;\n \n     case IFN_ADD_OVERFLOW:\n@@ -4826,6 +4827,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \t\tcase IFN_UBSAN_NULL:\n \t\tcase IFN_UBSAN_BOUNDS:\n \t\tcase IFN_UBSAN_VPTR:\n+\t\tcase IFN_FALLTHROUGH:\n \t\t  return true;\n \n \t\tcase IFN_ADD_OVERFLOW:"}, {"sha": "b4d85c908c63d34df7f9fb03d8f7305e0ae83064", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -116,7 +116,8 @@ function_concept_check_p (tree t)\n {\n   gcc_assert (TREE_CODE (t) == CALL_EXPR);\n   tree fn = CALL_EXPR_FN (t);\n-  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR\n+  if (fn != NULL_TREE\n+      && TREE_CODE (fn) == TEMPLATE_ID_EXPR\n       && TREE_CODE (TREE_OPERAND (fn, 0)) == OVERLOAD)\n     {\n       tree f1 = get_first_fn (fn);"}, {"sha": "5ec8b1b6ce12690dadbf185e810381d6df993bbf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -10585,14 +10585,31 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t}\n       /* Look for an expression-statement instead.  */\n       statement = cp_parser_expression_statement (parser, in_statement_expr);\n+\n+      /* Handle [[fallthrough]];.  */\n+      if (attribute_fallthrough_p (std_attrs))\n+\t{\n+\t  /* The next token after the fallthrough attribute is ';'.  */\n+\t  if (statement == NULL_TREE)\n+\t    {\n+\t      /* Turn [[fallthrough]]; into FALLTHROUGH ();.  */\n+\t      statement = build_call_expr_internal_loc (statement_location,\n+\t\t\t\t\t\t\tIFN_FALLTHROUGH,\n+\t\t\t\t\t\t\tvoid_type_node, 0);\n+\t      finish_expr_stmt (statement);\n+\t    }\n+\t  else\n+\t    warning_at (statement_location, OPT_Wattributes,\n+\t\t\t\"%<fallthrough%> attribute not followed by %<;%>\");\n+\t  std_attrs = NULL_TREE;\n+\t}\n     }\n \n   /* Set the line number for the statement.  */\n   if (statement && STATEMENT_CODE_P (TREE_CODE (statement)))\n     SET_EXPR_LOCATION (statement, statement_location);\n \n-  /* Note that for now, we don't do anything with c++11 statements\n-     parsed at this level.  */\n+  /* Allow \"[[fallthrough]];\", but warn otherwise.  */\n   if (std_attrs != NULL_TREE)\n     warning_at (attrs_location,\n \t\tOPT_Wattributes,\n@@ -10628,6 +10645,10 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n       return;\n     }\n \n+  /* Remember whether this case or a user-defined label is allowed to fall\n+     through to.  */\n+  bool fallthrough_p = token->flags & PREV_FALLTHROUGH;\n+\n   parser->colon_corrects_to_scope_p = false;\n   switch (token->keyword)\n     {\n@@ -10659,7 +10680,11 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n \t  expr_hi = NULL_TREE;\n \n \tif (parser->in_switch_statement_p)\n-\t  finish_case_label (token->location, expr, expr_hi);\n+\t  {\n+\t    tree l = finish_case_label (token->location, expr, expr_hi);\n+\t    if (l && TREE_CODE (l) == CASE_LABEL_EXPR)\n+\t      FALLTHROUGH_LABEL_P (CASE_LABEL (l)) = fallthrough_p;\n+\t  }\n \telse\n \t  error_at (token->location,\n \t\t    \"case label %qE not within a switch statement\",\n@@ -10672,14 +10697,20 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n       cp_lexer_consume_token (parser->lexer);\n \n       if (parser->in_switch_statement_p)\n-\tfinish_case_label (token->location, NULL_TREE, NULL_TREE);\n+\t{\n+\t  tree l = finish_case_label (token->location, NULL_TREE, NULL_TREE);\n+\t  if (l && TREE_CODE (l) == CASE_LABEL_EXPR)\n+\t    FALLTHROUGH_LABEL_P (CASE_LABEL (l)) = fallthrough_p;\n+\t}\n       else\n \terror_at (token->location, \"case label not within a switch statement\");\n       break;\n \n     default:\n       /* Anything else must be an ordinary label.  */\n       label = finish_label_stmt (cp_parser_identifier (parser));\n+      if (label && TREE_CODE (label) == LABEL_DECL)\n+\tFALLTHROUGH_LABEL_P (label) = fallthrough_p;\n       break;\n     }\n \n@@ -10728,6 +10759,10 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n {\n   tree statement = NULL_TREE;\n   cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  location_t loc = token->location;\n+\n+  /* There might be attribute fallthrough.  */\n+  tree attr = cp_parser_gnu_attributes_opt (parser);\n \n   /* If the next token is a ';', then there is no expression\n      statement.  */\n@@ -10742,6 +10777,25 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n \t}\n     }\n \n+  /* Handle [[fallthrough]];.  */\n+  if (attribute_fallthrough_p (attr))\n+    {\n+      /* The next token after the fallthrough attribute is ';'.  */\n+      if (statement == NULL_TREE)\n+\t/* Turn [[fallthrough]]; into FALLTHROUGH ();.  */\n+\tstatement = build_call_expr_internal_loc (loc, IFN_FALLTHROUGH,\n+\t\t\t\t\t\t  void_type_node, 0);\n+      else\n+\twarning_at (loc, OPT_Wattributes,\n+\t\t    \"%<fallthrough%> attribute not followed by %<;%>\");\n+      attr = NULL_TREE;\n+    }\n+\n+  /* Allow \"[[fallthrough]];\", but warn otherwise.  */\n+  if (attr != NULL_TREE)\n+    warning_at (loc, OPT_Wattributes,\n+\t\t\"attributes at the beginning of statement are ignored\");\n+\n   /* Give a helpful message for \"A<T>::type t;\" and the like.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON)\n       && !cp_parser_uncommitted_to_tentative_parse_p (parser))\n@@ -12980,6 +13034,7 @@ cp_parser_storage_class_specifier_opt (cp_parser* parser)\n       if (cxx_dialect != cxx98)\n         return NULL_TREE;\n       /* Fall through for C++98.  */\n+      gcc_fallthrough ();\n \n     case RID_REGISTER:\n     case RID_STATIC:\n@@ -24116,14 +24171,23 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n       if (is_attribute_p (\"noreturn\", attr_id))\n \tTREE_PURPOSE (TREE_PURPOSE (attribute)) = get_identifier (\"gnu\");\n       /* C++14 deprecated attribute is equivalent to GNU's.  */\n-      else if (cxx_dialect >= cxx11 && is_attribute_p (\"deprecated\", attr_id))\n+      else if (is_attribute_p (\"deprecated\", attr_id))\n \t{\n \t  if (cxx_dialect == cxx11)\n \t    pedwarn (token->location, OPT_Wpedantic,\n \t\t     \"%<deprecated%> is a C++14 feature;\"\n \t\t     \" use %<gnu::deprecated%>\");\n \t  TREE_PURPOSE (TREE_PURPOSE (attribute)) = get_identifier (\"gnu\");\n \t}\n+      /* C++17 fallthrough attribute is equivalent to GNU's.  */\n+      else if (is_attribute_p (\"fallthrough\", attr_id))\n+\t{\n+\t  if (cxx_dialect < cxx1z)\n+\t    pedwarn (token->location, OPT_Wpedantic,\n+\t\t     \"%<fallthrough%> is a C++17 feature;\"\n+\t\t     \" use %<gnu::fallthrough%>\");\n+\t  TREE_PURPOSE (TREE_PURPOSE (attribute)) = get_identifier (\"gnu\");\n+\t}\n       /* Transactional Memory TS optimize_for_synchronized attribute is\n \t equivalent to GNU transaction_callable.  */\n       else if (is_attribute_p (\"optimize_for_synchronized\", attr_id))\n@@ -24182,11 +24246,11 @@ cp_parser_check_std_attribute (tree attributes, tree attribute)\n       tree name = get_attribute_name (attribute);\n       if (is_attribute_p (\"noreturn\", name)\n \t  && lookup_attribute (\"noreturn\", attributes))\n-\terror (\"attribute noreturn can appear at most once \"\n+\terror (\"attribute %<noreturn%> can appear at most once \"\n \t       \"in an attribute-list\");\n       else if (is_attribute_p (\"deprecated\", name)\n \t       && lookup_attribute (\"deprecated\", attributes))\n-\terror (\"attribute deprecated can appear at most once \"\n+\terror (\"attribute %<deprecated%> can appear at most once \"\n \t       \"in an attribute-list\");\n     }\n }\n@@ -27303,6 +27367,7 @@ cp_parser_skip_to_end_of_template_parameter_list (cp_parser* parser)\n \t    }\n           /* Fall through for C++0x, so we handle the second `>' in\n              the `>>'.  */\n+\t  gcc_fallthrough ();\n \n \tcase CPP_GREATER:\n \t  if (!nesting_depth && level-- == 0)\n@@ -27760,6 +27825,7 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n \t  /* Fall through for C++0x, which treats the `>>'\n \t     operator like two `>' tokens in certain\n \t     cases.  */\n+\t  gcc_fallthrough ();\n \n \tcase CPP_GREATER:\n \t  if (depth == 0)\n@@ -33402,6 +33468,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n       if (code == CILK_SIMD || code == CILK_FOR)\n \tbreak;\n       /* Fall through: OpenMP disallows NE_EXPR.  */\n+      gcc_fallthrough ();\n     default:\n       return error_mark_node;\n     }"}, {"sha": "a0cbb2e8c0ea1492a6d3dcf45070fcb3b838d6a2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -16556,7 +16556,16 @@ tsubst_copy_and_build (tree t,\n \ttree ret;\n \n \tfunction = CALL_EXPR_FN (t);\n-\t/* When we parsed the expression,  we determined whether or\n+\tif (function == NULL_TREE)\n+\t  {\n+\t    /* If you hit this assert, it means that you're trying to tsubst\n+\t       an internal function with arguments.  This isn't yet supported,\n+\t       so you need to build another internal call with the tsubsted\n+\t       arguments after the arguments have been tsubsted down below.  */\n+\t    gcc_assert (call_expr_nargs (t) == 0);\n+\t    RETURN (t);\n+\t  }\n+\t/* When we parsed the expression, we determined whether or\n \t   not Koenig lookup should be performed.  */\n \tkoenig_p = KOENIG_LOOKUP_P (t);\n \tif (TREE_CODE (function) == SCOPE_REF)\n@@ -22787,7 +22796,7 @@ instantiation_dependent_scope_ref_p (tree t)\n bool\n value_dependent_expression_p (tree expression)\n {\n-  if (!processing_template_decl)\n+  if (!processing_template_decl || expression == NULL_TREE)\n     return false;\n \n   /* A name declared with a dependent type.  */"}, {"sha": "1d8f3369fc1b18deb106e94e7367c061679cbdb1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -8894,6 +8894,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n               break;\n             }\n           /* Fall through for fields that aren't bitfields.  */\n+\t  gcc_fallthrough ();\n \n         case FUNCTION_DECL:\n         case VAR_DECL:"}, {"sha": "617ca55ffe76f2099aa0e3d2ba88f9104a88a248", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1306,6 +1306,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n       if (TYPE_REF_IS_RVALUE (t1) != TYPE_REF_IS_RVALUE (t2))\n \treturn false;\n       /* fall through to checks for pointer types */\n+      gcc_fallthrough ();\n \n     case POINTER_TYPE:\n       if (TYPE_MODE (t1) != TYPE_MODE (t2)\n@@ -4265,6 +4266,7 @@ cp_build_binary_op (location_t location,\n \t}\n       /* The pointer - int case is just like pointer + int; fall\n \t through.  */\n+      gcc_fallthrough ();\n     case PLUS_EXPR:\n       if ((code0 == POINTER_TYPE || code1 == POINTER_TYPE)\n \t  && (code0 == INTEGER_TYPE || code1 == INTEGER_TYPE))\n@@ -7554,7 +7556,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t\t\t    TREE_OPERAND (lhs, 1)),\n \t\t    TREE_OPERAND (lhs, 0),\n \t\t    TREE_OPERAND (lhs, 1));\n-      /* Fall through.  */\n+      gcc_fallthrough ();\n \n       /* Handle (a ? b : c) used as an \"lvalue\".  */\n     case COND_EXPR:"}, {"sha": "fcf86d320fe45d07c1f8fa4b3f33b57af09cc142", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -60,6 +60,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Type Attributes::     Specifying attributes of types.\n * Label Attributes::    Specifying attributes on labels.\n * Enumerator Attributes:: Specifying attributes on enumerators.\n+* Statement Attributes:: Specifying attributes on statements.\n * Attribute Syntax::    Formal syntax for attributes.\n * Function Prototypes:: Prototype declarations and old-style definitions.\n * C++ Comments::        C++ comments are recognized.\n@@ -2261,6 +2262,7 @@ GCC also supports attributes on\n variable declarations (@pxref{Variable Attributes}),\n labels (@pxref{Label Attributes}),\n enumerators (@pxref{Enumerator Attributes}),\n+statements (@pxref{Statement Attributes}),\n and types (@pxref{Type Attributes}).\n \n There is some overlap between the purposes of attributes and pragmas\n@@ -5558,8 +5560,8 @@ attributes are currently defined generically for variables.\n Other attributes are defined for variables on particular target\n systems.  Other attributes are available for functions\n (@pxref{Function Attributes}), labels (@pxref{Label Attributes}),\n-enumerators (@pxref{Enumerator Attributes}), and for types\n-(@pxref{Type Attributes}).\n+enumerators (@pxref{Enumerator Attributes}), statements\n+(@pxref{Statement Attributes}), and for types (@pxref{Type Attributes}).\n Other front ends might define more attributes\n (@pxref{C++ Extensions,,Extensions to the C++ Language}).\n \n@@ -6340,7 +6342,8 @@ attributes of types.  Some type attributes apply only to @code{struct}\n and @code{union} types, while others can apply to any type defined\n via a @code{typedef} declaration.  Other attributes are defined for\n functions (@pxref{Function Attributes}), labels (@pxref{Label \n-Attributes}), enumerators (@pxref{Enumerator Attributes}), and for\n+Attributes}), enumerators (@pxref{Enumerator Attributes}), \n+statements (@pxref{Statement Attributes}), and for\n variables (@pxref{Variable Attributes}).\n \n The @code{__attribute__} keyword is followed by an attribute specification\n@@ -6850,7 +6853,8 @@ GCC allows attributes to be set on C labels.  @xref{Attribute Syntax}, for\n details of the exact syntax for using attributes.  Other attributes are \n available for functions (@pxref{Function Attributes}), variables \n (@pxref{Variable Attributes}), enumerators (@pxref{Enumerator Attributes}),\n-and for types (@pxref{Type Attributes}).\n+statements (@pxref{Statement Attributes}), and for types\n+(@pxref{Type Attributes}).\n \n This example uses the @code{cold} label attribute to indicate the \n @code{ErrorHandling} branch is unlikely to be taken and that the\n@@ -6903,8 +6907,8 @@ with computed goto or @code{asm goto}.\n GCC allows attributes to be set on enumerators.  @xref{Attribute Syntax}, for\n details of the exact syntax for using attributes.  Other attributes are\n available for functions (@pxref{Function Attributes}), variables\n-(@pxref{Variable Attributes}), labels (@pxref{Label Attributes}),\n-and for types (@pxref{Type Attributes}).\n+(@pxref{Variable Attributes}), labels (@pxref{Label Attributes}), statements\n+(@pxref{Statement Attributes}), and for types (@pxref{Type Attributes}).\n \n This example uses the @code{deprecated} enumerator attribute to indicate the\n @code{oldval} enumerator is deprecated:\n@@ -6935,6 +6939,46 @@ do instead.  Note that the warnings only occurs for uses.\n \n @end table\n \n+@node Statement Attributes\n+@section Statement Attributes\n+@cindex Statement Attributes\n+\n+GCC allows attributes to be set on null statements.  @xref{Attribute Syntax},\n+for details of the exact syntax for using attributes.  Other attributes are\n+available for functions (@pxref{Function Attributes}), variables\n+(@pxref{Variable Attributes}), labels (@pxref{Label Attributes}), enumerators\n+(@pxref{Enumerator Attributes}), and for types (@pxref{Type Attributes}).\n+\n+This example uses the @code{fallthrough} statement attribute to indicate that\n+the @option{-Wimplicit-fallthrough} warning should not be emitted:\n+\n+@smallexample\n+switch (cond)\n+  @{\n+  case 1:\n+    bar (1);\n+    __attribute__((fallthrough));\n+  case 2:\n+    @dots{}\n+  @}\n+@end smallexample\n+\n+@table @code\n+@item fallthrough\n+@cindex @code{fallthrough} statement attribute\n+The @code{fallthrough} attribute with a null statement serves as a\n+fallthrough statement.  It hints to the compiler that a statement\n+that falls through to another case label, or user-defined label\n+in a switch statement is intentional and thus the\n+@option{-Wimplicit-fallthrough} warning must not trigger.  The\n+fallthrough attribute may appear at most once in each attribute\n+list, and may not be mixed with other attributes.  It can only\n+be used in a switch statement (the compiler will issue an error\n+otherwise), after a preceding statement and before a logically\n+succeeding case label, or user-defined label.\n+\n+@end table\n+\n @node Attribute Syntax\n @section Attribute Syntax\n @cindex attribute syntax\n@@ -6962,6 +7006,8 @@ and enumerated types.\n applying to labels.\n @xref{Enumerator Attributes}, for details of the semantics of attributes\n applying to enumerators.\n+@xref{Statement Attributes}, for details of the semantics of attributes\n+applying to statements.\n \n An @dfn{attribute specifier} is of the form\n @code{__attribute__ ((@var{attribute-list}))}.  An @dfn{attribute list}\n@@ -7027,6 +7073,10 @@ present.  The optional attribute in the enumerator appertains to the\n enumeration constant.  It is not possible to place the attribute after\n the constant expression, if present.\n \n+@subsubheading Statement Attributes\n+In GNU C, an attribute specifier list may appear as part of a null\n+statement.  The attribute goes before the semicolon.\n+\n @subsubheading Type Attributes\n \n An attribute specifier list may appear as part of a @code{struct},"}, {"sha": "ce0eaef3c908ce4aad636a7e41cf0e2715878e56", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -273,7 +273,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wformat-security  -Wformat-signedness  -Wformat-y2k -Wframe-address @gol\n -Wframe-larger-than=@var{len} -Wno-free-nonheap-object -Wjump-misses-init @gol\n -Wignored-qualifiers  -Wignored-attributes  -Wincompatible-pointer-types @gol\n--Wimplicit  -Wimplicit-function-declaration  -Wimplicit-int @gol\n+-Wimplicit  -Wimplicit-fallthrough  -Wimplicit-function-declaration @gol\n+-Wimplicit-int @gol\n -Winit-self  -Winline  -Wno-int-conversion  -Wint-in-bool-context @gol\n -Wno-int-to-pointer-cast -Winvalid-memory-model -Wno-invalid-offsetof @gol\n -Winvalid-pch -Wlarger-than=@var{len} @gol\n@@ -3719,6 +3720,7 @@ name is still supported, but the newer name is more descriptive.)\n @gccoptlist{-Wclobbered  @gol\n -Wempty-body  @gol\n -Wignored-qualifiers @gol\n+-Wimplicit-fallthrough @gol\n -Wmissing-field-initializers  @gol\n -Wmissing-parameter-type @r{(C only)}  @gol\n -Wold-style-declaration @r{(C only)}  @gol\n@@ -4087,6 +4089,93 @@ enabled by default and it is made into an error by\n Same as @option{-Wimplicit-int} and @option{-Wimplicit-function-declaration}.\n This warning is enabled by @option{-Wall}.\n \n+@item -Wimplicit-fallthrough\n+@opindex Wimplicit-fallthrough\n+@opindex Wno-implicit-fallthrough\n+Warn when a switch case falls through.  For example:\n+\n+@smallexample\n+@group\n+switch (cond)\n+  @{\n+  case 1:\n+    a = 1;\n+    break;\n+  case 2:\n+    a = 2;\n+  case 3:\n+    a = 3;\n+    break;\n+  @}\n+@end group\n+@end smallexample\n+\n+This warning does not warn when the last statement of a case cannot\n+fall through, e.g. when there is a return statement or a call to function\n+declared with the noreturn attribute.  @option{-Wimplicit-fallthrough}\n+also takes into account control flow statements, such as ifs, and only\n+warns when appropriate.  E.g.@:\n+\n+@smallexample\n+@group\n+switch (cond)\n+  @{\n+  case 1:\n+    if (i > 3) @{\n+      bar (5);\n+      break;\n+    @} else if (i < 1) @{\n+      bar (0);\n+    @} else\n+      return;\n+  default:\n+    @dots{}\n+  @}\n+@end group\n+@end smallexample\n+\n+Since there are occasions where a switch case fall through is desirable,\n+GCC provides an attribute, @code{__attribute__ ((fallthrough))}, that is\n+to be used along with a null statement to suppress this warning that\n+would normally occur:\n+\n+@smallexample\n+@group\n+switch (cond)\n+  @{\n+  case 1:\n+    bar (0);\n+    __attribute__ ((fallthrough));\n+  default:\n+    @dots{}\n+  @}\n+@end group\n+@end smallexample\n+\n+C++17 provides a standard way to suppress the @option{-Wimplicit-fallthrough}\n+warning using @code{[[fallthrough]];} instead of the GNU attribute.  In C++11\n+or C++14 users can use @code{[[gnu::fallthrough]];}, which is a GNU extension.\n+Instead of the these attributes, it is also possible to add a \"falls through\"\n+comment to silence the warning.  GCC accepts a wide range of such comments,\n+for example all of \"Falls through.\", \"fallthru\", \"FALLS-THROUGH\" work.  This\n+comment needs to consist of two words merely, optionally followed by periods\n+or whitespaces.\n+\n+@smallexample\n+@group\n+switch (cond)\n+  @{\n+  case 1:\n+    bar (0);\n+    /* FALLTHRU */\n+  default:\n+    @dots{}\n+  @}\n+@end group\n+@end smallexample\n+\n+This warning is enabled by @option{-Wextra}.\n+\n @item -Wignored-qualifiers @r{(C and C++ only)}\n @opindex Wignored-qualifiers\n @opindex Wno-ignored-qualifiers"}, {"sha": "29c12fddc67cb643aab55895da55213fe33d3c86", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -2096,9 +2096,11 @@ output_alternate_entry_point (FILE *file, rtx_insn *insn)\n     case LABEL_WEAK_ENTRY:\n #ifdef ASM_WEAKEN_LABEL\n       ASM_WEAKEN_LABEL (file, name);\n+      gcc_fallthrough ();\n #endif\n     case LABEL_GLOBAL_ENTRY:\n       targetm.asm_out.globalize_label (file, name);\n+      gcc_fallthrough ();\n     case LABEL_STATIC_ENTRY:\n #ifdef ASM_OUTPUT_TYPE_DIRECTIVE\n       ASM_OUTPUT_TYPE_DIRECTIVE (file, name, \"function\");"}, {"sha": "dee19ded2411765a8fb987696bb42aad18292ead", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,15 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* arith.c (eval_intrinsic): Add gcc_fallthrough.\n+\t* frontend-passes.c (optimize_op): Likewise.\n+\t(gfc_expr_walker): Likewise.\n+\t* parse.c (next_fixed): Likewise.\n+\t* primary.c (match_variable): Likewise.\n+\t* trans-array.c: Likewise.\n+\t* trans-expr.c (flatten_array_ctors_without_strlen): Likewise.\n+\t* trans-io.c (transfer_expr): Likewise.\n+\n 2016-09-25  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77429 "}, {"sha": "8af75400d80db7eef586e1b516fdd0b7b33f21a9", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1521,7 +1521,7 @@ eval_intrinsic (gfc_intrinsic_op op,\n \t  break;\n \t}\n \n-    /* Fall through  */\n+    gcc_fallthrough ();\n     /* Numeric binary  */\n     case INTRINSIC_PLUS:\n     case INTRINSIC_MINUS:"}, {"sha": "e049fb9f2ced5e16eb472935c1f49a5844f03b5e", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1481,7 +1481,7 @@ optimize_op (gfc_expr *e)\n     case INTRINSIC_LT:\n       changed = optimize_comparison (e, op);\n \n-      /* Fall through */\n+      gcc_fallthrough ();\n       /* Look at array constructors.  */\n     case INTRINSIC_PLUS:\n     case INTRINSIC_MINUS:\n@@ -3349,6 +3349,7 @@ gfc_expr_walker (gfc_expr **e, walk_expr_fn_t exprfn, void *data)\n \n \t    /* Fall through to the variable case in order to walk the\n \t       reference.  */\n+\t    gcc_fallthrough ();\n \n \t  case EXPR_SUBSTRING:\n \t  case EXPR_VARIABLE:"}, {"sha": "73cb0dbdaf965e888eb4cac750f691a6fa9e50d5", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1261,7 +1261,7 @@ next_fixed (void)\n \t\t  return decode_oacc_directive ();\n \t\t}\n \t    }\n-\t  /* FALLTHROUGH */\n+\t  gcc_fallthrough ();\n \n \t  /* Comments have already been skipped by the time we get\n \t     here so don't bother checking for them.  */"}, {"sha": "85589eedc36cbab36faddf856ce2d4ee807e2c88", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -3572,6 +3572,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \tbreak;\n \n       /* Fall through to error */\n+      gcc_fallthrough ();\n \n     default:\n       gfc_error (\"%qs at %C is not a variable\", sym->name);"}, {"sha": "0b9776009400baa4cfc637f20b1816eb39dd2db3", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -4032,6 +4032,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t    continue;\n \t\t  }\n \t\t  /* Otherwise fall through GFC_SS_FUNCTION.  */\n+\t\t  gcc_fallthrough ();\n \t      }\n \t    case GFC_ISYM_LCOBOUND:\n \t    case GFC_ISYM_UCOBOUND:"}, {"sha": "a82178835ac112d6dc7b28cbaf384cdda84e1f07", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -2208,6 +2208,7 @@ flatten_array_ctors_without_strlen (gfc_expr* e)\n \t}\n \n       /* Otherwise, fall through to handle constructor elements.  */\n+      gcc_fallthrough ();\n     case EXPR_STRUCTURE:\n       for (c = gfc_constructor_first (e->value.constructor);\n \t   c; c = gfc_constructor_next (c))"}, {"sha": "3cdbf1fd2cac79c2c1e12dc74fa88cc41b54107b", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -2384,6 +2384,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr,\n \t    }\n \t  /* If a CLASS object gets through to here, fall through and ICE.  */\n \t}\n+      gcc_fallthrough ();\n     default:\n       gfc_internal_error (\"Bad IO basetype (%d)\", ts->type);\n     }"}, {"sha": "c8e166e3c4e754947b39fa306c03439df647b588", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1219,6 +1219,7 @@ make_canonical (file_location loc, struct attr_desc *attr, rtx exp)\n \n       exp = newexp;\n       /* Fall through to COND case since this is now a COND.  */\n+      gcc_fallthrough ();\n \n     case COND:\n       {\n@@ -3615,6 +3616,7 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n \t}\n \n       /* Otherwise, fall through to normal unary operator.  */\n+      gcc_fallthrough ();\n \n     /* Unary operators.  */\n     case ABS:  case NEG:"}, {"sha": "d18ebd2ab5a487478a95d2e15cd70ff6ca85b618", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -74,7 +74,7 @@ validate_exp (rtx exp, const char *name, file_location loc)\n \t      }\n \t  }\n       }\n-      /* fall through */\n+      gcc_fallthrough ();\n \n       /* These need no special checking.  */\n     case MATCH_OPERAND:"}, {"sha": "b49637f5c790d61f927a9f5e15548e203347f26e", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1690,7 +1690,7 @@ find_candidates_dom_walker::before_dom_children (basic_block bb)\n \t    case POINTER_PLUS_EXPR:\n \t    case MINUS_EXPR:\n \t      rhs2 = gimple_assign_rhs2 (gs);\n-\t      /* Fall-through.  */\n+\t      gcc_fallthrough ();\n \n \t    CASE_CONVERT:\n \t    case MODIFY_EXPR:"}, {"sha": "9fad15bf3f81738a355b657db5c3ec3255166710", "filename": "gcc/gimple.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -2921,6 +2921,16 @@ gimple_call_internal_unique_p (const gimple *gs)\n   return gimple_call_internal_unique_p (gc);\n }\n \n+/* Return true if GS is an internal function FN.  */\n+\n+static inline bool\n+gimple_call_internal_p (const gimple *gs, internal_fn fn)\n+{\n+  return (is_gimple_call (gs)\n+\t  && gimple_call_internal_p (gs)\n+\t  && gimple_call_internal_fn (gs) == fn);\n+}\n+\n /* If CTRL_ALTERING_P is true, mark GIMPLE_CALL S to be a stmt\n    that could alter control flow.  */\n "}, {"sha": "66bb8be264b45bab8477233bc7b95f83eeb75a08", "filename": "gcc/gimplify.c", "status": "modified", "additions": 449, "deletions": 5, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -160,6 +160,7 @@ struct gimplify_ctx\n   unsigned in_cleanup_point_expr : 1;\n   unsigned keep_stack : 1;\n   unsigned save_stack : 1;\n+  unsigned in_switch_expr : 1;\n };\n \n struct gimplify_omp_ctx\n@@ -1626,6 +1627,430 @@ maybe_warn_switch_unreachable (gimple_seq seq)\n     }\n }\n \n+\n+/* A label entry that pairs label and a location.  */\n+struct label_entry\n+{\n+  tree label;\n+  location_t loc;\n+};\n+\n+/* Find LABEL in vector of label entries VEC.  */\n+\n+static struct label_entry *\n+find_label_entry (const auto_vec<struct label_entry> *vec, tree label)\n+{\n+  unsigned int i;\n+  struct label_entry *l;\n+\n+  FOR_EACH_VEC_ELT (*vec, i, l)\n+    if (l->label == label)\n+      return l;\n+  return NULL;\n+}\n+\n+/* Return true if LABEL, a LABEL_DECL, represents a case label\n+   in a vector of labels CASES.  */\n+\n+static bool\n+case_label_p (const vec<tree> *cases, tree label)\n+{\n+  unsigned int i;\n+  tree l;\n+\n+  FOR_EACH_VEC_ELT (*cases, i, l)\n+    if (CASE_LABEL (l) == label)\n+      return true;\n+  return false;\n+}\n+\n+/* Find the last statement in a scope STMT.  */\n+\n+static gimple *\n+last_stmt_in_scope (gimple *stmt)\n+{\n+  if (!stmt)\n+    return NULL;\n+\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_BIND:\n+      {\n+\tgbind *bind = as_a <gbind *> (stmt);\n+\tstmt = gimple_seq_last_stmt (gimple_bind_body (bind));\n+\treturn last_stmt_in_scope (stmt);\n+      }\n+\n+    case GIMPLE_TRY:\n+      {\n+\tgtry *try_stmt = as_a <gtry *> (stmt);\n+\tstmt = gimple_seq_last_stmt (gimple_try_eval (try_stmt));\n+\tgimple *last_eval = last_stmt_in_scope (stmt);\n+\tif (gimple_stmt_may_fallthru (last_eval)\n+\t    && gimple_try_kind (try_stmt) == GIMPLE_TRY_FINALLY)\n+\t  {\n+\t    stmt = gimple_seq_last_stmt (gimple_try_cleanup (try_stmt));\n+\t    return last_stmt_in_scope (stmt);\n+\t  }\n+\telse\n+\t  return last_eval;\n+      }\n+\n+    default:\n+      return stmt;\n+    }\n+}\n+\n+/* Collect interesting labels in LABELS and return the statement preceding\n+   another case label, or a user-defined label.  */\n+\n+static gimple *\n+collect_fallthrough_labels (gimple_stmt_iterator *gsi_p,\n+\t\t\t    auto_vec <struct label_entry> *labels)\n+{\n+  gimple *prev = NULL;\n+\n+  do\n+    {\n+      if (gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_BIND\n+\t  || gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_TRY)\n+\t{\n+\t  /* Nested scope.  Only look at the last statement of\n+\t     the innermost scope.  */\n+\t  location_t bind_loc = gimple_location (gsi_stmt (*gsi_p));\n+\t  gimple *last = last_stmt_in_scope (gsi_stmt (*gsi_p));\n+\t  if (last)\n+\t    {\n+\t      prev = last;\n+\t      /* It might be a label without a location.  Use the\n+\t\t location of the scope then.  */\n+\t      if (!gimple_has_location (prev))\n+\t\tgimple_set_location (prev, bind_loc);\n+\t    }\n+\t  gsi_next (gsi_p);\n+\t  continue;\n+\t}\n+\n+      /* Ifs are tricky.  */\n+      if (gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_COND)\n+\t{\n+\t  gcond *cond_stmt = as_a <gcond *> (gsi_stmt (*gsi_p));\n+\t  tree false_lab = gimple_cond_false_label (cond_stmt);\n+\t  location_t if_loc = gimple_location (cond_stmt);\n+\n+\t  /* If we have e.g.\n+\t       if (i > 1) goto <D.2259>; else goto D;\n+\t     we can't do much with the else-branch.  */\n+\t  if (!DECL_ARTIFICIAL (false_lab))\n+\t    break;\n+\n+\t  /* Go on until the false label, then one step back.  */\n+\t  for (; !gsi_end_p (*gsi_p); gsi_next (gsi_p))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (*gsi_p);\n+\t      if (gimple_code (stmt) == GIMPLE_LABEL\n+\t\t  && gimple_label_label (as_a <glabel *> (stmt)) == false_lab)\n+\t\tbreak;\n+\t    }\n+\n+\t  /* Not found?  Oops.  */\n+\t  if (gsi_end_p (*gsi_p))\n+\t    break;\n+\n+\t  struct label_entry l = { false_lab, if_loc };\n+\t  labels->safe_push (l);\n+\n+\t  /* Go to the last statement of the then branch.  */\n+\t  gsi_prev (gsi_p);\n+\n+\t  /* if (i != 0) goto <D.1759>; else goto <D.1760>;\n+\t     <D.1759>:\n+\t     <stmt>;\n+\t     goto <D.1761>;\n+\t     <D.1760>:\n+\t   */\n+\t  if (gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_GOTO\n+\t      && !gimple_has_location (gsi_stmt (*gsi_p)))\n+\t    {\n+\t      /* Look at the statement before, it might be\n+\t\t attribute fallthrough, in which case don't warn.  */\n+\t      gsi_prev (gsi_p);\n+\t      bool fallthru_before_dest\n+\t\t= gimple_call_internal_p (gsi_stmt (*gsi_p), IFN_FALLTHROUGH);\n+\t      gsi_next (gsi_p);\n+\t      tree goto_dest = gimple_goto_dest (gsi_stmt (*gsi_p));\n+\t      if (!fallthru_before_dest)\n+\t\t{\n+\t\t  struct label_entry l = { goto_dest, if_loc };\n+\t\t  labels->safe_push (l);\n+\t\t}\n+\t    }\n+\t  /* And move back.  */\n+\t  gsi_next (gsi_p);\n+\t}\n+\n+      /* Remember the last statement.  Skip labels that are of no interest\n+\t to us.  */\n+      if (gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_LABEL)\n+\t{\n+\t  tree label = gimple_label_label (as_a <glabel *> (gsi_stmt (*gsi_p)));\n+\t  if (find_label_entry (labels, label))\n+\t    prev = gsi_stmt (*gsi_p);\n+\t}\n+      else\n+\tprev = gsi_stmt (*gsi_p);\n+      gsi_next (gsi_p);\n+    }\n+  while (!gsi_end_p (*gsi_p)\n+\t /* Stop if we find a case or a user-defined label.  */\n+\t && (gimple_code (gsi_stmt (*gsi_p)) != GIMPLE_LABEL\n+\t     || !gimple_has_location (gsi_stmt (*gsi_p))));\n+\n+  return prev;\n+}\n+\n+/* Return true if the switch fallthough warning should occur.  LABEL is\n+   the label statement that we're falling through to.  */\n+\n+static bool\n+should_warn_for_implicit_fallthrough (gimple_stmt_iterator *gsi_p, tree label)\n+{\n+  gimple_stmt_iterator gsi = *gsi_p;\n+\n+  /* Don't warn for a non-case label followed by a statement:\n+       case 0:\n+\t foo ();\n+       label:\n+\t bar ();\n+     as these are likely intentional.  */\n+  if (!case_label_p (&gimplify_ctxp->case_labels, label))\n+    {\n+      gsi_next (&gsi);\n+      if (gsi_end_p (gsi) || gimple_code (gsi_stmt (gsi)) != GIMPLE_LABEL)\n+\treturn false;\n+    }\n+\n+  /* Don't warn for terminated branches, i.e. when the subsequent case labels\n+     immediately breaks.  */\n+  gsi = *gsi_p;\n+\n+  /* Skip all immediately following labels.  */\n+  while (!gsi_end_p (gsi) && gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n+    gsi_next (&gsi);\n+\n+  /* { ... something; default:; } */\n+  if (gsi_end_p (gsi)\n+      /* { ... something; default: break; } or\n+\t { ... something; default: goto L; } */\n+      || gimple_code (gsi_stmt (gsi)) == GIMPLE_GOTO\n+      /* { ... something; default: return; } */\n+      || gimple_code (gsi_stmt (gsi)) == GIMPLE_RETURN)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Callback for walk_gimple_seq.  */\n+\n+static tree\n+warn_implicit_fallthrough_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n+\t\t\t     struct walk_stmt_info *)\n+{\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+\n+  *handled_ops_p = true;\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_TRY:\n+    case GIMPLE_BIND:\n+    case GIMPLE_CATCH:\n+    case GIMPLE_EH_FILTER:\n+    case GIMPLE_TRANSACTION:\n+      /* Walk the sub-statements.  */\n+      *handled_ops_p = false;\n+      break;\n+\n+    /* Find a sequence of form:\n+\n+       GIMPLE_LABEL\n+       [...]\n+       <may fallthru stmt>\n+       GIMPLE_LABEL\n+\n+       and possibly warn.  */\n+    case GIMPLE_LABEL:\n+      {\n+\t/* Found a label.  Skip all immediately following labels.  */\n+\twhile (!gsi_end_p (*gsi_p)\n+\t       && gimple_code (gsi_stmt (*gsi_p)) == GIMPLE_LABEL)\n+\t  gsi_next (gsi_p);\n+\n+\t/* There might be no more statements.  */\n+\tif (gsi_end_p (*gsi_p))\n+\t  return integer_zero_node;\n+\n+\t/* Vector of labels that fall through.  */\n+\tauto_vec <struct label_entry> labels;\n+\tgimple *prev = collect_fallthrough_labels (gsi_p, &labels);\n+\n+\t/* There might be no more statements.  */\n+\tif (gsi_end_p (*gsi_p))\n+\t  return integer_zero_node;\n+\n+\tgimple *next = gsi_stmt (*gsi_p);\n+\ttree label;\n+\t/* If what follows is a label, then we may have a fallthrough.  */\n+\tif (gimple_code (next) == GIMPLE_LABEL\n+\t    && gimple_has_location (next)\n+\t    && (label = gimple_label_label (as_a <glabel *> (next)))\n+\t    && !FALLTHROUGH_LABEL_P (label)\n+\t    && prev != NULL)\n+\t  {\n+\t    struct label_entry *l;\n+\t    bool warned_p = false;\n+\t    if (!should_warn_for_implicit_fallthrough (gsi_p, label))\n+\t      /* Quiet.  */;\n+\t    else if (gimple_code (prev) == GIMPLE_LABEL\n+\t\t     && (label = gimple_label_label (as_a <glabel *> (prev)))\n+\t\t     && (l = find_label_entry (&labels, label)))\n+\t      warned_p = warning_at (l->loc, OPT_Wimplicit_fallthrough,\n+\t\t\t\t     \"this statement may fall through\");\n+\t    else if (!gimple_call_internal_p (prev, IFN_FALLTHROUGH)\n+\t\t     /* Try to be clever and don't warn when the statement\n+\t\t\tcan't actually fall through.  */\n+\t\t     && gimple_stmt_may_fallthru (prev)\n+\t\t     && gimple_has_location (prev))\n+\t      warned_p = warning_at (gimple_location (prev),\n+\t\t\t\t     OPT_Wimplicit_fallthrough,\n+\t\t\t\t     \"this statement may fall through\");\n+\t    if (warned_p)\n+\t      inform (gimple_location (next), \"here\");\n+\n+\t    /* Mark this label as processed so as to prevent multiple\n+\t       warnings in nested switches.  */\n+\t    FALLTHROUGH_LABEL_P (label) = true;\n+\n+\t    /* So that next warn_implicit_fallthrough_r will start looking for\n+\t       a new sequence starting with this label.  */\n+\t    gsi_prev (gsi_p);\n+\t  }\n+      }\n+      break;\n+   default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Warn when a switch case falls through.  */\n+\n+static void\n+maybe_warn_implicit_fallthrough (gimple_seq seq)\n+{\n+  if (!warn_implicit_fallthrough)\n+    return;\n+\n+  /* This warning is meant for C/C++/ObjC/ObjC++ only.  */\n+  if (!(lang_GNU_C ()\n+\t|| lang_GNU_CXX ()\n+\t|| lang_GNU_OBJC ()))\n+    return;\n+\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  walk_gimple_seq (seq, warn_implicit_fallthrough_r, NULL, &wi);\n+}\n+\n+/* Callback for walk_gimple_seq.  */\n+\n+static tree\n+expand_FALLTHROUGH_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n+\t\t      struct walk_stmt_info *)\n+{\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+\n+  *handled_ops_p = true;\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_TRY:\n+    case GIMPLE_BIND:\n+    case GIMPLE_CATCH:\n+    case GIMPLE_EH_FILTER:\n+    case GIMPLE_TRANSACTION:\n+      /* Walk the sub-statements.  */\n+      *handled_ops_p = false;\n+      break;\n+    case GIMPLE_CALL:\n+      if (gimple_call_internal_p (stmt, IFN_FALLTHROUGH))\n+\t{\n+\t  gsi_remove (gsi_p, true);\n+\t  if (gsi_end_p (*gsi_p))\n+\t    return integer_zero_node;\n+\n+\t  bool found = false;\n+\t  location_t loc = gimple_location (stmt);\n+\n+\t  gimple_stmt_iterator gsi2 = *gsi_p;\n+\t  stmt = gsi_stmt (gsi2);\n+\t  if (gimple_code (stmt) == GIMPLE_GOTO && !gimple_has_location (stmt))\n+\t    {\n+\t      /* Go on until the artificial label.  */\n+\t      tree goto_dest = gimple_goto_dest (stmt);\n+\t      for (; !gsi_end_p (gsi2); gsi_next (&gsi2))\n+\t\t{\n+\t\t  if (gimple_code (gsi_stmt (gsi2)) == GIMPLE_LABEL\n+\t\t      && gimple_label_label (as_a <glabel *> (gsi_stmt (gsi2)))\n+\t\t\t   == goto_dest)\n+\t\t    break;\n+\t\t}\n+\n+\t      /* Not found?  Stop.  */\n+\t      if (gsi_end_p (gsi2))\n+\t\tbreak;\n+\n+\t      /* Look one past it.  */\n+\t      gsi_next (&gsi2);\n+\t    }\n+\n+\t  /* We're looking for a case label or default label here.  */\n+\t  while (!gsi_end_p (gsi2))\n+\t    {\n+\t      stmt = gsi_stmt (gsi2);\n+\t      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\t\t{\n+\t\t  tree label = gimple_label_label (as_a <glabel *> (stmt));\n+\t\t  if (gimple_has_location (stmt) && DECL_ARTIFICIAL (label))\n+\t\t    {\n+\t\t      found = true;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t/* Something other than a label.  That's not expected.  */\n+\t\tbreak;\n+\t      gsi_next (&gsi2);\n+\t    }\n+\t  if (!found)\n+\t    warning_at (loc, 0, \"attribute %<fallthrough%> not preceding \"\n+\t\t\t\"a case label or default label\");\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Expand all FALLTHROUGH () calls in SEQ.  */\n+\n+static void\n+expand_FALLTHROUGH (gimple_seq *seq_p)\n+{\n+  struct walk_stmt_info wi;\n+  memset (&wi, 0, sizeof (wi));\n+  walk_gimple_seq_mod (seq_p, expand_FALLTHROUGH_r, NULL, &wi);\n+}\n+\n \f\n /* Gimplify a SWITCH_EXPR, and collect the vector of labels it can\n    branch to.  */\n@@ -1660,10 +2085,17 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n          labels.  Save all the things from the switch body to append after.  */\n       saved_labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels.create (8);\n+      bool old_in_switch_expr = gimplify_ctxp->in_switch_expr;\n+      gimplify_ctxp->in_switch_expr = true;\n \n       gimplify_stmt (&SWITCH_BODY (switch_expr), &switch_body_seq);\n \n+      gimplify_ctxp->in_switch_expr = old_in_switch_expr;\n       maybe_warn_switch_unreachable (switch_body_seq);\n+      maybe_warn_implicit_fallthrough (switch_body_seq);\n+      /* Only do this for the outermost GIMPLE_SWITCH.  */\n+      if (!gimplify_ctxp->in_switch_expr)\n+\texpand_FALLTHROUGH (&switch_body_seq);\n \n       labels = gimplify_ctxp->case_labels;\n       gimplify_ctxp->case_labels = saved_labels;\n@@ -1694,6 +2126,21 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Gimplify the LABEL_EXPR pointed to by EXPR_P.  */\n+\n+static enum gimplify_status\n+gimplify_label_expr (tree *expr_p, gimple_seq *pre_p)\n+{\n+  gcc_assert (decl_function_context (LABEL_EXPR_LABEL (*expr_p))\n+\t      == current_function_decl);\n+\n+  glabel *label_stmt = gimple_build_label (LABEL_EXPR_LABEL (*expr_p));\n+  gimple_set_location (label_stmt, EXPR_LOCATION (*expr_p));\n+  gimplify_seq_add_stmt (pre_p, label_stmt);\n+\n+  return GS_ALL_DONE;\n+}\n+\n /* Gimplify the CASE_LABEL_EXPR pointed to by EXPR_P.  */\n \n static enum gimplify_status\n@@ -1711,6 +2158,7 @@ gimplify_case_label_expr (tree *expr_p, gimple_seq *pre_p)\n       break;\n \n   label_stmt = gimple_build_label (CASE_LABEL (*expr_p));\n+  gimple_set_location (label_stmt, EXPR_LOCATION (*expr_p));\n   ctxp->case_labels.safe_push (*expr_p);\n   gimplify_seq_add_stmt (pre_p, label_stmt);\n \n@@ -10777,11 +11225,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  break;\n \n \tcase LABEL_EXPR:\n-\t  ret = GS_ALL_DONE;\n-\t  gcc_assert (decl_function_context (LABEL_EXPR_LABEL (*expr_p))\n-\t\t      == current_function_decl);\n-\t  gimplify_seq_add_stmt (pre_p,\n-\t\t\t  gimple_build_label (LABEL_EXPR_LABEL (*expr_p)));\n+\t  ret = gimplify_label_expr (expr_p, pre_p);\n \t  break;\n \n \tcase CASE_LABEL_EXPR:"}, {"sha": "608542c63d9b721e763d3b5e5494d7cff49c2564", "filename": "gcc/godump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgodump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fgodump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgodump.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -893,6 +893,7 @@ go_format_type (struct godump_container *container, tree type,\n     case UNION_TYPE:\n       is_union = true;\n       /* Fall through to RECORD_TYPE case.  */\n+      gcc_fallthrough ();\n     case RECORD_TYPE:\n       {\n \tunsigned int prev_field_end;"}, {"sha": "029a534e9eb838c78f6b184f6ba4299ac5a20328", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -244,6 +244,15 @@ expand_TSAN_FUNC_EXIT (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in the lower pass.  */\n+\n+static void\n+expand_FALLTHROUGH (internal_fn, gcall *call)\n+{\n+  error_at (gimple_location (call),\n+\t    \"invalid use of attribute %<fallthrough%>\");\n+}\n+\n /* Helper function for expand_addsub_overflow.  Return 1\n    if ARG interpreted as signed in its precision is known to be always\n    positive or 2 if ARG is known to be always negative, or 3 if ARG may"}, {"sha": "d4fbdb286220797464d8b7e580da403d73474cb7", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -195,6 +195,9 @@ DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_COMPLEMENT, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ATOMIC_BIT_TEST_AND_RESET, ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ATOMIC_COMPARE_EXCHANGE, ECF_LEAF | ECF_NOTHROW, NULL)\n \n+/* To implement [[fallthrough]].  */\n+DEF_INTERNAL_FN (FALLTHROUGH, ECF_LEAF | ECF_NOTHROW, NULL)\n+\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_OPTAB_FN"}, {"sha": "79a846cd432a4c107e59a49ae9618e4b0478d58a", "filename": "gcc/langhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -725,3 +725,12 @@ lang_GNU_Fortran (void)\n {\n   return strncmp (lang_hooks.name, \"GNU Fortran\", 11) == 0;\n }\n+\n+/* Returns true if the current lang_hooks represents the GNU Objective-C\n+   frontend.  */\n+\n+bool\n+lang_GNU_OBJC (void)\n+{\n+  return strncmp (lang_hooks.name, \"GNU Objective-C\", 15) == 0;\n+}"}, {"sha": "cfaee621c6172d10ecbe53e5f7a4f5b122d40645", "filename": "gcc/langhooks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -546,5 +546,6 @@ extern tree add_builtin_type (const char *name, tree type);\n extern bool lang_GNU_C (void);\n extern bool lang_GNU_CXX (void);\n extern bool lang_GNU_Fortran (void);\n- \n+extern bool lang_GNU_OBJC (void);\n+\n #endif /* GCC_LANG_HOOKS_H */"}, {"sha": "55aafe46e877c8252ec519b74d9b7f5fe245a82a", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -3022,6 +3022,7 @@ elimination_effects (rtx x, machine_mode mem_mode)\n \tbreak;\n \n       /* Fall through to generic unary operation case.  */\n+      gcc_fallthrough ();\n     case STRICT_LOW_PART:\n     case NEG:          case NOT:\n     case SIGN_EXTEND:  case ZERO_EXTEND:"}, {"sha": "32e3e44856dcc0a11c1ed6a1a17ad77127af5399", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -364,6 +364,7 @@ mark_referenced_resources (rtx x, struct resources *res,\n \t}\n \n       /* ... fall through to other INSN processing ...  */\n+      gcc_fallthrough ();\n \n     case INSN:\n     case JUMP_INSN:\n@@ -674,6 +675,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \t}\n \n       /* ... and also what its RTL says it modifies, if anything.  */\n+      gcc_fallthrough ();\n \n     case JUMP_INSN:\n     case INSN:"}, {"sha": "8ca71cf0f0e4b15c723aaeec0f45c44ac3a85674", "filename": "gcc/system.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -746,6 +746,12 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n #define gcc_unreachable() (fancy_abort (__FILE__, __LINE__, __FUNCTION__))\n #endif\n \n+#if GCC_VERSION >= 7000\n+# define gcc_fallthrough() __attribute__((fallthrough))\n+#else\n+# define gcc_fallthrough()\n+#endif\n+\n #if GCC_VERSION >= 3001\n #define STATIC_CONSTANT_P(X) (__builtin_constant_p (X) && (X))\n #else"}, {"sha": "2dd006e194065c07b144784abc1c824d1a6fdbe9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,37 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* c-c++-common/Wimplicit-fallthrough-1.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-10.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-11.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-12.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-13.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-14.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-15.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-16.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-17.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-18.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-19.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-20.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-21.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-2.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-3.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-4.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-5.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-6.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-7.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-8.c: New test.\n+\t* c-c++-common/Wimplicit-fallthrough-9.c: New test.\n+\t* c-c++-common/attr-fallthrough-1.c: New test.\n+\t* c-c++-common/attr-fallthrough-2.c: New test.\n+\t* g++.dg/cpp0x/fallthrough1.C: New test.\n+\t* g++.dg/cpp0x/fallthrough2.C: New test.\n+\t* g++.dg/cpp1z/fallthrough1.C: New test.\n+\t* g++.dg/warn/Wunused-label-1.C: Turn dg-error into dg-warning.\n+\t* gcc.dg/Wimplicit-fallthrough-1.c: New test.\n+\t* obj-c++.dg/Wimplicit-fallthrough-1.mm: New test.\n+\t* objc.dg/Wimplicit-fallthrough-1.m: New test.\n+\n 2016-09-25  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/77429 "}, {"sha": "b45880f19b4e9d66b7712213075036e65a2b10fc", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-1.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,38 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+/* Test taken from\n+   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf>.  */\n+\n+extern void f (int);\n+\n+void\n+foo (int n)\n+{\n+  switch (n)\n+    {\n+    case 22:\n+    case 33:\n+      f (1);  /* { dg-warning \"statement may fall through\" } */\n+    case 44:\n+      f (2);\n+      __attribute__((fallthrough));\n+    case 55:\n+      if (n > 10)\n+\t{\n+\t  f (3);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  f (4);\n+\t  __attribute__((fallthrough));\n+\t}\n+    case 66:\n+      f (5);\n+     __attribute__((fallthrough)); /* { dg-warning \"not preceding\" } */\n+      f (6); /* { dg-warning \"statement may fall through\" } */\n+    case 77:\n+       f (7);\n+    }\n+}"}, {"sha": "99e44d9be7ac5321ed6a7f8a44b2c2a693463025", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-10.c", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-10.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,239 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  break;\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else\n+\tbreak;\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (2);\n+      else if (i > 10)\n+\t{\n+\t  bar (3);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else\n+\tbreak;\n+      case 2:\n+\tbar (4);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  break;\n+\t}\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  bar (1);\n+\t}\n+      else\n+\tbreak;\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  break;\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  break;\n+\t}\n+      else\n+\tbreak;\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  break;\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  break;\n+\t}\n+      else\n+\tbar (2); /* { dg-warning \"statement may fall through\" } */\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  break;\n+\t}\n+      else\n+\tbar (2); /* { dg-warning \"statement may fall through\" } */\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else\n+\tbreak;\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else\n+\tbar (2); /* { dg-warning \"statement may fall through\" } */\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  bar (1);\n+\t  bar (2);\n+\t}\n+      else\n+\t__attribute__((fallthrough));\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)  /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  bar (0);\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t}\n+      else\n+\t{\n+\t  bar (1);\n+\t  __attribute__((fallthrough));\n+\t}\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  __attribute__((fallthrough));\n+\t}\n+      else if (i > 10)\n+\t{\n+\t  bar (1);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  bar (1);\n+\t  __attribute__((fallthrough));\n+\t}\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t  bar (0);\n+\t  break;\n+\t}\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  bar (1);\n+\t}\n+      else\n+\t{\n+\t  bar (1);\n+\t  __attribute__((fallthrough));\n+\t}\n+      case 2:\n+\tbar (99);\n+    }\n+}"}, {"sha": "e8f47f56ab99f2f10377150592a5e2bfbeef1999", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-11.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-11.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,23 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough -O2\" } */\n+\n+/* Prevent false positive with optimizations.  */\n+\n+extern void g (int);\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 10)\n+\tg (0);\n+      else\n+\tgoto L;\n+      break;\n+L:\n+    case 2:;\n+    }\n+}"}, {"sha": "91a68ab0771f511e92ba8b7213f335b22702a362", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-12.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-12.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,26 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough -O2\" } */\n+\n+/* Don't let optimizations preclude the warning.  */\n+\n+extern void bar (int);\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 1)\n+\tbar (1);\n+      else\n+\tgoto D;\n+      break;\n+    case 2:\n+      bar (2); /* { dg-warning \"statement may fall through\" } */\n+    D:\n+    default:\n+      bar (33);\n+    }\n+}"}, {"sha": "f3ec79f975663de511ad4d799f16ced47a66d590", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-13.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-13.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,63 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* As per <http://security.coverity.com/blog/2013/Sep/gimme-a-break.html>, don't\n+   warn for terminated branches (fall through to break / end of the switch).  */\n+\n+extern void bar (int);\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+    default:\n+      return;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+    default:\n+      goto X;\n+    }\n+X:\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+    default:\n+      break;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+    case 2:\n+    case 3:\n+    default:\n+      break;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+    default:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+    case 2:\n+    case 3:\n+    default:;\n+    }\n+}"}, {"sha": "b7c825b54500f6479af8c497a4a3e1438fc1892a", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-14.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-14.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,162 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Test various falls through comments.  */\n+\n+extern void bar (int);\n+\n+void\n+fn (int i)\n+{\n+  switch (i)\n+    {\n+    case -1:\n+      bar (-1);\n+      /*-fallthrough*/\n+    case 0:\n+      bar (0);\n+      /*@fallthrough@*/\n+    case 1:\n+      bar (1);\n+      /* FALL THRU */\n+    case 2:\n+       bar (2);\n+      /* FALLTHRU */\n+    case 3:\n+      bar (3);\n+      /* FALLS THRU */\n+    case 4:\n+      bar (4);\n+      /* FALL-THRU */\n+    case 5:\n+      bar (5);\n+      /* FALL THROUGH */\n+    case 6:\n+       bar (6);\n+      /* FALLTHROUGH */\n+    case 7:\n+      bar (7);\n+      /* FALLS THROUGH */\n+    case 8:\n+      bar (8);\n+      /* FALL-THROUGH */\n+    case 9:\n+      bar (9);\n+      /*FALLTHRU*/\n+    case 10:\n+      bar (10);\n+      /* FALLTHRU.*/\n+    case 11:\n+       bar (11);\n+      /* FALLTHROUGH.  */\n+    case 12:\n+       bar (12);\n+      /* Fall thru */\n+    case 13:\n+       bar (13);\n+      /* Falls thru */\n+    case 14:\n+       bar (14);\n+      /* Fall-thru */\n+    case 15:\n+       bar (15);\n+      /* Fall Thru */\n+    case 16:\n+       bar (16);\n+      /* Falls Thru */\n+    case 17:\n+       bar (17);\n+      /* Fall-Thru */\n+    case 18:\n+       bar (18);\n+      /* Fall through */\n+    case 19:\n+       bar (19);\n+      /* Falls through */\n+    case 20:\n+       bar (20);\n+      /* Fall-through */\n+    case 21:\n+       bar (21);\n+      /* Fall Through */\n+    case 22:\n+       bar (22);\n+      /* Falls Through */\n+    case 23:\n+       bar (23);\n+      /* Fall-Through */\n+    case 24:\n+       bar (24);\n+      /* Falls through.  */\n+    case 25:\n+       bar (25);\n+      /*     Falls through.  */\n+    case 26:\n+       bar (26);\n+      /* fall thru */\n+    case 27:\n+       bar (27);\n+      /* falls thru */\n+    case 28:\n+       bar (28);\n+      /* fall-thru */\n+    case 29:\n+       bar (29);\n+      /* fall thru */\n+    case 30:\n+       bar (30);\n+      /* falls thru */\n+    case 31:\n+       bar (31);\n+      /* fall-thru */\n+    case 32:\n+       bar (32);\n+      /* fall through */\n+    case 33:\n+       bar (33);\n+      /* falls through */\n+    case 34:\n+       bar (34);\n+      /* fall-through */\n+    default:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      i++;\n+      /*@fallthrough@*/\n+L:\n+    default:\n+      bar (6);\n+    }\n+\n+  {\n+    __label__ L2;\n+    switch (i)\n+      {\n+      case 0:\n+\ti++;\n+\t/*@fallthrough@*/\n+L2:\n+      default:\n+      bar (6);\n+      }\n+  }\n+\n+  /* Don't generate false -Wswitch-unreachable warning.  */\n+  switch (i)\n+    {\n+      /*FALLTHROUGH*/\n+      case 0:\n+        i++;\n+    }\n+\n+  if (i)\n+  {\n+    /* fall through */\n+  L1:;\n+  }\n+}"}, {"sha": "ee3e52d5dc4077a9cd34815f00bce30ade983a8b", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-15.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-15.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,31 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Another nested switch.  Check that we don't warn here.  */\n+\n+void\n+f (int i)\n+{\n+  int j = 0;\n+  switch (i)\n+    {\n+    case 0:\n+    case 1:\n+      j = 10;\n+      __attribute__((fallthrough));\n+    case 2:\n+      j += 10;\n+      break;\n+    case 3:\n+      switch (i)\n+\t{\n+\tcase 5:\n+\t  j += 2;\n+\t  __attribute__((fallthrough));\n+\tcase 6:\n+\t  j += 4;\n+\t  break;\n+\t}\n+   }\n+}"}, {"sha": "923f0121475b21f80bf9c21da293d3495fe7b2ca", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-16.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-16.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,32 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Another nested switch, and with an initialization on top.  Check that\n+   we do warn here.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint t = 3;\n+\tswitch (i)\n+\t  {\n+\t  case 3:\n+\t    if (i > 5)\n+\t      --i;\n+\t    i += 10; /* { dg-warning \"statement may fall through\" } */\n+\t  case 4:\n+\t    t /= 5;\n+\t    break;\n+\t  }\n+\tbreak;\n+      }\n+    case 2:\n+      --i;\n+      break;\n+    }\n+}"}, {"sha": "23ff5f184fbb2663b77b2cb9f88e01d1ab52dbf5", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-17.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-17.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,29 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Another nested switch, and with an initialization on top.  Check that\n+   we do not warn here as the case 3 falls through to break.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint t = 3;\n+\tswitch (i)\n+\t  {\n+\t  case 3:\n+\t    i += 10;\n+\t  case 4:\n+\t    break;\n+\t  }\n+\tbreak;\n+      }\n+    case 2:\n+      --i;\n+      break;\n+    }\n+}"}, {"sha": "2c8a3cb98b3be2510e64e2b2f9c7885f1b8b1487", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-18.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-18.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,42 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Testing some loops.  */\n+\n+int f (void);\n+\n+int\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      for (;;)\n+\t{\n+\t  if (f ()) /* { dg-warning \"statement may fall through\" \"fall through\" { xfail *-*-* } } */\n+\t    break;\n+\t}\n+    case 1:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+h (int i)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      do\n+\t{\n+\t  if (f ()) /* { dg-warning \"statement may fall through\" } */\n+\t    break;\n+\t}\n+      while (0);\n+    case 1:\n+      return 1;\n+    }\n+  return 0;\n+}"}, {"sha": "b7a37910db3d1bdb2da1eadeeaff90ae16e5ac48", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-19.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-19.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,85 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Testing non-case labels.  */\n+\n+int foo (int);\n+\n+void\n+f1 (int i)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      foo (1);\n+    L1:\n+      foo (2);\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      foo (1); /* { dg-warning \"statement may fall through\" } */\n+    L2:\n+    case 2:\n+      foo (2);\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      foo (1); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+    L3:\n+      foo (2);\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      foo (1); /* { dg-warning \"statement may fall through\" } */\n+    L4:\n+    case 2:\n+    L5:\n+      foo (2);\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      switch (i)\n+\t{\n+\tcase 1:\n+\t  foo (2);\n+\tL6:\n+\t  foo (3);\n+\t}\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      switch (i)\n+\t{\n+\tcase 1:\n+\t  foo (2); /* { dg-warning \"statement may fall through\" } */\n+\tL7:\n+\tcase 2:\n+\t  foo (3);\n+\t}\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      switch (i)\n+\t{\n+\tcase 1:\n+\t  foo (2); /* { dg-warning \"statement may fall through\" } */\n+\tcase 2:\n+\tL8:\n+\t  foo (3);\n+\t}\n+    }\n+}"}, {"sha": "4dfb278c27b30188c3d889522ea48a05b2d6d616", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-2.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-2.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,223 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+\n+/* Test if without else.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (1);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)  /* { dg-warning \"statement may fall through\" } */\n+\tgoto L1;\n+    case 2:\n+L1:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)  /* { dg-warning \"statement may fall through\" } */\n+\tgoto L2;\n+L2:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tgoto L3;\n+      break;\n+    case 2:\n+L3:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tgoto L4;\n+      break;\n+L4:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)  /* { dg-warning \"statement may fall through\" } */\n+\tif (i > 9)\n+\t  bar (1);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tif (i > 9)\n+\t  bar (1);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      { int a; }\n+      {\n+      if (i)  /* { dg-warning \"statement may fall through\" } */\n+\tif (i > 9)\n+\t  bar (1);\n+      }\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      bar (2); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      bar (2);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      bar (2); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      bar (2);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      if (i)\n+\tbar (2);\n+      if (i)\n+\tbar (3);\n+      bar (4); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      if (i)\n+\tbar (2);\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (3);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      if (i)\n+\tbar (2);\n+      if (i)\n+\tbar (3);\n+      bar (4);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      if (i)\n+\tbar (2);\n+      if (i)\n+\tbar (3);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+}"}, {"sha": "d37a840a0d930a08276c5b4c4448662ebda32b73", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-20.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-20.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,41 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+int\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case -1:\n+      __attribute__((fallthrough));\n+    default:\n+      __attribute__((fallthrough));\n+    case 1:\n+      return 6;\n+    case 2 ... 4:\n+      __attribute__((fallthrough));\n+    case 5:\n+      return 7;\n+    }\n+  return 0;\n+}\n+\n+int\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case -1:\n+      __attribute__((used)); /* { dg-warning \"ignored|only attribute\" } */\n+    default:\n+      __attribute__((used)); /* { dg-warning \"ignored|only attribute\" } */\n+    case 1:\n+      return 6;\n+    case 2 ... 4:\n+      __attribute__((used)); /* { dg-warning \"ignored|only attribute\" } */\n+    case 5:\n+      return 7;\n+    }\n+  return 0;\n+}"}, {"sha": "6092a9018f33fc808423831cfe61decfe63c832a", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-21.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-21.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,25 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+int\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      i++;\n+      __attribute__((fallthrough));\n+    lab1:\n+    case 1:\n+      i++;\n+      __attribute__((fallthrough)); /* { dg-warning \"not preceding\" } */\n+    lab2:\n+      --i;\n+      break;\n+    case 3:\n+      i++;\n+      break;\n+    }\n+  return 0;\n+}"}, {"sha": "fbb97122ecb5ea39d5eed7644a770c6fcef0b896", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-3.c", "status": "added", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-3.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,543 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+\n+/* Test if with else.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (1);\n+      else\n+\tbar (2);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      else\n+\tbar (2);\n+      bar (3); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        return;\n+      else\n+\tbar (2); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        return;\n+      else\n+\tbar (2);\n+      bar (3); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      else\n+\treturn;\n+      bar (3); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      else\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      else\n+\treturn;\n+      bar (3); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+          bar (1);\n+          bar (2);\n+          bar (3);\n+          bar (4);\n+\t}\n+      else\n+\t{\n+          bar (5);\n+          bar (6);\n+          bar (7);\n+          bar (8);\n+\t}\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+          bar (1);\n+          bar (2);\n+          bar (3);\n+          bar (4);\n+\t}\n+      else\n+\t{\n+          bar (5);\n+          bar (6);\n+          bar (7);\n+          bar (8);\n+\t}\n+      bar (9); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+        {\n+\t}\n+      else\n+\tbar (2);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (1);\n+      else\n+\t{\n+\t}\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t}\n+      else\n+\t{\n+\t}\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\treturn;\n+      else\n+\t{\n+\t}\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t}\n+      else\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        goto L1;\n+      else\n+\tbar (2); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+L1:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        goto L2;\n+      else\n+\tbar (2); /* { dg-warning \"statement may fall through\" } */\n+L2:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (1);\n+      else\n+        goto L3;\n+    case 2:\n+L3:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i) /* { dg-warning \"statement may fall through\" } */\n+\tbar (1);\n+      else\n+        goto L4;\n+L4:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        goto L5;\n+      else\n+        goto L5;\n+L5:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        bar (1);\n+      else\n+\tbar (2);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        bar (1);\n+      else\n+\tbar (2);\n+      bar (3);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        return;\n+      else\n+\tbar (2);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        return;\n+      else\n+\tbar (2);\n+      bar (3);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        bar (1);\n+      else\n+\treturn;\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      else\n+\treturn;\n+      bar (3);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      else\n+\treturn;\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      else\n+\treturn;\n+      bar (3);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+          bar (1);\n+          bar (2);\n+          bar (3);\n+          bar (4);\n+\t}\n+      else\n+\t{\n+          bar (5);\n+          bar (6);\n+          bar (7);\n+          bar (8);\n+\t}\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+          bar (1);\n+          bar (2);\n+          bar (3);\n+          bar (4);\n+\t}\n+      else\n+\t{\n+          bar (5);\n+          bar (6);\n+          bar (7);\n+          bar (8);\n+\t}\n+      bar (9);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        {\n+\t}\n+      else\n+\tbar (2);\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      else\n+\t{\n+\t}\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t}\n+      else\n+\t{\n+\t}\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\treturn;\n+      else\n+\t{\n+\t}\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\t{\n+\t}\n+      else\n+\treturn;\n+      break;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        goto L6;\n+      else\n+\tbar (2);\n+      break;\n+    case 2:\n+L6:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        goto L7;\n+      else\n+\tbar (2);\n+      break;\n+L7:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      else\n+        goto L8;\n+      break;\n+    case 2:\n+L8:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+\tbar (1);\n+      else\n+        goto L9;\n+      break;\n+L9:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i)\n+        goto L10;\n+      else\n+        goto L10;\n+      break;\n+L10:\n+    case 2:\n+      __builtin_abort ();\n+    }\n+}"}, {"sha": "9a0aeb753d92bc755b5efcff1311bdadb85a5412", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-4.c", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-4.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,250 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+\n+/* Test if with more elses.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\tbar (2);\n+      else if (i > 15)\n+\tbar (3);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+\tbar (1);\n+      else if (i > 10)\n+\tbar (2);\n+      else if (i > 15)\n+\tbar (3);\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+        return;\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\tbar (2);\n+      else if (i > 15)\n+\tbar (3);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+        return;\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\tbar (2);\n+      else if (i > 15)\n+\tbar (3);\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15)\n+\tbar (3);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15)\n+\tbar (3);\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\tbar (4);\n+      else if (i > 15)\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\tbar (4);\n+      else if (i > 15)\n+\treturn;\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+        return;\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15) /* { dg-warning \"statement may fall through\" } */\n+\tbar (3);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+        return;\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15) /* { dg-warning \"statement may fall through\" } */\n+\tbar (3);\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+        return;\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\tbar (2);\n+      else if (i > 15)\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+        return;\n+      else if (i > 10) /* { dg-warning \"statement may fall through\" } */\n+\tbar (2);\n+      else if (i > 15)\n+\treturn;\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15)\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5) /* { dg-warning \"statement may fall through\" } */\n+        bar (1);\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15)\n+\treturn;\n+      else\n+\tbar (4);\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+       return;\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15) /* { dg-warning \"statement may fall through\" } */\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+       return;\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15)\n+\treturn;\n+      else\n+\tbar (4); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      __builtin_abort ();\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 5)\n+       return;\n+      else if (i > 10)\n+\treturn;\n+      else if (i > 15)\n+\treturn;\n+      else\n+\treturn;\n+    case 2:\n+      __builtin_abort ();\n+    }\n+}"}, {"sha": "9317484dbb25f4cf407599e78ea26121e90093ac", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-5.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-5.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,109 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+extern void die (void) __attribute__((noreturn));\n+\n+/* Test may_fallthru-ness.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      bar (0);\n+      __attribute__((fallthrough));\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (0);\n+      return;\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (0);\n+      break;\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (0);\n+      goto L1;\n+L1:\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      bar (0);\n+      die ();\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint i, j, k;\n+\tbar (0);\n+\t__attribute__((fallthrough));\n+      }\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint i, j, k;\n+        bar (0);\n+        return;\n+      }\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint i, j, k;\n+        bar (0);\n+        break;\n+      }\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint i, j, k;\n+        bar (0);\n+        goto L2;\n+      }\n+L2:\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint i, j, k;\n+        bar (0);\n+        die ();\n+      }\n+    case 2:;\n+    }\n+}"}, {"sha": "8364c1b670bc2220612692c130f913f3546b4b6a", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-6.c", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-6.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,305 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+\n+/* Test nested scopes.  */\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j;\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 10; /* { dg-warning \"statement may fall through\" } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint k = 9;\n+\tk++;\n+\t{\n+\t  int j = 10;\n+\t  j++; /* { dg-warning \"statement may fall through\" } */\n+\t}\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint k = 9;\n+\tk++;\n+\t{\n+\t  int j = 10;\n+\t  j++;\n+\t  {\n+\t    bar (1); /* { dg-warning \"statement may fall through\" } */\n+\t  }\n+\t}\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\t__attribute__((fallthrough));\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\t{\n+\t  int k = j + 5;\n+\t  bar (k);\n+\t  __attribute__((fallthrough));\n+\t}\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\treturn;\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tgoto L1;\n+      }\n+L1:\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      { /* { dg-warning \"statement may fall through\" \"\" { target c } 120 } */\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  return; /* { dg-warning \"statement may fall through\" \"\" { target c++ } 124 } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  return;\n+\telse\n+\t  return;\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      { /* { dg-warning \"statement may fall through\" \"\" { target c } 148 } */\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  bar (1);\n+\telse\n+\t  return; /* { dg-warning \"statement may fall through\" \"\" { target c++ } 154 } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  return;\n+\telse\n+\t  bar (2); /* { dg-warning \"statement may fall through\" } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      { /* { dg-warning \"statement may fall through\" \"\" { target c } 178 } */\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  bar (1);\n+\telse\n+\t  bar (2); /* { dg-warning \"statement may fall through\" \"\" { target c++ } 184 } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  return;\n+      }\n+      break;\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  return;\n+\telse\n+\t  return;\n+      }\n+      break;\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  bar (1);\n+\telse\n+\t  return;\n+      }\n+      break;\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  return;\n+\telse\n+\t  bar (2);\n+      }\n+      break;\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  bar (1);\n+\telse\n+\t  bar (2);\n+      }\n+      break;\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 9;\n+\twhile (1);\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      { /* { dg-warning \"statement may fall through\" \"\" { target c } 282 } */\n+\tint j = 9;\n+\tswitch (j); /* { dg-warning \"statement may fall through\" \"\" { target c++ } 284 } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tint j = 0;\n+\tbar (j);\n+\tif (j == 8)\n+\t  bar (1);\n+\telse\n+\t  bar (2);\n+\t__attribute__((fallthrough));\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+}"}, {"sha": "21a158ca14faec108dfb7c92e96a8389caad113f", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-7.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-7.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,124 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void bar (int);\n+extern int bar2 (void);\n+extern int *map;\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      bar (0); /* { dg-warning \"statement may fall through\" } */\n+      static int i = 10;\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      { /* { dg-warning \"statement may fall through\" \"\" { target c } 23 } */\n+\tint a[i]; /* { dg-warning \"statement may fall through\" \"\" { target c++ } 24 } */\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      for (int j = 0; j < 10; j++) /* { dg-warning \"statement may fall through\" \"\" { target c } 33 } */\n+\tmap[j] = j; /* { dg-warning \"statement may fall through\" \"\" { target c++ } 34 } */\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      do /* { dg-warning \"statement may fall through\" \"\" { target c++ } 42 } */\n+\tbar (2);\n+      while (--i); /* { dg-warning \"statement may fall through\" \"\" { target c } 44 } */\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tswitch (i + 2)\n+\t  case 4:\n+\t    bar (1); /* { dg-warning \"statement may fall through\" } */\n+\t  case 5:\n+\t    bar (5);\n+\t    return;\n+      }\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:;\n+    case 2:;\n+    }\n+\n+  switch (i)\n+    {\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i & 1) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  bar (23);\n+\t  break;\n+\t}\n+    case 2:\n+      bar (99);\n+    }\n+\n+  switch (i)\n+    {\n+    case 1:\n+      if (i > 9) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  bar (9);\n+\t  if (i == 10)\n+\t    {\n+\t      bar (10);\n+\t      break;\n+\t    }\n+\t}\n+    case 2:\n+      bar (99);\n+    }\n+\n+  int r;\n+  switch (i)\n+    {\n+    case 1:\n+      r = bar2 ();\n+      if (r) /* { dg-warning \"statement may fall through\" } */\n+\tbreak;\n+      case 2:\n+\tbar (99);\n+    }\n+\n+  switch (i)\n+    {\n+      case 1:\n+\tr = bar2 ();\n+\tif (r)\n+\t  return;\n+\tif (!i) /* { dg-warning \"statement may fall through\" } */\n+\t  return;\n+      case 2:\n+\tbar (99);\n+    }\n+}"}, {"sha": "0ed7928fd79124b680c97db4e04bac99413de280", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-8.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-8.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,101 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+extern void grace (int);\n+\n+int\n+fn1 (int i)\n+{\n+  switch (i)\n+    case 1:\n+    if (i == 5)\n+      grace (0);\n+    else\n+      goto done;\n+done:;\n+}\n+\n+int\n+fn2 (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i == 5) /* { dg-warning \"statement may fall through\" } */\n+\tgrace (0);\n+      else\n+\tgoto done;\n+    case 2:\n+      --i;\n+    }\n+done:;\n+}\n+\n+int\n+fn3 (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+    if (i == 5)\n+      goto done;\n+    else\n+      goto done;\n+    }\n+done:;\n+}\n+\n+int\n+fn4 (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i == 5)\n+\t{\n+\t  grace (1);\n+\t  goto done;\n+\t}\n+      else\n+\tgoto done;\n+    case 2:;\n+    }\n+done:;\n+}\n+\n+int\n+fn5 (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i == 5)\n+\t{\n+\t  grace (1);\n+\t  goto done;\n+\t}\n+      else\n+\tgrace (4); /* { dg-warning \"statement may fall through\" } */\n+    case 2:\n+      grace (9);\n+    }\n+done:;\n+}\n+\n+int\n+fn6 (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      if (i == 5) /* { dg-warning \"statement may fall through\" } */\n+\t{\n+\t  grace (1);\n+\t  goto done;\n+\t}\n+    case 2:\n+      grace (8);\n+    }\n+done:;\n+}"}, {"sha": "394d6998b65549397d93fd00e7bac80f7b85618b", "filename": "gcc/testsuite/c-c++-common/Wimplicit-fallthrough-9.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWimplicit-fallthrough-9.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,26 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+\n+/* Test we don't remove FALLTHROUGH () too early.  */\n+\n+extern void h (int);\n+\n+void\n+g (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      {\n+\tswitch (i)\n+\t  {\n+\t    case 3:\n+\t      h (7);\n+\t      __attribute__((fallthrough));\n+\t    case 4:;\n+\t  }\n+      }\n+    case 2:;\n+    }\n+}"}, {"sha": "ecfd094d9cd8052f64a04ed35366f431a5cf83f7", "filename": "gcc/testsuite/c-c++-common/attr-fallthrough-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fallthrough-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fallthrough-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fallthrough-1.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,57 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -Wextra -Wpedantic\" } */\n+\n+extern void bar (int);\n+void\n+fn (int i)\n+{\n+  __attribute__((fallthrough)) int j = 0; /* { dg-warning \"ignored|attribute not followed\" } */\n+\n+  if (j)\n+    __attribute__((fallthrough));  /* { dg-error \"invalid use\" } */\n+\n+  __attribute__((fallthrough));  /* { dg-error \"invalid use\" } */\n+  switch (i)\n+  {\n+    __attribute__((fallthrough)); /* { dg-warning \"statement will never\" } */\n+  case 1:\n+   i++;\n+   __attribute__((fallthrough));\n+  case 2:\n+    if (i) /* { dg-warning \"statement may fall through\" } */\n+      bar (2);\n+    else\n+      __attribute__((fallthrough));\n+  case 3:\n+    if (i > 1)\n+      __attribute__((fallthrough));\n+    else\n+      return;\n+  case 4:\n+    if (i)\n+      __attribute__((fallthrough)); /* { dg-warning \"not preceding\" } */\n+    __attribute__((fallthrough));\n+  case 5:\n+   ;\n+   __attribute__((fallthrough));\n+  case 6:\n+    if (i) /* { dg-warning \"statement may fall through\" } */\n+      bar (6);\n+    else\n+      {\n+\t__attribute__((fallthrough));\n+      }\n+  case 7:\n+    if (i > 1)\n+      {\n+\t__attribute__((fallthrough));\n+      }\n+    else\n+      bar (7); /* { dg-warning \"statement may fall through\" } */\n+  default:\n+    --j;\n+  }\n+\n+  __attribute__((fallthrough)); /* { dg-error \"invalid use\" } */\n+}"}, {"sha": "959564bca9f153d2844355899f8965bb34a43f8c", "filename": "gcc/testsuite/c-c++-common/attr-fallthrough-2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fallthrough-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fallthrough-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-fallthrough-2.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,54 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -Wextra -Wpedantic -Wno-unused -Wno-implicit-fallthrough\" } */\n+\n+extern void bar (int);\n+void\n+fn (int i)\n+{\n+  switch (i)\n+  {\n+  case 1:\n+    bar (1);\n+    __attribute__((used));\n+    /* { dg-warning \"empty declaration\" \"\" { target c } 13 } */\n+    /* { dg-warning \"ignored\" \"\" { target c++ } 13 } */\n+  case 2:\n+    bar (1);\n+    __attribute__((foo));\n+    /* { dg-warning \"empty declaration\" \"\" { target c } 18 } */\n+    /* { dg-warning \"ignored\" \"\" { target c++ } 18 } */\n+  case 3:\n+    bar (1);\n+    __attribute__((fallthrough)) /* { dg-warning \"not followed\" \"\" { target c } } */\n+  case 4: /* { dg-error \"expected\" } */\n+    bar (1);\n+    __attribute__((fallthrough)) 1;\n+    /* { dg-error \"expected\" \"\" { target c } 26 } */\n+    /* { dg-warning \"not followed\" \"\" { target *-*-* } 26 } */\n+  case 5:\n+    bar (1);\n+    __attribute__((fallthrough)) int i; /* { dg-warning \"ignored|not followed\" } */\n+  case 6:\n+    bar (1);\n+    __attribute__((fallthrough (\"x\"))); /* { dg-warning \"specified with a parameter\" } */\n+  case 7:\n+    bar (1);\n+    __attribute__((fallthrough, fallthrough)); /* { dg-warning \"attribute specified multiple times\" } */\n+  case 8:\n+    bar (1);\n+    __attribute__((fallthrough));\n+  case 9:\n+    __attribute__((fallthrough));\n+    /* { dg-warning \"not preceding\" \"\" { target *-*-* } 42 } */\n+    bar (1);\n+  case 10:\n+    bar (1);\n+    __attribute__((unused, fallthrough)); /* { dg-warning \"attribute ignored\" } */\n+  case 11:\n+    bar (1);\n+    __attribute__((fallthrough, unused)); /* { dg-warning \"attribute ignored\" } */\n+  default:\n+    bar (99);\n+  }\n+}"}, {"sha": "523067e6849c104c51d0e27a841c0f8e607d0d31", "filename": "gcc/testsuite/g++.dg/cpp0x/fallthrough1.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffallthrough1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffallthrough1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffallthrough1.C?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,57 @@\n+// PR c/7652\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wextra -Wall -Wpedantic\" }\n+\n+extern void bar (int);\n+void\n+fn (int i)\n+{\n+  [[gnu::fallthrough]] int j = 0; // { dg-warning \"attribute ignored\" }\n+\n+  if (j)\n+    [[gnu::fallthrough]];  // { dg-error \"invalid use\" }\n+\n+  [[gnu::fallthrough]];  // { dg-error \"invalid use\" }\n+  switch (i)\n+  {\n+    [[gnu::fallthrough]]; // { dg-warning \"statement will never\" }\n+  case 1:\n+   i++;\n+   [[gnu::fallthrough]];\n+  case 2:\n+    if (i) // { dg-warning \"statement may fall through\" }\n+      bar (2);\n+    else\n+      [[gnu::fallthrough]];\n+  case 3:\n+    if (i > 1)\n+      [[gnu::fallthrough]];\n+    else\n+      return;\n+  case 4:\n+    if (i)\n+      [[gnu::fallthrough]]; // { dg-warning \"not preceding\" }\n+    [[gnu::fallthrough]];\n+  case 5:\n+   ;\n+   [[gnu::fallthrough]];\n+  case 6:\n+    if (i) // { dg-warning \"statement may fall through\" }\n+      bar (6);\n+    else\n+      {\n+\t[[gnu::fallthrough]];\n+      }\n+  case 7:\n+    if (i > 1)\n+      {\n+\t[[gnu::fallthrough]];\n+      }\n+    else\n+      bar (7); // { dg-warning \"statement may fall through\" }\n+  default:\n+    --j;\n+  }\n+\n+  [[gnu::fallthrough]]; // { dg-error \"invalid use\" }\n+}"}, {"sha": "b6964e151d5376a7eb23cb6264bae0dc6f9c5612", "filename": "gcc/testsuite/g++.dg/cpp0x/fallthrough2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffallthrough2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffallthrough2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffallthrough2.C?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,21 @@\n+// PR c/7652\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wextra -Wall -Wpedantic\" }\n+\n+extern void bar (int);\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+      [[fallthrough]]; // { dg-warning \".fallthrough. is a C\\\\+\\\\+17 feature\" }\n+    case 3:\n+      bar (1);\n+      [[gnu::fallthrough, gnu::fallthrough]]; // { dg-warning \".fallthrough. attribute specified multiple times\" }\n+    case 2:\n+      bar (2);\n+    }\n+}"}, {"sha": "d15b1eac88a145d327a6c716594f5d4077fc209d", "filename": "gcc/testsuite/g++.dg/cpp1z/fallthrough1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffallthrough1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffallthrough1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffallthrough1.C?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,20 @@\n+// PR c/7652\n+// { dg-do compile }\n+// { dg-options \"-std=c++1z -Wextra -Wall -Wpedantic\" }\n+\n+// Check that we accept attribute [[fallthrough]].\n+\n+extern void bar (int);\n+\n+void\n+f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      bar (1);\n+      [[fallthrough]];\n+    case 2:\n+      bar (2);\n+    }\n+}"}, {"sha": "255a26e0e5a8e39c8a3d297fc31ee9579cc92c04", "filename": "gcc/testsuite/g++.dg/warn/Wunused-label-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWunused-label-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWunused-label-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWunused-label-1.C?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -21,7 +21,7 @@ void\n f3()\n {\n   // The next line would be OK in C but is a syntax error in C++.\n- l2: __attribute__ ((unused)) f9();\t// { dg-error \"expected\" }\n+ l2: __attribute__ ((unused)) f9();\t// { dg-warning \"ignored\" }\n \t\t// We still get an unused label warning--this is\n \t\t// optional and can be removed if it ever changes.\n \t\t// { dg-warning \"not used\" \"expected\" { target *-*-* } 24 }"}, {"sha": "f8b54f5237b4a1d28da8215ff25a0c0c377b7bcf", "filename": "gcc/testsuite/gcc.dg/Wimplicit-fallthrough-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fgcc.dg%2FWimplicit-fallthrough-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fgcc.dg%2FWimplicit-fallthrough-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWimplicit-fallthrough-1.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,22 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough -Wdeclaration-after-statement\" } */\n+\n+/* Test we don't print bogus \"mixed declarations and code\" warning.  */\n+\n+int\n+f (int b)\n+{\n+  switch (b)\n+    {\n+    case 0:\n+      b++;\n+      __attribute__((fallthrough));\n+    case 1:\n+      b--;\n+      __attribute__((unused)) int a; /* { dg-warning \"mixed declarations and code\" } */\n+    case 2:\n+      break;\n+    }\n+  return 99;\n+}"}, {"sha": "b45880f19b4e9d66b7712213075036e65a2b10fc", "filename": "gcc/testsuite/obj-c++.dg/Wimplicit-fallthrough-1.mm", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2FWimplicit-fallthrough-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2FWimplicit-fallthrough-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2FWimplicit-fallthrough-1.mm?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,38 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+/* Test taken from\n+   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf>.  */\n+\n+extern void f (int);\n+\n+void\n+foo (int n)\n+{\n+  switch (n)\n+    {\n+    case 22:\n+    case 33:\n+      f (1);  /* { dg-warning \"statement may fall through\" } */\n+    case 44:\n+      f (2);\n+      __attribute__((fallthrough));\n+    case 55:\n+      if (n > 10)\n+\t{\n+\t  f (3);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  f (4);\n+\t  __attribute__((fallthrough));\n+\t}\n+    case 66:\n+      f (5);\n+     __attribute__((fallthrough)); /* { dg-warning \"not preceding\" } */\n+      f (6); /* { dg-warning \"statement may fall through\" } */\n+    case 77:\n+       f (7);\n+    }\n+}"}, {"sha": "b45880f19b4e9d66b7712213075036e65a2b10fc", "filename": "gcc/testsuite/objc.dg/Wimplicit-fallthrough-1.m", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fobjc.dg%2FWimplicit-fallthrough-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftestsuite%2Fobjc.dg%2FWimplicit-fallthrough-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2FWimplicit-fallthrough-1.m?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -0,0 +1,38 @@\n+/* PR c/7652 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wimplicit-fallthrough\" } */\n+/* Test taken from\n+   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0188r0.pdf>.  */\n+\n+extern void f (int);\n+\n+void\n+foo (int n)\n+{\n+  switch (n)\n+    {\n+    case 22:\n+    case 33:\n+      f (1);  /* { dg-warning \"statement may fall through\" } */\n+    case 44:\n+      f (2);\n+      __attribute__((fallthrough));\n+    case 55:\n+      if (n > 10)\n+\t{\n+\t  f (3);\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  f (4);\n+\t  __attribute__((fallthrough));\n+\t}\n+    case 66:\n+      f (5);\n+     __attribute__((fallthrough)); /* { dg-warning \"not preceding\" } */\n+      f (6); /* { dg-warning \"statement may fall through\" } */\n+    case 77:\n+       f (7);\n+    }\n+}"}, {"sha": "353a62504250451523a5298bf47f1694a304d1ed", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1077,6 +1077,9 @@ struct GTY(()) tree_base {\n        TRANSACTION_EXPR_RELAXED in\n \t   TRANSACTION_EXPR\n \n+       FALLTHROUGH_LABEL_P in\n+\t   LABEL_DECL\n+\n    private_flag:\n \n        TREE_PRIVATE in"}, {"sha": "7f78734ea229fda7c46751e9ba7ac281d8730bc7", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1885,8 +1885,8 @@ find_deriving_biv_for_expr (struct ivopts_data *data, tree expr)\n       iv = find_deriving_biv_for_expr (data, e2);\n       if (iv)\n \treturn iv;\n+      gcc_fallthrough ();\n \n-      /* Fallthru.  */\n     CASE_CONVERT:\n       /* Casts are simple.  */\n       return find_deriving_biv_for_expr (data, e1);"}, {"sha": "0d9ad0198faadb471b798f622ba24916c5e02c6b", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -774,6 +774,11 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n    computed gotos.  */\n #define FORCED_LABEL(NODE) (LABEL_DECL_CHECK (NODE)->base.side_effects_flag)\n \n+/* Whether a case or a user-defined label is allowed to fall through to.\n+   This is used to implement -Wimplicit-fallthrough.  */\n+#define FALLTHROUGH_LABEL_P(NODE) \\\n+  (LABEL_DECL_CHECK (NODE)->base.public_flag)\n+\n /* Nonzero means this expression is volatile in the C sense:\n    its address should be of type `volatile WHATEVER *'.\n    In other words, the declared item is volatile qualified."}, {"sha": "3972790cc7bdfd72e91c2c59d678e2187c70d5c7", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -4173,7 +4173,7 @@ output_addressed_constants (tree exp)\n     case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       output_addressed_constants (TREE_OPERAND (exp, 1));\n-      /* Fall through.  */\n+      gcc_fallthrough ();\n \n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:"}, {"sha": "94ea99db8a129ff9c7afadc9c0e5f0fd57987418", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,13 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/7652\n+\t* include/cpplib.h (PREV_FALLTHROUGH): Define.\n+\t* internal.h (CPP_FALLTHRU): Define.\n+\t* lex.c (fallthrough_comment_p): New function.\n+\t(_cpp_lex_direct): Set PREV_FALLTHROUGH on tokens succeeding a falls\n+\tthrough comment.\n+\n 2016-09-23  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR preprocessor/77672"}, {"sha": "6352ac586d4c14d9080450edaa0c72afc9fe0ee3", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -185,14 +185,16 @@ struct GTY(()) cpp_string {\n #define STRINGIFY_ARG\t(1 << 2) /* If macro argument to be stringified.  */\n #define PASTE_LEFT\t(1 << 3) /* If on LHS of a ## operator.  */\n #define NAMED_OP\t(1 << 4) /* C++ named operators.  */\n-#define NO_EXPAND\t(1 << 5) /* Do not macro-expand this token.  */\n+#define PREV_FALLTHROUGH (1 << 5) /* On a token preceeded by FALLTHROUGH\n+\t\t\t\t     comment.  */\n #define BOL\t\t(1 << 6) /* Token at beginning of line.  */\n #define PURE_ZERO\t(1 << 7) /* Single 0 digit, used by the C++ frontend,\n \t\t\t\t    set in c-lex.c.  */\n #define SP_DIGRAPH\t(1 << 8) /* # or ## token was a digraph.  */\n #define SP_PREV_WHITE\t(1 << 9) /* If whitespace before a ##\n \t\t\t\t    operator, or before this token\n \t\t\t\t    after a # operator.  */\n+#define NO_EXPAND\t(1 << 10) /* Do not macro-expand this token.  */\n \n /* Specify which field, if any, of the cpp_token union is used.  */\n "}, {"sha": "0c47e2980701ace96e576ffdb05cce50e4cd3977", "filename": "libcpp/lex.c", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -2032,6 +2032,94 @@ save_comment (cpp_reader *pfile, cpp_token *token, const unsigned char *from,\n   store_comment (pfile, token);\n }\n \n+/* Returns true if comment at COMMENT_START is a recognized FALLTHROUGH\n+   comment.  */\n+\n+static bool\n+fallthrough_comment_p (cpp_reader *pfile, const unsigned char *comment_start)\n+{\n+  const unsigned char *from = comment_start + 1;\n+  /* Whole comment contents:\n+     -fallthrough\n+     @fallthrough@\n+   */\n+  if (*from == '-' || *from == '@')\n+    {\n+      size_t len = sizeof \"fallthrough\" - 1;\n+      if ((size_t) (pfile->buffer->cur - from - 1) < len)\n+\treturn false;\n+      if (memcmp (from + 1, \"fallthrough\", len))\n+\treturn false;\n+      if (*from == '@')\n+\t{\n+\t  if (from[len + 1] != '@')\n+\t    return false;\n+\t  len++;\n+\t}\n+      from += 1 + len;\n+    }\n+  /* Whole comment contents (regex):\n+     [ \\t]*FALL(S | |-)?THR(OUGH|U)\\.?[ \\t]*\n+     [ \\t]*Fall(s | |-)?[Tt]hr(ough|u)\\.?[ \\t]*\n+     [ \\t]*fall(s | |-)?thr(ough|u)\\.?[ \\t]*\n+   */\n+  else\n+    {\n+      while (*from == ' ' || *from == '\\t')\n+\tfrom++;\n+      unsigned char f = *from;\n+      if (f != 'F' && f != 'f')\n+\treturn false;\n+      if ((size_t) (pfile->buffer->cur - from) < sizeof \"fallthrough\")\n+\treturn false;\n+      bool all_upper = false;\n+      if (f == 'F' && memcmp (from + 1, \"ALL\", sizeof \"ALL\" - 1) == 0)\n+\tall_upper = true;\n+      else if (memcmp (from + 1, \"all\", sizeof \"all\" - 1))\n+\treturn false;\n+      if (from[sizeof \"fall\" - 1] == (all_upper ? 'S' : 's')\n+\t  && from[sizeof \"falls\" - 1] == ' ')\n+\tfrom += sizeof \"falls \" - 1;\n+      else if (from[sizeof \"fall\" - 1] == ' '\n+\t       || from[sizeof \"fall\" - 1] == '-')\n+\tfrom += sizeof \"fall \" - 1;\n+      else if (from[sizeof \"fall\" - 1] != (all_upper ? 'T' : 't'))\n+\treturn false;\n+      else\n+\tfrom += sizeof \"fall\" - 1;\n+      if ((f == 'f' || *from != 'T') && (all_upper || *from != 't'))\n+\treturn false;\n+      if ((size_t) (pfile->buffer->cur - from) < sizeof \"thru\")\n+\treturn false;\n+      if (memcmp (from + 1, all_upper ? \"HRU\" : \"hru\", sizeof \"hru\" - 1))\n+\t{\n+\t  if ((size_t) (pfile->buffer->cur - from) < sizeof \"through\")\n+\t    return false;\n+\t  if (memcmp (from + 1, all_upper ? \"HROUGH\" : \"hrough\",\n+\t\t      sizeof \"hrough\" - 1))\n+\t    return false;\n+\t  from += sizeof \"through\" - 1;\n+\t}\n+      else\n+\tfrom += sizeof \"thru\" - 1;\n+      if (*from == '.')\n+\tfrom++;\n+      while (*from == ' ' || *from == '\\t')\n+\tfrom++;\n+    }\n+  /* C block comment.  */\n+  if (*comment_start == '*')\n+    {\n+      if (*from != '*' || from[1] != '/')\n+\treturn false;\n+    }\n+  /* C++ line comment.  */\n+  else if (*from != '\\n')\n+    return false;\n+\n+  return true;\n+}\n+\n /* Allocate COUNT tokens for RUN.  */\n void\n _cpp_init_tokenrun (tokenrun *run, unsigned int count)\n@@ -2310,7 +2398,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n {\n   cppchar_t c;\n   cpp_buffer *buffer;\n-  const unsigned char *comment_start;\n+  const unsigned char *comment_start = NULL;\n   cpp_token *result = pfile->cur_token++;\n \n  fresh_line:\n@@ -2337,6 +2425,8 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t    }\n \t  return result;\n \t}\n+      if (buffer != pfile->buffer)\n+\tcomment_start = NULL;\n       if (!pfile->keep_tokens)\n \t{\n \t  pfile->cur_run = &pfile->base_run;\n@@ -2443,6 +2533,11 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t  result->flags |= NAMED_OP;\n \t  result->type = (enum cpp_ttype) result->val.node.node->directive_index;\n \t}\n+\n+      /* Signal FALLTHROUGH comment followed by another token.  */\n+      if (comment_start\n+\t  && fallthrough_comment_p (pfile, comment_start))\n+\tresult->flags |= PREV_FALLTHROUGH;\n       break;\n \n     case '\\'':\n@@ -2534,6 +2629,9 @@ _cpp_lex_direct (cpp_reader *pfile)\n \t  goto update_tokens_line;\n \t}\n \n+      if (fallthrough_comment_p (pfile, comment_start))\n+\tresult->flags |= PREV_FALLTHROUGH;\n+\n       /* Save the comment as a token in its own right.  */\n       save_comment (pfile, result, comment_start, c);\n       break;"}, {"sha": "230f764fd6f4d22d66851b7e62fd8463afe05e64", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -1,3 +1,8 @@\n+2016-09-26  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c/7652\n+\t* libsupc++/hash_bytes.cc: Add [[gnu::fallthrough]].\n+\n 2016-09-25  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* src/c++11/debug.cc: Include debug/vector. Include cctype. Remove"}, {"sha": "1042de66388a46cf85bc5f8ec736ad175542d0a3", "filename": "libstdc++-v3/libsupc++/hash_bytes.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fea426da8c4687bb32e6894dc26f00ae211822/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fhash_bytes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fea426da8c4687bb32e6894dc26f00ae211822/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fhash_bytes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fhash_bytes.cc?ref=81fea426da8c4687bb32e6894dc26f00ae211822", "patch": "@@ -95,8 +95,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n       case 3:\n \thash ^= static_cast<unsigned char>(buf[2]) << 16;\n+\t[[gnu::fallthrough]];\n       case 2:\n \thash ^= static_cast<unsigned char>(buf[1]) << 8;\n+\t[[gnu::fallthrough]];\n       case 1:\n \thash ^= static_cast<unsigned char>(buf[0]);\n \thash *= m;"}]}