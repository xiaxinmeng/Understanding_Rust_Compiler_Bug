{"sha": "0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwOWE2YzNjN2Q3YzljMzFkMjUzNTU4YjYwMmMzNWQzYWQ1MWQxYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-23T15:56:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-23T15:56:28Z"}, "message": "ipa-fnsummary.c (record_modified_bb_info): Use sreal frequencies.\n\n\n\t* ipa-fnsummary.c (record_modified_bb_info): Use sreal\n\tfrequencies. Fix estimation of aggregate parameters.\n\n\t* gcc.dg/ipa/inline-1.c: Update template.\n\nFrom-SVN: r255103", "tree": {"sha": "0d77aae211cec736fc4e555b919d750b9b5b2877", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d77aae211cec736fc4e555b919d750b9b5b2877"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/comments", "author": null, "committer": null, "parents": [{"sha": "8f58dbd171388efd96d61408a1de7b99bd95f627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f58dbd171388efd96d61408a1de7b99bd95f627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f58dbd171388efd96d61408a1de7b99bd95f627"}], "stats": {"total": 148, "additions": 57, "deletions": 91}, "files": [{"sha": "56b9473bc5e47cde9f29a3e811cea0629bd5db0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "patch": "@@ -1,3 +1,8 @@\n+2017-11-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (record_modified_bb_info): Use sreal\n+\tfrequencies. Fix estimation of aggregate parameters.\n+\n 2017-11-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraphclones.c (cgraph_node::create_clone): Fix updating of profile"}, {"sha": "c535a9ab7d6bc9f451e4b43ac9971f0866ab7cb0", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 44, "deletions": 87, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "patch": "@@ -129,9 +129,6 @@ static int overall_size;\n static profile_count max_count;\n static profile_count spec_rem;\n \n-/* Pre-computed constant 1/100. */\n-static sreal percent_rec;\n-\n /* Return false when inlining edge E would lead to violating\n    limits on function unit growth or stack usage growth.  \n \n@@ -642,7 +639,7 @@ compute_uninlined_call_time (struct cgraph_edge *edge,\n \t\t\t : edge->caller);\n \n   sreal freq = edge->sreal_frequency ();\n-  if (freq != 0)\n+  if (freq > 0)\n     uninlined_call_time *= freq;\n   else\n     uninlined_call_time = uninlined_call_time >> 11;\n@@ -664,7 +661,7 @@ compute_inlined_call_time (struct cgraph_edge *edge,\n   sreal caller_time = ipa_fn_summaries->get (caller)->time;\n \n   sreal freq = edge->sreal_frequency ();\n-  if (freq != 0)\n+  if (freq > 0)\n     time *= freq;\n   else\n     time = time >> 11;\n@@ -690,9 +687,8 @@ big_speedup_p (struct cgraph_edge *e)\n   sreal time = compute_uninlined_call_time (e, unspec_time);\n   sreal inlined_time = compute_inlined_call_time (e, spec_time);\n \n-  if (time - inlined_time\n-      > (sreal) (time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP))\n-\t * percent_rec)\n+  if (time - inlined_time * 100\n+      > (sreal) (time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)))\n     return true;\n   return false;\n }\n@@ -827,7 +823,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n {\n   char const *reason = NULL;\n   bool want_inline = true;\n-  int caller_freq = CGRAPH_FREQ_BASE;\n+  sreal caller_freq = 1;\n   int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n \n   if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n@@ -838,63 +834,44 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n       reason = \"recursive call is cold\";\n       want_inline = false;\n     }\n-  else if (!outer_node->count.ipa ().nonzero_p ())\n-    {\n-      reason = \"not executed in profile\";\n-      want_inline = false;\n-    }\n   else if (depth > max_depth)\n     {\n       reason = \"--param max-inline-recursive-depth exceeded.\";\n       want_inline = false;\n     }\n-\n-  if (outer_node->global.inlined_to)\n-    caller_freq = outer_node->callers->frequency ();\n-\n-  if (!caller_freq)\n+  else if (outer_node->global.inlined_to\n+\t   && (caller_freq = outer_node->callers->sreal_frequency ()) == 0)\n     {\n-      reason = \"function is inlined and unlikely\";\n+      reason = \"caller frequency is 0\";\n       want_inline = false;\n     }\n \n   if (!want_inline)\n     ;\n-  /* Inlining of self recursive function into copy of itself within other function\n-     is transformation similar to loop peeling.\n+  /* Inlining of self recursive function into copy of itself within other\n+     function is transformation similar to loop peeling.\n \n      Peeling is profitable if we can inline enough copies to make probability\n      of actual call to the self recursive function very small.  Be sure that\n      the probability of recursion is small.\n \n      We ensure that the frequency of recursing is at most 1 - (1/max_depth).\n-     This way the expected number of recision is at most max_depth.  */\n+     This way the expected number of recursion is at most max_depth.  */\n   else if (peeling)\n     {\n-      int max_prob = CGRAPH_FREQ_BASE - ((CGRAPH_FREQ_BASE + max_depth - 1)\n-\t\t\t\t\t / max_depth);\n+      sreal max_prob = (sreal)1 - ((sreal)1 / (sreal)max_depth);\n       int i;\n       for (i = 1; i < depth; i++)\n-\tmax_prob = max_prob * max_prob / CGRAPH_FREQ_BASE;\n-      if (max_count.nonzero_p () && edge->count.ipa ().nonzero_p () \n-\t  && (edge->count.ipa ().to_gcov_type () * CGRAPH_FREQ_BASE\n-\t      / outer_node->count.ipa ().to_gcov_type ()\n-\t      >= max_prob))\n-\t{\n-\t  reason = \"profile of recursive call is too large\";\n-\t  want_inline = false;\n-\t}\n-      if (!max_count.nonzero_p ()\n-\t  && (edge->frequency () * CGRAPH_FREQ_BASE / caller_freq\n-\t      >= max_prob))\n+\tmax_prob = max_prob * max_prob;\n+      if (edge->sreal_frequency () >= max_prob * caller_freq)\n \t{\n \t  reason = \"frequency of recursive call is too large\";\n \t  want_inline = false;\n \t}\n     }\n-  /* Recursive inlining, i.e. equivalent of unrolling, is profitable if recursion\n-     depth is large.  We reduce function call overhead and increase chances that\n-     things fit in hardware return predictor.\n+  /* Recursive inlining, i.e. equivalent of unrolling, is profitable if\n+     recursion depth is large.  We reduce function call overhead and increase\n+     chances that things fit in hardware return predictor.\n \n      Recursive inlining might however increase cost of stack frame setup\n      actually slowing down functions whose recursion tree is wide rather than\n@@ -904,24 +881,15 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n      is tricky.  For now we disable recursive inlining when probability of self\n      recursion is low. \n \n-     Recursive inlining of self recursive call within loop also results in large loop\n-     depths that generally optimize badly.  We may want to throttle down inlining\n-     in those cases.  In particular this seems to happen in one of libstdc++ rb tree\n-     methods.  */\n+     Recursive inlining of self recursive call within loop also results in\n+     large loop depths that generally optimize badly.  We may want to throttle\n+     down inlining in those cases.  In particular this seems to happen in one\n+     of libstdc++ rb tree methods.  */\n   else\n     {\n-      if (max_count.nonzero_p () && edge->count.ipa ().initialized_p ()\n-\t  && (edge->count.ipa ().to_gcov_type () * 100\n-\t      / outer_node->count.ipa ().to_gcov_type ()\n-\t      <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n-\t{\n-\t  reason = \"profile of recursive call is too small\";\n-\t  want_inline = false;\n-\t}\n-      else if ((!max_count.nonzero_p ()\n-\t        || !edge->count.ipa ().initialized_p ())\n-\t       && (edge->frequency () * 100 / caller_freq\n-\t           <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n+      if (edge->sreal_frequency () * 100\n+          <= caller_freq\n+\t     * PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY))\n \t{\n \t  reason = \"frequency of recursive call is too small\";\n \t  want_inline = false;\n@@ -1076,7 +1044,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n       numerator = (compute_uninlined_call_time (edge, unspec_edge_time)\n \t\t   - inlined_time);\n-      if (numerator == 0)\n+      if (numerator <= 0)\n \tnumerator = ((sreal) 1 >> 8);\n       if (caller->count.ipa ().nonzero_p ())\n \tnumerator *= caller->count.ipa ().to_gcov_type ();\n@@ -1106,17 +1074,16 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t  && callee_info->single_caller\n \t  && !edge->caller->global.inlined_to\n \t  /* ... and edges executed only conditionally ... */\n-\t  && edge->frequency () < CGRAPH_FREQ_BASE\n+\t  && edge->sreal_frequency () < 1\n \t  /* ... consider case where callee is not inline but caller is ... */\n \t  && ((!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t       && DECL_DECLARED_INLINE_P (caller->decl))\n \t      /* ... or when early optimizers decided to split and edge\n \t\t frequency still indicates splitting is a win ... */\n \t      || (callee->split_part && !caller->split_part\n-\t\t  && edge->frequency ()\n-\t\t     < CGRAPH_FREQ_BASE\n-\t\t       * PARAM_VALUE\n-\t\t\t  (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100\n+\t\t  && edge->sreal_frequency () * 100\n+\t\t     < PARAM_VALUE\n+\t\t\t  (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY)\n \t\t  /* ... and do not overwrite user specified hints.   */\n \t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n@@ -1151,7 +1118,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t    overall_growth += 256 * 256 - 256;\n \t  denominator *= overall_growth;\n         }\n-      denominator *= inlined_time;\n+      /*denominator *= inlined_time;*/\n \n       badness = - numerator / denominator;\n \n@@ -1169,7 +1136,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   caller->count.ipa ().initialized_p () ? caller->count.ipa ().to_gcov_type () : -1,\n \t\t   compute_uninlined_call_time (edge,\n \t\t\t\t\t\tunspec_edge_time).to_double (),\n-\t\t   compute_inlined_call_time (edge, edge_time).to_double (),\n+\t\t   inlined_time.to_double (),\n \t\t   estimate_growth (callee),\n \t\t   callee_info->growth, overall_growth);\n \t}\n@@ -1425,15 +1392,7 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n     if (e->callee == node\n \t|| (e->callee->ultimate_alias_target (&avail, e->caller) == node\n \t    && avail > AVAIL_INTERPOSABLE))\n-      {\n-\t/* When profile feedback is available, prioritize by expected number\n-\t   of calls.  */\n-        heap->insert (!(max_count > 0) || !e->count.ipa ().initialized_p () ? -e->frequency ()\n-\t\t      : -(e->count.ipa ().to_gcov_type ()\n-\t\t\t/ ((max_count.to_gcov_type () + (1<<24) - 1)\n-\t\t\t   / (1<<24))),\n-\t\t      e);\n-      }\n+      heap->insert (-e->sreal_frequency (), e);\n   for (e = where->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n       lookup_recursive_calls (node, e->callee, heap);\n@@ -2052,12 +2011,9 @@ inline_small_functions (void)\n       update_caller_keys (&edge_heap, where, updated_nodes, NULL);\n       /* Offline copy count has possibly changed, recompute if profile is\n \t available.  */\n-      if (max_count.nonzero_p ())\n-        {\n-\t  struct cgraph_node *n = cgraph_node::get (edge->callee->decl);\n-\t  if (n != edge->callee && n->analyzed)\n-\t    update_callee_keys (&edge_heap, n, updated_nodes);\n-        }\n+      struct cgraph_node *n = cgraph_node::get (edge->callee->decl);\n+      if (n != edge->callee && n->analyzed && n->count.ipa ().initialized_p ())\n+\tupdate_callee_keys (&edge_heap, n, updated_nodes);\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)\n@@ -2277,11 +2233,14 @@ dump_inline_stats (void)\n   int64_t noninlined_virt_cnt = 0, noninlined_virt_indir_cnt = 0;\n   int64_t  inlined_speculative = 0, inlined_speculative_ply = 0;\n   int64_t indirect_poly_cnt = 0, indirect_cnt = 0;\n-  int64_t reason[CIF_N_REASONS][3];\n+  int64_t reason[CIF_N_REASONS][2];\n+  sreal reason_freq[CIF_N_REASONS];\n   int i;\n   struct cgraph_node *node;\n \n   memset (reason, 0, sizeof (reason));\n+  for (i=0; i < CIF_N_REASONS; i++)\n+    reason_freq[i] = 0;\n   FOR_EACH_DEFINED_FUNCTION (node)\n   {\n     struct cgraph_edge *e;\n@@ -2291,8 +2250,8 @@ dump_inline_stats (void)\n \t  {\n \t    if (e->count.ipa ().initialized_p ())\n \t      reason[(int) e->inline_failed][0] += e->count.ipa ().to_gcov_type ();\n-\t    reason[(int) e->inline_failed][1] += e->frequency ();\n-\t    reason[(int) e->inline_failed][2] ++;\n+\t    reason_freq[(int) e->inline_failed] += e->sreal_frequency ();\n+\t    reason[(int) e->inline_failed][1] ++;\n \t    if (DECL_VIRTUAL_P (e->callee->decl)\n \t\t&& e->count.ipa ().initialized_p ())\n \t      {\n@@ -2367,10 +2326,10 @@ dump_inline_stats (void)\n   dump_overall_stats ();\n   fprintf (dump_file, \"\\nWhy inlining failed?\\n\");\n   for (i = 0; i < CIF_N_REASONS; i++)\n-    if (reason[i][2])\n-      fprintf (dump_file, \"%-50s: %8i calls, %8i freq, %\" PRId64\" count\\n\",\n+    if (reason[i][1])\n+      fprintf (dump_file, \"%-50s: %8i calls, %8f freq, %\" PRId64\" count\\n\",\n \t       cgraph_inline_failed_string ((cgraph_inline_failed_t) i),\n-\t       (int) reason[i][2], (int) reason[i][1], reason[i][0]);\n+\t       (int) reason[i][1], reason_freq[i].to_double (), reason[i][0]);\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n@@ -2386,8 +2345,6 @@ ipa_inline (void)\n   int cold;\n   bool remove_functions = false;\n \n-  percent_rec = (sreal) 1 / (sreal) 100;\n-\n   order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n \n   if (dump_file)"}, {"sha": "341f3495114cd8425e7bd019d2fd16639f429aab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "patch": "@@ -1,3 +1,7 @@\n+2017-11-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/ipa/inline-1.c: Update template.\n+\n 2017-11-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/82253"}, {"sha": "e9691e2f96125db1a3baa86d990e154ddbd7e8c8", "filename": "gcc/testsuite/gcc.dg/ipa/inline-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0009a6c3c7d7c9c31d253558b602c35d3ad51d1b/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-1.c?ref=0009a6c3c7d7c9c31d253558b602c35d3ad51d1b", "patch": "@@ -22,13 +22,13 @@ void foo (int invariant, struct bah invariant2)\n /* { dg-final { scan-ipa-dump-not \"op0 change\"  \"inline\"  } } */\n /* { dg-final { scan-ipa-dump \"op1 is compile time invariant\"  \"inline\"  } } */\n /* op2 is invariant within loop (we make assumption that function call does not afect it.). */\n-/* { dg-final { scan-ipa-dump \"op2 change 10.000000. of time\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"op2 change 9.990000. of time\"  \"inline\"  } } */\n /* op3 is invariant within loop (we make assumption that function call does not afect it.). */\n-/* { dg-final { scan-ipa-dump \"op3 change 10.000000. of time\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"op3 change 9.990000. of time\"  \"inline\"  } } */\n /* op4 is invariant within loop.  */\n-/* { dg-final { scan-ipa-dump \"op4 change 10.000000. of time\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"op4 change 9.990000. of time\"  \"inline\"  } } */\n /* op5 is invariant within loop.  */\n-/* { dg-final { scan-ipa-dump \"op5 change 10.000000. of time\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"op5 change 9.990000. of time\"  \"inline\"  } } */\n /* op6 is compile time invariant.  */\n /* { dg-final { scan-ipa-dump \"op6 is compile time invariant\"  \"inline\"  } } */\n /* op7 change.  */"}]}