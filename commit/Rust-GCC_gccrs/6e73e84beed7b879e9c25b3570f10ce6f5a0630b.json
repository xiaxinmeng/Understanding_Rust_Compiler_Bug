{"sha": "6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3M2U4NGJlZWQ3Yjg3OWU5YzI1YjM1NzBmMTBjZTZmNWEwNjMwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-30T15:30:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-30T15:30:22Z"}, "message": "cfgloop.c (scale_loop_profile): Move to...\n\n\n\t* cfgloop.c (scale_loop_profile): Move to...\n\t* cfgloopmanip.c (scale_loop_profile): .. here; use\n\tscale_loop_frequencies.\n\t(loopify): Use RDIV.\n\nFrom-SVN: r191868", "tree": {"sha": "24b888e5a807be55e84069a80be6911f847d0451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24b888e5a807be55e84069a80be6911f847d0451"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/comments", "author": null, "committer": null, "parents": [{"sha": "78b0551a68d1a7e60e549a4852fe78e600ce5320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b0551a68d1a7e60e549a4852fe78e600ce5320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78b0551a68d1a7e60e549a4852fe78e600ce5320"}], "stats": {"total": 237, "additions": 116, "deletions": 121}, "files": [{"sha": "370a076757056ad6ce5917d42da1a0da44f446c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "patch": "@@ -1,3 +1,10 @@\n+2012-09-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfgloop.c (scale_loop_profile): Move to...\n+\t* cfgloopmanip.c (scale_loop_profile): .. here; use\n+\tscale_loop_frequencies.\n+\t(loopify): Use RDIV.\n+\n 2012-09-28  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-call-cdce.c (shrink_wrap_one_built_in_call): Update profile."}, {"sha": "44df99b8f33092509fec37aebb13b22f4239ef46", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "patch": "@@ -1666,121 +1666,3 @@ loop_exits_from_bb_p (struct loop *loop, basic_block bb)\n \n   return false;\n }\n-\n-/* Scale the profile estiamte within loop by SCALE.\n-   If ITERATION_BOUND is non-zero, scale even further if loop is predicted\n-   to iterate too many times.  */\n-void\n-scale_loop_profile (struct loop *loop, int scale, int iteration_bound)\n-{\n-  gcov_type iterations = expected_loop_iterations_unbounded (loop);\n-  basic_block *bbs;\n-  unsigned int i;\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \";; Scaling loop %i with scale %f, \"\n-\t     \"bounding iterations to %i from guessed %i\\n\",\n-\t     loop->num, (double)scale / REG_BR_PROB_BASE,\n-\t     iteration_bound, (int)iterations);\n-\n-  /* See if loop is predicted to iterate too many times.  */\n-  if (iteration_bound && iterations > 0\n-      && RDIV (iterations * scale, REG_BR_PROB_BASE) > iteration_bound)\n-    {\n-      /* Fixing loop profile for different trip count is not trivial; the exit\n-\t probabilities has to be updated to match and frequencies propagated down\n-\t to the loop body.\n-\n-\t We fully update only the simple case of loop with single exit that is\n-\t either from the latch or BB just before latch and leads from BB with\n-\t simple conditional jump.   This is OK for use in vectorizer.  */\n-      e = single_exit (loop);\n-      if (e)\n-\t{\n-\t  edge other_e;\n-\t  int freq_delta;\n-\t  gcov_type count_delta;\n-\n-          FOR_EACH_EDGE (other_e, ei, e->src->succs)\n-\t    if (!(other_e->flags & (EDGE_ABNORMAL | EDGE_FAKE))\n-\t\t&& e != other_e)\n-\t      break;\n-\n-\t  /* Probability of exit must be 1/iterations.  */\n-\t  freq_delta = EDGE_FREQUENCY (e);\n-\t  e->probability = REG_BR_PROB_BASE / iteration_bound;\n-\t  other_e->probability = inverse_probability (e->probability);\n-\t  freq_delta -= EDGE_FREQUENCY (e);\n-\n-\t  /* Adjust counts accordingly.  */\n-\t  count_delta = e->count;\n-\t  e->count = apply_probability (e->src->count, e->probability);\n-\t  other_e->count = apply_probability (e->src->count, other_e->probability);\n-\t  count_delta -= e->count;\n-\n-\t  /* If latch exists, change its frequency and count, since we changed\n-\t     probability of exit.  Theoretically we should update everything from\n-\t     source of exit edge to latch, but for vectorizer this is enough.  */\n-\t  if (loop->latch\n-\t      && loop->latch != e->src)\n-\t    {\n-\t      loop->latch->frequency += freq_delta;\n-\t      if (loop->latch->frequency < 0)\n-\t\tloop->latch->frequency = 0;\n-\t      loop->latch->count += count_delta;\n-\t      if (loop->latch->count < 0)\n-\t\tloop->latch->count = 0;\n-\t    }\n-\t}\n-\n-      /* Roughly speaking we want to reduce the loop body profile by the\n-\t the difference of loop iterations.  We however can do better if\n-\t we look at the actual profile, if it is available.  */\n-      scale = RDIV (iteration_bound * scale, iterations);\n-      if (loop->header->count)\n-\t{\n-\t  gcov_type count_in = 0;\n-\n-\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\t    if (e->src != loop->latch)\n-\t      count_in += e->count;\n-\n-\t  if (count_in != 0)\n-\t    scale = RDIV (count_in * iteration_bound * REG_BR_PROB_BASE, loop->header->count);\n-\t}\n-      else if (loop->header->frequency)\n-\t{\n-\t  int freq_in = 0;\n-\n-\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n-\t    if (e->src != loop->latch)\n-\t      freq_in += EDGE_FREQUENCY (e);\n-\n-\t  if (freq_in != 0)\n-\t    scale = RDIV (freq_in * iteration_bound * REG_BR_PROB_BASE, loop->header->frequency);\n-\t}\n-      if (!scale)\n-\tscale = 1;\n-    }\n-\n-  if (scale == REG_BR_PROB_BASE)\n-    return;\n-\n-  /* Scale the actual probabilities.  */\n-  bbs = get_loop_body (loop);\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block bb = bbs[i];\n-\n-      bb->count = RDIV (bb->count * scale, REG_BR_PROB_BASE);\n-      bb->frequency = RDIV (bb->frequency * scale, REG_BR_PROB_BASE);\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\te->count = RDIV (e->count * scale, REG_BR_PROB_BASE);\n-    }\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \";; guessed iterations are now %i\\n\",\n-\t     (int)expected_loop_iterations_unbounded (loop));\n-  free (bbs);\n-}"}, {"sha": "8a44a0b6f933f0badb95311f6d42a5fe5fae65b2", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 109, "deletions": 3, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e73e84beed7b879e9c25b3570f10ce6f5a0630b/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=6e73e84beed7b879e9c25b3570f10ce6f5a0630b", "patch": "@@ -39,8 +39,6 @@ static bool fix_bb_placement (basic_block);\n static void fix_bb_placements (basic_block, bool *);\n static void unloop (struct loop *, bool *);\n \n-#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n-\n /* Checks whether basic block BB is dominated by DATA.  */\n static bool\n rpe_enum_p (const_basic_block bb, const void *data)\n@@ -462,6 +460,7 @@ add_loop (struct loop *loop, struct loop *outer)\n }\n \n /* Multiply all frequencies in LOOP by NUM/DEN.  */\n+\n void\n scale_loop_frequencies (struct loop *loop, int num, int den)\n {\n@@ -472,6 +471,113 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n   free (bbs);\n }\n \n+/* Multiply all frequencies in LOOP by SCALE/REG_BR_PROB_BASE.\n+   If ITERATION_BOUND is non-zero, scale even further if loop is predicted\n+   to iterate too many times.  */\n+\n+void\n+scale_loop_profile (struct loop *loop, int scale, int iteration_bound)\n+{\n+  gcov_type iterations = expected_loop_iterations_unbounded (loop);\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \";; Scaling loop %i with scale %f, \"\n+\t     \"bounding iterations to %i from guessed %i\\n\",\n+\t     loop->num, (double)scale / REG_BR_PROB_BASE,\n+\t     iteration_bound, (int)iterations);\n+\n+  /* See if loop is predicted to iterate too many times.  */\n+  if (iteration_bound && iterations > 0\n+      && RDIV (iterations * scale, REG_BR_PROB_BASE) > iteration_bound)\n+    {\n+      /* Fixing loop profile for different trip count is not trivial; the exit\n+\t probabilities has to be updated to match and frequencies propagated down\n+\t to the loop body.\n+\n+\t We fully update only the simple case of loop with single exit that is\n+\t either from the latch or BB just before latch and leads from BB with\n+\t simple conditional jump.   This is OK for use in vectorizer.  */\n+      e = single_exit (loop);\n+      if (e)\n+\t{\n+\t  edge other_e;\n+\t  int freq_delta;\n+\t  gcov_type count_delta;\n+\n+          FOR_EACH_EDGE (other_e, ei, e->src->succs)\n+\t    if (!(other_e->flags & (EDGE_ABNORMAL | EDGE_FAKE))\n+\t\t&& e != other_e)\n+\t      break;\n+\n+\t  /* Probability of exit must be 1/iterations.  */\n+\t  freq_delta = EDGE_FREQUENCY (e);\n+\t  e->probability = REG_BR_PROB_BASE / iteration_bound;\n+\t  other_e->probability = inverse_probability (e->probability);\n+\t  freq_delta -= EDGE_FREQUENCY (e);\n+\n+\t  /* Adjust counts accordingly.  */\n+\t  count_delta = e->count;\n+\t  e->count = apply_probability (e->src->count, e->probability);\n+\t  other_e->count = apply_probability (e->src->count, other_e->probability);\n+\t  count_delta -= e->count;\n+\n+\t  /* If latch exists, change its frequency and count, since we changed\n+\t     probability of exit.  Theoretically we should update everything from\n+\t     source of exit edge to latch, but for vectorizer this is enough.  */\n+\t  if (loop->latch\n+\t      && loop->latch != e->src)\n+\t    {\n+\t      loop->latch->frequency += freq_delta;\n+\t      if (loop->latch->frequency < 0)\n+\t\tloop->latch->frequency = 0;\n+\t      loop->latch->count += count_delta;\n+\t      if (loop->latch->count < 0)\n+\t\tloop->latch->count = 0;\n+\t    }\n+\t}\n+\n+      /* Roughly speaking we want to reduce the loop body profile by the\n+\t the difference of loop iterations.  We however can do better if\n+\t we look at the actual profile, if it is available.  */\n+      scale = RDIV (iteration_bound * scale, iterations);\n+      if (loop->header->count)\n+\t{\n+\t  gcov_type count_in = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+\t    if (e->src != loop->latch)\n+\t      count_in += e->count;\n+\n+\t  if (count_in != 0)\n+\t    scale = RDIV (count_in * iteration_bound * REG_BR_PROB_BASE, loop->header->count);\n+\t}\n+      else if (loop->header->frequency)\n+\t{\n+\t  int freq_in = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+\t    if (e->src != loop->latch)\n+\t      freq_in += EDGE_FREQUENCY (e);\n+\n+\t  if (freq_in != 0)\n+\t    scale = RDIV (freq_in * iteration_bound * REG_BR_PROB_BASE, loop->header->frequency);\n+\t}\n+      if (!scale)\n+\tscale = 1;\n+    }\n+\n+  if (scale == REG_BR_PROB_BASE)\n+    return;\n+\n+  /* Scale the actual probabilities.  */\n+  scale_loop_frequencies (loop, scale, REG_BR_PROB_BASE);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \";; guessed iterations are now %i\\n\",\n+\t     (int)expected_loop_iterations_unbounded (loop));\n+}\n+\n /* Recompute dominance information for basic blocks outside LOOP.  */\n \n static void\n@@ -772,7 +878,7 @@ loopify (edge latch_edge, edge header_edge,\n       switch_bb->count = cnt;\n       FOR_EACH_EDGE (e, ei, switch_bb->succs)\n \t{\n-\t  e->count = (switch_bb->count * e->probability) / REG_BR_PROB_BASE;\n+\t  e->count = RDIV (switch_bb->count * e->probability, REG_BR_PROB_BASE);\n \t}\n     }\n   scale_loop_frequencies (loop, false_scale, REG_BR_PROB_BASE);"}]}