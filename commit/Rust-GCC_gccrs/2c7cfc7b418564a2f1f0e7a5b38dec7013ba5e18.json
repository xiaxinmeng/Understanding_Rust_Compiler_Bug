{"sha": "2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "node_id": "C_kwDOANBUbNoAKDJjN2NmYzdiNDE4NTY0YTJmMWYwZTdhNWIzOGRlYzcwMTNiYTVlMTg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-18T09:09:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-18T09:09:48Z"}, "message": "ubsan: Add -fsanitize-trap= support\n\nOn Thu, Jun 16, 2022 at 09:32:02PM +0100, Jonathan Wakely wrote:\n> It looks like clang has addressed this deficiency now:\n>\n> https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html#usage\n\nThanks, that is roughly what I'd implement anyway and apparently they have\nit already since 2015, we've added the -fsanitize-undefined-trap-on-error\nsupport back in 2014 and didn't change it since then.\n\nAs a small divergence from clang, I chose -fsanitize-undefined-trap-on-error\nto be a (deprecated) alias for -fsanitize-trap aka -fsanitize-trap=all\nrather thn -fsanitize-trap=undefined which seems to be what clang does,\nbecause for a deprecated option it is IMHO more important backwards\ncompatibility with what gcc did over the past 8 years rather than clang\ncompatibility.\nSome sanitizers (e.g. asan, lsan, tsan) don't support traps,\n-fsanitize-trap=address etc. will be rejected (if enabled at the end of\ncommand line), -fno-sanitize-trap= can be specified even for them.\nThis is similar behavior to -fsanitize-recover=.\nOne complication is vptr sanitization, which can't easily trap,\nas the whole slow path of the checking is inside of libubsan.\nPreviously, -fsanitize=vptr -fsanitize-undefined-trap-on-error\nsilently ignored vptr sanitization.\nThis patch similarly to what clang does will accept\n-fsanitize-trap=all or -fsanitize-trap=undefined which enable\nthe vptr bit as trapping and again that causes silent disabling\nof vptr sanitization, while -fsanitize-trap=vptr is rejected\n(already during option processing).\n\n2022-06-18  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* common.opt (flag_sanitize_trap): New variable.\n\t(fsanitize-trap=, fsanitize-trap): New options.\n\t(fsanitize-undefined-trap-on-error): Change into deprecated alias\n\tfor -fsanitize-trap=all.\n\t* opts.h (struct sanitizer_opts_s): Add can_trap member.\n\t* opts.cc (finish_options): Complain about unsupported\n\t-fsanitize-trap= options.\n\t(sanitizer_opts): Add can_trap values to all entries.\n\t(get_closest_sanitizer_option): Ignore -fsanitize-trap=\n\toptions which have can_trap false.\n\t(parse_sanitizer_options): Add support for -fsanitize-trap=.\n\tFor -fsanitize-trap=all, enable\n\tSANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT.  Disallow\n\t-fsanitize-trap=vptr here.\n\t(common_handle_option): Handle OPT_fsanitize_trap_ and\n\tOPT_fsanitize_trap.\n\t* sanopt.cc (maybe_optimize_ubsan_null_ifn): Check\n\tflag_sanitize_trap & SANITIZE_{NULL,ALIGNMENT} instead of\n\tflag_sanitize_undefined_trap_on_error.\n\t* gcc.cc (sanitize_spec_function): Use\n\tflag_sanitize & ~flag_sanitize_trap instead of flag_sanitize\n\tand drop use of flag_sanitize_undefined_trap_on_error in\n\t\"undefined\" handling.\n\t* ubsan.cc (ubsan_instrument_unreachable): Use\n\tflag_sanitize_trap & SANITIZE_??? instead of\n\tflag_sanitize_undefined_trap_on_error.\n\t(ubsan_expand_bounds_ifn, ubsan_expand_null_ifn,\n\tubsan_expand_objsize_ifn, ubsan_expand_ptr_ifn,\n\tubsan_build_overflow_builtin, instrument_bool_enum_load,\n\tubsan_instrument_float_cast, instrument_nonnull_arg,\n\tinstrument_nonnull_return, instrument_builtin): Likewise.\n\t* doc/invoke.texi (-fsanitize-trap=, -fsanitize-trap): Document.\n\t(-fsanitize-undefined-trap-on-error): Document as deprecated\n\talias of -fsanitize-trap.\ngcc/c-family/\n\t* c-ubsan.cc (ubsan_instrument_division, ubsan_instrument_shift):\n\tUse flag_sanitize_trap & SANITIZE_??? instead of\n\tflag_sanitize_undefined_trap_on_error.  If 2 sanitizers are involved\n\tand flag_sanitize_trap differs for them, emit __builtin_trap only\n\tfor the comparison where trap is requested.\n\t(ubsan_instrument_vla, ubsan_instrument_return): Use\n\tlag_sanitize_trap & SANITIZE_??? instead of\n\tflag_sanitize_undefined_trap_on_error.\ngcc/cp/\n\t* cp-ubsan.cc (cp_ubsan_instrument_vptr_p): Use\n\tflag_sanitize_trap & SANITIZE_VPTR instead of\n\tflag_sanitize_undefined_trap_on_error.\ngcc/testsuite/\n\t* c-c++-common/ubsan/nonnull-4.c: Use -fsanitize-trap=all\n\tinstead of -fsanitize-undefined-trap-on-error.\n\t* c-c++-common/ubsan/div-by-zero-4.c: Use\n\t-fsanitize-trap=signed-integer-overflow instead of\n\t-fsanitize-undefined-trap-on-error.\n\t* c-c++-common/ubsan/overflow-add-4.c: Use -fsanitize-trap=undefined\n\tinstead of -fsanitize-undefined-trap-on-error.\n\t* c-c++-common/ubsan/pr56956.c: Likewise.\n\t* c-c++-common/ubsan/pr68142.c: Likewise.\n\t* c-c++-common/ubsan/pr80932.c: Use\n\t-fno-sanitize-trap=all -fsanitize-trap=shift,undefined\n\tinstead of -fsanitize-undefined-trap-on-error.\n\t* c-c++-common/ubsan/align-8.c: Use -fsanitize-trap=alignment\n\tinstead of -fsanitize-undefined-trap-on-error.", "tree": {"sha": "b9fab7e419fe1d603782f3010a4b3cee040c9e37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9fab7e419fe1d603782f3010a4b3cee040c9e37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef662120177d39af5f88ffc622d90bb6ae0ca1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef662120177d39af5f88ffc622d90bb6ae0ca1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef662120177d39af5f88ffc622d90bb6ae0ca1d3"}], "stats": {"total": 335, "additions": 226, "deletions": 109}, "files": [{"sha": "360ba82250ccdc2084a10077831b57337d537358", "filename": "gcc/c-family/c-ubsan.cc", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fc-family%2Fc-ubsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fc-family%2Fc-ubsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.cc?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -83,8 +83,9 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)\n \t  x = NULL_TREE;\n \t  flag = SANITIZE_SI_OVERFLOW;\n \t}\n-      else if (flag_sanitize_undefined_trap_on_error\n-\t       || (((flag_sanitize_recover & SANITIZE_DIVIDE) == 0)\n+      else if ((((flag_sanitize_trap & SANITIZE_DIVIDE) == 0)\n+\t\t== ((flag_sanitize_trap & SANITIZE_SI_OVERFLOW) == 0))\n+\t       && (((flag_sanitize_recover & SANITIZE_DIVIDE) == 0)\n \t\t   == ((flag_sanitize_recover & SANITIZE_SI_OVERFLOW) == 0)))\n \t{\n \t  t = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, t, x);\n@@ -105,33 +106,49 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)\n      make sure it gets evaluated before the condition.  */\n   t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), unshare_expr (op0), t);\n   t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), unshare_expr (op1), t);\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if ((flag_sanitize_trap & flag) && x == NULL_TREE)\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n       tree data = ubsan_create_data (\"__ubsan_overflow_data\", 1, &loc,\n \t\t\t\t     ubsan_type_descriptor (type), NULL_TREE,\n \t\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n-      enum built_in_function bcode\n-\t= (flag_sanitize_recover & flag)\n-\t  ? BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW\n-\t  : BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW_ABORT;\n-      tt = builtin_decl_explicit (bcode);\n-      op0 = unshare_expr (op0);\n-      op1 = unshare_expr (op1);\n-      tt = build_call_expr_loc (loc, tt, 3, data, ubsan_encode_value (op0),\n-\t\t\t\tubsan_encode_value (op1));\n-      if (x)\n+      if (flag_sanitize_trap & flag)\n+\ttt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP),\n+\t\t\t\t  0);\n+      else\n \t{\n-\t  bcode = (flag_sanitize_recover & SANITIZE_SI_OVERFLOW)\n-\t\t  ? BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW\n-\t\t  : BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW_ABORT;\n-\t  tree xt = builtin_decl_explicit (bcode);\n+\t  enum built_in_function bcode\n+\t    = (flag_sanitize_recover & flag)\n+\t      ? BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW\n+\t      : BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW_ABORT;\n+\t  tt = builtin_decl_explicit (bcode);\n \t  op0 = unshare_expr (op0);\n \t  op1 = unshare_expr (op1);\n-\t  xt = build_call_expr_loc (loc, xt, 3, data, ubsan_encode_value (op0),\n+\t  tt = build_call_expr_loc (loc, tt, 3, data, ubsan_encode_value (op0),\n \t\t\t\t    ubsan_encode_value (op1));\n+\t}\n+      if (x)\n+\t{\n+\t  tree xt;\n+\t  if (flag_sanitize_trap & SANITIZE_SI_OVERFLOW)\n+\t    xt = build_call_expr_loc (loc,\n+\t\t\t\t      builtin_decl_explicit (BUILT_IN_TRAP),\n+\t\t\t\t      0);\n+\t  else\n+\t    {\n+\t      enum built_in_function bcode\n+\t\t= (flag_sanitize_recover & SANITIZE_SI_OVERFLOW)\n+\t\t   ? BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW\n+\t\t   : BUILT_IN_UBSAN_HANDLE_DIVREM_OVERFLOW_ABORT;\n+\t      xt = builtin_decl_explicit (bcode);\n+\t      op0 = unshare_expr (op0);\n+\t      op1 = unshare_expr (op1);\n+\t      xt = build_call_expr_loc (loc, xt, 3, data,\n+\t\t\t\t\tubsan_encode_value (op0),\n+\t\t\t\t\tubsan_encode_value (op1));\n+\t    }\n \t  x = fold_build3 (COND_EXPR, void_type_node, x, xt, void_node);\n \t}\n     }\n@@ -225,16 +242,17 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,\n \t}\n       else\n \t{\n-\t  if (flag_sanitize_undefined_trap_on_error\n-\t      || ((!(flag_sanitize_recover & SANITIZE_SHIFT_EXPONENT))\n+\t  if (((!(flag_sanitize_trap & SANITIZE_SHIFT_EXPONENT))\n+\t       == (!(flag_sanitize_trap & SANITIZE_SHIFT_BASE)))\n+\t      && ((!(flag_sanitize_recover & SANITIZE_SHIFT_EXPONENT))\n \t\t  == (!(flag_sanitize_recover & SANITIZE_SHIFT_BASE))))\n \t    t = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, t, tt);\n \t  else\n \t    else_t = tt;\n \t}\n     }\n \n-  if (flag_sanitize_undefined_trap_on_error)\n+  if ((flag_sanitize_trap & recover_kind) && else_t == void_node)\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -244,26 +262,40 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,\n \t\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n \n-      enum built_in_function bcode\n-\t= (flag_sanitize_recover & recover_kind)\n-\t  ? BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS\n-\t  : BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS_ABORT;\n-      tt = builtin_decl_explicit (bcode);\n-      op0 = unshare_expr (op0);\n-      op1 = unshare_expr (op1);\n-      tt = build_call_expr_loc (loc, tt, 3, data, ubsan_encode_value (op0),\n-\t\t\t\tubsan_encode_value (op1));\n+      if (flag_sanitize_trap & recover_kind)\n+\ttt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+      else\n+\t{\n+\t  enum built_in_function bcode\n+\t    = (flag_sanitize_recover & recover_kind)\n+\t      ? BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS\n+\t      : BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS_ABORT;\n+\t  tt = builtin_decl_explicit (bcode);\n+\t  op0 = unshare_expr (op0);\n+\t  op1 = unshare_expr (op1);\n+\t  tt = build_call_expr_loc (loc, tt, 3, data, ubsan_encode_value (op0),\n+\t\t\t\t    ubsan_encode_value (op1));\n+\t}\n       if (else_t != void_node)\n \t{\n-\t  bcode = (flag_sanitize_recover & SANITIZE_SHIFT_BASE)\n+\t  tree else_tt;\n+\t  if (flag_sanitize_trap & SANITIZE_SHIFT_BASE)\n+\t    else_tt\n+\t      = build_call_expr_loc (loc,\n+\t\t\t\t     builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+\t  else\n+\t    {\n+\t      enum built_in_function bcode\n+\t\t= (flag_sanitize_recover & SANITIZE_SHIFT_BASE)\n \t\t  ? BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS\n \t\t  : BUILT_IN_UBSAN_HANDLE_SHIFT_OUT_OF_BOUNDS_ABORT;\n-\t  tree else_tt = builtin_decl_explicit (bcode);\n-\t  op0 = unshare_expr (op0);\n-\t  op1 = unshare_expr (op1);\n-\t  else_tt = build_call_expr_loc (loc, else_tt, 3, data,\n-\t\t\t\t\t ubsan_encode_value (op0),\n-\t\t\t\t\t ubsan_encode_value (op1));\n+\t      else_tt = builtin_decl_explicit (bcode);\n+\t      op0 = unshare_expr (op0);\n+\t      op1 = unshare_expr (op1);\n+\t      else_tt = build_call_expr_loc (loc, else_tt, 3, data,\n+\t\t\t\t\t     ubsan_encode_value (op0),\n+\t\t\t\t\t     ubsan_encode_value (op1));\n+\t    }\n \t  else_t = fold_build3 (COND_EXPR, void_type_node, else_t,\n \t\t\t\telse_tt, void_node);\n \t}\n@@ -282,7 +314,7 @@ ubsan_instrument_vla (location_t loc, tree size)\n   tree t, tt;\n \n   t = fold_build2 (LE_EXPR, boolean_type_node, size, build_int_cst (type, 0));\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & SANITIZE_VLA)\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -307,10 +339,10 @@ ubsan_instrument_vla (location_t loc, tree size)\n tree\n ubsan_instrument_return (location_t loc)\n {\n-  if (flag_sanitize_undefined_trap_on_error)\n-    return build_call_expr_loc\n-      /* pass_warn_function_return checks for BUILTINS_LOCATION.  */\n-      (BUILTINS_LOCATION, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  if (flag_sanitize_trap & SANITIZE_RETURN)\n+    /* pass_warn_function_return checks for BUILTINS_LOCATION.  */\n+    return build_call_expr_loc (BUILTINS_LOCATION,\n+\t\t\t\tbuiltin_decl_explicit (BUILT_IN_TRAP), 0);\n \n   tree data = ubsan_create_data (\"__ubsan_missing_return_data\", 1, &loc,\n \t\t\t\t NULL_TREE, NULL_TREE);"}, {"sha": "32917aafcaec1b49ddc3e45924e9da4820d04169", "filename": "gcc/common.opt", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -223,6 +223,10 @@ unsigned int flag_sanitize\n Variable\n unsigned int flag_sanitize_recover = (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT | SANITIZE_KERNEL_ADDRESS | SANITIZE_KERNEL_HWADDRESS) & ~(SANITIZE_UNREACHABLE | SANITIZE_RETURN)\n \n+; What sanitizers should use __builtin_trap () instead of runtime diagnostics\n+Variable\n+unsigned int flag_sanitize_trap\n+\n ; Flag whether a prefix has been added to dump_base_name\n Variable\n bool dump_base_name_prefixed = false\n@@ -1105,12 +1109,19 @@ fsanitize-recover\n Common\n This switch is deprecated; use -fsanitize-recover= instead.\n \n+fsanitize-trap=\n+Common Driver Joined\n+Use traps instead of diagnostics of undefined behavior sanitizers.\n+\n+fsanitize-trap\n+Common Driver\n+\n fsanitize-address-use-after-scope\n Common Driver Var(flag_sanitize_address_use_after_scope) Init(0)\n \n fsanitize-undefined-trap-on-error\n-Common Driver Var(flag_sanitize_undefined_trap_on_error) Init(0)\n-Use trap instead of a library function for undefined behavior sanitization.\n+Common Driver Alias(fsanitize-trap)\n+This switch is deprecated; use -fsanitize-trap= instead.\n \n fasynchronous-unwind-tables\n Common Var(flag_asynchronous_unwind_tables) Optimization"}, {"sha": "edad2bd68db08e58a34b2d6053799099b94e62d9", "filename": "gcc/cp/cp-ubsan.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fcp%2Fcp-ubsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fcp%2Fcp-ubsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-ubsan.cc?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -32,7 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n static bool\n cp_ubsan_instrument_vptr_p (tree type)\n {\n-  if (!flag_rtti || flag_sanitize_undefined_trap_on_error)\n+  if (!flag_rtti || (flag_sanitize_trap & SANITIZE_VPTR))\n     return false;\n \n   if (!sanitize_flags_p (SANITIZE_VPTR))"}, {"sha": "50f57877477bcd6caf23696b50e958079b9af199", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -609,6 +609,7 @@ Objective-C and Objective-C++ Dialects}.\n -fprofile-exclude-files=@var{regex} @gol\n -fprofile-reproducible=@r{[}multithreaded@r{|}parallel-runs@r{|}serial@r{]} @gol\n -fsanitize=@var{style}  -fsanitize-recover  -fsanitize-recover=@var{style} @gol\n+-fsanitize-trap   -fsanitize-trap=@var{style}  @gol\n -fasan-shadow-offset=@var{number}  -fsanitize-sections=@var{s1},@var{s2},... @gol\n -fsanitize-undefined-trap-on-error  -fbounds-check @gol\n -fcf-protection=@r{[}full@r{|}branch@r{|}return@r{|}none@r{|}check@r{]} @gol\n@@ -16116,13 +16117,37 @@ undefined,float-cast-overflow,float-divide-by-zero,bounds-strict\n Enable sanitization of local variables to detect use-after-scope bugs.\n The option sets @option{-fstack-reuse} to @samp{none}.\n \n+@item -fsanitize-trap@r{[}=@var{opts}@r{]}\n+@opindex fsanitize-trap\n+@opindex fno-sanitize-trap\n+The @option{-fsanitize-trap=} option instructs the compiler to\n+report for sanitizers mentioned in comma-separated list of @var{opts}\n+undefined behavior using @code{__builtin_trap} rather than a @code{libubsan}\n+library routine.  If this option is enabled for certain sanitizer,\n+it takes precedence over the @option{-fsanitizer-recover=} for that\n+sanitizer, @code{__builtin_trap} will be emitted and be fatal regardless\n+of whether recovery is enabled or disabled using @option{-fsanitize-recover=}.\n+\n+The advantage of this is that the @code{libubsan} library is not needed\n+and is not linked in, so this is usable even in freestanding environments.\n+\n+Currently this feature works with @option{-fsanitize=undefined} (and its suboptions\n+except for @option{-fsanitize=vptr}), @option{-fsanitize=float-cast-overflow},\n+@option{-fsanitize=float-divide-by-zero} and\n+@option{-fsanitize=bounds-strict}.  @code{-fsanitize-trap=all} can be also\n+specified, which enables it for @code{undefined} suboptions,\n+@option{-fsanitize=float-cast-overflow},\n+@option{-fsanitize=float-divide-by-zero} and\n+@option{-fsanitize=bounds-strict}.\n+If @code{-fsanitize-trap=undefined} or @code{-fsanitize-trap=all} is used\n+and @code{-fsanitize=vptr} is enabled on the command line, the\n+instrumentation is silently ignored as the instrumentation always needs\n+@code{libubsan} support, @option{-fsanitize-trap=vptr} is not allowed.\n+\n @item -fsanitize-undefined-trap-on-error\n @opindex fsanitize-undefined-trap-on-error\n-The @option{-fsanitize-undefined-trap-on-error} option instructs the compiler to\n-report undefined behavior using @code{__builtin_trap} rather than\n-a @code{libubsan} library routine.  The advantage of this is that the\n-@code{libubsan} library is not needed and is not linked in, so this\n-is usable even in freestanding environments.\n+The @option{-fsanitize-undefined-trap-on-error} option is deprecated\n+equivalent of @option{-fsanitize-trap=all}.\n \n @item -fsanitize-coverage=trace-pc\n @opindex fsanitize-coverage=trace-pc"}, {"sha": "5cbb38560b2663014af6cf8026d2b647487c75d1", "filename": "gcc/gcc.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fgcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fgcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.cc?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -10313,8 +10313,9 @@ sanitize_spec_function (int argc, const char **argv)\n     return (flag_sanitize & SANITIZE_THREAD) ? \"\" : NULL;\n   if (strcmp (argv[0], \"undefined\") == 0)\n     return ((flag_sanitize\n-\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT))\n-\t    && !flag_sanitize_undefined_trap_on_error) ? \"\" : NULL;\n+\t     & ~flag_sanitize_trap\n+\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT)))\n+\t   ? \"\" : NULL;\n   if (strcmp (argv[0], \"leak\") == 0)\n     return ((flag_sanitize\n \t     & (SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD))"}, {"sha": "959d48d173f120acabd1e8607b7cd23c8c6c390a", "filename": "gcc/opts.cc", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.cc?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1232,6 +1232,18 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n       error_at (loc, \"%<-fsanitize-recover=%s%> is not supported\",\n \t\tsanitizer_opts[i].name);\n \n+  /* Check -fsanitize-trap option.  */\n+  for (int i = 0; sanitizer_opts[i].name != NULL; ++i)\n+    if ((opts->x_flag_sanitize_trap & sanitizer_opts[i].flag)\n+\t&& !sanitizer_opts[i].can_trap\n+\t/* Allow -fsanitize-trap=all or -fsanitize-trap=undefined\n+\t   to set flag_sanitize_trap & SANITIZE_VPTR bit which will\n+\t   effectively disable -fsanitize=vptr, just disallow\n+\t   explicit -fsanitize-trap=vptr.  */\n+\t&& sanitizer_opts[i].flag != SANITIZE_VPTR)\n+      error_at (loc, \"%<-fsanitize-trap=%s%> is not supported\",\n+\t\tsanitizer_opts[i].name);\n+\n   /* When instrumenting the pointers, we don't want to remove\n      the null pointer checks.  */\n   if (opts->x_flag_sanitize & (SANITIZE_NULL | SANITIZE_NONNULL_ATTRIBUTE\n@@ -2020,48 +2032,50 @@ enable_fdo_optimizations (struct gcc_options *opts,\n /* -f{,no-}sanitize{,-recover}= suboptions.  */\n const struct sanitizer_opts_s sanitizer_opts[] =\n {\n-#define SANITIZER_OPT(name, flags, recover) \\\n-    { #name, flags, sizeof #name - 1, recover }\n-  SANITIZER_OPT (address, (SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS), true),\n+#define SANITIZER_OPT(name, flags, recover, trap) \\\n+    { #name, flags, sizeof #name - 1, recover, trap }\n+  SANITIZER_OPT (address, (SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS), true,\n+\t\t false),\n   SANITIZER_OPT (hwaddress, (SANITIZE_HWADDRESS | SANITIZE_USER_HWADDRESS),\n-\t\t true),\n+\t\t true, false),\n   SANITIZER_OPT (kernel-address, (SANITIZE_ADDRESS | SANITIZE_KERNEL_ADDRESS),\n-\t\t true),\n+\t\t true, false),\n   SANITIZER_OPT (kernel-hwaddress,\n \t\t (SANITIZE_HWADDRESS | SANITIZE_KERNEL_HWADDRESS),\n+\t\t true, false),\n+  SANITIZER_OPT (pointer-compare, SANITIZE_POINTER_COMPARE, true, false),\n+  SANITIZER_OPT (pointer-subtract, SANITIZE_POINTER_SUBTRACT, true, false),\n+  SANITIZER_OPT (thread, SANITIZE_THREAD, false, false),\n+  SANITIZER_OPT (leak, SANITIZE_LEAK, false, false),\n+  SANITIZER_OPT (shift, SANITIZE_SHIFT, true, true),\n+  SANITIZER_OPT (shift-base, SANITIZE_SHIFT_BASE, true, true),\n+  SANITIZER_OPT (shift-exponent, SANITIZE_SHIFT_EXPONENT, true, true),\n+  SANITIZER_OPT (integer-divide-by-zero, SANITIZE_DIVIDE, true, true),\n+  SANITIZER_OPT (undefined, SANITIZE_UNDEFINED, true, true),\n+  SANITIZER_OPT (unreachable, SANITIZE_UNREACHABLE, false, true),\n+  SANITIZER_OPT (vla-bound, SANITIZE_VLA, true, true),\n+  SANITIZER_OPT (return, SANITIZE_RETURN, false, true),\n+  SANITIZER_OPT (null, SANITIZE_NULL, true, true),\n+  SANITIZER_OPT (signed-integer-overflow, SANITIZE_SI_OVERFLOW, true, true),\n+  SANITIZER_OPT (bool, SANITIZE_BOOL, true, true),\n+  SANITIZER_OPT (enum, SANITIZE_ENUM, true, true),\n+  SANITIZER_OPT (float-divide-by-zero, SANITIZE_FLOAT_DIVIDE, true, true),\n+  SANITIZER_OPT (float-cast-overflow, SANITIZE_FLOAT_CAST, true, true),\n+  SANITIZER_OPT (bounds, SANITIZE_BOUNDS, true, true),\n+  SANITIZER_OPT (bounds-strict, SANITIZE_BOUNDS | SANITIZE_BOUNDS_STRICT, true,\n \t\t true),\n-  SANITIZER_OPT (pointer-compare, SANITIZE_POINTER_COMPARE, true),\n-  SANITIZER_OPT (pointer-subtract, SANITIZE_POINTER_SUBTRACT, true),\n-  SANITIZER_OPT (thread, SANITIZE_THREAD, false),\n-  SANITIZER_OPT (leak, SANITIZE_LEAK, false),\n-  SANITIZER_OPT (shift, SANITIZE_SHIFT, true),\n-  SANITIZER_OPT (shift-base, SANITIZE_SHIFT_BASE, true),\n-  SANITIZER_OPT (shift-exponent, SANITIZE_SHIFT_EXPONENT, true),\n-  SANITIZER_OPT (integer-divide-by-zero, SANITIZE_DIVIDE, true),\n-  SANITIZER_OPT (undefined, SANITIZE_UNDEFINED, true),\n-  SANITIZER_OPT (unreachable, SANITIZE_UNREACHABLE, false),\n-  SANITIZER_OPT (vla-bound, SANITIZE_VLA, true),\n-  SANITIZER_OPT (return, SANITIZE_RETURN, false),\n-  SANITIZER_OPT (null, SANITIZE_NULL, true),\n-  SANITIZER_OPT (signed-integer-overflow, SANITIZE_SI_OVERFLOW, true),\n-  SANITIZER_OPT (bool, SANITIZE_BOOL, true),\n-  SANITIZER_OPT (enum, SANITIZE_ENUM, true),\n-  SANITIZER_OPT (float-divide-by-zero, SANITIZE_FLOAT_DIVIDE, true),\n-  SANITIZER_OPT (float-cast-overflow, SANITIZE_FLOAT_CAST, true),\n-  SANITIZER_OPT (bounds, SANITIZE_BOUNDS, true),\n-  SANITIZER_OPT (bounds-strict, SANITIZE_BOUNDS | SANITIZE_BOUNDS_STRICT, true),\n-  SANITIZER_OPT (alignment, SANITIZE_ALIGNMENT, true),\n-  SANITIZER_OPT (nonnull-attribute, SANITIZE_NONNULL_ATTRIBUTE, true),\n+  SANITIZER_OPT (alignment, SANITIZE_ALIGNMENT, true, true),\n+  SANITIZER_OPT (nonnull-attribute, SANITIZE_NONNULL_ATTRIBUTE, true, true),\n   SANITIZER_OPT (returns-nonnull-attribute, SANITIZE_RETURNS_NONNULL_ATTRIBUTE,\n-\t\t true),\n-  SANITIZER_OPT (object-size, SANITIZE_OBJECT_SIZE, true),\n-  SANITIZER_OPT (vptr, SANITIZE_VPTR, true),\n-  SANITIZER_OPT (pointer-overflow, SANITIZE_POINTER_OVERFLOW, true),\n-  SANITIZER_OPT (builtin, SANITIZE_BUILTIN, true),\n-  SANITIZER_OPT (shadow-call-stack, SANITIZE_SHADOW_CALL_STACK, false),\n-  SANITIZER_OPT (all, ~0U, true),\n+\t\t true, true),\n+  SANITIZER_OPT (object-size, SANITIZE_OBJECT_SIZE, true, true),\n+  SANITIZER_OPT (vptr, SANITIZE_VPTR, true, false),\n+  SANITIZER_OPT (pointer-overflow, SANITIZE_POINTER_OVERFLOW, true, true),\n+  SANITIZER_OPT (builtin, SANITIZE_BUILTIN, true, true),\n+  SANITIZER_OPT (shadow-call-stack, SANITIZE_SHADOW_CALL_STACK, false, false),\n+  SANITIZER_OPT (all, ~0U, true, true),\n #undef SANITIZER_OPT\n-  { NULL, 0U, 0UL, false }\n+  { NULL, 0U, 0UL, false, false }\n };\n \n /* -fzero-call-used-regs= suboptions.  */\n@@ -2114,7 +2128,7 @@ struct edit_distance_traits<const string_fragment &>\n /* Given ARG, an unrecognized sanitizer option, return the best\n    matching sanitizer option, or NULL if there isn't one.\n    OPTS is array of candidate sanitizer options.\n-   CODE is OPT_fsanitize_ or OPT_fsanitize_recover_.\n+   CODE is OPT_fsanitize_, OPT_fsanitize_recover_ or OPT_fsanitize_trap_.\n    VALUE is non-zero for the regular form of the option, zero\n    for the \"no-\" form (e.g. \"-fno-sanitize-recover=\").  */\n \n@@ -2139,6 +2153,13 @@ get_closest_sanitizer_option (const string_fragment &arg,\n \t  && value)\n \tcontinue;\n \n+      /* For -fsanitize-trap= (and not -fno-sanitize-trap=),\n+\t don't offer the non-trapping options.  */\n+      if (code == OPT_fsanitize_trap_\n+\t  && !opts[i].can_trap\n+\t  && value)\n+\tcontinue;\n+\n       bm.consider (opts[i].name);\n     }\n   return bm.get_best_meaningful_candidate ();\n@@ -2183,10 +2204,13 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t\t    if (complain)\n \t\t      error_at (loc, \"%<-fsanitize=all%> option is not valid\");\n \t\t  }\n-\t\telse\n+\t\telse if (code == OPT_fsanitize_recover_)\n \t\t  flags |= ~(SANITIZE_THREAD | SANITIZE_LEAK\n \t\t\t     | SANITIZE_UNREACHABLE | SANITIZE_RETURN\n \t\t\t     | SANITIZE_SHADOW_CALL_STACK);\n+\t\telse /* if (code == OPT_fsanitize_trap_) */\n+\t\t  flags |= (SANITIZE_UNDEFINED\n+\t\t\t    | SANITIZE_UNDEFINED_NONDEFAULT);\n \t      }\n \t    else if (value)\n \t      {\n@@ -2197,6 +2221,10 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t\t    && sanitizer_opts[i].flag == SANITIZE_UNDEFINED)\n \t\t  flags |= (SANITIZE_UNDEFINED\n \t\t\t    & ~(SANITIZE_UNREACHABLE | SANITIZE_RETURN));\n+\t\telse if (code == OPT_fsanitize_trap_\n+\t\t\t && sanitizer_opts[i].flag == SANITIZE_VPTR)\n+\t\t  error_at (loc, \"%<-fsanitize-trap=%s%> is not supported\",\n+\t\t\t    sanitizer_opts[i].name);\n \t\telse\n \t\t  flags |= sanitizer_opts[i].flag;\n \t      }\n@@ -2215,6 +2243,8 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t  const char *suffix;\n \t  if (code == OPT_fsanitize_recover_)\n \t    suffix = \"-recover\";\n+\t  else if (code == OPT_fsanitize_trap_)\n+\t    suffix = \"-trap\";\n \t  else\n \t    suffix = \"\";\n \n@@ -2647,6 +2677,12 @@ common_handle_option (struct gcc_options *opts,\n \t\t\t\t   opts->x_flag_sanitize_recover, value, true);\n       break;\n \n+    case OPT_fsanitize_trap_:\n+      opts->x_flag_sanitize_trap\n+\t= parse_sanitizer_options (arg, loc, code,\n+\t\t\t\t   opts->x_flag_sanitize_trap, value, true);\n+      break;\n+\n     case OPT_fasan_shadow_offset_:\n       /* Deferred.  */\n       break;\n@@ -2665,6 +2701,15 @@ common_handle_option (struct gcc_options *opts,\n \t  &= ~(SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT);\n       break;\n \n+    case OPT_fsanitize_trap:\n+      if (value)\n+\topts->x_flag_sanitize_trap\n+\t  |= (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT);\n+      else\n+\topts->x_flag_sanitize_trap\n+\t  &= ~(SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT);\n+      break;\n+\n     case OPT_O:\n     case OPT_Os:\n     case OPT_Ofast:"}, {"sha": "73a96f32350aebe587acb4a045b408ced6c8bf9c", "filename": "gcc/opts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -473,6 +473,7 @@ extern const struct sanitizer_opts_s\n   unsigned int flag;\n   size_t len;\n   bool can_recover;\n+  bool can_trap;\n } sanitizer_opts[];\n \n extern const struct zero_call_used_regs_opts_s"}, {"sha": "c3187631153507221e2b53c4e818da6ccef0d277", "filename": "gcc/sanopt.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fsanopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fsanopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.cc?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -392,11 +392,11 @@ maybe_optimize_ubsan_null_ifn (class sanopt_ctx *ctx, gimple *stmt)\n      stmts have same location.  */\n   else if (integer_zerop (align))\n     remove = (flag_sanitize_recover & SANITIZE_NULL) == 0\n-\t      || flag_sanitize_undefined_trap_on_error\n+\t      || (flag_sanitize_trap & SANITIZE_NULL) != 0\n \t      || gimple_location (g) == gimple_location (stmt);\n   else if (tree_int_cst_le (cur_align, align))\n     remove = (flag_sanitize_recover & SANITIZE_ALIGNMENT) == 0\n-\t      || flag_sanitize_undefined_trap_on_error\n+\t      || (flag_sanitize_trap & SANITIZE_ALIGNMENT) != 0\n \t      || gimple_location (g) == gimple_location (stmt);\n \n   if (!remove && gimple_bb (g) == gimple_bb (stmt)"}, {"sha": "53b2b6ceb5f7cc8205c95080699340c58a2fea3b", "filename": "gcc/testsuite/c-c++-common/ubsan/align-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-8.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,6 +1,6 @@\n /* Limit this to known non-strict alignment targets.  */\n /* { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } } */\n-/* { dg-options \"-O -fsanitize=alignment -fsanitize-undefined-trap-on-error -Wno-address-of-packed-member -fdump-tree-sanopt-details\" } */\n+/* { dg-options \"-O -fsanitize=alignment -fsanitize-trap=alignment -Wno-address-of-packed-member -fdump-tree-sanopt-details\" } */\n /* { dg-skip-if \"\" { *-*-* } { \"-flto -fno-fat-lto-objects\" } } */\n /* { dg-shouldfail \"ubsan\" } */\n "}, {"sha": "e2cc9fe587f45b5d0191de0d6c9da2c4dc882ddf", "filename": "gcc/testsuite/c-c++-common/ubsan/div-by-zero-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fdiv-by-zero-4.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-fsanitize=signed-integer-overflow -fsanitize-undefined-trap-on-error -Wno-overflow\" } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -fsanitize-trap=signed-integer-overflow -Wno-overflow\" } */\n \n #define INT_MIN (-__INT_MAX__ - 1)\n "}, {"sha": "65b6dfb4c810f991b2521de1f726b95455537ce2", "filename": "gcc/testsuite/c-c++-common/ubsan/nonnull-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fnonnull-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fnonnull-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fnonnull-4.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-shouldfail \"ubsan\" } */\n-/* { dg-options \"-fsanitize=undefined -fsanitize-undefined-trap-on-error\" } */\n+/* { dg-options \"-fsanitize=undefined -fsanitize-trap=all\" } */\n \n int q, r;\n void *a, *b, *c = (void *) &q, *d, *e, *f = (void *) &q, *g, *h;"}, {"sha": "ac9df4d001ed2dc83cc3c09e19342394f7f5b839", "filename": "gcc/testsuite/c-c++-common/ubsan/overflow-add-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Foverflow-add-4.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable -fsanitize-undefined-trap-on-error\" } */\n+/* { dg-options \"-fsanitize=signed-integer-overflow -Wno-unused-variable -fsanitize-trap=undefined\" } */\n /* { dg-shouldfail \"ubsan\" } */\n \n #define INT_MAX __INT_MAX__"}, {"sha": "a3280c2908ec045e4d5ad39306be2c927ebc1d89", "filename": "gcc/testsuite/c-c++-common/ubsan/pr56956.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr56956.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr56956.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr56956.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-fsanitize=undefined -fsanitize-undefined-trap-on-error\" } */\n+/* { dg-options \"-fsanitize=undefined -fsanitize-trap=undefined\" } */\n \n unsigned int __attribute__((noinline,noclone))\n foo (unsigned int x)"}, {"sha": "13b7ef6a5e34f991968e88a53e048907e595d13b", "filename": "gcc/testsuite/c-c++-common/ubsan/pr68142.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr68142.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr68142.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr68142.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-fsanitize=undefined -fsanitize-undefined-trap-on-error\" } */\n+/* { dg-options \"-fsanitize=undefined -fsanitize-trap=undefined\" } */\n \n int __attribute__((noinline,noclone))\n h(int a)"}, {"sha": "3ee56c80740e490717f3280e039cc0a362190679", "filename": "gcc/testsuite/c-c++-common/ubsan/pr80932.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr80932.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr80932.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr80932.c?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -1,6 +1,6 @@\n /* PR sanitizer/80932 */\n /* { dg-do run } */\n-/* { dg-options \"-fsanitize=undefined -fsanitize-undefined-trap-on-error\" } */\n+/* { dg-options \"-fsanitize=undefined -fno-sanitize-trap=all -fsanitize-trap=shift,undefined\" } */\n \n int x = 1;\n "}, {"sha": "3aa25b534bba44d1cc639dd7188d011516143274", "filename": "gcc/ubsan.cc", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fubsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18/gcc%2Fubsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.cc?ref=2c7cfc7b418564a2f1f0e7a5b38dec7013ba5e18", "patch": "@@ -647,7 +647,7 @@ ubsan_instrument_unreachable (gimple_stmt_iterator *gsi)\n   gimple *g;\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n \n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & SANITIZE_UNREACHABLE)\n     g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -719,7 +719,7 @@ ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n \n   /* Generate __ubsan_handle_out_of_bounds call.  */\n   *gsi = gsi_after_labels (then_bb);\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & SANITIZE_BOUNDS)\n     g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -827,7 +827,8 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n     set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n \n   /* Put the ubsan builtin call into the newly created BB.  */\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & ((check_align ? SANITIZE_ALIGNMENT + 0 : 0)\n+\t\t\t    | (check_null ? SANITIZE_NULL + 0 : 0)))\n     g = gimple_build_call (builtin_decl_implicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -997,7 +998,7 @@ ubsan_expand_objsize_ifn (gimple_stmt_iterator *gsi)\n \t}\n \n       /* Generate __ubsan_handle_type_mismatch call.  */\n-      if (flag_sanitize_undefined_trap_on_error)\n+      if (flag_sanitize_trap & SANITIZE_OBJECT_SIZE)\n \tg = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n       else\n \t{\n@@ -1143,7 +1144,7 @@ ubsan_expand_ptr_ifn (gimple_stmt_iterator *gsip)\n     }\n \n   /* Put the ubsan builtin call into the newly created BB.  */\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & SANITIZE_POINTER_OVERFLOW)\n     g = gimple_build_call (builtin_decl_implicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -1518,7 +1519,7 @@ tree\n ubsan_build_overflow_builtin (tree_code code, location_t loc, tree lhstype,\n \t\t\t      tree op0, tree op1, tree *datap)\n {\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & SANITIZE_SI_OVERFLOW)\n     return build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \n   tree data;\n@@ -1741,7 +1742,8 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n     }\n \n   gsi2 = gsi_after_labels (then_bb);\n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & (TREE_CODE (type) == BOOLEAN_TYPE\n+\t\t\t    ? SANITIZE_BOOL : SANITIZE_ENUM))\n     g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -1904,7 +1906,7 @@ ubsan_instrument_float_cast (location_t loc, tree type, tree expr)\n   if (integer_zerop (t))\n     return NULL_TREE;\n \n-  if (flag_sanitize_undefined_trap_on_error)\n+  if (flag_sanitize_trap & SANITIZE_FLOAT_CAST)\n     fn = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n@@ -1974,7 +1976,7 @@ instrument_nonnull_arg (gimple_stmt_iterator *gsi)\n \t  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n \t  *gsi = gsi_after_labels (then_bb);\n-\t  if (flag_sanitize_undefined_trap_on_error)\n+\t  if (flag_sanitize_trap & SANITIZE_NONNULL_ATTRIBUTE)\n \t    g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \t  else\n \t    {\n@@ -2030,7 +2032,7 @@ instrument_nonnull_return (gimple_stmt_iterator *gsi)\n       gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n       *gsi = gsi_after_labels (then_bb);\n-      if (flag_sanitize_undefined_trap_on_error)\n+      if (flag_sanitize_trap & SANITIZE_RETURNS_NONNULL_ATTRIBUTE)\n \tg = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n       else\n \t{\n@@ -2279,7 +2281,7 @@ instrument_builtin (gimple_stmt_iterator *gsi)\n \t  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n \n \t  *gsi = gsi_after_labels (then_bb);\n-\t  if (flag_sanitize_undefined_trap_on_error)\n+\t  if (flag_sanitize_trap & SANITIZE_BUILTIN)\n \t    g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \t  else\n \t    {"}]}