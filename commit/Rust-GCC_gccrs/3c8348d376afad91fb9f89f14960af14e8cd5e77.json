{"sha": "3c8348d376afad91fb9f89f14960af14e8cd5e77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M4MzQ4ZDM3NmFmYWQ5MWZiOWY4OWYxNDk2MGFmMTRlOGNkNWU3Nw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2009-09-30T07:27:28Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-09-30T07:27:28Z"}, "message": "config.gcc (sh-symbianelf): Replace definition of extra_objs with separate definitions of c_target_objs and...\n\n        * config.gcc (sh-symbianelf): Replace definition of extra_objs\n        with separate definitions of c_target_objs and cxx_target_objs.\n        * config/sh/t-sh: Add rules to build symbian-cxx.o, symbian-c.o\n        and symbian-base.o.\n        * config/sh/sh.c (TARGET_CXX_INPUT_EXPORT_CLASS): Use\n        sh_symbian_import_export_class.\n        * config/sh/sh-protos.h: Fix names of exported symbian functions.\n        * config/sh/symbian.c: Delete, moving code into...\n        * config/sh/symbian-base.c: ... here\n        * config/sh/symbian-c.c: ... and here\n        * config/sh/symbian-cxx.c: ... and here.\n\nFrom-SVN: r152323", "tree": {"sha": "a07773b7f99167050e2f054029c205c70e6e0dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a07773b7f99167050e2f054029c205c70e6e0dec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c8348d376afad91fb9f89f14960af14e8cd5e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8348d376afad91fb9f89f14960af14e8cd5e77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8348d376afad91fb9f89f14960af14e8cd5e77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8348d376afad91fb9f89f14960af14e8cd5e77/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08a4a761ebe388e1b231eabd6f8e7e155d10b222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a4a761ebe388e1b231eabd6f8e7e155d10b222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a4a761ebe388e1b231eabd6f8e7e155d10b222"}], "stats": {"total": 1274, "additions": 773, "deletions": 501}, "files": [{"sha": "0c6ebdc0f223d46d2cfedd24abd93c1320756470", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -1,3 +1,17 @@\n+2009-09-30  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config.gcc (sh-symbianelf): Replace definition of extra_objs\n+\twith separate definitions of c_target_objs and cxx_target_objs.\n+\t* config/sh/t-sh: Add rules to build symbian-cxx.o, symbian-c.o\n+\tand symbian-base.o.\n+\t* config/sh/sh.c (TARGET_CXX_INPUT_EXPORT_CLASS): Use\n+\tsh_symbian_import_export_class.\n+\t* config/sh/sh-protos.h: Fix names of exported symbian functions.\n+\t* config/sh/symbian.c: Delete, moving code into...\n+\t* config/sh/symbian-base.c: ... here\n+\t* config/sh/symbian-c.c: ... and here\n+\t* config/sh/symbian-cxx.c: ... and here.\n+\n 2009-09-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/22093"}, {"sha": "1b0194b0589a090488ceeff70938b1551329546e", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -2184,7 +2184,8 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \t*-*-symbianelf*)\n \t\ttmake_file=\"sh/t-symbian\"\n \t\ttm_file=\"sh/symbian-pre.h sh/little.h ${tm_file} sh/symbian-post.h\"\n-\t\textra_objs=\"symbian.o\"\n+\t\tc_target_objs=\"symbian-base.o symbian-c.o\"\n+\t\tcxx_target_objs=\"symbian-base.o symbian-cxx.o\"\n \t\textra_parts=\"crt1.o crti.o crtn.o crtbegin.o crtend.o crtbeginS.o crtendS.o\"\n \t\t;;\n \t*-*-elf*)"}, {"sha": "8157221c0c6bdd2a702ed6eabb30cc82b3e47213", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -183,15 +183,15 @@ extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);\n #endif /* ! GCC_SH_PROTOS_H */\n \n #ifdef SYMBIAN\n-extern bool         sh_symbian_dllimport_name_p       (const char *);\n extern const char * sh_symbian_strip_name_encoding    (const char *);\n-extern bool         sh_symbian_dllexport_name_p       (const char *);\n-extern int          symbian_import_export_class       (tree, int);\n+extern bool         sh_symbian_is_dllexported_name    (const char *);\n #ifdef TREE_CODE\n-extern bool         sh_symbian_dllexport_p            (tree);\n+extern bool         sh_symbian_is_dllexported         (tree);\n+extern int          sh_symbian_import_export_class    (tree, int);\n extern tree         sh_symbian_handle_dll_attribute   (tree *, tree, tree, int, bool *);\n #ifdef RTX_CODE\n extern void         sh_symbian_encode_section_info    (tree, rtx, int);\n #endif\n #endif\n #endif /* SYMBIAN */\n+"}, {"sha": "2e37d2bbcac5807743b4d5caaf9d30b562d7d03e", "filename": "gcc/config/sh/sh-symbian.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsh-symbian.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsh-symbian.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-symbian.h?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -0,0 +1,42 @@\n+/* header file for GCC for a Symbian OS targeted SH backend.\n+   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Contributed by RedHat.\n+   Most of this code is stolen from i386/winnt.c.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* A unique character to encode declspec encoded objects.  */\n+#define SH_SYMBIAN_FLAG_CHAR \"$\"\n+\n+/* Unique strings to prefix exported and imported objects.  */\n+#define DLL_IMPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"i.\"\n+#define DLL_EXPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"e.\"\n+\n+/* Select the level of debugging information to display.\n+   0 for no debugging.\n+   1 for informative messages about decisions to add attributes\n+   2 for verbose information about what is being done.  */\n+#define SYMBIAN_DEBUG 0\n+/* #define SYMBIAN_DEBUG 1 */\n+/* #define SYMBIAN_DEBUG 2 */\n+\n+/* Functions exported from symbian-base.c.  */\n+extern tree sh_symbian_associated_type (tree);\n+\n+/* Functions exported from symbian-[c|c++].c.  */\n+extern bool sh_symbian_is_dllimported (tree);\n+"}, {"sha": "679cf11e83e6fa6c0e60e9111872e8a85942c19a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -503,7 +503,7 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef  TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING\tsh_symbian_strip_name_encoding\n #undef  TARGET_CXX_IMPORT_EXPORT_CLASS\n-#define TARGET_CXX_IMPORT_EXPORT_CLASS  symbian_import_export_class\n+#define TARGET_CXX_IMPORT_EXPORT_CLASS  sh_symbian_import_export_class\n \n #endif /* SYMBIAN */\n "}, {"sha": "624c6fc7a0a30cf4a80df633217cc1e414e0d6ac", "filename": "gcc/config/sh/symbian-base.c", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-base.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-base.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-base.c?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -0,0 +1,244 @@\n+/* Routines for GCC for a Symbian OS targeted SH backend, shared by\n+   both the C and C++ compilers.\n+   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Contributed by RedHat.\n+   Most of this code is stolen from i386/winnt.c.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"tm_p.h\"\n+#include \"toplev.h\"\n+#include \"sh-symbian.h\"\n+\n+/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n+\n+bool\n+sh_symbian_is_dllexported_name (const char *symbol)\n+{\n+  return strncmp (DLL_EXPORT_PREFIX, symbol,\n+\t\t  strlen (DLL_EXPORT_PREFIX)) == 0;\n+}\n+\n+/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n+\n+static bool\n+sh_symbian_is_dllimported_name (const char *symbol)\n+{\n+  return strncmp (DLL_IMPORT_PREFIX, symbol,\n+\t\t  strlen (DLL_IMPORT_PREFIX)) == 0;\n+}\n+\n+/* Return nonzero if DECL is a dllexport'd object.  */\n+\n+bool\n+sh_symbian_is_dllexported (tree decl)\n+{\n+  tree exp;\n+\n+  if (   TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return false;\n+\n+  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n+\n+  /* Class members get the dllexport status of their class.  */\n+  if (exp == NULL)\n+    {\n+      tree class = sh_symbian_associated_type (decl);\n+\n+      if (class)\n+\texp = lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class));\n+    }\n+#if SYMBIAN_DEBUG\n+  if (exp)\n+    {\n+      print_node_brief (stderr, \"dllexport:\", decl, 0);\n+      fprintf (stderr, \"\\n\");\n+    }\n+  else\n+#if SYMBIAN_DEBUG < 2\n+    if (TREE_CODE (decl) != FUNCTION_DECL)\n+#endif\n+    {\n+      print_node_brief (stderr, \"no dllexport:\", decl, 0);\n+      fprintf (stderr, \"\\n\");\n+    }\n+#endif\n+  return exp ? true : false;\n+}\n+\n+/* Mark a DECL as being dllimport'd.  */\n+\n+static void\n+sh_symbian_mark_dllimport (tree decl)\n+{\n+  const char *oldname;\n+  char *newname;\n+  tree idp;\n+  rtx rtlname;\n+  rtx newrtl;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+  if (MEM_P (rtlname))\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n+\n+  if (sh_symbian_is_dllexported_name (oldname))\n+    {\n+      error (\"%qE declared as both exported to and imported from a DLL\",\n+             DECL_NAME (decl));\n+    }\n+  else if (sh_symbian_is_dllimported_name (oldname))\n+    {\n+      /* Already done, but do a sanity check to prevent assembler errors.  */\n+      if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n+\terror (\"failure in redeclaration of %q+D: dllimport'd symbol lacks external linkage\",\n+\t       decl);\n+    }\n+  else\n+    {\n+      newname = (char *) alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n+      sprintf (newname, \"%s%s\", DLL_IMPORT_PREFIX, oldname);\n+\n+      /* We pass newname through get_identifier to ensure it has a unique\n+\t address.  RTL processing can sometimes peek inside the symbol ref\n+\t and compare the string's addresses to see if two symbols are\n+\t identical.  */\n+      idp = get_identifier (newname);\n+      newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+      XEXP (DECL_RTL (decl), 0) = newrtl;\n+    }\n+}\n+\n+/* Mark a DECL as being dllexport'd.\n+   Note that we override the previous setting (e.g.: dllimport).  */\n+\n+static void\n+sh_symbian_mark_dllexport (tree decl)\n+{\n+  const char *oldname;\n+  char *newname;\n+  rtx rtlname;\n+  tree idp;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+  if (MEM_P (rtlname))\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n+\n+  if (sh_symbian_is_dllimported_name (oldname))\n+    {\n+     /* Remove DLL_IMPORT_PREFIX.\n+\tNote - we do not issue a warning here.  In Symbian's environment it\n+\tis legitimate for a prototype to be marked as dllimport and the\n+\tcorresponding definition to be marked as dllexport.  The prototypes\n+\tare in headers used everywhere and the definition is in a translation\n+\tunit which has included the header in order to ensure argument\n+\tcorrectness.  */\n+      oldname += strlen (DLL_IMPORT_PREFIX);\n+      DECL_DLLIMPORT_P (decl) = 0;\n+    }\n+  else if (sh_symbian_is_dllexported_name (oldname))\n+    return; /* Already done.  */\n+\n+  newname = (char *) alloca (strlen (DLL_EXPORT_PREFIX) + strlen (oldname) + 1);\n+  sprintf (newname, \"%s%s\", DLL_EXPORT_PREFIX, oldname);\n+\n+  /* We pass newname through get_identifier to ensure it has a unique\n+     address.  RTL processing can sometimes peek inside the symbol ref\n+     and compare the string's addresses to see if two symbols are\n+     identical.  */\n+  idp = get_identifier (newname);\n+\n+  XEXP (DECL_RTL (decl), 0) =\n+    gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+}\n+\n+void\n+sh_symbian_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  default_encode_section_info (decl, rtl, first);\n+\n+  /* Mark the decl so we can tell from the rtl whether\n+     the object is dllexport'd or dllimport'd.  */\n+  if (sh_symbian_is_dllexported (decl))\n+    sh_symbian_mark_dllexport (decl);\n+  else if (sh_symbian_is_dllimported (decl))\n+    sh_symbian_mark_dllimport (decl);\n+  /* It might be that DECL has already been marked as dllimport, but a\n+     subsequent definition nullified that.  The attribute is gone but\n+     DECL_RTL still has (DLL_IMPORT_PREFIX) prefixed. We need to remove\n+     that. Ditto for the DECL_DLLIMPORT_P flag.  */\n+  else if (  (TREE_CODE (decl) == FUNCTION_DECL\n+\t   || TREE_CODE (decl) == VAR_DECL)\n+\t   && DECL_RTL (decl) != NULL_RTX\n+\t   && MEM_P (DECL_RTL (decl))\n+\t   && MEM_P (XEXP (DECL_RTL (decl), 0))\n+\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n+\t   && sh_symbian_is_dllimported_name (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n+    {\n+      const char * oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n+      /* Remove DLL_IMPORT_PREFIX.  */\n+      tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n+      rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+\n+      warning (0, \"%s %q+D %s after being referenced with dllimport linkage\",\n+\t       TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n+\t       decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n+\t       ? \"defined locally\" : \"redeclared without dllimport attribute\");\n+\n+      XEXP (DECL_RTL (decl), 0) = newrtl;\n+\n+      DECL_DLLIMPORT_P (decl) = 0;\n+    }\n+}\n+\n+/* Return the length of a function name prefix\n+    that starts with the character 'c'.  */\n+\n+static int\n+sh_symbian_get_strip_length (int c)\n+{\n+  /* XXX Assumes strlen (DLL_EXPORT_PREFIX) == strlen (DLL_IMPORT_PREFIX).  */\n+  return (c == SH_SYMBIAN_FLAG_CHAR[0]) ? strlen (DLL_EXPORT_PREFIX) : 0;\n+}\n+\n+/* Return a pointer to a function's name with any\n+   and all prefix encodings stripped from it.  */\n+\n+const char *\n+sh_symbian_strip_name_encoding (const char *name)\n+{\n+  int skip;\n+\n+  while ((skip = sh_symbian_get_strip_length (*name)))\n+    name += skip;\n+\n+  return name;\n+}\n+"}, {"sha": "4fda0aee99074dd067bf3e1ad954522727783186", "filename": "gcc/config/sh/symbian-c.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-c.c?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -0,0 +1,181 @@\n+/* Routines for C compiler part of GCC for a Symbian OS targeted SH backend.\n+   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Contributed by RedHat.\n+   Most of this code is stolen from i386/winnt.c.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"output.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"tm_p.h\"\n+#include \"toplev.h\"\n+#include \"sh-symbian.h\"\n+\n+\f\n+/* Return the type that we should use to determine if DECL is\n+   imported or exported.  */\n+\n+tree\n+sh_symbian_associated_type (tree decl)\n+{\n+  tree t = NULL_TREE;\n+\n+  /* We can just take the DECL_CONTEXT as normal.  */\n+  if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n+    t = DECL_CONTEXT (decl);\n+\n+  return t;\n+}\n+\n+/* Return nonzero if DECL is a dllimport'd object.  */\n+\n+bool\n+sh_symbian_is_dllimported (tree decl)\n+{\n+  tree imp;\n+\n+  if (   TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return false;\n+\n+  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n+  if (imp)\n+    return true;\n+\n+  /* Class members get the dllimport status of their class.  */\n+  imp = sh_symbian_associated_type (decl);\n+  if (! imp)\n+    return false;\n+\n+  imp = lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (imp));\n+  if (!imp)\n+    return false;\n+\n+  /* Don't mark defined functions as dllimport.  If the definition itself\n+     was marked with dllimport, then sh_symbian_handle_dll_attribute reports\n+     an error. This handles the case when the definition overrides an\n+     earlier declaration.  */\n+  if (TREE_CODE (decl) ==  FUNCTION_DECL\n+      && DECL_INITIAL (decl)\n+      && ! DECL_DECLARED_INLINE_P (decl))\n+    {\n+      warning (OPT_Wattributes, \"function %q+D is defined after prior \"\n+\t       \"declaration as dllimport: attribute ignored\",\n+\t       decl);\n+      return false;\n+    }\n+\n+  /*  Don't allow definitions of static data members in dllimport\n+      class.  Just ignore the attribute for vtable data.  */\n+  else if (TREE_CODE (decl) == VAR_DECL\n+\t   && TREE_STATIC (decl)\n+\t   && TREE_PUBLIC (decl)\n+\t   && !DECL_EXTERNAL (decl))\n+    {\n+      error (\"definition of static data member %q+D of dllimport'd class\",\n+\t     decl);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Handle a \"dllimport\" or \"dllexport\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n+\n+tree\n+sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n+\t\t\t\t int flags, bool *no_add_attrs)\n+{\n+  tree node = *pnode;\n+  const char *attr = IDENTIFIER_POINTER (name);\n+\n+  /* These attributes may apply to structure and union types being\n+     created, but otherwise should pass to the declaration involved.  */\n+  if (!DECL_P (node))\n+    {\n+      if (flags & ((int) ATTR_FLAG_DECL_NEXT\n+\t\t   | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t{\n+\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n+\t  *no_add_attrs = true;\n+\t  return tree_cons (name, args, NULL_TREE);\n+\t}\n+\n+      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n+\t{\n+\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n+\t  *no_add_attrs = true;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Report error on dllimport ambiguities\n+     seen now before they cause any damage.  */\n+  else if (is_attribute_p (\"dllimport\", name))\n+    {\n+      if (TREE_CODE (node) == VAR_DECL)\n+\t{\n+\t  if (DECL_INITIAL (node))\n+\t    {\n+\t      error (\"variable %q+D definition is marked dllimport\",\n+\t\t     node);\n+\t      *no_add_attrs = true;\n+\t    }\n+\n+\t  /* `extern' needn't be specified with dllimport.\n+\t     Specify `extern' now and hope for the best.  Sigh.  */\n+\t  DECL_EXTERNAL (node) = 1;\n+\t  /* Also, implicitly give dllimport'd variables declared within\n+\t     a function global scope, unless declared static.  */\n+\t  if (current_function_decl != NULL_TREE && ! TREE_STATIC (node))\n+  \t    TREE_PUBLIC (node) = 1;\n+\t}\n+    }\n+\n+  /*  Report error if symbol is not accessible at global scope.  */\n+  if (!TREE_PUBLIC (node)\n+      && (   TREE_CODE (node) == VAR_DECL\n+\t  || TREE_CODE (node) == FUNCTION_DECL))\n+    {\n+      error (\"external linkage required for symbol %q+D because of %qE attribute\",\n+\t     node, name);\n+      *no_add_attrs = true;\n+    }\n+\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"mark node\", node, 0);\n+  fprintf (stderr, \" as %s\\n\", attr);\n+#endif\n+\n+  return NULL_TREE;\n+}\n+\n+int\n+sh_symbian_import_export_class (tree ctype ATTRIBUTE_UNUSED, int import_export)\n+{\n+  return import_export;\n+}"}, {"sha": "0a457653520c20fc348c889d0f41b6a00f4d8fe8", "filename": "gcc/config/sh/symbian-cxx.c", "status": "renamed", "additions": 261, "deletions": 493, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -1,4 +1,4 @@\n-/* Routines for GCC for a Symbian OS targeted SH backend.\n+/* Routines for C++ support for GCC for a Symbian OS targeted SH backend.\n    Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n    Contributed by RedHat.\n    Most of this code is stolen from i386/winnt.c.\n@@ -31,27 +31,13 @@\n #include \"tm_p.h\"\n #include \"cp/cp-tree.h\"\t/* We need access to the OVL_... macros.  */\n #include \"toplev.h\"\n-\n-/* Select the level of debugging information to display.\n-   0 for no debugging.\n-   1 for informative messages about decisions to add attributes\n-   2 for verbose information about what is being done.  */\n-#define SYMBIAN_DEBUG 0\n-/* #define SYMBIAN_DEBUG 1 */\n-/* #define SYMBIAN_DEBUG 2 */\n-\n-/* A unique character to encode declspec encoded objects.  */\n-#define SH_SYMBIAN_FLAG_CHAR \"$\"\n-\n-/* Unique strings to prefix exported and imported objects.  */\n-#define DLL_IMPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"i.\"\n-#define DLL_EXPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"e.\"\n+#include \"sh-symbian.h\"\n \n \f\n /* Return the type that we should use to determine if DECL is\n    imported or exported.  */\n \n-static tree\n+tree\n sh_symbian_associated_type (tree decl)\n {\n   tree t = NULL_TREE;\n@@ -70,49 +56,11 @@ sh_symbian_associated_type (tree decl)\n   return t;\n }\n \n-/* Return nonzero if DECL is a dllexport'd object.  */\n-\n-bool\n-sh_symbian_dllexport_p (tree decl)\n-{\n-  tree exp;\n-\n-  if (   TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != FUNCTION_DECL)\n-    return false;\n-\n-  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n-\n-  /* Class members get the dllexport status of their class.  */\n-  if (exp == NULL)\n-    {\n-      tree class = sh_symbian_associated_type (decl);\n-\n-      if (class)\n-\texp = lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class));\n-    }\n-#if SYMBIAN_DEBUG\n-  if (exp)\n-    {\n-      print_node_brief (stderr, \"dllexport:\", decl, 0);\n-      fprintf (stderr, \"\\n\");\n-    }\n-  else\n-#if SYMBIAN_DEBUG < 2\n-    if (TREE_CODE (decl) != FUNCTION_DECL)\n-#endif\n-    {\n-      print_node_brief (stderr, \"no dllexport:\", decl, 0);\n-      fprintf (stderr, \"\\n\");\n-    }\n-#endif\n-  return exp ? true : false;\n-}\n-\n+\f\n /* Return nonzero if DECL is a dllimport'd object.  */\n \n-static bool\n-sh_symbian_dllimport_p (tree decl)\n+bool\n+sh_symbian_is_dllimported (tree decl)\n {\n   tree imp;\n \n@@ -186,183 +134,100 @@ sh_symbian_dllimport_p (tree decl)\n   return true;\n }\n \n-/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n-\n-bool\n-sh_symbian_dllexport_name_p (const char *symbol)\n-{\n-  return strncmp (DLL_EXPORT_PREFIX, symbol,\n-\t\t  strlen (DLL_EXPORT_PREFIX)) == 0;\n-}\n-\n-/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n+\f\n+/* This code implements a specification for exporting the vtable and rtti of\n+   classes that have members with the dllexport or dllexport attributes.\n+   This specification is defined here:\n \n+     http://www.armdevzone.com/EABI/exported_class.txt\n \n-bool\n-sh_symbian_dllimport_name_p (const char *symbol)\n-{\n-  return strncmp (DLL_IMPORT_PREFIX, symbol,\n-\t\t  strlen (DLL_IMPORT_PREFIX)) == 0;\n-}\n+   Basically it says that a class's vtable and rtti should be exported if\n+   the following rules apply:\n \n-/* Mark a DECL as being dllexport'd.\n-   Note that we override the previous setting (e.g.: dllimport).  */\n+   - If it has any non-inline non-pure virtual functions,\n+     at least one of these need to be declared dllimport\n+     OR any of the constructors is declared dllimport.\n \n-static void\n-sh_symbian_mark_dllexport (tree decl)\n-{\n-  const char *oldname;\n-  char *newname;\n-  rtx rtlname;\n-  tree idp;\n-\n-  rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (MEM_P (rtlname))\n-    rtlname = XEXP (rtlname, 0);\n-  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n-  oldname = XSTR (rtlname, 0);\n-\n-  if (sh_symbian_dllimport_name_p (oldname))\n-    {\n-     /* Remove DLL_IMPORT_PREFIX.\n-\tNote - we do not issue a warning here.  In Symbian's environment it\n-\tis legitimate for a prototype to be marked as dllimport and the\n-\tcorresponding definition to be marked as dllexport.  The prototypes\n-\tare in headers used everywhere and the definition is in a translation\n-\tunit which has included the header in order to ensure argument\n-\tcorrectness.  */\n-      oldname += strlen (DLL_IMPORT_PREFIX);\n-      DECL_DLLIMPORT_P (decl) = 0;\n-    }\n-  else if (sh_symbian_dllexport_name_p (oldname))\n-    return; /* Already done.  */\n+   AND\n \n-  newname = alloca (strlen (DLL_EXPORT_PREFIX) + strlen (oldname) + 1);\n-  sprintf (newname, \"%s%s\", DLL_EXPORT_PREFIX, oldname);\n+   - The class has an inline constructor/destructor and\n+     a key-function (placement of vtable uniquely defined) that\n+     is defined in this translation unit.\n \n-  /* We pass newname through get_identifier to ensure it has a unique\n-     address.  RTL processing can sometimes peek inside the symbol ref\n-     and compare the string's addresses to see if two symbols are\n-     identical.  */\n-  idp = get_identifier (newname);\n+   The specification also says that for classes which will have their\n+   vtables and rtti exported that their base class(es) might also need a\n+   similar exporting if:\n \n-  XEXP (DECL_RTL (decl), 0) =\n-    gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-}\n+   - Every base class needs to have its vtable & rtti exported\n+     as well, if the following the conditions hold true:\n+     + The base class has a non-inline declared non-pure virtual function\n+     + The base class is polymorphic (has or inherits any virtual functions)\n+       or the base class has any virtual base classes.  */\n \n-/* Mark a DECL as being dllimport'd.  */\n+/* Decide if a base class of a class should\n+   also have its vtable and rtti exported.  */\n \n static void\n-sh_symbian_mark_dllimport (tree decl)\n+sh_symbian_possibly_export_base_class (tree base_class)\n {\n-  const char *oldname;\n-  char *newname;\n-  tree idp;\n-  rtx rtlname;\n-  rtx newrtl;\n-\n-  rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (MEM_P (rtlname))\n-    rtlname = XEXP (rtlname, 0);\n-  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n-  oldname = XSTR (rtlname, 0);\n-\n-  if (sh_symbian_dllexport_name_p (oldname))\n-    {\n-      error (\"%qE declared as both exported to and imported from a DLL\",\n-             DECL_NAME (decl));\n-    }\n-  else if (sh_symbian_dllimport_name_p (oldname))\n-    {\n-      /* Already done, but do a sanity check to prevent assembler errors.  */\n-      if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n-\terror (\"failure in redeclaration of %q+D: dllimport'd symbol lacks external linkage\",\n-\t       decl);\n-    }\n-  else\n-    {\n-      newname = alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n-      sprintf (newname, \"%s%s\", DLL_IMPORT_PREFIX, oldname);\n-\n-      /* We pass newname through get_identifier to ensure it has a unique\n-\t address.  RTL processing can sometimes peek inside the symbol ref\n-\t and compare the string's addresses to see if two symbols are\n-\t identical.  */\n-      idp = get_identifier (newname);\n-      newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-      XEXP (DECL_RTL (decl), 0) = newrtl;\n-    }\n-}\n+  VEC(tree,gc) *method_vec;\n+  int len;\n \n-void\n-sh_symbian_encode_section_info (tree decl, rtx rtl, int first)\n-{\n-  default_encode_section_info (decl, rtl, first);\n-\n-  /* Mark the decl so we can tell from the rtl whether\n-     the object is dllexport'd or dllimport'd.  */\n-  if (sh_symbian_dllexport_p (decl))\n-    sh_symbian_mark_dllexport (decl);\n-  else if (sh_symbian_dllimport_p (decl))\n-    sh_symbian_mark_dllimport (decl);\n-  /* It might be that DECL has already been marked as dllimport, but a\n-     subsequent definition nullified that.  The attribute is gone but\n-     DECL_RTL still has (DLL_IMPORT_PREFIX) prefixed. We need to remove\n-     that. Ditto for the DECL_DLLIMPORT_P flag.  */\n-  else if (  (TREE_CODE (decl) == FUNCTION_DECL\n-\t   || TREE_CODE (decl) == VAR_DECL)\n-\t   && DECL_RTL (decl) != NULL_RTX\n-\t   && MEM_P (DECL_RTL (decl))\n-\t   && MEM_P (XEXP (DECL_RTL (decl), 0))\n-\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n-\t   && sh_symbian_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n+  if (! (TYPE_CONTAINS_VPTR_P (base_class)))\n+    return;\n+\n+  method_vec = CLASSTYPE_METHOD_VEC (base_class);\n+  len = method_vec ? VEC_length (tree, method_vec) : 0;\n+\n+  for (;len --;)\n     {\n-      const char * oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n-      /* Remove DLL_IMPORT_PREFIX.  */\n-      tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n-      rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n+      tree member = VEC_index (tree, method_vec, len);\n \n-      warning (0, \"%s %q+D %s after being referenced with dllimport linkage\",\n-\t       TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n-\t       decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n-\t       ? \"defined locally\" : \"redeclared without dllimport attribute\");\n+      if (! member)\n+\tcontinue;\n \n-      XEXP (DECL_RTL (decl), 0) = newrtl;\n+      for (member = OVL_CURRENT (member); member; member = OVL_NEXT (member))\n+\t{\n+\t  if (TREE_CODE (member) != FUNCTION_DECL)\n+\t    continue;\n \n-      DECL_DLLIMPORT_P (decl) = 0;\n-    }\n-}\n+\t  if (DECL_CONSTRUCTOR_P (member) || DECL_DESTRUCTOR_P (member))\n+\t    continue;\n \n+\t  if (! DECL_VIRTUAL_P (member))\n+\t    continue;\n \n-/* Return the length of a function name prefix\n-    that starts with the character 'c'.  */\n+\t  if (DECL_PURE_VIRTUAL_P (member))\n+\t    continue;\n \n-static int\n-sh_symbian_get_strip_length (int c)\n-{\n-  /* XXX Assumes strlen (DLL_EXPORT_PREFIX) == strlen (DLL_IMPORT_PREFIX).  */\n-  return (c == SH_SYMBIAN_FLAG_CHAR[0]) ? strlen (DLL_EXPORT_PREFIX) : 0;\n-}\n+\t  if (DECL_DECLARED_INLINE_P (member))\n+\t    continue;\n \n-/* Return a pointer to a function's name with any\n-   and all prefix encodings stripped from it.  */\n+\t  break;\n+\t}\n \n-const char *\n-sh_symbian_strip_name_encoding (const char *name)\n-{\n-  int skip;\n+      if (member)\n+\tbreak;\n+    }\n \n-  while ((skip = sh_symbian_get_strip_length (*name)))\n-    name += skip;\n+  if (len < 0)\n+    return;\n \n-  return name;\n+  /* FIXME: According to the spec this base class should be exported, but\n+     a) how do we do this ? and\n+     b) it does not appear to be necessary for compliance with the Symbian\n+        OS which so far is the only consumer of this code.  */\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"\", base_class, 0);\n+  fprintf (stderr, \" EXPORTed [base class of exported class]\\n\");\n+#endif\n }\n \n /* Add the named attribute to the given node.  Copes with both DECLs and\n    TYPEs.  Will only add the attribute if it is not already present.  */\n \n static void\n-symbian_add_attribute (tree node, const char *attr_name)\n+sh_symbian_add_attribute (tree node, const char *attr_name)\n {\n   tree attrs;\n   tree attr;\n@@ -386,221 +251,89 @@ symbian_add_attribute (tree node, const char *attr_name)\n #endif\n }\n \n-/* Handle a \"dllimport\" or \"dllexport\" attribute;\n-   arguments as in struct attribute_spec.handler.  */\n+/* Add the named attribute to a class and its vtable and rtti.  */\n \n-tree\n-sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n-\t\t\t\t int flags, bool *no_add_attrs)\n+static void\n+sh_symbian_add_attribute_to_class_vtable_and_rtti (tree ctype, const char *attr_name)\n {\n-  tree thunk;\n-  tree node = *pnode;\n-  const char *attr = IDENTIFIER_POINTER (name);\n-\n-  /* These attributes may apply to structure and union types being\n-     created, but otherwise should pass to the declaration involved.  */\n-  if (!DECL_P (node))\n-    {\n-      if (flags & ((int) ATTR_FLAG_DECL_NEXT\n-\t\t   | (int) ATTR_FLAG_FUNCTION_NEXT\n-\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n-\t{\n-\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n-\t  *no_add_attrs = true;\n-\t  return tree_cons (name, args, NULL_TREE);\n-\t}\n-\n-      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n-\t{\n-\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n-\t  *no_add_attrs = true;\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-\n-  /* Report error on dllimport ambiguities\n-     seen now before they cause any damage.  */\n-  else if (is_attribute_p (\"dllimport\", name))\n-    {\n-      if (TREE_CODE (node) == VAR_DECL)\n-\t{\n-\t  if (DECL_INITIAL (node))\n-\t    {\n-\t      error (\"variable %q+D definition is marked dllimport\",\n-\t\t     node);\n-\t      *no_add_attrs = true;\n-\t    }\n-\n-\t  /* `extern' needn't be specified with dllimport.\n-\t     Specify `extern' now and hope for the best.  Sigh.  */\n-\t  DECL_EXTERNAL (node) = 1;\n-\t  /* Also, implicitly give dllimport'd variables declared within\n-\t     a function global scope, unless declared static.  */\n-\t  if (current_function_decl != NULL_TREE && ! TREE_STATIC (node))\n-  \t    TREE_PUBLIC (node) = 1;\n-\t}\n-    }\n-\n-  /* If the node is an overloaded constructor or destructor, then we must\n-     make sure that the attribute is propagated along the overload chain,\n-     as it is these overloaded functions which will be emitted, rather than\n-     the user declared constructor itself.  */\n-  if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE\n-      && (DECL_CONSTRUCTOR_P (node) || DECL_DESTRUCTOR_P (node)))\n-    {\n-      tree overload;\n-\n-      for (overload = OVL_CHAIN (node); overload; overload = OVL_CHAIN (overload))\n-\t{\n-\t  tree node_args;\n-\t  tree func_args;\n-\t  tree function = OVL_CURRENT (overload);\n-\n-\t  if (! function\n-\t      || ! DECL_P (function)\n-\t      || (DECL_CONSTRUCTOR_P (node) && ! DECL_CONSTRUCTOR_P (function))\n-\t      || (DECL_DESTRUCTOR_P (node)  && ! DECL_DESTRUCTOR_P (function)))\n-\t    continue;\n-\n-\t  /* The arguments must match as well.  */\n-\t  for (node_args = DECL_ARGUMENTS (node), func_args = DECL_ARGUMENTS (function);\n-\t       node_args && func_args;\n-\t       node_args = TREE_CHAIN (node_args), func_args = TREE_CHAIN (func_args))\n-\t    if (TREE_TYPE (node_args) != TREE_TYPE (func_args))\n-\t      break;\n-\n-\t  if (node_args || func_args)\n-\t    {\n-\t      /* We can ignore an extraneous __in_chrg arguments in the node.\n-\t\t GCC generated destructors, for example, will have this.  */\n-\t      if ((node_args == NULL_TREE\n-\t\t   || func_args != NULL_TREE)\n-\t\t  && strcmp (IDENTIFIER_POINTER (DECL_NAME (node)), \"__in_chrg\") != 0)\n-\t\tcontinue;\n-\t    }\n-\n-\t  symbian_add_attribute (function, attr);\n-\n-\t  /* Propagate the attribute to any function thunks as well.  */\n-\t  for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n-\t    if (TREE_CODE (thunk) == FUNCTION_DECL)\n-\t      symbian_add_attribute (thunk, attr);\n-\t}\n-    }\n-\n-  if (TREE_CODE (node) == FUNCTION_DECL && DECL_VIRTUAL_P (node))\n-    {\n-      /* Propagate the attribute to any thunks of this function.  */\n-      for (thunk = DECL_THUNKS (node); thunk; thunk = TREE_CHAIN (thunk))\n-\tif (TREE_CODE (thunk) == FUNCTION_DECL)\n-\t  symbian_add_attribute (thunk, attr);\n-    }\n+  sh_symbian_add_attribute (ctype, attr_name);\n \n-  /*  Report error if symbol is not accessible at global scope.  */\n-  if (!TREE_PUBLIC (node)\n-      && (   TREE_CODE (node) == VAR_DECL\n-\t  || TREE_CODE (node) == FUNCTION_DECL))\n-    {\n-      error (\"external linkage required for symbol %q+D because of %qE attribute\",\n-\t     node, name);\n-      *no_add_attrs = true;\n-    }\n-\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"mark node\", node, 0);\n-  fprintf (stderr, \" as %s\\n\", attr);\n-#endif\n+  /* If the vtable exists then they need annotating as well.  */\n+  if (CLASSTYPE_VTABLES (ctype))\n+    /* XXX - Do we need to annotate any vtables other than the primary ?  */\n+    sh_symbian_add_attribute (CLASSTYPE_VTABLES (ctype), attr_name);\n \n-  return NULL_TREE;\n+  /* If the rtti exists then it needs annotating as well.  */\n+  if (TYPE_MAIN_VARIANT (ctype)\n+      && CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)))\n+    sh_symbian_add_attribute (CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)),\n+\t\t\t      attr_name);\n }\n \n-/* This code implements a specification for exporting the vtable and rtti of\n-   classes that have members with the dllexport or dllexport attributes.\n-   This specification is defined here:\n-\n-     http://www.armdevzone.com/EABI/exported_class.txt\n-\n-   Basically it says that a class's vtable and rtti should be exported if\n-   the following rules apply:\n-\n-   - If it has any non-inline non-pure virtual functions,\n-     at least one of these need to be declared dllimport\n-     OR any of the constructors is declared dllimport.\n-\n-   AND\n-\n-   - The class has an inline constructor/destructor and\n-     a key-function (placement of vtable uniquely defined) that\n-     is defined in this translation unit.\n-\n-   The specification also says that for classes which will have their\n-   vtables and rtti exported that their base class(es) might also need a\n-   similar exporting if:\n-\n-   - Every base class needs to have its vtable & rtti exported\n-     as well, if the following the conditions hold true:\n-     + The base class has a non-inline declared non-pure virtual function\n-     + The base class is polymorphic (has or inherits any virtual functions)\n-       or the base class has any virtual base classes.  */\n-\f\n-/* Decide if a base class of a class should\n-   also have its vtable and rtti exported.  */\n+/* Decide if a class needs to have an attribute because\n+   one of its member functions has the attribute.  */\n \n-static void\n-symbian_possibly_export_base_class (tree base_class)\n+static bool\n+sh_symbian_class_needs_attribute (tree ctype, const char *attribute_name)\n {\n   VEC(tree,gc) *method_vec;\n-  int len;\n \n-  if (! (TYPE_CONTAINS_VPTR_P (base_class)))\n-    return;\n+  method_vec = CLASSTYPE_METHOD_VEC (ctype);\n \n-  method_vec = CLASSTYPE_METHOD_VEC (base_class);\n-  len = method_vec ? VEC_length (tree, method_vec) : 0;\n+  /* If the key function has the attribute then the class needs it too.  */\n+  if (TYPE_POLYMORPHIC_P (ctype)\n+      && method_vec\n+      && tree_contains_struct [TREE_CODE (ctype), TS_DECL_COMMON] == 1\n+      && lookup_attribute (attribute_name,\n+\t\t\t   DECL_ATTRIBUTES (VEC_index (tree, method_vec, 0))))\n+    return true;\n \n-  for (;len --;)\n+  /* Check the class's member functions.  */\n+  if (TREE_CODE (ctype) == RECORD_TYPE)\n     {\n-      tree member = VEC_index (tree, method_vec, len);\n+      unsigned int len;\n \n-      if (! member)\n-\tcontinue;\n+      len = method_vec ? VEC_length (tree, method_vec) : 0;\n \n-      for (member = OVL_CURRENT (member); member; member = OVL_NEXT (member))\n+      for (;len --;)\n \t{\n-\t  if (TREE_CODE (member) != FUNCTION_DECL)\n-\t    continue;\n+\t  tree member = VEC_index (tree, method_vec, len);\n \n-\t  if (DECL_CONSTRUCTOR_P (member) || DECL_DESTRUCTOR_P (member))\n+\t  if (! member)\n \t    continue;\n \n-\t  if (! DECL_VIRTUAL_P (member))\n-\t    continue;\n+\t  for (member = OVL_CURRENT (member);\n+\t       member;\n+\t       member = OVL_NEXT (member))\n+\t    {\n+\t      if (TREE_CODE (member) != FUNCTION_DECL)\n+\t\tcontinue;\n \n-\t  if (DECL_PURE_VIRTUAL_P (member))\n-\t    continue;\n+\t      if (DECL_PURE_VIRTUAL_P (member))\n+\t\tcontinue;\n \n-\t  if (DECL_DECLARED_INLINE_P (member))\n-\t    continue;\n+\t      if (! DECL_VIRTUAL_P (member))\n+\t\tcontinue;\n \n-\t  break;\n+\t      if (lookup_attribute (attribute_name, DECL_ATTRIBUTES (member)))\n+\t\t{\n+#if SYMBIAN_DEBUG\n+\t\t  print_node_brief (stderr, \"\", ctype, 0);\n+\t\t  fprintf (stderr, \" inherits %s because\", attribute_name);\n+\t\t  print_node_brief (stderr, \"\", member, 0);\n+\t\t  fprintf (stderr, \" has it.\\n\");\n+#endif\n+\t\t  return true;\n+\t\t}\n+\t    }\n \t}\n-\n-      if (member)\n-\tbreak;\n     }\n \n-  if (len < 0)\n-    return;\n-\n-  /* FIXME: According to the spec this base class should be exported, but\n-     a) how do we do this ? and\n-     b) it does not appear to be necessary for compliance with the Symbian\n-        OS which so far is the only consumer of this code.  */\n #if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"\", base_class, 0);\n-  fprintf (stderr, \" EXPORTed [base class of exported class]\\n\");\n+  print_node_brief (stderr, \"\", ctype, 0);\n+  fprintf (stderr, \" does not inherit %s\\n\", attribute_name);\n #endif\n+  return false;\n }\n \n /* Decide if a class needs its vtable and rtti exporting.  */\n@@ -725,97 +458,19 @@ symbian_export_vtable_and_rtti_p (tree ctype)\n   /* Now we must check and possibly export the base classes.  */\n   for (i = 0, binfo = TYPE_BINFO (ctype);\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    symbian_possibly_export_base_class (BINFO_TYPE (base_binfo));\n+    sh_symbian_possibly_export_base_class (BINFO_TYPE (base_binfo));\n \n   return true;\n }\n \n-/* Add the named attribute to a class and its vtable and rtti.  */\n-\n-static void\n-symbian_add_attribute_to_class_vtable_and_rtti (tree ctype, const char *attr_name)\n-{\n-  symbian_add_attribute (ctype, attr_name);\n-\n-  /* If the vtable exists then they need annotating as well.  */\n-  if (CLASSTYPE_VTABLES (ctype))\n-    /* XXX - Do we need to annotate any vtables other than the primary ?  */\n-    symbian_add_attribute (CLASSTYPE_VTABLES (ctype), attr_name);\n-\n-  /* If the rtti exists then it needs annotating as well.  */\n-  if (TYPE_MAIN_VARIANT (ctype)\n-      && CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)))\n-    symbian_add_attribute (CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)),\n-\t\t\t   attr_name);\n-}\n-\n-/* Decide if a class needs to have an attribute because\n-   one of its member functions has the attribute.  */\n-\n-static bool\n-symbian_class_needs_attribute_p (tree ctype, const char *attribute_name)\n-{\n-  VEC(tree,gc) *method_vec;\n-\n-  method_vec = CLASSTYPE_METHOD_VEC (ctype);\n-\n-  /* If the key function has the attribute then the class needs it too.  */\n-  if (TYPE_POLYMORPHIC_P (ctype)\n-      && method_vec\n-      && lookup_attribute (attribute_name,\n-\t\t\t   DECL_ATTRIBUTES (VEC_index (tree, method_vec, 0))))\n-    return true;\n-\n-  /* Check the class's member functions.  */\n-  if (TREE_CODE (ctype) == RECORD_TYPE)\n-    {\n-      unsigned int len;\n-\n-      len = method_vec ? VEC_length (tree, method_vec) : 0;\n-\n-      for (;len --;)\n-\t{\n-\t  tree member = VEC_index (tree, method_vec, len);\n-\n-\t  if (! member)\n-\t    continue;\n-\n-\t  for (member = OVL_CURRENT (member);\n-\t       member;\n-\t       member = OVL_NEXT (member))\n-\t    {\n-\t      if (TREE_CODE (member) != FUNCTION_DECL)\n-\t\tcontinue;\n-\n-\t      if (DECL_PURE_VIRTUAL_P (member))\n-\t\tcontinue;\n-\n-\t      if (! DECL_VIRTUAL_P (member))\n-\t\tcontinue;\n-\n-\t      if (lookup_attribute (attribute_name, DECL_ATTRIBUTES (member)))\n-\t\t{\n-#if SYMBIAN_DEBUG\n-\t\t  print_node_brief (stderr, \"\", ctype, 0);\n-\t\t  fprintf (stderr, \" inherits %s because\", attribute_name);\n-\t\t  print_node_brief (stderr, \"\", member, 0);\n-\t\t  fprintf (stderr, \" has it.\\n\");\n-#endif\n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"\", ctype, 0);\n-  fprintf (stderr, \" does not inherit %s\\n\", attribute_name);\n-#endif\n-  return false;\n-}\n+/* Possibly override the decision to export class TYPE.  Upon entry\n+   IMPORT_EXPORT will contain 1 if the class is going to be exported,\n+   -1 if it is going to be imported and 0 otherwise.  This function\n+   should return the modified value and perform any other actions\n+   necessary to support the backend's targeted operating system.  */\n \n int\n-symbian_import_export_class (tree ctype, int import_export)\n+sh_symbian_import_export_class (tree ctype, int import_export)\n {\n   const char *attr_name = NULL;\n \n@@ -832,14 +487,14 @@ symbian_import_export_class (tree ctype, int import_export)\n   if (attr_name\n       && ! lookup_attribute (attr_name, TYPE_ATTRIBUTES (ctype)))\n     {\n-      if (symbian_class_needs_attribute_p (ctype, attr_name))\n-\tsymbian_add_attribute_to_class_vtable_and_rtti (ctype, attr_name);\n+      if (sh_symbian_class_needs_attribute (ctype, attr_name))\n+\tsh_symbian_add_attribute_to_class_vtable_and_rtti (ctype, attr_name);\n \n       /* Classes can be forced to export their\n \t vtable and rtti under certain conditions.  */\n       if (symbian_export_vtable_and_rtti_p (ctype))\n \t{\n-\t  symbian_add_attribute_to_class_vtable_and_rtti (ctype, \"dllexport\");\n+\t  sh_symbian_add_attribute_to_class_vtable_and_rtti (ctype, \"dllexport\");\n \n \t  /* Make sure that the class and its vtable are exported.  */\n \t  import_export = 1;\n@@ -877,18 +532,131 @@ symbian_import_export_class (tree ctype, int import_export)\n   return import_export;\n }\n \n-/* Dummy definition of this array for cc1 building purposes.  */\n-tree cp_global_trees[CPTI_MAX] __attribute__((weak));\n+/* Handle a \"dllimport\" or \"dllexport\" attribute;\n+   arguments as in struct attribute_spec.handler.  */\n \n-#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+tree\n+sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n+\t\t\t\t int flags, bool *no_add_attrs)\n+{\n+  tree thunk;\n+  tree node = *pnode;\n+  const char *attr = IDENTIFIER_POINTER (name);\n \n-/* Dummy version of this G++ function for building cc1.  */\n-void lang_check_failed (const char *, int, const char *) __attribute__((weak));\n+  /* These attributes may apply to structure and union types being\n+     created, but otherwise should pass to the declaration involved.  */\n+  if (!DECL_P (node))\n+    {\n+      if (flags & ((int) ATTR_FLAG_DECL_NEXT\n+\t\t   | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t{\n+\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n+\t  *no_add_attrs = true;\n+\t  return tree_cons (name, args, NULL_TREE);\n+\t}\n \n-void\n-lang_check_failed (const char *file, int line, const char *function)\n-{\n-  internal_error (\"lang_* check: failed in %s, at %s:%d\",\n-\t\t  function, trim_filename (file), line);\n+      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n+\t{\n+\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n+\t  *no_add_attrs = true;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Report error on dllimport ambiguities\n+     seen now before they cause any damage.  */\n+  else if (is_attribute_p (\"dllimport\", name))\n+    {\n+      if (TREE_CODE (node) == VAR_DECL)\n+\t{\n+\t  if (DECL_INITIAL (node))\n+\t    {\n+\t      error (\"variable %q+D definition is marked dllimport\",\n+\t\t     node);\n+\t      *no_add_attrs = true;\n+\t    }\n+\n+\t  /* `extern' needn't be specified with dllimport.\n+\t     Specify `extern' now and hope for the best.  Sigh.  */\n+\t  DECL_EXTERNAL (node) = 1;\n+\t  /* Also, implicitly give dllimport'd variables declared within\n+\t     a function global scope, unless declared static.  */\n+\t  if (current_function_decl != NULL_TREE && ! TREE_STATIC (node))\n+  \t    TREE_PUBLIC (node) = 1;\n+\t}\n+    }\n+\n+  /* If the node is an overloaded constructor or destructor, then we must\n+     make sure that the attribute is propagated along the overload chain,\n+     as it is these overloaded functions which will be emitted, rather than\n+     the user declared constructor itself.  */\n+  if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE\n+      && (DECL_CONSTRUCTOR_P (node) || DECL_DESTRUCTOR_P (node)))\n+    {\n+      tree overload;\n+\n+      for (overload = OVL_CHAIN (node); overload; overload = OVL_CHAIN (overload))\n+\t{\n+\t  tree node_args;\n+\t  tree func_args;\n+\t  tree function = OVL_CURRENT (overload);\n+\n+\t  if (! function\n+\t      || ! DECL_P (function)\n+\t      || (DECL_CONSTRUCTOR_P (node) && ! DECL_CONSTRUCTOR_P (function))\n+\t      || (DECL_DESTRUCTOR_P (node)  && ! DECL_DESTRUCTOR_P (function)))\n+\t    continue;\n+\n+\t  /* The arguments must match as well.  */\n+\t  for (node_args = DECL_ARGUMENTS (node), func_args = DECL_ARGUMENTS (function);\n+\t       node_args && func_args;\n+\t       node_args = TREE_CHAIN (node_args), func_args = TREE_CHAIN (func_args))\n+\t    if (TREE_TYPE (node_args) != TREE_TYPE (func_args))\n+\t      break;\n+\n+\t  if (node_args || func_args)\n+\t    {\n+\t      /* We can ignore an extraneous __in_chrg arguments in the node.\n+\t\t GCC generated destructors, for example, will have this.  */\n+\t      if ((node_args == NULL_TREE\n+\t\t   || func_args != NULL_TREE)\n+\t\t  && strcmp (IDENTIFIER_POINTER (DECL_NAME (node)), \"__in_chrg\") != 0)\n+\t\tcontinue;\n+\t    }\n+\n+\t  sh_symbian_add_attribute (function, attr);\n+\n+\t  /* Propagate the attribute to any function thunks as well.  */\n+\t  for (thunk = DECL_THUNKS (function); thunk; thunk = TREE_CHAIN (thunk))\n+\t    if (TREE_CODE (thunk) == FUNCTION_DECL)\n+\t      sh_symbian_add_attribute (thunk, attr);\n+\t}\n+    }\n+\n+  if (TREE_CODE (node) == FUNCTION_DECL && DECL_VIRTUAL_P (node))\n+    {\n+      /* Propagate the attribute to any thunks of this function.  */\n+      for (thunk = DECL_THUNKS (node); thunk; thunk = TREE_CHAIN (thunk))\n+\tif (TREE_CODE (thunk) == FUNCTION_DECL)\n+\t  sh_symbian_add_attribute (thunk, attr);\n+    }\n+\n+  /*  Report error if symbol is not accessible at global scope.  */\n+  if (!TREE_PUBLIC (node)\n+      && (   TREE_CODE (node) == VAR_DECL\n+\t  || TREE_CODE (node) == FUNCTION_DECL))\n+    {\n+      error (\"external linkage required for symbol %q+D because of %qE attribute\",\n+\t     node, name);\n+      *no_add_attrs = true;\n+    }\n+\n+#if SYMBIAN_DEBUG\n+  print_node_brief (stderr, \"mark node\", node, 0);\n+  fprintf (stderr, \" as %s\\n\", attr);\n+#endif\n+\n+  return NULL_TREE;\n }\n-#endif /* ENABLE_TREE_CHECKING */", "previous_filename": "gcc/config/sh/symbian.c"}, {"sha": "a4497b96994bf38a0fa8915e72e461367e3687a5", "filename": "gcc/config/sh/symbian-post.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-post.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Fsymbian-post.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-post.h?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -31,8 +31,8 @@\n #define SYMBIAN_EXPORT_NAME(NAME,FILE,DECL)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if ((DECL && sh_symbian_dllexport_p (DECL))\t\t\\\n-         || sh_symbian_dllexport_name_p (NAME))\t\t\t\\\n+      if ((DECL && sh_symbian_is_dllexported (DECL))\t\t\\\n+         || sh_symbian_is_dllexported_name (NAME))\t\t\\\n         {\t\t\t\t\t\t\t\\\n           fprintf ((FILE), \"\\t.pushsection .directive\\n\");\t\\\n           fprintf ((FILE), \"\\t.asciz \\\"EXPORT %s\\\\n\\\"\\n\",\t\\"}, {"sha": "f0b7dabd4e539f4ea37f7ab6c0d2f295608f3298", "filename": "gcc/config/sh/t-symbian", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Ft-symbian", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8348d376afad91fb9f89f14960af14e8cd5e77/gcc%2Fconfig%2Fsh%2Ft-symbian", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-symbian?ref=3c8348d376afad91fb9f89f14960af14e8cd5e77", "patch": "@@ -21,6 +21,28 @@ sh-c.o: $(srcdir)/config/sh/sh-c.c \\\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/sh/sh-c.c\n \n+symbian-cxx.o: \\\n+  $(srcdir)/config/sh/symbian-cxx.c \\\n+  $(srcdir)/config/sh/sh-symbian.h \\\n+  $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) $(RTL_H) \\\n+  toplev.h output.h coretypes.h flags.h expr.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+symbian-c.o: \\\n+  $(srcdir)/config/sh/symbian-c.c \\\n+  $(srcdir)/config/sh/sh-symbian.h \\\n+  $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) $(RTL_H) \\\n+  toplev.h output.h coretypes.h flags.h expr.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+symbian-base.o: \\\n+  $(srcdir)/config/sh/symbian-base.c \\\n+  $(srcdir)/config/sh/sh-symbian.h \\\n+  $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) $(RTL_H) \\\n+  toplev.h output.h coretypes.h flags.h expr.h\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+\n LIB1ASMSRC = sh/lib1funcs.asm\n LIB1ASMFUNCS = _ashiftrt _ashiftrt_n _ashiftlt _lshiftrt _movstr \\\n   _movstr_i4 _mulsi3 _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr \\"}]}