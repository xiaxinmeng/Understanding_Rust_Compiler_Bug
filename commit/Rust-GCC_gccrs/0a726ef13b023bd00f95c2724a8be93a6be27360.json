{"sha": "0a726ef13b023bd00f95c2724a8be93a6be27360", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE3MjZlZjEzYjAyM2JkMDBmOTVjMjcyNGE4YmU5M2E2YmUyNzM2MA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-04-05T03:52:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-05T03:52:19Z"}, "message": "i386.c (x86_double_with_add): Turn off for Pentium and PPro.\n\n\t* i386.c (x86_double_with_add): Turn off for Pentium and PPro.\n\t(small_shift_operand, output_ashlsi3): New functions.\n\t* i386.h (small_shift_operand, output_ashlsi3): Declare.\n\t* i386.md (ashlsi3): Simplify ahlsi3 patterns.  Remove splitters\n\tthat are no longer needed.\n\nFrom-SVN: r26189", "tree": {"sha": "76f283a65b0dc7df22c01741fb38801cc2756752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76f283a65b0dc7df22c01741fb38801cc2756752"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a726ef13b023bd00f95c2724a8be93a6be27360", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a726ef13b023bd00f95c2724a8be93a6be27360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a726ef13b023bd00f95c2724a8be93a6be27360", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a726ef13b023bd00f95c2724a8be93a6be27360/comments", "author": null, "committer": null, "parents": [{"sha": "b5d9b9ab00c982b667c5df009b555464ca765765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5d9b9ab00c982b667c5df009b555464ca765765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5d9b9ab00c982b667c5df009b555464ca765765"}], "stats": {"total": 323, "additions": 124, "deletions": 199}, "files": [{"sha": "dc45b01873dc2828330d52a875a2cbc0b2b74976", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a726ef13b023bd00f95c2724a8be93a6be27360", "patch": "@@ -1,12 +1,16 @@\n+Mon Apr  5 04:47:14 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* i386.c (x86_double_with_add): Turn off for Pentium and PPro.\n+\t(small_shift_operand, output_ashlsi3): New functions.\n+\t* i386.h (small_shift_operand, output_ashlsi3): Declare.\n+\t* i386.md (ashlsi3): Simplify ahlsi3 patterns.  Remove splitters\n+\tthat are no longer needed.\n+\n Sun Apr  4 04:05:04 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* stmt.c (expand_loop_end): When copying the loop exit test,\n \tdo not walk into a nested loop.\n \n-Sun Apr 4 01:15:04 PST 1999 Jeff Law  (law@cygnus.com)\n-\n-\t* version.c: Bump for snapshot.\n-\n Sun Apr  4 00:14:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* fixinc/hackshell.tpl: Skip links to directories, to avoid"}, {"sha": "81a024a275c36fe1b12f5c37e80f9f87d5f523ac", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0a726ef13b023bd00f95c2724a8be93a6be27360", "patch": "@@ -123,7 +123,7 @@ const int x86_use_leave = m_386 | m_K6;\n const int x86_push_memory = m_386 | m_K6;\n const int x86_zero_extend_with_and = m_486 | m_PENT;\n const int x86_movx = m_386 | m_PPRO | m_K6;\n-const int x86_double_with_add = ~m_386;\n+const int x86_double_with_add = ~(m_386 | m_PENT | m_PPRO);\n const int x86_use_bit_test = m_386;\n const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO;\n const int x86_use_q_reg = m_PENT | m_PPRO | m_K6;\n@@ -1687,6 +1687,17 @@ symbolic_operand (op, mode)\n     }\n }\n \n+/* Return nonzero if OP is a constant shift count small enough to\n+   encode into an lea instruction.  */\n+\n+int\n+small_shift_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == CONST_INT && INTVAL (op) > 0 && INTVAL (op) < 4);\n+}\n+\n /* Test for a valid operand for a call instruction.\n    Don't allow the arg pointer register or virtual regs\n    since they may change into reg + const, which the patterns\n@@ -5595,3 +5606,89 @@ x86_adjust_cost (insn, link, dep_insn, cost)\n \n   return cost;\n }\n+\n+/* Output assembly code for a left shift.\n+\n+   Always use \"sal\" when shifting a memory operand or for a non constant\n+   shift count.\n+\n+   When optimizing for size, we know that src == dest, and we should always\n+   use \"sal\".  If src != dest, then copy src to dest and use \"sal\".\n+   \n+   Pentium and PPro (speed):\n+\n+     When src == dest, use \"add\" for a shift counts of one, else use\n+     \"sal\".  If we modeled Pentium AGI stalls and U/V pipelining better we\n+     would want to generate lea for some shifts on the Pentium.\n+\n+     When src != dest, use \"lea\" for small shift counts.  Otherwise,\n+     copy src to dest and use the normal shifting code.  Exception for\n+     TARGET_DOUBLE_WITH_ADD.  */\n+\n+char *\n+output_ashlsi3 (operands)\n+     rtx *operands;\n+{\n+  /* Handle case where srcreg != dstreg.  */\n+  if (REG_P (operands[0]) && REGNO (operands[0]) != REGNO (operands[1]))\n+    {\n+      if (TARGET_DOUBLE_WITH_ADD && INTVAL (operands[2]) == 1)\n+\t{\n+\t  output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n+\t  return AS2 (add%L0,%1,%0);\n+\t}\n+      else\n+        {\n+          CC_STATUS_INIT;\n+\n+\t  /* This should be extremely rare (impossible?).  We can not encode a\n+\t     shift of the stack pointer using an lea instruction.  So copy the\n+\t     stack pointer into the destination register and use an lea.  */\n+\t  if (operands[1] == stack_pointer_rtx)\n+\t    {\n+\t      output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n+\t      operands[1] = operands[0];\n+\t    }\n+\n+\t  /* For shifts up to and including 3 bits, use lea.  */\n+          operands[1] = gen_rtx_MULT (SImode, operands[1],\n+\t\t\t\t      GEN_INT (1 << INTVAL (operands[2])));\n+\t  return AS2 (lea%L0,%a1,%0);\n+\t}\n+    }\n+\n+  /* Source and destination match.  */\n+\n+  /* Handle variable shift.  */\n+  if (REG_P (operands[2]))\n+    return AS2 (sal%L0,%b2,%0);\n+\n+  /* Always perform shift by 1 using an add instruction.  */\n+  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n+    return AS2 (add%L0,%0,%0);\n+\n+#if 0\n+  /* ??? Currently disabled.  reg-stack currently stomps on the mode of\n+     each insn.  Thus, we can not easily detect when we should use lea to\n+     improve issue characteristics.  Until reg-stack is fixed, fall back to\n+     sal instruction for Pentiums to avoid AGI stall.  */\n+  /* Shift reg by 2 or 3 use an lea instruction for Pentium if this is\n+     insn is expected to issue into the V pipe (the insn's mode will be\n+     TImode for a U pipe, and !TImode for a V pipe instruction).  */\n+  if (! optimize_size\n+      && REG_P (operands[0])\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= 3\n+      && (int)ix86_cpu == (int)PROCESSOR_PENTIUM\n+      && GET_MODE (insn) != TImode)\n+    {\n+      CC_STATUS_INIT;\n+      operands[1] = gen_rtx_MULT (SImode, operands[1],\n+\t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n+      return AS2 (lea%L0,%a1,%0);\n+    }\n+#endif\n+\n+  /* Otherwise use a shift instruction.  */\n+  return AS2 (sal%L0,%2,%0);\n+}"}, {"sha": "e3d6f18ce0d835ece7c67166c1c139e6c0516ac2", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0a726ef13b023bd00f95c2724a8be93a6be27360", "patch": "@@ -2765,6 +2765,8 @@ extern int reg_mentioned_in_mem ();\n extern char *output_int_conditional_move ();\n extern char *output_fp_conditional_move ();\n extern int ix86_can_use_return_insn_p ();\n+extern int small_shift_operand ();\n+extern char *output_ashlsi3 ();\n \n #ifdef NOTYET\n extern struct rtx_def *copy_all_rtx ();"}, {"sha": "c0d52cfd31043c6fba22b10d7e41a140d087f0d8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 194, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a726ef13b023bd00f95c2724a8be93a6be27360/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0a726ef13b023bd00f95c2724a8be93a6be27360", "patch": "@@ -4753,205 +4753,27 @@ byte_xor_operation:\n   \"\"\n   \"\")\n \n-;; Optimizing for code size:\n-;;   For regsiter destinations:\n-;;     add == 2 bytes, move == 2 bytes, shift == 3 bytes, lea == 7 bytes\n-;;\n-;;     lea loses when optimizing for size\n-;;\n-;;   Do the math.  If the count is 1, using add, else using sal will\n-;;   produce the smallest possible code, even when the source and\n-;;   dest do not match.  For a memory destination, sal is the only\n-;;   choice.\n-;;\n-;;   Do not try to handle case where src and dest do not match.  Let regmove\n-;;   and reload handle them.  A mov followed by this insn will generate the\n-;;   desired size optimized results.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n-  \"optimize_size\"\n-  \"*\n-{\n-  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n-    return AS2 (add%L0,%0,%0);\n-\n-  if (REG_P (operands[2]))\n-    return AS2 (sal%L0,%b2,%0);\n-  return AS2 (sal%L0,%2,%0);\n-}\")\n-\n-;; For Pentium/Pentium MMX:\n-;;\n-;;   We want to optimize for pairability, but avoid generating AGI stalls.\n-;;\n-;;   If this insn is expected to issue in the U pipe, then prefer sal,\n-;;   else prefer lea for small shifts when srcreg == dstreg.\n-;;\n-;; For PPro/PII\n-;;\n-;;   There's more than one approach to optimizing for this family; it is\n-;;   unclear which approach is best.  For now, we will try to minimize\n-;;   uops.  Note that sal and lea have the same characteristics, so we\n-;;   prefer sal as it takes less space.\n-;;\n-;; We can actually share code for these two cases since the basic techniques\n-;; for generating good code on these chips is the same, even if the final\n-;; code sequences are different.\n-;;\n-;; I do not know what is most appropriate for the AMD or Cyrix chips.\n-;;\n-;;   srcreg == dstreg, constant shift count:\n-;;\n-;;     For a shift count of one, use \"add\".\n-;;     For a shift count of two or three, use \"sal\"/\"lea\" for Pentium and\n-;;     Pentium MMX depending on which pipe the insn will execute.\n-;;     All others use \"sar\".\n-;;\n-;;   srcreg != dstreg, constant shift count:\n-;;\n-;;     For shift counts of one to three, use \"lea\".\n-;;     All others use \"lea\" for the first shift into the destination reg,\n-;;     then fall back on the srcreg == dstreg for the residual shifts.\n-;;\n-;;   memory destinations or nonconstant shift count:\n-;;\n-;;     Use \"sal\".\n+;; Pattern for shifts which can be encoded into an lea instruction.\n+;; This is kept as a separate pattern so that regmove can optimize cases\n+;; where we know the source and destination must match.\n ;;\n+;; Do not expose this pattern when optimizing for size since we never want\n+;; to use lea when optimizing for size since mov+sal is smaller than lea.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,r\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI,I\")))]\n-  \"! optimize_size\n-   && ((int)ix86_cpu == (int)PROCESSOR_PENTIUM\n-       || (int)ix86_cpu == (int)PROCESSOR_PENTIUMPRO)\"\n-  \"*\n-{\n-  /* This should be extremely rare (impossible?).  We can not encode a shift\n-     of the stack pointer using an lea instruction.  So copy the stack pointer\n-     into the destination register and fall into the srcreg == dstreg shifting\n-     support.  */\n-  if (operands[1] == stack_pointer_rtx)\n-    {\n-      output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n-      operands[1] = operands[0];\n-    }\n-\n-  /* Handle case where srcreg != dstreg.  */\n-  if (REG_P (operands[0]) && REGNO (operands[0]) != REGNO (operands[1]))\n-    {\n-      /* For counts > 3, it is easiest to split into component insns.  */\n-      if (INTVAL (operands[2]) > 3)\n-\treturn \\\"#\\\";\n-    \n-      /* For shifts up to and including 3 bits, use lea.  */\n-      operands[1] = gen_rtx_MULT (SImode, operands[1],\n-\t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n-      return AS2 (lea%L0,%a1,%0);\n-    }\n-\n-  /* Source and destination match.  */\n-\n-  /* Handle variable shift.  */\n-  if (REG_P (operands[2]))\n-    return AS2 (sal%L0,%b2,%0);\n-\n-  /* Always perform shift by 1 using an add instruction.  */\n-  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n-    return AS2 (add%L0,%0,%0);\n-\n-#if 0\n-  /* ??? Currently disabled.  reg-stack currently stomps on the mode of\n-     each insn.  Thus, we can not easily detect when we should use lea to\n-     improve issue characteristics.  Until reg-stack is fixed, fall back to\n-     sal instruction for Pentiums to avoid AGI stall.  */\n-  /* Shift reg by 2 or 3 use an lea instruction for Pentium if this is\n-     insn is expected to issue into the V pipe (the insn's mode will be\n-     TImode for a U pipe, and !TImode for a V pipe instruction).  */\n-  if (REG_P (operands[0])\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) <= 3\n-      && (int)ix86_cpu == (int)PROCESSOR_PENTIUM\n-      && GET_MODE (insn) != TImode)\n-    {\n-      operands[1] = gen_rtx_MULT (SImode, operands[1],\n-\t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n-      return AS2 (lea%L0,%a1,%0);\n-    }\n-#endif\n-\n-  /* Otherwise use a shift instruction.  */\n-  return AS2 (sal%L0,%2,%0);\n-}\")\n-\n-;; Pentium/PPro/PII Splitter used when srcreg != destreg and shift\n-;; count is > 3.  In each case we use lea to perform the first three\n-;; shifts into the destination register, then we fall back to the\n-;; normal shifting code for the residual shifts.\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n-  \"reload_completed\n-   && ! optimize_size\n-   && ((int)ix86_cpu == (int)PROCESSOR_PENTIUM\n-       || (int)ix86_cpu == (int)PROCESSOR_PENTIUMPRO)\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) > 3\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n-  [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 3)))]\n-  \"\n-{\n-  operands[3] = GEN_INT (INTVAL (operands[2]) - 3);\n-  operands[2] = GEN_INT (3);\n-}\")\n+\t\t   (match_operand:SI 2 \"small_shift_operand\" \"M,M\")))]\n+  \"! optimize_size\"\n+  \"* return output_ashlsi3 (operands);\")\n \n-\n-;; On i386 and i486, \"addl reg,reg\" is faster than \"sall $1,reg\"\n-;; On i486, movl/sall appears slightly faster than leal, but the leal\n-;; is smaller - use leal for now unless the shift count is 1.\n-;;\n+;; Generic left shift pattern to catch all cases not handled by the\n+;; shift pattern above.\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,r\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI,M\")))]\n-  \"! optimize_size\n-   && ! ((int)ix86_cpu == (int)PROCESSOR_PENTIUM\n-         || (int)ix86_cpu == (int)PROCESSOR_PENTIUMPRO)\"\n-  \"*\n-{\n-  if (REG_P (operands[0]) && REGNO (operands[0]) != REGNO (operands[1]))\n-    {\n-      if (TARGET_DOUBLE_WITH_ADD && INTVAL (operands[2]) == 1)\n-\t{\n-\t  output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n-\t  return AS2 (add%L0,%1,%0);\n-\t}\n-      else\n-        {\n-          CC_STATUS_INIT;\n-\n-\t  if (operands[1] == stack_pointer_rtx)\n-\t    {\n-\t      output_asm_insn (AS2 (mov%L0,%1,%0), operands);\n-\t      operands[1] = operands[0];\n-\t    }\n-          operands[1] = gen_rtx_MULT (SImode, operands[1],\n-\t\t\t\t      GEN_INT (1 << INTVAL (operands[2])));\n-\t  return AS2 (lea%L0,%a1,%0);\n-\t}\n-    }\n-\n-  if (REG_P (operands[2]))\n-    return AS2 (sal%L0,%b2,%0);\n-\n-  if (REG_P (operands[0]) && operands[2] == const1_rtx)\n-    return AS2 (add%L0,%0,%0);\n-\n-  return AS2 (sal%L0,%2,%0);\n-}\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"cI\")))]\n+  \"\"\n+  \"* return output_ashlsi3 (operands);\")\n \n (define_insn \"ashlhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")"}]}