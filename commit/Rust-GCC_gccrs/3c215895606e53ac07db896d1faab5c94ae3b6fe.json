{"sha": "3c215895606e53ac07db896d1faab5c94ae3b6fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyMTU4OTU2MDZlNTNhYzA3ZGI4OTZkMWZhYWI1Yzk0YWUzYjZmZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-03T22:27:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-03T22:27:04Z"}, "message": "cvt.c, [...]: Clean up more old overloading code, old RTTI code, and some formatting quirks.\n\n\t* cvt.c, decl.c, decl2.c, init.c, rtti.c, typeck.c, typeck2.c,\n\tcp-tree.h: Clean up more old overloading code, old RTTI code, and\n\tsome formatting quirks.\n\nFrom-SVN: r18391", "tree": {"sha": "53a3f9f471c6c09b1a34eab74943753b2d160b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53a3f9f471c6c09b1a34eab74943753b2d160b26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c215895606e53ac07db896d1faab5c94ae3b6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c215895606e53ac07db896d1faab5c94ae3b6fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c215895606e53ac07db896d1faab5c94ae3b6fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c215895606e53ac07db896d1faab5c94ae3b6fe/comments", "author": null, "committer": null, "parents": [{"sha": "de7987a645e310ed5701e693ccbbc8d25179686b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de7987a645e310ed5701e693ccbbc8d25179686b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de7987a645e310ed5701e693ccbbc8d25179686b"}], "stats": {"total": 1156, "additions": 172, "deletions": 984}, "files": [{"sha": "93a2527a31405c3bcad83636b4c42cb91b8f7341", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -2084,7 +2084,6 @@ extern tree convert\t\t\t\tPROTO((tree, tree));\n extern tree convert_force\t\t\tPROTO((tree, tree, int));\n extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n-extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern tree type_promotes_to\t\t\tPROTO((tree));\n extern tree perform_qualification_conversions   PROTO((tree, tree));\n "}, {"sha": "6cd62297d87ef350bcf9d6ffe9f414b64ecef14e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 29, "deletions": 273, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -38,8 +38,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern tree static_aggregates;\n \n-static tree build_thunk PROTO((tree, tree));\n-static tree convert_fn_ptr PROTO((tree, tree));\n static tree cp_convert_to_pointer PROTO((tree, tree));\n static tree convert_to_pointer_force PROTO((tree, tree));\n static tree build_up_reference PROTO((tree, tree, int, int));\n@@ -68,60 +66,6 @@ static tree build_type_conversion_1 PROTO((tree, tree, tree, tree,\n \f\n /* Subroutines of `convert'.  */\n \n-/* Build a thunk.  What it is, is an entry point that when called will\n-   adjust the this pointer (the first argument) by offset, and then\n-   goto the real address of the function given by REAL_ADDR that we\n-   would like called.  What we return is the address of the thunk.  */\n-\n-static tree\n-build_thunk (offset, real_addr)\n-     tree offset, real_addr;\n-{\n-  if (TREE_CODE (real_addr) != ADDR_EXPR\n-      || TREE_CODE (TREE_OPERAND (real_addr, 0)) != FUNCTION_DECL)\n-    {\n-      sorry (\"MI pointer to member conversion too complex\");\n-      return error_mark_node;\n-    }\n-  sorry (\"MI pointer to member conversion too complex\");\n-  return error_mark_node;\n-}\n-\n-/* Convert a `pointer to member' (POINTER_TYPE to METHOD_TYPE) into\n-   another `pointer to method'.  This may involved the creation of\n-   a thunk to handle the this offset calculation.  */\n-\n-static tree\n-convert_fn_ptr (type, expr)\n-     tree type, expr;\n-{\n-#if 0\t\t\t\t/* We don't use thunks for pmfs.  */\n-  if (flag_vtable_thunks)\n-    {\n-      tree intype = TREE_TYPE (expr);\n-      tree binfo = get_binfo (TYPE_METHOD_BASETYPE (TREE_TYPE (intype)),\n-\t\t\t      TYPE_METHOD_BASETYPE (TREE_TYPE (type)), 1);\n-      if (binfo == error_mark_node)\n-\t{\n-\t  error (\"  in pointer to member conversion\");\n-\t  return error_mark_node;\n-\t}\n-      if (binfo == NULL_TREE)\n-\t{\n-\t  /* ARM 4.8 restriction.  */\n-\t  error (\"invalid pointer to member conversion\");\n-\t  return error_mark_node;\n-\t}\n-\n-      if (BINFO_OFFSET_ZEROP (binfo))\n-\treturn build1 (NOP_EXPR, type, expr);\n-      return build1 (NOP_EXPR, type, build_thunk (BINFO_OFFSET (binfo), expr));\n-    }\n-  else\n-#endif\n-    return build_ptrmemfunc (type, expr, 1);\n-}\n-\n /* if converting pointer to pointer\n      if dealing with classes, check for derived->base or vice versa\n      else if dealing with method pointers, delegate\n@@ -239,17 +183,19 @@ cp_convert_to_pointer (type, expr)\n \t\t  tree path;\n \n \t\t  if (code == PLUS_EXPR)\n-\t\t    get_base_distance (TREE_TYPE (type), TREE_TYPE (intype), 0, &path);\n+\t\t    get_base_distance (TREE_TYPE (type), TREE_TYPE (intype),\n+\t\t\t\t       0, &path);\n \t\t  else\n-\t\t    get_base_distance (TREE_TYPE (intype), TREE_TYPE (type), 0, &path);\n+\t\t    get_base_distance (TREE_TYPE (intype), TREE_TYPE (type),\n+\t\t\t\t       0, &path);\n \t\t  return build_vbase_path (code, type, expr, path, 0);\n \t\t}\n \t    }\n \t}\n       if (TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE\n \t  && TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n-\treturn convert_fn_ptr (type, expr);\n+\treturn build_ptrmemfunc (type, expr, 1);\n \n       if (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n \t  && TREE_CODE (TREE_TYPE (intype)) == OFFSET_TYPE)\n@@ -548,7 +494,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  \n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n       if (rval != error_mark_node)\n-\trval = convert_force (build_pointer_type (TREE_TYPE (reftype)), rval, 0);\n+\trval = convert_force (build_pointer_type (TREE_TYPE (reftype)),\n+\t\t\t      rval, 0);\n       if (rval != error_mark_node)\n \trval = build1 (NOP_EXPR, reftype, rval);\n     }\n@@ -1033,230 +980,39 @@ build_expr_type_conversion (desires, expr, complain)\n      int complain;\n {\n   tree basetype = TREE_TYPE (expr);\n-  tree conv;\n-  tree winner = NULL_TREE;\n \n   if (TREE_CODE (basetype) == OFFSET_TYPE)\n     expr = resolve_offset_ref (expr);\n   expr = convert_from_reference (expr);\n   basetype = TREE_TYPE (expr);\n \n-  if (! IS_AGGR_TYPE (basetype))\n-    switch (TREE_CODE (basetype))\n-      {\n-      case INTEGER_TYPE:\n-\tif ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n-\t    && integer_zerop (expr))\n-\t  return expr;\n-\t/* else fall through...  */\n-\n-      case BOOLEAN_TYPE:\n-\treturn (desires & WANT_INT) ? expr : NULL_TREE;\n-      case ENUMERAL_TYPE:\n-\treturn (desires & WANT_ENUM) ? expr : NULL_TREE;\n-      case REAL_TYPE:\n-\treturn (desires & WANT_FLOAT) ? expr : NULL_TREE;\n-      case POINTER_TYPE:\n-\treturn (desires & WANT_POINTER) ? expr : NULL_TREE;\n-\t\n-      case FUNCTION_TYPE:\n-      case ARRAY_TYPE:\n-\treturn (desires & WANT_POINTER) ? default_conversion (expr)\n-     \t                                : NULL_TREE;\n-      default:\n-\treturn NULL_TREE;\n-      }\n-\n-  if (! TYPE_HAS_CONVERSION (basetype))\n-    return NULL_TREE;\n-\n-  for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n+  switch (TREE_CODE (basetype))\n     {\n-      int win = 0;\n-      tree candidate;\n-      tree cand = TREE_VALUE (conv);\n-\n-      if (winner && winner == cand)\n-\tcontinue;\n-\n-      candidate = TREE_TYPE (TREE_TYPE (cand));\n-      if (TREE_CODE (candidate) == REFERENCE_TYPE)\n-\tcandidate = TREE_TYPE (candidate);\n-\n-      switch (TREE_CODE (candidate))\n-\t{\n-\tcase BOOLEAN_TYPE:\n-\tcase INTEGER_TYPE:\n-\t  win = (desires & WANT_INT); break;\n-\tcase ENUMERAL_TYPE:\n-\t  win = (desires & WANT_ENUM); break;\n-\tcase REAL_TYPE:\n-\t  win = (desires & WANT_FLOAT); break;\n-\tcase POINTER_TYPE:\n-\t  win = (desires & WANT_POINTER); break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      if (win)\n-\t{\n-\t  if (winner)\n-\t    {\n-\t      if (complain)\n-\t\t{\n-\t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n-\t\t\t    basetype);\n-\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n-\t\t\t    winner, cand);\n-\t\t}\n-\t      return error_mark_node;\n-\t    }\n-\t  else\n-\t    winner = cand;\n-\t}\n-    }\n-\n-  if (winner)\n-    {\n-      tree type = TREE_TYPE (TREE_TYPE (winner));\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\ttype = TREE_TYPE (type);\n-      return build_type_conversion_1 (type, basetype, expr,\n-\t\t\t\t      DECL_NAME (winner), 1);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Must convert two aggregate types to non-aggregate type.\n-   Attempts to find a non-ambiguous, \"best\" type conversion.\n-\n-   Return 1 on success, 0 on failure.\n-\n-   @@ What are the real semantics of this supposed to be??? */\n-\n-int\n-build_default_binary_type_conversion (code, arg1, arg2)\n-     enum tree_code code;\n-     tree *arg1, *arg2;\n-{\n-  switch (code)\n-    {\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-      *arg1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n-      *arg2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n-      break;\n-\n-    case TRUNC_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case BIT_AND_EXPR:\n-    case BIT_XOR_EXPR:\n-    case BIT_IOR_EXPR:\n-      *arg1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, *arg1, 0);\n-      *arg2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, *arg2, 0);\n-      break;\n-\n-    case PLUS_EXPR:\n-      {\n-\ttree a1, a2, p1, p2;\n-\tint wins;\n-\n-\ta1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n-\ta2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n-\tp1 = build_expr_type_conversion (WANT_POINTER, *arg1, 0);\n-\tp2 = build_expr_type_conversion (WANT_POINTER, *arg2, 0);\n-\n-\twins = (a1 && a2) + (a1 && p2) + (p1 && a2);\n-\n-\tif (wins > 1)\n-\t  error (\"ambiguous default type conversion for `operator +'\");\n-\n-\tif (a1 && a2)\n-\t  *arg1 = a1, *arg2 = a2;\n-\telse if (a1 && p2)\n-\t  *arg1 = a1, *arg2 = p2;\n-\telse\n-\t  *arg1 = p1, *arg2 = a2;\n-\tbreak;\n-      }\n-\n-    case MINUS_EXPR:\n-      {\n-\ttree a1, a2, p1, p2;\n-\tint wins;\n-\n-\ta1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n-\ta2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n-\tp1 = build_expr_type_conversion (WANT_POINTER, *arg1, 0);\n-\tp2 = build_expr_type_conversion (WANT_POINTER, *arg2, 0);\n-\n-\twins = (a1 && a2) + (p1 && p2) + (p1 && a2);\n-\n-\tif (wins > 1)\n-\t  error (\"ambiguous default type conversion for `operator -'\");\n-\n-\tif (a1 && a2)\n-\t  *arg1 = a1, *arg2 = a2;\n-\telse if (p1 && p2)\n-\t  *arg1 = p1, *arg2 = p2;\n-\telse\n-\t  *arg1 = p1, *arg2 = a2;\n-\tbreak;\n-      }\n-\n-    case GT_EXPR:\n-    case LT_EXPR:\n-    case GE_EXPR:\n-    case LE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      {\n-\ttree a1, a2, p1, p2;\n-\tint wins;\n-\n-\ta1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n-\ta2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n-\tp1 = build_expr_type_conversion (WANT_POINTER | WANT_NULL, *arg1, 0);\n-\tp2 = build_expr_type_conversion (WANT_POINTER | WANT_NULL, *arg2, 0);\n-\n-\twins = (a1 && a2) + (p1 && p2);\n-\n-\tif (wins > 1)\n-\t  cp_error (\"ambiguous default type conversion for `%O'\", code);\n-\n-\tif (a1 && a2)\n-\t  *arg1 = a1, *arg2 = a2;\n-\telse\n-\t  *arg1 = p1, *arg2 = p2;\n-\tbreak;\n-      }\n-\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-      *arg1 = cp_convert (boolean_type_node, *arg1);\n-      *arg2 = cp_convert (boolean_type_node, *arg2);\n-      break;\n+    case INTEGER_TYPE:\n+      if ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n+\t  && integer_zerop (expr))\n+\treturn expr;\n+      /* else fall through...  */\n+\n+    case BOOLEAN_TYPE:\n+      return (desires & WANT_INT) ? expr : NULL_TREE;\n+    case ENUMERAL_TYPE:\n+      return (desires & WANT_ENUM) ? expr : NULL_TREE;\n+    case REAL_TYPE:\n+      return (desires & WANT_FLOAT) ? expr : NULL_TREE;\n+    case POINTER_TYPE:\n+      return (desires & WANT_POINTER) ? expr : NULL_TREE;\n+\t\n+    case FUNCTION_TYPE:\n+    case ARRAY_TYPE:\n+      return ((desires & WANT_POINTER) ? default_conversion (expr)\n+\t      : NULL_TREE);\n \n     default:\n-      *arg1 = NULL_TREE;\n-      *arg2 = NULL_TREE;\n+      break;\n     }\n \n-  if (*arg1 == error_mark_node || *arg2 == error_mark_node)\n-    cp_error (\"ambiguous default type conversion for `%O'\", code);\n-\n-  if (*arg1 && *arg2)\n-    return 1;\n-\n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Implements integral promotion (4.1) and float->double promotion.  */"}, {"sha": "fdf704c3ec99a4c865a90a12840bb6d698ebd9e7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -5648,122 +5648,6 @@ init_decl_processing ()\n \t\t\t void_type_node);\n   pushdecl (std_node);\n \n-#if 0\n-  if (flag_rtti)\n-    {\n-      /* Must build __t_desc type.  Currently, type descriptors look like this:\n-\n-\t struct __t_desc\n-\t {\n-           const char *name;\n-\t   int size;\n-\t   int bits;\n-\t   struct __t_desc *points_to;\n-\t   int ivars_count, meths_count;\n-\t   struct __i_desc *ivars[];\n-\t   struct __m_desc *meths[];\n-\t   struct __t_desc *parents[];\n-\t   struct __t_desc *vbases[];\n-\t   int offsets[];\n-\t };\n-\n-\t ...as per Linton's paper.  */\n-\n-      __t_desc_type_node = make_lang_type (RECORD_TYPE);\n-      __i_desc_type_node = make_lang_type (RECORD_TYPE);\n-      __m_desc_type_node = make_lang_type (RECORD_TYPE);\n-      __t_desc_array_type\n-\t= build_array_type (build_pointer_type (__t_desc_type_node),\n-\t\t\t    NULL_TREE);\n-      __i_desc_array_type\n-\t= build_array_type (build_pointer_type (__i_desc_type_node),\n-\t\t\t    NULL_TREE);\n-      __m_desc_array_type\n-\t= build_array_type (build_pointer_type (__m_desc_type_node),\n-\t\t\t    NULL_TREE);\n-\n-      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n-\t\t\t\t\t string_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"size\"),\n-\t\t\t\t\t unsigned_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"bits\"),\n-\t\t\t\t\t unsigned_type_node);\n-      fields[3] = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t get_identifier (\"points_to\"),\n-\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n-      fields[4] = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t get_identifier (\"ivars_count\"),\n-\t\t\t\t\t integer_type_node);\n-      fields[5] = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t\t get_identifier (\"meths_count\"),\n-\t\t\t\t\t integer_type_node);\n-      fields[6] = build_lang_field_decl (FIELD_DECL, get_identifier (\"ivars\"),\n-\t\t\t\t\t build_pointer_type (__i_desc_array_type));\n-      fields[7] = build_lang_field_decl (FIELD_DECL, get_identifier (\"meths\"),\n-\t\t\t\t\t build_pointer_type (__m_desc_array_type));\n-      fields[8] = build_lang_field_decl (FIELD_DECL, get_identifier (\"parents\"),\n-\t\t\t\t\t build_pointer_type (__t_desc_array_type));\n-      fields[9] = build_lang_field_decl (FIELD_DECL, get_identifier (\"vbases\"),\n-\t\t\t\t\t build_pointer_type (__t_desc_array_type));\n-      fields[10] = build_lang_field_decl (FIELD_DECL, get_identifier (\"offsets\"),\n-\t\t\t\t\t build_pointer_type (integer_type_node));\n-      finish_builtin_type (__t_desc_type_node, \"__t_desc\", fields, 10, integer_type_node);\n-\n-      /* ivar descriptors look like this:\n-\n-\t struct __i_desc\n-\t {\n-\t   const char *name;\n-\t   int offset;\n-\t   struct __t_desc *type;\n-\t };\n-      */\n-\n-      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n-\t\t\t\t\t string_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"offset\"),\n-\t\t\t\t\t integer_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n-\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n-      finish_builtin_type (__i_desc_type_node, \"__i_desc\", fields, 2,\n-\t\t\t   integer_type_node);\n-\n-      /* method descriptors look like this:\n-\n-\t struct __m_desc\n-\t {\n-\t   const char *name;\n-\t   int vindex;\n-\t   struct __t_desc *vcontext;\n-\t   struct __t_desc *return_type;\n-\t   void (*address)();\n-\t   short parm_count;\n-\t   short required_parms;\n-\t   struct __t_desc *parm_types[];\n-\t };\n-      */\n-\n-      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"name\"),\n-\t\t\t\t\t string_type_node);\n-      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"vindex\"),\n-\t\t\t\t\t integer_type_node);\n-      fields[2] = build_lang_field_decl (FIELD_DECL, get_identifier (\"vcontext\"),\n-\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n-      fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier (\"return_type\"),\n-\t\t\t\t\t build_pointer_type (__t_desc_type_node));\n-      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier (\"address\"),\n-\t\t\t\t\t build_pointer_type (default_function_type));\n-      fields[5] = build_lang_field_decl (FIELD_DECL, get_identifier (\"parm_count\"),\n-\t\t\t\t\t short_integer_type_node);\n-      fields[6] = build_lang_field_decl (FIELD_DECL, get_identifier (\"required_parms\"),\n-\t\t\t\t\t short_integer_type_node);\n-      fields[7] = build_lang_field_decl (FIELD_DECL, get_identifier (\"parm_types\"),\n-\t\t\t\t\t build_pointer_type (build_array_type (build_pointer_type (__t_desc_type_node), NULL_TREE)));\n-      finish_builtin_type (__m_desc_type_node, \"__m_desc\", fields, 7,\n-\t\t\t   integer_type_node);\n-    }\n-#endif /*flag_rtti*/\n-\n   /* Now, C++.  */\n   current_lang_name = lang_name_cplusplus;\n \n@@ -5811,76 +5695,6 @@ init_decl_processing ()\n   using_eh_for_cleanups ();\n }\n \n-/* initialize type descriptor type node of various rtti type.  */\n-\n-int\n-init_type_desc()\n-{\n-  tree tdecl;\n-\n-  tdecl = lookup_name (get_identifier (\"type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __t_desc_type_node = TREE_TYPE (tdecl);\n-#if 0\n-  __tp_desc_type_node = build_pointer_type (__t_desc_type_node);\n-#endif\n-\n-#if 0\n-  tdecl = lookup_name (get_identifier (\"__baselist_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __baselist_desc_type_node = TREE_TYPE (tdecl);\n-#endif\n-\n-  tdecl = lookup_name (get_identifier (\"__builtin_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __bltn_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__user_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __user_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__class_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __class_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_field (__class_desc_type_node, \n-\tget_identifier (\"access_mode\"), 0, 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __access_mode_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__attr_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __attr_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__pointer_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __ptr_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__func_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __func_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__ptmf_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __ptmf_desc_type_node = TREE_TYPE (tdecl);\n-\n-  tdecl = lookup_name (get_identifier (\"__ptmd_type_info\"), 0);\n-  if (tdecl == NULL_TREE)\n-    return 0;\n-  __ptmd_desc_type_node = TREE_TYPE (tdecl);\n-\n-  return 1;\n-}\n /* Make a definition for a builtin function named NAME and whose data type\n    is TYPE.  TYPE should be a function type with argument types.\n    FUNCTION_CODE tells later passes how to compile calls to this function."}, {"sha": "e337b18d01f0adeaebe0a0281bc9aa7463b97978", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 135, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -781,26 +781,6 @@ grok_method_quals (ctype, function, quals)\n   return ctype;\n }\n \n-#if 0\t\t\t\t/* Not used.  */\n-/* This routine replaces cryptic DECL_NAMEs with readable DECL_NAMEs.\n-   It leaves DECL_ASSEMBLER_NAMEs with the correct value.  */\n-/* This does not yet work with user defined conversion operators\n-   It should.  */\n-\n-static void\n-substitute_nice_name (decl)\n-     tree decl;\n-{\n-  if (DECL_NAME (decl) && TREE_CODE (DECL_NAME (decl)) == IDENTIFIER_NODE)\n-    {\n-      char *n = decl_as_string (DECL_NAME (decl), 1);\n-      if (n[strlen (n) - 1] == ' ')\n-\tn[strlen (n) - 1] = 0;\n-      DECL_NAME (decl) = get_identifier (n);\n-    }\n-}\n-#endif\n-\n /* Warn when -fexternal-templates is used and #pragma\n    interface/implementation is not used all the times it should be,\n    inform the user.  */\n@@ -1051,7 +1031,8 @@ grokclassfn (ctype, cname, function, flags, quals)\n       if (IDENTIFIER_TYPE_VALUE (cname))\n \tdbuf = build_overload_name (IDENTIFIER_TYPE_VALUE (cname), 1, 1);\n       else if (IDENTIFIER_LOCAL_VALUE (cname))\n-\tdbuf = build_overload_name (TREE_TYPE (IDENTIFIER_LOCAL_VALUE (cname)), 1, 1);\n+\tdbuf = build_overload_name (TREE_TYPE (IDENTIFIER_LOCAL_VALUE (cname)),\n+\t\t\t\t    1, 1);\n       else\n       /* Using ctype fixes the `X::Y::~Y()' crash.  The cname has no type when\n \t it's defined out of the class definition, since poplevel_class wipes\n@@ -1108,14 +1089,6 @@ grokclassfn (ctype, cname, function, flags, quals)\n       DECL_ASSEMBLER_NAME (function)\n \t= build_decl_overload (fn_name, these_arg_types,\n \t\t\t       1 + DECL_CONSTRUCTOR_P (function));\n-\n-#if 0\n-      /* This code is going into the compiler, but currently, it makes\n-\t libg++/src/Integer.cc not compile.  The problem is that the nice name\n-\t winds up going into the symbol table, and conversion operations look\n-\t for the manged name.  */\n-      substitute_nice_name (function);\n-#endif\n     }\n \n   DECL_ARGUMENTS (function) = last_function_parms;\n@@ -1199,8 +1172,7 @@ grok_array_decl (array_expr, index_exp)\n     type = TREE_TYPE (type);\n \n   /* If they have an `operator[]', use that.  */\n-  if (TYPE_LANG_SPECIFIC (type)\n-      && TYPE_OVERLOADS_ARRAY_REF (complete_type (type)))\n+  if (IS_AGGR_TYPE (type) || IS_AGGR_TYPE (TREE_TYPE (index_exp)))\n     return build_opfncall (ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t   array_expr, index_exp, NULL_TREE);\n \n@@ -1596,7 +1568,8 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (DECL_NAME (value) != NULL_TREE\n       && IDENTIFIER_POINTER (DECL_NAME (value))[0] == '_'\n       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (value)), \"_vptr\"))\n-    cp_error (\"member `%D' conflicts with virtual function table field name\", value);\n+    cp_error (\"member `%D' conflicts with virtual function table field name\",\n+\t      value);\n \n   /* Stash away type declarations.  */\n   if (TREE_CODE (value) == TYPE_DECL)\n@@ -1953,33 +1926,6 @@ grok_function_init (decl, init)\n \t    TYPE_HAS_ABSTRACT_ASSIGN_REF (current_class_type) = 1;\n \t}\n     }\n-  else if (TREE_CODE (init) == OFFSET_REF\n-\t   && TREE_OPERAND (init, 0) == NULL_TREE\n-\t   && TREE_CODE (TREE_TYPE (init)) == METHOD_TYPE)\n-    {\n-      tree basetype = DECL_CLASS_CONTEXT (init);\n-      tree basefn = TREE_OPERAND (init, 1);\n-      if (TREE_CODE (basefn) != FUNCTION_DECL)\n-\tcp_error (\"non-method initializer invalid for method `%D'\", decl);\n-      else if (! BINFO_OFFSET_ZEROP (TYPE_BINFO (DECL_CLASS_CONTEXT (basefn))))\n-\tsorry (\"base member function from other than first base class\");\n-      else\n-\t{\n-\t  tree binfo = get_binfo (basetype, TYPE_METHOD_BASETYPE (type), 1);\n-\t  if (binfo == error_mark_node)\n-\t    ;\n-\t  else if (binfo == 0)\n-\t    error_not_base_type (TYPE_METHOD_BASETYPE (TREE_TYPE (init)),\n-\t\t\t\t TYPE_METHOD_BASETYPE (type));\n-\t  else\n-\t    {\n-\t      /* Mark this function as being defined,\n-\t\t and give it new rtl.  */\n-\t      DECL_INITIAL (decl) = error_mark_node;\n-\t      DECL_RTL (decl) = DECL_RTL (basefn);\n-\t    }\n-\t}\n-    }\n   else\n     cp_error (\"invalid initializer for virtual method `%D'\", decl);\n }\n@@ -2264,82 +2210,6 @@ finish_anon_union (anon_union_decl)\n   expand_anon_union_decl (anon_union_decl, NULL_TREE, elems);\n }\n \n-/* Finish and output a table which is generated by the compiler.\n-   NAME is the name to give the table.\n-   TYPE is the type of the table entry.\n-   INIT is all the elements in the table.\n-   PUBLICP is non-zero if this table should be given external access.  */\n-\n-tree\n-finish_table (name, type, init, publicp)\n-     tree name, type, init;\n-     int publicp;\n-{\n-  tree itype, atype, decl;\n-  static tree empty_table;\n-  int is_empty = 0;\n-  tree asmspec;\n-\n-  itype = build_index_type (size_int (list_length (init) - 1));\n-  atype = build_cplus_array_type (type, itype);\n-  layout_type (atype);\n-\n-  if (TREE_VALUE (init) == integer_zero_node\n-      && TREE_CHAIN (init) == NULL_TREE)\n-    {\n-#if 0\n-      if (empty_table == NULL_TREE)\n-#endif\n-\t{\n-\t  empty_table = get_temp_name (atype, 1);\n-\t  init = build (CONSTRUCTOR, atype, NULL_TREE, init);\n-\t  TREE_CONSTANT (init) = 1;\n-\t  TREE_STATIC (init) = 1;\n-\t  DECL_INITIAL (empty_table) = init;\n-\t  asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (empty_table)),\n-\t\t\t\t  IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n-\t  cp_finish_decl (empty_table, NULL_TREE, asmspec, 0, 0);\n-\t}\n-      is_empty = 1;\n-    }\n-\n-  if (name == NULL_TREE)\n-    {\n-      if (is_empty)\n-\treturn empty_table;\n-      decl = get_temp_name (atype, 1);\n-    }\n-  else\n-    {\n-      decl = build_decl (VAR_DECL, name, atype);\n-      decl = pushdecl (decl);\n-      TREE_STATIC (decl) = 1;\n-    }\n-\n-  if (is_empty == 0)\n-    {\n-      TREE_PUBLIC (decl) = publicp;\n-      init = build (CONSTRUCTOR, atype, NULL_TREE, init);\n-      TREE_CONSTANT (init) = 1;\n-      TREE_STATIC (init) = 1;\n-      DECL_INITIAL (decl) = init;\n-      asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (decl)),\n-\t\t\t      IDENTIFIER_POINTER (DECL_NAME (decl)));\n-    }\n-  else\n-    {\n-      /* This will cause DECL to point to EMPTY_TABLE in rtl-land.  */\n-      DECL_EXTERNAL (decl) = 1;\n-      TREE_STATIC (decl) = 0;\n-      init = 0;\n-      asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (empty_table)),\n-\t\t\t      IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n-    }\n-\n-  cp_finish_decl (decl, NULL_TREE, asmspec, 0, 0);\n-  return decl;\n-}\n-\n /* Finish processing a builtin type TYPE.  It's name is NAME,\n    its fields are in the array FIELDS.  LEN is the number of elements\n    in FIELDS minus one, or put another way, it is the maximum subscript"}, {"sha": "1785142148ea8ba8dbc69bf7e66f5d0a38eb8b96", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -1589,9 +1589,9 @@ build_member_call (type, name, parmlist)\n \t  cp_error (\"invalid use of member `%D'\", t);\n \t  return error_mark_node;\n \t}\n-      if (TYPE_LANG_SPECIFIC (TREE_TYPE (decl))\n-\t  && TYPE_OVERLOADS_CALL_EXPR (TREE_TYPE (decl)))\n-\treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL, decl, parmlist, NULL_TREE);\n+      if (TYPE_LANG_SPECIFIC (TREE_TYPE (decl)))\n+\treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL, decl,\n+\t\t\t       parmlist, NULL_TREE);\n       return build_function_call (decl, parmlist);\n     }\n   else"}, {"sha": "d01077c8c967cde0dc06c7334233e201d8bea27d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -1108,285 +1108,3 @@ synthesize_tinfo_fn (fndecl)\n   c_expand_return (tmp);\n   finish_function (lineno, 0, 0);\n }\n-\n-#if 0\n-/* This is the old dossier type descriptor generation code, it's much\n-   more extended than rtti. It's reserved for later use.  */\n-/* Build an initializer for a __t_desc node.  So that we can take advantage\n-   of recursion, we accept NULL for TYPE.\n-   DEFINITION is greater than zero iff we must define the type descriptor\n-   (as opposed to merely referencing it).  1 means treat according to\n-   #pragma interface/#pragma implementation rules.  2 means define as\n-   global and public, no matter what.  */\n-\n-tree\n-build_t_desc (type, definition)\n-     tree type;\n-     int definition;\n-{\n-  tree tdecl;\n-  tree tname, name_string;\n-  tree elems, fields;\n-  tree parents, vbases, offsets, ivars, methods, target_type;\n-  int method_count = 0, field_count = 0;\n-\n-  if (type == NULL_TREE)\n-    return NULL_TREE;\n-\n-  tname = build_t_desc_overload (type);\n-  if (IDENTIFIER_AS_DESC (tname)\n-      && (!definition || TREE_ASM_WRITTEN (IDENTIFIER_AS_DESC (tname))))\n-    return IDENTIFIER_AS_DESC (tname);\n-\n-  tdecl = lookup_name (tname, 0);\n-  if (tdecl == NULL_TREE)\n-    {\n-      tdecl = build_decl (VAR_DECL, tname, __t_desc_type_node);\n-      DECL_EXTERNAL (tdecl) = 1;\n-      TREE_PUBLIC (tdecl) = 1;\n-      tdecl = pushdecl_top_level (tdecl);\n-    }\n-  /* If we previously defined it, return the defined result.  */\n-  else if (definition && DECL_INITIAL (tdecl))\n-    return IDENTIFIER_AS_DESC (tname);\n-\n-  if (definition)\n-    {\n-      tree taggr = type;\n-      /* Let T* and T& be written only when T is written (if T is an aggr).\n-         We do this for const, but not for volatile, since volatile\n-\t is rare and const is not.  */\n-      if (!TYPE_VOLATILE (taggr)\n-\t  && (TREE_CODE (taggr) == POINTER_TYPE\n-\t      || TREE_CODE (taggr) == REFERENCE_TYPE)\n-\t  && IS_AGGR_TYPE (TREE_TYPE (taggr)))\n-\ttaggr = TREE_TYPE (taggr);\n-\n-      /* If we know that we don't need to write out this type's\n-\t vtable, then don't write out it's dossier.  Somebody\n-\t else will take care of that.  */\n-      if (IS_AGGR_TYPE (taggr) && CLASSTYPE_VFIELD (taggr))\n-\t{\n-\t  if (CLASSTYPE_VTABLE_NEEDS_WRITING (taggr))\n-\t    {\n-\t      TREE_PUBLIC (tdecl) = ! CLASSTYPE_INTERFACE_ONLY (taggr)\n-\t\t&& CLASSTYPE_INTERFACE_KNOWN (taggr);\n-\t      DECL_EXTERNAL (tdecl) = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (write_virtuals != 0)\n-\t\tTREE_PUBLIC (tdecl) = 1;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  DECL_EXTERNAL (tdecl) = 0;\n-\t  TREE_PUBLIC (tdecl) = (definition > 1);\n-\t}\n-    }\n-  SET_IDENTIFIER_AS_DESC (tname, build_unary_op (ADDR_EXPR, tdecl, 0));\n-\n-  if (!definition || DECL_EXTERNAL (tdecl))\n-    {\n-      /* That's it!  */\n-      cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n-      return IDENTIFIER_AS_DESC (tname);\n-    }\n-\n-  /* Show that we are defining the t_desc for this type.  */\n-  DECL_INITIAL (tdecl) = error_mark_node;\n-\n-  parents = build_expr_list (NULL_TREE, integer_zero_node);\n-  vbases = build_expr_list (NULL_TREE, integer_zero_node);\n-  offsets = build_expr_list (NULL_TREE, integer_zero_node);\n-  methods = NULL_TREE;\n-  ivars = NULL_TREE;\n-\n-  if (TYPE_LANG_SPECIFIC (type))\n-    {\n-      int i = CLASSTYPE_N_BASECLASSES (type);\n-      tree method_vec = CLASSTYPE_METHOD_VEC (type);\n-      tree *meth, *end;\n-      tree binfos = TYPE_BINFO_BASETYPES (type);\n-      tree vb = CLASSTYPE_VBASECLASSES (type);\n-\n-      while (--i >= 0)\n-\tparents = tree_cons (NULL_TREE, build_t_desc (BINFO_TYPE (TREE_VEC_ELT (binfos, i)), 0), parents);\n-\n-      while (vb)\n-\t{\n-\t  vbases = tree_cons (NULL_TREE, build_t_desc (BINFO_TYPE (vb), 0), vbases);\n-\t  offsets = tree_cons (NULL_TREE, BINFO_OFFSET (vb), offsets);\n-\t  vb = TREE_CHAIN (vb);\n-\t}\n-\n-      if (method_vec)\n-\tfor (meth = TREE_VEC_END (method_vec),\n-\t     end = &TREE_VEC_ELT (method_vec, 0); meth-- != end; )\n-\t  if (*meth)\n-\t    {\n-\t      methods = tree_cons (NULL_TREE, build_m_desc (*meth), methods);\n-\t      method_count++;\n-\t    }\n-    }\n-\n-  if (IS_AGGR_TYPE (type))\n-    {\n-      for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n-\tif (TREE_CODE (fields) == FIELD_DECL\n-\t    || TREE_CODE (fields) == VAR_DECL)\n-\t  {\n-\t    ivars = tree_cons (NULL_TREE, build_i_desc (fields), ivars);\n-\t    field_count++;\n-\t  }\n-      ivars = nreverse (ivars);\n-    }\n-\n-  parents = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), parents, 0);\n-  vbases = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node), vbases, 0);\n-  offsets = finish_table (NULL_TREE, integer_type_node, offsets, 0);\n-  if (methods == NULL_TREE)\n-    methods = null_pointer_node;\n-  else\n-    methods = build_unary_op (ADDR_EXPR,\n-\t\t\t      finish_table (NULL_TREE, __m_desc_type_node, methods, 0),\n-\t\t\t      0);\n-  if (ivars == NULL_TREE)\n-    ivars = null_pointer_node;\n-  else\n-    ivars = build_unary_op (ADDR_EXPR,\n-\t\t\t    finish_table (NULL_TREE, __i_desc_type_node, ivars, 0),\n-\t\t\t    0);\n-  if (TREE_TYPE (type))\n-    target_type = build_t_desc (TREE_TYPE (type), definition);\n-  else\n-    target_type = integer_zero_node;\n-\n-  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (tname)+1, IDENTIFIER_POINTER (tname)));\n-\n-  elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0),\n-\t   tree_cons (NULL_TREE,\n-\t\t      TYPE_SIZE(type)? size_in_bytes(type) : integer_zero_node,\n-\t     /* really should use bitfield initialization here.  */\n-\t     tree_cons (NULL_TREE, integer_zero_node,\n-\t      tree_cons (NULL_TREE, target_type,\n-\t       tree_cons (NULL_TREE, build_int_2 (field_count, 2),\n-\t\ttree_cons (NULL_TREE, build_int_2 (method_count, 2),\n-\t\t tree_cons (NULL_TREE, ivars,\n-\t\t  tree_cons (NULL_TREE, methods,\n-\t\t   tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, parents, 0),\n-\t\t    tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, vbases, 0),\n-\t\t     build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, offsets, 0))))))))))));\n-  return build_generic_desc (tdecl, elems);\n-}\n-\n-/* Build an initializer for a __i_desc node.  */\n-\n-tree\n-build_i_desc (decl)\n-     tree decl;\n-{\n-  tree elems, name_string;\n-  tree taggr;\n-\n-  name_string = DECL_NAME (decl);\n-  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (name_string)+1, IDENTIFIER_POINTER (name_string)));\n-\n-  /* Now decide whether this ivar should cause it's type to get\n-     def'd or ref'd in this file.  If the type we are looking at\n-     has a proxy definition, we look at the proxy (i.e., a\n-     `foo *' is equivalent to a `foo').  */\n-  taggr = TREE_TYPE (decl);\n-\n-  if ((TREE_CODE (taggr) == POINTER_TYPE\n-       || TREE_CODE (taggr) == REFERENCE_TYPE)\n-      && TYPE_VOLATILE (taggr) == 0)\n-    taggr = TREE_TYPE (taggr);\n-\n-  elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0),\n-\t     tree_cons (NULL_TREE, DECL_FIELD_BITPOS (decl),\n-\t\tbuild_tree_list (NULL_TREE, build_t_desc (TREE_TYPE (decl),\n-\t\t\t\t\t\t\t  ! IS_AGGR_TYPE (taggr)))));\n-  taggr = build (CONSTRUCTOR, __i_desc_type_node, NULL_TREE, elems);\n-  TREE_CONSTANT (taggr) = 1;\n-  TREE_STATIC (taggr) = 1;\n-  TREE_READONLY (taggr) = 1;\n-  return taggr;\n-}\n-\n-/* Build an initializer for a __m_desc node.  */\n-\n-tree\n-build_m_desc (decl)\n-     tree decl;\n-{\n-  tree taggr, elems, name_string;\n-  tree parm_count, req_count, vindex, vcontext;\n-  tree parms;\n-  int p_count, r_count;\n-  tree parm_types = NULL_TREE;\n-\n-  for (parms = TYPE_ARG_TYPES (TREE_TYPE (decl)), p_count = 0, r_count = 0;\n-       parms != NULL_TREE; parms = TREE_CHAIN (parms), p_count++)\n-    {\n-      taggr = TREE_VALUE (parms);\n-      if ((TREE_CODE (taggr) == POINTER_TYPE\n-\t   || TREE_CODE (taggr) == REFERENCE_TYPE)\n-\t  && TYPE_VOLATILE (taggr) == 0)\n-\ttaggr = TREE_TYPE (taggr);\n-\n-      parm_types = tree_cons (NULL_TREE, build_t_desc (TREE_VALUE (parms),\n-\t\t\t\t\t\t       ! IS_AGGR_TYPE (taggr)),\n-\t\t\t      parm_types);\n-      if (TREE_PURPOSE (parms) == NULL_TREE)\n-\tr_count++;\n-    }\n-\n-  parm_types = finish_table (NULL_TREE, build_pointer_type (__t_desc_type_node),\n-\t\t\t     nreverse (parm_types), 0);\n-  parm_count = build_int_2 (p_count, 0);\n-  req_count = build_int_2 (r_count, 0);\n-\n-  if (DECL_VINDEX (decl))\n-    vindex = DECL_VINDEX (decl);\n-  else\n-    vindex = integer_zero_node;\n-  if (DECL_CONTEXT (decl)\n-      && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')\n-    vcontext = build_t_desc (DECL_CONTEXT (decl), 0);\n-  else\n-    vcontext = integer_zero_node;\n-  name_string = DECL_NAME (decl);\n-  if (name_string == NULL)\n-      name_string = DECL_ASSEMBLER_NAME (decl);\n-  name_string = combine_strings (build_string (IDENTIFIER_LENGTH (name_string)+1, IDENTIFIER_POINTER (name_string)));\n-\n-  /* Now decide whether the return type of this mvar\n-     should cause it's type to get def'd or ref'd in this file.\n-     If the type we are looking at has a proxy definition,\n-     we look at the proxy (i.e., a `foo *' is equivalent to a `foo').  */\n-  taggr = TREE_TYPE (TREE_TYPE (decl));\n-\n-  if ((TREE_CODE (taggr) == POINTER_TYPE\n-       || TREE_CODE (taggr) == REFERENCE_TYPE)\n-      && TYPE_VOLATILE (taggr) == 0)\n-    taggr = TREE_TYPE (taggr);\n-\n-  elems = tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, name_string, 0),\n-\t     tree_cons (NULL_TREE, vindex,\n-\t\ttree_cons (NULL_TREE, vcontext,\n-\t\t   tree_cons (NULL_TREE, build_t_desc (TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t\t\t\t       ! IS_AGGR_TYPE (taggr)),\n-\t\t      tree_cons (NULL_TREE, build_c_cast (build_pointer_type (default_function_type), build_unary_op (ADDR_EXPR, decl, 0)),\n-\t\t\t tree_cons (NULL_TREE, parm_count,\n-\t\t\t    tree_cons (NULL_TREE, req_count,\n-\t\t\t       build_tree_list (NULL_TREE, build_unary_op (ADDR_EXPR, parm_types, 0)))))))));\n-\n-  taggr = build (CONSTRUCTOR, __m_desc_type_node, NULL_TREE, elems);\n-  TREE_CONSTANT (taggr) = 1;\n-  TREE_STATIC (taggr) = 1;\n-  TREE_READONLY (taggr) = 1;\n-  return taggr;\n-}\n-#endif /* dossier */"}, {"sha": "137c73520089677f8dca62be867e496f00d53ead", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 132, "deletions": 102, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -570,10 +570,13 @@ common_type (t1, t2)\n \t  /* If this was a member function type, get back to the\n \t     original type of type member function (i.e., without\n \t     the class instance variable up front.  */\n-\t  t1 = build_function_type (TREE_TYPE (t1), TREE_CHAIN (TYPE_ARG_TYPES (t1)));\n-\t  t2 = build_function_type (TREE_TYPE (t2), TREE_CHAIN (TYPE_ARG_TYPES (t2)));\n+\t  t1 = build_function_type (TREE_TYPE (t1),\n+\t\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t1)));\n+\t  t2 = build_function_type (TREE_TYPE (t2),\n+\t\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t2)));\n \t  t3 = common_type (t1, t2);\n-\t  t3 = build_cplus_method_type (basetype, TREE_TYPE (t3), TYPE_ARG_TYPES (t3));\n+\t  t3 = build_cplus_method_type (basetype, TREE_TYPE (t3),\n+\t\t\t\t\tTYPE_ARG_TYPES (t3));\n \t  t1 = build_exception_variant (t3, raises);\n \t}\n       else\n@@ -958,7 +961,8 @@ comp_target_types (ttl, ttr, nptrs)\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     {\n       if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n-\tswitch (comp_target_parms (TYPE_ARG_TYPES (ttl), TYPE_ARG_TYPES (ttr), 1))\n+\tswitch (comp_target_parms (TYPE_ARG_TYPES (ttl),\n+\t\t\t\t   TYPE_ARG_TYPES (ttr), 1))\n \t  {\n \t  case 0:\n \t    return 0;\n@@ -978,9 +982,11 @@ comp_target_types (ttl, ttr, nptrs)\n       /* Contravariance: we can assign a pointer to base member to a pointer\n \t to derived member.  Note difference from simple pointer case, where\n \t we can pass a pointer to derived to a pointer to base.  */\n-      if (comptypes (TYPE_OFFSET_BASETYPE (ttr), TYPE_OFFSET_BASETYPE (ttl), 0))\n+      if (comptypes (TYPE_OFFSET_BASETYPE (ttr),\n+\t\t     TYPE_OFFSET_BASETYPE (ttl), 0))\n \treturn comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n-      else if (comptypes (TYPE_OFFSET_BASETYPE (ttl), TYPE_OFFSET_BASETYPE (ttr), 0)\n+      else if (comptypes (TYPE_OFFSET_BASETYPE (ttl),\n+\t\t\t  TYPE_OFFSET_BASETYPE (ttr), 0)\n \t       && comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs))\n \treturn -1;\n     }\n@@ -1150,7 +1156,8 @@ comp_target_parms (parms1, parms2, strict)\n \tcontinue;\n \n       if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n-\t  || (TREE_CODE (p1) == REFERENCE_TYPE && TREE_CODE (p2) == REFERENCE_TYPE))\n+\t  || (TREE_CODE (p1) == REFERENCE_TYPE\n+\t      && TREE_CODE (p2) == REFERENCE_TYPE))\n \t{\n \t  if (strict <= 0\n \t      && (TYPE_MAIN_VARIANT (TREE_TYPE (p1))\n@@ -1571,7 +1578,8 @@ decay_conversion (exp)\n \t  if (TREE_CODE (TREE_TYPE (inner)) == REFERENCE_TYPE)\n \t    {\n \t      inner = build1 (CONVERT_EXPR,\n-\t\t\t      build_pointer_type (TREE_TYPE (TREE_TYPE (inner))),\n+\t\t\t      build_pointer_type (TREE_TYPE\n+\t\t\t\t\t\t  (TREE_TYPE (inner))),\n \t\t\t      inner);\n \t      TREE_CONSTANT (inner) = TREE_CONSTANT (TREE_OPERAND (inner, 0));\n \t    }\n@@ -1604,8 +1612,8 @@ decay_conversion (exp)\n       if (TYPE_READONLY (type) || TYPE_VOLATILE (type)\n \t  || constp || volatilep)\n \trestype = cp_build_type_variant (restype,\n-\t\t\t\t\tTYPE_READONLY (type) || constp,\n-\t\t\t\t\tTYPE_VOLATILE (type) || volatilep);\n+\t\t\t\t\t TYPE_READONLY (type) || constp,\n+\t\t\t\t\t TYPE_VOLATILE (type) || volatilep);\n       ptrtype = build_pointer_type (restype);\n \n       if (TREE_CODE (exp) == VAR_DECL)\n@@ -1932,10 +1940,12 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t  tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n \t\t\t  tree fntype = TREE_TYPE (fndecl);\n \n-\t\t\t  addr = convert_pointer_to (DECL_CONTEXT (fndecl), addr);\n+\t\t\t  addr = convert_pointer_to (DECL_CONTEXT (fndecl),\n+\t\t\t\t\t\t     addr);\n \t\t\t  datum = build_indirect_ref (addr, NULL_PTR);\n \t\t\t  my_friendly_assert (datum != error_mark_node, 310);\n-\t\t\t  fndecl = build_vfn_ref (&addr, datum, DECL_VINDEX (fndecl));\n+\t\t\t  fndecl = build_vfn_ref (&addr, datum,\n+\t\t\t\t\t\t  DECL_VINDEX (fndecl));\n \t\t\t  /* The type of fndecl is a function type,\n \t\t\t     not a pointer-to-function type, since\n \t\t\t     build_vfn_ref returns not the correct\n@@ -1945,7 +1955,8 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t}\n \t\t      else\n \t\t\tmark_used (fndecl);\n-\t\t      return build (OFFSET_REF, TREE_TYPE (fndecl), datum, fndecl);\n+\t\t      return build (OFFSET_REF, TREE_TYPE (fndecl),\n+\t\t\t\t    datum, fndecl);\n \t\t    }\n \t\t  if (access == access_protected_node)\n \t\t    cp_error (\"member function `%D' is protected\", fndecl);\n@@ -2079,7 +2090,8 @@ build_x_indirect_ref (ptr, errorstring)\n   if (processing_template_decl)\n     return build_min_nt (INDIRECT_REF, ptr);\n \n-  rval = build_opfncall (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE, NULL_TREE);\n+  rval = build_opfncall (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE,\n+\t\t\t NULL_TREE);\n   if (rval)\n     return rval;\n   return build_indirect_ref (ptr, errorstring);\n@@ -2102,17 +2114,6 @@ build_indirect_ref (ptr, errorstring)\n   if (ptr == current_class_ptr)\n     return current_class_ref;\n \n-  if (IS_AGGR_TYPE (type))\n-    {\n-      ptr = build_expr_type_conversion (WANT_POINTER, pointer, 1);\n-\n-      if (ptr)\n-\t{\n-\t  pointer = ptr;\n-\t  type = TREE_TYPE (pointer);\n-\t}\n-    }\n-\n   if (TREE_CODE (type) == POINTER_TYPE || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (TREE_CODE (pointer) == ADDR_EXPR\n@@ -2135,7 +2136,8 @@ build_indirect_ref (ptr, errorstring)\n \t     to assign to.  Also, &* is supposed to be a no-op.  */\n \t  TREE_READONLY (ref) = TYPE_READONLY (t);\n \t  TREE_SIDE_EFFECTS (ref)\n-\t    = TYPE_VOLATILE (t) || TREE_SIDE_EFFECTS (pointer) || flag_volatile;\n+\t    = (TYPE_VOLATILE (t) || TREE_SIDE_EFFECTS (pointer)\n+\t       || flag_volatile);\n \t  TREE_THIS_VOLATILE (ref) = TYPE_VOLATILE (t);\n \t  return ref;\n \t}\n@@ -2214,7 +2216,8 @@ build_array_ref (array, idx)\n \t Likewise an array of elements of variable size.  */\n       if (TREE_CODE (idx) != INTEGER_CST\n \t  || (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array))) != 0\n-\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array)))) != INTEGER_CST))\n+\t      && (TREE_CODE (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array))))\n+\t\t  != INTEGER_CST)))\n \t{\n \t  if (mark_addressable (array) == 0)\n \t    return error_mark_node;\n@@ -2292,7 +2295,8 @@ build_array_ref (array, idx)\n \treturn error_mark_node;\n       }\n \n-    return build_indirect_ref (build_binary_op_nodefault (PLUS_EXPR, ar, ind, PLUS_EXPR),\n+    return build_indirect_ref (build_binary_op_nodefault (PLUS_EXPR, ar,\n+\t\t\t\t\t\t\t  ind, PLUS_EXPR),\n \t\t\t       \"array indexing\");\n   }\n }\n@@ -2357,12 +2361,14 @@ build_x_function_call (function, params, decl)\n       function = TREE_VALUE (function);\n       my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 999);\n       function = DECL_NAME (function);\n-      return build_method_call (decl, function, params, TYPE_BINFO (type), LOOKUP_NORMAL);\n+      return build_method_call (decl, function, params,\n+\t\t\t\tTYPE_BINFO (type), LOOKUP_NORMAL);\n     }\n     \n   is_method = ((TREE_CODE (function) == TREE_LIST\n \t\t&& current_class_type != NULL_TREE\n-\t\t&& IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (function)) == function)\n+\t\t&& (IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (function))\n+\t\t    == function))\n \t       || TREE_CODE (function) == IDENTIFIER_NODE\n \t       || TREE_CODE (type) == METHOD_TYPE\n \t       || TYPE_PTRMEMFUNC_P (type));\n@@ -2395,7 +2401,8 @@ build_x_function_call (function, params, decl)\n \t}\n       else if (TREE_CODE (function) == TREE_LIST)\n \t{\n-\t  my_friendly_assert (TREE_CODE (TREE_VALUE (function)) == FUNCTION_DECL, 312);\n+\t  my_friendly_assert (TREE_CODE (TREE_VALUE (function))\n+\t\t\t      == FUNCTION_DECL, 312);\n \t  basetype = DECL_CLASS_CONTEXT (TREE_VALUE (function));\n \t  function = TREE_PURPOSE (function);\n \t}\n@@ -2416,7 +2423,8 @@ build_x_function_call (function, params, decl)\n \t  if (TREE_CODE (TREE_TYPE (function)) != POINTER_TYPE\n \t      && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (function))\n \t      && TREE_CODE (function) != OFFSET_REF)\n-\t    function = build (OFFSET_REF, TREE_TYPE (type), NULL_TREE, function);\n+\t    function = build (OFFSET_REF, TREE_TYPE (type), NULL_TREE,\n+\t\t\t      function);\n \t  goto do_x_function;\n \t}\n \n@@ -2519,7 +2527,8 @@ build_x_function_call (function, params, decl)\n \t passed in as an argument.  */\n       else if (TYPE_PTRMEMFUNC_P (fntype))\n \t{\n-\t  tree rec = TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (fntype)));\n+\t  tree rec = TYPE_METHOD_BASETYPE (TREE_TYPE\n+\t\t\t\t\t   (TYPE_PTRMEMFUNC_FN_TYPE (fntype)));\n \t  ctypeptr = build_pointer_type (rec);\n \t}\n       /* Unexpected node type?  */\n@@ -2587,7 +2596,8 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t\t\t\t\t     NULL_TREE, 0)));\n       e1 = build_binary_op (GT_EXPR, idx, integer_zero_node, 1);\n       delta = cp_convert (ptrdiff_type_node,\n-\t\t\t  build_component_ref (function, delta_identifier, NULL_TREE, 0));\n+\t\t\t  build_component_ref (function, delta_identifier,\n+\t\t\t\t\t       NULL_TREE, 0));\n       delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n \n       /* Convert down to the right base, before using the instance.  */\n@@ -2610,9 +2620,13 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t{\n \t  aref = save_expr (aref);\n \n-\t  delta = build_binary_op (PLUS_EXPR,\n-\t\t\t\t   build_conditional_expr (e1, build_component_ref (aref, delta_identifier, NULL_TREE, 0), integer_zero_node),\n-\t\t\t\t   delta, 1);\n+\t  delta = build_binary_op\n+\t    (PLUS_EXPR,\n+\t     build_conditional_expr (e1, build_component_ref (aref,\n+\t\t\t\t\t\t\t      delta_identifier,\n+\t\t\t\t\t\t\t      NULL_TREE, 0),\n+\t\t\t\t     integer_zero_node),\n+\t     delta, 1);\n \t}\n \n       *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n@@ -2666,7 +2680,8 @@ build_function_call_real (function, params, require_complete, flags)\n \n       GNU_xref_call (current_function_decl,\n \t\t     IDENTIFIER_POINTER (name ? name\n-\t\t\t\t\t : TYPE_IDENTIFIER (DECL_CLASS_CONTEXT (function))));\n+\t\t\t\t\t : TYPE_IDENTIFIER (DECL_CLASS_CONTEXT\n+\t\t\t\t\t\t\t    (function))));\n       mark_used (function);\n       fndecl = function;\n \n@@ -2936,7 +2951,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n #ifdef PROMOTE_PROTOTYPES\n \t      if ((TREE_CODE (type) == INTEGER_TYPE\n \t\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\t\t  && (TYPE_PRECISION (type)\n+\t\t      < TYPE_PRECISION (integer_type_node)))\n \t\tparmval = default_conversion (parmval);\n #endif\n \t    }\n@@ -2955,7 +2971,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      && (TYPE_PRECISION (TREE_TYPE (val))\n \t\t  < TYPE_PRECISION (double_type_node)))\n \t    /* Convert `float' to `double'.  */\n-\t    result = expr_tree_cons (NULL_TREE, cp_convert (double_type_node, val), result);\n+\t    result = expr_tree_cons (NULL_TREE,\n+\t\t\t\t     cp_convert (double_type_node, val),\n+\t\t\t\t     result);\n \t  else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n \t\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n \t    {\n@@ -2965,7 +2983,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    }\n \t  else\n \t    /* Convert `short' and `char' to full-size `int'.  */\n-\t    result = expr_tree_cons (NULL_TREE, default_conversion (val), result);\n+\t    result = expr_tree_cons (NULL_TREE, default_conversion (val),\n+\t\t\t\t     result);\n \t}\n \n       if (typetail)\n@@ -2988,21 +3007,26 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      else if (TREE_CODE (val) == CONSTRUCTOR)\n \t\t{\n \t\t  parmval = digest_init (type, val, (tree *)0);\n-\t\t  parmval = convert_for_initialization (return_loc, type, parmval, flags,\n-\t\t\t\t\t\t\t\"default constructor\", fndecl, i);\n+\t\t  parmval = convert_for_initialization (return_loc, type,\n+\t\t\t\t\t\t\tparmval, flags,\n+\t\t\t\t\t\t\t\"default constructor\",\n+\t\t\t\t\t\t\tfndecl, i);\n \t\t}\n \t      else\n \t\t{\n \t\t  /* This could get clobbered by the following call.  */\n \t\t  if (TREE_HAS_CONSTRUCTOR (val))\n \t\t    val = copy_node (val);\n \n-\t\t  parmval = convert_for_initialization (return_loc, type, val, flags,\n-\t\t\t\t\t\t\t\"default argument\", fndecl, i);\n+\t\t  parmval = convert_for_initialization (return_loc, type,\n+\t\t\t\t\t\t\tval, flags,\n+\t\t\t\t\t\t\t\"default argument\",\n+\t\t\t\t\t\t\tfndecl, i);\n #ifdef PROMOTE_PROTOTYPES\n \t\t  if ((TREE_CODE (type) == INTEGER_TYPE\n \t\t       || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t      && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\t\t      && (TYPE_PRECISION (type)\n+\t\t\t  < TYPE_PRECISION (integer_type_node)))\n \t\t    parmval = default_conversion (parmval);\n #endif\n \t\t}\n@@ -3087,15 +3111,7 @@ build_binary_op (code, arg1, arg2, convert_p)\n \t}\n \n       if (IS_AGGR_TYPE (type0) || IS_AGGR_TYPE (type1))\n-\t{\n-\t  /* Try to convert this to something reasonable.  */\n-\t  if (! build_default_binary_type_conversion(code, &args[0], &args[1]))\n-\t    {\n-\t      cp_error (\"no match for `%O(%#T, %#T)'\", code,\n-\t\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n-\t      return error_mark_node;\n-\t    }\n-\t}\n+\tmy_friendly_abort (754867);\n     }\n   return build_binary_op_nodefault (code, args[0], args[1], code);\n }\n@@ -3279,7 +3295,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t in the short type, making the entire operation go away.  */\n       if (TREE_CODE (op0) == INTEGER_CST\n \t  && TREE_CODE (op1) == NOP_EXPR\n-\t  && TYPE_PRECISION (type1) > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op1, 0)))\n+\t  && (TYPE_PRECISION (type1)\n+\t      > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op1, 0))))\n \t  && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op1, 0))))\n \t{\n \t  final_type = result_type;\n@@ -3288,7 +3305,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t}\n       if (TREE_CODE (op1) == INTEGER_CST\n \t  && TREE_CODE (op0) == NOP_EXPR\n-\t  && TYPE_PRECISION (type0) > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t  && (TYPE_PRECISION (type0)\n+\t      > TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t  && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t{\n \t  final_type = result_type;\n@@ -3478,18 +3496,23 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t   && ((op1.index != -1 && op0.delta2 == op1.delta2)\n \t       || op0.pfn == op1.pfn)) */\n \n-\t  tree index0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n-\t  tree index1 = save_expr (build_component_ref (op1, index_identifier, NULL_TREE, 0));\n+\t  tree index0 = build_component_ref (op0, index_identifier,\n+\t\t\t\t\t     NULL_TREE, 0);\n+\t  tree index1 = save_expr (build_component_ref (op1, index_identifier,\n+\t\t\t\t\t\t\tNULL_TREE, 0));\n \t  tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n \t  tree pfn1 = PFN_FROM_PTRMEMFUNC (op1);\n \t  tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n \t  tree delta21 = DELTA2_FROM_PTRMEMFUNC (op1);\n \t  tree e1, e2, e3;\n \t  tree integer_neg_one_node\n-\t    = build_binary_op (MINUS_EXPR, integer_zero_node, integer_one_node, 1);\n+\t    = build_binary_op (MINUS_EXPR, integer_zero_node,\n+\t\t\t       integer_one_node, 1);\n \t  e1 = build_binary_op (EQ_EXPR, index0, index1, 1);\n \t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node, 1);\n-\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2, build_binary_op (EQ_EXPR, delta20, delta21, 1), 1);\n+\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n+\t\t\t\tbuild_binary_op (EQ_EXPR, delta20, delta21, 1),\n+\t\t\t\t1);\n \t  e3 = build_binary_op (EQ_EXPR, pfn0, pfn1, 1);\n \t  e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3, 1);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2, 1);\n@@ -3500,7 +3523,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       else if (TYPE_PTRMEMFUNC_P (type0)\n \t       && TYPE_PTRMEMFUNC_FN_TYPE (type0) == type1)\n \t{\n-\t  tree index0 = build_component_ref (op0, index_identifier, NULL_TREE, 0);\n+\t  tree index0 = build_component_ref (op0, index_identifier,\n+\t\t\t\t\t     NULL_TREE, 0);\n \t  tree index1;\n \t  tree pfn0 = PFN_FROM_PTRMEMFUNC (op0);\n \t  tree delta20 = DELTA2_FROM_PTRMEMFUNC (op0);\n@@ -3511,26 +3535,32 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  if (TREE_CODE (TREE_OPERAND (op1, 0)) == FUNCTION_DECL\n \t      && DECL_VINDEX (TREE_OPERAND (op1, 0)))\n \t    {\n-\t      /* Map everything down one to make room for the null pointer to member.  */\n+\t      /* Map everything down one to make room for\n+\t\t the null pointer to member.  */\n \t      index1 = size_binop (PLUS_EXPR,\n \t\t\t\t   DECL_VINDEX (TREE_OPERAND (op1, 0)),\n \t\t\t\t   integer_one_node);\n \t      op1 = integer_zero_node;\n-\t      delta21 = CLASSTYPE_VFIELD (TYPE_METHOD_BASETYPE (TREE_TYPE (type1)));\n+\t      delta21 = CLASSTYPE_VFIELD (TYPE_METHOD_BASETYPE\n+\t\t\t\t\t  (TREE_TYPE (type1)));\n \t      delta21 = DECL_FIELD_BITPOS (delta21);\n-\t      delta21 = size_binop (FLOOR_DIV_EXPR, delta21, size_int (BITS_PER_UNIT));\n+\t      delta21 = size_binop (FLOOR_DIV_EXPR, delta21,\n+\t\t\t\t    size_int (BITS_PER_UNIT));\n \t      delta21 = convert (sizetype, delta21);\n \t    }\n \t  else\n \t    index1 = integer_neg_one_node;\n \t  {\n-\t    tree nop1 = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type0), op1);\n+\t    tree nop1 = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type0),\n+\t\t\t\top1);\n \t    TREE_CONSTANT (nop1) = TREE_CONSTANT (op1);\n \t    op1 = nop1;\n \t  }\n \t  e1 = build_binary_op (EQ_EXPR, index0, index1, 1);\n \t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node, 1);\n-\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2, build_binary_op (EQ_EXPR, delta20, delta21, 1), 1);\n+\t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n+\t\t\t\tbuild_binary_op (EQ_EXPR, delta20, delta21, 1),\n+\t\t\t\t1);\n \t  e3 = build_binary_op (EQ_EXPR, pfn0, op1, 1);\n \t  e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3, 1);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2, 1);\n@@ -3665,7 +3695,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t      && (unsigned0 || !uns))\n \t    result_type\n \t      = signed_or_unsigned_type (unsigned0,\n-\t\t\t\t\t common_type (TREE_TYPE (arg0), TREE_TYPE (arg1)));\n+\t\t\t\t\t common_type (TREE_TYPE (arg0),\n+\t\t\t\t\t\t      TREE_TYPE (arg1)));\n \t  else if (TREE_CODE (arg0) == INTEGER_CST\n \t\t   && (unsigned1 || !uns)\n \t\t   && (TYPE_PRECISION (TREE_TYPE (arg1))\n@@ -3790,9 +3821,11 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t     not use the most significant bit of result_type.  */\n \t  else if ((resultcode == EQ_EXPR || resultcode == NE_EXPR)\n \t\t   && ((op0_signed && TREE_CODE (orig_op1) == INTEGER_CST\n-\t\t\t&& int_fits_type_p (orig_op1, signed_type (result_type))\n+\t\t\t&& int_fits_type_p (orig_op1,\n+\t\t\t\t\t    signed_type (result_type))\n \t\t\t|| (op1_signed && TREE_CODE (orig_op0) == INTEGER_CST\n-\t\t\t    && int_fits_type_p (orig_op0, signed_type (result_type))))))\n+\t\t\t    && int_fits_type_p (orig_op0,\n+\t\t\t\t\t\tsigned_type (result_type))))))\n \t    /* OK */;\n \t  else\n \t    warning (\"comparison between signed and unsigned\");\n@@ -3970,7 +4003,9 @@ pointer_int_sum (resultcode, ptrop, intop)\n \n   intop = cp_convert (result_type,\n \t\t      build_binary_op (MULT_EXPR, intop,\n-\t\t\t\t       cp_convert (TREE_TYPE (intop), size_exp), 1));\n+\t\t\t\t       cp_convert (TREE_TYPE (intop),\n+\t\t\t\t\t\t   size_exp),\n+\t\t\t\t       1));\n \n   /* Create the sum or difference.  */\n \n@@ -4009,8 +4044,8 @@ pointer_diff (op0, op1, ptrtype)\n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n \n-  op0 = build_binary_op (MINUS_EXPR,\n-\t\t\t cp_convert (restype, op0), cp_convert (restype, op1), 1);\n+  op0 = build_binary_op (MINUS_EXPR, cp_convert (restype, op0),\n+\t\t\t cp_convert (restype, op1), 1);\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (op1))) == 0)\n@@ -4565,8 +4600,9 @@ build_unary_op (code, xarg, noconvert)\n \ttree addr;\n \n \tif (TREE_CODE (arg) == COMPONENT_REF)\n-\t  addr = build_component_addr (arg, argtype,\n-\t\t\t\t       \"attempt to take address of bit-field structure member `%s'\");\n+\t  addr = build_component_addr\n+\t    (arg, argtype,\n+\t     \"attempt to take address of bit-field structure member `%s'\");\n \telse\n \t  addr = build1 (code, argtype, arg);\n \n@@ -4689,7 +4725,8 @@ unary_complex_lvalue (code, arg)\n \n       t = TREE_OPERAND (arg, 1);\n \n-      if (TREE_CODE (t) == FUNCTION_DECL) /* Check all this code for right semantics.  */\n+      /* Check all this code for right semantics.  */\t\n+      if (TREE_CODE (t) == FUNCTION_DECL)\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n       if (TREE_CODE (t) == VAR_DECL)\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n@@ -4700,7 +4737,8 @@ unary_complex_lvalue (code, arg)\n \n \t  if (TREE_OPERAND (arg, 0)\n \t      && (TREE_CODE (TREE_OPERAND (arg, 0)) != NOP_EXPR\n-\t\t  || TREE_OPERAND (TREE_OPERAND (arg, 0), 0) != error_mark_node))\n+\t\t  || (TREE_OPERAND (TREE_OPERAND (arg, 0), 0)\n+\t\t      != error_mark_node)))\n \t    if (TREE_CODE (t) != FIELD_DECL)\n \t      {\n \t\t/* Don't know if this should return address to just\n@@ -4723,7 +4761,8 @@ unary_complex_lvalue (code, arg)\n \t\t\t       convert (sizetype,\n \t\t\t\t\tsize_binop (EASY_DIV_EXPR,\n \t\t\t\t\t\t    DECL_FIELD_BITPOS (t),\n-\t\t\t\t\t\t    size_int (BITS_PER_UNIT))));\n+\t\t\t\t\t\t    size_int (BITS_PER_UNIT))\n+\t\t\t\t\t));\n \n \t  /* We offset all pointer to data members by 1 so that we can\n \t     distinguish between a null pointer to data member and the first\n@@ -4808,7 +4847,8 @@ mark_addressable (exp)\n \n \t    TREE_ASM_WRITTEN (x) = 0;\n \t    DECL_RTL (x) = 0;\n-\t    rest_of_decl_compilation (x, 0, IDENTIFIER_LOCAL_VALUE (x) == 0, 0);\n+\t    rest_of_decl_compilation (x, 0, IDENTIFIER_LOCAL_VALUE (x) == 0,\n+\t\t\t\t      0);\n \t    TREE_ADDRESSABLE (x) = 1;\n \n \t    pop_obstacks ();\n@@ -4977,7 +5017,8 @@ build_conditional_expr (ifexp, op1, op2)\n     {\n       if (code2 == ENUMERAL_TYPE)\n \t{\n-\t  cp_error (\"enumeral mismatch in conditional expression: `%T' vs `%T'\", type1, type2);\n+\t  cp_error (\"enumeral mismatch in conditional expression: `%T' vs `%T'\",\n+\t\t    type1, type2);\n \t  return error_mark_node;\n \t}\n       else if (extra_warnings && ! IS_AGGR_TYPE_CODE (code2)\n@@ -5066,7 +5107,8 @@ build_conditional_expr (ifexp, op1, op2)\n \tresult_type = type2;\n       else if (IS_AGGR_TYPE (TREE_TYPE (type1))\n \t       && IS_AGGR_TYPE (TREE_TYPE (type2))\n-\t       && (result_type = common_base_type (TREE_TYPE (type1), TREE_TYPE (type2))))\n+\t       && (result_type = common_base_type (TREE_TYPE (type1),\n+\t\t\t\t\t\t   TREE_TYPE (type2))))\n \t{\n \t  if (result_type == error_mark_node)\n \t    {\n@@ -5108,7 +5150,8 @@ build_conditional_expr (ifexp, op1, op2)\n \t an aggregate value, try converting to a scalar type.  */\n       if (code1 == RECORD_TYPE && code2 == RECORD_TYPE)\n \t{\n-\t  cp_error (\"aggregate mismatch in conditional expression: `%T' vs `%T'\", type1, type2);\n+\t  cp_error (\"aggregate mismatch in conditional expression: `%T' vs `%T'\",\n+\t\t    type1, type2);\n \t  return error_mark_node;\n \t}\n       /* Warning: this code assumes that conversion between cv-variants of\n@@ -5205,7 +5248,8 @@ build_x_compound_expr (list)\n   result = build_opfncall (COMPOUND_EXPR, LOOKUP_NORMAL,\n \t\t\t   TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n   if (result)\n-    return build_x_compound_expr (expr_tree_cons (NULL_TREE, result, TREE_CHAIN (rest)));\n+    return build_x_compound_expr (expr_tree_cons (NULL_TREE, result,\n+\t\t\t\t\t\t  TREE_CHAIN (rest)));\n \n   if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n     {\n@@ -5222,8 +5266,10 @@ build_x_compound_expr (list)\n     warn_if_unused_value (TREE_VALUE(list));\n #endif\n \n-  return build_compound_expr (expr_tree_cons (NULL_TREE, TREE_VALUE (list),\n-\t\t\t\t\t build_expr_list (NULL_TREE, build_x_compound_expr (rest))));\n+  return build_compound_expr\n+    (expr_tree_cons (NULL_TREE, TREE_VALUE (list),\n+\t\t     build_expr_list (NULL_TREE,\n+\t\t\t\t      build_x_compound_expr (rest))));\n }\n \n /* Given a list of expressions, return a compound expression\n@@ -5878,23 +5924,7 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n   else if (PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE))\n     {\n-      /* This case must convert to some sort of lvalue that\n-\t can participate in an op= operation.  */\n-      tree lhs_tmp = lhs;\n-      tree rhs_tmp = rhs;\n-      if (build_default_binary_type_conversion (modifycode, &lhs_tmp, &rhs_tmp))\n-\t{\n-\t  lhs = stabilize_reference (lhs_tmp);\n-\t  /* Forget it was ever anything else.  */\n-\t  olhstype = lhstype = TREE_TYPE (lhs);\n-\t  newrhs = build_binary_op (modifycode, lhs, rhs_tmp, 1);\n-\t}\n-      else\n-\t{\n-\t  cp_error (\"no match for `%Q(%#T, %#T)'\", modifycode,\n-\t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n-\t  return error_mark_node;\n-\t}\n+      my_friendly_abort (978652);\n     }\n   else\n     {"}, {"sha": "f462e79bc84f146029f371ab936663084db79cdb", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c215895606e53ac07db896d1faab5c94ae3b6fe/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3c215895606e53ac07db896d1faab5c94ae3b6fe", "patch": "@@ -1295,9 +1295,10 @@ build_x_arrow (datum)\n       type = TREE_TYPE (rval);\n     }\n \n-  if (IS_AGGR_TYPE (type) && TYPE_OVERLOADS_ARROW (complete_type (type)))\n+  if (IS_AGGR_TYPE (type))\n     {\n-      while ((rval = build_opfncall (COMPONENT_REF, LOOKUP_NORMAL, rval, NULL_TREE, NULL_TREE)))\n+      while ((rval = build_opfncall (COMPONENT_REF, LOOKUP_NORMAL, rval,\n+\t\t\t\t     NULL_TREE, NULL_TREE)))\n \t{\n \t  if (rval == error_mark_node)\n \t    return error_mark_node;"}]}