{"sha": "64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRiNjYzZjhiZDhhYmQxOTBlOWYyZjJhYTQ3ZGRkZjYwNzY5YjhlMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-27T15:23:46Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-27T15:23:46Z"}, "message": "fold-const.c (fold): Optimize ~X|X and X|~X as -1.\n\n\n\t* fold-const.c (fold) <BIT_IOR_EXPR>: Optimize ~X|X and X|~X as -1.\n\t<BIT_XOR_EXPR>: Optimize ~X|X and X|~X as -1.\n\t<BIT_AND_EXPR>: Optimize ~X&X and X&~X as 0.\n\t<TRUTH_AND_EXPR, TRUTH_ANDIF_EXPR>: Optimize !X&&X and X&&!X as false.\n        <TRUTH_OR_EXPR, TRUTH_ORIF_EXPR>: Optimize !X||X and !X||X as true.\n\t<TRUTH_XOR_EXPR>: Optimize !X^X and X^X! as true.  Now that\n\tTRUTH_XOR_EXPR is a commutative tree code, don't test whether arg0\n\tis a constant.\n\n\t* gcc.dg/20040527-1.c: New test case.\n\nFrom-SVN: r83733", "tree": {"sha": "bf00b8dfd6d9b655b708894fca96a9f725e3610a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf00b8dfd6d9b655b708894fca96a9f725e3610a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/comments", "author": null, "committer": null, "parents": [{"sha": "73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb"}], "stats": {"total": 147, "additions": 141, "deletions": 6}, "files": [{"sha": "69f8d327c8133e550654ef4d8b3d9efbb1fd89c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "patch": "@@ -1,3 +1,14 @@\n+2004-06-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold) <BIT_IOR_EXPR>: Optimize ~X|X and X|~X as -1.\n+\t<BIT_XOR_EXPR>: Optimize ~X|X and X|~X as -1.\n+\t<BIT_AND_EXPR>: Optimize ~X&X and X&~X as 0.\n+\t<TRUTH_AND_EXPR, TRUTH_ANDIF_EXPR>: Optimize !X&&X and X&&!X as false.\n+        <TRUTH_OR_EXPR, TRUTH_ORIF_EXPR>: Optimize !X||X and !X||X as true.\n+\t<TRUTH_XOR_EXPR>: Optimize !X^X and X^X! as true.  Now that\n+\tTRUTH_XOR_EXPR is a commutative tree code, don't test whether arg0\n+\tis a constant.\n+\n 2004-06-26  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR 13334"}, {"sha": "21cb85d32fa8a485f255c11a2fee9545440b1af4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "patch": "@@ -7185,6 +7185,27 @@ fold (tree expr)\n \treturn non_lvalue (fold_convert (type, arg0));\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn non_lvalue (fold_convert (type, arg0));\n+\n+      /* ~X | X is -1.  */\n+      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\t{\n+\t  t1 = build_int_2 (-1, -1);\n+\t  TREE_TYPE (t1) = type;\n+\t  force_fit_type (t1, 0);\n+\t  return omit_one_operand (type, t1, arg1);\n+\t}\n+\n+      /* X | ~X is -1.  */\n+      if (TREE_CODE (arg1) == BIT_NOT_EXPR\n+\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\t{\n+\t  t1 = build_int_2 (-1, -1);\n+\t  TREE_TYPE (t1) = type;\n+\t  force_fit_type (t1, 0);\n+\t  return omit_one_operand (type, t1, arg0);\n+\t}\n+\n       t1 = distribute_bit_expr (code, type, arg0, arg1);\n       if (t1 != NULL_TREE)\n \treturn t1;\n@@ -7216,6 +7237,26 @@ fold (tree expr)\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n \n+      /* ~X ^ X is -1.  */\n+      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\t{\n+\t  t1 = build_int_2 (-1, -1);\n+\t  TREE_TYPE (t1) = type;\n+\t  force_fit_type (t1, 0);\n+\t  return omit_one_operand (type, t1, arg1);\n+\t}\n+\n+      /* X ^ ~X is -1.  */\n+      if (TREE_CODE (arg1) == BIT_NOT_EXPR\n+\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\t{\n+\t  t1 = build_int_2 (-1, -1);\n+\t  TREE_TYPE (t1) = type;\n+\t  force_fit_type (t1, 0);\n+\t  return omit_one_operand (type, t1, arg0);\n+\t}\n+\n       /* If we are XORing two BIT_AND_EXPR's, both of which are and'ing\n          with a constant, and the two constants have no bits in common,\n \t we should treat this as a BIT_IOR_EXPR since this may produce more\n@@ -7243,6 +7284,17 @@ fold (tree expr)\n \treturn omit_one_operand (type, arg1, arg0);\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn non_lvalue (fold_convert (type, arg0));\n+\n+      /* ~X & X is always zero.  */\n+      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\treturn omit_one_operand (type, integer_zero_node, arg1);\n+\n+      /* X & ~X is always zero.  */\n+      if (TREE_CODE (arg1) == BIT_NOT_EXPR\n+\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\treturn omit_one_operand (type, integer_zero_node, arg0);\n+\n       t1 = distribute_bit_expr (code, type, arg0, arg1);\n       if (t1 != NULL_TREE)\n \treturn t1;\n@@ -7625,6 +7677,15 @@ fold (tree expr)\n       if (integer_zerop (arg0))\n \treturn omit_one_operand (type, arg0, arg1);\n \n+      /* !X && X is always false.  */\n+      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\treturn omit_one_operand (type, integer_zero_node, arg1);\n+      /* X && !X is always false.  */\n+      if (TREE_CODE (arg1) == TRUTH_NOT_EXPR\n+\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\treturn omit_one_operand (type, integer_zero_node, arg0);\n+\n     truth_andor:\n       /* We only do these simplifications if we are optimizing.  */\n       if (!optimize)\n@@ -7712,22 +7773,39 @@ fold (tree expr)\n \t TRUTH_OR_EXPR.  */\n       if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n \treturn omit_one_operand (type, arg0, arg1);\n+\n+      /* !X || X is always true.  */\n+      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\treturn omit_one_operand (type, integer_one_node, arg1);\n+      /* X || !X is always true.  */\n+      if (TREE_CODE (arg1) == TRUTH_NOT_EXPR\n+\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\treturn omit_one_operand (type, integer_one_node, arg0);\n+\n       goto truth_andor;\n \n     case TRUTH_XOR_EXPR:\n-      /* If either arg is constant zero, drop it.  */\n-      if (integer_zerop (arg0))\n-\treturn non_lvalue (fold_convert (type, arg1));\n+      /* If the second arg is constant zero, drop it.  */\n       if (integer_zerop (arg1))\n \treturn non_lvalue (fold_convert (type, arg0));\n-      /* If either arg is constant true, this is a logical inversion.  */\n-      if (integer_onep (arg0))\n-\treturn non_lvalue (fold_convert (type, invert_truthvalue (arg1)));\n+      /* If the second arg is constant true, this is a logical inversion.  */\n       if (integer_onep (arg1))\n \treturn non_lvalue (fold_convert (type, invert_truthvalue (arg0)));\n       /* Identical arguments cancel to zero.  */\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n+\n+      /* !X ^ X is always true.  */\n+      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR\n+\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\treturn omit_one_operand (type, integer_one_node, arg1);\n+\n+      /* X ^ !X is always true.  */\n+      if (TREE_CODE (arg1) == TRUTH_NOT_EXPR\n+\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n+\treturn omit_one_operand (type, integer_one_node, arg0);\n+\n       return t;\n \n     case EQ_EXPR:"}, {"sha": "ab98b2a9126764c8d547949d97f5edecb4be038d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "patch": "@@ -1,3 +1,7 @@\n+2004-06-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/20040527-1.c: New test case.\n+\n 2004-06-26  Bud Davis  <bdavis9659@comcast.net>\n \n \tPR gfortran/pr16196"}, {"sha": "2b4f09fefc7ed055706cec4789355b55e0652151", "filename": "gcc/testsuite/gcc.dg/20040627-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2Ftestsuite%2Fgcc.dg%2F20040627-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3/gcc%2Ftestsuite%2Fgcc.dg%2F20040627-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20040627-1.c?ref=64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error (void);\n+\n+\n+void test(int x)\n+{\n+  if ((x & ~x) != 0)\n+    link_error ();\n+  if ((~x & x) != 0)\n+    link_error ();\n+\n+  if ((x ^ ~x) != -1)\n+    link_error ();\n+  if ((~x ^ x) != -1)\n+    link_error ();\n+\n+  if ((x | ~x) != -1)\n+    link_error ();\n+  if ((~x | x) != -1)\n+    link_error ();\n+\n+  if (x && !x)\n+    link_error ();\n+  if (!x && x)\n+    link_error ();\n+\n+  if (!(x || !x))\n+    link_error ();\n+  if (!(!x || x))\n+    link_error ();\n+}\n+\n+int main()\n+{\n+  test (0);\n+  test (1);\n+  test (-1);\n+  return 0;\n+}\n+"}]}