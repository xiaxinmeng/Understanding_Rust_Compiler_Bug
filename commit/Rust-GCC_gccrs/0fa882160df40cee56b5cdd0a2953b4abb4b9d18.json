{"sha": "0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "node_id": "C_kwDOANBUbNoAKDBmYTg4MjE2MGRmNDBjZWU1NmI1Y2RkMGEyOTUzYjRhYmI0YjlkMTg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-24T16:54:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-24T16:54:54Z"}, "message": "Merge #1043 #1064\n\n1043: implement include_bytes! and include_str! macros r=CohenArthur a=dafaust\n\nImplement the include_bytes! and include_str! builtin macros.\r\n\r\nAddresses:  #927 \n\n1064: Handle :tt fragments properly r=CohenArthur a=CohenArthur\n\n:tt fragments stand for token trees, and are composed of either a token,\r\nor a delimited token tree, which is a token tree surrounded by\r\ndelimiters (parentheses, curly brackets or square brackets).\r\n\r\nThis should allow us to handle a lot more macros, including extremely\r\npowerful macro patterns such as TT munchers\r\n\n\nCo-authored-by: David Faust <david.faust@oracle.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "1bcc946dd8269d4e16c46ef980866140db20d139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bcc946dd8269d4e16c46ef980866140db20d139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiPKJeCRBK7hj4Ov3rIwAAV2cIAJewbd0rUQBGiFcCw4Z3G+Dy\nHbL/YXtntmIHic6zopRZ/POclQMlQTiizpc6Wu1820jUgSih7KLDvMBMZYELD4AE\nujmqFTPPYbri4l9j/BkscggM4kfTqvGunyR+yy5bMExzkX3gS/F89gyIpY5WsXdl\nEuqQ8rAbZLOsA3P1UIIOthRIRkrefputrUS5Yw6u55wYSi1yn8mquVVoVOGotD9k\nf85vQ8mPIRz0XVeLFT65pbR3KnOZLzyfSVdORAkhGHupTsikhhXK7VYiSFlSAnVv\nkEW4SBZDUDshu6JOWL9YZZpXVbOlsLmQhHw2AzXduB92JB7hxRatpwKUJKwh6JU=\n=fNWC\n-----END PGP SIGNATURE-----\n", "payload": "tree 1bcc946dd8269d4e16c46ef980866140db20d139\nparent 3a90596517a785aa7832198a9f400f519d3420da\nparent 261c753e56c245aadd6f842d29a7bdb5c5d11489\nparent 5651331236d39ce685e1de3396463fd88c3a83d2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648140894 +0000\ncommitter GitHub <noreply@github.com> 1648140894 +0000\n\nMerge #1043 #1064\n\n1043: implement include_bytes! and include_str! macros r=CohenArthur a=dafaust\n\nImplement the include_bytes! and include_str! builtin macros.\r\n\r\nAddresses:  #927 \n\n1064: Handle :tt fragments properly r=CohenArthur a=CohenArthur\n\n:tt fragments stand for token trees, and are composed of either a token,\r\nor a delimited token tree, which is a token tree surrounded by\r\ndelimiters (parentheses, curly brackets or square brackets).\r\n\r\nThis should allow us to handle a lot more macros, including extremely\r\npowerful macro patterns such as TT munchers\r\n\n\nCo-authored-by: David Faust <david.faust@oracle.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a90596517a785aa7832198a9f400f519d3420da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a90596517a785aa7832198a9f400f519d3420da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a90596517a785aa7832198a9f400f519d3420da"}, {"sha": "261c753e56c245aadd6f842d29a7bdb5c5d11489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261c753e56c245aadd6f842d29a7bdb5c5d11489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261c753e56c245aadd6f842d29a7bdb5c5d11489"}, {"sha": "5651331236d39ce685e1de3396463fd88c3a83d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5651331236d39ce685e1de3396463fd88c3a83d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5651331236d39ce685e1de3396463fd88c3a83d2"}], "stats": {"total": 304, "additions": 300, "deletions": 4}, "files": [{"sha": "14f60d202cca9c009ce814d212c7f993737aa9b6", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -20,6 +20,9 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-expr.h\"\n #include \"rust-session-manager.h\"\n+#include \"rust-macro-invoc-lexer.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n \n namespace Rust {\n namespace {\n@@ -30,6 +33,107 @@ make_string (Location locus, std::string value)\n     new AST::LiteralExpr (value, AST::Literal::STRING,\n \t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n }\n+\n+/* Parse a single string literal from the given delimited token tree,\n+   and return the LiteralExpr for it. Allow for an optional trailing comma,\n+   but otherwise enforce that these are the only tokens.  */\n+\n+std::unique_ptr<AST::LiteralExpr>\n+parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n+\t\t\t     Location invoc_locus)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  auto last_token_id = TokenId::RIGHT_CURLY;\n+  switch (invoc_token_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      last_token_id = TokenId::RIGHT_PAREN;\n+      rust_assert (parser.skip_token (LEFT_PAREN));\n+      break;\n+\n+    case AST::DelimType::CURLY:\n+      rust_assert (parser.skip_token (LEFT_CURLY));\n+      break;\n+\n+    case AST::DelimType::SQUARE:\n+      last_token_id = TokenId::RIGHT_SQUARE;\n+      rust_assert (parser.skip_token (LEFT_SQUARE));\n+      break;\n+    }\n+\n+  std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n+\n+  if (parser.peek_current_token ()->get_id () == STRING_LITERAL)\n+    {\n+      lit_expr = parser.parse_literal_expr ();\n+      parser.maybe_skip_token (COMMA);\n+      if (parser.peek_current_token ()->get_id () != last_token_id)\n+\t{\n+\t  lit_expr = nullptr;\n+\t  rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+\t}\n+    }\n+  else if (parser.peek_current_token ()->get_id () == last_token_id)\n+    rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+  else\n+    rust_error_at (invoc_locus, \"argument must be a string literal\");\n+\n+  parser.skip_token (last_token_id);\n+\n+  return lit_expr;\n+}\n+\n+/* Treat PATH as a path relative to the source file currently being\n+   compiled, and return the absolute path for it.  */\n+\n+std::string\n+source_relative_path (std::string path, Location locus)\n+{\n+  std::string compile_fname\n+    = Session::get_instance ().linemap->location_file (locus);\n+\n+  auto dir_separator_pos = compile_fname.rfind (file_separator);\n+\n+  /* If there is no file_separator in the path, use current dir ('.').  */\n+  std::string dirname;\n+  if (dir_separator_pos == std::string::npos)\n+    dirname = std::string (\".\") + file_separator;\n+  else\n+    dirname = compile_fname.substr (0, dir_separator_pos) + file_separator;\n+\n+  return dirname + path;\n+}\n+\n+/* Read the full contents of the file FILENAME and return them in a vector.\n+   FIXME: platform specific.  */\n+\n+std::vector<uint8_t>\n+load_file_bytes (const char *filename)\n+{\n+  RAIIFile file_wrap (filename);\n+  if (file_wrap.get_raw () == nullptr)\n+    {\n+      rust_error_at (Location (), \"cannot open filename %s: %m\", filename);\n+      return std::vector<uint8_t> ();\n+    }\n+\n+  FILE *f = file_wrap.get_raw ();\n+  fseek (f, 0L, SEEK_END);\n+  long fsize = ftell (f);\n+  fseek (f, 0L, SEEK_SET);\n+\n+  std::vector<uint8_t> buf (fsize);\n+\n+  if (fread (&buf[0], fsize, 1, f) != 1)\n+    {\n+      rust_error_at (Location (), \"error reading file %s: %m\", filename);\n+      return std::vector<uint8_t> ();\n+    }\n+\n+  return buf;\n+}\n } // namespace\n \n AST::ASTFragment\n@@ -63,4 +167,73 @@ MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n \n   return AST::ASTFragment ({column_no});\n }\n+\n+/* Expand builtin macro include_bytes!(\"filename\"), which includes the contents\n+   of the given file as reference to a byte array. Yields an expression of type\n+   &'static [u8; N].  */\n+\n+AST::ASTFragment\n+MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string target_filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+\n+  std::vector<uint8_t> bytes = load_file_bytes (target_filename.c_str ());\n+\n+  /* Is there a more efficient way to do this?  */\n+  std::vector<std::unique_ptr<AST::Expr>> elts;\n+  for (uint8_t b : bytes)\n+    {\n+      elts.emplace_back (\n+\tnew AST::LiteralExpr (std::string (1, (char) b), AST::Literal::BYTE,\n+\t\t\t      PrimitiveCoreType::CORETYPE_U8,\n+\t\t\t      {} /* outer_attrs */, invoc_locus));\n+    }\n+\n+  auto elems = std::unique_ptr<AST::ArrayElems> (\n+    new AST::ArrayElemsValues (std::move (elts), invoc_locus));\n+\n+  auto array = std::unique_ptr<AST::Expr> (\n+    new AST::ArrayExpr (std::move (elems), {}, {}, invoc_locus));\n+\n+  auto borrow = std::unique_ptr<AST::Expr> (\n+    new AST::BorrowExpr (std::move (array), false, false, {}, invoc_locus));\n+\n+  auto node = AST::SingleASTNode (std::move (borrow));\n+  return AST::ASTFragment ({node});\n+}\n+\n+/* Expand builtin macro include_str!(\"filename\"), which includes the contents\n+   of the given file as a string. The file must be UTF-8 encoded. Yields an\n+   expression of type &'static str.  */\n+\n+AST::ASTFragment\n+MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string target_filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+\n+  std::vector<uint8_t> bytes = load_file_bytes (target_filename.c_str ());\n+\n+  /* FIXME: Enforce that the file contents are valid UTF-8.  */\n+  std::string str ((const char *) &bytes[0], bytes.size ());\n+\n+  auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n+  return AST::ASTFragment ({node});\n+}\n+\n } // namespace Rust"}, {"sha": "8b7c016b2533c5c0d412042febfdcef1046de38b", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -71,6 +71,12 @@ class MacroBuiltin\n \n   static AST::ASTFragment column (Location invoc_locus,\n \t\t\t\t  AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include_bytes (Location invoc_locus,\n+\t\t\t\t\t AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include_str (Location invoc_locus,\n+\t\t\t\t       AST::MacroInvocData &invoc);\n };\n } // namespace Rust\n "}, {"sha": "62273448677e8ced8562003f235e10469b211ea2", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -497,10 +497,8 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       gcc_unreachable ();\n       break;\n \n-      // what is TT?\n     case AST::MacroFragSpec::TT:\n-      // parser.parse_token_tree() ?\n-      gcc_unreachable ();\n+      parser.parse_token_tree ();\n       break;\n \n       // i guess we just ignore invalid and just error out"}, {"sha": "88bd311935bd752c761fd36f46b119b498a7fe0d", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -142,6 +142,7 @@ template <typename ManagedTokenSource> class Parser\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   AST::Visibility parse_visibility ();\n   std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n+  std::unique_ptr<AST::TokenTree> parse_token_tree ();\n \n private:\n   void skip_after_semicolon ();\n@@ -188,7 +189,6 @@ template <typename ManagedTokenSource> class Parser\n \n   // Token tree or macro related\n   AST::DelimTokenTree parse_delim_token_tree ();\n-  std::unique_ptr<AST::TokenTree> parse_token_tree ();\n   std::unique_ptr<AST::MacroRulesDefinition>\n   parse_macro_rules_def (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocation>"}, {"sha": "7fbdbb0fc6db708134a001ffe15081f28b18e94d", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -751,6 +751,8 @@ Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n       {\"assert\", MacroBuiltin::assert},\n       {\"file\", MacroBuiltin::file},\n       {\"column\", MacroBuiltin::column},\n+      {\"include_bytes\", MacroBuiltin::include_bytes},\n+      {\"include_str\", MacroBuiltin::include_str},\n     };\n \n   auto builtin = builtin_macros.find (macro->get_rule_name ());"}, {"sha": "966c073a794e9fbd030e8ba3f8bef32e492767ef", "filename": "gcc/testsuite/rust/compile/builtin_macro_include_bytes.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_bytes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_bytes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_bytes.rs?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! include_bytes {\n+  () => {{}};\n+}\n+\n+fn main () {\n+  let file = \"include.txt\";\n+  include_bytes! (file); // { dg-error \"argument must be a string literal\" \"\" }\n+  include_bytes! (); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_bytes! (\"foo.txt\", \"bar.txt\"); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_bytes! (\"builtin_macro_include_bytes.rs\"); // ok\n+  include_bytes! (\"builtin_macro_include_bytes.rs\",); // trailing comma ok\n+}"}, {"sha": "3e559cb92cb327eba63e6212b14c184cb126df0f", "filename": "gcc/testsuite/rust/compile/builtin_macro_include_str.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_str.rs?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! include_str {\n+  () => {{}};\n+}\n+\n+fn main () {\n+  let file = \"include.txt\";\n+  include_str! (file); // { dg-error \"argument must be a string literal\" \"\" }\n+  include_str! (); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_str! (\"foo.txt\", \"bar.txt\"); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_str! (\"builtin_macro_include_str.rs\"); // ok\n+  include_str! (\"builtin_macro_include_str.rs\",); // trailing comma ok\n+}"}, {"sha": "3f7ebd288d9019918a862c4af9c0efe51be1c708", "filename": "gcc/testsuite/rust/execute/torture/builtin_macro_include_bytes.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_bytes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_bytes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_bytes.rs?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1,44 @@\n+// { dg-output \"104\\n33\\n1\\n\" }\n+\n+macro_rules! include_bytes {\n+  () => {{}};\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn print_int(value: i32) {\n+    let s = \"%d\\n\\0\" as *const str as *const i8;\n+    printf(s, value);\n+}\n+\n+fn main() -> i32 {\n+  let bytes = include_bytes! (\"include.txt\");\n+\n+  print_int (bytes[0] as i32);\n+  print_int (bytes[14] as i32);\n+\n+  let the_bytes = b\"hello, include!\\n\";\n+\n+  let x = bytes[0] == the_bytes[0]\n+    && bytes[1] == the_bytes [1]\n+    && bytes[2] == the_bytes [2]\n+    && bytes[3] == the_bytes [3]\n+    && bytes[4] == the_bytes [4]\n+    && bytes[5] == the_bytes [5]\n+    && bytes[6] == the_bytes [6]\n+    && bytes[7] == the_bytes [7]\n+    && bytes[8] == the_bytes [8]\n+    && bytes[9] == the_bytes [9]\n+    && bytes[10] == the_bytes [10]\n+    && bytes[11] == the_bytes [11]\n+    && bytes[12] == the_bytes [12]\n+    && bytes[13] == the_bytes [13]\n+    && bytes[14] == the_bytes [14]\n+    && bytes[15] == the_bytes [15];\n+\n+  print_int (x as i32);\n+\n+  0\n+}"}, {"sha": "095d7cbc6e8d2253bf677917e97d8b7a9230d033", "filename": "gcc/testsuite/rust/execute/torture/builtin_macro_include_str.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_str.rs?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1,23 @@\n+// { dg-output \"hello, include!\\n\" }\n+\n+macro_rules! include_str {\n+  () => {{}};\n+}\n+\n+extern \"C\" {\n+    fn printf(fmt: *const i8, ...);\n+}\n+\n+fn print(s: &str) {\n+  printf(\"%s\" as *const str as *const i8, s as *const str as *const i8);\n+}\n+\n+\n+fn main() -> i32 {\n+  // include_str! (and include_bytes!) allow for an optional trailing comma.\n+  let my_str = include_str! (\"include.txt\",);\n+\n+  print (my_str);\n+\n+  0\n+}"}, {"sha": "12c368778e1503c8099e7dc96a4d74b0de0ee386", "filename": "gcc/testsuite/rust/execute/torture/include.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Finclude.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Finclude.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Finclude.txt?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1 @@\n+hello, include!"}, {"sha": "c2658721bdfc2e83e69984c19eb8a8ac18bb7f15", "filename": "gcc/testsuite/rust/execute/torture/macros25.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros25.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros25.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros25.rs?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1,13 @@\n+macro_rules! t {\n+    ($t:tt) => {\n+        $t\n+    };\n+}\n+\n+fn frob() -> i32 {\n+    t!(15) + t!((14))\n+}\n+\n+fn main() -> i32 {\n+    frob() - 29\n+}"}, {"sha": "30f0beef0d969879a45c915123831422b3d92b61", "filename": "gcc/testsuite/rust/execute/torture/macros26.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros26.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fa882160df40cee56b5cdd0a2953b4abb4b9d18/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros26.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros26.rs?ref=0fa882160df40cee56b5cdd0a2953b4abb4b9d18", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! count_tt {\n+    ($t:tt) => { 1 };\n+    ($t:tt $($ts:tt)*) => { 1 + count_tt!($($ts)*) };\n+}\n+\n+fn main() -> i32 {\n+    let count = count_tt!(1 2 let a = 15) + count_tt!(1 2 (let a = 15));\n+    //                    ^ ^ ^^^ ^ ^ ^^              ^ ^ ^^^^^^^^^^^^\n+    //                    6 token-trees               3 token-trees\n+\n+    count - 9\n+}"}]}