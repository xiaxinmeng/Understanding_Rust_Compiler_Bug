{"sha": "f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdmYjVjMDhmMzZlYTFjMWFlZWJlMTcxMDgzOWQxYzBkNWU2ODY3NA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-25T08:46:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-25T08:46:40Z"}, "message": "[multiple changes]\n\n2017-09-25  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch3.adb: Rename Comp_Type_Simple to be Comp_Simple_Init.\n\n2017-09-25  Doug Rupp  <rupp@adacore.com>\n\n\t* libgnarl/s-taprop__linux.adb (Base_Monotonic_Clock): New variable.\n\t(Compute_Base_Monotonic_Clock): New function.\n\t(Timed_Sleep): Adjust to use Base_Monotonic_Clock.\n\t(Timed_Delay): Likewise.\n\t(Monotonic_Clock): Likewise.\n\t* s-oscons-tmplt.c (CLOCK_MONOTONIC): Use on Linux.\n\nFrom-SVN: r253136", "tree": {"sha": "b4cdb910fe7ef003d34d219972e910f4bc14e910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4cdb910fe7ef003d34d219972e910f4bc14e910"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/comments", "author": null, "committer": null, "parents": [{"sha": "aa11d1dd992874c1286d29343d499aa7c7855dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa11d1dd992874c1286d29343d499aa7c7855dd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa11d1dd992874c1286d29343d499aa7c7855dd6"}], "stats": {"total": 127, "additions": 114, "deletions": 13}, "files": [{"sha": "371d50ec30e51fd1a923862369d28b746bd3088c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "patch": "@@ -1,3 +1,16 @@\n+2017-09-25  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch3.adb: Rename Comp_Type_Simple to be Comp_Simple_Init.\n+\n+2017-09-25  Doug Rupp  <rupp@adacore.com>\n+\n+\t* libgnarl/s-taprop__linux.adb (Base_Monotonic_Clock): New variable.\n+\t(Compute_Base_Monotonic_Clock): New function.\n+\t(Timed_Sleep): Adjust to use Base_Monotonic_Clock.\n+\t(Timed_Delay): Likewise.\n+\t(Monotonic_Clock): Likewise.\n+\t* s-oscons-tmplt.c (CLOCK_MONOTONIC): Use on Linux.\n+\n 2017-09-25  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch12.adb (Save_References_In_Aggregate): Small correction to"}, {"sha": "39ad94a3437fa994c0031063b849e13a576c1bb7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "patch": "@@ -517,11 +517,16 @@ package body Exp_Ch3 is\n \n    procedure Build_Array_Init_Proc (A_Type : Entity_Id; Nod : Node_Id) is\n       Comp_Type        : constant Entity_Id := Component_Type (A_Type);\n-      Comp_Type_Simple : constant Boolean   :=\n+      Comp_Simple_Init : constant Boolean   :=\n         Needs_Simple_Initialization\n           (T           => Comp_Type,\n            Consider_IS =>\n              not (Validity_Check_Copies and Is_Bit_Packed_Array (A_Type)));\n+      --  True if the component needs simple initialization, based on its type,\n+      --  plus the fact that we do not do simple initialization for components\n+      --  of bit-packed arrays when validity checks are enabled, because the\n+      --  initialization with deliberately out-of-range values would raise\n+      --  Constraint_Error.\n \n       Body_Stmts       : List_Id;\n       Has_Default_Init : Boolean;\n@@ -563,7 +568,7 @@ package body Exp_Ch3 is\n                   Convert_To (Comp_Type,\n                     Default_Aspect_Component_Value (First_Subtype (A_Type)))));\n \n-         elsif Comp_Type_Simple then\n+         elsif Comp_Simple_Init then\n             Set_Assignment_OK (Comp);\n             return New_List (\n               Make_Assignment_Statement (Loc,\n@@ -595,7 +600,7 @@ package body Exp_Ch3 is\n          --  the dummy Init_Proc needed for Initialize_Scalars processing.\n \n          if not Has_Non_Null_Base_Init_Proc (Comp_Type)\n-           and then not Comp_Type_Simple\n+           and then not Comp_Simple_Init\n            and then not Has_Task (Comp_Type)\n            and then not Has_Default_Aspect (A_Type)\n          then\n@@ -685,7 +690,7 @@ package body Exp_Ch3 is\n       --  init_proc.\n \n       Has_Default_Init := Has_Non_Null_Base_Init_Proc (Comp_Type)\n-                            or else Comp_Type_Simple\n+                            or else Comp_Simple_Init\n                             or else Has_Task (Comp_Type)\n                             or else Has_Default_Aspect (A_Type);\n "}, {"sha": "4f83d73b674ca2558b604a16ee45de6b56ec239a", "filename": "gcc/ada/libgnarl/s-taprop__linux.adb", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb?ref=f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "patch": "@@ -64,6 +64,7 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use System.OS_Primitives;\n    use System.Task_Info;\n+   use type Interfaces.C.long;\n \n    ----------------\n    -- Local Data --\n@@ -110,6 +111,8 @@ package body System.Task_Primitives.Operations is\n    --  Constant to indicate that the thread identifier has not yet been\n    --  initialized.\n \n+   Base_Monotonic_Clock : Duration := 0.0;\n+\n    --------------------\n    -- Local Packages --\n    --------------------\n@@ -160,6 +163,12 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Handler (signo : Signal);\n \n+   function Compute_Base_Monotonic_Clock return Duration;\n+   --  The monotonic clock epoch is set to some undetermined time\n+   --  in the past (typically system boot time).  In order to use the\n+   --  monotonic clock for absolute time, the offset from a known epoch\n+   --  is needed.\n+\n    function GNAT_pthread_condattr_setup\n      (attr : access pthread_condattr_t) return C.int;\n    pragma Import\n@@ -257,6 +266,73 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Abort_Handler;\n \n+   ----------------------------------\n+   -- Compute_Base_Monotonic_Clock --\n+   ----------------------------------\n+\n+   function Compute_Base_Monotonic_Clock return Duration is\n+      TS_Bef0, TS_Mon0, TS_Aft0 : aliased timespec;\n+      TS_Bef,  TS_Mon,  TS_Aft  : aliased timespec;\n+      Bef, Mon, Aft             : Duration;\n+      Res_B, Res_M, Res_A       : Interfaces.C.int;\n+   begin\n+      Res_B := clock_gettime\n+       (clock_id => OSC.CLOCK_REALTIME, tp => TS_Bef0'Unchecked_Access);\n+      pragma Assert (Res_B = 0);\n+      Res_M := clock_gettime\n+       (clock_id => OSC.CLOCK_RT_Ada, tp => TS_Mon0'Unchecked_Access);\n+      pragma Assert (Res_M = 0);\n+      Res_A := clock_gettime\n+       (clock_id => OSC.CLOCK_REALTIME, tp => TS_Aft0'Unchecked_Access);\n+      pragma Assert (Res_A = 0);\n+\n+      for I in 1 .. 10 loop\n+         --  Guard against a leap second which will cause CLOCK_REALTIME\n+         --  to jump backwards.  In the extrenmely unlikely event we call\n+         --  clock_gettime before and after the jump the epoch result will\n+         --  be off slightly.\n+         --  Use only results where the tv_sec values match for the sake\n+         --  of convenience.\n+         --  Also try to calculate the most accurate\n+         --  epoch by taking the minimum difference of 10 tries.\n+\n+         Res_B := clock_gettime\n+          (clock_id => OSC.CLOCK_REALTIME, tp => TS_Bef'Unchecked_Access);\n+         pragma Assert (Res_B = 0);\n+         Res_M := clock_gettime\n+          (clock_id => OSC.CLOCK_RT_Ada, tp => TS_Mon'Unchecked_Access);\n+         pragma Assert (Res_M = 0);\n+         Res_A := clock_gettime\n+          (clock_id => OSC.CLOCK_REALTIME, tp => TS_Aft'Unchecked_Access);\n+         pragma Assert (Res_A = 0);\n+\n+         if (TS_Bef0.tv_sec /= TS_Aft0.tv_sec and then\n+             TS_Bef.tv_sec  = TS_Aft.tv_sec)\n+            --  The calls to clock_gettime before the loop were no good.\n+            or else\n+            (TS_Bef0.tv_sec = TS_Aft0.tv_sec and then\n+             TS_Bef.tv_sec  = TS_Aft.tv_sec and then\n+            (TS_Aft.tv_nsec  - TS_Bef.tv_nsec <\n+             TS_Aft0.tv_nsec - TS_Bef0.tv_nsec))\n+            --  The most recent calls to clock_gettime were more better.\n+         then\n+            TS_Bef0.tv_sec := TS_Bef.tv_sec;\n+            TS_Bef0.tv_nsec := TS_Bef.tv_nsec;\n+            TS_Aft0.tv_sec := TS_Aft.tv_sec;\n+            TS_Aft0.tv_nsec := TS_Aft.tv_nsec;\n+            TS_Mon0.tv_sec := TS_Mon.tv_sec;\n+            TS_Mon0.tv_nsec := TS_Mon.tv_nsec;\n+         end if;\n+      end loop;\n+\n+      Bef := To_Duration (TS_Bef0);\n+      Mon := To_Duration (TS_Mon0);\n+      Aft := To_Duration (TS_Aft0);\n+\n+      return Bef / 2 + Aft / 2 - Mon;\n+      --  Distribute the division to avoid potential type overflow someday.\n+   end Compute_Base_Monotonic_Clock;\n+\n    --------------\n    -- Lock_RTS --\n    --------------\n@@ -583,7 +659,7 @@ package body System.Task_Primitives.Operations is\n       pragma Unreferenced (Reason);\n \n       Base_Time  : constant Duration := Monotonic_Clock;\n-      Check_Time : Duration := Base_Time;\n+      Check_Time : Duration := Base_Time - Base_Monotonic_Clock;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n       Result     : C.int;\n@@ -595,7 +671,8 @@ package body System.Task_Primitives.Operations is\n       Abs_Time :=\n         (if Mode = Relative\n          then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n-         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n+         else Duration'Min (Check_Time + Max_Sensible_Delay,\n+                            Time - Base_Monotonic_Clock));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n@@ -612,7 +689,8 @@ package body System.Task_Primitives.Operations is\n                  abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+            exit when Abs_Time + Base_Monotonic_Clock <= Check_Time\n+                      or else Check_Time < Base_Time;\n \n             if Result in 0 | EINTR then\n \n@@ -640,7 +718,7 @@ package body System.Task_Primitives.Operations is\n       Mode    : ST.Delay_Modes)\n    is\n       Base_Time  : constant Duration := Monotonic_Clock;\n-      Check_Time : Duration := Base_Time;\n+      Check_Time : Duration := Base_Time - Base_Monotonic_Clock;\n       Abs_Time   : Duration;\n       Request    : aliased timespec;\n \n@@ -657,7 +735,8 @@ package body System.Task_Primitives.Operations is\n       Abs_Time :=\n         (if Mode = Relative\n          then Time + Check_Time\n-         else Duration'Min (Check_Time + Max_Sensible_Delay, Time));\n+         else Duration'Min (Check_Time + Max_Sensible_Delay,\n+                            Time - Base_Monotonic_Clock));\n \n       if Abs_Time > Check_Time then\n          Request := To_Timespec (Abs_Time);\n@@ -675,7 +754,8 @@ package body System.Task_Primitives.Operations is\n                  abstime => Request'Access);\n \n             Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+            exit when Abs_Time + Base_Monotonic_Clock <= Check_Time\n+                      or else Check_Time < Base_Time;\n \n             pragma Assert (Result in 0 | ETIMEDOUT | EINTR);\n          end loop;\n@@ -698,13 +778,13 @@ package body System.Task_Primitives.Operations is\n \n    function Monotonic_Clock return Duration is\n       TS     : aliased timespec;\n-      Result : C.int;\n+      Result : Interfaces.C.int;\n    begin\n       Result := clock_gettime\n         (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n       pragma Assert (Result = 0);\n \n-      return To_Duration (TS);\n+      return Base_Monotonic_Clock + To_Duration (TS);\n    end Monotonic_Clock;\n \n    -------------------\n@@ -1496,6 +1576,8 @@ package body System.Task_Primitives.Operations is\n \n       Interrupt_Management.Initialize;\n \n+      Base_Monotonic_Clock := Compute_Base_Monotonic_Clock;\n+\n       --  Prepare the set of signals that should be unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "444ad6072d426daf0aee064a4fefb4ba72b1524f", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=f7fb5c08f36ea1c1aeebe1710839d1c0d5e68674", "patch": "@@ -1440,7 +1440,8 @@ CND(CLOCK_FASTEST, \"Fastest clock\")\n #endif\n CND(CLOCK_THREAD_CPUTIME_ID, \"Thread CPU clock\")\n \n-#if defined(__FreeBSD__) || (defined(_AIX) && defined(_AIXVERSION_530)) \\\n+#if defined(__linux__) || defined(__FreeBSD__) \\\n+ || (defined(_AIX) && defined(_AIXVERSION_530)) \\\n  || defined(__DragonFly__)\n /** On these platforms use system provided monotonic clock instead of\n  ** the default CLOCK_REALTIME. We then need to set up cond var attributes"}]}