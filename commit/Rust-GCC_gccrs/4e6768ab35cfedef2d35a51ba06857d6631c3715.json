{"sha": "4e6768ab35cfedef2d35a51ba06857d6631c3715", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2NzY4YWIzNWNmZWRlZjJkMzVhNTFiYTA2ODU3ZDY2MzFjMzcxNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:39:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:39:31Z"}, "message": "[multiple changes]\n\n2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.ads Add a comment explaining why SPARK 2014 aspects are\n\tnot delayed. Update the delay status of most SPARK 2014 aspects.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Update all calls\n\tto Decorate_Aspect_And_Pragma and Insert_Delayed_Pragma to refert\n\tto Decorate and Insert_Pragma. Add various comments concerning\n\tthe delay status of several SPARK 2014 aspects. The insertion\n\tof Refined_State now uses routine Insert_After_SPARK_Mode.\n\t(Decorate): New routine.\n\t(Decorate_Aspect_And_Pragma): Removed.\n\t(Insert_Delayed_Pragma): Removed.\n\t(Insert_Pragma): New routine.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.adb (Expand_Inlined_Call): In GNATprove mode, emit\n\tonly a warning, not an error on an attempt to inline a recursive\n\tsubprogram.\n\nFrom-SVN: r213243", "tree": {"sha": "dc6949adfd51559094b0e258bf22172641294b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc6949adfd51559094b0e258bf22172641294b2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e6768ab35cfedef2d35a51ba06857d6631c3715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6768ab35cfedef2d35a51ba06857d6631c3715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e6768ab35cfedef2d35a51ba06857d6631c3715", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6768ab35cfedef2d35a51ba06857d6631c3715/comments", "author": null, "committer": null, "parents": [{"sha": "b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c8e5bee712ecde910e0495e46f5216a7c9a60a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c8e5bee712ecde910e0495e46f5216a7c9a60a"}], "stats": {"total": 316, "additions": 177, "deletions": 139}, "files": [{"sha": "d3e7897deb0fe24da9b20f723c19326af1ba90e0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4e6768ab35cfedef2d35a51ba06857d6631c3715", "patch": "@@ -1,3 +1,23 @@\n+2014-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.ads Add a comment explaining why SPARK 2014 aspects are\n+\tnot delayed. Update the delay status of most SPARK 2014 aspects.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Update all calls\n+\tto Decorate_Aspect_And_Pragma and Insert_Delayed_Pragma to refert\n+\tto Decorate and Insert_Pragma. Add various comments concerning\n+\tthe delay status of several SPARK 2014 aspects. The insertion\n+\tof Refined_State now uses routine Insert_After_SPARK_Mode.\n+\t(Decorate): New routine.\n+\t(Decorate_Aspect_And_Pragma): Removed.\n+\t(Insert_Delayed_Pragma): Removed.\n+\t(Insert_Pragma): New routine.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* inline.adb (Expand_Inlined_Call): In GNATprove mode, emit\n+\tonly a warning, not an error on an attempt to inline a recursive\n+\tsubprogram.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* g-forstr.adb: Minor code reorganization (use J rather than I"}, {"sha": "41fdf7a2fcaf1baabf05865681d9c94e70f2dc2c", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=4e6768ab35cfedef2d35a51ba06857d6631c3715", "patch": "@@ -543,6 +543,14 @@ package Aspects is\n    --  information from the parent type, which must be frozen at that point\n    --  (since freezing the derived type first freezes the parent type).\n \n+   --  SPARK 2014 aspects do not follow the general delay mechanism as they\n+   --  act as annotations and cannot modify the attributes of their related\n+   --  constructs. To handle forward references in such aspects, the compiler\n+   --  delays the analysis of their respective pragmas by collecting them in\n+   --  N_Contract nodes. The pragmas are then analyzed at the end of the\n+   --  declarative region which contains the related construct. For details,\n+   --  see routines Analyze_xxx_In_Decl_Part.\n+\n    --  The following shows which aspects are delayed. There are three cases:\n \n    type Delay_Type is\n@@ -593,12 +601,10 @@ package Aspects is\n       Aspect_Asynchronous                 => Always_Delay,\n       Aspect_Attach_Handler               => Always_Delay,\n       Aspect_Constant_Indexing            => Always_Delay,\n-      Aspect_Contract_Cases               => Always_Delay,\n       Aspect_CPU                          => Always_Delay,\n       Aspect_Default_Iterator             => Always_Delay,\n       Aspect_Default_Value                => Always_Delay,\n       Aspect_Default_Component_Value      => Always_Delay,\n-      Aspect_Depends                      => Always_Delay,\n       Aspect_Discard_Names                => Always_Delay,\n       Aspect_Dispatching_Domain           => Always_Delay,\n       Aspect_Dynamic_Predicate            => Always_Delay,\n@@ -607,15 +613,12 @@ package Aspects is\n       Aspect_External_Tag                 => Always_Delay,\n       Aspect_Export                       => Always_Delay,\n       Aspect_Favor_Top_Level              => Always_Delay,\n-      Aspect_Global                       => Always_Delay,\n       Aspect_Implicit_Dereference         => Always_Delay,\n       Aspect_Import                       => Always_Delay,\n       Aspect_Independent                  => Always_Delay,\n       Aspect_Independent_Components       => Always_Delay,\n       Aspect_Inline                       => Always_Delay,\n       Aspect_Inline_Always                => Always_Delay,\n-      Aspect_Initial_Condition            => Always_Delay,\n-      Aspect_Initializes                  => Always_Delay,\n       Aspect_Input                        => Always_Delay,\n       Aspect_Interrupt_Handler            => Always_Delay,\n       Aspect_Interrupt_Priority           => Always_Delay,\n@@ -639,9 +642,6 @@ package Aspects is\n       Aspect_Pure                         => Always_Delay,\n       Aspect_Pure_Function                => Always_Delay,\n       Aspect_Read                         => Always_Delay,\n-      Aspect_Refined_Depends              => Always_Delay,\n-      Aspect_Refined_Global               => Always_Delay,\n-      Aspect_Refined_State                => Always_Delay,\n       Aspect_Relative_Deadline            => Always_Delay,\n       Aspect_Remote_Access_Type           => Always_Delay,\n       Aspect_Remote_Call_Interface        => Always_Delay,\n@@ -671,13 +671,21 @@ package Aspects is\n       Aspect_Annotate                     => Never_Delay,\n       Aspect_Async_Readers                => Never_Delay,\n       Aspect_Async_Writers                => Never_Delay,\n+      Aspect_Contract_Cases               => Never_Delay,\n       Aspect_Convention                   => Never_Delay,\n+      Aspect_Depends                      => Never_Delay,\n       Aspect_Dimension                    => Never_Delay,\n       Aspect_Dimension_System             => Never_Delay,\n       Aspect_Effective_Reads              => Never_Delay,\n       Aspect_Effective_Writes             => Never_Delay,\n+      Aspect_Global                       => Never_Delay,\n+      Aspect_Initial_Condition            => Never_Delay,\n+      Aspect_Initializes                  => Never_Delay,\n       Aspect_Part_Of                      => Never_Delay,\n+      Aspect_Refined_Depends              => Never_Delay,\n+      Aspect_Refined_Global               => Never_Delay,\n       Aspect_Refined_Post                 => Never_Delay,\n+      Aspect_Refined_State                => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,\n       Aspect_Test_Case                    => Never_Delay,"}, {"sha": "438f27c1ca906731b240687b2af1e9bd77017e46", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=4e6768ab35cfedef2d35a51ba06857d6631c3715", "patch": "@@ -3619,7 +3619,19 @@ package body Inline is\n       A := First_Actual (N);\n       while Present (F) loop\n          if Present (Renamed_Object (F)) then\n-            Error_Msg_N (\"cannot inline call to recursive subprogram\", N);\n+\n+            --  If expander is active, it's an error to try to inline a\n+            --  recursive program. In GNATprove mode, just indicate that\n+            --  the inlining will not happen.\n+\n+            if Expander_Active then\n+               Error_Msg_N (\"cannot inline call to recursive subprogram\", N);\n+\n+            else\n+               Cannot_Inline\n+                 (\"cannot inline call to recursive subprogram?\", N, Subp);\n+            end if;\n+\n             return;\n          end if;\n "}, {"sha": "70129417262962869e5c1174d19896062df55d20", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 128, "deletions": 130, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6768ab35cfedef2d35a51ba06857d6631c3715/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=4e6768ab35cfedef2d35a51ba06857d6631c3715", "patch": "@@ -1185,45 +1185,42 @@ package body Sem_Ch13 is\n    -----------------------------------\n \n    procedure Analyze_Aspect_Specifications (N : Node_Id; E : Entity_Id) is\n-      procedure Decorate_Aspect_And_Pragma\n-        (Asp     : Node_Id;\n-         Prag    : Node_Id;\n-         Delayed : Boolean := False);\n+      procedure Decorate (Asp : Node_Id; Prag : Node_Id);\n       --  Establish the linkages between an aspect and its corresponding\n-      --  pragma. Flag Delayed should be set when both constructs are delayed.\n+      --  pragma.\n \n       procedure Insert_After_SPARK_Mode\n         (Prag    : Node_Id;\n          Ins_Nod : Node_Id;\n          Decls   : List_Id);\n-      --  Subsidiary to the analysis of aspects Abstract_State, Initializes and\n-      --  Initial_Condition. Insert node Prag before node Ins_Nod. If Ins_Nod\n-      --  denotes pragma SPARK_Mode, then SPARK_Mode is skipped. Decls is the\n-      --  associated declarative list where Prag is to reside.\n-\n-      procedure Insert_Delayed_Pragma (Prag : Node_Id);\n-      --  Insert a postcondition-like pragma into the tree depending on the\n-      --  context. Prag must denote one of the following: Pre, Post, Depends,\n-      --  Global or Contract_Cases. This procedure is also used for the case\n-      --  of Attach_Handler which has similar requirements for placement.\n-\n-      --------------------------------\n-      -- Decorate_Aspect_And_Pragma --\n-      --------------------------------\n-\n-      procedure Decorate_Aspect_And_Pragma\n-        (Asp     : Node_Id;\n-         Prag    : Node_Id;\n-         Delayed : Boolean := False)\n-      is\n+      --  Subsidiary to the analysis of aspects Abstract_State, Initializes,\n+      --  Initial_Condition and Refined_State. Insert node Prag before node\n+      --  Ins_Nod. If Ins_Nod denotes pragma SPARK_Mode, then SPARK_Mode is\n+      --  skipped. Decls is the associated declarative list where Prag is to\n+      --  reside.\n+\n+      procedure Insert_Pragma (Prag : Node_Id);\n+      --  Subsidiary to the analysis of aspects Attach_Handler, Contract_Cases,\n+      --  Depends, Global, Post, Pre, Refined_Depends and Refined_Global.\n+      --  Insert pragma Prag such that it mimics the placement of a source\n+      --  pragma of the same kind.\n+      --\n+      --    procedure Proc (Formal : ...) with Global => ...;\n+      --\n+      --    procedure Proc (Formal : ...);\n+      --    pragma Global (...);\n+\n+      --------------\n+      -- Decorate --\n+      --------------\n+\n+      procedure Decorate (Asp : Node_Id; Prag : Node_Id) is\n       begin\n          Set_Aspect_Rep_Item           (Asp,  Prag);\n          Set_Corresponding_Aspect      (Prag, Asp);\n          Set_From_Aspect_Specification (Prag);\n-         Set_Is_Delayed_Aspect         (Prag, Delayed);\n-         Set_Is_Delayed_Aspect         (Asp,  Delayed);\n          Set_Parent                    (Prag, Asp);\n-      end Decorate_Aspect_And_Pragma;\n+      end Decorate;\n \n       -----------------------------\n       -- Insert_After_SPARK_Mode --\n@@ -1256,12 +1253,13 @@ package body Sem_Ch13 is\n          end if;\n       end Insert_After_SPARK_Mode;\n \n-      ---------------------------\n-      -- Insert_Delayed_Pragma --\n-      ---------------------------\n+      -------------------\n+      -- Insert_Pragma --\n+      -------------------\n \n-      procedure Insert_Delayed_Pragma (Prag : Node_Id) is\n-         Aux : Node_Id;\n+      procedure Insert_Pragma (Prag : Node_Id) is\n+         Aux  : Node_Id;\n+         Decl : Node_Id;\n \n       begin\n          --  When the context is a library unit, the pragma is added to the\n@@ -1280,37 +1278,38 @@ package body Sem_Ch13 is\n          --  declarative part.\n \n          elsif Nkind (N) = N_Subprogram_Body then\n-            if No (Declarations (N)) then\n-               Set_Declarations (N, New_List (Prag));\n-            else\n-               declare\n-                  D : Node_Id;\n-               begin\n+            if Present (Declarations (N)) then\n \n-                  --  There may be several aspects associated with the body;\n-                  --  preserve the ordering of the corresponding pragmas.\n+               --  Skip other internally generated pragmas from aspects to find\n+               --  the proper insertion point. As a result the order of pragmas\n+               --  is the same as the order of aspects.\n \n-                  D := First (Declarations (N));\n-                  while Present (D) loop\n-                     exit when Nkind (D) /= N_Pragma\n-                       or else not From_Aspect_Specification (D);\n-                     Next (D);\n-                  end loop;\n-\n-                  if No (D) then\n-                     Append (Prag, Declarations (N));\n+               Decl := First (Declarations (N));\n+               while Present (Decl) loop\n+                  if Nkind (Decl) = N_Pragma\n+                    and then From_Aspect_Specification (Decl)\n+                  then\n+                     Next (Decl);\n                   else\n-                     Insert_Before (D, Prag);\n+                     exit;\n                   end if;\n-               end;\n+               end loop;\n+\n+               if Present (Decl) then\n+                  Insert_Before (Decl, Prag);\n+               else\n+                  Append (Prag, Declarations (N));\n+               end if;\n+            else\n+               Set_Declarations (N, New_List (Prag));\n             end if;\n \n          --  Default\n \n          else\n             Insert_After (N, Prag);\n          end if;\n-      end Insert_Delayed_Pragma;\n+      end Insert_Pragma;\n \n       --  Local variables\n \n@@ -1757,7 +1756,7 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Implemented);\n \n-               --  Attach Handler\n+               --  Attach_Handler\n \n                when Aspect_Attach_Handler =>\n                   Make_Aitem_Pragma\n@@ -1771,7 +1770,7 @@ package body Sem_Ch13 is\n                   --  We need to insert this pragma into the tree to get proper\n                   --  processing and to look valid from a placement viewpoint.\n \n-                  Insert_Delayed_Pragma (Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n \n                --  Dynamic_Predicate, Predicate, Static_Predicate\n@@ -2117,7 +2116,7 @@ package body Sem_Ch13 is\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Abstract_State);\n-                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate (Aspect, Aitem);\n \n                      Decls := Visible_Declarations (Specification (Context));\n \n@@ -2176,10 +2175,12 @@ package body Sem_Ch13 is\n \n                --  Depends\n \n-               --  Aspect Depends must be delayed because it mentions names\n-               --  of inputs and output that are classified by aspect Global.\n-               --  The aspect and pragma are treated the same way as a post\n-               --  condition.\n+               --  Aspect Depends is never delayed because it is equivalent to\n+               --  a source pragma which appears after the related subprogram.\n+               --  To deal with forward references, the generated pragma is\n+               --  stored in the contract of the related subprogram and later\n+               --  analyzed at the end of the declarative region. See routine\n+               --  Analyze_Depends_In_Decl_Part for details.\n \n                when Aspect_Depends =>\n                   Make_Aitem_Pragma\n@@ -2188,17 +2189,18 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Depends);\n \n-                  Decorate_Aspect_And_Pragma\n-                    (Aspect, Aitem, Delayed => True);\n-                  Insert_Delayed_Pragma (Aitem);\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n \n                --  Global\n \n-               --  Aspect Global must be delayed because it can mention names\n-               --  and benefit from the forward visibility rules applicable to\n-               --  aspects of subprograms. The aspect and pragma are treated\n-               --  the same way as a post condition.\n+               --  Aspect Global is never delayed because it is equivalent to\n+               --  a source pragma which appears after the related subprogram.\n+               --  To deal with forward references, the generated pragma is\n+               --  stored in the contract of the related subprogram and later\n+               --  analyzed at the end of the declarative region. See routine\n+               --  Analyze_Global_In_Decl_Part for details.\n \n                when Aspect_Global =>\n                   Make_Aitem_Pragma\n@@ -2207,25 +2209,28 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Global);\n \n-                  Decorate_Aspect_And_Pragma\n-                    (Aspect, Aitem, Delayed => True);\n-                  Insert_Delayed_Pragma (Aitem);\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n \n                --  Initial_Condition\n \n-               --  Aspect Initial_Condition covers the visible declarations of\n-               --  a package and all hidden states through functions. As such,\n-               --  it must be evaluated at the end of the said declarations.\n+               --  Aspect Initial_Condition is never delayed because it is\n+               --  equivalent to a source pragma which appears after the\n+               --  related package. To deal with forward references, the\n+               --  generated pragma is stored in the contract of the related\n+               --  package and later analyzed at the end of the declarative\n+               --  region. See routine Analyze_Initial_Condition_In_Decl_Part\n+               --  for details.\n \n                when Aspect_Initial_Condition => Initial_Condition : declare\n                   Context : Node_Id := N;\n                   Decls   : List_Id;\n \n                begin\n-                  --  When aspect Abstract_State appears on a generic package,\n-                  --  it is propageted to the package instance. The context in\n-                  --  this case is the instance spec.\n+                  --  When aspect Initial_Condition appears on a generic\n+                  --  package, it is propageted to the package instance. The\n+                  --  context in this case is the instance spec.\n \n                   if Nkind (Context) = N_Package_Instantiation then\n                      Context := Instance_Spec (Context);\n@@ -2242,9 +2247,7 @@ package body Sem_Ch13 is\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  =>\n                           Name_Initial_Condition);\n-\n-                     Decorate_Aspect_And_Pragma\n-                       (Aspect, Aitem, Delayed => True);\n+                     Decorate (Aspect, Aitem);\n \n                      if No (Decls) then\n                         Decls := New_List;\n@@ -2272,9 +2275,12 @@ package body Sem_Ch13 is\n \n                --  Initializes\n \n-               --  Aspect Initializes coverts the visible declarations of a\n-               --  package. As such, it must be evaluated at the end of the\n-               --  said declarations.\n+               --  Aspect Initializes is never delayed because it is equivalent\n+               --  to a source pragma appearing after the related package. To\n+               --  deal with forward references, the generated pragma is stored\n+               --  in the contract of the related package and later analyzed at\n+               --  the end of the declarative region. For details, see routine\n+               --  Analyze_Initializes_In_Decl_Part.\n \n                when Aspect_Initializes => Initializes : declare\n                   Context : Node_Id := N;\n@@ -2299,9 +2305,7 @@ package body Sem_Ch13 is\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Initializes);\n-\n-                     Decorate_Aspect_And_Pragma\n-                       (Aspect, Aitem, Delayed => True);\n+                     Decorate (Aspect, Aitem);\n \n                      if No (Decls) then\n                         Decls := New_List;\n@@ -2362,7 +2366,7 @@ package body Sem_Ch13 is\n                   --  emulate the behavior of a source pragma.\n \n                   if Nkind (N) = N_Package_Body then\n-                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate (Aspect, Aitem);\n \n                      Decls := Declarations (N);\n \n@@ -2379,7 +2383,7 @@ package body Sem_Ch13 is\n                   --  declarations to emulate the behavior of a source pragma.\n \n                   elsif Nkind (N) = N_Package_Declaration then\n-                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate (Aspect, Aitem);\n \n                      Decls := Visible_Declarations (Specification (N));\n \n@@ -2395,10 +2399,13 @@ package body Sem_Ch13 is\n \n                --  Refined_Depends\n \n-               --  Aspect Refined_Depends must be delayed because it can\n-               --  mention state refinements introduced by aspect Refined_State\n-               --  and further classified by aspect Refined_Global. Since both\n-               --  those aspects are delayed, so is Refined_Depends.\n+               --  Aspect Refined_Depends is never delayed because it is\n+               --  equivalent to a source pragma which appears in the\n+               --  declarations of the related subprogram body. To deal with\n+               --  forward references, the generated pragma is stored in the\n+               --  contract of the related subprogram body and later analyzed\n+               --  at the end of the declarative region. For details, see\n+               --  routine Analyze_Refined_Depends_In_Decl_Part.\n \n                when Aspect_Refined_Depends =>\n                   Make_Aitem_Pragma\n@@ -2407,17 +2414,19 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Depends);\n \n-                  Decorate_Aspect_And_Pragma\n-                    (Aspect, Aitem, Delayed => True);\n-                  Insert_Delayed_Pragma (Aitem);\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n \n                --  Refined_Global\n \n-               --  Aspect Refined_Global must be delayed because it can mention\n-               --  state refinements introduced by aspect Refined_State. Since\n-               --  Refined_State is already delayed due to forward references,\n-               --  so is Refined_Global.\n+               --  Aspect Refined_Global is never delayed because it is\n+               --  equivalent to a source pragma which appears in the\n+               --  declarations of the related subprogram body. To deal with\n+               --  forward references, the generated pragma is stored in the\n+               --  contract of the related subprogram body and later analyzed\n+               --  at the end of the declarative region. For details, see\n+               --  routine Analyze_Refined_Global_In_Decl_Part.\n \n                when Aspect_Refined_Global =>\n                   Make_Aitem_Pragma\n@@ -2426,8 +2435,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Global);\n \n-                  Decorate_Aspect_And_Pragma (Aspect, Aitem, Delayed => True);\n-                  Insert_Delayed_Pragma (Aitem);\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n \n                --  Refined_Post\n@@ -2442,7 +2451,6 @@ package body Sem_Ch13 is\n                --  Refined_State\n \n                when Aspect_Refined_State => Refined_State : declare\n-                  Decl  : Node_Id;\n                   Decls : List_Id;\n \n                begin\n@@ -2452,38 +2460,29 @@ package body Sem_Ch13 is\n                   --  the pragma.\n \n                   if Nkind (N) = N_Package_Body then\n+                     Decls := Declarations (N);\n+\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Refined_State);\n-                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n-\n-                     Decls := Declarations (N);\n-\n-                     --  When the package body is subject to pragma SPARK_Mode,\n-                     --  insert pragma Refined_State after SPARK_Mode.\n+                     Decorate (Aspect, Aitem);\n \n-                     if Present (Decls) then\n-                        Decl := First (Decls);\n-\n-                        if Nkind (Decl) = N_Pragma\n-                          and then Pragma_Name (Decl) = Name_SPARK_Mode\n-                        then\n-                           Insert_After (Decl, Aitem);\n-\n-                        --  The related package body lacks SPARK_Mode, the\n-                        --  corresponding pragma must be the first declaration.\n-\n-                        else\n-                           Prepend_To (Decls, Aitem);\n-                        end if;\n+                     if No (Decls) then\n+                        Decls := New_List;\n+                        Set_Declarations (N, Decls);\n+                     end if;\n \n-                     --  Otherwise the pragma forms a new declarative list\n+                     --  Pragma Refined_State must be inserted after pragma\n+                     --  SPARK_Mode in the tree. This ensures that any error\n+                     --  messages dependent on SPARK_Mode will be properly\n+                     --  enabled/suppressed.\n \n-                     else\n-                        Set_Declarations (N, New_List (Aitem));\n-                     end if;\n+                     Insert_After_SPARK_Mode\n+                       (Prag    => Aitem,\n+                        Ins_Nod => First (Decls),\n+                        Decls   => Decls);\n \n                   else\n                      Error_Msg_NE\n@@ -2741,7 +2740,7 @@ package body Sem_Ch13 is\n                   --  about delay issues, since the pragmas themselves deal\n                   --  with delay of visibility for the expression analysis.\n \n-                  Insert_Delayed_Pragma (Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n                end Pre_Post;\n \n@@ -2821,9 +2820,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Nam);\n \n-                  Decorate_Aspect_And_Pragma\n-                    (Aspect, Aitem, Delayed => True);\n-                  Insert_Delayed_Pragma (Aitem);\n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n                   goto Continue;\n \n                --  Case 5: Special handling for aspects with an optional\n@@ -3022,7 +3020,7 @@ package body Sem_Ch13 is\n             --  the aspect specification node.\n \n             if Present (Aitem) then\n-               Set_From_Aspect_Specification (Aitem, True);\n+               Set_From_Aspect_Specification (Aitem);\n             end if;\n \n             --  In the context of a compilation unit, we directly put the"}]}