{"sha": "6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkZDU4ZjczYTMzY2NlYmE0ZGE1OTY2YzE3YzM1NmVjYzIyYjBjNg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-13T22:57:44Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-13T22:57:44Z"}, "message": "Fix overflows in std::pmr::unsynchonized_pool_resource\n\n\t* src/c++17/memory_resource.cc (bitset::full()): Handle edge case\n\tfor _M_next_word maximum value.\n\t(bitset::get_first_unset(), bitset::set(size_type)): Use\n\tupdate_next_word() to update _M_next_word.\n\t(bitset::update_next_word()): New function, avoiding wraparound of\n\tunsigned _M_next_word member.\n\t(bitset::max_word_index()): New function.\n\t(chunk::chunk(void*, uint32_t, void*, size_t)): Add assertion.\n\t(chunk::max_bytes_per_chunk()): New function.\n\t(pool::replenish(memory_resource*, const pool_options&)): Prevent\n\t_M_blocks_per_chunk from exceeding max_blocks_per_chunk or from\n\tcausing chunk::max_bytes_per_chunk() to be exceeded.\n\t* testsuite/20_util/unsynchronized_pool_resource/allocate-max-chunks.cc:\n\tNew test.\n\nFrom-SVN: r266087", "tree": {"sha": "0e71c13741900a8eab433e8a507bbfe08fc89621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e71c13741900a8eab433e8a507bbfe08fc89621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874e50cbd5b254f1f171bf04ecdfeedc405dff5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874e50cbd5b254f1f171bf04ecdfeedc405dff5b"}], "stats": {"total": 165, "additions": 150, "deletions": 15}, "files": [{"sha": "973470dfb76e35f16931e5ace06070663a2bfd3d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "patch": "@@ -1,3 +1,20 @@\n+2018-11-13  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* src/c++17/memory_resource.cc (bitset::full()): Handle edge case\n+\tfor _M_next_word maximum value.\n+\t(bitset::get_first_unset(), bitset::set(size_type)): Use\n+\tupdate_next_word() to update _M_next_word.\n+\t(bitset::update_next_word()): New function, avoiding wraparound of\n+\tunsigned _M_next_word member.\n+\t(bitset::max_word_index()): New function.\n+\t(chunk::chunk(void*, uint32_t, void*, size_t)): Add assertion.\n+\t(chunk::max_bytes_per_chunk()): New function.\n+\t(pool::replenish(memory_resource*, const pool_options&)): Prevent\n+\t_M_blocks_per_chunk from exceeding max_blocks_per_chunk or from\n+\tcausing chunk::max_bytes_per_chunk() to be exceeded.\n+\t* testsuite/20_util/unsynchronized_pool_resource/allocate-max-chunks.cc:\n+\tNew test.\n+\n 2018-11-12  Jason Merrill  <jason@redhat.com>\n \n \t* libsupc++/new (std::destroying_delete_t): New."}, {"sha": "fdbbc914f2e21284b56cf7a90061199715093e9e", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "patch": "@@ -290,7 +290,18 @@ namespace pmr\n     }\n \n     // True if all bits are set\n-    bool full() const noexcept { return _M_next_word >= nwords(); }\n+    bool full() const noexcept\n+    {\n+      if (_M_next_word >= nwords())\n+\treturn true;\n+      // For a bitset with size() > (max_blocks_per_chunk() - 64) we will\n+      // have nwords() == (max_word_index() + 1) and so _M_next_word will\n+      // never be equal to nwords().\n+      // In that case, check if the last word is full:\n+      if (_M_next_word == max_word_index())\n+\treturn _M_words[_M_next_word] == word(-1);\n+      return false;\n+    }\n \n     // True if size() != 0 and no bits are set.\n     bool empty() const noexcept\n@@ -343,11 +354,7 @@ namespace pmr\n \t      const word bit = word(1) << n;\n \t      _M_words[i] |= bit;\n \t      if (i == _M_next_word)\n-\t\t{\n-\t\t  while (_M_words[_M_next_word] == word(-1)\n-\t\t      && ++_M_next_word != nwords())\n-\t\t    { }\n-\t\t}\n+\t\tupdate_next_word();\n \t      return (i * bits_per_word) + n;\n \t    }\n \t}\n@@ -361,11 +368,7 @@ namespace pmr\n       const word bit = word(1) << (n % bits_per_word);\n       _M_words[wd] |= bit;\n       if (wd == _M_next_word)\n-\t{\n-\t  while (_M_words[_M_next_word] == word(-1)\n-\t      && ++_M_next_word != nwords())\n-\t    { }\n-\t}\n+\tupdate_next_word();\n     }\n \n     void clear(size_type n) noexcept\n@@ -378,6 +381,18 @@ namespace pmr\n \t_M_next_word = wd;\n     }\n \n+    // Update _M_next_word to refer to the next word with an unset bit.\n+    // The size of the _M_next_word bit-field means it cannot represent\n+    // the maximum possible nwords() value. To avoid wraparound to zero\n+    // this function saturates _M_next_word at max_word_index().\n+    void update_next_word() noexcept\n+    {\n+      size_t next = _M_next_word;\n+      while (_M_words[next] == word(-1) && ++next < nwords())\n+\t{ }\n+      _M_next_word = std::min(next, max_word_index());\n+    }\n+\n     void swap(bitset& b) noexcept\n     {\n       std::swap(_M_words, b._M_words);\n@@ -396,6 +411,10 @@ namespace pmr\n     static constexpr size_t max_blocks_per_chunk() noexcept\n     { return (1ull << _S_size_digits) - 1; }\n \n+    // Maximum value that can be stored in bitset::_M_next_word member (8191).\n+    static constexpr size_t max_word_index() noexcept\n+    { return (max_blocks_per_chunk() + bits_per_word - 1) / bits_per_word; }\n+\n     word* data() const noexcept { return _M_words; }\n \n   private:\n@@ -425,7 +444,7 @@ namespace pmr\n     : bitset(words, n),\n       _M_bytes(bytes),\n       _M_p(static_cast<std::byte*>(p))\n-    { }\n+    { __glibcxx_assert(bytes <= chunk::max_bytes_per_chunk()); }\n \n     chunk(chunk&& c) noexcept\n     : bitset(std::move(c)), _M_bytes(c._M_bytes), _M_p(c._M_p)\n@@ -451,6 +470,9 @@ namespace pmr\n     // Number of blocks in this chunk\n     using bitset::size;\n \n+    static constexpr uint32_t max_bytes_per_chunk() noexcept\n+    { return numeric_limits<decltype(_M_bytes)>::max(); }\n+\n     // Determine if block with address p and size block_size\n     // is contained within this chunk.\n     bool owns(void* p, size_t block_size)\n@@ -639,8 +661,7 @@ namespace pmr\n     void replenish(memory_resource* __r, const pool_options& __opts)\n     {\n       using word = chunk::word;\n-      const size_t __blocks\n-\t= std::min<size_t>(__opts.max_blocks_per_chunk, _M_blocks_per_chunk);\n+      const size_t __blocks = _M_blocks_per_chunk;\n       const auto __bits = chunk::bits_per_word;\n       const size_t __words = (__blocks + __bits - 1) / __bits;\n       const size_t __block_size = block_size();\n@@ -658,7 +679,16 @@ namespace pmr\n \t  __r->deallocate(__p, __bytes, __alignment);\n \t}\n       if (_M_blocks_per_chunk < __opts.max_blocks_per_chunk)\n-\t_M_blocks_per_chunk *= 2;\n+\t{\n+\t  const size_t max_blocks\n+\t    = (chunk::max_bytes_per_chunk() - sizeof(word))\n+\t    / (__block_size + 0.125);\n+\t  _M_blocks_per_chunk = std::min({\n+\t      max_blocks,\n+\t      __opts.max_blocks_per_chunk,\n+\t      (size_t)_M_blocks_per_chunk * 2\n+\t  });\n+\t}\n     }\n \n     void release(memory_resource* __r)"}, {"sha": "f995fe9a47be8c53339e9d1e45f12d79ad7d6072", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate-max-chunks.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate-max-chunks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdd58f73a33cceba4da5966c17c356ecc22b0c6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate-max-chunks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate-max-chunks.cc?ref=6bdd58f73a33cceba4da5966c17c356ecc22b0c6", "patch": "@@ -0,0 +1,88 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+\n+struct custom_mr : std::pmr::memory_resource\n+{\n+  custom_mr(std::size_t max) : max(max) { }\n+\n+  bool reached_max = false;\n+\n+private:\n+  std::size_t max;\n+  std::size_t count = 0;\n+\n+  void* do_allocate(std::size_t b, std::size_t a)\n+  {\n+    if (b >= max)\n+      reached_max = true;\n+    count += b;\n+    if (count > (18 * 1024 * 1024))\n+      // Something went wrong, should not need to allocate this much.\n+      throw std::bad_alloc();\n+    return std::pmr::new_delete_resource()->allocate(b, a);\n+  }\n+\n+  void do_deallocate(void* p, std::size_t b, std::size_t a)\n+  { std::pmr::new_delete_resource()->deallocate(p, b, a); }\n+\n+  bool do_is_equal(const memory_resource& r) const noexcept\n+  { return false; }\n+};\n+\n+void\n+test01()\n+{\n+  // Only going to allocate blocks of this size:\n+  const std::size_t block_size = 8;\n+  std::pmr::pool_options opts{};\n+  // Use maximum allowed number of blocks per chunk:\n+  opts.max_blocks_per_chunk = (std::size_t)-1;\n+  opts.largest_required_pool_block = block_size;\n+  {\n+    std::pmr::unsynchronized_pool_resource r(opts);\n+    // Get the real max_blocks_per_chunk that will be used:\n+    opts = r.options();\n+    // Sanity test in case chunk::max_blocks_per_chunk() changes,\n+    // as that could make this test take much longer to run:\n+    VERIFY( opts.max_blocks_per_chunk <= (1 << 19) );\n+  }\n+  custom_mr c(block_size * opts.max_blocks_per_chunk);\n+  std::pmr::unsynchronized_pool_resource r(opts, &c);\n+  // Keep allocating from the pool until reaching the maximum chunk size:\n+  while (!c.reached_max)\n+    (void) r.allocate(block_size, 1);\n+  c.reached_max = false;\n+  // Now fill that maximally-sized chunk\n+  // (this used to go into an infinite loop ):\n+  for (std::size_t i = 0; i < opts.max_blocks_per_chunk; ++i)\n+    (void) r.allocate(block_size, 1);\n+  // Should have filled the maximally-sized chunk and allocated another\n+  // maximally-sized chunk from upstream:\n+  VERIFY( c.reached_max );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}