{"sha": "6c12686bc785194a7e9a7909cfb951e34c9d7355", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMxMjY4NmJjNzg1MTk0YTdlOWE3OTA5Y2ZiOTUxZTM0YzlkNzM1NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-11T06:19:57Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-11T06:19:57Z"}, "message": "re PR fortran/31474 (ENTRY & procedural pointer: insert_bbt(): Duplicate key found!)\n\n2007-05-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31474\n\t* decl.c (get_proc_name): If an entry has already been declared\n\tas a module procedure, pick up the symbol and the symtree and\n\tuse them for the entry.\n\n2007-05-11  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31474\n\t* gfortran.dg/entry_10.f90: New test.\n\nFrom-SVN: r124613", "tree": {"sha": "3fc6b79689fc2c56a85ab8d04947e4fd1fb9f782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fc6b79689fc2c56a85ab8d04947e4fd1fb9f782"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c12686bc785194a7e9a7909cfb951e34c9d7355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c12686bc785194a7e9a7909cfb951e34c9d7355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c12686bc785194a7e9a7909cfb951e34c9d7355", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c12686bc785194a7e9a7909cfb951e34c9d7355/comments", "author": null, "committer": null, "parents": [{"sha": "1b716e906bb86e68c79b3ff73c9786f3aff52dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b716e906bb86e68c79b3ff73c9786f3aff52dc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b716e906bb86e68c79b3ff73c9786f3aff52dc7"}], "stats": {"total": 71, "additions": 65, "deletions": 6}, "files": [{"sha": "342864b39a348125a24ef32dd80e87b8aec6365d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6c12686bc785194a7e9a7909cfb951e34c9d7355", "patch": "@@ -1,3 +1,10 @@\n+2007-05-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31474\n+\t* decl.c (get_proc_name): If an entry has already been declared\n+\tas a module procedure, pick up the symbol and the symtree and\n+\tuse them for the entry.\n+\n 2007-05-08  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/31630"}, {"sha": "9eeacc09427b52a4ab11e82a8e05c762b5282120", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=6c12686bc785194a7e9a7909cfb951e34c9d7355", "patch": "@@ -671,7 +671,12 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n      space is set to point to the master function, so that the fake\n      result mechanism can work.  */\n   if (module_fcn_entry)\n-    rc = gfc_get_symbol (name, NULL, result);\n+    {\n+      /* Present if entry is declared to be a module procedure.  */\n+      rc = gfc_find_symbol (name, gfc_current_ns->parent, 0, result);\n+      if (*result == NULL)\n+\trc = gfc_get_symbol (name, NULL, result);\n+    }\n   else\n     rc = gfc_get_symbol (name, gfc_current_ns->parent, result);\n \n@@ -712,7 +717,12 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n   /* Module function entries will already have a symtree in\n      the current namespace but will need one at module level.  */\n   if (module_fcn_entry)\n-    st = gfc_new_symtree (&gfc_current_ns->parent->sym_root, name);\n+    {\n+      /* Present if entry is declared to be a module procedure.  */\n+      rc = gfc_find_sym_tree (name, gfc_current_ns->parent, 0, &st);\n+      if (st == NULL)\n+\tst = gfc_new_symtree (&gfc_current_ns->parent->sym_root, name);\n+    }\n   else\n     st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n \n@@ -722,10 +732,11 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n   /* See if the procedure should be a module procedure */\n \n   if (((sym->ns->proc_name != NULL\n-\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t&& sym->attr.proc != PROC_MODULE) || module_fcn_entry)\n-       && gfc_add_procedure (&sym->attr, PROC_MODULE,\n-\t\t\t     sym->name, NULL) == FAILURE)\n+\t\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t\t&& sym->attr.proc != PROC_MODULE)\n+\t    || (module_fcn_entry && sym->attr.proc != PROC_MODULE))\n+\t&& gfc_add_procedure (&sym->attr, PROC_MODULE,\n+\t\t\t      sym->name, NULL) == FAILURE)\n     rc = 2;\n \n   return rc;"}, {"sha": "641c0508f20c2e3c7d6e6e90d088db3044394f06", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c12686bc785194a7e9a7909cfb951e34c9d7355", "patch": "@@ -1,3 +1,8 @@\n+2007-05-11  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31474\n+\t* gfortran.dg/entry_10.f90: New test.\n+\n 2007-05-10  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/31885"}, {"sha": "154d44ea9ba9b43d9076f6e716eae5086e6275a8", "filename": "gcc/testsuite/gfortran.dg/entry_10.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c12686bc785194a7e9a7909cfb951e34c9d7355/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_10.f90?ref=6c12686bc785194a7e9a7909cfb951e34c9d7355", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! Test fix for PR31474, in which the use of ENTRYs as module\n+! procedures in a generic interface would cause an internal error.\n+!\n+! Contributed by Michael Richmond <michael.a.richmond@nasa.gov>\n+!\n+module a\n+  interface b\n+    module procedure c, d\n+  end interface\n+contains\n+  real function d (i)\n+    real c, i\n+    integer j\n+    d = 1.0\n+    return\n+  entry c (j)\n+    d = 2.0\n+  end function\n+  real function e (i)\n+    real f, i\n+    integer j\n+    e = 3.0\n+    return\n+  entry f (j)\n+    e = 4.0\n+  end function\n+end module\n+\n+  use a\n+  if (b (1.0) .ne. 1.0) call abort ()\n+  if (b (1  ) .ne. 2.0) call abort ()\n+  if (e (1.0) .ne. 3.0) call abort ()\n+  if (f (1  ) .ne. 4.0) call abort ()\n+end\n+! { dg-final { cleanup-modules \"a\" } }"}]}