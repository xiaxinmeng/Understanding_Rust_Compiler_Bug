{"sha": "43558bcc9df59fc2a1d611030a936931e92cc6e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM1NThiY2M5ZGY1OWZjMmExZDYxMTAzMGE5MzY5MzFlOTJjYzZlNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-11-23T20:01:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-11-23T20:01:29Z"}, "message": "ipa-cp.c (ipcp_compute_node_scale): Work around completely wrong profile updates.\n\n\t* ipa-cp.c (ipcp_compute_node_scale): Work around completely\n\twrong profile updates.\n\t* predict.c (counts_to_freqs): Be expected for ENTRY/EXIT block\n\thaving largest frequency.\n\t* ira-live.c (ira_implicitly_set_insn_hard_regs): Silecne\n\tused uninitalized warning.\n\t* tree-optimize.c (execute_fixup_cfg): Rescale entry and exit block\n\tfrequencies.\n\nFrom-SVN: r154462", "tree": {"sha": "c9663c118c473b5fc50a9f3781ed3452e9f94056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9663c118c473b5fc50a9f3781ed3452e9f94056"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43558bcc9df59fc2a1d611030a936931e92cc6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43558bcc9df59fc2a1d611030a936931e92cc6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43558bcc9df59fc2a1d611030a936931e92cc6e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43558bcc9df59fc2a1d611030a936931e92cc6e5/comments", "author": null, "committer": null, "parents": [{"sha": "bf92569441a43c2d67fa9fa0c11f65fe7ca96bb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf92569441a43c2d67fa9fa0c11f65fe7ca96bb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf92569441a43c2d67fa9fa0c11f65fe7ca96bb7"}], "stats": {"total": 33, "additions": 30, "deletions": 3}, "files": [{"sha": "b8378a58b12bdd42e2c8f746eae87415850620d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43558bcc9df59fc2a1d611030a936931e92cc6e5", "patch": "@@ -1,3 +1,14 @@\n+2009-11-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_compute_node_scale): Work around completely\n+\twrong profile updates.\n+\t* predict.c (counts_to_freqs): Be expected for ENTRY/EXIT block\n+\thaving largest frequency.\n+\t* ira-live.c (ira_implicitly_set_insn_hard_regs): Silecne\n+\tused uninitalized warning.\n+\t* tree-optimize.c (execute_fixup_cfg): Rescale entry and exit block\n+\tfrequencies.\n+\n 2009-11-23  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.md (*cmp_sadd_sidi): Use gen_lowpart instead"}, {"sha": "2af2c7f2d6fb9abc167aec4eda5f6c6e2f85a8bd", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=43558bcc9df59fc2a1d611030a936931e92cc6e5", "patch": "@@ -578,7 +578,13 @@ build_const_val (struct ipcp_lattice *lat, tree tree_type)\n \n /* Compute the proper scale for NODE.  It is the ratio between the number of\n    direct calls (represented on the incoming cgraph_edges) and sum of all\n-   invocations of NODE (represented as count in cgraph_node).  */\n+   invocations of NODE (represented as count in cgraph_node).\n+\n+   FIXME: This code is wrong.  Since the callers can be also clones and\n+   the clones are not scaled yet, the sums gets unrealistically high.\n+   To properly compute the counts, we would need to do propagation across\n+   callgraph (as external call to A might imply call to non-clonned B\n+   if A's clone calls clonned B).  */\n static void\n ipcp_compute_node_scale (struct cgraph_node *node)\n {\n@@ -589,6 +595,12 @@ ipcp_compute_node_scale (struct cgraph_node *node)\n   /* Compute sum of all counts of callers. */\n   for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n     sum += cs->count;\n+  /* Work around the unrealistically high sum problem.  We just don't want\n+     the non-cloned body to have negative or very low frequency.  Since\n+     majority of execution time will be spent in clones anyway, this should\n+     give good enough profile.  */\n+  if (sum > node->count * 9 / 10)\n+    sum = node->count * 9 / 10;\n   if (node->count == 0)\n     ipcp_set_node_scale (node, 0);\n   else"}, {"sha": "ea241f4732cad0d407106dad2455ff8ccea37f9f", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=43558bcc9df59fc2a1d611030a936931e92cc6e5", "patch": "@@ -745,7 +745,7 @@ single_reg_operand_class (int op_num)\n void\n ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n {\n-  int i, c, regno;\n+  int i, c, regno = 0;\n   bool ignore_p;\n   enum reg_class cl;\n   rtx op;"}, {"sha": "058901e5903d2813fff149b51676caf30bb67735", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=43558bcc9df59fc2a1d611030a936931e92cc6e5", "patch": "@@ -2020,7 +2020,7 @@ counts_to_freqs (void)\n   gcov_type count_max, true_count_max = 0;\n   basic_block bb;\n \n-  FOR_EACH_BB (bb)\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     true_count_max = MAX (bb->count, true_count_max);\n \n   count_max = MAX (true_count_max, 1);"}, {"sha": "778658a70b47dc1cbb2b78f211b7a41dd570b021", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43558bcc9df59fc2a1d611030a936931e92cc6e5/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=43558bcc9df59fc2a1d611030a936931e92cc6e5", "patch": "@@ -255,6 +255,10 @@ execute_fixup_cfg (void)\n   else\n     count_scale = REG_BR_PROB_BASE;\n \n+  ENTRY_BLOCK_PTR->count = cgraph_node (current_function_decl)->count;\n+  EXIT_BLOCK_PTR->count = (EXIT_BLOCK_PTR->count * count_scale\n+  \t\t\t   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+\n   FOR_EACH_BB (bb)\n     {\n       bb->count = (bb->count * count_scale"}]}