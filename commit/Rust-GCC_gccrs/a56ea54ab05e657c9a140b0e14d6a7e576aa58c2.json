{"sha": "a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2ZWE1NGFiMDVlNjU3YzlhMTQwYjBlMTRkNmE3ZTU3NmFhNThjMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-08-05T12:06:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-08-05T12:06:25Z"}, "message": "re PR fortran/52846 ([F2008] Support submodules)\n\n2015-08-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52846\n\t* module.c (check_access): Return true if new static flag\n\t'dump_smod' is true..\n\t(gfc_dump_module): Rename original 'dump_module' and call from\n\tnew version. Use 'dump_smod' rather than the stack state to\n\tdetermine if a submodule is being processed. The new version of\n\tthis procedure sets 'dump_smod' depending on the stack state and\n\tthen writes both the mod and smod files if a module is being\n\tprocessed or just the smod for a submodule.\n\t(gfc_use_module): Eliminate the check for module_name and\n\tsubmodule_name being the same.\n\t* trans-decl.c (gfc_finish_var_decl, gfc_build_qualified_array,\n\tget_proc_pointer_decl): Set TREE_PUBLIC unconditionally and use\n\tthe conditions to set DECL_VISIBILITY as hidden and to set as\n\ttrue DECL_VISIBILITY_SPECIFIED.\n\n2015-08-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/52846\n\n\t* lib/fortran-modules.exp: Call cleanup-submodules from\n\tcleanup-modules.\n\t* gfortran.dg/public_private_module_2.f90: Add two XFAILS to\n\tcover the cases where private entities are no longer optimized\n\taway.\n\t* gfortran.dg/public_private_module_6.f90: Add an XFAIL for the\n\tsame reason.\n\t* gfortran.dg/submodule_1.f08: Change cleanup module names.\n\t* gfortran.dg/submodule_5.f08: The same.\n\t* gfortran.dg/submodule_9.f08: The same.\n\t* gfortran.dg/submodule_10.f08: New test\n\nFrom-SVN: r226622", "tree": {"sha": "c59e00ca13501b665157dd141e5829a813fb5c5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59e00ca13501b665157dd141e5829a813fb5c5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/comments", "author": null, "committer": null, "parents": [{"sha": "8282c8776d3727948daa41fa340f6b16d4f563d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8282c8776d3727948daa41fa340f6b16d4f563d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8282c8776d3727948daa41fa340f6b16d4f563d4"}], "stats": {"total": 363, "additions": 309, "deletions": 54}, "files": [{"sha": "008d3bd1c0562a8f3150a04f8d4b0cfb237a9571", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -1,3 +1,21 @@\n+2015-08-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/52846\n+\t* module.c (check_access): Return true if new static flag\n+\t'dump_smod' is true..\n+\t(gfc_dump_module): Rename original 'dump_module' and call from\n+\tnew version. Use 'dump_smod' rather than the stack state to\n+\tdetermine if a submodule is being processed. The new version of\n+\tthis procedure sets 'dump_smod' depending on the stack state and\n+\tthen writes both the mod and smod files if a module is being\n+\tprocessed or just the smod for a submodule.\n+\t(gfc_use_module): Eliminate the check for module_name and\n+\tsubmodule_name being the same.\n+\t* trans-decl.c (gfc_finish_var_decl, gfc_build_qualified_array,\n+\tget_proc_pointer_decl): Set TREE_PUBLIC unconditionally and use\n+\tthe conditions to set DECL_VISIBILITY as hidden and to set as\n+\ttrue DECL_VISIBILITY_SPECIFIED.\n+\n 2015-08-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/64022"}, {"sha": "86dca1c5382dde5fd8992f844bedbe9c0e1d4eca", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -525,9 +525,9 @@ gfc_match_use (void)\n   gfc_intrinsic_op op;\n   match m;\n   gfc_use_list *use_list;\n- \n+\n   use_list = gfc_get_use_list ();\n-  \n+\n   if (gfc_match (\" , \") == MATCH_YES)\n     {\n       if ((m = gfc_match (\" %n ::\", module_nature)) == MATCH_YES)\n@@ -1080,7 +1080,7 @@ gzopen_included_file_1 (const char *name, gfc_directorylist *list,\n   return NULL;\n }\n \n-static gzFile \n+static gzFile\n gzopen_included_file (const char *name, bool include_cwd, bool module)\n {\n   gzFile f = NULL;\n@@ -1660,7 +1660,7 @@ write_atom (atom_type atom, const void *v)\n \n     }\n \n-  if(p == NULL || *p == '\\0') \n+  if(p == NULL || *p == '\\0')\n      len = 0;\n   else\n   len = strlen (p);\n@@ -1856,7 +1856,7 @@ unquote_string (const char *s)\n     {\n       if (*p != '\\\\')\n \tcontinue;\n-\t\n+\n       if (p[1] == '\\\\')\n \tp++;\n       else if (p[1] == 'U')\n@@ -2106,7 +2106,7 @@ mio_symbol_attribute (symbol_attribute *attr)\n   attr->proc = MIO_NAME (procedure_type) (attr->proc, procedures);\n   attr->if_source = MIO_NAME (ifsrc) (attr->if_source, ifsrc_types);\n   attr->save = MIO_NAME (save_state) (attr->save, save_status);\n-  \n+\n   ext_attr = attr->ext_attr;\n   mio_integer ((int *) &ext_attr);\n   attr->ext_attr = ext_attr;\n@@ -2472,7 +2472,7 @@ mio_typespec (gfc_typespec *ts)\n   /* Add info for C interop and is_iso_c.  */\n   mio_integer (&ts->is_c_interop);\n   mio_integer (&ts->is_iso_c);\n-  \n+\n   /* If the typespec is for an identifier either from iso_c_binding, or\n      a constant that was initialized to an identifier from it, use the\n      f90_type.  Otherwise, use the ts->type, since it shouldn't matter.  */\n@@ -2725,7 +2725,7 @@ mio_component (gfc_component *c, int vtype)\n   mio_symbol_attribute (&c->attr);\n   if (c->ts.type == BT_CLASS)\n     c->attr.class_ok = 1;\n-  c->attr.access = MIO_NAME (gfc_access) (c->attr.access, access_types); \n+  c->attr.access = MIO_NAME (gfc_access) (c->attr.access, access_types);\n \n   if (!vtype || strcmp (c->name, \"_final\") == 0\n       || strcmp (c->name, \"_hash\") == 0)\n@@ -2925,7 +2925,7 @@ mio_symtree_ref (gfc_symtree **stp)\n \t    resolve_fixups (p->fixup, p->u.rsym.sym);\n \t  p->fixup = NULL;\n \t}\n-      \n+\n       if (p->type == P_UNKNOWN)\n \tp->type = P_SYMBOL;\n \n@@ -3260,7 +3260,7 @@ static const mstring intrinsics[] =\n \n \n /* Remedy a couple of situations where the gfc_expr's can be defective.  */\n- \n+\n static void\n fix_mio_expr (gfc_expr *e)\n {\n@@ -3830,7 +3830,7 @@ mio_full_typebound_tree (gfc_symtree** root)\n \t{\n \t  gfc_symtree* st;\n \n-\t  mio_lparen (); \n+\t  mio_lparen ();\n \n \t  require_atom (ATOM_STRING);\n \t  st = gfc_get_tbp_symtree (root, atom_string);\n@@ -3931,7 +3931,7 @@ static void\n mio_full_f2k_derived (gfc_symbol *sym)\n {\n   mio_lparen ();\n-  \n+\n   if (iomode == IO_OUTPUT)\n     {\n       if (sym->f2k_derived)\n@@ -4158,7 +4158,7 @@ static void\n mio_symbol (gfc_symbol *sym)\n {\n   int intmod = INTMOD_NONE;\n-  \n+\n   mio_lparen ();\n \n   mio_symbol_attribute (&sym->attr);\n@@ -4219,7 +4219,7 @@ mio_symbol (gfc_symbol *sym)\n       else\n \tsym->from_intmod = (intmod_id) intmod;\n     }\n-  \n+\n   mio_integer (&(sym->intmod_sym_id));\n \n   if (sym->attr.flavor == FL_DERIVED)\n@@ -4559,7 +4559,7 @@ load_commons (void)\n       if (strlen (label))\n \tp->binding_label = IDENTIFIER_POINTER (get_identifier (label));\n       XDELETEVEC (label);\n-      \n+\n       mio_rparen ();\n     }\n \n@@ -4805,7 +4805,7 @@ load_needed (pointer_info *p)\n       sym->name = dt_lower_string (p->u.rsym.true_name);\n       sym->module = gfc_get_string (p->u.rsym.module);\n       if (p->u.rsym.binding_label)\n-\tsym->binding_label = IDENTIFIER_POINTER (get_identifier \n+\tsym->binding_label = IDENTIFIER_POINTER (get_identifier\n \t\t\t\t\t\t (p->u.rsym.binding_label));\n \n       associate_integer_pointer (p, sym);\n@@ -4989,7 +4989,7 @@ read_module (void)\n \tinfo->u.rsym.binding_label = bind_label;\n       else\n \tXDELETEVEC (bind_label);\n-      \n+\n       require_atom (ATOM_INTEGER);\n       info->u.rsym.ns = atom_int;\n \n@@ -5165,8 +5165,8 @@ read_module (void)\n \t\t  sym->module = gfc_get_string (info->u.rsym.module);\n \n \t\t  if (info->u.rsym.binding_label)\n-\t\t    sym->binding_label = \n-\t\t      IDENTIFIER_POINTER (get_identifier \n+\t\t    sym->binding_label =\n+\t\t      IDENTIFIER_POINTER (get_identifier\n \t\t\t\t\t  (info->u.rsym.binding_label));\n \t\t}\n \n@@ -5279,13 +5279,18 @@ read_module (void)\n \n /* Given an access type that is specific to an entity and the default\n    access, return nonzero if the entity is publicly accessible.  If the\n-   element is declared as PUBLIC, then it is public; if declared \n+   element is declared as PUBLIC, then it is public; if declared\n    PRIVATE, then private, and otherwise it is public unless the default\n    access in this context has been declared PRIVATE.  */\n \n+static bool dump_smod = false;\n+\n static bool\n check_access (gfc_access specific_access, gfc_access default_access)\n {\n+  if (dump_smod)\n+    return true;\n+\n   if (specific_access == ACCESS_PUBLIC)\n     return TRUE;\n   if (specific_access == ACCESS_PRIVATE)\n@@ -5359,7 +5364,7 @@ write_common_0 (gfc_symtree *st, bool this_module)\n   const char *label;\n   struct written_common *w;\n   bool write_me = true;\n-\t      \n+\n   if (st == NULL)\n     return;\n \n@@ -5436,8 +5441,8 @@ write_blank_common (void)\n   const char * name = BLANK_COMMON_NAME;\n   int saved;\n   /* TODO: Blank commons are not bind(c).  The F2003 standard probably says\n-     this, but it hasn't been checked.  Just making it so for now.  */  \n-  int is_bind_c = 0;  \n+     this, but it hasn't been checked.  Just making it so for now.  */\n+  int is_bind_c = 0;\n \n   if (gfc_current_ns->blank_common.head == NULL)\n     return;\n@@ -5697,8 +5702,8 @@ find_symbols_to_write(sorted_pointer_info **tree, pointer_info *p)\n   if (p->type == P_SYMBOL && p->u.wsym.state == NEEDS_WRITE)\n     {\n       sorted_pointer_info *sp = gfc_get_sorted_pointer_info();\n-      sp->p = p; \n- \n+      sp->p = p;\n+\n       gfc_insert_bbt (tree, sp, compare_sorted_pointer_info);\n    }\n \n@@ -5724,7 +5729,7 @@ write_symbol1_recursion (sorted_pointer_info *sp)\n   p1->u.wsym.state = WRITTEN;\n   write_symbol (p1->integer, p1->u.wsym.sym);\n   p1->u.wsym.sym->attr.public_used = 1;\n- \n+\n   write_symbol1_recursion (sp->right);\n }\n \n@@ -5945,10 +5950,10 @@ read_crc32_from_module_file (const char* filename, uLong* crc)\n   /* Close the file.  */\n   fclose (file);\n \n-  val = (buf[0] & 0xFF) + ((buf[1] & 0xFF) << 8) + ((buf[2] & 0xFF) << 16) \n+  val = (buf[0] & 0xFF) + ((buf[1] & 0xFF) << 8) + ((buf[2] & 0xFF) << 16)\n     + ((buf[3] & 0xFF) << 24);\n   *crc = val;\n-  \n+\n   /* For debugging, the CRC value printed in hexadecimal should match\n      the CRC printed by \"zcat -l -v filename\".\n      printf(\"CRC of file %s is %x\\n\", filename, val); */\n@@ -5961,22 +5966,22 @@ read_crc32_from_module_file (const char* filename, uLong* crc)\n    processing the module, dump_flag will be set to zero and we delete\n    the module file, even if it was already there.  */\n \n-void\n-gfc_dump_module (const char *name, int dump_flag)\n+static void\n+dump_module (const char *name, int dump_flag)\n {\n   int n;\n   char *filename, *filename_tmp;\n   uLong crc, crc_old;\n \n   module_name = gfc_get_string (name);\n \n-  if (gfc_state_stack->state == COMP_SUBMODULE)\n+  if (dump_smod)\n     {\n       name = submodule_name;\n       n = strlen (name) + strlen (SUBMODULE_EXTENSION) + 1;\n     }\n   else\n-  n = strlen (name) + strlen (MODULE_EXTENSION) + 1;\n+    n = strlen (name) + strlen (MODULE_EXTENSION) + 1;\n \n   if (gfc_option.module_dir != NULL)\n     {\n@@ -5991,7 +5996,7 @@ gfc_dump_module (const char *name, int dump_flag)\n       strcpy (filename, name);\n     }\n \n-  if (gfc_state_stack->state == COMP_SUBMODULE)\n+  if (dump_smod)\n     strcat (filename, SUBMODULE_EXTENSION);\n   else\n   strcat (filename, MODULE_EXTENSION);\n@@ -6060,6 +6065,27 @@ gfc_dump_module (const char *name, int dump_flag)\n }\n \n \n+void\n+gfc_dump_module (const char *name, int dump_flag)\n+{\n+  if (gfc_state_stack->state == COMP_SUBMODULE)\n+    dump_smod = true;\n+  else\n+    dump_smod =false;\n+\n+  dump_module (name, dump_flag);\n+\n+  if (dump_smod)\n+    return;\n+\n+  /* Write a submodule file from a module.  The 'dump_smod' flag switches\n+     off the check for PRIVATE entities.  */\n+  dump_smod = true;\n+  submodule_name = module_name;\n+  dump_module (name, dump_flag);\n+  dump_smod = false;\n+}\n+\n static void\n create_intrinsic_function (const char *name, int id,\n \t\t\t   const char *modname, intmod_id module,\n@@ -6140,7 +6166,7 @@ import_iso_c_binding_module (void)\n       /* symtree doesn't already exist in current namespace.  */\n       gfc_get_sym_tree (iso_c_module_name, gfc_current_ns, &mod_symtree,\n \t\t\tfalse);\n-      \n+\n       if (mod_symtree != NULL)\n \tmod_sym = mod_symtree->n.sym;\n       else\n@@ -6452,7 +6478,7 @@ create_int_parameter_array (const char *name, int size, gfc_expr *value,\n   sym->as->rank = 1;\n   sym->as->type = AS_EXPLICIT;\n   sym->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n-  sym->as->upper[0] = gfc_get_int_expr (gfc_default_integer_kind, NULL, size); \n+  sym->as->upper[0] = gfc_get_int_expr (gfc_default_integer_kind, NULL, size);\n \n   sym->value = value;\n   sym->value->shape = gfc_get_shape (1);\n@@ -6754,13 +6780,12 @@ gfc_use_module (gfc_use_list *module)\n \t\t     \"USE statement at %C has no ONLY qualifier\");\n \n   if (gfc_state_stack->state == COMP_MODULE\n-      || module->submodule_name == NULL\n-      || strcmp (module_name, module->submodule_name) == 0)\n+      || module->submodule_name == NULL)\n     {\n       filename = XALLOCAVEC (char, strlen (module_name)\n \t\t\t\t   + strlen (MODULE_EXTENSION) + 1);\n-  strcpy (filename, module_name);\n-  strcat (filename, MODULE_EXTENSION);\n+      strcpy (filename, module_name);\n+      strcat (filename, MODULE_EXTENSION);\n     }\n   else\n     {\n@@ -7003,7 +7028,7 @@ gfc_use_modules (void)\n \t\t  r->next = next->rename;\n \t\t  next->rename = seek->rename;\n \t\t}\n-\t      last->next = seek->next; \n+\t      last->next = seek->next;\n \t      free (seek);\n \t    }\n \t  else"}, {"sha": "269c235e465d45dda261defa22e863aa4e6397e3", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -596,6 +596,11 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n \t both, of course.) (J3/04-007, section 15.3).  */\n       TREE_PUBLIC(decl) = 1;\n       DECL_COMMON(decl) = 1;\n+      if (sym->attr.access == ACCESS_PRIVATE && !sym->attr.public_used)\n+\t{\n+\t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+\t  DECL_VISIBILITY_SPECIFIED (decl) = true;\n+\t}\n     }\n \n   /* If a variable is USE associated, it's always external.  */\n@@ -609,9 +614,13 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       /* TODO: Don't set sym->module for result or dummy variables.  */\n       gcc_assert (current_function_decl == NULL_TREE || sym->result == sym);\n \n-      if (sym->attr.access != ACCESS_PRIVATE || sym->attr.public_used)\n-\tTREE_PUBLIC (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n       TREE_STATIC (decl) = 1;\n+      if (sym->attr.access == ACCESS_PRIVATE && !sym->attr.public_used)\n+\t{\n+\t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+\t  DECL_VISIBILITY_SPECIFIED (decl) = true;\n+\t}\n     }\n \n   /* Derived types are a bit peculiar because of the possibility of\n@@ -837,9 +846,13 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \t  else\n \t    TREE_STATIC (token) = 1;\n \n-\t  if (sym->attr.use_assoc || sym->attr.access != ACCESS_PRIVATE ||\n-\t      sym->attr.public_used)\n-\t    TREE_PUBLIC (token) = 1;\n+\t  TREE_PUBLIC (token) = 1;\n+\n+\t  if (sym->attr.access == ACCESS_PRIVATE && !sym->attr.public_used)\n+\t    {\n+\t      DECL_VISIBILITY (token) = VISIBILITY_HIDDEN;\n+\t      DECL_VISIBILITY_SPECIFIED (token) = true;\n+\t    }\n \t}\n       else\n \t{\n@@ -1747,9 +1760,12 @@ get_proc_pointer_decl (gfc_symbol *sym)\n   else if (sym->module && sym->ns->proc_name->attr.flavor == FL_MODULE)\n     {\n       /* This is the declaration of a module variable.  */\n-      if (sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t  && (sym->attr.access != ACCESS_PRIVATE || sym->attr.public_used))\n-\tTREE_PUBLIC (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+      if (sym->attr.access == ACCESS_PRIVATE && !sym->attr.public_used)\n+\t{\n+\t  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+\t  DECL_VISIBILITY_SPECIFIED (decl) = true;\n+\t}\n       TREE_STATIC (decl) = 1;\n     }\n "}, {"sha": "d1bb135d8bb0d9dd8267544e6f57447c3f890e7d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -1,3 +1,19 @@\n+2015-08-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/52846\n+\n+\t* lib/fortran-modules.exp: Call cleanup-submodules from\n+\tcleanup-modules.\n+\t* gfortran.dg/public_private_module_2.f90: Add two XFAILS to\n+\tcover the cases where private entities are no longer optimized\n+\taway.\n+\t* gfortran.dg/public_private_module_6.f90: Add an XFAIL for the\n+\tsame reason.\n+\t* gfortran.dg/submodule_1.f08: Change cleanup module names.\n+\t* gfortran.dg/submodule_5.f08: The same.\n+\t* gfortran.dg/submodule_9.f08: The same.\n+\t* gfortran.dg/submodule_10.f08: New test.\n+\n 2015-08-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/66595"}, {"sha": "4c72b2cb55d0080ba869ab2f40a8c28bd923e20d", "filename": "gcc/testsuite/gfortran.dg/public_private_module_2.f90", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_2.f90?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -18,12 +18,15 @@ module mod\n         integer, bind(C,name='') :: qq\n       end module mod\n \n+! The two xfails below have appeared with the introduction of submodules. 'iii' and\n+! 'mmm' now are TREE_PUBLIC but has DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN set.\n+\n       ! { dg-final { scan-assembler \"__mod_MOD_aa\" } }\n-      ! { dg-final { scan-assembler-not \"iii\" } }\n+      ! { dg-final { scan-assembler-not \"iii\" { xfail *-*-* } } }\n       ! { dg-final { scan-assembler \"jj\" } }\n       ! { dg-final { scan-assembler \"lll\" } }\n       ! { dg-final { scan-assembler-not \"kk\" } }\n-      ! { dg-final { scan-assembler-not \"mmmm\" } }\n+      ! { dg-final { scan-assembler-not \"mmmm\" { xfail *-*-* } } }\n       ! { dg-final { scan-assembler \"nnn\" } }\n       ! { dg-final { scan-assembler \"oo\" } }\n       ! { dg-final { scan-assembler \"__mod_MOD_qq\" } }"}, {"sha": "75b1a972c2370370f46a8c01d291f5a2b1da312f", "filename": "gcc/testsuite/gfortran.dg/public_private_module_6.f90", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpublic_private_module_6.f90?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -11,4 +11,7 @@ module m\n   integer, save :: aaaa\n end module m\n \n-! { dg-final { scan-assembler-not \"aaaa\" } }\n+! The xfail below has appeared with the introduction of submodules. 'aaaa'\n+! now is TREE_PUBLIC but has DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN set.\n+\n+! { dg-final { scan-assembler-not \"aaaa\" { xfail *-*-* } } }"}, {"sha": "578492e54e7cb6438f5a3087625039b1fb058c98", "filename": "gcc/testsuite/gfortran.dg/submodule_1.f08", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_1.f08?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -170,6 +170,6 @@ subroutine clear_messages\n      message2 = \"\"\n    end subroutine\n  end program\n-! { dg-final { cleanup-submodules \"foo_interface_son\" } }\n-! { dg-final { cleanup-submodules \"foo_interface_grandson\" } }\n-! { dg-final { cleanup-submodules \"foo_interface_daughter\" } }\n+! { dg-final { cleanup-submodules \"foo_interface@foo_interface_son\" } }\n+! { dg-final { cleanup-submodules \"foo_interface@foo_interface_grandson\" } }\n+! { dg-final { cleanup-submodules \"foo_interface@foo_interface_daughter\" } }"}, {"sha": "4671e393ddc411f6e7a0aa3936045f6d1c9e1f34", "filename": "gcc/testsuite/gfortran.dg/submodule_10.f08", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_10.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_10.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_10.f08?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -0,0 +1,170 @@\n+! { dg-do compile }\n+!\n+! Checks that PRIVATE enities are visible to submodules.\n+!\n+! Contributed by Salvatore Filippone  <salvatore.filippone@uniroma2.it>\n+!\n+module const_mod\n+  integer, parameter  :: ndig=8\n+  integer, parameter  :: ipk_ = selected_int_kind(ndig)\n+  integer, parameter  :: longndig=12\n+  integer, parameter  :: long_int_k_ = selected_int_kind(longndig)\n+  integer, parameter  :: mpik_ = kind(1)\n+\n+  integer(ipk_), parameter, public :: success_=0\n+\n+end module const_mod\n+\n+\n+module error_mod\n+  use const_mod\n+\n+  integer(ipk_), parameter, public :: act_ret_=0\n+  integer(ipk_), parameter, public :: act_print_=1\n+  integer(ipk_), parameter, public :: act_abort_=2\n+\n+  integer(ipk_), parameter, public ::  no_err_ = 0\n+\n+  public error, errcomm, get_numerr, &\n+       & error_handler, &\n+       & ser_error_handler, par_error_handler\n+\n+\n+  interface error_handler\n+    module subroutine ser_error_handler(err_act)\n+      integer(ipk_), intent(inout) ::  err_act\n+    end subroutine ser_error_handler\n+    module subroutine par_error_handler(ictxt,err_act)\n+      integer(mpik_), intent(in) ::  ictxt\n+      integer(ipk_), intent(in) ::  err_act\n+    end subroutine par_error_handler\n+  end interface\n+\n+  interface error\n+    module subroutine serror()\n+    end subroutine serror\n+    module subroutine perror(ictxt,abrt)\n+      integer(mpik_), intent(in) ::  ictxt\n+      logical, intent(in), optional  :: abrt\n+    end subroutine perror\n+  end interface\n+\n+\n+  interface error_print_stack\n+    module subroutine par_error_print_stack(ictxt)\n+      integer(mpik_), intent(in) ::  ictxt\n+    end subroutine par_error_print_stack\n+    module subroutine ser_error_print_stack()\n+    end subroutine ser_error_print_stack\n+  end interface\n+\n+  interface errcomm\n+    module subroutine errcomm(ictxt, err)\n+      integer(mpik_), intent(in)   :: ictxt\n+      integer(ipk_), intent(inout):: err\n+    end subroutine errcomm\n+  end interface errcomm\n+\n+\n+  private\n+\n+  type errstack_node\n+\n+    integer(ipk_) ::   err_code=0\n+    character(len=20)        ::   routine=''\n+    integer(ipk_),dimension(5)     ::   i_err_data=0\n+    character(len=40)        ::   a_err_data=''\n+    type(errstack_node), pointer :: next\n+\n+  end type errstack_node\n+\n+\n+  type errstack\n+    type(errstack_node), pointer :: top => null()\n+    integer(ipk_) :: n_elems=0\n+  end type errstack\n+\n+\n+  type(errstack), save  :: error_stack\n+  integer(ipk_), save   :: error_status    = no_err_\n+  integer(ipk_), save   :: verbosity_level = 1\n+  integer(ipk_), save   :: err_action      = act_abort_\n+  integer(ipk_), save   :: debug_level     = 0, debug_unit, serial_debug_level=0\n+\n+contains\n+end module error_mod\n+\n+submodule (error_mod) error_impl_mod\n+  use const_mod\n+contains\n+  ! checks whether an error has occurred on one of the processes in the execution pool\n+  subroutine errcomm(ictxt, err)\n+    integer(mpik_), intent(in)   :: ictxt\n+    integer(ipk_), intent(inout):: err\n+\n+\n+  end subroutine errcomm\n+\n+  subroutine ser_error_handler(err_act)\n+    implicit none\n+    integer(ipk_), intent(inout) ::  err_act\n+\n+    if (err_act /= act_ret_)     &\n+         &  call error()\n+    if (err_act == act_abort_) stop\n+\n+    return\n+  end subroutine ser_error_handler\n+\n+  subroutine par_error_handler(ictxt,err_act)\n+    implicit none\n+    integer(mpik_), intent(in) ::  ictxt\n+    integer(ipk_), intent(in) ::  err_act\n+\n+    if (err_act == act_print_)     &\n+         &  call error(ictxt, abrt=.false.)\n+    if (err_act == act_abort_)      &\n+         &  call error(ictxt, abrt=.true.)\n+\n+    return\n+\n+  end subroutine par_error_handler\n+\n+  subroutine par_error_print_stack(ictxt)\n+    integer(mpik_), intent(in) ::  ictxt\n+\n+    call error(ictxt, abrt=.false.)\n+\n+  end subroutine par_error_print_stack\n+\n+  subroutine ser_error_print_stack()\n+\n+    call error()\n+  end subroutine ser_error_print_stack\n+\n+  subroutine serror()\n+\n+    implicit none\n+\n+  end subroutine serror\n+\n+  subroutine perror(ictxt,abrt)\n+    use const_mod\n+    implicit none\n+    integer(mpik_), intent(in) :: ictxt\n+    logical, intent(in), optional  :: abrt\n+\n+  end subroutine perror\n+\n+end submodule error_impl_mod\n+\n+program testlk\n+  use error_mod\n+  implicit none\n+\n+  call error()\n+\n+  stop\n+end program testlk\n+! { dg-final { cleanup-submodules \"error_mod@error_impl_mod\" } }\n+"}, {"sha": "78f8b9ab5120d26407679a759d2a7399a7377eeb", "filename": "gcc/testsuite/gfortran.dg/submodule_5.f08", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_5.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_5.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_5.f08?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -49,3 +49,4 @@ subroutine foobar (arg)\n end SUBMODULE foo_interface_daughter\n \n end\n+! { dg-final { cleanup-submodules \"foo_interface@foo_interface_daughter\" } }"}, {"sha": "873979d1feb1db3e4669313d5e23693d8d733475", "filename": "gcc/testsuite/gfortran.dg/submodule_9.f08", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_9.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_9.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_9.f08?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -38,3 +38,4 @@ program a_s\n   implicit none\n   call p()\n end program\n+! { dg-final { cleanup-submodules \"mod_a@b\" } }"}, {"sha": "f1f04d9d15d3a7c1c8ec5b6f5c66dd574d60b69e", "filename": "gcc/testsuite/lib/fortran-modules.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Flib%2Ffortran-modules.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ea54ab05e657c9a140b0e14d6a7e576aa58c2/gcc%2Ftestsuite%2Flib%2Ffortran-modules.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ffortran-modules.exp?ref=a56ea54ab05e657c9a140b0e14d6a7e576aa58c2", "patch": "@@ -17,6 +17,7 @@\n # helper to deal with fortran modules\n \n # Remove files for specified Fortran modules.\n+# This includes both .mod and .smod files.\n proc cleanup-modules { modlist } {\n     global clean\n     foreach mod [concat $modlist $clean] {\n@@ -27,6 +28,7 @@ proc cleanup-modules { modlist } {\n \t}\n \tremote_file build delete $m\n     }\n+    cleanup-submodules $modlist\n }\n \n # Remove files for specified Fortran submodules."}]}