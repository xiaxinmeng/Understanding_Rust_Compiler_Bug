{"sha": "a968d80d0e89e847a1928842b7de166a6d42c92e", "node_id": "C_kwDOANBUbNoAKGE5NjhkODBkMGU4OWU4NDdhMTkyODg0MmI3ZGUxNjZhNmQ0MmM5MmU", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2022-08-31T14:52:11Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-12T08:16:51Z"}, "message": "[Ada] Tech debt: Expansion of contracts\n\nThis patch modifies the expansion of contracts such that the statements\nand declarations of a subprogram with post-execution checks get moved to\na local internally generated subprogram which the original subprogram\ncalls directly followed by the required post-execution checks.\n\nThis differs from the current implementation which requires delicate\nmachinary which coordinates with the finalization process to emulate the\ndesired behavior within the \"at end\" procedure.\n\ngcc/ada/\n\n\t* contracts.adb, contracts.ads\n\t(Analyze_Pragmas_In_Declarations): Added to aid in the new\n\texpansion model so that pragmas relating to contracts can get\n\tprocessed early before the rest of the subprogram containing them.\n\t(Build_Subprogram_Contract_Wrapper): Created to do the majority of\n\texpansion for postconditions. It builds a local wrapper with the\n\tstatements and declarations within a given subprogram.\n\t(Is_Prologue_Renaming): Moved out from Process_Preconditions to be\n\tused generally within the contracts package.\n\t(Build_Entry_Contract_Wrapper): Moved from exp_ch7.\n\t(Expand_Subprogram_Contract): Add new local variable Decls to\n\tstore expanded declarations needed for evaluation of contracts.\n\tCall new wrapper building procedure and modify comments to match\n\tnew expansion model.\n\t(Get_Postcond_Enabled): Deleted.\n\t(Get_Result_Object_For_Postcond): Deleted.\n\t(Get_Return_Success_For_Postcond): Deleted.\n\t(Process_Contract_Cases): Add new parameter to store declarations.\n\t(Process_Postconditions): Add new parameter to store declarations.\n\t(Process_Preconditions): Add new parameter to store declarations.\n\tAdd code to move entry-call prologue renamings\n\t* einfo.ads: Document new field Wrapped_Statements and modify\n\tcomment for Postconditions_Proc.\n\t* exp_attr.adb\n\t(Analyze_Attribute): Modify expansion of the 'Old attribute to\n\trecognize new expansion model and use Wrapped_Statements instead\n\tof Postconditions_Proc.\n\t* exp_ch6.adb\n\t(Add_Return): Remove special expansion for postconditions.\n\t(Expand_Call): Modify condition checking for calls to access\n\tsubprogram wrappers to handle new expansion models.\n\t(Expand_Call_Helper): Remove special expansion for postconditions.\n\t(Expand_Non_Function_Return): Remove special expansion for\n\tpostconditions.\n\t(Expand_Simple_Function_Return): Remove special expansion for\n\tpostconditions.\n\t* exp_ch7.adb\n\t(Build_Finalizer): Deleted, but replaced by code in\n\tBuild_Finalizer_Helper\n\t(Build_Finalizer_Helper): Renamed to Build_Finalizer, and special\n\thandling of 'Old objects removed.\n\t* exp_ch9.adb\n\t(Build_Contract_Wrapper): Renamed and moved to contracts package.\n\t* exp_prag.adb\n\t(Expand_Pragma_Contract_Cases): Delay analysis of contracts since\n\tthey now instead get analyzed as part of the wrapper generation\n\tinstead of after analysis of their corresponding subprogram's\n\tbody.\n\t(Expand_Pragma_Check): Label expanded if-statements which come\n\tfrom the expansion of assertion statements as\n\tComes_From_Check_Or_Contract.\n\t* freeze.adb\n\t(Freeze_Entity): Add special case to avoid freezing when a freeze\n\tnode gets generated as part of the expansion of a postcondition\n\tcheck.\n\t* gen_il-gen-gen_nodes.adb: Add new flag\n\tComes_From_Check_Or_Contract.\n\t* gen_il-fields.ads: Add new field Wrapped_Statements. Add new\n\tflag Comes_From_Check_Or_Contract.\n\t* gen_il-gen-gen_entities.adb: Add new field Wrapped_Statements.\n\t* ghost.adb\n\t(Is_OK_Declaration): Replace Name_uPostconditions with\n\tName_uWrapped_Statements.\n\t(Is_OK_Statement): Simplify condition due to the loss of\n\tOriginal_Node as a result of the new expansion model of contracts\n\tand use new flag Comes_From_Check_Or_Contract in its place.\n\t* inline.adb\n\t(Declare_Postconditions_Result): Replace Name_uPostconditions with\n\tName_uWrapped_Statements.\n\t(Expand_Inlined_Call): Replace Name_uPostconditions with\n\tName_uWrapped_Statements.\n\t* lib.adb, lib.ads\n\t(ipu): Created to aid in debugging.\n\t* lib-xref.adb\n\t(Generate_References): Remove special handling for postcondition\n\tprocedures.\n\t* sem_attr.adb\n\t(Analyze_Attribute_Old_Result): Add new context in which 'Old can\n\tappear due to the changes in expansion. Replace\n\tName_uPostconditions with Name_uWrapped_Statements.\n\t(Result): Replace Name_uPostconditions with\n\tName_uWrapped_Statements.\n\t* sem_ch11.adb\n\t(Analyze_Handled_Statements): Remove check to exclude warnings on\n\tuseless assignments within postcondition procedures since\n\tpostconditions no longer get isolated into separate subprograms.\n\t* sem_ch6.adb\n\t(Analyze_Generic_Subprogram_Body): Modify expansion of generic\n\tsubprogram bodies so that contracts (and their associated pragmas)\n\tget analyzed first.\n\t(Analyze_Subprogram_Body_Helper): Remove global HSS variable due\n\tto the HSS of the body potentially changing during the expansion\n\tof contracts. In cases where it was used instead directly call\n\tHandled_Statement_Sequence. Modify expansion of subprogram bodies\n\tso that contracts (and their associated pragmas) get analyzed\n\tfirst.\n\t(Check_Missing_Return): Create local HSS variable instead of using\n\ta global one.\n\t(Move_Pragmas): Use new pragma table instead of an explicit list.\n\t* sem_elab.adb\n\t(Is_Postconditions_Proc): Deleted since the new scheme of\n\texpansion no longer divides postcondition checks to a separate\n\tsubprogram and so cannot be easily identified (similar to\n\tpre-condition checks).\n\t(Info_Call): Remove info printing for _Postconditions subprograms.\n\t(Is_Assertion_Pragma_Target): Remove check for postconditions\n\tprocedure\n\t(Is_Bridge_Target): Remove check for postconditions procedure.\n\t(Get_Invocation_Attributes): Remove unneeded local variables and\n\tcheck for postconditions procedure.\n\t(Output_Call): Remove info printing for _Postconditions\n\tsubprograms.\n\t* sem_prag.adb, sem_prag.ads: Add new Pragma table for pragmas\n\tsignificant to subprograms, along with tech-debt comment.\n\t(Check_Arg_Is_Local_Name): Modified to recognize the new\n\t_Wrapped_Statements internal subprogram and the new expansion\n\tmodel.\n\t(Relocate_Pragmas_To_Body): Replace Name_uPostconditions with\n\tName_uWrapped_Statements.\n\t* sem_res.adb\n\t(Resolve_Entry_Call): Add conditional to detect both contract\n\tbased wrappers of entries, but also wrappers generated as part of\n\tgeneral contract expansion (e.g. local postconditions\n\tsubprograms).\n\t* sem_util.adb\n\t(Accessibility_Level): Verify 'Access is not taken based on a\n\tcomponent of a function result.\n\t(Has_Significant_Contracts): Replace Name_uPostconditions with\n\tName_uWrapped_Statements.\n\t(Same_Or_Aliased_Subprogram): Add conditional to detect and obtain\n\tthe original subprogram based on the new concept of\n\t\"postcondition\" wrappers.\n\t* sinfo.ads: Add documentation for new flag\n\tComes_From_Check_Or_Contract.\n\t* snames.ads-tmpl: Remove Name_uPostconditions and add\n\tName_uWrapped_Statements", "tree": {"sha": "4190c36a86a777293a7ca1be5847c291b1eacd8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4190c36a86a777293a7ca1be5847c291b1eacd8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a968d80d0e89e847a1928842b7de166a6d42c92e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a968d80d0e89e847a1928842b7de166a6d42c92e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a968d80d0e89e847a1928842b7de166a6d42c92e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a968d80d0e89e847a1928842b7de166a6d42c92e/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46ba7ae3c6eea45cc03de5fb00c8084cdc760d64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ba7ae3c6eea45cc03de5fb00c8084cdc760d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ba7ae3c6eea45cc03de5fb00c8084cdc760d64"}], "stats": {"total": 2520, "additions": 900, "deletions": 1620}, "files": [{"sha": "3f85ebc9460637e94c820c7884e5dd589eccc138", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 617, "deletions": 436, "changes": 1053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -68,6 +68,19 @@ package body Contracts is\n    --\n    --    Part_Of\n \n+   procedure Build_Subprogram_Contract_Wrapper\n+     (Body_Id : Entity_Id;\n+      Stmts   : List_Id;\n+      Decls   : List_Id;\n+      Result  : Entity_Id);\n+   --  Generate a wrapper for a given subprogram body when the expansion of\n+   --  postconditions require it by moving its declarations and statements\n+   --  into a locally declared subprogram _Wrapped_Statements.\n+\n+   --  Postcondition and precondition checks then get inserted in place of\n+   --  the original statements and declarations along with a call to\n+   --  _Wrapped_Statements.\n+\n    procedure Check_Class_Condition\n      (Cond            : Node_Id;\n       Subp            : Entity_Id;\n@@ -78,6 +91,10 @@ package body Contracts is\n    --  In SPARK_Mode, an inherited operation that is not overridden but has\n    --  inherited modified conditions pre/postconditions is illegal.\n \n+   function Is_Prologue_Renaming (Decl : Node_Id) return Boolean;\n+   --  Determine whether arbitrary declaration Decl denotes a renaming of\n+   --  a discriminant or protection field _object.\n+\n    procedure Check_Type_Or_Object_External_Properties\n      (Type_Or_Obj_Id : Entity_Id);\n    --  Perform checking of external properties pragmas that is common to both\n@@ -488,6 +505,45 @@ package body Contracts is\n       end loop;\n    end Analyze_Contracts;\n \n+   -------------------------------------\n+   -- Analyze_Pragmas_In_Declarations --\n+   -------------------------------------\n+\n+   procedure Analyze_Pragmas_In_Declarations (Body_Id : Entity_Id) is\n+      Curr_Decl : Node_Id;\n+\n+   begin\n+      --  Move through the body's declarations analyzing all pragmas which\n+      --  appear at the top of the declarations.\n+\n+      Curr_Decl := First (Declarations (Unit_Declaration_Node (Body_Id)));\n+      while Present (Curr_Decl) loop\n+\n+         if Nkind (Curr_Decl) = N_Pragma then\n+\n+            if Pragma_Significant_To_Subprograms\n+                 (Get_Pragma_Id (Curr_Decl))\n+            then\n+               Analyze (Curr_Decl);\n+            end if;\n+\n+         --  Skip the renamings of discriminants and protection fields\n+\n+         elsif Is_Prologue_Renaming (Curr_Decl) then\n+            null;\n+\n+         --  We have reached something which is not a pragma so we can be sure\n+         --  there are no more contracts or pragmas which need to be taken into\n+         --  account.\n+\n+         else\n+            exit;\n+         end if;\n+\n+         Next (Curr_Decl);\n+      end loop;\n+   end Analyze_Pragmas_In_Declarations;\n+\n    -----------------------------------------------\n    -- Analyze_Entry_Or_Subprogram_Body_Contract --\n    -----------------------------------------------\n@@ -644,7 +700,7 @@ package body Contracts is\n \n          else\n             declare\n-               Bod          : Node_Id;\n+               Bod          : Node_Id := Empty;\n                Freeze_Types : Boolean := False;\n \n             begin\n@@ -1499,6 +1555,442 @@ package body Contracts is\n         (Type_Or_Obj_Id => Type_Id);\n    end Analyze_Type_Contract;\n \n+   ---------------------------------------\n+   -- Build_Subprogram_Contract_Wrapper --\n+   ---------------------------------------\n+\n+   procedure Build_Subprogram_Contract_Wrapper\n+     (Body_Id : Entity_Id;\n+      Stmts   : List_Id;\n+      Decls   : List_Id;\n+      Result  : Entity_Id)\n+   is\n+      Actuals   : constant List_Id    := Empty_List;\n+      Body_Decl : constant Entity_Id  := Unit_Declaration_Node (Body_Id);\n+      Loc       : constant Source_Ptr := Sloc (Body_Decl);\n+      Spec_Id   : constant Entity_Id  := Corresponding_Spec (Body_Decl);\n+      Subp_Id   : Entity_Id;\n+      Ret_Type  : Entity_Id;\n+\n+      Wrapper_Id   : Entity_Id;\n+      Wrapper_Body : Node_Id;\n+      Wrapper_Spec : Node_Id;\n+\n+   begin\n+      --  When there are no postcondition statements we do not need to\n+      --  generate a wrapper.\n+\n+      if No (Stmts) then\n+         return;\n+      end if;\n+\n+      --  Obtain the related subprogram id from the body id.\n+\n+      if Present (Spec_Id) then\n+         Subp_Id := Spec_Id;\n+      else\n+         Subp_Id := Body_Id;\n+      end if;\n+      Ret_Type := Etype (Subp_Id);\n+\n+      --  Generate the contracts wrapper by moving the original declarations\n+      --  and statements within a local subprogram and calling it within\n+      --  an extended return to preserve the result for the purpose of\n+      --  evaluating postconditions, contracts, type invariants, etc.\n+\n+      --  Generate:\n+      --\n+      --  function Original_Func (X : in out Integer) return Typ is\n+      --     <prologue renamings>\n+      --     <preconditions>\n+      --\n+      --     function _Wrapped_Statements return Typ is\n+      --        <original declarations>\n+      --     begin\n+      --        <original statements>\n+      --     end;\n+      --\n+      --  begin\n+      --     return\n+      --        Result_Obj : constant Typ := _Wrapped_Statements\n+      --     do\n+      --        <postconditions statments>\n+      --     end return;\n+      --  end;\n+      --\n+      --  Or, in the case of a procedure:\n+      --\n+      --  procedure Original_Proc (X : in out Integer) is\n+      --     <prologue renamings>\n+      --     <preconditions>\n+      --\n+      --     procedure _Wrapped_Statements is\n+      --        <original declarations>\n+      --     begin\n+      --        <original statements>\n+      --     end;\n+      --\n+      --  begin\n+      --     _Wrapped_Statements;\n+      --     <postconditions statments>\n+      --  end;\n+      --\n+\n+      --  Create Identifier\n+\n+      Wrapper_Id := Make_Defining_Identifier (Loc, Name_uWrapped_Statements);\n+      Set_Debug_Info_Needed  (Wrapper_Id);\n+      Set_Wrapped_Statements (Subp_Id, Wrapper_Id);\n+\n+      --  Create specification and declaration for the wrapper\n+\n+      if No (Ret_Type) or else Ret_Type = Standard_Void_Type then\n+         Wrapper_Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name => Wrapper_Id);\n+      else\n+         Wrapper_Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name => Wrapper_Id,\n+             Result_Definition  => New_Occurrence_Of (Ret_Type, Loc));\n+      end if;\n+\n+      --  Create the wrapper body using Body_Id's statements and declarations\n+\n+      Wrapper_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              => Wrapper_Spec,\n+          Declarations               => Declarations (Body_Decl),\n+          Handled_Statement_Sequence =>\n+            Relocate_Node (Handled_Statement_Sequence (Body_Decl)));\n+\n+      Append_To (Decls, Wrapper_Body);\n+      Set_Declarations (Body_Decl, Decls);\n+      Set_Handled_Statement_Sequence (Body_Decl,\n+        Make_Handled_Sequence_Of_Statements (Loc,\n+          End_Label  => Make_Identifier (Loc, Chars (Wrapper_Id)),\n+          Statements => New_List));\n+\n+      --  Move certain flags which are relevant to the body\n+\n+      --  Wouldn't a better way be to perform some sort of copy of Body_Decl\n+      --  for Wrapper_Body be less error-prone ???\n+\n+      if Was_Expression_Function (Body_Decl) then\n+         Set_Was_Expression_Function (Body_Decl, False);\n+         Set_Was_Expression_Function (Wrapper_Body);\n+      end if;\n+\n+      Set_Has_Pragma_Inline (Wrapper_Id, Has_Pragma_Inline (Subp_Id));\n+      Set_Has_Pragma_Inline_Always\n+        (Wrapper_Id, Has_Pragma_Inline_Always (Subp_Id));\n+\n+      --  Generate call to the wrapper\n+\n+      if No (Ret_Type) or else Ret_Type = Standard_Void_Type then\n+         Prepend_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (Wrapper_Id, Loc)));\n+         Set_Statements\n+           (Handled_Statement_Sequence (Body_Decl), Stmts);\n+\n+      --  Generate the post-execution statements and the extended return\n+      --  when the subprogram being wrapped is a function.\n+\n+      else\n+         Set_Statements (Handled_Statement_Sequence (Body_Decl), New_List (\n+           Make_Extended_Return_Statement (Loc,\n+             Return_Object_Declarations => New_List (\n+                Make_Object_Declaration (Loc,\n+                  Defining_Identifier => Result,\n+                  Object_Definition   =>\n+                    New_Occurrence_Of (Ret_Type, Loc),\n+                  Expression          =>\n+                    Make_Function_Call (Loc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Wrapper_Id, Loc),\n+                      Parameter_Associations => Actuals))),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stmts))));\n+      end if;\n+   end Build_Subprogram_Contract_Wrapper;\n+\n+   ----------------------------------\n+   -- Build_Entry_Contract_Wrapper --\n+   ----------------------------------\n+\n+   procedure Build_Entry_Contract_Wrapper (E : Entity_Id; Decl : Node_Id) is\n+      Conc_Typ : constant Entity_Id  := Scope (E);\n+      Loc      : constant Source_Ptr := Sloc (E);\n+\n+      procedure Add_Discriminant_Renamings\n+        (Obj_Id : Entity_Id;\n+         Decls  : List_Id);\n+      --  Add renaming declarations for all discriminants of concurrent type\n+      --  Conc_Typ. Obj_Id is the entity of the wrapper formal parameter which\n+      --  represents the concurrent object.\n+\n+      procedure Add_Matching_Formals\n+        (Formals : List_Id;\n+         Actuals : in out List_Id);\n+      --  Add formal parameters that match those of entry E to list Formals.\n+      --  The routine also adds matching actuals for the new formals to list\n+      --  Actuals.\n+\n+      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id);\n+      --  Relocate pragma Prag to list To. The routine creates a new list if\n+      --  To does not exist.\n+\n+      --------------------------------\n+      -- Add_Discriminant_Renamings --\n+      --------------------------------\n+\n+      procedure Add_Discriminant_Renamings\n+        (Obj_Id : Entity_Id;\n+         Decls  : List_Id)\n+      is\n+         Discr         : Entity_Id;\n+         Renaming_Decl : Node_Id;\n+\n+      begin\n+         --  Inspect the discriminants of the concurrent type and generate a\n+         --  renaming for each one.\n+\n+         if Has_Discriminants (Conc_Typ) then\n+            Discr := First_Discriminant (Conc_Typ);\n+            while Present (Discr) loop\n+               Renaming_Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Chars (Discr)),\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (Etype (Discr), Loc),\n+                   Name                =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Chars (Discr))));\n+\n+               Prepend_To (Decls, Renaming_Decl);\n+\n+               Next_Discriminant (Discr);\n+            end loop;\n+         end if;\n+      end Add_Discriminant_Renamings;\n+\n+      --------------------------\n+      -- Add_Matching_Formals --\n+      --------------------------\n+\n+      procedure Add_Matching_Formals\n+        (Formals : List_Id;\n+         Actuals : in out List_Id)\n+      is\n+         Formal     : Entity_Id;\n+         New_Formal : Entity_Id;\n+\n+      begin\n+         --  Inspect the formal parameters of the entry and generate a new\n+         --  matching formal with the same name for the wrapper. A reference\n+         --  to the new formal becomes an actual in the entry call.\n+\n+         Formal := First_Formal (E);\n+         while Present (Formal) loop\n+            New_Formal := Make_Defining_Identifier (Loc, Chars (Formal));\n+            Append_To (Formals,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => New_Formal,\n+                In_Present          => In_Present  (Parent (Formal)),\n+                Out_Present         => Out_Present (Parent (Formal)),\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (Etype (Formal), Loc)));\n+\n+            if No (Actuals) then\n+               Actuals := New_List;\n+            end if;\n+\n+            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n+            Next_Formal (Formal);\n+         end loop;\n+      end Add_Matching_Formals;\n+\n+      ---------------------\n+      -- Transfer_Pragma --\n+      ---------------------\n+\n+      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id) is\n+         New_Prag : Node_Id;\n+\n+      begin\n+         if No (To) then\n+            To := New_List;\n+         end if;\n+\n+         New_Prag := Relocate_Node (Prag);\n+\n+         Set_Analyzed (New_Prag, False);\n+         Append       (New_Prag, To);\n+      end Transfer_Pragma;\n+\n+      --  Local variables\n+\n+      Items      : constant Node_Id := Contract (E);\n+      Actuals    : List_Id := No_List;\n+      Call       : Node_Id;\n+      Call_Nam   : Node_Id;\n+      Decls      : List_Id := No_List;\n+      Formals    : List_Id;\n+      Has_Pragma : Boolean := False;\n+      Index_Id   : Entity_Id;\n+      Obj_Id     : Entity_Id;\n+      Prag       : Node_Id;\n+      Wrapper_Id : Entity_Id;\n+\n+   --  Start of processing for Build_Entry_Contract_Wrapper\n+\n+   begin\n+      --  This routine generates a specialized wrapper for a protected or task\n+      --  entry [family] which implements precondition/postcondition semantics.\n+      --  Preconditions and case guards of contract cases are checked before\n+      --  the protected action or rendezvous takes place.\n+\n+      --    procedure Wrapper\n+      --      (Obj_Id    : Conc_Typ;    --  concurrent object\n+      --       [Index    : Index_Typ;]  --  index of entry family\n+      --       [Formal_1 : ...;         --  parameters of original entry\n+      --        Formal_N : ...])\n+      --    is\n+      --       [Discr_1 : ... renames Obj_Id.Discr_1;   --  discriminant\n+      --        Discr_N : ... renames Obj_Id.Discr_N;]  --  renamings\n+\n+      --       <contracts pragmas>\n+      --       <case guard checks>\n+\n+      --    begin\n+      --       Entry_Call (Obj_Id, [Index,] [Formal_1, Formal_N]);\n+      --    end Wrapper;\n+\n+      --  Create the wrapper only when the entry has at least one executable\n+      --  contract item such as contract cases, precondition or postcondition.\n+\n+      if Present (Items) then\n+\n+         --  Inspect the list of pre/postconditions and transfer all available\n+         --  pragmas to the declarative list of the wrapper.\n+\n+         Prag := Pre_Post_Conditions (Items);\n+         while Present (Prag) loop\n+            if Pragma_Name_Unmapped (Prag) in Name_Postcondition\n+                                            | Name_Precondition\n+              and then Is_Checked (Prag)\n+            then\n+               Has_Pragma := True;\n+               Transfer_Pragma (Prag, To => Decls);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Inspect the list of test/contract cases and transfer only contract\n+         --  cases pragmas to the declarative part of the wrapper.\n+\n+         Prag := Contract_Test_Cases (Items);\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Contract_Cases\n+              and then Is_Checked (Prag)\n+            then\n+               Has_Pragma := True;\n+               Transfer_Pragma (Prag, To => Decls);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  The entry lacks executable contract items and a wrapper is not needed\n+\n+      if not Has_Pragma then\n+         return;\n+      end if;\n+\n+      --  Create the profile of the wrapper. The first formal parameter is the\n+      --  concurrent object.\n+\n+      Obj_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Conc_Typ), 'A'));\n+\n+      Formals := New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Obj_Id,\n+          Out_Present         => True,\n+          In_Present          => True,\n+          Parameter_Type      => New_Occurrence_Of (Conc_Typ, Loc)));\n+\n+      --  Construct the call to the original entry. The call will be gradually\n+      --  augmented with an optional entry index and extra parameters.\n+\n+      Call_Nam :=\n+        Make_Selected_Component (Loc,\n+          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+          Selector_Name => New_Occurrence_Of (E, Loc));\n+\n+      --  When creating a wrapper for an entry family, the second formal is the\n+      --  entry index.\n+\n+      if Ekind (E) = E_Entry_Family then\n+         Index_Id := Make_Defining_Identifier (Loc, Name_I);\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Index_Id,\n+             Parameter_Type      =>\n+               New_Occurrence_Of (Entry_Index_Type (E), Loc)));\n+\n+         --  The call to the original entry becomes an indexed component to\n+         --  accommodate the entry index.\n+\n+         Call_Nam :=\n+           Make_Indexed_Component (Loc,\n+             Prefix      => Call_Nam,\n+             Expressions => New_List (New_Occurrence_Of (Index_Id, Loc)));\n+      end if;\n+\n+      --  Add formal parameters to match those of the entry and build actuals\n+      --  for the entry call.\n+\n+      Add_Matching_Formals (Formals, Actuals);\n+\n+      Call :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => Call_Nam,\n+          Parameter_Associations => Actuals);\n+\n+      --  Add renaming declarations for the discriminants of the enclosing type\n+      --  as the various contract items may reference them.\n+\n+      Add_Discriminant_Renamings (Obj_Id, Decls);\n+\n+      Wrapper_Id :=\n+        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n+      Set_Contract_Wrapper (E, Wrapper_Id);\n+      Set_Is_Entry_Wrapper (Wrapper_Id);\n+\n+      --  The wrapper body is analyzed when the enclosing type is frozen\n+\n+      Append_Freeze_Action (Defining_Entity (Decl),\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Wrapper_Id,\n+              Parameter_Specifications => Formals),\n+          Declarations               => Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Call))));\n+   end Build_Entry_Contract_Wrapper;\n+\n    ---------------------------\n    -- Check_Class_Condition --\n    ---------------------------\n@@ -1804,24 +2296,17 @@ package body Contracts is\n       --  the item denotes a pragma, it is added to the list only when it is\n       --  enabled.\n \n-      procedure Build_Postconditions_Procedure\n-        (Subp_Id : Entity_Id;\n-         Stmts   : List_Id;\n-         Result  : Entity_Id);\n-      --  Create the body of procedure _Postconditions which handles various\n-      --  assertion actions on exit from subprogram Subp_Id. Stmts is the list\n-      --  of statements to be checked on exit. Parameter Result is the entity\n-      --  of parameter _Result when Subp_Id denotes a function.\n-\n-      procedure Process_Contract_Cases (Stmts : in out List_Id);\n+      procedure Process_Contract_Cases\n+        (Stmts : in out List_Id;\n+         Decls : List_Id);\n       --  Process pragma Contract_Cases. This routine prepends items to the\n       --  body declarations and appends items to list Stmts.\n \n       procedure Process_Postconditions (Stmts : in out List_Id);\n       --  Collect all [inherited] spec and body postconditions and accumulate\n       --  their pragma Check equivalents in list Stmts.\n \n-      procedure Process_Preconditions;\n+      procedure Process_Preconditions (Decls : in out List_Id);\n       --  Collect all [inherited] spec and body preconditions and prepend their\n       --  pragma Check equivalents to the declarations of the body.\n \n@@ -2309,260 +2794,14 @@ package body Contracts is\n          end if;\n       end Append_Enabled_Item;\n \n-      ------------------------------------\n-      -- Build_Postconditions_Procedure --\n-      ------------------------------------\n-\n-      procedure Build_Postconditions_Procedure\n-        (Subp_Id : Entity_Id;\n-         Stmts   : List_Id;\n-         Result  : Entity_Id)\n-      is\n-         Loc       : constant Source_Ptr := Sloc (Body_Decl);\n-         Last_Decl : Node_Id;\n-         Params    : List_Id := No_List;\n-         Proc_Bod  : Node_Id;\n-         Proc_Decl : Node_Id;\n-         Proc_Id   : Entity_Id;\n-         Proc_Spec : Node_Id;\n-\n-         --  Extra declarations needed to handle interactions between\n-         --  postconditions and finalization.\n-\n-         Postcond_Enabled_Decl : Node_Id;\n-         Return_Success_Decl   : Node_Id;\n-         Result_Obj_Decl       : Node_Id;\n-         Result_Obj_Type_Decl  : Node_Id;\n-         Result_Obj_Type       : Entity_Id;\n-\n-      --  Start of processing for Build_Postconditions_Procedure\n-\n-      begin\n-         --  Nothing to do if there are no actions to check on exit\n-\n-         if No (Stmts) then\n-            return;\n-         end if;\n-\n-         --  Otherwise, we generate the postcondition procedure and add\n-         --  associated objects and conditions used to coordinate postcondition\n-         --  evaluation with finalization.\n-\n-         --  Generate:\n-         --\n-         --    procedure _postconditions (Return_Exp : Result_Typ);\n-         --\n-         --    --  Result_Obj_Type created when Result_Type is non-elementary\n-         --    [type Result_Obj_Type is access all Result_Typ;]\n-         --\n-         --    Result_Obj : Result_Obj_Type;\n-         --\n-         --    Postcond_Enabled            : Boolean := True;\n-         --    Return_Success_For_Postcond : Boolean := False;\n-         --\n-         --    procedure _postconditions (Return_Exp : Result_Typ) is\n-         --    begin\n-         --       if Postcond_Enabled and then Return_Success_For_Postcond then\n-         --          [stmts];\n-         --       end if;\n-         --    end;\n-\n-         Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n-         Set_Debug_Info_Needed   (Proc_Id);\n-         Set_Postconditions_Proc (Subp_Id, Proc_Id);\n-\n-         --  Mark it inlined to speed up the call\n-\n-         Set_Is_Inlined (Proc_Id);\n-\n-         --  Force the front-end inlining of _Postconditions when generating C\n-         --  code, since its body may have references to itypes defined in the\n-         --  enclosing subprogram, which would cause problems for unnesting\n-         --  routines in the absence of inlining.\n-\n-         if Modify_Tree_For_C then\n-            Set_Has_Pragma_Inline        (Proc_Id);\n-            Set_Has_Pragma_Inline_Always (Proc_Id);\n-         end if;\n-\n-         --  The related subprogram is a function: create the specification of\n-         --  parameter _Result.\n-\n-         if Present (Result) then\n-            Params := New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Result,\n-                Parameter_Type      =>\n-                  New_Occurrence_Of (Etype (Result), Loc)));\n-         end if;\n-\n-         Proc_Spec :=\n-           Make_Procedure_Specification (Loc,\n-             Defining_Unit_Name       => Proc_Id,\n-             Parameter_Specifications => Params);\n-\n-         Proc_Decl := Make_Subprogram_Declaration (Loc, Proc_Spec);\n-\n-         --  Insert _Postconditions before the first source declaration of the\n-         --  body. This ensures that the body will not cause any premature\n-         --  freezing, as it may mention types:\n-\n-         --  Generate:\n-         --\n-         --    procedure Proc (Obj : Array_Typ) is\n-         --       procedure _postconditions is\n-         --       begin\n-         --          ... Obj ...\n-         --       end _postconditions;\n-         --\n-         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n-         --    begin\n-\n-         --  In the example above, Obj is of type T but the incorrect placement\n-         --  of _Postconditions will cause a crash in gigi due to an out-of-\n-         --  order reference. The body of _Postconditions must be placed after\n-         --  the declaration of Temp to preserve correct visibility.\n-\n-         Insert_Before_First_Source_Declaration\n-           (Proc_Decl, Declarations (Body_Decl));\n-         Analyze (Proc_Decl);\n-         Last_Decl := Proc_Decl;\n-\n-         --  When Result is present (e.g. the postcondition checks apply to a\n-         --  function) we make a local object to capture the result, so, if\n-         --  needed, we can call the generated postconditions procedure during\n-         --  finalization instead of at the point of return.\n-\n-         --  Note: The placement of the following declarations before the\n-         --  declaration of the body of the postconditions, but after the\n-         --  declaration of the postconditions spec is deliberate and required\n-         --  since other code within the expander expects them to be located\n-         --  here. Perhaps when more space is available in the tree this will\n-         --  no longer be necessary ???\n-\n-         if Present (Result) then\n-            --  Elementary result types mean a copy is cheap and preferred over\n-            --  using pointers.\n-\n-            if Is_Elementary_Type (Etype (Result)) then\n-               Result_Obj_Type := Etype (Result);\n-\n-            --  Otherwise, we create a named access type to capture the result\n-\n-            --  Generate:\n-            --\n-            --  type Result_Obj_Type is access all [Result_Type];\n-\n-            else\n-               Result_Obj_Type := Make_Temporary (Loc, 'R');\n-\n-               Result_Obj_Type_Decl :=\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Result_Obj_Type,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       All_Present        => True,\n-                       Subtype_Indication => New_Occurrence_Of\n-                                               (Etype (Result), Loc)));\n-               Insert_After_And_Analyze (Proc_Decl, Result_Obj_Type_Decl);\n-               Last_Decl := Result_Obj_Type_Decl;\n-            end if;\n-\n-            --  Create the result obj declaration\n-\n-            --  Generate:\n-            --\n-            --  Result_Object_For_Postcond : Result_Obj_Type;\n-\n-            Result_Obj_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier\n-                    (Loc, Name_uResult_Object_For_Postcond),\n-                Object_Definition   =>\n-                  New_Occurrence_Of\n-                    (Result_Obj_Type, Loc));\n-            Set_No_Initialization (Result_Obj_Decl);\n-            Insert_After_And_Analyze (Last_Decl, Result_Obj_Decl);\n-            Last_Decl := Result_Obj_Decl;\n-         end if;\n-\n-         --  Build the Postcond_Enabled flag used to delay evaluation of\n-         --  postconditions until finalization has been performed when cleanup\n-         --  actions are present.\n-\n-         --  NOTE: This flag could be made into a predicate since we should be\n-         --  able at compile time to recognize when finalization and cleanup\n-         --  actions occur, but in practice this is not possible ???\n-\n-         --  Generate:\n-         --\n-         --    Postcond_Enabled : Boolean := True;\n-\n-         Postcond_Enabled_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier\n-                 (Loc, Name_uPostcond_Enabled),\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_True, Loc));\n-         Insert_After_And_Analyze (Last_Decl, Postcond_Enabled_Decl);\n-         Last_Decl := Postcond_Enabled_Decl;\n-\n-         --  Create a flag to indicate that return has been reached\n-\n-         --  This is necessary for deciding whether to execute _postconditions\n-         --  during finalization.\n-\n-         --  Generate:\n-         --\n-         --    Return_Success_For_Postcond : Boolean := False;\n-\n-         Return_Success_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier\n-                 (Loc, Name_uReturn_Success_For_Postcond),\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc));\n-         Insert_After_And_Analyze (Last_Decl, Return_Success_Decl);\n-         Last_Decl := Return_Success_Decl;\n-\n-         --  Set an explicit End_Label to override the sloc of the implicit\n-         --  RETURN statement, and prevent it from inheriting the sloc of one\n-         --  the postconditions: this would cause confusing debug info to be\n-         --  produced, interfering with coverage-analysis tools.\n-\n-         --  NOTE: Coverage-analysis and static-analysis tools rely on the\n-         --  postconditions procedure being free of internally generated code\n-         --  since some of these tools, like CodePeer, treat _postconditions\n-         --  as original source.\n-\n-         --  Generate:\n-         --\n-         --    procedure _postconditions is\n-         --    begin\n-         --       [Stmts];\n-         --    end;\n-\n-         Proc_Bod :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Copy_Subprogram_Spec (Proc_Spec),\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id)),\n-                 Statements => Stmts));\n-         Insert_After_And_Analyze (Last_Decl, Proc_Bod);\n-\n-      end Build_Postconditions_Procedure;\n-\n       ----------------------------\n       -- Process_Contract_Cases --\n       ----------------------------\n \n-      procedure Process_Contract_Cases (Stmts : in out List_Id) is\n+      procedure Process_Contract_Cases\n+        (Stmts : in out List_Id;\n+         Decls : List_Id)\n+      is\n          procedure Process_Contract_Cases_For (Subp_Id : Entity_Id);\n          --  Process pragma Contract_Cases for subprogram Subp_Id\n \n@@ -2583,14 +2822,14 @@ package body Contracts is\n                         Expand_Pragma_Contract_Cases\n                           (CCs     => Prag,\n                            Subp_Id => Subp_Id,\n-                           Decls   => Declarations (Body_Decl),\n+                           Decls   => Decls,\n                            Stmts   => Stmts);\n \n                      elsif Pragma_Name (Prag) = Name_Subprogram_Variant then\n                         Expand_Pragma_Subprogram_Variant\n                           (Prag       => Prag,\n                            Subp_Id    => Subp_Id,\n-                           Body_Decls => Declarations (Body_Decl));\n+                           Body_Decls => Decls);\n                      end if;\n                   end if;\n \n@@ -2599,11 +2838,6 @@ package body Contracts is\n             end if;\n          end Process_Contract_Cases_For;\n \n-         pragma Unmodified (Stmts);\n-         --  Stmts is passed as IN OUT to signal that the list can be updated,\n-         --  even if the corresponding integer value representing the list does\n-         --  not change.\n-\n       --  Start of processing for Process_Contract_Cases\n \n       begin\n@@ -2829,15 +3063,11 @@ package body Contracts is\n       -- Process_Preconditions --\n       ---------------------------\n \n-      procedure Process_Preconditions is\n+      procedure Process_Preconditions (Decls : in out List_Id) is\n          Insert_Node : Node_Id := Empty;\n          --  The insertion node after which all pragma Check equivalents are\n          --  inserted.\n \n-         function Is_Prologue_Renaming (Decl : Node_Id) return Boolean;\n-         --  Determine whether arbitrary declaration Decl denotes a renaming of\n-         --  a discriminant or protection field _object.\n-\n          procedure Prepend_To_Decls (Item : Node_Id);\n          --  Prepend a single item to the declarations of the subprogram body\n \n@@ -2849,64 +3079,12 @@ package body Contracts is\n          --  Collect all preconditions of subprogram Subp_Id and prepend their\n          --  pragma Check equivalents to the declarations of the body.\n \n-         --------------------------\n-         -- Is_Prologue_Renaming --\n-         --------------------------\n-\n-         function Is_Prologue_Renaming (Decl : Node_Id) return Boolean is\n-            Nam  : Node_Id;\n-            Obj  : Entity_Id;\n-            Pref : Node_Id;\n-            Sel  : Node_Id;\n-\n-         begin\n-            if Nkind (Decl) = N_Object_Renaming_Declaration then\n-               Obj := Defining_Entity (Decl);\n-               Nam := Name (Decl);\n-\n-               if Nkind (Nam) = N_Selected_Component then\n-                  Pref := Prefix (Nam);\n-                  Sel  := Selector_Name (Nam);\n-\n-                  --  A discriminant renaming appears as\n-                  --    Discr : constant ... := Prefix.Discr;\n-\n-                  if Ekind (Obj) = E_Constant\n-                    and then Is_Entity_Name (Sel)\n-                    and then Present (Entity (Sel))\n-                    and then Ekind (Entity (Sel)) = E_Discriminant\n-                  then\n-                     return True;\n-\n-                  --  A protection field renaming appears as\n-                  --    Prot : ... := _object._object;\n-\n-                  --  A renamed private component is just a component of\n-                  --  _object, with an arbitrary name.\n-\n-                  elsif Ekind (Obj) in E_Variable | E_Constant\n-                    and then Nkind (Pref) = N_Identifier\n-                    and then Chars (Pref) = Name_uObject\n-                    and then Nkind (Sel) = N_Identifier\n-                  then\n-                     return True;\n-                  end if;\n-               end if;\n-            end if;\n-\n-            return False;\n-         end Is_Prologue_Renaming;\n-\n          ----------------------\n          -- Prepend_To_Decls --\n          ----------------------\n \n          procedure Prepend_To_Decls (Item : Node_Id) is\n-            Decls : List_Id;\n-\n          begin\n-            Decls := Declarations (Body_Decl);\n-\n             --  Ensure that the body has a declarative list\n \n             if No (Decls) then\n@@ -2937,14 +3115,8 @@ package body Contracts is\n \n             else\n                Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+               Prepend_To_Decls (Check_Prag);\n \n-               if Present (Insert_Node) then\n-                  Insert_After (Insert_Node, Check_Prag);\n-               else\n-                  Prepend_To_Decls (Check_Prag);\n-               end if;\n-\n-               Analyze (Check_Prag);\n             end if;\n          end Prepend_Pragma_To_Decls;\n \n@@ -3037,16 +3209,17 @@ package body Contracts is\n \n          --  Local variables\n \n-         Decls : constant List_Id := Declarations (Body_Decl);\n-         Decl  : Node_Id;\n+         Body_Decls : constant List_Id := Declarations (Body_Decl);\n+         Decl       : Node_Id;\n+         Next_Decl  : Node_Id;\n \n       --  Start of processing for Process_Preconditions\n \n       begin\n          --  Find the proper insertion point for all pragma Check equivalents\n \n-         if Present (Decls) then\n-            Decl := First (Decls);\n+         if Present (Body_Decls) then\n+            Decl := First (Body_Decls);\n             while Present (Decl) loop\n \n                --  First source declaration terminates the search, because all\n@@ -3091,6 +3264,19 @@ package body Contracts is\n             --    <preconditions from body>\n \n             Process_Preconditions_For (Body_Id);\n+\n+            --  Move the generated entry-call prologue renamings into the\n+            --  outer declarations for use in the preconditions.\n+\n+            Decl := First (Body_Decls);\n+            while Present (Decl) and then Present (Insert_Node) loop\n+               Next_Decl := Next (Decl);\n+               Remove (Decl);\n+               Prepend_To_Decls (Decl);\n+\n+               exit when Decl = Insert_Node;\n+               Decl := Next_Decl;\n+            end loop;\n          end if;\n \n          if Present (Spec_Id) then\n@@ -3103,6 +3289,7 @@ package body Contracts is\n       Restore_Scope : Boolean := False;\n       Result        : Entity_Id;\n       Stmts         : List_Id := No_List;\n+      Decls         : List_Id := New_List;\n       Subp_Id       : Entity_Id;\n \n    --  Start of processing for Expand_Subprogram_Contract\n@@ -3181,33 +3368,33 @@ package body Contracts is\n       --  pragmas to verify the contract assertions of the spec and body in a\n       --  particular order. The order is as follows:\n \n-      --    function Example (...) return ... is\n-      --       procedure _Postconditions (...) is\n+      --    function Original_Code (...) return ... is\n+      --       <prologue renamings>\n+      --       <inherited preconditions>\n+      --       <preconditions from spec>\n+      --       <preconditions from body>\n+      --       <contract case conditions>\n+\n+      --       function _wrapped_statements (...) return ... is\n+      --          <source declarations>\n       --       begin\n+      --          <source statements>\n+      --       end _wrapped_statements;\n+\n+      --    begin\n+      --       return\n+      --          Result : ... := _wrapped_statements\n+      --       do\n       --          <refined postconditions from body>\n       --          <postconditions from body>\n       --          <postconditions from spec>\n       --          <inherited postconditions>\n       --          <contract case consequences>\n       --          <invariant check of function result>\n-      --          <invariant and predicate checks of parameters>\n-      --       end _Postconditions;\n-\n-      --       <inherited preconditions>\n-      --       <preconditions from spec>\n-      --       <preconditions from body>\n-      --       <contract case conditions>\n-\n-      --       <source declarations>\n-      --    begin\n-      --       <source statements>\n-\n-      --       _Preconditions (Result);\n-      --       return Result;\n-      --    end Example;\n-\n-      --  Routine _Postconditions holds all contract assertions that must be\n-      --  verified on exit from the related subprogram.\n+      --          <invariant and predicate checks of parameters\n+      --          return Result;\n+      --       end return;\n+      --    end Original_Code;\n \n       --  Step 1: augment contracts list with postconditions associated with\n       --  Stable_Properties and Stable_Properties'Class aspects. This must\n@@ -3222,7 +3409,7 @@ package body Contracts is\n       --  processing of pragma Contract_Cases because the pragma prepends items\n       --  to the body declarations.\n \n-      Process_Preconditions;\n+      Process_Preconditions (Decls);\n \n       --  Step 3: Handle all postconditions. This action must come before the\n       --  processing of pragma Contract_Cases because the pragma appends items\n@@ -3234,16 +3421,26 @@ package body Contracts is\n       --  the processing of invariants and predicates because those append\n       --  items to list Stmts.\n \n-      Process_Contract_Cases (Stmts);\n+      Process_Contract_Cases (Stmts, Decls);\n \n       --  Step 5: Apply invariant and predicate checks on a function result and\n       --  all formals. The resulting checks are accumulated in list Stmts.\n \n       Add_Invariant_And_Predicate_Checks (Subp_Id, Stmts, Result);\n \n-      --  Step 6: Construct procedure _Postconditions\n+      --  Step 6: Construct subprogram _wrapped_statements\n+\n+      --  When no statements are present we still need to insert contract\n+      --  related declarations.\n+\n+      if No (Stmts) then\n+         Prepend_List_To (Declarations (Body_Decl), Decls);\n+\n+      --  Otherwise, we need a wrapper\n \n-      Build_Postconditions_Procedure (Subp_Id, Stmts, Result);\n+      else\n+         Build_Subprogram_Contract_Wrapper (Body_Id, Stmts, Decls, Result);\n+      end if;\n \n       if Restore_Scope then\n          End_Scope;\n@@ -3448,81 +3645,6 @@ package body Contracts is\n       Freeze_Contracts;\n    end Freeze_Previous_Contracts;\n \n-   --------------------------\n-   -- Get_Postcond_Enabled --\n-   --------------------------\n-\n-   function Get_Postcond_Enabled (Subp : Entity_Id) return Entity_Id is\n-      Decl : Node_Id;\n-   begin\n-      Decl :=\n-        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n-      while Present (Decl) loop\n-\n-         if Nkind (Decl) = N_Object_Declaration\n-          and then Chars (Defining_Identifier (Decl))\n-                     = Name_uPostcond_Enabled\n-         then\n-            return Defining_Identifier (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Postcond_Enabled;\n-\n-   ------------------------------------\n-   -- Get_Result_Object_For_Postcond --\n-   ------------------------------------\n-\n-   function Get_Result_Object_For_Postcond\n-     (Subp : Entity_Id) return Entity_Id\n-   is\n-      Decl : Node_Id;\n-   begin\n-      Decl :=\n-        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n-      while Present (Decl) loop\n-\n-         if Nkind (Decl) = N_Object_Declaration\n-           and then Chars (Defining_Identifier (Decl))\n-                      = Name_uResult_Object_For_Postcond\n-         then\n-            return Defining_Identifier (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Result_Object_For_Postcond;\n-\n-   -------------------------------------\n-   -- Get_Return_Success_For_Postcond --\n-   -------------------------------------\n-\n-   function Get_Return_Success_For_Postcond (Subp : Entity_Id) return Entity_Id\n-   is\n-      Decl : Node_Id;\n-   begin\n-      Decl :=\n-        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n-      while Present (Decl) loop\n-\n-         if Nkind (Decl) = N_Object_Declaration\n-          and then Chars (Defining_Identifier (Decl))\n-                     = Name_uReturn_Success_For_Postcond\n-         then\n-            return Defining_Identifier (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Return_Success_For_Postcond;\n-\n    ---------------------------------\n    -- Inherit_Subprogram_Contract --\n    ---------------------------------\n@@ -3617,6 +3739,65 @@ package body Contracts is\n       end if;\n    end Instantiate_Subprogram_Contract;\n \n+   --------------------------\n+   -- Is_Prologue_Renaming --\n+   --------------------------\n+\n+   --  This should be turned into a flag and set during the expansion of\n+   --  task and protected types when the renamings get generated ???\n+\n+   function Is_Prologue_Renaming (Decl : Node_Id) return Boolean is\n+      Nam  : Node_Id;\n+      Obj  : Entity_Id;\n+      Pref : Node_Id;\n+      Sel  : Node_Id;\n+\n+   begin\n+      if Nkind (Decl) = N_Object_Renaming_Declaration\n+        and then not Comes_From_Source (Decl)\n+      then\n+         Obj := Defining_Entity (Decl);\n+         Nam := Name (Decl);\n+\n+         if Nkind (Nam) = N_Selected_Component then\n+            --  Analyze the renaming declaration so we can further examine it\n+\n+            if not Analyzed (Decl) then\n+               Analyze (Decl);\n+            end if;\n+\n+            Pref := Prefix (Nam);\n+            Sel  := Selector_Name (Nam);\n+\n+            --  A discriminant renaming appears as\n+            --    Discr : constant ... := Prefix.Discr;\n+\n+            if Ekind (Obj) = E_Constant\n+              and then Is_Entity_Name (Sel)\n+              and then Present (Entity (Sel))\n+              and then Ekind (Entity (Sel)) = E_Discriminant\n+            then\n+               return True;\n+\n+            --  A protection field renaming appears as\n+            --    Prot : ... := _object._object;\n+\n+            --  A renamed private component is just a component of\n+            --  _object, with an arbitrary name.\n+\n+            elsif Ekind (Obj) in E_Variable | E_Constant\n+              and then Nkind (Pref) = N_Identifier\n+              and then Chars (Pref) = Name_uObject\n+              and then Nkind (Sel) = N_Identifier\n+            then\n+               return True;\n+            end if;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Is_Prologue_Renaming;\n+\n    -----------------------------------\n    -- Make_Class_Precondition_Subps --\n    -----------------------------------"}, {"sha": "bde32ffc5b44a382a54880d97308dccad50eeed0", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -64,6 +64,16 @@ package Contracts is\n    procedure Analyze_Contracts (L : List_Id);\n    --  Analyze the contracts of all eligible constructs found in list L\n \n+   procedure Analyze_Pragmas_In_Declarations (Body_Id : Entity_Id);\n+   --  Perform early analysis of pragmas at the top of a given subprogram's\n+   --  declarations.\n+   --\n+   --  The purpose of this is to analyze contract-related pragmas for later\n+   --  processing, but also to handle other such pragmas before these\n+   --  declarations get moved to an internal wrapper as part of contract\n+   --  expansion. For example, pragmas Inline, Ghost, Volatile all need to\n+   --  apply directly to the subprogram and not be moved to a wrapper.\n+\n    procedure Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id : Entity_Id);\n    --  Analyze all delayed pragmas chained on the contract of entry or\n    --  subprogram body Body_Id as if they appeared at the end of a declarative\n@@ -177,6 +187,17 @@ package Contracts is\n    --    Depends\n    --    Global\n \n+   procedure Build_Entry_Contract_Wrapper (E : Entity_Id; Decl : Node_Id);\n+   --  Build the body of a wrapper procedure for an entry or entry family that\n+   --  has contract cases, preconditions, or postconditions, and add it to the\n+   --  freeze actions of the related synchronized type.\n+   --\n+   --  The body first verifies the preconditions and case guards of the\n+   --  contract cases, then invokes the entry [family], and finally verifies\n+   --  the postconditions and the consequences of the contract cases. E denotes\n+   --  the entry family. Decl denotes the declaration of the enclosing\n+   --  synchronized type.\n+\n    procedure Create_Generic_Contract (Unit : Node_Id);\n    --  Create a contract node for a generic package, generic subprogram, or a\n    --  generic body denoted by Unit by collecting all source contract-related\n@@ -188,21 +209,6 @@ package Contracts is\n    --  denoted by Body_Decl. In addition, freeze the contract of the nearest\n    --  enclosing package body.\n \n-   function Get_Postcond_Enabled (Subp : Entity_Id) return Entity_Id;\n-   --  Get the defining identifier for a subprogram's Postcond_Enabled\n-   --  object created during the expansion of the subprogram's postconditions.\n-\n-   function Get_Result_Object_For_Postcond (Subp : Entity_Id) return Entity_Id;\n-   --  Get the defining identifier for a subprogram's\n-   --  Result_Object_For_Postcond object created during the expansion of the\n-   --  subprogram's postconditions.\n-\n-   function Get_Return_Success_For_Postcond\n-     (Subp : Entity_Id) return Entity_Id;\n-   --  Get the defining identifier for a subprogram's\n-   --  Return_Success_For_Postcond object created during the expansion of the\n-   --  subprogram's postconditions.\n-\n    procedure Inherit_Subprogram_Contract\n      (Subp      : Entity_Id;\n       From_Subp : Entity_Id);"}, {"sha": "7ac8cf6e99a745890a45d549f480ef1939824d2c", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -4014,9 +4014,7 @@ package Einfo is\n --       fully initialized when the full view is frozen.\n \n --    Postconditions_Proc\n---       Defined in functions, procedures, entries, and entry families. Refers\n---       to the entity of the _Postconditions procedure used to check contract\n---       assertions on exit from a subprogram.\n+--       Obsolete field which can be removed once CodePeer is fixed ???\n \n --    Predicate_Function (synthesized)\n --       Defined in all types. Set for types for which (Has_Predicates is True)\n@@ -4767,6 +4765,13 @@ package Einfo is\n --       Defined in functions and procedures which have been classified as\n --       Is_Primitive_Wrapper. Set to the entity being wrapper.\n \n+--    Wrapped_Statements\n+--       Defined in functions, procedures, entries, and entry families. Refers\n+--       to the entity of the _Wrapped_Statements procedure which gets\n+--       generated as part of the expansion of contracts and postconditions\n+--       and contains its enclosing subprogram's original source declarations\n+--       and statements.\n+\n --    LSP_Subprogram\n --       Defined in subprogram entities. Set on wrappers created to handle\n --       inherited class-wide pre/post conditions that call overridden\n@@ -5412,7 +5417,6 @@ package Einfo is\n    --    Protected_Body_Subprogram\n    --    Barrier_Function\n    --    Elaboration_Entity\n-   --    Postconditions_Proc\n    --    Entry_Parameters_Type\n    --    First_Entity\n    --    Alias                                (for entry only. Empty)\n@@ -5527,7 +5531,6 @@ package Einfo is\n    --    Protected_Body_Subprogram\n    --    Next_Inlined_Subprogram\n    --    Elaboration_Entity                   (not implicit /=)\n-   --    Postconditions_Proc                  (non-generic case only)\n    --    DT_Position\n    --    DTC_Entity\n    --    First_Entity\n@@ -5891,7 +5894,6 @@ package Einfo is\n    --    Protected_Body_Subprogram\n    --    Next_Inlined_Subprogram\n    --    Elaboration_Entity\n-   --    Postconditions_Proc                  (non-generic case only)\n    --    DT_Position\n    --    DTC_Entity\n    --    First_Entity"}, {"sha": "6f49db70a3eb576a01644a244b033359a6b112bc", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -4895,24 +4895,25 @@ package body Exp_Attr is\n          use Old_Attr_Util.Indirect_Temps;\n       begin\n          --  Generating C code we don't need to expand this attribute when\n-         --  we are analyzing the internally built nested postconditions\n+         --  we are analyzing the internally built nested _Wrapped_Statements\n          --  procedure since it will be expanded inline (and later it will\n          --  be removed by Expand_N_Subprogram_Body). It this expansion is\n          --  performed in such case then the compiler generates unreferenced\n          --  extra temporaries.\n \n          if Modify_Tree_For_C\n-           and then Chars (Current_Scope) = Name_uPostconditions\n+           and then Chars (Current_Scope) = Name_uWrapped_Statements\n          then\n             return;\n          end if;\n \n-         --  Climb the parent chain looking for subprogram _Postconditions\n+         --  Climb the parent chain looking for subprogram _Wrapped_Statements\n \n          Subp := N;\n          while Present (Subp) loop\n             exit when Nkind (Subp) = N_Subprogram_Body\n-              and then Chars (Defining_Entity (Subp)) = Name_uPostconditions;\n+              and then Chars (Defining_Entity (Subp))\n+                         = Name_uWrapped_Statements;\n \n             --  If assertions are disabled, no need to create the declaration\n             --  that preserves the value. The postcondition pragma in which\n@@ -4925,14 +4926,11 @@ package body Exp_Attr is\n \n             Subp := Parent (Subp);\n          end loop;\n+         Subp := Empty;\n \n-         --  'Old can only appear in a postcondition, the generated body of\n-         --  _Postconditions must be in the tree (or inlined if we are\n-         --  generating C code).\n-\n-         pragma Assert\n-           (Present (Subp)\n-             or else (Modify_Tree_For_C and then In_Inlined_Body));\n+         --  'Old can only appear in the case where local contract-related\n+         --  wrapper has been generated with the purpose of wrapping the\n+         --  original declarations and statements.\n \n          Temp := Make_Temporary (Loc, 'T', Pref);\n \n@@ -4952,8 +4950,7 @@ package body Exp_Attr is\n          --  No need to push the scope when generating C code since the\n          --  _Postcondition procedure has been inlined.\n \n-         else pragma Assert (Modify_Tree_For_C);\n-            pragma Assert (In_Inlined_Body);\n+         else\n             null;\n          end if;\n \n@@ -4963,17 +4960,23 @@ package body Exp_Attr is\n          if Present (Subp) then\n             Ins_Nod := Subp;\n \n-         --  Generating C, the postcondition procedure has been inlined and the\n-         --  temporary is added before the first declaration of the enclosing\n-         --  subprogram.\n+         --  General case where the postcondtion checks occur after the call\n+         --  to _Wrapped_Statements.\n \n-         else pragma Assert (Modify_Tree_For_C);\n+         else\n             Ins_Nod := N;\n             while Nkind (Ins_Nod) /= N_Subprogram_Body loop\n                Ins_Nod := Parent (Ins_Nod);\n             end loop;\n \n-            Ins_Nod := First (Declarations (Ins_Nod));\n+            if Present (Corresponding_Spec (Ins_Nod))\n+              and then Present\n+                         (Wrapped_Statements (Corresponding_Spec (Ins_Nod)))\n+            then\n+               Ins_Nod := Last (Declarations (Ins_Nod));\n+            else\n+               Ins_Nod := First (Declarations (Ins_Nod));\n+            end if;\n          end if;\n \n          if Eligible_For_Conditional_Evaluation (N) then\n@@ -4986,9 +4989,9 @@ package body Exp_Attr is\n                --  unconditionally) or an evaluation statement (which is\n                --  to be executed conditionally).\n \n-               -------------------------------\n-               --  Append_For_Indirect_Temp --\n-               -------------------------------\n+               ------------------------------\n+               -- Append_For_Indirect_Temp --\n+               ------------------------------\n \n                procedure Append_For_Indirect_Temp\n                  (N : Node_Id; Is_Eval_Stmt : Boolean)\n@@ -5008,7 +5011,7 @@ package body Exp_Attr is\n                Declare_Indirect_Temporary\n                  (Attr_Prefix => Pref, Indirect_Temp => Temp);\n \n-               Insert_Before_And_Analyze (\n+               Insert_After_And_Analyze (\n                  Ins_Nod,\n                  Make_If_Statement\n                    (Sloc            => Loc,"}, {"sha": "f4630c9b1628f3feece974c80d8cd9ef078c317d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 10, "deletions": 160, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -26,7 +26,6 @@\n with Atree;          use Atree;\n with Aspects;        use Aspects;\n with Checks;         use Checks;\n-with Contracts;      use Contracts;\n with Debug;          use Debug;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n@@ -2729,11 +2728,16 @@ package body Exp_Ch6 is\n                                 | N_Function_Call\n                                 | N_Procedure_Call_Statement);\n \n-      --  Check that this is not the call in the body of the wrapper\n+      --  Check that this is not the call in the body of the access\n+      --  subprogram wrapper or the postconditions wrapper.\n \n       if Must_Rewrite_Indirect_Call\n         and then (not Is_Overloadable (Current_Scope)\n-             or else not Is_Access_Subprogram_Wrapper (Current_Scope))\n+             or else not (Is_Access_Subprogram_Wrapper (Current_Scope)\n+                           or else\n+                             (Chars (Current_Scope) = Name_uWrapped_Statements\n+                               and then Is_Access_Subprogram_Wrapper\n+                                          (Scope (Current_Scope)))))\n       then\n          declare\n             Loc      : constant Source_Ptr := Sloc (N);\n@@ -4871,11 +4875,12 @@ package body Exp_Ch6 is\n                   then\n                      Must_Inline := not In_Extended_Main_Source_Unit (Subp);\n \n-                  --  Inline calls to _postconditions when generating C code\n+                  --  Inline calls to _Wrapped_Statements when generating C\n \n                   elsif Modify_Tree_For_C\n                     and then In_Same_Extended_Unit (Sloc (Bod), Loc)\n-                    and then Chars (Name (Call_Node)) = Name_uPostconditions\n+                    and then Chars (Name (Call_Node))\n+                               = Name_uWrapped_Statements\n                   then\n                      Must_Inline := True;\n                   end if;\n@@ -5567,45 +5572,6 @@ package body Exp_Ch6 is\n             Append_To (Stmts, Stmt);\n             Set_Analyzed (Stmt);\n \n-            --  Call the _Postconditions procedure if the related subprogram\n-            --  has contract assertions that need to be verified on exit.\n-\n-            --  Also, mark the successful return to signal that postconditions\n-            --  need to be evaluated when finalization occurs by setting\n-            --  Return_Success_For_Postcond to be True.\n-\n-            if Ekind (Spec_Id) = E_Procedure\n-              and then Present (Postconditions_Proc (Spec_Id))\n-            then\n-               --  Generate:\n-               --\n-               --    Return_Success_For_Postcond := True;\n-               --    if Postcond_Enabled then\n-               --       _postconditions;\n-               --    end if;\n-\n-               Insert_Action (Stmt,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       =>\n-                     New_Occurrence_Of\n-                       (Get_Return_Success_For_Postcond (Spec_Id), Loc),\n-                   Expression => New_Occurrence_Of (Standard_True, Loc)));\n-\n-               --  Wrap the call to _postconditions within a test of the\n-               --  Postcond_Enabled flag to delay postcondition evaluation\n-               --  until after finalization when required.\n-\n-               Insert_Action (Stmt,\n-                 Make_If_Statement (Loc,\n-                   Condition       =>\n-                     New_Occurrence_Of (Get_Postcond_Enabled (Spec_Id), Loc),\n-                   Then_Statements => New_List (\n-                     Make_Procedure_Call_Statement (Loc,\n-                       Name =>\n-                         New_Occurrence_Of\n-                           (Postconditions_Proc (Spec_Id), Loc)))));\n-            end if;\n-\n             --  Ada 2022 (AI12-0279): append the call to 'Yield unless this is\n             --  a generic subprogram (since in such case it will be added to\n             --  the instantiations).\n@@ -6013,44 +5979,6 @@ package body Exp_Ch6 is\n       Lab_Node  : Node_Id;\n \n    begin\n-      --  Call the _Postconditions procedure if the related subprogram has\n-      --  contract assertions that need to be verified on exit.\n-\n-      --  Also, mark the successful return to signal that postconditions need\n-      --  to be evaluated when finalization occurs.\n-\n-      if Ekind (Scope_Id) in E_Entry | E_Entry_Family | E_Procedure\n-        and then Present (Postconditions_Proc (Scope_Id))\n-      then\n-         --  Generate:\n-         --\n-         --    Return_Success_For_Postcond := True;\n-         --    if Postcond_Enabled then\n-         --       _postconditions;\n-         --    end if;\n-\n-         Insert_Action (N,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               New_Occurrence_Of\n-                (Get_Return_Success_For_Postcond (Scope_Id), Loc),\n-             Expression => New_Occurrence_Of (Standard_True, Loc)));\n-\n-         --  Wrap the call to _postconditions within a test of the\n-         --  Postcond_Enabled flag to delay postcondition evaluation until\n-         --  after finalization when required.\n-\n-         Insert_Action (N,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               New_Occurrence_Of (Get_Postcond_Enabled (Scope_Id), Loc),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name =>\n-                   New_Occurrence_Of\n-                     (Postconditions_Proc (Scope_Id), Loc)))));\n-      end if;\n-\n       --  Ada 2022 (AI12-0279)\n \n       if Has_Yield_Aspect (Scope_Id)\n@@ -6995,84 +6923,6 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n-      --  Call the _Postconditions procedure if the related function has\n-      --  contract assertions that need to be verified on exit.\n-\n-      if Ekind (Scope_Id) = E_Function\n-        and then Present (Postconditions_Proc (Scope_Id))\n-      then\n-         --  In the case of discriminated objects, we have created a\n-         --  constrained subtype above, and used the underlying type. This\n-         --  transformation is post-analysis and harmless, except that now the\n-         --  call to the post-condition will be analyzed and the type kinds\n-         --  have to match.\n-\n-         if Nkind (Exp) = N_Unchecked_Type_Conversion\n-           and then Is_Private_Type (R_Type) /= Is_Private_Type (Etype (Exp))\n-         then\n-            Rewrite (Exp, Expression (Relocate_Node (Exp)));\n-         end if;\n-\n-         --  We are going to reference the returned value twice in this case,\n-         --  once in the call to _Postconditions, and once in the actual return\n-         --  statement, but we can't have side effects happening twice.\n-\n-         Force_Evaluation (Exp, Mode => Strict);\n-\n-         --  Save the return value or a pointer to the return value since we\n-         --  may need to call postconditions after finalization when cleanup\n-         --  actions are present.\n-\n-         --  Generate:\n-         --\n-         --    Result_Object_For_Postcond := [Exp]'Unrestricted_Access;\n-\n-         Insert_Action (Exp,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               New_Occurrence_Of\n-                (Get_Result_Object_For_Postcond (Scope_Id), Loc),\n-             Expression =>\n-               (if Is_Elementary_Type (Etype (R_Type)) then\n-                   New_Copy_Tree (Exp)\n-                else\n-                   Make_Attribute_Reference (Loc,\n-                     Attribute_Name => Name_Unrestricted_Access,\n-                     Prefix         => New_Copy_Tree (Exp)))));\n-\n-         --  Mark the successful return to signal that postconditions need to\n-         --  be evaluated when finalization occurs.\n-\n-         --  Generate:\n-         --\n-         --    Return_Success_For_Postcond := True;\n-         --    if Postcond_Enabled then\n-         --       _Postconditions ([exp]);\n-         --    end if;\n-\n-         Insert_Action (Exp,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               New_Occurrence_Of\n-                (Get_Return_Success_For_Postcond (Scope_Id), Loc),\n-             Expression => New_Occurrence_Of (Standard_True, Loc)));\n-\n-         --  Wrap the call to _postconditions within a test of the\n-         --  Postcond_Enabled flag to delay postcondition evaluation until\n-         --  after finalization when required.\n-\n-         Insert_Action (Exp,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               New_Occurrence_Of (Get_Postcond_Enabled (Scope_Id), Loc),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name                   =>\n-                   New_Occurrence_Of\n-                     (Postconditions_Proc (Scope_Id), Loc),\n-                 Parameter_Associations => New_List (New_Copy_Tree (Exp))))));\n-      end if;\n-\n       --  Ada 2005 (AI-251): If this return statement corresponds with an\n       --  simple return statement associated with an extended return statement\n       --  and the type of the returned object is an interface then generate an"}, {"sha": "fc4516dde5b187e65e196ada5a2d554c24403e5c", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 11, "deletions": 537, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -28,7 +28,6 @@\n --    - transient scopes\n \n with Atree;          use Atree;\n-with Contracts;      use Contracts;\n with Debug;          use Debug;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n@@ -305,17 +304,6 @@ package body Exp_Ch7 is\n    --  such as for task termination. Fin_Id is the finalizer declaration\n    --  entity.\n \n-   procedure Build_Finalizer_Helper\n-     (N                 : Node_Id;\n-      Clean_Stmts       : List_Id;\n-      Mark_Id           : Entity_Id;\n-      Top_Decls         : List_Id;\n-      Defer_Abort       : Boolean;\n-      Fin_Id            : out Entity_Id;\n-      Finalize_Old_Only : Boolean);\n-   --  An internal routine which does all of the heavy lifting on behalf of\n-   --  Build_Finalizer.\n-\n    procedure Build_Finalizer_Call (N : Node_Id; Fin_Id : Entity_Id);\n    --  N is a construct that contains a handled sequence of statements, Fin_Id\n    --  is the entity of a finalizer. Create an At_End handler that covers the\n@@ -1377,18 +1365,17 @@ package body Exp_Ch7 is\n       end;\n    end Build_Finalization_Master;\n \n-   ----------------------------\n-   -- Build_Finalizer_Helper --\n-   ----------------------------\n+   ---------------------\n+   -- Build_Finalizer --\n+   ---------------------\n \n-   procedure Build_Finalizer_Helper\n+   procedure Build_Finalizer\n      (N                 : Node_Id;\n       Clean_Stmts       : List_Id;\n       Mark_Id           : Entity_Id;\n       Top_Decls         : List_Id;\n       Defer_Abort       : Boolean;\n-      Fin_Id            : out Entity_Id;\n-      Finalize_Old_Only : Boolean)\n+      Fin_Id            : out Entity_Id)\n    is\n       Acts_As_Clean    : constant Boolean :=\n                            Present (Mark_Id)\n@@ -1682,15 +1669,9 @@ package body Exp_Ch7 is\n             --  there will need to be multiple finalization routines in the\n             --  same scope. See Build_Finalizer for details.\n \n-            if Finalize_Old_Only then\n-               Fin_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Name_uFinalizer_Old));\n-            else\n-               Fin_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Name_uFinalizer));\n-            end if;\n+            Fin_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Name_uFinalizer));\n \n             --  The visibility semantics of AT_END handlers force a strange\n             --  separation of spec and body for stack-related finalizers:\n@@ -2222,26 +2203,9 @@ package body Exp_Ch7 is\n \n          Decl := Last_Non_Pragma (Decls);\n          while Present (Decl) loop\n-            --  Depending on the value of flag Finalize_Old_Only we determine\n-            --  which objects get finalized as part of the current finalizer\n-            --  being built.\n-\n-            --  When True, only temporaries capturing the value of attribute\n-            --  'Old are finalized and all other cases are ignored.\n-\n-            --  When False, temporary objects used to capture the value of 'Old\n-            --  are ignored and all others are considered.\n-\n-            if Finalize_Old_Only\n-                 xor (Nkind (Decl) = N_Object_Declaration\n-                       and then Stores_Attribute_Old_Prefix\n-                                  (Defining_Identifier (Decl)))\n-            then\n-               null;\n-\n             --  Library-level tagged types\n \n-            elsif Nkind (Decl) = N_Full_Type_Declaration then\n+            if Nkind (Decl) = N_Full_Type_Declaration then\n                Typ := Defining_Identifier (Decl);\n \n                --  Ignored Ghost types do not need any cleanup actions because\n@@ -3528,7 +3492,7 @@ package body Exp_Ch7 is\n                New_Occurrence_Of (DT_Ptr, Loc))));\n       end Process_Tagged_Type_Declaration;\n \n-   --  Start of processing for Build_Finalizer_Helper\n+   --  Start of processing for Build_Finalizer\n \n    begin\n       Fin_Id := Empty;\n@@ -3685,7 +3649,7 @@ package body Exp_Ch7 is\n       if Acts_As_Clean or Has_Ctrl_Objs or Has_Tagged_Types then\n          Create_Finalizer;\n       end if;\n-   end Build_Finalizer_Helper;\n+   end Build_Finalizer;\n \n    --------------------------\n    -- Build_Finalizer_Call --\n@@ -3757,496 +3721,6 @@ package body Exp_Ch7 is\n       end;\n    end Build_Finalizer_Call;\n \n-   ---------------------\n-   -- Build_Finalizer --\n-   ---------------------\n-\n-   procedure Build_Finalizer\n-     (N           : Node_Id;\n-      Clean_Stmts : List_Id;\n-      Mark_Id     : Entity_Id;\n-      Top_Decls   : List_Id;\n-      Defer_Abort : Boolean;\n-      Fin_Id      : out Entity_Id)\n-   is\n-      Def_Ent : constant Entity_Id  := Unique_Defining_Entity (N);\n-      Loc     : constant Source_Ptr := Sloc (N);\n-\n-      --  Declarations used for the creation of _finalization_controller\n-\n-      Fin_Old_Id           : Entity_Id := Empty;\n-      Fin_Controller_Id    : Entity_Id := Empty;\n-      Fin_Controller_Decls : List_Id;\n-      Fin_Controller_Stmts : List_Id;\n-      Fin_Controller_Body  : Node_Id   := Empty;\n-      Fin_Controller_Spec  : Node_Id   := Empty;\n-      Postconditions_Call  : Node_Id   := Empty;\n-\n-      --  Defining identifiers for local objects used to store exception info\n-\n-      Raised_Post_Exception_Id         : Entity_Id := Empty;\n-      Raised_Finalization_Exception_Id : Entity_Id := Empty;\n-      Saved_Exception_Id               : Entity_Id := Empty;\n-\n-   --  Start of processing for Build_Finalizer\n-\n-   begin\n-      --  Create the general finalization routine\n-\n-      Build_Finalizer_Helper\n-        (N                 => N,\n-         Clean_Stmts       => Clean_Stmts,\n-         Mark_Id           => Mark_Id,\n-         Top_Decls         => Top_Decls,\n-         Defer_Abort       => Defer_Abort,\n-         Fin_Id            => Fin_Id,\n-         Finalize_Old_Only => False);\n-\n-      --  When postconditions are present, expansion gets much more complicated\n-      --  due to both the fact that they must be called after finalization and\n-      --  that finalization of 'Old objects must occur after the postconditions\n-      --  get checked.\n-\n-      --  Additionally, exceptions between general finalization and 'Old\n-      --  finalization must be propagated correctly and exceptions which happen\n-      --  during _postconditions need to be saved and reraised after\n-      --  finalization of 'Old objects.\n-\n-      --  Generate:\n-      --\n-      --    Postcond_Enabled := False;\n-      --\n-      --    procedure _finalization_controller is\n-      --\n-      --       --  Exception capturing and tracking\n-      --\n-      --       Saved_Exception               : Exception_Occurrence;\n-      --       Raised_Post_Exception         : Boolean := False;\n-      --       Raised_Finalization_Exception : Boolean := False;\n-      --\n-      --    --  Start of processing for _finalization_controller\n-      --\n-      --    begin\n-      --       --  Perform general finalization\n-      --\n-      --       begin\n-      --          _finalizer;\n-      --       exception\n-      --          when others =>\n-      --             --  Save the exception\n-      --\n-      --             Raised_Finalization_Exception := True;\n-      --             Save_Occurrence\n-      --               (Saved_Exception, Get_Current_Excep.all);\n-      --       end;\n-      --\n-      --       --  Perform postcondition checks after general finalization, but\n-      --       --  before finalization of 'Old related objects.\n-      --\n-      --       if not Raised_Finalization_Exception\n-      --         and then Return_Success_For_Postcond\n-      --       then\n-      --          begin\n-      --             --  Re-enable postconditions and check them\n-      --\n-      --             Postcond_Enabled := True;\n-      --             _postconditions [(Result_Obj_For_Postcond[.all])];\n-      --          exception\n-      --             when others =>\n-      --                --  Save the exception\n-      --\n-      --                Raised_Post_Exception := True;\n-      --                Save_Occurrence\n-      --                  (Saved_Exception, Get_Current_Excep.all);\n-      --          end;\n-      --       end if;\n-      --\n-      --       --  Finally finalize 'Old related objects\n-      --\n-      --       begin\n-      --          _finalizer_old;\n-      --       exception\n-      --          when others =>\n-      --             --  Reraise the previous finalization error if there is\n-      --             --  one.\n-      --\n-      --             if Raised_Finalization_Exception then\n-      --                Reraise_Occurrence (Saved_Exception);\n-      --             end if;\n-      --\n-      --             --  Otherwise, reraise the current one\n-      --\n-      --             raise;\n-      --       end;\n-      --\n-      --       --  Reraise any saved exception\n-      --\n-      --       if Raised_Finalization_Exception\n-      --            or else Raised_Post_Exception\n-      --       then\n-      --          Reraise_Occurrence (Saved_Exception);\n-      --       end if;\n-      --    end _finalization_controller;\n-\n-      if Nkind (N) = N_Subprogram_Body\n-        and then Present (Postconditions_Proc (Def_Ent))\n-      then\n-         Fin_Controller_Stmts := New_List;\n-         Fin_Controller_Decls := New_List;\n-\n-         --  Build the 'Old finalizer\n-\n-         Build_Finalizer_Helper\n-           (N                 => N,\n-            Clean_Stmts       => Empty_List,\n-            Mark_Id           => Mark_Id,\n-            Top_Decls         => Top_Decls,\n-            Defer_Abort       => Defer_Abort,\n-            Fin_Id            => Fin_Old_Id,\n-            Finalize_Old_Only => True);\n-\n-         --  Create local declarations for _finalization_controller needed for\n-         --  saving exceptions.\n-         --\n-         --  Generate:\n-         --\n-         --    Saved_Exception               : Exception_Occurrence;\n-         --    Raised_Post_Exception         : Boolean := False;\n-         --    Raised_Finalization_Exception : Boolean := False;\n-\n-         Saved_Exception_Id               := Make_Temporary (Loc, 'S');\n-         Raised_Post_Exception_Id         := Make_Temporary (Loc, 'P');\n-         Raised_Finalization_Exception_Id := Make_Temporary (Loc, 'F');\n-\n-         Append_List_To (Fin_Controller_Decls, New_List (\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Saved_Exception_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Exception_Occurrence), Loc)),\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Raised_Post_Exception_Id,\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc)),\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Raised_Finalization_Exception_Id,\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc))));\n-\n-         --  Call _finalizer and save any exceptions which occur\n-\n-         --  Generate:\n-         --\n-         --    begin\n-         --       _finalizer;\n-         --    exception\n-         --       when others =>\n-         --          Raised_Finalization_Exception := True;\n-         --          Save_Occurrence\n-         --            (Saved_Exception, Get_Current_Excep.all);\n-         --    end;\n-\n-         if Present (Fin_Id) then\n-            Append_To (Fin_Controller_Stmts,\n-              Make_Block_Statement (Loc,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements         => New_List (\n-                      Make_Procedure_Call_Statement (Loc,\n-                        Name => New_Occurrence_Of (Fin_Id, Loc))),\n-                    Exception_Handlers => New_List (\n-                      Make_Exception_Handler (Loc,\n-                        Exception_Choices => New_List (\n-                          Make_Others_Choice (Loc)),\n-                        Statements        => New_List (\n-                          Make_Assignment_Statement (Loc,\n-                            Name       =>\n-                              New_Occurrence_Of\n-                                (Raised_Finalization_Exception_Id, Loc),\n-                            Expression =>\n-                              New_Occurrence_Of (Standard_True, Loc)),\n-                          Make_Procedure_Call_Statement (Loc,\n-                             Name                   =>\n-                               New_Occurrence_Of\n-                                 (RTE (RE_Save_Occurrence), Loc),\n-                             Parameter_Associations => New_List (\n-                               New_Occurrence_Of\n-                                 (Saved_Exception_Id, Loc),\n-                               Make_Explicit_Dereference (Loc,\n-                                 Prefix =>\n-                                   Make_Function_Call (Loc,\n-                                     Name =>\n-                                       Make_Explicit_Dereference (Loc,\n-                                         Prefix =>\n-                                           New_Occurrence_Of\n-                                             (RTE (RE_Get_Current_Excep),\n-                                              Loc))))))))))));\n-         end if;\n-\n-         --  Create the call to postconditions based on the kind of the current\n-         --  subprogram, and the type of the Result_Obj_For_Postcond.\n-\n-         --  Generate:\n-         --\n-         --    _postconditions (Result_Obj_For_Postcond[.all]);\n-         --\n-         --   or\n-         --\n-         --    _postconditions;\n-\n-         if Ekind (Def_Ent) = E_Procedure then\n-            Postconditions_Call :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Occurrence_Of\n-                    (Postconditions_Proc (Def_Ent), Loc));\n-         else\n-            Postconditions_Call :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of\n-                    (Postconditions_Proc (Def_Ent), Loc),\n-                Parameter_Associations => New_List (\n-                  (if Is_Elementary_Type (Etype (Def_Ent)) then\n-                      New_Occurrence_Of\n-                        (Get_Result_Object_For_Postcond\n-                          (Def_Ent), Loc)\n-                   else\n-                      Make_Explicit_Dereference (Loc,\n-                        New_Occurrence_Of\n-                          (Get_Result_Object_For_Postcond\n-                            (Def_Ent), Loc)))));\n-         end if;\n-\n-         --  Call _postconditions when no general finalization exceptions have\n-         --  occurred taking care to enable the postconditions and save any\n-         --  exception occurrences.\n-\n-         --  Generate:\n-         --\n-         --    if not Raised_Finalization_Exception\n-         --      and then Return_Success_For_Postcond\n-         --    then\n-         --       begin\n-         --          Postcond_Enabled := True;\n-         --          _postconditions [(Result_Obj_For_Postcond[.all])];\n-         --       exception\n-         --          when others =>\n-         --             Raised_Post_Exception := True;\n-         --             Save_Occurrence\n-         --               (Saved_Exception, Get_Current_Excep.all);\n-         --       end;\n-         --    end if;\n-\n-         Append_To (Fin_Controller_Stmts,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               Make_And_Then (Loc,\n-                 Left_Opnd  =>\n-                   Make_Op_Not (Loc,\n-                     Right_Opnd =>\n-                       New_Occurrence_Of\n-                         (Raised_Finalization_Exception_Id, Loc)),\n-                 Right_Opnd =>\n-                   New_Occurrence_Of\n-                     (Get_Return_Success_For_Postcond (Def_Ent), Loc)),\n-             Then_Statements => New_List (\n-               Make_Block_Statement (Loc,\n-                 Handled_Statement_Sequence =>\n-                   Make_Handled_Sequence_Of_Statements (Loc,\n-                     Statements         => New_List (\n-                       Make_Assignment_Statement (Loc,\n-                         Name       =>\n-                           New_Occurrence_Of\n-                             (Get_Postcond_Enabled (Def_Ent), Loc),\n-                         Expression =>\n-                            New_Occurrence_Of\n-                              (Standard_True, Loc)),\n-                       Postconditions_Call),\n-                     Exception_Handlers => New_List (\n-                       Make_Exception_Handler (Loc,\n-                         Exception_Choices => New_List (\n-                           Make_Others_Choice (Loc)),\n-                         Statements        => New_List (\n-                           Make_Assignment_Statement (Loc,\n-                             Name       =>\n-                               New_Occurrence_Of\n-                                 (Raised_Post_Exception_Id, Loc),\n-                             Expression =>\n-                               New_Occurrence_Of (Standard_True, Loc)),\n-                           Make_Procedure_Call_Statement (Loc,\n-                              Name                   =>\n-                                New_Occurrence_Of\n-                                  (RTE (RE_Save_Occurrence), Loc),\n-                              Parameter_Associations => New_List (\n-                                New_Occurrence_Of\n-                                  (Saved_Exception_Id, Loc),\n-                                Make_Explicit_Dereference (Loc,\n-                                  Prefix =>\n-                                    Make_Function_Call (Loc,\n-                                      Name =>\n-                                        Make_Explicit_Dereference (Loc,\n-                                          Prefix =>\n-                                            New_Occurrence_Of\n-                                              (RTE (RE_Get_Current_Excep),\n-                                               Loc))))))))))))));\n-\n-         --  Call _finalizer_old and reraise any exception that occurred during\n-         --  initial finalization within the exception handler. Otherwise,\n-         --  propagate the current exception.\n-\n-         --  Generate:\n-         --\n-         --    begin\n-         --       _finalizer_old;\n-         --    exception\n-         --       when others =>\n-         --          if Raised_Finalization_Exception then\n-         --             Reraise_Occurrence (Saved_Exception);\n-         --          end if;\n-         --          raise;\n-         --    end;\n-\n-         if Present (Fin_Old_Id) then\n-            Append_To (Fin_Controller_Stmts,\n-              Make_Block_Statement (Loc,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements         => New_List (\n-                      Make_Procedure_Call_Statement (Loc,\n-                        Name => New_Occurrence_Of (Fin_Old_Id, Loc))),\n-                    Exception_Handlers => New_List (\n-                      Make_Exception_Handler (Loc,\n-                        Exception_Choices => New_List (\n-                          Make_Others_Choice (Loc)),\n-                        Statements        => New_List (\n-                          Make_If_Statement (Loc,\n-                            Condition       =>\n-                              New_Occurrence_Of\n-                                (Raised_Finalization_Exception_Id, Loc),\n-                            Then_Statements => New_List (\n-                              Make_Procedure_Call_Statement (Loc,\n-                                Name                   =>\n-                                  New_Occurrence_Of\n-                                    (RTE (RE_Reraise_Occurrence), Loc),\n-                                Parameter_Associations => New_List (\n-                                  New_Occurrence_Of\n-                                    (Saved_Exception_Id, Loc))))),\n-                          Make_Raise_Statement (Loc)))))));\n-         end if;\n-\n-         --  Once finalization is complete reraise any pending exceptions\n-\n-         --  Generate:\n-         --\n-         --    if Raised_Post_Exception\n-         --      or else Raised_Finalization_Exception\n-         --    then\n-         --       Reraise_Occurrence (Saved_Exception);\n-         --    end if;\n-\n-         Append_To (Fin_Controller_Stmts,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               Make_Or_Else (Loc,\n-                 Left_Opnd  =>\n-                   New_Occurrence_Of\n-                     (Raised_Post_Exception_Id, Loc),\n-                 Right_Opnd =>\n-                   New_Occurrence_Of\n-                     (Raised_Finalization_Exception_Id, Loc)),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name            =>\n-                   New_Occurrence_Of (RTE (RE_Reraise_Occurrence), Loc),\n-                 Parameter_Associations => New_List (\n-                   New_Occurrence_Of\n-                     (Saved_Exception_Id, Loc))))));\n-\n-         --  Make the finalization controller subprogram body and declaration.\n-\n-         --  Generate:\n-         --    procedure _finalization_controller;\n-         --\n-         --    procedure _finalization_controller is\n-         --    begin\n-         --       [Fin_Controller_Stmts];\n-         --    end;\n-\n-         Fin_Controller_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Name_uFinalization_Controller));\n-\n-         Fin_Controller_Spec :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name => Fin_Controller_Id));\n-\n-         Fin_Controller_Body :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name =>\n-                   Make_Defining_Identifier (Loc, Chars (Fin_Controller_Id))),\n-             Declarations               => Fin_Controller_Decls,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Fin_Controller_Stmts));\n-\n-         --  Disable _postconditions calls which get generated before return\n-         --  statements to delay their evaluation until after finalization.\n-\n-         --  This is done by way of the local Postcond_Enabled object which is\n-         --  initially assigned to True - we then create an assignment within\n-         --  the subprogram's declaration to make it False and assign it back\n-         --  to True before _postconditions is called within\n-         --  _finalization_controller.\n-\n-         --  Generate:\n-         --\n-         --    Postcond_Enable := False;\n-\n-         --  Note that we do not disable early evaluation of postconditions\n-         --  for return types that are unconstrained or have unconstrained\n-         --  elements since the temporary result object could get allocated on\n-         --  the stack and be out of scope at the point where we perform late\n-         --  evaluation of postconditions - leading to uninitialized memory\n-         --  reads.\n-\n-         --  This disabling of early evaluation can lead to incorrect run-time\n-         --  semantics where functions with unconstrained elements will\n-         --  have their corresponding postconditions evaluated before\n-         --  finalization. The proper solution here is to generate a wrapper\n-         --  to capture the result instead of using multiple flags and playing\n-         --  with flags which does not even work in all cases ???\n-\n-         if not Has_Unconstrained_Elements (Etype (Def_Ent))\n-           or else (Is_Array_Type (Etype (Def_Ent))\n-                     and then not Is_Constrained (Etype (Def_Ent)))\n-         then\n-            Append_To (Top_Decls,\n-              Make_Assignment_Statement (Loc,\n-                Name       =>\n-                  New_Occurrence_Of\n-                    (Get_Postcond_Enabled (Def_Ent), Loc),\n-                Expression =>\n-                  New_Occurrence_Of\n-                    (Standard_False, Loc)));\n-         end if;\n-\n-         --  Add the subprogram to the list of declarations an analyze it\n-\n-         Append_To (Top_Decls, Fin_Controller_Spec);\n-         Analyze (Fin_Controller_Spec);\n-         Insert_After (Fin_Controller_Spec, Fin_Controller_Body);\n-         Analyze (Fin_Controller_Body, Suppress => All_Checks);\n-\n-         --  Return the finalization controller as the result Fin_Id\n-\n-         Fin_Id := Fin_Controller_Id;\n-      end if;\n-   end Build_Finalizer;\n-\n    ---------------------\n    -- Build_Late_Proc --\n    ---------------------"}, {"sha": "8abff55110dc55232839fbb072bc3a4aed48ac10", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 6, "deletions": 293, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -26,6 +26,7 @@\n with Atree;          use Atree;\n with Aspects;        use Aspects;\n with Checks;         use Checks;\n+with Contracts;      use Contracts;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n@@ -134,15 +135,6 @@ package body Exp_Ch9 is\n    --  Build a specification for a function implementing the protected entry\n    --  barrier of the specified entry body.\n \n-   procedure Build_Contract_Wrapper (E : Entity_Id; Decl : Node_Id);\n-   --  Build the body of a wrapper procedure for an entry or entry family that\n-   --  has contract cases, preconditions, or postconditions. The body gathers\n-   --  the executable contract items and expands them in the usual way, and\n-   --  performs the entry call itself. This way preconditions are evaluated\n-   --  before the call is queued. E is the entry in question, and Decl is the\n-   --  enclosing synchronized type declaration at whose freeze point the\n-   --  generated body is analyzed.\n-\n    function Build_Corresponding_Record\n      (N    : Node_Id;\n       Ctyp : Entity_Id;\n@@ -1296,288 +1288,6 @@ package body Exp_Ch9 is\n       Set_Master_Id (Typ, Master_Id);\n    end Build_Class_Wide_Master;\n \n-   ----------------------------\n-   -- Build_Contract_Wrapper --\n-   ----------------------------\n-\n-   procedure Build_Contract_Wrapper (E : Entity_Id; Decl : Node_Id) is\n-      Conc_Typ : constant Entity_Id  := Scope (E);\n-      Loc      : constant Source_Ptr := Sloc (E);\n-\n-      procedure Add_Discriminant_Renamings\n-        (Obj_Id : Entity_Id;\n-         Decls  : List_Id);\n-      --  Add renaming declarations for all discriminants of concurrent type\n-      --  Conc_Typ. Obj_Id is the entity of the wrapper formal parameter which\n-      --  represents the concurrent object.\n-\n-      procedure Add_Matching_Formals\n-        (Formals : List_Id;\n-         Actuals : in out List_Id);\n-      --  Add formal parameters that match those of entry E to list Formals.\n-      --  The routine also adds matching actuals for the new formals to list\n-      --  Actuals.\n-\n-      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id);\n-      --  Relocate pragma Prag to list To. The routine creates a new list if\n-      --  To does not exist.\n-\n-      --------------------------------\n-      -- Add_Discriminant_Renamings --\n-      --------------------------------\n-\n-      procedure Add_Discriminant_Renamings\n-        (Obj_Id : Entity_Id;\n-         Decls  : List_Id)\n-      is\n-         Discr : Entity_Id;\n-\n-      begin\n-         --  Inspect the discriminants of the concurrent type and generate a\n-         --  renaming for each one.\n-\n-         if Has_Discriminants (Conc_Typ) then\n-            Discr := First_Discriminant (Conc_Typ);\n-            while Present (Discr) loop\n-               Prepend_To (Decls,\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Chars (Discr)),\n-                   Subtype_Mark        =>\n-                     New_Occurrence_Of (Etype (Discr), Loc),\n-                   Name                =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n-                       Selector_Name =>\n-                         Make_Identifier (Loc, Chars (Discr)))));\n-\n-               Next_Discriminant (Discr);\n-            end loop;\n-         end if;\n-      end Add_Discriminant_Renamings;\n-\n-      --------------------------\n-      -- Add_Matching_Formals --\n-      --------------------------\n-\n-      procedure Add_Matching_Formals\n-        (Formals : List_Id;\n-         Actuals : in out List_Id)\n-      is\n-         Formal     : Entity_Id;\n-         New_Formal : Entity_Id;\n-\n-      begin\n-         --  Inspect the formal parameters of the entry and generate a new\n-         --  matching formal with the same name for the wrapper. A reference\n-         --  to the new formal becomes an actual in the entry call.\n-\n-         Formal := First_Formal (E);\n-         while Present (Formal) loop\n-            New_Formal := Make_Defining_Identifier (Loc, Chars (Formal));\n-            Append_To (Formals,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => New_Formal,\n-                In_Present          => In_Present  (Parent (Formal)),\n-                Out_Present         => Out_Present (Parent (Formal)),\n-                Parameter_Type      =>\n-                  New_Occurrence_Of (Etype (Formal), Loc)));\n-\n-            if No (Actuals) then\n-               Actuals := New_List;\n-            end if;\n-\n-            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n-            Next_Formal (Formal);\n-         end loop;\n-      end Add_Matching_Formals;\n-\n-      ---------------------\n-      -- Transfer_Pragma --\n-      ---------------------\n-\n-      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id) is\n-         New_Prag : Node_Id;\n-\n-      begin\n-         if No (To) then\n-            To := New_List;\n-         end if;\n-\n-         New_Prag := Relocate_Node (Prag);\n-\n-         Set_Analyzed (New_Prag, False);\n-         Append       (New_Prag, To);\n-      end Transfer_Pragma;\n-\n-      --  Local variables\n-\n-      Items      : constant Node_Id := Contract (E);\n-      Actuals    : List_Id := No_List;\n-      Call       : Node_Id;\n-      Call_Nam   : Node_Id;\n-      Decls      : List_Id := No_List;\n-      Formals    : List_Id;\n-      Has_Pragma : Boolean := False;\n-      Index_Id   : Entity_Id;\n-      Obj_Id     : Entity_Id;\n-      Prag       : Node_Id;\n-      Wrapper_Id : Entity_Id;\n-\n-   --  Start of processing for Build_Contract_Wrapper\n-\n-   begin\n-      --  This routine generates a specialized wrapper for a protected or task\n-      --  entry [family] which implements precondition/postcondition semantics.\n-      --  Preconditions and case guards of contract cases are checked before\n-      --  the protected action or rendezvous takes place. Postconditions and\n-      --  consequences of contract cases are checked after the protected action\n-      --  or rendezvous takes place. The structure of the generated wrapper is\n-      --  as follows:\n-\n-      --    procedure Wrapper\n-      --      (Obj_Id    : Conc_Typ;    --  concurrent object\n-      --       [Index    : Index_Typ;]  --  index of entry family\n-      --       [Formal_1 : ...;         --  parameters of original entry\n-      --        Formal_N : ...])\n-      --    is\n-      --       [Discr_1 : ... renames Obj_Id.Discr_1;   --  discriminant\n-      --        Discr_N : ... renames Obj_Id.Discr_N;]  --  renamings\n-\n-      --       <precondition checks>\n-      --       <case guard checks>\n-\n-      --       procedure _Postconditions is\n-      --       begin\n-      --          <postcondition checks>\n-      --          <consequence checks>\n-      --       end _Postconditions;\n-\n-      --    begin\n-      --       Entry_Call (Obj_Id, [Index,] [Formal_1, Formal_N]);\n-      --       _Postconditions;\n-      --    end Wrapper;\n-\n-      --  Create the wrapper only when the entry has at least one executable\n-      --  contract item such as contract cases, precondition or postcondition.\n-\n-      if Present (Items) then\n-\n-         --  Inspect the list of pre/postconditions and transfer all available\n-         --  pragmas to the declarative list of the wrapper.\n-\n-         Prag := Pre_Post_Conditions (Items);\n-         while Present (Prag) loop\n-            if Pragma_Name_Unmapped (Prag) in Name_Postcondition\n-                                            | Name_Precondition\n-              and then Is_Checked (Prag)\n-            then\n-               Has_Pragma := True;\n-               Transfer_Pragma (Prag, To => Decls);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Inspect the list of test/contract cases and transfer only contract\n-         --  cases pragmas to the declarative part of the wrapper.\n-\n-         Prag := Contract_Test_Cases (Items);\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Contract_Cases\n-              and then Is_Checked (Prag)\n-            then\n-               Has_Pragma := True;\n-               Transfer_Pragma (Prag, To => Decls);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end if;\n-\n-      --  The entry lacks executable contract items and a wrapper is not needed\n-\n-      if not Has_Pragma then\n-         return;\n-      end if;\n-\n-      --  Create the profile of the wrapper. The first formal parameter is the\n-      --  concurrent object.\n-\n-      Obj_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Conc_Typ), 'A'));\n-\n-      Formals := New_List (\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => Obj_Id,\n-          Out_Present         => True,\n-          In_Present          => True,\n-          Parameter_Type      => New_Occurrence_Of (Conc_Typ, Loc)));\n-\n-      --  Construct the call to the original entry. The call will be gradually\n-      --  augmented with an optional entry index and extra parameters.\n-\n-      Call_Nam :=\n-        Make_Selected_Component (Loc,\n-          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n-          Selector_Name => New_Occurrence_Of (E, Loc));\n-\n-      --  When creating a wrapper for an entry family, the second formal is the\n-      --  entry index.\n-\n-      if Ekind (E) = E_Entry_Family then\n-         Index_Id := Make_Defining_Identifier (Loc, Name_I);\n-\n-         Append_To (Formals,\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Index_Id,\n-             Parameter_Type      =>\n-               New_Occurrence_Of (Entry_Index_Type (E), Loc)));\n-\n-         --  The call to the original entry becomes an indexed component to\n-         --  accommodate the entry index.\n-\n-         Call_Nam :=\n-           Make_Indexed_Component (Loc,\n-             Prefix      => Call_Nam,\n-             Expressions => New_List (New_Occurrence_Of (Index_Id, Loc)));\n-      end if;\n-\n-      --  Add formal parameters to match those of the entry and build actuals\n-      --  for the entry call.\n-\n-      Add_Matching_Formals (Formals, Actuals);\n-\n-      Call :=\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   => Call_Nam,\n-          Parameter_Associations => Actuals);\n-\n-      --  Add renaming declarations for the discriminants of the enclosing type\n-      --  as the various contract items may reference them.\n-\n-      Add_Discriminant_Renamings (Obj_Id, Decls);\n-\n-      Wrapper_Id :=\n-        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n-      Set_Contract_Wrapper (E, Wrapper_Id);\n-      Set_Is_Entry_Wrapper (Wrapper_Id);\n-\n-      --  The wrapper body is analyzed when the enclosing type is frozen\n-\n-      Append_Freeze_Action (Defining_Entity (Decl),\n-        Make_Subprogram_Body (Loc,\n-          Specification              =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Wrapper_Id,\n-              Parameter_Specifications => Formals),\n-          Declarations               => Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Call))));\n-   end Build_Contract_Wrapper;\n-\n    --------------------------------\n    -- Build_Corresponding_Record --\n    --------------------------------\n@@ -9135,7 +8845,7 @@ package body Exp_Ch9 is\n          --  Build a wrapper procedure to handle contract cases, preconditions,\n          --  and postconditions.\n \n-         Build_Contract_Wrapper (Ent_Id, N);\n+         Build_Entry_Contract_Wrapper (Ent_Id, N);\n \n          --  Create the barrier function\n \n@@ -12529,7 +12239,7 @@ package body Exp_Ch9 is\n          Ent := First_Entity (Tasktyp);\n          while Present (Ent) loop\n             if Ekind (Ent) in E_Entry | E_Entry_Family then\n-               Build_Contract_Wrapper (Ent, N);\n+               Build_Entry_Contract_Wrapper (Ent, N);\n             end if;\n \n             Next_Entity (Ent);\n@@ -13731,6 +13441,7 @@ package body Exp_Ch9 is\n                   Make_Selected_Component (Loc,\n                     Prefix        => New_Occurrence_Of (Obj_Ent, Loc),\n                     Selector_Name => Make_Identifier (Loc, Name_uObject)));\n+\n             Add (Decl);\n          end;\n       end if;\n@@ -13762,6 +13473,7 @@ package body Exp_Ch9 is\n                      Make_Selected_Component (Loc,\n                        Prefix        => New_Occurrence_Of (Obj_Ent, Loc),\n                        Selector_Name => Make_Identifier (Loc, Chars (D))));\n+\n                Add (Decl);\n \n                --  Set debug info needed on this renaming declaration even\n@@ -13828,6 +13540,7 @@ package body Exp_Ch9 is\n                            Make_Selected_Component (Loc,\n                              Prefix => New_Occurrence_Of (Obj_Ent, Loc),\n                              Selector_Name => Make_Identifier (Loc, Nam)));\n+\n                      Add (Decl);\n                   end if;\n "}, {"sha": "2def83cc20c87a16dc5857743fddc38b9483999a", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -453,6 +453,8 @@ package body Exp_Prag is\n                            New_Occurrence_Of (RTE (RE_Assert_Failure),\n                                                                    Loc))))))));\n \n+         Set_Comes_From_Check_Or_Contract (N);\n+\n       --  Case where we call the procedure\n \n       else\n@@ -541,6 +543,8 @@ package body Exp_Prag is\n                  Name                   =>\n                    New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n                  Parameter_Associations => New_List (Relocate_Node (Msg))))));\n+\n+         Set_Comes_From_Check_Or_Contract (N);\n       end if;\n \n       Analyze (N);\n@@ -1433,6 +1437,8 @@ package body Exp_Prag is\n                 Condition       => Cond,\n                 Then_Statements => New_List (Error));\n \n+            Set_Comes_From_Check_Or_Contract (Checks);\n+\n          else\n             if No (Elsif_Parts (Checks)) then\n                Set_Elsif_Parts (Checks, New_List);\n@@ -1642,6 +1648,8 @@ package body Exp_Prag is\n                 Condition       => New_Occurrence_Of (Flag, Loc),\n                 Then_Statements => Eval_Stmts);\n \n+            Set_Comes_From_Check_Or_Contract (Evals);\n+\n          --  Otherwise generate:\n          --    elsif Flag then\n          --       <evaluation statements>\n@@ -1836,6 +1844,8 @@ package body Exp_Prag is\n                   Set (Flag),\n                   Increment (Count)));\n \n+            Set_Comes_From_Check_Or_Contract (If_Stmt);\n+\n             Append_To (Decls, If_Stmt);\n             Analyze (If_Stmt);\n \n@@ -1904,6 +1914,8 @@ package body Exp_Prag is\n               Right_Opnd => Make_Integer_Literal (Loc, 0)),\n           Then_Statements => CG_Stmts);\n \n+      Set_Comes_From_Check_Or_Contract (CG_Checks);\n+\n       --  Detect a possible failure due to several case guards evaluating to\n       --  True.\n \n@@ -1937,15 +1949,17 @@ package body Exp_Prag is\n                            New_Occurrence_Of (Msg_Str, Loc))))))))));\n       end if;\n \n+      --  Append the checks, but do not analyze them at this point, because\n+      --  contracts get potentially expanded as part of a wrapper which gets\n+      --  fully analyzed once it is fully formed.\n+\n       Append_To (Decls, CG_Checks);\n-      Analyze (CG_Checks);\n \n       --  Once all case guards are evaluated and checked, evaluate any prefixes\n       --  of attribute 'Old founds in the selected consequence.\n \n       if Present (Old_Evals) then\n          Append_To (Decls, Old_Evals);\n-         Analyze (Old_Evals);\n       end if;\n \n       --  Raise Assertion_Error when the corresponding consequence of a case"}, {"sha": "346904ee0a4681c145e9df020e3cfd3fd05fb42b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -6248,6 +6248,32 @@ package body Freeze is\n         and then Scope (Test_E) /= Current_Scope\n         and then Ekind (Test_E) /= E_Constant\n       then\n+         --  Here we deal with the special case of the expansion of\n+         --  postconditions. Previously this was handled by the loop below,\n+         --  since these postcondition checks got isolated to a separate,\n+         --  internally generated, subprogram. Now, however, the postcondition\n+         --  checks get contained within their corresponding subprogram\n+         --  directly.\n+\n+         if not Comes_From_Source (N)\n+           and then Nkind (N) = N_Pragma\n+           and then From_Aspect_Specification (N)\n+           and then Is_Valid_Assertion_Kind (Original_Aspect_Pragma_Name (N))\n+\n+           --  Now, verify the placement of the pragma is within an expanded\n+           --  subprogram which contains postcondition expansion - detected\n+           --  through the presence of the \"Wrapped_Statements\" field.\n+\n+           and then Present (Enclosing_Subprogram (Current_Scope))\n+           and then Present (Wrapped_Statements\n+                              (Enclosing_Subprogram (Current_Scope)))\n+         then\n+            goto Leave;\n+         end if;\n+\n+         --  Otherwise, loop through scopes checking if an enclosing scope\n+         --  comes from source or is a generic.\n+\n          declare\n             S : Entity_Id;\n \n@@ -8330,9 +8356,9 @@ package body Freeze is\n             --  If the parent is a subprogram body, the candidate insertion\n             --  point is just ahead of it.\n \n-            if  Nkind (Parent_P) = N_Subprogram_Body\n-                and then Unique_Defining_Entity (Parent_P) =\n-                           Freeze_Outside_Subp\n+            if Nkind (Parent_P) = N_Subprogram_Body\n+              and then Unique_Defining_Entity (Parent_P) =\n+                         Freeze_Outside_Subp\n             then\n                P := Parent_P;\n                exit;"}, {"sha": "83c71800b5a5af5de2e2a00ce35c3dc51de48af5", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -96,6 +96,7 @@ package Gen_IL.Fields is\n       Class_Present,\n       Classifications,\n       Cleanup_Actions,\n+      Comes_From_Check_Or_Contract,\n       Comes_From_Extended_Return_Statement,\n       Compile_Time_Known_Aggregate,\n       Component_Associations,\n@@ -929,7 +930,8 @@ package Gen_IL.Fields is\n       Warnings_Off_Used_Unmodified,\n       Warnings_Off_Used_Unreferenced,\n       Was_Hidden,\n-      Wrapped_Entity\n+      Wrapped_Entity,\n+      Wrapped_Statements\n \n       --  End of entity fields.\n      ); -- Opt_Field_Enum"}, {"sha": "2e1e3c99f72f5919c82cfd3fbe9cf2f8a443b936", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -1046,7 +1046,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Thunk_Entity, Node_Id,\n             Pre => \"Is_Thunk (N)\"),\n         Sm (Wrapped_Entity, Node_Id,\n-            Pre => \"Is_Primitive_Wrapper (N)\")));\n+            Pre => \"Is_Primitive_Wrapper (N)\"),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Operator, Subprogram_Kind,\n        --  A predefined operator, appearing in Standard, or an implicitly\n@@ -1095,7 +1096,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Thunk_Entity, Node_Id,\n             Pre => \"Is_Thunk (N)\"),\n         Sm (Wrapped_Entity, Node_Id,\n-            Pre => \"Is_Primitive_Wrapper (N)\")));\n+            Pre => \"Is_Primitive_Wrapper (N)\"),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Abstract_State, Overloadable_Kind,\n        --  A state abstraction. Used to designate entities introduced by aspect\n@@ -1134,7 +1136,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Protection_Object, Node_Id),\n         Sm (Scope_Depth_Value, Unat),\n         Sm (SPARK_Pragma, Node_Id),\n-        Sm (SPARK_Pragma_Inherited, Flag)));\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Entry_Family, Entity_Kind,\n        --  An entry family, created by an entry family declaration in a\n@@ -1161,7 +1164,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Renamed_Or_Alias, Node_Id),\n         Sm (Scope_Depth_Value, Unat),\n         Sm (SPARK_Pragma, Node_Id),\n-        Sm (SPARK_Pragma_Inherited, Flag)));\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Block, Entity_Kind,\n        --  A block identifier, created by an explicit or implicit label on"}, {"sha": "556326a3e61412ca0557ff33a93751802f9138fe", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -1098,7 +1098,8 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Elsif_Parts, List_Id, Default_No_List),\n         Sy (Else_Statements, List_Id, Default_No_List),\n         Sy (End_Span, Unat, Default_Uint_0),\n-        Sm (From_Conditional_Expression, Flag)));\n+        Sm (From_Conditional_Expression, Flag),\n+        Sm (Comes_From_Check_Or_Contract, Flag)));\n \n    Cc (N_Accept_Alternative, Node_Kind,\n        (Sy (Accept_Statement, Node_Id),"}, {"sha": "0f03285b024174acac0d690e2bc1a97800c9e190", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -271,11 +271,11 @@ package body Ghost is\n \n                if Present (Subp_Id) then\n \n-                  --  The context is the internally built _Postconditions\n+                  --  The context is the internally built _Wrapped_Statements\n                   --  procedure, which is OK because the real check was done\n-                  --  before expansion activities.\n+                  --  before contract expansion activities.\n \n-                  if Chars (Subp_Id) = Name_uPostconditions then\n+                  if Chars (Subp_Id) = Name_uWrapped_Statements then\n                      return True;\n \n                   --  The context is the internally built predicate function,\n@@ -432,9 +432,7 @@ package body Ghost is\n             --  but it may still contain references to Ghost entities.\n \n             elsif Nkind (Stmt) = N_If_Statement\n-              and then Nkind (Original_Node (Stmt)) = N_Pragma\n-              and then Assertion_Expression_Pragma\n-                         (Get_Pragma_Id (Original_Node (Stmt)))\n+              and then Comes_From_Check_Or_Contract (Stmt)\n             then\n                return True;\n             end if;"}, {"sha": "e3f35daca09a266cb2ef8ffcea5f2c6a0c038105", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -3257,7 +3257,7 @@ package body Inline is\n          pragma Assert\n            (Modify_Tree_For_C\n              and then Is_Subprogram (Enclosing_Subp)\n-             and then Present (Postconditions_Proc (Enclosing_Subp)));\n+             and then Present (Wrapped_Statements (Enclosing_Subp)));\n \n          if Ekind (Enclosing_Subp) = E_Function then\n             if Nkind (First (Parameter_Associations (N))) in\n@@ -3851,7 +3851,7 @@ package body Inline is\n \n             if Modify_Tree_For_C\n               and then Nkind (N) = N_Procedure_Call_Statement\n-              and then Chars (Name (N)) = Name_uPostconditions\n+              and then Chars (Name (N)) = Name_uWrapped_Statements\n             then\n                Declare_Postconditions_Result;\n             end if;"}, {"sha": "043444c0ea3cb297209d26aa57acb5e9bc6c1f4d", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -618,15 +618,6 @@ package body Lib.Xref is\n          end if;\n       end if;\n \n-      --  Do not generate references if we are within a postcondition sub-\n-      --  program, because the reference does not comes from source, and the\n-      --  preanalysis of the aspect has already created an entry for the ALI\n-      --  file at the proper source location.\n-\n-      if Chars (Current_Scope) = Name_uPostconditions then\n-         return;\n-      end if;\n-\n       --  Never collect references if not in main source unit. However, we omit\n       --  this test if Typ is 'e' or 'k', since these entries are structural,\n       --  and it is useful to have them in units that reference packages as"}, {"sha": "691d8e4acb992d20ff126a3a734eadd8d78e9b2d", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -992,6 +992,15 @@ package body Lib is\n       return Is_Predefined_Renaming (Unit);\n    end In_Predefined_Renaming;\n \n+   ---------\n+   -- ipu --\n+   ---------\n+\n+   function ipu (N : Node_Or_Entity_Id) return Boolean is\n+   begin\n+      return In_Predefined_Unit (N);\n+   end ipu;\n+\n    ------------------------\n    -- In_Predefined_Unit --\n    ------------------------"}, {"sha": "c308ac17ed83de482bac6f878f204f674ba75a16", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -633,6 +633,12 @@ package Lib is\n    function In_Extended_Main_Source_Unit (Loc : Source_Ptr) return Boolean;\n    --  Same function as above, but argument is a source pointer\n \n+   function ipu (N : Node_Or_Entity_Id) return Boolean;\n+   --  Same as In_Predefined_Unit, but renamed so it can assist debugging.\n+   --  Otherwise, there is a disambiguous name conflict in the two versions of\n+   --  In_Predefined_Unit which makes it inconvient to set as a breakpoint\n+   --  condition.\n+\n    function In_Predefined_Unit (N : Node_Or_Entity_Id) return Boolean;\n    --  Returns True if the given node or entity appears within the source text\n    --  of a predefined unit (i.e. within Ada, Interfaces, System or within one"}, {"sha": "6869aca894d2694f8d934e6a06ad01b19d400c3f", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -1430,12 +1430,11 @@ package body Sem_Attr is\n                Placement_Error;\n             end if;\n \n-         --  'Old attribute reference ok in a _Postconditions procedure\n+         --  'Old attribute reference ok in a _Wrapped_Statements procedure\n \n          elsif Nkind (Prag) = N_Subprogram_Body\n-           and then not Comes_From_Source (Prag)\n-           and then Nkind (Corresponding_Spec (Prag)) = N_Defining_Identifier\n-           and then Chars (Corresponding_Spec (Prag)) = Name_uPostconditions\n+           and then Ekind (Defining_Entity (Prag)) in Subprogram_Kind\n+           and then Present (Wrapped_Statements (Defining_Entity (Prag)))\n          then\n             null;\n \n@@ -1450,18 +1449,18 @@ package body Sem_Attr is\n          if Nkind (Prag) = N_Aspect_Specification then\n             Subp_Decl := Parent (Prag);\n          elsif Nkind (Prag) = N_Subprogram_Body then\n-            declare\n-               Enclosing_Scope : constant Node_Id :=\n-                 Scope (Corresponding_Spec (Prag));\n-            begin\n-               pragma Assert (Postconditions_Proc (Enclosing_Scope)\n-                               = Corresponding_Spec (Prag));\n-               Subp_Decl := Parent (Parent (Enclosing_Scope));\n-            end;\n+            Subp_Decl := Prag;\n          else\n             Subp_Decl := Find_Related_Declaration_Or_Body (Prag);\n          end if;\n \n+         --  'Old objects appear in extended return statements as part of\n+         --  the expansion of contract wrappers.\n+\n+         if Nkind (Subp_Decl) = N_Extended_Return_Statement then\n+            Subp_Decl := Parent (Parent (Subp_Decl));\n+         end if;\n+\n          --  The aspect or pragma where the attribute resides should be\n          --  associated with a subprogram declaration or a body. If this is not\n          --  the case, then the aspect or pragma is illegal. Return as analysis\n@@ -1506,7 +1505,7 @@ package body Sem_Attr is\n \n          if Modify_Tree_For_C\n            and then Chars (Spec_Id) = Name_uParent\n-           and then Chars (Scope (Spec_Id)) = Name_uPostconditions\n+           and then Chars (Scope (Spec_Id)) = Name_uWrapped_Statements\n          then\n             --  This situation occurs only when analyzing the body-to-inline\n \n@@ -1750,7 +1749,7 @@ package body Sem_Attr is\n          if Is_Entry_Wrapper (Spec_Id) then\n             Legal := True;\n \n-         elsif Chars (Spec_Id) = Name_uPostconditions\n+         elsif Chars (Spec_Id) = Name_uWrapped_Statements\n            and then Is_Entry_Wrapper (Scope (Spec_Id))\n          then\n             Spec_Id := Scope (Spec_Id);\n@@ -5881,13 +5880,13 @@ package body Sem_Attr is\n             Error_Attr (\"prefix of % attribute must be a function\", P);\n          end if;\n \n-         --  Attribute 'Result is part of a _Postconditions procedure. There is\n+         --  Attribute 'Result is part of postconditions expansion. There is\n          --  no need to perform the semantic checks below as they were already\n          --  verified when the attribute was analyzed in its original context.\n          --  Instead, rewrite the attribute as a reference to formal parameter\n-         --  _Result of the _Postconditions procedure.\n+         --  _Result of the _Wrapped_Statements procedure.\n \n-         if Chars (Spec_Id) = Name_uPostconditions\n+         if Chars (Spec_Id) = Name_uWrapped_Statements\n            or else\n              (In_Inlined_C_Postcondition\n                and then Nkind (Parent (Spec_Id)) = N_Block_Statement)"}, {"sha": "339edd35d91698f2339fd70c65433be0ed8de0ef", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -49,7 +49,6 @@ with Sem_Warn;       use Sem_Warn;\n with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n-with Snames;         use Snames;\n with Stand;          use Stand;\n \n package body Sem_Ch11 is\n@@ -431,12 +430,10 @@ package body Sem_Ch11 is\n \n       --  If the current scope is a subprogram, entry or task body or declare\n       --  block then this is the right place to check for hanging useless\n-      --  assignments from the statement sequence. Skip this in the body of a\n-      --  postcondition, since in that case there are no source references.\n+      --  assignments from the statement sequence.\n \n-      if (Is_Subprogram_Or_Entry (Current_Scope)\n-           and then Chars (Current_Scope) /= Name_uPostconditions)\n-         or else Ekind (Current_Scope) in E_Block | E_Task_Type\n+      if Is_Subprogram_Or_Entry (Current_Scope)\n+        or else Ekind (Current_Scope) in E_Block | E_Task_Type\n       then\n          Warn_On_Useless_Assignments (Current_Scope);\n       end if;"}, {"sha": "045905825ad4200c96bb5057620f1656c008c3d7", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -1911,15 +1911,19 @@ package body Sem_Ch6 is\n             Analyze_Aspects_On_Subprogram_Body_Or_Stub (N);\n          end if;\n \n-         Analyze_Declarations (Declarations (N));\n-         Check_Completion;\n-\n-         --  Process the contract of the subprogram body after all declarations\n-         --  have been analyzed. This ensures that any contract-related pragmas\n-         --  are available through the N_Contract node of the body.\n+         --  Process the contract of the subprogram body after analyzing all\n+         --  the contract-related pragmas within the declarations.\n \n+         Analyze_Pragmas_In_Declarations (Body_Id);\n          Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id);\n \n+         --  Continue on with analyzing the declarations and statements once\n+         --  contract expansion is done and we are done expanding contract\n+         --  related wrappers.\n+\n+         Analyze_Declarations (Declarations (N));\n+         Check_Completion;\n+\n          Analyze (Handled_Statement_Sequence (N));\n          Save_Global_References (Original_Node (N));\n \n@@ -2895,7 +2899,6 @@ package body Sem_Ch6 is\n       Conformant : Boolean;\n       Desig_View : Entity_Id := Empty;\n       Exch_Views : Elist_Id  := No_Elist;\n-      HSS        : Node_Id;\n       Mask_Types : Elist_Id  := No_Elist;\n       Prot_Typ   : Entity_Id := Empty;\n       Spec_Decl  : Node_Id   := Empty;\n@@ -3530,6 +3533,8 @@ package body Sem_Ch6 is\n       --------------------------\n \n       procedure Check_Missing_Return is\n+         HSS : constant Node_Id := Handled_Statement_Sequence (N);\n+\n          Id          : Entity_Id;\n          Missing_Ret : Boolean;\n \n@@ -3968,18 +3973,9 @@ package body Sem_Ch6 is\n \n                --  Move relevant pragmas to the spec\n \n-               elsif Pragma_Name_Unmapped (Decl) in Name_Depends\n-                                                  | Name_Ghost\n-                                                  | Name_Global\n-                                                  | Name_Pre\n-                                                  | Name_Precondition\n-                                                  | Name_Post\n-                                                  | Name_Refined_Depends\n-                                                  | Name_Refined_Global\n-                                                  | Name_Refined_Post\n-                                                  | Name_Inline\n-                                                  | Name_Pure_Function\n-                                                  | Name_Volatile_Function\n+               elsif\n+                 Pragma_Significant_To_Subprograms\n+                   (Get_Pragma_Id (Decl))\n                then\n                   Remove (Decl);\n                   Insert_After (Insert_Nod, Decl);\n@@ -4223,7 +4219,6 @@ package body Sem_Ch6 is\n             Analyze_Generic_Subprogram_Body (N, Spec_Id);\n \n             if Nkind (N) = N_Subprogram_Body then\n-               HSS := Handled_Statement_Sequence (N);\n                Check_Missing_Return;\n             end if;\n \n@@ -5157,9 +5152,27 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n-      --  Now we can go on to analyze the body\n+      --  Ada 2012 (AI05-0151): Incomplete types coming from a limited context\n+      --  may now appear in parameter and result profiles. Since the analysis\n+      --  of a subprogram body may use the parameter and result profile of the\n+      --  spec, swap any limited views with their non-limited counterpart.\n+\n+      if Ada_Version >= Ada_2012 and then Present (Spec_Id) then\n+         Exch_Views := Exchange_Limited_Views (Spec_Id);\n+      end if;\n+\n+      --  Analyze any aspect specifications that appear on the subprogram body\n+\n+      if Has_Aspects (N) then\n+         Analyze_Aspects_On_Subprogram_Body_Or_Stub (N);\n+      end if;\n+\n+      --  Process the contract of the subprogram body after analyzing all the\n+      --  contract-related pragmas within the declarations.\n+\n+      Analyze_Pragmas_In_Declarations (Body_Id);\n+      Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id);\n \n-      HSS := Handled_Statement_Sequence (N);\n       Set_Actual_Subtypes (N, Current_Scope);\n \n       --  Add a declaration for the Protection object, renaming declarations\n@@ -5180,15 +5193,6 @@ package body Sem_Ch6 is\n            (Sloc (N), Spec_Id, Prot_Typ, N, Declarations (N));\n       end if;\n \n-      --  Ada 2012 (AI05-0151): Incomplete types coming from a limited context\n-      --  may now appear in parameter and result profiles. Since the analysis\n-      --  of a subprogram body may use the parameter and result profile of the\n-      --  spec, swap any limited views with their non-limited counterpart.\n-\n-      if Ada_Version >= Ada_2012 and then Present (Spec_Id) then\n-         Exch_Views := Exchange_Limited_Views (Spec_Id);\n-      end if;\n-\n       --  If the return type is an anonymous access type whose designated type\n       --  is the limited view of a class-wide type and the non-limited view is\n       --  available, update the return type accordingly.\n@@ -5225,12 +5229,6 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n-      --  Analyze any aspect specifications that appear on the subprogram body\n-\n-      if Has_Aspects (N) then\n-         Analyze_Aspects_On_Subprogram_Body_Or_Stub (N);\n-      end if;\n-\n       Analyze_Declarations (Declarations (N));\n \n       --  Verify that the SPARK_Mode of the body agrees with that of its spec\n@@ -5269,17 +5267,11 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  A subprogram body freezes its own contract. Analyze the contract\n-      --  after the declarations of the body have been processed as pragmas\n-      --  are now chained on the contract of the subprogram body.\n-\n-      Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id);\n-\n       --  Check completion, and analyze the statements\n \n       Check_Completion;\n       Inspect_Deferred_Constant_Completion (Declarations (N));\n-      Analyze (HSS);\n+      Analyze (Handled_Statement_Sequence (N));\n \n       --  Add the generated minimum accessibility objects to the subprogram\n       --  body's list of declarations after analysis of the statements and\n@@ -5296,7 +5288,8 @@ package body Sem_Ch6 is\n \n       --  Deal with end of scope processing for the body\n \n-      Process_End_Label (HSS, 't', Current_Scope);\n+      Process_End_Label\n+        (Handled_Statement_Sequence (N), 't', Current_Scope);\n       Update_Use_Clause_Chain;\n       End_Scope;\n \n@@ -5410,7 +5403,7 @@ package body Sem_Ch6 is\n       --  the warning.\n \n       declare\n-         Stm : Node_Id := First (Statements (HSS));\n+         Stm : Node_Id := First (Statements (Handled_Statement_Sequence (N)));\n       begin\n          --  Skip call markers installed by the ABE mechanism, labels, and\n          --  Push_xxx_Error_Label to find the first real statement."}, {"sha": "f912f8bfb0a2c41b95268d84526b40d6139a423f", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 2, "deletions": 47, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -1809,11 +1809,6 @@ package body Sem_Elab is\n       --  Determine whether arbitrary entity Id denotes a partial invariant\n       --  procedure.\n \n-      function Is_Postconditions_Proc (Id : Entity_Id) return Boolean;\n-      pragma Inline (Is_Postconditions_Proc);\n-      --  Determine whether arbitrary entity Id denotes internally generated\n-      --  routine _Postconditions.\n-\n       function Is_Preelaborated_Unit (Id : Entity_Id) return Boolean;\n       pragma Inline (Is_Preelaborated_Unit);\n       --  Determine whether arbitrary entity Id denotes a unit which is subject\n@@ -2481,14 +2476,6 @@ package body Sem_Elab is\n          elsif Is_Partial_Invariant_Proc (Subp_Id) then\n             null;\n \n-         --  _Postconditions\n-\n-         elsif Is_Postconditions_Proc (Subp_Id) then\n-            Output_Verification_Call\n-              (Pred    => \"postconditions\",\n-               Id      => Find_Enclosing_Scope (Call),\n-               Id_Kind => \"subprogram\");\n-\n          --  Subprograms must come last because some of the previous cases fall\n          --  under this category.\n \n@@ -6638,14 +6625,6 @@ package body Sem_Elab is\n             elsif Is_Partial_Invariant_Proc (Subp_Id) then\n                null;\n \n-            --  _Postconditions\n-\n-            elsif Is_Postconditions_Proc (Subp_Id) then\n-               Info_Verification_Call\n-                 (Pred    => \"postconditions\",\n-                  Id      => Find_Enclosing_Scope (Call),\n-                  Id_Kind => \"subprogram\");\n-\n             --  Subprograms must come last because some of the previous cases\n             --  fall under this category.\n \n@@ -13091,10 +13070,6 @@ package body Sem_Elab is\n            (Extra : out Entity_Id;\n             Kind  : out Invocation_Kind)\n          is\n-            Targ_Rep  : constant Target_Rep_Id :=\n-                          Target_Representation_Of (Targ_Id, In_State);\n-            Spec_Decl : constant Node_Id := Spec_Declaration (Targ_Rep);\n-\n          begin\n             --  Accept within a task body\n \n@@ -13180,12 +13155,6 @@ package body Sem_Elab is\n                Extra := First_Formal_Type (Targ_Id);\n                Kind  := Invariant_Verification;\n \n-            --  Postcondition verification\n-\n-            elsif Is_Postconditions_Proc (Targ_Id) then\n-               Extra := Find_Enclosing_Scope (Spec_Decl);\n-               Kind  := Postcondition_Verification;\n-\n             --  Protected entry call\n \n             elsif Is_Protected_Entry (Targ_Id) then\n@@ -14454,8 +14423,7 @@ package body Sem_Elab is\n            Is_Default_Initial_Condition_Proc (Id)\n              or else Is_Initial_Condition_Proc (Id)\n              or else Is_Invariant_Proc (Id)\n-             or else Is_Partial_Invariant_Proc (Id)\n-             or else Is_Postconditions_Proc (Id);\n+             or else Is_Partial_Invariant_Proc (Id);\n       end Is_Assertion_Pragma_Target;\n \n       ----------------------------\n@@ -14497,7 +14465,6 @@ package body Sem_Elab is\n            Is_Accept_Alternative_Proc (Id)\n              or else Is_Finalizer_Proc (Id)\n              or else Is_Partial_Invariant_Proc (Id)\n-             or else Is_Postconditions_Proc (Id)\n              or else Is_TSS (Id, TSS_Deep_Adjust)\n              or else Is_TSS (Id, TSS_Deep_Finalize)\n              or else Is_TSS (Id, TSS_Deep_Initialize);\n@@ -14653,18 +14620,6 @@ package body Sem_Elab is\n              and then Is_Partial_Invariant_Procedure (Id);\n       end Is_Partial_Invariant_Proc;\n \n-      ----------------------------\n-      -- Is_Postconditions_Proc --\n-      ----------------------------\n-\n-      function Is_Postconditions_Proc (Id : Entity_Id) return Boolean is\n-      begin\n-         --  To qualify, the entity must denote a _Postconditions procedure\n-\n-         return\n-           Ekind (Id) = E_Procedure and then Chars (Id) = Name_uPostconditions;\n-      end Is_Postconditions_Proc;\n-\n       ---------------------------\n       -- Is_Preelaborated_Unit --\n       ---------------------------\n@@ -17482,7 +17437,7 @@ package body Sem_Elab is\n \n       if Nkind (N) = N_Procedure_Call_Statement\n         and then Is_Entity_Name (Name (N))\n-        and then Chars (Entity (Name (N))) = Name_uPostconditions\n+        and then Chars (Entity (Name (N))) = Name_uWrapped_Statements\n       then\n          return;\n       end if;"}, {"sha": "509a04e3a036992f465306102324cc5979eb0d84", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -5548,6 +5548,14 @@ package body Sem_Prag is\n                then\n                   OK := True;\n \n+               --  Special case for postconditions wrappers\n+\n+               elsif Ekind (Scop) in Subprogram_Kind\n+                 and then Present (Wrapped_Statements (Scop))\n+                 and then Wrapped_Statements (Scop) = Current_Scope\n+               then\n+                  OK := True;\n+\n                --  Default case, just check that the pragma occurs in the scope\n                --  of the entity denoted by the name.\n \n@@ -32236,10 +32244,10 @@ package body Sem_Prag is\n       then\n          return;\n \n-      --  Do not process internally generated routine _Postconditions\n+      --  Do not process internally generated routine _Wrapped_Statements\n \n       elsif Ekind (Body_Id) = E_Procedure\n-        and then Chars (Body_Id) = Name_uPostconditions\n+        and then Chars (Body_Id) = Name_uWrapped_Statements\n       then\n          return;\n       end if;"}, {"sha": "619f8411f5c5e549f82370fab760b508a084c916", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -156,6 +156,9 @@ package Sem_Prag is\n       Pragma_Type_Invariant_Class      => True,\n       others                           => False);\n \n+   --  Should to following constant arrays be renamed to better suit their\n+   --  use as a predicate (e.g. Is_Pragma_*) ???\n+\n    --  The following table lists all the implementation-defined pragmas that\n    --  should apply to the anonymous object produced by the analysis of a\n    --  single protected or task type. The table should be synchronized with\n@@ -200,6 +203,32 @@ package Sem_Prag is\n       Pragma_Warnings                      => False,\n       others                               => True);\n \n+   --  The following table lists all pragmas which are relevant to the analysis\n+   --  of subprogram bodies.\n+\n+   Pragma_Significant_To_Subprograms : constant array (Pragma_Id) of Boolean :=\n+     (Pragma_Contract_Cases    => True,\n+      Pragma_Depends           => True,\n+      Pragma_Ghost             => True,\n+      Pragma_Global            => True,\n+      Pragma_Inline            => True,\n+      Pragma_Inline_Always     => True,\n+      Pragma_Post              => True,\n+      Pragma_Post_Class        => True,\n+      Pragma_Postcondition     => True,\n+      Pragma_Pre               => True,\n+      Pragma_Pre_Class         => True,\n+      Pragma_Precondition      => True,\n+      Pragma_Pure              => True,\n+      Pragma_Pure_Function     => True,\n+      Pragma_Refined_Depends   => True,\n+      Pragma_Refined_Global    => True,\n+      Pragma_Refined_Post      => True,\n+      Pragma_Refined_State     => True,\n+      Pragma_Volatile          => True,\n+      Pragma_Volatile_Function => True,\n+      others                   => False);\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "76750708bcad93f22cbf1bb56b3eecebf4559f60", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -8412,6 +8412,7 @@ package body Sem_Res is\n       if Is_Entry (Nam)\n         and then Present (Contract_Wrapper (Nam))\n         and then Current_Scope /= Contract_Wrapper (Nam)\n+        and then Current_Scope /= Wrapped_Statements (Contract_Wrapper (Nam))\n       then\n          --  Note the entity being called before rewriting the call, so that\n          --  it appears used at this point."}, {"sha": "8c64ac31dd303ba5d6431206394ebc31899c02be", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -597,6 +597,7 @@ package body Sem_Util is\n                --  Anonymous access types\n \n                elsif Nkind (Pre) in N_Has_Entity\n+                 and then Ekind (Entity (Pre)) not in Subprogram_Kind\n                  and then Present (Get_Dynamic_Accessibility (Entity (Pre)))\n                  and then Level = Dynamic_Level\n                then\n@@ -14122,9 +14123,10 @@ package body Sem_Util is\n       if Subp_Nam = Name_uFinalizer then\n          return False;\n \n-      --  _Postconditions procedure\n+      --  _Wrapped_Statements procedure which gets generated as part of the\n+      --  expansion of postconditions.\n \n-      elsif Subp_Nam = Name_uPostconditions then\n+      elsif Subp_Nam = Name_uWrapped_Statements then\n          return False;\n \n       --  Predicate function\n@@ -28013,8 +28015,18 @@ package body Sem_Util is\n       E : Entity_Id) return Boolean\n    is\n       Subp_Alias : constant Entity_Id := Alias (S);\n+      Subp       : Entity_Id := E;\n    begin\n-      return S = E or else (Present (Subp_Alias) and then Subp_Alias = E);\n+      --  During expansion of subprograms with postconditions the original\n+      --  subprogram's declarations and statements get wrapped into a local\n+      --  _Wrapped_Statements subprogram.\n+\n+      if Chars (Subp) = Name_uWrapped_Statements then\n+         Subp := Enclosing_Subprogram (Subp);\n+      end if;\n+\n+      return S = Subp\n+        or else (Present (Subp_Alias) and then Subp_Alias = Subp);\n    end Same_Or_Aliased_Subprograms;\n \n    ---------------\n@@ -32462,7 +32474,7 @@ package body Sem_Util is\n                and then Ekind (Scope (T))\n                  in E_Entry | E_Entry_Family | E_Function | E_Procedure\n                and then\n-                 (Present (Postconditions_Proc (Scope (T)))\n+                 (Present (Wrapped_Statements (Scope (T)))\n                   or else Present (Contract (Scope (T))))\n             then\n                --  ??? Should define a flag for this. We could incorrectly"}, {"sha": "53880c5dfce77b1a8f6ac808052bd9625dbf8a7c", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -82,6 +82,12 @@ package Sinfo is\n    --                 for this purpose, so e.g. in X := (if A then B else C);\n    --                 Paren_Count for the right side will be 1.\n \n+   --   Comes_From_Check_Or_Contract\n+   --                 This flag is present in all N_If_Statement nodes and\n+   --                 gets set when an N_If_Statement is generated as part of\n+   --                 the expansion of a Check, Assert, or contract-related\n+   --                 pragma.\n+\n    --   Comes_From_Source\n    --                 This flag is present in all nodes. It is set if the\n    --                 node is built by the scanner or parser, and clear if"}, {"sha": "79557e7065cee0331615412a3b4a27f6f3480094", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a968d80d0e89e847a1928842b7de166a6d42c92e/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a968d80d0e89e847a1928842b7de166a6d42c92e", "patch": "@@ -190,7 +190,6 @@ package Snames is\n    Name_uMaster                        : constant Name_Id := N + $;\n    Name_uObject                        : constant Name_Id := N + $;\n    Name_uPost                          : constant Name_Id := N + $;\n-   Name_uPostconditions                : constant Name_Id := N + $;\n    Name_uPostcond_Enabled              : constant Name_Id := N + $;\n    Name_uPre                           : constant Name_Id := N + $;\n    Name_uPriority                      : constant Name_Id := N + $;\n@@ -208,6 +207,7 @@ package Snames is\n    Name_uTask_Name                     : constant Name_Id := N + $;\n    Name_uType_Invariant                : constant Name_Id := N + $;\n    Name_uVariants                      : constant Name_Id := N + $;\n+   Name_uWrapped_Statements            : constant Name_Id := N + $;\n \n    --  Names of predefined primitives used in the expansion of dispatching\n    --  requeue and select statements, Abort, 'Callable and 'Terminated."}]}