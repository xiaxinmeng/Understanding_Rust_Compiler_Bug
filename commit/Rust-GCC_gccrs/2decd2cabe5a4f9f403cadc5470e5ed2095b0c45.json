{"sha": "2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "node_id": "C_kwDOANBUbNoAKDJkZWNkMmNhYmU1YTRmOWY0MDNjYWRjNTQ3MGU1ZWQyMDk1YjBjNDU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-20T14:28:20Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-20T14:28:20Z"}, "message": "c++: ahead-of-time overload set pruning for non-dep calls\n\nThis patch makes us remember the function selected by overload resolution\nduring ahead of time processing of a non-dependent call expression, so\nthat at instantiation time we avoid repeating some of the work of overload\nresolution for the call.  Note that we already do this for non-dependent\noperator expressions via build_min_non_dep_op_overload.\n\nSome caveats:\n\n * When processing ahead of time a non-dependent call to a member\n   function template of a currently open class template (as in\n   g++.dg/template/deduce4.C), we end up generating an \"inside-out\"\n   partial instantiation such as S<T>::foo<int, int>(), the likes of\n   which we're apparently not prepared to fully instantiate.  So in this\n   situation, we instead prune to the selected template instead of the\n   specialization in this situation.\n\n * This change triggered a latent FUNCTION_DECL pretty printing issue\n   in cpp0x/error2.C -- since we now resolve the call to foo<0> ahead\n   of time, the error now looks like:\n\n     error: expansion pattern \u2018foo()()=0\u2019 contains no parameter pack\n\n   where the FUNCTION_DECL for foo<0> is clearly misprinted.  But this\n   pretty-printing issue could be reproduced without this patch if\n   we define foo as a non-template function.  Since this testcase was\n   added to verify pretty printing of TEMPLATE_ID_EXPR, I work around\n   this test failure by making the call to foo type-dependent and thus\n   immune to this ahead of time pruning.\n\n * We now reject parts of cpp0x/fntmp-equiv1.C because we notice that\n   the non-dependent call d(f, b) in\n\n     int d(int, int);\n     template <unsigned long f, unsigned b, typename> e<d(f, b)> d();\n\n   is non-constexpr.  Since this testcase is about equivalency of\n   dependent names in the context of declaration matching, it seems the\n   best fix here is to make the calls to d, d2 and d3 within the\n   function signatures dependent.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (build_new_method_call): For a non-dependent call\n\texpression inside a template, returning a templated tree\n\twhose overload set contains just the selected function.\n\t* semantics.c (finish_call_expr): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/error2.C: Make the call to foo type-dependent in\n\torder to avoid latent pretty-printing issue for FUNCTION_DECL\n\tinside MODOP_EXPR.\n\t* g++.dg/cpp0x/fntmp-equiv1.C: Make the calls to d, d2 and d3\n\twithin the function signatures dependent.\n\t* g++.dg/template/non-dependent16.C: New test.\n\t* g++.dg/template/non-dependent16a.C: New test.\n\t* g++.dg/template/non-dependent17.C: New test.", "tree": {"sha": "2d59da32583f47810aeb52af89ca3fe75b1d09db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d59da32583f47810aeb52af89ca3fe75b1d09db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/comments", "author": null, "committer": null, "parents": [{"sha": "7424323bd5e1e27d8ffe37257459db5b28af18d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7424323bd5e1e27d8ffe37257459db5b28af18d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7424323bd5e1e27d8ffe37257459db5b28af18d2"}], "stats": {"total": 158, "additions": 147, "deletions": 11}, "files": [{"sha": "1fbfc580a1e7ef5cc8bd0c001c428d130c228043", "filename": "gcc/cp/call.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -11163,6 +11163,33 @@ build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n \t}\n       if (INDIRECT_REF_P (call))\n \tcall = TREE_OPERAND (call, 0);\n+\n+      /* Prune all but the selected function from the original overload\n+\t set so that we can avoid some duplicate work at instantiation time.  */\n+      if (really_overloaded_fn (fns))\n+\t{\n+\t  if (DECL_TEMPLATE_INFO (fn)\n+\t      && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (fn))\n+\t      && dependent_type_p (DECL_CONTEXT (fn)))\n+\t    {\n+\t      /* FIXME: We're not prepared to fully instantiate \"inside-out\"\n+\t\t partial instantiations such as A<T>::f<int>().  So instead\n+\t\t use the selected template, not the specialization.  */\n+\n+\t      if (OVL_SINGLE_P (fns))\n+\t\t/* If the original overload set consists of a single function\n+\t\t   template, this isn't beneficial.  */\n+\t\tgoto skip_prune;\n+\n+\t      fn = ovl_make (DECL_TI_TEMPLATE (fn));\n+\t      if (template_only)\n+\t\tfn = lookup_template_function (fn, explicit_targs);\n+\t    }\n+\t  orig_fns = copy_node (orig_fns);\n+\t  BASELINK_FUNCTIONS (orig_fns) = fn;\n+\t}\n+\n+skip_prune:\n       call = (build_min_non_dep_call_vec\n \t      (call,\n \t       build_min (COMPONENT_REF, TREE_TYPE (CALL_EXPR_FN (call)),"}, {"sha": "6ffd82cb0ecf7e1140447d5c9888fe1b60af1a7f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -2893,6 +2893,21 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n     {\n       if (INDIRECT_REF_P (result))\n \tresult = TREE_OPERAND (result, 0);\n+\n+      /* Prune all but the selected function from the original overload\n+\t set so that we can avoid some duplicate work at instantiation time.  */\n+      if (TREE_CODE (result) == CALL_EXPR\n+\t  && really_overloaded_fn (orig_fn))\n+\t{\n+\t  orig_fn = CALL_EXPR_FN (result);\n+\t  if (TREE_CODE (orig_fn) == COMPONENT_REF)\n+\t    {\n+\t      /* The non-dependent result of build_new_method_call.  */\n+\t      orig_fn = TREE_OPERAND (orig_fn, 1);\n+\t      gcc_assert (BASELINK_P (orig_fn));\n+\t    }\n+\t}\n+\n       result = build_call_vec (TREE_TYPE (result), orig_fn, orig_args);\n       SET_EXPR_LOCATION (result, input_location);\n       KOENIG_LOOKUP_P (result) = koenig_p;"}, {"sha": "eb966362ccbb869ea04ebc985873fc9ca1363f5d", "filename": "gcc/testsuite/g++.dg/cpp0x/error2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ferror2.C?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -3,7 +3,7 @@\n \n template<int> int foo();\n \n-template<typename F> void bar(F f)\n+template<typename F, int N> void bar(F f)\n {\n-  f((foo<0>()=0)...); // { dg-error \"pattern '\\\\(foo\\\\<0\\\\>\\\\)\\\\(\\\\)=0'\" }\n+  f((foo<N>()=0)...); // { dg-error \"pattern '\\\\(foo\\\\<N\\\\>\\\\)\\\\(\\\\)=0'\" }\n }"}, {"sha": "c7d7d60481e61208e4f4f2d02e53cb37f2e5c69b", "filename": "gcc/testsuite/g++.dg/cpp0x/fntmp-equiv1.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffntmp-equiv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffntmp-equiv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffntmp-equiv1.C?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -3,21 +3,21 @@\n \n int d(int, int);\n template <long> class e {};\n-template <unsigned long f, unsigned b, typename> e<sizeof(d(f, b))> d();\n-template <unsigned long f, unsigned b, typename> e<d(f, b)> d();\n+template <class T> e<sizeof(d(T{}, T{}))> d(...);\n+template <class T> e<d(T{}, T{})> d(...);\n \n template <class T, class U> constexpr T d2(T, U) { return 42; }\n-template <unsigned long f, unsigned b, typename> e<d2(f, b)> d2();\n-template <unsigned long f, unsigned b, typename> e<d2(f, b)> d2();\n+template <class T> e<d2(T{}, T{})> d2(...);\n+template <class T> e<d2(T{}, T{})> d2(...);\n \n template <typename a, typename c> a d3(a, c);\n-template <unsigned long f, unsigned b, typename> e<sizeof(d3(f, b))> d3();\n-template <unsigned long f, unsigned b, typename> e<sizeof(d3(f, b))> d3();\n+template <class T> e<sizeof(d3(T{}, T{}))> d3(...);\n+template <class T> e<sizeof(d3(T{}, T{}))> d3(...);\n \n \n int main()\n {\n-  d<1,2,int>();\n-  d2<1,2,int>();\n-  d3<1,2,int>();\n+  d<int>();\n+  d2<int>();\n+  d3<int>();\n }"}, {"sha": "ee8ef902529ea1e4c0088949ef1764b3c62618e1", "filename": "gcc/testsuite/g++.dg/template/non-dependent16.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16.C?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -0,0 +1,37 @@\n+// This test verifies that after resolving a non-dependent call expression\n+// ahead of time, we prune all but the selected candidate from the overload\n+// set.  Without this optimization, overload resolution for the final call to\n+// f<void>() would be exponential in the size of the overload set.\n+\n+// { dg-do compile { target c++11 } }\n+\n+template<class T> void f();\n+template<class T> auto f() -> decltype(f<void>(), 1, *T());\n+template<class T> auto f() -> decltype(f<void>(), 2, *T());\n+template<class T> auto f() -> decltype(f<void>(), 3, *T());\n+template<class T> auto f() -> decltype(f<void>(), 4, *T());\n+template<class T> auto f() -> decltype(f<void>(), 5, *T());\n+template<class T> auto f() -> decltype(f<void>(), 6, *T());\n+template<class T> auto f() -> decltype(f<void>(), 7, *T());\n+template<class T> auto f() -> decltype(f<void>(), 8, *T());\n+template<class T> auto f() -> decltype(f<void>(), 9, *T());\n+template<class T> auto f() -> decltype(f<void>(), 10, *T());\n+template<class T> auto f() -> decltype(f<void>(), 11, *T());\n+template<class T> auto f() -> decltype(f<void>(), 12, *T());\n+template<class T> auto f() -> decltype(f<void>(), 13, *T());\n+template<class T> auto f() -> decltype(f<void>(), 14, *T());\n+template<class T> auto f() -> decltype(f<void>(), 15, *T());\n+template<class T> auto f() -> decltype(f<void>(), 16, *T());\n+template<class T> auto f() -> decltype(f<void>(), 17, *T());\n+template<class T> auto f() -> decltype(f<void>(), 18, *T());\n+template<class T> auto f() -> decltype(f<void>(), 19, *T());\n+template<class T> auto f() -> decltype(f<void>(), 20, *T());\n+template<class T> auto f() -> decltype(f<void>(), 21, *T());\n+template<class T> auto f() -> decltype(f<void>(), 22, *T());\n+template<class T> auto f() -> decltype(f<void>(), 23, *T());\n+template<class T> auto f() -> decltype(f<void>(), 24, *T());\n+template<class T> auto f() -> decltype(f<void>(), 25, *T());\n+\n+int main() {\n+  f<void>();\n+}"}, {"sha": "0e04d646c0beb28ab0e0bd245b9eae5cae4cc0d7", "filename": "gcc/testsuite/g++.dg/template/non-dependent16a.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent16a.C?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -0,0 +1,36 @@\n+// Like non-dependent16.C, but using member functions.\n+\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  template<class T> static void f();\n+  template<class T> static auto f() -> decltype(f<void>(), 1, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 2, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 3, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 4, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 5, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 6, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 7, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 8, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 9, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 10, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 11, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 12, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 13, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 14, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 15, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 16, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 17, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 18, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 19, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 20, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 21, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 22, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 23, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 24, *T());\n+  template<class T> static auto f() -> decltype(f<void>(), 25, *T());\n+};\n+\n+int main() {\n+  A::f<void>();\n+}"}, {"sha": "6b62dd2a60dd0f2c98ac1fd755a5fd870d46895d", "filename": "gcc/testsuite/g++.dg/template/non-dependent17.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2decd2cabe5a4f9f403cadc5470e5ed2095b0c45/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent17.C?ref=2decd2cabe5a4f9f403cadc5470e5ed2095b0c45", "patch": "@@ -0,0 +1,21 @@\n+// A variant of deduce4.C with multiple overloads of foo.  Verify we don't\n+// crash after ahead-of-time pruning of the overload set for the non-dependent\n+// call to foo.\n+// { dg-do compile }\n+\n+template <typename T>\n+struct S {\n+  template <typename U, typename V>\n+  static void foo(V) { }\n+  template <typename U>\n+  static void foo(...) { }\n+\n+  void bar () { foo<int>(10); }\n+};\n+\n+void\n+test ()\n+{\n+  S<int> s;\n+  s.bar ();\n+}"}]}