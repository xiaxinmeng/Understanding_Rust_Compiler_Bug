{"sha": "a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA4MTYwYzMxY2Y4MWRlZjNhNGZmZDhiZWM5MzVmM2NhOTFhZDg0YQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-10-29T09:08:13Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-10-29T09:08:13Z"}, "message": "cris.c (reg_ok_for_base_p, [...]): New functions.\n\n\t* config/cris/cris.c (reg_ok_for_base_p, reg_ok_for_index_p,\n\tcris_constant_index_p, cris_base_p, cris_index_p,\n\tcris_base_or_autoincr_p, cris_bdap_index_p, cris_biap_index_p,\n\tcris_legitimate_address_p): New functions.\n\t(TARGET_LEGITIMATE_ADDRESS_P): Define.\n\t(cris_pic_symbol_type, cris_valid_pic_const): Change arguments type\n\tfrom rtx to const_rtx.\n\t(cris_print_operand_address, cris_address_cost,\n\tcris_side_effect_mode_ok):  Use\n\tcris_constant_index_p, cris_base_p, cris_base_or_autoincr_p,\n\tcris_biap_index_p and cris_bdap_index_p.\n\t* config/cris/cris.h (CONSTANT_INDEX_P, BASE_P, BASE_OR_AUTOINCR_P,\n\tBDAP_INDEX_P, BIAP_INDEX_P, GO_IF_LEGITIMATE_ADDRESS,\n\tREG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P): Remove.\n\t(EXTRA_CONSTRAINT_Q, EXTRA_CONSTRAINT_R, EXTRA_CONSTRAINT_T): Use\n\tcris_constant_index_p, cris_base_p, cris_base_or_autoincr_p,\n\tcris_biap_index_p and cris_bdap_index_p.\n\t* config/cris/cris.md (moversideqi movemsideqi peephole2): Use\n\tcris_base_p.\n\t* config/cris/cris-protos.h (cris_constant_index_p, cris_base_p,\n\tcris_base_or_autoincr_p, cris_bdap_index_p, cris_biap_index_p): New\n\tprototype.\n\t(cris_pic_symbol_type, cris_valid_pic_const): Update prototype.\n\nFrom-SVN: r180651", "tree": {"sha": "84a1d7603e4cb9f8c57e6c7606db56d7c07ed46b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84a1d7603e4cb9f8c57e6c7606db56d7c07ed46b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/comments", "author": null, "committer": null, "parents": [{"sha": "3bc50163311275e8da17365a68e10a765a134867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc50163311275e8da17365a68e10a765a134867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bc50163311275e8da17365a68e10a765a134867"}], "stats": {"total": 361, "additions": 215, "deletions": 146}, "files": [{"sha": "cb079857976cde451ebac84e323818581cf23317", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "patch": "@@ -1,3 +1,29 @@\n+2011-10-29  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/cris/cris.c (reg_ok_for_base_p, reg_ok_for_index_p,\n+\tcris_constant_index_p, cris_base_p, cris_index_p,\n+\tcris_base_or_autoincr_p, cris_bdap_index_p, cris_biap_index_p,\n+\tcris_legitimate_address_p): New functions.\n+\t(TARGET_LEGITIMATE_ADDRESS_P): Define.\n+\t(cris_pic_symbol_type, cris_valid_pic_const): Change arguments type\n+\tfrom rtx to const_rtx.\n+\t(cris_print_operand_address, cris_address_cost,\n+\tcris_side_effect_mode_ok):  Use\n+\tcris_constant_index_p, cris_base_p, cris_base_or_autoincr_p,\n+\tcris_biap_index_p and cris_bdap_index_p.\n+\t* config/cris/cris.h (CONSTANT_INDEX_P, BASE_P, BASE_OR_AUTOINCR_P,\n+\tBDAP_INDEX_P, BIAP_INDEX_P, GO_IF_LEGITIMATE_ADDRESS,\n+\tREG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P): Remove.\n+\t(EXTRA_CONSTRAINT_Q, EXTRA_CONSTRAINT_R, EXTRA_CONSTRAINT_T): Use\n+\tcris_constant_index_p, cris_base_p, cris_base_or_autoincr_p,\n+\tcris_biap_index_p and cris_bdap_index_p.\n+\t* config/cris/cris.md (moversideqi movemsideqi peephole2): Use\n+\tcris_base_p.\n+\t* config/cris/cris-protos.h (cris_constant_index_p, cris_base_p,\n+\tcris_base_or_autoincr_p, cris_bdap_index_p, cris_biap_index_p): New\n+\tprototype.\n+\t(cris_pic_symbol_type, cris_valid_pic_const): Update prototype.\n+\n 2011-10-21  Andi Kleen  <ak@linux.intel.com>\n \n \t* ggc-page (PAGE_ALIGN): Add."}, {"sha": "291981d5707b3763dd94e39ce5ff007731979367", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "patch": "@@ -33,8 +33,13 @@ extern bool cris_cc0_user_requires_cmp (rtx);\n extern rtx cris_return_addr_rtx (int, rtx);\n extern rtx cris_split_movdx (rtx *);\n extern int cris_legitimate_pic_operand (rtx);\n-extern enum cris_pic_symbol_type cris_pic_symbol_type_of (rtx);\n-extern bool cris_valid_pic_const (rtx, bool);\n+extern enum cris_pic_symbol_type cris_pic_symbol_type_of (const_rtx);\n+extern bool cris_valid_pic_const (const_rtx, bool);\n+extern bool cris_constant_index_p (const_rtx);\n+extern bool cris_base_p (const_rtx, bool);\n+extern bool cris_base_or_autoincr_p (const_rtx, bool);\n+extern bool cris_bdap_index_p (const_rtx, bool);\n+extern bool cris_biap_index_p (const_rtx, bool);\n extern bool cris_store_multiple_op_p (rtx);\n extern bool cris_movem_load_rest_p (rtx, int);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);"}, {"sha": "4a08ae03aee9f3890310aeab2faaa8b8bd55a8ca", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 158, "deletions": 17, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "patch": "@@ -125,6 +125,8 @@ static void cris_init_libfuncs (void);\n \n static reg_class_t cris_preferred_reload_class (rtx, reg_class_t);\n \n+static bool cris_legitimate_address_p (enum machine_mode, rtx, bool);\n+\n static int cris_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n static int cris_memory_move_cost (enum machine_mode, reg_class_t, bool);\n static bool cris_rtx_costs (rtx, int, int, int, int *, bool);\n@@ -200,6 +202,9 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS cris_init_libfuncs\n \n+#undef TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P cris_legitimate_address_p\n+\n #undef TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS cris_preferred_reload_class\n \n@@ -1122,20 +1127,20 @@ cris_print_operand_address (FILE *file, rtx x)\n \n   if (CONSTANT_ADDRESS_P (x))\n     cris_output_addr_const (file, x);\n-  else if (BASE_OR_AUTOINCR_P (x))\n+  else if (cris_base_or_autoincr_p (x, true))\n     cris_print_base (x, file);\n   else if (GET_CODE (x) == PLUS)\n     {\n       rtx x1, x2;\n \n       x1 = XEXP (x, 0);\n       x2 = XEXP (x, 1);\n-      if (BASE_P (x1))\n+      if (cris_base_p (x1, true))\n \t{\n \t  cris_print_base (x1, file);\n \t  cris_print_index (x2, file);\n \t}\n-      else if (BASE_P (x2))\n+      else if (cris_base_p (x2, true))\n \t{\n \t  cris_print_base (x2, file);\n \t  cris_print_index (x1, file);\n@@ -1272,6 +1277,136 @@ cris_initial_elimination_offset (int fromreg, int toreg)\n   gcc_unreachable ();\n }\n \n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+static inline bool\n+reg_ok_for_base_p (const_rtx x, bool strict)\n+{\n+  return ((! strict && ! HARD_REGISTER_P (x))\n+          || REGNO_OK_FOR_BASE_P (REGNO (x)));\n+}\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+static inline bool\n+reg_ok_for_index_p (const_rtx x, bool strict)\n+{\n+  return reg_ok_for_base_p (x, strict);\n+}\n+\n+/* No symbol can be used as an index (or more correct, as a base) together\n+   with a register with PIC; the PIC register must be there.  */\n+\n+bool\n+cris_constant_index_p (const_rtx x)\n+{\n+  return (CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));\n+}\n+\n+/* True if X is a valid base register.  */\n+\n+bool\n+cris_base_p (const_rtx x, bool strict)\n+{\n+  return (REG_P (x) && reg_ok_for_base_p (x, strict));\n+}\n+\n+/* True if X is a valid index register.  */\n+\n+static inline bool\n+cris_index_p (const_rtx x, bool strict)\n+{\n+  return (REG_P (x) && reg_ok_for_index_p (x, strict));\n+}\n+\n+/* True if X is a valid base register with or without autoincrement.  */\n+\n+bool\n+cris_base_or_autoincr_p (const_rtx x, bool strict)\n+{\n+  return (cris_base_p (x, strict)\n+\t  || (GET_CODE (x) == POST_INC\n+\t      && cris_base_p (XEXP (x, 0), strict)\n+\t      && REGNO (XEXP (x, 0)) != CRIS_ACR_REGNUM));\n+}\n+\n+/* True if X is a valid (register) index for BDAP, i.e. [Rs].S or [Rs+].S.  */\n+\n+bool\n+cris_bdap_index_p (const_rtx x, bool strict)\n+{\n+  return ((MEM_P (x)\n+\t   && GET_MODE (x) == SImode\n+\t   && cris_base_or_autoincr_p (XEXP (x, 0), strict))\n+\t  || (GET_CODE (x) == SIGN_EXTEND\n+\t      && MEM_P (XEXP (x, 0))\n+\t      && (GET_MODE (XEXP (x, 0)) == HImode\n+\t\t  || GET_MODE (XEXP (x, 0)) == QImode)\n+\t      && cris_base_or_autoincr_p (XEXP (XEXP (x, 0), 0), strict)));\n+}\n+\n+/* True if X is a valid (register) index for BIAP, i.e. Rd.m.  */\n+\n+bool\n+cris_biap_index_p (const_rtx x, bool strict)\n+{\n+  return (cris_index_p (x, strict)\n+\t  || (GET_CODE (x) == MULT\n+\t      && cris_index_p (XEXP (x, 0), strict)\n+\t      && cris_scale_int_operand (XEXP (x, 1), VOIDmode)));\n+}\n+\n+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.\n+\n+   A PIC operand looks like a normal symbol here.  At output we dress it\n+   in \"[rPIC+symbol:GOT]\" (global symbol) or \"rPIC+symbol:GOTOFF\" (local\n+   symbol) so we exclude all addressing modes where we can't replace a\n+   plain \"symbol\" with that.  A global PIC symbol does not fit anywhere\n+   here (but is thankfully a general_operand in itself).  A local PIC\n+   symbol is valid for the plain \"symbol + offset\" case.  */\n+\n+static bool\n+cris_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+{\n+  const_rtx x1, x2;\n+\n+  if (cris_base_or_autoincr_p (x, strict))\n+    return true;\n+  else if (TARGET_V32)\n+    /* Nothing else is valid then.  */\n+    return false;\n+  else if (cris_constant_index_p (x))\n+    return true;\n+  /* Indexed?  */\n+  else if (GET_CODE (x) == PLUS)\n+    {\n+      x1 = XEXP (x, 0);\n+      x2 = XEXP (x, 1);\n+      /* BDAP o, Rd.  */\n+      if ((cris_base_p (x1, strict) && cris_constant_index_p (x2))\n+\t  || (cris_base_p (x2, strict) && cris_constant_index_p (x1))\n+\t   /* BDAP Rs[+], Rd.  */\n+\t  || (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t      && ((cris_base_p (x1, strict)\n+\t\t   && cris_bdap_index_p (x2, strict))\n+\t\t  || (cris_base_p (x2, strict)\n+\t\t      && cris_bdap_index_p (x1, strict))\n+\t\t  /* BIAP.m Rs, Rd */\n+\t\t  || (cris_base_p (x1, strict)\n+\t\t      && cris_biap_index_p (x2, strict))\n+\t\t  || (cris_base_p (x2, strict)\n+\t\t      && cris_biap_index_p (x1, strict)))))\n+\treturn true;\n+     }\n+  else if (MEM_P (x))\n+    {\n+      /* DIP (Rs).  Reject [[reg+]] and [[reg]] for DImode (long long).  */\n+      if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t  && cris_base_or_autoincr_p (XEXP (x, 0), strict))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Worker function for LEGITIMIZE_RELOAD_ADDRESS.  */\n \n bool\n@@ -1860,7 +1995,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int opno, int *total,\n \n \t FIXME: this case is a stop-gap for 4.3 and 4.4, this whole\n \t function should be rewritten.  */\n-      if (outer_code == PLUS && BIAP_INDEX_P (x))\n+      if (outer_code == PLUS && cris_biap_index_p (x, false))\n \t{\n \t  *total = 0;\n \t  return true;\n@@ -1942,7 +2077,7 @@ cris_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n      loop there, without apparent reason.  */\n \n   /* The cheapest addressing modes get 0, since nothing extra is needed.  */\n-  if (BASE_OR_AUTOINCR_P (x))\n+  if (cris_base_or_autoincr_p (x, false))\n     return 0;\n \n   /* An indirect mem must be a DIP.  This means two bytes extra for code,\n@@ -1972,7 +2107,7 @@ cris_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n       /* A BIAP is 2 extra bytes for the prefix insn, nothing more.  We\n \t recognize the typical MULT which is always in tem1 because of\n \t insn canonicalization.  */\n-      if ((GET_CODE (tem1) == MULT && BIAP_INDEX_P (tem1))\n+      if ((GET_CODE (tem1) == MULT && cris_biap_index_p (tem1, false))\n \t  || REG_P (tem2))\n \treturn 2 / 2;\n \n@@ -2030,12 +2165,12 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n   /* The operands may be swapped.  Canonicalize them in reg_rtx and\n      val_rtx, where reg_rtx always is a reg (for this constraint to\n      match).  */\n-  if (! BASE_P (reg_rtx))\n+  if (! cris_base_p (reg_rtx, reload_in_progress || reload_completed))\n     reg_rtx = val_rtx, val_rtx = ops[rreg];\n \n   /* Don't forget to check that reg_rtx really is a reg.  If it isn't,\n      we have no business.  */\n-  if (! BASE_P (reg_rtx))\n+  if (! cris_base_p (reg_rtx, reload_in_progress || reload_completed))\n     return 0;\n \n   /* Don't do this when -mno-split.  */\n@@ -2060,8 +2195,9 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n       /* Check if the lvalue register is the same as the \"other\n \t operand\".  If so, the result is undefined and we shouldn't do\n \t this.  FIXME:  Check again.  */\n-      if ((BASE_P (ops[lreg])\n-\t   && BASE_P (ops[other_op])\n+      if ((cris_base_p (ops[lreg], reload_in_progress || reload_completed)\n+\t   && cris_base_p (ops[other_op],\n+\t\t\t   reload_in_progress || reload_completed)\n \t   && REGNO (ops[lreg]) == REGNO (ops[other_op]))\n \t  || rtx_equal_p (ops[other_op], ops[lreg]))\n       return 0;\n@@ -2074,7 +2210,7 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n     return 0;\n \n   if (code == PLUS\n-      && ! BASE_P (val_rtx))\n+      && ! cris_base_p (val_rtx, reload_in_progress || reload_completed))\n     {\n \n       /* Do not allow rx = rx + n if a normal add or sub with same size\n@@ -2088,19 +2224,24 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n       if (CONSTANT_P (val_rtx))\n \treturn 1;\n \n-      if (MEM_P (val_rtx) && BASE_OR_AUTOINCR_P (XEXP (val_rtx, 0)))\n+      if (MEM_P (val_rtx)\n+\t  && cris_base_or_autoincr_p (XEXP (val_rtx, 0),\n+\t\t\t\t      reload_in_progress || reload_completed))\n \treturn 1;\n \n       if (GET_CODE (val_rtx) == SIGN_EXTEND\n \t  && MEM_P (XEXP (val_rtx, 0))\n-\t  && BASE_OR_AUTOINCR_P (XEXP (XEXP (val_rtx, 0), 0)))\n+\t  && cris_base_or_autoincr_p (XEXP (XEXP (val_rtx, 0), 0),\n+\t\t\t\t      reload_in_progress || reload_completed))\n \treturn 1;\n \n       /* If we got here, it's not a valid addressing mode.  */\n       return 0;\n     }\n   else if (code == MULT\n-\t   || (code == PLUS && BASE_P (val_rtx)))\n+\t   || (code == PLUS\n+\t       && cris_base_p (val_rtx,\n+\t\t\t       reload_in_progress || reload_completed)))\n     {\n       /* Do not allow rx = rx + ry.S, since it doesn't give better code.  */\n       if (rtx_equal_p (ops[lreg], reg_rtx)\n@@ -2112,7 +2253,7 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n \treturn 0;\n \n       /* Only allow  r + ...  */\n-      if (! BASE_P (reg_rtx))\n+      if (! cris_base_p (reg_rtx, reload_in_progress || reload_completed))\n \treturn 0;\n \n       /* If we got here, all seems ok.\n@@ -2202,7 +2343,7 @@ cris_target_asm_named_section (const char *name, unsigned int flags,\n    elsewhere.  */\n \n bool\n-cris_valid_pic_const (rtx x, bool any_operand)\n+cris_valid_pic_const (const_rtx x, bool any_operand)\n {\n   gcc_assert (flag_pic);\n \n@@ -2252,7 +2393,7 @@ cris_valid_pic_const (rtx x, bool any_operand)\n    given the original (non-PIC) representation.  */\n \n enum cris_pic_symbol_type\n-cris_pic_symbol_type_of (rtx x)\n+cris_pic_symbol_type_of (const_rtx x)\n {\n   switch (GET_CODE (x))\n     {"}, {"sha": "62461d65cc5fb2e77ff6b14f05269c960e2a18c3", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 22, "deletions": 125, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "patch": "@@ -676,17 +676,18 @@ enum reg_class\n   /* Just an indirect register (happens to also be\t\\\n      \"all\" slottable memory addressing modes not\t\\\n      covered by other constraints, i.e. '>').  */\t\\\n-  MEM_P (X) && BASE_P (XEXP (X, 0))\t\t\t\\\n+  MEM_P (X)\t\t\t\t\t\t\\\n+  && cris_base_p (XEXP (X, 0), reload_in_progress || reload_completed) \\\n  )\n \n #define EXTRA_CONSTRAINT_R(X)\t\t\t\t\t\\\n  (\t\t\t\t\t\t\t\t\\\n   /* An operand to BDAP or BIAP:\t\t\t\t\\\n      A BIAP; r.S? */\t\t\t\t\t\t\\\n-  BIAP_INDEX_P (X)\t\t\t\t\t\t\\\n+  cris_biap_index_p (X, reload_in_progress || reload_completed)  \\\n   /* A [reg] or (int) [reg], maybe with post-increment.  */\t\\\n-  || BDAP_INDEX_P (X)\t\t\t\t\t\t\\\n-  || CONSTANT_INDEX_P (X)\t\t\t\t\t\\\n+  || cris_bdap_index_p (X, reload_in_progress || reload_completed) \\\n+  || cris_constant_index_p (X)\t\t\t\t\t\\\n  )\n \n #define EXTRA_CONSTRAINT_T(X)\t\t\t\t\t\t\\\n@@ -695,25 +696,33 @@ enum reg_class\n   MEM_P (X)\t\t\t\t\t\t\t\t\\\n   && ((MEM_P (XEXP (X, 0))\t\t\t\t\t\t\\\n        /* Double indirect: [[reg]] or [[reg+]]?  */\t\t\t\\\n-       && (BASE_OR_AUTOINCR_P (XEXP (XEXP (X, 0), 0))))\t\t\t\\\n+       && (cris_base_or_autoincr_p (XEXP (XEXP (X, 0), 0),\t\t\\\n+\t\t\t      reload_in_progress || reload_completed)))\t\\\n       /* Just an explicit indirect reference: [const]?  */\t\t\\\n       || CONSTANT_P (XEXP (X, 0))\t\t\t\t\t\\\n       /* Something that is indexed; [...+...]?  */\t\t\t\\\n       || (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n \t  /* A BDAP constant: [reg+(8|16|32)bit offset]?  */\t\t\\\n-\t  && ((BASE_P (XEXP (XEXP (X, 0), 0))\t\t\t\t\\\n-\t       && CONSTANT_INDEX_P (XEXP (XEXP (X, 0), 1)))\t\t\\\n+\t  && ((cris_base_p (XEXP (XEXP (X, 0), 0),\t\t\t\\\n+\t\t\t       reload_in_progress || reload_completed)\t\\\n+\t       && cris_constant_index_p (XEXP (XEXP (X, 0), 1)))\t\\\n \t      /* A BDAP register: [reg+[reg(+)].S]?  */\t\t\t\\\n-\t      || (BASE_P (XEXP (XEXP (X, 0), 0))\t\t\t\\\n-\t\t  && BDAP_INDEX_P(XEXP(XEXP(X, 0), 1)))\t\t\t\\\n+\t      || (cris_base_p (XEXP (XEXP (X, 0), 0),\t\t\t\\\n+\t\t\t       reload_in_progress || reload_completed)\t\\\n+\t\t  && cris_bdap_index_p (XEXP(XEXP(X, 0), 1),\t\t\\\n+\t\t \t       reload_in_progress || reload_completed))\t\\\n \t      /* Same, but with swapped arguments (no canonical\t\t\\\n \t\t ordering between e.g. REG and MEM as of LAST_UPDATED\t\\\n \t\t \"Thu May 12 03:59:11 UTC 2005\").  */\t\t\t\\\n-\t      || (BASE_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n-\t\t  && BDAP_INDEX_P (XEXP (XEXP (X, 0), 0)))\t\t\\\n+\t      || (cris_base_p (XEXP (XEXP (X, 0), 1),\t\t\t\\\n+\t\treload_in_progress | reload_completed)\t\t\t\\\n+\t\t  && cris_bdap_index_p (XEXP (XEXP (X, 0), 0),\t\t\\\n+\t\t\t       reload_in_progress || reload_completed))\t\\\n \t      /* A BIAP: [reg+reg.S] (MULT comes first).  */\t\t\\\n-\t      || (BASE_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n-\t\t  && BIAP_INDEX_P (XEXP (XEXP (X, 0), 0))))))\t\t\\\n+\t      || (cris_base_p (XEXP (XEXP (X, 0), 1),\t\t\t\\\n+\t\t\t\treload_in_progress || reload_completed)\t\\\n+\t\t  && cris_biap_index_p (XEXP (XEXP (X, 0), 0),\t\t\\\n+\t\t\t    reload_in_progress || reload_completed)))))\t\\\n  )\n \n /* PIC-constructs for symbols.  */\n@@ -888,118 +897,6 @@ struct cum_args {int regs;};\n    among all CRIS variants.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n-/* There are helper macros defined here which are used only in\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   Note that you *have to* reject invalid addressing modes for mode\n-   MODE, even if it is legal for normal addressing modes.  You cannot\n-   rely on the constraints to do this work.  They can only be used to\n-   doublecheck your intentions.  One example is that you HAVE TO reject\n-   (mem:DI (plus:SI (reg:SI x) (reg:SI y))) because for some reason\n-   this cannot be reloaded.  (Which of course you can argue that gcc\n-   should have done.)  FIXME:  Strange.  Check.  */\n-\n-/* No symbol can be used as an index (or more correct, as a base) together\n-   with a register with PIC; the PIC register must be there.  */\n-#define CONSTANT_INDEX_P(X) \\\n- (CONSTANT_P (X) && (!flag_pic || cris_valid_pic_const (X, true)))\n-\n-/* True if X is a valid base register.  */\n-#define BASE_P(X) \\\n- (REG_P (X) && REG_OK_FOR_BASE_P (X))\n-\n-/* True if X is a valid base register with or without autoincrement.  */\n-#define BASE_OR_AUTOINCR_P(X)\t\t\t\t\\\n- (BASE_P (X)\t\t\t\t\t\t\\\n-  || (GET_CODE (X) == POST_INC\t\t\t\t\\\n-      && BASE_P (XEXP (X, 0))\t\t\t\t\\\n-      && REGNO (XEXP (X, 0)) != CRIS_ACR_REGNUM))\n-\n-/* True if X is a valid (register) index for BDAP, i.e. [Rs].S or [Rs+].S.  */\n-#define BDAP_INDEX_P(X)\t\t\t\t\t\\\n- ((MEM_P (X) && GET_MODE (X) == SImode\t\t\t\\\n-   && BASE_OR_AUTOINCR_P (XEXP (X, 0)))\t\t\t\\\n-  || (GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n-      && MEM_P (XEXP (X, 0))\t\t\t\t\\\n-      && (GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n-\t  || GET_MODE (XEXP (X, 0)) == QImode)\t\t\\\n-      && BASE_OR_AUTOINCR_P (XEXP (XEXP (X, 0), 0))))\n-\n-/* True if X is a valid (register) index for BIAP, i.e. Rd.m.  */\n-#define BIAP_INDEX_P(X)\t\t\t\t\\\n- ((BASE_P (X) && REG_OK_FOR_INDEX_P (X))\t\\\n-  || (GET_CODE (X) == MULT\t\t\t\\\n-      && BASE_P (XEXP (X, 0))\t\t\t\\\n-      && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\\\n-      && CONST_INT_P (XEXP (X, 1))\t\t\\\n-      && (INTVAL (XEXP (X, 1)) == 2\t\t\\\n-\t  || INTVAL (XEXP (X, 1)) == 4)))\n-\n-/* A PIC operand looks like a normal symbol here.  At output we dress it\n-   in \"[rPIC+symbol:GOT]\" (global symbol) or \"rPIC+symbol:GOTOFF\" (local\n-   symbol) so we exclude all addressing modes where we can't replace a\n-   plain \"symbol\" with that.  A global PIC symbol does not fit anywhere\n-   here (but is thankfully a general_operand in itself).  A local PIC\n-   symbol is valid for the plain \"symbol + offset\" case.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n- {\t\t\t\t\t\t\t\t\\\n-   rtx x1, x2;\t\t\t\t\t\t\t\\\n-   if (BASE_OR_AUTOINCR_P (X))\t\t\t\t\t\\\n-     goto ADDR;\t\t\t\t\t\t\t\\\n-   else if (TARGET_V32)\t\t\t\t\t\t\\\n-     /* Nothing else is valid then.  */\t\t\t\t\\\n-     ;\t\t\t\t\t\t\t\t\\\n-   else if (CONSTANT_INDEX_P (X))\t\t\t\t\\\n-     goto ADDR;\t\t\t\t\t\t\t\\\n-   /* Indexed?  */\t\t\t\t\t\t\\\n-   else if (GET_CODE (X) == PLUS)\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-       x1 = XEXP (X, 0);\t\t\t\t\t\\\n-       x2 = XEXP (X, 1);\t\t\t\t\t\\\n-       /* BDAP o, Rd.  */\t\t\t\t\t\\\n-       if ((BASE_P (x1) && CONSTANT_INDEX_P (x2))\t\t\\\n-\t   || (BASE_P (x2) && CONSTANT_INDEX_P (x1))\t\t\\\n-\t    /* BDAP Rs[+], Rd.  */\t\t\t\t\\\n-\t   || (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\\\n-\t       && ((BASE_P (x1) && BDAP_INDEX_P (x2))\t\t\\\n-\t\t   || (BASE_P (x2) && BDAP_INDEX_P (x1))\t\\\n-\t\t   /* BIAP.m Rs, Rd */\t\t\t\t\\\n-\t\t   || (BASE_P (x1) && BIAP_INDEX_P (x2))\t\\\n-\t\t   || (BASE_P (x2) && BIAP_INDEX_P (x1)))))\t\\\n-\t goto ADDR;\t\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\\\n-   else if (MEM_P (X))\t\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-       /* DIP (Rs).  Reject [[reg+]] and [[reg]] for\t\t\\\n-\t  DImode (long long).  */\t\t\t\t\\\n-       if (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\\\n-\t   && (BASE_P (XEXP (X, 0))\t\t\t\t\\\n-\t       || BASE_OR_AUTOINCR_P (XEXP (X, 0))))\t\t\\\n-\t goto ADDR;\t\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\\\n- }\n-\n-#ifndef REG_OK_STRICT\n- /* Nonzero if X is a hard reg that can be used as a base reg\n-    or if it is a pseudo reg.  */\n-# define REG_OK_FOR_BASE_P(X)\t\t\t\\\n- (REGNO (X) <= CRIS_LAST_GENERAL_REGISTER\t\\\n-  || REGNO (X) == ARG_POINTER_REGNUM\t\t\\\n-  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-#else\n- /* Nonzero if X is a hard reg that can be used as a base reg.  */\n-# define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#endif\n-\n-#ifndef REG_OK_STRICT\n- /* Nonzero if X is a hard reg that can be used as an index\n-    or if it is a pseudo reg.  */\n-# define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n-#else\n- /* Nonzero if X is a hard reg that can be used as an index.  */\n-# define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-#endif\n-\n /* Fix reloads known to cause suboptimal spilling.  */\n #define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, INDL, WIN)\t\\\n   do\t\t\t\t\t\t\t\t\t\\"}, {"sha": "428132c2eb499b0b7b341b237da9604a432fc9f3", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08160c31cf81def3a4ffd8bec935f3ca91ad84a/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=a08160c31cf81def3a4ffd8bec935f3ca91ad84a", "patch": "@@ -4680,7 +4680,7 @@\n \t(match_operator 4 \"cris_mem_op\" [(match_dup 0)]))]\n   \"GET_MODE_SIZE (GET_MODE (operands[4])) <= UNITS_PER_WORD\n    && REGNO (operands[3]) != REGNO (operands[0])\n-   && (BASE_P (operands[1]) || BASE_P (operands[2]))\n+   && (cris_base_p (operands[1], true) || cris_base_p (operands[2], true))\n    && !CRIS_CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n    && !CRIS_CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n    && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\n@@ -4716,7 +4716,7 @@\n \t(match_operand 4 \"register_operand\" \"\"))]\n   \"GET_MODE_SIZE (GET_MODE (operands[4])) <= UNITS_PER_WORD\n    && REGNO (operands[4]) != REGNO (operands[0])\n-   && (BASE_P (operands[1]) || BASE_P (operands[2]))\n+   && (cris_base_p (operands[1], true) || cris_base_p (operands[2], true))\n    && !CRIS_CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n    && !CRIS_CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n    && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)"}]}