{"sha": "89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmMDI3NmE0OWEyYWU2OGYzZGQwODZiMjM3MDM3Y2RjZTZlZDZiNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-03-02T11:24:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:24:33Z"}, "message": "back_end.adb (Call_Back_End): Remove previous patch...\n\n2015-03-02  Robert Dewar  <dewar@adacore.com>\n\n\t* back_end.adb (Call_Back_End): Remove previous patch,\n\tthe back end now gets to see the result of -gnatd.1\n\t(Unnest_Subprogram_Mode) processing.\n\t* elists.ads, elists.adb (List_Length): New function.\n\t* exp_unst.ads, exp_unst.adb: Major changes, first complete version.\n\t* sem_util.adb (Check_Nested_Access): Handle formals in\n\tUnnest_Subprogram_Mode.\n\t(Adjust_Named_Associations): Minor reformatting.\n\t* sprint.adb (Sprint_Node_Actual): Fix failure to print aliased\n\tfor parameters.\n\nFrom-SVN: r221115", "tree": {"sha": "3229683b6e527c4242f24c3647c94ed861dfce61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3229683b6e527c4242f24c3647c94ed861dfce61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/comments", "author": null, "committer": null, "parents": [{"sha": "3830827c54e72b96400c9f9803b5518e8fb9f23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3830827c54e72b96400c9f9803b5518e8fb9f23d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3830827c54e72b96400c9f9803b5518e8fb9f23d"}], "stats": {"total": 792, "additions": 583, "deletions": 209}, "files": [{"sha": "d5da4d8a67caead90ed9c6ef31c02ed11ed757a0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -1,3 +1,16 @@\n+2015-03-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* back_end.adb (Call_Back_End): Remove previous patch,\n+\tthe back end now gets to see the result of -gnatd.1\n+\t(Unnest_Subprogram_Mode) processing.\n+\t* elists.ads, elists.adb (List_Length): New function.\n+\t* exp_unst.ads, exp_unst.adb: Major changes, first complete version.\n+\t* sem_util.adb (Check_Nested_Access): Handle formals in\n+\tUnnest_Subprogram_Mode.\n+\t(Adjust_Named_Associations): Minor reformatting.\n+\t* sprint.adb (Sprint_Node_Actual): Fix failure to print aliased\n+\tfor parameters.\n+\n 2015-03-02  Robert Dewar  <dewar@adacore.com>\n \n \t* atree.ads, atree.adb (Uint24): New function"}, {"sha": "7768687b26907cde6ae70605dc3cebdb0971e240", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -118,12 +118,6 @@ package body Back_End is\n          return;\n       end if;\n \n-      --  Skip call if unnesting subprograms (temp for now ???)\n-\n-      if Opt.Unnest_Subprogram_Mode then\n-         return;\n-      end if;\n-\n       --  The back end needs to know the maximum line number that can appear\n       --  in a Sloc, in other words the maximum logical line number.\n "}, {"sha": "0367bebd727150267ecb121eac9ed7d33d3dfac8", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -295,17 +295,23 @@ package body Elists is\n    function List_Length (List : Elist_Id) return Nat is\n       Elmt : Elmt_Id;\n       N    : Nat;\n+\n    begin\n-      N := 0;\n-      Elmt := First_Elmt (List);\n-      loop\n-         if No (Elmt) then\n-            return N;\n-         else\n-            N := N + 1;\n-            Next_Elmt (Elmt);\n-         end if;\n-      end loop;\n+      if List = No_Elist then\n+         return 0;\n+\n+      else\n+         N := 0;\n+         Elmt := First_Elmt (List);\n+         loop\n+            if No (Elmt) then\n+               return N;\n+            else\n+               N := N + 1;\n+               Next_Elmt (Elmt);\n+            end if;\n+         end loop;\n+      end if;\n    end List_Length;\n \n    ----------"}, {"sha": "c20bf2213d59b8b37975ed36b0386d2d3c8977c8", "filename": "gcc/ada/elists.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Felists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Felists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.ads?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -108,7 +108,7 @@ package Elists is\n    --  no items, then No_Elmt is returned.\n \n    function List_Length (List : Elist_Id) return Nat;\n-   --  Returns number of elements in given List\n+   --  Returns number of elements in given List (zero if List = No_Elist)\n \n    function Next_Elmt (Elmt : Elmt_Id) return Elmt_Id;\n    pragma Inline (Next_Elmt);"}, {"sha": "29746dcac96fc5f5c027dddf5985c8fdae155e91", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 531, "deletions": 182, "changes": 713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2014-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,11 +27,16 @@ with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n+with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n+with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Mech; use Sem_Mech;\n+with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n@@ -90,11 +95,11 @@ package body Exp_Unst is\n      Table_Low_Bound      => 1,\n      Table_Initial        => 100,\n      Table_Increment      => 200,\n-     Table_Name           => \"Subps\");\n+     Table_Name           => \"Unnest_Subps\");\n    --  Records the subprograms in the nest whose outer subprogram is Subp\n \n    type Call_Entry is record\n-      N   : Node_Id;\n+      N : Node_Id;\n       --  The actual call\n \n       From : Entity_Id;\n@@ -110,7 +115,7 @@ package body Exp_Unst is\n      Table_Low_Bound      => 1,\n      Table_Initial        => 100,\n      Table_Increment      => 200,\n-     Table_Name           => \"Calls\");\n+     Table_Name           => \"Unnest_Calls\");\n    --  Records each call within the outer subprogram and all nested subprograms\n    --  that are to other subprograms nested within the outer subprogram. These\n    --  are the calls that may need an additional parameter.\n@@ -285,17 +290,18 @@ package body Exp_Unst is\n       end if;\n \n       Set_Has_Uplevel_Reference (Entity (N));\n+      Set_Has_Uplevel_Reference (Subp);\n    end Note_Uplevel_Reference;\n \n    -----------------------\n    -- Unnest_Subprogram --\n    -----------------------\n \n    procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id) is\n-      function Get_AREC_String (Lev : Pos) return String;\n+      function AREC_String (Lev : Pos) return String;\n       --  Given a level value, 1, 2, ... returns the string AREC, AREC2, ...\n \n-      function Get_Enclosing_Subp (Subp : SI_Type) return SI_Type;\n+      function Enclosing_Subp (Subp : SI_Type) return SI_Type;\n       --  Subp is the index of a subprogram which has a Lev greater than 1.\n       --  This function returns the index of the enclosing subprogram which\n       --  will have a Lev value one less than this.\n@@ -308,34 +314,33 @@ package body Exp_Unst is\n       function Subp_Index (Sub : Entity_Id) return SI_Type;\n       --  Given the entity for a subprogram, return corresponding Subps index\n \n-      ---------------------\n-      -- Get_AREC_String --\n-      ---------------------\n+      -----------------\n+      -- AREC_String --\n+      -----------------\n \n-      function Get_AREC_String (Lev : Pos) return String is\n+      function AREC_String (Lev : Pos) return String is\n       begin\n          if Lev > 9 then\n             return\n-              Get_AREC_String (Lev / 10) & Character'Val (Lev mod 10 + 48);\n+              AREC_String (Lev / 10) & Character'Val (Lev mod 10 + 48);\n          else\n             return\n               \"AREC\" & Character'Val (Lev + 48);\n          end if;\n-      end Get_AREC_String;\n+      end AREC_String;\n \n-      ------------------------\n-      -- Get_Enclosing_Subp --\n-      ------------------------\n+      --------------------\n+      -- Enclosing_Subp --\n+      --------------------\n \n-      function Get_Enclosing_Subp (Subp : SI_Type) return SI_Type is\n+      function Enclosing_Subp (Subp : SI_Type) return SI_Type is\n          STJ : Subp_Entry renames Subps.Table (Subp);\n-         Ret : constant SI_Type :=\n-                 UI_To_Int (Subps_Index (Enclosing_Subprogram (STJ.Ent)));\n+         Ret : constant SI_Type := Subp_Index (Enclosing_Subprogram (STJ.Ent));\n       begin\n          pragma Assert (STJ.Lev > 1);\n          pragma Assert (Subps.Table (Ret).Lev = STJ.Lev - 1);\n          return Ret;\n-      end Get_Enclosing_Subp;\n+      end Enclosing_Subp;\n \n       ---------------\n       -- Get_Level --\n@@ -370,6 +375,12 @@ package body Exp_Unst is\n    --  Start of processing for Unnest_Subprogram\n \n    begin\n+      --  At least for now, do not unnest anything but main source unit\n+\n+      if not In_Extended_Main_Source_Unit (Subp_Body) then\n+         return;\n+      end if;\n+\n       --  First step, we must mark all nested subprograms that require a static\n       --  link (activation record) because either they contain explicit uplevel\n       --  references (as indicated by Has_Uplevel_Reference being set at this\n@@ -430,10 +441,7 @@ package body Exp_Unst is\n \n             if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call) then\n                Ent := Entity (Name (N));\n-\n-               if not Is_Library_Level_Entity (Ent) then\n-                  Calls.Append ((N, Find_Current_Subprogram, Ent));\n-               end if;\n+               Calls.Append ((N, Find_Current_Subprogram, Ent));\n \n             --  Record a subprogram\n \n@@ -454,7 +462,8 @@ package body Exp_Unst is\n                   if Nkind (N) = N_Subprogram_Body then\n                      STJ.Bod := N;\n                   else\n-                     STJ.Bod := Corresponding_Body (N);\n+                     STJ.Bod := Parent (Parent (Corresponding_Body (N)));\n+                     pragma Assert (Nkind (STJ.Bod) = N_Subprogram_Body);\n                   end if;\n \n                   --  Capture Uplevel_References, and then set (uses the same\n@@ -475,7 +484,26 @@ package body Exp_Unst is\n          procedure Visit is new Traverse_Proc (Visit_Node);\n          --  Used to traverse the body of Subp, populating the tables\n \n+      --  Start of processing for Build_Tables\n+\n       begin\n+         --  A special case, if the outer level subprogram has a separate spec\n+         --  then we won't catch it in the traversal of the body. But we do\n+         --  want to visit the declaration in this case!\n+\n+         declare\n+            Dummy : Traverse_Result;\n+            Decl  : constant Node_Id :=\n+              Parent (Declaration_Node (Corresponding_Spec (Subp_Body)));\n+            pragma Assert (Nkind (Decl) = N_Subprogram_Declaration);\n+         begin\n+            if not Acts_As_Spec (Subp_Body) then\n+               Dummy := Visit_Node (Decl);\n+            end if;\n+         end;\n+\n+         --  Traverse the body to get the rest of the subprograms and calls\n+\n          Visit (Subp_Body);\n       end Build_Tables;\n \n@@ -521,16 +549,15 @@ package body Exp_Unst is\n          declare\n             STJ : Subp_Entry renames Subps.Table (J);\n             Loc : constant Source_Ptr := Sloc (STJ.Bod);\n-            ARS : constant String     := Get_AREC_String (STJ.Lev);\n+            ARS : constant String     := AREC_String (STJ.Lev);\n \n          begin\n             if STJ.Ent = Subp then\n                STJ.ARECnF := Empty;\n             else\n                STJ.ARECnF :=\n                  Make_Defining_Identifier (Loc,\n-                   Chars =>\n-                     Name_Find_Str (Get_AREC_String (STJ.Lev - 1) & \"F\"));\n+                   Chars => Name_Find_Str (AREC_String (STJ.Lev - 1) & \"F\"));\n             end if;\n \n             if Has_Nested_Subprogram (STJ.Ent)\n@@ -558,7 +585,7 @@ package body Exp_Unst is\n \n             if Has_Uplevel_Reference (STJ.Ent) and then STJ.Lev > 1 then\n                declare\n-                  ARS1 : constant String := Get_AREC_String (STJ.Lev - 1);\n+                  ARS1 : constant String := AREC_String (STJ.Lev - 1);\n                begin\n                   STJ.ARECnU :=\n                     Make_Defining_Identifier (Loc,\n@@ -590,7 +617,91 @@ package body Exp_Unst is\n                --  nested subprograms that have uplevel references.\n \n                if STJ.Lev > 1 and then Has_Uplevel_Reference (STJ.Ent) then\n-                  null; -- TBD???\n+\n+                  --  Here we need the extra formal. We do the expansion and\n+                  --  analysis of this manually, since it is fairly simple,\n+                  --  and it is not obvious how we can get what we want if we\n+                  --  try to use the normal Analyze circuit.\n+\n+                  Extra_Formal : declare\n+                     Encl : constant SI_Type := Enclosing_Subp (J);\n+                     STJE : Subp_Entry renames Subps.Table (Encl);\n+                     --  Index and Subp_Entry for enclosing routine\n+\n+                     Form : constant Entity_Id := STJ.ARECnF;\n+                     --  The formal to be added. Note that n here is one less\n+                     --  than the level of the subprogram itself (STJ.Ent).\n+\n+                     Formb : Entity_Id;\n+                     --  If needed, this is the formal added to the body\n+\n+                     procedure Add_Form_To_Spec (F : Entity_Id; S : Node_Id);\n+                     --  S is an N_Function/Procedure_Specification node, and F\n+                     --  is the new entity to add to this subprogramn spec.\n+\n+                     ----------------------\n+                     -- Add_Form_To_Spec --\n+                     ----------------------\n+\n+                     procedure Add_Form_To_Spec (F : Entity_Id; S : Node_Id) is\n+                        Sub : constant Entity_Id := Defining_Unit_Name (S);\n+\n+                     begin\n+                        if No (First_Entity (Sub)) then\n+                           Set_First_Entity (Sub, F);\n+\n+                        else\n+                           declare\n+                              LastF : constant Entity_Id := Last_Formal (Sub);\n+                           begin\n+                              if No (LastF) then\n+                                 Set_Next_Entity (F, First_Entity (Sub));\n+                                 Set_First_Entity (Sub, F);\n+                              else\n+                                 Set_Next_Entity (F, Next_Entity (LastF));\n+                                 Set_Next_Entity (LastF, F);\n+                              end if;\n+                           end;\n+                        end if;\n+\n+                        if No (Parameter_Specifications (S)) then\n+                           Set_Parameter_Specifications (S, Empty_List);\n+                        end if;\n+\n+                        Append_To (Parameter_Specifications (S),\n+                          Make_Parameter_Specification (Sloc (F),\n+                            Defining_Identifier => F,\n+                            Parameter_Type      =>\n+                              New_Occurrence_Of (STJE.ARECnPT, Sloc (F))));\n+                     end Add_Form_To_Spec;\n+\n+                  --  Start of processing for Extra_Formal\n+\n+                  begin\n+                     --  Decorate the new formal entity\n+\n+                     Set_Scope               (Form, STJ.Ent);\n+                     Set_Ekind               (Form, E_In_Parameter);\n+                     Set_Etype               (Form, STJE.ARECnPT);\n+                     Set_Mechanism           (Form, By_Copy);\n+                     Set_Never_Set_In_Source (Form, True);\n+                     Set_Analyzed            (Form, True);\n+                     Set_Comes_From_Source   (Form, False);\n+\n+                     --  Case of only body present\n+\n+                     if Acts_As_Spec (STJ.Bod) then\n+                        Add_Form_To_Spec (Form, Specification (STJ.Bod));\n+\n+                     --  Case of separate spec\n+\n+                     else\n+                        Formb := New_Entity (Nkind (Form), Sloc (Form));\n+                        Copy_Node (Form, Formb);\n+                        Add_Form_To_Spec (Form, Parent (STJ.Ent));\n+                        Add_Form_To_Spec (Formb, Specification (STJ.Bod));\n+                     end if;\n+                  end Extra_Formal;\n                end if;\n \n                --  Processing for subprograms that have at least one nested\n@@ -608,6 +719,12 @@ package body Exp_Unst is\n                      Clist : List_Id;\n                      Comp  : Entity_Id;\n \n+                     Decl_ARECnT  : Node_Id;\n+                     Decl_ARECn   : Node_Id;\n+                     Decl_ARECnPT : Node_Id;\n+                     Decl_ARECnP  : Node_Id;\n+                     --  Declaration nodes for the AREC entities we build\n+\n                      Uplevel_Entities :\n                        array (1 .. List_Length (STJ.Urefs)) of Entity_Id;\n                      Num_Uplevel_Entities : Nat;\n@@ -622,19 +739,22 @@ package body Exp_Unst is\n                      --  Uplevel_Reference_Noted to avoid duplicates.\n \n                      Num_Uplevel_Entities := 0;\n-                     Elmt := First_Elmt (STJ.Urefs);\n-                     while Present (Elmt) loop\n-                        Ent := Entity (Node (Elmt));\n-\n-                        if not Uplevel_Reference_Noted (Ent) then\n-                           Set_Uplevel_Reference_Noted (Ent, True);\n-                           Num_Uplevel_Entities := Num_Uplevel_Entities + 1;\n-                           Uplevel_Entities (Num_Uplevel_Entities) := Ent;\n-                        end if;\n \n-                        Next_Elmt (Elmt);\n-                        Next_Elmt (Elmt);\n-                     end loop;\n+                     if Present (STJ.Urefs) then\n+                        Elmt := First_Elmt (STJ.Urefs);\n+                        while Present (Elmt) loop\n+                           Ent := Entity (Node (Elmt));\n+\n+                           if not Uplevel_Reference_Noted (Ent) then\n+                              Set_Uplevel_Reference_Noted (Ent, True);\n+                              Num_Uplevel_Entities := Num_Uplevel_Entities + 1;\n+                              Uplevel_Entities (Num_Uplevel_Entities) := Ent;\n+                           end if;\n+\n+                           Next_Elmt (Elmt);\n+                           Next_Elmt (Elmt);\n+                        end loop;\n+                     end if;\n \n                      --  Build list of component declarations for ARECnT\n \n@@ -647,7 +767,7 @@ package body Exp_Unst is\n                      if STJ.Lev > 1 then\n                         declare\n                            STJE : Subp_Entry\n-                             renames Subps.Table (Get_Enclosing_Subp (J));\n+                                    renames Subps.Table (Enclosing_Subp (J));\n \n                         begin\n                            Append_To (Clist,\n@@ -670,7 +790,7 @@ package body Exp_Unst is\n                             Chars => Chars (Uplevel_Entities (J)));\n \n                         Set_Activation_Record_Component\n-                            (Uplevel_Entities (J), Comp);\n+                          (Uplevel_Entities (J), Comp);\n \n                         Append_To (Clist,\n                           Make_Component_Declaration (Loc,\n@@ -683,49 +803,72 @@ package body Exp_Unst is\n \n                      --  Now we can insert the AREC declarations into the body\n \n+                     --  type ARECnT is record .. end record;\n+\n+                     Decl_ARECnT :=\n+                       Make_Full_Type_Declaration (Loc,\n+                         Defining_Identifier => STJ.ARECnT,\n+                         Type_Definition     =>\n+                           Make_Record_Definition (Loc,\n+                             Component_List =>\n+                               Make_Component_List (Loc,\n+                                 Component_Items => Clist)));\n+\n+                     --  ARECn : aliased ARECnT;\n+\n+                     Decl_ARECn :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => STJ.ARECn,\n+                           Aliased_Present   => True,\n+                           Object_Definition =>\n+                             New_Occurrence_Of (STJ.ARECnT, Loc));\n+\n+                     --  type ARECnPT is access all ARECnT;\n+\n+                     Decl_ARECnPT :=\n+                       Make_Full_Type_Declaration (Loc,\n+                         Defining_Identifier => STJ.ARECnPT,\n+                         Type_Definition     =>\n+                           Make_Access_To_Object_Definition (Loc,\n+                             All_Present        => True,\n+                             Subtype_Indication =>\n+                               New_Occurrence_Of (STJ.ARECnT, Loc)));\n+\n+                     --  ARECnP : constant ARECnPT := ARECn'Access;\n+\n+                     Decl_ARECnP :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => STJ.ARECnP,\n+                         Constant_Present    => True,\n+                         Object_Definition   =>\n+                           New_Occurrence_Of (STJ.ARECnPT, Loc),\n+                         Expression          =>\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix           =>\n+                               New_Occurrence_Of (STJ.ARECn, Loc),\n+                             Attribute_Name => Name_Access));\n+\n                      Prepend_List_To (Declarations (STJ.Bod),\n-                       New_List (\n-\n-                         --  type ARECnT is record .. end record;\n-\n-                         Make_Full_Type_Declaration (Loc,\n-                           Defining_Identifier => STJ.ARECnT,\n-                           Type_Definition     =>\n-                             Make_Record_Definition (Loc,\n-                               Component_List =>\n-                                 Make_Component_List (Loc,\n-                                   Component_Items => Clist))),\n-\n-                         --  ARECn : aliased ARECnT;\n-\n-                         Make_Object_Declaration (Loc,\n-                           Defining_Identifier => STJ.ARECn,\n-                             Aliased_Present   => True,\n-                             Object_Definition =>\n-                               New_Occurrence_Of (STJ.ARECnT, Loc)),\n-\n-                         --  type ARECnPT is access all ARECnT;\n-\n-                         Make_Full_Type_Declaration (Loc,\n-                           Defining_Identifier => STJ.ARECnPT,\n-                           Type_Definition     =>\n-                             Make_Access_To_Object_Definition (Loc,\n-                               All_Present        => True,\n-                               Subtype_Indication =>\n-                                 New_Occurrence_Of (STJ.ARECnT, Loc))),\n-\n-                        --  ARECnP : constant ARECnPT := ARECn'Access;\n-\n-                        Make_Object_Declaration (Loc,\n-                          Defining_Identifier => STJ.ARECnP,\n-                          Constant_Present    => True,\n-                          Object_Definition   =>\n-                            New_Occurrence_Of (STJ.ARECnPT, Loc),\n-                          Expression          =>\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix           =>\n-                                New_Occurrence_Of (STJ.ARECn, Loc),\n-                              Attribute_Name => Name_Access))));\n+                       New_List\n+                         (Decl_ARECnT, Decl_ARECn, Decl_ARECnPT, Decl_ARECnP));\n+\n+                     --  Analyze the newly inserted declarations. Note that\n+                     --  we do not need to establish the relevant scope stack\n+                     --  entries here, because we have already set the correct\n+                     --  entity references, so no name resolution is required.\n+\n+                     --  We analyze with all checks suppressed (since we do\n+                     --  not expect any exceptions, and also we temporarily\n+                     --  turn off Unested_Subprogram_Mode to avoid trying to\n+                     --  mark uplevel references (not needed at this stage,\n+                     --  and in fact causes a bit of recursive chaos).\n+\n+                     Opt.Unnest_Subprogram_Mode := False;\n+                     Analyze (Decl_ARECnT,  Suppress => All_Checks);\n+                     Analyze (Decl_ARECn,   Suppress => All_Checks);\n+                     Analyze (Decl_ARECnPT, Suppress => All_Checks);\n+                     Analyze (Decl_ARECnP,  Suppress => All_Checks);\n+                     Opt.Unnest_Subprogram_Mode := True;\n \n                      --  Next step, for each uplevel referenced entity, add\n                      --  assignment operations to set the comoponent in the\n@@ -736,11 +879,28 @@ package body Exp_Unst is\n                            Ent : constant Entity_Id  := Uplevel_Entities (J);\n                            Loc : constant Source_Ptr := Sloc (Ent);\n                            Dec : constant Node_Id    := Declaration_Node (Ent);\n+                           Ins : Node_Id;\n+                           Asn : Node_Id;\n \n                         begin\n                            Set_Aliased_Present (Dec);\n+                           Set_Is_Aliased (Ent);\n \n-                           Insert_After (Dec,\n+                           --  For parameters, we insert the assignment right\n+                           --  after the declaration of ARECnP. For all other\n+                           --  entities, we insert the assignment immediately\n+                           --  after the declaration of the entity.\n+\n+                           if Is_Formal (Ent) then\n+                              Ins := Decl_ARECnP;\n+                           else\n+                              Ins := Dec;\n+                           end if;\n+\n+                           --  Build and insert the assignment:\n+                           --    ARECn.nam := nam\n+\n+                           Asn :=\n                              Make_Assignment_Statement (Loc,\n                                Name       =>\n                                  Make_Selected_Component (Loc,\n@@ -753,143 +913,332 @@ package body Exp_Unst is\n                                  Make_Attribute_Reference (Loc,\n                                    Prefix         =>\n                                      New_Occurrence_Of (Ent, Loc),\n-                                   Attribute_Name => Name_Address)));\n+                                   Attribute_Name => Name_Address));\n+\n+                           Insert_After (Ins, Asn);\n+\n+                           --  Analyze the assignment statement. Again, we do\n+                           --  not need to establish the relevant scope stack\n+                           --  entries here, because we have already set the\n+                           --  correct entity references, so no name resolution\n+                           --  is required.\n+\n+                           --  We analyze with all checks suppressed (since\n+                           --  we do not expect any exceptions, and also we\n+                           --  temporarily turn off Unested_Subprogram_Mode\n+                           --  to avoid trying to mark uplevel references (not\n+                           --  needed at this stage, and in fact causes a bit\n+                           --  of recursive chaos).\n+\n+                           Opt.Unnest_Subprogram_Mode := False;\n+                           Analyze (Asn, Suppress => All_Checks);\n+                           Opt.Unnest_Subprogram_Mode := True;\n                         end;\n                      end loop;\n+                  end;\n+               end if;\n+            end;\n+         end loop;\n+      end Subp_Loop;\n \n-                     --  Next step, process uplevel references\n+      --  Next step, process uplevel references. This has to be done in a\n+      --  separate pass, after completing the processing in Sub_Loop because we\n+      --  need all the AREC declarations generated, inserted, and analyzed so\n+      --  that the uplevel references can be successfully analyzed.\n \n-                     Uplev_Refs : declare\n-                        Elmt : Elmt_Id;\n+      Uplev_Refs : for J in Subps.First .. Subps.Last loop\n+         declare\n+            STJ : Subp_Entry renames Subps.Table (J);\n \n-                     begin\n-                        --  Loop through uplevel references\n+         begin\n+            --  We are only interested in entries which have uplevel references\n+            --  to deal with, as indicated by the Urefs list being present\n \n-                        Elmt := First_Elmt (STJ.Urefs);\n-                        while Present (Elmt) loop\n-                           declare\n-                              Ref : constant Node_Id := Node (Elmt);\n-                              --  The uplevel reference itself\n+            if Present (STJ.Urefs) then\n+\n+               --  Process uplevel references for one subprogram\n \n-                              Loc : constant Source_Ptr := Sloc (Ref);\n-                              --  Source location for the reference\n+               declare\n+                  Elmt : Elmt_Id;\n \n-                              Ent : constant Entity_Id := Entity (Ref);\n-                              --  The referenced entity\n+               begin\n+                  --  Loop through uplevel references\n \n-                              Typ : constant Entity_Id := Etype (Ent);\n-                              --  The type of the referenced entity\n+                  Elmt := First_Elmt (STJ.Urefs);\n+                  while Present (Elmt) loop\n \n-                              Rsub : constant Entity_Id :=\n-                                       Node (Next_Elmt (Elmt));\n-                              --  The enclosing subprogram for the reference\n+                     --  Skip if we have an explicit dereference. This means\n+                     --  that we already did the expansion. There can be\n+                     --  duplicates in ths STJ.Urefs list.\n \n-                              RSX : constant SI_Type := Subp_Index (Rsub);\n-                              --  Subp_Index for enclosing subprogram for ref\n+                     if Nkind (Node (Elmt)) = N_Explicit_Dereference then\n+                        goto Continue;\n+                     end if;\n \n-                              STJR : Subp_Entry renames Subps.Table (RSX);\n-                              --  Subp_Entry for enclosing subprogram for ref\n+                     --  Otherwise, rewrite this reference\n \n-                              Tnn : constant Entity_Id :=\n-                                      Make_Temporary\n-                                        (Loc, 'T', Related_Node => Ref);\n-                              --  Local pointer type for reference\n+                     declare\n+                        Ref : constant Node_Id := Node (Elmt);\n+                        --  The uplevel reference itself\n \n-                              Pfx  : Node_Id;\n-                              Comp : Entity_Id;\n-                              SI   : SI_Type;\n+                        Loc : constant Source_Ptr := Sloc (Ref);\n+                        --  Source location for the reference\n \n-                           begin\n-                              --  First insert declaration for pointer type\n+                        Ent : constant Entity_Id := Entity (Ref);\n+                        --  The referenced entity\n \n-                              --    type Tnn is access all typ;\n+                        Typ : constant Entity_Id := Etype (Ent);\n+                        --  The type of the referenced entity\n \n-                              Insert_Action (Ref,\n-                                Make_Full_Type_Declaration (Loc,\n-                                  Defining_Identifier => Tnn,\n-                                  Type_Definition     =>\n-                                    Make_Access_To_Object_Definition (Loc,\n-                                      All_Present        => True,\n-                                      Subtype_Indication =>\n-                                        New_Occurrence_Of (Typ, Loc))));\n+                        Rsub : constant Entity_Id :=\n+                                 Node (Next_Elmt (Elmt));\n+                        --  The enclosing subprogram for the reference\n \n-                              --  Now we need to rewrite the reference. The\n-                              --  reference is from level STJE.Lev to level\n-                              --  STJ.Lev. The general form of the rewritten\n-                              --  reference for entity X is:\n+                        RSX : constant SI_Type := Subp_Index (Rsub);\n+                        --  Subp_Index for enclosing subprogram for ref\n \n-                              --    Tnn!(ARECaF.ARECbU.ARECcU.ARECdU\n-                              --            ....ARECm.X).all\n+                        STJR : Subp_Entry renames Subps.Table (RSX);\n+                        --  Subp_Entry for enclosing subprogram for ref\n \n-                              --  where a,b,c,d .. m =\n-                              --        STJR.Lev - 1,  STJ.Lev - 2, .. STJ.Lev\n+                        Tnn : constant Entity_Id :=\n+                                Make_Temporary\n+                                  (Loc, 'T', Related_Node => Ref);\n+                        --  Local pointer type for reference\n \n-                              pragma Assert (STJR.Lev > STJ.Lev);\n+                        Pfx  : Node_Id;\n+                        Comp : Entity_Id;\n+                        SI   : SI_Type;\n \n-                              --  Compute the prefix of X. Here are examples\n-                              --  to make things clear (with parens to show\n-                              --  groupings, the prefix is everything except\n-                              --  the .X at the end).\n+                     begin\n+                        --  First insert declaration for pointer type\n+\n+                        --    type Tnn is access all typ;\n \n-                              --   level 2 to level 1\n+                        Insert_Action (Ref,\n+                          Make_Full_Type_Declaration (Loc,\n+                            Defining_Identifier => Tnn,\n+                            Type_Definition     =>\n+                              Make_Access_To_Object_Definition (Loc,\n+                                All_Present        => True,\n+                                Subtype_Indication =>\n+                                  New_Occurrence_Of (Typ, Loc))));\n \n-                              --     AREC1F.X\n+                        --  Now we need to rewrite the reference. We have a\n+                        --  reference is from level STJE.Lev to level STJ.Lev.\n+                        --  The general form of the rewritten reference for\n+                        --  entity X is:\n \n-                              --   level 3 to level 1\n+                        --    Tnn!(ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X).all\n \n-                              --     (AREC2F.AREC1U).X\n+                        --  where a,b,c,d .. m =\n+                        --         STJR.Lev - 1,  STJ.Lev - 2, .. STJ.Lev\n \n-                              --   level 4 to level 1\n+                        pragma Assert (STJR.Lev > STJ.Lev);\n \n-                              --     ((AREC3F.AREC2U).AREC1U).X\n+                        --  Compute the prefix of X. Here are examples to make\n+                        --  things clear (with parens to show groupings, the\n+                        --  prefix is everything except the .X at the end).\n \n-                              --   level 6 to level 2\n+                        --   level 2 to level 1\n \n-                              --     (((AREC5F.AREC4U).AREC3U).AREC2U).X\n+                        --     AREC1F.X\n \n-                              Pfx := New_Occurrence_Of (STJR.ARECnF, Loc);\n-                              SI := RSX;\n-                              for L in STJ.Lev .. STJR.Lev - 2 loop\n-                                 SI := Get_Enclosing_Subp (SI);\n-                                 Pfx :=\n-                                   Make_Selected_Component (Loc,\n-                                     Prefix        => Pfx,\n-                                     Selector_Name =>\n-                                       New_Occurrence_Of\n-                                         (Subps.Table (SI).ARECnU, Loc));\n-                              end loop;\n+                        --   level 3 to level 1\n \n-                              --  Get activation record component (must exist)\n+                        --     (AREC2F.AREC1U).X\n \n-                              Comp := Activation_Record_Component (Ent);\n-                              pragma Assert (Present (Comp));\n+                        --   level 4 to level 1\n \n-                              --  Do the replacement\n+                        --     ((AREC3F.AREC2U).AREC1U).X\n \n-                              Rewrite (Ref,\n-                                Make_Explicit_Dereference (Loc,\n-                                  Prefix =>\n-                                    Unchecked_Convert_To (Tnn,\n-                                      Make_Selected_Component (Loc,\n-                                        Prefix        => Pfx,\n-                                        Selector_Name =>\n-                                          New_Occurrence_Of (Comp, Loc)))));\n+                        --   level 6 to level 2\n \n-                              Next_Elmt (Elmt);\n-                              Next_Elmt (Elmt);\n-                           end;\n+                        --     (((AREC5F.AREC4U).AREC3U).AREC2U).X\n+\n+                        Pfx := New_Occurrence_Of (STJR.ARECnF, Loc);\n+                        SI := RSX;\n+                        for L in STJ.Lev .. STJR.Lev - 2 loop\n+                           SI := Enclosing_Subp (SI);\n+                           Pfx :=\n+                             Make_Selected_Component (Loc,\n+                               Prefix        => Pfx,\n+                               Selector_Name =>\n+                                 New_Occurrence_Of\n+                                   (Subps.Table (SI).ARECnU, Loc));\n                         end loop;\n-                     end Uplev_Refs;\n-                  end;\n-               end if;\n-            end;\n-         end loop;\n-      end Subp_Loop;\n+\n+                        --  Get activation record component (must exist)\n+\n+                        Comp := Activation_Record_Component (Ent);\n+                        pragma Assert (Present (Comp));\n+\n+                        --  Do the replacement\n+\n+                        Rewrite (Ref,\n+                          Make_Explicit_Dereference (Loc,\n+                            Prefix =>\n+                              Unchecked_Convert_To (Tnn,\n+                                Make_Selected_Component (Loc,\n+                                  Prefix        => Pfx,\n+                                  Selector_Name =>\n+                                    New_Occurrence_Of (Comp, Loc)))));\n+\n+                        --  Analyze and resolve the new expression. We do not\n+                        --  need to establish the relevant scope stack entries\n+                        --  here, because we have already set all the correct\n+                        --  entity references, so no name resolution is needed.\n+\n+                        --  We analyze with all checks suppressed (since we do\n+                        --  not expect any exceptions, and also we temporarily\n+                        --  turn off Unested_Subprogram_Mode to avoid trying to\n+                        --  mark uplevel references (not needed at this stage,\n+                        --  and in fact causes a bit of recursive chaos).\n+\n+                        Opt.Unnest_Subprogram_Mode := False;\n+                        Analyze_And_Resolve (Ref, Typ, Suppress => All_Checks);\n+                        Opt.Unnest_Subprogram_Mode := True;\n+                     end;\n+\n+                  <<Continue>>\n+                     Next_Elmt (Elmt);\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end;\n+            end if;\n+         end;\n+      end loop Uplev_Refs;\n \n       --  Finally, loop through all calls adding extra actual for the\n       --  activation record where it is required.\n \n-      --  TBD ???\n+      Adjust_Calls : for J in Calls.First .. Calls.Last loop\n+\n+         --  Process a single call, we are only interested in a call to a\n+         --  subprogram that actually need a pointer to an activation record,\n+         --  as indicated by the ARECnF entity being set. This excludes the\n+         --  top level subprogram, and any subprogram not having uplevel refs.\n+\n+         declare\n+            CTJ : Call_Entry renames Calls.Table (J);\n+\n+         begin\n+            if Has_Uplevel_Reference (CTJ.To) and then CTJ.To /= Subp then\n+               declare\n+                  CTJ : Call_Entry renames Calls.Table (J);\n+                  STF : Subp_Entry renames Subps.Table (Subp_Index (CTJ.From));\n+                  STT : Subp_Entry renames Subps.Table (Subp_Index (CTJ.To));\n+\n+                  Loc : constant Source_Ptr := Sloc (CTJ.N);\n+\n+                  Extra  : Node_Id;\n+                  ExtraP : Node_Id;\n+                  SubX   : SI_Type;\n+                  Act    : Node_Id;\n+\n+               begin\n+                  --  CTJ.N is a call to a subprogram which may require\n+                  --  a pointer to an activation record. The subprogram\n+                  --  containing the call is CTJ.From and the subprogram being\n+                  --  called is CTJ.To, so we have a call from level STF.Lev to\n+                  --  level STT.Lev.\n+\n+                  --  There are three possibilities:\n+\n+                  --  For a call to the same level, we just pass the activation\n+                  --  record passed to the calling subprogram.\n+\n+                  if STF.Lev = STT.Lev then\n+                     Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n+\n+                  --  For a call that goes down a level, we pass a pointer\n+                  --  to the activation record constructed wtihin the caller\n+                  --  (which may be the outer level subprogram, but also may\n+                  --  be a more deeply nested caller).\n+\n+                  elsif STT.Lev = STF.Lev + 1 then\n+                     Extra := New_Occurrence_Of (STF.ARECnP, Loc);\n+\n+                     --  Otherwise we must have an upcall (STT.Lev < STF.LEV),\n+                     --  since it is not possible to do a downcall of more than\n+                     --  one level.\n+\n+                     --  For a call from level STF.Lev to level STT.Lev, we\n+                     --  have to find the activation record needed by the\n+                     --  callee. This is as follows:\n+\n+                     --    ARECaF.ARECbU.ARECcU....ARECm\n+\n+                     --  where a,b,c .. m =\n+                     --    STF.Lev - 1,  STF.Lev - 2, STF.Lev - 3 .. STT.Lev\n+\n+                  else\n+                     pragma Assert (STT.Lev < STF.Lev);\n+\n+                     Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n+                     SubX := Subp_Index (CTJ.From);\n+                     for K in reverse STT.Lev .. STF.Lev - 1 loop\n+                        SubX := Enclosing_Subp (SubX);\n+                        Extra :=\n+                          Make_Selected_Component (Loc,\n+                            Prefix        => Extra,\n+                            Selector_Name =>\n+                              New_Occurrence_Of\n+                                (Subps.Table (SubX).ARECnU, Loc));\n+                     end loop;\n+                  end if;\n+\n+                  --  Extra is the additional parameter to be added. Build a\n+                  --  parameter association that we can append to the actuals.\n+\n+                  ExtraP :=\n+                    Make_Parameter_Association (Loc,\n+                      Selector_Name             =>\n+                        New_Occurrence_Of (STT.ARECnF, Loc),\n+                      Explicit_Actual_Parameter => Extra);\n+\n+                  if No (Parameter_Associations (CTJ.N)) then\n+                     Set_Parameter_Associations (CTJ.N, Empty_List);\n+                  end if;\n+\n+                  Append (ExtraP, Parameter_Associations (CTJ.N));\n+\n+                  --  We need to deal with the actual parameter chain as well.\n+                  --  The newly added parameter is always the last actual.\n+\n+                  Act := First_Named_Actual (CTJ.N);\n+\n+                  if No (Act) then\n+                     Set_First_Named_Actual (CTJ.N, Extra);\n+\n+                  --  Here we must follow the chain and append the new entry\n+\n+                  else\n+                     while Present (Next_Named_Actual (Act)) loop\n+                        Act := Next_Named_Actual (Act);\n+                     end loop;\n+\n+                     Set_Next_Named_Actual (Act, Extra);\n+                  end if;\n+\n+                  --  Analyze and resolve the new actual. We do not need to\n+                  --  establish the relevant scope stack entries here, because\n+                  --  we have already set all the correct entity references, so\n+                  --  no name resolution is needed.\n+\n+                  --  We analyze with all checks suppressed (since we do not\n+                  --  expect any exceptions, and also we temporarily turn off\n+                  --  Unested_Subprogram_Mode to avoid trying to mark uplevel\n+                  --  references (not needed at this stage, and in fact causes\n+                  --  a bit of recursive chaos).\n+\n+                  Opt.Unnest_Subprogram_Mode := False;\n+                  Analyze_And_Resolve\n+                    (Extra, Etype (STT.ARECnF), Suppress => All_Checks);\n+                  Opt.Unnest_Subprogram_Mode := True;\n+               end;\n+            end if;\n+         end;\n+      end loop Adjust_Calls;\n \n       return;\n    end Unnest_Subprogram;"}, {"sha": "2c554dd979fa24723ecde50047c03c79488a081d", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2014-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "e048e216be9b0d7788d5c94589242855b602bec5", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -2883,13 +2883,22 @@ package body Sem_Util is\n \n         and then not Is_Imported (Ent)\n       then\n-         --  For VM case, we are only interested in variables, constants,\n-         --  and loop parameters. For general nested procedure usage, we\n-         --  allow types as well.\n+         --  In both the VM case and in Unnest_Subprogram_Mode, we mark\n+         --  variables, constants, and loop parameters.\n \n          if Ekind_In (Ent, E_Variable, E_Constant, E_Loop_Parameter) then\n             null;\n-         elsif not (Unnest_Subprogram_Mode and then Is_Type (Ent)) then\n+\n+         --  In Unnest_Subprogram_Mode, we also mark types and formals\n+\n+         elsif Unnest_Subprogram_Mode\n+           and then (Is_Type (Ent) or else Is_Formal (Ent))\n+         then\n+            null;\n+\n+            --  All other cases, do not mark\n+\n+         else\n             return;\n          end if;\n \n@@ -14081,8 +14090,8 @@ package body Sem_Util is\n                   New_Next := First (Parameter_Associations (New_Node));\n \n                   while Nkind (Old_Next) /= N_Parameter_Association\n-                    or else  Explicit_Actual_Parameter (Old_Next)\n-                      /= Next_Named_Actual (Old_E)\n+                    or else Explicit_Actual_Parameter (Old_Next) /=\n+                                              Next_Named_Actual (Old_E)\n                   loop\n                      Next (Old_Next);\n                      Next (New_Next);"}, {"sha": "670e53416644c17da14510f8cdb9ef98878c3f73", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f0276a49a2ae68f3dd086b237037cdce6ed6b4/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=89f0276a49a2ae68f3dd086b237037cdce6ed6b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2703,12 +2703,15 @@ package body Sprint is\n                --  it is emitted when the access definition is displayed.\n \n                if Null_Exclusion_Present (Node)\n-                 and then Nkind (Parameter_Type (Node))\n-                   /= N_Access_Definition\n+                 and then Nkind (Parameter_Type (Node)) /= N_Access_Definition\n                then\n                   Write_Str (\"not null \");\n                end if;\n \n+               if Aliased_Present (Node) then\n+                  Write_Str (\"aliased \");\n+               end if;\n+\n                Sprint_Node (Parameter_Type (Node));\n \n                if Present (Expression (Node)) then"}]}