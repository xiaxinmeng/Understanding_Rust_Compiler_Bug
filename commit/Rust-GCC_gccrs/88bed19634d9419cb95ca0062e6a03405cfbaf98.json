{"sha": "88bed19634d9419cb95ca0062e6a03405cfbaf98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhiZWQxOTYzNGQ5NDE5Y2I5NWNhMDA2MmU2YTAzNDA1Y2ZiYWY5OA==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2016-01-18T12:29:02Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2016-01-18T12:29:02Z"}, "message": "Make SRA scalarize constant-pool loads\n\nPR target/63679\n\ngcc/ChangeLog:\n    \n\t* tree-sra.c (disqualified_constants, constant_decl_p): New.\n\t(sra_initialize): Allocate disqualified_constants.\n\t(sra_deinitialize): Free disqualified_constants.\n\t(disqualify_candidate): Update disqualified_constants when appropriate.\n\t(create_access): Scan for constant-pool entries as we go along.\n\t(scalarizable_type_p): Add check against type_contains_placeholder_p.\n\t(maybe_add_sra_candidate): Allow constant-pool entries.\n\t(load_assign_lhs_subreplacements): Bind debug for constant pool vars.\n\t(initialize_constant_pool_replacements): New.\n\t(sra_modify_assign): Avoid mangling assignments created by previous,\n\tand don't generate writes into constant pool.\n\t(sra_modify_function_body): Call initialize_constant_pool_replacements.\n    \ngcc/testsuite/:\n\n\t* gcc.dg/tree-ssa/sra-17.c: New.\n\t* gcc.dg/tree-ssa/sra-18.c: New.\n\nFrom-SVN: r232506", "tree": {"sha": "7851c3d73521e5ceff55c173e0ff37a942ce966a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7851c3d73521e5ceff55c173e0ff37a942ce966a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88bed19634d9419cb95ca0062e6a03405cfbaf98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88bed19634d9419cb95ca0062e6a03405cfbaf98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88bed19634d9419cb95ca0062e6a03405cfbaf98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88bed19634d9419cb95ca0062e6a03405cfbaf98/comments", "author": null, "committer": null, "parents": [{"sha": "13092f619889805136f945718288a3c17c6beae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13092f619889805136f945718288a3c17c6beae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13092f619889805136f945718288a3c17c6beae1"}], "stats": {"total": 173, "additions": 169, "deletions": 4}, "files": [{"sha": "1b20442d95fb88c9133883ced8ef8af490864bce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88bed19634d9419cb95ca0062e6a03405cfbaf98", "patch": "@@ -1,3 +1,19 @@\n+2016-01-18  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR target/63679\n+\t* tree-sra.c (disqualified_constants, constant_decl_p): New.\n+\t(sra_initialize): Allocate disqualified_constants.\n+\t(sra_deinitialize): Free disqualified_constants.\n+\t(disqualify_candidate): Update disqualified_constants when appropriate.\n+\t(create_access): Scan for constant-pool entries as we go along.\n+\t(scalarizable_type_p): Add check against type_contains_placeholder_p.\n+\t(maybe_add_sra_candidate): Allow constant-pool entries.\n+\t(load_assign_lhs_subreplacements): Bind debug for constant pool vars.\n+\t(initialize_constant_pool_replacements): New.\n+\t(sra_modify_assign): Avoid mangling assignments created by previous,\n+\tand don't generate writes into constant pool.\n+\t(sra_modify_function_body): Call initialize_constant_pool_replacements.\n+\n 2016-01-18  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* config/i386/i386.c (scalar_to_vector_candidate_p): Support"}, {"sha": "3681ba1a3407826be1c101836157ed1d966e5e71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88bed19634d9419cb95ca0062e6a03405cfbaf98", "patch": "@@ -1,3 +1,9 @@\n+2016-01-18  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\tPR target/63679\n+\t* gcc.dg/tree-ssa/sra-17.c: New.\n+\t* gcc.dg/tree-ssa/sra-18.c: New.\n+\n 2016-01-18  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* gcc.target/i386/pr65105-5.c: Adjust to andn generation."}, {"sha": "25667f4e0d2cceeb1b16a46ba1d8a073e75e940a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-17.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-17.c?ref=88bed19634d9419cb95ca0062e6a03405cfbaf98", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do run { target { aarch64*-*-* alpha*-*-* arm*-*-* hppa*-*-* powerpc*-*-* s390*-*-* } } } */\n+/* { dg-options \"-O2 -fdump-tree-esra --param sra-max-scalarization-size-Ospeed=32\" } */\n+\n+extern void abort (void);\n+\n+int\n+main (int argc, char **argv)\n+{\n+  long a[4] = { 7, 19, 11, 255 };\n+  int tot = 0;\n+  for (int i = 0; i < 4; i++)\n+    tot = (tot*256) + a[i];\n+  if (tot == 0x07130bff)\n+    return 0;\n+  abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Removing load: a = \\\\\\*.LC0;\" 1 \"esra\" } } */\n+/* { dg-final { scan-tree-dump-times \"SR.\\[0-9_\\]+ = \\\\\\*.LC0\\\\\\[\" 4 \"esra\" } } */"}, {"sha": "609fb11c23cdca7736e8e5094bebf0d20f85d4c3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-18.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-18.c?ref=88bed19634d9419cb95ca0062e6a03405cfbaf98", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run { target { aarch64*-*-* alpha*-*-* arm*-*-* hppa*-*-* powerpc*-*-* s390*-*-* } } } */\n+/* { dg-options \"-O2 -fdump-tree-esra --param sra-max-scalarization-size-Ospeed=32\" } */\n+\n+extern void abort (void);\n+struct foo { long x; };\n+\n+struct bar { struct foo f[2]; };\n+\n+struct baz { struct bar b[2]; };\n+\n+int\n+main (int argc, char **argv)\n+{\n+  struct baz a = { { { { { 4 }, { 5 } } }, { { { 6 }, { 7 } } }  } };\n+  int tot = 0;\n+  for (int i = 0; i < 2; i++)\n+    for (int j = 0; j < 2; j++)\n+      tot = (tot*256) + a.b[i].f[j].x;\n+  if (tot == 0x04050607)\n+    return 0;\n+  abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Removing load: a = \\\\\\*.LC0;\" 1 \"esra\" } } */\n+/* { dg-final { scan-tree-dump-times \"SR.\\[0-9_\\]+ = \\\\\\*.LC0\\\\.b\\\\\\[0\\\\\\]\\\\.f\\\\\\[0\\\\\\]\\\\.x\" 1 \"esra\" } } */\n+/* { dg-final { scan-tree-dump-times \"SR.\\[0-9_\\]+ = \\\\\\*.LC0\\\\.b\\\\\\[0\\\\\\]\\\\.f\\\\\\[1\\\\\\]\\\\.x\" 1 \"esra\" } } */\n+/* { dg-final { scan-tree-dump-times \"SR.\\[0-9_\\]+ = \\\\\\*.LC0\\\\.b\\\\\\[1\\\\\\]\\\\.f\\\\\\[0\\\\\\]\\\\.x\" 1 \"esra\" } } */\n+/* { dg-final { scan-tree-dump-times \"SR.\\[0-9_\\]+ = \\\\\\*.LC0\\\\.b\\\\\\[1\\\\\\]\\\\.f\\\\\\[1\\\\\\]\\\\.x\" 1 \"esra\" } } */"}, {"sha": "740542fde0adf92dbd5dc33af820ad1b4f54792d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 100, "deletions": 4, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88bed19634d9419cb95ca0062e6a03405cfbaf98/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=88bed19634d9419cb95ca0062e6a03405cfbaf98", "patch": "@@ -328,6 +328,10 @@ candidate (unsigned uid)\n    those which cannot be (because they are and need be used as a whole).  */\n static bitmap should_scalarize_away_bitmap, cannot_scalarize_away_bitmap;\n \n+/* Bitmap of candidates in the constant pool, which cannot be scalarized\n+   because this would produce non-constant expressions (e.g. Ada).  */\n+static bitmap disqualified_constants;\n+\n /* Obstack for creation of fancy names.  */\n static struct obstack name_obstack;\n \n@@ -652,6 +656,7 @@ sra_initialize (void)\n     (vec_safe_length (cfun->local_decls) / 2);\n   should_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   cannot_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n+  disqualified_constants = BITMAP_ALLOC (NULL);\n   gcc_obstack_init (&name_obstack);\n   base_access_vec = new hash_map<tree, auto_vec<access_p> >;\n   memset (&sra_stats, 0, sizeof (sra_stats));\n@@ -670,20 +675,30 @@ sra_deinitialize (void)\n   candidates = NULL;\n   BITMAP_FREE (should_scalarize_away_bitmap);\n   BITMAP_FREE (cannot_scalarize_away_bitmap);\n+  BITMAP_FREE (disqualified_constants);\n   access_pool.release ();\n   assign_link_pool.release ();\n   obstack_free (&name_obstack, NULL);\n \n   delete base_access_vec;\n }\n \n+/* Return true if DECL is a VAR_DECL in the constant pool, false otherwise.  */\n+\n+static bool constant_decl_p (tree decl)\n+{\n+  return TREE_CODE (decl) == VAR_DECL && DECL_IN_CONSTANT_POOL (decl);\n+}\n+\n /* Remove DECL from candidates for SRA and write REASON to the dump file if\n    there is one.  */\n static void\n disqualify_candidate (tree decl, const char *reason)\n {\n   if (bitmap_clear_bit (candidate_bitmap, DECL_UID (decl)))\n     candidates->remove_elt_with_hash (decl, DECL_UID (decl));\n+  if (constant_decl_p (decl))\n+    bitmap_set_bit (disqualified_constants, DECL_UID (decl));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -835,8 +850,11 @@ create_access_1 (tree base, HOST_WIDE_INT offset, HOST_WIDE_INT size)\n   return access;\n }\n \n+static bool maybe_add_sra_candidate (tree);\n+\n /* Create and insert access for EXPR. Return created access, or NULL if it is\n-   not possible.  */\n+   not possible.  Also scan for uses of constant pool as we go along and add\n+   to candidates.  */\n \n static struct access *\n create_access (tree expr, gimple *stmt, bool write)\n@@ -859,6 +877,25 @@ create_access (tree expr, gimple *stmt, bool write)\n   else\n     ptr = false;\n \n+  /* For constant-pool entries, check we can substitute the constant value.  */\n+  if (constant_decl_p (base)\n+      && (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA))\n+    {\n+      gcc_assert (!bitmap_bit_p (disqualified_constants, DECL_UID (base)));\n+      if (expr != base\n+\t  && !is_gimple_reg_type (TREE_TYPE (expr))\n+\t  && dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  /* This occurs in Ada with accesses to ARRAY_RANGE_REFs,\n+\t     and elements of multidimensional arrays (which are\n+\t     multi-element arrays in their own right).  */\n+\t  fprintf (dump_file, \"Allowing non-reg-type load of part\"\n+\t\t\t      \" of constant-pool entry: \");\n+\t  print_generic_expr (dump_file, expr, 0);\n+\t}\n+      maybe_add_sra_candidate (base);\n+    }\n+\n   if (!DECL_P (base) || !bitmap_bit_p (candidate_bitmap, DECL_UID (base)))\n     return NULL;\n \n@@ -918,6 +955,8 @@ static bool\n scalarizable_type_p (tree type)\n {\n   gcc_assert (!is_gimple_reg_type (type));\n+  if (type_contains_placeholder_p (type))\n+    return false;\n \n   switch (TREE_CODE (type))\n   {\n@@ -1852,7 +1891,10 @@ maybe_add_sra_candidate (tree var)\n       reject (var, \"not aggregate\");\n       return false;\n     }\n-  if (needs_to_live_in_memory (var))\n+  /* Allow constant-pool entries (that \"need to live in memory\")\n+     unless we are doing IPA SRA.  */\n+  if (needs_to_live_in_memory (var)\n+      && (sra_mode == SRA_MODE_EARLY_IPA || !constant_decl_p (var)))\n     {\n       reject (var, \"needs to live in memory\");\n       return false;\n@@ -3113,7 +3155,7 @@ load_assign_lhs_subreplacements (struct access *lacc,\n \n \t      if (racc && racc->grp_to_be_replaced)\n \t\t{\n-\t\t  if (racc->grp_write)\n+\t\t  if (racc->grp_write || constant_decl_p (racc->base))\n \t\t    drhs = get_access_replacement (racc);\n \t\t  else\n \t\t    drhs = NULL;\n@@ -3272,6 +3314,9 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n   racc = get_access_for_expr (rhs);\n   if (!lacc && !racc)\n     return SRA_AM_NONE;\n+  /* Avoid modifying initializations of constant-pool replacements.  */\n+  if (racc && (racc->replacement_decl == lhs))\n+    return SRA_AM_NONE;\n \n   loc = gimple_location (stmt);\n   if (lacc && lacc->grp_to_be_replaced)\n@@ -3388,7 +3433,8 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n       || contains_vce_or_bfcref_p (lhs)\n       || stmt_ends_bb_p (stmt))\n     {\n-      if (access_has_children_p (racc))\n+      /* No need to copy into a constant-pool, it comes pre-initialized.  */\n+      if (access_has_children_p (racc) && !constant_decl_p (racc->base))\n \tgenerate_subtree_copies (racc->first_child, rhs, racc->offset, 0, 0,\n \t\t\t\t gsi, false, false, loc);\n       if (access_has_children_p (lacc))\n@@ -3491,6 +3537,54 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n     }\n }\n \n+/* Set any scalar replacements of values in the constant pool to the initial\n+   value of the constant.  (Constant-pool decls like *.LC0 have effectively\n+   been initialized before the program starts, we must do the same for their\n+   replacements.)  Thus, we output statements like 'SR.1 = *.LC0[0];' into\n+   the function's entry block.  */\n+\n+static void\n+initialize_constant_pool_replacements (void)\n+{\n+  gimple_seq seq = NULL;\n+  gimple_stmt_iterator gsi = gsi_start (seq);\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)\n+    if (bitmap_bit_p (should_scalarize_away_bitmap, i)\n+\t&& !bitmap_bit_p (cannot_scalarize_away_bitmap, i))\n+      {\n+\ttree var = candidate (i);\n+\tif (!constant_decl_p (var))\n+\t  continue;\n+\tvec<access_p> *access_vec = get_base_access_vector (var);\n+\tif (!access_vec)\n+\t  continue;\n+\tfor (unsigned i = 0; i < access_vec->length (); i++)\n+\t  {\n+\t    struct access *access = (*access_vec)[i];\n+\t    if (!access->replacement_decl)\n+\t      continue;\n+\t    gassign *stmt = gimple_build_assign (\n+\t      get_access_replacement (access), unshare_expr (access->expr));\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      {\n+\t\tfprintf (dump_file, \"Generating constant initializer: \");\n+\t\tprint_gimple_stmt (dump_file, stmt, 0, 1);\n+\t\tfprintf (dump_file, \"\\n\");\n+\t      }\n+\t    gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+\t    update_stmt (stmt);\n+\t  }\n+      }\n+\n+  seq = gsi_seq (gsi);\n+  if (seq)\n+    gsi_insert_seq_on_edge_immediate (\n+      single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);\n+}\n+\n /* Traverse the function body and all modifications as decided in\n    analyze_all_variable_accesses.  Return true iff the CFG has been\n    changed.  */\n@@ -3501,6 +3595,8 @@ sra_modify_function_body (void)\n   bool cfg_changed = false;\n   basic_block bb;\n \n+  initialize_constant_pool_replacements ();\n+\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       gimple_stmt_iterator gsi = gsi_start_bb (bb);"}]}