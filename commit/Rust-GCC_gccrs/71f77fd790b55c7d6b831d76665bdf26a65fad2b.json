{"sha": "71f77fd790b55c7d6b831d76665bdf26a65fad2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFmNzdmZDc5MGI1NWM3ZDZiODMxZDc2NjY1YmRmMjZhNjVmYWQyYg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-20T13:48:06Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-20T13:48:06Z"}, "message": "re PR fortran/29992 ([4.1 only] INTERFACE equivalent to MODULE PROCEDURE?!)\n\n2006-12-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29992\n\t* interface.c (check_sym_interfaces): Module procedures in a\n\tgeneric must be use associated or contained in the module.\n\t* decl.c (gfc_match_modproc): Set attribute mod_proc.\n\t* gfortran.h (symbol_attribute): Add mod_proc atribute.\n\n\tPR fortran/30081\n\t* resolve.c (resolve_generic_f, resolve_generic_s): Use\n\tgfc_intrinsic_name to find out if the function is intrinsic\n\tbecause it does not have to be a generic intrinsic to be\n\toverloaded.\n\n2006-12-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29992\n\t* gfortran.dg/generic_9.f90: New test.\n\n\tPR fortran/30081\n\t* gfortran.dg/generic_10.f90: New test.\n\nFrom-SVN: r120072", "tree": {"sha": "006a73693cd6f5f41909b3e2d5aff9801697221d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/006a73693cd6f5f41909b3e2d5aff9801697221d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71f77fd790b55c7d6b831d76665bdf26a65fad2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71f77fd790b55c7d6b831d76665bdf26a65fad2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71f77fd790b55c7d6b831d76665bdf26a65fad2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71f77fd790b55c7d6b831d76665bdf26a65fad2b/comments", "author": null, "committer": null, "parents": [{"sha": "0550e7b7aa95d5edd861932b4301a659266f0d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0550e7b7aa95d5edd861932b4301a659266f0d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0550e7b7aa95d5edd861932b4301a659266f0d0a"}], "stats": {"total": 132, "additions": 126, "deletions": 6}, "files": [{"sha": "d283671cb0cdc5e313e3564fb5510c99c24a5f70", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -1,3 +1,17 @@\n+2006-12-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29992\n+\t* interface.c (check_sym_interfaces): Module procedures in a\n+\tgeneric must be use associated or contained in the module.\n+\t* decl.c (gfc_match_modproc): Set attribute mod_proc.\n+\t* gfortran.h (symbol_attribute): Add mod_proc atribute.\n+\n+\tPR fortran/30081\n+\t* resolve.c (resolve_generic_f, resolve_generic_s): Use\n+\tgfc_intrinsic_name to find out if the function is intrinsic\n+\tbecause it does not have to be a generic intrinsic to be\n+\toverloaded.\n+\n 2006-12-19  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/39238"}, {"sha": "d8988fd201534950a3b5aeb91fafaf047f5afc53", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -4289,6 +4289,8 @@ gfc_match_modproc (void)\n       if (gfc_add_interface (sym) == FAILURE)\n \treturn MATCH_ERROR;\n \n+      sym->attr.mod_proc = 1;\n+\n       if (gfc_match_eos () == MATCH_YES)\n \tbreak;\n       if (gfc_match_char (',') != MATCH_YES)"}, {"sha": "296004edbc85958a79ca1f5ddedfe550705411c2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -494,7 +494,7 @@ typedef struct\n \n   /* Function/subroutine attributes */\n   unsigned sequence:1, elemental:1, pure:1, recursive:1;\n-  unsigned unmaskable:1, masked:1, contained:1;\n+  unsigned unmaskable:1, masked:1, contained:1, mod_proc:1;\n \n   /* This is set if the subroutine doesn't return.  Currently, this\n      is only possible for intrinsic subroutines.  */"}, {"sha": "6ffa4b2e9820af41da212d8469bd551d050c3fad", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -1011,6 +1011,7 @@ check_sym_interfaces (gfc_symbol * sym)\n {\n   char interface_name[100];\n   bool k;\n+  gfc_interface *p;\n \n   if (sym->ns != gfc_current_ns)\n     return;\n@@ -1021,6 +1022,18 @@ check_sym_interfaces (gfc_symbol * sym)\n       if (check_interface0 (sym->generic, interface_name))\n \treturn;\n \n+      for (p = sym->generic; p; p = p->next)\n+\t{\n+\t  if (!p->sym->attr.use_assoc\n+\t\t&& p->sym->attr.mod_proc\n+\t\t&& p->sym->attr.if_source != IFSRC_DECL)\n+\t    {\n+\t      gfc_error (\"MODULE PROCEDURE '%s' at %L does not come \"\n+\t\t\t \"from a module\", p->sym->name, &p->where);\n+\t      return;\n+\t    }\n+\t}\n+\n       /* Originally, this test was aplied to host interfaces too;\n \t this is incorrect since host associated symbols, from any\n \t source, cannot be ambiguous with local symbols.  */"}, {"sha": "519d92ab9b7f138e7ba15824330964fd7a4a133a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -1215,9 +1215,9 @@ resolve_generic_f (gfc_expr * expr)\n \tgoto generic;\n     }\n \n-  /* Last ditch attempt.  */\n-\n-  if (!gfc_generic_intrinsic (expr->symtree->n.sym->name))\n+  /* Last ditch attempt.  See if the reference is to an intrinsic\n+     that possesses a matching interface.  14.1.2.4  */\n+  if (!gfc_intrinsic_name (sym->name, 0))\n     {\n       gfc_error (\"There is no specific function for the generic '%s' at %L\",\n \t\t expr->symtree->n.sym->name, &expr->where);\n@@ -1675,9 +1675,11 @@ resolve_generic_s (gfc_code * c)\n \tgoto generic;\n     }\n \n-  /* Last ditch attempt.  */\n+  /* Last ditch attempt.  See if the reference is to an intrinsic\n+     that possesses a matching interface.  14.1.2.4  */\n   sym = c->symtree->n.sym;\n-  if (!gfc_generic_intrinsic (sym->name))\n+\n+  if (!gfc_intrinsic_name (sym->name, 1))\n     {\n       gfc_error\n \t(\"There is no specific subroutine for the generic '%s' at %L\","}, {"sha": "2cc1c29e067c50c0196a9243cb9588b224469c3c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -1,3 +1,11 @@\n+2006-12-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29992\n+\t* gfortran.dg/generic_9.f90: New test.\n+\n+\tPR fortran/30081\n+\t* gfortran.dg/generic_10.f90: New test.\n+\n 2006-12-19  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR tree-opt/30045"}, {"sha": "8f9ff6fcbe82e2a03d7d245a41f053c6fea1cf0f", "filename": "gcc/testsuite/gfortran.dg/generic_10.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_10.f90?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! Test the patch for PR30081 in which non-generic intrinsic\n+! procedures could not be overloaded by generic interfaces.\n+!\n+! Contributed by Harald Anlauf  <anlauf@gmx.de>\n+!\n+module gfcbug46\n+  interface random_seed\n+     module procedure put_seed\n+  end interface\n+  interface random_number\n+     module procedure random_vector\n+  end interface\n+  type t_t\n+     real :: x(2)\n+  end type t_t\n+contains\n+  subroutine put_seed (n, seed)\n+    integer, intent(inout) :: n\n+    integer, intent(in)    :: seed\n+    call random_seed (size=n)\n+  end subroutine put_seed\n+  subroutine random_vector (t)\n+    type(t_t) :: t\n+    call random_number (t% x)\n+  end subroutine random_vector\n+end module gfcbug46\n+\n+  use gfcbug46\n+  type(t_t) :: z\n+  integer :: n = 2, seed = 1\n+  call put_seed (n, seed)\n+  call random_number (z)\n+  print *, z\n+end\n+! { dg-final { cleanup-modules \"gfcbug46\" } }"}, {"sha": "2bd143ff858a203fbfcaa0ac904eb71195a1fb60", "filename": "gcc/testsuite/gfortran.dg/generic_9.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71f77fd790b55c7d6b831d76665bdf26a65fad2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_9.f90?ref=71f77fd790b55c7d6b831d76665bdf26a65fad2b", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+! Test the patch for PR29992. The standard requires that a\n+! module procedure be contained in the same scope as the\n+! interface or is use associated to it(12.3.2.1).\n+!\n+! Contributed by Daniel Franke  <franke.daniel@gmail.com>\n+!\n+MODULE class_foo_type\n+  TYPE :: foo\n+    INTEGER :: dummy\n+  END TYPE\n+contains\n+  SUBROUTINE bar_init_set_int(this, value)\n+    TYPE(foo), INTENT(out) :: this\n+    integer, intent(in) :: value\n+    this%dummy = value\n+  END SUBROUTINE\n+END MODULE\n+\n+MODULE class_foo\n+USE class_foo_type, ONLY: foo, bar_init_set_int\n+\n+INTERFACE foo_init\n+  MODULE PROCEDURE foo_init_default  ! { dg-error \"does not come from a module\" }\n+END INTERFACE\n+\n+INTERFACE bar_init\n+  MODULE PROCEDURE bar_init_default, bar_init_set_int  ! These are OK\n+END INTERFACE\n+\n+INTERFACE\n+  SUBROUTINE foo_init_default(this)\n+    USE class_foo_type, ONLY: foo\n+    TYPE(foo), INTENT(out) :: this\n+  END SUBROUTINE\n+END INTERFACE\n+\n+contains\n+  SUBROUTINE bar_init_default(this)\n+    TYPE(foo), INTENT(out) :: this\n+    this%dummy = 42\n+  END SUBROUTINE\n+\n+END MODULE\n+! { dg-final { cleanup-modules \"class_foo_type class_foo\" } }"}]}