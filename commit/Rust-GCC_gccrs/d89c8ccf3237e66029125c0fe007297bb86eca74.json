{"sha": "d89c8ccf3237e66029125c0fe007297bb86eca74", "node_id": "C_kwDOANBUbNoAKGQ4OWM4Y2NmMzIzN2U2NjAyOTEyNWMwZmUwMDcyOTdiYjg2ZWNhNzQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-04T11:58:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-04T11:58:45Z"}, "message": "Merge #990\n\n990: Add must use attribute support r=philberty a=philberty\n\nThis is a port of the CPP front-end nodiscard attribute to be used for\r\nmust_use. It contains a patch to clean up how we handle expressions vs\r\nstatements and removes more of the GCC abstraction. Its my hope that we\r\ncan leverage more and more existing code to get the static analysis where\r\nwe want it.\r\n\r\nFixes #856 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "24926ddec8217cdba774a50eaa06383c8a72d13e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24926ddec8217cdba774a50eaa06383c8a72d13e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d89c8ccf3237e66029125c0fe007297bb86eca74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIf71CRBK7hj4Ov3rIwAAkYQIAEkI3nOtn88TJ9rutWpf9Je8\nUoSBGHsx1wy3jCMv6qlN2XD6ewF6bW2ku4emqaqc3i3ftKGp399E6SIN6kLhBXZv\nBmiHPEdB6ZO3pC90zFLJNXZ2v94o14snFAUfF5gBsRQDZRMxCzzJy3Pf6t6qkAz1\nvXtslhl/I6Xs6iQSNCCLUxPA69Xr2YzF9usQv8Daw/azZSU/g7pUdPzvyFE5YQ6j\nc42rAW3+c1VnLTaqFzongXKJhsKjvYtRybqcJV63gRwZRVJSRQHQOOymd7n6So4P\nqXdWW94HBEErlIs9FIupLKNAVGnk6FAzd9TUwv8LJN+lmO9OVZYtEFHr+a/FKLw=\n=DHXN\n-----END PGP SIGNATURE-----\n", "payload": "tree 24926ddec8217cdba774a50eaa06383c8a72d13e\nparent b4bd389c66a3e3bf0489626a1a70c2500d415ef8\nparent d6e1771291c792f665f5b9ed7d065bf292051e6a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646395125 +0000\ncommitter GitHub <noreply@github.com> 1646395125 +0000\n\nMerge #990\n\n990: Add must use attribute support r=philberty a=philberty\n\nThis is a port of the CPP front-end nodiscard attribute to be used for\r\nmust_use. It contains a patch to clean up how we handle expressions vs\r\nstatements and removes more of the GCC abstraction. Its my hope that we\r\ncan leverage more and more existing code to get the static analysis where\r\nwe want it.\r\n\r\nFixes #856 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89c8ccf3237e66029125c0fe007297bb86eca74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89c8ccf3237e66029125c0fe007297bb86eca74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89c8ccf3237e66029125c0fe007297bb86eca74/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4bd389c66a3e3bf0489626a1a70c2500d415ef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4bd389c66a3e3bf0489626a1a70c2500d415ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4bd389c66a3e3bf0489626a1a70c2500d415ef8"}, {"sha": "d6e1771291c792f665f5b9ed7d065bf292051e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e1771291c792f665f5b9ed7d065bf292051e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6e1771291c792f665f5b9ed7d065bf292051e6a"}], "stats": {"total": 1129, "additions": 1004, "deletions": 125}, "files": [{"sha": "b33d90ea6c6771dfeee282f358bd7fa461446ef1", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -111,6 +111,7 @@ GRS_OBJS = \\\n     rust/rust-compile-type.o \\\n     rust/rust-constexpr.o \\\n     rust/rust-compile-base.o \\\n+    rust/rust-tree.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "a705da729fe5f711c510fa49586233a579b602f0", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -22,6 +22,8 @@\n #include \"rust-compile-fnparam.h\"\n #include \"rust-compile-var-decl.h\"\n \n+#include \"rust-expr.h\" // for AST::AttrInputLiteral\n+\n #include \"fold-const.h\"\n #include \"stringpool.h\"\n \n@@ -52,10 +54,16 @@ HIRCompileBase::setup_attributes_on_fndecl (\n   for (const auto &attr : attrs)\n     {\n       bool is_inline = attr.get_path ().as_string ().compare (\"inline\") == 0;\n+      bool is_must_use\n+\t= attr.get_path ().as_string ().compare (\"must_use\") == 0;\n       if (is_inline)\n \t{\n \t  handle_inline_attribute_on_fndecl (fndecl, attr);\n \t}\n+      else if (is_must_use)\n+\t{\n+\t  handle_must_use_attribute_on_fndecl (fndecl, attr);\n+\t}\n     }\n }\n \n@@ -107,6 +115,30 @@ HIRCompileBase::handle_inline_attribute_on_fndecl (tree fndecl,\n     }\n }\n \n+void\n+HIRCompileBase::handle_must_use_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t     const AST::Attribute &attr)\n+{\n+  tree nodiscard = get_identifier (\"nodiscard\");\n+  tree value = NULL_TREE;\n+\n+  if (attr.has_attr_input ())\n+    {\n+      rust_assert (attr.get_attr_input ().get_attr_input_type ()\n+\t\t   == AST::AttrInput::AttrInputType::LITERAL);\n+\n+      auto &literal\n+\t= static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+      const auto &msg_str = literal.get_literal ().as_string ();\n+      tree message = build_string (msg_str.size (), msg_str.c_str ());\n+\n+      value = tree_cons (nodiscard, message, NULL_TREE);\n+    }\n+\n+  DECL_ATTRIBUTES (fndecl)\n+    = tree_cons (nodiscard, value, DECL_ATTRIBUTES (fndecl));\n+}\n+\n void\n HIRCompileBase::setup_abi_options (tree fndecl, ABI abi)\n {\n@@ -262,9 +294,8 @@ HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  tree compiled_stmt\n-\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n-\t  ctx->add_statement (compiled_stmt);\n+\t  tree s = convert_to_void (compiled_expr, ICV_STATEMENT);\n+\t  ctx->add_statement (s);\n \t}\n     }\n \n@@ -289,10 +320,8 @@ HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n \t    }\n \t  else\n \t    {\n-\t      tree final_stmt\n-\t\t= ctx->get_backend ()->expression_statement (fndecl,\n-\t\t\t\t\t\t\t     compiled_expr);\n-\t      ctx->add_statement (final_stmt);\n+\t      // FIXME can this actually happen?\n+\t      ctx->add_statement (compiled_expr);\n \t    }\n \t}\n     }"}, {"sha": "c30aa4d051599fa8d3058826d806fb4dee4433c5", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -79,6 +79,9 @@ class HIRCompileBase\n   static void handle_inline_attribute_on_fndecl (tree fndecl,\n \t\t\t\t\t\t const AST::Attribute &attr);\n \n+  static void handle_must_use_attribute_on_fndecl (tree fndecl,\n+\t\t\t\t\t\t   const AST::Attribute &attr);\n+\n   static void setup_abi_options (tree fndecl, ABI abi);\n \n   static tree address_expression (tree, Location);"}, {"sha": "3fefd8d5c7c6e25847770862c0bdb753a6a8db4f", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -25,9 +25,9 @@\n #include \"rust-hir-type-check.h\"\n #include \"rust-backend.h\"\n #include \"rust-compile-tyty.h\"\n-#include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-mangle.h\"\n+#include \"rust-tree.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "6d50c3fcf9f69d45268aeee727c71662634e02b8", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -63,8 +63,6 @@ CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n void\n CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n {\n-  fncontext fn = ctx->peek_fn ();\n-\n   auto op = expr.get_expr_type ();\n   auto lhs = CompileExpr::Compile (expr.get_left_expr ().get (), ctx);\n   auto rhs = CompileExpr::Compile (expr.get_right_expr ().get (), ctx);\n@@ -82,10 +80,7 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n \t= resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n \t\t\t\t     expr.get_left_expr ().get (),\n \t\t\t\t     expr.get_right_expr ().get ());\n-      auto assignment\n-\t= ctx->get_backend ()->expression_statement (fn.fndecl,\n-\t\t\t\t\t\t     compound_assignment);\n-      ctx->add_statement (assignment);\n+      ctx->add_statement (compound_assignment);\n \n       return;\n     }\n@@ -94,7 +89,7 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n     = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n \t\t\t\t\t\t\t     expr.get_locus ());\n   tree assignment\n-    = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, operator_expr,\n+    = ctx->get_backend ()->assignment_statement (lhs, operator_expr,\n \t\t\t\t\t\t expr.get_locus ());\n   ctx->add_statement (assignment);\n }\n@@ -304,8 +299,10 @@ CompileExpr::visit (HIR::MatchExpr &expr)\n \t{\n \t  tree result_reference\n \t    = ctx->get_backend ()->var_expression (tmp, arm_locus);\n-\t  tree assignment = ctx->get_backend ()->assignment_statement (\n-\t    fnctx.fndecl, result_reference, kase_expr_tree, arm_locus);\n+\t  tree assignment\n+\t    = ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t\t kase_expr_tree,\n+\t\t\t\t\t\t\t arm_locus);\n \t  ctx->add_statement (assignment);\n \t}\n "}, {"sha": "8aeb703aa0354886e0130afa459d62fb57ca1277", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -169,7 +169,6 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \n   void visit (HIR::AssignmentExpr &expr) override\n   {\n-    fncontext fn = ctx->peek_fn ();\n     auto lvalue = CompileExpr::Compile (expr.get_lhs (), ctx);\n     auto rvalue = CompileExpr::Compile (expr.get_rhs (), ctx);\n \n@@ -191,7 +190,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t\t       expr.get_rhs ()->get_locus ());\n \n     tree assignment\n-      = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n+      = ctx->get_backend ()->assignment_statement (lvalue, rvalue,\n \t\t\t\t\t\t   expr.get_locus ());\n \n     ctx->add_statement (assignment);\n@@ -594,9 +593,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n     tree loop_expr\n       = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n-    tree loop_stmt\n-      = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n-    ctx->add_statement (loop_stmt);\n+    ctx->add_statement (loop_expr);\n \n     if (tmp != NULL)\n       {\n@@ -645,9 +642,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n       = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n     tree exit_expr\n       = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n-    tree break_stmt\n-      = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n-    ctx->add_statement (break_stmt);\n+    ctx->add_statement (exit_expr);\n \n     tree code_block_stmt\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n@@ -659,14 +654,11 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \n     tree loop_expr\n       = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n-    tree loop_stmt\n-      = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n-    ctx->add_statement (loop_stmt);\n+    ctx->add_statement (loop_expr);\n   }\n \n   void visit (HIR::BreakExpr &expr) override\n   {\n-    fncontext fnctx = ctx->peek_fn ();\n     if (expr.has_break_expr ())\n       {\n \ttree compiled_expr\n@@ -676,8 +668,10 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \ttree result_reference = ctx->get_backend ()->var_expression (\n \t  loop_result_holder, expr.get_expr ()->get_locus ());\n \n-\ttree assignment = ctx->get_backend ()->assignment_statement (\n-\t  fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n+\ttree assignment\n+\t  = ctx->get_backend ()->assignment_statement (result_reference,\n+\t\t\t\t\t\t       compiled_expr,\n+\t\t\t\t\t\t       expr.get_locus ());\n \tctx->add_statement (assignment);\n       }\n \n@@ -721,9 +715,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \ttree exit_expr = ctx->get_backend ()->exit_expression (\n \t  ctx->get_backend ()->boolean_constant_expression (true),\n \t  expr.get_locus ());\n-\ttree break_stmt\n-\t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n-\tctx->add_statement (break_stmt);\n+\tctx->add_statement (exit_expr);\n       }\n   }\n \n@@ -761,9 +753,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t  }\n       }\n \n-    tree goto_label\n-      = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n-    ctx->add_statement (goto_label);\n+    translated = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n   }\n \n   void visit (HIR::BorrowExpr &expr) override;"}, {"sha": "0f69fb0515a03e2dba4f9cc985180ae8b25976ca", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -90,9 +90,8 @@ class CompileStmt : public HIRCompileBase, public HIR::HIRStmtVisitor\n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())\n       {\n-\ttree expr_stmt\n-\t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, init);\n-\tctx->add_statement (expr_stmt);\n+\t// FIXME this feels wrong\n+\tctx->add_statement (init);\n       }\n     else\n       {"}, {"sha": "9e2c5b32b1717e304b59530e32d4c3318346fa64", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -82,10 +82,8 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  tree compiled_stmt\n-\t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n-\t\t\t\t\t\t\t compiled_expr);\n-\t  ctx->add_statement (compiled_stmt);\n+\t  tree s = convert_to_void (compiled_expr, ICV_STATEMENT);\n+\t  ctx->add_statement (s);\n \t}\n     }\n \n@@ -98,19 +96,15 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \t{\n \t  if (result == nullptr)\n \t    {\n-\t      tree final_stmt\n-\t\t= ctx->get_backend ()->expression_statement (fnctx.fndecl,\n-\t\t\t\t\t\t\t     compiled_expr);\n-\t      ctx->add_statement (final_stmt);\n+\t      ctx->add_statement (compiled_expr);\n \t    }\n \t  else\n \t    {\n \t      tree result_reference = ctx->get_backend ()->var_expression (\n \t\tresult, expr.get_final_expr ()->get_locus ());\n \n \t      tree assignment\n-\t\t= ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n-\t\t\t\t\t\t\t     result_reference,\n+\t\t= ctx->get_backend ()->assignment_statement (result_reference,\n \t\t\t\t\t\t\t     compiled_expr,\n \t\t\t\t\t\t\t     expr.get_locus ());\n \t      ctx->add_statement (assignment);"}, {"sha": "1b0515e959c71ff2f6811882cd945d3dd9455071", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -17,6 +17,7 @@\n #include \"rust-constexpr.h\"\n #include \"rust-location.h\"\n #include \"rust-diagnostics.h\"\n+#include \"rust-tree.h\"\n \n #include \"fold-const.h\"\n #include \"realmpfr.h\"\n@@ -25,52 +26,6 @@\n #include \"gimplify.h\"\n #include \"tree-iterator.h\"\n \n-/* Returns true if NODE is a pointer.  */\n-#define TYPE_PTR_P(NODE) (TREE_CODE (NODE) == POINTER_TYPE)\n-\n-/* Returns true if NODE is a reference.  */\n-#define TYPE_REF_P(NODE) (TREE_CODE (NODE) == REFERENCE_TYPE)\n-\n-/* Returns true if NODE is a pointer or a reference.  */\n-#define INDIRECT_TYPE_P(NODE) (TYPE_PTR_P (NODE) || TYPE_REF_P (NODE))\n-\n-/* [basic.fundamental]\n-\n-   Types  bool, char, wchar_t, and the signed and unsigned integer types\n-   are collectively called integral types.\n-\n-   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n-   types as well, which is incorrect in C++.  Keep these checks in\n-   ascending code order.  */\n-#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n-  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n-\n-/* [basic.fundamental]\n-\n-   Integral and floating types are collectively called arithmetic\n-   types.\n-\n-   As a GNU extension, we also accept complex types.\n-\n-   Keep these checks in ascending code order.  */\n-#define ARITHMETIC_TYPE_P(TYPE)                                                \\\n-  (RS_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE                  \\\n-   || TREE_CODE (TYPE) == COMPLEX_TYPE)\n-\n-/* True iff TYPE is cv decltype(nullptr).  */\n-#define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n-\n-/* [basic.types]\n-\n-   Arithmetic types, enumeration types, pointer types,\n-   pointer-to-member types, and std::nullptr_t are collectively called\n-   scalar types.\n-\n-   Keep these checks in ascending code order.  */\n-#define SCALAR_TYPE_P(TYPE)                                                    \\\n-  (TREE_CODE (TYPE) == ENUMERAL_TYPE || ARITHMETIC_TYPE_P (TYPE)               \\\n-   || TYPE_PTR_P (TYPE) || NULLPTR_TYPE_P (TYPE))\n-\n namespace Rust {\n namespace Compile {\n "}, {"sha": "8e39408e2afbbc6a9461e48243965452b4cebd20", "filename": "gcc/rust/backend/rust-tree.cc", "status": "added", "additions": 659, "deletions": 0, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -0,0 +1,659 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tree.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"escaped_string.h\"\n+\n+namespace Rust {\n+\n+void\n+mark_exp_read (tree exp)\n+{\n+  if (exp == NULL)\n+    return;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case VAR_DECL:\n+      gcc_fallthrough ();\n+    case PARM_DECL:\n+      DECL_READ_P (exp) = 1;\n+      break;\n+    case ARRAY_REF:\n+    case COMPONENT_REF:\n+    case MODIFY_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    CASE_CONVERT:\n+    case ADDR_EXPR:\n+    case INDIRECT_REF:\n+    case FLOAT_EXPR:\n+    case NON_DEPENDENT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      mark_exp_read (TREE_OPERAND (exp, 0));\n+      break;\n+    case COMPOUND_EXPR:\n+      mark_exp_read (TREE_OPERAND (exp, 1));\n+      break;\n+    case COND_EXPR:\n+      if (TREE_OPERAND (exp, 1))\n+\tmark_exp_read (TREE_OPERAND (exp, 1));\n+      if (TREE_OPERAND (exp, 2))\n+\tmark_exp_read (TREE_OPERAND (exp, 2));\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+tree\n+convert_from_reference (tree val)\n+{\n+  if (TREE_TYPE (val) && TYPE_REF_P (TREE_TYPE (val)))\n+    {\n+      tree t = TREE_TYPE (TREE_TYPE (val));\n+      tree ref = build1 (INDIRECT_REF, t, val);\n+\n+      mark_exp_read (val);\n+\n+      TREE_SIDE_EFFECTS (ref)\n+\t= (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (val));\n+      val = ref;\n+    }\n+\n+  return val;\n+}\n+\n+tree\n+mark_use (tree expr, bool rvalue_p, bool read_p,\n+\t  location_t loc /* = UNKNOWN_LOCATION */,\n+\t  bool reject_builtin /* = true */)\n+{\n+#define RECUR(t) mark_use ((t), rvalue_p, read_p, loc, reject_builtin)\n+\n+  if (expr == NULL_TREE || error_operand_p (expr))\n+    return expr;\n+\n+  if (reject_builtin)\n+    return error_mark_node;\n+\n+  if (read_p)\n+    mark_exp_read (expr);\n+\n+  bool recurse_op[3] = {false, false, false};\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+    case NON_DEPENDENT_EXPR:\n+      recurse_op[0] = true;\n+      break;\n+    case COMPOUND_EXPR:\n+      recurse_op[1] = true;\n+      break;\n+    case COND_EXPR:\n+      recurse_op[2] = true;\n+      if (TREE_OPERAND (expr, 1))\n+\trecurse_op[1] = true;\n+      break;\n+    case INDIRECT_REF:\n+      if (REFERENCE_REF_P (expr))\n+\t{\n+\t  /* Try to look through the reference.  */\n+\t  tree ref = TREE_OPERAND (expr, 0);\n+\t  tree r = mark_rvalue_use (ref, loc, reject_builtin);\n+\t  if (r != ref)\n+\t    expr = convert_from_reference (r);\n+\t}\n+      break;\n+\n+    case VIEW_CONVERT_EXPR:\n+      if (location_wrapper_p (expr))\n+\t{\n+\t  loc = EXPR_LOCATION (expr);\n+\t  tree op = TREE_OPERAND (expr, 0);\n+\t  tree nop = RECUR (op);\n+\t  if (nop == error_mark_node)\n+\t    return error_mark_node;\n+\t  else if (op == nop)\n+\t    /* No change.  */;\n+\t  else if (DECL_P (nop) || CONSTANT_CLASS_P (nop))\n+\t    {\n+\t      /* Reuse the location wrapper.  */\n+\t      TREE_OPERAND (expr, 0) = nop;\n+\t      /* If we're replacing a DECL with a constant, we also need to\n+\t\t change the TREE_CODE of the location wrapper.  */\n+\t      if (rvalue_p)\n+\t\tTREE_SET_CODE (expr, NON_LVALUE_EXPR);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Drop the location wrapper.  */\n+\t      expr = nop;\n+\t      protected_set_expr_location (expr, loc);\n+\t    }\n+\t  return expr;\n+\t}\n+      gcc_fallthrough ();\n+    CASE_CONVERT:\n+      recurse_op[0] = true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (int i = 0; i < 3; ++i)\n+    if (recurse_op[i])\n+      {\n+\ttree op = TREE_OPERAND (expr, i);\n+\top = RECUR (op);\n+\tif (op == error_mark_node)\n+\t  return error_mark_node;\n+\tTREE_OPERAND (expr, i) = op;\n+      }\n+\n+  return expr;\n+#undef RECUR\n+}\n+\n+tree\n+mark_rvalue_use (tree e, location_t loc /* = UNKNOWN_LOCATION */,\n+\t\t bool reject_builtin /* = true */)\n+{\n+  return mark_use (e, true, true, loc, reject_builtin);\n+}\n+\n+tree\n+mark_lvalue_use (tree expr)\n+{\n+  return mark_use (expr, false, true, input_location, false);\n+}\n+\n+tree\n+mark_lvalue_use_nonread (tree expr)\n+{\n+  return mark_use (expr, false, false, input_location, false);\n+}\n+\n+tree\n+mark_discarded_use (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return expr;\n+\n+  STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case COND_EXPR:\n+      TREE_OPERAND (expr, 2) = mark_discarded_use (TREE_OPERAND (expr, 2));\n+      gcc_fallthrough ();\n+    case COMPOUND_EXPR:\n+      TREE_OPERAND (expr, 1) = mark_discarded_use (TREE_OPERAND (expr, 1));\n+      return expr;\n+\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case INDIRECT_REF:\n+    case MEMBER_REF:\n+      break;\n+    default:\n+      if (DECL_P (expr))\n+\tbreak;\n+      else\n+\treturn expr;\n+    }\n+\n+  return mark_use (expr, true, true, input_location, false);\n+}\n+\n+tree\n+convert_to_void (tree expr, impl_conv_void implicit)\n+{\n+  location_t loc = expr_loc_or_input_loc (expr);\n+  if (expr == error_mark_node || TREE_TYPE (expr) == error_mark_node)\n+    return error_mark_node;\n+\n+  expr = mark_discarded_use (expr);\n+  if (implicit == ICV_CAST)\n+    /* An explicit cast to void avoids all -Wunused-but-set* warnings.  */\n+    mark_exp_read (expr);\n+\n+  if (!TREE_TYPE (expr))\n+    return expr;\n+\n+  if (VOID_TYPE_P (TREE_TYPE (expr)))\n+    return expr;\n+  switch (TREE_CODE (expr))\n+    {\n+      case COND_EXPR: {\n+\t/* The two parts of a cond expr might be separate lvalues.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree op2 = TREE_OPERAND (expr, 2);\n+\tbool side_effects\n+\t  = ((op1 && TREE_SIDE_EFFECTS (op1)) || TREE_SIDE_EFFECTS (op2));\n+\ttree new_op1, new_op2;\n+\tnew_op1 = NULL_TREE;\n+\tif (implicit != ICV_CAST && !side_effects)\n+\t  {\n+\t    if (op1)\n+\t      new_op1 = convert_to_void (op1, ICV_SECOND_OF_COND);\n+\t    new_op2 = convert_to_void (op2, ICV_THIRD_OF_COND);\n+\t  }\n+\telse\n+\t  {\n+\t    if (op1)\n+\t      new_op1 = convert_to_void (op1, ICV_CAST);\n+\t    new_op2 = convert_to_void (op2, ICV_CAST);\n+\t  }\n+\n+\texpr = build3_loc (loc, COND_EXPR, TREE_TYPE (new_op2),\n+\t\t\t   TREE_OPERAND (expr, 0), new_op1, new_op2);\n+\tbreak;\n+      }\n+\n+      case COMPOUND_EXPR: {\n+\t/* The second part of a compound expr contains the value.  */\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree new_op1;\n+\tif (implicit != ICV_CAST\n+\t    && !warning_suppressed_p (expr /* What warning? */))\n+\t  new_op1 = convert_to_void (op1, ICV_RIGHT_OF_COMMA);\n+\telse\n+\t  new_op1 = convert_to_void (op1, ICV_CAST);\n+\n+\tif (new_op1 != op1)\n+\t  {\n+\t    tree t = build2_loc (loc, COMPOUND_EXPR, TREE_TYPE (new_op1),\n+\t\t\t\t TREE_OPERAND (expr, 0), new_op1);\n+\t    expr = t;\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+      /* These have already decayed to rvalue.  */\n+      break;\n+\n+    case CALL_EXPR:\n+      maybe_warn_nodiscard (expr, implicit);\n+      break;\n+\n+      case INDIRECT_REF: {\n+\ttree type = TREE_TYPE (expr);\n+\tint is_reference = TYPE_REF_P (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\tint is_volatile = TYPE_VOLATILE (type);\n+\tint is_complete = COMPLETE_TYPE_P (type);\n+\n+\t/* Can't load the value if we don't know the type.  */\n+\tif (is_volatile && !is_complete)\n+\t  {\n+\t    switch (implicit)\n+\t      {\n+\t      case ICV_CAST:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"conversion to void will not access \"\n+\t\t\t    \"object of incomplete type %qT\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in second operand \"\n+\t\t\t    \"of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in third operand \"\n+\t\t\t    \"of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in right operand of \"\n+\t\t\t    \"comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in left operand of \"\n+\t\t\t    \"comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in statement\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"incomplete type %qT in for increment \"\n+\t\t\t    \"expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\t/* Don't load the value if this is an implicit dereference, or if\n+\t   the type needs to be handled by ctors/dtors.  */\n+\telse if (is_volatile && is_reference)\n+\t  {\n+\t    switch (implicit)\n+\t      {\n+\t      case ICV_CAST:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"conversion to void will not access \"\n+\t\t\t    \"object of type %qT\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in second operand of \"\n+\t\t\t    \"conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in third operand of \"\n+\t\t\t    \"conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in right operand of \"\n+\t\t\t    \"comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in left operand of comma \"\n+\t\t\t    \"operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in statement\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"implicit dereference will not access \"\n+\t\t\t    \"object of type %qT in for increment expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\telse if (is_volatile && TREE_ADDRESSABLE (type))\n+\t  {\n+\t    switch (implicit)\n+\t      {\n+\t      case ICV_CAST:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"conversion to void will not access \"\n+\t\t\t    \"object of non-trivially-copyable type %qT\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_SECOND_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in second \"\n+\t\t\t    \"operand of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_OF_COND:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in third \"\n+\t\t\t    \"operand of conditional expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_RIGHT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in right \"\n+\t\t\t    \"operand of comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_LEFT_OF_COMMA:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in left \"\n+\t\t\t    \"operand of comma operator\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_STATEMENT:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in statement\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      case ICV_THIRD_IN_FOR:\n+\t\twarning_at (loc, 0,\n+\t\t\t    \"indirection will not access object of \"\n+\t\t\t    \"non-trivially-copyable type %qT in for \"\n+\t\t\t    \"increment expression\",\n+\t\t\t    type);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\tif (is_reference || !is_volatile || !is_complete\n+\t    || TREE_ADDRESSABLE (type))\n+\t  {\n+\t    /* Emit a warning (if enabled) when the \"effect-less\" INDIRECT_REF\n+\t       operation is stripped off. Note that we don't warn about\n+\t       - an expression with TREE_NO_WARNING set. (For an example of\n+\t\t such expressions, see build_over_call in call.cc.)\n+\t       - automatic dereferencing of references, since the user cannot\n+\t\t control it. (See also warn_if_unused_value() in c-common.cc.)\n+\t     */\n+\t    if (warn_unused_value && implicit != ICV_CAST\n+\t\t&& !warning_suppressed_p (expr, OPT_Wunused_value)\n+\t\t&& !is_reference)\n+\t      warning_at (loc, OPT_Wunused_value, \"value computed is not used\");\n+\t    expr = TREE_OPERAND (expr, 0);\n+\t    if (TREE_CODE (expr) == CALL_EXPR)\n+\t      maybe_warn_nodiscard (expr, implicit);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+      case VAR_DECL: {\n+\t/* External variables might be incomplete.  */\n+\ttree type = TREE_TYPE (expr);\n+\tint is_complete = COMPLETE_TYPE_P (type);\n+\n+\tif (TYPE_VOLATILE (type) && !is_complete)\n+\t  switch (implicit)\n+\t    {\n+\t    case ICV_CAST:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"conversion to void will not access \"\n+\t\t\t  \"object %qE of incomplete type %qT\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_SECOND_OF_COND:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in second operand of \"\n+\t\t\t  \"conditional expression\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_THIRD_OF_COND:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in third operand of \"\n+\t\t\t  \"conditional expression\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_RIGHT_OF_COMMA:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in right operand of comma operator\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_LEFT_OF_COMMA:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in left operand of comma operator\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_STATEMENT:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in statement\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    case ICV_THIRD_IN_FOR:\n+\t      warning_at (loc, 0,\n+\t\t\t  \"variable %qE of incomplete type %qT will \"\n+\t\t\t  \"not be accessed in for increment expression\",\n+\t\t\t  expr, type);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\tbreak;\n+      }\n+\n+    default:;\n+    }\n+\n+  if (!TREE_SIDE_EFFECTS (expr))\n+    expr = void_node;\n+\n+  return expr;\n+}\n+\n+void\n+maybe_warn_nodiscard (tree expr, impl_conv_void implicit)\n+{\n+  tree call = expr;\n+  if (TREE_CODE (expr) == TARGET_EXPR)\n+    call = TARGET_EXPR_INITIAL (expr);\n+\n+  location_t loc = expr_loc_or_input_loc (call);\n+  tree callee = CALL_EXPR_FN (call);\n+  if (!callee)\n+    return;\n+\n+  tree type = TREE_TYPE (callee);\n+  if (INDIRECT_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+\n+  tree rettype = TREE_TYPE (type);\n+  tree fn = get_fndecl_from_callee (callee);\n+  tree attr;\n+  if (implicit != ICV_CAST && fn\n+      && (attr = lookup_attribute (\"nodiscard\", DECL_ATTRIBUTES (fn))))\n+    {\n+      escaped_string msg;\n+      tree args = TREE_VALUE (attr);\n+      if (args)\n+\tmsg.escape (TREE_STRING_POINTER (TREE_VALUE (args)));\n+      const char *format\n+\t= (msg ? G_ (\"ignoring return value of %qD, that must be used: %<%s%>\")\n+\t       : G_ (\"ignoring return value of %qD, that must be used\"));\n+      const char *raw_msg = msg ? (const char *) msg : \"\";\n+      auto_diagnostic_group d;\n+      if (warning_at (loc, OPT_Wunused_result, format, fn, raw_msg))\n+\tinform (DECL_SOURCE_LOCATION (fn), \"declared here\");\n+    }\n+  else if (implicit != ICV_CAST\n+\t   && (attr\n+\t       = lookup_attribute (\"nodiscard\", TYPE_ATTRIBUTES (rettype))))\n+    {\n+      escaped_string msg;\n+      tree args = TREE_VALUE (attr);\n+      if (args)\n+\tmsg.escape (TREE_STRING_POINTER (TREE_VALUE (args)));\n+      const char *format\n+\t= (msg ? G_ (\n+\t     \"ignoring returned value of type %qT, that must be used: %<%s%>\")\n+\t       : G_ (\"ignoring returned value of type %qT, that must be used\"));\n+      const char *raw_msg = msg ? (const char *) msg : \"\";\n+      auto_diagnostic_group d;\n+      if (warning_at (loc, OPT_Wunused_result, format, rettype, raw_msg))\n+\t{\n+\t  if (fn)\n+\t    inform (DECL_SOURCE_LOCATION (fn), \"in call to %qD, declared here\",\n+\t\t    fn);\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (rettype)),\n+\t\t  \"%qT declared here\", rettype);\n+\t}\n+    }\n+}\n+\n+location_t\n+expr_loc_or_loc (const_tree t, location_t or_loc)\n+{\n+  location_t loc = EXPR_LOCATION (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n+location_t\n+expr_loc_or_input_loc (const_tree t)\n+{\n+  return expr_loc_or_loc (t, input_location);\n+}\n+\n+// FN is the callee of a CALL_EXPR or AGGR_INIT_EXPR; return the FUNCTION_DECL\n+// if we can.\n+tree\n+get_fndecl_from_callee (tree fn)\n+{\n+  if (fn == NULL_TREE)\n+    return fn;\n+  if (TREE_CODE (fn) == FUNCTION_DECL)\n+    return fn;\n+  tree type = TREE_TYPE (fn);\n+  if (type == NULL_TREE || !INDIRECT_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  STRIP_NOPS (fn);\n+  if (TREE_CODE (fn) == ADDR_EXPR || TREE_CODE (fn) == FDESC_EXPR)\n+    fn = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fn) == FUNCTION_DECL)\n+    return fn;\n+  return NULL_TREE;\n+}\n+\n+} // namespace Rust"}, {"sha": "c21bf4b0509e12b874b5d29786cb71a32abd19c7", "filename": "gcc/rust/backend/rust-tree.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -0,0 +1,182 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TREE\n+#define RUST_TREE\n+\n+#include \"rust-system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+\n+/* Returns true if NODE is a pointer.  */\n+#define TYPE_PTR_P(NODE) (TREE_CODE (NODE) == POINTER_TYPE)\n+\n+/* Returns true if NODE is a reference.  */\n+#define TYPE_REF_P(NODE) (TREE_CODE (NODE) == REFERENCE_TYPE)\n+\n+/* Returns true if NODE is a pointer or a reference.  */\n+#define INDIRECT_TYPE_P(NODE) (TYPE_PTR_P (NODE) || TYPE_REF_P (NODE))\n+\n+/* [basic.fundamental]\n+\n+   Types  bool, char, wchar_t, and the signed and unsigned integer types\n+   are collectively called integral types.\n+\n+   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n+   types as well, which is incorrect in C++.  Keep these checks in\n+   ascending code order.  */\n+#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n+\n+/* [basic.fundamental]\n+\n+   Integral and floating types are collectively called arithmetic\n+   types.\n+\n+   As a GNU extension, we also accept complex types.\n+\n+   Keep these checks in ascending code order.  */\n+#define ARITHMETIC_TYPE_P(TYPE)                                                \\\n+  (RS_INTEGRAL_TYPE_P (TYPE) || TREE_CODE (TYPE) == REAL_TYPE                  \\\n+   || TREE_CODE (TYPE) == COMPLEX_TYPE)\n+\n+/* True iff TYPE is cv decltype(nullptr).  */\n+#define NULLPTR_TYPE_P(TYPE) (TREE_CODE (TYPE) == NULLPTR_TYPE)\n+\n+/* [basic.types]\n+\n+   Arithmetic types, enumeration types, pointer types,\n+   pointer-to-member types, and std::nullptr_t are collectively called\n+   scalar types.\n+\n+   Keep these checks in ascending code order.  */\n+#define SCALAR_TYPE_P(TYPE)                                                    \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE || ARITHMETIC_TYPE_P (TYPE)               \\\n+   || TYPE_PTR_P (TYPE) || NULLPTR_TYPE_P (TYPE))\n+\n+/* True if NODE is an implicit INDIRECT_REF from convert_from_reference.  */\n+#define REFERENCE_REF_P(NODE)                                                  \\\n+  (INDIRECT_REF_P (NODE) && TREE_TYPE (TREE_OPERAND (NODE, 0))                 \\\n+   && TYPE_REF_P (TREE_TYPE (TREE_OPERAND ((NODE), 0))))\n+\n+namespace Rust {\n+\n+// forked from gcc/cp/cvt.cc convert_to_void\n+//\n+// When an expression is used in a void context, its value is discarded and\n+// no lvalue-rvalue and similar conversions happen [expr.static.cast/4,\n+// stmt.expr/1, expr.comma/1].  This permits dereferencing an incomplete type\n+// in a void context. The C++ standard does not define what an `access' to an\n+// object is, but there is reason to believe that it is the lvalue to rvalue\n+// conversion -- if it were not, `*&*p = 1' would violate [expr]/4 in that it\n+// accesses `*p' not to calculate the value to be stored. But, dcl.type.cv/8\n+// indicates that volatile semantics should be the same between C and C++\n+// where ever possible. C leaves it implementation defined as to what\n+// constitutes an access to a volatile. So, we interpret `*vp' as a read of\n+// the volatile object `vp' points to, unless that is an incomplete type. For\n+// volatile references we do not do this interpretation, because that would\n+// make it impossible to ignore the reference return value from functions. We\n+// issue warnings in the confusing cases.\n+//\n+// The IMPLICIT is ICV_CAST when the user is explicitly converting an\n+// expression to void via a cast. If an expression is being implicitly\n+// converted, IMPLICIT indicates the context of the implicit conversion.\n+\n+/* Possible cases of implicit or explicit bad conversions to void. */\n+enum impl_conv_void\n+{\n+  ICV_CAST,\t      /* (explicit) conversion to void */\n+  ICV_SECOND_OF_COND, /* second operand of conditional expression */\n+  ICV_THIRD_OF_COND,  /* third operand of conditional expression */\n+  ICV_RIGHT_OF_COMMA, /* right operand of comma operator */\n+  ICV_LEFT_OF_COMMA,  /* left operand of comma operator */\n+  ICV_STATEMENT,      /* statement */\n+  ICV_THIRD_IN_FOR    /* for increment expression */\n+};\n+\n+extern tree\n+convert_to_void (tree expr, impl_conv_void implicit);\n+\n+// The lvalue-to-rvalue conversion (7.1) is applied if and only if the\n+// expression is a glvalue of volatile-qualified type and it is one of the\n+// following:\n+// * ( expression ), where expression is one of these expressions,\n+// * id-expression (8.1.4),\n+// * subscripting (8.2.1),\n+// * class member access (8.2.5),\n+// * indirection (8.3.1),\n+// * pointer-to-member operation (8.5),\n+// * conditional expression (8.16) where both the second and the third\n+//   operands are one of these expressions, or\n+// * comma expression (8.19) where the right operand is one of these\n+//   expressions.\n+extern tree\n+mark_discarded_use (tree expr);\n+\n+// Mark EXP as read, not just set, for set but not used -Wunused warning\n+// purposes.\n+extern void\n+mark_exp_read (tree exp);\n+\n+// We've seen an actual use of EXPR.  Possibly replace an outer variable\n+// reference inside with its constant value or a lambda capture.\n+extern tree\n+mark_use (tree expr, bool rvalue_p, bool read_p, location_t loc,\n+\t  bool reject_builtin);\n+\n+// Called whenever the expression EXPR is used in an rvalue context.\n+// When REJECT_BUILTIN is true the expression is checked to make sure\n+// it doesn't make it possible to obtain the address of a GCC built-in\n+// function with no library fallback (or any of its bits, such as in\n+// a conversion to bool).\n+extern tree\n+mark_rvalue_use (tree e, location_t loc /* = UNKNOWN_LOCATION */,\n+\t\t bool reject_builtin /* = true */);\n+\n+// Called whenever an expression is used in an lvalue context.\n+extern tree\n+mark_lvalue_use (tree expr);\n+\n+// As above, but don't consider this use a read.\n+extern tree\n+mark_lvalue_use_nonread (tree expr);\n+\n+// We are using a reference VAL for its value. Bash that reference all the way\n+// down to its lowest form.\n+extern tree\n+convert_from_reference (tree val);\n+\n+// Subroutine of convert_to_void.  Warn if we're discarding something with\n+// attribute [[nodiscard]].\n+extern void\n+maybe_warn_nodiscard (tree expr, impl_conv_void implicit);\n+\n+extern location_t\n+expr_loc_or_loc (const_tree t, location_t or_loc);\n+\n+extern location_t\n+expr_loc_or_input_loc (const_tree t);\n+\n+// FN is the callee of a CALL_EXPR or AGGR_INIT_EXPR; return the FUNCTION_DECL\n+// if we can.\n+extern tree\n+get_fndecl_from_callee (tree fn);\n+\n+} // namespace Rust\n+\n+#endif // RUST_TREE"}, {"sha": "25e568162c44d527e4d2b73b006ccdc7bb40b07b", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -2369,8 +2369,11 @@ class TraitItemFunc : public TraitItem\n     return TraitItemKind::FUNC;\n   }\n \n-  AST::AttrVec &get_outer_attrs () { return outer_attrs; }\n-  const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n+  AST::AttrVec &get_outer_attrs () override final { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const override final\n+  {\n+    return outer_attrs;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -2452,6 +2455,12 @@ class TraitItemConst : public TraitItem\n     return TraitItemKind::CONST;\n   }\n \n+  AST::AttrVec &get_outer_attrs () override final { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const override final\n+  {\n+    return outer_attrs;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -2533,6 +2542,12 @@ class TraitItemType : public TraitItem\n     return TraitItemKind::TYPE;\n   }\n \n+  AST::AttrVec &get_outer_attrs () override final { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const override final\n+  {\n+    return outer_attrs;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override\n@@ -2821,6 +2836,8 @@ class ExternalItem\n \n   Identifier get_item_name () const { return item_name; }\n \n+  AST::AttrVec &get_outer_attrs () { return outer_attrs; }\n+\n protected:\n   ExternalItem (Analysis::NodeMapping mappings, Identifier item_name,\n \t\tVisibility vis, AST::AttrVec outer_attrs, Location locus)"}, {"sha": "fda7e1d5d9df8b2feddde1a0f45ea472e4868104", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -723,6 +723,9 @@ class TraitItem\n   const Analysis::NodeMapping get_mappings () const { return mappings; }\n \n   virtual TraitItemKind get_item_kind () const = 0;\n+\n+  virtual AST::AttrVec &get_outer_attrs () = 0;\n+  virtual const AST::AttrVec &get_outer_attrs () const = 0;\n };\n \n class ImplItem"}, {"sha": "794a667c0eb63fd58a2f3840f94a3c059d259b48", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -34,6 +34,14 @@ L\n Rust Joined Separate\n ; Not documented\n \n+Wall\n+Rust\n+; Documented in c.opt\n+\n+Wunused-result\n+Rust Var(warn_unused_result) Init(1) Warning\n+Warn if a caller of a function, marked with attribute warn_unused_result, does not use its return value.\n+\n frust-crate=\n Rust Joined RejectNegative\n -frust-crate=<name>             Set the crate name for the compilation"}, {"sha": "fca09b2bd68dcc209d9bab5b76fbea8d026bea86", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -292,16 +292,13 @@ class Backend\n \n   // Statements.\n \n-  // Create an expression statement within the specified function.\n-  virtual tree expression_statement (tree, tree) = 0;\n-\n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n   virtual tree init_statement (tree, Bvariable *var, tree init) = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual tree assignment_statement (tree, tree lhs, tree rhs, Location) = 0;\n+  virtual tree assignment_statement (tree lhs, tree rhs, Location) = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return."}, {"sha": "dfdfe8a5d2634dbefb2af0d7dad9581240ddb9bb", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -249,11 +249,9 @@ class Gcc_backend : public Backend\n \n   // Statements.\n \n-  tree expression_statement (tree, tree);\n-\n   tree init_statement (tree, Bvariable *var, tree init);\n \n-  tree assignment_statement (tree, tree lhs, tree rhs, Location);\n+  tree assignment_statement (tree lhs, tree rhs, Location);\n \n   tree return_statement (tree, const std::vector<tree> &, Location);\n \n@@ -1837,14 +1835,6 @@ Gcc_backend::call_expression (tree, // containing fcn for call\n   return ret;\n }\n \n-// An expression as a statement.\n-\n-tree\n-Gcc_backend::expression_statement (tree, tree expr)\n-{\n-  return expr;\n-}\n-\n // Variable initialization.\n \n tree\n@@ -1880,8 +1870,7 @@ Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n // Assignment.\n \n tree\n-Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n-\t\t\t\t   Location location)\n+Gcc_backend::assignment_statement (tree lhs, tree rhs, Location location)\n {\n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n@@ -1896,8 +1885,7 @@ Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n       || int_size_in_bytes (TREE_TYPE (lhs)) == 0\n       || TREE_TYPE (rhs) == void_type_node\n       || int_size_in_bytes (TREE_TYPE (rhs)) == 0)\n-    return this->compound_statement (this->expression_statement (bfn, lhs),\n-\t\t\t\t     this->expression_statement (bfn, rhs));\n+    return this->compound_statement (lhs, rhs);\n \n   rhs = this->convert_tree (TREE_TYPE (lhs), rhs, location);\n \n@@ -2527,8 +2515,7 @@ Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n   if (init_tree != NULL_TREE\n       && (this->type_size (type_tree) == 0\n \t  || TREE_TYPE (init_tree) == void_type_node))\n-    *pstatement = this->compound_statement (\n-      this->expression_statement (fndecl, init_tree), *pstatement);\n+    *pstatement = this->compound_statement (init_tree, *pstatement);\n \n   return new Bvariable (var);\n }"}, {"sha": "80fd0ecc748d2b17542ee2785513f44c0a23b854", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -404,8 +404,6 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::ConstantItem &constant) override\n   {\n-    // resolved_trait_item = trait_reference.lookup_trait_item (\n-    //   constant.get_identifier (), TraitItemReference::TraitItemType::CONST);\n     trait_reference.lookup_trait_item_by_type (\n       constant.get_identifier (), TraitItemReference::TraitItemType::CONST,\n       &resolved_trait_item);\n@@ -428,6 +426,11 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     if (resolved_trait_item->is_error ())\n       return;\n \n+    // merge the attributes\n+    const HIR::TraitItem *hir_trait_item\n+      = resolved_trait_item->get_hir_trait_item ();\n+    merge_attributes (constant.get_outer_attrs (), *hir_trait_item);\n+\n     // check the types are compatible\n     if (!resolved_trait_item->get_tyty ()->can_eq (lookup, true))\n       {\n@@ -467,6 +470,11 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     if (resolved_trait_item->is_error ())\n       return;\n \n+    // merge the attributes\n+    const HIR::TraitItem *hir_trait_item\n+      = resolved_trait_item->get_hir_trait_item ();\n+    merge_attributes (type.get_outer_attrs (), *hir_trait_item);\n+\n     // check the types are compatible\n     if (!resolved_trait_item->get_tyty ()->can_eq (lookup, true))\n       {\n@@ -515,6 +523,11 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n     if (resolved_trait_item->is_error ())\n       return;\n \n+    // merge the attributes\n+    const HIR::TraitItem *hir_trait_item\n+      = resolved_trait_item->get_hir_trait_item ();\n+    merge_attributes (function.get_outer_attrs (), *hir_trait_item);\n+\n     rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n     rust_assert (resolved_trait_item->get_tyty ()->get_kind ()\n \t\t == TyTy::TypeKind::FNDEF);\n@@ -557,6 +570,18 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n       }\n   }\n \n+protected:\n+  // this allows us to inherit the must_use specified on a trait definition onto\n+  // its implementation\n+  void merge_attributes (AST::AttrVec &impl_item_attrs,\n+\t\t\t const HIR::TraitItem &trait_item)\n+  {\n+    for (const auto &attr : trait_item.get_outer_attrs ())\n+      {\n+\timpl_item_attrs.push_back (attr);\n+      }\n+  }\n+\n private:\n   TypeCheckImplItemWithTrait (\n     HIR::ImplBlock *parent, TyTy::BaseType *self,"}, {"sha": "4f3bd0b36497d8dd7faef8db43aae1ac3ab648f9", "filename": "gcc/rust/util/rust-attributes.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Futil%2Frust-attributes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Frust%2Futil%2Frust-attributes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.cc?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -22,10 +22,10 @@ namespace Rust {\n namespace Analysis {\n \n // https://doc.rust-lang.org/stable/nightly-rustc/src/rustc_feature/builtin_attrs.rs.html#256\n-static const BuiltinAttrDefinition __definitions[] = {\n-  {\"inline\", CODE_GENERATION}, {\"cfg\", EXPANSION},     {\"cfg_attr\", EXPANSION},\n-  {\"allow\", STATIC_ANALYSIS},  {\"lang\", HIR_LOWERING},\n-};\n+static const BuiltinAttrDefinition __definitions[]\n+  = {{\"inline\", CODE_GENERATION}, {\"cfg\", EXPANSION},\n+     {\"cfg_attr\", EXPANSION},\t  {\"allow\", STATIC_ANALYSIS},\n+     {\"lang\", HIR_LOWERING},\t  {\"must_use\", STATIC_ANALYSIS}};\n \n BuiltinAttributeMappings *\n BuiltinAttributeMappings::get ()"}, {"sha": "95a6657c8c111495e8e2d987e95b766394e1a384", "filename": "gcc/testsuite/rust/compile/torture/must_use1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmust_use1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmust_use1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmust_use1.rs?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -0,0 +1,16 @@\n+#[must_use = \"TEST 1\"]\n+fn test1() -> i32 {\n+    123\n+}\n+\n+#[must_use = \"TEST 2\"]\n+fn test2() -> i32 {\n+    456\n+}\n+\n+fn main() {\n+    let _a = test1();\n+\n+    test2();\n+    // { dg-warning \"ignoring return value of\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "4c6d660131143b0b6743e893303eeebe250d879c", "filename": "gcc/testsuite/rust/compile/torture/must_use2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmust_use2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89c8ccf3237e66029125c0fe007297bb86eca74/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmust_use2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmust_use2.rs?ref=d89c8ccf3237e66029125c0fe007297bb86eca74", "patch": "@@ -0,0 +1,17 @@\n+trait A {\n+    #[must_use]\n+    fn test() -> i32;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+struct S;\n+impl A for S {\n+    fn test() -> i32 {\n+        123\n+    }\n+}\n+\n+fn main() {\n+    S::test();\n+    // { dg-warning \"ignoring return value of\" \"\" { target *-*-* } .-1 }\n+}"}]}