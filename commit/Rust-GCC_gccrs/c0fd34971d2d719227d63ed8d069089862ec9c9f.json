{"sha": "c0fd34971d2d719227d63ed8d069089862ec9c9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBmZDM0OTcxZDJkNzE5MjI3ZDYzZWQ4ZDA2OTA4OTg2MmVjOWM5Zg==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2012-07-30T02:30:52Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2012-07-30T02:30:52Z"}, "message": "gengtype.c (adjust_field_type): Diagnose duplicate \"length\" option applications and option being applied to...\n\ngcc:\n2012-07-27  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\t    Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* gengtype.c (adjust_field_type): Diagnose duplicate \"length\"\n\toption applications and option being applied to arrays of atomic\n\ttypes.\n\t(walk_type): Allow \"atomic\" option on strings too.\n\t* dwarf2out.h (struct dw_vec_struct): Use the \"atomic\" GTY option\n\tfor the array field.\n\t* vec.h: Describe the atomic object \"A\" type of the macros in\n\tthe header comment.\n\t(VEC_T_GTY_ATOMIC, DEF_VEC_A, DEF_VEC_ALLOC_A): Define.\n\t* emit-rtl.c (locations_locators_vals): use the atomic object\n\tvector.\n\t* doc/gty.texi: Clarify that GTY option \"length\" is only for\n\tarrays of non-atomic objects.  Fix typo in the description of the\n\t\"atomic\" option.\n\ngcc/java:\n2012-07-24  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* jcf.h (CPool): Use the \"atomic\" GTY option for the tags field.\n\t(bootstrap_method): Likewise for the bootstrap_arguments field.\n\nlibcpp:\n2012-07-24  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* include/line-map.h (line_map_macro): Use the \"atomic\" GTY option\n\tfor the macro_locations field.\n\nCo-Authored-By: Steven Bosscher <steven@gcc.gnu.org>\n\nFrom-SVN: r189951", "tree": {"sha": "17345bf96a8e18558d9570c89caead4ccc1f2122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17345bf96a8e18558d9570c89caead4ccc1f2122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0fd34971d2d719227d63ed8d069089862ec9c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0fd34971d2d719227d63ed8d069089862ec9c9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0fd34971d2d719227d63ed8d069089862ec9c9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0fd34971d2d719227d63ed8d069089862ec9c9f/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c5f95e6ec470584f537c632200b92c9feb5f7f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c5f95e6ec470584f537c632200b92c9feb5f7f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c5f95e6ec470584f537c632200b92c9feb5f7f3"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "ec3d4d0a653fc35f9cbbdc8989fef048d5fe40e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -1,3 +1,21 @@\n+2012-07-30  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\t    Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* gengtype.c (adjust_field_type): Diagnose duplicate \"length\"\n+\toption applications and option being applied to arrays of atomic\n+\ttypes.\n+\t(walk_type): Allow \"atomic\" option on strings too.\n+\t* dwarf2out.h (struct dw_vec_struct): Use the \"atomic\" GTY option\n+\tfor the array field.\n+\t* vec.h: Describe the atomic object \"A\" type of the macros in\n+\tthe header comment.\n+\t(VEC_T_GTY_ATOMIC, DEF_VEC_A, DEF_VEC_ALLOC_A): Define.\n+\t* emit-rtl.c (locations_locators_vals): use the atomic object\n+\tvector.\n+\t* doc/gty.texi: Clarify that GTY option \"length\" is only for\n+\tarrays of non-atomic objects.  Fix typo in the description of the\n+\t\"atomic\" option.\n+\n 2012-07-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_avoid_lea_for_addr): Handle"}, {"sha": "ad0423abc4210f7259ad0343d490229d00492bc6", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -134,8 +134,8 @@ The available options are:\n @item length (\"@var{expression}\")\n \n There are two places the type machinery will need to be explicitly told\n-the length of an array.  The first case is when a structure ends in a\n-variable-length array, like this:\n+the length of an array of non-atomic objects.  The first case is when a\n+structure ends in a variable-length array, like this:\n @smallexample\n struct GTY(()) rtvec_def @{\n   int num_elem;         /* @r{number of elements} */\n@@ -163,6 +163,11 @@ This second use of @code{length} also works on global variables, like:\n static GTY((length(\"reg_known_value_size\"))) rtx *reg_known_value;\n @end verbatim\n \n+Note that the @code{length} option is only meant for use with arrays of\n+non-atomic objects, that is, objects that contain pointers pointing to\n+other GTY-managed objects.  For other GC-allocated arrays and strings\n+you should use @code{atomic}.\n+\n @findex skip\n @item skip\n \n@@ -411,7 +416,7 @@ Here is an example of how to use it:\n @smallexample\n struct GTY(()) my_struct @{\n   int number_of_elements;\n-  unsigned int GTY ((atomic)) * elements;\n+  unsigned int * GTY ((atomic)) elements;\n @};\n @end smallexample\n In this case, @code{elements} is a pointer under GC, and the memory it"}, {"sha": "a9952910e3862f832b0e5da02d01b1268cf0c839", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -160,7 +160,7 @@ enum dw_val_class\n /* Describe a floating point constant value, or a vector constant value.  */\n \n typedef struct GTY(()) dw_vec_struct {\n-  unsigned char * GTY((length (\"%h.length\"))) array;\n+  unsigned char * GTY((atomic)) array;\n   unsigned length;\n   unsigned elt_size;\n }"}, {"sha": "e0c4979246301e72fbe1f1da64461263f078c8c1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -5910,8 +5910,8 @@ gen_hard_reg_clobber (enum machine_mode mode, unsigned int regno)\n static VEC(int,heap) *block_locators_locs;\n static GTY(()) VEC(tree,gc) *block_locators_blocks;\n static VEC(int,heap) *locations_locators_locs;\n-DEF_VEC_O(location_t);\n-DEF_VEC_ALLOC_O(location_t,heap);\n+DEF_VEC_A(location_t);\n+DEF_VEC_ALLOC_A(location_t,heap);\n static VEC(location_t,heap) *locations_locators_vals;\n int prologue_locator;\n int epilogue_locator;"}, {"sha": "ecb8378207ebb0b7f5ca15e26821a17a4d1c4b75", "filename": "gcc/gengtype.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -1256,7 +1256,17 @@ adjust_field_type (type_p t, options_p opt)\n \n   for (; opt; opt = opt->next)\n     if (strcmp (opt->name, \"length\") == 0)\n-      length_p = 1;\n+      {\n+\tif (length_p)\n+\t  error_at_line (&lexer_line, \"duplicate `%s' option\", opt->name);\n+\tif (t->u.p->kind == TYPE_SCALAR || t->u.p->kind == TYPE_STRING)\n+\t  {\n+\t    error_at_line (&lexer_line,\n+\t\t\t   \"option `%s' may not be applied to \"\n+\t\t\t   \"arrays of atomic types\", opt->name);\n+\t  }\n+\tlength_p = 1;\n+      }\n     else if ((strcmp (opt->name, \"param_is\") == 0\n \t      || (strncmp (opt->name, \"param\", 5) == 0\n \t\t  && ISDIGIT (opt->name[5])\n@@ -2495,7 +2505,7 @@ walk_type (type_p t, struct walk_type_data *d)\n       return;\n     }\n \n-  if (atomic_p && (t->kind != TYPE_POINTER))\n+  if (atomic_p && (t->kind != TYPE_POINTER) && (t->kind != TYPE_STRING))\n     {\n       error_at_line (d->line, \"field `%s' has invalid option `atomic'\\n\", d->val);\n       return;"}, {"sha": "8fd18aaee2cdd02929a5b5ba47aed280e98e0fad", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -1,3 +1,8 @@\n+2012-07-30  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* jcf.h (CPool): Use the \"atomic\" GTY option for the tags field.\n+\t(bootstrap_method): Likewise for the bootstrap_arguments field.\n+\n 2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* java-gimplify.c Include dumpfile.h instead of tree-dump.h"}, {"sha": "38c035fe4390d051b787848eba96b0ed5aaa4766", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -82,7 +82,7 @@ typedef struct GTY(()) CPool {\n   /* The constant_pool_count. */\n   int\t\tcount;\n \n-  uint8* GTY((length (\"%h.count\")))\ttags;\n+  uint8 * GTY((atomic)) tags;\n \n   union cpool_entry * GTY((length (\"%h.count\"),\n \t\t\t   desc (\"cpool_entry_is_tree (%1.tags%a)\")))\tdata;\n@@ -91,7 +91,7 @@ typedef struct GTY(()) CPool {\n typedef struct GTY(()) bootstrap_method {\n   unsigned method_ref;\n   unsigned num_arguments;\n-  unsigned* GTY((length (\"%h.num_arguments\"))) bootstrap_arguments;\n+  unsigned * GTY((atomic)) bootstrap_arguments;\n } bootstrap_method;\n \n typedef struct GTY(()) BootstrapMethods {"}, {"sha": "cb871124ce2241402af05e4697a5e28904c462fb", "filename": "gcc/vec.h", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -95,24 +95,25 @@ along with GCC; see the file COPYING3.  If not see\n    the 'space' predicate will tell you whether there is spare capacity\n    in the vector.  You will not normally need to use these two functions.\n \n-   Vector types are defined using a DEF_VEC_{O,P,I}(TYPEDEF) macro, to\n+   Vector types are defined using a DEF_VEC_{O,A,P,I}(TYPEDEF) macro, to\n    get the non-memory allocation version, and then a\n-   DEF_VEC_ALLOC_{O,P,I}(TYPEDEF,ALLOC) macro to get memory managed\n+   DEF_VEC_ALLOC_{O,A,P,I}(TYPEDEF,ALLOC) macro to get memory managed\n    vectors.  Variables of vector type are declared using a\n    VEC(TYPEDEF,ALLOC) macro.  The ALLOC argument specifies the\n    allocation strategy, and can be either 'gc' or 'heap' for garbage\n    collected and heap allocated respectively.  It can be 'none' to get\n    a vector that must be explicitly allocated (for instance as a\n-   trailing array of another structure).  The characters O, P and I\n-   indicate whether TYPEDEF is a pointer (P), object (O) or integral\n-   (I) type.  Be careful to pick the correct one, as you'll get an\n-   awkward and inefficient API if you use the wrong one.  There is a\n-   check, which results in a compile-time warning, for the P and I\n-   versions, but there is no check for the O versions, as that is not\n-   possible in plain C.  Due to the way GTY works, you must annotate\n-   any structures you wish to insert or reference from a vector with a\n-   GTY(()) tag.  You need to do this even if you never declare the GC\n-   allocated variants.\n+   trailing array of another structure).  The characters O, A, P and I\n+   indicate whether TYPEDEF is a pointer (P), object (O), atomic object\n+   (A) or integral (I) type.  Be careful to pick the correct one, as\n+   you'll get an awkward and inefficient API if you use the wrong one or\n+   a even a crash if you pick the atomic object version when the object\n+   version should have been chosen instead.  There is a check, which\n+   results in a compile-time warning, for the P and I versions, but there\n+   is no check for the O versions, as that is not possible in plain C.\n+   Due to the way GTY works, you must annotate any structures you wish to\n+   insert or reference from a vector with a GTY(()) tag.  You need to do\n+   this even if you never declare the GC allocated variants.\n \n    An example of their use would be,\n \n@@ -530,6 +531,13 @@ typedef struct GTY(()) VEC(T,B)\t\t\t\t \t\t  \\\n   T GTY ((length (\"%h.prefix.num\"))) vec[1];\t\t\t\t  \\\n } VEC(T,B)\n \n+#define VEC_T_GTY_ATOMIC(T,B)\t\t\t\t\t\t  \\\n+typedef struct GTY(()) VEC(T,B)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  struct vec_prefix prefix;\t\t\t\t\t\t  \\\n+  T GTY ((atomic)) vec[1];\t\t\t\t\t\t  \\\n+} VEC(T,B)\n+\n /* Derived vector type, user visible.  */\n #define VEC_TA_GTY(T,B,A,GTY)\t\t\t\t\t\t  \\\n typedef struct GTY VEC(T,A)\t\t\t\t\t\t  \\\n@@ -904,6 +912,14 @@ DEF_VEC_ALLOC_FUNC_O(T,A)\t\t\t\t\t\t  \\\n DEF_VEC_NONALLOC_FUNCS_O(T,A)\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n \n+/* Vector of atomic object.  */\n+#define DEF_VEC_A(T)\t\t\t\t\t\t\t  \\\n+VEC_T_GTY_ATOMIC(T,base);\t\t\t\t\t\t  \\\n+VEC_TA(T,base,none);\t\t\t\t\t\t\t  \\\n+DEF_VEC_FUNC_O(T)\t\t\t\t\t\t\t  \\\n+struct vec_swallow_trailing_semi\n+#define DEF_VEC_ALLOC_A(T,A) DEF_VEC_ALLOC_O(T,A)\n+\n #define DEF_VEC_FUNC_O(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)\t  \\\n {\t\t\t\t\t\t\t\t\t  \\"}, {"sha": "0ec30137b3b2f4f58d53f7fc7d9eaffe23828072", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -1,3 +1,8 @@\n+2012-07-30  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* include/line-map.h (line_map_macro): Use the \"atomic\" GTY option\n+\tfor the macro_locations field.\n+\n 2011-06-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* lex.c (search_line_sse42): Use __builtin_ia32_loaddqu and"}, {"sha": "407ce4b0228641816ee032cf99d015995b142395", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fd34971d2d719227d63ed8d069089862ec9c9f/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fd34971d2d719227d63ed8d069089862ec9c9f/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=c0fd34971d2d719227d63ed8d069089862ec9c9f", "patch": "@@ -165,7 +165,7 @@ struct GTY(()) line_map_macro {\n      In the example above x1 (for token \"+\") is going to be the same\n      as y1.  x0 is the spelling location for the argument token \"1\",\n      and x2 is the spelling location for the argument token \"2\".  */\n-  source_location * GTY((length (\"2 * %h.n_tokens\"))) macro_locations;\n+  source_location * GTY((atomic)) macro_locations;\n \n   /* This is the location of the expansion point of the current macro\n      map.  It's the location of the macro name.  That location is held"}]}