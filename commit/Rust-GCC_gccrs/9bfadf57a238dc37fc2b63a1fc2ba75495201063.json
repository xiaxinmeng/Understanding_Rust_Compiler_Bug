{"sha": "9bfadf57a238dc37fc2b63a1fc2ba75495201063", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJmYWRmNTdhMjM4ZGMzN2ZjMmI2M2ExZmMyYmE3NTQ5NTIwMTA2Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-20T20:19:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-20T20:19:04Z"}, "message": "Remove support for assigning to `this'.\n\n\t* NEWS: Note that fact.\n\t* class.c (build_vbase_path): Don't check flag_this_is_variable.\n\t* cp-tree.h (EXPR_STMT_ASSIGNS_THIS): Remove.\n\t(language_function): Remove assigns_this, just_assigned_this, and\n\tx_base_init_expr.  Add x_vcalls_possible_p.  Add vtbls_set_up_p.\n\t(base_init_expr): Remove.\n\t(current_vcalls_possible_p): New macro.\n\t(vtbls_set_up_p): Likewise.\n\t(emit_base_init): Change prototype.\n\t* decl.c (finish_destructor_body): New function, split out from\n\tfinish_function.\n\t(current_function_assigns_this): Remove.\n\t(current_function_just_assigned_this): Likewise.\n\t(start_function): Don't set them.\n\t(finish_function): Don't check them.  Don't emit\n\tbase-initialization code here.  Generate code for destructors when\n\tdoing semantic analysis.\n\t(finish_stmt): Don't check current_function_just_assigned_this.\n\t* decl2.c (lang_f_options): Remove this-is-variable.\n\t(lang_decode_option): Likewise.\n\t(grokclassfn): Don't check flag_this_is_variable.\n\t* init.c (emit_base_init): Return the expression generated.\n\t(construct_virtual_bases): Don't push/pop obstacks.  Fix\n\ttypo.\n\t(build_new_1): Don't check flag_this_is_variable.\n\t(get_temp_regvar): Don't set DECL_REGISTER.\n\t(build_vec_init): Don't call use_variable.\n\t* lang-options.h: Remove \"-fthis-is-variable\" and\n\t\"-fno-this-is-variable\".\n\t* pt.c (tsubst_expr): Don't check EXPR_STMT_ASSIGNS_THIS.\n\t* search.c (expand_upcast_fixups): Use finish_expr_stmt, not\n\texpand_expr_stmt.\n\t* semantics.c (finish_expr_stmt_real): Rename to ...\n\t(finish_expr_stmt): This.  Remove assigned_this parameter.\n\t(begin_if_stmt): Call do_pushlevel before starting the statement.\n\t(begin_compound_stmt): Don't declare __FUNCTION__ in scope-less\n\tblocks.\n\t(setup_vtbl_ptr): Emit initialization code for bases and members\n\tat semantic-analysis time.  Emit code to initialize vtables in\n\tdestructors here.\n\t(expand_stmt): Use finish_expr_stmt, not finish_expr_stmt_real.\n\tDon't handle CTOR_INITIALIZER any more.\n\t* typeck.c (build_modify_expr): Don't check for assignments to\n\tthis.\n\t(c_expand_return): Don't suggest assigning to `this'.\n\n\t* Makefile.in (decl.o): Depend on RTL_H.\n\t(decl2.o): Likewise.\n\t(class.o): Likewise.\n\t(call.o): Likewise.\n\t(method.o): Likewise.\n\t(search.o): Likewise.\n\t(tree.o): Likewise.\n\t(pt.o): Likewise.\n\n\t* decl.c (duplicate_decls): When a builtin function is redeclared\n\tas static, make sure it is mangled correctly.\n\n\t* ir.texi (CTOR_INITIALIZER): Remove mention.  Fix typo.  Add\n\tdetail about the statement-tree.\n\nFrom-SVN: r29531", "tree": {"sha": "f594c41c30a40ef047f5d5f847c7882b2ddd44bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f594c41c30a40ef047f5d5f847c7882b2ddd44bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bfadf57a238dc37fc2b63a1fc2ba75495201063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bfadf57a238dc37fc2b63a1fc2ba75495201063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bfadf57a238dc37fc2b63a1fc2ba75495201063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bfadf57a238dc37fc2b63a1fc2ba75495201063/comments", "author": null, "committer": null, "parents": [{"sha": "2307e3723810fd0cc01af9e7082227140f6f9895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2307e3723810fd0cc01af9e7082227140f6f9895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2307e3723810fd0cc01af9e7082227140f6f9895"}], "stats": {"total": 782, "additions": 340, "deletions": 442}, "files": [{"sha": "5f0bce0c5052259706cc843e9630f6ce4e1a6d92", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -1,3 +1,67 @@\n+1999-09-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove support for assigning to `this'.\n+\t* NEWS: Note that fact.\n+\t* class.c (build_vbase_path): Don't check flag_this_is_variable.\n+\t* cp-tree.h (EXPR_STMT_ASSIGNS_THIS): Remove.\n+\t(language_function): Remove assigns_this, just_assigned_this, and\n+\tx_base_init_expr.  Add x_vcalls_possible_p.  Add vtbls_set_up_p.\n+\t(base_init_expr): Remove.\n+\t(current_vcalls_possible_p): New macro.\n+\t(vtbls_set_up_p): Likewise.\n+\t(emit_base_init): Change prototype.\n+\t* decl.c (finish_destructor_body): New function, split out from\n+\tfinish_function.\n+\t(current_function_assigns_this): Remove.\n+\t(current_function_just_assigned_this): Likewise.\n+\t(start_function): Don't set them.\n+\t(finish_function): Don't check them.  Don't emit\n+\tbase-initialization code here.  Generate code for destructors when\n+\tdoing semantic analysis.\n+\t(finish_stmt): Don't check current_function_just_assigned_this.\n+\t* decl2.c (lang_f_options): Remove this-is-variable.\n+\t(lang_decode_option): Likewise.\n+\t(grokclassfn): Don't check flag_this_is_variable.\n+\t* init.c (emit_base_init): Return the expression generated.\n+\t(construct_virtual_bases): Don't push/pop obstacks.  Fix\n+\ttypo.\n+\t(build_new_1): Don't check flag_this_is_variable.\n+\t(get_temp_regvar): Don't set DECL_REGISTER.\n+\t(build_vec_init): Don't call use_variable.\n+\t* lang-options.h: Remove \"-fthis-is-variable\" and\n+\t\"-fno-this-is-variable\".\n+\t* pt.c (tsubst_expr): Don't check EXPR_STMT_ASSIGNS_THIS.\n+\t* search.c (expand_upcast_fixups): Use finish_expr_stmt, not\n+\texpand_expr_stmt.\n+\t* semantics.c (finish_expr_stmt_real): Rename to ...\n+\t(finish_expr_stmt): This.  Remove assigned_this parameter.\n+\t(begin_if_stmt): Call do_pushlevel before starting the statement.\n+\t(begin_compound_stmt): Don't declare __FUNCTION__ in scope-less\n+\tblocks.\n+\t(setup_vtbl_ptr): Emit initialization code for bases and members\n+\tat semantic-analysis time.  Emit code to initialize vtables in\n+\tdestructors here.\n+\t(expand_stmt): Use finish_expr_stmt, not finish_expr_stmt_real.\n+\tDon't handle CTOR_INITIALIZER any more.\n+\t* typeck.c (build_modify_expr): Don't check for assignments to\n+\tthis.\n+\t(c_expand_return): Don't suggest assigning to `this'.\n+\t\n+\t* Makefile.in (decl.o): Depend on RTL_H.\n+\t(decl2.o): Likewise.\n+\t(class.o): Likewise.\n+\t(call.o): Likewise.\n+\t(method.o): Likewise.\n+\t(search.o): Likewise.\n+\t(tree.o): Likewise.\n+\t(pt.o): Likewise.\n+\n+\t* decl.c (duplicate_decls): When a builtin function is redeclared\n+\tas static, make sure it is mangled correctly.\n+\n+\t* ir.texi (CTOR_INITIALIZER): Remove mention.  Fix typo.  Add\n+\tdetail about the statement-tree.\n+\t\n 1999-09-20  Nathan Sidwell  <nathan@acm.org>\n \n \t* parse.y (primary): Use build_functional_cast for CV_QUALIFIER."}, {"sha": "db32e7f527ca01bf84c901a411204c3c70d9226e", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -248,33 +248,33 @@ lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../hash.h $(srcdir)/../ggc.h\n+  $(srcdir)/../hash.h $(srcdir)/../ggc.h $(RTL_H)\n decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(EXPR_H) $(srcdir)/../except.h \\\n   $(srcdir)/../output.h $(srcdir)/../except.h $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h \\\n-  $(srcdir)/../../include/splay-tree.h $(srcdir)/../ggc.h\n+  $(srcdir)/../../include/splay-tree.h $(srcdir)/../ggc.h $(RTL_H)\n typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h \n class.o : class.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../../include/splay-tree.h\n+  $(srcdir)/../../include/splay-tree.h $(RTL_H)\n call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h $(RTL_H)\n friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n init.o : init.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n method.o : method.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H)\n cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h decl.h \\\n   $(srcdir)/../flags.h $(srcdir)/../toplev.h $(srcdir)/../convert.h\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h \\\n-  $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h $(RTL_H)\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H)\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n@@ -285,7 +285,7 @@ expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H) lex.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h $(RTL_H)\n error.o : error.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\"}, {"sha": "a172f6dae42aa16fe427cd1e8fbc45fe4acb4aa3", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -1,5 +1,10 @@\n *** Changes in GCC 3.0:\n \n+* Support for assignment to `this' has been removed.  This idiom \n+  was used in the very early days of C++, before users were allowed\n+  to overload `operator new'; it is no longer allowed by the C++\n+  standard.\n+\n * Support for signatures, a G++ extension, have been removed.\n \n * Certain invalid conversions that were previously accepted will now"}, {"sha": "ff0cd8800d7b9d4f01388440010b1d385a0e9fe0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -224,11 +224,6 @@ build_vbase_path (code, type, expr, path, nonnull)\n   if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE)\n     return build1 (NOP_EXPR, type, expr);\n \n-  /* If -fthis-is-variable, we might have set nonnull incorrectly.  We\n-     don't care enough to get this right, so just clear it.  */\n-  if (flag_this_is_variable > 0)\n-    nonnull = 0;\n-\n   /* We could do better if we had additional logic to convert back to the\n      unconverted type (the static type of the complete object), and then\n      convert back to the type we want.  Until that is done, we only optimize"}, {"sha": "9a55744a1073af6857b316f63c56c868eda0d4ba", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -29,7 +29,6 @@ Boston, MA 02111-1307, USA.  */\n /* Usage of TREE_LANG_FLAG_?:\n    0: BINFO_MARKED (BINFO nodes).\n       COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n-      EXPR_STMT_ASSIGNS_THIS (in EXPR_STMT).\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n       LOOKUP_EXPR_GLOBAL (in LOOKUP_EXPR).\n@@ -618,7 +617,6 @@ struct language_function\n   tree x_dtor_label;\n   tree x_base_init_list;\n   tree x_member_init_list;\n-  tree x_base_init_expr;\n   tree x_current_class_ptr;\n   tree x_current_class_ref;\n   tree x_last_tree;\n@@ -627,21 +625,22 @@ struct language_function\n   tree x_scope_stmt_stack;\n   tree x_in_charge_parm;\n \n+  tree *x_vcalls_possible_p;\n+\n   struct rtx_def *x_last_dtor_insn;\n   struct rtx_def *x_last_parm_cleanup_insn;\n   struct rtx_def *x_result_rtx;\n \n   int returns_value;\n   int returns_null;\n-  int assigns_this;\n-  int just_assigned_this;\n   int parms_stored;\n   int temp_name_counter;\n   int static_labelno;\n   int in_function_try_handler;\n   int x_expanding_p;\n   int stmts_are_full_exprs_p; \n   int name_declared;\n+  int vtbls_set_up_p;\n \n   struct named_label_list *x_named_label_uses;\n   struct binding_level *bindings;\n@@ -674,10 +673,6 @@ struct language_function\n #define current_base_init_list cp_function_chain->x_base_init_list\n #define current_member_init_list cp_function_chain->x_member_init_list\n \n-/* Sequence of insns which represents base initialization.  */\n-\n-#define base_init_expr cp_function_chain->x_base_init_expr\n-\n /* When we're processing a member function, current_class_ptr is the\n    PARM_DECL for the `this' pointer.  The current_class_ref is an\n    expression for `*this'.  */\n@@ -712,6 +707,12 @@ struct language_function\n \n #define current_in_charge_parm cp_function_chain->x_in_charge_parm\n \n+/* In destructors, this is a pointer to a condition in an\n+   if-statement.  If the pointed-to value is boolean_true_node, then\n+   there may be virtual function calls in this destructor.  */\n+\n+#define current_vcalls_possible_p cp_function_chain->x_vcalls_possible_p\n+\n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n \n@@ -734,6 +735,11 @@ struct language_function\n #define current_function_name_declared \\\n   cp_function_chain->name_declared\n \n+/* Nonzero if we have already generated code to initialize virtual\n+   function tables in this function.  */\n+\n+#define vtbls_set_up_p cp_function_chain->vtbls_set_up_p\n+\n /* Used to help generate temporary names which are unique within\n    a function.  Reset to 0 by start_function.  */\n \n@@ -1868,12 +1874,6 @@ struct lang_decl\n    constructor call, rather than an ordinary function call.  */\n #define AGGR_INIT_VIA_CTOR_P(NODE) TREE_LANG_FLAG_0 (NODE)\n \n-/* Nonzero if this statement contained the first assigned to `this' in\n-   the current function.  (Of course, one cannot assign to `this' in\n-   ANSI/ISO C++, but we still support assignments to this with\n-   -fthis-is-variable.)  */\n-#define EXPR_STMT_ASSIGNS_THIS(NODE) TREE_LANG_FLAG_0 ((NODE))\n-\n /* Nonzero if this statement should be considered a full-expression.  */\n #define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n \n@@ -2857,8 +2857,7 @@ struct pending_inline\n /* in method.c */\n extern struct pending_inline *pending_inlines;\n \n-/* Positive values means that we cannot make optimizing assumptions about\n-   `this'.  Negative values means we know `this' to be of static type.  */\n+/* Negative values means we know `this' to be of static type.  */\n \n extern int flag_this_is_variable;\n \n@@ -3420,7 +3419,7 @@ extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, tree, enum overload_flag\n /* in init.c */\n extern void init_init_processing\t\tPROTO((void));\n extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n-extern void emit_base_init\t\t\tPROTO((tree));\n+extern tree emit_base_init\t\t\tPROTO((tree));\n extern void check_base_init\t\t\tPROTO((tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n extern tree build_aggr_init\t\t\tPROTO((tree, tree, int));"}, {"sha": "43713727958b62cb6396550c0ba91218fc4606e3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 134, "deletions": 276, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -180,6 +180,7 @@ static void save_function_data PROTO((tree));\n static void check_function_type PROTO((tree));\n static void destroy_local_static PROTO((tree));\n static void destroy_local_var PROTO((tree));\n+static void finish_destructor_body PROTO((void));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -371,13 +372,6 @@ extern int flag_conserve_space;\n \f\n /* C and C++ flags are in decl2.c.  */\n \n-/* Set to 0 at beginning of a constructor, set to 1\n-   if that function does an allocation before referencing its\n-   instance variable.  */\n-#define current_function_assigns_this cp_function_chain->assigns_this\n-#define current_function_just_assigned_this \\\n-  cp_function_chain->just_assigned_this\n-\n /* Flag used when debugging spew.c */\n \n extern int spew_debug;\n@@ -3060,6 +3054,15 @@ duplicate_decls (newdecl, olddecl)\n \t     the declarations, but make the original one static.  */\n \t  DECL_THIS_STATIC (olddecl) = 1;\n \t  TREE_PUBLIC (olddecl) = 0;\n+\n+\t  /* Make the olddeclaration consistent with the new one so that\n+\t     all remnants of the builtin-ness of this function will be\n+\t     banished.  */\n+\t  DECL_LANGUAGE (olddecl) = DECL_LANGUAGE (newdecl);\n+\t  DECL_RTL (olddecl) = DECL_RTL (newdecl);\n+\t  DECL_ASSEMBLER_NAME (olddecl) = DECL_ASSEMBLER_NAME (newdecl);\n+\t  SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (newdecl),\n+\t\t\t\t       newdecl);\n \t}\n     }\n   else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n@@ -12927,10 +12930,6 @@ start_function (declspecs, declarator, attrs, flags)\n       *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (decl1);\n       current_binding_level = bl;\n \n-      /* This function has not assigned to `this' yet.  */\n-      current_function_assigns_this = 0;\n-      current_function_just_assigned_this = 0;\n-\n       /* This function is being processed in whole-function mode; we\n \t already did semantic analysis.  */\n       current_function->x_whole_function_mode_p = 1;\n@@ -13298,6 +13297,121 @@ save_function_data (decl)\n   f->x_expanding_p = 1;\n }\n \n+/* At the end of every destructor we generate code to restore virtual\n+   function tables to the values desired by base classes and to call\n+   to base class destructors.  Do that now, for DECL.  */\n+\n+static void\n+finish_destructor_body ()\n+{\n+  tree compound_stmt;\n+  tree in_charge;\n+  tree virtual_size;\n+  tree exprstmt;\n+\n+  /* Create a block to contain all the extra code.  */\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+\n+  /* Generate the code to call destructor on base class.  If this\n+     destructor belongs to a class with virtual functions, then set\n+     the virtual function table pointer to represent the type of our\n+     base class.  */\n+\n+  /* This side-effect makes call to `build_delete' generate the code\n+     we have to have at the end of this destructor.  `build_delete'\n+     will set the flag again.  */\n+  TYPE_HAS_DESTRUCTOR (current_class_type) = 0;\n+\n+  /* These are two cases where we cannot delegate deletion.  */\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)\n+      || TYPE_GETS_REG_DELETE (current_class_type))\n+    in_charge = integer_zero_node;\n+  else\n+    in_charge = current_in_charge_parm;\n+\n+  exprstmt = build_delete (current_class_type,\n+\t\t\t   current_class_ref, \n+\t\t\t   in_charge,\n+\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL, \n+\t\t\t   0);\n+\n+  if (exprstmt != error_mark_node\n+      && (TREE_CODE (exprstmt) != NOP_EXPR\n+\t  || TREE_OPERAND (exprstmt, 0) != integer_zero_node\n+\t  || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)))\n+    {\n+      add_tree (build_min_nt (LABEL_STMT, dtor_label));\n+      if (exprstmt != void_zero_node)\n+\t/* Don't call `expand_expr_stmt' if we're not going to do\n+\t   anything, since -Wall will give a diagnostic.  */\n+\tfinish_expr_stmt (exprstmt);\n+\n+      /* Run destructor on all virtual baseclasses.  */\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+\t{\n+\t  tree vbases = nreverse (copy_list (CLASSTYPE_VBASECLASSES (current_class_type)));\n+\t  tree if_stmt = begin_if_stmt ();\n+\t  finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t      current_in_charge_parm, \n+\t\t\t\t      integer_two_node),\n+\t\t\t       if_stmt);\n+\n+\t  while (vbases)\n+\t    {\n+\t      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n+\t\t{\n+\t\t  tree vb = get_vbase\n+\t\t    (BINFO_TYPE (vbases),\n+\t\t     TYPE_BINFO (current_class_type));\n+\t\t  finish_expr_stmt\n+\t\t    (build_scoped_method_call\n+\t\t     (current_class_ref, vb, dtor_identifier,\n+\t\t      build_expr_list (NULL_TREE, integer_zero_node)));\n+\t\t}\n+\t      vbases = TREE_CHAIN (vbases);\n+\t    }\n+\n+\t  finish_then_clause (if_stmt);\n+\t  finish_if_stmt ();\n+\t}\n+    }\n+  \n+  virtual_size = c_sizeof (current_class_type);\n+\n+  /* At the end, call delete if that's what's requested.  */\n+  \n+  /* FDIS sez: At the point of definition of a virtual destructor\n+     (including an implicit definition), non-placement operator delete\n+     shall be looked up in the scope of the destructor's class and if\n+     found shall be accessible and unambiguous.\n+     \n+     This is somewhat unclear, but I take it to mean that if the class\n+     only defines placement deletes we don't do anything here.  So we\n+     pass LOOKUP_SPECULATIVELY; delete_sanity will complain for us if\n+     they ever try to delete one of these.  */\n+  if (TYPE_GETS_REG_DELETE (current_class_type)\n+      || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+    {\n+      tree if_stmt;\n+\n+      exprstmt = build_op_delete_call\n+\t(DELETE_EXPR, current_class_ptr, virtual_size,\n+\t LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n+\n+      if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t  current_in_charge_parm,\n+\t\t\t\t  integer_one_node),\n+\t\t\t   if_stmt);\n+      finish_expr_stmt (exprstmt);\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt ();\n+    }\n+\n+  /* Close the block we started above.  */\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n+}\n+\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n    for the function definition.\n@@ -13322,7 +13436,6 @@ finish_function (lineno, flags)\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n-  rtx fn_last_parm_insn, insns;\n   /* Label to use if this function is supposed to return a value.  */\n   tree no_return_label = NULL_TREE;\n   int call_poplevel = (flags & 1) != 0;\n@@ -13338,9 +13451,9 @@ finish_function (lineno, flags)\n   nested = function_depth > 1;\n   fntype = TREE_TYPE (fndecl);\n \n-/*  TREE_READONLY (fndecl) = 1;\n-    This caused &foo to be of type ptr-to-const-function\n-    which then got a warning when stored in a ptr-to-function variable.  */\n+  /*  TREE_READONLY (fndecl) = 1;\n+      This caused &foo to be of type ptr-to-const-function\n+      which then got a warning when stored in a ptr-to-function variable.  */\n \n   /* This happens on strange parse errors.  */\n   if (! current_function_parms_stored)\n@@ -13353,6 +13466,8 @@ finish_function (lineno, flags)\n     {\n       if (DECL_CONSTRUCTOR_P (fndecl) && call_poplevel)\n \tdo_poplevel ();\n+      else if (DECL_DESTRUCTOR_P (fndecl) && !processing_template_decl)\n+\tfinish_destructor_body ();\n \n       /* Finish dealing with exception specifiers.  */\n       if (flag_exceptions && !processing_template_decl\n@@ -13385,242 +13500,9 @@ finish_function (lineno, flags)\n       do_pending_stack_adjust ();\n \n       if (dtor_label)\n-\t{\n-\t  tree binfo = TYPE_BINFO (current_class_type);\n-\t  tree cond = integer_one_node;\n-\t  tree exprstmt;\n-\t  tree virtual_size;\n-\t  int ok_to_optimize_dtor = 0;\n-\t  int empty_dtor = get_last_insn () == last_dtor_insn;\n-\n-\t  if (current_function_assigns_this)\n-\t    cond = build (NE_EXPR, boolean_type_node,\n-\t\t\t  current_class_ptr, integer_zero_node);\n-\t  else\n-\t    {\n-\t      int n_baseclasses = CLASSTYPE_N_BASECLASSES (current_class_type);\n-\n-\t      /* If this destructor is empty, then we don't need to check\n-\t\t whether `this' is NULL in some cases.  */\n-\t      if ((flag_this_is_variable & 1) == 0)\n-\t\tok_to_optimize_dtor = 1;\n-\t      else if (empty_dtor)\n-\t\tok_to_optimize_dtor\n-\t\t  = (n_baseclasses == 0\n-\t\t     || (n_baseclasses == 1\n-\t\t\t && TYPE_HAS_DESTRUCTOR (TYPE_BINFO_BASETYPE (current_class_type, 0))));\n-\t    }\n-\n-\t  /* These initializations might go inline.  Protect\n-\t     the binding level of the parms.  */\n-\t  do_pushlevel ();\n-\n-\t  if (current_function_assigns_this)\n-\t    {\n-\t      current_function_assigns_this = 0;\n-\t      current_function_just_assigned_this = 0;\n-\t    }\n-\n-\t  /* Generate the code to call destructor on base class.\n-\t     If this destructor belongs to a class with virtual\n-\t     functions, then set the virtual function table\n-\t     pointer to represent the type of our base class.  */\n-\n-\t  /* This side-effect makes call to `build_delete' generate the\n-\t     code we have to have at the end of this destructor.\n-\t     `build_delete' will set the flag again.  */\n-\t  TYPE_HAS_DESTRUCTOR (current_class_type) = 0;\n-\n-\t  /* These are two cases where we cannot delegate deletion.  */\n-\t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)\n-\t      || TYPE_GETS_REG_DELETE (current_class_type))\n-\t    exprstmt = build_delete (current_class_type, current_class_ref, integer_zero_node,\n-\t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL, 0);\n-\t  else\n-\t    exprstmt = build_delete (current_class_type,\n-\t\t\t\t     current_class_ref, \n-\t\t\t\t     current_in_charge_parm,\n-\t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL, 0);\n-\n-\t  /* If we did not assign to this, then `this' is non-zero at\n-\t     the end of a destructor.  As a special optimization, don't\n-\t     emit test if this is an empty destructor.  If it does nothing,\n-\t     it does nothing.  If it calls a base destructor, the base\n-\t     destructor will perform the test.  */\n-\n-\t  if (exprstmt != error_mark_node\n-\t      && (TREE_CODE (exprstmt) != NOP_EXPR\n-\t\t  || TREE_OPERAND (exprstmt, 0) != integer_zero_node\n-\t\t  || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)))\n-\t    {\n-\t      expand_label (dtor_label);\n-\t      if (cond != integer_one_node)\n-\t\texpand_start_cond (cond, 0);\n-\t      if (exprstmt != void_zero_node)\n-\t\t/* Don't call `expand_expr_stmt' if we're not going to do\n-\t\t   anything, since -Wall will give a diagnostic.  */\n-\t\texpand_expr_stmt (exprstmt);\n-\n-\t      /* Run destructor on all virtual baseclasses.  */\n-\t      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t\t{\n-\t\t  tree vbases = nreverse (copy_list (CLASSTYPE_VBASECLASSES (current_class_type)));\n-\t\t  expand_start_cond (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t\t    current_in_charge_parm, \n-\t\t\t\t\t    integer_two_node), 0);\n-\t\t  while (vbases)\n-\t\t    {\n-\t\t      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n-\t\t\t{\n-\t\t\t  tree vb = get_vbase\n-\t\t\t    (BINFO_TYPE (vbases),\n-\t\t\t     TYPE_BINFO (current_class_type));\n-\t\t\t  expand_expr_stmt\n-\t\t\t    (build_scoped_method_call\n-\t\t\t     (current_class_ref, vb, dtor_identifier,\n-\t\t\t      build_expr_list (NULL_TREE, integer_zero_node)));\n-\t\t\t}\n-\t\t      vbases = TREE_CHAIN (vbases);\n-\t\t    }\n-\t\t  expand_end_cond ();\n-\t\t}\n-\n-\t      do_pending_stack_adjust ();\n-\t      if (cond != integer_one_node)\n-\t\texpand_end_cond ();\n-\t    }\n-\n-\t  virtual_size = c_sizeof (current_class_type);\n-\n-\t  /* At the end, call delete if that's what's requested.  */\n-\n-\t  /* FDIS sez: At the point of definition of a virtual destructor\n-\t       (including an implicit definition), non-placement operator\n-\t       delete shall be looked up in the scope of the destructor's\n-\t       class and if found shall be accessible and unambiguous.\n-\n-\t     This is somewhat unclear, but I take it to mean that if the\n-\t     class only defines placement deletes we don't do anything here.\n-\t     So we pass LOOKUP_SPECULATIVELY; delete_sanity will complain\n-\t     for us if they ever try to delete one of these.  */\n-\n-\t  if (TYPE_GETS_REG_DELETE (current_class_type)\n-\t      || TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t    exprstmt = build_op_delete_call\n-\t      (DELETE_EXPR, current_class_ptr, virtual_size,\n-\t       LOOKUP_NORMAL | LOOKUP_SPECULATIVELY, NULL_TREE);\n-\t  else\n-\t    exprstmt = NULL_TREE;\n-\n-\t  if (exprstmt)\n-\t    {\n-\t      cond = build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t    current_in_charge_parm, integer_one_node);\n-\t      expand_start_cond (cond, 0);\n-\t      expand_expr_stmt (exprstmt);\n-\t      expand_end_cond ();\n-\t    }\n-\n-\t  /* End of destructor.  */\n-\t  do_poplevel ();\n-\n-\t  /* Back to the top of destructor.  */\n-\t  /* Don't execute destructor code if `this' is NULL.  */\n-\n-\t  start_sequence ();\n-\n-\t  /* If the dtor is empty, and we know there is not possible way we\n-\t     could use any vtable entries, before they are possibly set by\n-\t     a base class dtor, we don't have to setup the vtables, as we\n-\t     know that any base class dtoring will set up any vtables it\n-\t     needs.  We avoid MI, because one base class dtor can do a\n-\t     virtual dispatch to an overridden function that would need to\n-\t     have a non-related vtable set up, we cannot avoid setting up\n-\t     vtables in that case.  We could change this to see if there is\n-\t     just one vtable.  */\n-\t  if (! empty_dtor || TYPE_USES_COMPLEX_INHERITANCE (current_class_type))\n-\t    {\n-\t      /* Make all virtual function table pointers in non-virtual base\n-\t\t classes point to CURRENT_CLASS_TYPE's virtual function\n-\t\t tables.  */\n-\t      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_ptr);\n-\n-\t      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t\texpand_indirect_vtbls_init (binfo, current_class_ref, current_class_ptr);\n-\t    }\n-\t  \n-\t  if (! ok_to_optimize_dtor)\n-\t    {\n-\t      cond = build_binary_op (NE_EXPR,\n-\t\t\t\t      current_class_ptr, integer_zero_node);\n-\t      expand_start_cond (cond, 0);\n-\t    }\n-\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\n-\t  fn_last_parm_insn = get_first_nonparm_insn ();\n-\t  if (fn_last_parm_insn == NULL_RTX)\n-\t    fn_last_parm_insn = get_last_insn ();\n-\t  else\n-\t    fn_last_parm_insn = previous_insn (fn_last_parm_insn);\n-\n-\t  emit_insns_after (insns, fn_last_parm_insn);\n-\n-\t  if (! ok_to_optimize_dtor)\n-\t    expand_end_cond ();\n-\t}\n+\t;\n       else if (DECL_CONSTRUCTOR_P (fndecl))\n \t{\n-\t  /* If the current function assigns to `this', then code to\n-\t     initialize members and base-classes will be generated\n-\t     directly after the assignment.  */\n-\t  if (!current_function_assigns_this)\n-\t    {\n-\t      start_sequence ();\n-\n-\t      if (flag_this_is_variable > 0)\n-\t\t{\n-\t\t  /* Allow constructor for a type to get a new instance of\n-\t\t     the object using `build_new'.  */\n-\t\t  tree cond = NULL_TREE, thenclause = NULL_TREE;\n-\t\t  tree abstract_virtuals \n-\t\t    = CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type);\n-\t\t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = NULL_TREE;\n-\n-\t\t  cond = build_binary_op (EQ_EXPR,\n-\t\t\t\t\t  current_class_ptr, integer_zero_node);\n-\n-\t\t  expand_start_cond (cond, 0);\n-\n-\t\t  thenclause \n-\t\t    = build_modify_expr (current_class_ptr, NOP_EXPR,\n-\t\t\t\t\t build_new (NULL_TREE,\n-\t\t\t\t\t\t    current_class_type,\n-\n-\t\t\t\t\t\t    void_type_node, 0));\n-\t\t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) \n-\t\t    = abstract_virtuals;\n-\t\t  expand_expr_stmt (thenclause);\n-\t\t  expand_end_cond ();\n-\t\t}\n-\n-\t      /* Emit insns from `emit_base_init' which sets up\n-\t\t virtual function table pointer(s).  Don't do this for\n-\t\t a function which assigns to `this' as we will emit\n-\t\t the appropriate code right after the assignment.  */\n-\t      if (!current_function_assigns_this && base_init_expr)\n-\t\t{\n-\t\t  expand_expr_stmt (base_init_expr);\n-\t\t  base_init_expr = NULL_TREE;\n-\t\t}\n-\n-\t      insns = get_insns ();\n-\t      end_sequence ();\n-\n-\t      emit_insns_after (insns, last_parm_cleanup_insn);\n-\t    }\n-\n \t  /* This is where the body of the constructor begins.  All\n \t     subobjects have been fully constructed at this point.  */\n \t  end_protect_partials ();\n@@ -13634,9 +13516,6 @@ finish_function (lineno, flags)\n \n \t  /* c_expand_return knows to return 'this' from a constructor.  */\n \t  c_expand_return (NULL_TREE);\n-\n-\t  current_function_assigns_this = 0;\n-\t  current_function_just_assigned_this = 0;\n \t}\n       else if (DECL_MAIN_P (fndecl))\n \t{\n@@ -13648,13 +13527,9 @@ finish_function (lineno, flags)\n #endif\n \t}\n       else if (return_label != NULL_RTX\n-\t       && ((flag_this_is_variable <= 0\n-\t\t    && current_function_return_value == NULL_TREE\n-\t\t    && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n-\t\t   || (flag_this_is_variable > 0\n-\t\t       && (TREE_CODE (TREE_TYPE (DECL_RESULT\n-\t\t\t\t\t\t (current_function_decl)))\n-\t\t\t   == VOID_TYPE))))\n+\t       && flag_this_is_variable <= 0\n+\t       && current_function_return_value == NULL_TREE\n+\t       && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n \tno_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n       if (flag_exceptions)\n@@ -14241,22 +14116,6 @@ cplus_expand_expr_stmt (exp)\n void\n finish_stmt ()\n {\n-  if (!current_function_assigns_this\n-      && current_function_just_assigned_this)\n-    {\n-      if (DECL_CONSTRUCTOR_P (current_function_decl) \n-\t  && !building_stmt_tree ())\n-\t{\n-\t  /* Constructors must wait until we are out of control\n-\t     zones before calling base constructors.  */\n-\t  if (in_control_zone_p ())\n-\t    return;\n-\t  expand_expr_stmt (base_init_expr);\n-\t  check_base_init (current_class_type);\n-\t}\n-      current_function_assigns_this = 1;\n-    }\n-\n   /* Always assume this statement was not an expression statement.  If\n      it actually was an expression statement, its our callers\n      responsibility to fix this up.  */\n@@ -14344,7 +14203,6 @@ mark_lang_function (p)\n   ggc_mark_tree (p->x_dtor_label);\n   ggc_mark_tree (p->x_base_init_list);\n   ggc_mark_tree (p->x_member_init_list);\n-  ggc_mark_tree (p->x_base_init_expr);\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);\n   ggc_mark_tree (p->x_last_tree);"}, {"sha": "868a62ecb924f712b6e5fbd05c7b4c4752d3ab69", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -523,7 +523,6 @@ lang_f_options[] =\n   {\"squangle\", &flag_do_squangling, 1},\n   {\"stats\", &flag_detailed_statistics, 1},\n   {\"strict-prototype\", &flag_strict_prototype, 1},\n-  {\"this-is-variable\", &flag_this_is_variable, 1},\n   {\"vtable-gc\", &flag_vtable_gc, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n   {\"weak\", &flag_weak, 1},\n@@ -619,12 +618,6 @@ lang_decode_option (argc, argv)\n \t  flag_guiding_decls = 0;\n \t  found = 1;\n \t}\n-      else if (!strcmp (p, \"this-is-variable\"))\n-        {\n-          flag_this_is_variable = 1;\n-          found = 1;\n-          cp_deprecated (\"-fthis-is-variable\");\n-        }\n       else if (!strcmp (p, \"external-templates\"))\n         {\n           flag_external_templates = 1;\n@@ -1007,11 +1000,6 @@ grokclassfn (ctype, function, flags, quals)\n       /* Right now we just make this a pointer.  But later\n \t we may wish to make it special.  */\n       tree type = TREE_VALUE (arg_types);\n-      int constp = 1;\n-\n-      if ((flag_this_is_variable > 0)\n-\t  && (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function)))\n-\tconstp = 0;\n \n       parm = build_decl (PARM_DECL, this_identifier, type);\n       /* Mark the artificial `this' parameter as \"artificial\".  */\n@@ -1020,8 +1008,7 @@ grokclassfn (ctype, function, flags, quals)\n       /* We can make this a register, so long as we don't\n \t accidentally complain if someone tries to take its address.  */\n       DECL_REGISTER (parm) = 1;\n-      if (constp)\n-\tTREE_READONLY (parm) = 1;\n+      TREE_READONLY (parm) = 1;\n       TREE_CHAIN (parm) = last_function_parms;\n       last_function_parms = parm;\n     }"}, {"sha": "11b96c4f3393a7f9d625dca692075d5095e7279b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -483,7 +483,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n    Note that emit_base_init does *not* initialize virtual base\n    classes.  That is done specially, elsewhere.  */\n \n-void\n+tree\n emit_base_init (t)\n      tree t;\n {\n@@ -623,10 +623,9 @@ emit_base_init (t)\n       mem_init_list = TREE_CHAIN (mem_init_list);\n     }\n \n-  base_init_expr = finish_init_stmts (stmt_expr, compound_stmt);\n-\n   /* All the implicit try blocks we built up will be zapped\n      when we come to a real binding contour boundary.  */\n+  return finish_init_stmts (stmt_expr, compound_stmt);\n }\n \n /* Check that all fields are properly initialized after\n@@ -747,10 +746,6 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n   if_stmt = begin_if_stmt ();\n   finish_if_stmt_cond (flag, if_stmt);\n   result = init_vbase_pointers (type, this_ptr);\n-  /* The RESULT will contain entries on the momentary obstack.  They\n-     must live until the end of this function; we use them in the loop\n-     below.  */\n-  push_momentary ();\n   if (result)\n     finish_expr_stmt (build_compound_expr (result));\n   finish_then_clause (if_stmt);\n@@ -785,14 +780,11 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n \t\t\t\tTREE_OPERAND (TREE_VALUE (tmp), 0),\n \t\t\t\tinit_list);\n       finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n-      finish_then_clause (if_stmt);\n+      finish_then_clause (inner_if_stmt);\n       finish_if_stmt ();\n       \n       expand_cleanup_for_base (vbases, flag);\n     }\n-\n-  /* Undo the call to push_momentary above.  */\n-  pop_momentary ();\n }\n \n /* Find the context in which this FIELD can be initialized.  */\n@@ -2214,18 +2206,7 @@ build_new_1 (exp)\n \n   /* Allocate the object.  */\n   \n-  if (! has_array && ! placement && flag_this_is_variable > 0\n-      && TYPE_NEEDS_CONSTRUCTING (true_type) && init != void_type_node)\n-    {\n-      if (init == NULL_TREE || TREE_CODE (init) == TREE_LIST)\n-\trval = NULL_TREE;\n-      else\n-\t{\n-\t  error (\"constructors take parameter lists\");\n-\t  return error_mark_node;\n-\t}\n-    }\n-  else if (! placement && TYPE_FOR_JAVA (true_type))\n+  if (! placement && TYPE_FOR_JAVA (true_type))\n     {\n       tree class_addr, alloc_decl;\n       tree class_decl = build_java_class_ref (true_type);\n@@ -2677,7 +2658,6 @@ get_temp_regvar (type, init)\n   decl = create_temporary_var (type);\n   if (building_stmt_tree ())\n     add_decl_stmt (decl);\n-  DECL_REGISTER (decl) = 1;\n   if (!building_stmt_tree ())\n     DECL_RTL (decl) = assign_temp (type, 2, 0, 1);\n   finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n@@ -2827,9 +2807,6 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \n       /* Clear out INIT so that we don't get confused below.  */\n       init = NULL_TREE;\n-\n-      if (obey_regdecls && !building_stmt_tree ())\n-\tuse_variable (DECL_RTL (base));\n     }\n   else if (from_array)\n     {\n@@ -2958,13 +2935,6 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t\t\t   build (PLUS_EXPR, build_pointer_type (type), \n \t\t\t\t  base2, size)));\n \n-      if (obey_regdecls && !building_stmt_tree ())\n-\t{\n-\t  use_variable (DECL_RTL (base));\n-\t  if (base2)\n-\t    use_variable (DECL_RTL (base2));\n-\t}\n-\n       finish_compound_stmt (/*has_no_scope=*/1, do_body);\n       finish_do_body (do_stmt);\n       finish_do_stmt (build (NE_EXPR, boolean_type_node,\n@@ -2996,12 +2966,6 @@ build_vec_init (decl, base, maxindex, init, from_array)\n       finish_cleanup (e, try_block);\n     }\n \n-  if (obey_regdecls && !building_stmt_tree ())\n-    {\n-      use_variable (DECL_RTL (iterator));\n-      use_variable (DECL_RTL (rval));\n-    }\n-\n   /* The value of the array initialization is the address of the\n      first element in the array.  */\n   finish_expr_stmt (rval);"}, {"sha": "e1ff4cae665ef26fcb5d7aabebd17507f3940123", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -660,7 +660,7 @@ list.  In particular, no @code{FIELD_DECL}, @code{LABEL_DECL}, or\n A class type is represented by either a @code{RECORD_TYPE} or a\n @code{UNION_TYPE}.  A class declared with the @code{union} tag is\n represented by a @code{UNION_TYPE}, while classes declared with either\n-the @code{struct} or the @code{union} tag are represented by\n+the @code{struct} or the @code{class} tag are represented by\n @code{RECORD_TYPE}s.  You can use the @code{CLASSTYPE_DECLARED_CLASS}\n macro to discern whether or not a particular type is a @code{class} as\n opposed to a @code{struct}.  This macro will be true only for classes\n@@ -1010,7 +1010,6 @@ FIXME: Explain about constructor try-catch blocks.\n @tindex COMPOUND_STMT\n @findex COMPOUND_BODY\n @tindex CONTINUE_STMT\n-@tindex CTOR_INITIALIZER\n @tindex DECL_STMT\n @findex DECL_STMT_DECL\n @tindex DO_STMT\n@@ -1050,26 +1049,17 @@ FIXME: Explain about constructor try-catch blocks.\n @findex WHILE_COND\n \n A function that has a definition in the current translation unit will\n-have a non-NULL @code{DECL_INITIAL}.  However, the @code{DECL_INITIAL}\n-will simply be the @code{error_mark_node}.  (When tree structure is\n-translated to RTL, @code{DECL_INITIAL} will contain a different value.)\n+have a non-NULL @code{DECL_INITIAL}.  However, back-ends should not make\n+use of the particular value given by @code{DECL_INITIAL}.\n \n The @code{DECL_SAVED_TREE} macro will give the complete body of the\n function.  This node will usually be a @code{COMPOUND_STMT} representing\n the outermost block of the function, but it may also be a\n-@code{TRY_BLOCK}, @code{RETURN_INIT}, or @code{CTOR_INITIALIZER}, as\n-described below.\n+@code{TRY_BLOCK} or a @code{RETURN_INIT}.\n \n If the function has a function try-block, the @code{DECL_SAVED_TREE}\n will be a @code{TRY_BLOCK}.  The @code{TRY_STMTS} will then be either a\n-@code{RETURN_INIT}, @code{CTOR_INITIALIZER}, or @code{COMPOUND_STMT}.\n-\n-If the function is a constructor, the @code{DECL_SAVED_TREE} may be a\n-@code{CTOR_INITIALIZER} node, indicating how base classes and members\n-should be initialized.  The @code{TREE_CHAIN} of the\n-@code{CTOR_INITIALIZER} will be the @code{COMPOUND_STMT} representing\n-the body of the constructor.  FIXME: Document how the base initializers\n-and member initializers can be used.\n+@code{RETURN_INIT}, or a @code{COMPOUND_STMT}.\n \n If the function uses the G++ ``named return value'' extension, meaning\n that the function has been defined like:\n@@ -1079,10 +1069,8 @@ S f(int) return s @{...@}\n the @code{DECL_SAVED_TREE} will be a @code{RETURN_INIT}.  The\n @code{TREE_CHAIN} of the @code{RETURN_INIT} will be the\n @code{COMPOUND_STMT} representing the body of the function.  There is\n-never a named returned value for a constructor, so there is never a\n-situation in which a @code{RETURN_INIT} and a @code{CTOR_INITIALIZER}\n-appear simultaneously.  FIXME: Document how the @code{RETURN_INIT} can\n-be used.\n+never a named returned value for a constructor.  FIXME: Document how the\n+@code{RETURN_INIT} can be used.\n \n @subsection Statements\n \n@@ -1115,7 +1103,34 @@ Many of the statements have substatements.  For example, a @code{while}\n loop will have a body, which is itself a statement.  If the substatement\n is @code{NULL_TREE}, it is considered equivalent to a statement\n consisting of a single @code{;}, i.e., an expression statement in which\n-the expression has been omitted.\n+the expression has been omitted.  A substatement may in fact be a list\n+of statements, connected via their @code{TREE_CHAIN}s.  So, you should\n+always process the statement tree by looping over substatements, like\n+this:\n+@example\n+void process_stmt (stmt)\n+     tree stmt;\n+{\n+  while (stmt)\n+    {\n+      switch (TREE_CODE (stmt))\n+        {\n+        case IF_STMT:\n+          process_stmt (THEN_CLAUSE (stmt));\n+          /* More processing here.  */\n+          break;\n+        \n+        ...\n+        }\n+\n+      stmt = TREE_CHAIN (stmt);\n+    }\n+}\n+@end example\n+In other words, while the @code{then} clause of an @code{if} statement\n+in C++ can be only one statement (although that one statement may be a\n+compound statement), the intermediate representation will sometimes use\n+several statements chained together.\n \n @table @code\n @item ASM_STMT"}, {"sha": "f5bf2bb4923a9d8a61994e60b7f34cea71f8c253", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -96,8 +96,6 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fstrict-prototype\", \"\" },\n   { \"-fno-strict-prototype\", \"Do not assume that empty prototype means no args\" },\n   { \"-ftemplate-depth-\", \"Specify maximum template instantiation depth\"},\n-  { \"-fthis-is-variable\", \"Make 'this' not be type '* const'\"  },\n-  { \"-fno-this-is-variable\", \"\" },\n   { \"-fvtable-gc\", \"Discard unused virtual functions\" },\n   { \"-fno-vtable-gc\", \"\" },\n   { \"-fvtable-thunks\", \"Implement vtables using thunks\" },"}, {"sha": "e7f35fa0952081120cba6f614b40056ea6d8605d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -7261,11 +7261,6 @@ tsubst_expr (t, args, complain, in_decl)\n \n     case EXPR_STMT:\n       prep_stmt (t);\n-      /* If we're doing tsubst'ing, then we should not yet have done\n-\t semantic analysisy, so we should not know that this statement\n-\t assigns to the `this' pointer.  */\n-      my_friendly_assert (EXPR_STMT_ASSIGNS_THIS (t) == 0,\n-\t\t\t  19990831);\n       finish_expr_stmt (tsubst_expr (EXPR_STMT_EXPR (t),\n \t\t\t\t     args, complain, in_decl));\n       break;"}, {"sha": "1f599c457a04bb0e3d86361a456f5484aeb37e8e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -2609,12 +2609,12 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t      init = build (MODIFY_EXPR, TREE_TYPE (nvtbl),\n \t\t\t    nvtbl, vtbl);\n \t      TREE_SIDE_EFFECTS (init) = 1;\n-\t      expand_expr_stmt (init);\n+\t      finish_expr_stmt (init);\n \t      /* Update the vtable pointers as necessary.  */\n \t      ref = build_vfield_ref\n \t\t(build_indirect_ref (addr, NULL_PTR),\n \t\t DECL_CONTEXT (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))));\n-\t      expand_expr_stmt\n+\t      finish_expr_stmt\n \t\t(build_modify_expr (ref, NOP_EXPR, nvtbl));\n \t    }\n \t  assemble_external (vtbl);\n@@ -2657,7 +2657,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t    cp_build_qualified_type (TREE_TYPE (new_delta),\n \t\t\t\t     CP_TYPE_QUALS (TREE_TYPE (new_delta))\n \t\t\t\t     & ~TYPE_QUAL_CONST);\n-\t  expand_expr_stmt (build_modify_expr (new_delta, NOP_EXPR,\n+\t  finish_expr_stmt (build_modify_expr (new_delta, NOP_EXPR,\n \t\t\t\t\t       old_delta));\n \t}\n       ++n;"}, {"sha": "d5ef09abd44e5965fa84d757b1eefa6c1069d62c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 62, "deletions": 37, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -41,7 +41,6 @@\n    parsing into this file; that will make implementing the new parser\n    much easier since it will be able to make use of these routines.  */\n \n-static void finish_expr_stmt_real PROTO((tree, int));\n static tree expand_cond PROTO((tree));\n static tree maybe_convert_cond PROTO((tree));\n \n@@ -110,14 +109,11 @@ maybe_convert_cond (cond)\n   return condition_conversion (cond);\n }\n \n-/* Finish an expression-statement, whose EXPRESSION is as indicated.\n-   If ASSIGNED_THIS is non-zero, then this statement just assigned to\n-   the `this' pointer.  */\n+/* Finish an expression-statement, whose EXPRESSION is as indicated.  */\n \n-static void \n-finish_expr_stmt_real (expr, assigned_this)\n+void \n+finish_expr_stmt (expr)\n      tree expr;\n-     int assigned_this;\n {\n   if (expr != NULL_TREE)\n     {\n@@ -147,27 +143,13 @@ finish_expr_stmt_real (expr, assigned_this)\n \t}\n     }\n \n-  /* If this statement assigned to the `this' pointer, record that\n-     fact for finish_stmt.  */\n-  if (assigned_this)\n-    current_function_just_assigned_this = 1;\n-\n   finish_stmt ();\n \n   /* This was an expression-statement, so we save the type of the\n      expression.  */\n   last_expr_type = expr ? TREE_TYPE (expr) : NULL_TREE;\n }\n \n-/* Like finish_expr_stmt_real, but ASSIGNS_THIS is always zero.  */\n-\n-void\n-finish_expr_stmt (expr)\n-     tree expr;\n-{\n-  finish_expr_stmt_real (expr, /*assigns_this=*/0);\n-}\n-\n /* Begin an if-statement.  Returns a newly created IF_STMT if\n    appropriate.  */\n \n@@ -176,6 +158,8 @@ begin_if_stmt ()\n {\n   tree r;\n \n+  do_pushlevel ();\n+\n   if (building_stmt_tree ())\n     {\n       r = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n@@ -184,8 +168,6 @@ begin_if_stmt ()\n   else\n     r = NULL_TREE;\n \n-  do_pushlevel ();\n-\n   return r;\n }\n \n@@ -924,7 +906,9 @@ begin_compound_stmt (has_no_scope)\n \n   /* If this is the outermost block of the function, declare the\n      variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n-  if (!current_function_name_declared && !processing_template_decl)\n+  if (!current_function_name_declared \n+      && !processing_template_decl\n+      && !has_no_scope)\n     {\n       declare_function_name ();\n       current_function_name_declared = 1;\n@@ -1163,21 +1147,69 @@ finish_named_return_value (return_id, init)\n void\n setup_vtbl_ptr ()\n {\n-  if (base_init_expr == 0\n-      && DECL_CONSTRUCTOR_P (current_function_decl))\n+  my_friendly_assert (doing_semantic_analysis_p (), 19990919);\n+\n+  /* If we've already done this, there's no need to do it again.  */\n+  if (vtbls_set_up_p)\n+    return;\n+\n+  if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n-      if (building_stmt_tree ())\n+      if (processing_template_decl)\n \tadd_tree (build_min_nt\n \t\t  (CTOR_INITIALIZER,\n \t\t   current_member_init_list, current_base_init_list));\n       else\n-\temit_base_init (current_class_type);\n+\tfinish_expr_stmt (emit_base_init (current_class_type));\n+    }\n+  else if (DECL_DESTRUCTOR_P (current_function_decl)\n+\t   && !processing_template_decl)\n+    {\n+      tree binfo = TYPE_BINFO (current_class_type);\n+      tree if_stmt;\n+      tree compound_stmt;\n+\n+      /* If the dtor is empty, and we know there is not possible way we\n+\t could use any vtable entries, before they are possibly set by\n+\t a base class dtor, we don't have to setup the vtables, as we\n+\t know that any base class dtoring will set up any vtables it\n+\t needs.  We avoid MI, because one base class dtor can do a\n+\t virtual dispatch to an overridden function that would need to\n+\t have a non-related vtable set up, we cannot avoid setting up\n+\t vtables in that case.  We could change this to see if there is\n+\t just one vtable.  */\n+      if_stmt = begin_if_stmt ();\n+\n+      /* If it is not safe to avoid setting up the vtables, then\n+\t someone will change the condition to be boolean_true_node.  \n+         (Actually, for now, we do not have code to set the condition\n+\t appropriate, so we just assume that we always need to\n+\t initialize the vtables.)  */\n+      finish_if_stmt_cond (boolean_true_node, if_stmt);\n+      current_vcalls_possible_p = &IF_COND (if_stmt);\n+      compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+\n+      /* Make all virtual function table pointers in non-virtual base\n+\t classes point to CURRENT_CLASS_TYPE's virtual function\n+\t tables.  */\n+      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_ptr);\n+\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+\texpand_indirect_vtbls_init (binfo, current_class_ref, \n+\t\t\t\t    current_class_ptr);\n+\n+      finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt ();\n     }\n \n   /* Always keep the BLOCK node associated with the outermost pair of\n-     curley braces of a function.  These are needed for correct\n+     curly braces of a function.  These are needed for correct\n      operation of dwarfout.c.  */\n   keep_next_level (1);\n+\n+  /* The virtual function tables are set up now.  */\n+  vtbls_set_up_p = 1;\n }\n \n /* Begin a new scope.  */\n@@ -2214,8 +2246,7 @@ expand_stmt (t)\n \t  break;\n \n \tcase EXPR_STMT:\n-\t  finish_expr_stmt_real (EXPR_STMT_EXPR (t),\n-\t\t\t\t EXPR_STMT_ASSIGNS_THIS (t));\n+\t  finish_expr_stmt (EXPR_STMT_EXPR (t));\n \t  break;\n \n \tcase DECL_STMT:\n@@ -2394,12 +2425,6 @@ expand_stmt (t)\n \t    expand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n \t  break;\n \n-\tcase CTOR_INITIALIZER:\n-\t  current_member_init_list = TREE_OPERAND (t, 0);\n-\t  current_base_init_list = TREE_OPERAND (t, 1);\n-\t  setup_vtbl_ptr ();\n-\t  break;\n-\n \tcase RETURN_INIT:\n \t  /* Clear this out so that finish_named_return_value can set it\n \t     again.  */"}, {"sha": "f4cdc92b7708c51891cc06274b79e0c6de182885", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -5802,17 +5802,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \t}\n     }\n \n-  /* check to see if there is an assignment to `this' */\n-  if (lhs == current_class_ptr)\n-    {\n-      if (flag_this_is_variable > 0\n-\t  && DECL_NAME (current_function_decl) != NULL_TREE\n-\t  && (DECL_NAME (current_function_decl)\n-\t      != constructor_name (current_class_type)))\n-\twarning (\"assignment to `this' not in constructor or destructor\");\n-      current_function_just_assigned_this = 1;\n-    }\n-\n   if (modifycode != INIT_EXPR)\n     {\n       /* Make modifycode now either a NOP_EXPR or an INIT_EXPR.  */\n@@ -6716,10 +6705,7 @@ c_expand_return (retval)\n     }\n   else if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n-      if (flag_this_is_variable)\n-\terror (\"return from a constructor: use `this = ...' instead\");\n-      else\n-\terror (\"returning a value from a constructor\");\n+      error (\"returning a value from a constructor\");\n       retval = current_class_ptr;\n     }\n "}, {"sha": "39575d2913d81cf9186e713ab22afa0631d0131b", "filename": "gcc/testsuite/g++.old-deja/g++.other/static8.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bfadf57a238dc37fc2b63a1fc2ba75495201063/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C?ref=9bfadf57a238dc37fc2b63a1fc2ba75495201063", "patch": "@@ -0,0 +1,7 @@\n+// Build don't link:\n+// Special g++ Options: -fno-squangle\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+static unsigned int strlen (const char*) {} // ERROR - previous declaration\n+\n+int strlen__FPCc = 0; // ERROR - duplicate declaration"}]}