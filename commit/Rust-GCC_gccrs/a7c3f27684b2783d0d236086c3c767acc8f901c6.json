{"sha": "a7c3f27684b2783d0d236086c3c767acc8f901c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdjM2YyNzY4NGIyNzgzZDBkMjM2MDg2YzNjNzY3YWNjOGY5MDFjNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-04-09T00:09:28Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-04-09T00:09:28Z"}, "message": "re PR c++/59115 (ICE with invalid template parameter)\n\n/cp\n2014-04-08  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/59115\n\t* pt.c (process_template_parm): For an invalid non-type parameter\n\tonly set TREE_TYPE to error_mark_node.\n\t(push_inline_template_parms_recursive, comp_template_parms,\n\tredeclare_class_template, coerce_template_template_parm,\n\tcoerce_template_template_parms, unify): Use error_operand_p.\n\n/testsuite\n2014-04-08  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/59115\n\t* g++.dg/template/crash119.C: New.\n\nFrom-SVN: r209230", "tree": {"sha": "176512599b63bfa609a087005a533215c8787c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/176512599b63bfa609a087005a533215c8787c0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7c3f27684b2783d0d236086c3c767acc8f901c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c3f27684b2783d0d236086c3c767acc8f901c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c3f27684b2783d0d236086c3c767acc8f901c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c3f27684b2783d0d236086c3c767acc8f901c6/comments", "author": null, "committer": null, "parents": [{"sha": "edb2b1b1fa0af901ab22ed58a4644115d3f4bbff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edb2b1b1fa0af901ab22ed58a4644115d3f4bbff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edb2b1b1fa0af901ab22ed58a4644115d3f4bbff"}], "stats": {"total": 103, "additions": 54, "deletions": 49}, "files": [{"sha": "4a25ad94e4d9eff73e256adf925da19116112b01", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a7c3f27684b2783d0d236086c3c767acc8f901c6", "patch": "@@ -1,3 +1,12 @@\n+2014-04-08  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/59115\n+\t* pt.c (process_template_parm): For an invalid non-type parameter\n+\tonly set TREE_TYPE to error_mark_node.\n+\t(push_inline_template_parms_recursive, comp_template_parms,\n+\tredeclare_class_template, coerce_template_template_parm,\n+\tcoerce_template_template_parms, unify): Use error_operand_p.\n+\n 2014-04-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (check_bases_and_members): Warn about non-virtual dtors"}, {"sha": "eaa4ba2824e4b0e6d5c9b6d0eb16a67c94d35322", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a7c3f27684b2783d0d236086c3c767acc8f901c6", "patch": "@@ -414,7 +414,7 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n \n-      if (parm == error_mark_node)\n+      if (error_operand_p (parm))\n \tcontinue;\n \n       gcc_assert (DECL_P (parm));\n@@ -2829,7 +2829,7 @@ comp_template_parms (const_tree parms1, const_tree parms2)\n \n           /* If either of the template parameters are invalid, assume\n              they match for the sake of error recovery. */\n-          if (parm1 == error_mark_node || parm2 == error_mark_node)\n+          if (error_operand_p (parm1) || error_operand_p (parm2))\n             return 1;\n \n \t  if (TREE_CODE (parm1) != TREE_CODE (parm2))\n@@ -3640,19 +3640,14 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n    to the LIST being built.  This new parameter is a non-type\n    parameter iff IS_NON_TYPE is true. This new parameter is a\n    parameter pack iff IS_PARAMETER_PACK is true.  The location of PARM\n-   is in PARM_LOC. NUM_TEMPLATE_PARMS is the size of the template\n-   parameter list PARM belongs to. This is used used to create a\n-   proper canonical type for the type of PARM that is to be created,\n-   iff PARM is a type.  If the size is not known, this parameter shall\n-   be set to 0.  */\n+   is in PARM_LOC.  */\n \n tree\n process_template_parm (tree list, location_t parm_loc, tree parm,\n \t\t       bool is_non_type, bool is_parameter_pack)\n {\n   tree decl = 0;\n   tree defval;\n-  tree err_parm_list;\n   int idx = 0;\n \n   gcc_assert (TREE_CODE (parm) == TREE_LIST);\n@@ -3673,48 +3668,36 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n \n       ++idx;\n     }\n-  else\n-    idx = 0;\n \n   if (is_non_type)\n     {\n       parm = TREE_VALUE (parm);\n \n       SET_DECL_TEMPLATE_PARM_P (parm);\n \n-      if (TREE_TYPE (parm) == error_mark_node)\n-        {\n-          err_parm_list = build_tree_list (defval, parm);\n-          TREE_VALUE (err_parm_list) = error_mark_node;\n-\t   return chainon (list, err_parm_list);\n-        }\n-      else\n-      {\n-\t/* [temp.param]\n-\n-\t   The top-level cv-qualifiers on the template-parameter are\n-\t   ignored when determining its type.  */\n-\tTREE_TYPE (parm) = TYPE_MAIN_VARIANT (TREE_TYPE (parm));\n-\tif (invalid_nontype_parm_type_p (TREE_TYPE (parm), 1))\n-          {\n-            err_parm_list = build_tree_list (defval, parm);\n-            TREE_VALUE (err_parm_list) = error_mark_node;\n-\t     return chainon (list, err_parm_list);\n-          }\n+      if (TREE_TYPE (parm) != error_mark_node)\n+\t{\n+\t  /* [temp.param]\n+\n+\t     The top-level cv-qualifiers on the template-parameter are\n+\t     ignored when determining its type.  */\n+\t  TREE_TYPE (parm) = TYPE_MAIN_VARIANT (TREE_TYPE (parm));\n+\t  if (invalid_nontype_parm_type_p (TREE_TYPE (parm), 1))\n+\t    TREE_TYPE (parm) = error_mark_node;\n+\t  else if (uses_parameter_packs (TREE_TYPE (parm))\n+\t\t   && !is_parameter_pack\n+\t\t   /* If we're in a nested template parameter list, the template\n+\t\t      template parameter could be a parameter pack.  */\n+\t\t   && processing_template_parmlist == 1)\n+\t    {\n+\t      /* This template parameter is not a parameter pack, but it\n+\t\t should be. Complain about \"bare\" parameter packs.  */\n+\t      check_for_bare_parameter_packs (TREE_TYPE (parm));\n \n-        if (uses_parameter_packs (TREE_TYPE (parm)) && !is_parameter_pack\n-\t    /* If we're in a nested template parameter list, the template\n-\t       template parameter could be a parameter pack.  */\n-\t    && processing_template_parmlist == 1)\n-\t  {\n-\t    /* This template parameter is not a parameter pack, but it\n-\t       should be. Complain about \"bare\" parameter packs.  */\n-\t    check_for_bare_parameter_packs (TREE_TYPE (parm));\n-\t    \n-\t    /* Recover by calling this a parameter pack.  */\n-\t    is_parameter_pack = true;\n-\t  }\n-      }\n+\t      /* Recover by calling this a parameter pack.  */\n+\t      is_parameter_pack = true;\n+\t    }\n+\t}\n \n       /* A template parameter is not modifiable.  */\n       TREE_CONSTANT (parm) = 1;\n@@ -5127,7 +5110,7 @@ redeclare_class_template (tree type, tree parms)\n         continue;\n \n       tmpl_parm = TREE_VALUE (TREE_VEC_ELT (tmpl_parms, i));\n-      if (tmpl_parm == error_mark_node)\n+      if (error_operand_p (tmpl_parm))\n \treturn false;\n \n       parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n@@ -6087,8 +6070,8 @@ coerce_template_template_parm (tree parm,\n                               tree in_decl,\n                               tree outer_args)\n {\n-  if (arg == NULL_TREE || arg == error_mark_node\n-      || parm == NULL_TREE || parm == error_mark_node)\n+  if (arg == NULL_TREE || error_operand_p (arg)\n+      || parm == NULL_TREE || error_operand_p (parm))\n     return 0;\n   \n   if (TREE_CODE (arg) != TREE_CODE (parm))\n@@ -6181,7 +6164,7 @@ coerce_template_template_parms (tree parm_parms,\n     {\n       parm = TREE_VALUE (TREE_VEC_ELT (parm_parms, nparms - 1));\n       \n-      if (parm == error_mark_node)\n+      if (error_operand_p (parm))\n \treturn 0;\n \n       switch (TREE_CODE (parm))\n@@ -17517,7 +17500,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n     case TEMPLATE_TEMPLATE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n-      if (tparm == error_mark_node)\n+      if (error_operand_p (tparm))\n \treturn unify_invalid (explain_p);\n \n       if (TEMPLATE_TYPE_LEVEL (parm)\n@@ -17535,7 +17518,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n       idx = TEMPLATE_TYPE_IDX (parm);\n       targ = TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx);\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, idx));\n-      if (tparm == error_mark_node)\n+      if (error_operand_p (tparm))\n \treturn unify_invalid (explain_p);\n \n       /* Check for mixed types and values.  */\n@@ -17718,7 +17701,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n     case TEMPLATE_PARM_INDEX:\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n-      if (tparm == error_mark_node)\n+      if (error_operand_p (tparm))\n \treturn unify_invalid (explain_p);\n \n       if (TEMPLATE_PARM_LEVEL (parm)"}, {"sha": "86a3f29acc35271064576d7a0834eec07646514d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a7c3f27684b2783d0d236086c3c767acc8f901c6", "patch": "@@ -1,3 +1,8 @@\n+2014-04-08  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/59115\n+\t* g++.dg/template/crash119.C: New.\n+\n 2014-04-08  Pat Haugen  <pthaugen@us.ibm.com>\n \n \t* gcc.target/powerpc/atomic_load_store-p8.c: New."}, {"sha": "95d80a8ffc56ad821ee9785ad30be3881d2d7544", "filename": "gcc/testsuite/g++.dg/template/crash119.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash119.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c3f27684b2783d0d236086c3c767acc8f901c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash119.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash119.C?ref=a7c3f27684b2783d0d236086c3c767acc8f901c6", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/59115\n+\n+template<typename T, float, int, typename U> void foo(T, U) {} // { dg-error \"valid type\" }\n+\n+void bar()\n+{\n+  foo(0, 0);  // { dg-error \"matching\" }\n+}"}]}