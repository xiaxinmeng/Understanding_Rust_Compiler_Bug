{"sha": "0154eaa8122a7a848fd40a79d30d3835508e2ab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE1NGVhYTgxMjJhN2E4NDhmZDQwYTc5ZDMwZDM4MzU1MDhlMmFiNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-04-07T06:09:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-04-07T06:09:27Z"}, "message": "re PR c++/5571 (crash in initialization of a static variable)\n\n\tPR c++/5571\n\t* stor-layout.c (layout_decl): Reset the RTL for the decl.\n\n\t* class.c (layout_class_type): Remember incomplete static\n\tvariables.\n\t(finish_struct_1): Call complete_vars, not\n\thack_incomplete_structures.\n\t* cp-tree.h (hack_incomplete_structures): Rename to ...\n\t(complete_vars): ... this.\n\t(struct saved_scope): Remove incomplete.\n\t(namespace_scope_incomplete): Remove.\n\t* decl.c (struct binding_level): Remove incomplete.\n\t(incomplete_vars): New variable.\n\t(mark_binding_level): Don't mark incomplete.\n\t(print_binding_level): Don't print it.\n\t(mark_saved_scope): Don't mark incomplete.\n\t(pushdecl): Use maybe_register_incopmlete_var.\n\t(cxx_init_decl_processing): Register incomplete_vars for GC.\n\t(start_decl_1): Clarify error message.\n\t(hack_incomplete_vars): Remove.\n\t(maybe_register_incomplete_var): New function.\n\t(complete_vars): Likewise.\n\n\t* g++.dg/opt/static2.C: New test.\n\nFrom-SVN: r51978", "tree": {"sha": "ee0530774216b52056190f27b4f1d7190346ac3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee0530774216b52056190f27b4f1d7190346ac3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0154eaa8122a7a848fd40a79d30d3835508e2ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0154eaa8122a7a848fd40a79d30d3835508e2ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0154eaa8122a7a848fd40a79d30d3835508e2ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0154eaa8122a7a848fd40a79d30d3835508e2ab6/comments", "author": null, "committer": null, "parents": [{"sha": "da00eaab0b9831c4d6aa278547c75cbad1ce6595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da00eaab0b9831c4d6aa278547c75cbad1ce6595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da00eaab0b9831c4d6aa278547c75cbad1ce6595"}], "stats": {"total": 204, "additions": 117, "deletions": 87}, "files": [{"sha": "abe29ba04a037a9bdf02fc3d6b6e00729d2b45b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -37,6 +37,9 @@\n \n 2002-04-06  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/5571\n+\t* stor-layout.c (layout_decl): Reset the RTL for the decl.\n+\n \tPR opt/5120\n \t* sibcall.c (optimize_sibling_and_tail_recursive_call): Clear\n \tRTX_UNCHANGING_P for the functions arguments when a tail call"}, {"sha": "1d2470abf476bd3b660cadcb89dd5b38a78ff1e0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -1,3 +1,26 @@\n+2002-04-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/5571\n+\t* class.c (layout_class_type): Remember incomplete static\n+\tvariables.\n+\t(finish_struct_1): Call complete_vars, not\n+\thack_incomplete_structures.\n+\t* cp-tree.h (hack_incomplete_structures): Rename to ...\n+\t(complete_vars): ... this.\n+\t(struct saved_scope): Remove incomplete.\n+\t(namespace_scope_incomplete): Remove.\n+\t* decl.c (struct binding_level): Remove incomplete.\n+\t(incomplete_vars): New variable.\n+\t(mark_binding_level): Don't mark incomplete.\n+\t(print_binding_level): Don't print it.\n+\t(mark_saved_scope): Don't mark incomplete.\n+\t(pushdecl): Use maybe_register_incopmlete_var.\n+\t(cxx_init_decl_processing): Register incomplete_vars for GC.\n+\t(start_decl_1): Clarify error message.\n+\t(hack_incomplete_vars): Remove.\n+\t(maybe_register_incomplete_var): New function.\n+\t(complete_vars): Likewise.\n+\n 2002-04-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/4934"}, {"sha": "ba28e849554a184f2434d65d37a434ecd3288897", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -4898,6 +4898,18 @@ layout_class_type (t, empty_p, vfuns_p,\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n \t  place_field (rli, field);\n+\t  /* If the static data member has incomplete type, keep track\n+\t     of it so that it can be completed later.  (The handling \n+\t     of pending statics in finish_record_layout is\n+\t     insufficient; consider:\n+\n+\t       struct S1;\n+\t       struct S2 { static S1 s1; };\n+\t       \n+             At this point, finish_record_layout will be called, but\n+\t     S1 is still incomplete.)  */\n+\t  if (TREE_CODE (field) == VAR_DECL)\n+\t    maybe_register_incomplete_var (field);\n \t  continue;\n \t}\n \n@@ -5240,7 +5252,7 @@ finish_struct_1 (t)\n       && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 1)) == NULL_TREE)\n     warning (\"`%#T' has virtual functions but non-virtual destructor\", t);\n \n-  hack_incomplete_structures (t);\n+  complete_vars (t);\n \n   if (warn_overloaded_virtual)\n     warn_hidden (t);"}, {"sha": "1cd7d4add53ae31535c76aede77a5549eccee5d0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -730,7 +730,6 @@ struct saved_scope\n   tree x_previous_class_type;\n   tree x_previous_class_values;\n   tree x_saved_tree;\n-  tree incomplete;\n   tree lookups;\n   tree last_parms;\n \n@@ -795,10 +794,6 @@ struct saved_scope\n \n #define previous_class_values scope_chain->x_previous_class_values\n \n-/* A list of the declarations with incomplete type at namespace scope.  */\n-\n-#define namespace_scope_incomplete scope_chain->incomplete\n-\n /* A list of private types mentioned, for deferred access checking.  */\n \n #define type_lookups scope_chain->lookups\n@@ -3766,7 +3761,8 @@ extern void finish_function_body\t\tPARAMS ((tree));\n extern tree finish_function\t\t\tPARAMS ((int));\n extern tree start_method\t\t\tPARAMS ((tree, tree, tree));\n extern tree finish_method\t\t\tPARAMS ((tree));\n-extern void hack_incomplete_structures\t\tPARAMS ((tree));\n+extern void maybe_register_incomplete_var       PARAMS ((tree));\n+extern void complete_vars\t\t\tPARAMS ((tree));\n extern void finish_stmt\t\t\t\tPARAMS ((void));\n extern void print_other_binding_stack\t\tPARAMS ((struct binding_level *));\n extern void revert_static_member_fn             PARAMS ((tree));"}, {"sha": "383991f0924a5c01dacd7aa2001ba780a626362b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 53, "deletions": 80, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -398,10 +398,6 @@ struct binding_level\n     /* The binding level which this one is contained in (inherits from).  */\n     struct binding_level *level_chain;\n \n-    /* List of decls in `names' that have incomplete\n-       structure or union types.  */\n-    tree incomplete;\n-\n     /* List of VAR_DECLS saved from a previous for statement.\n        These would be dead in ISO-conforming code, but might\n        be referenced in ARM-era code.  These are stored in a\n@@ -484,6 +480,12 @@ static struct binding_level *global_binding_level;\n \n static int keep_next_level_flag;\n \n+/* A TREE_LIST of VAR_DECLs.  The TREE_PURPOSE is a RECORD_TYPE or\n+   UNION_TYPE; the TREE_VALUE is a VAR_DECL with that type.  At the\n+   time the VAR_DECL was declared, the type was incomplete.  */\n+\n+static tree incomplete_vars;\n+\n #if defined(DEBUG_CP_BINDING_LEVELS)\n static int binding_depth = 0;\n static int is_class_level = 0;\n@@ -1957,7 +1959,6 @@ mark_binding_level (arg)\n       ggc_mark_tree (lvl->shadowed_labels);\n       ggc_mark_tree (lvl->blocks);\n       ggc_mark_tree (lvl->this_class);\n-      ggc_mark_tree (lvl->incomplete);\n       ggc_mark_tree (lvl->dead_vars_from_for);\n     }\n }\n@@ -1995,8 +1996,6 @@ print_binding_level (lvl)\n   int i = 0, len;\n   fprintf (stderr, \" blocks=\");\n   fprintf (stderr, HOST_PTR_PRINTF, lvl->blocks);\n-  fprintf (stderr, \" n_incomplete=%d parm_flag=%d keep=%d\",\n-\t   list_length (lvl->incomplete), lvl->parm_flag, lvl->keep);\n   if (lvl->tag_transparent)\n     fprintf (stderr, \" tag-transparent\");\n   if (lvl->more_cleanups_ok)\n@@ -2397,7 +2396,6 @@ mark_saved_scope (arg)\n       ggc_mark_tree (t->x_previous_class_type);\n       ggc_mark_tree (t->x_previous_class_values);\n       ggc_mark_tree (t->x_saved_tree);\n-      ggc_mark_tree (t->incomplete);\n       ggc_mark_tree (t->lookups);\n \n       mark_stmt_tree (&t->x_stmt_tree);\n@@ -4242,22 +4240,8 @@ pushdecl (x)\n       if (TREE_CODE (x) == FUNCTION_DECL)\n \tcheck_default_args (x);\n \n-      /* Keep count of variables in this level with incomplete type.  */\n-      if (TREE_CODE (x) == VAR_DECL\n-\t  && TREE_TYPE (x) != error_mark_node\n-\t  && ((!COMPLETE_TYPE_P (TREE_TYPE (x))\n-\t       && PROMOTES_TO_AGGR_TYPE (TREE_TYPE (x), ARRAY_TYPE))\n-\t      /* RTTI TD entries are created while defining the type_info.  */\n-\t      || (TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n-\t\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))))\n-\t{\n-\t  if (namespace_bindings_p ())\n-\t    namespace_scope_incomplete\n-\t      = tree_cons (NULL_TREE, x, namespace_scope_incomplete);\n-\t  else\n-\t    current_binding_level->incomplete\n-\t      = tree_cons (NULL_TREE, x, current_binding_level->incomplete);\n-\t}\n+      if (TREE_CODE (x) == VAR_DECL)\n+\tmaybe_register_incomplete_var (x);\n     }\n \n   if (need_new_binding)\n@@ -6649,6 +6633,7 @@ cxx_init_decl_processing ()\n   ggc_add_tree_root (&current_lang_name, 1);\n   ggc_add_tree_root (&static_aggregates, 1);\n   ggc_add_tree_root (&free_bindings, 1);\n+  ggc_add_tree_root (&incomplete_vars, 1);\n }\n \n /* Generate an initializer for a function naming variable from\n@@ -7430,7 +7415,7 @@ start_decl_1 (decl)\n       if ((! processing_template_decl || ! uses_template_parms (type))\n \t  && !COMPLETE_TYPE_P (complete_type (type)))\n \t{\n-\t  error (\"aggregate `%#D' has incomplete type and cannot be initialized\",\n+\t  error (\"aggregate `%#D' has incomplete type and cannot be defined\",\n \t\t decl);\n \t  /* Change the type so that assemble_variable will give\n \t     DECL an rtl we can live with: (mem (const_int 0)).  */\n@@ -14432,72 +14417,60 @@ finish_method (decl)\n   return decl;\n }\n \f\n-/* Called when a new struct TYPE is defined.\n-   If this structure or union completes the type of any previous\n-   variable declaration, lay it out and output its rtl.  */\n+\n+/* VAR is a VAR_DECL.  If its type is incomplete, remember VAR so that\n+   we can lay it out later, when and if its type becomes complete.  */\n \n void\n-hack_incomplete_structures (type)\n-     tree type;\n+maybe_register_incomplete_var (var)\n+     tree var;\n {\n-  tree *list;\n-  struct binding_level *level;\n+  my_friendly_assert (TREE_CODE (var) == VAR_DECL, 20020406);\n \n-  if (!type) /* Don't do this for class templates.  */\n-    return;\n-\n-  if (namespace_bindings_p ())\n-    {\n-      level = 0;\n-      list = &namespace_scope_incomplete;\n-    }\n-  else\n+  /* Keep track of variables with incomplete types.  */\n+  if (!processing_template_decl && TREE_TYPE (var) != error_mark_node \n+      && DECL_EXTERNAL (var))\n     {\n-      level = innermost_nonclass_level ();\n-      list = &level->incomplete;\n+      tree inner_type = TREE_TYPE (var);\n+      \n+      while (TREE_CODE (inner_type) == ARRAY_TYPE)\n+\tinner_type = TREE_TYPE (inner_type);\n+      inner_type = TYPE_MAIN_VARIANT (inner_type);\n+      \n+      if ((!COMPLETE_TYPE_P (inner_type) && CLASS_TYPE_P (inner_type))\n+\t  /* RTTI TD entries are created while defining the type_info.  */\n+\t  || (TYPE_LANG_SPECIFIC (inner_type)\n+\t      && TYPE_BEING_DEFINED (inner_type)))\n+\tincomplete_vars = tree_cons (inner_type, var, incomplete_vars);\n     }\n+}\n \n-  while (1)\n-    {\n-      while (*list)\n-\t{\n-\t  tree decl = TREE_VALUE (*list);\n-\t  if ((decl && TREE_TYPE (decl) == type)\n-\t      || (TREE_TYPE (decl)\n-\t\t  && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t\t  && TREE_TYPE (TREE_TYPE (decl)) == type))\n-\t    {\n-\t      int toplevel = toplevel_bindings_p ();\n-\t      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n-\t\t  && TREE_TYPE (TREE_TYPE (decl)) == type)\n-\t\tlayout_type (TREE_TYPE (decl));\n-\t      layout_decl (decl, 0);\n-\t      rest_of_decl_compilation (decl, NULL, toplevel, 0);\n-\t      if (! toplevel)\n-\t\t{\n-\t\t  tree cleanup;\n-\t\t  expand_decl (decl);\n-\t\t  cleanup = cxx_maybe_build_cleanup (decl);\n-\t\t  expand_decl_init (decl);\n-\t\t  if (! expand_decl_cleanup (decl, cleanup))\n-\t\t    error (\"parser lost in parsing declaration of `%D'\",\n-\t\t\t      decl);\n-\t\t}\n-\t      *list = TREE_CHAIN (*list);\n-\t    }\n-\t  else\n-\t    list = &TREE_CHAIN (*list);\n-\t}\n+/* Called when a class type (given by TYPE) is defined.  If there are\n+   any existing VAR_DECLs whose type hsa been completed by this\n+   declaration, update them now.  */\n \n-      /* Keep looking through artificial binding levels generated\n-\t for local variables.  */\n-      if (level && level->keep == 2)\n+void\n+complete_vars (type)\n+     tree type;\n+{\n+  tree *list = &incomplete_vars;\n+\n+  my_friendly_assert (CLASS_TYPE_P (type), 20020406);\n+  while (*list) \n+    {\n+      if (same_type_p (type, TREE_PURPOSE (*list)))\n \t{\n-\t  level = level->level_chain;\n-\t  list = &level->incomplete;\n+\t  tree var = TREE_VALUE (*list);\n+\t  /* Make sure that the type of the VAR has been laid out.  It\n+\t     might not have been if the type of VAR is an array.  */\n+\t  layout_type (TREE_TYPE (var));\n+\t  /* Lay out the variable itself.  */\n+\t  layout_decl (var, 0);\n+\t  /* Remove this entry from the list.  */\n+\t  *list = TREE_CHAIN (*list);\n \t}\n       else\n-\tbreak;\n+\tlist = &TREE_CHAIN (*list);\n     }\n }\n "}, {"sha": "fbf5e4f42ad4919f103ff0ef02923aabec3de3d3", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -461,6 +461,11 @@ layout_decl (decl, known_align)\n \t\t\t       larger_than_size);\n \t}\n     }\n+\n+  /* If there was already RTL for this DECL, as for a variable with an\n+     incomplete type whose type is completed later, update the RTL.  */\n+  if (DECL_RTL_SET_P (decl))\n+    make_decl_rtl (decl, NULL);\n }\n \f\n /* Hook for a front-end function that can modify the record layout as needed"}, {"sha": "c71c02ebbe2f5463264a80d4758ba391315956ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -1,3 +1,8 @@\n+2002-04-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/5571\n+\t* g++.dg/opt/static2.C: New test.\n+\n 2002-04-06  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c/5120"}, {"sha": "e2ecd13c57277a3d19c5d83797a67a85b79d111d", "filename": "gcc/testsuite/g++.dg/opt/static2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstatic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0154eaa8122a7a848fd40a79d30d3835508e2ab6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstatic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstatic2.C?ref=0154eaa8122a7a848fd40a79d30d3835508e2ab6", "patch": "@@ -0,0 +1,13 @@\n+// Origin: reichelt@igpm.rwth-aachen.de\n+// PR 5571\n+// { dg-options \"-O2\" }\n+\n+template <class T> struct A {};\n+\n+struct B\n+{\n+    static A<int> a;\n+    void f() { a; }\n+};\n+\n+A<int> B::a = A<int>();"}]}