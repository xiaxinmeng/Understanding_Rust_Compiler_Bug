{"sha": "6a78b724701505a225b87a4915d4040217d5833d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3OGI3MjQ3MDE1MDVhMjI1Yjg3YTQ5MTVkNDA0MDIxN2Q1ODMzZA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2010-06-16T22:52:25Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2010-06-16T22:52:25Z"}, "message": "common.opt (-fstrict-volatile-bitfields): new.\n\n* common.opt (-fstrict-volatile-bitfields): new.\n* doc/invoke.texi: Document it.\n* fold-const.c (optimize_bit_field_compare): For volatile\nbitfields, use the field's type to determine the mode, not the\nfield's size.\n* expr.c (expand_assignment): Likewise.\n(get_inner_reference): Likewise.\n(expand_expr_real_1): Likewise.\n* expmed.c (store_fixed_bit_field): Likewise.\n(extract_bit_field_1): Likewise.\n(extract_fixed_bit_field): Likewise.\n\n* gcc.target/i386/volatile-bitfields-1.c: New.\n* gcc.target/i386/volatile-bitfields-2.c: New.\n\nFrom-SVN: r160865", "tree": {"sha": "3dd0caaaba78a7ab2d30d7b774f9c8f7ea157dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd0caaaba78a7ab2d30d7b774f9c8f7ea157dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a78b724701505a225b87a4915d4040217d5833d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a78b724701505a225b87a4915d4040217d5833d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a78b724701505a225b87a4915d4040217d5833d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a78b724701505a225b87a4915d4040217d5833d/comments", "author": null, "committer": null, "parents": [{"sha": "f1071b127d01cbf763ae493b6d88ccc6185c3cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1071b127d01cbf763ae493b6d88ccc6185c3cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1071b127d01cbf763ae493b6d88ccc6185c3cdf"}], "stats": {"total": 206, "additions": 191, "deletions": 15}, "files": [{"sha": "2ee859beb6ce7ec437f5b45f2cd7282a21966e4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -1,3 +1,17 @@\n+2010-06-16  DJ Delorie  <dj@redhat.com>\n+\n+\t* common.opt (-fstrict-volatile-bitfields): new.\n+\t* doc/invoke.texi: Document it.\n+\t* fold-const.c (optimize_bit_field_compare): For volatile\n+\tbitfields, use the field's type to determine the mode, not the\n+\tfield's size.\n+\t* expr.c (expand_assignment): Likewise.\n+\t(get_inner_reference): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* expmed.c (store_fixed_bit_field): Likewise.\n+\t(extract_bit_field_1): Likewise.\n+\t(extract_fixed_bit_field): Likewise.\n+\n 2010-06-16  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-inline.c (remap_gimple_op_r): Recurse using"}, {"sha": "968663a43e4444dc2aade7dd1d24871a9ad304c0", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -629,6 +629,10 @@ floop-block\n Common Report Var(flag_loop_block) Optimization\n Enable Loop Blocking transformation\n \n+fstrict-volatile-bitfields\n+Common Report Var(flag_strict_volatile_bitfields) Init(-1)\n+Force bitfield accesses to match their type width\n+\n fguess-branch-probability\n Common Report Var(flag_guess_branch_prob) Optimization\n Enable guessing of branch probabilities"}, {"sha": "88240fcc19fd6fbb2cc81d66e4b789b14a960ed6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -17725,6 +17725,32 @@ the DSOs.\n An overview of these techniques, their benefits and how to use them\n is at @w{@uref{http://gcc.gnu.org/wiki/Visibility}}.\n \n+@item -fstrict-volatile-bitfields\n+This option should be used if accesses to volatile bitfields (or other\n+structure fields, although the compiler usually honors those types\n+anyway) should use a single access in a mode of the same size as the\n+container's type, aligned to a natural alignment if possible.  For\n+example, targets with memory-mapped peripheral registers might require\n+all such accesses to be 16 bits wide; with this flag the user could\n+declare all peripheral bitfields as ``unsigned short'' (assuming short\n+is 16 bits on these targets) to force GCC to use 16 bit accesses\n+instead of, perhaps, a more efficient 32 bit access.\n+\n+If this option is disabled, the compiler will use the most efficient\n+instruction.  In the previous example, that might be a 32-bit load\n+instruction, even though that will access bytes that do not contain\n+any portion of the bitfield, or memory-mapped registers unrelated to\n+the one being updated.\n+\n+If the target requires strict alignment, and honoring the container\n+type would require violating this alignment, a warning is issued.\n+However, the access happens as the user requested, under the\n+assumption that the user knows something about the target hardware\n+that GCC is unaware of.\n+\n+The default value of this option is determined by the application binary\n+interface for the target processor.\n+\n @end table\n \n @c man end"}, {"sha": "a06137e65f9fa383d4ae5522c2c3b51c2a9c9398", "filename": "gcc/expmed.c", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -903,8 +903,14 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n       if (GET_MODE_BITSIZE (mode) == 0\n \t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n \tmode = word_mode;\n-      mode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n-\t\t\t    MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n+\n+      if (MEM_VOLATILE_P (op0)\n+          && GET_MODE_BITSIZE (GET_MODE (op0)) > 0\n+\t  && flag_strict_volatile_bitfields > 0)\n+\tmode = GET_MODE (op0);\n+      else\n+\tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n+\t\t\t      MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t{\n@@ -1377,6 +1383,14 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    ? mode_for_size (bitsize, GET_MODE_CLASS (tmode), 0)\n \t    : mode);\n \n+  /* If the bitfield is volatile, we need to make sure the access\n+     remains on a type-aligned boundary.  */\n+  if (GET_CODE (op0) == MEM\n+      && MEM_VOLATILE_P (op0)\n+      && GET_MODE_BITSIZE (GET_MODE (op0)) > 0\n+      && flag_strict_volatile_bitfields > 0)\n+    goto no_subreg_mode_swap;\n+\n   if (((bitsize >= BITS_PER_WORD && bitsize == GET_MODE_BITSIZE (mode)\n \t&& bitpos % BITS_PER_WORD == 0)\n        || (mode1 != BLKmode\n@@ -1729,8 +1743,19 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t includes the entire field.  If such a mode would be larger than\n \t a word, we won't be doing the extraction the normal way.  */\n \n-      mode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n-\t\t\t    MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n+      if (MEM_VOLATILE_P (op0)\n+\t  && flag_strict_volatile_bitfields > 0)\n+\t{\n+\t  if (GET_MODE_BITSIZE (GET_MODE (op0)) > 0)\n+\t    mode = GET_MODE (op0);\n+\t  else if (target && GET_MODE_BITSIZE (GET_MODE (target)) > 0)\n+\t    mode = GET_MODE (target);\n+\t  else\n+\t    mode = tmode;\n+\t}\n+      else\n+\tmode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,\n+\t\t\t      MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t/* The only way this should occur is if the field spans word\n@@ -1751,12 +1776,51 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t\t     * BITS_PER_UNIT);\n \t}\n \n-      /* Get ref to an aligned byte, halfword, or word containing the field.\n-\t Adjust BITPOS to be position within a word,\n-\t and OFFSET to be the offset of that word.\n-\t Then alter OP0 to refer to that word.  */\n-      bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n-      offset -= (offset % (total_bits / BITS_PER_UNIT));\n+      /* If we're accessing a volatile MEM, we can't do the next\n+\t alignment step if it results in a multi-word access where we\n+\t otherwise wouldn't have one.  So, check for that case\n+\t here.  */\n+      if (MEM_P (op0)\n+\t  && MEM_VOLATILE_P (op0)\n+\t  && flag_strict_volatile_bitfields > 0\n+\t  && bitpos + bitsize <= total_bits\n+\t  && bitpos + bitsize + (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT > total_bits)\n+\t{\n+\t  if (STRICT_ALIGNMENT)\n+\t    {\n+\t      static bool informed_about_misalignment = false;\n+\t      bool warned;\n+\n+\t      if (bitsize == total_bits)\n+\t\twarned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t\t     \"mis-aligned access used for structure member\");\n+\t      else\n+\t\twarned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t\t     \"mis-aligned access used for structure bitfield\");\n+\n+\t      if (! informed_about_misalignment && warned)\n+\t\t{\n+\t\t  informed_about_misalignment = true;\n+\t\t  inform (input_location,\n+\t\t\t  \"When a volatile object spans multiple type-sized locations,\"\n+\t\t\t  \" the compiler must choose between using a single mis-aligned access to\"\n+\t\t\t  \" preserve the volatility, or using multiple aligned accesses to avoid\"\n+\t\t\t  \" runtime faults.  This code may fail at runtime if the hardware does\"\n+\t\t\t  \" not allow this access.\");\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\n+\t  /* Get ref to an aligned byte, halfword, or word containing the field.\n+\t     Adjust BITPOS to be position within a word,\n+\t     and OFFSET to be the offset of that word.\n+\t     Then alter OP0 to refer to that word.  */\n+\t  bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n+\t  offset -= (offset % (total_bits / BITS_PER_UNIT));\n+\t}\n+\n       op0 = adjust_address (op0, mode, offset);\n     }\n "}, {"sha": "0d0bb23fbf89b8623ce4f2aec3aa789aa373a7a0", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -4229,6 +4229,13 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       to_rtx = expand_normal (tem);\n \n+      /* If the bitfield is volatile, we want to access it in the\n+\t field's mode, not the computed mode.  */\n+      if (volatilep\n+\t  && GET_CODE (to_rtx) == MEM\n+\t  && flag_strict_volatile_bitfields > 0)\n+\tto_rtx = adjust_address (to_rtx, mode1, 0);\n+ \n       if (offset != 0)\n \t{\n \t  enum machine_mode address_mode;\n@@ -5990,6 +5997,12 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \tmode = DECL_MODE (field);\n       else if (DECL_MODE (field) == BLKmode)\n \tblkmode_bitfield = true;\n+      else if (TREE_THIS_VOLATILE (exp)\n+\t       && flag_strict_volatile_bitfields > 0)\n+\t/* Volatile bitfields should be accessed in the mode of the\n+\t     field's type, not the mode computed based on the bit\n+\t     size.  */\n+\tmode = TYPE_MODE (DECL_BIT_FIELD_TYPE (field));\n \n       *punsignedp = DECL_UNSIGNED (field);\n     }\n@@ -8966,6 +8979,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t  || modifier == EXPAND_STACK_PARM)\n \t\t\t ? modifier : EXPAND_NORMAL);\n \n+\n+\t/* If the bitfield is volatile, we want to access it in the\n+\t   field's mode, not the computed mode.  */\n+\tif (volatilep\n+\t    && GET_CODE (op0) == MEM\n+\t    && flag_strict_volatile_bitfields > 0)\n+\t  op0 = adjust_address (op0, mode1, 0);\n+\n \tmode2\n \t  = CONSTANT_P (op0) ? TYPE_MODE (TREE_TYPE (tem)) : GET_MODE (op0);\n \n@@ -9091,6 +9112,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t&& GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT\n \t\t&& modifier != EXPAND_CONST_ADDRESS\n \t\t&& modifier != EXPAND_INITIALIZER)\n+\t    /* If the field is volatile, we always want an aligned\n+\t       access.  */\n+\t    || (volatilep && flag_strict_volatile_bitfields > 0)\n \t    /* If the field isn't aligned enough to fetch as a memref,\n \t       fetch it as a bit field.  */\n \t    || (mode1 != BLKmode"}, {"sha": "9abc94e84578840d382859345f0ef0e9b5cb800d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -3463,11 +3463,16 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n \n   /* See if we can find a mode to refer to this field.  We should be able to,\n      but fail if we can't.  */\n-  nmode = get_best_mode (lbitsize, lbitpos,\n-\t\t\t const_p ? TYPE_ALIGN (TREE_TYPE (linner))\n-\t\t\t : MIN (TYPE_ALIGN (TREE_TYPE (linner)),\n-\t\t\t\tTYPE_ALIGN (TREE_TYPE (rinner))),\n-\t\t\t word_mode, lvolatilep || rvolatilep);\n+  if (lvolatilep\n+      && GET_MODE_BITSIZE (lmode) > 0\n+      && flag_strict_volatile_bitfields > 0)\n+    nmode = lmode;\n+  else\n+    nmode = get_best_mode (lbitsize, lbitpos,\n+\t\t\t   const_p ? TYPE_ALIGN (TREE_TYPE (linner))\n+\t\t\t   : MIN (TYPE_ALIGN (TREE_TYPE (linner)),\n+\t\t\t\t  TYPE_ALIGN (TREE_TYPE (rinner))),\n+\t\t\t   word_mode, lvolatilep || rvolatilep);\n   if (nmode == VOIDmode)\n     return 0;\n "}, {"sha": "0970bf47e29cc3fd29a7f4cbcdbd3a48005b6971", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -1,3 +1,8 @@\n+2010-06-16  DJ Delorie  <dj@redhat.com>\n+\n+\t* gcc.target/i386/volatile-bitfields-1.c: New.\n+\t* gcc.target/i386/volatile-bitfields-2.c: New.\n+\n 2010-06-16  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/noexcept03.C: Test -Wnoexcept."}, {"sha": "01a35f9f92064f301b27f657696f992c24a6780a", "filename": "gcc/testsuite/gcc.target/i386/volatile-bitfields-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-bitfields-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-bitfields-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-bitfields-1.c?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstrict-volatile-bitfields\" } */\n+\n+typedef struct {\n+  char a:1;\n+  char b:7;\n+  int c;\n+} BitStruct;\n+\n+volatile BitStruct bits;\n+\n+int foo ()\n+{\n+  return bits.b;\n+}\n+\n+/* { dg-final { scan-assembler \"movzbl.*bits\" } } */"}, {"sha": "302625a199b5b79d950592dcc869895753bf4884", "filename": "gcc/testsuite/gcc.target/i386/volatile-bitfields-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-bitfields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a78b724701505a225b87a4915d4040217d5833d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-bitfields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvolatile-bitfields-2.c?ref=6a78b724701505a225b87a4915d4040217d5833d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-strict-volatile-bitfields\" } */\n+\n+typedef struct {\n+  char a:1;\n+  char b:7;\n+  int c;\n+} BitStruct;\n+\n+volatile BitStruct bits;\n+\n+int foo ()\n+{\n+  return bits.b;\n+}\n+\n+/* { dg-final { scan-assembler \"movl.*bits\" } } */"}]}