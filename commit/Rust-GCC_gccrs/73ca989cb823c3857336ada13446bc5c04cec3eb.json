{"sha": "73ca989cb823c3857336ada13446bc5c04cec3eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjYTk4OWNiODIzYzM4NTczMzZhZGExMzQ0NmJjNWMwNGNlYzNlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:53:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:53:35Z"}, "message": "poly_int: lra frame offsets\n\nThis patch makes LRA use poly_int64s rather than HOST_WIDE_INTs\nto store a frame offset (including in things like eliminations).\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* lra-int.h (lra_reg): Change offset from int to poly_int64.\n\t(lra_insn_recog_data): Change sp_offset from HOST_WIDE_INT\n\tto poly_int64.\n\t(lra_eliminate_regs_1, eliminate_regs_in_insn): Change\n\tupdate_sp_offset from a HOST_WIDE_INT to a poly_int64.\n\t(lra_update_reg_val_offset, lra_reg_val_equal_p): Take the\n\toffset as a poly_int64 rather than an int.\n\t* lra-assigns.c (find_hard_regno_for_1): Handle poly_int64 offsets.\n\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n\t* lra-constraints.c (equiv_address_substitution): Track offsets\n\tas poly_int64s.\n\t(emit_inc): Check poly_int_rtx_p instead of CONST_INT_P.\n\t(curr_insn_transform): Handle the new form of sp_offset.\n\t* lra-eliminations.c (lra_elim_table): Change previous_offset\n\tand offset from HOST_WIDE_INT to poly_int64.\n\t(print_elim_table, update_reg_eliminate): Update accordingly.\n\t(self_elim_offsets): Change from HOST_WIDE_INT to poly_int64_pod.\n\t(get_elimination): Update accordingly.\n\t(form_sum): Check poly_int_rtx_p instead of CONST_INT_P.\n\t(lra_eliminate_regs_1, eliminate_regs_in_insn): Change\n\tupdate_sp_offset from a HOST_WIDE_INT to a poly_int64.  Handle\n\tpoly_int64 offsets generally.\n\t(curr_sp_change): Change from HOST_WIDE_INT to poly_int64.\n\t(mark_not_eliminable, init_elimination): Update accordingly.\n\t(remove_reg_equal_offset_note): Return a bool and pass the new\n\toffset back by pointer as a poly_int64.\n\t* lra-remat.c (change_sp_offset): Take sp_offset as a poly_int64\n\trather than a HOST_WIDE_INT.\n\t(do_remat): Track offsets poly_int64s.\n\t* lra.c (lra_update_insn_recog_data, setup_sp_offset): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255876", "tree": {"sha": "fc42b0612019e3b1e83163506a633ce5c28f801e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc42b0612019e3b1e83163506a633ce5c28f801e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73ca989cb823c3857336ada13446bc5c04cec3eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ca989cb823c3857336ada13446bc5c04cec3eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ca989cb823c3857336ada13446bc5c04cec3eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ca989cb823c3857336ada13446bc5c04cec3eb/comments", "author": null, "committer": null, "parents": [{"sha": "d05d755107df11e675a57ac4371fd0031c7d68a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d05d755107df11e675a57ac4371fd0031c7d68a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d05d755107df11e675a57ac4371fd0031c7d68a4"}], "stats": {"total": 214, "additions": 129, "deletions": 85}, "files": [{"sha": "b87072762644cc634c1a00a022a251d4665e08aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -1,3 +1,38 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lra-int.h (lra_reg): Change offset from int to poly_int64.\n+\t(lra_insn_recog_data): Change sp_offset from HOST_WIDE_INT\n+\tto poly_int64.\n+\t(lra_eliminate_regs_1, eliminate_regs_in_insn): Change\n+\tupdate_sp_offset from a HOST_WIDE_INT to a poly_int64.\n+\t(lra_update_reg_val_offset, lra_reg_val_equal_p): Take the\n+\toffset as a poly_int64 rather than an int.\n+\t* lra-assigns.c (find_hard_regno_for_1): Handle poly_int64 offsets.\n+\t(setup_live_pseudos_and_spill_after_risky_transforms): Likewise.\n+\t* lra-constraints.c (equiv_address_substitution): Track offsets\n+\tas poly_int64s.\n+\t(emit_inc): Check poly_int_rtx_p instead of CONST_INT_P.\n+\t(curr_insn_transform): Handle the new form of sp_offset.\n+\t* lra-eliminations.c (lra_elim_table): Change previous_offset\n+\tand offset from HOST_WIDE_INT to poly_int64.\n+\t(print_elim_table, update_reg_eliminate): Update accordingly.\n+\t(self_elim_offsets): Change from HOST_WIDE_INT to poly_int64_pod.\n+\t(get_elimination): Update accordingly.\n+\t(form_sum): Check poly_int_rtx_p instead of CONST_INT_P.\n+\t(lra_eliminate_regs_1, eliminate_regs_in_insn): Change\n+\tupdate_sp_offset from a HOST_WIDE_INT to a poly_int64.  Handle\n+\tpoly_int64 offsets generally.\n+\t(curr_sp_change): Change from HOST_WIDE_INT to poly_int64.\n+\t(mark_not_eliminable, init_elimination): Update accordingly.\n+\t(remove_reg_equal_offset_note): Return a bool and pass the new\n+\toffset back by pointer as a poly_int64.\n+\t* lra-remat.c (change_sp_offset): Take sp_offset as a poly_int64\n+\trather than a HOST_WIDE_INT.\n+\t(do_remat): Track offsets poly_int64s.\n+\t* lra.c (lra_update_insn_recog_data, setup_sp_offset): Likewise.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8174b586790f6b6ff7cd51fdf9284fb9b3aa00ff", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -485,7 +485,8 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n   int hr, conflict_hr, nregs;\n   machine_mode biggest_mode;\n   unsigned int k, conflict_regno;\n-  int offset, val, biggest_nregs, nregs_diff;\n+  poly_int64 offset;\n+  int val, biggest_nregs, nregs_diff;\n   enum reg_class rclass;\n   bitmap_iterator bi;\n   bool *rclass_intersect_p;\n@@ -1147,7 +1148,8 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n {\n   int p, i, j, n, regno, hard_regno;\n   unsigned int k, conflict_regno;\n-  int val, offset;\n+  poly_int64 offset;\n+  int val;\n   HARD_REG_SET conflict_set;\n   machine_mode mode;\n   lra_live_range_t r;"}, {"sha": "0681a4c188d3958e6519bc7708a0b2eafe7c9b18", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -3084,7 +3084,8 @@ static bool\n equiv_address_substitution (struct address_info *ad)\n {\n   rtx base_reg, new_base_reg, index_reg, new_index_reg, *base_term, *index_term;\n-  HOST_WIDE_INT disp, scale;\n+  poly_int64 disp;\n+  HOST_WIDE_INT scale;\n   bool change_p;\n \n   base_term = strip_subreg (ad->base_term);\n@@ -3115,17 +3116,18 @@ equiv_address_substitution (struct address_info *ad)\n     }\n   if (base_reg != new_base_reg)\n     {\n+      poly_int64 offset;\n       if (REG_P (new_base_reg))\n \t{\n \t  *base_term = new_base_reg;\n \t  change_p = true;\n \t}\n       else if (GET_CODE (new_base_reg) == PLUS\n \t       && REG_P (XEXP (new_base_reg, 0))\n-\t       && CONST_INT_P (XEXP (new_base_reg, 1))\n+\t       && poly_int_rtx_p (XEXP (new_base_reg, 1), &offset)\n \t       && can_add_disp_p (ad))\n \t{\n-\t  disp += INTVAL (XEXP (new_base_reg, 1));\n+\t  disp += offset;\n \t  *base_term = XEXP (new_base_reg, 0);\n \t  change_p = true;\n \t}\n@@ -3134,23 +3136,24 @@ equiv_address_substitution (struct address_info *ad)\n     }\n   if (index_reg != new_index_reg)\n     {\n+      poly_int64 offset;\n       if (REG_P (new_index_reg))\n \t{\n \t  *index_term = new_index_reg;\n \t  change_p = true;\n \t}\n       else if (GET_CODE (new_index_reg) == PLUS\n \t       && REG_P (XEXP (new_index_reg, 0))\n-\t       && CONST_INT_P (XEXP (new_index_reg, 1))\n+\t       && poly_int_rtx_p (XEXP (new_index_reg, 1), &offset)\n \t       && can_add_disp_p (ad)\n \t       && (scale = get_index_scale (ad)))\n \t{\n-\t  disp += INTVAL (XEXP (new_index_reg, 1)) * scale;\n+\t  disp += offset * scale;\n \t  *index_term = XEXP (new_index_reg, 0);\n \t  change_p = true;\n \t}\n     }\n-  if (disp != 0)\n+  if (maybe_ne (disp, 0))\n     {\n       if (ad->disp != NULL)\n \t*ad->disp = plus_constant (GET_MODE (*ad->inner), *ad->disp, disp);\n@@ -3630,9 +3633,10 @@ emit_inc (enum reg_class new_rclass, rtx in, rtx value, int inc_amount)\n \t register.  */\n       if (plus_p)\n \t{\n-\t  if (CONST_INT_P (inc))\n+\t  poly_int64 offset;\n+\t  if (poly_int_rtx_p (inc, &offset))\n \t    emit_insn (gen_add2_insn (result,\n-\t\t\t\t      gen_int_mode (-INTVAL (inc),\n+\t\t\t\t      gen_int_mode (-offset,\n \t\t\t\t\t\t    GET_MODE (result))));\n \t  else\n \t    emit_insn (gen_sub2_insn (result, inc));\n@@ -4000,10 +4004,13 @@ curr_insn_transform (bool check_only_p)\n       if (INSN_CODE (curr_insn) >= 0\n           && (p = get_insn_name (INSN_CODE (curr_insn))) != NULL)\n         fprintf (lra_dump_file, \" {%s}\", p);\n-      if (curr_id->sp_offset != 0)\n-        fprintf (lra_dump_file, \" (sp_off=%\" HOST_WIDE_INT_PRINT \"d)\",\n-\t\t curr_id->sp_offset);\n-       fprintf (lra_dump_file, \"\\n\");\n+      if (maybe_ne (curr_id->sp_offset, 0))\n+\t{\n+\t  fprintf (lra_dump_file, \" (sp_off=\");\n+\t  print_dec (curr_id->sp_offset, lra_dump_file);\n+\t  fprintf (lra_dump_file, \")\");\n+\t}\n+      fprintf (lra_dump_file, \"\\n\");\n     }\n \n   /* Right now, for any pair of operands I and J that are required to"}, {"sha": "4f130a68e79854aefd18b04a3c94d20b894e9466", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -79,9 +79,9 @@ struct lra_elim_table\n   int to;\n   /* Difference between values of the two hard registers above on\n      previous iteration.  */\n-  HOST_WIDE_INT previous_offset;\n+  poly_int64 previous_offset;\n   /* Difference between the values on the current iteration.  */\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n   /* Nonzero if this elimination can be done.  */\n   bool can_eliminate;\n   /* CAN_ELIMINATE since the last check.  */\n@@ -120,10 +120,14 @@ print_elim_table (FILE *f)\n   struct lra_elim_table *ep;\n \n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-    fprintf (f, \"%s eliminate %d to %d (offset=\" HOST_WIDE_INT_PRINT_DEC\n-\t     \", prev_offset=\" HOST_WIDE_INT_PRINT_DEC \")\\n\",\n-\t     ep->can_eliminate ? \"Can\" : \"Can't\",\n-\t     ep->from, ep->to, ep->offset, ep->previous_offset);\n+    {\n+      fprintf (f, \"%s eliminate %d to %d (offset=\",\n+\t       ep->can_eliminate ? \"Can\" : \"Can't\", ep->from, ep->to);\n+      print_dec (ep->offset, f);\n+      fprintf (f, \", prev_offset=\");\n+      print_dec (ep->previous_offset, f);\n+      fprintf (f, \")\\n\");\n+    }\n }\n \n /* Print info about elimination table to stderr.  */\n@@ -161,7 +165,7 @@ static struct lra_elim_table self_elim_table;\n /* Offsets should be used to restore original offsets for eliminable\n    hard register which just became not eliminable.  Zero,\n    otherwise.  */\n-static HOST_WIDE_INT self_elim_offsets[FIRST_PSEUDO_REGISTER];\n+static poly_int64_pod self_elim_offsets[FIRST_PSEUDO_REGISTER];\n \n /* Map: hard regno -> RTL presentation.\t RTL presentations of all\n    potentially eliminable hard registers are stored in the map.\t */\n@@ -193,17 +197,18 @@ static rtx\n form_sum (rtx x, rtx y)\n {\n   machine_mode mode = GET_MODE (x);\n+  poly_int64 offset;\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (y);\n \n   if (mode == VOIDmode)\n     mode = Pmode;\n \n-  if (CONST_INT_P (x))\n-    return plus_constant (mode, y, INTVAL (x));\n-  else if (CONST_INT_P (y))\n-    return plus_constant (mode, x, INTVAL (y));\n+  if (poly_int_rtx_p (x, &offset))\n+    return plus_constant (mode, y, offset);\n+  else if (poly_int_rtx_p (y, &offset))\n+    return plus_constant (mode, x, offset);\n   else if (CONSTANT_P (x))\n     std::swap (x, y);\n \n@@ -252,14 +257,14 @@ get_elimination (rtx reg)\n {\n   int hard_regno;\n   struct lra_elim_table *ep;\n-  HOST_WIDE_INT offset;\n \n   lra_assert (REG_P (reg));\n   if ((hard_regno = REGNO (reg)) < 0 || hard_regno >= FIRST_PSEUDO_REGISTER)\n     return NULL;\n   if ((ep = elimination_map[hard_regno]) != NULL)\n     return ep->from_rtx != reg ? NULL : ep;\n-  if ((offset = self_elim_offsets[hard_regno]) == 0)\n+  poly_int64 offset = self_elim_offsets[hard_regno];\n+  if (known_eq (offset, 0))\n     return NULL;\n   /* This is an iteration to restore offsets just after HARD_REGNO\n      stopped to be eliminable.\t*/\n@@ -325,7 +330,7 @@ move_plus_up (rtx x)\n rtx\n lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t\t      bool subst_p, bool update_p,\n-\t\t      HOST_WIDE_INT update_sp_offset, bool full_p)\n+\t\t      poly_int64 update_sp_offset, bool full_p)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct lra_elim_table *ep;\n@@ -335,7 +340,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n   int copied = 0;\n \n   lra_assert (!update_p || !full_p);\n-  lra_assert (update_sp_offset == 0 || (!subst_p && update_p && !full_p));\n+  lra_assert (known_eq (update_sp_offset, 0)\n+\t      || (!subst_p && update_p && !full_p));\n   if (! current_function_decl)\n     return x;\n \n@@ -360,7 +366,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t{\n \t  rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n \n-\t  if (update_sp_offset != 0)\n+\t  if (maybe_ne (update_sp_offset, 0))\n \t    {\n \t      if (ep->to_rtx == stack_pointer_rtx)\n \t\treturn plus_constant (Pmode, to, update_sp_offset);\n@@ -387,20 +393,21 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t{\n \t  if ((ep = get_elimination (XEXP (x, 0))) != NULL)\n \t    {\n-\t      HOST_WIDE_INT offset;\n+\t      poly_int64 offset, curr_offset;\n \t      rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n \n \t      if (! update_p && ! full_p)\n \t\treturn gen_rtx_PLUS (Pmode, to, XEXP (x, 1));\n \t      \n-\t      if (update_sp_offset != 0)\n+\t      if (maybe_ne (update_sp_offset, 0))\n \t\toffset = ep->to_rtx == stack_pointer_rtx ? update_sp_offset : 0;\n \t      else\n \t\toffset = (update_p\n \t\t\t  ? ep->offset - ep->previous_offset : ep->offset);\n \t      if (full_p && insn != NULL_RTX && ep->to_rtx == stack_pointer_rtx)\n \t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n-\t      if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) == -offset)\n+\t      if (poly_int_rtx_p (XEXP (x, 1), &curr_offset)\n+\t\t  && known_eq (curr_offset, -offset))\n \t\treturn to;\n \t      else\n \t\treturn gen_rtx_PLUS (Pmode, to,\n@@ -449,7 +456,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t{\n \t  rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n \n-\t  if (update_sp_offset != 0)\n+\t  if (maybe_ne (update_sp_offset, 0))\n \t    {\n \t      if (ep->to_rtx == stack_pointer_rtx)\n \t\treturn plus_constant (Pmode,\n@@ -464,7 +471,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t\t\t\t  * INTVAL (XEXP (x, 1)));\n \t  else if (full_p)\n \t    {\n-\t      HOST_WIDE_INT offset = ep->offset;\n+\t      poly_int64 offset = ep->offset;\n \n \t      if (insn != NULL_RTX && ep->to_rtx == stack_pointer_rtx)\n \t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n@@ -711,7 +718,7 @@ lra_eliminate_regs (rtx x, machine_mode mem_mode,\n /* Stack pointer offset before the current insn relative to one at the\n    func start.  RTL insns can change SP explicitly.  We keep the\n    changes from one insn to another through this variable.  */\n-static HOST_WIDE_INT curr_sp_change;\n+static poly_int64 curr_sp_change;\n \n /* Scan rtx X for references to elimination source or target registers\n    in contexts that would prevent the elimination from happening.\n@@ -725,6 +732,7 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n   struct lra_elim_table *ep;\n   int i, j;\n   const char *fmt;\n+  poly_int64 offset = 0;\n \n   switch (code)\n     {\n@@ -738,7 +746,7 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n \t  && ((code != PRE_MODIFY && code != POST_MODIFY)\n \t      || (GET_CODE (XEXP (x, 1)) == PLUS\n \t\t  && XEXP (x, 0) == XEXP (XEXP (x, 1), 0)\n-\t\t  && CONST_INT_P (XEXP (XEXP (x, 1), 1)))))\n+\t\t  && poly_int_rtx_p (XEXP (XEXP (x, 1), 1), &offset))))\n \t{\n \t  int size = GET_MODE_SIZE (mem_mode);\n \t  \n@@ -752,7 +760,7 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n \t  else if (code == PRE_INC || code == POST_INC)\n \t    curr_sp_change += size;\n \t  else if (code == PRE_MODIFY || code == POST_MODIFY)\n-\t    curr_sp_change += INTVAL (XEXP (XEXP (x, 1), 1));\n+\t    curr_sp_change += offset;\n \t}\n       else if (REG_P (XEXP (x, 0))\n \t       && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER)\n@@ -802,9 +810,9 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n       if (SET_DEST (x) == stack_pointer_rtx\n \t  && GET_CODE (SET_SRC (x)) == PLUS\n \t  && XEXP (SET_SRC (x), 0) == SET_DEST (x)\n-\t  && CONST_INT_P (XEXP (SET_SRC (x), 1)))\n+\t  && poly_int_rtx_p (XEXP (SET_SRC (x), 1), &offset))\n \t{\n-\t  curr_sp_change += INTVAL (XEXP (SET_SRC (x), 1));\n+\t  curr_sp_change += offset;\n \t  return;\n \t}\n       if (! REG_P (SET_DEST (x))\n@@ -859,11 +867,11 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n \n #ifdef HARD_FRAME_POINTER_REGNUM\n \n-/* Find offset equivalence note for reg WHAT in INSN and return the\n-   found elmination offset.  If the note is not found, return NULL.\n-   Remove the found note.  */\n-static rtx\n-remove_reg_equal_offset_note (rtx_insn *insn, rtx what)\n+/* Search INSN's reg notes to see whether the destination is equal to\n+   WHAT + C for some constant C.  Return true if so, storing C in\n+   *OFFSET_OUT and removing the reg note.  */\n+static bool\n+remove_reg_equal_offset_note (rtx_insn *insn, rtx what, poly_int64 *offset_out)\n {\n   rtx link, *link_loc;\n \n@@ -873,12 +881,12 @@ remove_reg_equal_offset_note (rtx_insn *insn, rtx what)\n     if (REG_NOTE_KIND (link) == REG_EQUAL\n \t&& GET_CODE (XEXP (link, 0)) == PLUS\n \t&& XEXP (XEXP (link, 0), 0) == what\n-\t&& CONST_INT_P (XEXP (XEXP (link, 0), 1)))\n+\t&& poly_int_rtx_p (XEXP (XEXP (link, 0), 1), offset_out))\n       {\n \t*link_loc = XEXP (link, 1);\n-\treturn XEXP (XEXP (link, 0), 1);\n+\treturn true;\n       }\n-  return NULL_RTX;\n+  return false;\n }\n \n #endif\n@@ -899,7 +907,7 @@ remove_reg_equal_offset_note (rtx_insn *insn, rtx what)\n \n void\n eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n-\t\t\tHOST_WIDE_INT update_sp_offset)\n+\t\t\tpoly_int64 update_sp_offset)\n {\n   int icode = recog_memoized (insn);\n   rtx old_set = single_set (insn);\n@@ -940,28 +948,21 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n \t\t nonlocal goto.  */\n \t      {\n \t\trtx src = SET_SRC (old_set);\n-\t\trtx off = remove_reg_equal_offset_note (insn, ep->to_rtx);\n-\t\t\n+\t\tpoly_int64 offset = 0;\n+\n \t\t/* We should never process such insn with non-zero\n \t\t   UPDATE_SP_OFFSET.  */\n-\t\tlra_assert (update_sp_offset == 0);\n+\t\tlra_assert (known_eq (update_sp_offset, 0));\n \t\t\n-\t\tif (off != NULL_RTX\n-\t\t    || src == ep->to_rtx\n-\t\t    || (GET_CODE (src) == PLUS\n-\t\t\t&& XEXP (src, 0) == ep->to_rtx\n-\t\t\t&& CONST_INT_P (XEXP (src, 1))))\n+\t\tif (remove_reg_equal_offset_note (insn, ep->to_rtx, &offset)\n+\t\t    || strip_offset (src, &offset) == ep->to_rtx)\n \t\t  {\n-\t\t    HOST_WIDE_INT offset;\n-\t\t    \n \t\t    if (replace_p)\n \t\t      {\n \t\t\tSET_DEST (old_set) = ep->to_rtx;\n \t\t\tlra_update_insn_recog_data (insn);\n \t\t\treturn;\n \t\t      }\n-\t\t    offset = (off != NULL_RTX ? INTVAL (off)\n-\t\t\t      : src == ep->to_rtx ? 0 : INTVAL (XEXP (src, 1)));\n \t\t    offset -= (ep->offset - ep->previous_offset);\n \t\t    src = plus_constant (Pmode, ep->to_rtx, offset);\n \t\t    \n@@ -997,13 +998,13 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n      currently support: a single set with the source or a REG_EQUAL\n      note being a PLUS of an eliminable register and a constant.  */\n   plus_src = plus_cst_src = 0;\n+  poly_int64 offset = 0;\n   if (old_set && REG_P (SET_DEST (old_set)))\n     {\n       if (GET_CODE (SET_SRC (old_set)) == PLUS)\n \tplus_src = SET_SRC (old_set);\n       /* First see if the source is of the form (plus (...) CST).  */\n-      if (plus_src\n-\t  && CONST_INT_P (XEXP (plus_src, 1)))\n+      if (plus_src && poly_int_rtx_p (XEXP (plus_src, 1), &offset))\n \tplus_cst_src = plus_src;\n       /* Check that the first operand of the PLUS is a hard reg or\n \t the lowpart subreg of one.  */\n@@ -1021,7 +1022,6 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n   if (plus_cst_src)\n     {\n       rtx reg = XEXP (plus_cst_src, 0);\n-      HOST_WIDE_INT offset = INTVAL (XEXP (plus_cst_src, 1));\n \n       if (GET_CODE (reg) == SUBREG)\n \treg = SUBREG_REG (reg);\n@@ -1032,7 +1032,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n \n \t  if (! replace_p)\n \t    {\n-\t      if (update_sp_offset == 0)\n+\t      if (known_eq (update_sp_offset, 0))\n \t\toffset += (ep->offset - ep->previous_offset);\n \t      if (ep->to_rtx == stack_pointer_rtx)\n \t\t{\n@@ -1051,7 +1051,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n \t     the cost of the insn by replacing a simple REG with (plus\n \t     (reg sp) CST).  So try only when we already had a PLUS\n \t     before.  */\n-\t  if (offset == 0 || plus_src)\n+\t  if (known_eq (offset, 0) || plus_src)\n \t    {\n \t      rtx new_src = plus_constant (GET_MODE (to_rtx), to_rtx, offset);\n \n@@ -1239,7 +1239,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t      if (lra_dump_file != NULL)\n \t\tfprintf (lra_dump_file, \"    Using elimination %d to %d now\\n\",\n \t\t\t ep1->from, ep1->to);\n-\t      lra_assert (ep1->previous_offset == 0);\n+\t      lra_assert (known_eq (ep1->previous_offset, 0));\n \t      ep1->previous_offset = ep->offset;\n \t    }\n \t  else\n@@ -1251,7 +1251,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t\tfprintf (lra_dump_file, \"    %d is not eliminable at all\\n\",\n \t\t\t ep->from);\n \t      self_elim_offsets[ep->from] = -ep->offset;\n-\t      if (ep->offset != 0)\n+\t      if (maybe_ne (ep->offset, 0))\n \t\tbitmap_ior_into (insns_with_changed_offsets,\n \t\t\t\t &lra_reg_info[ep->from].insn_bitmap);\n \t    }\n@@ -1271,7 +1271,7 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n \t   the usage for pseudos.  */\n         if (ep->from != ep->to)\n \t  SET_HARD_REG_BIT (temp_hard_reg_set, ep->to);\n-\tif (ep->previous_offset != ep->offset)\n+\tif (maybe_ne (ep->previous_offset, ep->offset))\n \t  {\n \t    bitmap_ior_into (insns_with_changed_offsets,\n \t\t\t     &lra_reg_info[ep->from].insn_bitmap);\n@@ -1357,13 +1357,13 @@ init_elimination (void)\n \t    if (NONDEBUG_INSN_P (insn))\n \t      {\n \t\tmark_not_eliminable (PATTERN (insn), VOIDmode);\n-\t\tif (curr_sp_change != 0\n+\t\tif (maybe_ne (curr_sp_change, 0)\n \t\t    && find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX))\n \t\t  stop_to_sp_elimination_p = true;\n \t      }\n \t  }\n       if (! frame_pointer_needed\n-\t  && (curr_sp_change != 0 || stop_to_sp_elimination_p)\n+\t  && (maybe_ne (curr_sp_change, 0) || stop_to_sp_elimination_p)\n \t  && bb->succs && bb->succs->length () != 0)\n \tfor (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \t  if (ep->to == STACK_POINTER_REGNUM)"}, {"sha": "4d35435600910e0483d08a7ad1daf2fda92fe2df", "filename": "gcc/lra-int.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -106,7 +106,7 @@ struct lra_reg\n      they do not conflict.  */\n   int val;\n   /* Offset from relative eliminate register to pesudo reg.  */\n-  int offset;\n+  poly_int64 offset;\n   /* These members are set up in lra-lives.c and updated in\n      lra-coalesce.c.  */\n   /* The biggest size mode in which each pseudo reg is referred in\n@@ -213,7 +213,7 @@ struct lra_insn_recog_data\n      insn.  */\n   int used_insn_alternative;\n   /* SP offset before the insn relative to one at the func start.  */\n-  HOST_WIDE_INT sp_offset;\n+  poly_int64 sp_offset;\n   /* The insn itself.  */\n   rtx_insn *insn;\n   /* Common data for insns with the same ICODE.  Asm insns (their\n@@ -406,8 +406,8 @@ extern bool lra_remat (void);\n extern void lra_debug_elim_table (void);\n extern int lra_get_elimination_hard_regno (int);\n extern rtx lra_eliminate_regs_1 (rtx_insn *, rtx, machine_mode,\n-\t\t\t\t bool, bool, HOST_WIDE_INT, bool);\n-extern void eliminate_regs_in_insn (rtx_insn *insn, bool, bool, HOST_WIDE_INT);\n+\t\t\t\t bool, bool, poly_int64, bool);\n+extern void eliminate_regs_in_insn (rtx_insn *insn, bool, bool, poly_int64);\n extern void lra_eliminate (bool, bool);\n \n extern void lra_eliminate_reg_if_possible (rtx *);\n@@ -493,7 +493,7 @@ lra_get_insn_recog_data (rtx_insn *insn)\n \n /* Update offset from pseudos with VAL by INCR.  */\n static inline void\n-lra_update_reg_val_offset (int val, int incr)\n+lra_update_reg_val_offset (int val, poly_int64 incr)\n {\n   int i;\n \n@@ -506,10 +506,10 @@ lra_update_reg_val_offset (int val, int incr)\n \n /* Return true if register content is equal to VAL with OFFSET.  */\n static inline bool\n-lra_reg_val_equal_p (int regno, int val, int offset)\n+lra_reg_val_equal_p (int regno, int val, poly_int64 offset)\n {\n   if (lra_reg_info[regno].val == val\n-      && lra_reg_info[regno].offset == offset)\n+      && known_eq (lra_reg_info[regno].offset, offset))\n     return true;\n \n   return false;"}, {"sha": "baba0a8ff73bfd7b5d18ed9fa53615df97d85c62", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -994,7 +994,7 @@ calculate_global_remat_bb_data (void)\n \n /* Setup sp offset attribute to SP_OFFSET for all INSNS.  */\n static void\n-change_sp_offset (rtx_insn *insns, HOST_WIDE_INT sp_offset)\n+change_sp_offset (rtx_insn *insns, poly_int64 sp_offset)\n {\n   for (rtx_insn *insn = insns; insn != NULL; insn = NEXT_INSN (insn))\n     eliminate_regs_in_insn (insn, false, false, sp_offset);\n@@ -1118,7 +1118,7 @@ do_remat (void)\n \t  int i, hard_regno, nregs;\n \t  int dst_hard_regno, dst_nregs;\n \t  rtx_insn *remat_insn = NULL;\n-\t  HOST_WIDE_INT cand_sp_offset = 0;\n+\t  poly_int64 cand_sp_offset = 0;\n \t  if (cand != NULL)\n \t    {\n \t      lra_insn_recog_data_t cand_id\n@@ -1241,8 +1241,8 @@ do_remat (void)\n \n \t  if (remat_insn != NULL)\n \t    {\n-\t      HOST_WIDE_INT sp_offset_change = cand_sp_offset - id->sp_offset;\n-\t      if (sp_offset_change != 0)\n+\t      poly_int64 sp_offset_change = cand_sp_offset - id->sp_offset;\n+\t      if (maybe_ne (sp_offset_change, 0))\n \t\tchange_sp_offset (remat_insn, sp_offset_change);\n \t      update_scratch_ops (remat_insn);\n \t      lra_process_new_insns (insn, remat_insn, NULL,"}, {"sha": "c48ab72508f901b2c7b2591c8e187d840f1c9b7f", "filename": "gcc/lra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ca989cb823c3857336ada13446bc5c04cec3eb/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=73ca989cb823c3857336ada13446bc5c04cec3eb", "patch": "@@ -1188,7 +1188,7 @@ lra_update_insn_recog_data (rtx_insn *insn)\n   int n;\n   unsigned int uid = INSN_UID (insn);\n   struct lra_static_insn_data *insn_static_data;\n-  HOST_WIDE_INT sp_offset = 0;\n+  poly_int64 sp_offset = 0;\n \n   check_and_expand_insn_recog_data (uid);\n   if ((data = lra_insn_recog_data[uid]) != NULL\n@@ -1831,8 +1831,8 @@ static void\n setup_sp_offset (rtx_insn *from, rtx_insn *last)\n {\n   rtx_insn *before = next_nonnote_nondebug_insn_bb (last);\n-  HOST_WIDE_INT offset = (before == NULL_RTX || ! INSN_P (before)\n-\t\t\t  ? 0 : lra_get_insn_recog_data (before)->sp_offset);\n+  poly_int64 offset = (before == NULL_RTX || ! INSN_P (before)\n+\t\t       ? 0 : lra_get_insn_recog_data (before)->sp_offset);\n \n   for (rtx_insn *insn = from; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n     lra_get_insn_recog_data (insn)->sp_offset = offset;"}]}