{"sha": "dc4f83ca6a03f9c3351501bedabd4ad30b28ed34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM0ZjgzY2E2YTAzZjljMzM1MTUwMWJlZGFiZDRhZDMwYjI4ZWQzNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-02-28T22:16:31Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-02-28T22:16:31Z"}, "message": "More soft-float/powerpc patches.\n\nFrom-SVN: r9094", "tree": {"sha": "b4e037a2a689accb3c7288cc421f6b9950897c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4e037a2a689accb3c7288cc421f6b9950897c22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc4f83ca6a03f9c3351501bedabd4ad30b28ed34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4f83ca6a03f9c3351501bedabd4ad30b28ed34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc4f83ca6a03f9c3351501bedabd4ad30b28ed34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4f83ca6a03f9c3351501bedabd4ad30b28ed34/comments", "author": null, "committer": null, "parents": [{"sha": "6e5ea9350ffc2af7ed20212ec6c0650a9023689f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5ea9350ffc2af7ed20212ec6c0650a9023689f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e5ea9350ffc2af7ed20212ec6c0650a9023689f"}], "stats": {"total": 120, "additions": 110, "deletions": 10}, "files": [{"sha": "1b884debaf562bd588ca6d57d2acfb19b9e560f2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4f83ca6a03f9c3351501bedabd4ad30b28ed34/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4f83ca6a03f9c3351501bedabd4ad30b28ed34/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dc4f83ca6a03f9c3351501bedabd4ad30b28ed34", "patch": "@@ -3135,7 +3135,7 @@\n    (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(minus:DF (subreg:DF (match_dup 2) 0)\n \t\t  (match_dup 5)))]\n-  \"! TARGET_POWERPC64\"\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n   operands[2] = gen_reg_rtx (DImode);\n@@ -3152,7 +3152,7 @@\n    (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(minus:DF (subreg:DF (match_dup 2) 0)\n \t\t  (match_dup 4)))]\n-  \"! TARGET_POWERPC64\"\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n   operands[2] = gen_reg_rtx (DImode);\n@@ -4017,8 +4017,9 @@\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,f,f,m\")\n \t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,f,m,f\"))]\n-  \"! TARGET_POWERPC64 && (register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode))\"\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n   \"*\n {\n   switch (which_alternative)\n@@ -4056,11 +4057,49 @@\n   [(set_attr \"type\" \"*,load,*,*,fp,fpload,*\")\n    (set_attr \"length\" \"8,8,8,8,*,*,*\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G\"))]\n+  \"! TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n+      else\n+\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n+    case 1:\n+      /* If the low-address word is used in the address, we must load it\n+\t last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is known to be\n+\t dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands [1], 0))\n+\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n+      else\n+\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n+    case 2:\n+      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+    case 3:\n+      return \\\"#\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"*,load,*,*\")\n+   (set_attr \"length\" \"8,8,8,8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=!r,??r,o,!r,f,f,m\")\n \t(match_operand:DF 1 \"input_operand\" \"r,o,r,G,f,m,f\"))]\n-  \"TARGET_POWERPC64 && (register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode))\"\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n   \"@\n    mr %0,%1\n    ld%U1%X1 %0,%1\n@@ -4070,6 +4109,19 @@\n    lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\"\n   [(set_attr \"type\" \"*,load,*,*,fp,fpload,*\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r\")\n+\t(match_operand:DF 1 \"input_operand\" \"r,o,r,G\"))]\n+  \"TARGET_POWERPC64 && TARGET_SOFT_FLOAT\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n+  \"@\n+   mr %0,%1\n+   ld%U1%X1 %0,%1\n+   sd%U0%X0 %1,%0\n+   #\"\n+  [(set_attr \"type\" \"*,load,*,*\")])\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n@@ -4203,12 +4255,15 @@\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,r,Q,m\"))\n    (clobber (match_scratch:SI 2 \"=q,q#X,X,X,X\"))]\n-  \"TARGET_MULTIPLE && ! TARGET_POWERPC64 && (gpc_reg_operand (operands[0], TImode)\n-   || gpc_reg_operand (operands[1], TImode))\"\n+  \"TARGET_MULTIPLE && TARGET_POWER && ! TARGET_POWERPC64\n+   && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n {\n   switch (which_alternative)\n     {\n+    default:\n+      abort ();\n+\n     case 0:\n       return \\\"{stsi|stswi} %1,%P0,16\\\";\n \n@@ -4250,6 +4305,51 @@\n   [(set_attr \"type\" \"*,load,load,*,*\")\n    (set_attr \"length\" \"*,16,16,*,16\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=m,????r,????r\")\n+\t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,m\"))\n+   (clobber (match_scratch:SI 2 \"=X,X,X\"))]\n+  \"TARGET_MULTIPLE && !TARGET_POWER && ! TARGET_POWERPC64\n+   && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    default:\n+      abort ();\n+\n+    case 0:\n+      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\;{st|stw} %Y1,%Y0\\;{st|stw} %Z1,%Z0\\\";\n+\n+    case 1:\n+      /* Normally copy registers with lowest numbered register copied first.\n+\t But copy in the other order if the first register of the output\n+\t is the second, third, or fourth register in the input.  */\n+      if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n+\t  && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n+\treturn \\\"mr %Z0,%Z1\\;mr %Y0,%Y1\\;mr %L0,%L1\\;mr %0,%1\\\";\n+      else\n+\treturn \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+    case 2:\n+      /* If the address register is the same as the register for the lowest-\n+\t addressed word, load it last.  Similarly for the next two words.\n+\t Otherwise load lowest address to highest.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands[1], 0))\n+\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %0,%1\\\";\n+      else if (refers_to_regno_p (REGNO (operands[0]) + 1,\n+\t\t\t\t  REGNO (operands[0]) + 2, operands[1], 0))\n+\treturn \\\"{l|lwz} %0,%1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %L0,%L1\\\";\n+      else if (refers_to_regno_p (REGNO (operands[0]) + 2,\n+\t\t\t\t  REGNO (operands[0]) + 3, operands[1], 0))\n+\treturn \\\"{l|lwz} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %Y0,%Y1\\\";\n+      else\n+\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"load,*,*\")\n+   (set_attr \"length\" \"16,16,16\")])\n+\n (define_insn \"\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:TI 1 \"input_operand\" \"r,m,r\"))]\n@@ -4399,15 +4499,15 @@\n \t\t   [(set (match_operand:SI 1 \"indirect_operand\" \"=Q\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n \t\t    (clobber (match_scratch:SI 3 \"=q\"))])]\n-  \"TARGET_MULTIPLE && !TARGET_POWERPC\"\n+  \"TARGET_MULTIPLE && TARGET_POWER\"\n   \"{stsi|stswi} %2,%P1,%O0\")\n \n (define_insn \"\"\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"indirect_operand\" \"=Q\")\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n \t\t    (clobber (match_scratch:SI 3 \"X\"))])]\n-  \"TARGET_MULTIPLE && TARGET_POWERPC\"\n+  \"TARGET_MULTIPLE && !TARGET_POWER\"\n   \"{stsi|stswi} %2,%P1,%O0\")\n \f\n ;; Define insns that do load or store with update.  Some of these we can "}]}