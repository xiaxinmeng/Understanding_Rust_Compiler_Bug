{"sha": "51c0c1d7d2fd985d1fe9145e6a971dee36086456", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFjMGMxZDdkMmZkOTg1ZDFmZTkxNDVlNmE5NzFkZWUzNjA4NjQ1Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-11T16:11:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-11T16:11:48Z"}, "message": "h8300.c (shift_one): Emit tabs between opcode and operands to be consistent with the rest of the...\n\nThu Jul 11 10:12:50 1996  Jeffrey A Law  (law@cygnus.com)\n\n        * h8300/h8300.c (shift_one): Emit tabs between opcode and\n        operands to be consistent with the rest of the compiler.\n        (rotate_one): Likewise.\n        (shift_two, rotate_two): Define.\n        (get_shift_alg): Accept new argument \"assembler2_p\" for\n        rotate/shift by two insns.  All callers changed.  Rework\n        to generate more efficient code on the H8/300, H8/300H, and\n        H8/S.  Try to simplify somewhat.\n        (emit_a_shift): Use shift-by-two insns when they're available.\n        Emit tabs between opcode and operands to be consistent with\n        the rest of the compiler.\n\nFrom-SVN: r12426", "tree": {"sha": "c59f4ee8c6e3e5312183e60f7b5c43ca0ecf9138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59f4ee8c6e3e5312183e60f7b5c43ca0ecf9138"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51c0c1d7d2fd985d1fe9145e6a971dee36086456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c0c1d7d2fd985d1fe9145e6a971dee36086456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51c0c1d7d2fd985d1fe9145e6a971dee36086456", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c0c1d7d2fd985d1fe9145e6a971dee36086456/comments", "author": null, "committer": null, "parents": [{"sha": "54705743fdc765e2bebc91540fd26313d815b730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54705743fdc765e2bebc91540fd26313d815b730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54705743fdc765e2bebc91540fd26313d815b730"}], "stats": {"total": 771, "additions": 601, "deletions": 170}, "files": [{"sha": "0f1d1d7543d96b9708b303a70b54c0f74e313c65", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 601, "deletions": 170, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c0c1d7d2fd985d1fe9145e6a971dee36086456/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c0c1d7d2fd985d1fe9145e6a971dee36086456/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=51c0c1d7d2fd985d1fe9145e6a971dee36086456", "patch": "@@ -1659,83 +1659,171 @@ bit_operator (x, mode)\n /* Shifts.\n \n    We devote a fair bit of code to getting efficient shifts since we can only\n-   shift one bit at a time.  See the .md file for more comments.\n+   shift one bit at a time on the H8/300 and H8/300H and only one or two\n+   bits at a time on the H8/S.\n+\n+   The basic shift methods:\n+\n+     * loop shifts -- emit a loop using one (or two on H8/S) bit shifts;\n+     this is the default.  SHIFT_LOOP\n+\n+     * inlined shifts -- emit straight line code for the shift; this is\n+     used when a straight line shift is about the same size or smaller\n+     than a loop.  We allow the inline version to be slightly longer in\n+     some cases as it saves a register.  SHIFT_INLINE\n+\n+     * rotate + and -- rotate the value the opposite direction, then\n+     mask off the values we don't need.  This is used when only a few\n+     of the bits in the original value will survive in the shifted value.\n+     Again, this is used when it's about the same size or smaller than\n+     a loop.  We allow this version to be slightly longer as it is usually\n+     much faster than a loop.  SHIFT_ROT_AND\n+\n+     * swap (+ shifts) -- often it's possible to swap bytes/words to\n+     simulate a shift by 8/16.  Once swapped a few inline shifts can be\n+     added if the shift count is slightly more than 8 or 16.  This is used\n+     when it's about the same size or smaller than a loop.  We allow this\n+     version to be slightly longer as it is usually much faster than a loop.\n+     SHIFT_SPECIAL\n+\n+     * There other oddballs.  Not worth explaining.  SHIFT_SPECIAL\n+\n \n    Here are some thoughts on what the absolutely positively best code is.\n    \"Best\" here means some rational trade-off between code size and speed,\n    where speed is more preferred but not at the expense of generating 20 insns.\n \n+   A trailing '*' after the shift count indicates the \"best\" mode isn't\n+   implemented.\n+   \n    H8/300 QImode shifts\n-   1-4   - do them inline\n-   5-6   - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-           ASHIFTRT: loop\n-   7     - ASHIFT | LSHIFTRT: rotate, mask off other bits\n-           ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+   1-4    - do them inline\n+   5-6    - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+            ASHIFTRT: loop\n+   7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+            ASHIFTRT: shll, subx (propagate carry bit to all bits)\n \n    H8/300 HImode shifts\n-   1-4   - do them inline\n-   5-6   - loop\n-   7     - shift other way once, move byte into place, move carry bit into place\n-   8     - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n-   9     - inline shift 1-4, move byte, set other byte\n-   13-14 - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n-         - ASHIFTRT: loop\n-   15    - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n-         - ASHIFTRT: shll, subx, set other byte\n+   1-4    - do them inline\n+   5-6    - loop\n+   7      - shift 2nd half other way into carry.\n+\t    copy 1st half into 2nd half\n+\t    rotate 2nd half other way with carry\n+\t    rotate 1st half other way (no carry)\n+\t    mask off bits in 1st half (ASHIFT | LSHIFTRT).\n+\t    sign extend 1st half (ASHIFTRT)\n+   8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n+   9-12   - do shift by 8, inline remaining shifts\n+   13-14* - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n+          - ASHIFTRT: loop\n+   15     - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n+          - ASHIFTRT: shll, subx, set other byte\n \n    H8/300 SImode shifts\n-   1-2   - do them inline\n-   3-6   - loop\n-   7     - shift other way once, move bytes into place,\n-           move carry into place (possibly with sign extension)\n-   8     - move bytes into place, zero or sign extend other\n-   9-14  - loop\n-   15    - shift other way once, move word into place, move carry into place\n-   16    - move word, zero or sign extend other\n-   17-23 - loop\n-   24    - move bytes into place, zero or sign extend other\n-   25-27 - loop\n-   28-30 - ASHIFT | LSHIFTRT: rotate top byte, mask, move byte into place,\n-                              zero others\n-           ASHIFTRT: loop\n-   31    - ASHIFT | LSHIFTRT: rotate top byte, mask, byte byte into place,\n-                              zero others\n-           ASHIFTRT: shll top byte, subx, copy to other bytes\n-\n-   H8/300H QImode shifts\n-   - same as H8/300\n+   1-2    - do them inline\n+   3-6    - loop\n+   7*     - shift other way once, move bytes into place,\n+            move carry into place (possibly with sign extension)\n+   8      - move bytes into place, zero or sign extend other\n+   9-14   - loop\n+   15*    - shift other way once, move word into place, move carry into place\n+   16     - move word, zero or sign extend other\n+   17-23  - loop\n+   24*    - move bytes into place, zero or sign extend other\n+   25-27  - loop\n+   28-30* - ASHIFT | LSHIFTRT: rotate top byte, mask, move byte into place,\n+                               zero others\n+            ASHIFTRT: loop\n+   31     - ASHIFT | LSHIFTRT: rotate top byte, mask, byte byte into place,\n+                               zero others\n+            ASHIFTRT: shll top byte, subx, copy to other bytes\n+\n+   H8/300H QImode shifts (same as H8/300 QImode shifts)\n+   1-4    - do them inline\n+   5-6    - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+            ASHIFTRT: loop\n+   7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+            ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+\n \n    H8/300H HImode shifts\n-   - same as H8/300\n+   1-4    - do them inline\n+   5-6    - loop\n+   7      - shift 2nd half other way into carry.\n+\t    copy 1st half into 2nd half\n+\t    rotate entire word other way using carry\n+\t    mask off remaining bits  (ASHIFT | LSHIFTRT)\n+\t    sign extend remaining bits (ASHIFTRT)\n+   8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n+   9-12   - do shift by 8, inline remaining shifts\n+   13-14  - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n+          - ASHIFTRT: loop\n+   15     - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n+          - ASHIFTRT: shll, subx, set other byte\n \n    H8/300H SImode shifts\n    (These are complicated by the fact that we don't have byte level access to\n    the top word.)\n    A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n-   1-4   - do them inline\n-   5-14  - loop\n-   15    - shift other way once, move word into place, move carry into place\n-           (with sign extension for ASHIFTRT)\n-   16    - move word into place, zero or sign extend other\n-   17-23 - loop\n-   24    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n-                   move word 0 to word 1, zero word 0\n-           LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n-                     zero word 1, zero byte 1\n-           ASHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n-                     sign extend byte 0, sign extend word 0\n-   25-27 - either loop, or\n-           do 24 bit shift, inline rest\n-   28-30 - ASHIFT: rotate 4/3/2, mask\n-           LSHIFTRT: rotate 4/3/2, mask\n-           ASHIFTRT: loop\n-   31    - shll, subx byte 0, sign extend byte 0, sign extend word 0\n-\n-   Don't Panic!!!\n-\n-   All of these haven't been implemented.  I've just documented them and\n-   provided hooks so they can be.\n-*/\n+   1-4    - do them inline\n+   5-14   - loop\n+   15*    - shift other way once, move word into place, move carry into place\n+            (with sign extension for ASHIFTRT)\n+   16     - move word into place, zero or sign extend other\n+   17-20  - do 16bit shift, then inline remaining shifts\n+   20-23  - loop\n+   24*    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n+                    move word 0 to word 1, zero word 0\n+            LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n+                      zero word 1, zero byte 1\n+            ASHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n+                      sign extend byte 0, sign extend word 0\n+   25-27* - either loop, or\n+            do 24 bit shift, inline rest\n+   28-30  - ASHIFT: rotate 4/3/2, mask\n+            LSHIFTRT: rotate 4/3/2, mask\n+            ASHIFTRT: loop\n+   31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n+\n+   H8/S QImode shifts\n+   1-6    - do them inline\n+   7      - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+            ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+\n+   H8/S HImode shifts\n+   1-7\t  - do them inline\n+   8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n+   9-12   - do shift by 8, inline remaining shifts\n+   13-14  - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n+          - ASHIFTRT: loop\n+   15     - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n+          - ASHIFTRT: shll, subx, set other byte\n+\n+   H8/S SImode shifts\n+   (These are complicated by the fact that we don't have byte level access to\n+   the top word.)\n+   A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n+   1-10   - do them inline\n+   11-14  - loop\n+   15*    - shift other way once, move word into place, move carry into place\n+            (with sign extension for ASHIFTRT)\n+   16     - move word into place, zero or sign extend other\n+   17-20  - do 16bit shift, then inline remaining shifts\n+   20-23  - loop\n+   24*    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n+                    move word 0 to word 1, zero word 0\n+            LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n+                      zero word 1, zero byte 1\n+            ASHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n+                      sign extend byte 0, sign extend word 0\n+   25-27* - either loop, or\n+            do 24 bit shift, inline rest\n+   28-30  - ASHIFT: rotate 4/3/2, mask\n+            LSHIFTRT: rotate 4/3/2, mask\n+            ASHIFTRT: loop\n+   31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n+\n+   Panic!!!  */\n \n int\n nshift_operator (x, mode)\n@@ -1834,46 +1922,68 @@ static const struct shift_insn shift_one[2][3][3] =\n   {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shll %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n-      { \"add.w %T0,%T0\\t; shal.w\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n-      { \"add.w %f0,%f0\\t; shal.l\\n\\taddx %y0,%y0\\n\\taddx %z0,%z0\\t; end shal.l\", 0 }\n+      { \"shll\\t%X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"add.w\\t%T0,%T0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"add.w\\t%f0,%f0\\n\\taddx\\t%y0,%y0\\n\\taddx\\t%z0,%z0\", 0 }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n-      { \"shlr %t0\\t; shlr.w\\n\\trotxr %s0\\t; end shlr.w\", 0 },\n-      { \"shlr %z0\\t; shlr.l\\n\\trotxr %y0\\n\\trotxr %x0\\n\\trotxr %w0\\t; end shlr.l\", 0 }\n+      { \"shlr\\t%X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr\\t%t0\\n\\trotxr\\t%s0\", 0 },\n+      { \"shlr\\t%z0\\n\\trotxr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\", 0 }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar %X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n-      { \"shar %t0\\t; shar.w\\n\\trotxr %s0\\t; end shar.w\", 0 },\n-      { \"shar %z0\\t; shar.l\\n\\trotxr %y0\\n\\trotxr %x0\\n\\trotxr %w0\\t; end shar.l\", 0 }\n+      { \"shar\\t%X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar\\t%t0\\n\\trotxr\\t%s0\", 0 },\n+      { \"shar\\t%z0\\n\\trotxr\\t%y0\\n\\trotxr\\t%x0\\n\\trotxr\\t%w0\", 0 }\n     }\n   },\n /* H8/300H */\n   {\n /* SHIFT_ASHIFT */\n     {\n-      { \"shll.b %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n-      { \"shll.w %T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n-      { \"shll.l %S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n+      { \"shll.b\\t%X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shll.w\\t%T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shll.l\\t%S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      { \"shlr.b %X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n-      { \"shlr.w %T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n-      { \"shlr.l %S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n+      { \"shlr.b\\t%X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr.w\\t%T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr.l\\t%S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      { \"shar.b %X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n-      { \"shar.w %T0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n-      { \"shar.l %S0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY }\n+      { \"shar.b\\t%X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar.w\\t%T0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar.l\\t%S0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY }\n     }\n   }\n };\n \n+static const struct shift_insn shift_two[3][3] =\n+{\n+/* SHIFT_ASHIFT */\n+    {\n+      { \"shll.b\\t#2,%X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shll.w\\t#2,%T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shll.l\\t#2,%S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n+    },\n+/* SHIFT_LSHIFTRT */\n+    {\n+      { \"shlr.b\\t#2,%X0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr.w\\t#2,%T0\", CC_OVERFLOW_0 | CC_NO_CARRY },\n+      { \"shlr.l\\t#2,%S0\", CC_OVERFLOW_0 | CC_NO_CARRY }\n+    },\n+/* SHIFT_ASHIFTRT */\n+    {\n+      { \"shar.b\\t#2,%X0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar.w\\t#2,%T0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+      { \"shar.l\\t#2,%S0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY }\n+    }\n+};\n+\n /* Rotates are organized by which shift they'll be used in implementing.\n    There's no need to record whether the cc is valid afterwards because\n    it is the AND insn that will decide this.  */\n@@ -1884,46 +1994,68 @@ static const char *const rotate_one[2][3][3] =\n   {\n /* SHIFT_ASHIFT */\n     {\n-      \"rotr %X0\",\n-      \"shlr %t0\\t; rotr.w\\n\\trotxr %s0\\n\\tbst #7,%t0\\t; end rotr.w\",\n+      \"rotr\\t%X0\",\n+      \"shlr\\t%t0\\n\\trotxr\\t%s0\\n\\tbst\\t#7,%t0\",\n       0\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      \"rotl %X0\",\n-      \"shll %s0\\t; rotl.w\\n\\trotxl %t0\\n\\tbst #0,%s0\\t; end rotl.w\",\n+      \"rotl\\t%X0\",\n+      \"shll\\t%s0\\n\\trotxl\\t%t0\\n\\tbst\\t#0,%s0\",\n       0\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      \"rotl %X0\",\n-      \"shll %s0\\t; rotl.w\\n\\trotxl %t0\\n\\tbst #0,%s0\\t; end rotl.w\",\n+      \"rotl\\t%X0\",\n+      \"shll\\t%s0\\n\\trotxl\\t%t0\\n\\tbst\\t#0,%s0\",\n       0\n     }\n   },\n /* H8/300H */\n   {\n /* SHIFT_ASHIFT */\n     {\n-      \"rotr.b %X0\",\n-      \"rotr.w %T0\",\n-      \"rotr.l %S0\"\n+      \"rotr.b\\t%X0\",\n+      \"rotr.w\\t%T0\",\n+      \"rotr.l\\t%S0\"\n     },\n /* SHIFT_LSHIFTRT */\n     {\n-      \"rotl.b %X0\",\n-      \"rotl.w %T0\",\n-      \"rotl.l %S0\"\n+      \"rotl.b\\t%X0\",\n+      \"rotl.w\\t%T0\",\n+      \"rotl.l\\t%S0\"\n     },\n /* SHIFT_ASHIFTRT */\n     {\n-      \"rotl.b %X0\",\n-      \"rotl.w %T0\",\n-      \"rotl.l %S0\"\n+      \"rotl.b\\t%X0\",\n+      \"rotl.w\\t%T0\",\n+      \"rotl.l\\t%S0\"\n     }\n   }\n };\n \n+static const char *const rotate_two[3][3] =\n+{\n+/* SHIFT_ASHIFT */\n+    {\n+      \"rotr.b\\t#2,%X0\",\n+      \"rotr.w\\t#2,%T0\",\n+      \"rotr.l\\t#2,%S0\"\n+    },\n+/* SHIFT_LSHIFTRT */\n+    {\n+      \"rotl.b\\t#2,%X0\",\n+      \"rotl.w\\t#2,%T0\",\n+      \"rotl.l\\t#2,%S0\"\n+    },\n+/* SHIFT_ASHIFTRT */\n+    {\n+      \"rotl.b\\t#2,%X0\",\n+      \"rotl.w\\t#2,%T0\",\n+      \"rotl.l\\t#2,%S0\"\n+    }\n+};\n+\n /* Given CPU, MODE, SHIFT_TYPE, and shift count COUNT, determine the best\n    algorithm for doing the shift.  The assembler code is stored in ASSEMBLER.\n    We don't achieve maximum efficiency in all cases, but the hooks are here\n@@ -1938,12 +2070,14 @@ static const char *const rotate_one[2][3][3] =\n    1,2,3,4 will be inlined (1,2 for SI).  */\n \n static enum shift_alg\n-get_shift_alg (cpu, shift_type, mode, count, assembler_p, cc_valid_p)\n+get_shift_alg (cpu, shift_type, mode, count, assembler_p,\n+\t       assembler2_p, cc_valid_p)\n      enum attr_cpu cpu;\n      enum shift_type shift_type;\n      enum machine_mode mode;\n      int count;\n      const char **assembler_p;\n+     const char **assembler2_p;\n      int *cc_valid_p;\n {\n   /* The default is to loop.  */\n@@ -1974,6 +2108,10 @@ get_shift_alg (cpu, shift_type, mode, count, assembler_p, cc_valid_p)\n   /* Assume either SHIFT_LOOP or SHIFT_INLINE.\n      It is up to the caller to know that looping clobbers cc.  */\n   *assembler_p = shift_one[cpu][shift_type][shift_mode].assembler;\n+  if (TARGET_H8300S)\n+    *assembler2_p = shift_two[shift_type][shift_mode].assembler;\n+  else\n+    *assembler2_p = NULL;\n   *cc_valid_p = shift_one[cpu][shift_type][shift_mode].cc_valid;\n \n   /* Now look for cases we want to optimize.  */\n@@ -1983,174 +2121,414 @@ get_shift_alg (cpu, shift_type, mode, count, assembler_p, cc_valid_p)\n     case QIshift:\n       if (count <= 4)\n \treturn SHIFT_INLINE;\n-      else if (count <= 6)\n+      else\n \t{\n+\t  /* Shift by 5/6 are only 3 insns on the H8/S, so it's just as\n+\t     fast as SHIFT_ROT_AND, plus CC is valid.  */\n+\t  if (TARGET_H8300S && count <= 6)\n+\t    return SHIFT_INLINE;\n+\n+\t  /* For ASHIFTRT by 7 bits, the sign bit is simply replicated\n+\t     through the entire value.  */\n+\t  if (shift_type == SHIFT_ASHIFTRT && count == 7)\n+\t    {\n+\t      *assembler_p = \"shll\\t%X0\\n\\tsubx\\t%X0,%X0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\n+\t  /* Other ASHIFTRTs are too much of a pain.  */\n \t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    return SHIFT_LOOP;\n+\n+\t  /* Other shifts by 5, 6, or 7 bits use SHIFT_ROT_AND.  */\n+\t  *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t  if (TARGET_H8300S)\n+\t    *assembler2_p = rotate_two[shift_type][shift_mode];\n+\t  *cc_valid_p = 0;\n+\t  return SHIFT_ROT_AND;\n+\t}\n+\n+    case HIshift:\n+      if (count <= 4)\n+\treturn SHIFT_INLINE;\n+      else if (TARGET_H8300S && count <= 7)\n+\treturn SHIFT_INLINE;\n+      else if (count == 7)\n+\t{\n+\t  if (shift_type == SHIFT_ASHIFT && TARGET_H8300)\n \t    {\n-\t      return SHIFT_LOOP;\n+\t      *assembler_p = \"shar.b\\t%t0\\n\\tmov.b\\t%s0,%t0\\n\\trotxr.b\\t%t0\\n\\trotr.b\\t%s0\\n\\tand.b\\t#0x80,%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n \t    }\n-\t  else\n+\n+\t  if (shift_type == SHIFT_ASHIFT && TARGET_H8300H)\n \t    {\n-\t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      *assembler_p = \"shar.b\\t%t0\\n\\tmov.b\\t%s0,%t0\\n\\trotxr.w\\t%T0\\n\\tand.b\\t#0x80,%s0\";\n \t      *cc_valid_p = 0;\n-\t      return SHIFT_ROT_AND;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\n+\t  if (shift_type == SHIFT_LSHIFTRT && TARGET_H8300)\n+\t    {\n+\t      *assembler_p = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.b\\t%s0\\n\\trotl.b\\t%t0\\n\\tand.b\\t#0x01,%t0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\n+\t  if (shift_type == SHIFT_LSHIFTRT && TARGET_H8300H)\n+\t    {\n+\t      *assembler_p = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.w\\t%T0\\n\\tand.b\\t#0x01,%t0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\n+\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    {\n+\t      *assembler_p = \"shal.b\\t%s0\\n\\tmov.b\\t%t0,%s0\\n\\trotxl.b\\t%s0\\n\\tsubx\\t%t0,%t0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n \t    }\n \t}\n-      else if (count == 7)\n+      else if (count == 8)\n \t{\n-\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t  switch (shift_type)\n \t    {\n-\t      *assembler_p = \"shll %X0\\t; shar.b(7)\\n\\tsubx %X0,%X0\\t; end shar.b(7)\";\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tshll\\t%t0\\n\\tsubx\\t%t0,%t0\\t\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    }\n-\t  else\n+\t}\n+      else if (count == 9)\n+\t{\n+\t  switch (shift_type)\n \t    {\n-\t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t%t0\";\n \t      *cc_valid_p = 0;\n-\t      return SHIFT_ROT_AND;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tbld\\t#7,%s0\\n\\tsubx\\t%t0,%t0\\n\\tshar.b\\t%s0\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\\n\\tshar.b\\t%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n \t    }\n \t}\n-      break;\n-    case HIshift:\n-      if (count <= 4)\n-\treturn SHIFT_INLINE;\n-      else if (count == 8)\n+      else if (count == 10)\n \t{\n \t  switch (shift_type)\n \t    {\n \t    case SHIFT_ASHIFT:\n-\t      *assembler_p = \"mov.b %s0,%t0\\t; shal.w(8)\\n\\tsub.b %s0,%s0\\t; end shal.w(8)\";\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t#2,%t0\\n\\t\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t%t0\\n\\tshal.b\\t%t0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    case SHIFT_LSHIFTRT:\n-\t      *assembler_p = \"mov.b %t0,%s0\\t; shlr.w(8)\\n\\tsub.b %t0,%t0\\t; end shlr.w(8)\";\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t#2,%s0\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t%s0\\n\\tshlr.b\\t%s0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    case SHIFT_ASHIFTRT:\n-\t      if (cpu == CPU_H8300)\n-\t\t*assembler_p = \"mov.b %t0,%s0\\t; shar.w(8)\\n\\tshll %t0\\n\\tsubx %t0,%t0\\t; end shar.w(8)\";\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tbld\\t#7,%s0\\n\\tsubx\\t%t0,%t0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\";\n+\t      else if (TARGET_H8300H)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\";\n+\t      else if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\\n\\tshar.b\\t#2,%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count == 11)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t#2,%t0\\n\\tshal.b\\t%t0\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t%t0\\n\\tshal.b\\t%t0\\n\\tshal.b\\t%t0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t#2,%s0\\n\\tshlr.b\\t%s0\";\n \t      else\n-\t\t*assembler_p = \"mov.b %t0,%s0\\t; shar.w(8)\\n\\texts.w %T0\\t; end shar.w(8)\";\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t%s0\\n\\tshlr.b\\t%s0\\n\\tshlr.b\\t%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tbld\\t#7,%s0\\n\\tsubx\\t%t0,%t0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\";\n+\t      else if (TARGET_H8300H)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\";\n+\t      else if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\texts.w\\t%T0\\n\\tshar.b\\t#2,%s0\\n\\tshar.b\\t%s0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    }\n-\t  abort ();\n \t}\n-      else if (count == 15)\n+      else if (count == 12)\n \t{\n-\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t#2,%t0\\n\\tshal.b\\t#2,%t0\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%s0,%t0\\n\\tsub.b\\t%s0,%s0\\n\\tshal.b\\t%t0\\n\\tshal.b\\t%t0\\n\\tshal.b\\t%t0\\n\\tshal.b\\t%t0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t#2,%s0\\n\\tshlr.b\\t#2,%s0\";\n+\t      else\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tsub.b\\t%t0,%t0\\n\\tshlr.b\\t%s0\\n\\tshlr.b\\t%s0\\n\\tshlr.b\\t%s0\\n\\tshlr.b\\t%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\tbld\\t#7,%s0\\n\\tsubx\\t%t0,%t0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\";\n+\t      else if (TARGET_H8300H)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\textw.w\\t%T0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\\n\\tshar.b\\t%s0\";\n+\t      else if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.b\\t%t0,%s0\\n\\textw.w\\t%T0\\n\\tshar.b\\t#2,%s0\\n\\tshar.b\\t#2,%s0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (!TARGET_H8300 && (count == 13 || count == 14)\n+\t       || count == 15)\n+\t{\n+\t  if (count == 15 && shift_type == SHIFT_ASHIFTRT)\n \t    {\n-\t      *assembler_p = \"shll %t0,%t0\\t; shar.w(15)\\n\\tsubx %t0,%t0\\n\\tmov.b %t0,%s0\\t; end shar.w(15)\";\n+\t      *assembler_p = \"shll\\t%t0,%t0\\n\\tsubx\\t%t0,%t0\\n\\tmov.b\\t%t0,%s0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    }\n \t  else\n \t    {\n \t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      if (TARGET_H8300S)\n+\t        *assembler2_p = rotate_two[shift_type][shift_mode];\n+\t      else\n+\t\t*assembler2_p = NULL;\n \t      *cc_valid_p = 0;\n \t      return SHIFT_ROT_AND;\n \t    }\n \t}\n       break;\n+\n     case SIshift:\n-      if (count <= (cpu == CPU_H8300 ? 2 : 4))\n+      if (count <= (TARGET_H8300 ? 2 : 4))\n \treturn SHIFT_INLINE;\n-      else if (count == 8)\n+      else if (TARGET_H8300S && count <= 10)\n+\treturn SHIFT_INLINE;\n+      else if (count == 8 && TARGET_H8300)\n \t{\n-\t  if (cpu == CPU_H8300)\n+\t  switch (shift_type)\n \t    {\n-\t      switch (shift_type)\n-\t\t{\n-\t\tcase SHIFT_ASHIFT:\n-\t\t  *assembler_p = \"mov.b %y0,%z0\\t; shal.l(8)\\n\\tmov.b %x0,%y0\\n\\tmov.b %w0,%x0\\n\\tsub.b %w0,%w0\\t; end shal.l(8)\";\n-\t\t  *cc_valid_p = 0;\n-\t\t  return SHIFT_SPECIAL;\n-\t\tcase SHIFT_LSHIFTRT:\n-\t\t  *assembler_p = \"mov.b %x0,%w0\\t; shlr.l(8)\\n\\tmov.b %y0,%x0\\n\\tmov.b %z0,%y0\\n\\tsub.b %z0,%z0\\t; end shlr.l(8)\";\n-\t\t  *cc_valid_p = 0;\n-\t\t  return SHIFT_SPECIAL;\n-\t\tcase SHIFT_ASHIFTRT:\n-\t\t  *assembler_p = \"mov.b %x0,%w0\\t; shar.l(8)\\n\\tmov.b %y0,%x0\\n\\tmov.b %z0,%y0\\n\\tshll %z0\\n\\tsubx %z0,%z0; end shar.l(8)\";\n-\t\t  *cc_valid_p = 0;\n-\t\t  return SHIFT_SPECIAL;\n-\t\t}\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.b\\t%y0,%z0n\\tmov.b\\t%x0,%y0\\n\\tmov.b\\t%w0,%x0\\n\\tsub.b\\t%w0,%w0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.b\\t%x0,%w0\\n\\tmov.b\\t%y0,%x0\\n\\tmov.b\\t%z0,%y0\\n\\tsub.b\\t%z0,%z0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      *assembler_p = \"mov.b\\t%x0,%w0\\n\\tmov.b\\t%y0,%x0\\n\\tmov.b\\t%z0,%y0\\n\\tshll\\t%z0\\n\\tsubx\\t%z0,%z0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n \t    }\n-\t  else\t\t\t/* CPU_H8300H */\n-\t    /* We don't have byte level access to the high word so this isn't\n-\t       easy to do.  For now, just loop.  */\n-\t    ;\n \t}\n       else if (count == 16)\n \t{\n \t  switch (shift_type)\n \t    {\n \t    case SHIFT_ASHIFT:\n-\t      *assembler_p = \"mov.w %f0,%e0\\t; shal.l(16)\\n\\tsub.w %f0,%f0\\t; end shal.l(16)\";\n+\t      *assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\tshll\\t%z0\\n\\tsubx\\t%z0,%z0\\n\\tmov.b\\t%z0,%y0\";\n+\t      else\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count == 17 && !TARGET_H8300)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\\n\\tshll.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\\n\\tshlr.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      *assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\\n\\tshar.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count == 18 && !TARGET_H8300)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\\n\\tshll.l\\t#2,%S0\";\n+\t      else\n+\t\t*assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\\n\\tshll.l\\t%S0\\n\\tshll.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\\n\\tshlr.l\\t#2,%S0\";\n+\t      else\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\\n\\tshlr.l\\t%S0\\n\\tshlr.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\\n\\tshar.l\\t#2,%S0\";\n+\t      else\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\\n\\tshar.l\\t%S0\\n\\tshar.l\\t%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count == 19 && !TARGET_H8300)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\\n\\tshll.l\\t#2,%S0\\n\\tshll.l\\t%S0\";\n+\t      else\n+\t\t*assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\\n\\tshll.l\\t%S0\\n\\tshll.l\\t%S0\\n\\tshll.l\\t%S0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    case SHIFT_LSHIFTRT:\n-\t      *assembler_p = \"mov.w %e0,%f0\\t; shlr.l(16)\\n\\tsub.w %e0,%e0\\t; end shlr.l(16)\";\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\\n\\tshlr.l\\t#2,%S0\\n\\tshlr.l\\t%S0\";\n+\t      else\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\\n\\tshlr.l\\t%S0\\n\\tshlr.l\\t%S0\\n\\tshlr.l\\t%S0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    case SHIFT_ASHIFTRT:\n-\t      if (cpu == CPU_H8300)\n-\t\t*assembler_p = \"mov.w %e0,%f0\\t; shar.l(16)\\n\\tshll %z0\\n\\tsubx %z0,%z0\\n\\tmov.b %z0,%y0\\t; end shar.l(16)\";\n+\t      if (TARGET_H8300S)\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\\n\\tshar.l\\t#2,%S0\\n\\tshar.l\\t%S0\";\n \t      else\n-\t\t*assembler_p = \"mov.w %e0,%f0\\t; shar.l(16)\\n\\texts.l %S0\\t; end shar.l(16)\";\n+\t\t*assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\\n\\tshar.l\\t%S0\\n\\tshar.l\\t%S0\\n\\tshar.l\\t%S0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    }\n \t}\n-      else if (count >= 28 && count <= 30)\n+      else if (count == 20 && TARGET_H8300S)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.w\\t%f0,%e0\\n\\tsub.w\\t%f0,%f0\\n\\tshll.l\\t#2,%S0\\n\\tshll.l\\t#2,%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.w\\t%e0,%f0\\n\\tsub.w\\t%e0,%e0\\n\\tshlr.l\\t#2,%S0\\n\\tshlr.l\\t#2,%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      *assembler_p = \"mov.w\\t%e0,%f0\\n\\texts.l\\t%S0\\n\\tshar.l\\t#2,%S0\\n\\tshar.l\\t#2,%S0\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count >= 28 && count <= 30 && !TARGET_H8300)\n \t{\n \t  if (shift_type == SHIFT_ASHIFTRT)\n \t    {\n \t      return SHIFT_LOOP;\n \t    }\n \t  else\n \t    {\n-\t      if (cpu == CPU_H8300)\n-\t\treturn SHIFT_LOOP;\n+\t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      if (TARGET_H8300S)\n+\t        *assembler2_p = rotate_two[shift_type][shift_mode];\n \t      else\n-\t\t{\n-\t\t  *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n-\t\t  *cc_valid_p = 0;\n-\t\t  return SHIFT_ROT_AND;\n-\t\t}\n+\t\t*assembler2_p = NULL;\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_ROT_AND;\n \t    }\n \t}\n       else if (count == 31)\n \t{\n \t  if (shift_type == SHIFT_ASHIFTRT)\n \t    {\n-\t      if (cpu == CPU_H8300)\n-\t\t*assembler_p = \"shll %z0\\t; shar.l(31)\\n\\tsubx %w0,%w0\\n\\tmov.b %w0,%x0\\n\\tmov.w %f0,%e0\\t; end shar.l(31)\";\n+\t      if (TARGET_H8300)\n+\t\t*assembler_p = \"shll\\t%z0\\n\\tsubx %w0,%w0\\n\\tmov.b\\t%w0,%x0\\n\\tmov.w\\t%f0,%e0\";\n \t      else\n-\t\t*assembler_p = \"shll %e0\\t; shar.l(31)\\n\\tsubx %w0,%w0\\n\\tmov.b %w0,%x0\\n\\tmov.w %f0,%e0\\t; end shar.l(31)\";\n+\t\t*assembler_p = \"shll\\t%e0\\n\\tsubx\\t%w0,%w0\\n\\tmov.b\\t%w0,%x0\\n\\tmov.w\\t%f0,%e0\";\n \t      *cc_valid_p = 0;\n \t      return SHIFT_SPECIAL;\n \t    }\n \t  else\n \t    {\n-\t      if (cpu == CPU_H8300)\n+\t      if (TARGET_H8300)\n \t\t{\n \t\t  if (shift_type == SHIFT_ASHIFT)\n-\t\t    *assembler_p = \"sub.w %e0,%e0\\t; shal.l(31)\\n\\tshlr %w0\\n\\tmov.w %e0,%f0\\n\\trotxr %z0\\t; end shal.l(31)\";\n+\t\t    *assembler_p = \"sub.w\\t%e0,%e0\\n\\tshlr\\t%w0\\n\\tmov.w\\t%e0,%f0\\n\\trotxr\\t%z0\";\n \t\t  else\n-\t\t    *assembler_p = \"sub.w %f0,%f0\\t; shlr.l(31)\\n\\tshll %z0\\n\\tmov.w %f0,%e0\\n\\trotxl %w0\\t; end shlr.l(31)\";\n+\t\t    *assembler_p = \"sub.w\\t%f0,%f0\\n\\tshll\\t%z0\\n\\tmov.w\\t%f0,%e0\\n\\trotxl\\t%w0\";\n \t\t  *cc_valid_p = 0;\n \t\t  return SHIFT_SPECIAL;\n \t\t}\n \t      else\n \t\t{\n \t\t  *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      if (TARGET_H8300S)\n+\t        *assembler2_p = rotate_two[shift_type][shift_mode];\n+\t      else\n+\t\t*assembler2_p = NULL;\n \t\t  *cc_valid_p = 0;\n \t\t  return SHIFT_ROT_AND;\n \t\t}\n \t    }\n \t}\n       break;\n+\n     default:\n       abort ();\n     }\n@@ -2167,6 +2545,7 @@ emit_a_shift (insn, operands)\n {\n   static int loopend_lab;\n   char *assembler;\n+  char *assembler2;\n   int cc_valid;\n   rtx inside = PATTERN (insn);\n   rtx shift = operands[3];\n@@ -2214,7 +2593,8 @@ emit_a_shift (insn, operands)\n       fprintf (asm_out_file, \"\\tble\t.Lle%d\\n\", loopend_lab);\n \n       /* Get the assembler code to do one shift.  */\n-      get_shift_alg (cpu_type, shift_type, mode, 1, &assembler, &cc_valid);\n+      get_shift_alg (cpu_type, shift_type, mode, 1, &assembler,\n+\t\t     &assembler2, &cc_valid);\n     }\n   else\n     {\n@@ -2230,19 +2610,34 @@ emit_a_shift (insn, operands)\n       else if (n > GET_MODE_BITSIZE (mode))\n \tn = GET_MODE_BITSIZE (mode);\n \n-      alg = get_shift_alg (cpu_type, shift_type, mode, n, &assembler, &cc_valid);\n+      alg = get_shift_alg (cpu_type, shift_type, mode, n, &assembler,\n+\t\t\t   &assembler2, &cc_valid);\n \n       switch (alg)\n \t{\n \tcase SHIFT_INLINE:\n-\t  while (--n >= 0)\n-\t    output_asm_insn (assembler, operands);\n+\t  /* Emit two bit shifts first.  */\n+\t  while (n > 1 && assembler2 != NULL)\n+\t    {\n+\t      output_asm_insn (assembler2, operands);\n+\t      n -= 2;\n+\t    }\n+\n+\t  /* Now emit one bit shifts for any residual.  */\n+\t  while (n > 0)\n+\t    {\n+\t      output_asm_insn (assembler, operands);\n+\t      n -= 1;\n+\t    }\n+\n+\t  /* Keep track of CC.  */\n \t  if (cc_valid)\n \t    {\n \t      cc_status.value1 = operands[0];\n \t      cc_status.flags |= cc_valid;\n \t    }\n \t  return \"\";\n+\n \tcase SHIFT_ROT_AND:\n \t  {\n \t    int m = GET_MODE_BITSIZE (mode) - n;\n@@ -2254,20 +2649,34 @@ emit_a_shift (insn, operands)\n \t       be generated, but let's watch for 'em.  */\n \t    if (assembler == 0)\n \t      abort ();\n-\t    while (--m >= 0)\n-\t      output_asm_insn (assembler, operands);\n+\n+\t    /* Emit two bit rotates first.  */\n+\t    while (m > 1 && assembler2 != NULL)\n+\t      {\n+\t\toutput_asm_insn (assembler2, operands);\n+\t\tm -= 2;\n+\t      }\n+\n+\t    /* Now single bit rotates for any residual.  */\n+\t    while (m > 0)\n+\t      {\n+\t\toutput_asm_insn (assembler, operands);\n+\t\tm -= 1;\n+\t      }\n+\n+\t    /* Now mask off the high bits.  */\n \t    if (TARGET_H8300)\n \t      {\n \t\tswitch (mode)\n \t\t  {\n \t\t  case QImode:\n-\t\t    sprintf (insn_buf, \"and #%d,%%X0\\t; end shift %d via rotate+and\",\n+\t\t    sprintf (insn_buf, \"and #%d,%%X0\",\n \t\t\t     mask, n);\n \t\t    cc_status.value1 = operands[0];\n \t\t    cc_status.flags |= CC_OVERFLOW_0 | CC_NO_CARRY;\n \t\t    break;\n \t\t  case HImode:\n-\t\t    sprintf (insn_buf, \"and #%d,%%s0\\n\\tand #%d,%%t0\\t; end shift %d via rotate+and\",\n+\t\t    sprintf (insn_buf, \"and #%d,%%s0\\n\\tand #%d,%%t0\",\n \t\t\t     mask & 255, mask >> 8, n);\n \t\t    break;\n \t\t  case SImode:\n@@ -2290,8 +2699,30 @@ emit_a_shift (insn, operands)\n \t  return \"\";\n \t}\n \n-      /* Need a loop, move limit to tmp reg */\n-      fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n, names_big[REGNO (operands[4])]);\n+      /* A loop to shift by a \"large\" constant value.\n+\t If we have shift-by-2 insns, use them.  */\n+      if (assembler2 != NULL)\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n / 2,\n+\t\t   names_big[REGNO (operands[4])]);\n+\t  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+\t  output_asm_insn (assembler2, operands);\n+\t  output_asm_insn (\"add\t#0xff,%X4\", operands);\n+\t  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n+\t  if (n % 2)\n+\t    output_asm_insn (assembler, operands);\n+\t  return \"\";\n+\t}\n+      else\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n,\n+\t\t   names_big[REGNO (operands[4])]);\n+\t  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+\t  output_asm_insn (assembler, operands);\n+\t  output_asm_insn (\"add\t#0xff,%X4\", operands);\n+\t  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n+\t  return \"\";\n+\t}\n     }\n \n   fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);"}]}