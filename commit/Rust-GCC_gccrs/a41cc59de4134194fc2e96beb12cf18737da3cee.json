{"sha": "a41cc59de4134194fc2e96beb12cf18737da3cee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxY2M1OWRlNDEzNDE5NGZjMmU5NmJlYjEyY2YxODczN2RhM2NlZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-10-03T20:00:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-10-03T20:00:46Z"}, "message": "gimple-ssa-sprintf.c (struct fmtresult): Add new member and initialize it.\n\n\t* gimple-ssa-sprintf.c (struct fmtresult): Add new member and\n\tinitialize it.\n\t(get_string_length): Detect unterminated arrays.\n\t(format_string): Same.\n\t(format_directive): Warn about unterminated arrays.\n\t(handle_gimple_call): Mark statements with no_warning as needed.\n\n\t* gcc.dg/warn-sprintf-no-nul.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r264822", "tree": {"sha": "0988b94c4dbe58784462cbb8759f7fce187de973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0988b94c4dbe58784462cbb8759f7fce187de973"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a41cc59de4134194fc2e96beb12cf18737da3cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41cc59de4134194fc2e96beb12cf18737da3cee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41cc59de4134194fc2e96beb12cf18737da3cee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41cc59de4134194fc2e96beb12cf18737da3cee/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "119b4963ea4f68e88eb496f0efcb450e1fbbbe9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119b4963ea4f68e88eb496f0efcb450e1fbbbe9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/119b4963ea4f68e88eb496f0efcb450e1fbbbe9b"}], "stats": {"total": 162, "additions": 158, "deletions": 4}, "files": [{"sha": "1f479545e53c8edd9d7e6081b8da35c41ad3fc21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a41cc59de4134194fc2e96beb12cf18737da3cee", "patch": "@@ -1,3 +1,13 @@\n+2018-10-03  Martin Sebor  <msebor@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* gimple-ssa-sprintf.c (struct fmtresult): Add new member and\n+\tinitialize it.\n+\t(get_string_length): Detect unterminated arrays.\n+\t(format_string): Same.\n+\t(format_directive): Warn about unterminated arrays.\n+\t(handle_gimple_call): Mark statements with no_warning as needed.\n+\n 2018-10-03  Jim Wilson  <jimw@sifive.com>\n \n \t* config/riscv/riscv-c.c (riscv_cpu_cpp_builtins): For ABI_ILP32E,"}, {"sha": "88e952828e1c13a867d48ef16f442c8108f630b5", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=a41cc59de4134194fc2e96beb12cf18737da3cee", "patch": "@@ -516,7 +516,7 @@ struct fmtresult\n   /* Construct a FMTRESULT object with all counters initialized\n      to MIN.  KNOWNRANGE is set when MIN is valid.  */\n   fmtresult (unsigned HOST_WIDE_INT min = HOST_WIDE_INT_MAX)\n-  : argmin (), argmax (),\n+  : argmin (), argmax (), nonstr (),\n     knownrange (min < HOST_WIDE_INT_MAX),\n     mayfail (), nullp ()\n   {\n@@ -530,7 +530,7 @@ struct fmtresult\n      KNOWNRANGE is set when both MIN and MAX are valid.   */\n   fmtresult (unsigned HOST_WIDE_INT min, unsigned HOST_WIDE_INT max,\n \t     unsigned HOST_WIDE_INT likely = HOST_WIDE_INT_MAX)\n-  : argmin (), argmax (),\n+  : argmin (), argmax (), nonstr (),\n     knownrange (min < HOST_WIDE_INT_MAX && max < HOST_WIDE_INT_MAX),\n     mayfail (), nullp ()\n   {\n@@ -557,6 +557,10 @@ struct fmtresult\n      results in on output for an argument in the range above.  */\n   result_range range;\n \n+  /* Non-nul when the argument of a string directive is not a nul\n+     terminated string.  */\n+  tree nonstr;\n+\n   /* True when the range above is obtained from a known value of\n      a directive's argument or its bounds and not the result of\n      heuristics that depend on warning levels.  */\n@@ -2001,13 +2005,38 @@ get_string_length (tree str, unsigned eltsize)\n   if (!str)\n     return fmtresult ();\n \n+  c_strlen_data data;\n+  memset (&data, 0, sizeof (c_strlen_data));\n+  tree slen = c_strlen (str, 1, &data, eltsize);\n+  if (slen && TREE_CODE (slen) == INTEGER_CST)\n+    {\n+      /* The string is properly terminated and\n+\t we know its length.  */\n+      fmtresult res (tree_to_shwi (slen));\n+      res.nonstr = NULL_TREE;\n+      return res;\n+    }\n+  else if (!slen\n+\t   && data.decl\n+\t   && data.len\n+\t   && TREE_CODE (data.len) == INTEGER_CST)\n+    {\n+      /* STR was not properly NUL terminated, but we have\n+\t length information about the unterminated string.  */\n+      fmtresult res (tree_to_shwi (data.len));\n+      res.nonstr = data.decl;\n+      return res;\n+    }\n+\n   /* Determine the length of the shortest and longest string referenced\n      by STR.  Strings of unknown lengths are bounded by the sizes of\n      arrays that subexpressions of STR may refer to.  Pointers that\n      aren't known to point any such arrays result in LENRANGE[1] set\n-     to SIZE_MAX.  */\n+     to SIZE_MAX.  NONSTR is set to the declaration of the constant\n+     array that is known not to be nul-terminated.  */\n   tree lenrange[2];\n-  bool flexarray = get_range_strlen (str, lenrange, eltsize);\n+  tree nonstr;\n+  bool flexarray = get_range_strlen (str, lenrange, eltsize, false, &nonstr);\n \n   if (lenrange [0] || lenrange [1])\n     {\n@@ -2030,6 +2059,7 @@ get_string_length (tree str, unsigned eltsize)\n \tmax = HOST_WIDE_INT_M1U;\n \n       fmtresult res (min, max);\n+      res.nonstr = nonstr;\n \n       /* Set RES.KNOWNRANGE to true if and only if all strings referenced\n \t by STR are known to be bounded (though not necessarily by their\n@@ -2309,6 +2339,11 @@ format_string (const directive &dir, tree arg, vr_values *)\n       res.range.unlikely = res.range.max;\n     }\n \n+  /* If the argument isn't a nul-terminated string and the number\n+     of bytes on output isn't bounded by precision, set NONSTR.  */\n+  if (slen.nonstr && slen.range.min < (unsigned HOST_WIDE_INT)dir.prec[0])\n+    res.nonstr = slen.nonstr;\n+\n   /* Bump up the byte counters if WIDTH is greater.  */\n   return res.adjust_for_width_or_precision (dir.width);\n }\n@@ -2878,6 +2913,19 @@ format_directive (const sprintf_dom_walker::call_info &info,\n \t\t\t  fmtres.range.min, fmtres.range.max);\n     }\n \n+  if (!warned && fmtres.nonstr)\n+    {\n+      warned = fmtwarn (dirloc, argloc, NULL, info.warnopt (),\n+\t\t\t\"%<%.*s%> directive argument is not a nul-terminated \"\n+\t\t\t\"string\",\n+\t\t\tdirlen,\n+\t\t\ttarget_to_host (hostdir, sizeof hostdir, dir.beg));\n+      if (warned && DECL_P (fmtres.nonstr))\n+\tinform (DECL_SOURCE_LOCATION (fmtres.nonstr),\n+\t\t\"referenced argument declared here\");\n+      return false;\n+    }\n+\n   if (warned && fmtres.range.min < fmtres.range.likely\n       && fmtres.range.likely < fmtres.range.max)\n     inform_n (info.fmtloc, fmtres.range.likely,\n@@ -3926,6 +3974,8 @@ sprintf_dom_walker::handle_gimple_call (gimple_stmt_iterator *gsi)\n   format_result res = format_result ();\n \n   bool success = compute_format_length (info, &res);\n+  if (res.warned)\n+    gimple_set_no_warning (info.callstmt, true);\n \n   /* When optimizing and the printf return value optimization is enabled,\n      attempt to substitute the computed result for the return value of"}, {"sha": "c06842d0f4f54c9aab5425e0372a36fb7485cd92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a41cc59de4134194fc2e96beb12cf18737da3cee", "patch": "@@ -1,3 +1,7 @@\n+2018-10-03  Martin Sebor  <msebor@redhat.com>\n+\n+\t* gcc.dg/warn-sprintf-no-nul.c: New test.\n+\n 2018-10-03  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/86109"}, {"sha": "b331bb5aaff433c929ab420fead30ec440617f29", "filename": "gcc/testsuite/gcc.dg/warn-sprintf-no-nul.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-sprintf-no-nul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41cc59de4134194fc2e96beb12cf18737da3cee/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-sprintf-no-nul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-sprintf-no-nul.c?ref=a41cc59de4134194fc2e96beb12cf18737da3cee", "patch": "@@ -0,0 +1,90 @@\n+/* PR tree-optimization/86552 - missing warning for reading past the end\n+   of non-string arrays\n+   Exercise non-string detection in sprintf.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wno-array-bounds -Wall -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern int sprintf (char*, const char*, ...);\n+\n+extern char *dst;\n+\n+int i0 = 0;\n+int i1 = 1;\n+\n+void sink (int, ...);\n+\n+#define CONCAT(a, b)   a ## b\n+#define CAT(a, b)      CONCAT(a, b)\n+\n+#define T(fmt, ...)\t\t\t\t\\\n+  sink (sprintf (dst, fmt, __VA_ARGS__))\n+\n+const char a[5] = \"12345\";    /* { dg-message \"declared here\" } */\n+const char b[6] = \"123456\";   /* { dg-message \"declared here\" } */\n+const char a2[][3] = {\n+  \"\", \"1\", \"12\", \"123\", \"123\\000\"   /* { dg-warning \"initializer-string for array of chars is too long\" } */\n+};\n+\n+\n+void test_narrow (void)\n+{\n+  /* Verify that precision suppresses the warning when it's less\n+     than the size of the array.  */\n+  T (\"%.0s%.1s%.2s%.3s%.4s%.5s\", a, a, a, a, a, a);\n+\n+  T (\"%s\", a);          /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+  T (\"%.6s\", a);        /* { dg-warning \".%.6s. directive argument is not a nul-terminated string\" } */\n+\n+  /* Exercise conditional expressions involving strings and non-strings.  */\n+  const char *s0 = i0 < 0 ? a2[0] : a2[3];\n+  T (\"%s\", s0);         /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+  s0 = i0 < 0 ? \"123456\" : a2[4];\n+  T (\"%s\", s0);         /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+\n+  const char *s1 = i0 < 0 ? a2[3] : a2[0];\n+  T (\"%s\", s1);         /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+\n+  const char *s2 = i0 < 0 ? a2[3] : a2[4];\n+  T (\"%s\", s2);         /* { dg-warning \".%s. directive argument is not a nul-terminated string\" } */\n+\n+  s0 = i0 < 0 ? a : b;\n+  T (\"%.5s\", s0);\n+\n+  /* Verify that the warning triggers even if precision prevents\n+     reading past the end of one of the non-terminated arrays but\n+     not the other.  */\n+  T (\"%.6s\", s0);       /* { dg-warning \".%.6s. directive argument is not a nul-terminated string\" } */\n+\n+  s0 = i0 < 0 ? b : a;\n+  T (\"%.7s\", s0);       /* { dg-warning \".%.7s. directive argument is not a nul-terminated string\" } */\n+\n+  /* Verify that at -Wformat-overflow=1 the lower bound of precision\n+     given by a range is used to determine whether or not to warn.  */\n+  int r = SR (4, 5);\n+\n+  T (\"%.*s\", r, a);\n+  T (\"%.*s\", r, b);\n+\n+  r = SR (5, 6);\n+  T (\"%.*s\", r, a);\n+  T (\"%.*s\", r, b);\n+\n+  r = SR (6, 7);\n+  T (\"%.*s\", r, a);     /* { dg-warning \".%.\\\\\\*s. directive argument is not a nul-terminated string\" } */\n+  T (\"%.*s\", r, b);\n+}\n+\n+\n+const wchar_t wa[5] = L\"12345\";   /* { dg-message \"declared here\" } */\n+\n+void test_wide (void)\n+{\n+  T (\"%.0ls%.1ls%.2ls%.3ls%.4ls%.5ls\", wa, wa, wa, wa, wa, wa);\n+\n+  T (\"%ls\", wa);        /* { dg-warning \".%ls. directive argument is not a nul-terminated string\" } */\n+  T (\"%.6ls\", wa);      /* { dg-warning \".%.6ls. directive argument is not a nul-terminated string\" } */\n+}"}]}