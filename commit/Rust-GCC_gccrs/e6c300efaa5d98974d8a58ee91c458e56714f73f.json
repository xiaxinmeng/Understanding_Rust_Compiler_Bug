{"sha": "e6c300efaa5d98974d8a58ee91c458e56714f73f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZjMzAwZWZhYTVkOTg5NzRkOGE1OGVlOTFjNDU4ZTU2NzE0ZjczZg==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2006-04-05T21:26:34Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2006-04-05T21:26:34Z"}, "message": "Makefile.am: Add PA_HPUX port.\n\n2006-04-05  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n\t    Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* Makefile.am: Add PA_HPUX port.\n\t* Makefile.in: Regenerate.\n\t* include/Makefile.in: Likewise.\n\t* testsuite/Makefile.in: Likewise.\n\t* configure.ac: Add PA_HPUX rules.\n\t* configure: Regenerate.\n\t* src/pa/ffitarget.h: Rename linux target to PA_LINUX.\n\tAdd PA_HPUX and PA64_HPUX.\n\tRename FFI_LINUX ABI to FFI_PA32 ABI.\n\t(FFI_TRAMPOLINE_SIZE): Define for 32-bit HP-UX targets.\n\t(FFI_TYPE_SMALL_STRUCT2): Define.\n\t(FFI_TYPE_SMALL_STRUCT4): Likewise.\n\t(FFI_TYPE_SMALL_STRUCT8): Likewise.\n\t(FFI_TYPE_SMALL_STRUCT3): Redefine.\n\t(FFI_TYPE_SMALL_STRUCT5): Likewise.\n\t(FFI_TYPE_SMALL_STRUCT6): Likewise.\n\t(FFI_TYPE_SMALL_STRUCT7): Likewise.\n\t* src/pa/ffi.c (ROUND_DOWN): Delete.\n\t(fldw, fstw, fldd, fstd): Use '__asm__'.\n\t(ffi_struct_type): Add support for FFI_TYPE_SMALL_STRUCT2,\n\tFFI_TYPE_SMALL_STRUCT4 and FFI_TYPE_SMALL_STRUCT8.\n\t(ffi_prep_args_LINUX): Rename to ffi_prep_args_pa32. Update comment.\n\tSimplify incrementing of stack slot variable. Change type of local\n\t'n' to unsigned int.\n\t(ffi_size_stack_LINUX): Rename to ffi_size_stack_pa32. Handle long\n\tdouble on PA_HPUX.\n\t(ffi_prep_cif_machdep): Likewise.\n\t(ffi_call): Likewise.\n\t(ffi_closure_inner_LINUX): Rename to ffi_closure_inner_pa32. Change\n\treturn type to ffi_status. Simplify incrementing of stack slot\n\tvariable. Only copy floating point argument registers when PA_LINUX\n\tis true. Reformat debug statement.\n\tAdd support for FFI_TYPE_SMALL_STRUCT2, FFI_TYPE_SMALL_STRUCT4 and\n\tFFI_TYPE_SMALL_STRUCT8.\n\t(ffi_closure_LINUX): Rename to ffi_closure_pa32. Add 'extern' to\n\tdeclaration.\n\t(ffi_prep_closure): Make linux trampoline conditional on PA_LINUX.\n\tAdd nops to cache flush.  Add trampoline for PA_HPUX.\n\t* src/pa/hpux32.S: New file.\n\t* src/pa/linux.S (ffi_call_LINUX): Rename to ffi_call_pa32. Rename\n\tffi_prep_args_LINUX to ffi_prep_args_pa32.\n\tLocalize labels. Add support for 2, 4 and 8-byte small structs. Handle\n\tunaligned destinations in 3, 5, 6 and 7-byte small structs. Order\n\targument type checks so that common argument types appear first.\n\t(ffi_closure_LINUX): Rename to ffi_closure_pa32. Rename\n\tffi_closure_inner_LINUX to ffi_closure_inner_pa32.\n\nCo-Authored-By: Andreas Tobler <a.tobler@schweiz.ch>\n\nFrom-SVN: r112719", "tree": {"sha": "e38e6b7b7e9fa8cdd32350f91446780dab010fc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e38e6b7b7e9fa8cdd32350f91446780dab010fc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6c300efaa5d98974d8a58ee91c458e56714f73f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c300efaa5d98974d8a58ee91c458e56714f73f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6c300efaa5d98974d8a58ee91c458e56714f73f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c300efaa5d98974d8a58ee91c458e56714f73f/comments", "author": null, "committer": null, "parents": [{"sha": "300adfc2dda4d3c1922367bee08c4cc29a5ac80f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/300adfc2dda4d3c1922367bee08c4cc29a5ac80f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/300adfc2dda4d3c1922367bee08c4cc29a5ac80f"}], "stats": {"total": 1183, "additions": 915, "deletions": 268}, "files": [{"sha": "b7ec8d6beb4fde64ed5e69e2502cb788f63f2efe", "filename": "libffi/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -1,3 +1,53 @@\n+2006-04-05  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\t    Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* Makefile.am: Add PA_HPUX port.\n+\t* Makefile.in: Regenerate.\n+\t* include/Makefile.in: Likewise.\n+\t* testsuite/Makefile.in: Likewise.\n+\t* configure.ac: Add PA_HPUX rules.\n+\t* configure: Regenerate.\n+\t* src/pa/ffitarget.h: Rename linux target to PA_LINUX.\n+\tAdd PA_HPUX and PA64_HPUX.\n+\tRename FFI_LINUX ABI to FFI_PA32 ABI.\n+\t(FFI_TRAMPOLINE_SIZE): Define for 32-bit HP-UX targets.\n+\t(FFI_TYPE_SMALL_STRUCT2): Define.\n+\t(FFI_TYPE_SMALL_STRUCT4): Likewise.\n+\t(FFI_TYPE_SMALL_STRUCT8): Likewise.\n+\t(FFI_TYPE_SMALL_STRUCT3): Redefine.\n+\t(FFI_TYPE_SMALL_STRUCT5): Likewise.\n+\t(FFI_TYPE_SMALL_STRUCT6): Likewise.\n+\t(FFI_TYPE_SMALL_STRUCT7): Likewise.\n+\t* src/pa/ffi.c (ROUND_DOWN): Delete.\n+\t(fldw, fstw, fldd, fstd): Use '__asm__'.\n+\t(ffi_struct_type): Add support for FFI_TYPE_SMALL_STRUCT2,\n+\tFFI_TYPE_SMALL_STRUCT4 and FFI_TYPE_SMALL_STRUCT8.\n+\t(ffi_prep_args_LINUX): Rename to ffi_prep_args_pa32. Update comment.\n+\tSimplify incrementing of stack slot variable. Change type of local\n+\t'n' to unsigned int.\n+\t(ffi_size_stack_LINUX): Rename to ffi_size_stack_pa32. Handle long\n+\tdouble on PA_HPUX.\n+\t(ffi_prep_cif_machdep): Likewise.\n+\t(ffi_call): Likewise.\n+\t(ffi_closure_inner_LINUX): Rename to ffi_closure_inner_pa32. Change\n+\treturn type to ffi_status. Simplify incrementing of stack slot\n+\tvariable. Only copy floating point argument registers when PA_LINUX\n+\tis true. Reformat debug statement.\n+\tAdd support for FFI_TYPE_SMALL_STRUCT2, FFI_TYPE_SMALL_STRUCT4 and\n+\tFFI_TYPE_SMALL_STRUCT8.\n+\t(ffi_closure_LINUX): Rename to ffi_closure_pa32. Add 'extern' to\n+\tdeclaration.\n+\t(ffi_prep_closure): Make linux trampoline conditional on PA_LINUX.\n+\tAdd nops to cache flush.  Add trampoline for PA_HPUX.\n+\t* src/pa/hpux32.S: New file.\n+\t* src/pa/linux.S (ffi_call_LINUX): Rename to ffi_call_pa32. Rename\n+\tffi_prep_args_LINUX to ffi_prep_args_pa32.\n+\tLocalize labels. Add support for 2, 4 and 8-byte small structs. Handle\n+\tunaligned destinations in 3, 5, 6 and 7-byte small structs. Order\n+\targument type checks so that common argument types appear first.\n+\t(ffi_closure_LINUX): Rename to ffi_closure_pa32. Rename\n+\tffi_closure_inner_LINUX to ffi_closure_inner_pa32.\n+\n 2006-03-24  Alan Modra  <amodra@bigpond.net.au>\n \n \t* src/powerpc/ffitarget.h (enum ffi_abi): Add FFI_LINUX.  Default"}, {"sha": "af9bc17e361515149be3e90e3649ca423cf7b75b", "filename": "libffi/Makefile.am", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -26,7 +26,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 \\\n \tsrc/sparc/ffi.c \\\n \tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S \\\n \tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \\\n-\tsrc/pa/ffi.c src/pa/linux.S src/frv/eabi.S src/frv/ffitarget.h\n+\tsrc/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \\\n+\tsrc/frv/eabi.S src/frv/ffitarget.h\n \n ## ################################################################\n \n@@ -141,9 +142,12 @@ endif\n if SH64\n nodist_libffi_la_SOURCES += src/sh64/sysv.S src/sh64/ffi.c\n endif\n-if PA\n+if PA_LINUX\n nodist_libffi_la_SOURCES += src/pa/linux.S src/pa/ffi.c\n endif\n+if PA_HPUX\n+nodist_libffi_la_SOURCES += src/pa/hpux32.S src/pa/ffi.c\n+endif\n \n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)"}, {"sha": "b0a9b154f82bfebd439f765cb0e100a886ce1ecf", "filename": "libffi/Makefile.in", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -59,7 +59,8 @@ target_triplet = @target@\n @X86_64_TRUE@am__append_18 = src/x86/ffi64.c src/x86/unix64.S src/x86/ffi.c src/x86/sysv.S\n @SH_TRUE@am__append_19 = src/sh/sysv.S src/sh/ffi.c\n @SH64_TRUE@am__append_20 = src/sh64/sysv.S src/sh64/ffi.c\n-@PA_TRUE@am__append_21 = src/pa/linux.S src/pa/ffi.c\n+@PA_LINUX_TRUE@am__append_21 = src/pa/linux.S src/pa/ffi.c\n+@PA_HPUX_TRUE@am__append_22 = src/pa/hpux32.S src/pa/ffi.c\n DIST_COMMON = README $(am__configure_deps) $(srcdir)/../compile \\\n \t$(srcdir)/../config.guess $(srcdir)/../config.sub \\\n \t$(srcdir)/../depcomp $(srcdir)/../install-sh \\\n@@ -123,29 +124,31 @@ am_libffi_la_OBJECTS = src/debug.lo src/prep_cif.lo src/types.lo \\\n @X86_64_TRUE@\tsrc/x86/ffi.lo src/x86/sysv.lo\n @SH_TRUE@am__objects_19 = src/sh/sysv.lo src/sh/ffi.lo\n @SH64_TRUE@am__objects_20 = src/sh64/sysv.lo src/sh64/ffi.lo\n-@PA_TRUE@am__objects_21 = src/pa/linux.lo src/pa/ffi.lo\n+@PA_LINUX_TRUE@am__objects_21 = src/pa/linux.lo src/pa/ffi.lo\n+@PA_HPUX_TRUE@am__objects_22 = src/pa/hpux32.lo src/pa/ffi.lo\n nodist_libffi_la_OBJECTS = $(am__objects_1) $(am__objects_2) \\\n \t$(am__objects_3) $(am__objects_4) $(am__objects_5) \\\n \t$(am__objects_6) $(am__objects_7) $(am__objects_8) \\\n \t$(am__objects_9) $(am__objects_10) $(am__objects_11) \\\n \t$(am__objects_12) $(am__objects_13) $(am__objects_14) \\\n \t$(am__objects_15) $(am__objects_16) $(am__objects_17) \\\n \t$(am__objects_18) $(am__objects_19) $(am__objects_20) \\\n-\t$(am__objects_21)\n+\t$(am__objects_21) $(am__objects_22)\n libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \\\n \t$(nodist_libffi_la_OBJECTS)\n libffi_convenience_la_LIBADD =\n-am__objects_22 = src/debug.lo src/prep_cif.lo src/types.lo \\\n+am__objects_23 = src/debug.lo src/prep_cif.lo src/types.lo \\\n \tsrc/raw_api.lo src/java_raw_api.lo\n-am_libffi_convenience_la_OBJECTS = $(am__objects_22)\n-am__objects_23 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n+am_libffi_convenience_la_OBJECTS = $(am__objects_23)\n+am__objects_24 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n \t$(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_8) $(am__objects_9) \\\n \t$(am__objects_10) $(am__objects_11) $(am__objects_12) \\\n \t$(am__objects_13) $(am__objects_14) $(am__objects_15) \\\n \t$(am__objects_16) $(am__objects_17) $(am__objects_18) \\\n-\t$(am__objects_19) $(am__objects_20) $(am__objects_21)\n-nodist_libffi_convenience_la_OBJECTS = $(am__objects_23)\n+\t$(am__objects_19) $(am__objects_20) $(am__objects_21) \\\n+\t$(am__objects_22)\n+nodist_libffi_convenience_la_OBJECTS = $(am__objects_24)\n libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \\\n \t$(nodist_libffi_convenience_la_OBJECTS)\n DEFAULT_INCLUDES = -I. -I$(srcdir) -I.\n@@ -250,15 +253,19 @@ MIPS_IRIX_TRUE = @MIPS_IRIX_TRUE@\n MIPS_LINUX_FALSE = @MIPS_LINUX_FALSE@\n MIPS_LINUX_TRUE = @MIPS_LINUX_TRUE@\n OBJEXT = @OBJEXT@\n+PA64_HPUX_FALSE = @PA64_HPUX_FALSE@\n+PA64_HPUX_TRUE = @PA64_HPUX_TRUE@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n PACKAGE_NAME = @PACKAGE_NAME@\n PACKAGE_STRING = @PACKAGE_STRING@\n PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n-PA_FALSE = @PA_FALSE@\n-PA_TRUE = @PA_TRUE@\n+PA_HPUX_FALSE = @PA_HPUX_FALSE@\n+PA_HPUX_TRUE = @PA_HPUX_TRUE@\n+PA_LINUX_FALSE = @PA_LINUX_FALSE@\n+PA_LINUX_TRUE = @PA_LINUX_TRUE@\n POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@\n POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@\n POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@\n@@ -359,7 +366,8 @@ EXTRA_DIST = LICENSE ChangeLog.v1 \\\n \tsrc/sparc/ffi.c \\\n \tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S \\\n \tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \\\n-\tsrc/pa/ffi.c src/pa/linux.S src/frv/eabi.S src/frv/ffitarget.h\n+\tsrc/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \\\n+\tsrc/frv/eabi.S src/frv/ffitarget.h\n \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n@@ -412,7 +420,7 @@ nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) \\\n \t$(am__append_12) $(am__append_13) $(am__append_14) \\\n \t$(am__append_15) $(am__append_16) $(am__append_17) \\\n \t$(am__append_18) $(am__append_19) $(am__append_20) \\\n-\t$(am__append_21)\n+\t$(am__append_21) $(am__append_22)\n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n AM_CFLAGS = -Wall -g -fexceptions\n@@ -695,6 +703,8 @@ src/pa/$(DEPDIR)/$(am__dirstamp):\n src/pa/linux.lo: src/pa/$(am__dirstamp) \\\n \tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n src/pa/ffi.lo: src/pa/$(am__dirstamp) src/pa/$(DEPDIR)/$(am__dirstamp)\n+src/pa/hpux32.lo: src/pa/$(am__dirstamp) \\\n+\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES) \n \t$(LINK) -rpath $(toolexeclibdir) $(libffi_la_LDFLAGS) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)\n libffi_convenience.la: $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_DEPENDENCIES) \n@@ -742,6 +752,8 @@ mostlyclean-compile:\n \t-rm -f src/mips/o32.lo\n \t-rm -f src/pa/ffi.$(OBJEXT)\n \t-rm -f src/pa/ffi.lo\n+\t-rm -f src/pa/hpux32.$(OBJEXT)\n+\t-rm -f src/pa/hpux32.lo\n \t-rm -f src/pa/linux.$(OBJEXT)\n \t-rm -f src/pa/linux.lo\n \t-rm -f src/powerpc/aix.$(OBJEXT)"}, {"sha": "0c32170a753625b224918a21d0d92d933d6a9015", "filename": "libffi/configure", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -310,7 +310,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS CCAS CCASFLAGS LN_S RANLIB ac_ct_RANLIB LIBTOOL MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CPP CPPFLAGS EGREP TESTSUBDIR_TRUE TESTSUBDIR_FALSE AM_RUNTESTFLAGS MIPS_IRIX_TRUE MIPS_IRIX_FALSE MIPS_LINUX_TRUE MIPS_LINUX_FALSE SPARC_TRUE SPARC_FALSE X86_TRUE X86_FALSE X86_WIN32_TRUE X86_WIN32_FALSE ALPHA_TRUE ALPHA_FALSE IA64_TRUE IA64_FALSE M32R_TRUE M32R_FALSE M68K_TRUE M68K_FALSE POWERPC_TRUE POWERPC_FALSE POWERPC_AIX_TRUE POWERPC_AIX_FALSE POWERPC_DARWIN_TRUE POWERPC_DARWIN_FALSE POWERPC_FREEBSD_TRUE POWERPC_FREEBSD_FALSE ARM_TRUE ARM_FALSE LIBFFI_CRIS_TRUE LIBFFI_CRIS_FALSE FRV_TRUE FRV_FALSE S390_TRUE S390_FALSE X86_64_TRUE X86_64_FALSE SH_TRUE SH_FALSE SH64_TRUE SH64_FALSE PA_TRUE PA_FALSE ALLOCA HAVE_LONG_DOUBLE TARGET TARGETDIR toolexecdir toolexeclibdir LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS CCAS CCASFLAGS LN_S RANLIB ac_ct_RANLIB LIBTOOL MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CPP CPPFLAGS EGREP TESTSUBDIR_TRUE TESTSUBDIR_FALSE AM_RUNTESTFLAGS MIPS_IRIX_TRUE MIPS_IRIX_FALSE MIPS_LINUX_TRUE MIPS_LINUX_FALSE SPARC_TRUE SPARC_FALSE X86_TRUE X86_FALSE X86_WIN32_TRUE X86_WIN32_FALSE ALPHA_TRUE ALPHA_FALSE IA64_TRUE IA64_FALSE M32R_TRUE M32R_FALSE M68K_TRUE M68K_FALSE POWERPC_TRUE POWERPC_FALSE POWERPC_AIX_TRUE POWERPC_AIX_FALSE POWERPC_DARWIN_TRUE POWERPC_DARWIN_FALSE POWERPC_FREEBSD_TRUE POWERPC_FREEBSD_FALSE ARM_TRUE ARM_FALSE LIBFFI_CRIS_TRUE LIBFFI_CRIS_FALSE FRV_TRUE FRV_FALSE S390_TRUE S390_FALSE X86_64_TRUE X86_64_FALSE SH_TRUE SH_FALSE SH64_TRUE SH64_FALSE PA_LINUX_TRUE PA_LINUX_FALSE PA_HPUX_TRUE PA_HPUX_FALSE PA64_HPUX_TRUE PA64_HPUX_FALSE ALLOCA HAVE_LONG_DOUBLE TARGET TARGETDIR toolexecdir toolexeclibdir LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -5417,7 +5417,9 @@ x86_64-*-linux* | x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu) TARGET=X86_64; TAR\n sh-*-linux* | sh[34]*-*-linux*) TARGET=SH; TARGETDIR=sh;;\n sh-*-rtems*) TARGET=SH; TARGETDIR=sh;;\n sh64-*-linux* | sh5*-*-linux*) TARGET=SH64; TARGETDIR=sh64;;\n-hppa-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;\n+hppa*-*-linux* | parisc*-*-linux*) TARGET=PA_LINUX; TARGETDIR=pa;;\n+hppa*64-*-hpux*) TARGET=PA64_HPUX; TARGETDIR=pa;;\n+hppa*-*-hpux*) TARGET=PA_HPUX; TARGETDIR=pa;;\n esac\n \n \n@@ -5630,12 +5632,32 @@ fi\n \n \n \n-if test x$TARGET = xPA; then\n-  PA_TRUE=\n-  PA_FALSE='#'\n+if test x$TARGET = xPA_LINUX; then\n+  PA_LINUX_TRUE=\n+  PA_LINUX_FALSE='#'\n else\n-  PA_TRUE='#'\n-  PA_FALSE=\n+  PA_LINUX_TRUE='#'\n+  PA_LINUX_FALSE=\n+fi\n+\n+\n+\n+if test x$TARGET = xPA_HPUX; then\n+  PA_HPUX_TRUE=\n+  PA_HPUX_FALSE='#'\n+else\n+  PA_HPUX_TRUE='#'\n+  PA_HPUX_FALSE=\n+fi\n+\n+\n+\n+if test x$TARGET = xPA64_HPUX; then\n+  PA64_HPUX_TRUE=\n+  PA64_HPUX_FALSE='#'\n+else\n+  PA64_HPUX_TRUE='#'\n+  PA64_HPUX_FALSE=\n fi\n \n \n@@ -7901,10 +7923,24 @@ echo \"$as_me: error: conditional \\\"SH64\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" >&2;}\n    { (exit 1); exit 1; }; }\n fi\n-if test -z \"${PA_TRUE}\" && test -z \"${PA_FALSE}\"; then\n-  { { echo \"$as_me:$LINENO: error: conditional \\\"PA\\\" was never defined.\n+if test -z \"${PA_LINUX_TRUE}\" && test -z \"${PA_LINUX_FALSE}\"; then\n+  { { echo \"$as_me:$LINENO: error: conditional \\\"PA_LINUX\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&5\n+echo \"$as_me: error: conditional \\\"PA_LINUX\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+if test -z \"${PA_HPUX_TRUE}\" && test -z \"${PA_HPUX_FALSE}\"; then\n+  { { echo \"$as_me:$LINENO: error: conditional \\\"PA_HPUX\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&5\n+echo \"$as_me: error: conditional \\\"PA_HPUX\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+if test -z \"${PA64_HPUX_TRUE}\" && test -z \"${PA64_HPUX_FALSE}\"; then\n+  { { echo \"$as_me:$LINENO: error: conditional \\\"PA64_HPUX\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" >&5\n-echo \"$as_me: error: conditional \\\"PA\\\" was never defined.\n+echo \"$as_me: error: conditional \\\"PA64_HPUX\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" >&2;}\n    { (exit 1); exit 1; }; }\n fi\n@@ -8567,8 +8603,12 @@ s,@SH_TRUE@,$SH_TRUE,;t t\n s,@SH_FALSE@,$SH_FALSE,;t t\n s,@SH64_TRUE@,$SH64_TRUE,;t t\n s,@SH64_FALSE@,$SH64_FALSE,;t t\n-s,@PA_TRUE@,$PA_TRUE,;t t\n-s,@PA_FALSE@,$PA_FALSE,;t t\n+s,@PA_LINUX_TRUE@,$PA_LINUX_TRUE,;t t\n+s,@PA_LINUX_FALSE@,$PA_LINUX_FALSE,;t t\n+s,@PA_HPUX_TRUE@,$PA_HPUX_TRUE,;t t\n+s,@PA_HPUX_FALSE@,$PA_HPUX_FALSE,;t t\n+s,@PA64_HPUX_TRUE@,$PA64_HPUX_TRUE,;t t\n+s,@PA64_HPUX_FALSE@,$PA64_HPUX_FALSE,;t t\n s,@ALLOCA@,$ALLOCA,;t t\n s,@HAVE_LONG_DOUBLE@,$HAVE_LONG_DOUBLE,;t t\n s,@TARGET@,$TARGET,;t t"}, {"sha": "e80c262dc3294465136beeba200dafcb374bb87a", "filename": "libffi/configure.ac", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -82,7 +82,9 @@ x86_64-*-linux* | x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu) TARGET=X86_64; TAR\n sh-*-linux* | sh[[34]]*-*-linux*) TARGET=SH; TARGETDIR=sh;;\n sh-*-rtems*) TARGET=SH; TARGETDIR=sh;;\n sh64-*-linux* | sh5*-*-linux*) TARGET=SH64; TARGETDIR=sh64;;\n-hppa-*-linux* | parisc-*-linux*) TARGET=PA; TARGETDIR=pa;;\n+hppa*-*-linux* | parisc*-*-linux*) TARGET=PA_LINUX; TARGETDIR=pa;;\n+hppa*64-*-hpux*) TARGET=PA64_HPUX; TARGETDIR=pa;;\n+hppa*-*-hpux*) TARGET=PA_HPUX; TARGETDIR=pa;;\n esac\n \n AC_SUBST(AM_RUNTESTFLAGS)\n@@ -111,7 +113,9 @@ AM_CONDITIONAL(S390, test x$TARGET = xS390)\n AM_CONDITIONAL(X86_64, test x$TARGET = xX86_64)\n AM_CONDITIONAL(SH, test x$TARGET = xSH)\n AM_CONDITIONAL(SH64, test x$TARGET = xSH64)\n-AM_CONDITIONAL(PA, test x$TARGET = xPA)\n+AM_CONDITIONAL(PA_LINUX, test x$TARGET = xPA_LINUX)\n+AM_CONDITIONAL(PA_HPUX, test x$TARGET = xPA_HPUX)\n+AM_CONDITIONAL(PA64_HPUX, test x$TARGET = xPA64_HPUX)\n \n case x$TARGET in\n   xMIPS*) TARGET=MIPS ;;"}, {"sha": "360f184f12983f37cba0c0926ffba7cb43944001", "filename": "libffi/include/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -123,15 +123,19 @@ MIPS_IRIX_TRUE = @MIPS_IRIX_TRUE@\n MIPS_LINUX_FALSE = @MIPS_LINUX_FALSE@\n MIPS_LINUX_TRUE = @MIPS_LINUX_TRUE@\n OBJEXT = @OBJEXT@\n+PA64_HPUX_FALSE = @PA64_HPUX_FALSE@\n+PA64_HPUX_TRUE = @PA64_HPUX_TRUE@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n PACKAGE_NAME = @PACKAGE_NAME@\n PACKAGE_STRING = @PACKAGE_STRING@\n PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n-PA_FALSE = @PA_FALSE@\n-PA_TRUE = @PA_TRUE@\n+PA_HPUX_FALSE = @PA_HPUX_FALSE@\n+PA_HPUX_TRUE = @PA_HPUX_TRUE@\n+PA_LINUX_FALSE = @PA_LINUX_FALSE@\n+PA_LINUX_TRUE = @PA_LINUX_TRUE@\n POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@\n POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@\n POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@"}, {"sha": "65f958ff2c1b15575eb7e830aba48ce9106b194a", "filename": "libffi/src/pa/ffi.c", "status": "modified", "additions": 226, "deletions": 130, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -2,6 +2,7 @@\n    ffi.c - (c) 2003-2004 Randolph Chung <tausq@debian.org>\n \n    HPPA Foreign Function Interface\n+   HP-UX PA ABI support (c) 2006 Free Software Foundation, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -30,15 +31,19 @@\n #include <stdio.h>\n \n #define ROUND_UP(v, a)  (((size_t)(v) + (a) - 1) & ~((a) - 1))\n-#define ROUND_DOWN(v, a)  (((size_t)(v) - (a) + 1) & ~((a) - 1))\n+\n #define MIN_STACK_SIZE  64\n #define FIRST_ARG_SLOT  9\n #define DEBUG_LEVEL   0\n \n-#define fldw(addr, fpreg) asm volatile (\"fldw 0(%0), %%\" #fpreg \"L\" : : \"r\"(addr) : #fpreg)\n-#define fstw(fpreg, addr) asm volatile (\"fstw %%\" #fpreg \"L, 0(%0)\" : : \"r\"(addr))\n-#define fldd(addr, fpreg) asm volatile (\"fldd 0(%0), %%\" #fpreg : : \"r\"(addr) : #fpreg)\n-#define fstd(fpreg, addr) asm volatile (\"fstd %%\" #fpreg \"L, 0(%0)\" : : \"r\"(addr))\n+#define fldw(addr, fpreg) \\\n+  __asm__ volatile (\"fldw 0(%0), %%\" #fpreg \"L\" : : \"r\"(addr) : #fpreg)\n+#define fstw(fpreg, addr) \\\n+  __asm__ volatile (\"fstw %%\" #fpreg \"L, 0(%0)\" : : \"r\"(addr))\n+#define fldd(addr, fpreg) \\\n+  __asm__ volatile (\"fldd 0(%0), %%\" #fpreg : : \"r\"(addr) : #fpreg)\n+#define fstd(fpreg, addr) \\\n+  __asm__ volatile (\"fstd %%\" #fpreg \"L, 0(%0)\" : : \"r\"(addr))\n \n #define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)\n \n@@ -47,78 +52,102 @@ static inline int ffi_struct_type(ffi_type *t)\n   size_t sz = t->size;\n \n   /* Small structure results are passed in registers,\n-     larger ones are passed by pointer.  */\n+     larger ones are passed by pointer.  Note that\n+     small structures of size 2, 4 and 8 differ from\n+     the corresponding integer types in that they have\n+     different alignment requirements.  */\n \n   if (sz <= 1)\n     return FFI_TYPE_UINT8;\n   else if (sz == 2)\n-    return FFI_TYPE_UINT16;\n+    return FFI_TYPE_SMALL_STRUCT2;\n   else if (sz == 3)\n     return FFI_TYPE_SMALL_STRUCT3;\n   else if (sz == 4)\n-    return FFI_TYPE_UINT32;\n+    return FFI_TYPE_SMALL_STRUCT4;\n   else if (sz == 5)\n     return FFI_TYPE_SMALL_STRUCT5;\n   else if (sz == 6)\n     return FFI_TYPE_SMALL_STRUCT6;\n   else if (sz == 7)\n     return FFI_TYPE_SMALL_STRUCT7;\n   else if (sz <= 8)\n-    return FFI_TYPE_UINT64;\n+    return FFI_TYPE_SMALL_STRUCT8;\n   else\n     return FFI_TYPE_STRUCT; /* else, we pass it by pointer.  */\n }\n \n /* PA has a downward growing stack, which looks like this:\n-  \n+\n    Offset\n-        [ Variable args ]\n+\t[ Variable args ]\n    SP = (4*(n+9))       arg word N\n    ...\n    SP-52                arg word 4\n-        [ Fixed args ]\n+\t[ Fixed args ]\n    SP-48                arg word 3\n    SP-44                arg word 2\n    SP-40                arg word 1\n    SP-36                arg word 0\n-        [ Frame marker ]\n+\t[ Frame marker ]\n    ...\n    SP-20                RP\n    SP-4                 previous SP\n-  \n-   First 4 non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23\n-   First 2 non-FP 64-bit args are passed in register pairs, starting\n-     on an even numbered register (i.e. r26/r25 and r24+r23)\n-   First 4 FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L\n-   First 2 FP 64-bit arguments are passed in fr5 and fr7\n-   The rest are passed on the stack starting at SP-52, but 64-bit\n-     arguments need to be aligned to an 8-byte boundary\n-  \n+\n+   The first four argument words on the stack are reserved for use by\n+   the callee.  Instead, the general and floating registers replace\n+   the first four argument slots.  Non FP arguments are passed solely\n+   in the general registers.  FP arguments are passed in both general\n+   and floating registers when using libffi.\n+\n+   Non-FP 32-bit args are passed in gr26, gr25, gr24 and gr23.\n+   Non-FP 64-bit args are passed in register pairs, starting\n+   on an odd numbered register (i.e. r25+r26 and r23+r24).\n+   FP 32-bit arguments are passed in fr4L, fr5L, fr6L and fr7L.\n+   FP 64-bit arguments are passed in fr5 and fr7.\n+\n+   The registers are allocated in the same manner as stack slots.\n+   This allows the callee to save its arguments on the stack if\n+   necessary:\n+\n+   arg word 3 -> gr23 or fr7L\n+   arg word 2 -> gr24 or fr6L or fr7R\n+   arg word 1 -> gr25 or fr5L\n+   arg word 0 -> gr26 or fr4L or fr5R\n+\n+   Note that fr4R and fr6R are never used for arguments (i.e.,\n+   doubles are not passed in fr4 or fr6).\n+\n+   The rest of the arguments are passed on the stack starting at SP-52,\n+   but 64-bit arguments need to be aligned to an 8-byte boundary\n+\n    This means we can have holes either in the register allocation,\n    or in the stack.  */\n \n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments\n-  \n+\n    The following code will put everything into the stack frame\n    (which was allocated by the asm routine), and on return\n    the asm routine will load the arguments that should be\n    passed by register into the appropriate registers\n-  \n+\n    NOTE: We load floating point args in this function... that means we\n    assume gcc will not mess with fp regs in here.  */\n \n /*@-exportheader@*/\n-void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n+void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n /*@=exportheader@*/\n {\n   register unsigned int i;\n   register ffi_type **p_arg;\n   register void **p_argv;\n-  unsigned int slot = FIRST_ARG_SLOT - 1;\n+  unsigned int slot = FIRST_ARG_SLOT;\n   char *dest_cpy;\n+  size_t len;\n \n-  debug(1, \"%s: stack = %p, ecif = %p, bytes = %u\\n\", __FUNCTION__, stack, ecif, bytes);\n+  debug(1, \"%s: stack = %p, ecif = %p, bytes = %u\\n\", __FUNCTION__, stack,\n+\tecif, bytes);\n \n   p_arg = ecif->cif->arg_types;\n   p_argv = ecif->avalue;\n@@ -130,116 +159,105 @@ void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n       switch (type)\n \t{\n \tcase FFI_TYPE_SINT8:\n-\t  slot++;\n \t  *(SINT32 *)(stack - slot) = *(SINT8 *)(*p_argv);\n \t  break;\n \n \tcase FFI_TYPE_UINT8:\n-\t  slot++;\n \t  *(UINT32 *)(stack - slot) = *(UINT8 *)(*p_argv);\n \t  break;\n \n \tcase FFI_TYPE_SINT16:\n-\t  slot++;\n \t  *(SINT32 *)(stack - slot) = *(SINT16 *)(*p_argv);\n \t  break;\n \n \tcase FFI_TYPE_UINT16:\n-\t  slot++;\n \t  *(UINT32 *)(stack - slot) = *(UINT16 *)(*p_argv);\n \t  break;\n \n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_POINTER:\n-\t  slot++;\n-\t  debug(3, \"Storing UINT32 %u in slot %u\\n\", *(UINT32 *)(*p_argv), slot);\n+\t  debug(3, \"Storing UINT32 %u in slot %u\\n\", *(UINT32 *)(*p_argv),\n+\t\tslot);\n \t  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);\n \t  break;\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-\t  slot += 2;\n-\t  if (slot & 1)\n-\t    slot++;\n-\n-\t  *(UINT32 *)(stack - slot) = (*(UINT64 *)(*p_argv)) >> 32;\n-\t  *(UINT32 *)(stack - slot + 1) = (*(UINT64 *)(*p_argv)) & 0xffffffffUL;\n+\t  /* Align slot for 64-bit type.  */\n+\t  slot += (slot & 1) ? 1 : 2;\n+\t  *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t  /* First 4 args go in fr4L - fr7L */\n-\t  slot++;\n+\t  /* First 4 args go in fr4L - fr7L.  */\n+\t  debug(3, \"Storing UINT32(float) in slot %u\\n\", slot);\n+\t  *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);\n \t  switch (slot - FIRST_ARG_SLOT)\n \t    {\n+\t    /* First 4 args go in fr4L - fr7L.  */\n \t    case 0: fldw(*p_argv, fr4); break;\n \t    case 1: fldw(*p_argv, fr5); break;\n \t    case 2: fldw(*p_argv, fr6); break;\n \t    case 3: fldw(*p_argv, fr7); break;\n-\t    default:\n-\t      /* Other ones are just passed on the stack.  */\n-\t      debug(3, \"Storing UINT32(float) in slot %u\\n\", slot);\n-\t      *(UINT32 *)(stack - slot) = *(UINT32 *)(*p_argv);\n-\t      break;\n \t    }\n-\t    break;\n+\t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  slot += 2;\n-\t  if (slot & 1)\n-\t    slot++;\n-\t  switch (slot - FIRST_ARG_SLOT + 1)\n+\t  /* Align slot for 64-bit type.  */\n+\t  slot += (slot & 1) ? 1 : 2;\n+\t  debug(3, \"Storing UINT64(double) at slot %u\\n\", slot);\n+\t  *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);\n+\t  switch (slot - FIRST_ARG_SLOT)\n \t    {\n-\t      /* First 2 args go in fr5, fr7 */\n-\t      case 2: fldd(*p_argv, fr5); break;\n-\t      case 4: fldd(*p_argv, fr7); break;\n-\t      default:\n-\t        debug(3, \"Storing UINT64(double) at slot %u\\n\", slot);\n-\t        *(UINT64 *)(stack - slot) = *(UINT64 *)(*p_argv);\n-\t        break;\n+\t      /* First 2 args go in fr5, fr7.  */\n+\t      case 1: fldd(*p_argv, fr5); break;\n+\t      case 3: fldd(*p_argv, fr7); break;\n \t    }\n \t  break;\n \n+#ifdef PA_HPUX\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  /* Long doubles are passed in the same manner as structures\n+\t     larger than 8 bytes.  */\n+\t  *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);\n+\t  break;\n+#endif\n+\n \tcase FFI_TYPE_STRUCT:\n \n \t  /* Structs smaller or equal than 4 bytes are passed in one\n \t     register. Structs smaller or equal 8 bytes are passed in two\n \t     registers. Larger structures are passed by pointer.  */\n \n-\t  if((*p_arg)->size <= 4) \n+\t  len = (*p_arg)->size;\n+\t  if (len <= 4)\n \t    {\n-\t      slot++;\n-\t      dest_cpy = (char *)(stack - slot);\n-\t      dest_cpy += 4 - (*p_arg)->size;\n-\t      memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);\n+\t      dest_cpy = (char *)(stack - slot) + 4 - len;\n+\t      memcpy(dest_cpy, (char *)*p_argv, len);\n \t    }\n-\t  else if ((*p_arg)->size <= 8) \n+\t  else if (len <= 8)\n \t    {\n-\t      slot += 2;\n-\t      if (slot & 1)\n-\t        slot++;\n-\t      dest_cpy = (char *)(stack - slot);\n-\t      dest_cpy += 8 - (*p_arg)->size;\n-\t      memcpy((char *)dest_cpy, (char *)*p_argv, (*p_arg)->size);\n-\t    } \n-\t  else \n-\t    {\n-\t      slot++;\n-\t      *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);\n+\t      slot += (slot & 1) ? 1 : 2;\n+\t      dest_cpy = (char *)(stack - slot) + 8 - len;\n+\t      memcpy(dest_cpy, (char *)*p_argv, len);\n \t    }\n+\t  else\n+\t    *(UINT32 *)(stack - slot) = (UINT32)(*p_argv);\n \t  break;\n \n \tdefault:\n \t  FFI_ASSERT(0);\n \t}\n \n+      slot++;\n       p_arg++;\n       p_argv++;\n     }\n \n   /* Make sure we didn't mess up and scribble on the stack.  */\n   {\n-    int n;\n+    unsigned int n;\n \n     debug(5, \"Stack setup:\\n\");\n     for (n = 0; n < (bytes + 3) / 4; n++)\n@@ -255,7 +273,7 @@ void ffi_prep_args_LINUX(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n   return;\n }\n \n-static void ffi_size_stack_LINUX(ffi_cif *cif)\n+static void ffi_size_stack_pa32(ffi_cif *cif)\n {\n   ffi_type **ptr;\n   int i;\n@@ -273,6 +291,9 @@ static void ffi_size_stack_LINUX(ffi_cif *cif)\n \t  z += 2 + (z & 1); /* must start on even regs, so we may waste one */\n \t  break;\n \n+#ifdef PA_HPUX\n+\tcase FFI_TYPE_LONGDOUBLE:\n+#endif\n \tcase FFI_TYPE_STRUCT:\n \t  z += 1; /* pass by ptr, callee will copy */\n \t  break;\n@@ -304,6 +325,13 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       cif->flags = (unsigned) cif->rtype->type;\n       break;\n \n+#ifdef PA_HPUX\n+    case FFI_TYPE_LONGDOUBLE:\n+      /* Long doubles are treated like a structure.  */\n+      cif->flags = FFI_TYPE_STRUCT;\n+      break;\n+#endif\n+\n     case FFI_TYPE_STRUCT:\n       /* For the return type we have to check the size of the structures.\n \t If the size is smaller or equal 4 bytes, the result is given back\n@@ -327,8 +355,8 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n      own stack sizing.  */\n   switch (cif->abi)\n     {\n-    case FFI_LINUX:\n-      ffi_size_stack_LINUX(cif);\n+    case FFI_PA32:\n+      ffi_size_stack_pa32(cif);\n       break;\n \n     default:\n@@ -341,7 +369,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n /*@-declundef@*/\n /*@-exportheader@*/\n-extern void ffi_call_LINUX(void (*)(UINT32 *, extended_cif *, unsigned),\n+extern void ffi_call_pa32(void (*)(UINT32 *, extended_cif *, unsigned),\n \t\t\t   /*@out@*/ extended_cif *,\n \t\t\t   unsigned, unsigned,\n \t\t\t   /*@out@*/ unsigned *,\n@@ -362,8 +390,13 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   /* If the return value is a struct and we don't have a return\n      value address then we need to make one.  */\n \n-  if ((rvalue == NULL) &&\n-      (cif->rtype->type == FFI_TYPE_STRUCT))\n+  if (rvalue == NULL\n+#ifdef PA_HPUX\n+      && (cif->rtype->type == FFI_TYPE_STRUCT\n+\t  || cif->rtype->type == FFI_TYPE_LONGDOUBLE))\n+#else\n+      && cif->rtype->type == FFI_TYPE_STRUCT)\n+#endif\n     {\n       /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n@@ -375,10 +408,10 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \n   switch (cif->abi)\n     {\n-    case FFI_LINUX:\n+    case FFI_PA32:\n       /*@-usedef@*/\n-      debug(2, \"Calling ffi_call_LINUX: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\\n\", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);\n-      ffi_call_LINUX(ffi_prep_args_LINUX, &ecif, cif->bytes,\n+      debug(3, \"Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\\n\", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);\n+      ffi_call_pa32(ffi_prep_args_pa32, &ecif, cif->bytes,\n \t\t     cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n@@ -394,15 +427,16 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n    the stack, and we need to fill them into a cif structure and invoke\n    the user function. This really ought to be in asm to make sure\n    the compiler doesn't do things we don't expect.  */\n-UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)\n+ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n {\n   ffi_cif *cif;\n   void **avalue;\n   void *rvalue;\n   UINT32 ret[2]; /* function can return up to 64-bits in registers */\n   ffi_type **p_arg;\n   char *tmp;\n-  int i, avn, slot = FIRST_ARG_SLOT - 1;\n+  int i, avn;\n+  unsigned int slot = FIRST_ARG_SLOT;\n   register UINT32 r28 asm(\"r28\");\n \n   cif = closure->cif;\n@@ -430,75 +464,81 @@ UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_POINTER:\n-\t  slot++;\n \t  avalue[i] = (char *)(stack - slot) + sizeof(UINT32) - (*p_arg)->size;\n \t  break;\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n-\t  slot += 2;\n-\t  if (slot & 1)\n-\t    slot++;\n+\t  slot += (slot & 1) ? 1 : 2;\n \t  avalue[i] = (void *)(stack - slot);\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t  slot++;\n+#ifdef PA_LINUX\n+\t  /* The closure call is indirect.  In Linux, floating point\n+\t     arguments in indirect calls with a prototype are passed\n+\t     in the floating point registers instead of the general\n+\t     registers.  So, we need to replace what was previously\n+\t     stored in the current slot with the value in the\n+\t     corresponding floating point register.  */\n \t  switch (slot - FIRST_ARG_SLOT)\n \t    {\n \t    case 0: fstw(fr4, (void *)(stack - slot)); break;\n \t    case 1: fstw(fr5, (void *)(stack - slot)); break;\n \t    case 2: fstw(fr6, (void *)(stack - slot)); break;\n \t    case 3: fstw(fr7, (void *)(stack - slot)); break;\n \t    }\n+#endif\n \t  avalue[i] = (void *)(stack - slot);\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  slot += 2;\n-\t  if (slot & 1)\n-\t    slot++;\n-\t  switch (slot - FIRST_ARG_SLOT + 1)\n+\t  slot += (slot & 1) ? 1 : 2;\n+#ifdef PA_LINUX\n+\t  /* See previous comment for FFI_TYPE_FLOAT.  */\n+\t  switch (slot - FIRST_ARG_SLOT)\n \t    {\n-\t    case 2: fstd(fr5, (void *)(stack - slot)); break;\n-\t    case 4: fstd(fr7, (void *)(stack - slot)); break;\n+\t    case 1: fstd(fr5, (void *)(stack - slot)); break;\n+\t    case 3: fstd(fr7, (void *)(stack - slot)); break;\n \t    }\n+#endif\n \t  avalue[i] = (void *)(stack - slot);\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n \t  /* Structs smaller or equal than 4 bytes are passed in one\n \t     register. Structs smaller or equal 8 bytes are passed in two\n \t     registers. Larger structures are passed by pointer.  */\n-\t  if((*p_arg)->size <= 4) {\n-\t    slot++;\n-\t    avalue[i] = (void *)(stack - slot) + sizeof(UINT32) -\n-\t      (*p_arg)->size;\n-\t  } else if ((*p_arg)->size <= 8) {\n-\t    slot += 2;\n-\t    if (slot & 1)\n-\t      slot++;\n-\t    avalue[i] = (void *)(stack - slot) + sizeof(UINT64) -\n-\t      (*p_arg)->size;\n-\t  } else {\n-\t    slot++;\n+\t  if((*p_arg)->size <= 4)\n+\t    {\n+\t      avalue[i] = (void *)(stack - slot) + sizeof(UINT32) -\n+\t\t(*p_arg)->size;\n+\t    }\n+\t  else if ((*p_arg)->size <= 8)\n+\t    {\n+\t      slot += (slot & 1) ? 1 : 2;\n+\t      avalue[i] = (void *)(stack - slot) + sizeof(UINT64) -\n+\t\t(*p_arg)->size;\n+\t    }\n+\t  else\n \t    avalue[i] = (void *) *(stack - slot);\n-\t  }\n \t  break;\n \n \tdefault:\n \t  FFI_ASSERT(0);\n \t}\n \n+      slot++;\n       p_arg++;\n     }\n \n   /* Invoke the closure.  */\n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n-  debug(3, \"after calling function, ret[0] = %08x, ret[1] = %08x\\n\", ret[0], ret[1]);\n+  debug(3, \"after calling function, ret[0] = %08x, ret[1] = %08x\\n\", ret[0],\n+\tret[1]);\n \n-  /* Store the result */\n+  /* Store the result using the lower 2 bytes of the flags.  */\n   switch (cif->flags)\n     {\n     case FFI_TYPE_UINT8:\n@@ -536,7 +576,9 @@ UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)\n       /* Don't need a return value, done by caller.  */\n       break;\n \n+    case FFI_TYPE_SMALL_STRUCT2:\n     case FFI_TYPE_SMALL_STRUCT3:\n+    case FFI_TYPE_SMALL_STRUCT4:\n       tmp = (void*)(stack -  FIRST_ARG_SLOT);\n       tmp += 4 - cif->rtype->size;\n       memcpy((void*)tmp, &ret[0], cif->rtype->size);\n@@ -545,6 +587,7 @@ UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)\n     case FFI_TYPE_SMALL_STRUCT5:\n     case FFI_TYPE_SMALL_STRUCT6:\n     case FFI_TYPE_SMALL_STRUCT7:\n+    case FFI_TYPE_SMALL_STRUCT8:\n       {\n \tunsigned int ret2[2];\n \tint off;\n@@ -582,7 +625,7 @@ UINT32 ffi_closure_inner_LINUX(ffi_closure *closure, UINT32 *stack)\n    cif specifies the argument and result types for fun.\n    The cif must already be prep'ed.  */\n \n-void ffi_closure_LINUX(void);\n+extern void ffi_closure_pa32(void);\n \n ffi_status\n ffi_prep_closure (ffi_closure* closure,\n@@ -591,30 +634,83 @@ ffi_prep_closure (ffi_closure* closure,\n \t\t  void *user_data)\n {\n   UINT32 *tramp = (UINT32 *)(closure->tramp);\n+#ifdef PA_HPUX\n+  UINT32 *tmp;\n+#endif\n \n-  FFI_ASSERT (cif->abi == FFI_LINUX);\n+  FFI_ASSERT (cif->abi == FFI_PA32);\n \n   /* Make a small trampoline that will branch to our\n      handler function. Use PC-relative addressing.  */\n \n-  tramp[0] = 0xeaa00000; /* b,l  .+8, %r21      ; %r21 <- pc+8 */\n-  tramp[1] = 0xd6a01c1e; /* depi 0,31,2, %r21   ; mask priv bits */\n-  tramp[2] = 0x4aa10028; /* ldw  20(%r21), %r1  ; load plabel */\n-  tramp[3] = 0x36b53ff1; /* ldo  -8(%r21), %r21 ; get closure addr */\n-  tramp[4] = 0x0c201096; /* ldw  0(%r1), %r22   ; address of handler */\n-  tramp[5] = 0xeac0c000; /* bv\t %r0(%r22)      ; branch to handler */\n-  tramp[6] = 0x0c281093; /* ldw  4(%r1), %r19   ; GP of handler */\n-  tramp[7] = ((UINT32)(ffi_closure_LINUX) & ~2);\n+#ifdef PA_LINUX\n+  tramp[0] = 0xeaa00000; /* b,l .+8,%r21        ; %r21 <- pc+8 */\n+  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21    ; mask priv bits */\n+  tramp[2] = 0x4aa10028; /* ldw 20(%r21),%r1    ; load plabel */\n+  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21   ; get closure addr */\n+  tramp[4] = 0x0c201096; /* ldw 0(%r1),%r22     ; address of handler */\n+  tramp[5] = 0xeac0c000; /* bv%r0(%r22)         ; branch to handler */\n+  tramp[6] = 0x0c281093; /* ldw 4(%r1),%r19     ; GP of handler */\n+  tramp[7] = ((UINT32)(ffi_closure_pa32) & ~2);\n \n   /* Flush d/icache -- have to flush up 2 two lines because of\n      alignment.  */\n-  asm volatile (\n-\t\t\"fdc 0(%0)\\n\"\n-\t\t\"fdc %1(%0)\\n\"\n-\t\t\"fic 0(%%sr4, %0)\\n\"\n-\t\t\"fic %1(%%sr4, %0)\\n\"\n-\t\t\"sync\\n\"\n-\t\t: : \"r\"((unsigned long)tramp & ~31), \"r\"(32 /* stride */));\n+  __asm__ volatile(\n+\t\t   \"fdc 0(%0)\\n\\t\"\n+\t\t   \"fdc %1(%0)\\n\\t\"\n+\t\t   \"fic 0(%%sr4, %0)\\n\\t\"\n+\t\t   \"fic %1(%%sr4, %0)\\n\\t\"\n+\t\t   \"sync\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\"\n+\t\t   :\n+\t\t   : \"r\"((unsigned long)tramp & ~31),\n+\t\t     \"r\"(32 /* stride */)\n+\t\t   : \"memory\");\n+#endif\n+\n+#ifdef PA_HPUX\n+  tramp[0] = 0xeaa00000; /* b,l .+8,%r21        ; %r21 <- pc+8  */\n+  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21    ; mask priv bits  */\n+  tramp[2] = 0x4aa10038; /* ldw 28(%r21),%r1    ; load plabel  */\n+  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21   ; get closure addr  */\n+  tramp[4] = 0x0c201096; /* ldw 0(%r1),%r22     ; address of handler  */\n+  tramp[5] = 0x02c010b4; /* ldsid (%r22),%r20   ; load space id  */\n+  tramp[6] = 0x00141820; /* mtsp %r20,%sr0      ; into %sr0  */\n+  tramp[7] = 0xe2c00000; /* be 0(%sr0,%r22)     ; branch to handler  */\n+  tramp[8] = 0x0c281093; /* ldw 4(%r1),%r19     ; GP of handler  */\n+  tramp[9] = ((UINT32)(ffi_closure_pa32) & ~2);\n+\n+  /* Flush d/icache -- have to flush three lines because of alignment.  */\n+  __asm__ volatile(\n+\t\t   \"copy %1,%0\\n\\t\"\n+\t\t   \"fdc,m %2(%0)\\n\\t\"\n+\t\t   \"fdc,m %2(%0)\\n\\t\"\n+\t\t   \"fdc,m %2(%0)\\n\\t\"\n+\t\t   \"ldsid (%1),%0\\n\\t\"\n+\t\t   \"mtsp %0,%%sr0\\n\\t\"\n+\t\t   \"copy %1,%0\\n\\t\"\n+\t\t   \"fic,m %2(%%sr0,%0)\\n\\t\"\n+\t\t   \"fic,m %2(%%sr0,%0)\\n\\t\"\n+\t\t   \"fic,m %2(%%sr0,%0)\\n\\t\"\n+\t\t   \"sync\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\\t\"\n+\t\t   \"nop\\n\"\n+\t\t   : \"=&r\" ((unsigned long)tmp)\n+\t\t   : \"r\" ((unsigned long)tramp & ~31),\n+\t\t     \"r\" (32/* stride */)\n+\t\t   : \"memory\");\n+#endif\n \n   closure->cif  = cif;\n   closure->user_data = user_data;"}, {"sha": "95ac48060c6365dbedc4179ef658f092e50bb13a", "filename": "libffi/src/pa/ffitarget.h", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffitarget.h?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -35,9 +35,20 @@ typedef signed long            ffi_sarg;\n typedef enum ffi_abi {\n   FFI_FIRST_ABI = 0,\n \n-#ifdef PA\n-  FFI_LINUX,\n-  FFI_DEFAULT_ABI = FFI_LINUX,\n+#ifdef PA_LINUX\n+  FFI_PA32,\n+  FFI_DEFAULT_ABI = FFI_PA32,\n+#endif\n+\n+#ifdef PA_HPUX\n+  FFI_PA32,\n+  FFI_DEFAULT_ABI = FFI_PA32,\n+#endif\n+\n+#ifdef PA64_HPUX\n+#error \"PA64_HPUX FFI is not yet implemented\"\n+  FFI_PA64,\n+  FFI_DEFAULT_ABI = FFI_PA64,\n #endif\n \n   FFI_LAST_ABI = FFI_DEFAULT_ABI + 1\n@@ -49,11 +60,17 @@ typedef enum ffi_abi {\n #define FFI_CLOSURES 1\n #define FFI_NATIVE_RAW_API 0\n \n+#ifdef PA_LINUX\n #define FFI_TRAMPOLINE_SIZE 32\n-\n-#define FFI_TYPE_SMALL_STRUCT3 -1\n-#define FFI_TYPE_SMALL_STRUCT5 -2\n-#define FFI_TYPE_SMALL_STRUCT6 -3\n-#define FFI_TYPE_SMALL_STRUCT7 -4\n+#else\n+#define FFI_TRAMPOLINE_SIZE 40\n #endif\n \n+#define FFI_TYPE_SMALL_STRUCT2 -1\n+#define FFI_TYPE_SMALL_STRUCT3 -2\n+#define FFI_TYPE_SMALL_STRUCT4 -3\n+#define FFI_TYPE_SMALL_STRUCT5 -4\n+#define FFI_TYPE_SMALL_STRUCT6 -5\n+#define FFI_TYPE_SMALL_STRUCT7 -6\n+#define FFI_TYPE_SMALL_STRUCT8 -7\n+#endif"}, {"sha": "4c4470fbf9b73cb818dabf0c68e3f9ffc6d03d23", "filename": "libffi/src/pa/hpux32.S", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Fhpux32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Fhpux32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fhpux32.S?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -0,0 +1,367 @@\n+/* -----------------------------------------------------------------------\n+   hpux32.S - Copyright (c) 2006 Free Software Foundation, Inc.\n+   based on src/pa/linux.S\n+\n+   HP-UX PA Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+\t.LEVEL 1.1\n+\t.SPACE\t$PRIVATE$\n+\t.IMPORT\t$global$,DATA\n+\t.IMPORT\t$$dyncall,MILLICODE\n+\t.SUBSPA\t$DATA$\n+\t.align\t4\n+\n+\t/* void ffi_call_pa32(void (*)(char *, extended_cif *),\n+\t\t\t       extended_cif *ecif,\n+\t\t\t       unsigned bytes,\n+\t\t\t       unsigned flags,\n+\t\t\t       unsigned *rvalue,\n+\t\t\t       void (*fn)());\n+\t */\n+\n+\t.export\tffi_call_pa32,ENTRY,PRIV_LEV=3\n+\t.import\tffi_prep_args_pa32,CODE\n+\n+\t.SPACE\t$TEXT$\n+\t.SUBSPA $CODE$\n+\t.align\t4\n+\n+L$FB1\n+ffi_call_pa32\n+\t.proc\n+\t.callinfo\tFRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4\n+\t.entry\n+\tstw\t%rp, -20(%sp)\n+\tcopy\t%r3, %r1\n+L$CFI11\n+\tcopy\t%sp, %r3\n+L$CFI12\n+\n+\t/* Setup the stack for calling prep_args...\n+\t   We want the stack to look like this:\n+\n+\t   [ Previous stack                            ] <- %r3\n+\n+\t   [ 64-bytes register save area               ] <- %r4\n+\n+\t   [ Stack space for actual call, passed as    ] <- %arg0\n+\t   [     arg0 to ffi_prep_args_pa32           ]\n+\n+\t   [ Stack for calling prep_args               ] <- %sp\n+\t */\n+\n+\tstwm\t%r1, 64(%sp)\n+\tstw\t%r4, 12(%r3)\n+L$CFI13\n+\tcopy\t%sp, %r4\n+\n+\taddl\t%arg2, %r4, %arg0\t; arg stack\n+\tstw\t%arg3, -48(%r3)\t\t; save flags we need it later\n+\n+\t/* Call prep_args:\n+\t   %arg0(stack) -- set up above\n+\t   %arg1(ecif)  -- same as incoming param\n+\t   %arg2(bytes) -- same as incoming param */\n+\tbl\tffi_prep_args_pa32,%r2\n+\tldo\t64(%arg0), %sp\n+\tldo\t-64(%sp), %sp\n+\n+\t/* now %sp should point where %arg0 was pointing.  */\n+\n+\t/* Load the arguments that should be passed in registers\n+\t   The fp args are loaded by the prep_args function.  */\n+\tldw\t-36(%sp), %arg0\n+\tldw\t-40(%sp), %arg1\n+\tldw\t-44(%sp), %arg2\n+\tldw\t-48(%sp), %arg3\n+\n+\t/* in case the function is going to return a structure\n+\t   we need to give it a place to put the result.  */\n+\tldw\t-52(%r3), %ret0\t\t; %ret0 <- rvalue\n+\tldw\t-56(%r3), %r22\t\t; %r22 <- function to call\n+\tbl\t$$dyncall, %r31\t\t; Call the user function\n+\tcopy\t%r31, %rp\n+\n+\t/* Prepare to store the result; we need to recover flags and rvalue.  */\n+\tldw\t-48(%r3), %r21\t\t; r21 <- flags\n+\tldw\t-52(%r3), %r20\t\t; r20 <- rvalue\n+\n+\t/* Store the result according to the return type.  The most\n+\t   likely types should come first.  */\n+\n+L$checkint\n+\tcomib,<>,n FFI_TYPE_INT, %r21, L$checkint8\n+\tb\tL$done\n+\tstw\t%ret0, 0(%r20)\n+\n+L$checkint8\n+\tcomib,<>,n FFI_TYPE_UINT8, %r21, L$checkint16\n+\tb\tL$done\n+\tstb\t%ret0, 0(%r20)\n+\n+L$checkint16\n+\tcomib,<>,n FFI_TYPE_UINT16, %r21, L$checkdbl\n+\tb\tL$done\n+\tsth\t%ret0, 0(%r20)\n+\n+L$checkdbl\n+\tcomib,<>,n FFI_TYPE_DOUBLE, %r21, L$checkfloat\n+\tb\tL$done\n+\tfstd\t%fr4,0(%r20)\n+\n+L$checkfloat\n+\tcomib,<>,n FFI_TYPE_FLOAT, %r21, L$checkll\n+\tb\tL$done\n+\tfstw\t%fr4L,0(%r20)\n+\n+L$checkll\n+\tcomib,<>,n FFI_TYPE_UINT64, %r21, L$checksmst2\n+\tstw\t%ret0, 0(%r20)\n+\tb\tL$done\n+\tstw\t%ret1, 4(%r20)\n+\n+L$checksmst2\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT2, %r21, L$checksmst3\n+\t/* 2-byte structs are returned in ret0 as ????xxyy.  */\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\tL$done\n+\tstb\t%ret0, 0(%r20)\n+\n+L$checksmst3\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT3, %r21, L$checksmst4\n+\t/* 3-byte structs are returned in ret0 as ??xxyyzz.  */\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\tL$done\n+\tstb\t%ret0, 0(%r20)\n+\n+L$checksmst4\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT4, %r21, L$checksmst5\n+\t/* 4-byte structs are returned in ret0 as wwxxyyzz.  */\n+\textru\t%ret0, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\tL$done\n+\tstb\t%ret0, 0(%r20)\n+\n+L$checksmst5\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT5, %r21, L$checksmst6\n+\t/* 5 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   5: ??????aa bbccddee */\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\tL$done\n+\tstb\t%ret1, 0(%r20)\n+\n+L$checksmst6\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT6, %r21, L$checksmst7\n+\t/* 6 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   6: ????aabb ccddeeff */\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\tL$done\n+\tstb\t%ret1, 0(%r20)\n+\n+L$checksmst7\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT7, %r21, L$checksmst8\n+\t/* 7 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   7: ??aabbcc ddeeffgg */\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\tL$done\n+\tstb\t%ret1, 0(%r20)\n+\n+L$checksmst8\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT8, %r21, L$done\n+\t/* 8 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   8: aabbccdd eeffgghh */\n+\textru\t%ret0, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstb\t%ret1, 0(%r20)\n+\n+L$done\n+\t/* all done, return */\n+\tcopy\t%r4, %sp\t; pop arg stack\n+\tldw\t12(%r3), %r4\n+\tldwm\t-64(%sp), %r3\t; .. and pop stack\n+\tldw\t-20(%sp), %rp\n+\tbv\t%r0(%rp)\n+\tnop\n+\t.exit\n+\t.procend\n+L$FE1\n+\n+\t/* void ffi_closure_pa32(void);\n+\t   Called with closure argument in %r21 */\n+\n+\t.SPACE $TEXT$\n+\t.SUBSPA $CODE$\n+\t.export ffi_closure_pa32,ENTRY,PRIV_LEV=3,RTNVAL=GR\n+\t.import ffi_closure_inner_pa32,CODE\n+\t.align 4\n+L$FB2\n+ffi_closure_pa32\n+\t.proc\n+\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n+\t.entry\n+\n+\tstw\t%rp, -20(%sp)\n+\tcopy\t%r3, %r1\n+L$CFI21\n+\tcopy\t%sp, %r3\n+L$CFI22\n+\tstwm\t%r1, 64(%sp)\n+\n+\t/* Put arguments onto the stack and call ffi_closure_inner.  */\n+\tstw\t%arg0, -36(%r3)\n+\tstw\t%arg1, -40(%r3)\n+\tstw\t%arg2, -44(%r3)\n+\tstw\t%arg3, -48(%r3)\n+\n+\tcopy\t%r21, %arg0\n+\tbl\tffi_closure_inner_pa32, %r2\n+\tcopy    %r3, %arg1\n+\tldwm\t-64(%sp), %r3\n+\tldw\t-20(%sp), %rp\n+\tldw\t-36(%sp), %ret0\n+\tbv\t%r0(%rp)\n+\tldw\t-40(%sp), %ret1\n+\t.exit\n+\t.procend\n+L$FE2:\n+\n+\t.SPACE $PRIVATE$\n+\t.SUBSPA $DATA$\n+\n+\t.align 4\n+\t.EXPORT _GLOBAL__F_ffi_call_pa32,DATA\n+_GLOBAL__F_ffi_call_pa32\n+L$frame1:\n+\t.word   L$ECIE1-L$SCIE1 ;# Length of Common Information Entry\n+L$SCIE1:\n+\t.word   0x0     ;# CIE Identifier Tag\n+\t.byte   0x1     ;# CIE Version\n+\t.ascii \"\\0\"     ;# CIE Augmentation\n+\t.uleb128 0x1    ;# CIE Code Alignment Factor\n+\t.sleb128 4      ;# CIE Data Alignment Factor\n+\t.byte   0x2     ;# CIE RA Column\n+\t.byte   0xc     ;# DW_CFA_def_cfa\n+\t.uleb128 0x1e\n+\t.uleb128 0x0\n+\t.align 4\n+L$ECIE1:\n+L$SFDE1:\n+\t.word   L$EFDE1-L$ASFDE1        ;# FDE Length\n+L$ASFDE1:\n+\t.word   L$ASFDE1-L$frame1       ;# FDE CIE offset\n+\t.word   L$FB1   ;# FDE initial location\n+\t.word   L$FE1-L$FB1     ;# FDE address range\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI11-L$FB1\n+\t.byte\t0x83\t;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI12-L$CFI11\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI13-L$CFI12\n+\t.byte\t0x84\t;# DW_CFA_offset, column 0x4\n+\t.uleb128 0x3\n+\n+\t.align 4\n+L$EFDE1:\n+\n+L$SFDE2:\n+\t.word   L$EFDE2-L$ASFDE2        ;# FDE Length\n+L$ASFDE2:\n+\t.word   L$ASFDE2-L$frame1       ;# FDE CIE offset\n+\t.word   L$FB2   ;# FDE initial location\n+\t.word   L$FE2-L$FB2     ;# FDE address range\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI21-L$FB2\n+\t.byte   0x83    ;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   L$CFI12-L$CFI11\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n+\n+\t.align 4\n+L$EFDE2:"}, {"sha": "322ceb3e7ee8cd5c7ee49d8f7b56499f0e0adbf9", "filename": "libffi/src/pa/linux.S", "status": "modified", "additions": 147, "deletions": 98, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Flinux.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Fsrc%2Fpa%2Flinux.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Flinux.S?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -31,20 +31,20 @@\n \t.level 1.1\n \t.align 4\n \n-\t/* void ffi_call_LINUX(void (*)(char *, extended_cif *),\n+\t/* void ffi_call_pa32(void (*)(char *, extended_cif *),\n \t\t\t       extended_cif *ecif,\n \t\t\t       unsigned bytes,\n \t\t\t       unsigned flags,\n \t\t\t       unsigned *rvalue,\n \t\t\t       void (*fn)());\n \t */\n \n-\t.export ffi_call_LINUX,code\n-\t.import ffi_prep_args_LINUX,code\n+\t.export ffi_call_pa32,code\n+\t.import ffi_prep_args_pa32,code\n \n-\t.type ffi_call_LINUX, @function\n+\t.type ffi_call_pa32, @function\n .LFB1:\n-ffi_call_LINUX:\n+ffi_call_pa32:\n \t.proc\n \t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4\n \t.entry\n@@ -63,7 +63,7 @@ ffi_call_LINUX:\n \t   [ 64-bytes register save area               ] <- %r4\n \n \t   [ Stack space for actual call, passed as    ] <- %arg0\n-\t   [     arg0 to ffi_prep_args_LINUX           ]\n+\t   [     arg0 to ffi_prep_args_pa32           ]\n \n \t   [ Stack for calling prep_args               ] <- %sp\n \t */\n@@ -73,14 +73,14 @@ ffi_call_LINUX:\n .LCFI13:\n \tcopy %sp, %r4\n \n-\taddl %arg2, %r4, %arg0                  /* arg stack */\n-\tstw %arg3, -48(%r3)                     /* save flags; we need it later */\n+\taddl %arg2, %r4, %arg0      /* arg stack */\n+\tstw %arg3, -48(%r3)         /* save flags; we need it later */\n \n \t/* Call prep_args:\n \t   %arg0(stack) -- set up above\n \t   %arg1(ecif) -- same as incoming param\n \t   %arg2(bytes) -- same as incoming param */\n-\tbl ffi_prep_args_LINUX,%r2\n+\tbl ffi_prep_args_pa32,%r2\n \tldo 64(%arg0), %sp\n \tldo -64(%sp), %sp\n \n@@ -106,90 +106,139 @@ ffi_call_LINUX:\n \n \t/* Store the result according to the return type.  */\n \n-checksmst3:\n-\tcomib,<>,n FFI_TYPE_SMALL_STRUCT3, %r21, checksmst567\n-\t/* 3-byte structs are returned in ret0 as ??xxyyzz.  Shift\n-\t   left 8 bits to write to the result structure.  */\n-\tzdep %ret0, 23, 24, %r22\n-\tb done\n-\tstw %r22, 0(%r20)\n-\n-checksmst567:\n-\t/* 5-7 byte values are returned right justified:\n+.Lcheckint:\n+\tcomib,<>,n FFI_TYPE_INT, %r21, .Lcheckint8\n+\tb\t.Ldone\n+\tstw\t%ret0, 0(%r20)\n+\n+.Lcheckint8:\n+\tcomib,<>,n FFI_TYPE_UINT8, %r21, .Lcheckint16\n+\tb\t.Ldone\n+\tstb\t%ret0, 0(%r20)\n+\n+.Lcheckint16:\n+\tcomib,<>,n FFI_TYPE_UINT16, %r21, .Lcheckdbl\n+\tb\t.Ldone\n+\tsth\t%ret0, 0(%r20)\n+\n+.Lcheckdbl:\n+\tcomib,<>,n FFI_TYPE_DOUBLE, %r21, .Lcheckfloat\n+\tb\t.Ldone\n+\tfstd\t%fr4,0(%r20)\n+\n+.Lcheckfloat:\n+\tcomib,<>,n FFI_TYPE_FLOAT, %r21, .Lcheckll\n+\tb\t.Ldone\n+\tfstw\t%fr4L,0(%r20)\n+\n+.Lcheckll:\n+\tcomib,<>,n FFI_TYPE_UINT64, %r21, .Lchecksmst2\n+\tstw\t%ret0, 0(%r20)\n+\tb\t.Ldone\n+\tstw\t%ret1, 4(%r20)\n+\n+.Lchecksmst2:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT2, %r21, .Lchecksmst3\n+\t/* 2-byte structs are returned in ret0 as ????xxyy.  */\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\t.Ldone\n+\tstb\t%ret0, 0(%r20)\n+\n+.Lchecksmst3:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT3, %r21, .Lchecksmst4\n+\t/* 3-byte structs are returned in ret0 as ??xxyyzz.  */\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\t.Ldone\n+\tstb\t%ret0, 0(%r20)\n+\n+.Lchecksmst4:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT4, %r21, .Lchecksmst5\n+\t/* 4-byte structs are returned in ret0 as wwxxyyzz.  */\n+\textru\t%ret0, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\t.Ldone\n+\tstb\t%ret0, 0(%r20)\n+\n+.Lchecksmst5:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT5, %r21, .Lchecksmst6\n+\t/* 5 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   5: ??????aa bbccddee */\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\t.Ldone\n+\tstb\t%ret1, 0(%r20)\n+\n+.Lchecksmst6:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT6, %r21, .Lchecksmst7\n+\t/* 6 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   6: ????aabb ccddeeff */\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\t.Ldone\n+\tstb\t%ret1, 0(%r20)\n+\n+.Lchecksmst7:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT7, %r21, .Lchecksmst8\n+\t/* 7 byte values are returned right justified:\n+\t      ret0     ret1\n+\t   7: ??aabbcc ddeeffgg */\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tb\t.Ldone\n+\tstb\t%ret1, 0(%r20)\n+\n+.Lchecksmst8:\n+\tcomib,<>,n FFI_TYPE_SMALL_STRUCT8, %r21, .Ldone\n+\t/* 8 byte values are returned right justified:\n \t      ret0     ret1\n-\t   5: ??????aa bbccddee\n-\t   6: ????aabb ccddeeff\n-\t   7: ??aabbcc ddeeffgg\n-\n-\t   To store this in the result, write the first 4 bytes into a temp\n-\t   register using shrpw (t1 = aabbccdd), followed by a rotation of\n-\t   ret1:\n-\n-\t      ret0     ret1\t   ret1\n-\t   5: ??????aa bbccddee -> eebbccdd (rotate 8)\n-\t   6: ????aabb ccddeeff -> eeffccdd (rotate 16)\n-\t   7: ??aabbcc ddeeffgg -> eeffggdd (rotate 24)\n-\n-\t   then we write (t1, ret1) into the result.  */\n-\n-\taddi,<> -FFI_TYPE_SMALL_STRUCT5,%r21,%r0\n-\tldi 8, %r22\n-\taddi,<> -FFI_TYPE_SMALL_STRUCT6,%r21,%r0\n-\tldi 16, %r22\n-\taddi,<> -FFI_TYPE_SMALL_STRUCT7,%r21,%r0\n-\tldi 24, %r22\n-\n-\t/* This relies on all the FFI_TYPE_*_STRUCT* defines being <0 */\n-\tcmpib,<=,n 0, %r21, checkint8\n-\tmtsar %r22\n-\n-\tshrpw %ret0, %ret1, %sar, %ret0  /* ret0 = aabbccdd */\n-\tshrpw %ret1, %ret1, %sar, %ret1  /* rotate ret1 */\n-\t\n-\tstw %ret0, 0(%r20)\n-\tb done\n-\tstw %ret1, 4(%r20)\n-\n-checkint8:\n-\tcomib,<>,n FFI_TYPE_UINT8, %r21, checkint16\n-\tb done\n-\tstb %ret0, 0(%r20)\n-\n-checkint16:\n-\tcomib,<>,n FFI_TYPE_UINT16, %r21, checkint32\n-\tb done\n-\tsth %ret0, 0(%r20)\n-\n-checkint32:\n-\tcomib,<>,n FFI_TYPE_UINT32, %r21, checkint\n-\tb done\n-\tstw %ret0, 0(%r20)\n-\n-checkint:\n-\tcomib,<>,n FFI_TYPE_INT, %r21, checkll\n-\tb done\n-\tstw %ret0, 0(%r20)\n-\n-checkll:\n-\tcomib,<>,n FFI_TYPE_UINT64, %r21, checkdbl\n-\tstw %ret0, 0(%r20)\n-\tb done\n-\tstw %ret1, 4(%r20)\n-\n-checkdbl:\n-\tcomib,<>,n FFI_TYPE_DOUBLE, %r21, checkfloat\n-\tb done\n-\tfstd %fr4,0(%r20)\n-\n-checkfloat:\n-\tcomib,<>,n FFI_TYPE_FLOAT, %r21, done\n-\tfstw %fr4L,0(%r20)\n-\n-\t/* structure returns are either handled by one of the\n-\t   INT/UINT64 cases above, or, if passed by pointer,\n-\t   is handled by the callee.  */\n-\n-done:\n+\t   8: aabbccdd eeffgghh */\n+\textru\t%ret0, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret0, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstbs,ma\t%ret0, 1(%r20)\n+\textru\t%ret1, 7, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 15, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\textru\t%ret1, 23, 8, %r22\n+\tstbs,ma\t%r22, 1(%r20)\n+\tstb\t%ret1, 0(%r20)\n+\n+.Ldone:\n \t/* all done, return */\n \tcopy %r4, %sp                           /* pop arg stack */\n \tldw 12(%r3), %r4\n@@ -201,14 +250,14 @@ done:\n \t.procend\n .LFE1:\n \n-\t/* void ffi_closure_LINUX(void);\n+\t/* void ffi_closure_pa32(void);\n \t   Called with closure argument in %r21 */\n-\t.export ffi_closure_LINUX,code\n-\t.import ffi_closure_inner_LINUX,code\n+\t.export ffi_closure_pa32,code\n+\t.import ffi_closure_inner_pa32,code\n \n-\t.type ffi_closure_LINUX, @function\n+\t.type ffi_closure_pa32, @function\n .LFB2:\n-ffi_closure_LINUX:\n+ffi_closure_pa32:\n \t.proc\n \t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n \t.entry\n@@ -228,7 +277,7 @@ ffi_closure_LINUX:\n \tstw %arg3, -48(%r3)\n \n \tcopy %r21, %arg0\n-\tbl ffi_closure_inner_LINUX, %r2\n+\tbl ffi_closure_inner_pa32, %r2\n \tcopy %r3, %arg1\n \n \tldwm -64(%sp), %r3"}, {"sha": "e46741c040dbcfb7797bd87b93f0c18031d6c2ba", "filename": "libffi/testsuite/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c300efaa5d98974d8a58ee91c458e56714f73f/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=e6c300efaa5d98974d8a58ee91c458e56714f73f", "patch": "@@ -109,15 +109,19 @@ MIPS_IRIX_TRUE = @MIPS_IRIX_TRUE@\n MIPS_LINUX_FALSE = @MIPS_LINUX_FALSE@\n MIPS_LINUX_TRUE = @MIPS_LINUX_TRUE@\n OBJEXT = @OBJEXT@\n+PA64_HPUX_FALSE = @PA64_HPUX_FALSE@\n+PA64_HPUX_TRUE = @PA64_HPUX_TRUE@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n PACKAGE_NAME = @PACKAGE_NAME@\n PACKAGE_STRING = @PACKAGE_STRING@\n PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n-PA_FALSE = @PA_FALSE@\n-PA_TRUE = @PA_TRUE@\n+PA_HPUX_FALSE = @PA_HPUX_FALSE@\n+PA_HPUX_TRUE = @PA_HPUX_TRUE@\n+PA_LINUX_FALSE = @PA_LINUX_FALSE@\n+PA_LINUX_TRUE = @PA_LINUX_TRUE@\n POWERPC_AIX_FALSE = @POWERPC_AIX_FALSE@\n POWERPC_AIX_TRUE = @POWERPC_AIX_TRUE@\n POWERPC_DARWIN_FALSE = @POWERPC_DARWIN_FALSE@"}]}