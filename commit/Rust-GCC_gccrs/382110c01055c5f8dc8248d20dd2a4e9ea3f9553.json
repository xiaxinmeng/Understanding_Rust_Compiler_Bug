{"sha": "382110c01055c5f8dc8248d20dd2a4e9ea3f9553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgyMTEwYzAxMDU1YzVmOGRjODI0OGQyMGRkMmE0ZTllYTNmOTU1Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-10-20T19:42:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-10-20T19:42:40Z"}, "message": "stor-layout.c (compute_record_mode): Use tree_low_cst.\n\n\t* stor-layout.c (compute_record_mode): Use tree_low_cst.\n\tDon't use mode of field for record unless sizes are the same.\n\t(layout_type, case ARRAY_TYPE): Remove special bounds handling\n\tpreviously added for Ada; also change to using host_integerp\n\tand tree_low_cst.\n\nFrom-SVN: r36976", "tree": {"sha": "0e5a2b6551decd38ed5f8c09625492d2fb4d730e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e5a2b6551decd38ed5f8c09625492d2fb4d730e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/382110c01055c5f8dc8248d20dd2a4e9ea3f9553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382110c01055c5f8dc8248d20dd2a4e9ea3f9553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/382110c01055c5f8dc8248d20dd2a4e9ea3f9553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382110c01055c5f8dc8248d20dd2a4e9ea3f9553/comments", "author": null, "committer": null, "parents": [{"sha": "1dcdb0df61a9811b076bb7d175666eaf0d421909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcdb0df61a9811b076bb7d175666eaf0d421909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dcdb0df61a9811b076bb7d175666eaf0d421909"}], "stats": {"total": 45, "additions": 15, "deletions": 30}, "files": [{"sha": "c98116c12c210603e71bb9f55fd914f721cd07d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382110c01055c5f8dc8248d20dd2a4e9ea3f9553/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382110c01055c5f8dc8248d20dd2a4e9ea3f9553/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=382110c01055c5f8dc8248d20dd2a4e9ea3f9553", "patch": "@@ -1,5 +1,11 @@\n Fri Oct 20 13:33:16 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* stor-layout.c (compute_record_mode): Use tree_low_cst.\n+\tDon't use mode of field for record unless sizes are the same.\n+\t(layout_type, case ARRAY_TYPE): Remove special bounds handling\n+\tpreviously added for Ada; also change to using host_integerp\n+\tand tree_low_cst.\n+\n \t* loop.c (strength_reduce): Show when new register made for\n \tgiv is known to be a pointer and its aligment if so and known.\n \t(loop_dump_aux): Show VERBOSE parameter unused."}, {"sha": "ea9ee013dd780d076db036a66c2c266dd1cde11b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382110c01055c5f8dc8248d20dd2a4e9ea3f9553/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382110c01055c5f8dc8248d20dd2a4e9ea3f9553/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=382110c01055c5f8dc8248d20dd2a4e9ea3f9553", "patch": "@@ -1057,7 +1057,7 @@ compute_record_mode (type)\n       /* Must be BLKmode if any field crosses a word boundary,\n \t since extract_bit_field can't handle that in registers.  */\n       if (bitpos / BITS_PER_WORD\n-\t  != ((TREE_INT_CST_LOW (DECL_SIZE (field)) + bitpos - 1)\n+\t  != ((tree_low_cst (DECL_SIZE (field), 1) + bitpos - 1)\n \t      / BITS_PER_WORD)\n \t  /* But there is no problem if the field is entire words.  */\n \t  && tree_low_cst (DECL_SIZE (field), 1) % BITS_PER_WORD != 0)\n@@ -1069,7 +1069,8 @@ compute_record_mode (type)\n \t we don't support using such a mode if there is no integer mode\n \t of the same size, so don't set it here.  */\n       if (field == TYPE_FIELDS (type) && TREE_CHAIN (field) == 0\n-\t  && int_mode_for_mode (DECL_MODE (field)) != BLKmode)\n+\t  && int_mode_for_mode (DECL_MODE (field)) != BLKmode\n+\t  && operand_equal_p (DECL_SIZE (field), TYPE_SIZE (type), 1))\n \tmode = DECL_MODE (field);\n \n #ifdef STRUCT_FORCE_BLK\n@@ -1336,22 +1337,6 @@ layout_type (type)\n \t    tree length;\n \t    tree element_size;\n \n-\t    /* If UB is max (lb - 1, x), remove the MAX_EXPR since the\n-\t       test for negative below covers it.  */\n-\t    if (TREE_CODE (ub) == MAX_EXPR\n-\t\t&& TREE_CODE (TREE_OPERAND (ub, 0)) == MINUS_EXPR\n-\t\t&& integer_onep (TREE_OPERAND (TREE_OPERAND (ub, 0), 1))\n-\t\t&& operand_equal_p (TREE_OPERAND (TREE_OPERAND (ub, 0), 0),\n-\t\t\t\t    lb, 0))\n-\t      ub = TREE_OPERAND (ub, 1);\n-\t    else if (TREE_CODE (ub) == MAX_EXPR\n-\t\t     && TREE_CODE (TREE_OPERAND (ub, 1)) == MINUS_EXPR\n-\t\t     && integer_onep (TREE_OPERAND (TREE_OPERAND (ub, 1), 1))\n-\t\t     && operand_equal_p (TREE_OPERAND (TREE_OPERAND (ub, 1),\n-\t\t\t\t\t\t       0),\n-\t\t\t\t\t lb, 0))\n-\t      ub = TREE_OPERAND (ub, 0);\n-\n \t    /* The initial subtraction should happen in the original type so\n \t       that (possible) negative values are handled appropriately.  */\n \t    length = size_binop (PLUS_EXPR, size_one_node,\n@@ -1360,23 +1345,17 @@ layout_type (type)\n \t\t\t\t\t\t       TREE_TYPE (lb),\n \t\t\t\t\t\t       ub, lb))));\n \n-\t    /* If neither bound is a constant and sizetype is signed, make\n-\t       sure the size is never negative.  We should really do this\n-\t       if *either* bound is non-constant, but this is the best\n-\t       compromise between C and Ada.  */\n-\t    if (! TREE_UNSIGNED (sizetype)\n-\t\t&& TREE_CODE (TYPE_MIN_VALUE (index)) != INTEGER_CST\n-\t\t&& TREE_CODE (TYPE_MAX_VALUE (index)) != INTEGER_CST)\n-\t      length = size_binop (MAX_EXPR, length, size_zero_node);\n-\n \t    /* Special handling for arrays of bits (for Chill).  */\n \t    element_size = TYPE_SIZE (element);\n-\t    if (TYPE_PACKED (type) && INTEGRAL_TYPE_P (element))\n+\t    if (TYPE_PACKED (type) && INTEGRAL_TYPE_P (element)\n+\t\t&& (integer_zerop (TYPE_MAX_VALUE (element))\n+\t\t    || integer_onep (TYPE_MAX_VALUE (element)))\n+\t\t&& host_integerp (TYPE_MIN_VALUE (element), 1))\n \t      {\n \t\tHOST_WIDE_INT maxvalue\n-\t\t  = TREE_INT_CST_LOW (TYPE_MAX_VALUE (element));\n+\t\t  = tree_low_cst (TYPE_MAX_VALUE (element), 1);\n \t\tHOST_WIDE_INT minvalue\n-\t\t  = TREE_INT_CST_LOW (TYPE_MIN_VALUE (element));\n+\t\t  = tree_low_cst (TYPE_MIN_VALUE (element), 1);\n \n \t\tif (maxvalue - minvalue == 1\n \t\t    && (maxvalue == 1 || maxvalue == 0))"}]}