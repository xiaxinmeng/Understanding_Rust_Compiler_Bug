{"sha": "fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM3MTYwYjJjNzE4ZDc5NzRhZWU5N2NhOWI4NDQ4ZWM3NjBiYmZiNw==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2017-11-22T15:58:22Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2017-11-22T15:58:22Z"}, "message": "[ARM] Factor out CMSE register clearing code\n\nFunctions cmse_nonsecure_call_clear_caller_saved and\ncmse_nonsecure_entry_clear_before_return both contain very similar code\nto clear registers. What's worse, they differ slightly at times so if a\nbug is found in one careful thoughts is needed to decide whether the\nother function needs fixing too.\n\nThis commit addresses the situation by factoring the two pieces of code\ninto a new function. In doing so the code generated to clear VFP\nregisters in cmse_nonsecure_call now uses the same sequence as\ncmse_nonsecure_entry functions. Tests expectation are thus updated\naccordingly.\n\n2017-11-22  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    * config/arm/arm.c (cmse_clear_registers): New function.\n    (cmse_nonsecure_call_clear_caller_saved): Replace register clearing\n    code by call to cmse_clear_registers.\n    (cmse_nonsecure_entry_clear_before_return): Likewise.\n\n    gcc/testsuite/\n    * gcc.target/arm/cmse/mainline/hard-sp/cmse-13.c: Adapt expectations\n    to vmov instructions now generated.\n    * gcc.target/arm/cmse/mainline/hard-sp/cmse-7.c: Likewise.\n    * gcc.target/arm/cmse/mainline/hard-sp/cmse-8.c: Likewise.\n    * gcc.target/arm/cmse/mainline/hard/cmse-13.c: Likewise.\n    * gcc.target/arm/cmse/mainline/hard/cmse-7.c: Likewise.\n    * gcc.target/arm/cmse/mainline/hard/cmse-8.c: Likewise.\n\nFrom-SVN: r255065", "tree": {"sha": "518896eb9721f8ef7c85871655e1ed784b2ae673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/518896eb9721f8ef7c85871655e1ed784b2ae673"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9388732aa53da50828a37884c88adae7fd313839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9388732aa53da50828a37884c88adae7fd313839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9388732aa53da50828a37884c88adae7fd313839"}], "stats": {"total": 452, "additions": 235, "deletions": 217}, "files": [{"sha": "1538448a807974950cce6de90adf3c46623b9a9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -1,3 +1,10 @@\n+2017-11-22  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/arm.c (cmse_clear_registers): New function.\n+\t(cmse_nonsecure_call_clear_caller_saved): Replace register clearing\n+\tcode by call to cmse_clear_registers.\n+\t(cmse_nonsecure_entry_clear_before_return): Likewise.\n+\n 2017-11-22  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/arm/arm_neon.h (vdot_u32, vdotq_u32)"}, {"sha": "bed4d6cdd4825d67c1b2472e4a19441ec2068398", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 142, "deletions": 141, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -16992,6 +16992,128 @@ compute_not_to_clear_mask (tree arg_type, rtx arg_rtx, int regno,\n   return not_to_clear_mask;\n }\n \n+/* Clear registers secret before doing a cmse_nonsecure_call or returning from\n+   a cmse_nonsecure_entry function.  TO_CLEAR_BITMAP indicates which registers\n+   are to be fully cleared, using the value in register CLEARING_REG if more\n+   efficient.  The PADDING_BITS_LEN entries array PADDING_BITS_TO_CLEAR gives\n+   the bits that needs to be cleared in caller-saved core registers, with\n+   SCRATCH_REG used as a scratch register for that clearing.\n+\n+   NOTE: one of three following assertions must hold:\n+   - SCRATCH_REG is a low register\n+   - CLEARING_REG is in the set of registers fully cleared (ie. its bit is set\n+     in TO_CLEAR_BITMAP)\n+   - CLEARING_REG is a low register.  */\n+\n+static void\n+cmse_clear_registers (sbitmap to_clear_bitmap, uint32_t *padding_bits_to_clear,\n+\t\t      int padding_bits_len, rtx scratch_reg, rtx clearing_reg)\n+{\n+  bool saved_clearing = false;\n+  rtx saved_clearing_reg = NULL_RTX;\n+  int i, regno, clearing_regno, minregno = R0_REGNUM, maxregno = minregno - 1;\n+\n+  gcc_assert (arm_arch_cmse);\n+\n+  if (!bitmap_empty_p (to_clear_bitmap))\n+    {\n+      minregno = bitmap_first_set_bit (to_clear_bitmap);\n+      maxregno = bitmap_last_set_bit (to_clear_bitmap);\n+    }\n+  clearing_regno = REGNO (clearing_reg);\n+\n+  /* Clear padding bits.  */\n+  gcc_assert (padding_bits_len <= NUM_ARG_REGS);\n+  for (i = 0, regno = R0_REGNUM; i < padding_bits_len; i++, regno++)\n+    {\n+      uint64_t mask;\n+      rtx rtx16, dest, cleared_reg = gen_rtx_REG (SImode, regno);\n+\n+      if (padding_bits_to_clear[i] == 0)\n+\tcontinue;\n+\n+      /* If this is a Thumb-1 target and SCRATCH_REG is not a low register, use\n+\t CLEARING_REG as scratch.  */\n+      if (TARGET_THUMB1\n+\t  && REGNO (scratch_reg) > LAST_LO_REGNUM)\n+\t{\n+\t  /* clearing_reg is not to be cleared, copy its value into scratch_reg\n+\t     such that we can use clearing_reg to clear the unused bits in the\n+\t     arguments.  */\n+\t  if ((clearing_regno > maxregno\n+\t       || !bitmap_bit_p (to_clear_bitmap, clearing_regno))\n+\t      && !saved_clearing)\n+\t    {\n+\t      gcc_assert (clearing_regno <= LAST_LO_REGNUM);\n+\t      emit_move_insn (scratch_reg, clearing_reg);\n+\t      saved_clearing = true;\n+\t      saved_clearing_reg = scratch_reg;\n+\t    }\n+\t  scratch_reg = clearing_reg;\n+\t}\n+\n+      /* Fill the lower half of the negated padding_bits_to_clear[i].  */\n+      mask = (~padding_bits_to_clear[i]) & 0xFFFF;\n+      emit_move_insn (scratch_reg, gen_int_mode (mask, SImode));\n+\n+      /* Fill the top half of the negated padding_bits_to_clear[i].  */\n+      mask = (~padding_bits_to_clear[i]) >> 16;\n+      rtx16 = gen_int_mode (16, SImode);\n+      dest = gen_rtx_ZERO_EXTRACT (SImode, scratch_reg, rtx16, rtx16);\n+      if (mask)\n+\temit_insn (gen_rtx_SET (dest, gen_int_mode (mask, SImode)));\n+\n+      emit_insn (gen_andsi3 (cleared_reg, cleared_reg, scratch_reg));\n+    }\n+  if (saved_clearing)\n+    emit_move_insn (clearing_reg, saved_clearing_reg);\n+\n+\n+  /* Clear full registers.  */\n+\n+  /* If not marked for clearing, clearing_reg already does not contain\n+     any secret.  */\n+  if (clearing_regno <= maxregno\n+      && bitmap_bit_p (to_clear_bitmap, clearing_regno))\n+    {\n+      emit_move_insn (clearing_reg, const0_rtx);\n+      emit_use (clearing_reg);\n+      bitmap_clear_bit (to_clear_bitmap, clearing_regno);\n+    }\n+\n+  for (regno = minregno; regno <= maxregno; regno++)\n+    {\n+      if (!bitmap_bit_p (to_clear_bitmap, regno))\n+\tcontinue;\n+\n+      if (IS_VFP_REGNUM (regno))\n+\t{\n+\t  /* If regno is an even vfp register and its successor is also to\n+\t     be cleared, use vmov.  */\n+\t  if (TARGET_VFP_DOUBLE\n+\t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n+\t      && bitmap_bit_p (to_clear_bitmap, regno + 1))\n+\t    {\n+\t      emit_move_insn (gen_rtx_REG (DFmode, regno),\n+\t\t\t      CONST1_RTX (DFmode));\n+\t      emit_use (gen_rtx_REG (DFmode, regno));\n+\t      regno++;\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_move_insn (gen_rtx_REG (SFmode, regno),\n+\t\t\t      CONST1_RTX (SFmode));\n+\t      emit_use (gen_rtx_REG (SFmode, regno));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (SImode, regno), clearing_reg);\n+\t  emit_use (gen_rtx_REG (SImode, regno));\n+\t}\n+    }\n+}\n+\n /* Clears caller saved registers not used to pass arguments before a\n    cmse_nonsecure_call.  Saving, clearing and restoring of callee saved\n    registers is done in __gnu_cmse_nonsecure_call libcall.\n@@ -17012,12 +17134,12 @@ cmse_nonsecure_call_clear_caller_saved (void)\n \t    TARGET_HARD_FLOAT_ABI ? D7_VFP_REGNUM : NUM_ARG_REGS - 1;\n \t  auto_sbitmap to_clear_bitmap (maxregno + 1);\n \t  rtx_insn *seq;\n-\t  rtx pat, call, unspec, reg, cleared_reg, tmp;\n+\t  rtx pat, call, unspec, clearing_reg, ip_reg, shift;\n \t  rtx address;\n \t  CUMULATIVE_ARGS args_so_far_v;\n \t  cumulative_args_t args_so_far;\n \t  tree arg_type, fntype;\n-\t  bool using_r4, first_param = true;\n+\t  bool first_param = true;\n \t  function_args_iterator args_iter;\n \t  uint32_t padding_bits_to_clear[4] = {0U, 0U, 0U, 0U};\n \n@@ -17116,79 +17238,20 @@ cmse_nonsecure_call_clear_caller_saved (void)\n \t      first_param = false;\n \t    }\n \n-\t  /* Clear padding bits where needed.  */\n-\t  cleared_reg = XEXP (address, 0);\n-\t  reg = gen_rtx_REG (SImode, IP_REGNUM);\n-\t  using_r4 = false;\n-\t  for (regno = R0_REGNUM; regno < NUM_ARG_REGS; regno++)\n-\t    {\n-\t      if (padding_bits_to_clear[regno] == 0)\n-\t\tcontinue;\n-\n-\t      /* If this is a Thumb-1 target copy the address of the function\n-\t\t we are calling from 'r4' into 'ip' such that we can use r4 to\n-\t\t clear the unused bits in the arguments.  */\n-\t      if (TARGET_THUMB1 && !using_r4)\n-\t\t{\n-\t\t  using_r4 =  true;\n-\t\t  reg = cleared_reg;\n-\t\t  emit_move_insn (gen_rtx_REG (SImode, IP_REGNUM),\n-\t\t\t\t\t  reg);\n-\t\t}\n-\n-\t      tmp = GEN_INT ((((~padding_bits_to_clear[regno]) << 16u) >> 16u));\n-\t      emit_move_insn (reg, tmp);\n-\t      /* Also fill the top half of the negated\n-\t\t padding_bits_to_clear.  */\n-\t      if (((~padding_bits_to_clear[regno]) >> 16) > 0)\n-\t\t{\n-\t\t  tmp = GEN_INT ((~padding_bits_to_clear[regno]) >> 16);\n-\t\t  emit_insn (gen_rtx_SET (gen_rtx_ZERO_EXTRACT (SImode, reg,\n-\t\t\t\t\t\t\t\tGEN_INT (16),\n-\t\t\t\t\t\t\t\tGEN_INT (16)),\n-\t\t\t\t\t  tmp));\n-\t\t}\n-\n-\t      emit_insn (gen_andsi3 (gen_rtx_REG (SImode, regno),\n-\t\t\t\t     gen_rtx_REG (SImode, regno),\n-\t\t\t\t     reg));\n-\n-\t    }\n-\t  if (using_r4)\n-\t    emit_move_insn (cleared_reg,\n-\t\t\t    gen_rtx_REG (SImode, IP_REGNUM));\n-\n \t  /* We use right shift and left shift to clear the LSB of the address\n \t     we jump to instead of using bic, to avoid having to use an extra\n \t     register on Thumb-1.  */\n-\t  tmp = gen_rtx_LSHIFTRT (SImode, cleared_reg, const1_rtx);\n-\t  emit_insn (gen_rtx_SET (cleared_reg, tmp));\n-\t  tmp = gen_rtx_ASHIFT (SImode, cleared_reg, const1_rtx);\n-\t  emit_insn (gen_rtx_SET (cleared_reg, tmp));\n+\t  clearing_reg = XEXP (address, 0);\n+\t  shift = gen_rtx_LSHIFTRT (SImode, clearing_reg, const1_rtx);\n+\t  emit_insn (gen_rtx_SET (clearing_reg, shift));\n+\t  shift = gen_rtx_ASHIFT (SImode, clearing_reg, const1_rtx);\n+\t  emit_insn (gen_rtx_SET (clearing_reg, shift));\n \n-\t  /* Clearing all registers that leak before doing a non-secure\n+\t  /* Clear caller-saved registers that leak before doing a non-secure\n \t     call.  */\n-\t  for (regno = R0_REGNUM; regno <= maxregno; regno++)\n-\t    {\n-\t      if (!bitmap_bit_p (to_clear_bitmap, regno))\n-\t\tcontinue;\n-\n-\t      /* If regno is an even vfp register and its successor is also to\n-\t\t be cleared, use vmov.  */\n-\t      if (IS_VFP_REGNUM (regno))\n-\t\t{\n-\t\t  if (TARGET_VFP_DOUBLE\n-\t\t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n-\t\t      && bitmap_bit_p (to_clear_bitmap, (regno + 1)))\n-\t\t    emit_move_insn (gen_rtx_REG (DFmode, regno++),\n-\t\t\t\t    CONST0_RTX (DFmode));\n-\t\t  else\n-\t\t    emit_move_insn (gen_rtx_REG (SFmode, regno),\n-\t\t\t\t    CONST0_RTX (SFmode));\n-\t\t}\n-\t      else\n-\t\temit_move_insn (gen_rtx_REG (SImode, regno), cleared_reg);\n-\t    }\n+\t  ip_reg = gen_rtx_REG (SImode, IP_REGNUM);\n+\t  cmse_clear_registers (to_clear_bitmap, padding_bits_to_clear,\n+\t\t\t\tNUM_ARG_REGS, ip_reg, clearing_reg);\n \n \t  seq = get_insns ();\n \t  end_sequence ();\n@@ -25152,8 +25215,8 @@ cmse_nonsecure_entry_clear_before_return (void)\n   int regno, maxregno = TARGET_HARD_FLOAT ? LAST_VFP_REGNUM : IP_REGNUM;\n   uint32_t padding_bits_to_clear = 0;\n   auto_sbitmap to_clear_bitmap (maxregno + 1);\n+  rtx r1_reg, result_rtl, clearing_reg = NULL_RTX;\n   tree result_type;\n-  rtx result_rtl;\n \n   bitmap_clear (to_clear_bitmap);\n   bitmap_set_range (to_clear_bitmap, R0_REGNUM, NUM_ARG_REGS);\n@@ -25217,84 +25280,22 @@ cmse_nonsecure_entry_clear_before_return (void)\n \n   if (padding_bits_to_clear != 0)\n     {\n-      rtx reg_rtx;\n       int to_clear_bitmap_size = SBITMAP_SIZE ((sbitmap) to_clear_bitmap);\n       auto_sbitmap to_clear_arg_regs_bitmap (to_clear_bitmap_size);\n \n-      /* Padding bits to clear is not 0 so we know we are dealing with\n+      /* Padding_bits_to_clear is not 0 so we know we are dealing with\n \t returning a composite type, which only uses r0.  Let's make sure that\n-\t r1-r3 is cleared too, we will use r1 as a scratch register.  */\n+\t r1-r3 is cleared too.  */\n       bitmap_clear (to_clear_arg_regs_bitmap);\n-      bitmap_set_range (to_clear_arg_regs_bitmap, R0_REGNUM + 1,\n-\t\t\tNUM_ARG_REGS - 1);\n+      bitmap_set_range (to_clear_arg_regs_bitmap, R1_REGNUM, NUM_ARG_REGS - 1);\n       gcc_assert (bitmap_subset_p (to_clear_arg_regs_bitmap, to_clear_bitmap));\n-\n-      reg_rtx = gen_rtx_REG (SImode, R1_REGNUM);\n-\n-      /* Fill the lower half of the negated padding_bits_to_clear.  */\n-      emit_move_insn (reg_rtx,\n-\t\t      GEN_INT ((((~padding_bits_to_clear) << 16u) >> 16u)));\n-\n-      /* Also fill the top half of the negated padding_bits_to_clear.  */\n-      if (((~padding_bits_to_clear) >> 16) > 0)\n-\temit_insn (gen_rtx_SET (gen_rtx_ZERO_EXTRACT (SImode, reg_rtx,\n-\t\t\t\t\t\t      GEN_INT (16),\n-\t\t\t\t\t\t      GEN_INT (16)),\n-\t\t\t\tGEN_INT ((~padding_bits_to_clear) >> 16)));\n-\n-      emit_insn (gen_andsi3 (gen_rtx_REG (SImode, R0_REGNUM),\n-\t\t\t   gen_rtx_REG (SImode, R0_REGNUM),\n-\t\t\t   reg_rtx));\n     }\n \n-  for (regno = R0_REGNUM; regno <= maxregno; regno++)\n-    {\n-      if (!bitmap_bit_p (to_clear_bitmap, regno))\n-\tcontinue;\n-\n-      if (IS_VFP_REGNUM (regno))\n-\t{\n-\t  /* If regno is an even vfp register and its successor is also to\n-\t     be cleared, use vmov.  */\n-\t  if (TARGET_VFP_DOUBLE\n-\t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n-\t      && bitmap_bit_p (to_clear_bitmap, regno + 1))\n-\t    {\n-\t      emit_move_insn (gen_rtx_REG (DFmode, regno),\n-\t\t\t      CONST1_RTX (DFmode));\n-\t      emit_use (gen_rtx_REG (DFmode, regno));\n-\t      regno++;\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_move_insn (gen_rtx_REG (SFmode, regno),\n-\t\t\t      CONST1_RTX (SFmode));\n-\t      emit_use (gen_rtx_REG (SFmode, regno));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (TARGET_THUMB1)\n-\t    {\n-\t      if (regno == R0_REGNUM)\n-\t\temit_move_insn (gen_rtx_REG (SImode, regno),\n-\t\t\t\tconst0_rtx);\n-\t      else\n-\t\t/* R0 has either been cleared before, see code above, or it\n-\t\t   holds a return value, either way it is not secret\n-\t\t   information.  */\n-\t\temit_move_insn (gen_rtx_REG (SImode, regno),\n-\t\t\t\tgen_rtx_REG (SImode, R0_REGNUM));\n-\t      emit_use (gen_rtx_REG (SImode, regno));\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_move_insn (gen_rtx_REG (SImode, regno),\n-\t\t\t      gen_rtx_REG (SImode, LR_REGNUM));\n-\t      emit_use (gen_rtx_REG (SImode, regno));\n-\t    }\n-\t}\n-    }\n+  /* Clear full registers that leak before returning.  */\n+  clearing_reg = gen_rtx_REG (SImode, TARGET_THUMB1 ? R0_REGNUM : LR_REGNUM);\n+  r1_reg = gen_rtx_REG (SImode, R0_REGNUM + 1);\n+  cmse_clear_registers (to_clear_bitmap, &padding_bits_to_clear, 1, r1_reg,\n+\t\t\tclearing_reg);\n }\n \n /* Generate pattern *pop_multiple_with_stack_update_and_return if single"}, {"sha": "d557f4a35dbc6d73d1254e29d7ef977ab859b192", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -1,3 +1,13 @@\n+2017-11-22  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-13.c: Adapt expectations\n+\tto vmov instructions now generated.\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-8.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-13.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-7.c: Likewise.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-8.c: Likewise.\n+\n 2017-11-22  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.target/arm/simd/vdot-compile.c: New."}, {"sha": "70a0258c482e5a81513207f0edd4fe314821775b", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-13.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-13.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -12,22 +12,22 @@\n /* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts0, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts1, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts2, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts4, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts5, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts6, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts7, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts8, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts9, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts10, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts11, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts12, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts13, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts14, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts15, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "2c9dfcfb562e2d2a7f7cc3084998e9850f5a480c", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-7.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-7.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -12,22 +12,22 @@\n /* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts0, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts1, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts2, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts4, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts5, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts6, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts7, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts8, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts9, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts10, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts11, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts12, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts13, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts14, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts15, .L\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "b46585ebcf192c58721363307686f8649a4f8a4a", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-8.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-8.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -12,22 +12,22 @@\n /* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts0, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts1, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts2, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts4, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts5, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts6, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts7, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts8, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts9, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts10, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts11, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts12, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts13, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts14, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts15, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "576013a74422861ed0d6cb7b5e59aa7779026443", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-13.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-13.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -12,18 +12,18 @@\n /* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.32\\ts1, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.64\\td0, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts0, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.64\\td1, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts2, .L\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.32\\ts3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td2, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td4, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td5, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td6, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td7, .L\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f64\\td0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f64\\td1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "3e502a2c84be94c8767c1e6e97a5864f9aa63ccb", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-7.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-7.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -12,14 +12,14 @@\n /* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td0, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td1, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td2, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td4, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td5, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td6, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td7, .L\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}, {"sha": "5ed3e7a3fd8f51b2813e7affe4da944d938ac1d6", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-8.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc7160b2c718d7974aee97ca9b8448ec760bbfb7/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-8.c?ref=fc7160b2c718d7974aee97ca9b8448ec760bbfb7", "patch": "@@ -12,14 +12,14 @@\n /* { dg-final { scan-assembler \"mov\\tr1, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr2, r4\" } } */\n /* { dg-final { scan-assembler \"mov\\tr3, r4\" } } */\n-/* { dg-final { scan-assembler-not \"vldr\\.64\\td0, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td1, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td2, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td3, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td4, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td5, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td6, .L\" } } */\n-/* { dg-final { scan-assembler \"vldr\\.64\\td7, .L\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f64\\td0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n \n /* Now we check that we use the correct intrinsic to call.  */\n /* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */"}]}