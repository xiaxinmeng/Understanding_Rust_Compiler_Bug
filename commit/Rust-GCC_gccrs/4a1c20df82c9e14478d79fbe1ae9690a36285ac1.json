{"sha": "4a1c20df82c9e14478d79fbe1ae9690a36285ac1", "node_id": "C_kwDOANBUbNoAKDRhMWMyMGRmODJjOWUxNDQ3OGQ3OWZiZTFhZTk2OTBhMzYyODVhYzE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-01T18:43:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-01T18:43:04Z"}, "message": "warn-access: Comment spelling fixes\n\nI've noticed various spelling bugs in comments in this file.\n\nThere is one spot I haven't fixed:\n\"Otherwise, VAR is the auto variable\n(including an unnamed temporary such as a compound literal) whose\nlifetime's rended it dangling.\"\nI'm afraid I don't know what it wanted to say, \"lifetime rendered it\"\nor something else?\n\n2022-03-01  Jakub Jelinek  <jakub@redhat.com>\n\n\t* gimple-ssa-warn-access.cc (warn_string_no_nul,\n\tmaybe_warn_nonstring_arg, fndecl_alloc_p, new_delete_mismatch_p,\n\tmatching_alloc_calls_p, maybe_warn_alloc_args_overflow,\n\tpass_waccess::check_alloca, pass_waccess::check_strcat,\n\tmemmodel_to_uhwi, fntype_argno_type,\n\tpass_waccess::maybe_check_access_sizes,\n\tpass_waccess::check_call_access,\n\tpass_waccess::maybe_check_dealloc_call, pass_waccess::check_stmt):\n\tComment spelling fixes.", "tree": {"sha": "20d5c1c58cb2832c196d3a89348c542f56c9dbf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20d5c1c58cb2832c196d3a89348c542f56c9dbf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a1c20df82c9e14478d79fbe1ae9690a36285ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a1c20df82c9e14478d79fbe1ae9690a36285ac1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a1c20df82c9e14478d79fbe1ae9690a36285ac1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a1c20df82c9e14478d79fbe1ae9690a36285ac1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "469073c1e6816d245fb402303883fee3d0c6a1cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469073c1e6816d245fb402303883fee3d0c6a1cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469073c1e6816d245fb402303883fee3d0c6a1cc"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "d015c73dfc67a4c0a070731c888b93800084ace3", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a1c20df82c9e14478d79fbe1ae9690a36285ac1/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a1c20df82c9e14478d79fbe1ae9690a36285ac1/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=4a1c20df82c9e14478d79fbe1ae9690a36285ac1", "patch": "@@ -146,7 +146,7 @@ warn_string_no_nul (location_t loc, GimpleOrTree expr, const char *fname,\n   loc = expansion_point_location_if_in_system_header (loc);\n   bool warned;\n \n-  /* Format the bound range as a string to keep the nuber of messages\n+  /* Format the bound range as a string to keep the number of messages\n      from exploding.  */\n   char bndstr[80];\n   *bndstr = 0;\n@@ -619,7 +619,7 @@ maybe_warn_nonstring_arg (tree fndecl, GimpleOrTree exp)\n       /* In a call to strncat with a bound in a range whose lower but\n \t not upper bound is less than the array size, reset ASIZE to\n \t be the same as the bound and the other variable to trigger\n-\t the apprpriate warning below.  */\n+\t the appropriate warning below.  */\n       if (fncode == BUILT_IN_STRNCAT\n \t  && bndrng[0] != bndrng[1]\n \t  && wi::ltu_p (wi::to_offset (bndrng[0]), asize)\n@@ -1538,7 +1538,7 @@ check_access (tree expr, tree dstwrite,\n }\n \n /* Return true if STMT is a call to an allocation function.  Unless\n-   ALL_ALLOC is set, consider only functions that return dynmamically\n+   ALL_ALLOC is set, consider only functions that return dynamically\n    allocated objects.  Otherwise return true even for all forms of\n    alloca (including VLA).  */\n \n@@ -1720,7 +1720,7 @@ new_delete_mismatch_p (const demangle_component &newc,\n }\n \n /* Return true if DELETE_DECL is an operator delete that's not suitable\n-   to call with a pointer returned fron NEW_DECL.  */\n+   to call with a pointer returned from NEW_DECL.  */\n \n static bool\n new_delete_mismatch_p (tree new_decl, tree delete_decl)\n@@ -1960,7 +1960,7 @@ matching_alloc_calls_p (tree alloc_decl, tree dealloc_decl)\n }\n \n /* Return true if DEALLOC_DECL is a function suitable to deallocate\n-   objectes allocated by the ALLOC call.  */\n+   objects allocated by the ALLOC call.  */\n \n static bool\n matching_alloc_calls_p (gimple *alloc, tree dealloc_decl)\n@@ -2215,7 +2215,7 @@ alloc_max_size (void)\n \n /* Diagnose a call EXP to function FN decorated with attribute alloc_size\n    whose argument numbers given by IDX with values given by ARGS exceed\n-   the maximum object size or cause an unsigned oveflow (wrapping) when\n+   the maximum object size or cause an unsigned overflow (wrapping) when\n    multiplied.  FN is null when EXP is a call via a function pointer.\n    When ARGS[0] is null the function does nothing.  ARGS[1] may be null\n    for functions like malloc, and non-null for those like calloc that\n@@ -2388,7 +2388,7 @@ pass_waccess::check_alloca (gcall *stmt)\n       /* -Walloca-larger-than and -Wvla-larger-than settings of less\n \t than  HWI_MAX override the more general -Walloc-size-larger-than\n \t so unless either of the former options is smaller than the last\n-\t one (wchich would imply that the call was already checked), check\n+\t one (which would imply that the call was already checked), check\n \t the alloca arguments for overflow.  */\n       const tree alloc_args[] = { call_arg (stmt, 0), NULL_TREE };\n       const int idx[] = { 0, -1 };\n@@ -2471,7 +2471,7 @@ pass_waccess::check_strcat (gcall *stmt)\n \n   /* There is no way here to determine the length of the string in\n      the destination to which the SRC string is being appended so\n-     just diagnose cases when the souce string is longer than\n+     just diagnose cases when the source string is longer than\n      the destination object.  */\n   access_data data (m_ptr_qry.rvals, stmt, access_read_write, NULL_TREE,\n \t\t    true, NULL_TREE, true);\n@@ -2789,7 +2789,7 @@ memmodel_to_uhwi (tree ord, gimple *stmt, unsigned HOST_WIDE_INT *cstval)\n   else\n     {\n       /* Use the range query to determine constant values in the absence\n-\t of constant proppagation (such as at -O0).  */\n+\t of constant propagation (such as at -O0).  */\n       value_range rng;\n       if (!get_range_query (cfun)->range_of_expr (rng, ord, stmt)\n \t  || !rng.constant_p ()\n@@ -3270,7 +3270,7 @@ pass_waccess::check_builtin (gcall *stmt)\n }\n \n /* Returns the type of the argument ARGNO to function with type FNTYPE\n-   or null when the typoe cannot be determined or no such argument exists.  */\n+   or null when the type cannot be determined or no such argument exists.  */\n \n static tree\n fntype_argno_type (tree fntype, unsigned argno)\n@@ -3347,7 +3347,7 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n       tree ptrtype = fntype_argno_type (fntype, ptridx);\n       if (!ptrtype)\n \t/* A function with a prototype was redeclared without one and\n-\t   the protype has been lost.  See pr102759.  Avoid dealing\n+\t   the prototype has been lost.  See pr102759.  Avoid dealing\n \t   with this pathological case.  */\n \treturn;\n \n@@ -3605,7 +3605,7 @@ pass_waccess::check_call_access (gcall *stmt)\n   if (!fntypeattrs)\n     return false;\n \n-  /* Map of attribute accewss specifications for function arguments.  */\n+  /* Map of attribute access specifications for function arguments.  */\n   rdwr_map rdwr_idx;\n   init_attr_rdwr_indices (&rdwr_idx, fntypeattrs);\n \n@@ -3621,7 +3621,7 @@ pass_waccess::check_call_access (gcall *stmt)\n \t  if (POINTER_TYPE_P (TREE_TYPE (arg)))\n \t    {\n \t      access->ptr = arg;\n-\t      // A nonnull ACCESS->SIZE contains VLA bounds.  */\n+\t      /* A nonnull ACCESS->SIZE contains VLA bounds.  */\n \t    }\n \t  else\n \t    {\n@@ -3654,7 +3654,7 @@ check_nonstring_args (gcall *stmt)\n /* Issue a warning if a deallocation function such as free, realloc,\n    or C++ operator delete is called with an argument not returned by\n    a matching allocation function such as malloc or the corresponding\n-   form of C++ operatorn new.  */\n+   form of C++ operator new.  */\n \n void\n pass_waccess::maybe_check_dealloc_call (gcall *call)\n@@ -4331,7 +4331,7 @@ pass_waccess::check_stmt (gimple *stmt)\n   if (m_check_dangling_p\n       && gimple_clobber_p (stmt, CLOBBER_EOL))\n     {\n-      /* Ignore clobber statemts in blocks with exceptional edges.  */\n+      /* Ignore clobber statements in blocks with exceptional edges.  */\n       basic_block bb = gimple_bb (stmt);\n       edge e = EDGE_PRED (bb, 0);\n       if (e->flags & EDGE_EH)"}]}