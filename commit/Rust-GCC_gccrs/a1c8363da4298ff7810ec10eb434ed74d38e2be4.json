{"sha": "a1c8363da4298ff7810ec10eb434ed74d38e2be4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjODM2M2RhNDI5OGZmNzgxMGVjMTBlYjQzNGVkNzRkMzhlMmJlNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-23T17:29:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-06-23T17:29:13Z"}, "message": "Initial revision\n\nFrom-SVN: r14289", "tree": {"sha": "261e2aa99386dba2f43afbf53c900aea44a53247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/261e2aa99386dba2f43afbf53c900aea44a53247"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c8363da4298ff7810ec10eb434ed74d38e2be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c8363da4298ff7810ec10eb434ed74d38e2be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c8363da4298ff7810ec10eb434ed74d38e2be4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c8363da4298ff7810ec10eb434ed74d38e2be4/comments", "author": null, "committer": null, "parents": [{"sha": "5a060962811963d7d56f18099ff65596754d807a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a060962811963d7d56f18099ff65596754d807a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a060962811963d7d56f18099ff65596754d807a"}], "stats": {"total": 5404, "additions": 5404, "deletions": 0}, "files": [{"sha": "6faa09102b57623dc78c07a1f39d2be8125fa826", "filename": "gcc/config/mn10200/divmod.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fdivmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fdivmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fdivmod.c?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,50 @@\n+long udivmodsi4 ();\n+\n+long\n+__divsi3 (long a, long b)\n+{\n+  int neg = 0;\n+  long res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = udivmodsi4 (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+long\n+__modsi3 (long a, long b)\n+{\n+  int neg = 0;\n+  long res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = udivmodsi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}"}, {"sha": "ff98fcc0ca20bc73d66777ef55807acc606038f9", "filename": "gcc/config/mn10200/lib1funcs.asm", "status": "added", "additions": 609, "deletions": 0, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Flib1funcs.asm?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,609 @@\n+/* libgcc1 routines for Matsushita mn10200.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifdef L_divhi3\n+\t/* Derive signed division/modulo from unsigned \"divu\" instruction.  */\n+\t.text\n+\t.globl ___divhi3\n+\t.type ___divhi3,@function\n+___divhi3:\n+\n+\t/* We're going to need some scratch registers, so save d2/d3\n+\t   into the stack.  */\n+\tadd -8,a3\n+\tmovx d2,(0,a3)\n+\tmovx d3,(4,a3)\n+\n+\t/* Loading zeros into registers now allows us to use them\n+\t   in the compare instructions, which saves a total of\n+\t   two bytes (egad).  */\n+\tsub d3,d3\n+\tsub d2,d2\n+\tsub a0,a0\n+\n+\t/* If first operand is negative, then make it positive.\n+\t   It will be contained in d2 just before .L1. \n+\n+\t   a0 tells us if the first operand was negated.  */\n+\tcmp d2,d0\n+\tbge .L0\n+\tsub d0,d2\n+\tmov 1,a0\n+\tbra .L1\n+.L0:\n+\tmov d0,d2\n+.L1:\n+\t/* If the second operand is negative, then make it positive.\n+\t   It will be contained in d3 just before .L3. \n+\n+\t   d0 tells us if the second operand was negated.  */\n+\tcmp d3,d1\n+\tbge .L2\n+\tsub d1,d3\n+\tmov 1,d0\n+\tbra .L3\n+.L2:\n+\tsub d0,d0\n+\tmov d1,d3\n+.L3:\n+\t/* Loading d1 with zero here allows us to save one byte\n+\t   in the comparison below.  */\n+\n+\tsub d1,d1\n+\n+\t/* Make sure to clear the mdr register, then do the unsigned\n+\t   division.  Result will be in d2/mdr.  */\n+\tmov d1,mdr\n+\tdivu d3,d2\n+\n+\t/* Negate the remainder based on the first argument negation\n+\t   flag only.  */\n+\tcmp d1,a0\n+\tbeq .L4\n+\tmov mdr,d3\n+\tsub d3,d1\n+\tbra .L5\n+.L4:\n+\tmov mdr,d1\n+\n+.L5:\n+\t/* Negate the result if either, but not both of the inputs\n+\t   were negated.  */\n+\tmov a0,d3\n+\txor d3,d0\n+\tbeq .L6\n+\tsub d0,d0\n+\tsub d2,d0\n+\tbra .L7\n+.L6:\n+\tmov d2,d0\n+.L7:\n+\t\n+\t/* Restore our scratch registers, deallocate our stack and return.  */\n+\tmovx (0,a3),d2\n+\tmovx (4,a3),d3\n+\tadd 8,a3\n+\trts\n+\t.size ___divhi3,.-___divhi3\n+#endif\n+\n+#ifdef L_modhi3\n+\t.text\n+\t.globl ___modhi3\n+\t.type ___modhi3,@function\n+___modhi3:\n+\tjsr ___divhi3\n+\tmov d1,d0\n+\trts\n+\t.size ___modhi3,.-___modhi3\n+#endif\n+\n+#ifdef L_addsi3\n+\t.text\n+\t.globl ___addsi3\n+\t.type  ___addsi3,@function\n+___addsi3:\n+\tadd -4,a3\n+\tmovx d2,(0,a3)\n+\tmov (8,a3),d2\n+\tadd d2,d0\n+\tmov (10,a3),d2\n+\taddc d2,d1\n+\tmovx (0,a3),d2\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___addsi3,.-___addsi3\n+#endif\n+\n+#ifdef L_subsi3\n+\t.text\n+\t.globl ___subsi3\n+\t.type  ___subsi3,@function\n+___subsi3:\n+\tadd -4,a3\n+\tmovx d2,(0,a3)\n+\tmov (8,a3),d2\n+\tsub d2,d0\n+\tmov (10,a3),d2\n+\tsubc d2,d1\n+\tmovx (0,a3),d2\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___subsi3,.-___subsi3\n+#endif\n+\n+#ifdef L_mulsi3\n+\t.text\n+\t.globl ___mulsi3\n+\t.type  ___mulsi3,@function\n+___mulsi3:\n+\tadd -4,a3\n+\tmov a1,(0,a3)\n+\tmov d0,a0\n+\t/* Multiply arg0 msb with arg1 lsb.\n+\t   arg0 msb is in register d1,\n+\t   arg1 lsb is in memory.  */\n+\tmov (8,a3),d0\n+\tmulu d0,d1\n+\tmov d1,a1\n+\n+\t/* Multiply arg0 lsb with arg1 msb.\n+\t   arg0 msb is in register a0,\n+\t   arg1 lsb is in memory.  */\n+\tmov a0,d0\n+\tmov (10,a3),d1\n+\tmulu d0,d1\n+\n+\t/* Add the cross products.  */\n+\tadd d1,a1\n+\n+\t/* Now multiply arg0 lsb with arg1 lsb.  */\n+\tmov (8,a3),d1\n+\tmulu d1,d0\n+\n+\t/* Add in the upper 16 bits to the cross product sum.  */\n+\tmov mdr,d1\n+\tadd a1,d1\n+\tmov (0,a3),a1\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___mulsi3,.-___mulsi3\n+#endif\n+\n+#ifdef  L_ashlsi3\n+\t.text\n+\t.globl ___ashlsi3\n+\t.type  ___ashlsi3,@function\n+___ashlsi3:\n+\tmov (4,a3),a0\n+\tcmp 0,a0\n+\tbeq .L0\n+.L1:\n+\tadd d0,d0\n+\taddc d1,d1\n+\tadd -1,a0\n+\tbne .L1\n+.L0:\n+\trts\n+\n+\t.size ___ashlsi3,.-___ashlsi3\n+#endif\n+\n+#ifdef  L_lshrsi3\n+\t.text\n+\t.globl ___lshrsi3\n+\t.type  ___lshrsi3,@function\n+___lshrsi3:\n+\tmov (4,a3),a0\n+\tcmp 0,a0\n+\tbeq .L0\n+.L1:\n+\tlsr d1\n+\tror d0\n+\tadd -1,a0\n+\tbne .L1\n+.L0:\n+\trts\n+\n+\t.size ___lshrsi3,.-___lshrsi3\n+#endif\n+\n+#ifdef  L_ashrsi3\n+\t.text\n+\t.globl ___ashrsi3\n+\t.type  ___ashrsi3,@function\n+___ashrsi3:\n+\tmov (4,a3),a0\n+\tcmp 0,a0\n+\tbeq .L0\n+.L1:\n+\tasr d1\n+\tror d0\n+\tadd -1,a0\n+\tbne .L1\n+.L0:\n+\trts\n+\n+\t.size ___ashrsi3,.-___ashrsi3\n+#endif\n+\n+/* All functions beyond this point pass their arguments in registers! */\n+#ifdef  L_negsi2_d0\n+\t.text\n+\t.globl ___negsi2_d0\n+\t.type  ___negsi2_d0,@function\n+___negsi2_d0:\n+\tadd -8,a3\n+\tmovx d3,(0,a3)\n+\tmovx d2,(4,a3)\n+\tmov d0,d2\n+\tmov d1,d3\n+\tsub d0,d0\n+\tsub d1,d1\n+\tsub d2,d0\n+\tsubc d3,d1\n+\tmovx (0,a3),d3\n+\tmovx (4,a3),d2\n+\tadd 8,a3\n+\trts\n+\n+\t.size ___negsi2_d0,.-___negsi2_d0\n+#endif\n+\n+#ifdef  L_negsi2_d2\n+\t.text\n+\t.globl ___negsi2_d2\n+\t.type  ___negsi2_d2,@function\n+___negsi2_d2:\n+\tadd -8,a3\n+\tmovx d1,(0,a3)\n+\tmovx d0,(4,a3)\n+\tmov d2,d0\n+\tmov d3,d1\n+\tsub d2,d2\n+\tsub d3,d3\n+\tsub d0,d2\n+\tsubc d1,d3\n+\tmovx (0,a3),d1\n+\tmovx (4,a3),d0\n+\tadd 8,a3\n+\trts\n+\n+\t.size ___negsi2_d2,.-___negsi2_d2\n+#endif\n+\n+#ifdef  L_zero_extendpsisi2_d0\n+\t.text\n+\t.globl ___zero_extendpsisi2_d0\n+\t.type  ___zero_extendpsisi2_d0,@function\n+___zero_extendpsisi2_d0:\n+\tadd -4,a3\n+\tmovx d0,(0,a3)\n+\tmovbu (2,a3),d1\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___zero_extendpsisi2_d0,.-___zero_extendpsisi2_d0\n+#endif\n+\n+#ifdef  L_zero_extendpsisi2_d2\n+\t.text\n+\t.globl ___zero_extendpsisi2_d2\n+\t.type  ___zero_extendpsisi2_d2,@function\n+___zero_extendpsisi2_d2:\n+\tadd -4,a3\n+\tmovx d2,(0,a3)\n+\tmovbu (2,a3),d3\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___zero_extendpsisi2_d2,.-___zero_extendpsisi2_d2\n+#endif\n+\n+#ifdef  L_sign_extendpsisi2_d0\n+\t.text\n+\t.globl ___sign_extendpsisi2_d0\n+\t.type  ___sign_extendpsisi2_d0,@function\n+___sign_extendpsisi2_d0:\n+\tadd -4,a3\n+\tmovx d0,(0,a3)\n+\tmovb (2,a3),d1\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___sign_extendpsisi2_d0,.-___sign_extendpsisi2_d0\n+#endif\n+\n+#ifdef  L_sign_extendpsisi2_d2\n+\t.text\n+\t.globl ___sign_extendpsisi2_d2\n+\t.type  ___sign_extendpsisi2_d2,@function\n+___sign_extendpsisi2_d2:\n+\tadd -4,a3\n+\tmovx d2,(0,a3)\n+\tmovb (2,a3),d3\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___sign_extendpsisi2_d2,.-___sign_extendpsisi2_d2\n+#endif\n+\n+#ifdef  L_truncsipsi2_d0_d0\n+\t.text\n+\t.globl ___truncsipsi2_d0_d0\n+\t.type  ___truncsipsi2_d0_d0,@function\n+___truncsipsi2_d0_d0:\n+\tadd -4,a3\n+\tmov d0,(a3)\n+\tmov d1,(2,a3)\n+\tmovx (0,a3),d0\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d0_d0,.-___truncsipsi2_d0_d0\n+#endif\n+\n+#ifdef  L_truncsipsi2_d0_d1\n+\t.text\n+\t.globl ___truncsipsi2_d0_d1\n+\t.type  ___truncsipsi2_d0_d1,@function\n+___truncsipsi2_d0_d1:\n+\tadd -4,a3\n+\tmov d0,(a3)\n+\tmov d1,(2,a3)\n+\tmovx (0,a3),d1\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d0_d1,.-___truncsipsi2_d0_d1\n+#endif\n+\n+#ifdef  L_truncsipsi2_d0_d2\n+\t.text\n+\t.globl ___truncsipsi2_d0_d2\n+\t.type  ___truncsipsi2_d0_d2,@function\n+___truncsipsi2_d0_d2:\n+\tadd -4,a3\n+\tmov d0,(a3)\n+\tmov d1,(2,a3)\n+\tmovx (0,a3),d2\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d0_d2,.-___truncsipsi2_d0_d2\n+#endif\n+\n+#ifdef  L_truncsipsi2_d0_d3\n+\t.text\n+\t.globl ___truncsipsi2_d0_d3\n+\t.type  ___truncsipsi2_d0_d3,@function\n+___truncsipsi2_d0_d3:\n+\tadd -4,a3\n+\tmov d0,(a3)\n+\tmov d1,(2,a3)\n+\tmovx (0,a3),d3\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d0_d3,.-___truncsipsi2_d0_d3\n+#endif\n+\n+#ifdef  L_truncsipsi2_d2_d0\n+\t.text\n+\t.globl ___truncsipsi2_d2_d0\n+\t.type  ___truncsipsi2_d2_d0,@function\n+___truncsipsi2_d2_d0:\n+\tadd -4,a3\n+\tmov d2,(a3)\n+\tmov d3,(2,a3)\n+\tmovx (0,a3),d0\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d2_d0,.-___truncsipsi2_d2_d0\n+#endif\n+\n+#ifdef  L_truncsipsi2_d2_d1\n+\t.text\n+\t.globl ___truncsipsi2_d2_d1\n+\t.type  ___truncsipsi2_d2_d1,@function\n+___truncsipsi2_d2_d1:\n+\tadd -4,a3\n+\tmov d2,(a3)\n+\tmov d3,(2,a3)\n+\tmovx (0,a3),d1\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d2_d1,.-___truncsipsi2_d2_d1\n+#endif\n+\n+#ifdef  L_truncsipsi2_d2_d2\n+\t.text\n+\t.globl ___truncsipsi2_d2_d2\n+\t.type  ___truncsipsi2_d2_d2,@function\n+___truncsipsi2_d2_d2:\n+\tadd -4,a3\n+\tmov d2,(a3)\n+\tmov d3,(2,a3)\n+\tmovx (0,a3),d2\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d2_d2,.-___truncsipsi2_d2_d2\n+#endif\n+\n+#ifdef  L_truncsipsi2_d2_d3\n+\t.text\n+\t.globl ___truncsipsi2_d2_d3\n+\t.type  ___truncsipsi2_d2_d3,@function\n+___truncsipsi2_d2_d3:\n+\tadd -4,a3\n+\tmov d2,(a3)\n+\tmov d3,(2,a3)\n+\tmovx (0,a3),d3\n+\tadd 4,a3\n+\trts\n+\n+\t.size ___truncsipsi2_d2_d3,.-___truncsipsi2_d2_d3\n+#endif\n+\n+\n+#ifdef  L_cmpsi2\n+\t.text\n+\t.globl ___cmpsi2\n+\t.type  ___cmpsi2,@function\n+___cmpsi2:\n+\tadd -4,a3\n+\tmov a1,(0,a3)\n+        mov (10,a3),a1\n+        mov (8,a3),a0\n+        cmp a1,d1\n+        blt .L9\n+        bgt .L6\n+        cmp a0,d0\n+        bcc .L5\n+.L9:\n+        sub d0,d0\n+        jmp .L8\n+.L5:\n+        cmp a0,d0\n+        bhi .L6\n+        mov 1,d0\n+        jmp .L8\n+.L6:\n+        mov 2,d0\n+.L8:\n+\tmov (0,a3),a1\n+\tadd 4,a3\n+        rts\n+\t.size ___cmpsi2,.-___cmpsi2\n+#endif\n+\n+#ifdef  L_ucmpsi2\n+\t.text\n+\t.globl ___ucmpsi2\n+\t.type  ___ucmpsi2,@function\n+___ucmpsi2:\n+\tadd -4,a3\n+\tmov a1,(0,a3)\n+        mov (10,a3),a1\n+        mov (8,a3),a0\n+        cmp a1,d1\n+        bcs .L9\n+        bhi .L6\n+        cmp a0,d0\n+        bcc .L5\n+.L9:\n+        sub d0,d0\n+        jmp .L8\n+.L5:\n+        cmp a0,d0\n+        bhi .L6\n+        mov 1,d0\n+        jmp .L8\n+.L6:\n+        mov 2,d0\n+.L8:\n+\tmov (0,a3),a1\n+\tadd 4,a3\n+        rts\n+\t.size ___ucmpsi2,.-___ucmpsi2\n+#endif\n+\n+\n+#ifdef L_prologue\n+\t.text\n+\t.globl ___prologue\n+\t.type ___prologue,@function\n+___prologue:\n+\tmov (0,a3),a0\n+\tadd -16,a3\n+\tmovx d2,(4,a3)\n+\tmovx d3,(8,a3)\n+\tmov a1,(12,a3)\n+\tmov a2,(16,a3)\n+\tmov a0,(0,a3)\n+\trts\n+\t.size ___prologue,.-___prologue\n+#endif\n+\n+#ifdef L_epilogue_a0\n+\t.text\n+\t.globl ___epilogue_a0\n+\t.type ___epilogue_a0,@function\n+___epilogue_a0:\n+\tmov (0,a3),a0\n+\tmovx (4,a3),d2\n+\tmovx (8,a3),d3\n+\tmov (12,a3),a1\n+\tmov (16,a3),a2\n+\tadd 16,a3\n+\tmov a0,(0,a3)\n+\trts\n+\t.size ___epilogue_a0,.-___epilogue_a0\n+#endif\n+\n+#ifdef L_epilogue_d0\n+\t.text\n+\t.globl ___epilogue_d0\n+\t.type ___epilogue_d0,@function\n+___epilogue_d0:\n+\tmovx (0,a3),d0\n+\tmovx (4,a3),d2\n+\tmovx (8,a3),d3\n+\tmov (12,a3),a1\n+\tmov (16,a3),a2\n+\tadd 16,a3\n+\tmovx d0,(0,a3)\n+\trts\n+\t.size ___epilogue_d0,.-___epilogue_d0\n+#endif\n+\n+#ifdef L_epilogue_noreturn\n+\t.text\n+\t.globl ___epilogue_noreturn\n+\t.type ___epilogue_noreturn,@function\n+___epilogue_noreturn:\n+\tmovx (0,a3),d2\n+\tmovx (4,a3),d3\n+\tmov (8,a3),a1\n+\tmov (12,a3),a2\n+\tadd 16,a3\n+\trts\n+\t.size ___epilogue_noreturn,.-___epilogue_noreturn\n+#endif"}, {"sha": "6c929c81136463848b675e8b1086640a913b504c", "filename": "gcc/config/mn10200/mn10200.c", "status": "added", "additions": 1542, "deletions": 0, "changes": 1542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,1542 @@\n+/* Subroutines for insn-output.c for Matsushita MN10200 series\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"tree.h\"\n+#include \"obstack.h\"\n+\n+/* Global registers known to hold the value zero.\n+\n+   Normally we'd depend on CSE and combine to put zero into a\n+   register and re-use it.\n+\n+   However, on the mn10x00 processors we implicitly use the constant\n+   zero in tst instructions, so we might be able to do better by\n+   loading the value into a register in the prologue, then re-useing\n+   that register throughout the function.\n+\n+   We could perform similar optimizations for other constants, but with\n+   gcse due soon, it doesn't seem worth the effort.\n+\n+   These variables hold a rtx for a register known to hold the value\n+   zero throughout the entire function, or NULL if no register of\n+   the appropriate class has such a value throughout the life of the\n+   function.  */\n+rtx zero_dreg;\n+rtx zero_areg;\n+\n+/* Note whether or not we need an out of line epilogue.  */\n+static int out_of_line_epilogue;\n+\n+/* Indicate this file was compiled by gcc and what optimization\n+   level was used.  */\n+void\n+asm_file_start (file)\n+     FILE *file;\n+{\n+  fprintf (file, \"#\\tGCC For the Matsushita MN10200\\n\");\n+  if (optimize)\n+    fprintf (file, \"# -O%d\\n\", optimize);\n+  else\n+    fprintf (file, \"\\n\\n\");\n+  output_file_directive (file, main_input_filename);\n+}\n+\n+/* Print operand X using operand code CODE to assembly language output file\n+   FILE.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+      case 'b':\n+      case 'B':\n+\t/* These are normal and reversed branches.  */\n+\tswitch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n+\t  {\n+\t  case NE:\n+\t    fprintf (file, \"ne\");\n+\t    break;\n+\t  case EQ:\n+\t    fprintf (file, \"eq\");\n+\t    break;\n+\t  case GE:\n+\t    fprintf (file, \"ge\");\n+\t    break;\n+\t  case GT:\n+\t    fprintf (file, \"gt\");\n+\t    break;\n+\t  case LE:\n+\t    fprintf (file, \"le\");\n+\t    break;\n+\t  case LT:\n+\t    fprintf (file, \"lt\");\n+\t    break;\n+\t  case GEU:\n+\t    fprintf (file, \"cc\");\n+\t    break;\n+\t  case GTU:\n+\t    fprintf (file, \"hi\");\n+\t    break;\n+\t  case LEU:\n+\t    fprintf (file, \"ls\");\n+\t    break;\n+\t  case LTU:\n+\t    fprintf (file, \"cs\");\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+      case 'C':\n+\t/* This is used for the operand to a call instruction;\n+\t   if it's a REG, enclose it in parens, else output\n+\t   the operand normally.  */\n+\tif (GET_CODE (x) == REG)\n+\t  {\n+\t    fputc ('(', file);\n+\t    print_operand (file, x, 0);\n+\t    fputc (')', file);\n+\t  }\n+\telse\n+\t  print_operand (file, x, 0);\n+\tbreak;\n+     \n+      /* These are the least significant word in a 32bit value.\n+\t 'o' allows us to sign extend a constant if doing so\n+\t makes for more compact code.  */\n+      case 'L':\n+      case 'o':\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t    break;\n+\n+\t  case SUBREG:\n+\t    fprintf (file, \"%s\",\n+\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    break;\n+\n+\t  case CONST_DOUBLE:\n+\t    if (code == 'L')\n+\t      {\n+\t\tlong val;\n+\t\tREAL_VALUE_TYPE rv;\n+\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\t\tprint_operand_address (file, GEN_INT (val & 0xffff));\n+\t      }\n+\t    else\n+\t      {\n+\t\tlong val;\n+\t\tREAL_VALUE_TYPE rv;\n+\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\n+\t\tval &= 0xffff;\n+\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n+\t\tprint_operand_address (file, GEN_INT (val));\n+\t      }\n+\t    break;\n+\n+\t  case CONST_INT:\n+\t    if (code == 'L')\n+\t      print_operand_address (file, GEN_INT ((INTVAL (x) & 0xffff)));\n+\t    else\n+\t      {\n+\t        unsigned int val = INTVAL (x) & 0xffff;\n+\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n+\t\tprint_operand_address (file, GEN_INT (val));\n+\t      }\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      /* Similarly, but for the most significant word.  */\n+      case 'H':\n+      case 'h':\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    x = adj_offsettable_operand (x, 2);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+\t    break;\n+\n+\t  case SUBREG:\n+\t    fprintf (file, \"%s\",\n+\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)] + 1);\n+\t    break;\n+\n+\t  case CONST_DOUBLE:\n+\t    if (code == 'H')\n+\t      {\n+\t\tlong val;\n+\t\tREAL_VALUE_TYPE rv;\n+\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\n+\t\tprint_operand_address (file, GEN_INT ((val >> 16) & 0xffff));\n+\t      }\n+\t    else\n+\t      {\n+\t\tlong val;\n+\t\tREAL_VALUE_TYPE rv;\n+\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n+\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\n+\t\tval = (val >> 16) & 0xffff;\n+\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n+\n+\t\tprint_operand_address (file, GEN_INT (val));\n+\t      }\n+\t    break;\n+\n+\t  case CONST_INT:\n+\t    if (code == 'H')\n+\t      print_operand_address (file,\n+\t\t\t\t     GEN_INT ((INTVAL (x) >> 16) & 0xffff));\n+\t    else\n+\t      {\n+\t        unsigned int val = (INTVAL (x) >> 16) & 0xffff;\n+\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n+\n+\t\tprint_operand_address (file, GEN_INT (val));\n+\t      }\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n+      /* Output ~CONST_INT.  */\n+      case 'N':\n+\tif (GET_CODE (x) != CONST_INT)\n+\t  abort ();\n+        fprintf (file, \"%d\", ~INTVAL (x));\n+        break;\n+\n+      /* An address which can not be register indirect, if it is\n+\t register indirect, then turn it into reg + disp.  */\n+      case 'A':\n+\tif (GET_CODE (x) != MEM)\n+\t  abort ();\n+\tif (GET_CODE (XEXP (x, 0)) == REG)\n+\t  x = gen_rtx (PLUS, PSImode, XEXP (x, 0), GEN_INT (0));\n+\telse\n+\t  x = XEXP (x, 0);\n+\tfputc ('(', file);\n+\toutput_address (x);\n+\tfputc (')', file);\n+\tbreak;\n+\n+      case 'Z':\n+        print_operand (file, XEXP (x, 1), 0);\n+\tbreak;\n+\n+      /* More cases where we can sign-extend a CONST_INT if it\n+\t results in more compact code.  */\n+      case 's':\n+      case 'S':\n+\tif (GET_CODE (x) == CONST_INT)\n+\t  {\n+\t    int val = INTVAL (x);\n+\n+\t    if (code == 's')\n+\t      x = GEN_INT (((val & 0xffff) ^ (~0x7fff)) + 0x8000);\n+\t    else\n+\t      x = GEN_INT (((val & 0xff) ^ (~0x7f)) + 0x80);\n+\t  }\n+        /* FALL THROUGH */\n+      default:\n+\tswitch (GET_CODE (x))\n+\t  {\n+\t  case MEM:\n+\t    fputc ('(', file);\n+\t    output_address (XEXP (x, 0));\n+\t    fputc (')', file);\n+\t    break;\n+\n+\t  case REG:\n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t    break;\n+\n+\t  case SUBREG:\n+\t    fprintf (file, \"%s\",\n+\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    break;\n+\n+\t  case CONST_INT:\n+\t  case CONST_DOUBLE:\n+\t  case SYMBOL_REF:\n+\t  case CONST:\n+\t  case LABEL_REF:\n+\t  case CODE_LABEL:\n+\t    print_operand_address (file, x);\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+   }\n+}\n+\n+/* Output assembly language output for the address ADDR to FILE.  */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      print_operand (file, addr, 0);\n+      break;\n+    case PLUS:\n+      {\n+\trtx base, index;\n+\t/* The base and index could be in any order, so we have\n+\t   to figure out which is the base and which is the index.\n+\t   Uses the same code as GO_IF_LEGITIMATE_ADDRESS.  */\n+\tif (REG_P (XEXP (addr, 0))\n+\t    && REG_OK_FOR_BASE_P (XEXP (addr, 0)))\n+\t  base = XEXP (addr, 0), index = XEXP (addr, 1);\n+\telse if (REG_P (XEXP (addr, 1))\n+\t    && REG_OK_FOR_BASE_P (XEXP (addr, 1)))\n+\t  base = XEXP (addr, 1), index = XEXP (addr, 0);\n+      \telse\n+\t  abort ();\n+\tprint_operand (file, index, 0);\n+\tfputc (',', file);\n+\tprint_operand (file, base, 0);;\n+\tbreak;\n+      }\n+    case SYMBOL_REF:\n+      output_addr_const (file, addr);\n+      break;\n+    default:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+/* Count the number of tst insns which compare an address register\n+   with zero.  */\n+static void \n+count_tst_insns (areg_countp)\n+     int *areg_countp;\n+{\n+  rtx insn;\n+\n+  /* Assume no tst insns exist.  */\n+  *areg_countp = 0;\n+\n+  /* If not optimizing, then quit now.  */\n+  if (!optimize)\n+    return;\n+\n+  /* Walk through all the insns.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      /* Ignore anything that is not a normal INSN.  */\n+      if (GET_CODE (insn) != INSN)\n+\tcontinue;\n+\n+      /* Ignore anything that isn't a SET.  */\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) != SET)\n+\tcontinue;\n+\n+      /* Check for a tst insn.  */\n+      if (SET_DEST (pat) == cc0_rtx\n+\t  && GET_CODE (SET_SRC (pat)) == REG\n+\t  && REGNO_REG_CLASS (REGNO (SET_SRC (pat))) == ADDRESS_REGS)\n+\t(*areg_countp)++;\n+    }\n+}\n+\n+/* Return the total size (in bytes) of the current function's frame.\n+   This is the size of the register save area + the size of locals,\n+   spills, etc.  */\n+int\n+total_frame_size ()\n+{\n+  unsigned int size = get_frame_size ();\n+  unsigned int outgoing_args_size = current_function_outgoing_args_size;\n+  int i;\n+\n+  /* First figure out if we're going to use an out of line\n+     prologue, if so we have to make space for all the\n+     registers, even if we don't use them.  */\n+  if (optimize && !current_function_needs_context && !frame_pointer_needed)\n+    {\n+      int inline_count, outline_count;\n+\n+      /* Compute how many bytes an inline prologue would take.\n+\n+         Each address register store takes two bytes, each data register\n+\t store takes three bytes.  */\n+      inline_count = 0;\n+      if (regs_ever_live[5])\n+\tinline_count += 2;\n+      if (regs_ever_live[6])\n+\tinline_count += 2;\n+      if (regs_ever_live[2])\n+\tinline_count += 3;\n+      if (regs_ever_live[3])\n+\tinline_count += 3;\n+\n+      /* If this function has any stack, then the stack adjustment\n+\t will take two (or more) bytes.  */\n+      if (size || outgoing_args_size\n+\t  || regs_ever_live[5] || regs_ever_live[6]\n+\t  || regs_ever_live[2] || regs_ever_live[3])\n+      inline_count += 2;\n+\n+      /* Multiply the current count by two and add one to account for the\n+\t epilogue insns.  */\n+      inline_count = inline_count * 2 + 1;\n+    \n+      /* Now compute how many bytes an out of line sequence would take.  */\n+      /* A relaxed jsr will be three bytes.  */\n+      outline_count = 3;\n+\n+      /* If there are outgoing arguments, then we will need a stack\n+\t pointer adjustment after the call to the prologue, two\n+\t more bytes.  */\n+      outline_count += (outgoing_args_size == 0 ? 0 : 2);\n+\n+      /* If there is some local frame to allocate, it will need to be\n+\t done before the call to the prologue, two more bytes.  */\n+      if (get_frame_size () != 0)\n+\toutline_count += 2;\n+\n+      /* Now account for the epilogue, multiply the base count by two,\n+\t then deal with optimizing away the rts instruction.  */\n+      outline_count = outline_count * 2 + 1;\n+\n+      if (get_frame_size () == 0 && outgoing_args_size == 0)\n+\toutline_count -= 1;\n+\n+      /* If an out of line prologue is smaller, use it.  */\n+      if (inline_count > outline_count)\n+\treturn size + outgoing_args_size + 16;\n+    }\n+\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && !call_used_regs[i] && ! fixed_regs[i]\n+\t  || (i == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\tsize += 4;\n+    }\n+\n+  return (size + outgoing_args_size);\n+}\n+\n+/* Expand the prologue into RTL.  */\n+void\n+expand_prologue ()\n+{\n+  unsigned int size = total_frame_size ();\n+  unsigned int outgoing_args_size = current_function_outgoing_args_size;\n+  int offset, i;\n+\n+  zero_areg = NULL_RTX;\n+  zero_dreg = NULL_RTX;\n+\n+  /* If optimizing, see if we should do an out of line prologue/epilogue\n+     sequence.\n+\n+     We don't support out of line prologues if the current function\n+     needs a context or frame pointer.  */\n+  if (optimize && !current_function_needs_context && !frame_pointer_needed)\n+    {\n+      int inline_count, outline_count, areg_count;\n+\n+      /* We need to end the current sequence so that count_tst_insns can\n+\t look at all the insns in this function.  Normally this would be\n+\t unsafe, but it's OK in the prologue/epilogue expanders.  */\n+      end_sequence ();\n+\n+      /* Get a count of the number of tst insns which use address\n+\t registers (it's not profitable to try and improve tst insns\n+\t which use data registers).  */\n+      count_tst_insns (&areg_count);\n+\n+      /* Now start a new sequence.  */\n+      start_sequence ();\n+\n+      /* Compute how many bytes an inline prologue would take.\n+\n+         Each address register store takes two bytes, each data register\n+\t store takes three bytes.  */\n+      inline_count = 0;\n+      if (regs_ever_live[5])\n+\tinline_count += 2;\n+      if (regs_ever_live[6])\n+\tinline_count += 2;\n+      if (regs_ever_live[2])\n+\tinline_count += 3;\n+      if (regs_ever_live[3])\n+\tinline_count += 3;\n+\n+      /* If this function has any stack, then the stack adjustment\n+\t will take two (or more) bytes.  */\n+      if (size || outgoing_args_size\n+\t  || regs_ever_live[5] || regs_ever_live[6]\n+\t  || regs_ever_live[2] || regs_ever_live[3])\n+      inline_count += 2;\n+\n+      /* Multiply the current count by two and add one to account for the\n+\t epilogue insns.  */\n+      inline_count = inline_count * 2 + 1;\n+    \n+      /* Now compute how many bytes an out of line sequence would take.  */\n+      /* A relaxed jsr will be three bytes.  */\n+      outline_count = 3;\n+\n+      /* If there are outgoing arguments, then we will need a stack\n+\t pointer adjustment after the call to the prologue, two\n+\t more bytes.  */\n+      outline_count += (outgoing_args_size == 0 ? 0 : 2);\n+\n+      /* If there is some local frame to allocate, it will need to be\n+\t done before the call to the prologue, two more bytes.  */\n+      if (get_frame_size () != 0)\n+\toutline_count += 2;\n+\n+      /* Now account for the epilogue, multiply the base count by two,\n+\t then deal with optimizing away the rts instruction.  */\n+      outline_count = outline_count * 2 + 1;\n+\n+      if (get_frame_size () == 0 && outgoing_args_size == 0)\n+\toutline_count -= 1;\n+     \n+      /* If an out of line prologue is smaller, use it.  */\n+      if (inline_count > outline_count)\n+\t{\n+\t  if (get_frame_size () != 0)\n+\t    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-size + outgoing_args_size + 16)));\n+\t  emit_insn (gen_outline_prologue_call ());\n+\n+\t  if (outgoing_args_size)\n+\t    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-outgoing_args_size)));\n+\t\n+\t  out_of_line_epilogue = 1;\n+\n+\t  /* Determine if it is profitable to put the value zero into a register\n+\t     for the entire function.  If so, set ZERO_DREG and ZERO_AREG.  */\n+\n+\t  /* First see if we could load the value into a data register\n+\t     since that's the most efficient way.  */\n+\t  if (areg_count > 1\n+\t      && (!regs_ever_live[2] || !regs_ever_live[3]))\n+\t    {\n+\t      if (!regs_ever_live[2])\n+\t\t{\n+\t\t  regs_ever_live[2] = 1;\n+\t\t  zero_dreg = gen_rtx (REG, HImode, 2);\n+\t\t}\n+\t      if (!regs_ever_live[3])\n+\t\t{\n+\t\t  regs_ever_live[3] = 1;\n+\t\t  zero_dreg = gen_rtx (REG, HImode, 3);\n+\t\t}\n+\t    }\n+\n+\t  /* Now see if we could load the value into a address register.  */\n+\t  if (zero_dreg == NULL_RTX\n+\t      && areg_count > 2\n+\t      && (!regs_ever_live[5] || !regs_ever_live[6]))\n+\t    {\n+\t      if (!regs_ever_live[5])\n+\t\t{\n+\t\t  regs_ever_live[5] = 1;\n+\t\t  zero_dreg = gen_rtx (REG, HImode, 5);\n+\t\t}\n+\t      if (!regs_ever_live[6])\n+\t\t{\n+\t\t  regs_ever_live[6] = 1;\n+\t\t  zero_dreg = gen_rtx (REG, HImode, 6);\n+\t\t}\n+\t    }\n+\n+\t  if (zero_dreg)\n+\t    emit_move_insn (zero_dreg, const0_rtx);\n+\n+\t  if (zero_areg)\n+\t    emit_move_insn (zero_areg, const0_rtx);\n+\n+\t  return;\n+\t}\n+    }\n+\n+  out_of_line_epilogue = 0;\n+\n+  /* Temporarily stuff the static chain onto the stack so we can\n+     use a0 as a scratch register during the prologue.  */\n+  if (current_function_needs_context)\n+    {\n+      emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t      GEN_INT (-4)));\n+      emit_move_insn (gen_rtx (MEM, PSImode, stack_pointer_rtx),\n+\t\t      gen_rtx (REG, PSImode, STATIC_CHAIN_REGNUM));\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Store a2 into a0 temporarily.  */\n+      emit_move_insn (gen_rtx (REG, PSImode, 4), frame_pointer_rtx);\n+\n+      /* Set up the frame pointer.  */\n+      emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+    }\n+\n+  /* Make any necessary space for the saved registers and local frame.  */\n+  if (size)\n+    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t    GEN_INT (-size)));\n+\n+  /* Save the callee saved registers.  They're saved into the top\n+     of the frame, using the stack pointer.  */\n+  for (i = 0, offset = outgoing_args_size;\n+       i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && !call_used_regs[i] && ! fixed_regs[i]\n+\t  || (i == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\t{\n+\t  int regno;\n+\n+\t  /* If we're saving the frame pointer, then it will be found in\n+\t     register 4 (a0).  */\n+\t  regno = (i == FRAME_POINTER_REGNUM && frame_pointer_needed) ? 4 : i;\n+\t\n+\t  emit_move_insn (gen_rtx (MEM, PSImode,\n+\t\t\t\t   gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t\t    GEN_INT (offset))),\n+\t\t\t  gen_rtx (REG, PSImode, regno));\n+\t  offset += 4;\n+\t}\n+    }\n+\n+  /* Now put the static chain back where the rest of the function\n+     expects to find it.  */\n+  if (current_function_needs_context)\n+    {\n+      emit_move_insn (gen_rtx (REG, PSImode, STATIC_CHAIN_REGNUM),\n+\t\t      gen_rtx (MEM, PSImode,\n+\t\t\t       gen_rtx (PLUS, PSImode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (size))));\n+    }\n+}\n+\n+/* Expand the epilogue into RTL.  */\n+void\n+expand_epilogue ()\n+{\n+  unsigned int size;\n+  unsigned int outgoing_args_size = current_function_outgoing_args_size;\n+  int offset, i, temp_regno;\n+  rtx basereg;\n+\n+  size = total_frame_size ();\n+\n+  if (DECL_RESULT (current_function_decl)\n+      && DECL_RTL (DECL_RESULT (current_function_decl))\n+      && REG_P (DECL_RTL (DECL_RESULT (current_function_decl))))\n+    temp_regno = (REGNO (DECL_RTL (DECL_RESULT (current_function_decl))) == 4\n+\t\t  ? 0 : 4);\n+  else\n+    temp_regno = 4;\n+\n+  /* Emit an out of line epilogue sequence if it's profitable to do so.  */\n+  if (out_of_line_epilogue)\n+    {\n+      /* If there were no outgoing arguments and no local frame, then\n+\t we will be able to omit the rts at the end of this function,\n+\t so just jump to the epilogue_noreturn routine.  */\n+      if (get_frame_size () == 0 && outgoing_args_size == 0)\n+\t{\n+\t  emit_jump_insn (gen_outline_epilogue_jump ());\n+\t  return;\n+\t}\n+\n+      if (outgoing_args_size)\n+\temit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\tGEN_INT (outgoing_args_size)));\n+\n+      if (temp_regno == 0)\n+\temit_insn (gen_outline_epilogue_call_d0 ());\n+      else if (temp_regno == 4)\n+\temit_insn (gen_outline_epilogue_call_a0 ());\n+\n+      if (get_frame_size () != 0)\n+\temit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\tGEN_INT (size - outgoing_args_size - 16)));\n+      emit_jump_insn (gen_return_internal ());\n+      return;\n+    }\n+\n+  /* Registers are restored from the frame pointer if we have one,\n+     else they're restored from the stack pointer.  Figure out\n+     the appropriate offset to the register save area for both cases.  */\n+  if (frame_pointer_needed)\n+    {\n+      basereg = frame_pointer_rtx;\n+      offset = -(size - outgoing_args_size);\n+    }\n+  else\n+    {\n+      basereg = stack_pointer_rtx;\n+      offset = outgoing_args_size;\n+    }\n+\n+  /* Restore each register.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && !call_used_regs[i] && ! fixed_regs[i]\n+\t  || (i == FRAME_POINTER_REGNUM && frame_pointer_needed))\n+\t{\n+\t  int regno;\n+\n+\t  /* Restore the frame pointer (if it exists) into a temporary\n+\t     register.  */\n+\t  regno = ((i == FRAME_POINTER_REGNUM && frame_pointer_needed)\n+\t\t   ? temp_regno : i);\n+\t\n+\t  emit_move_insn (gen_rtx (REG, PSImode, regno),\n+\t\t\t  gen_rtx (MEM, PSImode,\n+\t\t\t\t   gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t    basereg,\n+\t\t\t\t\t    GEN_INT (offset))));\n+\t  offset += 4;\n+\t}\n+    }\n+\n+  if (frame_pointer_needed)\n+    {\n+      /* Deallocate this frame's stack.  */\n+      emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+      /* Restore the old frame pointer.  */\n+      emit_move_insn (frame_pointer_rtx, gen_rtx (REG, PSImode, temp_regno));\n+    }\n+  else if (size)\n+    {\n+      /* Deallocate this function's stack.  */\n+      emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t      GEN_INT (size)));\n+    }\n+\n+  /* If we had to allocate a slot to save the context pointer,\n+     then it must be deallocated here.  */\n+  if (current_function_needs_context)\n+    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (4)));\n+\n+  /* Emit the return insn, if this function had no stack, then we\n+     can use the standard return (which allows more optimizations),\n+     else we have to use the special one which inhibits optimizations.  */\n+  if (size == 0 && !current_function_needs_context)\n+    emit_jump_insn (gen_return ());\n+  else\n+    emit_jump_insn (gen_return_internal ());\n+}\n+\n+/* Update the condition code from the insn.  */\n+\n+void\n+notice_update_cc (body, insn)\n+     rtx body;\n+     rtx insn;\n+{\n+  switch (get_attr_cc (insn))\n+    {\n+    case CC_NONE:\n+      /* Insn does not affect CC at all.  */\n+      break;\n+\n+    case CC_NONE_0HIT:\n+      /* Insn does not change CC, but the 0'th operand has been changed.  */\n+      if (cc_status.value1 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\tcc_status.value1 = 0;\n+      break;\n+\n+    case CC_SET_ZN:\n+      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+\t V,C is in an unusable state.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+    case CC_SET_ZNV:\n+      /* Insn sets the Z,N,V flags of CC to recog_operand[0].\n+\t C is in an unusable state.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_NO_CARRY;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+    case CC_COMPARE:\n+      /* The insn is a compare instruction.  */\n+      CC_STATUS_INIT;\n+      cc_status.value1 = SET_SRC (body);\n+      break;\n+\n+    case CC_CLOBBER:\n+      /* Insn doesn't leave CC in a usable state.  */\n+      CC_STATUS_INIT;\n+      break;\n+\n+    default:\n+      CC_STATUS_INIT;\n+      break;\n+    }\n+}\n+\n+/* Return true if OP is a valid call operand.  Valid call operands\n+   are SYMBOL_REFs and REGs.  */\n+int\n+call_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n+}\n+\n+/* Return true if OP is an indirect memory operand, the \"bset\" and \"bclr\"\n+   insns use this predicate.  */\n+int\n+indirect_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG);\n+}\n+\n+/* Return true if OP is a memory operand with a constant address.\n+   A special PSImode move pattern uses this predicate.  */\n+int\n+constant_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == MEM && CONSTANT_ADDRESS_P (XEXP (op, 0));\n+}\n+\n+/* What (if any) secondary registers are needed to move IN with mode\n+   MODE into a register from in register class CLASS. \n+\n+   We might be able to simplify this.  */\n+enum reg_class\n+secondary_reload_class (class, mode, in, input)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+     int input;\n+{\n+  int regno;\n+\n+  /* Memory loads less than a full word wide can't have an\n+     address or stack pointer destination.  They must use\n+     a data register as an intermediate register.  */\n+  if (input\n+      && GET_CODE (in) == MEM\n+      && (mode == QImode)\n+      && class == ADDRESS_REGS)\n+    return DATA_REGS;\n+\n+  /* Address register stores which are not PSImode need a scrach register.  */\n+  if (! input\n+      && GET_CODE (in) == MEM\n+      && (mode != PSImode)\n+      && class == ADDRESS_REGS)\n+    return DATA_REGS;\n+\n+  /* Otherwise assume no secondary reloads are needed.  */\n+  return NO_REGS;\n+}\n+\n+\f\n+/* Shifts.\n+\n+   We devote a fair bit of code to getting efficient shifts since we can only\n+   shift one bit at a time, and each single bit shift may take multiple\n+   instructions.\n+\n+   The basic shift methods:\n+\n+     * loop shifts -- emit a loop using one (or two on H8/S) bit shifts;\n+     this is the default.  SHIFT_LOOP\n+\n+     * inlined shifts -- emit straight line code for the shift; this is\n+     used when a straight line shift is about the same size or smaller\n+     than a loop.  We allow the inline version to be slightly longer in\n+     some cases as it saves a register.  SHIFT_INLINE\n+\n+     * There other oddballs.  Not worth explaining.  SHIFT_SPECIAL\n+\n+\n+   HImode shifts:\n+\n+     1-4    do them inline\n+\n+     5-7    If ashift, then multiply, else loop.\n+\t\n+     8-14 - If ashift, then multiply, if lshiftrt, then divide, else loop.\n+     15   - rotate the bit we want into the carry, clear the destination,\n+\t    (use mov 0,dst, not sub as sub will clobber the carry), then\n+\t    move bit into place.\n+\n+   Don't Panic, it's not nearly as bad as the H8 shifting code!!!  */\n+\n+int\n+nshift_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ASHIFT:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Called from the .md file to emit code to do shifts.\n+   Returns a boolean indicating success\n+   (currently this is always TRUE).  */\n+\n+int\n+expand_a_shift (mode, code, operands)\n+     enum machine_mode mode;\n+     int code;\n+     rtx operands[];\n+{\n+  emit_move_insn (operands[0], operands[1]);\n+\n+  /* need a loop to get all the bits we want  - we generate the\n+     code at emit time, but need to allocate a scratch reg now  */\n+\n+  emit_insn (gen_rtx\n+\t     (PARALLEL, VOIDmode,\n+\t      gen_rtvec (2,\n+\t\t\t gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\t  gen_rtx (code, mode,\n+\t\t\t\t\t   operands[0], operands[2])),\n+\t\t\t gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t  gen_rtx (SCRATCH, HImode, 0)))));\n+\n+  return 1;\n+}\n+\n+/* Shift algorithm determination.\n+\n+   There are various ways of doing a shift:\n+   SHIFT_INLINE: If the amount is small enough, just generate as many one-bit\n+                 shifts as we need.\n+   SHIFT_SPECIAL: Hand crafted assembler.\n+   SHIFT_LOOP:    If the above methods fail, just loop.  */\n+\n+enum shift_alg\n+{\n+  SHIFT_INLINE,\n+  SHIFT_SPECIAL,\n+  SHIFT_LOOP,\n+  SHIFT_MAX\n+};\n+\n+/* Symbols of the various shifts which can be used as indices.  */\n+\n+enum shift_type\n+  {\n+    SHIFT_ASHIFT, SHIFT_LSHIFTRT, SHIFT_ASHIFTRT\n+  };\n+\n+/* Symbols of the various modes which can be used as indices.  */\n+\n+enum shift_mode\n+  {\n+    HIshift, \n+  };\n+\n+/* For single bit shift insns, record assembler and what bits of the\n+   condition code are valid afterwards (represented as various CC_FOO\n+   bits, 0 means CC isn't left in a usable state).  */\n+\n+struct shift_insn\n+{\n+  char *assembler;\n+  int cc_valid;\n+};\n+\n+/* Assembler instruction shift table.\n+\n+   These tables are used to look up the basic shifts.\n+   They are indexed by cpu, shift_type, and mode.\n+*/\n+\n+static const struct shift_insn shift_one[3][3] =\n+{\n+  {\n+/* SHIFT_ASHIFT */\n+      { \"add\\t%0,%0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n+  },\n+/* SHIFT_LSHIFTRT */\n+  {\n+      { \"lsr\\t%0\", CC_NO_CARRY },\n+  },\n+/* SHIFT_ASHIFTRT */\n+  {\n+      { \"asr\\t%0\", CC_NO_CARRY },\n+  },\n+};\n+\n+/* Given CPU, MODE, SHIFT_TYPE, and shift count COUNT, determine the best\n+   algorithm for doing the shift.  The assembler code is stored in ASSEMBLER.\n+   We don't achieve maximum efficiency in all cases, but the hooks are here\n+   to do so.\n+\n+   For now we just use lots of switch statements.  Since we don't even come\n+   close to supporting all the cases, this is simplest.  If this function ever\n+   gets too big, perhaps resort to a more table based lookup.  Of course,\n+   at this point you may just wish to do it all in rtl.  */\n+\n+static enum shift_alg\n+get_shift_alg (shift_type, mode, count, assembler_p, cc_valid_p)\n+     enum shift_type shift_type;\n+     enum machine_mode mode;\n+     int count;\n+     const char **assembler_p;\n+     int *cc_valid_p;\n+{\n+  /* The default is to loop.  */\n+  enum shift_alg alg = SHIFT_LOOP;\n+  enum shift_mode shift_mode;\n+\n+  /* We don't handle negative shifts or shifts greater than the word size,\n+     they should have been handled already.  */\n+\n+  if (count < 0 || count > GET_MODE_BITSIZE (mode))\n+    abort ();\n+\n+  switch (mode)\n+    {\n+    case HImode:\n+      shift_mode = HIshift;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* Assume either SHIFT_LOOP or SHIFT_INLINE.\n+     It is up to the caller to know that looping clobbers cc.  */\n+  *assembler_p = shift_one[shift_type][shift_mode].assembler;\n+  *cc_valid_p = shift_one[shift_type][shift_mode].cc_valid;\n+\n+  /* Now look for cases we want to optimize.  */\n+\n+  switch (shift_mode)\n+    {\n+    case HIshift:\n+      if (count <= 4)\n+\treturn SHIFT_INLINE;\n+      else if (count < 15 && shift_type != SHIFT_ASHIFTRT)\n+\t{\n+\t  switch (count)\n+\t    {\n+\t    case 5:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 32,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 32,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 6:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 64,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 64,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 7:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 128,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 128,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 8:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 256,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 256,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 9:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 512,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 512,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 10:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 1024,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 1024,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 11:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 2048,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 2048,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 12:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 4096,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 4096,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 13:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 8192,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 8192,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    case 14:\n+\t      if (shift_type == SHIFT_ASHIFT)\n+\t\t*assembler_p = \"mov 16384,%4\\n\\tmul %4,%0\";\n+\t      else if (shift_type == SHIFT_LSHIFTRT)\n+\t\t*assembler_p\n+\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 16384,%4\\n\\tdivu %4,%0\";\n+\t      *cc_valid_p = CC_NO_CARRY;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count == 15)\n+\t{\n+          if (shift_type == SHIFT_ASHIFTRT)\n+            {\n+              *assembler_p = \"add\\t%0,%0\\n\\tsubc\\t%0,%0\\n\";\n+              *cc_valid_p = CC_NO_CARRY;\n+              return SHIFT_SPECIAL;\n+\t    }\n+          if (shift_type == SHIFT_LSHIFTRT)\n+            {\n+              *assembler_p = \"add\\t%0,%0\\n\\tmov 0,%0\\n\\trol %0\\n\";\n+              *cc_valid_p = CC_NO_CARRY;\n+              return SHIFT_SPECIAL;\n+\t    }\n+          if (shift_type == SHIFT_ASHIFT)\n+            {\n+              *assembler_p = \"ror\\t%0\\n\\tmov 0,%0\\n\\tror %0\\n\";\n+              *cc_valid_p = CC_NO_CARRY;\n+              return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return alg;\n+}\n+\n+/* Emit the assembler code for doing shifts.  */\n+\n+char *\n+emit_a_shift (insn, operands)\n+     rtx insn;\n+     rtx *operands;\n+{\n+  static int loopend_lab;\n+  char *assembler;\n+  int cc_valid;\n+  rtx inside = PATTERN (insn);\n+  rtx shift = operands[3];\n+  enum machine_mode mode = GET_MODE (shift);\n+  enum rtx_code code = GET_CODE (shift);\n+  enum shift_type shift_type;\n+  enum shift_mode shift_mode;\n+\n+  loopend_lab++;\n+\n+  switch (mode)\n+    {\n+    case HImode:\n+      shift_mode = HIshift;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  switch (code)\n+    {\n+    case ASHIFTRT:\n+      shift_type = SHIFT_ASHIFTRT;\n+      break;\n+    case LSHIFTRT:\n+      shift_type = SHIFT_LSHIFTRT;\n+      break;\n+    case ASHIFT:\n+      shift_type = SHIFT_ASHIFT;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      /* Indexing by reg, so have to loop and test at top */\n+      output_asm_insn (\"mov\t%2,%4\", operands);\n+      output_asm_insn (\"cmp\t0,%4\", operands);\n+      fprintf (asm_out_file, \"\\tble\t.Lle%d\\n\", loopend_lab);\n+\n+      /* Get the assembler code to do one shift.  */\n+      get_shift_alg (shift_type, mode, 1, &assembler, &cc_valid);\n+    }\n+  else\n+    {\n+      int n = INTVAL (operands[2]);\n+      enum shift_alg alg;\n+\n+      /* If the count is negative, make it 0.  */\n+      if (n < 0)\n+\tn = 0;\n+      /* If the count is too big, truncate it.\n+         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n+\t do the intuitive thing.  */\n+      else if (n > GET_MODE_BITSIZE (mode))\n+\tn = GET_MODE_BITSIZE (mode);\n+\n+      alg = get_shift_alg (shift_type, mode, n, &assembler, &cc_valid);\n+\n+\n+      switch (alg)\n+\t{\n+\tcase SHIFT_INLINE:\n+\t  /* Emit one bit shifts.  */\n+\t  while (n > 0)\n+\t    {\n+\t      output_asm_insn (assembler, operands);\n+\t      n -= 1;\n+\t    }\n+\n+\t  /* Keep track of CC.  */\n+\t  if (cc_valid)\n+\t    {\n+\t      cc_status.value1 = operands[0];\n+\t      cc_status.flags |= cc_valid;\n+\t    }\n+\t  return \"\";\n+\n+\tcase SHIFT_SPECIAL:\n+\t  output_asm_insn (assembler, operands);\n+\n+\t  /* Keep track of CC.  */\n+\t  if (cc_valid)\n+\t    {\n+\t      cc_status.value1 = operands[0];\n+\t      cc_status.flags |= cc_valid;\n+\t    }\n+\t  return \"\";\n+\t}\n+\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov\t%d,%s\\n\", n,\n+\t\t   reg_names[REGNO (operands[4])]);\n+\t  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+\t  output_asm_insn (assembler, operands);\n+\t  output_asm_insn (\"add\t-1,%4\", operands);\n+\t  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n+\t  return \"\";\n+\t}\n+    }\n+\n+  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+  output_asm_insn (assembler, operands);\n+  output_asm_insn (\"add\t-1,%4\", operands);\n+  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n+  fprintf (asm_out_file, \".Lle%d:\\n\", loopend_lab);\n+\n+  return \"\";\n+}\n+\n+/* Return an RTX to represent where a value with mode MODE will be returned\n+   from a function.  If the result is 0, the argument is pushed.  */\n+\n+rtx\n+function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  rtx result = 0;\n+  int size, align;\n+\n+  /* We only support using 2 data registers as argument registers.  */\n+  int nregs = 2;\n+\n+  /* Only pass named arguments in registers.  */\n+  if (!named)\n+    return NULL_RTX;\n+\n+  /* Figure out the size of the object to be passed.  We lie and claim\n+     PSImode values are only two bytes since they fit in a single\n+     register.  */\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else if (mode == PSImode)\n+    size = 2;\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  /* Figure out the alignment of the object to be passed.  */\n+    align = size;\n+\n+  cum->nbytes = (cum->nbytes + 1) & ~1;\n+\n+  /* Don't pass this arg via a register if all the argument registers\n+     are used up.  */\n+  if (cum->nbytes + size > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  switch (cum->nbytes / UNITS_PER_WORD)\n+    {\n+    case 0:\n+      result = gen_rtx (REG, mode, 0);\n+      break;\n+    case 1:\n+      result = gen_rtx (REG, mode, 1);\n+      break;\n+    default:\n+      result = 0;\n+    }\n+\n+  return result;\n+}\n+\n+/* Return the number of registers to use for an argument passed partially\n+   in registers and partially in memory.  */\n+\n+int\n+function_arg_partial_nregs (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int size, align;\n+\n+  /* We only support using 2 data registers as argument registers.  */\n+  int nregs = 2;\n+\n+  return 0;\n+  /* Only pass named arguments in registers.  */\n+  if (!named)\n+    return 0;\n+\n+  /* Figure out the size of the object to be passed.  */\n+  if (mode == BLKmode)\n+    size = int_size_in_bytes (type);\n+  else if (mode == PSImode)\n+    size = 2;\n+  else\n+    size = GET_MODE_SIZE (mode);\n+\n+  /* Figure out the alignment of the object to be passed.  */\n+  align = size;\n+\n+  cum->nbytes = (cum->nbytes + 1) & ~1;\n+\n+  /* Don't pass this arg via a register if all the argument registers\n+     are used up.  */\n+  if (cum->nbytes > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  if (cum->nbytes + size <= nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  /* Don't pass this arg via a register if it would be split between\n+     registers and memory.  */\n+  if (type == NULL_TREE\n+      && cum->nbytes + size > nregs * UNITS_PER_WORD)\n+    return 0;\n+\n+  return (nregs * UNITS_PER_WORD - cum->nbytes) / UNITS_PER_WORD;\n+}\n+\n+char *\n+output_tst (operand, insn)\n+     rtx operand, insn;\n+{\n+  \n+  rtx temp;\n+  int past_call = 0;\n+\n+  /* Only tst insns using address registers can be optimized.  */\n+  if (REGNO_REG_CLASS (REGNO (operand)) != ADDRESS_REGS)\n+    return \"cmp 0,%0\";\n+\n+  /* If testing an address register against zero, we can do better if\n+     we know there's a register already holding the value zero.  First\n+     see if a global register has been set to zero, else we do a search\n+     for a register holding zero, if both of those fail, then we use a\n+     compare against zero.  */\n+  if (zero_dreg || zero_areg)\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = operand;\n+      xoperands[1] = zero_dreg ? zero_dreg : zero_areg;\n+\n+      output_asm_insn (\"cmp %1,%0\", xoperands);\n+      return \"\";\n+    }\n+\n+  /* We can save a byte if we can find a register which has the value\n+     zero in it.  */\n+  temp = PREV_INSN (insn);\n+  while (temp)\n+    {\n+      rtx set;\n+\n+      /* We allow the search to go through call insns.  We record\n+\t the fact that we've past a CALL_INSN and reject matches which\n+\t use call clobbered registers.  */\n+      if (GET_CODE (temp) == CODE_LABEL\n+\t  || GET_CODE (temp) == JUMP_INSN\n+\t  || GET_CODE (temp) == BARRIER)\n+\tbreak;\n+\n+      if (GET_CODE (temp) == CALL_INSN)\n+\tpast_call = 1;\n+\n+      if (GET_CODE (temp) == NOTE)\n+\t{\n+\t  temp = PREV_INSN (temp);\n+\t  continue;\n+\t}\n+\n+      /* It must be an insn, see if it is a simple set. */\n+      set = single_set (temp);\n+      if (!set)\n+\t{\n+\t  temp = PREV_INSN (temp);\n+\t  continue;\n+\t}\n+\n+      /* Are we setting a register to zero?\n+\n+\t If it's a call clobbered register, have we past a call?  */\n+      if (REG_P (SET_DEST (set))\n+\t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n+\t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n+\t  && (!past_call \n+\t      || !call_used_regs[REGNO (SET_DEST (set))]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[0] = operand;\n+\t  xoperands[1] = SET_DEST (set);\n+\n+\t  output_asm_insn (\"cmp %1,%0\", xoperands);\n+\t  return \"\";\n+\t}\n+      temp = PREV_INSN (temp);\n+    }\n+  return \"cmp 0,%0\";\n+}\n+\n+/* Return nonzero if OP is a valid operand for a {zero,sign}_extendpsisi\n+   instruction.\n+\n+   It accepts anything that is a general operand or the sum of the\n+   stack pointer and a general operand.  */\n+extendpsi_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (general_operand (op, mode)\n+\t  || (GET_CODE (op) == PLUS\n+\t      && XEXP (op, 0) == stack_pointer_rtx\n+\t      && general_operand (XEXP (op, 1), VOIDmode)));\n+}"}, {"sha": "53ec0de0a71f074d6e60774d49e910fb32bb80fa", "filename": "gcc/config/mn10200/mn10200.h", "status": "added", "additions": 1073, "deletions": 0, "changes": 1073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,1073 @@\n+/* Definitions of target machine for GNU compiler. \n+   Matsushita MN10200 series\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"svr4.h\"\n+\n+/* Get rid of svr4.h stuff we don't want/need.  */\n+#undef ASM_SPEC\n+#undef ASM_FINAL_SPEC\n+#undef LIB_SPEC\n+#undef ENDFILE_SPEC\n+#undef LINK_SPEC\n+#undef STARTFILE_SPEC\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-D__mn10200__ -D__MN10200__ -D__LONG_MAX__=2147483647L -D__LONG_LONG_MAX__=2147483647L -D__INT_MAX__=32767\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+/* We don't have any switched on the mn10200.  Though there are some things\n+   that might be worth a switch:\n+\n+   -mspace to optimize even more for space.\n+\n+   -mrelax to enable the relaxing linker.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  {{ \"\", TARGET_DEFAULT}}\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (MN10200)\");\n+\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the Matsushita MN10300.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* This is not true on the Matsushita MN10200.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.\n+   This is not true on the Matsushita MN10200.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.\n+\n+   This is a white lie.  Registers are really 24bits, but most operations\n+   only operate on 16 bits.   GCC chokes badly if we set this to a value\n+   that is not a power of two.  */\n+#define BITS_PER_WORD\t\t16\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD\t\t2\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.\n+\n+   This differs from Pmode because we need to allocate 32bits of space\n+   to hold the 24bit pointers on this machine.  */\n+#define POINTER_SIZE \t\t32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY\t\t16\n+\n+/* The stack goes in 16 bit lumps.  */\n+#define STACK_BOUNDARY \t\t16\n+\n+/* Allocation boundary (in *bits*) for the code of a function.\n+   8 is the minimum boundary; it's unclear if bigger alignments\n+   would improve performance.  */\n+#define FUNCTION_BOUNDARY 8\n+\n+/* No data type wants to be aligned rounder than this.   */\n+#define BIGGEST_ALIGNMENT\t16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 16\n+\n+/* Seems to be how the Matsushita compiler does things, and there's\n+   no real reason to be different.  */\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+#undef PCC_BITFIELD_TYPE_MATTERS\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   XXX Long term we should probably expose the MDR register, we use\n+   it for division, multiplication, and some extension operations.  */\n+\n+#define FIRST_PSEUDO_REGISTER 8\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS \\\n+  { 0, 0, 0, 0, 0, 0, 0, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you\n+   like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+  { 1, 1, 0, 0, 1, 0, 0, 1}\n+\n+#define REG_ALLOC_ORDER \\\n+  { 0, 1, 4, 2, 3, 5, 6, 7}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((MODE) == PSImode ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) \\\n+\t\t\t    / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE.\n+\n+   We allow any register to hold a PSImode value.  We allow any register\n+   to hold values <= 16 bits.  For values > 16 bits we require aligned\n+   register pairs.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+ ((MODE) == PSImode ? 1 : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 2)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  (MODE1 == MODE2 || (GET_MODE_SIZE (MODE1) <= 2 && GET_MODE_SIZE (MODE2) <= 2))\n+\n+/* 4 data, and effectively 2 address registers is small as far as I'm\n+   concerned.  Especially since we use 2 data registers for argument\n+   passing and return values.\n+\n+   We used to define CLASS_LIKELY_SPILLED_P as true for DATA_REGS too,\n+   but we've made improvements to the port which greatly reduce register\n+   pressure.  As a result we no longer need to define CLASS_LIKELY_SPILLED_P\n+   for DATA_REGS (and by not defining it we get significantly better code).  */\n+#define SMALL_REGISTER_CLASSES 1\n+#define CLASS_LIKELY_SPILLED_P(CLASS) (CLASS == ADDRESS_REGS)\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+enum reg_class {\n+  NO_REGS, DATA_REGS, ADDRESS_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n+  \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS  \t\t\t\\\n+{     0,\t\t/* No regs      */\t\\\n+   0x0f,\t\t/* DATA_REGS */\t\t\\\n+   0xf0,\t\t/* ADDRESS_REGS */\t\\\n+   0xff,\t\t/* GENERAL_REGS */    \t\\\n+   0xff,\t\t/* ALL_REGS \t*/\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) < 4 ? DATA_REGS : ADDRESS_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS DATA_REGS\n+#define BASE_REG_CLASS  ADDRESS_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'd' ? DATA_REGS : \\\n+   (C) == 'a' ? ADDRESS_REGS : NO_REGS)\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+ \n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+  (((regno) > 3 && regno < FIRST_PSEUDO_REGISTER)\t\\\n+   || (reg_renumber[regno] > 3 && reg_renumber[regno] < FIRST_PSEUDO_REGISTER))\n+\n+#define REGNO_OK_FOR_INDEX_P(regno) \\\n+  (((regno) >= 0 && regno < 4)\t\\\n+   || (reg_renumber[regno] >= 0 && reg_renumber[regno] < 4))\n+\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+  ((GET_MODE (X) != PSImode) ? DATA_REGS : CLASS)\n+\n+/* We want to use DATA_REGS for anything that is not PSImode.  */\n+#define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n+  ((MODE != PSImode) ? DATA_REGS : CLASS)\n+\n+/* We have/need secondary reloads on the mn10200.  Mostly to deal\n+   with problems using address registers.  */\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class(CLASS,MODE,IN, 1)\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class(CLASS,MODE,IN, 0)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((MODE) == PSImode ? 1 : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+#define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n+#define INT_16_BITS(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n+\n+#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n+#define CONST_OK_FOR_J(VALUE) ((VALUE) >= 1 && (VALUE) <= 3)\n+#define CONST_OK_FOR_K(VALUE) ((VALUE) >= 1 && (VALUE) <= 4)\n+#define CONST_OK_FOR_L(VALUE) ((VALUE) == 15)\n+#define CONST_OK_FOR_M(VALUE) ((VALUE) == 255)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n+   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n+   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n+   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n+   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself. \n+     \n+  `G' is a floating-point zero.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n+\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n+   : 0)\n+\n+\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+/* Is equal to the size of the saved fp + pc, even if an fp isn't\n+   saved since the value is used before we know.  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) (current_function_needs_context ? 8 : 4)\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 7\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 6\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 6\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 4\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.\n+\n+   We allow frame pointers to be eliminated when not having one will\n+   not interfere with debugging.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+#define FRAME_POINTER_REQUIRED 0\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = total_frame_size()\n+\n+/* Various type size information.\n+\n+   The mn10200 has a limited number of small registers.  Sizes of basic\n+   data types are adjusted accordingly.  */\n+#define SHORT_TYPE_SIZE         16\n+#define INT_TYPE_SIZE           16\n+#define LONG_TYPE_SIZE          32\n+#define LONG_LONG_TYPE_SIZE     32\n+#define FLOAT_TYPE_SIZE         32\n+#define DOUBLE_TYPE_SIZE        32\n+#define LONG_DOUBLE_TYPE_SIZE   DOUBLE_TYPE_SIZE\n+\n+/* Any size less than 64bits will work; but a smarter definition\n+   can make G++ code smaller and faster.  Most operations on the\n+   mn10200 occur on 16bit hunks, so the best size for a boolean\n+   is 16bits.  */\n+#define BOOL_TYPE_SIZE\t\t16\n+\n+/* The difference of two pointers must be at least 24bits since pointers\n+   are 24bits; however, no basic data type is 24bits, so we have to round\n+   up to a 32bits for the difference of pointers.  */\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+#define PTRDIFF_TYPE \"long unsigned int\"\n+\n+/* Note sizeof (WCHAR_TYPE) must be equal to the value of WCHAR_TYPE_SIZE!  */\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+#define MAX_FIXED_MODE_SIZE     32\n+\n+/* A guess for the MN10200.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) ((N) <= 1)\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+\n+#define CUMULATIVE_ARGS struct cum_arg\n+struct cum_arg { int nbytes; };\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the MN10200, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+ ((CUM).nbytes = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\\\n+\t? (MODE) == PSImode ? 2 :\t\t\t\\\n+\t    (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD \\\n+\t: (int_size_in_bytes (TYPE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+extern struct rtx_def *function_arg();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, NAMED)\n+\n+\f\n+/* For \"large\" items, we pass them by invisible reference, and the\n+   callee is responsible for copying the data item if it might be\n+   modified.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+ \n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n+  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.   */\n+   \n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), TYPE_MODE (VALTYPE) == PSImode ? 4 : 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, (MODE) == PSImode ? 4 : 0)\n+\n+/* 1 if N is a possible register number for a function value.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 4)\n+\n+/* Return values > 8 bytes in length in memory.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+#define RETURN_IN_MEMORY(TYPE)  \\\n+  (int_size_in_bytes (TYPE) > 8 || TYPE_MODE (TYPE) == BLKmode)\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  On the MN10200 it's passed as\n+   the first parameter.  */\n+\n+#define STRUCT_VALUE 0\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.\n+\n+   ?!? Profiling is not currently supported.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) ;\n+\n+/* Yes, we actually support trampolines on this machine, even though\n+   nobody is likely to ever use them.  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.byte 0xfd\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.byte 0x03\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.byte 0x00\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tmov (a3),a0\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tadd -4,a3\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\tmov a0,(0,a3)\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (21,a0),a0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov a0,(4,a3)\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (0,a3),a0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tmov (17,a0),a0\\n\");\t\t\\\n+    fprintf (FILE, \"\\tadd 4,a3\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\trts\\n\");\t\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n+    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 0x1c\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, PSImode, plus_constant ((TRAMP), 20)),  \\\n+\t\t  (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, PSImode, plus_constant ((TRAMP), 24)),  \\\n+\t\t  (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+/* A C expression whose value is RTL representing the value of the return\n+   address for the frame COUNT steps up from the current frame.  */\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAME)   \\\n+  ((COUNT == 0)                         \\\n+   ? gen_rtx (MEM, Pmode, frame_pointer_rtx) \\\n+   : (rtx) 0)\n+\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+\f\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)   CONSTANT_P (X)\n+\n+/* Extra constraints.  */\n+ \n+/* Q is used for sp + <something> in the {zero,sign}_extendpsisi2 patterns.  */\n+#define EXTRA_CONSTRAINT(OP, C) \\\n+ ((C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : \\\n+  (C) == 'Q' ? GET_CODE (OP) == PLUS : 0)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X)  \\\n+  (GET_MODE (X) == PSImode \\\n+   && ((REGNO (X) >= 0 && REGNO(X) <= 3) || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (GET_MODE (X) == PSImode \\\n+   && ((REGNO (X) >= 4 && REGNO(X) <= 8) || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+#else\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  (GET_MODE (X) == PSImode) && REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (GET_MODE (X) == PSImode) && REGNO_OK_FOR_BASE_P (REGNO (X))\n+#endif\n+\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+/* Accept either REG or SUBREG where a register is valid.  */\n+  \n+#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\\\n+  ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))\t\t\\\n+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)    \t\\\n+{\t\t\t\t\t\t\t\\\n+  if ((MODE != PSImode) && CONSTANT_ADDRESS_P (X))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      rtx base = 0, index = 0;\t\t\t\t\\\n+      if (REG_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n+\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\\\n+      if (REG_P (XEXP (X, 1))\t\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n+\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n+      if (base != 0 && index != 0)\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (index) == CONST_INT)\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t  if (GET_CODE (index) == REG\t\t\t\\\n+\t      && REG_OK_FOR_INDEX_P (index)\t\t\\\n+\t      && GET_MODE_SIZE (MODE) <= word_mode)\t\\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.   */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the vax.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define CC_OVERFLOW_UNUSABLE 0x200\n+#define CC_NO_CARRY CC_NO_OVERFLOW\n+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n+\n+/* The mn10200 has a limited number of registers, so CSE of function\n+   addresses generally makes code worse due to register pressure.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+    /* Zeros are extremely cheap.  */\t\t\t\t\t\\\n+    if (INTVAL (RTX) == 0)\t\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\t\\\n+    /* If it fits in 8 bits, then it's still relatively cheap.  */\t\\\n+    if (INT_8_BITS (INTVAL (RTX)))\t\t\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+    /* This is the \"base\" cost, includes constants where either the\t\\\n+       upper or lower 16bits are all zeros.  */\t\t\t\t\\\n+    if (INT_16_BITS (INTVAL (RTX))\t\t\t\t\t\\\n+\t|| (INTVAL (RTX) & 0xffff) == 0\t\t\t\t\t\\\n+\t|| (INTVAL (RTX) & 0xffff0000) == 0)\t\t\t\t\\\n+      return 2;\t\t\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\t\\\n+  /* These are more costly than a CONST_INT, but we can relax them,\t\\\n+     so they're less costly than a CONST_DOUBLE.  */\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+    return 6;\t\t\t\t\t\t\t\t\\\n+  /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\t\\\n+     so their cost is very high.  */\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    return 8;\n+\n+/* Make moves between different classes more expensive than moves\n+   within the same class.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)  (CLASS1 != CLASS2 ? 4 : 2)\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+\n+   ?!? This probably needs more work.  The definitions below were first\n+   taken from the H8 port, then tweaked slightly to improve code density\n+   on various sample codes.  */\n+\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case MOD:\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+    return 8;\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return (GET_MODE (RTX) == SImode ? 20 : 8);\n+\n+/* Nonzero if access to memory by bytes or half words is no faster\n+   than accessing full words.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* According expr.c, a value of around 6 should minimize code size, and\n+   for the MN10200 series, code size our primary concern.  */\n+#define MOVE_RATIO 6\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP \"\\t.section .data\"\n+#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n+\n+/* Output at beginning/end of assembler file.  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) asm_file_start(FILE)\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* This is how to output an assembler line defining a `double' constant.\n+   It is .dfloat or .gfloat, depending.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+     fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n+   } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.hword \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* This says how to output the assembler to define a global\n+   uninitialized but not common symbol.\n+   Try to use asm_output_bss to implement this macro.  */\n+\n+#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED) \\\n+  asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED))\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\\\n+  do { fputs (\"\\t.global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)\t          \\\n+  do {                                            \\\n+  char* real_name;                                \\\n+  STRIP_NAME_ENCODING (real_name, (NAME));        \\\n+  fprintf (FILE, \"_%s\", real_name);               \\\n+  } while (0)           \n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+/* This is how we tell the assembler that two symbols have the same value.  */\n+\n+#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \\\n+  do { assemble_name(FILE, NAME1); \t \\\n+       fputs(\" = \", FILE);\t\t \\\n+       assemble_name(FILE, NAME2);\t \\\n+       fputc('\\n', FILE); } while (0)\n+\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\"}\n+\n+/* Print an instruction operand X on file FILE.\n+   look in mn10200.c for details */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in output-vax.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  asm_fprintf (FILE, \"\\t%s .L%d\\n\", \".long\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+/* We don't have to worry about dbx compatability for the mn10200.  */\n+#define DEFAULT_GDB_EXTENSIONS 1\n+\n+/* Use stabs debugging info by default.  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#define DBX_REGISTER_NUMBER(REGNO) REGNO\n+\n+/* GDB always assumes the current function's frame begins at the value\n+   of the stack pointer upon entry to the current function.  Accessing\n+   local variables and parameters passed on the stack is done using the\n+   base of the frame + an offset provided by GCC.\n+\n+   For functions which have frame pointers this method works fine;\n+   the (frame pointer) == (stack pointer at function entry) and GCC provides\n+   an offset relative to the frame pointer.\n+\n+   This loses for functions without a frame pointer; GCC provides an offset\n+   which is relative to the stack pointer after adjusting for the function's\n+   frame size.  GDB would prefer the offset to be relative to the value of\n+   the stack pointer at the function's entry.  Yuk!  */\n+#define DEBUGGER_AUTO_OFFSET(X) \\\n+  ((GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0) \\\n+    + (frame_pointer_needed ? 0 : -total_frame_size ()))\n+\n+#define DEBUGGER_ARG_OFFSET(OFFSET, X) \\\n+  ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n+    + (frame_pointer_needed ? 0 : -total_frame_size ()))\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+#define CASE_DROPS_THROUGH\n+\n+/* Dispatch tables on the mn10200 are extremely expensive in terms of code\n+   and readonly data size.  So we crank up the case threshold value to\n+   encourage a series of if/else comparisons to implement many small switch\n+   statements.  In theory, this value could be increased much more if we\n+   were solely optimizing for space, but we keep it \"reasonable\" to avoid\n+   serious code efficiency lossage.  */\n+#define CASE_VALUES_THRESHOLD 8\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* We could define this either way.  Using ZERO_EXTEND for QImode makes slightly\n+   fast and more compact code.  */\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX\t2\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) (OUTPREC != 32)\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode PSImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Perform target dependent optabs initialization.  */\n+#define MODHI3_LIBCALL \"__modhi3\"\n+#define DIVHI3_LIBCALL \"__divhi3\"\n+\n+#define INIT_TARGET_OPTABS \\\n+  do { \\\n+    sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n+      = gen_rtx (SYMBOL_REF, Pmode, DIVHI3_LIBCALL);\t\\\n+    smod_optab->handlers[(int) HImode].libfunc\t\t\\\n+      = gen_rtx (SYMBOL_REF, Pmode, MODHI3_LIBCALL);\t\\\n+  } while (0)\n+\n+/* The assembler op to get a word.  */\n+\n+#define FILE_ASM_OP \"\\t.file\\n\"\n+\n+extern void asm_file_start ();\n+extern void print_operand ();\n+extern void print_operand_address ();\n+extern void expand_prologue ();\n+extern void expand_epilogue ();\n+extern void notice_update_cc ();\n+extern int call_address_operand ();\n+extern enum reg_class secondary_reload_class ();\n+extern char *emit_a_shift ();\n+extern int current_function_needs_context;\n+extern char *output_tst ();\n+extern int extendpsi_operand ();\n+extern int rtx_equal_function_value_matters;\n+extern struct rtx_def *zero_dreg;\n+extern struct rtx_def *zero_areg;"}, {"sha": "90eac0e9e084fdc39ac11eba8538c320259ba82a", "filename": "gcc/config/mn10200/mn10200.md", "status": "added", "additions": 1958, "deletions": 0, "changes": 1958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.md?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,1958 @@\n+;; GCC machine description for Matsushita MN10200\n+;; Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+;; Contributed by Jeff Law (law@cygnus.com).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The original PO technology requires these to be ordered by speed,\n+;; so that assigner will pick the fastest.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; Condition code settings.\n+;; none - insn does not affect cc\n+;; none_0hit - insn does not affect cc but it does modify operand 0\n+;;\tThis attribute is used to keep track of when operand 0 changes.\n+;; \tSee the description of NOTICE_UPDATE_CC for more info.\n+;; set_znv - sets z,n,v to useable values; c is unknown.\n+;; set_zn  - sets z,n to usable values; v,c is unknown.\n+;; compare - compare instruction\n+;; clobber - value of cc is unknown\n+(define_attr \"cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber\"\n+  (const_string \"clobber\"))\n+\f\n+;; ----------------------------------------------------------------------\n+;; MOVE INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+;;\n+;; Some general notes on move instructions.\n+;;\n+;; The hardware can't encode nop moves involving data registers, so\n+;; we catch them and emit a nop instead.\n+;;\n+;; Loads/stores to/from address registers must be 16bit aligned,\n+;; thus we avoid them for QImode.\n+;;\n+;; Stores from address registers always store 24bits, so avoid\n+;; stores from address registers in HImode, SImode, and SFmode.\n+;;\n+;; As a result of the various problems using address registers in\n+;; QImode, HImode, SImode, and SFmode, we discourage their use via\n+;; '*' in their constraints.  They're still allowed, but they're never\n+;; the preferred class for for insns with those modes.\n+\n+;; movqi\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand0, QImode)\n+      && !register_operand (operand1, QImode))\n+    operands[1] = copy_to_mode_reg (QImode, operand1);\n+}\")\n+\n+;; We avoid memory operations involving address registers because we\n+;; can't be sure they'll be suitably aligned.\n+;;\n+;; We also discourage holding QImode values in address registers.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,*a,d,d,m,d,*a,*a\")\n+\t(match_operand:QI 1 \"general_operand\" \"0,I,I,di,m,d,*a,d,i*a\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+  nop\n+  sub %0,%0\n+  sub %0,%0\n+  mov %S1,%0\n+  movbu %1,%0\n+  movb %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\"\n+  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+;; movhi\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, HImode)\n+      && !register_operand (operand0, HImode))\n+    operands[1] = copy_to_mode_reg (HImode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,*a,d,d,m,d,*a,*a,*a\")\n+\t(match_operand:HI 1 \"general_operand\" \"0,I,I,di,m,d,*a,d,i*a,m\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"@\n+  nop\n+  sub %0,%0\n+  sub %0,%0\n+  mov %s1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %1,%0\n+  mov %A1,%0\"\n+  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+;; movpsi and helpers\n+\n+(define_expand \"movpsi\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n+\t(match_operand:PSI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, PSImode)\n+      && !register_operand (operand0, PSImode))\n+    operands[1] = copy_to_mode_reg (PSImode, operand1);\n+}\")\n+\n+\n+;; Constant and indexed addresses are not valid addresses for PSImode,\n+;; therefore they won't be matched by the general movpsi pattern below.\n+;; ??? We had patterns to handle indexed addresses, but they kept making\n+;; us run out of regs, so they were eliminated.\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=a\")\n+\t(match_operand:PSI 1 \"constant_memory_operand\" \"\"))]\n+  \"\"\n+  \"mov %A1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"constant_memory_operand\" \"=X\")\n+\t(match_operand:PSI 1 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"mov %1,%A0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+;; We want to prefer address registers here because 24bit moves to/from\n+;; memory are shorter and faster when done via address registers.\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,a?d,?da,a,m,?d,m\")\n+\t(match_operand:PSI 1 \"general_operand\" \"0,I,?dai,m,a,m,?d\"))]\n+  \"register_operand (operands[0], PSImode)\n+   || register_operand (operands[1], PSImode)\"\n+  \"@\n+  nop\n+  sub %0,%0\n+  mov %1,%0\n+  mov %A1,%0\n+  mov %1,%A0\n+  movx %A1,%0\n+  movx %1,%A0\"\n+  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, SImode)\n+      && !register_operand (operand0, SImode))\n+    operands[1] = copy_to_mode_reg (SImode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,*a,dm,d,d,*a,*a,*a\")\n+\t(match_operand:SI 1 \"general_operand\" \"0,I,I,d,dim,*a,d,*a,i\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"nop\\\";\n+    case 1:\n+    case 2:\n+      return \\\"sub %H0,%H0\\;sub %L0,%L0\\\";\n+    case 3:\n+    case 5:\n+    case 6:\n+    case 7:\n+      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n+\n+    /* The next two cases try to optimize cases where one half\n+       of the constant is all zeros, or when the two halves are\n+       the same.  */\n+    case 4:\n+    case 8:\n+      if (REG_P (operands[0])\n+\t  && GET_CODE (operands[1]) == CONST_INT\n+\t  && (INTVAL (operands[1]) & 0xffff0000) == 0)\n+\toutput_asm_insn (\\\"sub %H0,%H0\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"mov %h1,%H0\\\", operands);\n+\n+      if (GET_CODE (operands[1]) == CONST_INT\n+\t  && ((INTVAL (operands[1]) & 0xffff)\n+\t      == ((INTVAL (operands[1]) >> 16) & 0xffff)))\n+\toutput_asm_insn (\\\"mov %H0,%L0\\\", operands);\n+      else if (GET_CODE (operands[1]) == CONST_INT\n+\t       && (INTVAL (operands[1]) & 0xffff) == 0)\n+\toutput_asm_insn (\\\"sub %L0,%L0\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"mov %o1,%L0\\\", operands);\n+      return \\\"\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register */\n+  if (!register_operand (operand1, SFmode)\n+      && !register_operand (operand0, SFmode))\n+    operands[1] = copy_to_mode_reg (SFmode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=d,d,*a,dm,d,d,*a,*a,*a\")\n+\t(match_operand:SF 1 \"general_operand\" \"0,G,G,d,dim,*a,d,*a,i\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"nop\\\";\n+\n+    case 1:\n+    case 2:\n+      return \\\"sub %H0,%H0\\;sub %L0,%L0\\\";\n+\n+    default:\n+      {\n+        long val;\n+        REAL_VALUE_TYPE rv;\n+\n+\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t  {\n+\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+\t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\t  }\n+\n+\tif (GET_CODE (operands[1]) == CONST_INT)\n+\t  val = INTVAL (operands[1]);\n+\n+        if ((GET_CODE (operands[1]) == CONST_INT\n+\t     || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    && (val & 0xffff0000) == 0)\n+\t  output_asm_insn (\\\"sub %H0,%H0\\\", operands);\n+\telse\n+\t  output_asm_insn (\\\"mov %h1,%H0\\\", operands);\n+\t\n+\tif (GET_CODE (operands[1]) == CONST_INT\n+\t    && ((INTVAL (operands[1]) & 0xffff)\n+\t\t == ((INTVAL (operands[1]) >> 16) & 0xffff)))\n+\t  output_asm_insn (\\\"mov %H0,%L0\\\", operands);\n+        else if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t  || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t && (val & 0x0000ffff) == 0)\n+\t  output_asm_insn (\\\"sub %L0,%L0\\\", operands);\n+\telse\n+\t  output_asm_insn (\\\"mov %o1,%L0\\\", operands);\n+\treturn \\\"\\\";\n+      }\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; TEST INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Go ahead and define tsthi and tstpsi so we can eliminate redundant tst insns\n+;; when we start trying to optimize this port.\n+(define_insn \"tsthi\"\n+  [(set (cc0) (match_operand:HI 0 \"general_operand\" \"da\"))]\n+  \"\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"tstpsi\"\n+  [(set (cc0) (match_operand:PSI 0 \"general_operand\" \"da\"))]\n+  \"\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extend:HI (match_operand:QI 0 \"memory_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extend:PSI (match_operand:QI 0 \"memory_operand\" \"d\")))]\n+  \"\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare:HI (match_operand:HI 0 \"general_operand\" \"da\")\n+\t\t    (match_operand:HI 1 \"general_operand\" \"dai\")))]\n+  \"\"\n+  \"cmp %1,%0\"\n+  [(set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"cmppsi\"\n+  [(set (cc0)\n+\t(compare:PSI (match_operand:PSI 0 \"general_operand\" \"da\")\n+\t\t     (match_operand:PSI 1 \"general_operand\" \"dai\")))]\n+  \"\"\n+  \"cmp %1,%0\"\n+  [(set_attr \"cc\" \"compare\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; ADD INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"dai\")))]\n+  \"\"\n+  \"add %2,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"addpsi3\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=da\")\n+\t(plus:PSI (match_operand:PSI 1 \"general_operand\" \"%0\")\n+\t\t  (match_operand:PSI 2 \"general_operand\" \"dai\")))]\n+  \"\"\n+  \"add %2,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+;; We want to avoid using explicit registers; reload won't tell us\n+;; if it has to spill them and may generate incorrect code in such\n+;; cases.\n+;;\n+;; So we call out to a library routine to perform 32bit add or\n+;; subtract operations.\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* If adding a CONST_INT, we are better off generating code ourselves.\n+\n+     During RTL generation we call out to library routines.\n+\n+     After RTL generation we can not call the library routines as\n+     they need to push arguments via virtual_outgoing_args_rtx which\n+     has already been instantiated.  So, after RTL generation we just\n+     FAIL and open code the operation.  */\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (!rtx_equal_p (operands[0], operands[1]))\n+\temit_move_insn (operands[0], operands[1]);\n+      emit_insn (gen_addsi3_const (operands[0], operands[0], operands[2]));\n+      DONE;\n+    }\n+  else if (rtx_equal_function_value_matters)\n+    {\n+      rtx ret, insns;\n+      extern rtx emit_library_call_value ();\n+\n+      start_sequence ();\n+      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__addsi3\\\"),\n+\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n+\t\t\t\t     SImode, operands[2], SImode);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_libcall_block (insns, operands[0], ret,\n+\t\t\t  gen_rtx (ASHIFT, SImode, operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"addsi3_const\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")))\n+   (clobber (match_scratch:SI 3 \"=&d\"))]\n+  \"\"\n+  \"*\n+{\n+  unsigned long value = INTVAL (operands[2]);\n+\n+  /* If only the high bits are set in the constant, then we only\n+     need a single add operation.  It might be better to catch this\n+     at RTL expansion time.  */\n+  if ((value & 0xffff) == 0)\n+    return \\\"add %h2,%H0\\\";\n+\n+  value >>= 16;\n+  value &= 0xffff;\n+\n+  if (value == 0)\n+    return \\\"sub %3,%3\\;add %o2,%L0\\;addc %3,%H0\\\";\n+  else\n+    return \\\"mov %h2,%3\\;add %o2,%L0\\;addc %3,%H0\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; ----------------------------------------------------------------------\n+;; SUBTRACT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"dai\")))]\n+  \"\"\n+  \"sub %2,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"subpsi3\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=da\")\n+\t(minus:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:PSI 2 \"general_operand\" \"dai\")))]\n+  \"\"\n+  \"sub %2,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* During RTL generation we call out to library routines.\n+\n+     After RTL generation we can not call the library routines as\n+     they need to push arguments via virtual_outgoing_args_rtx which\n+     has already been instantiated.  So, after RTL generation we just\n+     FAIL and open code the operation.  */\n+  if (rtx_equal_function_value_matters)\n+    {\n+      rtx ret, insns;\n+      extern rtx emit_library_call_value ();\n+\n+      start_sequence ();\n+      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__subsi3\\\"),\n+\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n+\t\t\t\t     SImode, operands[2], SImode);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_libcall_block (insns, operands[0], ret,\n+\t\t\t  gen_rtx (ASHIFT, SImode, operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+;; There isn't a negate instruction, so we fake it.\n+;;\n+;; We used to expand this into patterns, but a single pattern\n+;; actually generates better overall code.\n+;; \n+;; We could do HImode negations with a \"not;add\" sequence, but\n+;; generally it's generated slightly worse code.\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=&d\")\n+        (neg:HI (match_operand:HI 1 \"general_operand\" \"d\")))]\n+  \"\"\n+  \"sub %0,%0\\;sub %1,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"negpsi2\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=&d\")\n+        (neg:PSI (match_operand:PSI 1 \"general_operand\" \"d\")))]\n+  \"\"\n+  \"sub %0,%0\\;sub %1,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+;; Using a magic libcall that accepts its arguments in any\n+;; data register pair has proven to be the most efficient\n+;; and most compact way to represent negsi2.\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"jsr ___negsi2_%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+ \n+;; ----------------------------------------------------------------------\n+;; MULTIPLY INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+;;\n+;; The mn10200 has HIxHI->SI widening multiply, but we get _severe_\n+;; code density regressions if we enable such a pattern.\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"d\")))]\n+  \"\"\n+  \"mul %2,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"udivmodhi4\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"d\")))\n+   (set (match_operand:HI 3 \"general_operand\" \"=&d\")\n+\t(umod:HI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"*\n+{\n+  if (zero_dreg)\n+    output_asm_insn (\\\"mov %0,mdr\\\", &zero_dreg);\n+  else\n+    output_asm_insn (\\\"sub %3,%3\\;mov %3,mdr\\\", operands);\n+    \n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \\\"divu %2,%0\\\";\n+  else\n+    return \\\"divu %2,%0\\;mov mdr,%3\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; AND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"M,di\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)\n+    return \\\"extxbu %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fff)\n+    return \\\"add %0,%0\\;lsr %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffe)\n+    return \\\"lsr %0\\;add %0,%0\\\";\n+  return \\\"and %2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit,set_znv\")])\n+\n+;; This expander + pattern exist only to allow trampolines to be aligned\n+;; in the stack.\n+(define_expand \"andpsi3\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n+\t(and:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n+\t\t(match_operand:PSI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || (INTVAL (operands[2]) & 0xff0000) != 0xff0000)\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d\")\n+\t(and:PSI (match_operand:PSI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:PSI 2 \"const_int_operand\" \"i\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\n+   && (INTVAL (operands[2]) & 0xff0000) == 0xff0000\"\n+  \"and %2,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; ----------------------------------------------------------------------\n+;; OR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"di\")))]\n+  \"\"\n+  \"or %2,%0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+;; ----------------------------------------------------------------------\n+;; XOR INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"di\")))]\n+  \"\"\n+  \"xor %2,%0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+;; ----------------------------------------------------------------------\n+;; NOT INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not %0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+\f\n+;; -----------------------------------------------------------------\n+;; BIT INSTRUCTIONS\n+;; -----------------------------------------------------------------\n+\n+;; When clearing a set of bits in memory, we load the inverted bitmask into\n+;; a register, then use bclr.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+\t(subreg:QI\n+\t  (and:HI (subreg:HI (match_dup 0) 0)\n+\t\t  (match_operand 1 \"const_int_operand\" \"\")) 0))\n+   (clobber (match_scratch:HI 2 \"=&d\"))]\n+  \"\"\n+  \"mov %N1,%2\\;bclr %2,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; These clear a non-constant set of bits in memory.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+\t(subreg:QI\n+\t  (and:HI (subreg:HI (match_dup 0) 0)\n+\t\t  (not:HI (match_operand:HI 1 \"general_operand\" \"d\"))) 0))]\n+  \"\"\n+  \"bclr %1,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+\t(subreg:QI\n+\t  (and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"d\"))\n+\t\t  (subreg:HI (match_dup 0) 0)) 0))]\n+  \"\"\n+  \"bclr %1,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; These set bits in memory.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+\t(subreg:QI\n+\t  (ior:HI (subreg:HI (match_dup 0) 0)\n+\t\t  (match_operand:HI 1 \"general_operand\" \"d\")) 0))]\n+  \"\"\n+  \"bset %1,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+\t(subreg:QI\n+\t  (ior:HI (match_operand:HI 1 \"general_operand\" \"d\")\n+\t\t  (subreg:HI (match_dup 0) 0)) 0))]\n+  \"\"\n+  \"bset %1,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; Not any shorter/faster than using cmp, but it might save a\n+;; register if the result of the AND isn't ever used.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+     (zero_extract:HI (match_operand:HI 0 \"general_operand\" \"d\")\n+\t\t      (match_operand 1 \"const_int_operand\" \"\")\n+\t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  int len = INTVAL (operands[1]);\n+  int bit = INTVAL (operands[2]);\n+  int mask = 0;\n+  rtx xoperands[2];\n+\n+  while (len > 0)\n+    {\n+      mask |= (1 << bit);\n+      bit++;\n+      len--;\n+    }\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = GEN_INT (mask);\n+  output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (and:HI (match_operand:HI 0 \"general_operand\" \"d\")\n+\t\t      (match_operand:HI 1 \"const_int_operand\" \"i\")))]\n+  \"\"\n+  \"btst %1,%0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+\f\n+;; ----------------------------------------------------------------------\n+;; JUMP INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+;; Conditional jump instructions\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+          || GET_CODE (operands[1]) == GE\n+          || GET_CODE (operands[1]) == LE\n+          || GET_CODE (operands[1]) == LT))\n+    return 0;\n+\n+  if (GET_MODE (SET_SRC (PATTERN (PREV_INSN (insn)))) == PSImode)\n+    return \\\"b%b1x %0\\\";\n+  else\n+    return \\\"b%b1 %0\\\";\n+}\"\n+ [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n+      && (GET_CODE (operands[1]) == GT\n+          || GET_CODE (operands[1]) == GE\n+          || GET_CODE (operands[1]) == LE\n+          || GET_CODE (operands[1]) == LT))\n+    return 0;\n+\n+  if (GET_MODE (SET_SRC (PATTERN (PREV_INSN (insn)))) == PSImode)\n+    return \\\"b%B1x %0\\\";\n+  else\n+    return \\\"b%B1 %0\\\";\n+}\"\n+ [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp %l0\"\n+ [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:PSI 0 \"general_operand\" \"a\"))]\n+  \"\"\n+  \"jmp (%0)\"\n+  [(set_attr \"cc\" \"none\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:PSI 0 \"general_operand\" \"a\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp  (%0)\"\n+  [(set_attr \"cc\" \"none\")])\n+\n+;; Call subroutine with no return value.\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\" \"\")\n+\t (match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (! call_address_operand (XEXP (operands[0], 0)))\n+    XEXP (operands[0], 0) = force_reg (PSImode, XEXP (operands[0], 0));\n+  emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:QI (match_operand:PSI 0 \"call_address_operand\" \"aS\"))\n+\t (match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"jsr %C0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"general_operand\" \"\")\n+\t      (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! call_address_operand (XEXP (operands[1], 0)))\n+    XEXP (operands[1], 0) = force_reg (PSImode, XEXP (operands[1], 0));\n+  emit_call_insn (gen_call_value_internal (operands[0],\n+\t\t\t\t\t   XEXP (operands[1], 0),\n+\t\t\t\t\t   operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand 0 \"\" \"=da\")\n+\t(call (mem:QI (match_operand:PSI 1 \"call_address_operand\" \"aS\"))\n+\t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"jsr %C1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+                    (const_int 0))\n+              (match_operand 1 \"\" \"\")\n+              (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+  DONE;\n+}\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"cc\" \"none\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; EXTEND INSTRUCTIONS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"@\n+  extxbu %0\n+  mov %1,%0\\;extxbu %0\n+  movbu %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"zero_extendqipsi2\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(zero_extend:PSI\n+\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"@\n+  extxbu %0\n+  mov %1,%0\\;extxbu %0\n+  movbu %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"@\n+  extxbu %L0\\;sub %H0,%H0\n+  mov %1,%L0\\;extxbu %L0\\;sub %H0,%H0\n+  movbu %1,%L0\\;sub %H0,%H0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"zero_extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(zero_extend:PSI\n+\t (match_operand:HI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"@\n+  extxu %0\n+  mov %1,%0\\;extxu %0\n+  mov %1,%0\\;extxu %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"general_operand\" \"0,dim\")))]\n+  \"\"\n+  \"@\n+  sub %H0,%H0\n+  mov %1,%L0\\;sub %H0,%H0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+;; The last alternative is necessary because the second operand might\n+;; have been the frame pointer.  The frame pointer would get replaced\n+;; by (plus (stack_pointer) (const_int)).\n+;;\n+;; Reload would think that it only needed a PSImode register in\n+;; push_reload and at the start of allocate_reload_regs.  However,\n+;; at the end of allocate_reload_reg it would realize that the\n+;; reload register must also be valid for SImode, and if it was\n+;; not valid reload would abort.\n+(define_insn \"zero_extendpsisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,?d,?*d,?*d\")\n+\t(zero_extend:SI (match_operand:PSI 1 \"extendpsi_operand\"\n+\t\t\t\t\t\t\"m,?0,?*dai,Q\")))]\n+  \"\"\n+  \"@\n+  mov %L1,%L0\\;movbu %H1,%H0\n+  jsr ___zero_extendpsisi2_%0\n+  mov %1,%L0\\;jsr ___zero_extendpsisi2_%0\n+  mov a3,%L0\\;add %Z1,%L0\\;jsr ___zero_extendpsisi2_%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;;- sign extension instructions\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"extxb %0\\\";\n+  else if (which_alternative == 1)\n+    return \\\"mov %1,%0\\;extxb %0\\\";\n+  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+    return \\\"movbu %1,%0\\;extxb %0\\\";\n+  else\n+    return \\\"movb %1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"extendqipsi2\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(sign_extend:PSI\n+\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"extxb %0\\\";\n+  else if (which_alternative == 1)\n+    return \\\"mov %1,%0\\;extxb %0\\\";\n+  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+    return \\\"movbu %1,%0\\;extxb %0\\\";\n+  else\n+    return \\\"movb %1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"extxb %L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n+  else if (which_alternative == 1)\n+    return \\\"mov %1,%L0\\;extxb %L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n+  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+    return \\\"movbu %1,%L0\\;extxb %L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n+  else\n+    return \\\"movb %1,%L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(sign_extend:PSI\n+\t (match_operand:HI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"@\n+  extx %0\n+  mov %1,%0\\;extx %0\n+  mov %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"general_operand\" \"0,di,m\")))]\n+  \"\"\n+  \"@\n+  mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\n+  mov %1,%L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\n+  mov %1,%L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+;; The last alternative is necessary because the second operand might\n+;; have been the frame pointer.  The frame pointer would get replaced\n+;; by (plus (stack_pointer) (const_int)).\n+;;\n+;; Reload would think that it only needed a PSImode register in\n+;; push_reload and at the start of allocate_reload_regs.  However,\n+;; at the end of allocate_reload_reg it would realize that the\n+;; reload register must also be valid for SImode, and if it was\n+;; not valid reload would abort.\n+(define_insn \"extendpsisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,?d,?*d,?*d\")\n+\t(sign_extend:SI (match_operand:PSI 1 \"extendpsi_operand\"\n+\t\t\t\t\t\t\"m,?0,?*dai,Q\")))]\n+  \"\"\n+  \"@\n+  mov %L1,%L0\\;movb %H1,%H0\n+  jsr ___sign_extendpsisi2_%0\n+  mov %1,%L0\\;jsr ___sign_extendpsisi2_%0\n+  mov a3,%L0\\;add %Z1,%L0\\;jsr ___sign_extendpsisi2_%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"truncsipsi2\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=a,?d,?*d,da\")\n+\t(truncate:PSI (match_operand:SI 1 \"general_operand\" \"m,?m,?*d,i\")))]\n+   \"\"\n+   \"@\n+   mov %1,%0\n+   movx %A1,%0\n+   jsr ___truncsipsi2_%1_%0\n+   mov %1,%0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+\f\n+;; Combine should be simplifying this stuff, but isn't.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n+\t(sign_extend:SI\n+\t  (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,di,m\"))))]\n+  \"\"\n+  \"@\n+  extxbu %L0\\;sub %H0,%H0\n+  mov %1,%L0\\;extxbu %L0\\;sub %H0,%H0\n+  movbu %1,%L0\\;sub %H0,%H0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+        (truncate:PSI\n+\t  (sign_extend:SI (match_operand:QI 1 \"general_operand\" \"0,di,m\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"extxb %0\\\";\n+  else if (which_alternative == 1)\n+    return \\\"mov %1,%0\\;extxb %0\\\";\n+  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+    return \\\"movbu %1,%0\\;extxb %0\\\";\n+  else\n+    return \\\"movb %1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(truncate:PSI\n+\t  (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,di,m\"))))]\n+  \"\"\n+  \"@\n+  extx %0\n+  mov %1,%0\\;extx %0\n+  mov %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(truncate:PSI\n+\t  (sign_extend:SI\n+\t    (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,di,m\")))))]\n+  \"\"\n+  \"@\n+  extxbu %0\n+  mov %1,%0\\;extxbu %0\n+  movbu %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(truncate:PSI\n+\t  (zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,di,m\"))))]\n+  \"\"\n+  \"@\n+  extxu %0\n+  mov %1,%0\\;extxu %0\n+  mov %1,%0\\;extxu %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+        (truncate:PSI\n+\t  (zero_extend:SI (match_operand:QI 1 \"general_operand\" \"0,di,m\"))))]\n+  \"\"\n+  \"@\n+  extxbu %0\n+  mov %1,%0\\;extxbu %0\n+  movbu %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n+;; ----------------------------------------------------------------------\n+;; SHIFTS\n+;; ----------------------------------------------------------------------\n+\n+;; If the shift count is small, we expand it into several single bit\n+;; shift insns.  Otherwise we expand into a generic shift insn which\n+;; handles larger shift counts, shift by variable amounts, etc.\n+(define_expand \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* This is an experiment to see if exposing more of the underlying\n+     operations results in better code.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= 4)\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, HImode, operands[0],\n+\t\t\t      gen_rtx (ASHIFT, HImode,\n+\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else\n+    {\n+      expand_a_shift (HImode, ASHIFT, operands);\n+      DONE;\n+    }\n+}\")\n+\n+;; ASHIFT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add %0,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* This is an experiment to see if exposing more of the underlying\n+     operations results in better code.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= 4)\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, HImode, operands[0],\n+\t\t\t      gen_rtx (LSHIFTRT, HImode,\n+\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else\n+    {\n+      expand_a_shift (HImode, LSHIFTRT, operands);\n+      DONE;\n+    }\n+}\")\n+\n+;; LSHIFTRT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"lsr %0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* This is an experiment to see if exposing more of the underlying\n+     operations results in better code.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= 4)\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, HImode, operands[0],\n+\t\t\t      gen_rtx (ASHIFTRT, HImode,\n+\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else\n+    {\n+      expand_a_shift (HImode, ASHIFTRT, operands);\n+      DONE;\n+    }\n+}\")\n+\n+;; ASHIFTRT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"asr %0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n+;; And the general HImode shift pattern.  Handles both shift by constants\n+;; and shift by variable counts.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d\")\n+\t(match_operator:HI 3 \"nshift_operator\" \n+\t\t\t[ (match_operand:HI 1 \"general_operand\" \"0,0\")\n+\t\t\t  (match_operand:HI 2 \"general_operand\" \"KL,dan\")]))\n+   (clobber (match_scratch:HI 4 \"=X,&d\"))]\n+  \"\"\n+  \"* return emit_a_shift (insn, operands);\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; We expect only ASHIFT with constant shift counts to be common for\n+;; PSImode, so we optimize just that case.  For all other cases we\n+;; extend the value to SImode and perform the shift in SImode.\n+(define_expand \"ashlpsi3\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n+\t(ashift:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* This is an experiment to see if exposing more of the underlying\n+     operations results in better code.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= 7)\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, PSImode, operands[0],\n+\t\t\t      gen_rtx (ASHIFT, PSImode,\n+\t\t\t\t       operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else\n+    {\n+      expand_a_shift (PSImode, ASHIFT, operands);\n+      DONE;\n+    }\n+}\")\n+\n+;; ASHIFT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d\")\n+\t(ashift:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n+\t\t    (const_int 1)))]\n+  \"\"\n+  \"add %0,%0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_expand \"lshrpsi3\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n+\t(lshiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_zero_extendpsisi2 (reg, operands[1]));\n+  reg = expand_binop (SImode, lshr_optab, reg,\n+\t\t      operands[2], reg, 1, OPTAB_WIDEN);\n+  emit_insn (gen_truncsipsi2 (operands[0], reg));\n+  DONE;\n+}\")\n+\n+(define_expand \"ashrpsi3\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n+\t(ashiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_extendpsisi2 (reg, operands[1]));\n+  reg = expand_binop (SImode, ashr_optab, reg,\n+\t\t      operands[2], reg, 0, OPTAB_WIDEN);\n+  emit_insn (gen_truncsipsi2 (operands[0], reg));\n+  DONE;\n+}\")\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"nonmemory_operand\" \"\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* For small shifts, just emit a series of single bit shifts inline.\n+\n+     For other constant shift counts smaller than a word or non-constant\n+     shift counts we call out to a library call during RTL generation time;\n+     after RTL generation time we allow optabs.c to open code the operation.\n+     See comments in addsi3/subsi3 expanders.\n+\n+     Otherwise we allow optabs.c to open code the operation.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (INTVAL (operands[2]) <= 3))\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n+\t\t\t\t   gen_rtx (ASHIFT, SImode,\n+\t\t\t\t\t    operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else if (rtx_equal_function_value_matters\n+\t   && (GET_CODE (operands[2]) != CONST_INT\n+\t       || INTVAL (operands[2]) <= 15))\n+    {\n+      rtx ret, insns;\n+      extern rtx emit_library_call_value ();\n+\n+      start_sequence ();\n+      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__ashlsi3\\\"),\n+\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n+\t\t\t\t     SImode, operands[2], HImode);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_libcall_block (insns, operands[0], ret,\n+\t\t\t  gen_rtx (ASHIFT, SImode, operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+;; ASHIFT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"add %L0,%L0\\;addc %H0,%H0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* For small shifts, just emit a series of single bit shifts inline.\n+\n+     For other constant shift counts smaller than a word or non-constant\n+     shift counts we call out to a library call during RTL generation time;\n+     after RTL generation time we allow optabs.c to open code the operation.\n+     See comments in addsi3/subsi3 expanders.\n+\n+     Otherwise we allow optabs.c to open code the operation.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (INTVAL (operands[2]) <= 2))\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n+\t\t\t\t   gen_rtx (LSHIFTRT, SImode,\n+\t\t\t\t\t    operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else if (rtx_equal_function_value_matters\n+\t   && (GET_CODE (operands[2]) != CONST_INT\n+\t       || INTVAL (operands[2]) <= 15))\n+    {\n+      rtx ret, insns;\n+      extern rtx emit_library_call_value ();\n+\n+      start_sequence ();\n+      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__lshrsi3\\\"),\n+\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n+\t\t\t\t     SImode, operands[2], HImode);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_libcall_block (insns, operands[0], ret,\n+\t\t\t  gen_rtx (LSHIFTRT, SImode, operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+;; LSHIFTRT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"lsr %H0\\;ror %L0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* For small shifts, just emit a series of single bit shifts inline.\n+\n+     For other constant shift counts smaller than a word or non-constant\n+     shift counts we call out to a library call during RTL generation time;\n+     after RTL generation time we allow optabs.c to open code the operation.\n+     See comments in addsi3/subsi3 expanders.\n+\n+     Otherwise we allow optabs.c to open code the operation.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (INTVAL (operands[2]) <= 2))\n+    {\n+      int count = INTVAL (operands[2]);\n+      emit_move_insn (operands[0], operands[1]);\n+      while (count > 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, SImode, operands[0],\n+\t\t\t\t   gen_rtx (ASHIFTRT, SImode,\n+\t\t\t\t\t    operands[0], GEN_INT (1))));\n+\t  count--;\n+\t}\n+      DONE;\n+    }\n+  else if (rtx_equal_function_value_matters\n+\t   && (GET_CODE (operands[2]) != CONST_INT\n+\t       || INTVAL (operands[2]) <= 15))\n+    {\n+      rtx ret, insns;\n+      extern rtx emit_library_call_value ();\n+\n+      start_sequence ();\n+      ret = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"__ashrsi3\\\"),\n+\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n+\t\t\t\t     SImode, operands[2], HImode);\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_libcall_block (insns, operands[0], ret,\n+\t\t\t  gen_rtx (ASHIFTRT, SImode, operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+}\")\n+\n+;; ASHIFTRT one bit.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"asr %H0\\;ror %L0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; ----------------------------------------------------------------------\n+;; PROLOGUE/EPILOGUE\n+;; ----------------------------------------------------------------------\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"expand_prologue (); DONE;\")\n+\n+(define_insn \"outline_prologue_call\"\n+  [(const_int 1)]\n+  \"\"\n+  \"jsr ___prologue\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"\n+{\n+  expand_epilogue ();\n+  DONE;\n+}\")\n+\n+(define_insn \"outline_epilogue_call_a0\"\n+  [(const_int 2)]\n+  \"\"\n+  \"jsr ___epilogue_a0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"outline_epilogue_call_d0\"\n+  [(const_int 3)]\n+  \"\"\n+  \"jsr ___epilogue_d0\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"outline_epilogue_jump\"\n+  [(const_int 4)]\n+  \"\"\n+  \"jmp ___epilogue_noreturn\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"reload_completed && total_frame_size () == 0\n+   && !current_function_needs_context\"\n+  \"*\n+{\n+  rtx next = next_active_insn (insn);\n+\n+  if (next\n+      && GET_CODE (next) == JUMP_INSN\n+      && GET_CODE (PATTERN (next)) == RETURN)\n+    return \\\"\\\";\n+  return \\\"rts\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"return_internal\"\n+  [(const_int 0)\n+   (return)]\n+  \"\"\n+  \"rts\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; These are special combiner patterns to improve array/pointer accesses.\n+;;\n+;; A typical sequence involves extending an integer/char, shifting it left\n+;; a few times, then truncating the value to PSImode.\n+;;\n+;; This first pattern combines the shifting & truncation operations, by\n+;; itself it is a win because the shifts end up occuring in PSImode instead\n+;; of SImode.  However, it has the secondary effect of giving us the\n+;; opportunity to match patterns which allow us to remove the initial\n+;; extension completely, which is a big win.\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,a\")\n+\t(truncate:PSI\n+\t  (ashift:SI (match_operand:SI 1 \"general_operand\" \"d,m,m\")\n+\t\t     (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n+  \"\"\n+  \"*\n+{\n+  int count = INTVAL (operands[2]);\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"jsr ___truncsipsi2_%1_%0\\\", operands);\n+  else if (which_alternative == 1)\n+    output_asm_insn (\\\"movx %A1,%0\\\", operands);\n+  else\n+    output_asm_insn (\\\" mov %1,%0\\\", operands);\n+\n+  while (count)\n+    {\n+      output_asm_insn (\\\"add %0,%0\\\", operands);\n+      count--;\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; Similarly, except that we also have zero/sign extension of the\n+;; original operand.  */\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d\")\n+\t(truncate:PSI\n+\t  (ashift:SI\n+\t    (zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,dim\"))\n+\t    (match_operand:HI 2 \"const_int_operand\" \"i,i\"))))]\n+  \"\"\n+  \"*\n+{\n+  int count = INTVAL (operands[2]);\n+\n+  /* First extend operand 1 to PSImode.  */\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"extxu %0\\\", operands);\n+  else\n+    output_asm_insn (\\\"mov %1,%0\\;extxu %0\\\", operands);\n+\n+  /* Now do the shifting.  */\n+  while (count)\n+    {\n+      output_asm_insn (\\\"add %0,%0\\\", operands);\n+      count--;\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(truncate:PSI\n+\t  (ashift:SI\n+\t    (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,di,m\"))\n+\t    (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n+  \"\"\n+  \"*\n+{\n+  int count = INTVAL (operands[2]);\n+\n+  /* First extend operand 1 to PSImode.  */\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"extx %0\\\", operands);\n+  else if (which_alternative == 1)\n+    output_asm_insn (\\\"mov %1,%0\\;extx %0\\\", operands);\n+  else\n+    output_asm_insn (\\\"mov %1,%0\\\", operands);\n+\n+  /* Now do the shifting.  */\n+  while (count)\n+    {\n+      output_asm_insn (\\\"add %0,%0\\\", operands);\n+      count--;\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(truncate:PSI\n+\t  (ashift:SI\n+\t    (sign_extend:SI\n+\t      (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,di,m\")))\n+\t    (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n+  \"\"\n+  \"*\n+{\n+  int count = INTVAL (operands[2]);\n+\n+  /* First extend operand 1 to PSImode.  */\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"extxbu %0\\\", operands);\n+  else if (which_alternative == 1)\n+    output_asm_insn (\\\"mov %1,%0\\;extxbu %0\\\", operands);\n+  else\n+    output_asm_insn (\\\"movbu %1,%0\\\", operands);\n+\n+  /* Now do the shifting.  */\n+  while (count)\n+    {\n+      output_asm_insn (\\\"add %0,%0\\\", operands);\n+      count--;\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n+\t(truncate:PSI\n+\t  (ashift:SI\n+\t    (sign_extend:SI\n+\t      (match_operand:QI 1 \"general_operand\" \"0,di,m\"))\n+\t    (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n+  \"\"\n+  \"*\n+{\n+  int count = INTVAL (operands[2]);\n+\n+  /* First extend operand 1 to PSImode.  */\n+  if (which_alternative == 0)\n+    output_asm_insn (\\\"extxb %0\\\", operands);\n+  else if (which_alternative == 1)\n+    output_asm_insn (\\\"mov %1,%0\\;extxb %0\\\", operands);\n+  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+    output_asm_insn (\\\"movbu %1,%0\\;extxb %0\\\", operands);\n+  else\n+    output_asm_insn (\\\"movb %1,%0\\\", operands);\n+\n+  /* Now do the shifting.  */\n+  while (count)\n+    {\n+      output_asm_insn (\\\"add %0,%0\\\", operands);\n+      count--;\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; Try to combine consecutive updates of the stack pointer (or any\n+;; other register for that matter).\n+(define_peephole\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=da\")\n+\t(plus:PSI (match_dup 0)\n+\t\t  (match_operand 1 \"const_int_operand\" \"\")))\n+   (set (match_dup 0)\n+\t(plus:PSI (match_dup 0)\n+\t\t  (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[1]));\n+  return \\\"add %1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;;\n+;; We had patterns to check eq/ne, but the they don't work because\n+;; 0x80000000 + 0x80000000 = 0x0 with a carry out.\n+;;\n+;; The Z flag and C flag would be set, and we have no way to\n+;; check for the Z flag set and C flag clear.\n+;;\n+;; This will work on the mn10200 because we can check the ZX flag\n+;; if the comparison is in HImode.\n+(define_peephole\n+  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (match_operand 1 \"\" \"\")\n+\t\t\t   (pc)))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcc %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (match_operand 1 \"\" \"\")\n+\t\t\t   (pc)))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcs %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (match_operand 1 \"\" \"\")))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcs %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (match_operand 1 \"\" \"\")))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcc %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (match_operand 1 \"\" \"\")\n+\t\t\t   (pc)))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bccx %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (match_operand 1 \"\" \"\")\n+\t\t\t   (pc)))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcsx %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (match_operand 1 \"\" \"\")))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bcsx %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n+   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (match_operand 1 \"\" \"\")))]\n+  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n+  \"add %0,%0\\;bccx %1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+;; We call out to library routines to perform 32bit addition and subtraction\n+;; operations (see addsi3/subsi3 expanders for why).  These peepholes catch\n+;; the trivial case where the operation could be done with an add;addc or\n+;; sub;subc sequence.\n+(define_peephole\n+  [(set (mem:SI (reg:PSI 7)) (reg:SI 2))\n+   (set (reg:SI 0) (call (match_operand:QI 1 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+   && strcmp (XSTR (XEXP (operands[1], 0), 0), \\\"__addsi3\\\") == 0\"\n+  \"add d2,d0\\;addc d3,d1\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n+(define_peephole\n+  [(set (mem:SI (reg:PSI 7)) (reg:SI 2))\n+   (set (reg:SI 0) (call (match_operand:QI 1 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+   && strcmp (XSTR (XEXP (operands[1], 0), 0), \\\"__subsi3\\\") == 0\"\n+  \"sub d2,d0\\;subc d3,d1\"\n+  [(set_attr \"cc\" \"clobber\")])"}, {"sha": "70a2c43e7de7f667ed24a87d0be03abdca061234", "filename": "gcc/config/mn10200/t-mn10200", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Ft-mn10200", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Ft-mn10200", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Ft-mn10200?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,50 @@\n+LIBGCC1=libgcc1.null\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = mn10200/lib1funcs.asm\n+LIB1ASMFUNCS    = _divhi3 \\\n+\t\t  _modhi3 \\\n+\t\t  _addsi3 \\\n+\t\t  _subsi3 \\\n+\t\t  _mulsi3 \\\n+\t\t  _ashlsi3 \\\n+\t\t  _lshrsi3 \\\n+\t\t  _ashrsi3 \\\n+\t\t  _negsi2_d0 \\\n+\t\t  _negsi2_d2 \\\n+\t\t  _zero_extendpsisi2_d0 \\\n+\t\t  _zero_extendpsisi2_d2 \\\n+\t\t  _sign_extendpsisi2_d0 \\\n+\t\t  _sign_extendpsisi2_d2 \\\n+\t\t  _truncsipsi2_d0_d0 \\\n+\t\t  _truncsipsi2_d0_d1 \\\n+\t\t  _truncsipsi2_d0_d2 \\\n+\t\t  _truncsipsi2_d0_d3 \\\n+\t\t  _truncsipsi2_d2_d0 \\\n+\t\t  _truncsipsi2_d2_d1 \\\n+\t\t  _truncsipsi2_d2_d2 \\\n+\t\t  _truncsipsi2_d2_d3 \\\n+\t\t  _cmpsi2 \\\n+\t\t  _ucmpsi2 \\\n+\t\t  _prologue \\\n+\t\t  _epilogue_a0 \\\n+\t\t  _epilogue_d0 \\\n+\t\t  _epilogue_noreturn\n+\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+# We do not have DF or DI types, so fake out the libgcc2 compilation.\n+LIBGCC2_CFLAGS = -g -O2 -DDF=SF -DDI=SI $(GCC_CFLAGS) $(LIBGCC2_INCLUDES)\n+LIB2FUNCS_EXTRA = fp-bit.c $(srcdir)/config/mn10200/udivmodsi4.c \\\n+\t$(srcdir)/config/mn10200/divmod.c $(srcdir)/config/mn10200/udivmod.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#define FLOAT_ONLY' >> fp-bit.c\n+\techo '#define SMALL_MACHINE' >> fp-bit.c\n+\techo '#define CMPtype HItype' >> fp-bit.c\n+\techo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n+\techo '#endif' \t\t>> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c"}, {"sha": "1395e9cc94025eed0f52d285f00291a1e4688c35", "filename": "gcc/config/mn10200/udivmod.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fudivmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fudivmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fudivmod.c?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,14 @@\n+long udivmodsi4 ();\n+\n+long\n+__udivsi3 (long a, long b)\n+{\n+  return udivmodsi4 (a, b, 0);\n+}\n+\n+long\n+__umodsi3 (long a, long b)\n+{\n+  return udivmodsi4 (a, b, 1);\n+}\n+"}, {"sha": "83c2340c2f8b4f3dd74b263a81278d9dc4c226bc", "filename": "gcc/config/mn10200/udivmodsi4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fudivmodsi4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fudivmodsi4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fudivmodsi4.c?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,24 @@\n+unsigned long\n+udivmodsi4(unsigned long num, unsigned long den, int modwanted)\n+{\n+  unsigned long bit = 1;\n+  unsigned long res = 0;\n+\n+  while (den < num && bit && !(den & (1L<<31)))\n+    {\n+      den <<=1;\n+      bit <<=1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>=1;\n+      den >>=1;\n+    }\n+  if (modwanted) return num;\n+  return res;\n+}"}, {"sha": "7ebac70ed3f5a285d702e2e4bfbe2bdea636f4ce", "filename": "gcc/config/mn10200/xm-mn10200.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fxm-mn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fconfig%2Fmn10200%2Fxm-mn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fxm-mn10200.h?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,47 @@\n+/* Configuration for Matsushita MN10200. \n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT 16\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+\n+#include \"tm.h\"\n+\n+#ifndef __STDC__\n+extern char *malloc (), *realloc (), *calloc ();\n+#else\n+extern void *malloc (), *realloc (), *calloc ();\n+#endif\n+extern void free ();"}, {"sha": "b458b56e0bebb74bd563c0a9ece011d20d77f024", "filename": "gcc/ginclude/va-mn10200.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fginclude%2Fva-mn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c8363da4298ff7810ec10eb434ed74d38e2be4/gcc%2Fginclude%2Fva-mn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mn10200.h?ref=a1c8363da4298ff7810ec10eb434ed74d38e2be4", "patch": "@@ -0,0 +1,37 @@\n+/* CYGNUS LOCAL entire file/law */\n+/* Define __gnuc_va_list. */\n+\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+typedef void *__gnuc_va_list;\n+#endif /* not __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+#define __gnuc_va_start(AP) (AP = (__gnuc_va_list)__builtin_saveregs())\n+#define __va_ellipsis ...\n+\n+#ifdef _STDARG_H\n+#define va_start(AP, LASTARG) \\\n+ (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n+#else\n+#define va_alist __builtin_va_alist\n+#define va_dcl int __builtin_va_alist; __va_ellipsis\n+#define va_start(AP)  AP=(char *) &__builtin_va_alist\n+#endif\n+\n+/* Now stuff common to both varargs & stdarg implementations.  */\n+#define __va_rounded_size(TYPE)\t\t\t\t\t\t\\\n+  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n+#undef va_end\n+void va_end (__gnuc_va_list);\n+#define va_end(AP) ((void)0)\n+#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n+ (sizeof (TYPE) > 8\t\t\t\t\t\t\t\\\n+  ? (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (char *)),\\\n+    **((TYPE **) (void *) ((char *) (AP) - __va_rounded_size (char *))))\\\n+  : (AP = (__gnuc_va_list) ((char *) (AP) + __va_rounded_size (TYPE)),\t\\\n+    *((TYPE *) (void *) ((char *) (AP) - __va_rounded_size (TYPE)))))\n+#endif\n+/* END CYGNUS LOCAL */"}]}