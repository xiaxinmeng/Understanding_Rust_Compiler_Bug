{"sha": "f33a43f9f7eab7482837662821abb7fd02cb4350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMzYTQzZjlmN2VhYjc0ODI4Mzc2NjI4MjFhYmI3ZmQwMmNiNDM1MA==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2020-10-05T10:12:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-05T10:32:10Z"}, "message": "libstdc++: Use correct duration for atomic_futex wait on custom clock [PR 91486]\n\nAs Jonathan Wakely pointed out[1], my change in commit\nf9ddb696a289cc48d24d3d23c0b324cb88de9573 should have been rounding to\nthe target clock duration type rather than the input clock duration type\nin __atomic_futex_unsigned::_M_load_when_equal_until just as (e.g.)\ncondition_variable does.\n\nAs well as fixing this, let's create a rather contrived test that fails\nwith the previous code, but unfortunately only when run on a machine\nwith an uptime of over 208.5 days, and even then not always.\n\n[1] https://gcc.gnu.org/pipermail/libstdc++/2020-September/051004.html\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/91486\n\t* include/bits/atomic_futex.h:\n\t(__atomic_futex_unsigned::_M_load_when_equal_until): Use target\n\tclock duration type when rounding.\n\t* testsuite/30_threads/async/async.cc (test_pr91486_wait_for):\n\tRename from test_pr91486.\n\t(float_steady_clock): New class for test.\n\t(test_pr91486_wait_until): New test.", "tree": {"sha": "ef6c5a6fe39f3d02ec61799440b7a4199ee6679c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef6c5a6fe39f3d02ec61799440b7a4199ee6679c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f33a43f9f7eab7482837662821abb7fd02cb4350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f33a43f9f7eab7482837662821abb7fd02cb4350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f33a43f9f7eab7482837662821abb7fd02cb4350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f33a43f9f7eab7482837662821abb7fd02cb4350/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5243c46266f92f8e5373c3f314aa2abc15c9db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5243c46266f92f8e5373c3f314aa2abc15c9db4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5243c46266f92f8e5373c3f314aa2abc15c9db4"}], "stats": {"total": 64, "additions": 61, "deletions": 3}, "files": [{"sha": "6093be0fbc72d8d7f19a0dafeb95c5fe37f5c004", "filename": "libstdc++-v3/include/bits/atomic_futex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33a43f9f7eab7482837662821abb7fd02cb4350/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33a43f9f7eab7482837662821abb7fd02cb4350/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h?ref=f33a43f9f7eab7482837662821abb7fd02cb4350", "patch": "@@ -235,7 +235,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  const __clock_t::time_point __s_entry = __clock_t::now();\n \t  const auto __delta = __atime - __c_entry;\n \t  const auto __s_atime = __s_entry +\n-\t      chrono::__detail::ceil<_Duration>(__delta);\n+\t      chrono::__detail::ceil<__clock_t::duration>(__delta);\n \t  if (_M_load_when_equal_until(__val, __mo, __s_atime))\n \t    return true;\n \t  __c_entry = _Clock::now();"}, {"sha": "1c779bfbcad4523732978e809eccb9d2fca5507f", "filename": "libstdc++-v3/testsuite/30_threads/async/async.cc", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f33a43f9f7eab7482837662821abb7fd02cb4350/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f33a43f9f7eab7482837662821abb7fd02cb4350/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc?ref=f33a43f9f7eab7482837662821abb7fd02cb4350", "patch": "@@ -157,7 +157,7 @@ void test04()\n   }\n }\n \n-void test_pr91486()\n+void test_pr91486_wait_for()\n {\n   future<void> f1 = async(launch::async, []() {\n       std::this_thread::sleep_for(std::chrono::seconds(1));\n@@ -171,6 +171,63 @@ void test_pr91486()\n   VERIFY( elapsed_steady >= std::chrono::seconds(1) );\n }\n \n+// This is a clock with a very recent epoch which ensures that the difference\n+// between now() and one second in the future is representable in a float so\n+// that when the generic clock version of\n+// __atomic_futex_unsigned::_M_load_when_equal_until calculates the delta it\n+// gets a duration of 1.0f.  When chrono::steady_clock has moved sufficiently\n+// far from its epoch (about 208.5 days in my testing - about 2^54ns because\n+// there's a promotion to double happening too somewhere) adding 1.0f to the\n+// current time has no effect.  Using this clock ensures that\n+// __atomic_futex_unsigned::_M_load_when_equal_until is using\n+// chrono::__detail::ceil correctly so that the function actually sleeps rather\n+// than spinning.\n+struct float_steady_clock\n+{\n+  using duration = std::chrono::duration<float>;\n+  using rep = typename duration::rep;\n+  using period = typename duration::period;\n+  using time_point = std::chrono::time_point<float_steady_clock, duration>;\n+  static constexpr bool is_steady = true;\n+\n+  static chrono::steady_clock::time_point epoch;\n+  static int call_count;\n+\n+  static time_point now()\n+  {\n+    ++call_count;\n+    auto real = std::chrono::steady_clock::now();\n+    return time_point{real - epoch};\n+  }\n+};\n+\n+chrono::steady_clock::time_point float_steady_clock::epoch = chrono::steady_clock::now();\n+int float_steady_clock::call_count = 0;\n+\n+void test_pr91486_wait_until()\n+{\n+  future<void> f1 = async(launch::async, []() {\n+      std::this_thread::sleep_for(std::chrono::seconds(1));\n+    });\n+\n+  float_steady_clock::time_point const now = float_steady_clock::now();\n+\n+  std::chrono::duration<float> const wait_time = std::chrono::seconds(1);\n+  float_steady_clock::time_point const expire = now + wait_time;\n+  VERIFY( expire > now );\n+\n+  auto const start_steady = chrono::steady_clock::now();\n+  auto status = f1.wait_until(expire);\n+  auto const elapsed_steady = chrono::steady_clock::now() - start_steady;\n+\n+  // This checks that we didn't come back too soon\n+  VERIFY( elapsed_steady >= std::chrono::seconds(1) );\n+\n+  // This checks that wait_until didn't busy wait checking the clock more times\n+  // than necessary.\n+  VERIFY( float_steady_clock::call_count <= 3 );\n+}\n+\n int main()\n {\n   test01();\n@@ -179,6 +236,7 @@ int main()\n   test03<std::chrono::steady_clock>();\n   test03<steady_clock_copy>();\n   test04();\n-  test_pr91486();\n+  test_pr91486_wait_for();\n+  test_pr91486_wait_until();\n   return 0;\n }"}]}