{"sha": "1378bf105ea73f1d4fab574dc8ed6d1479433296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM3OGJmMTA1ZWE3M2YxZDRmYWI1NzRkYzhlZDZkMTQ3OTQzMzI5Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T10:19:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T10:19:00Z"}, "message": "[multiple changes]\n\n2011-08-29  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_type.adb: Minor reformatting.\n\n2011-08-29  Robert Dewar  <dewar@adacore.com>\n\n\t* makeutl.adb: Minor reformatting.\n\n2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Object_Renaming): If the renamed object is a\n\tfunction call of a limited type, the expansion of the renaming is\n\tcomplicated by the presence of various temporaries and subtypes that\n\tcapture constraints of the renamed object.\n\tRewrite node as an object declaration, whose expansion is simpler.\n\tGiven that the object is limited there is no copy involved and no\n\tperformance hit.\n\nFrom-SVN: r178187", "tree": {"sha": "28305a5dec129da5c93001b73f0d5239be6459fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28305a5dec129da5c93001b73f0d5239be6459fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1378bf105ea73f1d4fab574dc8ed6d1479433296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1378bf105ea73f1d4fab574dc8ed6d1479433296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1378bf105ea73f1d4fab574dc8ed6d1479433296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1378bf105ea73f1d4fab574dc8ed6d1479433296/comments", "author": null, "committer": null, "parents": [{"sha": "164e06c6c1fcb98089ed09959d251376ca1717dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/164e06c6c1fcb98089ed09959d251376ca1717dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/164e06c6c1fcb98089ed09959d251376ca1717dc"}], "stats": {"total": 100, "additions": 73, "deletions": 27}, "files": [{"sha": "89975863d6ec08528eccc77d053ee6852e758ead", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1378bf105ea73f1d4fab574dc8ed6d1479433296", "patch": "@@ -1,3 +1,21 @@\n+2011-08-29  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_type.adb: Minor reformatting.\n+\n+2011-08-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* makeutl.adb: Minor reformatting.\n+\n+2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Object_Renaming): If the renamed object is a\n+\tfunction call of a limited type, the expansion of the renaming is\n+\tcomplicated by the presence of various temporaries and subtypes that\n+\tcapture constraints of the renamed object.\n+\tRewrite node as an object declaration, whose expansion is simpler.\n+\tGiven that the object is limited there is no copy involved and no\n+\tperformance hit.\n+\n 2011-08-29  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb, sinfo.ads, make.adb, s-pooglo.adb, sem_ch12.adb,"}, {"sha": "848db592a1ad0ed9d65910c92c95ae17a6572436", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=1378bf105ea73f1d4fab574dc8ed6d1479433296", "patch": "@@ -1560,13 +1560,17 @@ package body Makeutl is\n \n                         if Is_Absolute_Path (Main) then\n                            Main_Id := Create_Name (Base);\n+\n+                        --  Not an absolute path\n+\n                         else\n+                           --  Always resolve links here, so that users can be\n+                           --  specify any name on the command line. If the\n+                           --  project itself uses links, the user will be\n+                           --  using -eL anyway, and thus files are also stored\n+                           --  with resolved names.\n+\n                            declare\n-                              --  Always resolve links here, so that users\n-                              --  can be specify any name on the command line.\n-                              --  If the project itself uses links, the user\n-                              --  will be using -eL anyway, and thus files are\n-                              --  also stored with resolved names.\n                               Absolute : constant String :=\n                                            Normalize_Pathname\n                                              (Name           => Main,"}, {"sha": "8a144623db74bbf19d09d3a16e214194e113b00d", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=1378bf105ea73f1d4fab574dc8ed6d1479433296", "patch": "@@ -682,9 +682,10 @@ package body Sem_Ch8 is\n    -----------------------------\n \n    procedure Analyze_Object_Renaming (N : Node_Id) is\n-      Id  : constant Entity_Id := Defining_Identifier (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Id  : constant Entity_Id  := Defining_Identifier (N);\n       Dec : Node_Id;\n-      Nam : constant Node_Id   := Name (N);\n+      Nam : constant Node_Id    := Name (N);\n       T   : Entity_Id;\n       T2  : Entity_Id;\n \n@@ -704,7 +705,6 @@ package body Sem_Ch8 is\n       ------------------------------\n \n       procedure Check_Constrained_Object is\n-         Loc  : constant Source_Ptr := Sloc (N);\n          Subt : Entity_Id;\n \n       begin\n@@ -805,6 +805,29 @@ package body Sem_Ch8 is\n \n          Resolve (Nam, T);\n \n+         --  If the renamed object is a function call of a limited type,\n+         --  the expansion of the renaming is complicated by the presence\n+         --  of various temporaries and subtypes that capture constraints\n+         --  of the renamed object. Rewrite node as an object declaration,\n+         --  whose expansion is simpler. Given that the object is limited\n+         --  there is no copy involved and no performance hit.\n+\n+         if Nkind (Nam) = N_Function_Call\n+           and then Is_Immutably_Limited_Type (Etype (Nam))\n+           and then not Is_Constrained (T)\n+           and then Comes_From_Source (N)\n+         then\n+            Set_Etype (Id, T);\n+            Set_Ekind (Id, E_Constant);\n+            Rewrite (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Id,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (T, Loc),\n+                Expression          => Relocate_Node (Nam)));\n+            return;\n+         end if;\n+\n          --  Check that a class-wide object is not being renamed as an object\n          --  of a specific type. The test for access types is needed to exclude\n          --  cases where the renamed object is a dynamically tagged access\n@@ -2330,9 +2353,7 @@ package body Sem_Ch8 is\n          --  of a generic, its entity is set to the first available homonym.\n          --  We must first disambiguate the name, then set the proper entity.\n \n-         if Is_Actual\n-           and then Is_Overloaded (Nam)\n-         then\n+         if Is_Actual and then Is_Overloaded (Nam) then\n             Set_Entity (Nam, Old_S);\n          end if;\n       end if;\n@@ -2403,9 +2424,7 @@ package body Sem_Ch8 is\n       end if;\n \n       if Old_S /= Any_Id then\n-         if Is_Actual\n-           and then From_Default (N)\n-         then\n+         if Is_Actual and then From_Default (N) then\n             --  This is an implicit reference to the default actual\n \n             Generate_Reference (Old_S, Nam, Typ => 'i', Force => True);"}, {"sha": "70a94234d3e2dda684d4470fda35e4d260f3b741", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1378bf105ea73f1d4fab574dc8ed6d1479433296/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=1378bf105ea73f1d4fab574dc8ed6d1479433296", "patch": "@@ -569,31 +569,34 @@ package body Sem_Type is\n       Ent          : constant Entity_Id := Entity (N);\n       H            : Entity_Id;\n       First_Interp : Interp_Index;\n+\n       function Within_Instance (E : Entity_Id) return Boolean;\n       --  Within an instance there can be spurious ambiguities between a local\n-      --  entity and one declared outside of the instance. This can only\n-      --  happen for subprograms, because otherwise the local entity hides the\n-      --  outer one. For overloadable entities, this predicate determines\n-      --  whether it is a candidate within the instance, or must be ignored.\n+      --  entity and one declared outside of the instance. This can only happen\n+      --  for subprograms, because otherwise the local entity hides the outer\n+      --  one. For an overloadable entity, this predicate determines whether it\n+      --  is a candidate within the instance, or must be ignored.\n+\n+      ---------------------\n+      -- Within_Instance --\n+      ---------------------\n \n       function Within_Instance (E : Entity_Id) return Boolean is\n          Inst : Entity_Id;\n          Scop : Entity_Id;\n+\n       begin\n          if not In_Instance then\n             return False;\n          end if;\n+\n          Inst := Current_Scope;\n-         while Present (Inst)\n-           and then not Is_Generic_Instance (Inst)\n-         loop\n+         while Present (Inst) and then not Is_Generic_Instance (Inst) loop\n             Inst := Scope (Inst);\n          end loop;\n-         Scop := Scope (E);\n \n-         while Present (Scop)\n-           and then Scop /= Standard_Standard\n-         loop\n+         Scop := Scope (E);\n+         while Present (Scop) and then Scop /= Standard_Standard loop\n             if Scop = Inst then\n                return True;\n             end if;\n@@ -603,6 +606,8 @@ package body Sem_Type is\n          return False;\n       end Within_Instance;\n \n+   --  Start of processing for Collect_Interps\n+\n    begin\n       New_Interps (N);\n \n@@ -660,8 +665,8 @@ package body Sem_Type is\n                      --  within the instance must not be included.\n \n                      if Within_Instance (H)\n-                        and then H /= Renamed_Entity (Ent)\n-                        and then not Is_Inherited_Operation (H)\n+                       and then H /= Renamed_Entity (Ent)\n+                       and then not Is_Inherited_Operation (H)\n                      then\n                         All_Interp.Table (All_Interp.Last) :=\n                           (H, Etype (H), Empty);"}]}