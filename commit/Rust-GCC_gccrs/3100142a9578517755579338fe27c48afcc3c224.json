{"sha": "3100142a9578517755579338fe27c48afcc3c224", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwMDE0MmE5NTc4NTE3NzU1NTc5MzM4ZmUyN2M0OGFmY2MzYzIyNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2014-01-29T22:50:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-01-29T22:50:22Z"}, "message": "ipa-inline-analysis.c (clobber_only_eh_bb_p): New function.\n\n\t* ipa-inline-analysis.c (clobber_only_eh_bb_p): New function.\n\t(estimate_function_body_sizes): Use it.\n\nFrom-SVN: r207287", "tree": {"sha": "09092aa76aa36e636fa3d25ecb7d1dee5779b6cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09092aa76aa36e636fa3d25ecb7d1dee5779b6cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3100142a9578517755579338fe27c48afcc3c224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3100142a9578517755579338fe27c48afcc3c224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3100142a9578517755579338fe27c48afcc3c224", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3100142a9578517755579338fe27c48afcc3c224/comments", "author": null, "committer": null, "parents": [{"sha": "0429e064651d53720971f398de7124d9b46a09cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0429e064651d53720971f398de7124d9b46a09cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0429e064651d53720971f398de7124d9b46a09cc"}], "stats": {"total": 61, "additions": 61, "deletions": 0}, "files": [{"sha": "5dba715e4b72bd2d509bbe3b77ced901b1f29a4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3100142a9578517755579338fe27c48afcc3c224/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3100142a9578517755579338fe27c48afcc3c224/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3100142a9578517755579338fe27c48afcc3c224", "patch": "@@ -1,3 +1,8 @@\n+2014-01-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c (clobber_only_eh_bb_p): New function.\n+\t(estimate_function_body_sizes): Use it.\n+\n 2014-01-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58561"}, {"sha": "9a4c6df2cb340c6e10c289ad43e8f769a3b87c42", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3100142a9578517755579338fe27c48afcc3c224/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3100142a9578517755579338fe27c48afcc3c224/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=3100142a9578517755579338fe27c48afcc3c224", "patch": "@@ -2347,6 +2347,54 @@ find_foldable_builtin_expect (basic_block bb)\n   return NULL;\n }\n \n+/* Return true when the basic blocks contains only clobbers followed by RESX.\n+   Such BBs are kept around to make removal of dead stores possible with\n+   presence of EH and will be optimized out by optimize_clobbers later in the\n+   game. \n+\n+   NEED_EH is used to recurse in case the clobber has non-EH predecestors\n+   that can be clobber only, too.. When it is false, the RESX is not necessary\n+   on the end of basic block.  */\n+\n+static bool\n+clobber_only_eh_bb_p (basic_block bb, bool need_eh = true)\n+{\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  edge_iterator ei;\n+  edge e;\n+\n+  if (need_eh)\n+    {\n+      if (gsi_end_p (gsi))\n+\treturn false;\n+      if (gimple_code (gsi_stmt (gsi)) != GIMPLE_RESX)\n+        return false;\n+      gsi_prev (&gsi);\n+    }\n+  else if (!single_succ_p (bb))\n+    return false;\n+\n+  for (; !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      if (gimple_clobber_p (stmt))\n+\tcontinue;\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tbreak;\n+      return false;\n+    }\n+\n+  /* See if all predecestors are either throws or clobber only BBs.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (!(e->flags & EDGE_EH)\n+\t&& !clobber_only_eh_bb_p (e->src, false))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Compute function body size parameters for NODE.\n    When EARLY is true, we compute only simple summaries without\n    non-trivial predicates to drive the early inliner.  */\n@@ -2410,6 +2458,14 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, order[n]);\n       freq = compute_call_stmt_bb_frequency (node->decl, bb);\n+      if (clobber_only_eh_bb_p (bb))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"\\n Ignoring BB %i;\"\n+\t\t     \" it will be optimized away by cleanup_clobbers\\n\",\n+\t\t     bb->index);\n+\t  continue;\n+\t}\n \n       /* TODO: Obviously predicates can be propagated down across CFG.  */\n       if (parms_info)"}]}