{"sha": "2f97d24cad349a09ee1beb3e20b636925aa9baa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5N2QyNGNhZDM0OWEwOWVlMWJlYjNlMjBiNjM2OTI1YWE5YmFhOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-27T11:56:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-27T11:56:12Z"}, "message": "[multiple changes]\n\n2015-10-27  Tristan Gingold  <gingold@adacore.com>\n\n\t* bindgen.adb (System_BB_CPU_Primitives_Multiprocessors_Used):\n\tNew variable.\n\t(Gen_Adainit): Call Start_All_CPUs if the above\n\tvariable is set to true.\n\n2015-10-27  Emmanuel Briot  <briot@adacore.com>\n\n\t* adaint.c, s-os_lib.adb, s-os_lib.ads (Copy_File_Attributes): New\n\tsubprogram.\n\nFrom-SVN: r229429", "tree": {"sha": "35eda234e18f129cc90e7b4653320126aa073196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35eda234e18f129cc90e7b4653320126aa073196"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f97d24cad349a09ee1beb3e20b636925aa9baa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f97d24cad349a09ee1beb3e20b636925aa9baa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f97d24cad349a09ee1beb3e20b636925aa9baa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f97d24cad349a09ee1beb3e20b636925aa9baa9/comments", "author": null, "committer": null, "parents": [{"sha": "4e48e02be82c63ebe6687bca93f07b76b5765261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e48e02be82c63ebe6687bca93f07b76b5765261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e48e02be82c63ebe6687bca93f07b76b5765261"}], "stats": {"total": 1198, "additions": 664, "deletions": 534}, "files": [{"sha": "0065f94408737138e9397d024fb05688b7796f7f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2f97d24cad349a09ee1beb3e20b636925aa9baa9", "patch": "@@ -1,3 +1,15 @@\n+2015-10-27  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* bindgen.adb (System_BB_CPU_Primitives_Multiprocessors_Used):\n+\tNew variable.\n+\t(Gen_Adainit): Call Start_All_CPUs if the above\n+\tvariable is set to true.\n+\n+2015-10-27  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* adaint.c, s-os_lib.adb, s-os_lib.ads (Copy_File_Attributes): New\n+\tsubprogram.\n+\n 2015-10-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* namet.adb, namet.ads: Minor reformatting."}, {"sha": "5fef49cc4c07220dde432990adebb1bd3c0da2f9", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=2f97d24cad349a09ee1beb3e20b636925aa9baa9", "patch": "@@ -2902,6 +2902,8 @@ char __gnat_environment_char = '$';\n    mode = 1  : In this mode, time stamps and read/write/execute attributes are\n                copied.\n \n+   mode = 2  : In this mode, only read/write/execute attributes are copied\n+\n    Returns 0 if operation was successful and -1 in case of error. */\n \n int\n@@ -2921,39 +2923,46 @@ __gnat_copy_attribs (char *from ATTRIBUTE_UNUSED, char *to ATTRIBUTE_UNUSED,\n   S2WSC (wfrom, from, GNAT_MAX_PATH_LEN + 2);\n   S2WSC (wto, to, GNAT_MAX_PATH_LEN + 2);\n \n-  /* retrieve from times */\n+  /*  Do we need to copy the timestamp ? */\n \n-  hfrom = CreateFile\n-    (wfrom, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n+  if (mode != 2) {\n+     /* retrieve from times */\n \n-  if (hfrom == INVALID_HANDLE_VALUE)\n-    return -1;\n+     hfrom = CreateFile\n+       (wfrom, GENERIC_READ, 0, NULL, OPEN_EXISTING,\n+        FILE_ATTRIBUTE_NORMAL, NULL);\n \n-  res = GetFileTime (hfrom, &fct, &flat, &flwt);\n+     if (hfrom == INVALID_HANDLE_VALUE)\n+       return -1;\n \n-  CloseHandle (hfrom);\n+     res = GetFileTime (hfrom, &fct, &flat, &flwt);\n \n-  if (res == 0)\n-    return -1;\n+     CloseHandle (hfrom);\n \n-  /* retrieve from times */\n+     if (res == 0)\n+       return -1;\n \n-  hto = CreateFile\n-    (wto, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n+     /* retrieve from times */\n \n-  if (hto == INVALID_HANDLE_VALUE)\n-    return -1;\n+     hto = CreateFile\n+       (wto, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\n+        FILE_ATTRIBUTE_NORMAL, NULL);\n \n-  res = SetFileTime (hto, NULL, &flat, &flwt);\n+     if (hto == INVALID_HANDLE_VALUE)\n+       return -1;\n \n-  CloseHandle (hto);\n+     res = SetFileTime (hto, NULL, &flat, &flwt);\n \n-  if (res == 0)\n-    return -1;\n+     CloseHandle (hto);\n \n+     if (res == 0)\n+       return -1;\n+  }\n+\n+  /* Do we need to copy the permissions ? */\n   /* Set file attributes in full mode. */\n \n-  if (mode == 1)\n+  if (mode != 0)\n     {\n       DWORD attribs = GetFileAttributes (wfrom);\n \n@@ -2971,26 +2980,24 @@ __gnat_copy_attribs (char *from ATTRIBUTE_UNUSED, char *to ATTRIBUTE_UNUSED,\n   GNAT_STRUCT_STAT fbuf;\n   struct utimbuf tbuf;\n \n-  if (GNAT_STAT (from, &fbuf) == -1)\n-    {\n-      return -1;\n-    }\n+  if (GNAT_STAT (from, &fbuf) == -1) {\n+     return -1;\n+  }\n \n-  tbuf.actime = fbuf.st_atime;\n-  tbuf.modtime = fbuf.st_mtime;\n+  /* Do we need to copy timestamp ? */\n+  if (mode != 2) {\n+     tbuf.actime = fbuf.st_atime;\n+     tbuf.modtime = fbuf.st_mtime;\n \n-  if (utime (to, &tbuf) == -1)\n-    {\n-      return -1;\n-    }\n+     if (utime (to, &tbuf) == -1) {\n+        return -1;\n+     }\n+  }\n \n-  if (mode == 1)\n-    {\n-      if (chmod (to, fbuf.st_mode) == -1)\n-\t{\n+  /* Do we need to copy file permissions ? */\n+  if (mode != 0 && (chmod (to, fbuf.st_mode) == -1)) {\n \t  return -1;\n-\t}\n-    }\n+  }\n \n   return 0;\n #endif"}, {"sha": "098a1aeab1476de16f831875aa0c83963f773ce2", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=2f97d24cad349a09ee1beb3e20b636925aa9baa9", "patch": "@@ -88,6 +88,12 @@ package body Bindgen is\n    --  attach interrupt handlers at the end of the elaboration when partition\n    --  elaboration policy is sequential.\n \n+   System_BB_CPU_Primitives_Multiprocessors_Used : Boolean := False;\n+   --  Flag indicating wether the unit System.BB.CPU_Primitives.Multiprocessors\n+   --  is in the closure of the partiation. This is set by procedure\n+   --  Resolve_Binder_Options, and it is used to call a procedure that starts\n+   --  slave processors.\n+\n    Lib_Final_Built : Boolean := False;\n    --  Flag indicating whether the finalize_library rountine has been built\n \n@@ -536,6 +542,13 @@ package body Bindgen is\n             WBI (\"      procedure Activate_All_Tasks_Sequential;\");\n             WBI (\"      pragma Import (C, Activate_All_Tasks_Sequential,\" &\n                  \" \"\"__gnat_activate_all_tasks\"\");\");\n+            WBI (\"\");\n+         end if;\n+\n+         if System_BB_CPU_Primitives_Multiprocessors_Used then\n+            WBI (\"      procedure Start_Slave_CPUs;\");\n+            WBI (\"      pragma Import (C, Start_Slave_CPUs,\" &\n+                 \" \"\"__gnat_start_slave_cpus\"\");\");\n          end if;\n \n          WBI (\"   begin\");\n@@ -944,6 +957,10 @@ package body Bindgen is\n          end if;\n       end if;\n \n+      if System_BB_CPU_Primitives_Multiprocessors_Used then\n+         WBI (\"      Start_Slave_CPUs;\");\n+      end if;\n+\n       WBI (\"   end \" & Ada_Init_Name.all & \";\");\n       WBI (\"\");\n    end Gen_Adainit;\n@@ -2872,6 +2889,12 @@ package body Bindgen is\n          --  Ditto for the use of restrictions\n \n          Check_Package (System_Restrictions_Used, \"system.restrictions%s\");\n+\n+         --  Ditto for use of an SMP bareboard runtime\n+\n+         Check_Package (System_BB_CPU_Primitives_Multiprocessors_Used,\n+                        \"system.bb.cpu_primitives.multiprocessors%s\");\n+\n       end loop;\n    end Resolve_Binder_Options;\n "}, {"sha": "dad157861da0e24a770110cdb80e20166734c9e0", "filename": "gcc/ada/s-os_lib.adb", "status": "modified", "additions": 151, "deletions": 75, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=2f97d24cad349a09ee1beb3e20b636925aa9baa9", "patch": "@@ -55,11 +55,13 @@ package body System.OS_Lib is\n    pragma Import (C, Dup2, \"__gnat_dup2\");\n \n    function Copy_Attributes\n-     (From, To : System.Address;\n-      Mode     : Integer) return Integer;\n+     (From : System.Address;\n+      To   : System.Address;\n+      Mode : Integer) return Integer;\n    pragma Import (C, Copy_Attributes, \"__gnat_copy_attribs\");\n    --  Mode = 0 - copy only time stamps.\n    --  Mode = 1 - copy time stamps and read/write/execute attributes\n+   --  Mode = 2 - copy read/write/execute attributes\n \n    On_Windows : constant Boolean := Directory_Separator = '\\';\n    --  An indication that we are on Windows. Used in Normalize_Pathname, to\n@@ -324,7 +326,7 @@ package body System.OS_Lib is\n       --  Returns pathname Dir concatenated with File adding the directory\n       --  separator only if needed.\n \n-      procedure Copy (From, To : File_Descriptor);\n+      procedure Copy (From : File_Descriptor; To : File_Descriptor);\n       --  Read data from From and place them into To. In both cases the\n       --  operations uses the current file position. Raises Constraint_Error\n       --  if a problem occurs during the copy.\n@@ -337,11 +339,6 @@ package body System.OS_Lib is\n       ----------------\n \n       function Build_Path (Dir : String; File : String) return String is\n-         Res : String (1 .. Dir'Length + File'Length + 1);\n-\n-         Base_File_Ptr : Integer;\n-         --  The base file name is File (Base_File_Ptr + 1 .. File'Last)\n-\n          function Is_Dirsep (C : Character) return Boolean;\n          pragma Inline (Is_Dirsep);\n          --  Returns True if C is a directory separator. On Windows we\n@@ -356,6 +353,13 @@ package body System.OS_Lib is\n             return C = Directory_Separator or else C = '/';\n          end Is_Dirsep;\n \n+         --  Local variables\n+\n+         Base_File_Ptr : Integer;\n+         --  The base file name is File (Base_File_Ptr + 1 .. File'Last)\n+\n+         Res : String (1 .. Dir'Length + File'Length + 1);\n+\n       --  Start of processing for Build_Path\n \n       begin\n@@ -392,7 +396,7 @@ package body System.OS_Lib is\n       -- Copy --\n       ----------\n \n-      procedure Copy (From, To : File_Descriptor) is\n+      procedure Copy (From : File_Descriptor; To : File_Descriptor) is\n          Buf_Size : constant := 200_000;\n          type Buf is array (1 .. Buf_Size) of Character;\n          type Buf_Ptr is access Buf;\n@@ -490,7 +494,6 @@ package body System.OS_Lib is\n          C_To (C_To'Last) := ASCII.NUL;\n \n          case Preserve is\n-\n             when Time_Stamps =>\n                if Copy_Attributes (C_From'Address, C_To'Address, 0) = -1 then\n                   raise Copy_Error;\n@@ -621,11 +624,55 @@ package body System.OS_Lib is\n       Free (Ada_Pathname);\n    end Copy_File;\n \n+   --------------------------\n+   -- Copy_File_Attributes --\n+   --------------------------\n+\n+   procedure Copy_File_Attributes\n+     (From             : String;\n+      To               : String;\n+      Success          : out Boolean;\n+      Copy_Timestamp   : Boolean := True;\n+      Copy_Permissions : Boolean := True)\n+   is\n+      F    : aliased String (1 .. From'Length + 1);\n+      Mode : Integer;\n+      T    : aliased String (1 .. To'Length + 1);\n+\n+   begin\n+      if Copy_Timestamp then\n+         if Copy_Permissions then\n+            Mode := 1;\n+         else\n+            Mode := 0;\n+         end if;\n+      else\n+         if Copy_Permissions then\n+            Mode := 2;\n+         else\n+            Success := True;\n+            return;  --  nothing to do\n+         end if;\n+      end if;\n+\n+      F (1 .. From'Length) := From;\n+      F (F'Last) := ASCII.NUL;\n+\n+      T (1 .. To'Length) := To;\n+      T (T'Last) := ASCII.NUL;\n+\n+      Success := Copy_Attributes (F'Address, T'Address, Mode) /= -1;\n+   end Copy_File_Attributes;\n+\n    ----------------------\n    -- Copy_Time_Stamps --\n    ----------------------\n \n-   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean) is\n+   procedure Copy_Time_Stamps\n+     (Source  : String;\n+      Dest    : String;\n+      Success : out Boolean)\n+   is\n    begin\n       if Is_Regular_File (Source) and then Is_Writable_File (Dest) then\n          declare\n@@ -652,8 +699,9 @@ package body System.OS_Lib is\n    end Copy_Time_Stamps;\n \n    procedure Copy_Time_Stamps\n-     (Source, Dest : C_File_Name;\n-      Success      : out Boolean)\n+     (Source  : C_File_Name;\n+      Dest    : C_File_Name;\n+      Success : out Boolean)\n    is\n       Ada_Source : String_Access :=\n                      To_Path_String_Access\n@@ -726,10 +774,11 @@ package body System.OS_Lib is\n    -----------------------------\n \n    function Create_Output_Text_File (Name : String) return File_Descriptor is\n-      function C_Create_File\n-        (Name : C_File_Name) return File_Descriptor;\n+      function C_Create_File (Name : C_File_Name) return File_Descriptor;\n       pragma Import (C, C_Create_File, \"__gnat_create_output_file\");\n+\n       C_Name : String (1 .. Name'Length + 1);\n+\n    begin\n       C_Name (1 .. Name'Length) := Name;\n       C_Name (C_Name'Last)      := ASCII.NUL;\n@@ -801,10 +850,11 @@ package body System.OS_Lib is\n       function Create_New_Output_Text_File\n         (Name : String) return File_Descriptor\n       is\n-         function C_Create_File\n-           (Name : C_File_Name) return File_Descriptor;\n+         function C_Create_File (Name : C_File_Name) return File_Descriptor;\n          pragma Import (C, C_Create_File, \"__gnat_create_output_file_new\");\n+\n          C_Name : String (1 .. Name'Length + 1);\n+\n       begin\n          C_Name (1 .. Name'Length) := Name;\n          C_Name (C_Name'Last)      := ASCII.NUL;\n@@ -1036,9 +1086,9 @@ package body System.OS_Lib is\n       procedure Get_Suffix_Ptr (Length, Ptr : Address);\n       pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_debuggable_suffix_ptr\");\n \n-      Suffix_Ptr    : Address;\n-      Suffix_Length : Integer;\n       Result        : String_Access;\n+      Suffix_Length : Integer;\n+      Suffix_Ptr    : Address;\n \n    begin\n       Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n@@ -1059,9 +1109,9 @@ package body System.OS_Lib is\n       procedure Get_Suffix_Ptr (Length, Ptr : Address);\n       pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_executable_suffix_ptr\");\n \n-      Suffix_Ptr    : Address;\n-      Suffix_Length : Integer;\n       Result        : String_Access;\n+      Suffix_Length : Integer;\n+      Suffix_Ptr    : Address;\n \n    begin\n       Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n@@ -1082,9 +1132,9 @@ package body System.OS_Lib is\n       procedure Get_Suffix_Ptr (Length, Ptr : Address);\n       pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_object_suffix_ptr\");\n \n-      Suffix_Ptr    : Address;\n-      Suffix_Length : Integer;\n       Result        : String_Access;\n+      Suffix_Length : Integer;\n+      Suffix_Ptr    : Address;\n \n    begin\n       Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n@@ -1106,8 +1156,8 @@ package body System.OS_Lib is\n       pragma Import\n         (C, Target_Exec_Ext_Ptr, \"__gnat_target_debuggable_extension\");\n \n-      Suffix_Length : Integer;\n       Result        : String_Access;\n+      Suffix_Length : Integer;\n \n    begin\n       Suffix_Length := Integer (CRTL.strlen (Target_Exec_Ext_Ptr));\n@@ -1130,8 +1180,8 @@ package body System.OS_Lib is\n       pragma Import\n         (C, Target_Exec_Ext_Ptr, \"__gnat_target_executable_extension\");\n \n-      Suffix_Length : Integer;\n       Result        : String_Access;\n+      Suffix_Length : Integer;\n \n    begin\n       Suffix_Length := Integer (CRTL.strlen (Target_Exec_Ext_Ptr));\n@@ -1154,8 +1204,8 @@ package body System.OS_Lib is\n       pragma Import\n         (C, Target_Object_Ext_Ptr, \"__gnat_target_object_extension\");\n \n-      Suffix_Length : Integer;\n       Result        : String_Access;\n+      Suffix_Length : Integer;\n \n    begin\n       Suffix_Length := Integer (CRTL.strlen (Target_Object_Ext_Ptr));\n@@ -1308,7 +1358,13 @@ package body System.OS_Lib is\n       Second : out Second_Type)\n    is\n       procedure To_GM_Time\n-        (P_Time_T, P_Year, P_Month, P_Day, P_Hours, P_Mins, P_Secs : Address);\n+        (P_Time_T : Address;\n+         P_Year   : Address;\n+         P_Month  : Address;\n+         P_Day    : Address;\n+         P_Hours  : Address;\n+         P_Mins   : Address;\n+         P_Secs   : Address);\n       pragma Import (C, To_GM_Time, \"__gnat_to_gm_time\");\n \n       T  : OS_Time := Date;\n@@ -1325,8 +1381,13 @@ package body System.OS_Lib is\n       Locked_Processing : begin\n          SSL.Lock_Task.all;\n          To_GM_Time\n-           (T'Address, Y'Address, Mo'Address, D'Address,\n-            H'Address, Mn'Address, S'Address);\n+           (P_Time_T => T'Address,\n+            P_Year   => Y'Address,\n+            P_Month  => Mo'Address,\n+            P_Day    => D'Address,\n+            P_Hours  => H'Address,\n+            P_Mins   => Mn'Address,\n+            P_Secs   => S'Address);\n          SSL.Unlock_Task.all;\n \n       exception\n@@ -1356,12 +1417,26 @@ package body System.OS_Lib is\n       Second : Second_Type) return OS_Time\n    is\n       procedure To_OS_Time\n-        (P_Time_T : Address; Year, Month, Day, Hours, Mins, Secs : Integer);\n+        (P_Time_T : Address;\n+         P_Year   : Integer;\n+         P_Month  : Integer;\n+         P_Day    : Integer;\n+         P_Hours  : Integer;\n+         P_Mins   : Integer;\n+         P_Secs   : Integer);\n       pragma Import (C, To_OS_Time, \"__gnat_to_os_time\");\n+\n       Result : OS_Time;\n+\n    begin\n       To_OS_Time\n-        (Result'Address, Year - 1900, Month - 1, Day, Hour, Minute, Second);\n+        (P_Time_T => Result'Address,\n+         P_Year   => Year - 1900,\n+         P_Month  => Month - 1,\n+         P_Day    => Day,\n+         P_Hours  => Hour,\n+         P_Mins   => Minute,\n+         P_Secs   => Second);\n       return Result;\n    end GM_Time_Of;\n \n@@ -1644,9 +1719,10 @@ package body System.OS_Lib is\n      (Program_Name : String;\n       Args         : Argument_List) return Process_Id\n    is\n-      Pid  : Process_Id;\n       Junk : Integer;\n       pragma Warnings (Off, Junk);\n+      Pid  : Process_Id;\n+\n    begin\n       Spawn_Internal (Program_Name, Args, Junk, Pid, Blocking => False);\n       return Pid;\n@@ -1658,9 +1734,9 @@ package body System.OS_Lib is\n       Output_File_Descriptor : File_Descriptor;\n       Err_To_Out             : Boolean := True) return Process_Id\n    is\n-      Saved_Output : File_Descriptor;\n-      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning\n       Pid          : Process_Id;\n+      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning\n+      Saved_Output : File_Descriptor;\n \n    begin\n       if Output_File_Descriptor = Invalid_FD then\n@@ -1717,8 +1793,9 @@ package body System.OS_Lib is\n          return Invalid_Pid;\n \n       else\n-         Result := Non_Blocking_Spawn\n-                     (Program_Name, Args, Output_File_Descriptor, Err_To_Out);\n+         Result :=\n+          Non_Blocking_Spawn\n+            (Program_Name, Args, Output_File_Descriptor, Err_To_Out);\n \n          --  Close the file just created for the output, as the file descriptor\n          --  cannot be used anywhere, being a local value. It is safe to do\n@@ -1737,15 +1814,14 @@ package body System.OS_Lib is\n       Stdout_File  : String;\n       Stderr_File  : String) return Process_Id\n    is\n-      Stdout_FD : constant File_Descriptor :=\n-                     Create_Output_Text_File (Stdout_File);\n       Stderr_FD : constant File_Descriptor :=\n-                     Create_Output_Text_File (Stderr_File);\n+                    Create_Output_Text_File (Stderr_File);\n+      Stdout_FD : constant File_Descriptor :=\n+                    Create_Output_Text_File (Stdout_File);\n \n-      Saved_Output : File_Descriptor;\n+      Result       : Process_Id;\n       Saved_Error  : File_Descriptor;\n-\n-      Result : Process_Id;\n+      Saved_Output : File_Descriptor;\n \n    begin\n       --  Do not attempt to spawn if the output files could not be created\n@@ -1784,7 +1860,6 @@ package body System.OS_Lib is\n    -------------------------\n \n    procedure Normalize_Arguments (Args : in out Argument_List) is\n-\n       procedure Quote_Argument (Arg : in out String_Access);\n       --  Add quote around argument if it contains spaces (or HT characters)\n \n@@ -1797,9 +1872,9 @@ package body System.OS_Lib is\n       --------------------\n \n       procedure Quote_Argument (Arg : in out String_Access) is\n-         Res          : String (1 .. Arg'Length * 2);\n          J            : Positive := 1;\n          Quote_Needed : Boolean  := False;\n+         Res          : String (1 .. Arg'Length * 2);\n \n       begin\n          if Arg (Arg'First) /= '\"' or else Arg (Arg'Last) /= '\"' then\n@@ -1896,33 +1971,19 @@ package body System.OS_Lib is\n       Resolve_Links  : Boolean := True;\n       Case_Sensitive : Boolean := True) return String\n    is\n-      Max_Path : Integer;\n-      pragma Import (C, Max_Path, \"__gnat_max_path_len\");\n-      --  Maximum length of a path name\n-\n       procedure Get_Current_Dir\n         (Dir    : System.Address;\n          Length : System.Address);\n       pragma Import (C, Get_Current_Dir, \"__gnat_get_current_dir\");\n \n-      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n-      End_Path    : Natural := 0;\n-      Link_Buffer : String (1 .. Max_Path + 2);\n-      Status      : Integer;\n-      Last        : Positive;\n-      Start       : Natural;\n-      Finish      : Positive;\n-\n-      Max_Iterations : constant := 500;\n-\n       function Get_File_Names_Case_Sensitive return Integer;\n       pragma Import\n         (C, Get_File_Names_Case_Sensitive,\n          \"__gnat_get_file_names_case_sensitive\");\n \n-      Fold_To_Lower_Case : constant Boolean :=\n-                             not Case_Sensitive\n-                               and then Get_File_Names_Case_Sensitive = 0;\n+      Max_Path : Integer;\n+      pragma Import (C, Max_Path, \"__gnat_max_path_len\");\n+      --  Maximum length of a path name\n \n       function Readlink\n         (Path   : System.Address;\n@@ -1936,9 +1997,9 @@ package body System.OS_Lib is\n         (C, To_Canonical_File_Spec, \"__gnat_to_canonical_file_spec\");\n       --  Convert possible foreign file syntax to canonical form\n \n-      The_Name : String (1 .. Name'Length + 1);\n-      Canonical_File_Addr : System.Address;\n-      Canonical_File_Len  : Integer;\n+      Fold_To_Lower_Case : constant Boolean :=\n+                             not Case_Sensitive\n+                               and then Get_File_Names_Case_Sensitive = 0;\n \n       function Final_Value (S : String) return String;\n       --  Make final adjustment to the returned string. This function strips\n@@ -2052,6 +2113,22 @@ package body System.OS_Lib is\n          end if;\n       end Get_Directory;\n \n+      --  Local variables\n+\n+      Max_Iterations : constant := 500;\n+\n+      Canonical_File_Addr : System.Address;\n+      Canonical_File_Len  : Integer;\n+\n+      End_Path    : Natural := 0;\n+      Finish      : Positive;\n+      Last        : Positive;\n+      Link_Buffer : String (1 .. Max_Path + 2);\n+      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n+      Start       : Natural;\n+      Status      : Integer;\n+      The_Name    : String (1 .. Name'Length + 1);\n+\n    --  Start of processing for Normalize_Pathname\n \n    begin\n@@ -2236,15 +2313,12 @@ package body System.OS_Lib is\n                if Last = 1 then\n                   return (1 => Directory_Separator);\n                else\n-\n                   if Fold_To_Lower_Case then\n                      System.Case_Util.To_Lower (Path_Buffer (1 .. Last - 1));\n                   end if;\n \n                   return Path_Buffer (1 .. Last - 1);\n-\n                end if;\n-\n             else\n                Path_Buffer (Last + 1 .. End_Path - 2) :=\n                  Path_Buffer (Last + 3 .. End_Path);\n@@ -2294,9 +2368,11 @@ package body System.OS_Lib is\n \n             begin\n                Path_Buffer (Finish + 1) := ASCII.NUL;\n-               Status := Readlink (Path_Buffer'Address,\n-                                   Link_Buffer'Address,\n-                                   Link_Buffer'Length);\n+               Status :=\n+                 Readlink\n+                   (Path   => Path_Buffer'Address,\n+                    Buf    => Link_Buffer'Address,\n+                    Bufsiz => Link_Buffer'Length);\n                Path_Buffer (Finish + 1) := Saved;\n             end;\n \n@@ -2631,9 +2707,10 @@ package body System.OS_Lib is\n      (Program_Name : String;\n       Args         : Argument_List) return Integer\n    is\n-      Result : Integer;\n       Junk   : Process_Id;\n       pragma Warnings (Off, Junk);\n+      Result : Integer;\n+\n    begin\n       Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);\n       return Result;\n@@ -2655,8 +2732,8 @@ package body System.OS_Lib is\n       Return_Code            : out Integer;\n       Err_To_Out             : Boolean := True)\n    is\n-      Saved_Output : File_Descriptor;\n       Saved_Error  : File_Descriptor := Invalid_FD; -- prevent compiler warning\n+      Saved_Output : File_Descriptor;\n \n    begin\n       --  Set standard output and error to the temporary file\n@@ -2727,7 +2804,6 @@ package body System.OS_Lib is\n       Pid          : out Process_Id;\n       Blocking     : Boolean)\n    is\n-\n       procedure Spawn (Args : Argument_List);\n       --  Call Spawn with given argument list\n \n@@ -2742,8 +2818,8 @@ package body System.OS_Lib is\n          type Chars is array (Positive range <>) of aliased Character;\n          type Char_Ptr is access constant Character;\n \n-         Command_Len  : constant Positive := Program_Name'Length + 1\n-                                               + Args_Length (Args);\n+         Command_Len  : constant Positive := Program_Name'Length + 1 +\n+                                               Args_Length (Args);\n          Command_Last : Natural := 0;\n          Command      : aliased Chars (1 .. Command_Len);\n          --  Command contains all characters of the Program_Name and Args, all"}, {"sha": "dcc1deab6874e78ec158e0ace2c1ed130f34fac4", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 436, "deletions": 424, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f97d24cad349a09ee1beb3e20b636925aa9baa9/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=2f97d24cad349a09ee1beb3e20b636925aa9baa9", "patch": "@@ -66,14 +66,14 @@ package System.OS_Lib is\n \n    subtype String_Access is Strings.String_Access;\n \n-   function \"=\" (Left, Right : String_Access) return Boolean\n+   function \"=\" (Left : String_Access; Right : String_Access) return Boolean\n      renames Strings.\"=\";\n \n    procedure Free (X : in out String_Access) renames Strings.Free;\n \n    subtype String_List is Strings.String_List;\n \n-   function \"=\" (Left, Right : String_List) return Boolean\n+   function \"=\" (Left : String_List; Right : String_List) return Boolean\n      renames Strings.\"=\";\n \n    function \"&\" (Left : String_Access; Right : String_Access)\n@@ -87,11 +87,11 @@ package System.OS_Lib is\n \n    subtype String_List_Access is Strings.String_List_Access;\n \n-   function \"=\" (Left, Right : String_List_Access) return Boolean\n-     renames Strings.\"=\";\n+   function \"=\"\n+     (Left  : String_List_Access;\n+      Right : String_List_Access) return Boolean renames Strings.\"=\";\n \n-   procedure Free (Arg : in out String_List_Access)\n-     renames Strings.Free;\n+   procedure Free (Arg : in out String_List_Access) renames Strings.Free;\n \n    ---------------------\n    -- Time/Date Stuff --\n@@ -110,6 +110,14 @@ package System.OS_Lib is\n    Invalid_Time : constant OS_Time;\n    --  A special unique value used to flag an invalid time stamp value\n \n+   function \"<\"  (X : OS_Time; Y : OS_Time) return Boolean;\n+   function \">\"  (X : OS_Time; Y : OS_Time) return Boolean;\n+   function \">=\" (X : OS_Time; Y : OS_Time) return Boolean;\n+   function \"<=\" (X : OS_Time; Y : OS_Time) return Boolean;\n+   --  Basic comparison operators on OS_Time with obvious meanings. Note that\n+   --  these have Intrinsic convention, so for example it is not permissible\n+   --  to create accesses to any of these functions.\n+\n    subtype Year_Type   is Integer range 1900 .. 2099;\n    subtype Month_Type  is Integer range    1 ..   12;\n    subtype Day_Type    is Integer range    1 ..   31;\n@@ -121,6 +129,10 @@ package System.OS_Lib is\n    function Current_Time return OS_Time;\n    --  Return the system clock value as OS_Time\n \n+   function Current_Time_String return String;\n+   --  Returns current local time in the form YYYY-MM-DD HH:MM:SS. The result\n+   --  has bounds 1 .. 19.\n+\n    function GM_Year    (Date : OS_Time) return Year_Type;\n    function GM_Month   (Date : OS_Time) return Month_Type;\n    function GM_Day     (Date : OS_Time) return Day_Type;\n@@ -129,14 +141,6 @@ package System.OS_Lib is\n    function GM_Second  (Date : OS_Time) return Second_Type;\n    --  Functions to extract information from OS_Time value in GMT form\n \n-   function \"<\"  (X, Y : OS_Time) return Boolean;\n-   function \">\"  (X, Y : OS_Time) return Boolean;\n-   function \">=\" (X, Y : OS_Time) return Boolean;\n-   function \"<=\" (X, Y : OS_Time) return Boolean;\n-   --  Basic comparison operators on OS_Time with obvious meanings. Note that\n-   --  these have Intrinsic convention, so for example it is not permissible\n-   --  to create accesses to any of these functions.\n-\n    procedure GM_Split\n      (Date   : OS_Time;\n       Year   : out Year_Type;\n@@ -160,10 +164,6 @@ package System.OS_Lib is\n    --  component parts to be interpreted in the local time zone, and returns\n    --  an OS_Time. Returns Invalid_Time if the creation fails.\n \n-   function Current_Time_String return String;\n-   --  Returns current local time in the form YYYY-MM-DD HH:MM:SS. The result\n-   --  has bounds 1 .. 19.\n-\n    ----------------\n    -- File Stuff --\n    ----------------\n@@ -191,6 +191,87 @@ package System.OS_Lib is\n    Invalid_FD : constant File_Descriptor := -1;\n    --  File descriptor returned when error in opening/creating file\n \n+   procedure Close (FD : File_Descriptor; Status : out Boolean);\n+   --  Close file referenced by FD. Status is False if the underlying service\n+   --  failed. Reasons for failure include: disk full, disk quotas exceeded\n+   --  and invalid file descriptor (the file may have been closed twice).\n+\n+   procedure Close (FD : File_Descriptor);\n+   --  Close file referenced by FD. This form is used when the caller wants to\n+   --  ignore any possible error (see above for error cases).\n+\n+   type Copy_Mode is\n+     (Copy,\n+      --  Copy the file. It is an error if the target file already exists. The\n+      --  time stamps and other file attributes are preserved in the copy.\n+\n+      Overwrite,\n+      --  If the target file exists, the file is replaced otherwise the file\n+      --  is just copied. The time stamps and other file attributes are\n+      --  preserved in the copy.\n+\n+      Append);\n+      --  If the target file exists, the contents of the source file is\n+      --  appended at the end. Otherwise the source file is just copied. The\n+      --  time stamps and other file attributes are preserved if the\n+      --  destination file does not exist.\n+\n+   type Attribute is\n+     (Time_Stamps,\n+      --  Copy time stamps from source file to target file. All other\n+      --  attributes are set to normal default values for file creation.\n+\n+      Full,\n+      --  All attributes are copied from the source file to the target file.\n+      --  This includes the timestamps, and for example also includes\n+      --  read/write/execute attributes in Unix systems.\n+\n+      None);\n+      --  No attributes are copied. All attributes including the time stamp\n+      --  values are set to normal default values for file creation.\n+\n+   --  Note: The default is Time_Stamps, which corresponds to the normal\n+   --  default on Windows style systems. Full corresponds to the typical\n+   --  effect of \"cp -p\" on Unix systems, and None corresponds to the typical\n+   --  effect of \"cp\" on Unix systems.\n+\n+   --  Note: Time_Stamps and Full are not supported on VxWorks 5\n+\n+   procedure Copy_File\n+     (Name     : String;\n+      Pathname : String;\n+      Success  : out Boolean;\n+      Mode     : Copy_Mode := Copy;\n+      Preserve : Attribute := Time_Stamps);\n+   --  Copy a file. Name must designate a single file (no wild cards allowed).\n+   --  Pathname can be a filename or directory name. In the latter case Name\n+   --  is copied into the directory preserving the same file name. Mode\n+   --  defines the kind of copy, see above with the default being a normal\n+   --  copy in which the target file must not already exist. Success is set to\n+   --  True or False indicating if the copy is successful (depending on the\n+   --  specified Mode).\n+\n+   procedure Copy_File_Attributes\n+      (From             : String;\n+       To               : String;\n+       Success          : out Boolean;\n+       Copy_Timestamp   : Boolean := True;\n+       Copy_Permissions : Boolean := True);\n+   --  Copy some of the file attributes from one file to another. Both files\n+   --  must exist, or Success is set to False.\n+\n+   procedure Copy_Time_Stamps\n+     (Source  : String;\n+      Dest    : String;\n+      Success : out Boolean);\n+   --  Copy Source file time stamps (last modification and last access time\n+   --  stamps) to Dest file. Source and Dest must be valid filenames,\n+   --  furthermore Dest must be writable. Success will be set to True if the\n+   --  operation was successful and False otherwise.\n+   --\n+   --  Note: this procedure is not supported on VxWorks 5. On this platform,\n+   --  Success is always set to False.\n+\n    type Mode is (Binary, Text);\n    for Mode'Size use Integer'Size;\n    for Mode use (Binary => 0, Text => 1);\n@@ -202,26 +283,6 @@ package System.OS_Lib is\n    --  of Text where appropriate allows programs to take a portable Unix view\n    --  of DOS-format files and process them appropriately.\n \n-   function Open_Read\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Open file Name for reading, returning its file descriptor. File\n-   --  descriptor returned is Invalid_FD if the file cannot be opened.\n-\n-   function Open_Read_Write\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Open file Name for both reading and writing, returning its file\n-   --  descriptor. File descriptor returned is Invalid_FD if the file\n-   --  cannot be opened.\n-\n-   function Open_Append\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Opens file Name for appending, returning its file descriptor. File\n-   --  descriptor returned is Invalid_FD if the file cannot be successfully\n-   --  opened.\n-\n    function Create_File\n      (Name  : String;\n       Fmode : Mode) return File_Descriptor;\n@@ -230,11 +291,6 @@ package System.OS_Lib is\n    --  overwritten. File descriptor returned is Invalid_FD if file cannot be\n    --  successfully created.\n \n-   function Create_Output_Text_File (Name : String) return File_Descriptor;\n-   --  Creates new text file with given name suitable to redirect standard\n-   --  output, returning file descriptor. File descriptor returned is\n-   --  Invalid_FD if file cannot be successfully created.\n-\n    function Create_New_File\n      (Name  : String;\n       Fmode : Mode) return File_Descriptor;\n@@ -243,6 +299,11 @@ package System.OS_Lib is\n    --  that it fails if the file already exists. File descriptor returned is\n    --  Invalid_FD if the file exists or cannot be created.\n \n+   function Create_Output_Text_File (Name : String) return File_Descriptor;\n+   --  Creates new text file with given name suitable to redirect standard\n+   --  output, returning file descriptor. File descriptor returned is\n+   --  Invalid_FD if file cannot be successfully created.\n+\n    Temp_File_Len : constant Integer := 12;\n    --  Length of name returned by Create_Temp_File call (GNAT-XXXXXX & NUL)\n \n@@ -296,148 +357,17 @@ package System.OS_Lib is\n    --  There is no race condition problem between processes trying to create\n    --  temp files at the same time in the same directory.\n \n-   procedure Close (FD : File_Descriptor; Status : out Boolean);\n-   --  Close file referenced by FD. Status is False if the underlying service\n-   --  failed. Reasons for failure include: disk full, disk quotas exceeded\n-   --  and invalid file descriptor (the file may have been closed twice).\n-\n-   procedure Close (FD : File_Descriptor);\n-   --  Close file referenced by FD. This form is used when the caller wants to\n-   --  ignore any possible error (see above for error cases).\n-\n-   procedure Set_Close_On_Exec\n-     (FD            : File_Descriptor;\n-      Close_On_Exec : Boolean;\n-      Status        : out Boolean);\n-   --  When Close_On_Exec is True, mark FD to be closed automatically when new\n-   --  program is executed by the calling process (i.e. prevent FD from being\n-   --  inherited by child processes). When Close_On_Exec is False, mark FD to\n-   --  not be closed on exec (i.e. allow it to be inherited). Status is False\n-   --  if the operation could not be performed.\n-\n    procedure Delete_File (Name : String; Success : out Boolean);\n    --  Deletes file. Success is set True or False indicating if the delete is\n    --  successful.\n \n-   procedure Rename_File\n-     (Old_Name : String;\n-      New_Name : String;\n-      Success  : out Boolean);\n-   --  Rename a file. Success is set True or False indicating if the rename is\n-   --  successful or not.\n-   --\n-   --  WARNING: In one very important respect, this function is significantly\n-   --  non-portable. If New_Name already exists then on Unix systems, the call\n-   --  deletes the existing file, and the call signals success. On Windows, the\n-   --  call fails, without doing the rename operation. See also the procedure\n-   --  Ada.Directories.Rename, which portably provides the windows semantics,\n-   --  i.e. fails if the output file already exists.\n-\n-   --  The following defines the mode for the Copy_File procedure below. Note\n-   --  that \"time stamps and other file attributes\" in the descriptions below\n-   --  refers to the creation and last modification times, and also the file\n-   --  access (read/write/execute) status flags.\n-\n-   type Copy_Mode is\n-     (Copy,\n-      --  Copy the file. It is an error if the target file already exists. The\n-      --  time stamps and other file attributes are preserved in the copy.\n-\n-      Overwrite,\n-      --  If the target file exists, the file is replaced otherwise the file\n-      --  is just copied. The time stamps and other file attributes are\n-      --  preserved in the copy.\n-\n-      Append);\n-      --  If the target file exists, the contents of the source file is\n-      --  appended at the end. Otherwise the source file is just copied. The\n-      --  time stamps and other file attributes are preserved if the\n-      --  destination file does not exist.\n-\n-   type Attribute is\n-     (Time_Stamps,\n-      --  Copy time stamps from source file to target file. All other\n-      --  attributes are set to normal default values for file creation.\n-\n-      Full,\n-      --  All attributes are copied from the source file to the target file.\n-      --  This includes the timestamps, and for example also includes\n-      --  read/write/execute attributes in Unix systems.\n-\n-      None);\n-      --  No attributes are copied. All attributes including the time stamp\n-      --  values are set to normal default values for file creation.\n-\n-   --  Note: The default is Time_Stamps, which corresponds to the normal\n-   --  default on Windows style systems. Full corresponds to the typical\n-   --  effect of \"cp -p\" on Unix systems, and None corresponds to the typical\n-   --  effect of \"cp\" on Unix systems.\n-\n-   --  Note: Time_Stamps and Full are not supported on VxWorks 5\n-\n-   procedure Copy_File\n-     (Name     : String;\n-      Pathname : String;\n-      Success  : out Boolean;\n-      Mode     : Copy_Mode := Copy;\n-      Preserve : Attribute := Time_Stamps);\n-   --  Copy a file. Name must designate a single file (no wild cards allowed).\n-   --  Pathname can be a filename or directory name. In the latter case Name\n-   --  is copied into the directory preserving the same file name. Mode\n-   --  defines the kind of copy, see above with the default being a normal\n-   --  copy in which the target file must not already exist. Success is set to\n-   --  True or False indicating if the copy is successful (depending on the\n-   --  specified Mode).\n-   --\n-   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean);\n-   --  Copy Source file time stamps (last modification and last access time\n-   --  stamps) to Dest file. Source and Dest must be valid filenames,\n-   --  furthermore Dest must be writable. Success will be set to True if the\n-   --  operation was successful and False otherwise.\n-   --\n-   --  Note: this procedure is not supported on VxWorks 5. On this platform,\n-   --  Success is always set to False.\n-\n-   procedure Set_File_Last_Modify_Time_Stamp (Name : String; Time : OS_Time);\n-   --  Given the name of a file or directory, Name, set the last modification\n-   --  time stamp. This function must be used for an unopened file.\n-\n-   function Read\n-     (FD : File_Descriptor;\n-      A  : System.Address;\n-      N  : Integer) return Integer;\n-   --  Read N bytes to address A from file referenced by FD. Returned value is\n-   --  count of bytes actually read, which can be less than N at EOF.\n-\n-   function Write\n-     (FD : File_Descriptor;\n-      A  : System.Address;\n-      N  : Integer) return Integer;\n-   --  Write N bytes from address A to file referenced by FD. The returned\n-   --  value is the number of bytes written, which can be less than N if a\n-   --  disk full condition was detected.\n-\n-   Seek_Cur : constant := 1;\n-   Seek_End : constant := 2;\n-   Seek_Set : constant := 0;\n-   --  Used to indicate origin for Lseek call\n-\n-   procedure Lseek\n-     (FD     : File_Descriptor;\n-      offset : Long_Integer;\n-      origin : Integer);\n-   pragma Import (C, Lseek, \"__gnat_lseek\");\n-   --  Sets the current file pointer to the indicated offset value, relative\n-   --  to the current position (origin = SEEK_CUR), end of file (origin =\n-   --  SEEK_END), or start of file (origin = SEEK_SET).\n+   function File_Length (FD : File_Descriptor) return Long_Integer;\n+   pragma Import (C, File_Length, \"__gnat_file_length_long\");\n \n    type Large_File_Size is range -2**63 .. 2**63 - 1;\n    --  Maximum supported size for a file (8 exabytes = 8 million terabytes,\n    --  should be enough to accomodate all possible needs for quite a while).\n \n-   function File_Length (FD : File_Descriptor) return Long_Integer;\n-   pragma Import (C, File_Length, \"__gnat_file_length_long\");\n-\n    function File_Length64 (FD : File_Descriptor) return Large_File_Size;\n    pragma Import (C, File_Length64, \"__gnat_file_length\");\n    --  Get length of file from file descriptor FD\n@@ -451,73 +381,42 @@ package System.OS_Lib is\n    --  Get time stamp of file from file descriptor FD Returns Invalid_Time is\n    --  FD doesn't correspond to an existing file.\n \n-   function Normalize_Pathname\n-     (Name           : String;\n-      Directory      : String  := \"\";\n-      Resolve_Links  : Boolean := True;\n-      Case_Sensitive : Boolean := True) return String;\n-   --  Returns a file name as an absolute path name, resolving all relative\n-   --  directories, and symbolic links. The parameter Directory is a fully\n-   --  resolved path name for a directory, or the empty string (the default).\n-   --  Name is the name of a file, which is either relative to the given\n-   --  directory name, if Directory is non-null, or to the current working\n-   --  directory if Directory is null. The result returned is the normalized\n-   --  name of the file. For most cases, if two file names designate the same\n-   --  file through different paths, Normalize_Pathname will return the same\n-   --  canonical name in both cases. However, there are cases when this is not\n-   --  true; for example, this is not true in Unix for two hard links\n-   --  designating the same file.\n-   --\n-   --  On Windows, the returned path will start with a drive letter except\n-   --  when Directory is not empty and does not include a drive letter. If\n-   --  Directory is empty (the default) and Name is a relative path or an\n-   --  absolute path without drive letter, the letter of the current drive\n-   --  will start the returned path. If Case_Sensitive is True (the default),\n-   --  then this drive letter will be forced to upper case (\"C:\\...\").\n-   --\n-   --  If Resolve_Links is set to True, then the symbolic links, on systems\n-   --  that support them, will be fully converted to the name of the file or\n-   --  directory pointed to. This is slightly less efficient, since it\n-   --  requires system calls.\n-   --\n-   --  If Name cannot be resolved, is invalid (for example if it is too big) or\n-   --  is null on entry (for example if there is symbolic link circularity,\n-   --  e.g. A is a symbolic link for B, and B is a symbolic link for A), then\n-   --  Normalize_Pathname returns an empty string.\n-   --\n-   --  For case-sensitive file systems, the value of Case_Sensitive parameter\n-   --  is ignored. For file systems that are not case-sensitive, such as\n-   --  Windows, if this parameter is set to False, then the file and directory\n-   --  names are folded to lower case. This allows checking whether two files\n-   --  are the same by applying this function to their names and comparing the\n-   --  results. If Case_Sensitive is set to True, this function does not change\n-   --  the casing of file and directory names.\n+   function Get_Debuggable_Suffix return String_Access;\n+   --  Return the debuggable suffix convention. Usually this is the same as\n+   --  the convention for Get_Executable_Suffix. The result is allocated on\n+   --  the heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Executable_Suffix return String_Access;\n+   --  Return the executable suffix convention. The result is allocated on the\n+   --  heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Object_Suffix return String_Access;\n+   --  Return the object suffix convention. The result is allocated on the heap\n+   --  and should be freed after use to avoid storage leaks.\n+\n+   function Get_Target_Debuggable_Suffix return String_Access;\n+   --  Return the target debuggable suffix convention. Usually this is the same\n+   --  as the convention for Get_Executable_Suffix. The result is allocated on\n+   --  the heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Target_Executable_Suffix return String_Access;\n+   --  Return the target executable suffix convention. The result is allocated\n+   --  on the heap and should be freed after use to avoid storage leaks.\n+\n+   function Get_Target_Object_Suffix return String_Access;\n+   --  Return the target object suffix convention. The result is allocated on\n+   --  the heap and should be freed after use to avoid storage leaks.\n \n    function Is_Absolute_Path (Name : String) return Boolean;\n    --  Returns True if Name is an absolute path name, i.e. it designates a\n    --  file or directory absolutely rather than relative to another directory.\n \n-   function Is_Regular_File (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the name of an existing\n-   --  regular file. Returns True if so, False otherwise. Name may be an\n-   --  absolute path name or a relative path name, including a simple file\n-   --  name. If it is a relative path name, it is relative to the current\n-   --  working directory.\n-\n    function Is_Directory (Name : String) return Boolean;\n    --  Determines if the given string, Name, is the name of a directory.\n    --  Returns True if so, False otherwise. Name may be an absolute path\n    --  name or a relative path name, including a simple file name. If it is\n    --  a relative path name, it is relative to the current working directory.\n \n-   function Is_Readable_File (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the name of an existing file\n-   --  that is readable. Returns True if so, False otherwise. Note that this\n-   --  function simply interrogates the file attributes (e.g. using the C\n-   --  function stat), so it does not indicate a situation in which a file may\n-   --  not actually be readable due to some other process having exclusive\n-   --  access.\n-\n    function Is_Executable_File (Name : String) return Boolean;\n    --  Determines if the given string, Name, is the name of an existing file\n    --  that is executable. Returns True if so, False otherwise. Note that this\n@@ -526,14 +425,21 @@ package System.OS_Lib is\n    --  not actually be readable due to some other process having exclusive\n    --  access.\n \n-   function Is_Writable_File (Name : String) return Boolean;\n+   function Is_Readable_File (Name : String) return Boolean;\n    --  Determines if the given string, Name, is the name of an existing file\n-   --  that is writable. Returns True if so, False otherwise. Note that this\n+   --  that is readable. Returns True if so, False otherwise. Note that this\n    --  function simply interrogates the file attributes (e.g. using the C\n    --  function stat), so it does not indicate a situation in which a file may\n-   --  not actually be writeable due to some other process having exclusive\n+   --  not actually be readable due to some other process having exclusive\n    --  access.\n \n+   function Is_Regular_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing\n+   --  regular file. Returns True if so, False otherwise. Name may be an\n+   --  absolute path name or a relative path name, including a simple file\n+   --  name. If it is a relative path name, it is relative to the current\n+   --  working directory.\n+\n    function Is_Symbolic_Link (Name : String) return Boolean;\n    --  Determines if the given string, Name, is the path of a symbolic link on\n    --  systems that support it. Returns True if so, False if the path is not a\n@@ -543,38 +449,15 @@ package System.OS_Lib is\n    --  contains the name of the file to which it is linked. Symbolic links may\n    --  span file systems and may refer to directories.\n \n-   procedure Set_Writable (Name : String);\n-   --  Change permissions on the named file to make it writable for its owner\n-\n-   procedure Set_Non_Writable (Name : String);\n-   --  Change permissions on the named file to make it non-writable for its\n-   --  owner. The readable and executable permissions are not modified.\n-\n-   procedure Set_Read_Only (Name : String) renames Set_Non_Writable;\n-   --  This renaming is provided for backwards compatibility with previous\n-   --  versions. The use of Set_Non_Writable is preferred (clearer name).\n-\n-   S_Owner  : constant := 1;\n-   S_Group  : constant := 2;\n-   S_Others : constant := 4;\n-   --  Constants for use in Mode parameter to Set_Executable\n-\n-   procedure Set_Executable (Name : String; Mode : Positive := S_Owner);\n-   --  Change permissions on the file given by Name to make it executable\n-   --  for its owner, group or others, according to the setting of Mode.\n-   --  As indicated, the default if no Mode parameter is given is owner.\n-\n-   procedure Set_Readable (Name : String);\n-   --  Change permissions on the named file to make it readable for its\n-   --  owner.\n-\n-   procedure Set_Non_Readable (Name : String);\n-   --  Change permissions on the named file to make it non-readable for\n-   --  its owner. The writable and executable permissions are not\n-   --  modified.\n+   function Is_Writable_File (Name : String) return Boolean;\n+   --  Determines if the given string, Name, is the name of an existing file\n+   --  that is writable. Returns True if so, False otherwise. Note that this\n+   --  function simply interrogates the file attributes (e.g. using the C\n+   --  function stat), so it does not indicate a situation in which a file may\n+   --  not actually be writeable due to some other process having exclusive\n+   --  access.\n \n-   function Locate_Exec_On_Path\n-     (Exec_Name : String) return String_Access;\n+   function Locate_Exec_On_Path (Exec_Name : String) return String_Access;\n    --  Try to locate an executable whose name is given by Exec_Name in the\n    --  directories listed in the environment Path. If the Exec_Name does not\n    --  have the executable suffix, it will be appended before the search.\n@@ -602,31 +485,159 @@ package System.OS_Lib is\n    --  Note that this function allocates some memory for the returned value.\n    --  This memory needs to be deallocated after use.\n \n-   function Get_Debuggable_Suffix return String_Access;\n-   --  Return the debuggable suffix convention. Usually this is the same as\n-   --  the convention for Get_Executable_Suffix. The result is allocated on\n-   --  the heap and should be freed after use to avoid storage leaks.\n+   Seek_Cur : constant := 1;\n+   Seek_End : constant := 2;\n+   Seek_Set : constant := 0;\n+   --  Used to indicate origin for Lseek call\n \n-   function Get_Target_Debuggable_Suffix return String_Access;\n-   --  Return the target debuggable suffix convention. Usually this is the same\n-   --  as the convention for Get_Executable_Suffix. The result is allocated on\n-   --  the heap and should be freed after use to avoid storage leaks.\n+   procedure Lseek\n+     (FD     : File_Descriptor;\n+      offset : Long_Integer;\n+      origin : Integer);\n+   pragma Import (C, Lseek, \"__gnat_lseek\");\n+   --  Sets the current file pointer to the indicated offset value, relative\n+   --  to the current position (origin = SEEK_CUR), end of file (origin =\n+   --  SEEK_END), or start of file (origin = SEEK_SET).\n \n-   function Get_Executable_Suffix return String_Access;\n-   --  Return the executable suffix convention. The result is allocated on the\n-   --  heap and should be freed after use to avoid storage leaks.\n+   function Normalize_Pathname\n+     (Name           : String;\n+      Directory      : String  := \"\";\n+      Resolve_Links  : Boolean := True;\n+      Case_Sensitive : Boolean := True) return String;\n+   --  Returns a file name as an absolute path name, resolving all relative\n+   --  directories, and symbolic links. The parameter Directory is a fully\n+   --  resolved path name for a directory, or the empty string (the default).\n+   --  Name is the name of a file, which is either relative to the given\n+   --  directory name, if Directory is non-null, or to the current working\n+   --  directory if Directory is null. The result returned is the normalized\n+   --  name of the file. For most cases, if two file names designate the same\n+   --  file through different paths, Normalize_Pathname will return the same\n+   --  canonical name in both cases. However, there are cases when this is not\n+   --  true; for example, this is not true in Unix for two hard links\n+   --  designating the same file.\n+   --\n+   --  On Windows, the returned path will start with a drive letter except\n+   --  when Directory is not empty and does not include a drive letter. If\n+   --  Directory is empty (the default) and Name is a relative path or an\n+   --  absolute path without drive letter, the letter of the current drive\n+   --  will start the returned path. If Case_Sensitive is True (the default),\n+   --  then this drive letter will be forced to upper case (\"C:\\...\").\n+   --\n+   --  If Resolve_Links is set to True, then the symbolic links, on systems\n+   --  that support them, will be fully converted to the name of the file or\n+   --  directory pointed to. This is slightly less efficient, since it\n+   --  requires system calls.\n+   --\n+   --  If Name cannot be resolved, is invalid (for example if it is too big) or\n+   --  is null on entry (for example if there is symbolic link circularity,\n+   --  e.g. A is a symbolic link for B, and B is a symbolic link for A), then\n+   --  Normalize_Pathname returns an empty string.\n+   --\n+   --  For case-sensitive file systems, the value of Case_Sensitive parameter\n+   --  is ignored. For file systems that are not case-sensitive, such as\n+   --  Windows, if this parameter is set to False, then the file and directory\n+   --  names are folded to lower case. This allows checking whether two files\n+   --  are the same by applying this function to their names and comparing the\n+   --  results. If Case_Sensitive is set to True, this function does not change\n+   --  the casing of file and directory names.\n \n-   function Get_Object_Suffix return String_Access;\n-   --  Return the object suffix convention. The result is allocated on the heap\n-   --  and should be freed after use to avoid storage leaks.\n+   function Open_Append\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Opens file Name for appending, returning its file descriptor. File\n+   --  descriptor returned is Invalid_FD if the file cannot be successfully\n+   --  opened.\n \n-   function Get_Target_Executable_Suffix return String_Access;\n-   --  Return the target executable suffix convention. The result is allocated\n-   --  on the heap and should be freed after use to avoid storage leaks.\n+   function Open_Read\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Open file Name for reading, returning its file descriptor. File\n+   --  descriptor returned is Invalid_FD if the file cannot be opened.\n \n-   function Get_Target_Object_Suffix return String_Access;\n-   --  Return the target object suffix convention. The result is allocated on\n-   --  the heap and should be freed after use to avoid storage leaks.\n+   function Open_Read_Write\n+     (Name  : String;\n+      Fmode : Mode) return File_Descriptor;\n+   --  Open file Name for both reading and writing, returning its file\n+   --  descriptor. File descriptor returned is Invalid_FD if the file\n+   --  cannot be opened.\n+\n+   function Read\n+     (FD : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer;\n+   --  Read N bytes to address A from file referenced by FD. Returned value is\n+   --  count of bytes actually read, which can be less than N at EOF.\n+\n+   procedure Rename_File\n+     (Old_Name : String;\n+      New_Name : String;\n+      Success  : out Boolean);\n+   --  Rename a file. Success is set True or False indicating if the rename is\n+   --  successful or not.\n+   --\n+   --  WARNING: In one very important respect, this function is significantly\n+   --  non-portable. If New_Name already exists then on Unix systems, the call\n+   --  deletes the existing file, and the call signals success. On Windows, the\n+   --  call fails, without doing the rename operation. See also the procedure\n+   --  Ada.Directories.Rename, which portably provides the windows semantics,\n+   --  i.e. fails if the output file already exists.\n+\n+   --  The following defines the mode for the Copy_File procedure below. Note\n+   --  that \"time stamps and other file attributes\" in the descriptions below\n+   --  refers to the creation and last modification times, and also the file\n+   --  access (read/write/execute) status flags.\n+\n+   procedure Set_Close_On_Exec\n+     (FD            : File_Descriptor;\n+      Close_On_Exec : Boolean;\n+      Status        : out Boolean);\n+   --  When Close_On_Exec is True, mark FD to be closed automatically when new\n+   --  program is executed by the calling process (i.e. prevent FD from being\n+   --  inherited by child processes). When Close_On_Exec is False, mark FD to\n+   --  not be closed on exec (i.e. allow it to be inherited). Status is False\n+   --  if the operation could not be performed.\n+\n+   S_Owner  : constant := 1;\n+   S_Group  : constant := 2;\n+   S_Others : constant := 4;\n+   --  Constants for use in Mode parameter to Set_Executable\n+\n+   procedure Set_Executable (Name : String; Mode : Positive := S_Owner);\n+   --  Change permissions on the file given by Name to make it executable\n+   --  for its owner, group or others, according to the setting of Mode.\n+   --  As indicated, the default if no Mode parameter is given is owner.\n+\n+   procedure Set_File_Last_Modify_Time_Stamp (Name : String; Time : OS_Time);\n+   --  Given the name of a file or directory, Name, set the last modification\n+   --  time stamp. This function must be used for an unopened file.\n+\n+   procedure Set_Non_Readable (Name : String);\n+   --  Change permissions on the named file to make it non-readable for\n+   --  its owner. The writable and executable permissions are not\n+   --  modified.\n+\n+   procedure Set_Non_Writable (Name : String);\n+   --  Change permissions on the named file to make it non-writable for its\n+   --  owner. The readable and executable permissions are not modified.\n+\n+   procedure Set_Read_Only (Name : String) renames Set_Non_Writable;\n+   --  This renaming is provided for backwards compatibility with previous\n+   --  versions. The use of Set_Non_Writable is preferred (clearer name).\n+\n+   procedure Set_Readable (Name : String);\n+   --  Change permissions on the named file to make it readable for its\n+   --  owner.\n+\n+   procedure Set_Writable (Name : String);\n+   --  Change permissions on the named file to make it writable for its owner\n+\n+   function Write\n+     (FD : File_Descriptor;\n+      A  : System.Address;\n+      N  : Integer) return Integer;\n+   --  Write N bytes from address A to file referenced by FD. The returned\n+   --  value is the number of bytes written, which can be less than N if a\n+   --  disk full condition was detected.\n \n    --  The following section contains low-level routines using addresses to\n    --  pass file name and executable name. In each routine the name must be\n@@ -639,17 +650,17 @@ package System.OS_Lib is\n \n    --  All the following functions need comments ???\n \n-   function Open_Read\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n-\n-   function Open_Read_Write\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n+   procedure Copy_File\n+     (Name     : C_File_Name;\n+      Pathname : C_File_Name;\n+      Success  : out Boolean;\n+      Mode     : Copy_Mode := Copy;\n+      Preserve : Attribute := Time_Stamps);\n \n-   function Open_Append\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n+   procedure Copy_Time_Stamps\n+     (Source  : C_File_Name;\n+      Dest    : C_File_Name;\n+      Success : out Boolean);\n \n    function Create_File\n      (Name  : C_File_Name;\n@@ -661,36 +672,37 @@ package System.OS_Lib is\n \n    procedure Delete_File (Name : C_File_Name; Success : out Boolean);\n \n-   procedure Rename_File\n-     (Old_Name : C_File_Name;\n-      New_Name : C_File_Name;\n-      Success  : out Boolean);\n-\n-   procedure Copy_File\n-     (Name     : C_File_Name;\n-      Pathname : C_File_Name;\n-      Success  : out Boolean;\n-      Mode     : Copy_Mode := Copy;\n-      Preserve : Attribute := Time_Stamps);\n-\n-   procedure Copy_Time_Stamps\n-     (Source, Dest : C_File_Name;\n-      Success      : out Boolean);\n-\n    function File_Time_Stamp (Name : C_File_Name) return OS_Time;\n    --  Returns Invalid_Time is Name doesn't correspond to an existing file\n \n-   function Is_Regular_File (Name : C_File_Name) return Boolean;\n    function Is_Directory (Name : C_File_Name) return Boolean;\n-   function Is_Readable_File (Name : C_File_Name) return Boolean;\n    function Is_Executable_File (Name : C_File_Name) return Boolean;\n-   function Is_Writable_File (Name : C_File_Name) return Boolean;\n+   function Is_Readable_File (Name : C_File_Name) return Boolean;\n+   function Is_Regular_File (Name : C_File_Name) return Boolean;\n    function Is_Symbolic_Link (Name : C_File_Name) return Boolean;\n+   function Is_Writable_File (Name : C_File_Name) return Boolean;\n \n    function Locate_Regular_File\n      (File_Name : C_File_Name;\n       Path      : C_File_Name) return String_Access;\n \n+   function Open_Append\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   function Open_Read\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   function Open_Read_Write\n+     (Name  : C_File_Name;\n+      Fmode : Mode) return File_Descriptor;\n+\n+   procedure Rename_File\n+     (Old_Name : C_File_Name;\n+      New_Name : C_File_Name;\n+      Success  : out Boolean);\n+\n    ------------------\n    -- Subprocesses --\n    ------------------\n@@ -705,6 +717,84 @@ package System.OS_Lib is\n    --  Note that there is a Free procedure declared for this subtype which\n    --  frees the array and all referenced strings.\n \n+   type Process_Id is private;\n+   --  A private type used to identify a process activated by the following\n+   --  non-blocking calls. The only meaningful operation on this type is a\n+   --  comparison for equality.\n+\n+   Invalid_Pid : constant Process_Id;\n+   --  A special value used to indicate errors, as described below\n+\n+   function Argument_String_To_List\n+     (Arg_String : String) return Argument_List_Access;\n+   --  Take a string that is a program and its arguments and parse it into an\n+   --  Argument_List. Note that the result is allocated on the heap, and must\n+   --  be freed by the programmer (when it is no longer needed) to avoid\n+   --  memory leaks.\n+\n+   procedure Kill (Pid : Process_Id; Hard_Kill : Boolean := True);\n+   --  Kill the process designated by Pid. Does nothing if Pid is Invalid_Pid\n+   --  or on platforms where it is not supported, such as VxWorks. Hard_Kill\n+   --  is True by default, and when True the process is terminated immediately.\n+   --  If Hard_Kill is False, then a signal SIGINT is sent to the process on\n+   --  POSIX OS or a ctrl-C event on Windows, allowing the process a chance to\n+   --  terminate properly using a corresponding handler.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List) return Process_Id;\n+   --  This is a non blocking call. The Process_Id of the spawned process is\n+   --  returned. Parameters are to be used as in Spawn. If Invalid_Pid is\n+   --  returned the program could not be spawned.\n+   --\n+   --  Spawning processes from tasking programs is not recommended. See\n+   --  \"NOTE: Spawn in tasking programs\" below.\n+   --\n+   --  This function will always return Invalid_Pid under VxWorks, since there\n+   --  is no notion of executables under this OS.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name           : String;\n+      Args                   : Argument_List;\n+      Output_File_Descriptor : File_Descriptor;\n+      Err_To_Out             : Boolean := True) return Process_Id;\n+   --  Similar to the procedure above, but redirects the output to the file\n+   --  designated by Output_File_Descriptor. If Err_To_Out is True, then the\n+   --  Standard Error output is also redirected. Invalid_Pid is returned\n+   --  if the program could not be spawned successfully.\n+   --\n+   --  Spawning processes from tasking programs is not recommended. See\n+   --  \"NOTE: Spawn in tasking programs\" below.\n+   --\n+   --  This function will always return Invalid_Pid under VxWorks, since there\n+   --  is no notion of executables under this OS.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Output_File  : String;\n+      Err_To_Out   : Boolean := True) return Process_Id;\n+   --  Similar to the procedure above, but saves the output of the command to\n+   --  a file with the name Output_File.\n+   --\n+   --  Invalid_Pid is returned if the output file could not be created or if\n+   --  the program could not be spawned successfully.\n+   --\n+   --  Spawning processes from tasking programs is not recommended. See\n+   --  \"NOTE: Spawn in tasking programs\" below.\n+   --\n+   --  This function will always return Invalid_Pid under VxWorks, since there\n+   --  is no notion of executables under this OS.\n+\n+   function Non_Blocking_Spawn\n+     (Program_Name : String;\n+      Args         : Argument_List;\n+      Stdout_File  : String;\n+      Stderr_File  : String) return Process_Id;\n+   --  Similar to the procedure above, but saves the standard output of the\n+   --  command to a file with the name Stdout_File and the standard output\n+   --  of the command to a file with the name Stderr_File.\n+\n    procedure Normalize_Arguments (Args : in out Argument_List);\n    --  Normalize all arguments in the list. This ensure that the argument list\n    --  is compatible with the running OS and will works fine with Spawn and\n@@ -717,6 +807,10 @@ package System.OS_Lib is\n    --  individual referenced arguments in Argument_List are on the heap, and\n    --  may free them and reallocate if they are modified.\n \n+   function Pid_To_Integer (Pid : Process_Id) return Integer;\n+   --  Convert a process id to an Integer. Useful for writing hash functions\n+   --  for type Process_Id or to compare two Process_Id (e.g. for sorting).\n+\n    procedure Spawn\n      (Program_Name : String;\n       Args         : Argument_List;\n@@ -795,73 +889,6 @@ package System.OS_Lib is\n    --  Spawning processes from tasking programs is not recommended. See\n    --  \"NOTE: Spawn in tasking programs\" below.\n \n-   type Process_Id is private;\n-   --  A private type used to identify a process activated by the following\n-   --  non-blocking calls. The only meaningful operation on this type is a\n-   --  comparison for equality.\n-\n-   Invalid_Pid : constant Process_Id;\n-   --  A special value used to indicate errors, as described below\n-\n-   function Pid_To_Integer (Pid : Process_Id) return Integer;\n-   --  Convert a process id to an Integer. Useful for writing hash functions\n-   --  for type Process_Id or to compare two Process_Id (e.g. for sorting).\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List) return Process_Id;\n-   --  This is a non blocking call. The Process_Id of the spawned process is\n-   --  returned. Parameters are to be used as in Spawn. If Invalid_Pid is\n-   --  returned the program could not be spawned.\n-   --\n-   --  Spawning processes from tasking programs is not recommended. See\n-   --  \"NOTE: Spawn in tasking programs\" below.\n-   --\n-   --  This function will always return Invalid_Pid under VxWorks, since there\n-   --  is no notion of executables under this OS.\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name           : String;\n-      Args                   : Argument_List;\n-      Output_File_Descriptor : File_Descriptor;\n-      Err_To_Out             : Boolean := True) return Process_Id;\n-   --  Similar to the procedure above, but redirects the output to the file\n-   --  designated by Output_File_Descriptor. If Err_To_Out is True, then the\n-   --  Standard Error output is also redirected. Invalid_Pid is returned\n-   --  if the program could not be spawned successfully.\n-   --\n-   --  Spawning processes from tasking programs is not recommended. See\n-   --  \"NOTE: Spawn in tasking programs\" below.\n-   --\n-   --  This function will always return Invalid_Pid under VxWorks, since there\n-   --  is no notion of executables under this OS.\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Output_File  : String;\n-      Err_To_Out   : Boolean := True) return Process_Id;\n-   --  Similar to the procedure above, but saves the output of the command to\n-   --  a file with the name Output_File.\n-   --\n-   --  Invalid_Pid is returned if the output file could not be created or if\n-   --  the program could not be spawned successfully.\n-   --\n-   --  Spawning processes from tasking programs is not recommended. See\n-   --  \"NOTE: Spawn in tasking programs\" below.\n-   --\n-   --  This function will always return Invalid_Pid under VxWorks, since there\n-   --  is no notion of executables under this OS.\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Stdout_File  : String;\n-      Stderr_File  : String) return Process_Id;\n-   --  Similar to the procedure above, but saves the standard output of the\n-   --  command to a file with the name Stdout_File and the standard output\n-   --  of the command to a file with the name Stderr_File.\n-\n    procedure Wait_Process (Pid : out Process_Id; Success : out Boolean);\n    --  Wait for the completion of any of the processes created by previous\n    --  calls to Non_Blocking_Spawn. The caller will be suspended until one of\n@@ -876,21 +903,6 @@ package System.OS_Lib is\n    --  This function will always set success to False under VxWorks, since\n    --  there is no notion of executables under this OS.\n \n-   procedure Kill (Pid : Process_Id; Hard_Kill : Boolean := True);\n-   --  Kill the process designated by Pid. Does nothing if Pid is Invalid_Pid\n-   --  or on platforms where it is not supported, such as VxWorks. Hard_Kill\n-   --  is True by default, and when True the process is terminated immediately.\n-   --  If Hard_Kill is False, then a signal SIGINT is sent to the process on\n-   --  POSIX OS or a ctrl-C event on Windows, allowing the process a chance to\n-   --  terminate properly using a corresponding handler.\n-\n-   function Argument_String_To_List\n-     (Arg_String : String) return Argument_List_Access;\n-   --  Take a string that is a program and its arguments and parse it into an\n-   --  Argument_List. Note that the result is allocated on the heap, and must\n-   --  be freed by the programmer (when it is no longer needed) to avoid\n-   --  memory leaks.\n-\n    -------------------------------------\n    -- NOTE: Spawn in Tasking Programs --\n    -------------------------------------\n@@ -960,6 +972,17 @@ package System.OS_Lib is\n    -- Miscellaneous --\n    -------------------\n \n+   function Errno return Integer;\n+   pragma Import (C, Errno, \"__get_errno\");\n+   --  Return the task-safe last error number\n+\n+   function Errno_Message\n+     (Err     : Integer := Errno;\n+      Default : String  := \"\") return String;\n+   --  Return a message describing the given Errno value. If none is provided\n+   --  by the system, return Default if not empty, else return a generic\n+   --  message indicating the numeric errno value.\n+\n    function Getenv (Name : String) return String_Access;\n    --  Get the value of the environment variable. Returns an access to the\n    --  empty string if the environment variable does not exist or has an\n@@ -969,16 +992,12 @@ package System.OS_Lib is\n    --  case), and needs to be freed explicitly when no longer needed to avoid\n    --  memory leaks.\n \n-   procedure Setenv (Name : String; Value : String);\n-   --  Set the value of the environment variable Name to Value. This call\n-   --  modifies the current environment, but does not modify the parent\n-   --  process environment. After a call to Setenv, Getenv (Name) will always\n-   --  return a String_Access referencing the same String as Value. This is\n-   --  true also for the null string case (the actual effect may be to either\n-   --  set an explicit null as the value, or to remove the entry, this is\n-   --  operating system dependent). Note that any following calls to Spawn\n-   --  will pass an environment to the spawned process that includes the\n-   --  changes made by Setenv calls.\n+   procedure OS_Abort;\n+   pragma Import (C, OS_Abort, \"abort\");\n+   pragma No_Return (OS_Abort);\n+   --  Exit to OS signalling an abort (traceback or other appropriate\n+   --  diagnostic information should be given if possible, or entry made to\n+   --  the debugger if that is possible).\n \n    procedure OS_Exit (Status : Integer);\n    pragma No_Return (OS_Exit);\n@@ -999,27 +1018,20 @@ package System.OS_Lib is\n    --  change the implementation of OS_Exit by redirecting OS_Exit_Ptr to an\n    --  other implementation.\n \n-   procedure OS_Abort;\n-   pragma Import (C, OS_Abort, \"abort\");\n-   pragma No_Return (OS_Abort);\n-   --  Exit to OS signalling an abort (traceback or other appropriate\n-   --  diagnostic information should be given if possible, or entry made to\n-   --  the debugger if that is possible).\n-\n-   function Errno return Integer;\n-   pragma Import (C, Errno, \"__get_errno\");\n-   --  Return the task-safe last error number\n-\n    procedure Set_Errno (Errno : Integer);\n    pragma Import (C, Set_Errno, \"__set_errno\");\n    --  Set the task-safe error number\n \n-   function Errno_Message\n-     (Err     : Integer := Errno;\n-      Default : String  := \"\") return String;\n-   --  Return a message describing the given Errno value. If none is provided\n-   --  by the system, return Default if not empty, else return a generic\n-   --  message indicating the numeric errno value.\n+   procedure Setenv (Name : String; Value : String);\n+   --  Set the value of the environment variable Name to Value. This call\n+   --  modifies the current environment, but does not modify the parent\n+   --  process environment. After a call to Setenv, Getenv (Name) will always\n+   --  return a String_Access referencing the same String as Value. This is\n+   --  true also for the null string case (the actual effect may be to either\n+   --  set an explicit null as the value, or to remove the entry, this is\n+   --  operating system dependent). Note that any following calls to Spawn\n+   --  will pass an environment to the spawned process that includes the\n+   --  changes made by Setenv calls.\n \n    Directory_Separator : constant Character;\n    --  The character that is used to separate parts of a pathname"}]}