{"sha": "5273aaa9059a832ebe21bc60a4efb2b5acd61066", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3M2FhYTkwNTlhODMyZWJlMjFiYzYwYTRlZmIyYjVhY2Q2MTA2Ng==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2007-07-16T13:30:46Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2007-07-16T13:30:46Z"}, "message": "Fix broken commit -- add files that were missed.\n\nFrom-SVN: r126682", "tree": {"sha": "49b67a22eb3d58f1231c60d74029fadf5747bfcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49b67a22eb3d58f1231c60d74029fadf5747bfcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5273aaa9059a832ebe21bc60a4efb2b5acd61066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5273aaa9059a832ebe21bc60a4efb2b5acd61066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5273aaa9059a832ebe21bc60a4efb2b5acd61066", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5273aaa9059a832ebe21bc60a4efb2b5acd61066/comments", "author": null, "committer": null, "parents": [{"sha": "fb028571632dff0d94b85cc6609b0114586cbf69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb028571632dff0d94b85cc6609b0114586cbf69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb028571632dff0d94b85cc6609b0114586cbf69"}], "stats": {"total": 324, "additions": 324, "deletions": 0}, "files": [{"sha": "9286361b343d23499d8b90ceb0f62f1667104dfc", "filename": "gcc/testsuite/gcc.target/spu/dfcmeq.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5273aaa9059a832ebe21bc60a4efb2b5acd61066/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmeq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5273aaa9059a832ebe21bc60a4efb2b5acd61066/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmeq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmeq.c?ref=5273aaa9059a832ebe21bc60a4efb2b5acd61066", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=celledp -O1\" } */\n+/* { dg-final { scan-assembler \"dfcmeq\" } } */\n+\n+int foo(double x, double y)\n+{\n+  if (__builtin_fabs(x) == __builtin_fabs(y))\n+    return 0;\n+}"}, {"sha": "ef7ef5899f7903a2273822a993f52bc8584eaef4", "filename": "gcc/testsuite/gcc.target/spu/dfcmgt.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5273aaa9059a832ebe21bc60a4efb2b5acd61066/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmgt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5273aaa9059a832ebe21bc60a4efb2b5acd61066/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmgt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fdfcmgt.c?ref=5273aaa9059a832ebe21bc60a4efb2b5acd61066", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=celledp -O1\" } */\n+/* { dg-final { scan-assembler \"dfcmgt\" } } */\n+\n+int foo(double x, double y)\n+{\n+  if (__builtin_fabs(x) > __builtin_fabs(y))\n+    return 0;\n+}\n+"}, {"sha": "43a272b91d8f03fbb899e946bca6de56ffdda32e", "filename": "gcc/testsuite/gcc.target/spu/intrinsics-2.c", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5273aaa9059a832ebe21bc60a4efb2b5acd61066/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5273aaa9059a832ebe21bc60a4efb2b5acd61066/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fintrinsics-2.c?ref=5273aaa9059a832ebe21bc60a4efb2b5acd61066", "patch": "@@ -0,0 +1,305 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99\" } */\n+#include <vec_types.h>\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef union {\n+  vec_ullong2   vull;\n+  vec_double2   vd;\n+  unsigned int  ui[4];\n+  unsigned long long ull[2];\n+  double        d[2];\n+} v128;\n+\n+static v128 a, b, c, d, a0, b0, a1, b1;\n+static int samples = 10;\n+unsigned int seed = 0;\n+\n+unsigned int rand_local()\n+{\n+  seed = seed * 69607 + 54329;\n+  return (seed);\n+}\n+\n+double rand_double(double min, double max)\n+{\n+  union {\n+    unsigned int ui[2];\n+    double d;\n+  } x;\n+\n+  x.ui[0] = (rand_local() & 0x000FFFFF) | 0x3FF00000;\n+  x.ui[1] = rand_local();\n+  x.d -= 1.0;\n+  x.d *= max - min;\n+  x.d += min;\n+  return (x.d);\n+}\n+\n+vec_double2 rand_vd(double min, double max)\n+{\n+  int i;\n+  static v128 val;\n+\n+  for (i=0; i<2; i++) val.d[i] = rand_double(min, max);\n+  return (val.vd);\n+}\n+\n+int test_spu_cmpeq()\n+{\n+  int i, j;\n+  unsigned long long exp;\n+\n+  /* double */\n+  for (i=0; i<samples; i++) {\n+    a.vd = rand_vd(-4.0, 4.0);\n+    b.vd = rand_vd(-4.0, 4.0);\n+    d.vull = spu_cmpeq(a.vd, b.vd);\n+    for (j=0; j<2; j++) {\n+      exp = (a.d[j] == b.d[j]) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  }\n+\n+  /* compare zeros  */\n+    d.vull = spu_cmpeq(a0.vd, b0.vd);\n+    for (j=0; j<2; j++) {\n+      exp = (a0.d[j] == b0.d[j]) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+\n+  /* compare NaNs  */\n+    d.vull = spu_cmpeq(a1.vd, b1.vd);\n+    for (j=0; j<2; j++) {\n+      exp = (a1.d[j] == b1.d[j]) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  return 0;\n+}\n+\n+int test_spu_cmpgt()\n+{   \n+  int i, j;\n+  unsigned long long exp;\n+\n+  /* double */\n+  for (i=0; i<samples; i++) {\n+    a.vd = rand_vd(-4.0, 4.0);\n+    b.vd = rand_vd(-4.0, 4.0);\n+    d.vull = spu_cmpgt(a.vd, b.vd);\n+    for (j=0; j<2; j++) {\n+      exp = (a.d[j] > b.d[j]) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    } \n+  }\n+\n+  /* compare zeros  */\n+    d.vull = spu_cmpgt(a0.vd, b0.vd);\n+    for (j=0; j<2; j++) {\n+      exp = (a0.d[j] > b0.d[j]) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  /* compare NaNs  */\n+    d.vull = spu_cmpgt(a1.vd, b1.vd);\n+    for (j=0; j<2; j++) {\n+      exp = (a1.d[j] > b1.d[j]) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  return 0;\n+}\n+\n+int test_spu_cmpabseq()\n+{   \n+  int i, j;\n+  unsigned long long exp;\n+\n+  /* double */\n+  for (i=0; i<samples; i++) {\n+    a.vd = rand_vd(-4.0, 4.0);\n+    b.vd = rand_vd(-4.0, 4.0);\n+    d.vull = spu_cmpabseq(a.vd, b.vd);\n+    for (j=0; j<2; j++) {\n+      exp = ((a.d[j] == b.d[j]) || (-a.d[j] == b.d[j]) || (a.d[j] == -b.d[j])) ?\n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    } \n+  }\n+\n+  /* compare zeros  */\n+    d.vull = spu_cmpabseq(a0.vd, b0.vd);\n+    for (j=0; j<2; j++) {\n+      exp = ((a0.d[j] == b0.d[j]) || (-a0.d[j] == b0.d[j]) || (a0.d[j] == -b0.d[j])) ?\n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+\n+  /* compare NaNs  */\n+    d.vull = spu_cmpabseq(a1.vd, b1.vd);\n+    for (j=0; j<2; j++) {\n+      exp = ((a1.d[j] == b1.d[j]) || (-a1.d[j] == b1.d[j]) || (a1.d[j] == -b1.d[j])) ?\n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  return 0;\n+}\n+\n+int test_spu_cmpabsgt()\n+{\n+  int i, j;\n+  unsigned long long exp;\n+  double abs_a, abs_b;\n+  \n+  /* double */\n+  for (i=0; i<samples; i++) {\n+    a.vd = rand_vd(-4.0, 4.0);\n+    b.vd = rand_vd(-4.0, 4.0);\n+    d.vull = spu_cmpabsgt(a.vd, b.vd);\n+    for (j=0; j<2; j++) {\n+      double abs_a = (a.d[j] < 0.0) ? -a.d[j] : a.d[j];\n+      double abs_b = (b.d[j] < 0.0) ? -b.d[j] : b.d[j];\n+      exp = (abs_a > abs_b) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  }\n+\n+  /* compare zeros  */\n+    d.vull = spu_cmpabsgt(a0.vd, b0.vd);\n+    for (j=0; j<2; j++) {\n+      abs_a = (a0.d[j] < 0.0) ? -a0.d[j] : a0.d[j];\n+      abs_b = (b0.d[j] < 0.0) ? -b0.d[j] : b0.d[j];\n+      exp = (abs_a > abs_b) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  /* compare NaNs  */\n+    d.vull = spu_cmpabsgt(a1.vd, b1.vd);\n+    for (j=0; j<2; j++) {\n+      abs_a = (a1.d[j] < 0.0) ? -a1.d[j] : a1.d[j];\n+      abs_b = (b1.d[j] < 0.0) ? -b1.d[j] : b1.d[j];\n+      exp = (abs_a > abs_b) ? \n+\t    (((unsigned long long)(0xFFFFFFFF) << 32) \n+\t     | (unsigned long long)(0xFFFFFFFF)) : 0;\n+      if (exp != d.ull[j]) abort();\n+    }\n+  return 0;\n+}\n+\n+int test_spu_testsv()\n+{\n+  int i, j;\n+  unsigned long long exp;\n+  struct _samples {\n+    unsigned long long v;\n+    unsigned int sv;\n+ } samples[] = {\n+  {0x0000000000000000ULL, SPU_SV_POS_ZERO},\n+  {0x8000000000000000ULL, SPU_SV_NEG_ZERO},\n+  {0x0000000000000001ULL, SPU_SV_POS_DENORM},\n+  {0x0000000080000000ULL, SPU_SV_POS_DENORM},\n+  {0x0000000100000000ULL, SPU_SV_POS_DENORM},\n+  {0x0008000000000000ULL, SPU_SV_POS_DENORM},\n+  {0x000FFFFFFFFFFFFFULL, SPU_SV_POS_DENORM},\n+  {0x00000000FFF00000ULL, SPU_SV_POS_DENORM},\n+  {0x8000000000000001ULL, SPU_SV_NEG_DENORM},\n+  {0x8000000080000000ULL, SPU_SV_NEG_DENORM},\n+  {0x8000000100000000ULL, SPU_SV_NEG_DENORM},\n+  {0x8008000000000000ULL, SPU_SV_NEG_DENORM},\n+  {0x800FFFFFFFFFFFFFULL, SPU_SV_NEG_DENORM},\n+  {0x80000000FFF00000ULL, SPU_SV_NEG_DENORM},\n+  {0x0010000000000000ULL, 0},\n+  {0x0010000000000001ULL, 0},\n+  {0x3FF0000000000000ULL, 0},\n+  {0x3FF00000FFF00000ULL, 0},\n+  {0xBFF0000000000000ULL, 0},\n+  {0xBFF00000FFF00000ULL, 0},\n+  {0x7FE0000000000000ULL, 0},\n+  {0x7FEFFFFFFFFFFFFFULL, 0},\n+  {0x8010000000000000ULL, 0},\n+  {0x8010000000000001ULL, 0},\n+  {0xFFE0000000000000ULL, 0},\n+  {0xFFEFFFFFFFFFFFFFULL, 0},\n+  {0x7FF0000000000000ULL, SPU_SV_POS_INFINITY},\n+  {0xFFF0000000000000ULL, SPU_SV_NEG_INFINITY},\n+  {0x7FF0000000000001ULL, SPU_SV_NAN},\n+  {0x7FF0000080000000ULL, SPU_SV_NAN},\n+  {0x7FF0000100000000ULL, SPU_SV_NAN},\n+  {0x7FFFFFFFFFFFFFFFULL, SPU_SV_NAN},\n+  {0xFFF0000000000001ULL, SPU_SV_NAN},\n+  {0xFFF0000080000000ULL, SPU_SV_NAN},\n+  {0xFFF0000100000000ULL, SPU_SV_NAN},\n+  {0xFFFFFFFFFFFFFFFFULL, SPU_SV_NAN}\n+ };\n+\n+  unsigned char cnt = sizeof(samples)/sizeof(struct _samples);\n+  int e0;\n+    for (e0=0; e0<cnt; e0++)\n+    {   \n+      a.ull[0] = samples[e0].v;\n+      a.d[1] = rand_double(-1, -4);\n+\n+      d.vull = spu_testsv(a.vd, SPU_SV_NEG_DENORM);\n+      exp = (SPU_SV_NEG_DENORM & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+    \n+      d.vull = spu_testsv(a.vd, SPU_SV_POS_DENORM);\n+      exp = (SPU_SV_POS_DENORM & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+    \n+      d.vull = spu_testsv(a.vd, SPU_SV_NEG_ZERO);\n+      exp = (SPU_SV_NEG_ZERO & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+    \n+      d.vull = spu_testsv(a.vd, SPU_SV_POS_ZERO);\n+      exp = (SPU_SV_POS_ZERO & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+    \n+      d.vull = spu_testsv(a.vd, SPU_SV_NEG_INFINITY);\n+      exp = (SPU_SV_NEG_INFINITY & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+    \n+      d.vull = spu_testsv(a.vd, SPU_SV_POS_INFINITY);\n+      exp = (SPU_SV_POS_INFINITY & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+    \n+      d.vull = spu_testsv(a.vd, SPU_SV_NAN);\n+      exp = (SPU_SV_NAN & samples[e0].sv) ? 0xFFFFFFFFFFFFFFFFULL : 0ULL;\n+      if (exp != d.ull[0] || d.ull[1] != 0) abort();\n+   }  \n+  return 0;\n+}\n+\n+int main()\n+{\n+  /* +0.0 and -0.0  */\n+  a0.d[0] = 0.0; a0.d[1] = -0.0; b0.d[0] = -0.0; b0.d[1] = 0.0;\n+  /* NaN  */\n+  a1.d[0] = 0.0/0.0; a1.d[1] = 0.0/-0.0; b1.d[0] = -0.0/0.0;  b1.d[1] = -0.0/-0.0;\n+\n+  test_spu_cmpeq();\n+  test_spu_cmpabseq();\n+  test_spu_cmpgt();\n+  test_spu_cmpabsgt();\n+  test_spu_testsv();\n+  return 0;\n+}\n+\n+"}]}