{"sha": "2f278625ee254d3293798efeb57003a42fc2871a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyNzg2MjVlZTI1NGQzMjkzNzk4ZWZlYjU3MDAzYTQyZmMyODcxYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-02-01T01:01:38Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-02-01T01:01:38Z"}, "message": "reload.c (find_reloads): Do not use the mode specified in the insn pattern as reload mode for address...\n\ngcc/\n\t* reload.c (find_reloads): Do not use the mode specified in the insn\n\tpattern as reload mode for address operands.  Do not generate optional\n\treloads for operands where a mandatory reload was already pushed.\n\tGenerate optional reloads only in the final pass though find_reloads.\n\t(have_replacement_p): New function.\n\ngcc/testsuite/\n\t* gcc.dg/20030129-1.c: New test.\n\nFrom-SVN: r62225", "tree": {"sha": "6695bfe875cd231e5b9de23862d2deddab1b9692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6695bfe875cd231e5b9de23862d2deddab1b9692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f278625ee254d3293798efeb57003a42fc2871a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f278625ee254d3293798efeb57003a42fc2871a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f278625ee254d3293798efeb57003a42fc2871a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f278625ee254d3293798efeb57003a42fc2871a/comments", "author": null, "committer": null, "parents": [{"sha": "e4b9b5fb09bda446289e62fd40feb679187ad901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b9b5fb09bda446289e62fd40feb679187ad901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b9b5fb09bda446289e62fd40feb679187ad901"}], "stats": {"total": 100, "additions": 87, "deletions": 13}, "files": [{"sha": "bd9a73d7eaa142205f28e903513b6ad0fba7447e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f278625ee254d3293798efeb57003a42fc2871a", "patch": "@@ -1,3 +1,11 @@\n+2003-01-31  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads): Do not use the mode specified in the insn\n+\tpattern as reload mode for address operands.  Do not generate optional\n+\treloads for operands where a mandatory reload was already pushed.\n+\tGenerate optional reloads only in the final pass though find_reloads.\n+\t(have_replacement_p): New function.\n+\n 2003-01-31  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* doc/install.texi (Testing): Remove a reference to our obsolete"}, {"sha": "1a7434f643c64e286cd68b41d14ce556dcf4383a", "filename": "gcc/reload.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=2f278625ee254d3293798efeb57003a42fc2871a", "patch": "@@ -274,6 +274,7 @@ static void find_reloads_address_part PARAMS ((rtx, rtx *, enum reg_class,\n static rtx find_reloads_subreg_address PARAMS ((rtx, int, int,\n \t\t\t\t\t\tenum reload_type, int, rtx));\n static void copy_replacements_1 PARAMS ((rtx *, rtx *, int));\n+static bool have_replacement_p\tPARAMS ((rtx *));\n static int find_inc_amount\tPARAMS ((rtx, rtx));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n@@ -2689,6 +2690,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  recog_data.operand[i] = *recog_data.operand_loc[i];\n \t  substed_operand[i] = recog_data.operand[i];\n+\n+\t  /* Address operands are reloaded in their existing mode,\n+\t     no matter what is specified in the machine description.  */\n+\t  operand_mode[i] = GET_MODE (recog_data.operand[i]);\n \t}\n       else if (code == MEM)\n \t{\n@@ -3302,10 +3307,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   the address into a base register.  */\n \t\t\tthis_alternative[i] = (int) MODE_BASE_REG_CLASS (VOIDmode);\n \t\t\tbadop = 0;\n-\n-\t\t\t/* Address constraints are reloaded in Pmode, no matter\n-\t\t\t   what mode is given in the machine description.  */\n-\t\t\toperand_mode[i] = Pmode;\n \t\t\tbreak;\n \t\t      }\n \n@@ -3876,9 +3877,20 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    return 0;\n \t  }\n       }\n+\n+    /* Generate optional reloads only when optimizing, and only\n+       on the last pass through reload.  Also, make sure we do not\n+       make an optional reload where we already have a mandatory\n+       one; this can happen in the case of address operands.\n+\n+       To check for mandatory reloads, we use have_replacement_p.\n+       Note that this works only on the last pass through reload.  */\n+    else if (!optimize || !replace \n+\t     || have_replacement_p (recog_data.operand_loc[i]))\n+      ; /* Do nothing.  */\n+\n     else if (goal_alternative_matched[i] < 0\n-\t     && goal_alternative_matches[i] < 0\n-\t     && optimize)\n+\t     && goal_alternative_matches[i] < 0)\n       {\n \t/* For each non-matching operand that's a MEM or a pseudo-register\n \t   that didn't get a hard register, make an optional reload.\n@@ -3928,11 +3940,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   reload, check if this is actually a pseudo register reference;\n \t   we then need to emit a USE and/or a CLOBBER so that reload\n \t   inheritance will do the right thing.  */\n-\telse if (replace\n-\t\t && (GET_CODE (operand) == MEM\n-\t\t     || (GET_CODE (operand) == REG\n-\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t && reg_renumber [REGNO (operand)] < 0)))\n+\telse if (GET_CODE (operand) == MEM\n+\t\t || (GET_CODE (operand) == REG\n+\t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t     && reg_renumber [REGNO (operand)] < 0))\n \t  {\n \t    operand = *recog_data.operand_loc[i];\n \n@@ -3955,8 +3966,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     && goal_alternative_win[goal_alternative_matches[i]]\n \t     && modified[i] == RELOAD_READ\n \t     && modified[goal_alternative_matches[i]] == RELOAD_WRITE\n-\t     && ! no_input_reloads && ! no_output_reloads\n-\t     && optimize)\n+\t     && ! no_input_reloads && ! no_output_reloads)\n       {\n \t/* Similarly, make an optional reload for a pair of matching\n \t   objects that are in MEM or a pseudo that didn't get a hard reg.  */\n@@ -6130,6 +6140,21 @@ find_replacement (loc)\n \n   return *loc;\n }\n+\n+/* Return true if some replacement was scheduled at LOC.  */\n+\n+static bool\n+have_replacement_p (loc)\n+     rtx *loc;\n+{\n+  struct replacement *r;\n+\n+  for (r = &replacements[0]; r < &replacements[n_replacements]; r++)\n+    if (r->where == loc)\n+      return true;\n+\n+  return false;\n+}\n \f\n /* Return nonzero if register in range [REGNO, ENDREGNO)\n    appears either explicitly or implicitly in X"}, {"sha": "acf883d108d1f028af6949b9f0830b42d18f5310", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f278625ee254d3293798efeb57003a42fc2871a", "patch": "@@ -1,3 +1,7 @@\n+2003-01-31  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* gcc.dg/20030129-1.c: New test.\n+\n 2003-01-31  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/8849"}, {"sha": "0b745a901b1d0803ab3db83911ecbd1dd2337534", "filename": "gcc/testsuite/gcc.dg/20030129-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2Ftestsuite%2Fgcc.dg%2F20030129-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f278625ee254d3293798efeb57003a42fc2871a/gcc%2Ftestsuite%2Fgcc.dg%2F20030129-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030129-1.c?ref=2f278625ee254d3293798efeb57003a42fc2871a", "patch": "@@ -0,0 +1,37 @@\n+/* This used to ICE due to a reload bug on s390*.  */\n+\n+/* { dg-do compile { target s390*-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+int f (unsigned int);\n+void g (void *);\n+\n+void test (void *p, void *dummy)\n+{\n+  unsigned int flags = 0;\n+\n+  if (dummy)\n+    g (dummy);\n+\n+  if (p)\n+    flags |= 0x80000000;\n+\n+  asm volatile (\"\" : : : \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\");\n+\n+  if (dummy)\n+    g (dummy);\n+\n+  if (p) \n+    {\n+      flags |= 0x20000000|0x80000000;\n+\n+      if (!f (0))\n+        flags &= ~0x80000000;\n+    }\n+\n+  f (flags);\n+\n+  if (dummy)\n+    g (dummy);\n+}\n+"}]}