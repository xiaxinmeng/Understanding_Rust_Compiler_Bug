{"sha": "0166ff05ca0605e631452f1e504dad60d90f9e26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2NmZmMDVjYTA2MDVlNjMxNDUyZjFlNTA0ZGFkNjBkOTBmOWUyNg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2006-09-02T02:38:20Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2006-09-02T02:38:20Z"}, "message": "cond.md (cbranch<mode>4): Defer splitting until after reload.\n\n* config/m32c/cond.md (cbranch<mode>4): Defer splitting until after reload.\n(stzx_16): Likewise.\n(\"stzx_24_<mode>\"): Likewise.\n(\"stzx_reversed_<mode>\"): Likewise, and make mode-specific.\n(\"cmp<mode>_op\"): New.\n(cmp<mode>): Change to expander; just save operands.\n(b<code>_op): New.\n(b<code>): Change to expander, emit compare here.\n(s<code>_op): Change to use split and expander.\n(s<code>_24_op): Likewise.\n(s<code>_<mode>): New.\n(s<code>_<mode>_24): New.\n(movqicc_<code>_<mode): New.\n(movhicc_<code>_<mode>): New.\n(s<code>): New.\n(s<code>_24): New.\n* config/m32c/m32c.c (compare_op0, compare_op1): New.\n(m32c_pend_compare): New.\n(m32c_unpend_compare): New.\n(m32c_expand_scc): New.\n(m32c_expand_movcc): Emit the compare also.\n* config/m32c/predicates.md (mra_nopp_operand): New.\n\nFrom-SVN: r116653", "tree": {"sha": "2c0f6158f507bd70b6411b29d1995dc05773b846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c0f6158f507bd70b6411b29d1995dc05773b846"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0166ff05ca0605e631452f1e504dad60d90f9e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0166ff05ca0605e631452f1e504dad60d90f9e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0166ff05ca0605e631452f1e504dad60d90f9e26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0166ff05ca0605e631452f1e504dad60d90f9e26/comments", "author": null, "committer": null, "parents": [{"sha": "3a79c9917c3e068844a8c57d837a304cd73d04bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a79c9917c3e068844a8c57d837a304cd73d04bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a79c9917c3e068844a8c57d837a304cd73d04bb"}], "stats": {"total": 255, "additions": 233, "deletions": 22}, "files": [{"sha": "2478b45d2136b0c17759ed7502225b2fe793d7ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0166ff05ca0605e631452f1e504dad60d90f9e26", "patch": "@@ -1,3 +1,28 @@\n+2006-09-01  DJ Delorie  <dj@redhat.com>\n+\n+\t* config/m32c/cond.md (cbranch<mode>4): Defer splitting until after reload.\n+\t(stzx_16): Likewise.\n+\t(\"stzx_24_<mode>\"): Likewise.\n+\t(\"stzx_reversed_<mode>\"): Likewise, and make mode-specific.\n+\t(\"cmp<mode>_op\"): New.\n+\t(cmp<mode>): Change to expander; just save operands.\n+\t(b<code>_op): New.\n+\t(b<code>): Change to expander, emit compare here.\n+\t(s<code>_op): Change to use split and expander.\n+\t(s<code>_24_op): Likewise.\n+\t(s<code>_<mode>): New.\n+\t(s<code>_<mode>_24): New.\n+\t(movqicc_<code>_<mode): New.\n+\t(movhicc_<code>_<mode>): New.\n+\t(s<code>): New.\n+\t(s<code>_24): New.\n+\t* config/m32c/m32c.c (compare_op0, compare_op1): New.\n+\t(m32c_pend_compare): New.\n+\t(m32c_unpend_compare): New.\n+\t(m32c_expand_scc): New.\n+\t(m32c_expand_movcc): Emit the compare also.\n+\t* config/m32c/predicates.md (mra_nopp_operand): New.\n+\n 2006-09-01  J\"orn Rennecke  <joern.rennecke@st.com>\n \tRichard Guenther  <rguenther@suse.de>\n \tAdam Nemet  <anemet@caviumnetworks.com>"}, {"sha": "be590afc49e2e21765b01ac8da1d647821ee2c98", "filename": "gcc/config/m32c/cond.md", "status": "modified", "additions": 145, "deletions": 16, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fcond.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fcond.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fcond.md?ref=0166ff05ca0605e631452f1e504dad60d90f9e26", "patch": "@@ -22,6 +22,20 @@\n \n ; conditionals - cmp, jcc, setcc, etc.\n \n+; Special note about conditional instructions: GCC always emits the\n+; compare right before the insn, which is good, because m32c's mov\n+; insns modify the flags.  However, this means that any conditional\n+; insn that may require reloading must be kept with its compare until\n+; after reload finishes, else the reload insns might clobber the\n+; flags.  Thus, these rules:\n+;\n+; * the cmp* expanders just save the operands in compare_op0 and\n+;   compare_op1 via m32c_pend_compare.\n+; * conditional insns that won't need reload can call\n+;   m32c_unpend_compare before their expansion.\n+; * other insns must expand to include the compare operands within,\n+;   then split after reload to a separate compare and conditional.\n+\n ; Until support for relaxing is supported in gas, we must assume that\n ; short labels won't reach, so we must use long labels.\n ; Unfortunately, there aren't any conditional jumps with long labels,\n@@ -41,7 +55,7 @@\n \t      (pc)))]\n   \"\"\n   \"#\"\n-  \"\"\n+  \"reload_completed\"\n   [(set (reg:CC FLG_REGNO)\n \t(compare (match_dup 1)\n \t\t (match_dup 2)))\n@@ -56,7 +70,7 @@\n \t(if_then_else:QI (eq (reg:CC FLG_REGNO) (const_int 0))\n \t\t\t (match_operand:QI 1 \"const_int_operand\" \"i,i,0\")\n \t\t\t (match_operand:QI 2 \"const_int_operand\" \"i,0,i\")))]\n-  \"TARGET_A16\"\n+  \"TARGET_A16 && reload_completed\"\n   \"@\n    stzx\\t%1,%2,%0\n    stz\\t%1,%0\n@@ -69,38 +83,45 @@\n \t(if_then_else:QHI (eq (reg:CC FLG_REGNO) (const_int 0))\n \t\t\t (match_operand:QHI 1 \"const_int_operand\" \"i,i,0\")\n \t\t\t (match_operand:QHI 2 \"const_int_operand\" \"i,0,i\")))]\n-  \"TARGET_A24\"\n+  \"TARGET_A24 && reload_completed\"\n   \"@\n    stzx.<bwl>\\t%1,%2,%0\n    stz.<bwl>\\t%1,%0\n    stnz.<bwl>\\t%2,%0\"\n   [(set_attr \"flags\" \"n,n,n\")])\n \n-(define_insn_and_split \"stzx_reversed\"\n-  [(set (match_operand 0 \"m32c_r0_operand\" \"\")\n-\t(if_then_else (ne (reg:CC FLG_REGNO) (const_int 0))\n-\t\t\t (match_operand 1 \"const_int_operand\" \"\")\n-\t\t\t (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_A24 || GET_MODE (operands[0]) == QImode\"\n+(define_insn_and_split \"stzx_reversed_<mode>\"\n+  [(set (match_operand:QHI 0 \"m32c_r0_operand\" \"\")\n+\t(if_then_else:QHI (ne (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (match_operand:QHI 1 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:QHI 2 \"const_int_operand\" \"\")))]\n+  \"(TARGET_A24 || GET_MODE (operands[0]) == QImode) && reload_completed\"\n   \"#\"\n   \"\"\n   [(set (match_dup 0)\n-\t(if_then_else (eq (reg:CC FLG_REGNO) (const_int 0))\n+\t(if_then_else:QHI (eq (reg:CC FLG_REGNO) (const_int 0))\n \t\t      (match_dup 2)\n \t\t      (match_dup 1)))]\n   \"\"\n   )\n \n \n-(define_insn \"cmp<mode>\"\n+(define_insn \"cmp<mode>_op\"\n   [(set (reg:CC FLG_REGNO)\n \t(compare (match_operand:QHPSI 0 \"mra_operand\" \"RraSd\")\n \t\t (match_operand:QHPSI 1 \"mrai_operand\" \"RraSdi\")))]\n   \"\"\n   \"* return m32c_output_compare(insn, operands); \"\n   [(set_attr \"flags\" \"oszc\")])\n \n-(define_insn \"b<code>\"\n+(define_expand \"cmp<mode>\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_operand:QHPSI 0 \"mra_operand\" \"RraSd\")\n+\t\t (match_operand:QHPSI 1 \"mrai_operand\" \"RraSdi\")))]\n+  \"\"\n+  \"m32c_pend_compare (operands); DONE;\")\n+\n+(define_insn \"b<code>_op\"\n   [(set (pc)\n         (if_then_else (any_cond (reg:CC FLG_REGNO)\n \t\t\t\t(const_int 0))\n@@ -111,23 +132,131 @@\n   [(set_attr \"flags\" \"n\")]\n )\n \n+(define_expand \"b<code>\"\n+  [(set (pc)\n+        (if_then_else (any_cond (reg:CC FLG_REGNO)\n+\t\t\t\t(const_int 0))\n+                      (label_ref (match_operand 0 \"\"))\n+                      (pc)))]\n+  \"\"\n+  \"m32c_unpend_compare ();\"\n+)\n+\n ;; m32c_conditional_register_usage changes the setcc_gen_code array to\n ;; point to the _24 variants if needed.\n \n-(define_insn \"s<code>\"\n+;; We need to keep the compare and conditional sets together through\n+;; reload, because reload might need to add address reloads to the\n+;; set, which would clobber the flags.  By keeping them together, the\n+;; reloads get put before the compare, thus preserving the flags.\n+\n+;; These are the post-split patterns for the conditional sets.\n+\n+(define_insn \"s<code>_op\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n \t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n-  \"TARGET_A16\"\n+  \"TARGET_A16 && reload_completed\"\n   \"* return m32c_scc_pattern(operands, <CODE>);\")\n \n-(define_insn \"s<code>_24\"\n+(define_insn \"s<code>_24_op\"\n   [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd\")\n \t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n-  \"TARGET_A24\"\n+  \"TARGET_A24 && reload_completed\"\n   \"sc<code>\\t%0\"\n   [(set_attr \"flags\" \"n\")]\n )\n \n+;; These are the pre-split patterns for the conditional sets.  Yes,\n+;; there are a lot of permutations.\n+\n+(define_insn_and_split \"s<code>_<mode>\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n+\t(any_cond:QI (match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n+\t\t     (match_operand:QHPSI 2 \"mrai_operand\" \"RraSdi\")))]\n+  \"TARGET_A16\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0)\n+\t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n+  \"\"\n+  [(set_attr \"flags\" \"x\")]\n+)\n+\n+(define_insn_and_split \"s<code>_<mode>_24\"\n+  [(set (match_operand:HI 0 \"mra_nopp_operand\" \"=RhiSd\")\n+\t(any_cond:HI (match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n+\t\t     (match_operand:QHPSI 2 \"mrai_operand\" \"RraSdi\")))]\n+  \"TARGET_A24\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0)\n+\t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n+  \"\"\n+  [(set_attr \"flags\" \"x\")]\n+)\n+\n+(define_insn_and_split \"movqicc_<code>_<mode>\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (if_then_else:QI (eqne_cond:QI (match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n+\t\t\t\t       (match_operand:QHPSI 2 \"mrai_operand\" \"RraSdi\"))\n+\t\t\t  (match_operand:QI 3 \"const_int_operand\" \"\")\n+\t\t\t  (match_operand:QI 4 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0)\n+        (if_then_else:QI (eqne_cond:QI (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (match_dup 3)\n+\t\t\t (match_dup 4)))]\n+  \"\"\n+  [(set_attr \"flags\" \"x\")]\n+  )\n+\n+(define_insn_and_split \"movhicc_<code>_<mode>\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+        (if_then_else:HI (eqne_cond:HI (match_operand:QHPSI 1 \"mra_operand\" \"RraSd\")\n+\t\t\t\t       (match_operand:QHPSI 2 \"mrai_operand\" \"RraSdi\"))\n+\t\t\t  (match_operand:QI 3 \"const_int_operand\" \"\")\n+\t\t\t  (match_operand:QI 4 \"const_int_operand\" \"\")))]\n+  \"TARGET_A24\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC FLG_REGNO)\n+\t(compare (match_dup 1)\n+\t\t (match_dup 2)))\n+   (set (match_dup 0)\n+        (if_then_else:HI (eqne_cond:HI (reg:CC FLG_REGNO) (const_int 0))\n+\t\t\t (match_dup 3)\n+\t\t\t (match_dup 4)))]\n+  \"\"\n+  [(set_attr \"flags\" \"x\")]\n+  )\n+\n+;; And these are the expanders, which read the pending compare\n+;; operands to build a combined insn.\n+\n+(define_expand \"s<code>\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=Rqi\")\n+\t(any_cond:QI (reg:CC FLG_REGNO) (const_int 0)))]\n+  \"TARGET_A16\"\n+  \"m32c_expand_scc (<CODE>, operands); DONE;\")\n+\n+(define_expand \"s<code>_24\"\n+  [(set (match_operand:HI 0 \"mra_nopp_operand\" \"=RhiSd\")\n+\t(any_cond:HI (reg:CC FLG_REGNO) (const_int 0)))]\n+  \"TARGET_A24\"\n+  \"m32c_expand_scc (<CODE>, operands); DONE;\")\n+\n+\n (define_expand \"movqicc\"\n   [(set (match_operand:QI 0 \"register_operand\" \"\")\n         (if_then_else:QI (match_operand 1 \"m32c_eqne_operator\" \"\")"}, {"sha": "06bd0070ac33900397b36d625903a1899b95e71f", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=0166ff05ca0605e631452f1e504dad60d90f9e26", "patch": "@@ -46,6 +46,7 @@ void m32c_register_pragmas (void);\n int  m32c_regno_ok_for_base_p (int);\n int  m32c_trampoline_alignment (void);\n int  m32c_trampoline_size (void);\n+void m32c_unpend_compare (void);\n \n #if defined(RTX_CODE) && defined(TREE_CODE)\n \n@@ -68,6 +69,7 @@ int  m32c_expand_movmemhi (rtx *);\n int  m32c_expand_movstr (rtx *);\n void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);\n+void m32c_expand_scc (int, rtx *);\n int  m32c_extra_constraint_p (rtx, char, const char *);\n int  m32c_extra_constraint_p2 (rtx, char, const char *);\n int  m32c_hard_regno_nregs (int, MM);\n@@ -86,6 +88,7 @@ int  m32c_mode_dependent_address (rtx);\n int  m32c_modes_tieable_p (MM, MM);\n bool m32c_mov_ok (rtx *, MM);\n char * m32c_output_compare (rtx, rtx *);\n+void m32c_pend_compare (rtx *);\n int  m32c_preferred_output_reload_class (rtx, int);\n int  m32c_preferred_reload_class (rtx, int);\n int  m32c_prepare_move (rtx *, MM);"}, {"sha": "684678739760e95ba34e8ca4280e733efef23ae7", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=0166ff05ca0605e631452f1e504dad60d90f9e26", "patch": "@@ -3488,6 +3488,42 @@ m32c_expand_neg_mulpsi3 (rtx * operands)\n   emit_insn (gen_truncsipsi2 (operands[0], temp2));\n }\n \n+static rtx compare_op0, compare_op1;\n+\n+void\n+m32c_pend_compare (rtx *operands)\n+{\n+  compare_op0 = operands[0];\n+  compare_op1 = operands[1];\n+}\n+\n+void\n+m32c_unpend_compare (void)\n+{\n+  switch (GET_MODE (compare_op0))\n+    {\n+    case QImode:\n+      emit_insn (gen_cmpqi_op (compare_op0, compare_op1));\n+    case HImode:\n+      emit_insn (gen_cmphi_op (compare_op0, compare_op1));\n+    case PSImode:\n+      emit_insn (gen_cmppsi_op (compare_op0, compare_op1));\n+    }\n+}\n+\n+void\n+m32c_expand_scc (int code, rtx *operands)\n+{\n+  enum machine_mode mode = TARGET_A16 ? QImode : HImode;\n+\n+  emit_insn (gen_rtx_SET (mode,\n+\t\t\t  operands[0],\n+\t\t\t  gen_rtx_fmt_ee (code,\n+\t\t\t\t\t  mode,\n+\t\t\t\t\t  compare_op0,\n+\t\t\t\t\t  compare_op1)));\n+}\n+\n /* Pattern Output Functions */\n \n /* Returns a (OP (reg:CC FLG_REGNO) (const_int 0)) from some other\n@@ -3505,6 +3541,8 @@ int\n m32c_expand_movcc (rtx *operands)\n {\n   rtx rel = operands[1];\n+  rtx cmp;\n+\n   if (GET_CODE (rel) != EQ && GET_CODE (rel) != NE)\n     return 1;\n   if (GET_CODE (operands[2]) != CONST_INT\n@@ -3517,12 +3555,17 @@ m32c_expand_movcc (rtx *operands)\n       operands[2] = operands[3];\n       operands[3] = tmp;\n     }\n-  if (TARGET_A16)\n-    emit_insn (gen_stzx_16 (operands[0], operands[2], operands[3]));\n-  else if (GET_MODE (operands[0]) == QImode)\n-    emit_insn (gen_stzx_24_qi (operands[0], operands[2], operands[3]));\n-  else\n-    emit_insn (gen_stzx_24_hi (operands[0], operands[2], operands[3]));\n+\n+  cmp = gen_rtx_fmt_ee (GET_CODE (rel),\n+\t\t\tGET_MODE (rel),\n+\t\t\tcompare_op0,\n+\t\t\tcompare_op1);\n+\n+  emit_move_insn (operands[0],\n+\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t\tcmp,\n+\t\t\t\t\toperands[2],\n+\t\t\t\t\toperands[3]));\n   return 0;\n }\n "}, {"sha": "b0fbc846c89da6958c754d0a0d04579f87418170", "filename": "gcc/config/m32c/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0166ff05ca0605e631452f1e504dad60d90f9e26/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fpredicates.md?ref=0166ff05ca0605e631452f1e504dad60d90f9e26", "patch": "@@ -141,6 +141,17 @@\n   (and (match_operand 0 \"nonimmediate_operand\" \"\")\n        (not (match_operand 1 \"cr_operand\" \"\"))))\n \n+; As above, but no push/pop operations\n+(define_predicate \"mra_nopp_operand\"\n+  (match_operand 0 \"mra_operand\" \"\")\n+{\n+  if (GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t  || (GET_CODE (XEXP (op, 0)) == POST_INC)))\n+    return 0;\n+  return 1;\n+})\n+\n ; TRUE for memory, r0..r3, a0..a1, or immediates.\n (define_predicate \"mrai_operand\"\n   (and (and (match_operand 0 \"m32c_any_operand\" \"\")"}]}