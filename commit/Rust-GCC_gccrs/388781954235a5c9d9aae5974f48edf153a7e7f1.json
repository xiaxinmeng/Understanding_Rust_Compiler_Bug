{"sha": "388781954235a5c9d9aae5974f48edf153a7e7f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg4NzgxOTU0MjM1YTVjOWQ5YWFlNTk3NGY0OGVkZjE1M2E3ZTdmMQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-09-29T11:28:58Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-29T11:28:58Z"}, "message": "IndexColorModel.java: Reformated.\n\n2003-09-29  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/image/IndexColorModel.java: Reformated.\n\nFrom-SVN: r71898", "tree": {"sha": "f3a56d22d29dc2a5553e9538b8746add5560f4f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3a56d22d29dc2a5553e9538b8746add5560f4f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/388781954235a5c9d9aae5974f48edf153a7e7f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388781954235a5c9d9aae5974f48edf153a7e7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/388781954235a5c9d9aae5974f48edf153a7e7f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388781954235a5c9d9aae5974f48edf153a7e7f1/comments", "author": null, "committer": null, "parents": [{"sha": "7da1da835210b6388c3600f3070ebfda50bf717c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da1da835210b6388c3600f3070ebfda50bf717c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da1da835210b6388c3600f3070ebfda50bf717c"}], "stats": {"total": 340, "additions": 172, "deletions": 168}, "files": [{"sha": "100dc466509bd405192c201db9a5833067fde610", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388781954235a5c9d9aae5974f48edf153a7e7f1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388781954235a5c9d9aae5974f48edf153a7e7f1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=388781954235a5c9d9aae5974f48edf153a7e7f1", "patch": "@@ -1,3 +1,7 @@\n+2003-09-29  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/image/IndexColorModel.java: Reformated.\n+\n 2003-09-29  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/InetAddress.java,"}, {"sha": "9ceb0bf0944e3422f455a577c25da665cae7adf6", "filename": "libjava/java/awt/image/IndexColorModel.java", "status": "modified", "additions": 168, "deletions": 168, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/388781954235a5c9d9aae5974f48edf153a7e7f1/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/388781954235a5c9d9aae5974f48edf153a7e7f1/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java?ref=388781954235a5c9d9aae5974f48edf153a7e7f1", "patch": "@@ -43,70 +43,70 @@\n  */\n public class IndexColorModel extends ColorModel\n {\n-    private int map_size;\n-    private boolean opaque;\n-    private int trans = -1;\n-    private int[] rgb;\n+  private int map_size;\n+  private boolean opaque;\n+  private int trans = -1;\n+  private int[] rgb;\n \n-    /**\n-     * Each array much contain <code>size</code> elements.  For each \n-     * array, the i-th color is described by reds[i], greens[i], \n-     * blues[i], alphas[i], unless alphas is not specified, then all the \n-     * colors are opaque except for the transparent color. \n-     *\n-     * @param bits the number of bits needed to represent <code>size</code> colors\n-     * @param size the number of colors in the color map\n-     * @param reds the red component of all colors\n-     * @param greens the green component of all colors\n-     * @param blues the blue component of all colors\n-     */\n-    public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n+  /**\n+   * Each array much contain <code>size</code> elements.  For each \n+   * array, the i-th color is described by reds[i], greens[i], \n+   * blues[i], alphas[i], unless alphas is not specified, then all the \n+   * colors are opaque except for the transparent color. \n+   *\n+   * @param bits the number of bits needed to represent <code>size</code> colors\n+   * @param size the number of colors in the color map\n+   * @param reds the red component of all colors\n+   * @param greens the green component of all colors\n+   * @param blues the blue component of all colors\n+   */\n+  public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n                          byte[] blues)\n   {\n-\tthis(bits, size, reds, greens, blues, (byte[])null);\n-    }\n+    this (bits, size, reds, greens, blues, (byte[]) null);\n+  }\n \n-    /**\n-     * Each array much contain <code>size</code> elements.  For each \n-     * array, the i-th color is described by reds[i], greens[i], \n-     * blues[i], alphas[i], unless alphas is not specified, then all the \n-     * colors are opaque except for the transparent color. \n-     *\n-     * @param bits the number of bits needed to represent <code>size</code> colors\n-     * @param size the number of colors in the color map\n-     * @param reds the red component of all colors\n-     * @param greens the green component of all colors\n-     * @param blues the blue component of all colors\n-     * @param trans the index of the transparent color\n-     */\n-    public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n+  /**\n+   * Each array much contain <code>size</code> elements.  For each \n+   * array, the i-th color is described by reds[i], greens[i], \n+   * blues[i], alphas[i], unless alphas is not specified, then all the \n+   * colors are opaque except for the transparent color. \n+   *\n+   * @param bits the number of bits needed to represent <code>size</code> colors\n+   * @param size the number of colors in the color map\n+   * @param reds the red component of all colors\n+   * @param greens the green component of all colors\n+   * @param blues the blue component of all colors\n+   * @param trans the index of the transparent color\n+   */\n+  public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n                          byte[] blues, int trans)\n   {\n-\tthis(bits, size, reds, greens, blues, (byte[])null);\n-\tthis.trans = trans;\n-    }\n+    this (bits, size, reds, greens, blues, (byte[]) null);\n+    this.trans = trans;\n+  }\n \n-    /**\n-     * Each array much contain <code>size</code> elements.  For each \n-     * array, the i-th color is described by reds[i], greens[i], \n-     * blues[i], alphas[i], unless alphas is not specified, then all the \n-     * colors are opaque except for the transparent color. \n-     *\n-     * @param bits the number of bits needed to represent <code>size</code> colors\n-     * @param size the number of colors in the color map\n-     * @param reds the red component of all colors\n-     * @param greens the green component of all colors\n-     * @param blues the blue component of all colors\n-     * @param alphas the alpha component of all colors\n-     */\n-    public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n+  /**\n+   * Each array much contain <code>size</code> elements.  For each \n+   * array, the i-th color is described by reds[i], greens[i], \n+   * blues[i], alphas[i], unless alphas is not specified, then all the \n+   * colors are opaque except for the transparent color. \n+   *\n+   * @param bits the number of bits needed to represent <code>size</code> colors\n+   * @param size the number of colors in the color map\n+   * @param reds the red component of all colors\n+   * @param greens the green component of all colors\n+   * @param blues the blue component of all colors\n+   * @param alphas the alpha component of all colors\n+   */\n+  public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n                          byte[] blues, byte[] alphas)\n   {\n-\tsuper(bits);\n-\tmap_size = size;\n-\topaque = (alphas == null);\n+    super (bits);\n+    map_size = size;\n+    opaque = (alphas == null);\n \n-\trgb = new int[size];\n+    rgb = new int[size];\n     if (alphas == null)\n       {\n         for (int i = 0; i < size; i++)\n@@ -115,8 +115,8 @@ public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n                       | ((reds[i] & 0xff) << 16)\n                       | ((greens[i] & 0xff) << 8)\n                       | (blues[i] & 0xff));\n-\t    }\n-\t}\n+          }\n+      }\n     else\n       {\n         for (int i = 0; i < size; i++)\n@@ -125,165 +125,165 @@ public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n                       | ((reds[i] & 0xff) << 16)\n                       | ((greens[i] & 0xff) << 8)\n                       | (blues[i] & 0xff));\n-\t    }\n-\t}\n-    }\n+          }\n+      }\n+  }\n \n-    /**\n-     * Each array much contain <code>size</code> elements.  For each \n-     * array, the i-th color is described by reds[i], greens[i], \n-     * blues[i], alphas[i], unless alphas is not specified, then all the \n-     * colors are opaque except for the transparent color. \n-     *\n-     * @param bits the number of bits needed to represent <code>size</code> colors\n-     * @param size the number of colors in the color map\n-     * @param cmap packed color components\n-     * @param start the offset of the first color component in <code>cmap</code>\n-     * @param hasAlpha <code>cmap</code> has alpha values\n-     */\n-    public IndexColorModel(int bits, int size, byte[] cmap, int start, \n+  /**\n+   * Each array much contain <code>size</code> elements.  For each \n+   * array, the i-th color is described by reds[i], greens[i], \n+   * blues[i], alphas[i], unless alphas is not specified, then all the \n+   * colors are opaque except for the transparent color. \n+   *\n+   * @param bits the number of bits needed to represent <code>size</code> colors\n+   * @param size the number of colors in the color map\n+   * @param cmap packed color components\n+   * @param start the offset of the first color component in <code>cmap</code>\n+   * @param hasAlpha <code>cmap</code> has alpha values\n+   */\n+  public IndexColorModel (int bits, int size, byte[] cmap, int start, \n                           boolean hasAlpha)\n   {\n-\tthis(bits, size, cmap, start, hasAlpha, -1);\n-    }\n+    this (bits, size, cmap, start, hasAlpha, -1);\n+  }\n \n-    /**\n-     * Each array much contain <code>size</code> elements.  For each \n-     * array, the i-th color is described by reds[i], greens[i], \n-     * blues[i], alphas[i], unless alphas is not specified, then all the \n-     * colors are opaque except for the transparent color. \n-     *\n-     * @param bits the number of bits needed to represent <code>size</code> colors\n-     * @param size the number of colors in the color map\n-     * @param cmap packed color components\n-     * @param start the offset of the first color component in <code>cmap</code>\n-     * @param hasAlpha <code>cmap</code> has alpha values\n-     * @param trans the index of the transparent color\n-     */\n-    public IndexColorModel(int bits, int size, byte[] cmap, int start, \n+  /**\n+   * Each array much contain <code>size</code> elements.  For each \n+   * array, the i-th color is described by reds[i], greens[i], \n+   * blues[i], alphas[i], unless alphas is not specified, then all the \n+   * colors are opaque except for the transparent color. \n+   *\n+   * @param bits the number of bits needed to represent <code>size</code> colors\n+   * @param size the number of colors in the color map\n+   * @param cmap packed color components\n+   * @param start the offset of the first color component in <code>cmap</code>\n+   * @param hasAlpha <code>cmap</code> has alpha values\n+   * @param trans the index of the transparent color\n+   */\n+  public IndexColorModel (int bits, int size, byte[] cmap, int start, \n                           boolean hasAlpha, int trans)\n   {\n-\tsuper(bits);\n-\tmap_size = size;\n-        opaque = !hasAlpha;\n-\tthis.trans = trans;\n-    }\n+    super (bits);\n+    map_size = size;\n+    opaque = !hasAlpha;\n+    this.trans = trans;\n+  }\n \n   public final int getMapSize ()\n   {\n-\treturn map_size;\n-    }\n+    return map_size;\n+  }\n \n-    /**\n-     * Get the index of the transparent color in this color model\n-     */\n+  /**\n+   * Get the index of the transparent color in this color model\n+   */\n   public final int getTransparentPixel ()\n   {\n-\treturn trans;\n-    }\n+    return trans;\n+  }\n \n-    /**\n-     * <br>\n-     */\n+  /**\n+   * <br>\n+   */\n   public final void getReds (byte[] r)\n   {\n-\tgetComponents( r, 2 );\n-    }\n+    getComponents (r, 2);\n+  }\n \n-    /**\n-     * <br>\n-     */\n+  /**\n+   * <br>\n+   */\n   public final void getGreens (byte[] g)\n   {\n-\tgetComponents( g, 1 );\n-    }\n+    getComponents (g, 1);\n+  }\n \n-    /**\n-     * <br>\n-     */\n+  /**\n+   * <br>\n+   */\n   public final void getBlues (byte[] b)\n   {\n-\tgetComponents( b, 0 );\n-    }\n+    getComponents (b, 0);\n+  }\n \n-    /**\n-     * <br>\n-     */\n+  /**\n+   * <br>\n+   */\n   public final void getAlphas (byte[] a)\n   {\n-\tgetComponents( a, 3 );\n-    }\n+    getComponents (a, 3);\n+  }\n \n-    private void getComponents( byte[] c, int ci )\n-    {\n-\tint i, max = ( map_size < c.length ) ? map_size : c.length;\n-\tfor( i = 0; i < max; i++ )\n-\t    c[i] = (byte)(( generateMask( ci )  & rgb[i]) >> ( ci * pixel_bits) );\n-    } \n+  private void getComponents (byte[] c, int ci)\n+  {\n+    int i, max = (map_size < c.length) ? map_size : c.length;\n+    for (i = 0; i < max; i++)\n+\t    c[i] = (byte) ((generateMask (ci)  & rgb[i]) >> (ci * pixel_bits));\n+  } \n \n-    /**\n-     * Get the red component of the given pixel.\n-     */\n+  /**\n+   * Get the red component of the given pixel.\n+   */\n   public final int getRed (int pixel)\n   {\n-\tif( pixel < map_size ) \n-\t    return  (int)(( generateMask( 2 )  & rgb[pixel]) >> (2 * pixel_bits ) );\n+    if (pixel < map_size)\n+\t    return (int) ((generateMask (2) & rgb[pixel]) >> (2 * pixel_bits));\n     \n-\treturn 0;\n-    }\n+    return 0;\n+  }\n \n-    /**\n-     * Get the green component of the given pixel.\n-     */\n+  /**\n+   * Get the green component of the given pixel.\n+   */\n   public final int getGreen (int pixel)\n   {\n-\tif( pixel < map_size ) \n-\t    return (int)(( generateMask( 1 )  & rgb[pixel]) >> (1 * pixel_bits ) );\n+    if (pixel < map_size)\n+\t    return (int) ((generateMask (1) & rgb[pixel]) >> (1 * pixel_bits));\n     \n-\treturn 0;\n-    }\n+    return 0;\n+  }\n \n-    /**\n-     * Get the blue component of the given pixel.\n-     */\n+  /**\n+   * Get the blue component of the given pixel.\n+   */\n   public final int getBlue (int pixel)\n   {\n-\tif( pixel < map_size ) \n-\t    return  (int)( generateMask( 0 )  & rgb[pixel]);\n+    if (pixel < map_size) \n+\t    return (int) (generateMask (0) & rgb[pixel]);\n     \n-\treturn 0;\n-    }\n+    return 0;\n+  }\n \n-    /**\n-     * Get the alpha component of the given pixel.\n-     */\n+  /**\n+   * Get the alpha component of the given pixel.\n+   */\n   public final int getAlpha (int pixel)\n   {\n-\tif( pixel < map_size ) \n-\t    return  (int)(( generateMask( 3 )  & rgb[pixel]) >> (3 * pixel_bits ) );\n+    if (pixel < map_size)\n+\t    return (int) ((generateMask (3) & rgb[pixel]) >> (3 * pixel_bits));\n     \n-\treturn 0;\n-    }\n+    return 0;\n+  }\n \n-    /**\n-     * Get the RGB color value of the given pixel using the default\n-     * RGB color model. \n-     *\n-     * @param pixel a pixel value\n-     */\n+  /**\n+   * Get the RGB color value of the given pixel using the default\n+   * RGB color model. \n+   *\n+   * @param pixel a pixel value\n+   */\n   public final int getRGB (int pixel)\n   {\n-\tif( pixel < map_size ) \n+    if (pixel < map_size)\n \t    return rgb[pixel];\n     \n-\treturn 0;\n-    }\n+    return 0;\n+  }\n     \n-    //pixel_bits is number of bits to be in generated mask\n-    private int generateMask( int offset )\n-    {\n-\treturn (  ( ( 2 << pixel_bits ) - 1 ) << ( pixel_bits * offset ) );\n-    }\n+  //pixel_bits is number of bits to be in generated mask\n+  private int generateMask (int offset)\n+  {\n+    return (((2 << pixel_bits ) - 1) << (pixel_bits * offset));\n+  }\n \n }\n "}]}