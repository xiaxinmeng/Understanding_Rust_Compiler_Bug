{"sha": "8019105d7c6d15f611cd479437093d674f36293a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxOTEwNWQ3YzZkMTVmNjExY2Q0Nzk0MzcwOTNkNjc0ZjM2MjkzYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-11-04T20:19:40Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2013-11-04T20:19:40Z"}, "message": "re PR fortran/58771 (ICE in transfer_expr, at fortran/trans-io.c:2164)\n\n2013-11-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/58771\n\t* trans-io.c (transfer_expr): If the backend_decl for a derived\n\ttype is missing, build it with gfc_typenode_for_spec.\n\n2013-11-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/58771\n\t* gfortran.dg/derived_external_function_1.f90 : New test\n\nFrom-SVN: r204358", "tree": {"sha": "148e097852336d15e0998904c779d8782f968797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/148e097852336d15e0998904c779d8782f968797"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8019105d7c6d15f611cd479437093d674f36293a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8019105d7c6d15f611cd479437093d674f36293a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8019105d7c6d15f611cd479437093d674f36293a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8019105d7c6d15f611cd479437093d674f36293a/comments", "author": null, "committer": null, "parents": [{"sha": "7e8c8abc9974707605cd422ff13bc6d5dd264986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8c8abc9974707605cd422ff13bc6d5dd264986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8c8abc9974707605cd422ff13bc6d5dd264986"}], "stats": {"total": 66, "additions": 55, "deletions": 11}, "files": [{"sha": "d1934a28e809850e67877fe66f3b48d0a6eff681", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8019105d7c6d15f611cd479437093d674f36293a", "patch": "@@ -1,3 +1,9 @@\n+2013-11-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/58771\n+\t* trans-io.c (transfer_expr): If the backend_decl for a derived\n+\ttype is missing, build it with gfc_typenode_for_spec.\n+\n 2013-11-04  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/57445"}, {"sha": "5fa1cdc091ea9b862620ce73464fb8e349a3bef1", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=8019105d7c6d15f611cd479437093d674f36293a", "patch": "@@ -243,16 +243,16 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n \n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n-  \n+\n   arg1 = gfc_build_addr_expr (NULL_TREE, var);\n-  \n+\n   arg2 = build_int_cst (integer_type_node, error_code),\n-  \n+\n   asprintf (&message, \"%s\", _(msgid));\n   arg3 = gfc_build_addr_expr (pchar_type_node,\n \t\t\t      gfc_build_localized_cstring_const (message));\n   free (message);\n-  \n+\n   tmp = build_call_expr_loc (input_location,\n \t\t\t gfor_fndecl_generate_error, 3, arg1, arg2, arg3);\n \n@@ -521,7 +521,7 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n       gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n \t\t\t       \"Unit number in I/O statement too small\",\n \t\t\t       &se.pre);\n-    \n+\n       /* UNIT numbers should be less than the max.  */\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);\n       cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n@@ -1000,7 +1000,7 @@ gfc_trans_open (gfc_code * code)\n   if (p->convert)\n     mask |= set_string (&block, &post_block, var, IOPARM_open_convert,\n \t\t\tp->convert);\n-\t\t\t\n+\n   if (p->newunit)\n     mask |= set_parameter_ref (&block, &post_block, var, IOPARM_open_newunit,\n \t\t\t       p->newunit);\n@@ -1234,7 +1234,7 @@ gfc_trans_inquire (gfc_code * code)\n     {\n       mask |= set_parameter_ref (&block, &post_block, var, IOPARM_inquire_exist,\n \t\t\t\t p->exist);\n-    \n+\n       if (p->unit && !p->iostat)\n \t{\n \t  p->iostat = create_dummy_iostat ();\n@@ -1322,7 +1322,7 @@ gfc_trans_inquire (gfc_code * code)\n   if (p->pad)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_pad,\n \t\t\tp->pad);\n-  \n+\n   if (p->convert)\n     mask |= set_string (&block, &post_block, var, IOPARM_inquire_convert,\n \t\t\tp->convert);\n@@ -1547,7 +1547,7 @@ transfer_namelist_element (stmtblock_t * block, const char * var_name,\n   tree dtype;\n   tree dt_parm_addr;\n   tree decl = NULL_TREE;\n-  int n_dim; \n+  int n_dim;\n   int itype;\n   int rank = 0;\n \n@@ -2029,7 +2029,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n       ts->type = BT_INTEGER;\n       ts->kind = gfc_index_integer_kind;\n     }\n-  \n+\n   kind = ts->kind;\n   function = NULL;\n   arg2 = NULL;\n@@ -2111,7 +2111,7 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n \t    function = iocall[IOCALL_X_CHARACTER_WIDE];\n \t  else\n \t    function = iocall[IOCALL_X_CHARACTER_WIDE_WRITE];\n-\t    \n+\n \t  tmp = gfc_build_addr_expr (NULL_TREE, dt_parm);\n \t  tmp = build_call_expr_loc (input_location,\n \t\t\t\t function, 4, tmp, addr_expr, arg2, arg3);\n@@ -2146,6 +2146,12 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n       expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t      expr);\n \n+      /* Make sure that the derived type has been built.  An external\n+\t function, if only referenced in an io statement, requires this\n+\t check (see PR58771).  */\n+      if (ts->u.derived->backend_decl == NULL_TREE)\n+\ttmp = gfc_typenode_for_spec (ts);\n+\n       for (c = ts->u.derived->components; c; c = c->next)\n \t{\n \t  field = c->backend_decl;"}, {"sha": "eb6202f1bf81abb38861621d16bfc51f85f897a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8019105d7c6d15f611cd479437093d674f36293a", "patch": "@@ -1,3 +1,8 @@\n+2013-11-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/58771\n+\t* gfortran.dg/derived_external_function_1.f90 : New test\n+\n 2013-11-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/58978"}, {"sha": "7421c4c0f221880e02883f908c28ee9005d927ec", "filename": "gcc/testsuite/gfortran.dg/derived_external_function_1.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_external_function_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8019105d7c6d15f611cd479437093d674f36293a/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_external_function_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fderived_external_function_1.f90?ref=8019105d7c6d15f611cd479437093d674f36293a", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do run }\n+!\n+! PR fortran/58771\n+!\n+! Contributed by Vittorio Secca  <zeccav@gmail.com>\n+!\n+! ICEd on the write statement with f() because the derived type backend\n+! declaration not built.\n+!\n+module m\n+  type t\n+    integer(4) g\n+  end type\n+end\n+\n+type(t) function f() result(ff)\n+  use m\n+  ff%g = 42\n+end\n+\n+  use m\n+  character (20) :: line1, line2\n+  type(t)  f\n+  write (line1, *) f()\n+  write (line2, *) 42_4\n+  if (line1 .ne. line2) call abort\n+end"}]}