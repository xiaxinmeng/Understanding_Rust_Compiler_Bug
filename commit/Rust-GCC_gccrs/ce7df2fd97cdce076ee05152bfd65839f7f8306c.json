{"sha": "ce7df2fd97cdce076ee05152bfd65839f7f8306c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U3ZGYyZmQ5N2NkY2UwNzZlZTA1MTUyYmZkNjU4MzlmN2Y4MzA2Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-03-12T21:11:51Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-03-12T21:11:51Z"}, "message": "14176.cc: New.\n\n\n2004-03-12  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* testsuite/20_util/allocator/14176.cc: New.\n\t* include/ext/mt_allocator.h: Formatting fixes.\n\nFrom-SVN: r79407", "tree": {"sha": "2b0c0fe642d19afe58fa53b38b83aa5f2278a493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0c0fe642d19afe58fa53b38b83aa5f2278a493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce7df2fd97cdce076ee05152bfd65839f7f8306c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce7df2fd97cdce076ee05152bfd65839f7f8306c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce7df2fd97cdce076ee05152bfd65839f7f8306c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce7df2fd97cdce076ee05152bfd65839f7f8306c/comments", "author": null, "committer": null, "parents": [{"sha": "4319ac925d2a540e2fc790fdf842ab2a93d01134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4319ac925d2a540e2fc790fdf842ab2a93d01134", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4319ac925d2a540e2fc790fdf842ab2a93d01134"}], "stats": {"total": 367, "additions": 203, "deletions": 164}, "files": [{"sha": "6f53566c47550862dcd942efa766ba9bc5f66ac2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7df2fd97cdce076ee05152bfd65839f7f8306c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7df2fd97cdce076ee05152bfd65839f7f8306c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ce7df2fd97cdce076ee05152bfd65839f7f8306c", "patch": "@@ -1,11 +1,17 @@\n+2004-03-12  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* testsuite/20_util/allocator/14176.cc: New.\n+\t* include/ext/mt_allocator.h: Formatting fixes.\n+\t\n 2004-03-11  Dhruv Matani  <dhruvbird@HotPOP.com>\n \n \t* include/Makefile.am (ext_headers): Add\n \t${ext_srcdir}/bitmap_allocator.h .\n \t* include/Makefile.in: Regenerate.\n \t* docs/html/ext/ballocator_doc.txt: New file.\n \t* include/ext/bitmap_allocator.h: New file.\n-\t* testsuite/performance/20_util/allocator/list_sort_search.cc: New test.\n+\t* testsuite/performance/20_util/allocator/list_sort_search.cc: Add \n+\ttest.\n \t* testsuite/performance/20_util/allocator/map_mt_find.cc: Likewise.\n \t* testsuite/performance/20_util/allocator/producer_consumer.cc: Add\n \ttest for the bitmap_allocator<>."}, {"sha": "7204d84174503bb0357a143ee6475d983b881d42", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 154, "deletions": 163, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7df2fd97cdce076ee05152bfd65839f7f8306c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7df2fd97cdce076ee05152bfd65839f7f8306c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=ce7df2fd97cdce076ee05152bfd65839f7f8306c", "patch": "@@ -216,10 +216,10 @@ namespace __gnu_cxx\n \n       static void \n       _S_destroy_thread_key(void* freelist_pos);\n+#endif\n \n       static size_t \n       _S_get_thread_id();\n-#endif\n \n       struct block_record\n       {\n@@ -293,18 +293,14 @@ namespace __gnu_cxx\n \t}\n       \n       // Round up to power of 2 and figure out which bin to use.\n-      size_t bin = _S_binmap[__bytes];\n-      \n-#ifdef __GTHREADS\n-      size_t thread_id = _S_get_thread_id();\n-#else\n-      size_t thread_id = 0;\n-#endif\n+      const size_t __which = _S_binmap[__bytes];      \n+      const size_t __thread_id = _S_get_thread_id();\n       \n       // Find out if we have blocks on our freelist.  If so, go ahead\n       // and use them directly without having to lock anything.\n+      const bin_record& __bin = _S_bin[__which];\n       block_record* block = NULL;\n-      if (_S_bin[bin].first[thread_id] == NULL)\n+      if (__bin.first[__thread_id] == NULL)\n \t{\n \t  // Are we using threads?\n \t  // - Yes, check if there are free blocks on the global\n@@ -319,224 +315,211 @@ namespace __gnu_cxx\n #ifdef __GTHREADS\n \t  if (__gthread_active_p())\n \t    {\n-\t      size_t bin_t = 1 << bin;\n-\t      size_t block_count =\n-\t\t_S_options._M_chunk_size /(bin_t + sizeof(block_record));\n+\t      const size_t bin_size = (1 << __which) + sizeof(block_record);\n+\t      size_t block_count = _S_options._M_chunk_size / bin_size;\n \t      \n-\t      __gthread_mutex_lock(_S_bin[bin].mutex);\n-\t      \n-\t      if (_S_bin[bin].first[0] == NULL)\n+\t      __gthread_mutex_lock(__bin.mutex);\t      \n+\t      if (__bin.first[0] == NULL)\n \t\t{\n \t\t  // No need to hold the lock when we are adding a\n \t\t  // whole chunk to our own list.\n-\t\t  __gthread_mutex_unlock(_S_bin[bin].mutex);\n-\t\t  \n-\t\t  _S_bin[bin].first[thread_id] =\n-\t\t    static_cast<block_record*>(::operator new(_S_options._M_chunk_size));\n-\t\t  \n-\t\t  if (!_S_bin[bin].first[thread_id])\n-\t\t    std::__throw_bad_alloc();\n+\t\t  __gthread_mutex_unlock(__bin.mutex);\n \t\t  \n-\t\t  _S_bin[bin].free[thread_id] = block_count;\n+\t\t  void* v = ::operator new(_S_options._M_chunk_size);\n+\t\t  __bin.first[__thread_id] = static_cast<block_record*>(v);\n \t\t  \n+\t\t  __bin.free[__thread_id] = block_count;\t\t  \n \t\t  block_count--;\n-\t\t  block = _S_bin[bin].first[thread_id];\n+\t\t  block = __bin.first[__thread_id];\n \t\t  \n \t\t  while (block_count > 0)\n \t\t    {\n-\t\t      block->next = (block_record*)((char*)block +\n-\t\t\t\t\t\t    (bin_t + sizeof(block_record)));\n-\t\t      block->thread_id = thread_id;\n+\t\t      char* c = reinterpret_cast<char*>(block) + bin_size;\n+\t\t      block->next = reinterpret_cast<block_record*>(c);\n+\t\t      block->thread_id = __thread_id;\n \t\t      block = block->next;\n \t\t      block_count--;\n \t\t    }\n \t\t  \n \t\t  block->next = NULL;\n-\t\t  block->thread_id = thread_id;\n+\t\t  block->thread_id = __thread_id;\n \t\t}\n \t      else\n \t\t{\n \t\t  size_t global_count = 0;\t\t  \n \t\t  block_record* tmp;\t\t  \n-\t\t  while (_S_bin[bin].first[0] != NULL \n-\t\t\t && global_count < block_count)\n+\t\t  while (__bin.first[0] != NULL && global_count < block_count)\n \t\t    {\n-\t\t      tmp = _S_bin[bin].first[0]->next;\n-\t\t      block = _S_bin[bin].first[0];\n+\t\t      tmp = __bin.first[0]->next;\n+\t\t      block = __bin.first[0];\n \n-\t\t      if (_S_bin[bin].first[thread_id] == NULL)\n+\t\t      if (__bin.first[__thread_id] == NULL)\n \t\t\t{\n-\t\t\t  _S_bin[bin].first[thread_id] = block;\n+\t\t\t  __bin.first[__thread_id] = block;\n \t\t\t  block->next = NULL;\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  block->next = _S_bin[bin].first[thread_id];\n-\t\t\t  _S_bin[bin].first[thread_id] = block;\n+\t\t\t  block->next = __bin.first[__thread_id];\n+\t\t\t  __bin.first[__thread_id] = block;\n \t\t\t}\n \t\t      \n-\t\t      block->thread_id = thread_id;\n-\t\t      _S_bin[bin].free[thread_id]++;\n-\t\t      _S_bin[bin].first[0] = tmp;\n+\t\t      block->thread_id = __thread_id;\n+\t\t      __bin.free[__thread_id]++;\n+\t\t      __bin.first[0] = tmp;\n \t\t      global_count++;\n \t\t    }\n-\t\t  __gthread_mutex_unlock(_S_bin[bin].mutex);\n+\t\t  __gthread_mutex_unlock(__bin.mutex);\n \t\t}\n \t      \n \t      // Return the first newly added block in our list and\n \t      // update the counters\n-\t      block = _S_bin[bin].first[thread_id];\n-\t      _S_bin[bin].first[thread_id] = \n-\t\t_S_bin[bin].first[thread_id]->next;\t      \n-\t      _S_bin[bin].free[thread_id]--;\n-\t      _S_bin[bin].used[thread_id]++;\n+\t      block = __bin.first[__thread_id];\n+\t      __bin.first[__thread_id] = __bin.first[__thread_id]->next; \n+\t      __bin.free[__thread_id]--;\n+\t      __bin.used[__thread_id]++;\n \t    }\n \t  else\n #endif\n \t    {\n-\t      _S_bin[bin].first[0] = \n-\t\tstatic_cast<block_record*>(::operator new(_S_options._M_chunk_size));\n+\t      void* __v = ::operator new(_S_options._M_chunk_size);\n+\t      __bin.first[0] = static_cast<block_record*>(__v);\n \t      \n-\t      size_t bin_t = 1 << bin;\n-\t      size_t block_count = \n-\t\t_S_options._M_chunk_size / (bin_t + sizeof(block_record));\n+\t      const size_t bin_size = (1 << __which) + sizeof(block_record);\n+\t      size_t block_count = _S_options._M_chunk_size / bin_size;\n \t      \n \t      block_count--;\n-\t      block = _S_bin[bin].first[0];\t      \n+\t      block = __bin.first[0];\n \t      while (block_count > 0)\n \t\t{\n-\t\t  block->next = (block_record*)((char*)block +\n-\t\t\t\t\t\t(bin_t + sizeof(block_record)));\n+\t\t  char* __c = reinterpret_cast<char*>(block) + bin_size;\n+\t\t  block->next = reinterpret_cast<block_record*>(__c);\n \t\t  block = block->next;\n \t\t  block_count--;\n \t\t}\n \t      block->next = NULL;\n-\t      block = _S_bin[bin].first[0];\n \t      \n \t      // Remove from list.\n-\t      _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n+\t      block = __bin.first[0];\n+\t      __bin.first[0] = __bin.first[0]->next;\n \t    }\n \t}\n       else\n \t{\n-\t  // \"Default\" operation - we have blocks on our own\n-\t  // freelist grab the first record and update the counters.\n-\t  block = _S_bin[bin].first[thread_id];\n-\t  \n-\t  _S_bin[bin].first[thread_id] = _S_bin[bin].first[thread_id]->next;\n-\t  \n+\t  // \"Default\" operation - we have blocks on our own freelist\n+\t  // grab the first record and update the counters.\n+\t  block = __bin.first[__thread_id];\t  \n+\t  __bin.first[__thread_id] = __bin.first[__thread_id]->next;\n+\n #ifdef __GTHREADS\n \t  if (__gthread_active_p())\n \t    {\n-\t      _S_bin[bin].free[thread_id]--;\n-\t      _S_bin[bin].used[thread_id]++;\n+\t      __bin.free[__thread_id]--;\n+\t      __bin.used[__thread_id]++;\n \t    }\n #endif\n \t}\n-      return static_cast<_Tp*>(static_cast<void*>((char*)block + \n-\t\t\t\t\t\t  sizeof(block_record)));\n+      char* __c = reinterpret_cast<char*>(block) + sizeof(block_record);\n+      return static_cast<_Tp*>(static_cast<void*>(__c));\n     }\n   \n+\n   template<typename _Tp>\n     void\n     __mt_alloc<_Tp>::\n     deallocate(pointer __p, size_type __n)\n     {\n       // Requests larger than _M_max_bytes are handled by operators\n       // new/delete directly.\n-      if (__n * sizeof(_Tp) > _S_options._M_max_bytes \n-\t  || _S_options._M_force_new)\n+      const size_t __bytes = __n * sizeof(_Tp);\n+      if (__bytes > _S_options._M_max_bytes || _S_options._M_force_new)\n \t{\n \t  ::operator delete(__p);\n \t  return;\n \t}\n       \n       // Round up to power of 2 and figure out which bin to use.\n-      size_t bin = _S_binmap[__n * sizeof(_Tp)];\n-      \n-#ifdef __GTHREADS\n-      size_t thread_id = _S_get_thread_id();\n-#else\n-      size_t thread_id = 0;\n-#endif\n-      \n-      block_record* block = (block_record*)((char*)__p\n-\t\t\t\t\t    - sizeof(block_record));\n+      const size_t __which = _S_binmap[__bytes];\n+      const size_t thread_id = _S_get_thread_id();\n+      const bin_record& __bin = _S_bin[__which];\n+\n+      char* __c = reinterpret_cast<char*>(__p) - sizeof(block_record);\n+      block_record* block = reinterpret_cast<block_record*>(__c);\n       \n #ifdef __GTHREADS\n       if (__gthread_active_p())\n \t{\n \t  // Calculate the number of records to remove from our freelist.\n-\t  int remove = _S_bin[bin].free[thread_id] -\n-\t    (_S_bin[bin].used[thread_id] / _S_options._M_freelist_headroom);\n+\t  int remove = __bin.free[thread_id] -\n+\t    (__bin.used[thread_id] / _S_options._M_freelist_headroom);\n \n \t  // The calculation above will almost always tell us to\n \t  // remove one or two records at a time, but this creates too\n \t  // much contention when locking and therefore we wait until\n \t  // the number of records is \"high enough\".\n-\t  if (remove > (int)(100 * (_S_bin_size - bin)) &&\n-\t      remove > (int)(_S_bin[bin].free[thread_id] /\n-                               _S_options._M_freelist_headroom))\n+\t  int __cond1 = static_cast<int>(100 * (_S_bin_size - __which));\n+\t  int __cond2 = static_cast<int>(__bin.free[thread_id] / _S_options._M_freelist_headroom);\n+\t  if (remove > __cond1 && remove > __cond2)\n \t    {\n-\t      __gthread_mutex_lock(_S_bin[bin].mutex);\n+\t      __gthread_mutex_lock(__bin.mutex);\n \t      block_record* tmp;\n \t      while (remove > 0)\n \t\t{\n-\t\t  tmp = _S_bin[bin].first[thread_id]->next;\n-\t\t  if (_S_bin[bin].first[0] == NULL)\n+\t\t  tmp = __bin.first[thread_id]->next;\n+\t\t  if (__bin.first[0] == NULL)\n \t\t    {\n-\t\t      _S_bin[bin].first[0] = _S_bin[bin].first[thread_id];\n-\t\t      _S_bin[bin].first[0]->next = NULL;\n+\t\t      __bin.first[0] = __bin.first[thread_id];\n+\t\t      __bin.first[0]->next = NULL;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      _S_bin[bin].first[thread_id]->next = _S_bin[bin].first[0];\n-\t\t      _S_bin[bin].first[0] = _S_bin[bin].first[thread_id];\n+\t\t      __bin.first[thread_id]->next = __bin.first[0];\n+\t\t      __bin.first[0] = __bin.first[thread_id];\n \t\t    }\n \t\t  \n-\t\t  _S_bin[bin].first[thread_id] = tmp;\n-\t\t  _S_bin[bin].free[thread_id]--;\n+\t\t  __bin.first[thread_id] = tmp;\n+\t\t  __bin.free[thread_id]--;\n \t\t  remove--;\n \t\t}\n-\t      __gthread_mutex_unlock(_S_bin[bin].mutex);\n+\t      __gthread_mutex_unlock(__bin.mutex);\n \t    }\n \t  \n \t  // Return this block to our list and update counters and\n \t  // owner id as needed.\n-\t  if (_S_bin[bin].first[thread_id] == NULL)\n+\t  if (__bin.first[thread_id] == NULL)\n \t    {\n-\t      _S_bin[bin].first[thread_id] = block;\n+\t      __bin.first[thread_id] = block;\n \t      block->next = NULL;\n \t    }\n \t  else\n \t    {\n-\t      block->next = _S_bin[bin].first[thread_id];\n-\t      _S_bin[bin].first[thread_id] = block;\n+\t      block->next = __bin.first[thread_id];\n+\t      __bin.first[thread_id] = block;\n \t    }\n \t  \n-\t  _S_bin[bin].free[thread_id]++;\n+\t  __bin.free[thread_id]++;\n \t  \n \t  if (thread_id == block->thread_id)\n-\t    _S_bin[bin].used[thread_id]--;\n+\t    __bin.used[thread_id]--;\n \t  else\n \t    {\n-\t      _S_bin[bin].used[block->thread_id]--;\n+\t      __bin.used[block->thread_id]--;\n \t      block->thread_id = thread_id;\n \t    }\n \t}\n       else\n #endif\n \t{\n \t  // Single threaded application - return to global pool.\n-\t  if (_S_bin[bin].first[0] == NULL)\n+\t  if (__bin.first[0] == NULL)\n \t    {\n-\t      _S_bin[bin].first[0] = block;\n+\t      __bin.first[0] = block;\n \t      block->next = NULL;\n \t    }\n \t  else\n \t    {\n-\t      block->next = _S_bin[bin].first[0];\n-\t      _S_bin[bin].first[0] = block;\n+\t      block->next = __bin.first[0];\n+\t      __bin.first[0] = block;\n \t    }\n \t}\n     }\n@@ -551,52 +534,54 @@ namespace __gnu_cxx\n \n       // Calculate the number of bins required based on _M_max_bytes.\n       // _S_bin_size is statically-initialized to one.\n-      size_t bin_size = 1;\n-      while (_S_options._M_max_bytes > bin_size)\n+      size_t __bin_size = 1;\n+      while (_S_options._M_max_bytes > __bin_size)\n \t{\n-\t  bin_size = bin_size << 1;\n+\t  __bin_size = __bin_size << 1;\n \t  _S_bin_size++;\n \t}\n \n       // Setup the bin map for quick lookup of the relevant bin.\n-      const size_t n1 = (_S_options._M_max_bytes + 1) * sizeof(binmap_type);\n-      _S_binmap = static_cast<binmap_type*>(::operator new(n1));\n+      const size_t __j = (_S_options._M_max_bytes + 1) * sizeof(binmap_type);\n+      _S_binmap = static_cast<binmap_type*>(::operator new(__j));\n \n-      binmap_type* bp_t = _S_binmap;\n-      binmap_type bin_max_t = 1;\n-      binmap_type bin_t = 0;\n-      for (binmap_type ct = 0; ct <= _S_options._M_max_bytes; ct++)\n+      binmap_type* __bp = _S_binmap;\n+      binmap_type __bin_max = 1;\n+      binmap_type __bint = 0;\n+      for (binmap_type __ct = 0; __ct <= _S_options._M_max_bytes; __ct++)\n         {\n-          if (ct > bin_max_t)\n+          if (__ct > __bin_max)\n             {\n-              bin_max_t <<= 1;\n-              bin_t++;\n+              __bin_max <<= 1;\n+              __bint++;\n             }\n-          *bp_t++ = bin_t;\n+          *__bp++ = __bint;\n         }\n \n       // If __gthread_active_p() create and initialize the list of\n       // free thread ids. Single threaded applications use thread id 0\n       // directly and have no need for this.\n+      void* __v;\n #ifdef __GTHREADS\n       if (__gthread_active_p())\n         {\n-\t  const size_t n2 = sizeof(thread_record) * _S_options._M_max_threads;\n-          _S_thread_freelist_first = static_cast<thread_record*>(::operator new(n2));\n+\t  const size_t __k = sizeof(thread_record) * _S_options._M_max_threads;\n+\t  __v = ::operator new(__k);\n+          _S_thread_freelist_first = static_cast<thread_record*>(__v);\n \n \t  // NOTE! The first assignable thread id is 1 since the\n \t  // global pool uses id 0\n-          size_t i;\n-          for (i = 1; i < _S_options._M_max_threads; i++)\n+          size_t __i;\n+          for (__i = 1; __i < _S_options._M_max_threads; __i++)\n             {\n-\t      thread_record& tr = _S_thread_freelist_first[i - 1];\n-              tr.next = &_S_thread_freelist_first[i];\n-              tr.id = i;\n+\t      thread_record& __tr = _S_thread_freelist_first[__i - 1];\n+              __tr.next = &_S_thread_freelist_first[__i];\n+              __tr.id = __i;\n             }\n \n           // Set last record.\n-          _S_thread_freelist_first[i - 1].next = NULL;\n-          _S_thread_freelist_first[i - 1].id = i;\n+          _S_thread_freelist_first[__i - 1].next = NULL;\n+          _S_thread_freelist_first[__i - 1].id = __i;\n \n \n \t  // Make sure this is initialized.\n@@ -610,102 +595,108 @@ namespace __gnu_cxx\n #endif\n \n       // Initialize _S_bin and its members.\n-      _S_bin = static_cast<bin_record*>(::operator \n-\t\t\t\t\tnew(sizeof(bin_record) * _S_bin_size));\n-\n+      __v = ::operator new(sizeof(bin_record) * _S_bin_size);\n+      _S_bin = static_cast<bin_record*>(__v);\n+\t\n       // Maximum number of threads. \n-      size_t __n = 1;\n+      size_t __max_threads = 1;\n #ifdef __GTHREADS\n       if (__gthread_active_p())\n-        __n = _S_options._M_max_threads + 1;\n+        __max_threads = _S_options._M_max_threads + 1;\n #endif\n \n-      for (size_t bin = 0; bin < _S_bin_size; bin++)\n+      for (size_t __n = 0; __n < _S_bin_size; __n++)\n         {\n-\t  bin_record& br = _S_bin[bin];\n-          br.first = static_cast<block_record**>(::operator new(sizeof(block_record*) * __n));\n+\t  bin_record& __bin = _S_bin[__n];\n+\t  __v = ::operator new(sizeof(block_record*) * __max_threads);\n+          __bin.first = static_cast<block_record**>(__v);\n \n #ifdef __GTHREADS\n           if (__gthread_active_p())\n             {\n-              br.free = static_cast<size_t*>(::operator new(sizeof(size_t) \n-\t\t\t\t\t\t\t    * __n));\n-              br.used = static_cast<size_t*>(::operator new(sizeof(size_t) \n-\t\t\t\t\t\t\t    * __n));\n-              br.mutex = static_cast<__gthread_mutex_t*>(::operator new(sizeof(__gthread_mutex_t)));\n+\t      __v = ::operator new(sizeof(size_t) * __max_threads);\n+              __bin.free = static_cast<size_t*>(__v);\n+\n+\t      __v = ::operator new(sizeof(size_t) * __max_threads);\n+              __bin.used = static_cast<size_t*>(__v);\n+\n+\t      __v = ::operator new(sizeof(__gthread_mutex_t));\n+              __bin.mutex = static_cast<__gthread_mutex_t*>(__v);\n \n #ifdef __GTHREAD_MUTEX_INIT\n               {\n                 // Do not copy a POSIX/gthr mutex once in use.\n                 __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-                *br.mutex = __tmp;\n+                *__bin.mutex = __tmp;\n               }\n #else\n-              { __GTHREAD_MUTEX_INIT_FUNCTION(br.mutex); }\n+              { __GTHREAD_MUTEX_INIT_FUNCTION(__bin.mutex); }\n #endif\n             }\n #endif\n \n-          for (size_t thread = 0; thread < __n; thread++)\n+          for (size_t __threadn = 0; __threadn < __max_threads; __threadn++)\n             {\n-              br.first[thread] = NULL;\n+              __bin.first[__threadn] = NULL;\n #ifdef __GTHREADS\n               if (__gthread_active_p())\n                 {\n-                  br.free[thread] = 0;\n-                  br.used[thread] = 0;\n+                  __bin.free[__threadn] = 0;\n+                  __bin.used[__threadn] = 0;\n                 }\n #endif\n             }\n         }\n       _S_init = true;\n     }\n \n-#ifdef __GTHREADS\n-  template<typename _Tp>\n-    void\n-    __mt_alloc<_Tp>::\n-    _S_destroy_thread_key(void* freelist_pos)\n-    {\n-      // Return this thread id record to front of thread_freelist.\n-      __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-      ((thread_record*)freelist_pos)->next = _S_thread_freelist_first;\n-      _S_thread_freelist_first = (thread_record*)freelist_pos;\n-      __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n-    }\n-\n   template<typename _Tp>\n     size_t\n     __mt_alloc<_Tp>::\n     _S_get_thread_id()\n     {\n+#ifdef __GTHREADS\n       // If we have thread support and it's active we check the thread\n       // key value and return it's id or if it's not set we take the\n       // first record from _S_thread_freelist and sets the key and\n       // returns it's id.\n       if (__gthread_active_p())\n         {\n-          thread_record* freelist_pos = static_cast<thread_record*>(__gthread_getspecific(_S_thread_key)); \n-\t  if (freelist_pos == NULL)\n+          thread_record* __freelist_pos = static_cast<thread_record*>(__gthread_getspecific(_S_thread_key)); \n+\t  if (__freelist_pos == NULL)\n             {\n \t      // Since _S_options._M_max_threads must be larger than\n \t      // the theoretical max number of threads of the OS the\n \t      // list can never be empty.\n               __gthread_mutex_lock(&_S_thread_freelist_mutex);\n-              freelist_pos = _S_thread_freelist_first;\n+              __freelist_pos = _S_thread_freelist_first;\n               _S_thread_freelist_first = _S_thread_freelist_first->next;\n               __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n \n               __gthread_setspecific(_S_thread_key, \n-\t\t\t\t    static_cast<void*>(freelist_pos));\n+\t\t\t\t    static_cast<void*>(__freelist_pos));\n             }\n-          return freelist_pos->id;\n+          return __freelist_pos->id;\n         }\n-\n+#endif\n       // Otherwise (no thread support or inactive) all requests are\n       // served from the global pool 0.\n       return 0;\n     }\n+\n+#ifdef __GTHREADS\n+  template<typename _Tp>\n+    void\n+    __mt_alloc<_Tp>::\n+    _S_destroy_thread_key(void* __freelist_pos)\n+    {\n+      // Return this thread id record to front of thread_freelist.\n+      __gthread_mutex_lock(&_S_thread_freelist_mutex);\n+      thread_record* __tr = static_cast<thread_record*>(__freelist_pos);\n+      __tr->next = _S_thread_freelist_first;\n+      _S_thread_freelist_first = __tr;\n+      __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n+    }\n #endif\n \n   template<typename _Tp>"}, {"sha": "cb8a2f5c4bf81c630a8dbcc583388341cc2f7a90", "filename": "libstdc++-v3/testsuite/20_util/allocator/14176.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7df2fd97cdce076ee05152bfd65839f7f8306c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F14176.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7df2fd97cdce076ee05152bfd65839f7f8306c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F14176.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator%2F14176.cc?ref=ce7df2fd97cdce076ee05152bfd65839f7f8306c", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/14176\n+void test02()\n+{\n+  unsigned int len = 0;  \n+  std::allocator<int> a;\n+  int* p = a.allocate(len);\n+  a.deallocate(p, len);\n+}\n+\n+#if !__GXX_WEAK__ && _MT_ALLOCATOR_H\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template class __gnu_cxx::__mt_alloc<int>;\n+#endif\n+\n+int main()\n+{\n+  test02();\n+  return 0;\n+}"}]}