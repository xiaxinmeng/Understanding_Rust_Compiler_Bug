{"sha": "911b3fdbe38f8a259a8212773098bf201423a242", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTExYjNmZGJlMzhmOGEyNTlhODIxMjc3MzA5OGJmMjAxNDIzYTI0Mg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-11-12T20:05:49Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-11-12T20:05:49Z"}, "message": "tree-ssa-loop-prefetch.c (schedule_prefetches): Cleanup and improve comments.\n\n\t* tree-ssa-loop-prefetch.c (schedule_prefetches): Cleanup and improve\n\tcomments.\n\t(issue_prefetch_ref): Move assignment to write_p out of loop.\n\t(determine_unroll_factor): Do not take PARAM_MAX_UNROLL_TIMES and\n\tSIMULTANEOUS_PREFETCHES into account.\n\t(loop_prefetch_arrays): Do not pass ahead to determine_unroll_factor.\n\t* lambda-code.c (lcm): Renamed to ...\n\t(least_common_multiple): ... and exported.\n\t* tree-flow.h (least_common_multiple): Declare.\n\nFrom-SVN: r118730", "tree": {"sha": "872aef0e893c395cc6fdd9d9fe625854bf2281f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/872aef0e893c395cc6fdd9d9fe625854bf2281f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/911b3fdbe38f8a259a8212773098bf201423a242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911b3fdbe38f8a259a8212773098bf201423a242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/911b3fdbe38f8a259a8212773098bf201423a242", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911b3fdbe38f8a259a8212773098bf201423a242/comments", "author": null, "committer": null, "parents": [{"sha": "946e1bc7575f0676faf87b8f9937e3a2a8b828af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946e1bc7575f0676faf87b8f9937e3a2a8b828af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/946e1bc7575f0676faf87b8f9937e3a2a8b828af"}], "stats": {"total": 150, "additions": 94, "deletions": 56}, "files": [{"sha": "e29ed31ff01406e78b8b548bfa58077d2b2fcf78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=911b3fdbe38f8a259a8212773098bf201423a242", "patch": "@@ -1,3 +1,15 @@\n+2006-11-12  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-prefetch.c (schedule_prefetches): Cleanup and improve\n+\tcomments.\n+\t(issue_prefetch_ref): Move assignment to write_p out of loop.\n+\t(determine_unroll_factor): Do not take PARAM_MAX_UNROLL_TIMES and\n+\tSIMULTANEOUS_PREFETCHES into account.\n+\t(loop_prefetch_arrays): Do not pass ahead to determine_unroll_factor.\n+\t* lambda-code.c (lcm): Renamed to ...\n+\t(least_common_multiple): ... and exported.\n+\t* tree-flow.h (least_common_multiple): Declare.\n+\n 2006-11-12  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* Makefile.in (tree-data-ref.o): Add langhooks.h dependency."}, {"sha": "3dfad91720f183f977836eae9a1a4b6ca21b134a", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=911b3fdbe38f8a259a8212773098bf201423a242", "patch": "@@ -442,8 +442,8 @@ lambda_lattice_compute_base (lambda_loopnest nest)\n \n /* Compute the least common multiple of two numbers A and B .  */\n \n-static int\n-lcm (int a, int b)\n+int\n+least_common_multiple (int a, int b)\n {\n   return (abs (a) * abs (b) / gcd (a, b));\n }\n@@ -577,7 +577,7 @@ compute_nest_using_fourier_motzkin (int size,\n \t\t{\n \t\t  if (A[k][i] < 0)\n \t\t    {\n-\t\t      multiple = lcm (A[j][i], A[k][i]);\n+\t\t      multiple = least_common_multiple (A[j][i], A[k][i]);\n \t\t      f1 = multiple / A[j][i];\n \t\t      f2 = -1 * multiple / A[k][i];\n "}, {"sha": "71597e25d1c44d8af43daeecfc6ebdc386e47dd2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=911b3fdbe38f8a259a8212773098bf201423a242", "patch": "@@ -1,3 +1,7 @@\n+2006-11-12  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/prefetch-3.c: New test.\n+\n 2006-11-12  Roger Sayle  <roger@eyesopen.com>\n \n \tPR tree-optimization/13827"}, {"sha": "c5767a704b37d315894f57ddcb472b9964ab7272", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-3.c?ref=911b3fdbe38f8a259a8212773098bf201423a242", "patch": "@@ -0,0 +1,22 @@\n+/* Prefetching used to prefer nonsensical unroll factor of 5 in this testcase.  */\n+\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse -fdump-tree-aprefetch-details\" } */\n+\n+#define N 1000000\n+\n+double a[N];\n+\n+double test(void)\n+{\n+  unsigned i;\n+  double sum = 0;\n+\n+  for (i = 0; i < N; i += 2)\n+    sum += (a[i] * a[i+1]);\n+\n+  return sum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unroll factor 4\" 1 \"aprefetch\" } } */\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "a880c3299e3cdfea217349619e8c617eadf34fcc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=911b3fdbe38f8a259a8212773098bf201423a242", "patch": "@@ -1036,4 +1036,7 @@ void swap_tree_operands (tree, tree *, tree *);\n \n extern void recalculate_used_alone (void);\n extern bool updating_used_alone;\n+\n+int least_common_multiple (int, int);\n+\n #endif /* _TREE_FLOW_H  */"}, {"sha": "b40fc0f6617887ed6d272c9d45e5cff578af0c0b", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/911b3fdbe38f8a259a8212773098bf201423a242/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=911b3fdbe38f8a259a8212773098bf201423a242", "patch": "@@ -744,19 +744,21 @@ static bool\n schedule_prefetches (struct mem_ref_group *groups, unsigned unroll_factor,\n \t\t     unsigned ahead)\n {\n-  unsigned max_prefetches, n_prefetches;\n+  unsigned remaining_prefetch_slots, n_prefetches, prefetch_slots;\n+  unsigned slots_per_prefetch;\n   struct mem_ref *ref;\n   bool any = false;\n \n-  max_prefetches = (SIMULTANEOUS_PREFETCHES * unroll_factor) / ahead;\n-  if (max_prefetches > (unsigned) SIMULTANEOUS_PREFETCHES)\n-    max_prefetches = SIMULTANEOUS_PREFETCHES;\n+  /* At most SIMULTANEOUS_PREFETCHES should be running at the same time.  */\n+  remaining_prefetch_slots = SIMULTANEOUS_PREFETCHES;\n \n+  /* The prefetch will run for AHEAD iterations of the original loop, i.e.,\n+     AHEAD / UNROLL_FACTOR iterations of the unrolled loop.  In each iteration,\n+     it will need a prefetch slot.  */\n+  slots_per_prefetch = (ahead + unroll_factor / 2) / unroll_factor;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Max prefetches to issue: %d.\\n\", max_prefetches);\n-\n-  if (!max_prefetches)\n-    return false;\n+    fprintf (dump_file, \"Each prefetch instruction takes %u prefetch slots.\\n\",\n+\t     slots_per_prefetch);\n \n   /* For now we just take memory references one by one and issue\n      prefetches for as many as possible.  The groups are sorted\n@@ -769,16 +771,24 @@ schedule_prefetches (struct mem_ref_group *groups, unsigned unroll_factor,\n \tif (!should_issue_prefetch_p (ref))\n \t  continue;\n \n-\tref->issue_prefetch_p = true;\n-\n-\t/* If prefetch_mod is less then unroll_factor, we need to insert\n-\t   several prefetches for the reference.  */\n+\t/* If we need to prefetch the reference each PREFETCH_MOD iterations,\n+\t   and we unroll the loop UNROLL_FACTOR times, we need to insert\n+\t   ceil (UNROLL_FACTOR / PREFETCH_MOD) instructions in each\n+\t   iteration.  */\n \tn_prefetches = ((unroll_factor + ref->prefetch_mod - 1)\n \t\t\t/ ref->prefetch_mod);\n-\tif (max_prefetches <= n_prefetches)\n-\t  return true;\n+\tprefetch_slots = n_prefetches * slots_per_prefetch;\n+\n+\t/* If more than half of the prefetches would be lost anyway, do not\n+\t   issue the prefetch.  */\n+\tif (2 * remaining_prefetch_slots < prefetch_slots)\n+\t  continue;\n+\n+\tref->issue_prefetch_p = true;\n \n-\tmax_prefetches -= n_prefetches;\n+\tif (remaining_prefetch_slots <= prefetch_slots)\n+\t  return true;\n+\tremaining_prefetch_slots -= prefetch_slots;\n \tany = true;\n       }\n \n@@ -822,6 +832,7 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n \t\t  / ref->prefetch_mod);\n   addr_base = build_fold_addr_expr_with_type (ref->mem, ptr_type_node);\n   addr_base = force_gimple_operand_bsi (&bsi, unshare_expr (addr_base), true, NULL);\n+  write_p = ref->write_p ? integer_one_node : integer_zero_node;\n \n   for (ap = 0; ap < n_prefetches; ap++)\n     {\n@@ -832,10 +843,9 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n       addr = force_gimple_operand_bsi (&bsi, unshare_expr (addr), true, NULL);\n \n       /* Create the prefetch instruction.  */\n-      write_p = ref->write_p ? integer_one_node : integer_zero_node;\n       params = tree_cons (NULL_TREE, addr,\n \t\t\t  tree_cons (NULL_TREE, write_p, NULL_TREE));\n-\t\t\t\t \n+\n       prefetch = build_function_call_expr (built_in_decls[BUILT_IN_PREFETCH],\n \t\t\t\t\t   params);\n       bsi_insert_before (&bsi, prefetch, BSI_SAME_STMT);\n@@ -888,48 +898,36 @@ should_unroll_loop_p (struct loop *loop, struct tree_niter_desc *desc,\n \n static unsigned\n determine_unroll_factor (struct loop *loop, struct mem_ref_group *refs,\n-\t\t\t unsigned ahead, unsigned ninsns,\n-\t\t\t struct tree_niter_desc *desc)\n+\t\t\t unsigned ninsns, struct tree_niter_desc *desc)\n {\n-  unsigned upper_bound, size_factor, constraint_factor;\n-  unsigned factor, max_mod_constraint, ahead_factor;\n+  unsigned upper_bound;\n+  unsigned nfactor, factor, mod_constraint;\n   struct mem_ref_group *agp;\n   struct mem_ref *ref;\n \n-  upper_bound = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n-\n-  /* First check whether the loop is not too large to unroll.  */\n-  size_factor = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / ninsns;\n-  if (size_factor <= 1)\n+  /* First check whether the loop is not too large to unroll.  We ignore\n+     PARAM_MAX_UNROLL_TIMES, because for small loops, it prevented us\n+     from unrolling them enough to make exactly one cache line covered by each\n+     iteration.  Also, the goal of PARAM_MAX_UNROLL_TIMES is to prevent\n+     us from unrolling the loops too many times in cases where we only expect\n+     gains from better scheduling and decreasing loop overhead, which is not\n+     the case here.  */\n+  upper_bound = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / ninsns;\n+  if (upper_bound <= 1)\n     return 1;\n \n-  if (size_factor < upper_bound)\n-    upper_bound = size_factor;\n-\n-  max_mod_constraint = 1;\n+  /* Choose the factor so that we may prefetch each cache just once,\n+     but bound the unrolling by UPPER_BOUND.  */\n+  factor = 1;\n   for (agp = refs; agp; agp = agp->next)\n     for (ref = agp->refs; ref; ref = ref->next)\n-      if (should_issue_prefetch_p (ref)\n-\t  && ref->prefetch_mod > max_mod_constraint)\n-\tmax_mod_constraint = ref->prefetch_mod;\n-\n-  /* Set constraint_factor as large as needed to be able to satisfy the\n-     largest modulo constraint.  */\n-  constraint_factor = max_mod_constraint;\n-\n-  /* If ahead is too large in comparison with the number of available\n-     prefetches, unroll the loop as much as needed to be able to prefetch\n-     at least partially some of the references in the loop.  */\n-  ahead_factor = ((ahead + SIMULTANEOUS_PREFETCHES - 1)\n-\t\t  / SIMULTANEOUS_PREFETCHES);\n-\n-  /* Unroll as much as useful, but bound the code size growth.  */\n-  if (constraint_factor < ahead_factor)\n-    factor = ahead_factor;\n-  else\n-    factor = constraint_factor;\n-  if (factor > upper_bound)\n-    factor = upper_bound;\n+      if (should_issue_prefetch_p (ref))\n+\t{\n+\t  mod_constraint = ref->prefetch_mod;\n+\t  nfactor = least_common_multiple (mod_constraint, factor);\n+\t  if (nfactor <= upper_bound)\n+\t    factor = nfactor;\n+\t}\n \n   if (!should_unroll_loop_p (loop, desc, factor))\n     return 1;\n@@ -964,8 +962,7 @@ loop_prefetch_arrays (struct loops *loops, struct loop *loop)\n      instructions executed per iteration of the loop.  */\n   ninsns = tree_num_loop_insns (loop);\n   ahead = (PREFETCH_LATENCY + ninsns - 1) / ninsns;\n-  unroll_factor = determine_unroll_factor (loop, refs, ahead, ninsns,\n-\t\t\t\t\t   &desc);\n+  unroll_factor = determine_unroll_factor (loop, refs, ninsns, &desc);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Ahead %d, unroll factor %d\\n\", ahead, unroll_factor);\n "}]}