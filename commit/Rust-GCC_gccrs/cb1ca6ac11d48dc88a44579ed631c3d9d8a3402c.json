{"sha": "cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IxY2E2YWMxMWQ0OGRjODhhNDQ1NzllZDYzMWMzZDlkOGEzNDAyYw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-10-27T16:39:26Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-10-27T16:39:26Z"}, "message": "ira-int.h (ira_allocno): Add member updated_cover_class_cost.\n\n2008-10-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* ira-int.h (ira_allocno): Add member updated_cover_class_cost.\n\t(ALLOCNO_UPDATED_COVER_CLASS_COST): New.\n\t(ira_fast_allocation): Remove the prototype.\n\t\n\t* ira-color.c (update_copy_costs, allocno_cost_compare_func,\n\tassign_hard_reg, calculate_allocno_spill_cost): Use updated costs.\n\t(color_pass): Modify the updated costs.\n\t(ira_color): Rename to color.  Make it static.\n\t(ira_fast_allocation): Rename to fast_allocation.  Make it static.\n\t(ira_color): New function.\n\t\n\t* ira-conflicts.c (process_regs_for_copy): Propagate hard reg cost\n\tchange.\n\n\t* ira-lives.c (last_call_num, allocno_saved_at_call): New\n\tvariables.\n\t(set_allocno_live, clear_allocno_live, mark_ref_live,\n\tmark_ref_dead): Invalidate corresponding element of\n\tallocno_saved_at_call.\n\t(process_bb_node_lives): Increment last_call_num.  Setup\n\tallocno_saved_at_call.  Don't increase ALLOCNO_CALL_FREQ if the\n\tallocno was already saved.\n\t(ira_create_allocno_live_ranges): Initiate last_call_num and\n\tallocno_saved_at_call.\n\n\t* ira-build.c (ira_create_allocno): Initiate\n\tALLOCNO_UPDATED_COVER_CLASS_COST.\n\t(create_cap_allocno, propagate_allocno_info,\n\tremove_unnecessary_allocnos): Remove setting updated costs.\n\t(ira_flattening): Set up ALLOCNO_UPDATED_COVER_CLASS_COST.\n\n\t* ira.c (ira):  Don't call ira_fast_allocation.\n\n\t* ira-costs.c (setup_allocno_cover_class_and_costs): Don't set up\n\tupdated costs.\n\nFrom-SVN: r141385", "tree": {"sha": "2e5a85daedf6bfc58bc769f2372dc729b240724f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e5a85daedf6bfc58bc769f2372dc729b240724f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0683a829001ee2630451cbdbb138fd89cfe0e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0683a829001ee2630451cbdbb138fd89cfe0e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0683a829001ee2630451cbdbb138fd89cfe0e5f"}], "stats": {"total": 194, "additions": 148, "deletions": 46}, "files": [{"sha": "a683eca7e00aeace0d034ec247605c35bd49fbc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -1,3 +1,41 @@\n+2008-10-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* ira-int.h (ira_allocno): Add member updated_cover_class_cost.\n+\t(ALLOCNO_UPDATED_COVER_CLASS_COST): New.\n+\t(ira_fast_allocation): Remove the prototype.\n+\t\n+\t* ira-color.c (update_copy_costs, allocno_cost_compare_func,\n+\tassign_hard_reg, calculate_allocno_spill_cost): Use updated costs.\n+\t(color_pass): Modify the updated costs.\n+\t(ira_color): Rename to color.  Make it static.\n+\t(ira_fast_allocation): Rename to fast_allocation.  Make it static.\n+\t(ira_color): New function.\n+\t\n+\t* ira-conflicts.c (process_regs_for_copy): Propagate hard reg cost\n+\tchange.\n+\n+\t* ira-lives.c (last_call_num, allocno_saved_at_call): New\n+\tvariables.\n+\t(set_allocno_live, clear_allocno_live, mark_ref_live,\n+\tmark_ref_dead): Invalidate corresponding element of\n+\tallocno_saved_at_call.\n+\t(process_bb_node_lives): Increment last_call_num.  Setup\n+\tallocno_saved_at_call.  Don't increase ALLOCNO_CALL_FREQ if the\n+\tallocno was already saved.\n+\t(ira_create_allocno_live_ranges): Initiate last_call_num and\n+\tallocno_saved_at_call.\n+\n+\t* ira-build.c (ira_create_allocno): Initiate\n+\tALLOCNO_UPDATED_COVER_CLASS_COST.\n+\t(create_cap_allocno, propagate_allocno_info,\n+\tremove_unnecessary_allocnos): Remove setting updated costs.\n+\t(ira_flattening): Set up ALLOCNO_UPDATED_COVER_CLASS_COST.\n+\n+\t* ira.c (ira):  Don't call ira_fast_allocation.\n+\n+\t* ira-costs.c (setup_allocno_cover_class_and_costs): Don't set up\n+\tupdated costs.\n+\t\n 2008-10-27  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/37813"}, {"sha": "8e92f8c1b3ef6118c2acf81649c47389aef6dbf5", "filename": "gcc/ira-build.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -469,6 +469,7 @@ ira_create_allocno (int regno, bool cap_p, ira_loop_tree_node_t loop_tree_node)\n   ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) = NULL;\n   ALLOCNO_LEFT_CONFLICTS_NUM (a) = -1;\n   ALLOCNO_COVER_CLASS (a) = NO_REGS;\n+  ALLOCNO_UPDATED_COVER_CLASS_COST (a) = 0;\n   ALLOCNO_COVER_CLASS_COST (a) = 0;\n   ALLOCNO_MEMORY_COST (a) = 0;\n   ALLOCNO_UPDATED_MEMORY_COST (a) = 0;\n@@ -769,7 +770,6 @@ create_cap_allocno (ira_allocno_t a)\n   ALLOCNO_CAP (a) = cap;\n   ALLOCNO_COVER_CLASS_COST (cap) = ALLOCNO_COVER_CLASS_COST (a);\n   ALLOCNO_MEMORY_COST (cap) = ALLOCNO_MEMORY_COST (a);\n-  ALLOCNO_UPDATED_MEMORY_COST (cap) = ALLOCNO_UPDATED_MEMORY_COST (a);\n   ira_allocate_and_copy_costs\n     (&ALLOCNO_HARD_REG_COSTS (cap), cover_class, ALLOCNO_HARD_REG_COSTS (a));\n   ira_allocate_and_copy_costs\n@@ -1509,8 +1509,6 @@ propagate_allocno_info (void)\n \t  ALLOCNO_COVER_CLASS_COST (parent_a)\n \t    += ALLOCNO_COVER_CLASS_COST (a);\n \t  ALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n-\t  ALLOCNO_UPDATED_MEMORY_COST (parent_a)\n-\t    += ALLOCNO_UPDATED_MEMORY_COST (a);\n \t}\n }\n \n@@ -1789,8 +1787,6 @@ remove_unnecessary_allocnos (void)\n \t\tALLOCNO_COVER_CLASS_COST (parent_a)\n \t\t  += ALLOCNO_COVER_CLASS_COST (a);\n \t\tALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n-\t\tALLOCNO_UPDATED_MEMORY_COST (parent_a)\n-\t\t  += ALLOCNO_UPDATED_MEMORY_COST (a);\n \t\tfinish_allocno (a);\n \t      }\n \t  }\n@@ -2353,7 +2349,9 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n       ALLOCNO_LOOP_TREE_NODE (a) = ira_loop_tree_root;\n       ALLOCNO_REGNO (a) = REGNO (ALLOCNO_REG (a));\n       ALLOCNO_CAP (a) = NULL;\n+      /* Restore updated costs for assignments from reload.  */\n       ALLOCNO_UPDATED_MEMORY_COST (a) = ALLOCNO_MEMORY_COST (a);\n+      ALLOCNO_UPDATED_COVER_CLASS_COST (a) = ALLOCNO_COVER_CLASS_COST (a);\n       if (! ALLOCNO_ASSIGNED_P (a))\n \tira_free_allocno_updated_costs (a);\n       ira_assert (ALLOCNO_UPDATED_HARD_REG_COSTS (a) == NULL);"}, {"sha": "7a89c1b62eb67f9316a79efd811f2606f9412e5e", "filename": "gcc/ira-color.c", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -252,7 +252,7 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n \n \t  ira_allocate_and_set_or_copy_costs\n \t    (&ALLOCNO_UPDATED_HARD_REG_COSTS (another_allocno), cover_class,\n-\t     ALLOCNO_COVER_CLASS_COST (another_allocno),\n+\t     ALLOCNO_UPDATED_COVER_CLASS_COST (another_allocno),\n \t     ALLOCNO_HARD_REG_COSTS (another_allocno));\n \t  ira_allocate_and_set_or_copy_costs\n \t    (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (another_allocno),\n@@ -348,8 +348,8 @@ allocno_cost_compare_func (const void *v1p, const void *v2p)\n   ira_allocno_t p2 = *(const ira_allocno_t *) v2p;\n   int c1, c2;\n \n-  c1 = ALLOCNO_UPDATED_MEMORY_COST (p1) - ALLOCNO_COVER_CLASS_COST (p1);\n-  c2 = ALLOCNO_UPDATED_MEMORY_COST (p2) - ALLOCNO_COVER_CLASS_COST (p2);\n+  c1 = ALLOCNO_UPDATED_MEMORY_COST (p1) - ALLOCNO_UPDATED_COVER_CLASS_COST (p1);\n+  c2 = ALLOCNO_UPDATED_MEMORY_COST (p2) - ALLOCNO_UPDATED_COVER_CLASS_COST (p2);\n   if (c1 - c2)\n     return c1 - c2;\n \n@@ -426,7 +426,9 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n #ifdef STACK_REGS\n       no_stack_reg_p = no_stack_reg_p || ALLOCNO_TOTAL_NO_STACK_REG_P (a);\n #endif\n-      for (cost = ALLOCNO_COVER_CLASS_COST (a), i = 0; i < class_size; i++)\n+      for (cost = ALLOCNO_UPDATED_COVER_CLASS_COST (a), i = 0;\n+\t   i < class_size;\n+\t   i++)\n \tif (a_costs != NULL)\n \t  {\n \t    costs[i] += a_costs[i];\n@@ -959,7 +961,7 @@ calculate_allocno_spill_cost (ira_allocno_t a)\n   ira_loop_tree_node_t parent_node, loop_node;\n \n   regno = ALLOCNO_REGNO (a);\n-  cost = ALLOCNO_UPDATED_MEMORY_COST (a) - ALLOCNO_COVER_CLASS_COST (a);\n+  cost = ALLOCNO_UPDATED_MEMORY_COST (a) - ALLOCNO_UPDATED_COVER_CLASS_COST (a);\n   if (ALLOCNO_CAP (a) != NULL)\n     return cost;\n   loop_node = ALLOCNO_LOOP_TREE_NODE (a);\n@@ -1821,24 +1823,26 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  else\n \t    {\n \t      cover_class = ALLOCNO_COVER_CLASS (subloop_allocno);\n-\t      ira_allocate_and_set_costs\n-\t\t(&ALLOCNO_HARD_REG_COSTS (subloop_allocno), cover_class,\n-\t\t ALLOCNO_COVER_CLASS_COST (subloop_allocno));\n-\t      ira_allocate_and_set_costs\n-\t\t(&ALLOCNO_CONFLICT_HARD_REG_COSTS (subloop_allocno),\n-\t\t cover_class, 0);\n \t      cost = (ira_register_move_cost[mode][rclass][rclass] \n \t\t      * (exit_freq + enter_freq));\n-\t      ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index] -= cost;\n-\t      ALLOCNO_CONFLICT_HARD_REG_COSTS (subloop_allocno)[index]\n+\t      ira_allocate_and_set_or_copy_costs\n+\t\t(&ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno), cover_class,\n+\t\t ALLOCNO_UPDATED_COVER_CLASS_COST (subloop_allocno),\n+\t\t ALLOCNO_HARD_REG_COSTS (subloop_allocno));\n+\t      ira_allocate_and_set_or_copy_costs\n+\t\t(&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (subloop_allocno),\n+\t\t cover_class, 0,\n+\t\t ALLOCNO_CONFLICT_HARD_REG_COSTS (subloop_allocno));\n+\t      ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno)[index] -= cost;\n+\t      ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (subloop_allocno)[index]\n \t\t-= cost;\n+\t      if (ALLOCNO_UPDATED_COVER_CLASS_COST (subloop_allocno)\n+\t\t  > ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno)[index])\n+\t\tALLOCNO_UPDATED_COVER_CLASS_COST (subloop_allocno)\n+\t\t  = ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno)[index];\n \t      ALLOCNO_UPDATED_MEMORY_COST (subloop_allocno)\n \t\t+= (ira_memory_move_cost[mode][rclass][0] * enter_freq\n \t\t    + ira_memory_move_cost[mode][rclass][1] * exit_freq);\n-\t      if (ALLOCNO_COVER_CLASS_COST (subloop_allocno)\n-\t\t  > ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index])\n-\t\tALLOCNO_COVER_CLASS_COST (subloop_allocno)\n-\t\t  = ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index];\n \t    }\n \t}\n     }\n@@ -3054,8 +3058,8 @@ ira_finish_assign (void)\n \f\n \n /* Entry function doing color-based register allocation.  */\n-void\n-ira_color (void)\n+static void\n+color (void)\n {\n   allocno_stack_vec = VEC_alloc (ira_allocno_t, heap, ira_allocnos_num);\n   removed_splay_allocno_vec\n@@ -3077,8 +3081,8 @@ ira_color (void)\n /* Do register allocation by not using allocno conflicts.  It uses\n    only allocno live ranges.  The algorithm is close to Chow's\n    priority coloring.  */\n-void\n-ira_fast_allocation (void)\n+static void\n+fast_allocation (void)\n {\n   int i, j, k, num, class_size, hard_regno;\n #ifdef STACK_REGS\n@@ -3148,3 +3152,24 @@ ira_fast_allocation (void)\n   if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)\n     ira_print_disposition (ira_dump_file);\n }\n+\n+\f\n+\n+/* Entry function doing coloring.  */\n+void\n+ira_color (void)\n+{\n+  ira_allocno_t a;\n+  ira_allocno_iterator ai;\n+\n+  /* Setup updated costs.  */\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      ALLOCNO_UPDATED_MEMORY_COST (a) = ALLOCNO_MEMORY_COST (a);\n+      ALLOCNO_UPDATED_COVER_CLASS_COST (a) = ALLOCNO_COVER_CLASS_COST (a);\n+    }\n+  if (optimize)\n+    color ();\n+  else\n+    fast_allocation ();\n+}"}, {"sha": "01ba907ab5d24c764609861f6bd79619517edd55", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -337,6 +337,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n   enum reg_class rclass, cover_class;\n   enum machine_mode mode;\n   ira_copy_t cp;\n+  ira_loop_tree_node_t parent;\n \n   gcc_assert (REG_SUBREG_P (reg1) && REG_SUBREG_P (reg2));\n   only_regs_p = REG_P (reg1) && REG_P (reg2);\n@@ -386,13 +387,23 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n     cost = ira_register_move_cost[mode][cover_class][rclass] * freq;\n   else\n     cost = ira_register_move_cost[mode][rclass][cover_class] * freq;\n-  ira_allocate_and_set_costs\n-    (&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n-     ALLOCNO_COVER_CLASS_COST (a));\n-  ira_allocate_and_set_costs\n-    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a), cover_class, 0);\n-  ALLOCNO_HARD_REG_COSTS (a)[index] -= cost;\n-  ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[index] -= cost;\n+  for (;;)\n+    {\n+      ira_allocate_and_set_costs\n+\t(&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n+\t ALLOCNO_COVER_CLASS_COST (a));\n+      ira_allocate_and_set_costs\n+\t(&ALLOCNO_CONFLICT_HARD_REG_COSTS (a), cover_class, 0);\n+      ALLOCNO_HARD_REG_COSTS (a)[index] -= cost;\n+      ALLOCNO_CONFLICT_HARD_REG_COSTS (a)[index] -= cost;\n+      if (ALLOCNO_HARD_REG_COSTS (a)[index] < ALLOCNO_COVER_CLASS_COST (a))\n+\tALLOCNO_COVER_CLASS_COST (a) = ALLOCNO_HARD_REG_COSTS (a)[index];\n+      if (ALLOCNO_CAP (a) != NULL)\n+\ta = ALLOCNO_CAP (a);\n+      else if ((parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) == NULL\n+\t       || (a = parent->regno_allocno_map[ALLOCNO_REGNO (a)]) == NULL)\n+\tbreak;\n+    }\n   return true;\n }\n "}, {"sha": "eade4da4d1cc87b5f45a8b388dac3678c8f3ff2b", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -1407,8 +1407,7 @@ setup_allocno_cover_class_and_costs (void)\n       mode = ALLOCNO_MODE (a);\n       cover_class = ira_class_translate[allocno_pref[i]];\n       ira_assert (allocno_pref[i] == NO_REGS || cover_class != NO_REGS);\n-      ALLOCNO_MEMORY_COST (a) = ALLOCNO_UPDATED_MEMORY_COST (a)\n-\t= COSTS_OF_ALLOCNO (allocno_costs, i)->mem_cost;\n+      ALLOCNO_MEMORY_COST (a) = COSTS_OF_ALLOCNO (allocno_costs, i)->mem_cost;\n       ira_set_allocno_cover_class (a, cover_class);\n       if (cover_class == NO_REGS)\n \tcontinue;"}, {"sha": "c72df3de77b90dac87ae47caaf93926aca04f060", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -258,9 +258,9 @@ struct ira_allocno\n   /* Register class which should be used for allocation for given\n      allocno.  NO_REGS means that we should use memory.  */\n   enum reg_class cover_class;\n-  /* Minimal accumulated cost of usage register of the cover class for\n-     the allocno.  */\n-  int cover_class_cost;\n+  /* Minimal accumulated and updated costs of usage register of the\n+     cover class for the allocno.  */\n+  int cover_class_cost, updated_cover_class_cost;\n   /* Minimal accumulated, and updated costs of memory for the allocno.\n      At the allocation start, the original and updated costs are\n      equal.  The updated cost may be changed after finishing\n@@ -451,6 +451,7 @@ struct ira_allocno\n #define ALLOCNO_LEFT_CONFLICTS_NUM(A) ((A)->left_conflicts_num)\n #define ALLOCNO_COVER_CLASS(A) ((A)->cover_class)\n #define ALLOCNO_COVER_CLASS_COST(A) ((A)->cover_class_cost)\n+#define ALLOCNO_UPDATED_COVER_CLASS_COST(A) ((A)->updated_cover_class_cost)\n #define ALLOCNO_MEMORY_COST(A) ((A)->memory_cost)\n #define ALLOCNO_UPDATED_MEMORY_COST(A) ((A)->updated_memory_cost)\n #define ALLOCNO_EXCESS_PRESSURE_POINTS_NUM(A) ((A)->excess_pressure_points_num)\n@@ -902,7 +903,6 @@ extern void ira_reassign_conflict_allocnos (int);\n extern void ira_initiate_assign (void);\n extern void ira_finish_assign (void);\n extern void ira_color (void);\n-extern void ira_fast_allocation (void);\n \n /* ira-emit.c */\n extern void ira_emit (bool);"}, {"sha": "5573ce86a5ec69572bde34a13574bd7bdabc4bea", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -75,6 +75,11 @@ static HARD_REG_SET hard_regs_live;\n /* The loop tree node corresponding to the current basic block.  */\n static ira_loop_tree_node_t curr_bb_node;\n \n+/* The number of the last processed call.  */\n+static int last_call_num;\n+/* The number of last call at which given allocno was saved.  */\n+static int *allocno_saved_at_call;\n+\n /* The function processing birth of register REGNO.  It updates living\n    hard regs and conflict hard regs for living allocnos or starts a\n    new live range for the allocno corresponding to REGNO if it is\n@@ -163,6 +168,8 @@ set_allocno_live (ira_allocno_t a)\n   int nregs;\n   enum reg_class cover_class;\n \n+  /* Invalidate because it is referenced.  */\n+  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n   if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n     return;\n   sparseset_set_bit (allocnos_live, ALLOCNO_NUM (a));\n@@ -189,6 +196,8 @@ clear_allocno_live (ira_allocno_t a)\n   unsigned int i;\n   enum reg_class cover_class;\n \n+  /* Invalidate because it is referenced.  */\n+  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n   if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n     {\n       cover_class = ALLOCNO_COVER_CLASS (a);\n@@ -228,7 +237,11 @@ mark_reg_live (rtx reg)\n       if (a != NULL)\n \t{\n \t  if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n-\t    return;\n+\t    {\n+\t      /* Invalidate because it is referenced.  */\n+\t      allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n+\t      return;\n+\t    }\n \t  set_allocno_live (a);\n \t}\n       make_regno_born (regno);\n@@ -293,7 +306,11 @@ mark_reg_dead (rtx reg)\n       if (a != NULL)\n \t{\n \t  if (! sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n-\t    return;\n+\t    {\n+\t      /* Invalidate because it is referenced.  */\n+\t      allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n+\t      return;\n+\t    }\n \t  clear_allocno_live (a);\n \t}\n       make_regno_dead (regno);\n@@ -820,6 +837,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n       if (freq == 0)\n \tfreq = 1;\n \n+      /* Invalidate all allocno_saved_at_call entries.  */\n+      last_call_num++;\n+\n       /* Scan the code of this basic block, noting which allocnos and\n \t hard regs are born or die.\n \n@@ -901,12 +921,21 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \n \t  if (call_p)\n \t    {\n+\t      last_call_num++;\n \t      /* The current set of live allocnos are live across the call.  */\n \t      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n \t        {\n \t\t  ira_allocno_t a = ira_allocnos[i];\n \t\t  \n-\t\t  ALLOCNO_CALL_FREQ (a) += freq;\n+\t\t  if (allocno_saved_at_call[i] != last_call_num)\n+\t\t    /* Here we are mimicking caller-save.c behaviour\n+\t\t       which does not save hard register at a call if\n+\t\t       it was saved on previous call in the same basic\n+\t\t       block and the hard register was not mentioned\n+\t\t       between the two calls.  */\n+\t\t    ALLOCNO_CALL_FREQ (a) += freq;\n+\t\t  /* Mark it as saved at the next call.  */\n+\t\t  allocno_saved_at_call[i] = last_call_num + 1;\n \t\t  ALLOCNO_CALLS_CROSSED_NUM (a)++;\n \t\t  /* Don't allocate allocnos that cross setjmps or any\n \t\t     call, if this function receives a nonlocal\n@@ -1152,13 +1181,18 @@ ira_create_allocno_live_ranges (void)\n {\n   allocnos_live = sparseset_alloc (ira_allocnos_num);\n   curr_point = 0;\n+  last_call_num = 0;\n+  allocno_saved_at_call\n+    = (int *) ira_allocate (ira_allocnos_num * sizeof (int));\n+  memset (allocno_saved_at_call, 0, ira_allocnos_num * sizeof (int));\n   ira_traverse_loop_tree (true, ira_loop_tree_root, NULL,\n \t\t\t  process_bb_node_lives);\n   ira_max_point = curr_point;\n   create_start_finish_chains ();\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_live_ranges (ira_dump_file);\n   /* Clean up.  */\n+  ira_free (allocno_saved_at_call);\n   sparseset_free (allocnos_live);\n }\n "}, {"sha": "d0232f75a1efb6ebdec98cb327af34c34506ab76", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=cb1ca6ac11d48dc88a44579ed631c3d9d8a3402c", "patch": "@@ -1792,10 +1792,7 @@ ira (FILE *f)\n   loops_p = ira_build (optimize\n \t\t       && (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n \t\t\t   || flag_ira_algorithm == IRA_ALGORITHM_MIXED));\n-  if (optimize)\n-    ira_color ();\n-  else\n-    ira_fast_allocation ();\n+  ira_color ();\n       \n   ira_max_point_before_emit = ira_max_point;\n       "}]}