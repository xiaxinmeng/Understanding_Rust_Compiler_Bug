{"sha": "77aecf92a2c47af6e8fda93b020f75c7de48b84c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhZWNmOTJhMmM0N2FmNmU4ZmRhOTNiMDIwZjc1YzdkZTQ4Yjg0Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-20T16:13:29Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-04-20T16:13:29Z"}, "message": "vect: Tweak vect_better_loop_vinfo_p handling of variable VFs\n\nThis patch fixes a large lmbench performance regression with\n128-bit SVE, compiled in length-agnostic mode.\n\nvect_better_loop_vinfo_p (new in GCC 10) tries to estimate whether\na new loop_vinfo is cheaper than a previous one, with an in-built\npreference for the old one.  For variable VF it prefers the old\nloop_vinfo if it is cheaper for at least one VF.  However, we have\nno idea how likely that VF is in practice.\n\nAnother extreme would be to do what most of the rest of the\nvectoriser does, and rely solely on the constant estimated VF.\nBut as noted in the comment, this means that a one-unit cost\ndifference would be enough to pick the new loop_vinfo,\ndespite the target generally preferring the old loop_vinfo\nwhere possible.  The cost model just isn't accurate enough\nfor that to produce good results as things stand: there might\nnot be any practical benefit to the new loop_vinfo at the\nestimated VF, and it would be significantly worse for higher VFs.\n\nThe patch instead goes for a hacky compromise: make sure that the new\nloop_vinfo is also no worse than the old loop_vinfo at double the\nestimated VF.  For all but trivial loops, this ensures that the\nnew loop_vinfo is only chosen if it is better than the old one\nby a non-trivial amount at the estimated VF.  It also avoids\nputting too much faith in the VF estimate.\n\nI realise this isn't great, but it's supposed to be a conservative fix\nsuitable for stage 4.  The only affected testcases are the ones for\npr89007-*.c, where Advanced SIMD is indeed preferred for 128-bit SVE\nand is no worse for 256-bit SVE.\n\nPart of the problem here is that if the new loop_vinfo is better,\nwe discard the old one and never consider using it even as an\nepilogue loop.  This means that if we choose Advanced SIMD over SVE,\nwe're much more likely to have left-over scalar elements.\n\nAnother is that the estimate provided by estimated_poly_value might have\ndifferent probabilities attached.  E.g. when tuning for a particular core,\nthe estimate is probably accurate, but when tuning for generic code,\nthe estimate is more of a guess.  Relying solely on the estimate is\nprobably correct for the former but not for the latter.\n\nHopefully those are things that we could tackle in GCC 11.\n\n2020-04-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vect_better_loop_vinfo_p): If old_loop_vinfo\n\thas a variable VF, prefer new_loop_vinfo if it is cheaper for the\n\testimated VF and is no worse at double the estimated VF.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/cost_model_8.c: New test.\n\t* gcc.target/aarch64/sve/cost_model_9.c: Likewise.\n\t* gcc.target/aarch64/sve/pr89007-1.c: Add -msve-vector-bits=512.\n\t* gcc.target/aarch64/sve/pr89007-2.c: Likewise.", "tree": {"sha": "5362a39fde6eb36b13670fcf76bfdf354614367a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5362a39fde6eb36b13670fcf76bfdf354614367a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77aecf92a2c47af6e8fda93b020f75c7de48b84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77aecf92a2c47af6e8fda93b020f75c7de48b84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77aecf92a2c47af6e8fda93b020f75c7de48b84c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77aecf92a2c47af6e8fda93b020f75c7de48b84c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5da301cbd81c41b2e9629f55dd1b1889f7dae75e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da301cbd81c41b2e9629f55dd1b1889f7dae75e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da301cbd81c41b2e9629f55dd1b1889f7dae75e"}], "stats": {"total": 73, "additions": 70, "deletions": 3}, "files": [{"sha": "433b976077c60d129e908034e54206df49172c2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -1,3 +1,9 @@\n+2020-04-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-loop.c (vect_better_loop_vinfo_p): If old_loop_vinfo\n+\thas a variable VF, prefer new_loop_vinfo if it is cheaper for the\n+\testimated VF and is no worse at double the estimated VF.\n+\n 2020-04-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR target/94668"}, {"sha": "ea3ba36d97f676ae454dfbd8c4a0e3251f2f5099", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -1,3 +1,10 @@\n+2020-04-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/cost_model_8.c: New test.\n+\t* gcc.target/aarch64/sve/cost_model_9.c: Likewise.\n+\t* gcc.target/aarch64/sve/pr89007-1.c: Add -msve-vector-bits=512.\n+\t* gcc.target/aarch64/sve/pr89007-2.c: Likewise.\n+\n 2020-04-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR target/94668"}, {"sha": "80c3a23e18a00bfc2adc1853f182a157d34aabb6", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cost_model_8.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_8.c?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-O3 -msve-vector-bits=scalable\" } */\n+\n+void\n+vset (int *restrict dst, int *restrict src, int count)\n+{\n+  for (int i = 0; i < count; ++i)\n+#pragma GCC unroll 4\n+    for (int j = 0; j < 4; ++j)\n+      *dst++ = 1;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz} 1 } } */"}, {"sha": "e7a1bac3c83a3a52a886373459ca53ea8b555853", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cost_model_9.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcost_model_9.c?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O3 -msve-vector-bits=scalable\" } */\n+\n+void\n+vset (int *restrict dst, int *restrict src, int count)\n+{\n+  for (int i = 0; i < count; ++i)\n+#pragma GCC unroll 8\n+    for (int j = 0; j < 8; ++j)\n+      *dst++ = 1;\n+}\n+\n+/* { dg-final { scan-assembler-not {\\tst1w\\tz} } } */\n+/* { dg-final { scan-assembler-times {\\tstp\\tq} 1 } } */"}, {"sha": "ff9550c91091cc55e180094f7603eeafba0ac8d1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr89007-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-1.c?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do assemble { target aarch64_asm_sve_ok } } */\n-/* { dg-options \"-O -ftree-vectorize -march=armv8.2-a+sve --save-temps\" } */\n+/* { dg-options \"-O -ftree-vectorize -march=armv8.2-a+sve -msve-vector-bits=512 --save-temps\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n #define N 1024"}, {"sha": "da345fe8bd6e744179fb910aa221e48574af1b61", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pr89007-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpr89007-2.c?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do assemble { target aarch64_asm_sve_ok } } */\n-/* { dg-options \"-O -ftree-vectorize -march=armv8.2-a+sve --save-temps\" } */\n+/* { dg-options \"-O -ftree-vectorize -march=armv8.2-a+sve -msve-vector-bits=512 --save-temps\" } */\n /* { dg-final { check-function-bodies \"**\" \"\" } } */\n \n #define N 1024"}, {"sha": "b6c3faeae5153e1cac91cfd2936479de773352f4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77aecf92a2c47af6e8fda93b020f75c7de48b84c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=77aecf92a2c47af6e8fda93b020f75c7de48b84c", "patch": "@@ -2414,7 +2414,36 @@ vect_better_loop_vinfo_p (loop_vec_info new_loop_vinfo,\n   poly_widest_int rel_old = (old_loop_vinfo->vec_inside_cost\n \t\t\t     * poly_widest_int (new_vf));\n   if (maybe_lt (rel_old, rel_new))\n-    return false;\n+    {\n+      /* When old_loop_vinfo uses a variable vectorization factor,\n+\t we know that it has a lower cost for at least one runtime VF.\n+\t However, we don't know how likely that VF is.\n+\n+\t One option would be to compare the costs for the estimated VFs.\n+\t The problem is that that can put too much pressure on the cost\n+\t model.  E.g. if the estimated VF is also the lowest possible VF,\n+\t and if old_loop_vinfo is 1 unit worse than new_loop_vinfo\n+\t for the estimated VF, we'd then choose new_loop_vinfo even\n+\t though (a) new_loop_vinfo might not actually be better than\n+\t old_loop_vinfo for that VF and (b) it would be significantly\n+\t worse at larger VFs.\n+\n+\t Here we go for a hacky compromise: pick new_loop_vinfo if it is\n+\t no more expensive than old_loop_vinfo even after doubling the\n+\t estimated old_loop_vinfo VF.  For all but trivial loops, this\n+\t ensures that we only pick new_loop_vinfo if it is significantly\n+\t better than old_loop_vinfo at the estimated VF.  */\n+      if (rel_new.is_constant ())\n+\treturn false;\n+\n+      HOST_WIDE_INT new_estimated_vf = estimated_poly_value (new_vf);\n+      HOST_WIDE_INT old_estimated_vf = estimated_poly_value (old_vf);\n+      widest_int estimated_rel_new = (new_loop_vinfo->vec_inside_cost\n+\t\t\t\t      * widest_int (old_estimated_vf));\n+      widest_int estimated_rel_old = (old_loop_vinfo->vec_inside_cost\n+\t\t\t\t      * widest_int (new_estimated_vf));\n+      return estimated_rel_new * 2 <= estimated_rel_old;\n+    }\n   if (known_lt (rel_new, rel_old))\n     return true;\n "}]}