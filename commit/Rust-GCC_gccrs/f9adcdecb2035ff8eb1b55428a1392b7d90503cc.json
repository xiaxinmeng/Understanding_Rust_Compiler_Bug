{"sha": "f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlhZGNkZWNiMjAzNWZmOGViMWI1NTQyOGExMzkyYjdkOTA1MDNjYw==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-07-12T19:02:57Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-07-12T19:02:57Z"}, "message": "rtl.texi (REG_NONNEG): Remove decrement and branch until zero reference, add doloop_end instead.\n\n\t* doc/rtl.texi (REG_NONNEG): Remove decrement and branch until\n\tzero reference, add doloop_end instead.\n\t* doc/md.texi (decrement_and_branch_until_zero): Remove.\n\t(Looping patterns): Remove decrement_and_branch_until_zero.  Add\n\tdetail for doloop_end.\n\nFrom-SVN: r262603", "tree": {"sha": "308f8d7a0bc50b32c84b8f5a53d48013bed3564f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/308f8d7a0bc50b32c84b8f5a53d48013bed3564f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/comments", "author": null, "committer": null, "parents": [{"sha": "e57aae39e0cc7f683980a1eaa593c0e48ec233b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57aae39e0cc7f683980a1eaa593c0e48ec233b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57aae39e0cc7f683980a1eaa593c0e48ec233b3"}], "stats": {"total": 156, "additions": 74, "deletions": 82}, "files": [{"sha": "3bc1f902ccb655372447fe98283616d2f4bbfc9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "patch": "@@ -1,3 +1,11 @@\n+2018-07-12  Paul Koning  <ni1d@arrl.net>\n+\n+\t* doc/rtl.texi (REG_NONNEG): Remove decrement and branch until\n+\tzero reference, add doloop_end instead.\n+\t* doc/md.texi (decrement_and_branch_until_zero): Remove.\n+\t(Looping patterns): Remove decrement_and_branch_until_zero.  Add\n+\tdetail for doloop_end.\n+\n 2018-07-12  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/86453"}, {"sha": "734bc7653872b1e6d1ebf5d59139bca347ef503c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 62, "deletions": 78, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "patch": "@@ -6698,17 +6698,6 @@ second operand, but you should incorporate it in the RTL pattern so\n that the jump optimizer will not delete the table as unreachable code.\n \n \n-@cindex @code{decrement_and_branch_until_zero} instruction pattern\n-@item @samp{decrement_and_branch_until_zero}\n-Conditional branch instruction that decrements a register and\n-jumps if the register is nonzero.  Operand 0 is the register to\n-decrement and test; operand 1 is the label to jump to if the\n-register is nonzero.  @xref{Looping Patterns}.\n-\n-This optional instruction pattern is only used by the combiner,\n-typically for loops reversed by the loop optimizer when strength\n-reduction is enabled.\n-\n @cindex @code{doloop_end} instruction pattern\n @item @samp{doloop_end}\n Conditional branch instruction that decrements a register and\n@@ -7532,66 +7521,11 @@ iterations.  This avoids the need for fetching and executing a\n @samp{dbra}-like instruction and avoids pipeline stalls associated with\n the jump.\n \n-GCC has three special named patterns to support low overhead looping.\n-They are @samp{decrement_and_branch_until_zero}, @samp{doloop_begin},\n-and @samp{doloop_end}.  The first pattern,\n-@samp{decrement_and_branch_until_zero}, is not emitted during RTL\n-generation but may be emitted during the instruction combination phase.\n-This requires the assistance of the loop optimizer, using information\n-collected during strength reduction, to reverse a loop to count down to\n-zero.  Some targets also require the loop optimizer to add a\n-@code{REG_NONNEG} note to indicate that the iteration count is always\n-positive.  This is needed if the target performs a signed loop\n-termination test.  For example, the 68000 uses a pattern similar to the\n-following for its @code{dbra} instruction:\n-\n-@smallexample\n-@group\n-(define_insn \"decrement_and_branch_until_zero\"\n-  [(set (pc)\n-        (if_then_else\n-          (ge (plus:SI (match_operand:SI 0 \"general_operand\" \"+d*am\")\n-                       (const_int -1))\n-              (const_int 0))\n-          (label_ref (match_operand 1 \"\" \"\"))\n-          (pc)))\n-   (set (match_dup 0)\n-        (plus:SI (match_dup 0)\n-                 (const_int -1)))]\n-  \"find_reg_note (insn, REG_NONNEG, 0)\"\n-  \"@dots{}\")\n-@end group\n-@end smallexample\n-\n-Note that since the insn is both a jump insn and has an output, it must\n-deal with its own reloads, hence the `m' constraints.  Also note that\n-since this insn is generated by the instruction combination phase\n-combining two sequential insns together into an implicit parallel insn,\n-the iteration counter needs to be biased by the same amount as the\n-decrement operation, in this case @minus{}1.  Note that the following similar\n-pattern will not be matched by the combiner.\n-\n-@smallexample\n-@group\n-(define_insn \"decrement_and_branch_until_zero\"\n-  [(set (pc)\n-        (if_then_else\n-          (ge (match_operand:SI 0 \"general_operand\" \"+d*am\")\n-              (const_int 1))\n-          (label_ref (match_operand 1 \"\" \"\"))\n-          (pc)))\n-   (set (match_dup 0)\n-        (plus:SI (match_dup 0)\n-                 (const_int -1)))]\n-  \"find_reg_note (insn, REG_NONNEG, 0)\"\n-  \"@dots{}\")\n-@end group\n-@end smallexample\n-\n-The other two special looping patterns, @samp{doloop_begin} and\n-@samp{doloop_end}, are emitted by the loop optimizer for certain\n-well-behaved loops with a finite number of loop iterations using\n-information collected during strength reduction.\n+GCC has two special named patterns to support low overhead looping.\n+They are @samp{doloop_begin} and @samp{doloop_end}.  These are emitted\n+by the loop optimizer for certain well-behaved loops with a finite\n+number of loop iterations using information collected during strength\n+reduction.\n \n The @samp{doloop_end} pattern describes the actual looping instruction\n (or the implicit looping operation) and the @samp{doloop_begin} pattern\n@@ -7611,14 +7545,64 @@ desired special iteration counter register was not allocated, this\n machine dependent reorg pass could emit a traditional compare and jump\n instruction pair.\n \n-The essential difference between the\n-@samp{decrement_and_branch_until_zero} and the @samp{doloop_end}\n-patterns is that the loop optimizer allocates an additional pseudo\n-register for the latter as an iteration counter.  This pseudo register\n-cannot be used within the loop (i.e., general induction variables cannot\n-be derived from it), however, in many cases the loop induction variable\n-may become redundant and removed by the flow pass.\n+For the @samp{doloop_end} pattern, the loop optimizer allocates an\n+additional pseudo register as an iteration counter.  This pseudo\n+register cannot be used within the loop (i.e., general induction\n+variables cannot be derived from it), however, in many cases the loop\n+induction variable may become redundant and removed by the flow pass.\n+\n+The @samp{doloop_end} pattern must have a specific structure to be\n+handled correctly by GCC.  The example below is taken (slightly\n+simplified) from the PDP-11 target:\n+\n+@smallexample\n+@group\n+(define_insn \"doloop_end\"\n+  [(set (pc)\n+        (if_then_else\n+         (ne (match_operand:HI 0 \"nonimmediate_operand\" \"+r,!m\")\n+             (const_int 1))\n+         (label_ref (match_operand 1 \"\" \"\"))\n+         (pc)))\n+   (set (match_dup 0)\n+        (plus:HI (match_dup 0)\n+              (const_int -1)))]\n+  \"\"\n+  \n+  @{\n+    if (which_alternative == 0)\n+      return \"sob %0,%l1\";\n+\n+    /* emulate sob */\n+    output_asm_insn (\"dec %0\", operands);\n+    return \"bne %l1\";\n+  @})\n+@end group\n+@end smallexample\n+\n+The first part of the pattern describes the branch condition.  GCC\n+supports three cases for the way the target machine handles the loop\n+counter:\n+@itemize @bullet\n+@item Loop terminates when the loop register decrements to zero.  This\n+is represented by a @code{ne} comparison of the register (its old value)\n+with constant 1 (as in the example above).\n+@item Loop terminates when the loop register decrements to @minus{}1.\n+This is represented by a @code{ne} comparison of the register with\n+constant zero.\n+@item Loop terminates when the loop register decrements to a negative\n+value.  This is represented by a @code{ge} comparison of the register\n+with constant zero.  For this case, GCC will attach a @code{REG_NONNEG}\n+note to the @code{doloop_end} insn if it can determine that the register\n+will be non-negative.\n+@end itemize\n \n+Since the @code{doloop_end} insn is a jump insn that also has an output,\n+the reload pass does not handle the output operand.  Therefore, the\n+constraint must allow for that operand to be in memory rather than a\n+register.  In the example shown above, that is handled by using a loop\n+instruction sequence that can handle memory operands when the memory\n+alternative appears.\n \n @end ifset\n @ifset INTERNALS"}, {"sha": "a37d9ac538991c507985bda4f825023534321b76", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9adcdecb2035ff8eb1b55428a1392b7d90503cc/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=f9adcdecb2035ff8eb1b55428a1392b7d90503cc", "patch": "@@ -4151,11 +4151,11 @@ This means it appears in a @code{post_inc}, @code{pre_inc},\n @findex REG_NONNEG\n @item REG_NONNEG\n The register @var{op} is known to have a nonnegative value when this\n-insn is reached.  This is used so that decrement and branch until zero\n-instructions, such as the m68k dbra, can be matched.\n+insn is reached.  This is used by special looping instructions\n+that terminate when the register goes negative.\n \n-The @code{REG_NONNEG} note is added to insns only if the machine\n-description has a @samp{decrement_and_branch_until_zero} pattern.\n+The @code{REG_NONNEG} note is added only to @samp{doloop_end}\n+insns, if its pattern uses a @code{ge} condition.\n \n @findex REG_LABEL_OPERAND\n @item REG_LABEL_OPERAND"}]}