{"sha": "353a10d05618c4a9661cc756624c4f9f5a71f553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUzYTEwZDA1NjE4YzRhOTY2MWNjNzU2NjI0YzRmOWY1YTcxZjU1Mw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-07-01T16:13:01Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-07-01T16:13:01Z"}, "message": "Makefile.in: Remove all trace of tradcpp.c, tradcpp.h, tradcif.y and related files.\n\n\t* Makefile.in: Remove all trace of tradcpp.c, tradcpp.h,\n\ttradcif.y and related files.\n\nFrom-SVN: r55139", "tree": {"sha": "b57f0bac51abba447a0be8f5b727498701bc088f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b57f0bac51abba447a0be8f5b727498701bc088f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/353a10d05618c4a9661cc756624c4f9f5a71f553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/353a10d05618c4a9661cc756624c4f9f5a71f553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/353a10d05618c4a9661cc756624c4f9f5a71f553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/353a10d05618c4a9661cc756624c4f9f5a71f553/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cfefc4344507f68ca2dd1b98dbbe12dced8c80cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf"}], "stats": {"total": 5901, "additions": 8, "deletions": 5893}, "files": [{"sha": "1a67262da9dc13045162c030f2e2c2a182714837", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/353a10d05618c4a9661cc756624c4f9f5a71f553/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/353a10d05618c4a9661cc756624c4f9f5a71f553/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=353a10d05618c4a9661cc756624c4f9f5a71f553", "patch": "@@ -1,3 +1,8 @@\n+2002-07-01  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in: Remove all trace of tradcpp.c, tradcpp.h,\n+\ttradcif.y and related files.\n+\n 2002-07-01  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cpptrad.c (skip_whitespace): Pass pointer to prior char."}, {"sha": "d1af43cdcf2a06839c473ba8b6b5fa5f2e80b8c0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/353a10d05618c4a9661cc756624c4f9f5a71f553/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/353a10d05618c4a9661cc756624c4f9f5a71f553/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=353a10d05618c4a9661cc756624c4f9f5a71f553", "patch": "@@ -767,7 +767,7 @@ STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  xgcc$(exeext) cpp$(exeext) cc1$(exeext) $(EXTRA_PASSES) \\\n  $(EXTRA_PARTS) $(EXTRA_PROGRAMS) gcc-cross$(exeext) cc1obj$(exeext) \\\n  enquire$(exeext) protoize$(exeext) unprotoize$(exeext) \\\n- specs collect2$(exeext) $(USE_COLLECT2) underscore.c tradcpp0$(exeext) \\\n+ specs collect2$(exeext) $(USE_COLLECT2) underscore.c \\\n  gcov$(exeext) *.[0-9][0-9].* *.[si] libcpp.a libbackend.a libgcc.mk \\\n  $(LANG_STAGESTUFF)\n \n@@ -934,7 +934,7 @@ native: config.status auto-host.h intl.all build-@POSUB@ $(LANGUAGES) \\\n \t$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)\n \n # Define the names for selecting languages in LANGUAGES.\n-C c: cc1$(exeext) tradcpp0$(exeext)\n+C c: cc1$(exeext)\n PROTO: proto\n \n # Tell GNU make these are phony targets.\n@@ -2063,7 +2063,7 @@ intl.all intl.install: config.h insn-flags.h insn-constants.h\n \n # Make-lang.in should add dependencies of po-generated on any generated\n # files which need to be scanned by gettext (usually Yacc-generated parsers).\n-po-generated: c-parse.c tradcif.c\n+po-generated: c-parse.c\n \n #\f\n # Remake cpp and protoize.\n@@ -2111,20 +2111,6 @@ cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) cppdefault.h Makefile\n \n mkdeps.o: mkdeps.c $(CONFIG_H) $(SYSTEM_H) mkdeps.h\n \n-# The traditional mode preprocessor, a separate program for ease of\n-# maintenance.  Some code is shared with the ISO-C cpp.\n-tradcpp0$(exeext): tradcpp.o tradcif.o cppdefault.o version.o intl.o \\\n-        mkdeps.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o tradcpp0$(exeext) \\\n-\ttradcpp.o tradcif.o mkdeps.o cppdefault.o version.o intl.o $(LIBS)\n-\n-tradcpp.o: tradcpp.c $(CONFIG_H) $(SYSTEM_H) version.h cppdefault.h tradcpp.h\n-tradcif.o: $(srcdir)/tradcif.c $(CONFIG_H) $(SYSTEM_H) tradcpp.h\n-\n-$(srcdir)/tradcif.c: $(srcdir)/tradcif.y\n-\t(cd $(srcdir) && $(BISON) $(BISONFLAGS) -o tr$$$$.c tradcif.y && \\\n-\tmv -f tr$$$$.c tradcif.c)\n-\n # Note for the stamp targets, we run the program `true' instead of\n # having an empty command (nothing following the semicolon).\n \n@@ -2735,8 +2721,6 @@ install-common: native $(EXTRA_PARTS) lang.install-common\n \t    $(INSTALL_DATA) SYSCALLS.c.X $(libsubdir)/SYSCALLS.c.X; \\\n \t    chmod a-x $(libsubdir)/SYSCALLS.c.X; \\\n \tfi\n-\t-rm -f $(libsubdir)/tradcpp0$(exeext)\n-\t$(INSTALL_PROGRAM) tradcpp0$(exeext) $(libsubdir)/tradcpp0$(exeext)\n # Install gcov if it was compiled.\n \t-if [ -f gcov$(exeext) ]; \\\n \tthen \\"}, {"sha": "953e2d6706ff5fcbe1a0e861eab657b6b2c8b093", "filename": "gcc/tradcif.y", "status": "removed", "additions": 0, "deletions": 567, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf/gcc%2Ftradcif.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf/gcc%2Ftradcif.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcif.y?ref=cfefc4344507f68ca2dd1b98dbbe12dced8c80cf", "patch": "@@ -1,567 +0,0 @@\n-/* Parse C expressions for CCCP.\n-   Copyright (C) 1987, 2000, 2001 Free Software Foundation.\n-   Adapted from expread.y of GDB by Paul Rubin, July 1986.\n-   Adapted to ANSI C, Richard Stallman, Jan 1987\n-   Dusted off, polished, and adapted for use as traditional\n-   preprocessor only, Zack Weinberg, Jul 2000\n-\n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n-\n-/* Parse a C expression from text in a string  */\n-   \n-%{\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"intl.h\"\n-#include \"tradcpp.h\"\n-#include <setjmp.h>\n-\n-  static int yylex PARAMS ((void));\n-  static void yyerror PARAMS ((const char *msgid)) ATTRIBUTE_NORETURN;\n-\n-  static int parse_number PARAMS ((int));\n-  static int parse_escape PARAMS ((const char **));\n-\n-  static int expression_value;\n-  static jmp_buf parse_return_error;\n-\n-  /* During parsing of a C expression, the pointer to the next\n-     character is in this variable.  */\n-\n-  static const char *lexptr;\n-%}\n-\n-%union {\n-  struct constant {long value; int unsignedp;} integer;\n-  int voidval;\n-  char *sval;\n-}\n-\n-%type <integer> exp exp1 start\n-%token <integer> INT CHAR\n-%token <sval> NAME\n-%token <integer> ERROR\n-\n-%right '?' ':'\n-%left ','\n-%left OR\n-%left AND\n-%left '|'\n-%left '^'\n-%left '&'\n-%left EQUAL NOTEQUAL\n-%left '<' '>' LEQ GEQ\n-%left LSH RSH\n-%left '+' '-'\n-%left '*' '/' '%'\n-%right UNARY\n-\n-/* %expect 40 */\n-\f\n-%%\n-\n-start   :\texp1\n-\t\t{ expression_value = $1.value; }\n-\t;\n-\n-/* Expressions, including the comma operator.  */\n-exp1\t:\texp\n-\t|\texp1 ',' exp\n-\t\t\t{ $$ = $3; }\n-\t;\n-\n-/* Expressions, not including the comma operator.  */\n-exp\t:\t'-' exp    %prec UNARY\n-\t\t\t{ $$.value = - $2.value;\n-\t\t\t  $$.unsignedp = $2.unsignedp; }\n-\t|\t'!' exp    %prec UNARY\n-\t\t\t{ $$.value = ! $2.value;\n-\t\t\t  $$.unsignedp = 0; }\n-\t|\t'+' exp    %prec UNARY\n-\t\t\t{ $$ = $2; }\n-\t|\t'~' exp    %prec UNARY\n-\t\t\t{ $$.value = ~ $2.value;\n-\t\t\t  $$.unsignedp = $2.unsignedp; }\n-\t|\t'(' exp1 ')'\n-\t\t\t{ $$ = $2; }\n-\t;\n-\n-/* Binary operators in order of decreasing precedence.  */\n-exp\t:\texp '*' exp\n-\t\t\t{ $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value * $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value * $3.value; }\n-\t|\texp '/' exp\n-\t\t\t{ if ($3.value == 0)\n-\t\t\t    {\n-\t\t\t      error (\"division by zero in #if\");\n-\t\t\t      $3.value = 1;\n-\t\t\t    }\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value / $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value / $3.value; }\n-\t|\texp '%' exp\n-\t\t\t{ if ($3.value == 0)\n-\t\t\t    {\n-\t\t\t      error (\"division by zero in #if\");\n-\t\t\t      $3.value = 1;\n-\t\t\t    }\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value % $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value % $3.value; }\n-\t|\texp '+' exp\n-\t\t\t{ $$.value = $1.value + $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n-\t|\texp '-' exp\n-\t\t\t{ $$.value = $1.value - $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n-\t|\texp LSH exp\n-\t\t\t{ $$.unsignedp = $1.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value << $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value << $3.value; }\n-\t|\texp RSH exp\n-\t\t\t{ $$.unsignedp = $1.unsignedp;\n-\t\t\t  if ($$.unsignedp)\n-\t\t\t    $$.value = (unsigned) $1.value >> $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value >> $3.value; }\n-\t|\texp EQUAL exp\n-\t\t\t{ $$.value = ($1.value == $3.value);\n-\t\t\t  $$.unsignedp = 0; }\n-\t|\texp NOTEQUAL exp\n-\t\t\t{ $$.value = ($1.value != $3.value);\n-\t\t\t  $$.unsignedp = 0; }\n-\t|\texp LEQ exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value =\n-\t\t\t      (unsigned) $1.value <= (unsigned) $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value <= $3.value; }\n-\t|\texp GEQ exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value =\n-\t\t\t      (unsigned) $1.value >= (unsigned) $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value >= $3.value; }\n-\t|\texp '<' exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value =\n-\t\t\t      (unsigned) $1.value < (unsigned) $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value < $3.value; }\n-\t|\texp '>' exp\n-\t\t\t{ $$.unsignedp = 0;\n-\t\t\t  if ($1.unsignedp || $3.unsignedp)\n-\t\t\t    $$.value =\n-\t\t\t      (unsigned) $1.value > (unsigned) $3.value;\n-\t\t\t  else\n-\t\t\t    $$.value = $1.value > $3.value; }\n-\t|\texp '&' exp\n-\t\t\t{ $$.value = $1.value & $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n-\t|\texp '^' exp\n-\t\t\t{ $$.value = $1.value ^ $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n-\t|\texp '|' exp\n-\t\t\t{ $$.value = $1.value | $3.value;\n-\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n-\t|\texp AND exp\n-\t\t\t{ $$.value = ($1.value && $3.value);\n-\t\t\t  $$.unsignedp = 0; }\n-\t|\texp OR exp\n-\t\t\t{ $$.value = ($1.value || $3.value);\n-\t\t\t  $$.unsignedp = 0; }\n-\t|\texp '?' exp ':' exp\n-\t\t\t{ $$.value = $1.value ? $3.value : $5.value;\n-\t\t\t  $$.unsignedp = $3.unsignedp || $5.unsignedp; }\n-\t|\tINT\n-\t\t\t{ $$ = yylval.integer; }\n-\t|\tCHAR\n-\t\t\t{ $$ = yylval.integer; }\n-\t|\tNAME\n-\t\t\t{ $$.value = 0;\n-\t\t\t  $$.unsignedp = 0; }\n-\t|\t'#'\t{ $$.value =\n-\t\t\t    test_assertion ((unsigned char **) &lexptr); }\n-\t;\n-%%\n-\f\n-/* Take care of parsing a number (anything that starts with a digit).\n-   Set yylval and return the token type; update lexptr.\n-   LEN is the number of characters in it.  */\n-\n-/* maybe needs to actually deal with floating point numbers */\n-\n-static int\n-parse_number (olen)\n-     int olen;\n-{\n-  const char *p = lexptr;\n-  long n = 0;\n-  int c;\n-  int base = 10;\n-  int len = olen;\n-\n-  for (c = 0; c < len; c++)\n-    if (p[c] == '.') {\n-      /* It's a float since it contains a point.  */\n-      yyerror (\"floating point numbers not allowed in #if expressions\");\n-      return ERROR;\n-    }\n-\n-  /* Traditionally, all numbers are signed.  However, we make it\n-     unsigned if requested with a suffix.  */\n-  yylval.integer.unsignedp = 0;\n-\n-  if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n-    p += 2;\n-    base = 16;\n-    len -= 2;\n-  }\n-  else if (*p == '0')\n-    base = 8;\n-\n-  while (len > 0) {\n-    c = *p++;\n-    len--;\n-    if (ISUPPER (c))\n-      c = TOLOWER (c);\n-\n-    if (ISDIGIT (c)\n-\t|| (base == 16 && ISXDIGIT (c))) {\n-      n = (n * base) + hex_value (c);\n-    } else {\n-      /* `l' means long, and `u' means unsigned.  */\n-      while (1) {\n-\tif (c == 'l' || c == 'L')\n-\t  ;\n-\telse if (c == 'u' || c == 'U')\n-\t  yylval.integer.unsignedp = 1;\n-\telse\n-\t  break;\n-\n-\tif (len == 0)\n-\t  break;\n-\tc = *p++;\n-\tlen--;\n-      }\n-      /* Don't look for any more digits after the suffixes.  */\n-      break;\n-    }\n-  }\n-\n-  if (len != 0) {\n-    yyerror (\"invalid number in #if expression\");\n-    return ERROR;\n-  }\n-\n-  lexptr = p;\n-  yylval.integer.value = n;\n-  return INT;\n-}\n-\n-struct token {\n-  const char *const operator;\n-  const int token;\n-};\n-\n-#ifndef NULL\n-#define NULL 0\n-#endif\n-\n-static const struct token tokentab2[] = {\n-  {\"&&\", AND},\n-  {\"||\", OR},\n-  {\"<<\", LSH},\n-  {\">>\", RSH},\n-  {\"==\", EQUAL},\n-  {\"!=\", NOTEQUAL},\n-  {\"<=\", LEQ},\n-  {\">=\", GEQ},\n-  {NULL, ERROR}\n-};\n-\n-/* Read one token, getting characters through lexptr.  */\n-\n-static int\n-yylex ()\n-{\n-  int c;\n-  int namelen;\n-  const char *tokstart;\n-  const struct token *toktab;\n-\n- retry:\n-\n-  tokstart = lexptr;\n-  c = *tokstart;\n-  /* See if it is a special token of length 2.  */\n-  for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n-    if (c == *toktab->operator && tokstart[1] == toktab->operator[1]) {\n-      lexptr += 2;\n-      return toktab->token;\n-    }\n-\n-  switch (c) {\n-  case 0:\n-    return 0;\n-    \n-  case ' ':\n-  case '\\t':\n-  case '\\r':\n-  case '\\n':\n-    lexptr++;\n-    goto retry;\n-    \n-  case '\\'':\n-    lexptr++;\n-    c = *lexptr++;\n-    if (c == '\\\\')\n-      c = parse_escape (&lexptr);\n-\n-    /* Sign-extend the constant if chars are signed on target machine.  */\n-    {\n-      if (flag_signed_char == 0\n-\t  || ((c >> (CHAR_TYPE_SIZE - 1)) & 1) == 0)\n-\tyylval.integer.value = c & ((1 << CHAR_TYPE_SIZE) - 1);\n-      else\n-\tyylval.integer.value = c | ~((1 << CHAR_TYPE_SIZE) - 1);\n-    }\n-\n-    yylval.integer.unsignedp = 0;\n-    c = *lexptr++;\n-    if (c != '\\'') {\n-      yyerror (\"invalid character constant in #if\");\n-      return ERROR;\n-    }\n-    \n-    return CHAR;\n-\n-    /* some of these chars are invalid in constant expressions;\n-       maybe do something about them later */\n-  case '/':\n-  case '+':\n-  case '-':\n-  case '*':\n-  case '%':\n-  case '|':\n-  case '&':\n-  case '^':\n-  case '~':\n-  case '!':\n-  case '@':\n-  case '<':\n-  case '>':\n-  case '(':\n-  case ')':\n-  case '[':\n-  case ']':\n-  case '.':\n-  case '?':\n-  case ':':\n-  case '=':\n-  case '{':\n-  case '}':\n-  case ',':\n-  case '#':\n-    lexptr++;\n-    return c;\n-    \n-  case '\"':\n-    yyerror (\"double quoted strings not allowed in #if expressions\");\n-    return ERROR;\n-  }\n-  if (ISDIGIT (c)) {\n-    /* It's a number */\n-    for (namelen = 0;\n-\t c = tokstart[namelen], is_idchar (c) || c == '.'; \n-\t namelen++)\n-      ;\n-    return parse_number (namelen);\n-  }\n-  \n-  if (!is_idstart (c)) {\n-    yyerror (\"invalid token in expression\");\n-    return ERROR;\n-  }\n-  \n-  /* It is a name.  See how long it is.  */\n-  \n-  for (namelen = 0;\n-       is_idchar (tokstart[namelen]);\n-       namelen++)\n-    ;\n-  \n-  lexptr += namelen;\n-  return NAME;\n-}\n-\n-\n-/* Parse a C escape sequence.  STRING_PTR points to a variable\n-   containing a pointer to the string to parse.  That pointer\n-   is updated past the characters we use.  The value of the\n-   escape sequence is returned.\n-\n-   A negative value means the sequence \\ newline was seen,\n-   which is supposed to be equivalent to nothing at all.\n-\n-   If \\ is followed by a null character, we return a negative\n-   value and leave the string pointer pointing at the null character.\n-\n-   If \\ is followed by 000, we return 0 and leave the string pointer\n-   after the zeros.  A value of 0 does not mean end of string.  */\n-\n-static int\n-parse_escape (string_ptr)\n-     const char **string_ptr;\n-{\n-  int c = *(*string_ptr)++;\n-  switch (c)\n-    {\n-    case 'a':\n-      return TARGET_BELL;\n-    case 'b':\n-      return TARGET_BS;\n-    case 'e':\n-      return 033;\n-    case 'f':\n-      return TARGET_FF;\n-    case 'n':\n-      return TARGET_NEWLINE;\n-    case 'r':\n-      return TARGET_CR;\n-    case 't':\n-      return TARGET_TAB;\n-    case 'v':\n-      return TARGET_VT;\n-    case '\\n':\n-      return -2;\n-    case 0:\n-      (*string_ptr)--;\n-      return 0;\n-    case '^':\n-      c = *(*string_ptr)++;\n-      if (c == '\\\\')\n-\tc = parse_escape (string_ptr);\n-      if (c == '?')\n-\treturn 0177;\n-      return (c & 0200) | (c & 037);\n-      \n-    case '0':\n-    case '1':\n-    case '2':\n-    case '3':\n-    case '4':\n-    case '5':\n-    case '6':\n-    case '7':\n-      {\n-\tint i = c - '0';\n-\tint count = 0;\n-\twhile (++count < 3)\n-\t  {\n-\t    c = *(*string_ptr)++;\n-\t    if (c >= '0' && c <= '7')\n-\t      i = (i << 3) + c - '0';\n-\t    else\n-\t      {\n-\t\t(*string_ptr)--;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif ((i & ~((1 << CHAR_TYPE_SIZE) - 1)) != 0)\n-\t  {\n-\t    i &= (1 << CHAR_TYPE_SIZE) - 1;\n-\t    warning (\"octal character constant does not fit in a byte\");\n-\t  }\n-\treturn i;\n-      }\n-    case 'x':\n-      {\n-\tint i = 0;\n-\tfor (;;)\n-\t  {\n-\t    c = *(*string_ptr)++;\n-\t    if (hex_p (c))\n-\t      i = (i << 4) + hex_value (c);\n-\t    else\n-\t      {\n-\t\t(*string_ptr)--;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif ((i & ~((1 << BITS_PER_UNIT) - 1)) != 0)\n-\t  {\n-\t    i &= (1 << BITS_PER_UNIT) - 1;\n-\t    warning (\"hex character constant does not fit in a byte\");\n-\t  }\n-\treturn i;\n-      }\n-    default:\n-      return c;\n-    }\n-}\n-\n-static void\n-yyerror (msgid)\n-     const char *msgid;\n-{\n-  error (\"%s\", _(msgid));\n-  longjmp (parse_return_error, 1);\n-}\n-\f\n-/* This page contains the entry point to this file.  */\n-\n-/* Parse STRING as an expression, and complain if this fails\n-   to use up all of the contents of STRING.  */\n-/* We do not support C comments.  They should be removed before\n-   this function is called.  */\n-\n-int\n-parse_c_expression (string)\n-     const char *string;\n-{\n-  lexptr = string;\n-  \n-  if (lexptr == 0 || *lexptr == 0) {\n-    error (\"empty #if expression\");\n-    return 0;\t\t\t/* don't include the #if group */\n-  }\n-\n-  /* if there is some sort of scanning error, just return 0 and assume\n-     the parsing routine has printed an error message somewhere.\n-     there is surely a better thing to do than this.     */\n-  if (setjmp (parse_return_error))\n-    return 0;\n-\n-  if (yyparse ())\n-    return 0;\t\t\t/* actually this is never reached\n-\t\t\t\t   the way things stand. */\n-  if (*lexptr)\n-    error (\"Junk after end of expression.\");\n-\n-  return expression_value;\t/* set by yyparse () */\n-}"}, {"sha": "dbc4334bcbe5b4ceb3cea002c3f125bd888605ab", "filename": "gcc/tradcpp.c", "status": "removed", "additions": 0, "deletions": 5262, "changes": 5262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf/gcc%2Ftradcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf/gcc%2Ftradcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.c?ref=cfefc4344507f68ca2dd1b98dbbe12dced8c80cf"}, {"sha": "89940d0c3f04211899751e740ec6926bb1a92e44", "filename": "gcc/tradcpp.h", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf/gcc%2Ftradcpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfefc4344507f68ca2dd1b98dbbe12dced8c80cf/gcc%2Ftradcpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.h?ref=cfefc4344507f68ca2dd1b98dbbe12dced8c80cf", "patch": "@@ -1,45 +0,0 @@\n-/* C Compatible Compiler Preprocessor (CCCP)\n-Copyright (C) 1986, 1987, 1989, 2000 Free Software Foundation, Inc.\n-                    Written by Paul Rubin, June 1986\n-\t\t    Adapted to ANSI C, Richard Stallman, Jan 1987\n-\t\t    Dusted off, polished, and adapted for use as traditional\n-\t\t    preprocessor only, Zack Weinberg, Jul 2000\n-\n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; if not, write to the Free Software\n-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_TRADCPP_H\n-#define GCC_TRADCPP_H\n-\n-extern void error PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n-extern void warning PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1;\n-extern void fatal PARAMS ((const char *msgid, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void error_with_line PARAMS ((int, const char *msgid, ...)) ATTRIBUTE_PRINTF_2;\n-extern void error_from_errno PARAMS ((const char *msgid));\n-\n-extern void perror_with_name PARAMS ((const char *msgid));\n-extern void pfatal_with_name PARAMS ((const char *msgid)) ATTRIBUTE_NORETURN;\n-extern void fancy_abort PARAMS ((int, const char *)) ATTRIBUTE_NORETURN;\n-\n-extern struct hashnode *lookup PARAMS ((const unsigned char *, int, int));\n-extern int parse_c_expression PARAMS ((const char *));  /* in tradcif.y */\n-extern int test_assertion PARAMS ((unsigned char **));\n-extern int flag_signed_char;\n-\n-#define is_idchar(x)\tISIDNUM(x)\n-#define is_idstart(x)\tISIDST(x)\n-#define is_space(x)\tISSPACE(x)\n-#define is_nvspace(x)\t(IS_NVSPACE(x) && x != '\\0')\n-\n-#endif /* ! GCC_TRADCPP_H */"}]}