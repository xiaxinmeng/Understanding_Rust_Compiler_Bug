{"sha": "c9a881907525e22505d63851ccda7e15ebbee104", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlhODgxOTA3NTI1ZTIyNTA1ZDYzODUxY2NkYTdlMTVlYmJlZTEwNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-18T18:10:48Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-18T18:10:48Z"}, "message": "pa-protos.h: Add prototypes for magic_milli and shadd_constant_p.\n\n\t* config/pa/pa-protos.h: Add prototypes for magic_milli and\n\tshadd_constant_p.\n\t* config/pa/pa.c (reg_or_0_operand, call_operand_address,\n\tsymbolic_operand, symbolic_memory_operand,\n\treg_or_0_or_nonsymb_mem_operand, reg_before_reload_operand,\n\tindexed_memory_operand, move_dest_operand, move_src_operand,\n\tprefetch_cc_operand, prefetch_nocc_operand,\n\treg_or_cint_move_operand, pic_label_operand, fp_reg_operand,\n\tarith_operand, arith11_operand, pre_cint_operand,\n\tpost_cint_operan, arith_double_operand, ireg_or_int5_operand,\n\tireg_operand, int5_operand, uint5_operand, int11_operand,\n\tuint32_operand, arith5_operand, and_operand, ior_operand,\n\tlhs_lshift_operand, lhs_lshift_cint_operand, arith32_operand,\n\tpc_or_label_operand, div_operand, plus_xor_ior_operator,\n\tshadd_operand, movb_comparison_operator,\n\tcmpib_comparison_operator): Move to predicates.md.\n\t(magic_milli, shadd_constant_p): Make it extern.\n\t* config/pa/pa.h (PREDICATE_CODES): Remove.\n\t* config/pa/pa.md: Include predicates.md.\n\t* config/pa/predicates.md: New.\n\nFrom-SVN: r96692", "tree": {"sha": "1ce65784d75bd4e965b457946948ee55cffd03fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ce65784d75bd4e965b457946948ee55cffd03fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9a881907525e22505d63851ccda7e15ebbee104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9a881907525e22505d63851ccda7e15ebbee104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9a881907525e22505d63851ccda7e15ebbee104", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9a881907525e22505d63851ccda7e15ebbee104/comments", "author": null, "committer": null, "parents": [{"sha": "22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a14e0dccd8e24ace4f1c617e47c96d2d69bba6"}], "stats": {"total": 1110, "additions": 578, "deletions": 532}, "files": [{"sha": "395ecce16355b9d1aeeff95d3e4b062360699774", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9a881907525e22505d63851ccda7e15ebbee104", "patch": "@@ -1,4 +1,4 @@\n-2005-03-18  2005-03-18  Kazu Hirata  <kazu@cs.umass.edu>\n+2005-03-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/m32r/m32r-protos.h: Remove the prototypes for\n \tcall_address_operand, symbolic_operand, seth_add3_operand,\n@@ -26,6 +26,27 @@\n \t* config/m32r/m32r.md: Include predicates.md.\n \t* config/m32r/predicates.md: New.\n \n+\t* config/pa/pa-protos.h: Add prototypes for magic_milli and\n+\tshadd_constant_p.\n+\t* config/pa/pa.c (reg_or_0_operand, call_operand_address,\n+\tsymbolic_operand, symbolic_memory_operand,\n+\treg_or_0_or_nonsymb_mem_operand, reg_before_reload_operand,\n+\tindexed_memory_operand, move_dest_operand, move_src_operand,\n+\tprefetch_cc_operand, prefetch_nocc_operand,\n+\treg_or_cint_move_operand, pic_label_operand, fp_reg_operand,\n+\tarith_operand, arith11_operand, pre_cint_operand,\n+\tpost_cint_operan, arith_double_operand, ireg_or_int5_operand,\n+\tireg_operand, int5_operand, uint5_operand, int11_operand,\n+\tuint32_operand, arith5_operand, and_operand, ior_operand,\n+\tlhs_lshift_operand, lhs_lshift_cint_operand, arith32_operand,\n+\tpc_or_label_operand, div_operand, plus_xor_ior_operator,\n+\tshadd_operand, movb_comparison_operator,\n+\tcmpib_comparison_operator): Move to predicates.md.\n+\t(magic_milli, shadd_constant_p): Make it extern.\n+\t* config/pa/pa.h (PREDICATE_CODES): Remove.\n+\t* config/pa/pa.md: Include predicates.md.\n+\t* config/pa/predicates.md: New.\n+\n 2005-03-18  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* hooks.c, hooks.h, intl.c, opts.h, prefix.c, tree-gimple.c,"}, {"sha": "87bb7f2a0b1a903e6b00ba98a52635743727425f", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=c9a881907525e22505d63851ccda7e15ebbee104", "patch": "@@ -176,6 +176,9 @@ extern void pa_asm_output_aligned_local (FILE *, const char *,\n \t\t\t\t\t unsigned int);\n extern void pa_hpux_asm_output_external (FILE *, tree, const char *);\n \n+extern const int magic_milli[];\n+extern int shadd_constant_p (int);\n+\n /* Functions in varasm.c used by pa.c.  */\n extern void som_readonly_data_section (void);\n extern void som_one_only_readonly_data_section (void);"}, {"sha": "70484c23e2e49bade59a8ef673bc6648dc045fa9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 487, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c9a881907525e22505d63851ccda7e15ebbee104", "patch": "@@ -91,7 +91,6 @@ static void pa_reorg (void);\n static void pa_combine_instructions (void);\n static int pa_can_combine_p (rtx, rtx, rtx, int, rtx, rtx, rtx);\n static int forward_branch_p (rtx);\n-static int shadd_constant_p (int);\n static void compute_zdepwi_operands (unsigned HOST_WIDE_INT, unsigned *);\n static int compute_movmem_length (rtx);\n static int compute_clrmem_length (rtx);\n@@ -550,26 +549,6 @@ copy_reg_pointer (rtx to, rtx from)\n     mark_reg_pointer (to, REGNO_POINTER_ALIGN (REGNO (from)));\n }\n \n-/* Return nonzero only if OP is a register of mode MODE,\n-   or CONST0_RTX.  */\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  return (op == CONST0_RTX (mode) || register_operand (op, mode));\n-}\n-\n-/* Return nonzero if OP is suitable for use in a call to a named\n-   function.\n-\n-   For 2.5 try to eliminate either call_operand_address or\n-   function_label_operand, they perform very similar functions.  */\n-int\n-call_operand_address (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_MODE (op) == word_mode\n-\t  && CONSTANT_P (op) && ! TARGET_PORTABLE_RUNTIME);\n-}\n-\n /* Return 1 if X contains a symbolic expression.  We know these\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */\n@@ -584,95 +563,6 @@ symbolic_expression_p (rtx x)\n   return (symbolic_operand (x, VOIDmode));\n }\n \n-int\n-symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return truth value of statement that OP is a symbolic memory\n-   operand of mode MODE.  */\n-\n-int\n-symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n-}\n-\n-/* Return 1 if the operand is either a register, zero, or a memory operand\n-   that is not symbolic.  */\n-\n-int\n-reg_or_0_or_nonsymb_mem_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (op == CONST0_RTX (mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating move insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (op, 0), 0))\n-      && REG_P (XEXP (XEXP (op, 0), 1)))\n-    return 0;\n-\n-  return (!symbolic_memory_operand (op, mode)\n-\t  && memory_address_p (mode, XEXP (op, 0)));\n-}\n-\n-/* Return 1 if the operand is a register operand or a non-symbolic memory\n-   operand after reload.  This predicate is used for branch patterns that\n-   internally handle register reloading.  We need to accept non-symbolic\n-   memory operands after reload to ensure that the pattern is still valid\n-   if reload didn't find a hard register for the operand.  */\n-\n-int\n-reg_before_reload_operand (rtx op, enum machine_mode mode)\n-{\n-  /* Don't accept a SUBREG since it will need a reload.  */\n-  if (GET_CODE (op) == SUBREG)\n-    return 0;\n-\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (reload_completed\n-      && memory_operand (op, mode)\n-      && !symbolic_memory_operand (op, mode))\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Accept any constant that can be moved in one instruction into a\n    general register.  */\n int\n@@ -683,198 +573,7 @@ cint_ok_for_move (HOST_WIDE_INT intval)\n \t  || CONST_OK_FOR_LETTER_P (intval, 'N')\n \t  || CONST_OK_FOR_LETTER_P (intval, 'K'));\n }\n-\n-/* Return 1 iff OP is an indexed memory operand.  */\n-int\n-indexed_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-\n-  /* Before reload, a (SUBREG (MEM...)) forces reloading into a register.  */\n-  if (reload_completed && GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  return (memory_address_p (mode, op) && IS_INDEX_ADDR_P (op));\n-}\n-\n-/* Accept anything that can be used as a destination operand for a\n-   move instruction.  We don't accept indexed memory operands since\n-   they are supported only for floating point stores.  */\n-int\n-move_dest_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  return (memory_address_p (mode, op)\n-\t  && !IS_INDEX_ADDR_P (op)\n-\t  && !IS_LO_SUM_DLT_ADDR_P (op));\n-}\n-\n-/* Accept anything that can be used as a source operand for a move\n-   instruction.  */\n-int\n-move_src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return cint_ok_for_move (INTVAL (op));\n-\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating move insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (op, 0), 0))\n-      && REG_P (XEXP (XEXP (op, 0), 1)))\n-    return 0;\n-\n-  return memory_address_p (mode, XEXP (op, 0));\n-}\n-\n-/* Accept anything that can be used as the source operand for a prefetch\n-   instruction with a cache-control completer.  */\n-int\n-prefetch_cc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  /* We must reject virtual registers as we don't allow REG+D.  */\n-  if (op == virtual_incoming_args_rtx\n-      || op == virtual_stack_vars_rtx\n-      || op == virtual_stack_dynamic_rtx\n-      || op == virtual_outgoing_args_rtx\n-      || op == virtual_cfa_rtx)\n-    return 0;\n-\n-  if (!REG_P (op) && !IS_INDEX_ADDR_P (op))\n-    return 0;\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating prefetch insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (op) == PLUS\n-      && REG_P (XEXP (op, 0)))\n-    return 0;\n-\n-  return memory_address_p (mode, op);\n-}\n-\n-/* Accept anything that can be used as the source operand for a prefetch\n-   instruction with no cache-control completer.  */\n-int\n-prefetch_nocc_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  /* Until problems with management of the REG_POINTER flag are resolved,\n-     we need to delay creating prefetch insns with unscaled indexed addresses\n-     until CSE is not expected.  */\n-  if (!TARGET_NO_SPACE_REGS\n-      && !cse_not_expected\n-      && GET_CODE (op) == PLUS\n-      && REG_P (XEXP (op, 0))\n-      && REG_P (XEXP (op, 1)))\n-    return 0;\n-\n-  return memory_address_p (mode, op);\n-}\n-\n-/* Accept REG and any CONST_INT that can be moved in one instruction into a\n-   general register.  */\n-int\n-reg_or_cint_move_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  return (GET_CODE (op) == CONST_INT && cint_ok_for_move (INTVAL (op)));\n-}\n-\n-int\n-pic_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (!flag_pic)\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF:\n-      return 1;\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return (GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n-    default:\n-      return 0;\n-    }\n-}\n-\n-int\n-fp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return reg_renumber && FP_REG_P (op);\n-}\n-\n \f\n-\n-/* Return truth value of whether OP can be used as an operand in a\n-   three operand arithmetic insn that accepts registers of mode MODE\n-   or 14-bit signed integers.  */\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && INT_14_BITS (op)));\n-}\n-\n-/* Return truth value of whether OP can be used as an operand in a\n-   three operand arithmetic insn that accepts registers of mode MODE\n-   or 11-bit signed integers.  */\n-int\n-arith11_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n-}\n-\n /* Return truth value of whether OP can be used as an operand in a\n    adddi3 insn.  */\n int\n@@ -885,94 +584,6 @@ adddi3_operand (rtx op, enum machine_mode mode)\n \t      && (TARGET_64BIT ? INT_14_BITS (op) : INT_11_BITS (op))));\n }\n \n-/* A constant integer suitable for use in a PRE_MODIFY memory\n-   reference.  */\n-int\n-pre_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10);\n-}\n-\n-/* A constant integer suitable for use in a POST_MODIFY memory\n-   reference.  */\n-int\n-post_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) < 0x2000 && INTVAL (op) >= -0x10);\n-}\n-\n-int\n-arith_double_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && GET_MODE (op) == mode\n-\t      && VAL_14_BITS_P (CONST_DOUBLE_LOW (op))\n-\t      && ((CONST_DOUBLE_HIGH (op) >= 0)\n-\t\t  == ((CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in three-address insns, or\n-   is an integer register.  */\n-\n-int\n-ireg_or_int5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ((GET_CODE (op) == CONST_INT && INT_5_BITS (op))\n-\t  || (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32));\n-}\n-\n-/* Return nonzero if OP is an integer register, else return zero.  */\n-int\n-ireg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32);\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in three-address insns.  */\n-\n-int\n-int5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && INT_5_BITS (op));\n-}\n-\n-int\n-uint5_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && INT_U5_BITS (op));\n-}\n-\n-int\n-int11_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n-}\n-\n-int\n-uint32_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-#if HOST_BITS_PER_WIDE_INT > 32\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= 0 && INTVAL (op) < (HOST_WIDE_INT) 1 << 32));\n-#else\n-  return (GET_CODE (op) == CONST_INT\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0));\n-#endif\n-}\n-\n-int\n-arith5_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode) || int5_operand (op, mode);\n-}\n-\n /* True iff zdepi can be used to generate this CONST_INT.\n    zdepi first sign extends a 5 bit signed number to a given field\n    length, then places this field anywhere in a zero.  */\n@@ -1002,59 +613,13 @@ and_mask_p (unsigned HOST_WIDE_INT mask)\n   return (mask & (mask - 1)) == 0;\n }\n \n-/* True iff depi or extru can be used to compute (reg & OP).  */\n-int\n-and_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && and_mask_p (INTVAL (op))));\n-}\n-\n /* True iff depi can be used to compute (reg | MASK).  */\n int\n ior_mask_p (unsigned HOST_WIDE_INT mask)\n {\n   mask += mask & -mask;\n   return (mask & (mask - 1)) == 0;\n }\n-\n-/* True iff depi can be used to compute (reg | OP).  */\n-int\n-ior_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op)));\n-}\n-\n-int\n-lhs_lshift_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode) || lhs_lshift_cint_operand (op, mode);\n-}\n-\n-/* True iff OP is a CONST_INT of the forms 0...0xxxx or 0...01...1xxxx.\n-   Such values can be the left hand side x in (x << r), using the zvdepi\n-   instruction.  */\n-int\n-lhs_lshift_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  unsigned HOST_WIDE_INT x;\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  x = INTVAL (op) >> 4;\n-  return (x & (x + 1)) == 0;\n-}\n-\n-int\n-arith32_operand (rtx op, enum machine_mode mode)\n-{\n-  return register_operand (op, mode) || GET_CODE (op) == CONST_INT;\n-}\n-\n-int\n-pc_or_label_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == PC || GET_CODE (op) == LABEL_REF);\n-}\n \f\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n@@ -5741,24 +5306,14 @@ output_mul_insn (int unsignedp ATTRIBUTE_UNUSED, rtx insn)\n /* Emit the rtl for doing a division by a constant.  */\n \n /* Do magic division millicodes exist for this value? */\n-static const int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0,\n-\t\t\t\t 1, 1};\n+const int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1};\n \n /* We'll use an array to keep track of the magic millicodes and\n    whether or not we've used them already. [n][0] is signed, [n][1] is\n    unsigned.  */\n \n static int div_milli[16][2];\n \n-int\n-div_operand (rtx op, enum machine_mode mode)\n-{\n-  return (mode == SImode\n-\t  && ((GET_CODE (op) == REG && REGNO (op) == 25)\n-\t      || (GET_CODE (op) == CONST_INT && INTVAL (op) > 0\n-\t\t  && INTVAL (op) < 16 && magic_milli[INTVAL (op)])));\n-}\n-\n int\n emit_hpdiv_const (rtx *operands, int unsignedp)\n {\n@@ -8440,16 +7995,9 @@ fmpysuboperands (rtx *operands)\n   return 1;\n }\n \n-int\n-plus_xor_ior_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == PLUS || GET_CODE (op) == XOR\n-\t  || GET_CODE (op) == IOR);\n-}\n-\n /* Return 1 if the given constant is 2, 4, or 8.  These are the valid\n    constants for shadd instructions.  */\n-static int\n+int\n shadd_constant_p (int val)\n {\n   if (val == 2 || val == 4 || val == 8)\n@@ -8458,14 +8006,6 @@ shadd_constant_p (int val)\n     return 0;\n }\n \n-/* Return 1 if OP is a CONST_INT with the value 2, 4, or 8.  These are\n-   the valid constant for shadd instructions.  */\n-int\n-shadd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && shadd_constant_p (INTVAL (op)));\n-}\n-\n /* Return 1 if OP is valid as a base or index register in a\n    REG+REG address.  */\n \n@@ -8528,14 +8068,6 @@ eq_neq_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n \n-/* Return 1 if OP is an operator suitable for use in a movb instruction.  */\n-int\n-movb_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == EQ || GET_CODE (op) == NE\n-\t  || GET_CODE (op) == LT || GET_CODE (op) == GE);\n-}\n-\n /* Return 1 if INSN is in the delay slot of a call instruction.  */\n int\n jump_in_call_delay (rtx insn)\n@@ -9367,23 +8899,6 @@ pa_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n \n-/* Return 1 if this is a comparison operator.  This allows the use of\n-   MATCH_OPERATOR to recognize all the branch insns.  */\n-\n-int\n-cmpib_comparison_operator (rtx op, enum machine_mode mode)\n-{\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-          && (GET_CODE (op) == EQ\n-\t      || GET_CODE (op) == NE\n-\t      || GET_CODE (op) == GT\n-\t      || GET_CODE (op) == GTU\n-\t      || GET_CODE (op) == GE\n-\t      || GET_CODE (op) == LT\n-\t      || GET_CODE (op) == LE\n-\t      || GET_CODE (op) == LEU));\n-}\n-\n /* Return a string to output before text in the current function.\n \n    This function is only used with SOM.  Because we don't support"}, {"sha": "26201f80291f177d1690bcf1c03ace88b2914d50", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=c9a881907525e22505d63851ccda7e15ebbee104", "patch": "@@ -2128,49 +2128,6 @@ forget_section (void)\t\t\t\t\t\t\t\\\n /* The number of Pmode words for the setjmp buffer.  */\n #define JMP_BUF_SIZE 50\n \n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\\\n-  {\"call_operand_address\", {LABEL_REF, SYMBOL_REF, CONST_INT,\t\t\\\n-\t\t\t    CONST_DOUBLE, CONST, HIGH}},\t\t \\\n-  {\"indexed_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n-  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n-  {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n-  {\"reg_before_reload_operand\", {REG, MEM}},\t\t\t\t\\\n-  {\"reg_or_0_or_nonsymb_mem_operand\", {SUBREG, REG, MEM, CONST_INT,\t\\\n-\t\t\t\t       CONST_DOUBLE}},\t\t\t\\\n-  {\"move_dest_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"move_src_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n-  {\"prefetch_cc_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"prefetch_nocc_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"reg_or_cint_move_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"pic_label_operand\", {LABEL_REF, CONST}},\t\t\t\t\\\n-  {\"fp_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"arith11_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"pre_cint_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"post_cint_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"arith_double_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n-  {\"ireg_or_int5_operand\", {CONST_INT, REG}},\t\t\t\t\\\n-  {\"int5_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"uint5_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"int11_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"uint32_operand\", {CONST_INT,\t\t\t\t\t\\\n-   HOST_BITS_PER_WIDE_INT > 32 ? 0 : CONST_DOUBLE}},\t\t\t\\\n-  {\"arith5_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"ior_operand\", {CONST_INT}},\t\t\t\t\t\t\\\n-  {\"lhs_lshift_cint_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"lhs_lshift_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"arith32_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"pc_or_label_operand\", {PC, LABEL_REF}},\t\t\t\t\\\n-  {\"plus_xor_ior_operator\", {PLUS, XOR, IOR}},\t\t\t\t\\\n-  {\"shadd_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"div_operand\", {REG, CONST_INT}},\t\t\t\t\t\\\n-  {\"ireg_operand\", {REG}},\t\t\t\t\t\t\\\n-  {\"cmpib_comparison_operator\", {EQ, NE, LT, LE, LEU,\t\t\t\\\n-   GT, GTU, GE}},\t\t\t\t\t\t\t\\\n-  {\"movb_comparison_operator\", {EQ, NE, LT, GE}},\n-\n /* We need a libcall to canonicalize function pointers on TARGET_ELF32.  */\n #define CANONICALIZE_FUNCPTR_FOR_COMPARE_LIBCALL \\\n   \"__canonicalize_funcptr_for_compare\""}, {"sha": "6b8c77b071c460c49f06aee25502b621aa1a02e4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=c9a881907525e22505d63851ccda7e15ebbee104", "patch": "@@ -561,7 +561,7 @@\n    (eq_attr \"cpu\" \"8000\"))\n  \"inm_8000,fdivsqrt_8000*6,rnm_8000\")\n \n-\n+(include \"predicates.md\")\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation."}, {"sha": "23f62e3aacdbfe4ac3d27e3dd93f72d7a9bb4fe4", "filename": "gcc/config/pa/predicates.md", "status": "added", "additions": 550, "deletions": 0, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9a881907525e22505d63851ccda7e15ebbee104/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=c9a881907525e22505d63851ccda7e15ebbee104", "patch": "@@ -0,0 +1,550 @@\n+;; Predicate definitions for HP PA-RISC.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return nonzero only if OP is a register of mode MODE, or\n+;; CONST0_RTX.\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (match_code \"subreg,reg,const_int,const_double\")\n+{\n+  return (op == CONST0_RTX (mode) || register_operand (op, mode));\n+})\n+\n+;; Return nonzero if OP is suitable for use in a call to a named\n+;; function.\n+;;\n+;; For 2.5 try to eliminate either call_operand_address or\n+;; function_label_operand, they perform very similar functions.\n+\n+(define_predicate \"call_operand_address\"\n+  (match_code \"label_ref,symbol_ref,const_int,const_double,const,high\")\n+{\n+  return (GET_MODE (op) == word_mode\n+\t  && CONSTANT_P (op) && ! TARGET_PORTABLE_RUNTIME);\n+})\n+\n+;; Return 1 iff OP is an indexed memory operand.\n+\n+(define_predicate \"indexed_memory_operand\"\n+  (match_code \"subreg,mem\")\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  /* Before reload, a (SUBREG (MEM...)) forces reloading into a register.  */\n+  if (reload_completed && GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  return (memory_address_p (mode, op) && IS_INDEX_ADDR_P (op));\n+})\n+\n+;; TODO: Add a comment.\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; Return truth value of statement that OP is a symbolic memory\n+;; operand of mode MODE.\n+\n+(define_predicate \"symbolic_memory_operand\"\n+  (match_code \"subreg,mem\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n+})\n+\n+;; Return 1 if the operand is a register operand or a non-symbolic\n+;; memory operand after reload.  This predicate is used for branch\n+;; patterns that internally handle register reloading.  We need to\n+;; accept non-symbolic memory operands after reload to ensure that the\n+;; pattern is still valid if reload didn't find a hard register for\n+;; the operand.\n+\n+(define_predicate \"reg_before_reload_operand\"\n+  (match_code \"reg,mem\")\n+{\n+  /* Don't accept a SUBREG since it will need a reload.  */\n+  if (GET_CODE (op) == SUBREG)\n+    return 0;\n+\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (reload_completed\n+      && memory_operand (op, mode)\n+      && !symbolic_memory_operand (op, mode))\n+    return 1;\n+\n+  return 0;\n+})\n+\n+;; Return 1 if the operand is either a register, zero, or a memory\n+;; operand that is not symbolic.\n+\n+(define_predicate \"reg_or_0_or_nonsymb_mem_operand\"\n+  (match_code \"subreg,reg,mem,const_int,const_double\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (op == CONST0_RTX (mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating move insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (op, 0), 0))\n+      && REG_P (XEXP (XEXP (op, 0), 1)))\n+    return 0;\n+\n+  return (!symbolic_memory_operand (op, mode)\n+\t  && memory_address_p (mode, XEXP (op, 0)));\n+})\n+\n+;; Accept anything that can be used as a destination operand for a\n+;; move instruction.  We don't accept indexed memory operands since\n+;; they are supported only for floating point stores.\n+\n+(define_predicate \"move_dest_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM || symbolic_memory_operand (op, mode))\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  return (memory_address_p (mode, op)\n+\t  && !IS_INDEX_ADDR_P (op)\n+\t  && !IS_LO_SUM_DLT_ADDR_P (op));\n+})\n+\n+;; Accept anything that can be used as a source operand for a move\n+;; instruction.\n+\n+(define_predicate \"move_src_operand\"\n+  (match_code \"subreg,reg,const_int,mem\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return cint_ok_for_move (INTVAL (op));\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating move insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (XEXP (op, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (op, 0), 0))\n+      && REG_P (XEXP (XEXP (op, 0), 1)))\n+    return 0;\n+\n+  return memory_address_p (mode, XEXP (op, 0));\n+})\n+\n+;; Accept anything that can be used as the source operand for a\n+;; prefetch instruction with a cache-control completer.\n+\n+(define_predicate \"prefetch_cc_operand\"\n+  (match_code \"mem\")\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  /* We must reject virtual registers as we don't allow REG+D.  */\n+  if (op == virtual_incoming_args_rtx\n+      || op == virtual_stack_vars_rtx\n+      || op == virtual_stack_dynamic_rtx\n+      || op == virtual_outgoing_args_rtx\n+      || op == virtual_cfa_rtx)\n+    return 0;\n+\n+  if (!REG_P (op) && !IS_INDEX_ADDR_P (op))\n+    return 0;\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating prefetch insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (op) == PLUS\n+      && REG_P (XEXP (op, 0)))\n+    return 0;\n+\n+  return memory_address_p (mode, op);\n+})\n+\n+;; Accept anything that can be used as the source operand for a\n+;; prefetch instruction with no cache-control completer.\n+\n+(define_predicate \"prefetch_nocc_operand\"\n+  (match_code \"mem\")\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  /* Until problems with management of the REG_POINTER flag are resolved,\n+     we need to delay creating prefetch insns with unscaled indexed addresses\n+     until CSE is not expected.  */\n+  if (!TARGET_NO_SPACE_REGS\n+      && !cse_not_expected\n+      && GET_CODE (op) == PLUS\n+      && REG_P (XEXP (op, 0))\n+      && REG_P (XEXP (op, 1)))\n+    return 0;\n+\n+  return memory_address_p (mode, op);\n+})\n+\n+;; Accept REG and any CONST_INT that can be moved in one instruction\n+;; into a general register.\n+\n+(define_predicate \"reg_or_cint_move_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  return (GET_CODE (op) == CONST_INT && cint_ok_for_move (INTVAL (op)));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"pic_label_operand\"\n+  (match_code \"label_ref,const\")\n+{\n+  if (!flag_pic)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return (GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"fp_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  return reg_renumber && FP_REG_P (op);\n+})\n+\n+;; Return truth value of whether OP can be used as an operand in a\n+;; three operand arithmetic insn that accepts registers of mode MODE\n+;; or 14-bit signed integers.\n+\n+(define_predicate \"arith_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && INT_14_BITS (op)));\n+})\n+\n+;; Return truth value of whether OP can be used as an operand in a\n+;; three operand arithmetic insn that accepts registers of mode MODE\n+;; or 11-bit signed integers.\n+\n+(define_predicate \"arith11_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n+})\n+\n+;; A constant integer suitable for use in a PRE_MODIFY memory\n+;; reference.\n+\n+(define_predicate \"pre_cint_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10);\n+})\n+\n+;; A constant integer suitable for use in a POST_MODIFY memory\n+;; reference.\n+\n+(define_predicate \"post_cint_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) < 0x2000 && INTVAL (op) >= -0x10);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"arith_double_operand\"\n+  (match_code \"subreg,reg,const_double\")\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && GET_MODE (op) == mode\n+\t      && VAL_14_BITS_P (CONST_DOUBLE_LOW (op))\n+\t      && ((CONST_DOUBLE_HIGH (op) >= 0)\n+\t\t  == ((CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n+})\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns, or is an\n+;; integer register.\n+\n+(define_predicate \"ireg_or_int5_operand\"\n+  (match_code \"const_int,reg\")\n+{\n+  return ((GET_CODE (op) == CONST_INT && INT_5_BITS (op))\n+\t  || (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32));\n+})\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns.\n+\n+(define_predicate \"int5_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && INT_5_BITS (op));\n+})\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns.\n+\n+(define_predicate \"uint5_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && INT_U5_BITS (op));\n+})\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns.\n+\n+(define_predicate \"int11_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n+})\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns.\n+\n+(define_predicate \"uint32_operand\"\n+  (match_code \"const_int,const_double\")\n+{\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  /* All allowed constants will fit a CONST_INT.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) >= 0 && INTVAL (op) < (HOST_WIDE_INT) 1 << 32));\n+#else\n+  return (GET_CODE (op) == CONST_INT\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && CONST_DOUBLE_HIGH (op) == 0));\n+#endif\n+})\n+\n+;; Return truth value of whether OP is an integer which fits the range\n+;; constraining immediate operands in three-address insns.\n+\n+(define_predicate \"arith5_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  return register_operand (op, mode) || int5_operand (op, mode);\n+})\n+\n+;; True iff depi or extru can be used to compute (reg & OP).\n+\n+(define_predicate \"and_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && and_mask_p (INTVAL (op))));\n+})\n+\n+;; True iff depi can be used to compute (reg | OP).\n+\n+(define_predicate \"ior_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && ior_mask_p (INTVAL (op)));\n+})\n+\n+;; True iff OP is a CONST_INT of the forms 0...0xxxx or\n+;; 0...01...1xxxx. Such values can be the left hand side x in (x <<\n+;; r), using the zvdepi instruction.\n+\n+(define_predicate \"lhs_lshift_cint_operand\"\n+  (match_code \"const_int\")\n+{\n+  unsigned HOST_WIDE_INT x;\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+  x = INTVAL (op) >> 4;\n+  return (x & (x + 1)) == 0;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"lhs_lshift_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  return register_operand (op, mode) || lhs_lshift_cint_operand (op, mode);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"arith32_operand\"\n+  (match_code \"subreg,reg,const_int\")\n+{\n+  return register_operand (op, mode) || GET_CODE (op) == CONST_INT;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"pc_or_label_operand\"\n+  (match_code \"pc,label_ref\")\n+{\n+  return (GET_CODE (op) == PC || GET_CODE (op) == LABEL_REF);\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"plus_xor_ior_operator\"\n+  (match_code \"plus,xor,ior\")\n+{\n+  return (GET_CODE (op) == PLUS || GET_CODE (op) == XOR\n+\t  || GET_CODE (op) == IOR);\n+})\n+\n+;; Return 1 if OP is a CONST_INT with the value 2, 4, or 8.  These are\n+;; the valid constant for shadd instructions.\n+\n+(define_predicate \"shadd_operand\"\n+  (match_code \"const_int\")\n+{\n+  return (GET_CODE (op) == CONST_INT && shadd_constant_p (INTVAL (op)));\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"div_operand\"\n+  (match_code \"reg,const_int\")\n+{\n+  return (mode == SImode\n+\t  && ((GET_CODE (op) == REG && REGNO (op) == 25)\n+\t      || (GET_CODE (op) == CONST_INT && INTVAL (op) > 0\n+\t\t  && INTVAL (op) < 16 && magic_milli[INTVAL (op)])));\n+})\n+\n+;; Return nonzero if OP is an integer register, else return zero.\n+\n+(define_predicate \"ireg_operand\"\n+  (match_code \"reg\")\n+{\n+  return (GET_CODE (op) == REG && REGNO (op) > 0 && REGNO (op) < 32);\n+})\n+\n+;; Return 1 if this is a comparison operator.  This allows the use of\n+;; MATCH_OPERATOR to recognize all the branch insns.\n+\n+(define_predicate \"cmpib_comparison_operator\"\n+  (match_code \"eq,ne,lt,le,leu,gt,gtu,ge\")\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+          && (GET_CODE (op) == EQ\n+\t      || GET_CODE (op) == NE\n+\t      || GET_CODE (op) == GT\n+\t      || GET_CODE (op) == GTU\n+\t      || GET_CODE (op) == GE\n+\t      || GET_CODE (op) == LT\n+\t      || GET_CODE (op) == LE\n+\t      || GET_CODE (op) == LEU));\n+})\n+\n+;; Return 1 if OP is an operator suitable for use in a movb\n+;; instruction.\n+\n+(define_predicate \"movb_comparison_operator\"\n+  (match_code \"eq,ne,lt,ge\")\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE\n+\t  || GET_CODE (op) == LT || GET_CODE (op) == GE);\n+})"}]}