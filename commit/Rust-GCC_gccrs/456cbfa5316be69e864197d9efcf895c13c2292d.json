{"sha": "456cbfa5316be69e864197d9efcf895c13c2292d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU2Y2JmYTUzMTZiZTY5ZTg2NDE5N2Q5ZWZjZjg5NWMxM2MyMjkyZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T10:22:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T10:22:31Z"}, "message": "[multiple changes]\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb: Minor reformatting.\n\n2012-10-01  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Suppress tag\n\tassignment for initializations that are aggregates.\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Compare_Minimize_Eliminate_Overflow):\n\tNew procedure.\n\nFrom-SVN: r191914", "tree": {"sha": "6a42ae9934c26024c06fb4c1708cac0a0ece4c49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a42ae9934c26024c06fb4c1708cac0a0ece4c49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/456cbfa5316be69e864197d9efcf895c13c2292d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456cbfa5316be69e864197d9efcf895c13c2292d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/456cbfa5316be69e864197d9efcf895c13c2292d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456cbfa5316be69e864197d9efcf895c13c2292d/comments", "author": null, "committer": null, "parents": [{"sha": "d79059a3c4ed8e3c0e6a30e7baa52c8df550a791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79059a3c4ed8e3c0e6a30e7baa52c8df550a791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79059a3c4ed8e3c0e6a30e7baa52c8df550a791"}], "stats": {"total": 327, "additions": 325, "deletions": 2}, "files": [{"sha": "ddc3f4d6181fbabe3794061062637e4c022f5c3c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=456cbfa5316be69e864197d9efcf895c13c2292d", "patch": "@@ -1,3 +1,17 @@\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb: Minor reformatting.\n+\n+2012-10-01  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Suppress tag\n+\tassignment for initializations that are aggregates.\n+\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Compare_Minimize_Eliminate_Overflow):\n+\tNew procedure.\n+\n 2012-10-01  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb (Minimize_Eliminate_Checks): Changes from testing."}, {"sha": "06d378647124b183257f30821b15cc0ab15f4b23", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=456cbfa5316be69e864197d9efcf895c13c2292d", "patch": "@@ -1114,12 +1114,12 @@ package body Checks is\n \n       elsif Is_RTE (Etype (Op), RE_Bignum) then\n \n-         --  We need a sequence that looks like\n+         --  We need a sequence that looks like:\n \n          --    Rnn : Result_Type;\n \n          --    declare\n-         --       M   : Mark_Id := SS_Mark;\n+         --       M : Mark_Id := SS_Mark;\n          --    begin\n          --       Rnn := Long_Long_Integer'Base (From_Bignum (Op));\n          --       SS_Release (M);"}, {"sha": "d7427d9d5237f810fe04077b1d0e6873b61602e0", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=456cbfa5316be69e864197d9efcf895c13c2292d", "patch": "@@ -5393,6 +5393,8 @@ package body Exp_Ch3 is\n               and then not Is_CPP_Class (Typ)\n               and then Tagged_Type_Expansion\n               and then Nkind (Expr) /= N_Aggregate\n+              and then (Nkind (Expr) /= N_Qualified_Expression\n+                         or else Nkind (Expression (Expr)) /= N_Aggregate)\n             then\n                declare\n                   Full_Typ : constant Entity_Id := Underlying_Type (Typ);"}, {"sha": "9d22e9cbc9873ce3ecffe91e5b8df0ef58d300de", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/456cbfa5316be69e864197d9efcf895c13c2292d/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=456cbfa5316be69e864197d9efcf895c13c2292d", "patch": "@@ -140,6 +140,10 @@ package body Exp_Ch4 is\n    procedure Expand_Short_Circuit_Operator (N : Node_Id);\n    --  Common expansion processing for short-circuit boolean operators\n \n+   procedure Expand_Compare_Minimize_Eliminate_Overflow (N : Node_Id);\n+   --  Deal with comparison in Minimize/Eliminate overflow mode. This is where\n+   --  we allow comparison of \"out of range\" values.\n+\n    function Expand_Composite_Equality\n      (Nod    : Node_Id;\n       Typ    : Entity_Id;\n@@ -2276,6 +2280,237 @@ package body Exp_Ch4 is\n       end;\n    end Expand_Boolean_Operator;\n \n+   ------------------------------------------------\n+   -- Expand_Compare_Minimize_Eliminate_Overflow --\n+   ------------------------------------------------\n+\n+   procedure Expand_Compare_Minimize_Eliminate_Overflow (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Llo, Lhi : Uint;\n+      Rlo, Rhi : Uint;\n+\n+      LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n+      --  Entity for Long_Long_Integer'Base\n+\n+      Check : constant Overflow_Check_Type := Overflow_Check_Mode (Empty);\n+      --  Current checking mode\n+\n+      procedure Set_True;\n+      procedure Set_False;\n+      --  These procedures rewrite N with an occurrence of Standard_True or\n+      --  Standard_False, and then makes a call to Warn_On_Known_Condition.\n+\n+      ---------------\n+      -- Set_False --\n+      ---------------\n+\n+      procedure Set_False is\n+      begin\n+         Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n+         Warn_On_Known_Condition (N);\n+      end Set_False;\n+\n+      --------------\n+      -- Set_True --\n+      --------------\n+\n+      procedure Set_True is\n+      begin\n+         Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n+         Warn_On_Known_Condition (N);\n+      end Set_True;\n+\n+   --  Start of processing for Expand_Compare_Minimize_Eliminate_Overflow\n+\n+   begin\n+      --  Nothing to do unless we have a comparison operator with operands\n+      --  that are signed integer types, and we are operating in either\n+      --  MINIMIZED or ELIMINATED overflow checking mode.\n+\n+      if Nkind (N) not in N_Op_Compare\n+        or else Check not in Minimized_Or_Eliminated\n+        or else not Is_Signed_Integer_Type (Etype (Left_Opnd (N)))\n+      then\n+         return;\n+      end if;\n+\n+      --  OK, this is the case we are interested in. First step is to process\n+      --  our operands using the Minimize_Eliminate circuitry which applies\n+      --  this processing to the two operand subtrees.\n+\n+      Minimize_Eliminate_Overflow_Checks (Left_Opnd (N),  Llo, Lhi);\n+      Minimize_Eliminate_Overflow_Checks (Right_Opnd (N), Rlo, Rhi);\n+\n+      --  See if the range information decides the result of the comparison\n+\n+      case N_Op_Compare (Nkind (N)) is\n+         when N_Op_Eq =>\n+            if Llo = Lhi and then Rlo = Rhi and then Llo = Rlo then\n+               Set_True;\n+            elsif Llo > Rhi or else Rlo > Lhi then\n+               Set_False;\n+            end if;\n+\n+         when N_Op_Ge =>\n+            if Llo >= Rhi then\n+               Set_True;\n+            elsif Lhi < Rlo then\n+               Set_False;\n+            end if;\n+\n+         when N_Op_Gt =>\n+            if Llo > Rhi then\n+               Set_True;\n+            elsif Lhi <= Rlo then\n+               Set_False;\n+            end if;\n+\n+         when N_Op_Le =>\n+            if Llo > Rhi then\n+               Set_False;\n+            elsif Lhi <= Rlo then\n+               Set_True;\n+            end if;\n+\n+         when N_Op_Lt =>\n+            if Llo >= Rhi then\n+               Set_True;\n+            elsif Lhi < Rlo then\n+               Set_False;\n+            end if;\n+\n+         when N_Op_Ne =>\n+            if Llo = Lhi and then Rlo = Rhi and then Llo = Rlo then\n+               Set_True;\n+            elsif Llo > Rhi or else Rlo > Lhi then\n+               Set_False;\n+            end if;\n+      end case;\n+\n+      --  All done if we did the rewrite\n+\n+      if Nkind (N) not in N_Op_Compare then\n+         return;\n+      end if;\n+\n+      --  Otherwise, time to do the comparison\n+\n+      declare\n+         Ltype : constant Entity_Id := Etype (Left_Opnd (N));\n+         Rtype : constant Entity_Id := Etype (Right_Opnd (N));\n+\n+      begin\n+         --  If the two operands have the same signed integer type we are\n+         --  all set, nothing more to do. This is the case where either\n+         --  both operands were unchanged, or we rewrote both of them to\n+         --  be Long_Long_Integer.\n+\n+         --  Note: Entity for the comparison may be wrong, but it's not worth\n+         --  the effort to change it, since the back end does not use it.\n+\n+         if Is_Signed_Integer_Type (Ltype)\n+           and then Base_Type (Ltype) = Base_Type (Rtype)\n+         then\n+            return;\n+\n+         --  Here if bignums are involved (can only happen in ELIMINATED mode)\n+\n+         elsif Is_RTE (Ltype, RE_Bignum) or else Is_RTE (Rtype, RE_Bignum) then\n+            declare\n+               Left  : Node_Id := Left_Opnd (N);\n+               Right : Node_Id := Right_Opnd (N);\n+               --  Bignum references for left and right operands\n+\n+            begin\n+               if not Is_RTE (Ltype, RE_Bignum) then\n+                  Left := Convert_To_Bignum (Left);\n+               elsif not Is_RTE (Rtype, RE_Bignum) then\n+                  Right := Convert_To_Bignum (Right);\n+               end if;\n+\n+               --  We need a sequence that looks like\n+\n+               --    Bnn : Boolean;\n+\n+               --    declare\n+               --       M : Mark_Id := SS_Mark;\n+               --    begin\n+               --       Bnn := Big_xx (Left, Right); (xx = EQ, NT etc)\n+               --       SS_Release (M);\n+               --    end;\n+\n+               --  This block is inserted (using Insert_Actions), and then the\n+               --  node is replaced with a reference to Bnn.\n+\n+               declare\n+                  Blk : constant Node_Id  := Make_Bignum_Block (Loc);\n+                  Bnn : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n+                  Ent : RE_Id;\n+\n+               begin\n+                  case N_Op_Compare (Nkind (N)) is\n+                     when N_Op_Eq => Ent := RE_Big_EQ;\n+                     when N_Op_Ge => Ent := RE_Big_GE;\n+                     when N_Op_Gt => Ent := RE_Big_GT;\n+                     when N_Op_Le => Ent := RE_Big_LE;\n+                     when N_Op_Lt => Ent := RE_Big_LT;\n+                     when N_Op_Ne => Ent := RE_Big_NE;\n+                  end case;\n+\n+                  --  Insert assignment to Bnn\n+\n+                  Insert_Before\n+                    (First (Statements (Handled_Statement_Sequence (Blk))),\n+                     Make_Assignment_Statement (Loc,\n+                       Name       => New_Occurrence_Of (Bnn, Loc),\n+                       Expression =>\n+                         Make_Function_Call (Loc,\n+                           Name                   =>\n+                             New_Occurrence_Of (RTE (Ent), Loc),\n+                           Parameter_Associations => New_List (Left, Right))));\n+\n+                  --  Insert actions (declaration of Bnn and block)\n+\n+                  Insert_Actions (N, New_List (\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Bnn,\n+                      Object_Definition   =>\n+                        New_Occurrence_Of (Standard_Boolean, Loc)),\n+                    Blk));\n+\n+                  --  Rewrite node with reference to Bnn\n+\n+                  Rewrite (N, New_Occurrence_Of (Bnn, Loc));\n+                  Analyze_And_Resolve (N);\n+               end;\n+            end;\n+\n+         --  No bignums involved, but types are different, so we must have\n+         --  rewritten one of the operands as a Long_Long_Integer but not\n+         --  the other one.\n+\n+         --  If left operand is Long_Long_Integer, convert right operand\n+         --  and we are done (with a comparison of two Long_Long_Integers).\n+\n+         elsif Ltype = LLIB then\n+            Convert_To_And_Rewrite (LLIB, Right_Opnd (N));\n+            Analyze_And_Resolve (Right_Opnd (N), LLIB, Suppress => All_Checks);\n+            return;\n+\n+         --  If right operand is Long_Long_Integer, convert left operand\n+         --  and we are done (with a comparison of two Long_Long_Integers).\n+\n+         --  This is the only remaining possibility\n+\n+         else pragma Assert (Rtype = LLIB);\n+            Convert_To_And_Rewrite (LLIB, Left_Opnd (N));\n+            Analyze_And_Resolve (Left_Opnd (N), LLIB, Suppress => All_Checks);\n+            return;\n+         end if;\n+      end;\n+   end Expand_Compare_Minimize_Eliminate_Overflow;\n+\n    -------------------------------\n    -- Expand_Composite_Equality --\n    -------------------------------\n@@ -6367,6 +6602,8 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Deal with private types\n+\n       if Ekind (Typl) = E_Private_Type then\n          Typl := Underlying_Type (Typl);\n       elsif Ekind (Typl) = E_Private_Subtype then\n@@ -6385,6 +6622,15 @@ package body Exp_Ch4 is\n \n       Typl := Base_Type (Typl);\n \n+      --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n+      --  results in not having a comparison operation any more, we are done.\n+\n+      Expand_Compare_Minimize_Eliminate_Overflow (N);\n+\n+      if Nkind (N) /= N_Op_Eq then\n+         return;\n+      end if;\n+\n       --  Boolean types (requiring handling of non-standard case)\n \n       if Is_Boolean_Type (Typl) then\n@@ -6955,11 +7201,24 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n+      --  results in not having a comparison operation any more, we are done.\n+\n+      Expand_Compare_Minimize_Eliminate_Overflow (N);\n+\n+      if Nkind (N) /= N_Op_Ge then\n+         return;\n+      end if;\n+\n+      --  Array type case\n+\n       if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n \n+      --  Deal with boolean operands\n+\n       if Is_Boolean_Type (Typ1) then\n          Adjust_Condition (Op1);\n          Adjust_Condition (Op2);\n@@ -6992,11 +7251,24 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n+      --  results in not having a comparison operation any more, we are done.\n+\n+      Expand_Compare_Minimize_Eliminate_Overflow (N);\n+\n+      if Nkind (N) /= N_Op_Gt then\n+         return;\n+      end if;\n+\n+      --  Deal with array type operands\n+\n       if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n \n+      --  Deal with boolean type operands\n+\n       if Is_Boolean_Type (Typ1) then\n          Adjust_Condition (Op1);\n          Adjust_Condition (Op2);\n@@ -7029,11 +7301,24 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n+      --  results in not having a comparison operation any more, we are done.\n+\n+      Expand_Compare_Minimize_Eliminate_Overflow (N);\n+\n+      if Nkind (N) /= N_Op_Le then\n+         return;\n+      end if;\n+\n+      --  Deal with array type operands\n+\n       if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n \n+      --  Deal with Boolean type operands\n+\n       if Is_Boolean_Type (Typ1) then\n          Adjust_Condition (Op1);\n          Adjust_Condition (Op2);\n@@ -7066,11 +7351,24 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n+      --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n+      --  results in not having a comparison operation any more, we are done.\n+\n+      Expand_Compare_Minimize_Eliminate_Overflow (N);\n+\n+      if Nkind (N) /= N_Op_Lt then\n+         return;\n+      end if;\n+\n+      --  Deal with array type operands\n+\n       if Is_Array_Type (Typ1) then\n          Expand_Array_Comparison (N);\n          return;\n       end if;\n \n+      --  Deal with Boolean type operands\n+\n       if Is_Boolean_Type (Typ1) then\n          Adjust_Condition (Op1);\n          Adjust_Condition (Op2);\n@@ -7447,6 +7745,15 @@ package body Exp_Ch4 is\n       then\n          Binary_Op_Validity_Checks (N);\n \n+         --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if\n+         --  that results in not having a /= opertion any more, we are done.\n+\n+         Expand_Compare_Minimize_Eliminate_Overflow (N);\n+\n+         if Nkind (N) /= N_Op_Ne then\n+            return;\n+         end if;\n+\n          --  Boolean types (requiring handling of non-standard case)\n \n          if Is_Boolean_Type (Typ) then"}]}