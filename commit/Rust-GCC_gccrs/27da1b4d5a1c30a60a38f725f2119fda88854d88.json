{"sha": "27da1b4d5a1c30a60a38f725f2119fda88854d88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdkYTFiNGQ1YTFjMzBhNjBhMzhmNzI1ZjIxMTlmZGE4ODg1NGQ4OA==", "commit": {"author": {"name": "Mumit Khan", "email": "khan@xraylith.wisc.edu", "date": "1998-07-07T00:05:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-07-07T00:05:27Z"}, "message": "Support for dllimport and dllexport attributes for i386-pe.\n\n\t* tree.h (DECL_NON_ADDR_CONST_P): New accessor macro.\n\t(struct tree_decl): Add non_addr_const_p field.\n\t* tree.c (staticp): Use.\n\t* i386/cygwin32.h (CPP_PREDEFINES): Map __declspec(x) to GCC\n\tattributes.\n\t(SUBTARGET_SWITCHES): Switches to turn on/off dllimport|export\n\tattributes. Also accept -mwindows option.\n\t(VALID_MACHINE_DECL_ATTRIBUTE): New macro.\n\t(MERGE_MACHINE_DECL_ATTRIBUTE): New macro.\n\t(REDO_SECTION_INFO_P): New macro.\n\t(DRECTVE_SECTION_FUNCTION): New macro.\n\t(drectve_section): Cover function to implement above.\n\t(SWITCH_TO_SECTION_FUNCTION): New macro.\n\t(switch_to_section): Covert function to implement above.\n\t(EXTRA_SECTIONS): Add in_drectve.\n\t(EXTRA_SECTION_FUNCTIONS): Add in_drectve and switch_to_section.\n\t(ENCODE_SECTION_INFO): Delete old macro and redefine as a function.\n\t(STRIP_NAME_ENCODING): Handle new attributes.\n\t(ASM_OUTPUT_LABELREF): New macro.\n\t(ASM_OUTPUT_FUNCTION_NAME): New macro.\n\t(ASM_OUTPUT_COMMON): New macro.\n\t(ASM_OUTPUT_DECLARE_OBJECT_NAME): New macro.\n\t* i386/mingw32.h (CPP_PREDEFINES): Map __declspec(x) to GCC\n\tattributes.\n\t* i386/winnt.c (i386_pe_valid_decl_attribute_p): New function.\n\t(i386_pe_merge_decl_attributes): New function.\n\t(i386_pe_check_vtable_importexport): New function.\n\t(i386_pe_dllexport_p): New function.\n\t(i386_pe_dllimport_p): New function.\n\t(i386_pe_dllexport_name_p): New function.\n\t(i386_pe_dllimport_name_p): New function.\n\t(i386_pe_mark_dllexport): New function.\n\t(i386_pe_mark_dllimport): New function.\n\t(i386_pe_encode_section_info): New function.\n\t(i386_pe_unique_section): Strip encoding from name first.\n\nFrom-SVN: r20983", "tree": {"sha": "75c3f6b8a5b39fd43548abba6d1860adc4b7c3fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75c3f6b8a5b39fd43548abba6d1860adc4b7c3fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27da1b4d5a1c30a60a38f725f2119fda88854d88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27da1b4d5a1c30a60a38f725f2119fda88854d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27da1b4d5a1c30a60a38f725f2119fda88854d88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27da1b4d5a1c30a60a38f725f2119fda88854d88/comments", "author": null, "committer": null, "parents": [{"sha": "bceb30e77bd19db8debc5182b75018c169acd6ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bceb30e77bd19db8debc5182b75018c169acd6ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bceb30e77bd19db8debc5182b75018c169acd6ff"}], "stats": {"total": 645, "additions": 615, "deletions": 30}, "files": [{"sha": "d258618c837b12871ed51332a820f2a4fa6ce901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27da1b4d5a1c30a60a38f725f2119fda88854d88", "patch": "@@ -1,3 +1,46 @@\n+Tue Jul  7 01:03:03 1998  Mumit Khan <khan@xraylith.wisc.edu>\n+\n+\tSupport for dllimport and dllexport attributes for i386-pe.\n+\n+\t* tree.h (DECL_NON_ADDR_CONST_P): New accessor macro.\n+\t(struct tree_decl): Add non_addr_const_p field.\n+\t* tree.c (staticp): Use.\n+\n+\t* i386/cygwin32.h (CPP_PREDEFINES): Map __declspec(x) to GCC\n+\tattributes.\n+\t(SUBTARGET_SWITCHES): Switches to turn on/off dllimport|export\n+\tattributes. Also accept -mwindows option.\n+\t(VALID_MACHINE_DECL_ATTRIBUTE): New macro.\n+\t(MERGE_MACHINE_DECL_ATTRIBUTE): New macro.\n+\t(REDO_SECTION_INFO_P): New macro.\n+\t(DRECTVE_SECTION_FUNCTION): New macro.\n+\t(drectve_section): Cover function to implement above.\n+\t(SWITCH_TO_SECTION_FUNCTION): New macro.\n+\t(switch_to_section): Covert function to implement above.\n+\t(EXTRA_SECTIONS): Add in_drectve.\n+\t(EXTRA_SECTION_FUNCTIONS): Add in_drectve and switch_to_section.\n+\t(ENCODE_SECTION_INFO): Delete old macro and redefine as a function.\n+\t(STRIP_NAME_ENCODING): Handle new attributes.\n+\t(ASM_OUTPUT_LABELREF): New macro.\n+\t(ASM_OUTPUT_FUNCTION_NAME): New macro.\n+\t(ASM_OUTPUT_COMMON): New macro.\n+\t(ASM_OUTPUT_DECLARE_OBJECT_NAME): New macro.\n+\n+\t* i386/mingw32.h (CPP_PREDEFINES): Map __declspec(x) to GCC\n+\tattributes.\n+\n+\t* i386/winnt.c (i386_pe_valid_decl_attribute_p): New function.\n+\t(i386_pe_merge_decl_attributes): New function.\n+\t(i386_pe_check_vtable_importexport): New function.\n+\t(i386_pe_dllexport_p): New function.\n+\t(i386_pe_dllimport_p): New function.\n+\t(i386_pe_dllexport_name_p): New function.\n+\t(i386_pe_dllimport_name_p): New function.\n+\t(i386_pe_mark_dllexport): New function.\n+\t(i386_pe_mark_dllimport): New function.\n+\t(i386_pe_encode_section_info): New function.\n+\t(i386_pe_unique_section): Strip encoding from name first.\n+\n Tue Jul  7 00:50:17 1998  Manfred Hollstein   (manfred@s-direktnet.de)\n \n         * libgcc2.c (L_exit): Provide a fake for atexit on systems which"}, {"sha": "f76cd534add849ec2ce6b5a8a0094a5de76049b2", "filename": "gcc/config/i386/cygwin32.h", "status": "modified", "additions": 160, "deletions": 28, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Fconfig%2Fi386%2Fcygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin32.h?ref=27da1b4d5a1c30a60a38f725f2119fda88854d88", "patch": "@@ -30,6 +30,14 @@ Boston, MA 02111-1307, USA. */\n #include \"i386/gas.h\"\n #include \"dbxcoff.h\"\n \n+/* Support the __declspec keyword by turning them into attributes.\n+   We currently only support: dllimport and dllexport.\n+   Note that the current way we do this may result in a collision with\n+   predefined attributes later on.  This can be solved by using one attribute,\n+   say __declspec__, and passing args to it.  The problem with that approach\n+   is that args are not accumulated: each new appearance would clobber any\n+   existing args.  */\n+\n #ifdef CPP_PREDEFINES\n #undef CPP_PREDEFINES\n #endif\n@@ -38,6 +46,7 @@ Boston, MA 02111-1307, USA. */\n   -D__CYGWIN32__ -DWINNT  -D_X86_=1 -D__STDC__=1\\\n   -D__stdcall=__attribute__((__stdcall__)) \\\n   -D__cdecl=__attribute__((__cdecl__)) \\\n+  -D__declspec(x)=__attribute__((x)) \\\n   -Asystem(winnt) -Acpu(i386) -Amachine(i386)\"\n \n #undef CPP_SPEC\n@@ -69,13 +78,51 @@ Boston, MA 02111-1307, USA. */\n #define WCHAR_TYPE \"short unsigned int\"\n #define HAVE_ATEXIT 1\n \n+\f\n+/* Ignore dllimport for functions.  */\n+#define TARGET_NOP_FUN_DLLIMPORT (target_flags & 0x20000)\n+\n+#undef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES \t\t\t\\\n+  { \"nop-fun-dllimport\",\t 0x20000 },\t\\\n+  { \"no-nop-fun-dllimport\",\t-0x20000 },\t\\\n+  { \"windows\",\t\t\t 0x0     },\n+\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+extern int i386_pe_valid_decl_attribute_p ();\n+\n+#undef VALID_MACHINE_DECL_ATTRIBUTE\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+  i386_pe_valid_decl_attribute_p (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+extern union tree_node *i386_pe_merge_decl_attributes ();\n+#define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n+  i386_pe_merge_decl_attributes ((OLD), (NEW))\n+\n+/* Used to implement dllexport overriding dllimport semantics.  It's also used\n+   to handle vtables - the first pass won't do anything because\n+   DECL_CONTEXT (DECL) will be 0 so i386_pe_dll{ex,im}port_p will return 0.\n+   It's also used to handle dllimport override semantics.  */\n+#if 0\n+#define REDO_SECTION_INFO_P(DECL) \\\n+  ((DECL_MACHINE_ATTRIBUTES (DECL) != NULL_TREE) \\\n+   || (TREE_CODE (DECL) == VAR_DECL && DECL_VIRTUAL_P (DECL)))\n+#else\n+#define REDO_SECTION_INFO_P(DECL) 1\n+#endif\n+\n+\f\n #undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_ctor, in_dtor\n+#define EXTRA_SECTIONS in_ctor, in_dtor, in_drectve\n \n #undef EXTRA_SECTION_FUNCTIONS\n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n   CTOR_SECTION_FUNCTION\t\t\t\t\t\t\\\n-  DTOR_SECTION_FUNCTION\n+  DTOR_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  DRECTVE_SECTION_FUNCTION\t\t\t\t\t\\\n+  SWITCH_TO_SECTION_FUNCTION\n \n #define CTOR_SECTION_FUNCTION\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\\\n@@ -99,6 +146,41 @@ dtor_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n+#define DRECTVE_SECTION_FUNCTION \\\n+void\t\t\t\t\t\t\t\t\t\\\n+drectve_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_drectve)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", \"\\t.section .drectve\\n\");\t\t\\\n+      in_section = in_drectve;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Switch to SECTION (an `enum in_section').\n+\n+   ??? This facility should be provided by GCC proper.\n+   The problem is that we want to temporarily switch sections in\n+   ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n+   afterwards.  */\n+#define SWITCH_TO_SECTION_FUNCTION \t\t\t\t\\\n+void \t\t\t\t\t\t\t\t\\\n+switch_to_section (section, decl) \t\t\t\t\\\n+     enum in_section section; \t\t\t\t\t\\\n+     tree decl; \t\t\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\\\n+  switch (section) \t\t\t\t\t\t\\\n+    { \t\t\t\t\t\t\t\t\\\n+      case in_text: text_section (); break; \t\t\t\\\n+      case in_data: data_section (); break; \t\t\t\\\n+      case in_named: named_section (decl, NULL, 0); break; \t\\\n+      case in_ctor: ctor_section (); break; \t\t\t\\\n+      case in_dtor: dtor_section (); break; \t\t\t\\\n+      case in_drectve: drectve_section (); break; \t\t\\\n+      default: abort (); break; \t\t\t\t\\\n+    } \t\t\t\t\t\t\t\t\\\n+}\n+\n #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\\\n   do {\t\t\t\t\t\t\\\n     ctor_section ();\t\t\t\t\\\n@@ -111,52 +193,46 @@ dtor_section ()\t\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\\\n     dtor_section ();                   \t\t\\\n     fprintf (FILE, \"%s\\t\", ASM_LONG);\t\t\\\n-    assemble_name (FILE, NAME);              \t\\\n+    assemble_name (FILE, NAME);\t\t\t\\\n     fprintf (FILE, \"\\n\");\t\t\t\\\n   } while (0)\n \n /* Define this macro if references to a symbol must be treated\n    differently depending on something about the variable or\n    function named by the symbol (such as what section it is in).\n \n-   On i386, if using PIC, mark a SYMBOL_REF for a non-global symbol\n-   so that we may access it directly in the GOT.\n-\n    On i386 running Windows NT, modify the assembler name with a suffix \n    consisting of an atsign (@) followed by string of digits that represents\n    the number of bytes of arguments passed to the function, if it has the \n-   attribute STDCALL. */\n+   attribute STDCALL.\n+\n+   In addition, we must mark dll symbols specially. Definitions of \n+   dllexport'd objects install some info in the .drectve section.  \n+   References to dllimport'd objects are fetched indirectly via\n+   _imp__.  If both are declared, dllexport overrides.  This is also \n+   needed to implement one-only vtables: they go into their own\n+   section and we need to set DECL_SECTION_NAME so we do that here.\n+   Note that we can be called twice on the same decl.  */\n+\n+extern void i386_pe_encode_section_info ();\n \n #ifdef ENCODE_SECTION_INFO\n #undef ENCODE_SECTION_INFO\n-#define ENCODE_SECTION_INFO(DECL) \t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n-\t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n-\tSYMBOL_REF_FLAG (XEXP (rtl, 0))\t\t\t\t\t\\\n-\t  = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n-\t     || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (TREE_CODE (DECL) == FUNCTION_DECL) \t\t\t\t\\\n-      if (lookup_attribute (\"stdcall\",\t\t\t\t\t\\\n-\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (DECL))))\t\\\n-        XEXP (DECL_RTL (DECL), 0) = \t\t\t\t\t\\\n-          gen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (DECL)); \t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n #endif\n+#define ENCODE_SECTION_INFO(DECL) i386_pe_encode_section_info (DECL)\n \n-/* This macro gets just the user-specified name out of the string in a\n-   SYMBOL_REF.  Discard trailing @[NUM] encoded by ENCODE_SECTION_INFO.   */\n+/* Utility used only in this file.  */\n+#define I386_PE_STRIP_ENCODING(SYM_NAME) \\\n+  ((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n \n+/* This macro gets just the user-specified name\n+   out of the string in a SYMBOL_REF.  Discard\n+   trailing @[NUM] encoded by ENCODE_SECTION_INFO.  */\n #undef  STRIP_NAME_ENCODING\n #define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char *_p;\t\t\t\t\t\t\t\t\\\n-  char *_name = ((SYMBOL_NAME) + ((SYMBOL_NAME)[0] == '*'));\t\t\\\n+  char *_name = I386_PE_STRIP_ENCODING (SYMBOL_NAME);\t\t\t\\\n   for (_p = _name; *_p && *_p != '@'; ++_p)\t\t\t\t\\\n     ;\t\t\t\t\t\t\t\t\t\\\n   if (*_p == '@')\t\t\t\t\t\t\t\\\n@@ -170,6 +246,62 @@ do {\t\t\t\t\t\t\t\t\t\\\n     (VAR) = _name;\t\t\t\t\t\t\t\\\n } while (0)\n       \n+\f\n+/* Output a reference to a label.  */\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)  \t\t\\\n+  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, \t\t\\\n+           I386_PE_STRIP_ENCODING (NAME))\t\t\\\n+\n+/* Output a function definition label.  */\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)\t\\\n+do {\t\t\t\t\t\t\t\\\n+  if (i386_pe_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\", \t\\\n+               I386_PE_STRIP_ENCODING (NAME));\t\t\\\n+      function_section (DECL);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\n+/* Output a common block.  */\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\\\n+do {\t\t\t\t\t\t\t\\\n+  if (i386_pe_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+               I386_PE_STRIP_ENCODING (NAME));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  if (! i386_pe_dllimport_name_p (NAME))\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.comm\\t\"); \t\t\t\\\n+      assemble_name ((STREAM), (NAME));\t\t\t\\\n+      fprintf ((STREAM), \", %d\\t%s %d\\n\",\t\t\\\n+\t       (ROUNDED), ASM_COMMENT_START, (SIZE));\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Output the label for an initialized variable.  */\n+#undef ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL) \t\\\n+do {\t\t\t\t\t\t\t\\\n+  if (i386_pe_dllexport_name_p (NAME))\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      enum in_section save_section = in_section;\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf ((STREAM), \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+               I386_PE_STRIP_ENCODING (NAME));\t\t\\\n+      switch_to_section (save_section, (DECL));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+} while (0)\n+\n+\f\n /* Emit code to check the stack when allocating more that 4000\n    bytes in one go. */\n "}, {"sha": "19299621f7b60994e3d715207d7e941e02659e86", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=27da1b4d5a1c30a60a38f725f2119fda88854d88", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA. */\n   -D__MINGW32__ -DWINNT  -D_X86_=1 -D__STDC__=1\\\n   -D__stdcall=__attribute__((__stdcall__)) \\\n   -D__cdecl=__attribute__((__cdecl__)) \\\n+  -D__declspec(x)=__attribute__((x)) \\\n   -Asystem(winnt) -Acpu(i386) -Amachine(i386)\"\n \n /* Specific a different directory for the standard include files.  */"}, {"sha": "95daf14ff90866e1b8f73cc558e2ab2996ad553e", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=27da1b4d5a1c30a60a38f725f2119fda88854d88", "patch": "@@ -28,6 +28,351 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"flags.h\"\n \n+/* i386/PE specific attribute support.\n+\n+   i386/PE has two new attributes:\n+   dllexport - for exporting a function/variable that will live in a dll\n+   dllimport - for importing a function/variable from a dll\n+\n+   Microsoft allows multiple declspecs in one __declspec, separating\n+   them with spaces.  We do NOT support this.  Instead, use __declspec\n+   multiple times.\n+*/\n+\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.  */\n+\n+int\n+i386_pe_valid_decl_attribute_p (decl, attributes, attr, args)\n+     tree decl;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  if (args != NULL_TREE)\n+    return 0;\n+\n+  if (is_attribute_p (\"dllexport\", attr))\n+    return 1;\n+  if (is_attribute_p (\"dllimport\", attr))\n+    return 1;\n+\n+  return i386_valid_decl_attribute_p (decl, attributes, attr, args);\n+}\n+\n+/* Merge attributes in decls OLD and NEW.\n+\n+   This handles the following situation:\n+\n+   __declspec (dllimport) int foo;\n+   int foo;\n+\n+   The second instance of `foo' nullifies the dllimport.  */\n+\n+tree\n+i386_pe_merge_decl_attributes (old, new)\n+     tree old, new;\n+{\n+  tree a;\n+  int delete_dllimport_p;\n+\n+  old = DECL_MACHINE_ATTRIBUTES (old);\n+  new = DECL_MACHINE_ATTRIBUTES (new);\n+\n+  /* What we need to do here is remove from `old' dllimport if it doesn't\n+     appear in `new'.  dllimport behaves like extern: if a declaration is\n+     marked dllimport and a definition appears later, then the object\n+     is not dllimport'd.  */\n+\n+  if (lookup_attribute (\"dllimport\", old) != NULL_TREE\n+      && lookup_attribute (\"dllimport\", new) == NULL_TREE)\n+    delete_dllimport_p = 1;\n+  else\n+    delete_dllimport_p = 0;\n+\n+  a = merge_attributes (old, new);\n+\n+  if (delete_dllimport_p)\n+    {\n+      tree prev,t;\n+\n+      /* Scan the list for dllimport and delete it.  */\n+      for (prev = NULL_TREE, t = a; t; prev = t, t = TREE_CHAIN (t))\n+\t{\n+\t  if (is_attribute_p (\"dllimport\", TREE_PURPOSE (t)))\n+\t    {\n+\t      if (prev == NULL_TREE)\n+\t\ta = TREE_CHAIN (a);\n+\t      else\n+\t\tTREE_CHAIN (prev) = TREE_CHAIN (t);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  return a;\n+}\n+\f\n+/* Check a type that has a virtual table, and see if any virtual methods are\n+   marked for import or export, and if so, arrange for the vtable to\n+   be imported or exported.  */\n+\n+static int\n+i386_pe_check_vtable_importexport (type)\n+     tree type;\n+{\n+  tree methods = TYPE_METHODS (type);\n+  tree fndecl;\n+\n+  if (TREE_CODE (methods) == FUNCTION_DECL)\n+    fndecl = methods;\n+  else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n+    fndecl = TREE_VEC_ELT (methods, 0);\n+  else\n+    fndecl = TREE_VEC_ELT (methods, 1);\n+\n+  while (fndecl)\n+    {\n+      if (DECL_VIRTUAL_P (fndecl) || DECL_VINDEX (fndecl) != NULL_TREE)\n+\t{\n+\t  tree exp = lookup_attribute (\"dllimport\",\n+\t\t\t\t       DECL_MACHINE_ATTRIBUTES (fndecl));\n+\t  if (exp == 0)\n+\t    exp = lookup_attribute (\"dllexport\",\n+\t\t\t\t    DECL_MACHINE_ATTRIBUTES (fndecl));\n+\t  if (exp)\n+\t    return 1;\n+\t}\n+\n+      fndecl = TREE_CHAIN (fndecl);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if DECL is a dllexport'd object.  */\n+\n+#if 0\n+tree current_class_type; /* FIXME */\n+#endif\n+\n+int\n+i386_pe_dllexport_p (decl)\n+     tree decl;\n+{\n+  tree exp;\n+\n+  if (TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return 0;\n+  exp = lookup_attribute (\"dllexport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  if (exp)\n+    return 1;\n+\n+#if 0 /* This was a hack to get vtable's exported or imported since only one\n+\t copy of them is ever output.  Disabled pending better solution.  */\n+  /* For C++, the vtables might have to be marked.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+    {\n+      if (TREE_PUBLIC (decl)\n+\t  && DECL_EXTERNAL (decl) == 0\n+\t  && (DECL_CONTEXT (decl)\n+\t      ? i386_pe_check_vtable_importexport (DECL_CONTEXT (decl))\n+\t      : current_class_type\n+\t      ? i386_pe_check_vtable_importexport (current_class_type)\n+\t      : 0)\n+\t  )\n+\treturn 1;\n+    }\n+#endif\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if DECL is a dllimport'd object.  */\n+\n+int\n+i386_pe_dllimport_p (decl)\n+     tree decl;\n+{\n+  tree imp;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TARGET_NOP_FUN_DLLIMPORT)\n+    return 0;\n+\n+  if (TREE_CODE (decl) != VAR_DECL\n+      && TREE_CODE (decl) != FUNCTION_DECL)\n+    return 0;\n+  imp = lookup_attribute (\"dllimport\", DECL_MACHINE_ATTRIBUTES (decl));\n+  if (imp)\n+    return 1;\n+\n+#if 0 /* This was a hack to get vtable's exported or imported since only one\n+\t copy of them is ever output.  Disabled pending better solution.  */\n+  /* For C++, the vtables might have to be marked.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+    {\n+      if (TREE_PUBLIC (decl)\n+\t  && DECL_EXTERNAL (decl)\n+\t  && (DECL_CONTEXT (decl)\n+\t      ? i386_pe_check_vtable_importexport (DECL_CONTEXT (decl))\n+\t      : current_class_type\n+\t      ? i386_pe_check_vtable_importexport (current_class_type)\n+\t      : 0)\n+\t  )\n+\treturn 1;\n+    }\n+#endif\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if SYMBOL is marked as being dllexport'd.  */\n+\n+int\n+i386_pe_dllexport_name_p (symbol)\n+     char *symbol;\n+{\n+  return symbol[0] == '@' && symbol[1] == 'e' && symbol[2] == '.';\n+}\n+\n+/* Return non-zero if SYMBOL is marked as being dllimport'd.  */\n+\n+int\n+i386_pe_dllimport_name_p (symbol)\n+     char *symbol;\n+{\n+  return symbol[0] == '@' && symbol[1] == 'i' && symbol[2] == '.';\n+}\n+\n+/* Mark a DECL as being dllexport'd.\n+   Note that we override the previous setting (eg: dllimport).  */\n+\n+void\n+i386_pe_mark_dllexport (decl)\n+     tree decl;\n+{\n+  char *oldname, *newname;\n+  rtx rtlname;\n+  tree idp;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    abort ();\n+  if (i386_pe_dllimport_name_p (oldname))\n+    oldname += 9;\n+  else if (i386_pe_dllexport_name_p (oldname))\n+    return; /* already done */\n+\n+  newname = alloca (strlen (oldname) + 4);\n+  sprintf (newname, \"@e.%s\", oldname);\n+\n+  /* We pass newname through get_identifier to ensure it has a unique\n+     address.  RTL processing can sometimes peek inside the symbol ref\n+     and compare the string's addresses to see if two symbols are\n+     identical.  */\n+  idp = get_identifier (newname);\n+\n+  XEXP (DECL_RTL (decl), 0) =\n+    gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+}\n+\n+/* Mark a DECL as being dllimport'd.  */\n+\n+void\n+i386_pe_mark_dllimport (decl)\n+     tree decl;\n+{\n+  char *oldname, *newname;\n+  tree idp;\n+  rtx rtlname, newrtl;\n+\n+  rtlname = XEXP (DECL_RTL (decl), 0);\n+  if (GET_CODE (rtlname) == SYMBOL_REF)\n+    oldname = XSTR (rtlname, 0);\n+  else if (GET_CODE (rtlname) == MEM\n+\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n+    oldname = XSTR (XEXP (rtlname, 0), 0);\n+  else\n+    abort ();\n+  if (i386_pe_dllexport_name_p (oldname))\n+    {\n+      error (\"`%s' declared as both exported to and imported from a DLL.\",\n+             IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      return;\n+    }\n+  else if (i386_pe_dllimport_name_p (oldname))\n+    {\n+      /* Already done, but force correct linkage since the redeclaration \n+         might have omitted explicit extern.  Sigh.  */\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  /* ??? Is this test for vtables needed?  */\n+\t  && !DECL_VIRTUAL_P (decl))\n+\t{\n+\t  DECL_EXTERNAL (decl) = 1;\n+\t  TREE_PUBLIC (decl) = 1;\n+\t}\n+      return;\n+    }\n+\n+  /* ??? One can well ask why we're making these checks here,\n+     and that would be a good question.  */\n+\n+  /* Imported variables can't be initialized. Note that C++ classes\n+     are marked initial, so we need to check.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && !DECL_VIRTUAL_P (decl)\n+      && (DECL_INITIAL (decl)\n+          && ! TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))))\n+    {\n+      error_with_decl (decl, \"initialized variable `%s' is marked dllimport\");\n+      return;\n+    }\n+  /* Nor can they be static.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      /* ??? Is this test for vtables needed?  */\n+      && !DECL_VIRTUAL_P (decl)\n+      && 0 /*???*/)\n+    {\n+      error_with_decl (decl, \"static variable `%s' is marked dllimport\");\n+      return;\n+    }\n+\n+  /* `extern' needn't be specified with dllimport.\n+     Specify `extern' now and hope for the best.  Sigh.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      /* ??? Is this test for vtables needed?  */\n+      && !DECL_VIRTUAL_P (decl))\n+    {\n+      DECL_EXTERNAL (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+    }\n+\n+  newname = alloca (strlen (oldname) + 11);\n+  sprintf (newname, \"@i._imp__%s\", oldname);\n+\n+  /* We pass newname through get_identifier to ensure it has a unique\n+     address.  RTL processing can sometimes peek inside the symbol ref\n+     and compare the string's addresses to see if two symbols are\n+     identical.  */\n+  idp = get_identifier (newname);\n+\n+  newrtl = gen_rtx (MEM, Pmode,\n+\t\t    gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t     IDENTIFIER_POINTER (idp)));\n+  XEXP (DECL_RTL (decl), 0) = newrtl;\n+\n+  /* Can't treat a pointer to this as a constant address */\n+  DECL_NON_ADDR_CONST_P (decl) = 1;\n+}\n+\n /* Return string which is the former assembler name modified with a \n    suffix consisting of an atsign (@) followed by the number of bytes of \n    arguments */\n@@ -66,6 +411,59 @@ gen_stdcall_suffix (decl)\n   return IDENTIFIER_POINTER (get_identifier (newsym));\n }\n \n+/* Cover function to implement ENCODE_SECTION_INFO.  */\n+\n+void\n+i386_pe_encode_section_info (decl)\n+     tree decl;\n+{\n+  /* This bit is copied from i386.h.  */\n+  if (optimize > 0 && TREE_CONSTANT (decl)\n+      && (!flag_writable_strings || TREE_CODE (decl) != STRING_CST))\n+    {\n+      rtx rtl = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'\n+                 ? TREE_CST_RTL (decl) : DECL_RTL (decl));\n+      SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\n+    }\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    if (lookup_attribute (\"stdcall\",\n+\t\t\t  TYPE_ATTRIBUTES (TREE_TYPE (decl))))\n+      XEXP (DECL_RTL (decl), 0) = \n+\tgen_rtx (SYMBOL_REF, Pmode, gen_stdcall_suffix (decl));\n+\n+  /* Mark the decl so we can tell from the rtl whether the object is\n+     dllexport'd or dllimport'd.  */\n+\n+  if (i386_pe_dllexport_p (decl))\n+    i386_pe_mark_dllexport (decl);\n+  else if (i386_pe_dllimport_p (decl))\n+    i386_pe_mark_dllimport (decl);\n+  /* It might be that DECL has already been marked as dllimport, but a\n+     subsequent definition nullified that.  The attribute is gone but\n+     DECL_RTL still has @i._imp__foo.  We need to remove that. Ditto\n+     for the DECL_NON_ADDR_CONST_P flag.  */\n+  else if ((TREE_CODE (decl) == FUNCTION_DECL\n+\t    || TREE_CODE (decl) == VAR_DECL)\n+\t   && DECL_RTL (decl) != NULL_RTX\n+\t   && GET_CODE (DECL_RTL (decl)) == MEM\n+\t   && GET_CODE (XEXP (DECL_RTL (decl), 0)) == MEM\n+\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n+\t   && i386_pe_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n+    {\n+      char *oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n+      tree idp = get_identifier (oldname + 9);\n+      rtx newrtl = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n+\n+      XEXP (DECL_RTL (decl), 0) = newrtl;\n+\n+      DECL_NON_ADDR_CONST_P (decl) = 0;\n+\n+      /* We previously set TREE_PUBLIC and DECL_EXTERNAL.\n+\t We leave these alone for now.  */\n+    }\n+}\n+\n /* Cover function for UNIQUE_SECTION.  */\n \n void\n@@ -77,6 +475,8 @@ i386_pe_unique_section (decl, reloc)\n   char *name,*string,*prefix;\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  /* Strip off any encoding in fnname.  */\n+  STRIP_NAME_ENCODING (name, name);\n \n   /* The object is put in, for example, section .text$foo.\n      The linker will then ultimately place them in .text"}, {"sha": "ec42643f333e780cf51789cd4422a7fa0afe3b07", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=27da1b4d5a1c30a60a38f725f2119fda88854d88", "patch": "@@ -2265,9 +2265,12 @@ staticp (arg)\n     case FUNCTION_DECL:\n       /* Nested functions aren't static, since taking their address\n \t involves a trampoline.  */\n-       return decl_function_context (arg) == 0 || DECL_NO_STATIC_CHAIN (arg);\n+       return (decl_function_context (arg) == 0 || DECL_NO_STATIC_CHAIN (arg))\n+              && ! DECL_NON_ADDR_CONST_P (arg);\n+\n     case VAR_DECL:\n-      return TREE_STATIC (arg) || DECL_EXTERNAL (arg);\n+      return (TREE_STATIC (arg) || DECL_EXTERNAL (arg))\n+             && ! DECL_NON_ADDR_CONST_P (arg);\n \n     case CONSTRUCTOR:\n       return TREE_STATIC (arg);"}, {"sha": "c79270bf2a706180325977bf8790dbc10d1cc173", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27da1b4d5a1c30a60a38f725f2119fda88854d88/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=27da1b4d5a1c30a60a38f725f2119fda88854d88", "patch": "@@ -1201,6 +1201,10 @@ struct tree_type\n #define DECL_LANG_FLAG_6(NODE) (DECL_CHECK (NODE)->decl.lang_flag_6)\n #define DECL_LANG_FLAG_7(NODE) (DECL_CHECK (NODE)->decl.lang_flag_7)\n \n+/* Used to indicate that the pointer to this DECL cannot be treated as\n+   an address constant.  */\n+#define DECL_NON_ADDR_CONST_P(NODE) (DECL_CHECK (NODE)->decl.non_addr_const_p)\n+\n struct tree_decl\n {\n   char common[sizeof (struct tree_common)];\n@@ -1242,6 +1246,8 @@ struct tree_decl\n   unsigned lang_flag_6 : 1;\n   unsigned lang_flag_7 : 1;\n \n+  unsigned non_addr_const_p : 1;\n+\n   /* For a FUNCTION_DECL, if inline, this is the size of frame needed.\n      If built-in, this is the code for which built-in function.\n      For other kinds of decls, this is DECL_ALIGN.  */"}]}