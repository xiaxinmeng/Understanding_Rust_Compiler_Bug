{"sha": "133a8e6339ff5d4c695cd1c4ee0f4958386d46bd", "node_id": "C_kwDOANBUbNoAKDEzM2E4ZTYzMzlmZjVkNGM2OTVjZDFjNGVlMGY0OTU4Mzg2ZDQ2YmQ", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-12-19T10:47:38Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-05T14:30:01Z"}, "message": "ada: Optimize class-wide objects initialized with function calls\n\nThis optimizes the implementation of class-wide objects initialized with\nfunction calls in the non-interface case, by avoiding an unnecessary copy\noperation and/or a dispatching call to the _Size primitive when possible.\n\ngcc/ada/\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): New local variable\n\tFunc_Id holding the function for a special return object.\n\tUse a direct renaming in the class-wide case when the initializing\n\texpression is a captured function call, except for a special return\n\tobject when the two functions do not return on the same stack.\n\tApply the accessibility check for class-wide special return objects.\n\t* exp_util.adb (Make_CW_Equivalent_Type) <Has_Tag_Of_Type>: New.\n\tDo not force a dispatching call to the primitive operation _Size if\n\tthe expression is known to statically have the tag of its type.", "tree": {"sha": "2d3d80f89a22715e3d7df4ee8034d4d74bef326a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d3d80f89a22715e3d7df4ee8034d4d74bef326a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "229f5150ad6e233a0b2e0cd9f8b09072a566aa96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229f5150ad6e233a0b2e0cd9f8b09072a566aa96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229f5150ad6e233a0b2e0cd9f8b09072a566aa96"}], "stats": {"total": 143, "additions": 108, "deletions": 35}, "files": [{"sha": "23a910ecdba70de7a592cb4b74aeb94721a5db75", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=133a8e6339ff5d4c695cd1c4ee0f4958386d46bd", "patch": "@@ -6235,6 +6235,10 @@ package body Exp_Ch3 is\n       --  and ultimately rewritten as a renaming, so initialization activities\n       --  need to be deferred until after that is done.\n \n+      Func_Id : constant Entity_Id :=\n+       (if Special_Ret_Obj then Return_Applies_To (Scope (Def_Id)) else Empty);\n+      --  The function if this is a special return object, otherwise Empty\n+\n       function Build_Equivalent_Aggregate return Boolean;\n       --  If the object has a constrained discriminated type and no initial\n       --  value, it may be possible to build an equivalent aggregate instead,\n@@ -6243,7 +6247,6 @@ package body Exp_Ch3 is\n       function Build_Heap_Or_Pool_Allocator\n         (Temp_Id    : Entity_Id;\n          Temp_Typ   : Entity_Id;\n-         Func_Id    : Entity_Id;\n          Ret_Typ    : Entity_Id;\n          Alloc_Expr : Node_Id) return Node_Id;\n       --  Create the statements necessary to allocate a return object on the\n@@ -6442,7 +6445,6 @@ package body Exp_Ch3 is\n       function Build_Heap_Or_Pool_Allocator\n         (Temp_Id    : Entity_Id;\n          Temp_Typ   : Entity_Id;\n-         Func_Id    : Entity_Id;\n          Ret_Typ    : Entity_Id;\n          Alloc_Expr : Node_Id) return Node_Id\n       is\n@@ -7103,8 +7105,6 @@ package body Exp_Ch3 is\n       -------------------------------\n \n       function Make_Allocator_For_Return (Expr : Node_Id) return Node_Id is\n-         Func_Id : constant Entity_Id := Return_Applies_To (Scope (Def_Id));\n-\n          Alloc : Node_Id;\n \n       begin\n@@ -7933,13 +7933,19 @@ package body Exp_Ch3 is\n                 --  finalize it prematurely (see Expand_Simple_Function_Return\n                 --  for the same test in the case of a simple return).\n \n+                --  Moreover, in the case of a special return object, we also\n+                --  need to make sure that the two functions return on the same\n+                --  stack, otherwise we would create a dangling reference.\n+\n                 and then\n                   ((not Is_Library_Level_Entity (Def_Id)\n                      and then Is_Captured_Function_Call (Expr_Q)\n-                     and then (not Special_Ret_Obj\n-                                or else Is_Related_To_Func_Return\n-                                          (Entity (Prefix (Expr_Q))))\n-                     and then not Is_Class_Wide_Type (Typ))\n+                     and then\n+                       (not Special_Ret_Obj\n+                         or else\n+                          (Is_Related_To_Func_Return (Entity (Prefix (Expr_Q)))\n+                            and then Needs_Secondary_Stack (Etype (Expr_Q)) =\n+                                     Needs_Secondary_Stack (Etype (Func_Id)))))\n \n                    --  If the initializing expression is a variable with the\n                    --  flag OK_To_Rename set, then transform:\n@@ -8148,8 +8154,6 @@ package body Exp_Ch3 is\n \n       if Is_Build_In_Place_Return_Object (Def_Id) then\n          declare\n-            Func_Id : constant Entity_Id := Return_Applies_To (Scope (Def_Id));\n-\n             Init_Stmt       : Node_Id;\n             Obj_Acc_Formal  : Entity_Id;\n \n@@ -8441,7 +8445,6 @@ package body Exp_Ch3 is\n                             Build_Heap_Or_Pool_Allocator\n                               (Temp_Id    => Alloc_Obj_Id,\n                                Temp_Typ   => Acc_Typ,\n-                               Func_Id    => Func_Id,\n                                Ret_Typ    => Desig_Typ,\n                                Alloc_Expr => Heap_Allocator))),\n \n@@ -8465,7 +8468,6 @@ package body Exp_Ch3 is\n                             Build_Heap_Or_Pool_Allocator\n                               (Temp_Id    => Alloc_Obj_Id,\n                                Temp_Typ   => Acc_Typ,\n-                               Func_Id    => Func_Id,\n                                Ret_Typ    => Desig_Typ,\n                                Alloc_Expr => Pool_Allocator)))),\n \n@@ -8586,11 +8588,8 @@ package body Exp_Ch3 is\n       --  and that the tag is assigned in the case of any return object.\n \n       elsif Rewrite_As_Renaming then\n-         if Is_Secondary_Stack_Return_Object (Def_Id) then\n+         if Special_Ret_Obj then\n             declare\n-               Func_Id  : constant Entity_Id  :=\n-                 Return_Applies_To (Scope (Def_Id));\n-\n                Desig_Typ : constant Entity_Id :=\n                  (if Ekind (Typ) = E_Array_Subtype\n                   then Etype (Func_Id) else Typ);\n@@ -8603,11 +8602,23 @@ package body Exp_Ch3 is\n                   Set_Etype (Def_Id, Desig_Typ);\n                   Set_Actual_Subtype (Def_Id, Typ);\n                end if;\n-            end;\n-         end if;\n \n-         if Special_Ret_Obj and then Present (Tag_Assign) then\n-            Insert_Action_After (Init_After, Tag_Assign);\n+               if Present (Tag_Assign) then\n+                  Insert_Action_After (Init_After, Tag_Assign);\n+               end if;\n+\n+               --  Ada 2005 (AI95-344): If the result type is class-wide,\n+               --  insert a check that the level of the return expression's\n+               --  underlying type is not deeper than the level of the master\n+               --  enclosing the function.\n+\n+               --  AI12-043: The check is made immediately after the return\n+               --  object is created.\n+\n+               if Is_Class_Wide_Type (Etype (Func_Id)) then\n+                  Apply_CW_Accessibility_Check (Expr_Q, Func_Id);\n+               end if;\n+            end;\n          end if;\n \n       --  If this is the return object of a function returning on the secondary\n@@ -8628,9 +8639,6 @@ package body Exp_Ch3 is\n \n       elsif Is_Secondary_Stack_Return_Object (Def_Id) then\n          declare\n-            Func_Id  : constant Entity_Id  :=\n-              Return_Applies_To (Scope (Def_Id));\n-\n             Desig_Typ : constant Entity_Id :=\n               (if Ekind (Typ) = E_Array_Subtype\n                then Etype (Func_Id) else Typ);"}, {"sha": "9fbd6dfbd8230d070e48afe402acf89185a87022", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 77, "deletions": 12, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/133a8e6339ff5d4c695cd1c4ee0f4958386d46bd/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=133a8e6339ff5d4c695cd1c4ee0f4958386d46bd", "patch": "@@ -9669,7 +9669,7 @@ package body Exp_Util is\n \n    --   type Equiv_T is record\n    --     _parent : T (List of discriminant constraints taken from Exp);\n-   --     Ext__50 : Storage_Array (1 .. (Exp'size - Typ'object_size)/8);\n+   --     Cnn : Storage_Array (1 .. (Exp'size - Typ'object_size)/Storage_Unit);\n    --   end Equiv_T;\n    --\n    --  Note that this type does not guarantee same alignment as all derived\n@@ -9693,7 +9693,63 @@ package body Exp_Util is\n       Range_Type  : Entity_Id;\n       Str_Type    : Entity_Id;\n       Constr_Root : Entity_Id;\n-      Sizexpr     : Node_Id;\n+      Size_Expr   : Node_Id;\n+      Size_Pref   : Node_Id;\n+\n+      function Has_Tag_Of_Type (Exp : Node_Id) return Boolean;\n+      --  Return True if expression Exp of a tagged type is known to statically\n+      --  have the tag of this tagged type as specified by RM 3.9(19-25).\n+\n+      ---------------------\n+      -- Has_Tag_Of_Type --\n+      ---------------------\n+\n+      function Has_Tag_Of_Type (Exp : Node_Id) return Boolean is\n+         Typ : constant Entity_Id := Etype (Exp);\n+\n+      begin\n+         pragma Assert (Is_Tagged_Type (Typ));\n+\n+         --  The tag of an object of a class-wide type is that of its\n+         --  initialization expression.\n+\n+         if Is_Class_Wide_Type (Typ) then\n+            return False;\n+         end if;\n+\n+         --  The tag of a stand-alone object of a specific tagged type T\n+         --  identifies T.\n+\n+         if Is_Entity_Name (Exp)\n+           and then Ekind (Entity (Exp)) in Constant_Or_Variable_Kind\n+         then\n+            return True;\n+\n+         else\n+            case Nkind (E) is\n+               --  The tag of a component or an aggregate of a specific tagged\n+               --  type T identifies T.\n+\n+               when N_Indexed_Component\n+                 |  N_Selected_Component\n+                 |  N_Aggregate\n+               =>\n+                  return True;\n+\n+               --  The tag of the result returned by a function whose result\n+               --  type is a specific tagged type T identifies T.\n+\n+               when N_Function_Call =>\n+                  return True;\n+\n+               when N_Explicit_Dereference =>\n+                  return Is_Captured_Function_Call (Exp);\n+\n+               when others =>\n+                  return False;\n+            end case;\n+         end if;\n+      end Has_Tag_Of_Type;\n \n    begin\n       --  If the root type is already constrained, there are no discriminants\n@@ -9728,42 +9784,51 @@ package body Exp_Util is\n \n       Range_Type := Make_Temporary (Loc, 'G');\n \n+      --  If the expression is known to have the tag of its type, then we can\n+      --  use it directly for the prefix of the Size attribute; otherwise we\n+      --  need to convert it first to the class-wide type to force a call to\n+      --  the _Size primitive operation.\n+\n+      if Has_Tag_Of_Type (E) then\n+         Size_Pref := Duplicate_Subexpr_No_Checks (E);\n+      else\n+         Size_Pref := OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E));\n+      end if;\n+\n       if not Is_Interface (Root_Typ) then\n \n          --  subtype rg__xx is\n-         --    Storage_Offset range 1 .. (Expr'size - typ'object_size)\n+         --    Storage_Offset range 1 .. (Exp'size - Typ'object_size)\n          --                                / Storage_Unit\n \n-         Sizexpr :=\n+         Size_Expr :=\n            Make_Op_Subtract (Loc,\n              Left_Opnd =>\n                Make_Attribute_Reference (Loc,\n-                 Prefix =>\n-                   OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E)),\n+                 Prefix => Size_Pref,\n                  Attribute_Name => Name_Size),\n              Right_Opnd =>\n                Make_Attribute_Reference (Loc,\n                  Prefix => New_Occurrence_Of (Constr_Root, Loc),\n                  Attribute_Name => Name_Object_Size));\n       else\n          --  subtype rg__xx is\n-         --    Storage_Offset range 1 .. (Expr'size - Ada.Tags.Tag'object_size)\n+         --    Storage_Offset range 1 .. (Exp'size - Ada.Tags.Tag'object_size)\n          --                                / Storage_Unit\n \n-         Sizexpr :=\n+         Size_Expr :=\n            Make_Op_Subtract (Loc,\n              Left_Opnd =>\n                Make_Attribute_Reference (Loc,\n-                 Prefix =>\n-                   OK_Convert_To (T, Duplicate_Subexpr_No_Checks (E)),\n+                 Prefix => Size_Pref,\n                  Attribute_Name => Name_Size),\n              Right_Opnd =>\n                Make_Attribute_Reference (Loc,\n                  Prefix => New_Occurrence_Of (RTE (RE_Tag), Loc),\n                  Attribute_Name => Name_Object_Size));\n       end if;\n \n-      Set_Paren_Count (Sizexpr, 1);\n+      Set_Paren_Count (Size_Expr, 1);\n \n       Append_To (List_Def,\n         Make_Subtype_Declaration (Loc,\n@@ -9777,7 +9842,7 @@ package body Exp_Util is\n                     Low_Bound => Make_Integer_Literal (Loc, 1),\n                     High_Bound =>\n                       Make_Op_Divide (Loc,\n-                        Left_Opnd => Sizexpr,\n+                        Left_Opnd => Size_Expr,\n                         Right_Opnd => Make_Integer_Literal (Loc,\n                             Intval => System_Storage_Unit)))))));\n "}]}