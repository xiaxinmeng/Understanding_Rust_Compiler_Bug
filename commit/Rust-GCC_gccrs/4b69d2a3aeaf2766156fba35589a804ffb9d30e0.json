{"sha": "4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2OWQyYTNhZWFmMjc2NjE1NmZiYTM1NTg5YTgwNGZmYjlkMzBlMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-30T03:49:49Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-30T03:49:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r634", "tree": {"sha": "4129b6f17f80a10eb6f97d9c283172fcb132b3ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4129b6f17f80a10eb6f97d9c283172fcb132b3ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b69d2a3aeaf2766156fba35589a804ffb9d30e0/comments", "author": null, "committer": null, "parents": [{"sha": "2525c7828207fff10eb6d9427d9e83077ca3d9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2525c7828207fff10eb6d9427d9e83077ca3d9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2525c7828207fff10eb6d9427d9e83077ca3d9b6"}], "stats": {"total": 81, "additions": 42, "deletions": 39}, "files": [{"sha": "9c635c6e4efbe03e2ddb6f3b8d75a1a3557e9d92", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b69d2a3aeaf2766156fba35589a804ffb9d30e0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b69d2a3aeaf2766156fba35589a804ffb9d30e0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "patch": "@@ -438,7 +438,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   40, 41, 42, 43, 44, 45, 46, 47,\t\\\n   48, 49, 50, 51, 52, 53, 54, 55,\t\\\n   56, 57, 58, 59, 60, 61, 62, 63,\t\\\n-  1, 4, 5, 6, 7, 0, 14, 30};\n+  1, 4, 5, 6, 7, 0, 14, 30}\n \n /* This is the order in which to allocate registers for\n    leaf functions.  If all registers can fit in the \"i\" registers,\n@@ -451,7 +451,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   40, 41, 42, 43, 44, 45, 46, 47,\t\\\n   48, 49, 50, 51, 52, 53, 54, 55,\t\\\n   56, 57, 58, 59, 60, 61, 62, 63,\t\\\n-  1, 4, 5, 6, 7, 0, 14, 30, 31};\n+  1, 4, 5, 6, 7, 0, 14, 30, 31}\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n@@ -463,7 +463,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1};\n+  1, 1, 1, 1, 1, 1, 1, 1}\n \n extern char leaf_reg_remap[];\n #define LEAF_REG_REMAP(REGNO) (leaf_reg_remap[REGNO])\n@@ -765,20 +765,23 @@ extern struct rtx_def *sparc_compare_op0, *sparc_compare_op1;\n \n extern struct rtx_def *gen_compare_reg ();\n \f\n+/* Generate the special assembly code needed to tell the assembler whatever\n+   it might need to know about the return value of a function.\n+\n+   For Sparc assemblers, we need to output a .proc pseudo-op which conveys\n+   information to the assembler relating to peephole optimization (done in\n+   the assembler).  */\n+\n+#define ASM_DECLARE_RESULT(FILE, RESULT) \\\n+  fprintf ((FILE), \"\\t.proc\\t0%o\\n\", sparc_type_code (TREE_TYPE (RESULT)))\n+\n /* Output the label for a function definition.  */\n \n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n-{\t\t\t\t\t\t\t\\\n-  extern tree double_type_node, float_type_node;\t\\\n-  if (TREE_TYPE (DECL) == float_type_node)\t\t\\\n-    fprintf (FILE, \"\\t.proc 6\\n\");\t\t\t\\\n-  else if (TREE_TYPE (DECL) == double_type_node)\t\\\n-    fprintf (FILE, \"\\t.proc 7\\n\");\t\t\t\\\n-  else if (TREE_TYPE (DECL) == void_type_node)\t\t\\\n-    fprintf (FILE, \"\\t.proc 0\\n\");\t\t\t\\\n-  else fprintf (FILE, \"\\t.proc 1\\n\");\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\\\n-}\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+} while (0)\n \n /* Two views of the size of the current frame.  */\n extern int actual_fsize;\n@@ -1500,13 +1503,25 @@ extern struct rtx_def *legitimize_pic_address ();\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n+do {\t\t\t\t\t\t\t\t\t\\\n+  char label[30];\t\t\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n+  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+} while (0)\n \n /* This is how to output an element of a case-vector that is relative.\n    (SPARC uses such vectors only when generating PIC.)  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-1b\\n\", VALUE)\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  char label[30];\t\t\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n+  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"-1b\\n\");\t\t\t\t\t\t\\\n+} while (0)\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}, {"sha": "2859ce4aec43ecc01ec793807cff240b4aac3a95", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b69d2a3aeaf2766156fba35589a804ffb9d30e0/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b69d2a3aeaf2766156fba35589a804ffb9d30e0/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=4b69d2a3aeaf2766156fba35589a804ffb9d30e0", "patch": "@@ -281,41 +281,27 @@ do {\t\t\t\t \t\t\t\t\\\n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.\n \n-   If the NUM argument is negative, we don't use it when generating the\n-   label.\n-\n    For most svr4 systems, the convention is that any symbol which begins\n-   with a period is not put into the linker symbol table by the assembler.\n-*/\n+   with a period is not put into the linker symbol table by the assembler.  */\n \n #undef ASM_OUTPUT_INTERNAL_LABEL\n #define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if ((int) (NUM) >= 0)\t\t\t\t\t\t\t\\ ???\n-    fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \".%s:\\n\", PREFIX);\t\t\t\t\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n } while (0)\n \n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.\n    This is suitable for output with `assemble_name'.\n \n-   If the NUM argument is negative, we don't use it when generating the\n-   label.\n-\n    For most svr4 systems, the convention is that any symbol which begins\n-   with a period is not put into the linker symbol table by the assembler.\n-*/\n+   with a period is not put into the linker symbol table by the assembler.  */\n \n #undef ASM_GENERATE_INTERNAL_LABEL\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if ((int) (NUM) >= 0)\t\t\t\t\t\t\t\\\n-    sprintf (LABEL, \"*.%s%d\", PREFIX, NUM);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    sprintf (LABEL, \"*.%s\", PREFIX);\t\t\t\t\t\\\n+  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM);\t\t\t\t\\\n } while (0)\n \n /* The standard SVR4 assembler seems to require that certain builtin\n@@ -345,13 +331,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n    the linker seems to want the alignment of data objects\n    to depend on their types.  We do exactly that here.  */\n \n-#define BSS_ASM_OP\t\".bss\"\n+#define LOCAL_ASM_OP\t\".local\"\n \n #undef ASM_OUTPUT_ALIGNED_LOCAL\n #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t%s,%u,%u\\n\",\t\t\t\t\t\\\n-\t   BSS_ASM_OP, (NAME), (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+  fprintf ((FILE), \"\\t%s\\t\", LOCAL_ASM_OP);\t\t\t\t\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+  ASM_OUTPUT_ALIGNED_COMMON (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n } while (0)\n \n /* This is the pseudo-op used to generate a 32-bit word of data with a"}]}