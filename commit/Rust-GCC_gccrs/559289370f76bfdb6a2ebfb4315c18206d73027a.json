{"sha": "559289370f76bfdb6a2ebfb4315c18206d73027a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU5Mjg5MzcwZjc2YmZkYjZhMmViZmI0MzE1YzE4MjA2ZDczMDI3YQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-05-02T10:46:00Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-05-02T10:46:00Z"}, "message": "rs6000: Remove paired single\n\nThis removes paired single (used on the 750CL and friends).  It was\ndeprecated in GCC 8.  Removing it means we only have one vector model\nto deal with (VMX+VSX, 16-byte vectors).\n\n\n\t* config.gcc (powerpc*-*-*): Remove paired.h.  Unsupport the\n\tpowerpc*-*-linux*paired* target.\n\t* config/rs6000/750cl.h: Delete.\n\t* config/rs6000/paired.h: Delete.\n\t* config/rs6000/paired.md: Delete.\n\t* config/rs6000/predicates.md (easy_vector_constant): Remove paired\n\tfloat support.\n\t* config/rs6000/rs6000-builtin.def: Remove paired float support.\n\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Update\n\tcomment.  Remove paired float support.\n\t* config/rs6000/rs6000-modes.def: Remove V2SF and V2SI.\n\t* config/rs6000/rs6000-opts.h (enum rs6000_vector): Delete\n\tVECTOR_PAIRED.\n\t* config/rs6000/rs6000-protos.h (paired_expand_vector_init,\n\tpaired_emit_vector_cond_expr, paired_expand_vector_move): Delete\n\tdeclarations.\n\t* config/rs6000/rs6000.c: Remove paired float support.\n\t(paired_expand_vector_init, paired_expand_vector_move,\n\tpaired_emit_vector_compare, paired_emit_vector_cond_expr,\n\t(paired_expand_lv_builtin, paired_expand_stv_builtin,\n\tpaired_expand_builtin, paired_expand_predicate_builtin,\n\tpaired_init_builtins): Delete.\n\t* config/rs6000/rs6000.h: Remove paired float support.\n\t* config/rs6000/rs6000.md: Remove paired float support.\n\t(move_from_CR_ov_bit): Delete.\n\t* config/rs6000/rs6000.opt (mpaired): Delete.\n\t* config/rs6000/t-rs6000: Remove paired.md from MD_INCLUDES.\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Delete -mpaired.\n\nFrom-SVN: r259833", "tree": {"sha": "7bf904c3e9fd65fd073cca2eca0f432708229112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bf904c3e9fd65fd073cca2eca0f432708229112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/559289370f76bfdb6a2ebfb4315c18206d73027a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/559289370f76bfdb6a2ebfb4315c18206d73027a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/559289370f76bfdb6a2ebfb4315c18206d73027a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/559289370f76bfdb6a2ebfb4315c18206d73027a/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85b3bb6d57c00993d2692c75cdd563945438da24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b3bb6d57c00993d2692c75cdd563945438da24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b3bb6d57c00993d2692c75cdd563945438da24"}], "stats": {"total": 1523, "additions": 79, "deletions": 1444}, "files": [{"sha": "d8ea0f078271e7a2308ab6cfbe93899234f1df8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -1,3 +1,34 @@\n+2018-05-02  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config.gcc (powerpc*-*-*): Remove paired.h.  Unsupport the\n+\tpowerpc*-*-linux*paired* target.\n+\t* config/rs6000/750cl.h: Delete.\n+\t* config/rs6000/paired.h: Delete.\n+\t* config/rs6000/paired.md: Delete.\n+\t* config/rs6000/predicates.md (easy_vector_constant): Remove paired\n+\tfloat support.\n+\t* config/rs6000/rs6000-builtin.def: Remove paired float support.\n+\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Update\n+\tcomment.  Remove paired float support.\n+\t* config/rs6000/rs6000-modes.def: Remove V2SF and V2SI.\n+\t* config/rs6000/rs6000-opts.h (enum rs6000_vector): Delete\n+\tVECTOR_PAIRED.\n+\t* config/rs6000/rs6000-protos.h (paired_expand_vector_init,\n+\tpaired_emit_vector_cond_expr, paired_expand_vector_move): Delete\n+\tdeclarations.\n+\t* config/rs6000/rs6000.c: Remove paired float support.\n+\t(paired_expand_vector_init, paired_expand_vector_move,\n+\tpaired_emit_vector_compare, paired_emit_vector_cond_expr,\n+\t(paired_expand_lv_builtin, paired_expand_stv_builtin,\n+\tpaired_expand_builtin, paired_expand_predicate_builtin,\n+\tpaired_init_builtins): Delete.\n+\t* config/rs6000/rs6000.h: Remove paired float support.\n+\t* config/rs6000/rs6000.md: Remove paired float support.\n+\t(move_from_CR_ov_bit): Delete.\n+\t* config/rs6000/rs6000.opt (mpaired): Delete.\n+\t* config/rs6000/t-rs6000: Remove paired.md from MD_INCLUDES.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Delete -mpaired.\n+\n 2018-05-02  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/85567"}, {"sha": "3658c428f7a898f01032ab085ab7a5d0e0303b8f", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -473,7 +473,6 @@ powerpc*-*-*)\n \textra_headers=\"${extra_headers} xmmintrin.h mm_malloc.h emmintrin.h\"\n \textra_headers=\"${extra_headers} mmintrin.h x86intrin.h\"\n \textra_headers=\"${extra_headers} ppu_intrinsics.h spu2vmx.h vec_types.h si2vmx.h\"\n-\textra_headers=\"${extra_headers} paired.h\"\n \textra_headers=\"${extra_headers} amo.h\"\n \tcase x$with_cpu in\n \t    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[3456789]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|xe6500)\n@@ -2502,11 +2501,11 @@ powerpc*-*-linux*)\n \t    all) maybe_biarch=yes ;;\n \tesac\n \tcase ${target} in\n-\t    powerpc64*-*-linux*spe* | powerpc64*-*-linux*paired*)\n+\t    powerpc64*-*-linux*spe* | powerpc*-*-linux*paired*)\n \t\techo \"*** Configuration ${target} not supported\" 1>&2\n \t\texit 1\n \t\t;;\n-\t    powerpc*-*-linux*spe* | powerpc*-*-linux*paired*)\n+\t    powerpc*-*-linux*spe*)\n \t\tmaybe_biarch=\n \t\t;;\n \tesac\n@@ -2552,8 +2551,6 @@ powerpc*-*-linux*)\n \t\ttm_file=\"${tm_file} rs6000/linuxaltivec.h\" ;;\n \t    powerpc*-*-linux*spe*)\n \t\ttm_file=\"${tm_file} ${cpu_type}/linuxspe.h ${cpu_type}/e500.h\" ;;\n-\t    powerpc*-*-linux*paired*)\n-\t\ttm_file=\"${tm_file} rs6000/750cl.h\" ;;\n \tesac\n \tcase ${target} in\n \t    *-linux*-musl*)"}, {"sha": "50080027b58fa3ead6f5243be9dcc334ad0372ce", "filename": "gcc/config/rs6000/750cl.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b3bb6d57c00993d2692c75cdd563945438da24/gcc%2Fconfig%2Frs6000%2F750cl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b3bb6d57c00993d2692c75cdd563945438da24/gcc%2Fconfig%2Frs6000%2F750cl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2F750cl.h?ref=85b3bb6d57c00993d2692c75cdd563945438da24", "patch": "@@ -1,30 +0,0 @@\n-/* Enable 750cl paired single support.\n-   Copyright (C) 2007-2018 Free Software Foundation, Inc.\n-   Contributed by Revital Eres (eres@il.ibm.com)\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#undef TARGET_PAIRED_FLOAT\n-#define TARGET_PAIRED_FLOAT rs6000_paired_float\n-\n-#undef ASM_CPU_SPEC \n-#define ASM_CPU_SPEC \"-m750cl\"\n-"}, {"sha": "042cee21656d237e057228136e57f14cd247f46c", "filename": "gcc/config/rs6000/paired.h", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b3bb6d57c00993d2692c75cdd563945438da24/gcc%2Fconfig%2Frs6000%2Fpaired.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b3bb6d57c00993d2692c75cdd563945438da24/gcc%2Fconfig%2Frs6000%2Fpaired.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpaired.h?ref=85b3bb6d57c00993d2692c75cdd563945438da24", "patch": "@@ -1,75 +0,0 @@\n-/* PowerPC 750CL user include file.\n-   Copyright (C) 2007-2018 Free Software Foundation, Inc.\n-   Contributed by Revital Eres (eres@il.ibm.com).\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef _PAIRED_H\n-#define _PAIRED_H\n-\n-#define vector __attribute__((vector_size(8)))\n-\n-#define paired_msub __builtin_paired_msub\n-#define paired_madd __builtin_paired_madd\n-#define paired_nmsub __builtin_paired_nmsub\n-#define paired_nmadd __builtin_paired_nmadd\n-#define paired_sum0 __builtin_paired_sum0\n-#define paired_sum1 __builtin_paired_sum1\n-#define paired_div __builtin_paired_divv2sf3\n-#define paired_add __builtin_paired_addv2sf3\n-#define paired_sub __builtin_paired_subv2sf3\n-#define paired_mul __builtin_paired_mulv2sf3\n-#define paired_muls0 __builtin_paired_muls0\n-#define paired_muls1 __builtin_paired_muls1\n-#define paired_madds0 __builtin_paired_madds0\n-#define paired_madds1 __builtin_paired_madds1\n-#define paired_merge00 __builtin_paired_merge00\n-#define paired_merge01 __builtin_paired_merge01\n-#define paired_merge10 __builtin_paired_merge10\n-#define paired_merge11 __builtin_paired_merge11\n-#define paired_abs __builtin_paired_absv2sf2\n-#define paired_nabs __builtin_paired_nabsv2sf2\n-#define paired_neg __builtin_paired_negv2sf2\n-#define paired_sqrt __builtin_paired_sqrtv2sf2\n-#define paired_res __builtin_paired_resv2sf2\n-#define paired_stx __builtin_paired_stx\n-#define paired_lx __builtin_paired_lx\n-#define paired_cmpu0 __builtin_paired_cmpu0\n-#define paired_cmpu1 __builtin_paired_cmpu1\n-#define paired_sel __builtin_paired_selv2sf4\n-\n-/* Condition register codes for Paired predicates. */\n-#define LT            0\n-#define GT            1\n-#define EQ            2\n-#define UN            3\n-\n-#define paired_cmpu0_un(a,b) __builtin_paired_cmpu0 (UN, (a), (b))\n-#define paired_cmpu0_eq(a,b) __builtin_paired_cmpu0 (EQ, (a), (b))\n-#define paired_cmpu0_lt(a,b) __builtin_paired_cmpu0 (LT, (a), (b))\n-#define paired_cmpu0_gt(a,b) __builtin_paired_cmpu0 (GT, (a), (b))\n-#define paired_cmpu1_un(a,b) __builtin_paired_cmpu1 (UN, (a), (b))\n-#define paired_cmpu1_eq(a,b) __builtin_paired_cmpu1 (EQ, (a), (b))\n-#define paired_cmpu1_lt(a,b) __builtin_paired_cmpu1 (LT, (a), (b))\n-#define paired_cmpu1_gt(a,b) __builtin_paired_cmpu1 (GT, (a), (b))\n-\n-#endif /* _PAIRED_H */"}, {"sha": "ab076a425b8f074cdfd097e3ae807834e10102f7", "filename": "gcc/config/rs6000/paired.md", "status": "removed", "additions": 0, "deletions": 492, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b3bb6d57c00993d2692c75cdd563945438da24/gcc%2Fconfig%2Frs6000%2Fpaired.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b3bb6d57c00993d2692c75cdd563945438da24/gcc%2Fconfig%2Frs6000%2Fpaired.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpaired.md?ref=85b3bb6d57c00993d2692c75cdd563945438da24", "patch": "@@ -1,492 +0,0 @@\n-;; PowerPC paired single and double hummer description\n-;; Copyright (C) 2007-2018 Free Software Foundation, Inc.\n-;; Contributed by David Edelsohn <edelsohn@gnu.org> and Revital Eres\n-;; <eres@il.ibm.com>\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify it\n-;; under the terms of the GNU General Public License as published\n-;; by the Free Software Foundation; either version 3, or (at your\n-;; option) any later version.\n-\n-;; GCC is distributed in the hope that it will be useful, but WITHOUT\n-;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-;; License for more details.\n-;; \n-;; You should have received a copy of the GNU General Public License\n-;; along with this program; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-(define_c_enum \"unspec\"\n-  [UNSPEC_INTERHI_V2SF\n-   UNSPEC_INTERLO_V2SF\n-   UNSPEC_EXTEVEN_V2SF\n-   UNSPEC_EXTODD_V2SF\n-  ])\n-\n-(define_insn \"negv2sf2\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_neg %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"sqrtv2sf2\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(sqrt:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_rsqrte %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"absv2sf2\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(abs:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_abs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"nabsv2sf2\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:V2SF (abs:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_nabs %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"addv2sf3\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(plus:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"%f\")\n-\t\t   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_add %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"subv2sf3\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-        (minus:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-                    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_sub %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"mulv2sf3\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(mult:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"%f\")\n-\t\t   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_mul %0,%1,%2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"resv2sf2\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(unspec:V2SF [(match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")] UNSPEC_FRES))]\n-  \"TARGET_PAIRED_FLOAT && flag_finite_math_only\"\n-  \"ps_res %0,%1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"divv2sf3\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(div:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t  (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_div %0,%1,%2\"\n-  [(set_attr \"type\" \"sdiv\")])\n-\n-(define_insn \"paired_madds0\"\n- [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-       (vec_concat:V2SF\n-\t (fma:SF\n-           (vec_select:SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 0)]))\n-\t   (vec_select:SF (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-                          (parallel [(const_int 0)]))\n-\t   (vec_select:SF (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")\n-                          (parallel [(const_int 0)])))\n-\t (fma:SF\n-\t   (vec_select:SF (match_dup 1)\n-                          (parallel [(const_int 1)]))\n-\t   (vec_select:SF (match_dup 2)\n-                          (parallel [(const_int 0)]))\n-\t   (vec_select:SF (match_dup 3)\n-                          (parallel [(const_int 1)])))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_madds0 %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_madds1\"\n- [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-       (vec_concat:V2SF\n-         (fma:SF\n-\t   (vec_select:SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-                          (parallel [(const_int 0)]))\n-           (vec_select:SF (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-                          (parallel [(const_int 1)]))\n-           (vec_select:SF (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")\n-                          (parallel [(const_int 0)])))\n-\t (fma:SF\n-\t   (vec_select:SF (match_dup 1)\n-                          (parallel [(const_int 1)]))\n-           (vec_select:SF (match_dup 2)\n-                          (parallel [(const_int 1)]))\n-           (vec_select:SF (match_dup 3)\n-                          (parallel [(const_int 1)])))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_madds1 %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*paired_madd\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(fma:V2SF\n-\t  (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t  (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t  (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_madd %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")]) \n-\n-(define_insn \"*paired_msub\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(fma:V2SF\n-\t  (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t  (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t  (neg:V2SF (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_msub %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*paired_nmadd\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:V2SF\n-\t  (fma:V2SF\n-\t    (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\"))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_nmadd %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*paired_nmsub\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(neg:V2SF\n-\t  (fma:V2SF\n-\t    (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t    (neg:V2SF (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_nmsub %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"dmul\")])\n-\n-(define_insn \"selv2sf4\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_concat:V2SF\n-\t (if_then_else:SF (ge (vec_select:SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t\t     (parallel [(const_int 0)]))\n-\t\t\t      (match_operand:SF 4 \"zero_fp_constant\" \"F\"))\n-\t\t\t  (vec_select:SF (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t\t (parallel [(const_int 0)]))\n-\t\t\t  (vec_select:SF (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t\t (parallel [(const_int 0)])))\n-\t (if_then_else:SF (ge (vec_select:SF (match_dup 1)\n-\t\t\t\t\t     (parallel [(const_int 1)]))\n-\t\t\t      (match_dup 4))\n-\t\t\t  (vec_select:SF (match_dup 2)\n-\t\t\t\t\t (parallel [(const_int 1)]))\n-\t\t\t  (vec_select:SF (match_dup 3)\n-\t\t\t\t\t (parallel [(const_int 1)])))))]\n-\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_sel %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"*movv2sf_paired\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=Z,f,f,Y,r,r,f\")\n-\t\t (match_operand:V2SF 1 \"input_operand\" \"f,Z,f,r,Y,r,W\"))]\n-  \"TARGET_PAIRED_FLOAT\n-   && (register_operand (operands[0], V2SFmode) \n-       || register_operand (operands[1], V2SFmode))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \"psq_stx %1,%y0,0,0\";\n-    case 1: return \"psq_lx %0,%y1,0,0\";\n-    case 2: return \"ps_mr %0,%1\";\n-    case 3: return \"#\";\n-    case 4: return \"#\";\n-    case 5: return \"#\";\n-    case 6: return \"#\"; \n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fpstore,fpload,fp,*,*,*,*\")])\n-\n-(define_insn \"paired_stx\"\n-  [(set (match_operand:V2SF 0 \"memory_operand\" \"=Z\")\n-        (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\"))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"psq_stx %1,%y0,0,0\"\n-  [(set_attr \"type\" \"fpstore\")])\n-\n-(define_insn \"paired_lx\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-        (match_operand:V2SF 1 \"memory_operand\" \"Z\"))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"psq_lx %0,%y1,0,0\"\n-  [(set_attr \"type\" \"fpload\")])\n-\n-\n-(define_split\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:V2SF 1 \"input_operand\" \"\"))]\n-  \"TARGET_PAIRED_FLOAT && reload_completed\n-   && gpr_or_gpr_p (operands[0], operands[1])\"\n-  [(pc)]\n-  {\n-  rs6000_split_multireg_move (operands[0], operands[1]); DONE;\n-  })\n-\n-(define_insn \"paired_cmpu0\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCFP (vec_select:SF\n-\t\t       (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t       (parallel [(const_int 0)]))\n-\t\t      (vec_select:SF\n-\t\t       (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t       (parallel [(const_int 0)]))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_cmpu0 %0,%1,%2\"\n-  [(set_attr \"type\" \"fpcompare\")])\n-\n-(define_insn \"paired_cmpu1\"\n-  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCFP (vec_select:SF\n-\t\t       (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t       (parallel [(const_int 1)]))\n-\t\t      (vec_select:SF\n-\t\t       (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t       (parallel [(const_int 1)]))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_cmpu1 %0,%1,%2\"\n-  [(set_attr \"type\" \"fpcompare\")])\n-\n-(define_insn \"paired_merge00\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_select:V2SF\n-\t  (vec_concat:V4SF\n-\t    (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\"))\n-\t  (parallel [(const_int 0) (const_int 2)])))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_merge00 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_merge01\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_select:V2SF\n-\t  (vec_concat:V4SF\n-\t    (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\"))\n-\t  (parallel [(const_int 0) (const_int 3)])))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_merge01 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_merge10\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_select:V2SF\n-\t  (vec_concat:V4SF\n-\t    (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\"))\n-\t  (parallel [(const_int 1) (const_int 2)])))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_merge10 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_merge11\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_select:V2SF\n-\t  (vec_concat:V4SF\n-\t    (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t    (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\"))\n-\t  (parallel [(const_int 1) (const_int 3)])))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_merge11 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_sum0\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_concat:V2SF (plus:SF (vec_select:SF\n-\t\t\t\t   (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t   (parallel [(const_int 0)]))\n-\t\t\t\t  (vec_select:SF\n-\t\t\t\t   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t   (parallel [(const_int 1)])))\n-\t\t\t (vec_select:SF\n-\t\t\t  (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 1)]))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_sum0 %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_sum1\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(vec_concat:V2SF (vec_select:SF\n-\t\t\t  (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 1)]))\n-\t\t\t (plus:SF (vec_select:SF\n-\t\t\t\t   (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t   (parallel [(const_int 0)]))\n-\t\t\t\t  (vec_select:SF\n-\t\t\t\t   (match_operand:V2SF 3 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t   (parallel [(const_int 1)])))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_sum1 %0,%1,%2,%3\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_insn \"paired_muls0\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(mult:V2SF (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t   (vec_duplicate:V2SF\n-\t\t    (vec_select:SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t   (parallel [(const_int 0)])))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_muls0 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-\n-(define_insn \"paired_muls1\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-\t(mult:V2SF (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")\n-\t\t   (vec_duplicate:V2SF\n-\t\t    (vec_select:SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t\t   (parallel [(const_int 1)])))))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_muls1 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"vec_initv2sfsf\"\n-  [(match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-   (match_operand 1 \"\" \"\")]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  paired_expand_vector_init (operands[0], operands[1]);\n-  DONE;\n-})\n-\n-(define_insn \"*vconcatsf\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-        (vec_concat:V2SF\n-         (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-         (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"ps_merge00 %0, %1, %2\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-(define_expand \"sminv2sf3\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-        (smin:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-                   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-\n-  emit_insn (gen_subv2sf3 (tmp, operands[1], operands[2]));\n-  emit_insn (gen_selv2sf4 (operands[0], tmp, operands[2], operands[1], CONST0_RTX (SFmode)));\n-  DONE;\n-})\n-\n-(define_expand \"smaxv2sf3\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-        (smax:V2SF (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-                   (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-\n-  emit_insn (gen_subv2sf3 (tmp, operands[1], operands[2]));\n-  emit_insn (gen_selv2sf4 (operands[0], tmp, operands[1], operands[2], CONST0_RTX (SFmode)));\n-  DONE;\n-})\n-\n-(define_expand \"reduc_smax_scal_v2sf\"\n-  [(match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-   (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  rtx tmp_swap = gen_reg_rtx (V2SFmode);\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-  rtx vec_res = gen_reg_rtx (V2SFmode);\n-  rtx di_res = gen_reg_rtx (DImode);\n-\n-  emit_insn (gen_paired_merge10 (tmp_swap, operands[1], operands[1]));\n-  emit_insn (gen_subv2sf3 (tmp, operands[1], tmp_swap));\n-  emit_insn (gen_selv2sf4 (vec_res, tmp, operands[1], tmp_swap,\n-\t\t\t   CONST0_RTX (SFmode)));\n-  emit_move_insn (di_res, simplify_gen_subreg (DImode, vec_res, V2SFmode, 0));\n-  emit_move_insn (operands[0], simplify_gen_subreg (SFmode, di_res, DImode,\n-\t\t\t\t\t\t    BYTES_BIG_ENDIAN ? 4 : 0));\n-\n-  DONE;\n-})\n-\n-(define_expand \"reduc_smin_scal_v2sf\"\n-  [(match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-   (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  rtx tmp_swap = gen_reg_rtx (V2SFmode);\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-  rtx vec_res = gen_reg_rtx (V2SFmode);\n-  rtx di_res = gen_reg_rtx (DImode);\n-\n-  emit_insn (gen_paired_merge10 (tmp_swap, operands[1], operands[1]));\n-  emit_insn (gen_subv2sf3 (tmp, operands[1], tmp_swap));\n-  emit_insn (gen_selv2sf4 (vec_res, tmp, tmp_swap, operands[1],\n-\t\t\t   CONST0_RTX (SFmode)));\n-  emit_move_insn (di_res, simplify_gen_subreg (DImode, vec_res, V2SFmode, 0));\n-  emit_move_insn (operands[0], simplify_gen_subreg (SFmode, di_res, DImode,\n-\t\t\t\t\t\t    BYTES_BIG_ENDIAN ? 4 : 0));\n-\n-  DONE;\n-})\n-\n-(define_expand \"reduc_plus_scal_v2sf\"\n-  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n-        (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\"))]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  rtx vec_res = gen_reg_rtx (V2SFmode);\n-  rtx di_res = gen_reg_rtx (DImode);\n-\n-  emit_insn (gen_paired_sum1 (vec_res, operands[1], operands[1], operands[1]));\n-  emit_move_insn (di_res, simplify_gen_subreg (DImode, vec_res, V2SFmode, 0));\n-  emit_move_insn (operands[0], simplify_gen_subreg (SFmode, di_res, DImode,\n-\t\t\t\t\t\t    BYTES_BIG_ENDIAN ? 4 : 0));\n-  DONE;\n-})\n-\n-(define_expand \"movmisalignv2sf\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:V2SF 1 \"any_operand\" \"\"))]\n-  \"TARGET_PAIRED_FLOAT\"\n-{\n-  paired_expand_vector_move (operands);\n-  DONE;\n-})\n-\n-(define_expand \"vcondv2sfv2sf\"\n-  [(set (match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n-        (if_then_else:V2SF\n-         (match_operator 3 \"gpc_reg_operand\"\n-                         [(match_operand:V2SF 4 \"gpc_reg_operand\" \"f\")\n-                          (match_operand:V2SF 5 \"gpc_reg_operand\" \"f\")])\n-         (match_operand:V2SF 1 \"gpc_reg_operand\" \"f\")\n-         (match_operand:V2SF 2 \"gpc_reg_operand\" \"f\")))]\n-  \"TARGET_PAIRED_FLOAT && flag_unsafe_math_optimizations\"\n-{\n-  if (paired_emit_vector_cond_expr (operands[0], operands[1], operands[2],\n-                                    operands[3], operands[4], operands[5]))\n-    DONE;\n-  else\n-    FAIL;\n-})"}, {"sha": "1fc5a50696a3c0db620fd4cd28427426b69d5350", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -690,11 +690,6 @@\n (define_predicate \"easy_vector_constant\"\n   (match_code \"const_vector\")\n {\n-  /* As the paired vectors are actually FPRs it seems that there is\n-     no easy way to load a CONST_VECTOR without using memory.  */\n-  if (TARGET_PAIRED_FLOAT)\n-    return false;\n-\n   /* Because IEEE 128-bit floating point is considered a vector type\n      in order to pass it in VSX registers, it might use this function\n      instead of easy_fp_constant.  */"}, {"sha": "550389348b1a2afc7cb575169eeef2a811dbfd1d", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -32,7 +32,6 @@\n    RS6000_BUILTIN_D -- DST builtins\n    RS6000_BUILTIN_H -- HTM builtins\n    RS6000_BUILTIN_P -- Altivec, VSX, ISA 2.07 vector predicate builtins\n-   RS6000_BUILTIN_Q -- Paired floating point VSX predicate builtins\n    RS6000_BUILTIN_X -- special builtins\n \n    Each of the above macros takes 4 arguments:\n@@ -74,10 +73,6 @@\n   #error \"RS6000_BUILTIN_P is not defined.\"\n #endif\n \n-#ifndef RS6000_BUILTIN_Q\n-  #error \"RS6000_BUILTIN_Q is not defined.\"\n-#endif\n-\n #ifndef RS6000_BUILTIN_X\n   #error \"RS6000_BUILTIN_X is not defined.\"\n #endif\n@@ -549,47 +544,6 @@\n \t\t     | RS6000_BTC_VOID),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n-/* Paired floating point convenience macros.  */\n-#define BU_PAIRED_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n-  RS6000_BUILTIN_1 (PAIRED_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n-\t\t    \"__builtin_paired_\" NAME,\t\t/* NAME */\t\\\n-\t\t    RS6000_BTM_PAIRED,\t\t\t/* MASK */\t\\\n-\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n-\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n-\n-#define BU_PAIRED_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n-  RS6000_BUILTIN_2 (PAIRED_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n-\t\t    \"__builtin_paired_\" NAME,\t\t/* NAME */\t\\\n-\t\t    RS6000_BTM_PAIRED,\t\t\t/* MASK */\t\\\n-\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n-\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n-\n-#define BU_PAIRED_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n-  RS6000_BUILTIN_3 (PAIRED_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n-\t\t    \"__builtin_paired_\" NAME,\t\t/* NAME */\t\\\n-\t\t    RS6000_BTM_PAIRED,\t\t\t/* MASK */\t\\\n-\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n-\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n-\n-#define BU_PAIRED_P(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n-  RS6000_BUILTIN_Q (PAIRED_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n-\t\t    \"__builtin_paired_\" NAME,\t\t/* NAME */\t\\\n-\t\t    RS6000_BTM_PAIRED,\t\t\t/* MASK */\t\\\n-\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_PREDICATE),\t\t\t\t\\\n-\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n-\n-#define BU_PAIRED_X(ENUM, NAME, ATTR)\t\t\t\t\t\\\n-  RS6000_BUILTIN_X (PAIRED_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n-\t\t    \"__builtin_paired_\" NAME,\t\t/* NAME */\t\\\n-\t\t    RS6000_BTM_PAIRED,\t\t\t/* MASK */\t\\\n-\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n-\t\t     | RS6000_BTC_SPECIAL),\t\t\t\t\\\n-\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n-\n #define BU_SPECIAL_X(ENUM, NAME, MASK, ATTR)\t\t\t\t\\\n   RS6000_BUILTIN_X (ENUM,\t\t\t\t/* ENUM */\t\\\n \t\t    NAME,\t\t\t\t/* NAME */\t\\\n@@ -2480,44 +2434,6 @@ BU_HTM_V1 (SET_TEXASR,\t\"set_texasr\",\tSPR,\tnothing)\n BU_HTM_0  (GET_TEXASRU,\t\"get_texasru\",\tSPR,\tnothing)\n BU_HTM_V1 (SET_TEXASRU,\t\"set_texasru\",\tSPR,\tnothing)\n \n-\f\n-/* 3 argument paired floating point builtins.  */\n-BU_PAIRED_3 (MSUB,            \"msub\",           FP, \tfmsv2sf4)\n-BU_PAIRED_3 (MADD,            \"madd\",           FP, \tfmav2sf4)\n-BU_PAIRED_3 (MADDS0,          \"madds0\",         FP, \tpaired_madds0)\n-BU_PAIRED_3 (MADDS1,          \"madds1\",         FP, \tpaired_madds1)\n-BU_PAIRED_3 (NMSUB,           \"nmsub\",          FP, \tnfmsv2sf4)\n-BU_PAIRED_3 (NMADD,           \"nmadd\",          FP, \tnfmav2sf4)\n-BU_PAIRED_3 (SUM0,            \"sum0\",           FP, \tpaired_sum0)\n-BU_PAIRED_3 (SUM1,            \"sum1\",           FP, \tpaired_sum1)\n-BU_PAIRED_3 (SELV2SF4,        \"selv2sf4\",       CONST, \tselv2sf4)\n-\n-/* 2 argument paired floating point builtins.  */\n-BU_PAIRED_2 (DIVV2SF3,\t      \"divv2sf3\",\tFP,\tdivv2sf3)\n-BU_PAIRED_2 (ADDV2SF3,\t      \"addv2sf3\",\tFP,\taddv2sf3)\n-BU_PAIRED_2 (SUBV2SF3,\t      \"subv2sf3\",\tFP,\tsubv2sf3)\n-BU_PAIRED_2 (MULV2SF3,\t      \"mulv2sf3\",\tFP,\tmulv2sf3)\n-BU_PAIRED_2 (MULS0,\t      \"muls0\",\t\tFP,\tpaired_muls0)\n-BU_PAIRED_2 (MULS1,\t      \"muls1\",\t\tFP,\tpaired_muls1)\n-BU_PAIRED_2 (MERGE00,\t      \"merge00\",\tCONST,\tpaired_merge00)\n-BU_PAIRED_2 (MERGE01,\t      \"merge01\",\tCONST,\tpaired_merge01)\n-BU_PAIRED_2 (MERGE10,\t      \"merge10\",\tCONST,\tpaired_merge10)\n-BU_PAIRED_2 (MERGE11,\t      \"merge11\",\tCONST,\tpaired_merge11)\n-\n-/* 1 argument paired floating point builtin functions.  */\n-BU_PAIRED_1 (ABSV2SF2,\t      \"absv2sf2\",\tCONST,\tabsv2sf2)\n-BU_PAIRED_1 (NABSV2SF2,\t      \"nabsv2sf2\",\tCONST,\tnabsv2sf2)\n-BU_PAIRED_1 (NEGV2SF2,\t      \"negv2sf2\",\tCONST,\tnegv2sf2)\n-BU_PAIRED_1 (SQRTV2SF2,\t      \"sqrtv2sf2\",\tFP,\tsqrtv2sf2)\n-BU_PAIRED_1 (RESV2SF,\t      \"resv2sf2\",\tFP,\tresv2sf2)\n-\n-/* PAIRED builtins that are handled as special cases.  */\n-BU_PAIRED_X (STX,\t      \"stx\",\t\tMISC)\n-BU_PAIRED_X (LX,\t      \"lx\",\t\tMISC)\n-\n-/* Paired predicates.  */\n-BU_PAIRED_P (CMPU0,\t\"cmpu0\",\tCONST,\tpaired_cmpu0)\n-BU_PAIRED_P (CMPU1,\t\"cmpu1\",\tCONST,\tpaired_cmpu1)\n \f\n /* Power7 builtins, that aren't VSX instructions.  */\n BU_SPECIAL_X (POWER7_BUILTIN_BPERMD, \"__builtin_bpermd\", RS6000_BTM_POPCNTD,"}, {"sha": "d36d491784937f7bbd72c81bfaf4b5258bc23b87", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -494,17 +494,14 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n \tor TARGET_DOUBLE_FLOAT are turned off.  Hereafter, the\n \tOPTION_MASK_VSX flag is considered to have been turned off\n \texplicitly.\n-     3. If TARGET_PAIRED_FLOAT was enabled.  Hereafter, the\n-\tOPTION_MASK_VSX flag is considered to have been turned off\n-\texplicitly.\n-     4. If TARGET_AVOID_XFORM is turned on explicitly at the outermost\n+     3. If TARGET_AVOID_XFORM is turned on explicitly at the outermost\n \tcompilation context, or if it is turned on by any means in an\n \tinner compilation context.  Hereafter, the OPTION_MASK_VSX\n \tflag is considered to have been turned off explicitly.\n-     5. If TARGET_ALTIVEC was explicitly disabled.  Hereafter, the\n+     4. If TARGET_ALTIVEC was explicitly disabled.  Hereafter, the\n \tOPTION_MASK_VSX flag is considered to have been turned off\n \texplicitly.\n-     6. If an inner context (as introduced by\n+     5. If an inner context (as introduced by\n \t__attribute__((__target__())) or #pragma GCC target()\n \trequests a target that normally enables the\n \tOPTION_MASK_VSX flag but the outer-most \"main target\"\n@@ -590,10 +587,6 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n     rs6000_define_or_undefine_macro (define_p, \"__FLOAT128_HARDWARE__\");\n \n   /* options from the builtin masks.  */\n-  /* Note that RS6000_BTM_PAIRED is enabled only if\n-     TARGET_PAIRED_FLOAT is enabled (e.g. -mpaired).  */\n-  if ((bu_mask & RS6000_BTM_PAIRED) != 0)\n-    rs6000_define_or_undefine_macro (define_p, \"__PAIRED__\");\n   /* Note that RS6000_BTM_CELL is enabled only if (rs6000_cpu ==\n      PROCESSOR_CELL) (e.g. -mcpu=cell).  */\n   if ((bu_mask & RS6000_BTM_CELL) != 0)"}, {"sha": "bda6b8ac78e8b5a9a47ed49e1a4706480e8ce197", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -51,10 +51,6 @@ VECTOR_MODES (FLOAT, 16);     /*       V8HF  V4SF V2DF */\n VECTOR_MODES (INT, 32);       /* V32QI V16HI V8SI V4DI */\n VECTOR_MODES (FLOAT, 32);     /*       V16HF V8SF V4DF */\n \n-/* Paired single.  */\n-VECTOR_MODE (FLOAT, SF, 2);   /* The only valid paired-single mode.  */\n-VECTOR_MODE (INT, SI, 2);     /* For paired-single permutes.  */\n-\n /* Replacement for TImode that only is allowed in GPRs.  We also use PTImode\n    for quad memory atomic operations to force getting an even/odd register\n    combination.  */"}, {"sha": "1d3495bfa0f1a51e05db700411a4b9f9574948fa", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -149,7 +149,6 @@ enum rs6000_vector {\n   VECTOR_ALTIVEC,\t\t/* Use altivec for vector processing */\n   VECTOR_VSX,\t\t\t/* Use VSX for vector processing */\n   VECTOR_P8_VECTOR,\t\t/* Use ISA 2.07 VSX for vector processing */\n-  VECTOR_PAIRED,\t\t/* Use paired floating point for vectors */\n   VECTOR_OTHER\t\t\t/* Some other vector unit */\n };\n "}, {"sha": "a5ac1acfa83739c125ec5215dbe721e088a68a23", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -57,7 +57,6 @@ extern bool rs6000_move_128bit_ok_p (rtx []);\n extern bool rs6000_split_128bit_ok_p (rtx []);\n extern void rs6000_expand_float128_convert (rtx, rtx, bool);\n extern void rs6000_expand_vector_init (rtx, rtx);\n-extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);\n extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n@@ -110,9 +109,6 @@ extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n \t\t\t\t\t\t\t    rtx);\n extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n extern void rs6000_secondary_reload_gpr (rtx, rtx, rtx, bool);\n-extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,\n-                                         rtx, rtx, rtx);\n-extern void paired_expand_vector_move (rtx operands[]);\n \n \n extern int ccr_bit (rtx, int);"}, {"sha": "a591783f4f5e326b1545535b03bff85de08f96d2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 668, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -1271,7 +1271,6 @@ struct processor_costs ppca2_cost = {\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) \\\n@@ -1298,9 +1297,6 @@ struct processor_costs ppca2_cost = {\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)  \\\n   { NAME, ICODE, MASK, ATTR },\n \n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)  \\\n   { NAME, ICODE, MASK, ATTR },\n \n@@ -1324,7 +1320,6 @@ static const struct rs6000_builtin_info_type rs6000_builtin_info[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n /* Support for -mveclibabi=<xxx> to control which vector library to use.  */\n@@ -1359,8 +1354,6 @@ static tree builtin_function_type (machine_mode, machine_mode,\n \t\t\t\t   machine_mode, machine_mode,\n \t\t\t\t   enum rs6000_builtins, const char *name);\n static void rs6000_common_init_builtins (void);\n-static void paired_init_builtins (void);\n-static rtx paired_expand_predicate_builtin (enum insn_code, tree, rtx);\n static void htm_init_builtins (void);\n static rs6000_stack_t *rs6000_stack_info (void);\n static void is_altivec_return_reg (rtx, void *);\n@@ -2117,10 +2110,6 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n \t    return 1;\n \t}\n \n-      if (PAIRED_SIMD_REGNO_P (regno) && TARGET_PAIRED_FLOAT\n-\t  && PAIRED_VECTOR_MODE (mode))\n-\treturn 1;\n-\n       return 0;\n     }\n \n@@ -2190,11 +2179,6 @@ rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n   if (GET_MODE_CLASS (mode2) == MODE_CC)\n     return false;\n \n-  if (PAIRED_VECTOR_MODE (mode1))\n-    return PAIRED_VECTOR_MODE (mode2);\n-  if (PAIRED_VECTOR_MODE (mode2))\n-    return false;\n-\n   return true;\n }\n \n@@ -2311,7 +2295,6 @@ rs6000_debug_vector_unit (enum rs6000_vector v)\n     case VECTOR_ALTIVEC:   ret = \"altivec\";   break;\n     case VECTOR_VSX:\t   ret = \"vsx\";       break;\n     case VECTOR_P8_VECTOR: ret = \"p8_vector\"; break;\n-    case VECTOR_PAIRED:\t   ret = \"paired\";    break;\n     case VECTOR_OTHER:\t   ret = \"other\";     break;\n     default:\t\t   ret = \"unknown\";   break;\n     }\n@@ -2525,7 +2508,6 @@ rs6000_debug_reg_global (void)\n     SDmode,\n     DDmode,\n     TDmode,\n-    V2SImode,\n     V16QImode,\n     V8HImode,\n     V4SImode,\n@@ -2536,7 +2518,6 @@ rs6000_debug_reg_global (void)\n     V8SImode,\n     V4DImode,\n     V2TImode,\n-    V2SFmode,\n     V4SFmode,\n     V2DFmode,\n     V8SFmode,\n@@ -3257,8 +3238,6 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_vector_align[TImode] = align64;\n     }\n \n-  /* TODO add paired floating point vector support.  */\n-\n   /* Register class constraints for the constraints that depend on compile\n      switches. When the VSX code was added, different constraints were added\n      based on the type (DFmode, V2DFmode, V4SFmode).  For the vector types, all\n@@ -3896,15 +3875,14 @@ darwin_rs6000_override_options (void)\n \n /* Return the builtin mask of the various options used that could affect which\n    builtins were used.  In the past we used target_flags, but we've run out of\n-   bits, and some options like PAIRED are no longer in target_flags.  */\n+   bits, and some options are no longer in target_flags.  */\n \n HOST_WIDE_INT\n rs6000_builtin_mask_calculate (void)\n {\n   return (((TARGET_ALTIVEC)\t\t    ? RS6000_BTM_ALTIVEC   : 0)\n \t  | ((TARGET_CMPB)\t\t    ? RS6000_BTM_CMPB\t   : 0)\n \t  | ((TARGET_VSX)\t\t    ? RS6000_BTM_VSX\t   : 0)\n-\t  | ((TARGET_PAIRED_FLOAT)\t    ? RS6000_BTM_PAIRED\t   : 0)\n \t  | ((TARGET_FRE)\t\t    ? RS6000_BTM_FRE\t   : 0)\n \t  | ((TARGET_FRES)\t\t    ? RS6000_BTM_FRES\t   : 0)\n \t  | ((TARGET_FRSQRTE)\t\t    ? RS6000_BTM_FRSQRTE   : 0)\n@@ -4277,8 +4255,6 @@ rs6000_option_override_internal (bool global_init_p)\n \t      rs6000_isa_flags_explicit |= OPTION_MASK_VSX;\n \t    }\n \t}\n-      else if (TARGET_PAIRED_FLOAT)\n-\tmsg = N_(\"-mvsx and -mpaired are incompatible\");\n       else if (TARGET_AVOID_XFORM > 0)\n \tmsg = N_(\"-mvsx needs indexed addressing\");\n       else if (!TARGET_ALTIVEC && (rs6000_isa_flags_explicit\n@@ -5266,7 +5242,7 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* Set the builtin mask of the various options used that could affect which\n      builtins were used.  In the past we used target_flags, but we've run out\n-     of bits, and some options like PAIRED are no longer in target_flags.  */\n+     of bits, and some options are no longer in target_flags.  */\n   rs6000_builtin_mask = rs6000_builtin_mask_calculate ();\n   if (TARGET_DEBUG_BUILTIN || TARGET_DEBUG_TARGET)\n     rs6000_print_builtin_options (stderr, 0, \"builtin mask\",\n@@ -5593,9 +5569,6 @@ rs6000_preferred_simd_mode (scalar_mode mode)\n \treturn V16QImode;\n       default:;\n       }\n-  if (TARGET_PAIRED_FLOAT\n-      && mode == SFmode)\n-    return V2SFmode;\n   return word_mode;\n }\n \n@@ -6272,8 +6245,8 @@ num_insns_constant (rtx op, machine_mode mode)\n \n /* Interpret element ELT of the CONST_VECTOR OP as an integer value.\n    If the mode of OP is MODE_VECTOR_INT, this simply returns the\n-   corresponding element of the vector, but for V4SFmode and V2SFmode,\n-   the corresponding \"float\" is interpreted as an SImode integer.  */\n+   corresponding element of the vector, but for V4SFmode, the\n+   corresponding \"float\" is interpreted as an SImode integer.  */\n \n HOST_WIDE_INT\n const_vector_elt_as_int (rtx op, unsigned int elt)\n@@ -6285,8 +6258,7 @@ const_vector_elt_as_int (rtx op, unsigned int elt)\n \t      && GET_MODE (op) != V2DFmode);\n \n   tmp = CONST_VECTOR_ELT (op, elt);\n-  if (GET_MODE (op) == V4SFmode\n-      || GET_MODE (op) == V2SFmode)\n+  if (GET_MODE (op) == V4SFmode)\n     tmp = gen_lowpart (SImode, tmp);\n   return INTVAL (tmp);\n }\n@@ -6790,156 +6762,6 @@ output_vec_const_move (rtx *operands)\n   gcc_unreachable ();\n }\n \n-/* Initialize TARGET of vector PAIRED to VALS.  */\n-\n-void\n-paired_expand_vector_init (rtx target, rtx vals)\n-{\n-  machine_mode mode = GET_MODE (target);\n-  int n_elts = GET_MODE_NUNITS (mode);\n-  int n_var = 0;\n-  rtx x, new_rtx, tmp, constant_op, op1, op2;\n-  int i;\n-\n-  for (i = 0; i < n_elts; ++i)\n-    {\n-      x = XVECEXP (vals, 0, i);\n-      if (!(CONST_SCALAR_INT_P (x) || CONST_DOUBLE_P (x) || CONST_FIXED_P (x)))\n-\t++n_var;\n-    }\n-  if (n_var == 0)\n-    {\n-      /* Load from constant pool.  */\n-      emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n-      return;\n-    }\n-\n-  if (n_var == 2)\n-    {\n-      /* The vector is initialized only with non-constants.  */\n-      new_rtx = gen_rtx_VEC_CONCAT (V2SFmode, XVECEXP (vals, 0, 0),\n-\t\t\t\tXVECEXP (vals, 0, 1));\n-\n-      emit_move_insn (target, new_rtx);\n-      return;\n-    }\n-  \n-  /* One field is non-constant and the other one is a constant.  Load the\n-     constant from the constant pool and use ps_merge instruction to\n-     construct the whole vector.  */\n-  op1 = XVECEXP (vals, 0, 0);\n-  op2 = XVECEXP (vals, 0, 1);\n-\n-  constant_op = (CONSTANT_P (op1)) ? op1 : op2;\n-\n-  tmp = gen_reg_rtx (GET_MODE (constant_op));\n-  emit_move_insn (tmp, constant_op);\n-\n-  if (CONSTANT_P (op1))\n-    new_rtx = gen_rtx_VEC_CONCAT (V2SFmode, tmp, op2);\n-  else\n-    new_rtx = gen_rtx_VEC_CONCAT (V2SFmode, op1, tmp);\n-\n-  emit_move_insn (target, new_rtx);\n-}\n-\n-void\n-paired_expand_vector_move (rtx operands[])\n-{\n-  rtx op0 = operands[0], op1 = operands[1];\n-\n-  emit_move_insn (op0, op1);\n-}\n-\n-/* Emit vector compare for code RCODE.  DEST is destination, OP1 and\n-   OP2 are two VEC_COND_EXPR operands, CC_OP0 and CC_OP1 are the two\n-   operands for the relation operation COND.  This is a recursive\n-   function.  */\n-\n-static void\n-paired_emit_vector_compare (enum rtx_code rcode,\n-                            rtx dest, rtx op0, rtx op1,\n-                            rtx cc_op0, rtx cc_op1)\n-{\n-  rtx tmp = gen_reg_rtx (V2SFmode);\n-  rtx tmp1, max, min;\n-\n-  gcc_assert (TARGET_PAIRED_FLOAT);\n-  gcc_assert (GET_MODE (op0) == GET_MODE (op1));\n-\n-  switch (rcode)\n-    {\n-    case LT:\n-    case LTU:\n-      paired_emit_vector_compare (GE, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    case GE:\n-    case GEU:\n-      emit_insn (gen_subv2sf3 (tmp, cc_op0, cc_op1));\n-      emit_insn (gen_selv2sf4 (dest, tmp, op0, op1, CONST0_RTX (SFmode)));\n-      return;\n-    case LE:\n-    case LEU:\n-      paired_emit_vector_compare (GE, dest, op0, op1, cc_op1, cc_op0);\n-      return;\n-    case GT:\n-      paired_emit_vector_compare (LE, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    case EQ:\n-      tmp1 = gen_reg_rtx (V2SFmode);\n-      max = gen_reg_rtx (V2SFmode);\n-      min = gen_reg_rtx (V2SFmode);\n-      gen_reg_rtx (V2SFmode);\n-      \n-      emit_insn (gen_subv2sf3 (tmp, cc_op0, cc_op1));\n-      emit_insn (gen_selv2sf4\n-                 (max, tmp, cc_op0, cc_op1, CONST0_RTX (SFmode)));\n-      emit_insn (gen_subv2sf3 (tmp, cc_op1, cc_op0));\n-      emit_insn (gen_selv2sf4\n-                 (min, tmp, cc_op0, cc_op1, CONST0_RTX (SFmode)));\n-      emit_insn (gen_subv2sf3 (tmp1, min, max));\n-      emit_insn (gen_selv2sf4 (dest, tmp1, op0, op1, CONST0_RTX (SFmode)));\n-      return;\n-    case NE:\n-      paired_emit_vector_compare (EQ, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    case UNLE:\n-      paired_emit_vector_compare (LE, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    case UNLT:\n-      paired_emit_vector_compare (LT, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    case UNGE:\n-      paired_emit_vector_compare (GE, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    case UNGT:\n-      paired_emit_vector_compare (GT, dest, op1, op0, cc_op0, cc_op1);\n-      return;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return;\n-}\n-\n-/* Emit vector conditional expression.\n-   DEST is destination. OP1 and OP2 are two VEC_COND_EXPR operands.\n-   CC_OP0 and CC_OP1 are the two operands for the relation operation COND.  */\n-\n-int\n-paired_emit_vector_cond_expr (rtx dest, rtx op1, rtx op2,\n-\t\t\t      rtx cond, rtx cc_op0, rtx cc_op1)\n-{\n-  enum rtx_code rcode = GET_CODE (cond);\n-\n-  if (!TARGET_PAIRED_FLOAT)\n-    return 0;\n-\n-  paired_emit_vector_compare (rcode, dest, op1, op2, cc_op0, cc_op1);\n-\n-  return 1;\n-}\n-\n /* Initialize vector TARGET to VALS.  */\n \n void\n@@ -7869,16 +7691,8 @@ rs6000_data_alignment (tree type, unsigned int align, enum data_align how)\n {\n   if (how != align_opt)\n     {\n-      if (TREE_CODE (type) == VECTOR_TYPE)\n-\t{\n-\t  if (TARGET_PAIRED_FLOAT && PAIRED_VECTOR_MODE (TYPE_MODE (type)))\n-\t    {\n-\t      if (align < 64)\n-\t\talign = 64;\n-\t    }\n-\t  else if (align < 128)\n-\t    align = 128;\n-\t}\n+      if (TREE_CODE (type) == VECTOR_TYPE && align < 128)\n+\talign = 128;\n     }\n \n   if (how != align_abi)\n@@ -8293,13 +8107,6 @@ reg_offset_addressing_ok_p (machine_mode mode)\n \treturn mode_supports_vsx_dform_quad (mode);\n       break;\n \n-    case E_V2SImode:\n-    case E_V2SFmode:\n-       /* Paired vector modes.  Only reg+reg addressing is valid.  */\n-      if (TARGET_PAIRED_FLOAT)\n-        return false;\n-      break;\n-\n     case E_SDmode:\n       /* If we can do direct load/stores of SDmode, restrict it to reg+reg\n \t addressing for the LFIWZX and STFIWX instructions.  */\n@@ -8541,11 +8348,6 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n   extra = 0;\n   switch (mode)\n     {\n-    case E_V2SImode:\n-    case E_V2SFmode:\n-      /* Paired single modes: offset addressing isn't valid.  */\n-      return false;\n-\n     case E_DFmode:\n     case E_DDmode:\n     case E_DImode:\n@@ -8763,8 +8565,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1)) + 0x8000)\n-\t  >= 0x10000 - extra)\n-      && !PAIRED_VECTOR_MODE (mode))\n+\t  >= 0x10000 - extra))\n     {\n       HOST_WIDE_INT high_int, low_int;\n       rtx sum;\n@@ -8789,33 +8590,6 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t\t   force_reg (Pmode, force_operand (XEXP (x, 1), 0)));\n     }\n-  else if (PAIRED_VECTOR_MODE (mode))\n-    {\n-      if (mode == DImode)\n-\treturn x;\n-      /* We accept [reg + reg].  */\n-\n-      if (GET_CODE (x) == PLUS)\n-       {\n-         rtx op1 = XEXP (x, 0);\n-         rtx op2 = XEXP (x, 1);\n-         rtx y;\n-\n-         op1 = force_reg (Pmode, op1);\n-         op2 = force_reg (Pmode, op2);\n-\n-         /* We can't always do [reg + reg] for these, because [reg +\n-            reg + offset] is not a legitimate addressing mode.  */\n-         y = gen_rtx_PLUS (Pmode, op1, op2);\n-\n-         if ((GET_MODE_SIZE (mode) > 8 || mode == DDmode) && REG_P (op2))\n-           return force_reg (Pmode, y);\n-         else\n-           return y;\n-       }\n-\n-      return force_reg (Pmode, x);\n-    }\n   else if ((TARGET_ELF\n #if TARGET_MACHO\n \t    || !MACHO_DYNAMIC_NO_PIC_P\n@@ -9548,7 +9322,6 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n       && CONST_INT_P (XEXP (x, 1))\n       && reg_offset_p\n-      && !PAIRED_VECTOR_MODE (mode)\n       && (quad_offset_p || !VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n@@ -9589,7 +9362,6 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && reg_offset_p\n       && !quad_offset_p\n       && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode))\n-      && !PAIRED_VECTOR_MODE (mode)\n #if TARGET_MACHO\n       && DEFAULT_ABI == ABI_DARWIN\n       && (flag_pic || MACHO_DYNAMIC_NO_PIC_P)\n@@ -10745,8 +10517,6 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n     case E_V8HImode:\n     case E_V4SFmode:\n     case E_V4SImode:\n-    case E_V2SFmode:\n-    case E_V2SImode:\n     case E_V2DFmode:\n     case E_V2DImode:\n     case E_V1TImode:\n@@ -11386,8 +11156,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t\t      == long_double_type_node))))\n \t\trs6000_passes_long_double = true;\n \t    }\n-\t  if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode)\n-\t      || PAIRED_VECTOR_MODE (return_mode))\n+\t  if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode))\n \t    rs6000_passes_vector = true;\n \t}\n     }\n@@ -11560,10 +11329,9 @@ rs6000_function_arg_boundary (machine_mode mode, const_tree type)\n     return 64;\n   else if (FLOAT128_VECTOR_P (mode))\n     return 128;\n-  else if (PAIRED_VECTOR_MODE (mode)\n-\t   || (type && TREE_CODE (type) == VECTOR_TYPE\n-\t       && int_size_in_bytes (type) >= 8\n-\t       && int_size_in_bytes (type) < 16))\n+  else if (type && TREE_CODE (type) == VECTOR_TYPE\n+\t   && int_size_in_bytes (type) >= 8\n+\t   && int_size_in_bytes (type) < 16)\n     return 64;\n   else if (ALTIVEC_OR_VSX_VECTOR_MODE (elt_mode)\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n@@ -11839,10 +11607,7 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t      && TYPE_MAIN_VARIANT (type) == long_double_type_node)))\n \t    rs6000_passes_long_double = true;\n \t}\n-      if ((named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n-\t  || (PAIRED_VECTOR_MODE (mode)\n-\t      && !cum->stdarg\n-\t      && cum->sysv_gregno <= GP_ARG_MAX_REG))\n+      if (named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n \trs6000_passes_vector = true;\n     }\n #endif\n@@ -13629,7 +13394,6 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13642,7 +13406,6 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_3arg[] =\n@@ -13660,7 +13423,6 @@ static const struct builtin_description bdesc_3arg[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13673,7 +13435,6 @@ static const struct builtin_description bdesc_3arg[] =\n \n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_dst[] =\n@@ -13691,7 +13452,6 @@ static const struct builtin_description bdesc_dst[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13704,7 +13464,6 @@ static const struct builtin_description bdesc_dst[] =\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_2arg[] =\n@@ -13720,7 +13479,6 @@ static const struct builtin_description bdesc_2arg[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13733,7 +13491,6 @@ static const struct builtin_description bdesc_2arg[] =\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) \\\n   { MASK, ICODE, NAME, ENUM },\n \n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n /* AltiVec predicates.  */\n@@ -13743,36 +13500,6 @@ static const struct builtin_description bdesc_altivec_preds[] =\n #include \"rs6000-builtin.def\"\n };\n \n-/* PAIRED predicates.  */\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_paired_preds[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n /* ABS* operations.  */\n \n #undef RS6000_BUILTIN_0\n@@ -13783,7 +13510,6 @@ static const struct builtin_description bdesc_paired_preds[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13796,7 +13522,6 @@ static const struct builtin_description bdesc_paired_preds[] =\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_abs[] =\n@@ -13815,7 +13540,6 @@ static const struct builtin_description bdesc_abs[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13828,7 +13552,6 @@ static const struct builtin_description bdesc_abs[] =\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_1arg[] =\n@@ -13846,7 +13569,6 @@ static const struct builtin_description bdesc_1arg[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) \\\n@@ -13859,7 +13581,6 @@ static const struct builtin_description bdesc_1arg[] =\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_0arg[] =\n@@ -13876,7 +13597,6 @@ static const struct builtin_description bdesc_0arg[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n@@ -13889,7 +13609,6 @@ static const struct builtin_description bdesc_0arg[] =\n   { MASK, ICODE, NAME, ENUM },\n \n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE)\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n \n static const struct builtin_description bdesc_htm[] =\n@@ -13905,7 +13624,6 @@ static const struct builtin_description bdesc_htm[] =\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n \n /* Return true if a builtin function is overloaded.  */\n bool\n@@ -14252,52 +13970,6 @@ altivec_expand_predicate_builtin (enum insn_code icode, tree exp, rtx target)\n   return target;\n }\n \n-static rtx\n-paired_expand_lv_builtin (enum insn_code icode, tree exp, rtx target)\n-{\n-  rtx pat, addr;\n-  tree arg0 = CALL_EXPR_ARG (exp, 0);\n-  tree arg1 = CALL_EXPR_ARG (exp, 1);\n-  machine_mode tmode = insn_data[icode].operand[0].mode;\n-  machine_mode mode0 = Pmode;\n-  machine_mode mode1 = Pmode;\n-  rtx op0 = expand_normal (arg0);\n-  rtx op1 = expand_normal (arg1);\n-\n-  if (icode == CODE_FOR_nothing)\n-    /* Builtin not supported on this processor.  */\n-    return 0;\n-\n-  /* If we got invalid arguments bail out before generating bad rtl.  */\n-  if (arg0 == error_mark_node || arg1 == error_mark_node)\n-    return const0_rtx;\n-\n-  if (target == 0\n-      || GET_MODE (target) != tmode\n-      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n-    target = gen_reg_rtx (tmode);\n-\n-  op1 = copy_to_mode_reg (mode1, op1);\n-\n-  if (op0 == const0_rtx)\n-    {\n-      addr = gen_rtx_MEM (tmode, op1);\n-    }\n-  else\n-    {\n-      op0 = copy_to_mode_reg (mode0, op0);\n-      addr = gen_rtx_MEM (tmode, gen_rtx_PLUS (Pmode, op0, op1));\n-    }\n-\n-  pat = GEN_FCN (icode) (target, addr);\n-\n-  if (! pat)\n-    return 0;\n-  emit_insn (pat);\n-\n-  return target;\n-}\n-\n /* Return a constant vector for use as a little-endian permute control vector\n    to reverse the order of elements of the given vector mode.  */\n static rtx\n@@ -14514,47 +14186,6 @@ altivec_expand_lv_builtin (enum insn_code icode, tree exp, rtx target, bool blk)\n   return target;\n }\n \n-static rtx\n-paired_expand_stv_builtin (enum insn_code icode, tree exp)\n-{\n-  tree arg0 = CALL_EXPR_ARG (exp, 0);\n-  tree arg1 = CALL_EXPR_ARG (exp, 1);\n-  tree arg2 = CALL_EXPR_ARG (exp, 2);\n-  rtx op0 = expand_normal (arg0);\n-  rtx op1 = expand_normal (arg1);\n-  rtx op2 = expand_normal (arg2);\n-  rtx pat, addr;\n-  machine_mode tmode = insn_data[icode].operand[0].mode;\n-  machine_mode mode1 = Pmode;\n-  machine_mode mode2 = Pmode;\n-\n-  /* Invalid arguments.  Bail before doing anything stoopid!  */\n-  if (arg0 == error_mark_node\n-      || arg1 == error_mark_node\n-      || arg2 == error_mark_node)\n-    return const0_rtx;\n-\n-  if (! (*insn_data[icode].operand[1].predicate) (op0, tmode))\n-    op0 = copy_to_mode_reg (tmode, op0);\n-\n-  op2 = copy_to_mode_reg (mode2, op2);\n-\n-  if (op1 == const0_rtx)\n-    {\n-      addr = gen_rtx_MEM (tmode, op2);\n-    }\n-  else\n-    {\n-      op1 = copy_to_mode_reg (mode1, op1);\n-      addr = gen_rtx_MEM (tmode, gen_rtx_PLUS (Pmode, op1, op2));\n-    }\n-\n-  pat = GEN_FCN (icode) (addr, op0);\n-  if (pat)\n-    emit_insn (pat);\n-  return NULL_RTX;\n-}\n-\n static rtx\n altivec_expand_stxvl_builtin (enum insn_code icode, tree exp)\n {\n@@ -15182,10 +14813,7 @@ rs6000_expand_ternop_builtin (enum insn_code icode, tree exp, rtx target)\n   if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n     op2 = copy_to_mode_reg (mode2, op2);\n \n-  if (TARGET_PAIRED_FLOAT && icode == CODE_FOR_selv2sf4)\n-    pat = GEN_FCN (icode) (target, op0, op1, op2, CONST0_RTX (SFmode));\n-  else \n-    pat = GEN_FCN (icode) (target, op0, op1, op2);\n+  pat = GEN_FCN (icode) (target, op0, op1, op2);\n   if (! pat)\n     return 0;\n   emit_insn (pat);\n@@ -15798,113 +15426,6 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n   return NULL_RTX;\n }\n \n-/* Expand the builtin in EXP and store the result in TARGET.  Store\n-   true in *EXPANDEDP if we found a builtin to expand.  */\n-static rtx\n-paired_expand_builtin (tree exp, rtx target, bool * expandedp)\n-{\n-  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-  enum rs6000_builtins fcode = (enum rs6000_builtins) DECL_FUNCTION_CODE (fndecl);\n-  const struct builtin_description *d;\n-  size_t i;\n-\n-  *expandedp = true;\n-\n-  switch (fcode)\n-    {\n-    case PAIRED_BUILTIN_STX:\n-      return paired_expand_stv_builtin (CODE_FOR_paired_stx, exp);\n-    case PAIRED_BUILTIN_LX:\n-      return paired_expand_lv_builtin (CODE_FOR_paired_lx, exp, target);\n-    default:\n-      break;\n-      /* Fall through.  */\n-    }\n-\n-  /* Expand the paired predicates.  */\n-  d = bdesc_paired_preds;\n-  for (i = 0; i < ARRAY_SIZE (bdesc_paired_preds); i++, d++)\n-    if (d->code == fcode)\n-      return paired_expand_predicate_builtin (d->icode, exp, target);\n-\n-  *expandedp = false;\n-  return NULL_RTX;\n-}\n-\n-static rtx\n-paired_expand_predicate_builtin (enum insn_code icode, tree exp, rtx target)\n-{\n-  rtx pat, scratch, tmp;\n-  tree form = CALL_EXPR_ARG (exp, 0);\n-  tree arg0 = CALL_EXPR_ARG (exp, 1);\n-  tree arg1 = CALL_EXPR_ARG (exp, 2);\n-  rtx op0 = expand_normal (arg0);\n-  rtx op1 = expand_normal (arg1);\n-  machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  machine_mode mode1 = insn_data[icode].operand[2].mode;\n-  int form_int;\n-  enum rtx_code code;\n-\n-  if (TREE_CODE (form) != INTEGER_CST)\n-    {\n-      error (\"argument 1 of %s must be a constant\",\n-\t     \"__builtin_paired_predicate\");\n-      return const0_rtx;\n-    }\n-  else\n-    form_int = TREE_INT_CST_LOW (form);\n-\n-  gcc_assert (mode0 == mode1);\n-\n-  if (arg0 == error_mark_node || arg1 == error_mark_node)\n-    return const0_rtx;\n-\n-  if (target == 0\n-      || GET_MODE (target) != SImode\n-      || !(*insn_data[icode].operand[0].predicate) (target, SImode))\n-    target = gen_reg_rtx (SImode);\n-  if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n-    op0 = copy_to_mode_reg (mode0, op0);\n-  if (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-    op1 = copy_to_mode_reg (mode1, op1);\n-\n-  scratch = gen_reg_rtx (CCFPmode);\n-\n-  pat = GEN_FCN (icode) (scratch, op0, op1);\n-  if (!pat)\n-    return const0_rtx;\n-\n-  emit_insn (pat);\n-\n-  switch (form_int)\n-    {\n-      /* LT bit.  */\n-    case 0:\n-      code = LT;\n-      break;\n-      /* GT bit.  */\n-    case 1:\n-      code = GT;\n-      break;\n-      /* EQ bit.  */\n-    case 2:\n-      code = EQ;\n-      break;\n-      /* UN bit.  */\n-    case 3:\n-      emit_insn (gen_move_from_CR_ov_bit (target, scratch));\n-      return target;\n-    default:\n-      error (\"argument 1 of %qs is out of range\",\n-\t     \"__builtin_paired_predicate\");\n-      return const0_rtx;\n-    }\n-\n-  tmp = gen_rtx_fmt_ee (code, SImode, scratch, const0_rtx);\n-  emit_move_insn (target, tmp);\n-  return target;\n-}\n-\n /* Check whether a builtin function is supported in this target\n    configuration.  */\n bool\n@@ -15936,8 +15457,6 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n     error (\"builtin function %qs requires the %qs option\", name, \"-mhtm\");\n   else if ((fnmask & RS6000_BTM_ALTIVEC) != 0)\n     error (\"builtin function %qs requires the %qs option\", name, \"-maltivec\");\n-  else if ((fnmask & RS6000_BTM_PAIRED) != 0)\n-    error (\"builtin function %qs requires the %qs option\", name, \"-mpaired\");\n   else if ((fnmask & (RS6000_BTM_DFP | RS6000_BTM_P8_VECTOR))\n \t   == (RS6000_BTM_DFP | RS6000_BTM_P8_VECTOR))\n     error (\"builtin function %qs requires the %qs and %qs options\",\n@@ -16856,13 +16375,6 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       if (success)\n \treturn ret;\n     }\n-  if (TARGET_PAIRED_FLOAT)\n-    {\n-      ret = paired_expand_builtin (exp, target, &success);\n-\n-      if (success)\n-\treturn ret;\n-    }  \n   if (TARGET_HTM)\n     {\n       ret = htm_expand_builtin (exp, target, &success);\n@@ -16929,13 +16441,10 @@ rs6000_init_builtins (void)\n   machine_mode mode;\n \n   if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"rs6000_init_builtins%s%s%s\\n\",\n-\t     (TARGET_PAIRED_FLOAT) ? \", paired\"\t : \"\",\n+    fprintf (stderr, \"rs6000_init_builtins%s%s\\n\",\n \t     (TARGET_ALTIVEC)\t   ? \", altivec\" : \"\",\n \t     (TARGET_VSX)\t   ? \", vsx\"\t : \"\");\n \n-  V2SI_type_node = build_vector_type (intSI_type_node, 2);\n-  V2SF_type_node = build_vector_type (float_type_node, 2);\n   V2DI_type_node = rs6000_vector_type (TARGET_POWERPC64 ? \"__vector long\"\n \t\t\t\t       : \"__vector long long\",\n \t\t\t\t       intDI_type_node, 2);\n@@ -16959,9 +16468,6 @@ rs6000_init_builtins (void)\n \t\t\t\t       : \"__vector unsigned long long\",\n \t\t\t\t       unsigned_intDI_type_node, 2);\n \n-  opaque_V2SF_type_node = build_opaque_vector_type (float_type_node, 2);\n-  opaque_V2SI_type_node = build_opaque_vector_type (intSI_type_node, 2);\n-  opaque_p_V2SI_type_node = build_pointer_type (opaque_V2SI_type_node);\n   opaque_V4SI_type_node = build_opaque_vector_type (intSI_type_node, 4);\n \n   const_str_type_node\n@@ -17069,8 +16575,6 @@ rs6000_init_builtins (void)\n   builtin_mode_to_type[TDmode][0] = dfloat128_type_node;\n   builtin_mode_to_type[V1TImode][0] = V1TI_type_node;\n   builtin_mode_to_type[V1TImode][1] = unsigned_V1TI_type_node;\n-  builtin_mode_to_type[V2SImode][0] = V2SI_type_node;\n-  builtin_mode_to_type[V2SFmode][0] = V2SF_type_node;\n   builtin_mode_to_type[V2DImode][0] = V2DI_type_node;\n   builtin_mode_to_type[V2DImode][1] = unsigned_V2DI_type_node;\n   builtin_mode_to_type[V2DFmode][0] = V2DF_type_node;\n@@ -17107,19 +16611,15 @@ rs6000_init_builtins (void)\n   pixel_V8HI_type_node = rs6000_vector_type (\"__vector __pixel\",\n \t\t\t\t\t     pixel_type_node, 8);\n \n-  /* Paired builtins are only available if you build a compiler with the\n-     appropriate options, so only create those builtins with the appropriate\n-     compiler option.  Create Altivec and VSX builtins on machines with at\n-     least the general purpose extensions (970 and newer) to allow the use of\n+  /* Create Altivec and VSX builtins on machines with at least the\n+     general purpose extensions (970 and newer) to allow the use of\n      the target attribute.  */\n-  if (TARGET_PAIRED_FLOAT)\n-    paired_init_builtins ();\n   if (TARGET_EXTRA_BUILTINS)\n     altivec_init_builtins ();\n   if (TARGET_HTM)\n     htm_init_builtins ();\n \n-  if (TARGET_EXTRA_BUILTINS || TARGET_PAIRED_FLOAT)\n+  if (TARGET_EXTRA_BUILTINS)\n     rs6000_common_init_builtins ();\n \n   ftype = builtin_function_type (DFmode, DFmode, DFmode, VOIDmode,\n@@ -17203,78 +16703,6 @@ rs6000_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n   return rs6000_builtin_decls[code];\n }\n \n-static void\n-paired_init_builtins (void)\n-{\n-  const struct builtin_description *d;\n-  size_t i;\n-  HOST_WIDE_INT builtin_mask = rs6000_builtin_mask;\n-\n-   tree int_ftype_int_v2sf_v2sf\n-    = build_function_type_list (integer_type_node,\n-                                integer_type_node,\n-                                V2SF_type_node,\n-                                V2SF_type_node,\n-                                NULL_TREE);\n-  tree pcfloat_type_node =\n-    build_pointer_type (build_qualified_type\n-\t\t\t(float_type_node, TYPE_QUAL_CONST));\n-\n-  tree v2sf_ftype_long_pcfloat = build_function_type_list (V2SF_type_node,\n-\t\t\t\t\t\t\t   long_integer_type_node,\n-\t\t\t\t\t\t\t   pcfloat_type_node,\n-\t\t\t\t\t\t\t   NULL_TREE);\n-  tree void_ftype_v2sf_long_pcfloat =\n-    build_function_type_list (void_type_node,\n-\t\t\t      V2SF_type_node,\n-\t\t\t      long_integer_type_node,\n-\t\t\t      pcfloat_type_node,\n-\t\t\t      NULL_TREE);\n-\n-\n-  def_builtin (\"__builtin_paired_lx\", v2sf_ftype_long_pcfloat,\n-\t       PAIRED_BUILTIN_LX);\n-\n-\n-  def_builtin (\"__builtin_paired_stx\", void_ftype_v2sf_long_pcfloat,\n-\t       PAIRED_BUILTIN_STX);\n-\n-  /* Predicates.  */\n-  d = bdesc_paired_preds;\n-  for (i = 0; i < ARRAY_SIZE (bdesc_paired_preds); ++i, d++)\n-    {\n-      tree type;\n-      HOST_WIDE_INT mask = d->mask;\n-\n-      if ((mask & builtin_mask) != mask)\n-\t{\n-\t  if (TARGET_DEBUG_BUILTIN)\n-\t    fprintf (stderr, \"paired_init_builtins, skip predicate %s\\n\",\n-\t\t     d->name);\n-\t  continue;\n-\t}\n-\n-      /* Cannot define builtin if the instruction is disabled.  */\n-      gcc_assert (d->icode != CODE_FOR_nothing);\n-\n-      if (TARGET_DEBUG_BUILTIN)\n-\tfprintf (stderr, \"paired pred #%d, insn = %s [%d], mode = %s\\n\",\n-\t\t (int)i, get_insn_name (d->icode), (int)d->icode,\n-\t\t GET_MODE_NAME (insn_data[d->icode].operand[1].mode));\n-\n-      switch (insn_data[d->icode].operand[1].mode)\n-\t{\n-\tcase E_V2SFmode:\n-\t  type = int_ftype_int_v2sf_v2sf;\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      def_builtin (d->name, type, d->code);\n-    }\n-}\n-\n static void\n altivec_init_builtins (void)\n {\n@@ -18260,23 +17688,11 @@ rs6000_common_init_builtins (void)\n   tree opaque_ftype_opaque = NULL_TREE;\n   tree opaque_ftype_opaque_opaque = NULL_TREE;\n   tree opaque_ftype_opaque_opaque_opaque = NULL_TREE;\n-  tree v2si_ftype = NULL_TREE;\n-  tree v2si_ftype_qi = NULL_TREE;\n-  tree v2si_ftype_v2si_qi = NULL_TREE;\n-  tree v2si_ftype_int_qi = NULL_TREE;\n   HOST_WIDE_INT builtin_mask = rs6000_builtin_mask;\n \n-  if (!TARGET_PAIRED_FLOAT)\n-    {\n-      builtin_mode_to_type[V2SImode][0] = opaque_V2SI_type_node;\n-      builtin_mode_to_type[V2SFmode][0] = opaque_V2SF_type_node;\n-    }\n-\n-  /* Paired builtins are only available if you build a compiler with the\n-     appropriate options, so only create those builtins with the appropriate\n-     compiler option.  Create Altivec and VSX builtins on machines with at\n-     least the general purpose extensions (970 and newer) to allow the use of\n-     the target attribute..  */\n+  /* Create Altivec and VSX builtins on machines with at least the\n+     general purpose extensions (970 and newer) to allow the use of\n+     the target attribute.  */\n \n   if (TARGET_EXTRA_BUILTINS)\n     builtin_mask |= RS6000_BTM_COMMON;\n@@ -18385,30 +17801,8 @@ rs6000_common_init_builtins (void)\n           mode1 = insn_data[icode].operand[1].mode;\n           mode2 = insn_data[icode].operand[2].mode;\n \n-\t  if (mode0 == V2SImode && mode1 == V2SImode && mode2 == QImode)\n-\t    {\n-\t      if (! (type = v2si_ftype_v2si_qi))\n-\t\ttype = v2si_ftype_v2si_qi\n-\t\t  = build_function_type_list (opaque_V2SI_type_node,\n-\t\t\t\t\t      opaque_V2SI_type_node,\n-\t\t\t\t\t      char_type_node,\n-\t\t\t\t\t      NULL_TREE);\n-\t    }\n-\n-\t  else if (mode0 == V2SImode && GET_MODE_CLASS (mode1) == MODE_INT\n-\t\t   && mode2 == QImode)\n-\t    {\n-\t      if (! (type = v2si_ftype_int_qi))\n-\t\ttype = v2si_ftype_int_qi\n-\t\t  = build_function_type_list (opaque_V2SI_type_node,\n-\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t      char_type_node,\n-\t\t\t\t\t      NULL_TREE);\n-\t    }\n-\n-\t  else\n-\t    type = builtin_function_type (mode0, mode1, mode2, VOIDmode,\n-\t\t\t\t\t  d->code, d->name);\n+\t  type = builtin_function_type (mode0, mode1, mode2, VOIDmode,\n+\t\t\t\t\td->code, d->name);\n \t}\n \n       def_builtin (d->name, type, d->code);\n@@ -18461,18 +17855,8 @@ rs6000_common_init_builtins (void)\n           mode0 = insn_data[icode].operand[0].mode;\n           mode1 = insn_data[icode].operand[1].mode;\n \n-\t  if (mode0 == V2SImode && mode1 == QImode)\n-\t    {\n-\t      if (! (type = v2si_ftype_qi))\n-\t\ttype = v2si_ftype_qi\n-\t\t  = build_function_type_list (opaque_V2SI_type_node,\n-\t\t\t\t\t      char_type_node,\n-\t\t\t\t\t      NULL_TREE);\n-\t    }\n-\n-\t  else\n-\t    type = builtin_function_type (mode0, mode1, VOIDmode, VOIDmode,\n-\t\t\t\t\t  d->code, d->name);\n+\t  type = builtin_function_type (mode0, mode1, VOIDmode, VOIDmode,\n+\t\t\t\t\td->code, d->name);\n \t}\n \n       def_builtin (d->name, type, d->code);\n@@ -18518,20 +17902,8 @@ rs6000_common_init_builtins (void)\n \t      continue;\n \t    }\n \t  mode0 = insn_data[icode].operand[0].mode;\n-\t  if (mode0 == V2SImode)\n-\t    {\n-\t      /* code for paired single */\n-\t      if (! (type = v2si_ftype))\n-\t\t{\n-\t\t  v2si_ftype\n-\t\t    = build_function_type_list (opaque_V2SI_type_node, \n-\t\t\t\t\t\tNULL_TREE);\n-\t\t  type = v2si_ftype;\n-\t\t}\n-\t    }\n-\t  else\n-\t    type = builtin_function_type (mode0, VOIDmode, VOIDmode, VOIDmode,\n-\t\t\t\t\t  d->code, d->name);\n+\t  type = builtin_function_type (mode0, VOIDmode, VOIDmode, VOIDmode,\n+\t\t\t\t\td->code, d->name);\n \t}\n       def_builtin (d->name, type, d->code);\n     }\n@@ -35954,7 +35326,7 @@ altivec_expand_vec_perm_const (rtx target, rtx op0, rtx op1,\n   return false;\n }\n \n-/* Expand a Paired Single or VSX Permute Doubleword constant permutation.\n+/* Expand a VSX Permute Doubleword constant permutation.\n    Return true if we match an efficient implementation.  */\n \n static bool\n@@ -36020,9 +35392,7 @@ rs6000_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n     return true;\n \n   /* Check for ps_merge* or xxpermdi insns.  */\n-  if ((vmode == V2SFmode && TARGET_PAIRED_FLOAT)\n-      || ((vmode == V2DFmode || vmode == V2DImode)\n-\t  && VECTOR_MEM_VSX_P (vmode)))\n+  if ((vmode == V2DFmode || vmode == V2DImode) && VECTOR_MEM_VSX_P (vmode))\n     {\n       if (testing_p)\n \t{\n@@ -36477,14 +35847,10 @@ rs6000_scalar_mode_supported_p (scalar_mode mode)\n static bool\n rs6000_vector_mode_supported_p (machine_mode mode)\n {\n-\n-  if (TARGET_PAIRED_FLOAT && PAIRED_VECTOR_MODE (mode))\n-    return true;\n-\n   /* There is no vector form for IEEE 128-bit.  If we return true for IEEE\n      128-bit, the compiler might try to widen IEEE 128-bit to IBM\n      double-double.  */\n-  else if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode) && !FLOAT128_IEEE_P (mode))\n+  if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode) && !FLOAT128_IEEE_P (mode))\n     return true;\n \n   else\n@@ -36678,7 +36044,6 @@ static struct rs6000_opt_mask const rs6000_builtin_mask_names[] =\n {\n   { \"altivec\",\t\t RS6000_BTM_ALTIVEC,\tfalse, false },\n   { \"vsx\",\t\t RS6000_BTM_VSX,\tfalse, false },\n-  { \"paired\",\t\t RS6000_BTM_PAIRED,\tfalse, false },\n   { \"fre\",\t\t RS6000_BTM_FRE,\tfalse, false },\n   { \"fres\",\t\t RS6000_BTM_FRES,\tfalse, false },\n   { \"frsqrte\",\t\t RS6000_BTM_FRSQRTE,\tfalse, false },\n@@ -36715,9 +36080,6 @@ static struct rs6000_opt_var const rs6000_opt_vars[] =\n   { \"avoid-indexed-addresses\",\n     offsetof (struct gcc_options, x_TARGET_AVOID_XFORM),\n     offsetof (struct cl_target_option, x_TARGET_AVOID_XFORM) },\n-  { \"paired\",\n-    offsetof (struct gcc_options, x_rs6000_paired_float),\n-    offsetof (struct cl_target_option, x_rs6000_paired_float), },\n   { \"longcall\",\n     offsetof (struct gcc_options, x_rs6000_default_long_calls),\n     offsetof (struct cl_target_option, x_rs6000_default_long_calls), },"}, {"sha": "fb27ee6f89912ba2b31278f9aa4154b50e79c90c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 12, "deletions": 40, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -67,10 +67,6 @@\n #define PPC405_ERRATUM77 0\n #endif\n \n-#ifndef TARGET_PAIRED_FLOAT\n-#define TARGET_PAIRED_FLOAT 0\n-#endif\n-\n #ifdef HAVE_AS_POPCNTB\n #define ASM_CPU_POWER5_SPEC \"-mpower5\"\n #else\n@@ -695,19 +691,16 @@ extern int rs6000_vector_align[];\n /* For power systems, we want to enable Altivec and VSX builtins even if the\n    user did not use -maltivec or -mvsx to allow the builtins to be used inside\n    of #pragma GCC target or the target attribute to change the code level for a\n-   given system.  The Paired builtins are only enabled if you configure the\n-   compiler for those builtins, and those machines don't support altivec or\n-   VSX.  */\n-\n-#define TARGET_EXTRA_BUILTINS\t(!TARGET_PAIRED_FLOAT\t\t\t \\\n-\t\t\t\t && ((TARGET_POWERPC64\t\t\t \\\n-\t\t\t\t      || TARGET_PPC_GPOPT /* 970/power4 */ \\\n-\t\t\t\t      || TARGET_POPCNTB\t  /* ISA 2.02 */ \\\n-\t\t\t\t      || TARGET_CMPB\t  /* ISA 2.05 */ \\\n-\t\t\t\t      || TARGET_POPCNTD\t  /* ISA 2.06 */ \\\n-\t\t\t\t      || TARGET_ALTIVEC\t\t\t \\\n-\t\t\t\t      || TARGET_VSX\t\t\t \\\n-\t\t\t\t      || TARGET_HARD_FLOAT)))\n+   given system.  */\n+\n+#define TARGET_EXTRA_BUILTINS\t(TARGET_POWERPC64\t\t\t \\\n+\t\t\t\t || TARGET_PPC_GPOPT /* 970/power4 */\t \\\n+\t\t\t\t || TARGET_POPCNTB   /* ISA 2.02 */\t \\\n+\t\t\t\t || TARGET_CMPB      /* ISA 2.05 */\t \\\n+\t\t\t\t || TARGET_POPCNTD   /* ISA 2.06 */\t \\\n+\t\t\t\t || TARGET_ALTIVEC\t\t\t \\\n+\t\t\t\t || TARGET_VSX\t\t\t\t \\\n+\t\t\t\t || TARGET_HARD_FLOAT)\n \n /* E500 cores only support plain \"sync\", not lwsync.  */\n #define TARGET_NO_LWSYNC (rs6000_cpu == PROCESSOR_PPC8540 \\\n@@ -863,7 +856,6 @@ extern unsigned char rs6000_recip_bits[];\n #define UNITS_PER_FP_WORD 8\n #define UNITS_PER_ALTIVEC_WORD 16\n #define UNITS_PER_VSX_WORD 16\n-#define UNITS_PER_PAIRED_WORD 8\n \n /* Type used for ptrdiff_t, as a string used in a declaration.  */\n #define PTRDIFF_TYPE \"int\"\n@@ -1169,9 +1161,6 @@ enum data_align { align_abi, align_opt, align_both };\n #define INT_REGNO_P(N) \\\n   ((N) <= 31 || (N) == ARG_POINTER_REGNUM || (N) == FRAME_POINTER_REGNUM)\n \n-/* PAIRED SIMD registers are just the FPRs.  */\n-#define PAIRED_SIMD_REGNO_P(N) ((N) >= 32 && (N) <= 63)\n-\n /* True if register is the CA register.  */\n #define CA_REGNO_P(N) ((N) == CA_REGNO)\n \n@@ -1232,9 +1221,6 @@ enum data_align { align_abi, align_opt, align_both };\n   (ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE)\t\t\t\\\n    || (MODE) == V2DImode || (MODE) == V1TImode)\n \n-#define PAIRED_VECTOR_MODE(MODE)        \\\n-         ((MODE) == V2SFmode)            \n-\n /* Post-reload, we can't use any new AltiVec registers, as we already\n    emitted the vrsave mask.  */\n \n@@ -2484,8 +2470,8 @@ extern int frame_pointer_needed;\n #define RS6000_BTC_SAT\t\tRS6000_BTC_MISC\t/* saturate sets VSCR.  */\n \n /* Builtin targets.  For now, we reuse the masks for those options that are in\n-   target flags, and pick two random bits for paired and ldbl128, which\n-   aren't in target_flags.  */\n+   target flags, and pick a random bit for ldbl128, which isn't in\n+   target_flags.  */\n #define RS6000_BTM_ALWAYS\t0\t\t/* Always enabled.  */\n #define RS6000_BTM_ALTIVEC\tMASK_ALTIVEC\t/* VMX/altivec vectors.  */\n #define RS6000_BTM_CMPB\t\tMASK_CMPB\t/* ISA 2.05: compare bytes.  */\n@@ -2495,7 +2481,6 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_P9_MISC\tMASK_P9_MISC\t/* ISA 3.0 misc. non-vector */\n #define RS6000_BTM_CRYPTO\tMASK_CRYPTO\t/* crypto funcs.  */\n #define RS6000_BTM_HTM\t\tMASK_HTM\t/* hardware TM funcs.  */\n-#define RS6000_BTM_PAIRED\tMASK_MULHW\t/* 750CL paired insns.  */\n #define RS6000_BTM_FRE\t\tMASK_POPCNTB\t/* FRE instruction.  */\n #define RS6000_BTM_FRES\t\tMASK_PPC_GFXOPT\t/* FRES instruction.  */\n #define RS6000_BTM_FRSQRTE\tMASK_PPC_GFXOPT\t/* FRSQRTE instruction.  */\n@@ -2541,7 +2526,6 @@ extern int frame_pointer_needed;\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n #define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n@@ -2552,7 +2536,6 @@ extern int frame_pointer_needed;\n #define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_Q(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n #define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n \n enum rs6000_builtins\n@@ -2570,20 +2553,14 @@ enum rs6000_builtins\n #undef RS6000_BUILTIN_D\n #undef RS6000_BUILTIN_H\n #undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_Q\n #undef RS6000_BUILTIN_X\n \n enum rs6000_builtin_type_index\n {\n   RS6000_BTI_NOT_OPAQUE,\n-  RS6000_BTI_opaque_V2SI,\n-  RS6000_BTI_opaque_V2SF,\n-  RS6000_BTI_opaque_p_V2SI,\n   RS6000_BTI_opaque_V4SI,\n   RS6000_BTI_V16QI,              /* __vector signed char */\n   RS6000_BTI_V1TI,\n-  RS6000_BTI_V2SI,\n-  RS6000_BTI_V2SF,\n   RS6000_BTI_V2DI,\n   RS6000_BTI_V2DF,\n   RS6000_BTI_V4HI,\n@@ -2638,16 +2615,11 @@ enum rs6000_builtin_type_index\n };\n \n \n-#define opaque_V2SI_type_node         (rs6000_builtin_types[RS6000_BTI_opaque_V2SI])\n-#define opaque_V2SF_type_node         (rs6000_builtin_types[RS6000_BTI_opaque_V2SF])\n-#define opaque_p_V2SI_type_node       (rs6000_builtin_types[RS6000_BTI_opaque_p_V2SI])\n #define opaque_V4SI_type_node         (rs6000_builtin_types[RS6000_BTI_opaque_V4SI])\n #define V16QI_type_node               (rs6000_builtin_types[RS6000_BTI_V16QI])\n #define V1TI_type_node                (rs6000_builtin_types[RS6000_BTI_V1TI])\n #define V2DI_type_node                (rs6000_builtin_types[RS6000_BTI_V2DI])\n #define V2DF_type_node                (rs6000_builtin_types[RS6000_BTI_V2DF])\n-#define V2SI_type_node                (rs6000_builtin_types[RS6000_BTI_V2SI])\n-#define V2SF_type_node                (rs6000_builtin_types[RS6000_BTI_V2SF])\n #define V4HI_type_node                (rs6000_builtin_types[RS6000_BTI_V4HI])\n #define V4SI_type_node                (rs6000_builtin_types[RS6000_BTI_V4SI])\n #define V4SF_type_node                (rs6000_builtin_types[RS6000_BTI_V4SF])"}, {"sha": "0c8b86997a8b5e195b7718d642094f896fcd5a0e", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -394,7 +394,6 @@\n   (SF \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\")\n   (DF \"(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n        || VECTOR_UNIT_VSX_P (DFmode)\")\n-  (V2SF \"TARGET_PAIRED_FLOAT\")\n   (V4SF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\")\n   (V2DF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V2DFmode)\")\n   (KF \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (KFmode)\")\n@@ -11663,16 +11662,6 @@\n \t(const_string \"mfcr\")))\n    (set_attr \"length\" \"8\")])\n \n-;; Same as above, but get the OV/ORDERED bit.\n-(define_insn \"move_from_CR_ov_bit\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(unspec:SI [(match_operand:CC 1 \"cc_reg_operand\" \"y\")]\n-\t\t   UNSPEC_MV_CR_OV))]\n-  \"TARGET_PAIRED_FLOAT\"\n-  \"mfcr %0\\;rlwinm %0,%0,%t1,1\"\n-  [(set_attr \"type\" \"mfcr\")\n-   (set_attr \"length\" \"8\")])\n-\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(match_operator:DI 1 \"scc_comparison_operator\"\n@@ -14572,6 +14561,5 @@\n (include \"vsx.md\")\n (include \"altivec.md\")\n (include \"dfp.md\")\n-(include \"paired.md\")\n (include \"crypto.md\")\n (include \"htm.md\")"}, {"sha": "f4fa35378d92986a915dc35f352219600486de59", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -357,10 +357,6 @@ misel=yes\n Target RejectNegative Alias(misel) Warn(%<-misel=yes%> is deprecated; use %<-misel%> instead)\n Deprecated option.  Use -misel instead.\n \n-mpaired\n-Target Var(rs6000_paired_float) Save\n-Generate PPC750CL paired-single instructions.\n-\n mdebug=\n Target RejectNegative Joined\n -mdebug=\tEnable debug output."}, {"sha": "0adb5f595939234b5f63d3adc04fbd0db353f5ab", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -72,5 +72,4 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/altivec.md \\\n \t$(srcdir)/config/rs6000/crypto.md \\\n \t$(srcdir)/config/rs6000/htm.md \\\n-\t$(srcdir)/config/rs6000/dfp.md \\\n-\t$(srcdir)/config/rs6000/paired.md\n+\t$(srcdir)/config/rs6000/dfp.md"}, {"sha": "b3d23aa2e9a1985393d126194e1688e053a68929", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/559289370f76bfdb6a2ebfb4315c18206d73027a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=559289370f76bfdb6a2ebfb4315c18206d73027a", "patch": "@@ -1089,7 +1089,6 @@ See RS/6000 and PowerPC Options.\n -mstring-compare-inline-limit=@var{num} @gol\n -misel  -mno-isel @gol\n -misel=yes  -misel=no @gol\n--mpaired @gol\n -mvrsave  -mno-vrsave @gol\n -mmulhw  -mno-mulhw @gol\n -mdlmzb  -mno-dlmzb @gol\n@@ -23475,13 +23474,6 @@ This switch enables or disables the generation of ISEL instructions.\n This switch has been deprecated.  Use @option{-misel} and\n @option{-mno-isel} instead.\n \n-@item -mpaired\n-@itemx -mno-paired\n-@opindex mpaired\n-@opindex mno-paired\n-This switch enables or disables the generation of PAIRED simd\n-instructions.\n-\n @item -mvsx\n @itemx -mno-vsx\n @opindex mvsx"}]}