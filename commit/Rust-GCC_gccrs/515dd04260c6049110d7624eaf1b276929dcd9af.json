{"sha": "515dd04260c6049110d7624eaf1b276929dcd9af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1ZGQwNDI2MGM2MDQ5MTEwZDc2MjRlYWYxYjI3NjkyOWRjZDlhZg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-02-14T14:02:35Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-02-14T14:02:35Z"}, "message": "sra: Avoid verification failure (PR 93516)\n\nget_ref_base_and_extent can return different sizes for COMPONENT_REFs\nand DECLs of the same type, with the latter including (more?)  padding.\nWhen in the IL there is an assignment between such a COMPONENT_REF and a\nDECL, SRA will try to propagate the access from the former as a child of\nthe latter, creating an artificial reference that does not match the\naccess's declared size, which triggers a verifier assert.\n\nFixed by teaching the propagation functions about this special situation\nso that they don't do it.  The condition is the same that\nbuild_user_friendly_ref_for_offset uses so the artificial reference\ncausing the verifier is guaranteed not to be created.\n\n2020-02-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/93516\n\t* tree-sra.c (propagate_subaccesses_from_rhs): Do not create\n\taccess of the same type as the parent.\n\t(propagate_subaccesses_from_lhs): Likewise.\n\n\tgcc/testsuite/\n\t* g++.dg/tree-ssa/pr93516.C: New test.", "tree": {"sha": "e62aa998fdbd5b7def31b1bcabc6970603962821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e62aa998fdbd5b7def31b1bcabc6970603962821"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/515dd04260c6049110d7624eaf1b276929dcd9af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515dd04260c6049110d7624eaf1b276929dcd9af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515dd04260c6049110d7624eaf1b276929dcd9af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515dd04260c6049110d7624eaf1b276929dcd9af/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8754323d67011f7dceb5c8b82c4a5b48f0de4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a8754323d67011f7dceb5c8b82c4a5b48f0de4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a8754323d67011f7dceb5c8b82c4a5b48f0de4d"}], "stats": {"total": 67, "additions": 60, "deletions": 7}, "files": [{"sha": "1cdec0b4071ed6c3690a94c3478db7130b050b43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=515dd04260c6049110d7624eaf1b276929dcd9af", "patch": "@@ -1,3 +1,10 @@\n+2020-02-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/93516\n+\t* tree-sra.c (propagate_subaccesses_from_rhs): Do not create\n+\taccess of the same type as the parent.\n+\t(propagate_subaccesses_from_lhs): Likewise.\n+\n 2020-02-14 Hongtao Liu  <hongtao.liu@intel.com>\n \n \tPR target/93724"}, {"sha": "a69fa2c2947370bf280727b98d78704c33612155", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=515dd04260c6049110d7624eaf1b276929dcd9af", "patch": "@@ -1,3 +1,8 @@\n+2020-02-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/93516\n+\t* g++.dg/tree-ssa/pr93516.C: New test.\n+\n 2020-02-14 Hongtao Liu  <hongtao.liu@intel.com>\n \n \t* gcc.target/i386/avx512vbmi2-vpshld-1.c: New test."}, {"sha": "2bba37c1386a4329a83f760a17e898212456ee8b", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr93516.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr93516.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr93516.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr93516.C?ref=515dd04260c6049110d7624eaf1b276929dcd9af", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+// { dg-options \"-O2\" } */\n+\n+struct b;\n+struct c {\n+  b *operator->();\n+};\n+class e {\n+  void *f;\n+  int d;\n+\n+public:\n+  template <typename a> a g() { return *static_cast<a *>(this); }\n+};\n+struct h : e {};\n+struct b {\n+  void i(e);\n+  e j();\n+};\n+void m() {\n+  c k;\n+  h l = k->j().g<h>();\n+  k->i(l);\n+}"}, {"sha": "0cfac0a81924bcd9255e270b6069db04f72010d4", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/515dd04260c6049110d7624eaf1b276929dcd9af/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=515dd04260c6049110d7624eaf1b276929dcd9af", "patch": "@@ -2785,9 +2785,17 @@ propagate_subaccesses_from_rhs (struct access *lacc, struct access *racc)\n \t}\n \n       rchild->grp_hint = 1;\n-      new_acc = create_artificial_child_access (lacc, rchild, norm_offset,\n-\t\t\t\t\t\tfalse, (lacc->grp_write\n-\t\t\t\t\t\t\t|| rchild->grp_write));\n+      /* Because get_ref_base_and_extent always includes padding in size for\n+\t accesses to DECLs but not necessarily for COMPONENT_REFs of the same\n+\t type, we might be actually attempting to here to create a child of the\n+\t same type as the parent.  */\n+      if (!types_compatible_p (lacc->type, rchild->type))\n+\tnew_acc = create_artificial_child_access (lacc, rchild, norm_offset,\n+\t\t\t\t\t\t  false,\n+\t\t\t\t\t\t  (lacc->grp_write\n+\t\t\t\t\t\t   || rchild->grp_write));\n+      else\n+\tnew_acc = lacc;\n       gcc_checking_assert (new_acc);\n       if (racc->first_child)\n \tpropagate_subaccesses_from_rhs (new_acc, rchild);\n@@ -2834,10 +2842,19 @@ propagate_subaccesses_from_lhs (struct access *lacc, struct access *racc)\n \t  continue;\n \t}\n \n-      struct access *new_acc\n-\t=  create_artificial_child_access (racc, lchild, norm_offset,\n-\t\t\t\t\t   true, false);\n-      propagate_subaccesses_from_lhs (lchild, new_acc);\n+      /* Because get_ref_base_and_extent always includes padding in size for\n+\t accesses to DECLs but not necessarily for COMPONENT_REFs of the same\n+\t type, we might be actually attempting to here to create a child of the\n+\t same type as the parent.  */\n+      if (!types_compatible_p (racc->type, lchild->type))\n+\t{\n+\t  struct access *new_acc\n+\t    = create_artificial_child_access (racc, lchild, norm_offset,\n+\t\t\t\t\t      true, false);\n+\t  propagate_subaccesses_from_lhs (lchild, new_acc);\n+\t}\n+      else\n+\tpropagate_subaccesses_from_lhs (lchild, racc);\n       ret = true;\n     }\n   return ret;"}]}