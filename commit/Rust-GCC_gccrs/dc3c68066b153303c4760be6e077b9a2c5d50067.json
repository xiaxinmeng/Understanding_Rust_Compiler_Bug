{"sha": "dc3c68066b153303c4760be6e077b9a2c5d50067", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMzYzY4MDY2YjE1MzMwM2M0NzYwYmU2ZTA3N2I5YTJjNWQ1MDA2Nw==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2001-05-04T18:22:00Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2001-05-04T18:22:00Z"}, "message": "m68hc11.md (*tbne, *tbeq): New patterns for 68HC12.\n\n\t* config/m68hc11/m68hc11.md (*tbne, *tbeq): New patterns for 68HC12.\n\t(extendqisi2, extendqihi2, extendhisi2): Use sex for 68HC12.\n\t(uminqi3, umaxqi3, uminhi3, umaxhi3): New pattern for 68HC12.\n\nFrom-SVN: r41836", "tree": {"sha": "b6ed617e23cfec5dcb5f810bfb76e02329f4affc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6ed617e23cfec5dcb5f810bfb76e02329f4affc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc3c68066b153303c4760be6e077b9a2c5d50067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3c68066b153303c4760be6e077b9a2c5d50067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3c68066b153303c4760be6e077b9a2c5d50067", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3c68066b153303c4760be6e077b9a2c5d50067/comments", "author": null, "committer": null, "parents": [{"sha": "5a62a69372b8e6f55dcc3d5cb86b661efc3ea999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a62a69372b8e6f55dcc3d5cb86b661efc3ea999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a62a69372b8e6f55dcc3d5cb86b661efc3ea999"}], "stats": {"total": 221, "additions": 215, "deletions": 6}, "files": [{"sha": "5d4139a00866f5a5e3e0b911c7ceb58df1c644e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3c68066b153303c4760be6e077b9a2c5d50067/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3c68066b153303c4760be6e077b9a2c5d50067/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc3c68066b153303c4760be6e077b9a2c5d50067", "patch": "@@ -1,3 +1,9 @@\n+2001-05-04  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.md (*tbne, *tbeq): New patterns for 68HC12.\n+\t(extendqisi2, extendqihi2, extendhisi2): Use sex for 68HC12.\n+\t(uminqi3, umaxqi3, uminhi3, umaxhi3): New pattern for 68HC12.\n+\n 2001-05-04  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.h (CONST_COSTS): Make the cost of"}, {"sha": "46bfad8d4e5ef110e7f209b79b1ad7985121a31a", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 209, "deletions": 6, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3c68066b153303c4760be6e077b9a2c5d50067/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3c68066b153303c4760be6e077b9a2c5d50067/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=dc3c68066b153303c4760be6e077b9a2c5d50067", "patch": "@@ -1273,6 +1273,20 @@\n   rtx ops[3];\n   int need_tst = 0;\n \n+  /* The 68HC12 has a sign-extension instruction.  Use it when the\n+     destination is the register (X,D).  First sign-extend the low\n+     part and fill X with the sign-extension of the high part.  */\n+  if (TARGET_M6812 && X_REG_P (operands[0]))\n+    {\n+      if (!D_REG_P (operands[1]))\n+        {\n+\t  ops[0] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+\t  ops[1] = operands[1];\n+\t  m68hc11_gen_movqi (insn, ops);\n+\t}\n+      return \\\"sex\\\\tb,d\\\\n\\\\tsex\\\\ta,x\\\";\n+    }\n+\n   ops[2] = gen_label_rtx ();\n \n   if (X_REG_P (operands[1]))\n@@ -1368,6 +1382,16 @@\n   ops[0] = gen_label_rtx ();\n   if (D_REG_P (operands[0]))\n     {\n+      if (TARGET_M6812)\n+\t{\n+\t  if (!D_REG_P (operands[1]))\n+\t    {\n+\t      ops[0] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n+\t      ops[1] = operands[1];\n+\t      m68hc11_gen_movqi (insn, ops);\n+\t    }\n+\t  return \\\"sex\\\\tb,d\\\";\n+\t}\n       output_asm_insn (\\\"clra\\\", operands);\n       if (H_REG_P (operands[1]))\n         {\n@@ -1426,14 +1450,12 @@\n   \"*\n {\n   extern rtx ix_reg;\n-  rtx ops[1];\n+  rtx ops[2];\n   int x_reg_used;\n \n   if (Y_REG_P (operands[1]))\n     return \\\"#\\\";\n \n-  ops[0] = gen_label_rtx ();\n-\n   if (X_REG_P (operands[1]))\n     {\n       output_asm_insn (\\\"xgdx\\\", operands);\n@@ -1446,27 +1468,136 @@\n       x_reg_used = reg_mentioned_p (ix_reg, operands[1]);\n       if (x_reg_used)\n         {\n-          output_asm_insn (\\\"ldd\\\\t%1\\\", operands);\n+\t  ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+\t  ops[1] = operands[1];\n+\t  m68hc11_gen_movhi (insn, ops);\n         }\n     }\n+\n+  CC_STATUS_INIT;\n+  if (TARGET_M6812 && 0)\n+    {\n+      /* This sequence of code is larger than the one for 68HC11.\n+         Don't use it; keep it for documentation.  */\n+      if (!D_REG_P (operands[1]) && !x_reg_used)\n+        {\n+          ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+          ops[1] = operands[1];\n+          m68hc11_gen_movhi (insn, ops);\n+        }\n+      output_asm_insn (\\\"sex\\\\ta,x\\\", operands);\n+      output_asm_insn (\\\"xgdx\\\", operands);\n+      output_asm_insn (\\\"sex\\\\ta,d\\\", operands);\n+      return \\\"xgdx\\\";\n+    }\n+\n   output_asm_insn (\\\"ldx\\\\t#0\\\", operands);\n   if (D_REG_P (operands[1]) || x_reg_used)\n     {\n       output_asm_insn (\\\"tsta\\\", operands);\n     }\n   else\n     {\n-      output_asm_insn (\\\"ldd\\\\t%1\\\", operands);\n+      ops[0] = gen_rtx (REG, HImode, HARD_D_REGNUM);\n+      ops[1] = operands[1];\n+      m68hc11_gen_movhi (insn, ops);\n     }\n+\n+  ops[0] = gen_label_rtx ();\n   output_asm_insn (\\\"bpl\\\\t%l0\\\", ops);\n   output_asm_insn (\\\"dex\\\", operands);\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\", CODE_LABEL_NUMBER (ops[0]));\n \n-  CC_STATUS_INIT;\n   return \\\"\\\";\n }\")\n \n \n+;;--------------------------------------------------------------------\n+;;- Min and Max instructions (68HC12).\n+;;--------------------------------------------------------------------\n+(define_insn \"uminqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(umin:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"m,d\")))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  /* Flags are set according to (sub:QI (operand 1) (operand2)).\n+     The mina/minm use A as the source or destination.  This is the\n+     high part of D.  There is no way to express that in the pattern\n+     so we must use 'exg a,b' to put the operand in the good register.  */\n+  CC_STATUS_INIT;\n+  if (D_REG_P (operands[0]))\n+    {\n+      return \\\"exg\\\\ta,b\\\\n\\\\tmina\\\\t%2\\\\n\\\\texg\\\\ta,b\\\";\n+    }\n+  else\n+    {\n+      return \\\"exg\\\\ta,b\\\\n\\\\tminm\\\\t%0\\\\n\\\\texg\\\\ta,b\\\";\n+    }\n+}\")\n+\n+(define_insn \"umaxqi3\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(umax:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"m,d\")))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  /* Flags are set according to (sub:QI (operand 1) (operand2)).\n+     The maxa/maxm use A as the source or destination.  This is the\n+     high part of D.  There is no way to express that in the pattern\n+     so we must use 'exg a,b' to put the operand in the good register.  */\n+  CC_STATUS_INIT;\n+  if (D_REG_P (operands[0]))\n+    {\n+      return \\\"exg\\\\ta,b\\\\n\\\\tmaxa\\\\t%2\\\\n\\\\texg\\\\ta,b\\\";\n+    }\n+  else\n+    {\n+      return \\\"exg\\\\ta,b\\\\n\\\\tmaxm\\\\t%0\\\\n\\\\texg\\\\ta,b\\\";\n+    }\n+}\")\n+\n+(define_insn \"uminhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(umin:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"m,d\")))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  /* Flags are set according to (sub:HI (operand 1) (operand2)).  */\n+  CC_STATUS_INIT;\n+  if (D_REG_P (operands[0]))\n+    {\n+      return \\\"emind\\\\t%2\\\";\n+    }\n+  else\n+    {\n+      return \\\"eminm\\\\t%0\\\";\n+    }\n+}\")\n+\n+(define_insn \"umaxhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(umax:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"m,d\")))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  /* Flags are set according to (sub:HI (operand 1) (operand2)).  */\n+  CC_STATUS_INIT;\n+  if (D_REG_P (operands[0]))\n+    {\n+      return \\\"emaxd\\\\t%2\\\";\n+    }\n+  else\n+    {\n+      return \\\"emaxm\\\\t%0\\\";\n+    }\n+}\")\n+\n+\n ;;--------------------------------------------------------------------\n ;;- Add instructions.\n ;;--------------------------------------------------------------------\n@@ -5218,6 +5349,78 @@\n   DONE;\n }\")\n \n+;;\n+;; Test and branch instructions for 68HC12 for EQ and NE.\n+;; 'z' must not appear in the constraints because the z replacement \n+;; pass does not know how to restore the replacement register.\n+;;\n+(define_insn \"*tbeq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:HI 0 \"register_operand\" \"dxy\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+   /* If the flags are already set correctly, use 'bne/beq' which are\n+      smaller and a little bit faster.  This happens quite often due\n+      to reloading of operands[0].  In that case, flags are set correctly\n+      due to the load instruction.  */\n+  if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+    return \\\"beq\\\\t%l1\\\";\n+  else\n+    return \\\"tbeq\\\\t%0,%l1\\\";\n+}\")\n+\n+(define_insn \"*tbne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:HI 0 \"register_operand\" \"dxy\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+   if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+     return \\\"bne\\\\t%l1\\\";\n+   else\n+     return \\\"tbne\\\\t%0,%l1\\\";\n+}\")\n+\n+;;\n+;; Test and branch with 8-bit register.  Register must be B (or A).\n+;;\n+(define_insn \"*tbeq8\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_operand:QI 0 \"register_operand\" \"d\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+   if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+     return \\\"beq\\\\t%l1\\\";\n+   else\n+     return \\\"tbeq\\\\tb,%l1\\\";\n+}\")\n+\n+(define_insn \"*tbne8\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:QI 0 \"register_operand\" \"d\")\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+   if (cc_status.value1 && rtx_equal_p (cc_status.value1, operands[0]))\n+     return \\\"bne\\\\t%l1\\\";\n+   else\n+     return \\\"tbne\\\\tb,%l1\\\";\n+}\")\n+\n (define_insn \"*beq\"\n   [(set (pc)\n \t(if_then_else (eq (cc0)"}]}