{"sha": "02954c2552424aa9eb56cb613df48c07c8fc6b87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI5NTRjMjU1MjQyNGFhOWViNTZjYjYxM2RmNDhjMDdjOGZjNmI4Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T10:15:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T10:15:47Z"}, "message": "[multiple changes]\n\n2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Same_Object): include formal parameters.\n\n2010-09-09  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Queue): New package implementing a new impementation of the\n\tqueue, taking into account the new switch --single-compile-per-obj-dir.\n\t* makeutl.ads (Single_Compile_Per_Obj_Dir_Switch): New constant String\n\tfor gnatmake and gprbuild new switch --single-compile-per-obj-dir.\n\t* opt.ads (One_Compilation_Per_Obj_Dir): New Boolean flag, defauted to\n\tFalse.\n\t* switch-m.adb (Scan_Make_Switches): Take into account new gnatmake\n\tswitch --single-compile-per-obj-dir.\n\t* vms_data.ads: Add qualifier SINGLE_COMPILE_PER_OBJ_DIR for gnatmake\n\tswitch --single-compile-per-obj-dir.\n\t* gnat_ugn.texi: Add documentation for new gnatmake switch\n\t--single-compile-per-obj-dir.\n\nFrom-SVN: r164067", "tree": {"sha": "50ccdd7601a2a3e1f3d358b078848ebde8e85470", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50ccdd7601a2a3e1f3d358b078848ebde8e85470"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02954c2552424aa9eb56cb613df48c07c8fc6b87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02954c2552424aa9eb56cb613df48c07c8fc6b87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02954c2552424aa9eb56cb613df48c07c8fc6b87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02954c2552424aa9eb56cb613df48c07c8fc6b87/comments", "author": null, "committer": null, "parents": [{"sha": "855f2f8c94dd2a52d39c17440363c91d51c54035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/855f2f8c94dd2a52d39c17440363c91d51c54035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/855f2f8c94dd2a52d39c17440363c91d51c54035"}], "stats": {"total": 682, "additions": 453, "deletions": 229}, "files": [{"sha": "eba59bd7af5c441c850f7266af41ee2b647217f9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -1,3 +1,22 @@\n+2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Same_Object): include formal parameters.\n+\n+2010-09-09  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb (Queue): New package implementing a new impementation of the\n+\tqueue, taking into account the new switch --single-compile-per-obj-dir.\n+\t* makeutl.ads (Single_Compile_Per_Obj_Dir_Switch): New constant String\n+\tfor gnatmake and gprbuild new switch --single-compile-per-obj-dir.\n+\t* opt.ads (One_Compilation_Per_Obj_Dir): New Boolean flag, defauted to\n+\tFalse.\n+\t* switch-m.adb (Scan_Make_Switches): Take into account new gnatmake\n+\tswitch --single-compile-per-obj-dir.\n+\t* vms_data.ads: Add qualifier SINGLE_COMPILE_PER_OBJ_DIR for gnatmake\n+\tswitch --single-compile-per-obj-dir.\n+\t* gnat_ugn.texi: Add documentation for new gnatmake switch\n+\t--single-compile-per-obj-dir.\n+\n 2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n \n \t* einfo.adb, einfo.ads: Clarify use of Corresponding_Protected_Entry."}, {"sha": "76d555a713249dde865e53091d990c557949689b", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -9250,7 +9250,11 @@ itself must not include any embedded spaces.\n \n @item ^--subdirs^/SUBDIRS^=subdir\n Actual object directory of each project file is the subdirectory subdir of the\n-object directory specified or defauted in the project file.\n+object directory specified or defaulted in the project file.\n+\n+@item ^--single-compile-per-obj-dir^/SINGLE_COMPILE_PER_OBJ_DIR^\n+Disallow simultaneous compilations in the same object directory when\n+project files are used.\n \n @item ^--unchecked-shared-lib-imports^/UNCHECKED_SHARED_LIB_IMPORTS^\n By default, shared library projects are not allowed to import static library"}, {"sha": "c6b382f21e860e85ed717d6a545d9ab522e5efe2", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 408, "deletions": 227, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -71,6 +71,7 @@ with Ada.Command_Line;          use Ada.Command_Line;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.Dynamic_HTables;      use GNAT.Dynamic_HTables;\n+with GNAT.HTable;\n with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n@@ -135,49 +136,6 @@ package body Make is\n    --  complex, for example in main.1.ada, the termination in this name is\n    --  \".1.ada\" and in main_.ada the termination is \"_.ada\".\n \n-   -------------------------------------\n-   -- Queue (Q) Manipulation Routines --\n-   -------------------------------------\n-\n-   --  The Q is used in Compile_Sources below. Its implementation uses the GNAT\n-   --  generic package Table (basically an extensible array). Q_Front points to\n-   --  the first valid element in the Q, whereas Q.First is the first element\n-   --  ever enqueued, while Q.Last - 1 is the last element in the Q.\n-   --\n-   --        +---+--------------+---+---+---+-----------+---+--------\n-   --    Q   |   |  ........    |   |   |   | .......   |   |\n-   --        +---+--------------+---+---+---+-----------+---+--------\n-   --          ^                  ^                       ^\n-   --       Q.First             Q_Front               Q.Last-1\n-   --\n-   --  The elements comprised between Q.First and Q_Front-1 are the elements\n-   --  that have been enqueued and then dequeued, while the elements between\n-   --  Q_Front and Q.Last-1 are the elements currently in the Q. When the Q\n-   --  is initialized Q_Front = Q.First = Q.Last. After Compile_Sources has\n-   --  terminated its execution, Q_Front = Q.Last and the elements contained\n-   --  between Q.First and Q.Last-1 are those that were explored and thus\n-   --  marked by Compile_Sources. Whenever the Q is reinitialized, the elements\n-   --  between Q.First and Q.Last-1 are unmarked.\n-\n-   procedure Init_Q;\n-   --  Must be called to (re)initialize the Q\n-\n-   procedure Insert_Q\n-     (Source_File : File_Name_Type;\n-      Source_Unit : Unit_Name_Type := No_Unit_Name;\n-      Index       : Int            := 0);\n-   --  Inserts Source_File at the end of Q. Provide Source_Unit when possible\n-   --  for external use (gnatdist). Provide index for multi-unit sources.\n-\n-   function Empty_Q return Boolean;\n-   --  Returns True if Q is empty\n-\n-   procedure Extract_From_Q\n-     (Source_File  : out File_Name_Type;\n-      Source_Unit  : out Unit_Name_Type;\n-      Source_Index : out Int);\n-   --  Extracts the first element from the Q\n-\n    procedure Insert_Project_Sources\n      (The_Project  : Project_Id;\n       All_Projects : Boolean;\n@@ -190,12 +148,6 @@ package body Make is\n    --  including, if The_Project is an extending project, sources inherited\n    --  from projects being extended.\n \n-   First_Q_Initialization : Boolean := True;\n-   --  Will be set to false after Init_Q has been called once\n-\n-   Q_Front : Natural;\n-   --  Points to the first valid element in the Q\n-\n    Unique_Compile : Boolean := False;\n    --  Set to True if -u or -U or a project file with no main is used\n \n@@ -216,24 +168,55 @@ package body Make is\n    N_M_Switch : Natural := 0;\n    --  Used to count -mxxx switches that can affect multilib\n \n-   type Q_Record is record\n-      File  : File_Name_Type;\n-      Unit  : Unit_Name_Type;\n-      Index : Int;\n-   end record;\n-   --  File is the name of the file to compile. Unit is for gnatdist\n-   --  use in order to easily get the unit name of a file to compile\n-   --  when its name is krunched or declared in gnat.adc. Index, when not 0,\n-   --  is the index of the unit in a multi-unit source.\n+   package Queue is\n+      ---------------------------------\n+      -- Queue Manipulation Routines --\n+      ---------------------------------\n \n-   package Q is new Table.Table (\n-     Table_Component_Type => Q_Record,\n-     Table_Index_Type     => Natural,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => 4000,\n-     Table_Increment      => 100,\n-     Table_Name           => \"Make.Q\");\n-   --  This is the actual Q\n+      procedure Initialize (Queue_Per_Obj_Dir : Boolean);\n+      --  Initialize the queue\n+\n+      function Is_Empty return Boolean;\n+      --  Returns True if the queue is empty\n+\n+      function Is_Virtually_Empty return Boolean;\n+      --  Returns True if the queue is empty or if all object directories are\n+      --  busy.\n+\n+      procedure Insert\n+        (Source_File_Name : File_Name_Type;\n+         Project          : Project_Id;\n+         Source_Unit      : Unit_Name_Type := No_Unit_Name;\n+         Index            : Int            := 0);\n+      --  Insert source in the queue\n+\n+      procedure Extract\n+        (Source_File_Name  : out File_Name_Type;\n+         Source_Unit       : out Unit_Name_Type;\n+         Source_Index      : out Int);\n+      --  Get the first source that can be compiled from the queue. If no\n+      --  source may be compiled, return No_File/No_Source.\n+\n+      function Size return Natural;\n+      --  Return the total size of the queue, including the sources already\n+      --  extracted.\n+\n+      function Processed return Natural;\n+      --  Return the number of source in the queue that have aready been\n+      --  processed.\n+\n+      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type);\n+      --  Indicate that this object directory is busy, so that when\n+      --  One_Compilation_Per_Obj_Dir is True no other compilation occurs in\n+      --  this object directory.\n+\n+      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type);\n+      --  Indicate that there is no compilation for this object directory\n+\n+      function Element (Rank : Positive) return File_Name_Type;\n+      --  Get the file name for element of index Rank in the queue\n+\n+   end Queue;\n \n    --  The 3 following packages are used to store gcc, gnatbind and gnatlink\n    --  switches found in the project files.\n@@ -2503,8 +2486,13 @@ package body Make is\n       --  library file name. Process_Id of the process spawned to execute the\n       --  compilation.\n \n+      type ALI_Project is record\n+         ALI      : ALI_Id;\n+         Project : Project_Id;\n+      end record;\n+\n       package Good_ALI is new Table.Table (\n-        Table_Component_Type => ALI_Id,\n+        Table_Component_Type => ALI_Project,\n         Table_Index_Type     => Natural,\n         Table_Low_Bound      => 1,\n         Table_Initial        => 50,\n@@ -2519,7 +2507,7 @@ package body Make is\n       --  Get a mapping file name. If there is one to be reused, reuse it.\n       --  Otherwise, create a new mapping file.\n \n-      function Get_Next_Good_ALI return ALI_Id;\n+      function Get_Next_Good_ALI return ALI_Project;\n       --  Returns the next good ALI_Id record\n \n       procedure Record_Failure\n@@ -2530,7 +2518,7 @@ package body Make is\n       --  If Found is False then the compilation of File failed because we\n       --  could not find it. Records also Unit when possible.\n \n-      procedure Record_Good_ALI (A : ALI_Id);\n+      procedure Record_Good_ALI (A : ALI_Id; Project : Project_Id);\n       --  Records in the previous set the Id of an ALI file\n \n       function Must_Exit_Because_Of_Error return Boolean;\n@@ -2586,6 +2574,10 @@ package body Make is\n             Project          => Arguments_Project);\n \n          Outstanding_Compiles := OC1;\n+\n+         if Arguments_Project /= No_Project then\n+            Queue.Set_Obj_Dir_Busy (Arguments_Project.Object_Directory.Name);\n+         end if;\n       end Add_Process;\n \n       --------------------\n@@ -2624,6 +2616,10 @@ package body Make is\n                   Data    := Running_Compile (J);\n                   Project := Running_Compile (J).Project;\n \n+                  if Project /= No_Project then\n+                     Queue.Set_Obj_Dir_Free (Project.Object_Directory.Name);\n+                  end if;\n+\n                   --  If a mapping file was used by this compilation, get its\n                   --  file name for reuse by a subsequent compilation.\n \n@@ -2704,7 +2700,7 @@ package body Make is\n                      end if;\n \n                   else\n-                     Insert_Q (Sfile, Index => 0);\n+                     Queue.Insert (Sfile, Project => No_Project, Index => 0);\n                      Mark (Sfile, Index => 0);\n                   end if;\n                end if;\n@@ -3013,6 +3009,7 @@ package body Make is\n       -------------------------------\n \n       procedure Fill_Queue_From_ALI_Files is\n+         ALI_P        : ALI_Project;\n          ALI          : ALI_Id;\n          Source_Index : Int;\n          Sfile        : File_Name_Type;\n@@ -3022,8 +3019,9 @@ package body Make is\n \n       begin\n          while Good_ALI_Present loop\n-            ALI          := Get_Next_Good_ALI;\n-            Source_Index := Unit_Index_Of (ALIs.Table (ALI).Afile);\n+            ALI_P        := Get_Next_Good_ALI;\n+            ALI          := ALI_P.ALI;\n+            Source_Index := Unit_Index_Of (ALIs.Table (ALI_P.ALI).Afile);\n \n             --  If we are processing the library file corresponding to the\n             --  main source file check if this source can be a main unit.\n@@ -3109,8 +3107,11 @@ package body Make is\n                            Debug_Msg (\"Skipping internal file:\", Sfile);\n \n                         else\n-                           Insert_Q\n-                             (Sfile, Withs.Table (K).Uname, Source_Index);\n+                           Queue.Insert\n+                             (Sfile,\n+                              ALI_P.Project,\n+                              Withs.Table (K).Uname,\n+                              Source_Index);\n                            Mark (Sfile, Source_Index);\n                         end if;\n                      end if;\n@@ -3156,14 +3157,14 @@ package body Make is\n       -- Get_Next_Good_ALI --\n       -----------------------\n \n-      function Get_Next_Good_ALI return ALI_Id is\n-         ALI : ALI_Id;\n+      function Get_Next_Good_ALI return ALI_Project is\n+         ALIP : ALI_Project;\n \n       begin\n          pragma Assert (Good_ALI_Present);\n-         ALI := Good_ALI.Table (Good_ALI.Last);\n+         ALIP := Good_ALI.Table (Good_ALI.Last);\n          Good_ALI.Decrement_Last;\n-         return ALI;\n+         return ALIP;\n       end Get_Next_Good_ALI;\n \n       ----------------------\n@@ -3217,10 +3218,10 @@ package body Make is\n       -- Record_Good_ALI --\n       ---------------------\n \n-      procedure Record_Good_ALI (A : ALI_Id) is\n+      procedure Record_Good_ALI (A : ALI_Id; Project : Project_Id) is\n       begin\n          Good_ALI.Increment_Last;\n-         Good_ALI.Table (Good_ALI.Last) := A;\n+         Good_ALI.Table (Good_ALI.Last) := (A, Project);\n       end Record_Good_ALI;\n \n       -------------------------------\n@@ -3256,8 +3257,10 @@ package body Make is\n          --  The object file\n \n       begin\n-         if not Empty_Q and then Outstanding_Compiles < Max_Process then\n-            Extract_From_Q (Source_File, Source_Unit, Source_Index);\n+         if not Queue.Is_Virtually_Empty and then\n+            Outstanding_Compiles < Max_Process\n+         then\n+            Queue.Extract (Source_File, Source_Unit, Source_Index);\n \n             Osint.Full_Source_Name\n               (Source_File,\n@@ -3387,7 +3390,7 @@ package body Make is\n \n                      --  The ALI file is up-to-date; record its Id\n \n-                     Record_Good_ALI (ALI);\n+                     Record_Good_ALI (ALI, Arguments_Project);\n \n                      --  Record the time stamp of the most recent object\n                      --  file as long as no (re)compilations are needed.\n@@ -3542,7 +3545,7 @@ package body Make is\n \n       begin\n          if Outstanding_Compiles = Max_Process\n-           or else (Empty_Q\n+           or else (Queue.Is_Virtually_Empty\n                      and then not Good_ALI_Present\n                      and then Outstanding_Compiles > 0)\n          then\n@@ -3603,7 +3606,7 @@ package body Make is\n                      end if;\n \n                   else\n-                     Record_Good_ALI (ALI);\n+                     Record_Good_ALI (ALI, Data.Project);\n                   end if;\n \n                   Free (Text);\n@@ -3639,10 +3642,6 @@ package body Make is\n \n       Good_ALI.Init;\n \n-      if First_Q_Initialization then\n-         Init_Q;\n-      end if;\n-\n       if Initialize_ALI_Data then\n          Initialize_ALI;\n          Initialize_ALI_Source;\n@@ -3662,7 +3661,7 @@ package body Make is\n       --  compilations if -jnnn is used.\n \n       if not Is_Marked (Main_Source, Main_Index) then\n-         Insert_Q (Main_Source, Index => Main_Index);\n+         Queue.Insert (Main_Source, Main_Project, Index => Main_Index);\n          Mark (Main_Source, Main_Index);\n       end if;\n \n@@ -3674,7 +3673,8 @@ package body Make is\n       --  Keep looping until there is no more work to do (the Q is empty)\n       --  and all the outstanding compilations have terminated.\n \n-      Make_Loop : while not Empty_Q or else Outstanding_Compiles > 0 loop\n+      Make_Loop :\n+      while not Queue.Is_Empty or else Outstanding_Compiles > 0 loop\n          exit Make_Loop when Must_Exit_Because_Of_Error;\n          exit Make_Loop when Start_Compile_If_Possible (Args);\n \n@@ -3687,11 +3687,11 @@ package body Make is\n \n          if Display_Compilation_Progress then\n             Write_Str (\"completed \");\n-            Write_Int (Int (Q_Front));\n+            Write_Int (Int (Queue.Processed));\n             Write_Str (\" out of \");\n-            Write_Int (Int (Q.Last));\n+            Write_Int (Int (Queue.Size));\n             Write_Str (\" (\");\n-            Write_Int (Int ((Q_Front * 100) / (Q.Last - Q.First)));\n+            Write_Int (Int ((Queue.Processed * 100) / Queue.Size));\n             Write_Str (\"%)...\");\n             Write_Eol;\n          end if;\n@@ -4052,29 +4052,6 @@ package body Make is\n       Display_Executed_Programs := Display;\n    end Display_Commands;\n \n-   -------------\n-   -- Empty_Q --\n-   -------------\n-\n-   function Empty_Q return Boolean is\n-   begin\n-      if Debug.Debug_Flag_P then\n-         Write_Str (\"   Q := [\");\n-\n-         for J in Q_Front .. Q.Last - 1 loop\n-            Write_Str (\" \");\n-            Write_Name (Q.Table (J).File);\n-            Write_Eol;\n-            Write_Str (\"         \");\n-         end loop;\n-\n-         Write_Str (\"]\");\n-         Write_Eol;\n-      end if;\n-\n-      return Q_Front >= Q.Last;\n-   end Empty_Q;\n-\n    --------------------------\n    -- Enter_Into_Obsoleted --\n    --------------------------\n@@ -4106,39 +4083,6 @@ package body Make is\n       Obsoleted.Set (F2, True);\n    end Enter_Into_Obsoleted;\n \n-   --------------------\n-   -- Extract_From_Q --\n-   --------------------\n-\n-   procedure Extract_From_Q\n-     (Source_File  : out File_Name_Type;\n-      Source_Unit  : out Unit_Name_Type;\n-      Source_Index : out Int)\n-   is\n-      File  : constant File_Name_Type := Q.Table (Q_Front).File;\n-      Unit  : constant Unit_Name_Type := Q.Table (Q_Front).Unit;\n-      Index : constant Int            := Q.Table (Q_Front).Index;\n-\n-   begin\n-      if Debug.Debug_Flag_Q then\n-         Write_Str (\"   Q := Q - [ \");\n-         Write_Name (File);\n-\n-         if Index /= 0 then\n-            Write_Str (\", \");\n-            Write_Int (Index);\n-         end if;\n-\n-         Write_Str (\" ]\");\n-         Write_Eol;\n-      end if;\n-\n-      Q_Front := Q_Front + 1;\n-      Source_File  := File;\n-      Source_Unit  := Unit;\n-      Source_Index := Index;\n-   end Extract_From_Q;\n-\n    --------------\n    -- Gnatmake --\n    --------------\n@@ -4575,10 +4519,10 @@ package body Make is\n \n             Add_Switch (\"-n\", Binder, And_Save => True);\n \n-            for J in Q.First .. Q.Last - 1 loop\n+            for J in 1 .. Queue.Size loop\n                Add_Switch\n                  (Get_Name_String\n-                    (Lib_File_Name (Q.Table (J).File)),\n+                    (Lib_File_Name (Queue.Element (J))),\n                   Binder, And_Save => True);\n             end loop;\n          end if;\n@@ -5595,6 +5539,10 @@ package body Make is\n                   Args (J) := Gcc_Switches.Table (J);\n                end loop;\n \n+               Queue.Initialize\n+                       (Main_Project /= No_Project and then\n+                        One_Compilation_Per_Obj_Dir);\n+\n                --  Now we invoke Compile_Sources for the current main\n \n                Compile_Sources\n@@ -5619,10 +5567,6 @@ package body Make is\n                   Write_Eol;\n                end if;\n \n-               --  Make sure the queue will be reinitialized for the next round\n-\n-               First_Q_Initialization := True;\n-\n                Total_Compilation_Failures :=\n                  Total_Compilation_Failures + Compilation_Failures;\n \n@@ -6688,17 +6632,6 @@ package body Make is\n       File_Index := Data.Last_Mapping_File_Names;\n    end Init_Mapping_File;\n \n-   ------------\n-   -- Init_Q --\n-   ------------\n-\n-   procedure Init_Q is\n-   begin\n-      First_Q_Initialization := False;\n-      Q_Front := Q.First;\n-      Q.Set_Last (Q.First);\n-   end Init_Q;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -6969,6 +6902,7 @@ package body Make is\n       Unit     : Unit_Index;\n       Sfile    : File_Name_Type;\n       Index    : Int;\n+      Project  : Project_Id;\n \n       Extending : constant Boolean := The_Project.Extends /= No_Project;\n \n@@ -7010,8 +6944,9 @@ package body Make is\n \n       Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n       while Unit /= null loop\n-         Sfile := No_File;\n-         Index := 0;\n+         Sfile   := No_File;\n+         Index   := 0;\n+         Project := No_Project;\n \n          --  If there is a source for the body, and the body has not been\n          --  locally removed.\n@@ -7022,6 +6957,7 @@ package body Make is\n             --  And it is a source for the specified project\n \n             if Check_Project (Unit.File_Names (Impl).Project) then\n+               Project := Unit.File_Names (Impl).Project;\n \n                --  If we don't have a spec, we cannot consider the source\n                --  if it is a subunit.\n@@ -7072,38 +7008,36 @@ package body Make is\n \n             Sfile := Unit.File_Names (Spec).Display_File;\n             Index := Unit.File_Names (Spec).Index;\n+            Project := Unit.File_Names (Spec).Project;\n          end if;\n \n-         --  If Put_In_Q is True, we insert into the Q\n+         --  For the first source inserted into the Q, we need to initialize\n+         --  the Q, but not for the subsequent sources.\n \n-         if Put_In_Q then\n+         Queue.Initialize\n+                 (Main_Project /= No_Project and then\n+                  One_Compilation_Per_Obj_Dir);\n \n-            --  For the first source inserted into the Q, we need to initialize\n-            --  the Q, but not for the subsequent sources.\n+         --  And of course, only insert in the Q if the source is not marked\n \n-            if First_Q_Initialization then\n-               Init_Q;\n+         if Sfile /= No_File and then not Is_Marked (Sfile, Index) then\n+            if Verbose_Mode then\n+               Write_Str (\"Adding \"\"\");\n+               Write_Str (Get_Name_String (Sfile));\n+               Write_Line (\"\"\" to the queue\");\n             end if;\n \n-            --  And of course, only insert in the Q if the source is not marked\n-\n-            if Sfile /= No_File and then not Is_Marked (Sfile, Index) then\n-               if Verbose_Mode then\n-                  Write_Str (\"Adding \"\"\");\n-                  Write_Str (Get_Name_String (Sfile));\n-                  Write_Line (\"\"\" to the queue\");\n-               end if;\n-\n-               Insert_Q (Sfile, Index => Index);\n-               Mark (Sfile, Index);\n-            end if;\n+            Queue.Insert (Sfile, Project, Index => Index);\n+            Mark (Sfile, Index);\n+         end if;\n \n-         elsif Sfile /= No_File then\n+         if not Put_In_Q and then Sfile /= No_File then\n \n             --  If Put_In_Q is False, we add the source as if it were specified\n             --  on the command line, and we set Put_In_Q to True, so that the\n-            --  following sources will be put directly in the queue. This will\n-            --  allow parallel compilation processes if -jx switch is used.\n+            --  following sources will only be put in the queue. The source is\n+            --  aready in the Q, but we need at least one fake main to call\n+            --  Compile_Sources.\n \n             if Verbose_Mode then\n                Write_Str (\"Adding \"\"\");\n@@ -7113,49 +7047,12 @@ package body Make is\n \n             Osint.Add_File (Get_Name_String (Sfile), Index);\n             Put_In_Q := True;\n-\n-            --  As we may look into the Q later, ensure the Q has been\n-            --  initialized to avoid errors.\n-\n-            if First_Q_Initialization then\n-               Init_Q;\n-            end if;\n          end if;\n \n          Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n       end loop;\n    end Insert_Project_Sources;\n \n-   --------------\n-   -- Insert_Q --\n-   --------------\n-\n-   procedure Insert_Q\n-     (Source_File : File_Name_Type;\n-      Source_Unit : Unit_Name_Type := No_Unit_Name;\n-      Index       : Int            := 0)\n-   is\n-   begin\n-      if Debug.Debug_Flag_Q then\n-         Write_Str (\"   Q := Q + [ \");\n-         Write_Name (Source_File);\n-\n-         if Index /= 0 then\n-            Write_Str (\", \");\n-            Write_Int (Index);\n-         end if;\n-\n-         Write_Str (\" ] \");\n-         Write_Eol;\n-      end if;\n-\n-      Q.Table (Q.Last) :=\n-        (File  => Source_File,\n-         Unit  => Source_Unit,\n-         Index => Index);\n-      Q.Increment_Last;\n-   end Insert_Q;\n-\n    ---------------------\n    -- Is_In_Obsoleted --\n    ---------------------\n@@ -7568,6 +7465,290 @@ package body Make is\n         (Project_Node_Tree, \"--RTS=\" & Line (1 .. N_Read), And_Save => True);\n    end Process_Multilib;\n \n+   -----------\n+   -- Queue --\n+   -----------\n+\n+   package body Queue is\n+\n+      type Q_Record is record\n+         File      : File_Name_Type;\n+         Unit      : Unit_Name_Type;\n+         Index     : Int;\n+         Project   : Project_Id;\n+         Processed : Boolean;\n+      end record;\n+      --  File is the name of the file to compile. Unit is for gnatdist use in\n+      --  order to easily get the unit name of a file to compile when its name\n+      --  is krunched or declared in gnat.adc. Index, when not 0, is the index\n+      --  of the unit in a multi-unit source.\n+\n+      package Q is new Table.Table\n+        (Table_Component_Type => Q_Record,\n+         Table_Index_Type     => Positive,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 4000,\n+         Table_Increment      => 100,\n+         Table_Name           => \"Make.Queue.Q\");\n+      --  This is the actual Q\n+\n+      package Busy_Obj_Dirs is new GNAT.HTable.Simple_HTable\n+        (Header_Num => Prj.Header_Num,\n+         Element    => Boolean,\n+         No_Element => False,\n+         Key        => Path_Name_Type,\n+         Hash       => Hash,\n+         Equal      => \"=\");\n+\n+      Q_First : Natural := 1;\n+      --  Points to the first valid element in the queue\n+\n+      Q_Processed           : Natural := 0;\n+      One_Queue_Per_Obj_Dir : Boolean := False;\n+      Q_Initialized         : Boolean := False;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element (Rank : Positive) return File_Name_Type is\n+      begin\n+         if Rank <= Q.Last then\n+            return Q.Table (Rank).File;\n+         else\n+            return No_File;\n+         end if;\n+      end Element;\n+\n+      -------------\n+      -- Extract --\n+      -------------\n+\n+      --  This body needs commenting ???\n+\n+      procedure Extract\n+        (Source_File_Name : out File_Name_Type;\n+         Source_Unit      : out Unit_Name_Type;\n+         Source_Index     : out Int)\n+      is\n+         Found : Boolean := False;\n+\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            for J in Q_First .. Q.Last loop\n+               if not Q.Table (J).Processed\n+                 and then (Q.Table (J).Project = No_Project\n+                            or else not\n+                              Busy_Obj_Dirs.Get\n+                                (Q.Table (J).Project.Object_Directory.Name))\n+               then\n+                  Found := True;\n+                  Source_File_Name := Q.Table (J).File;\n+                  Source_Unit      := Q.Table (J).Unit;\n+                  Source_Index     := Q.Table (J).Index;\n+                  Q.Table (J).Processed := True;\n+\n+                  if J = Q_First then\n+                     while Q_First <= Q.Last\n+                       and then Q.Table (Q_First).Processed\n+                     loop\n+                        Q_First := Q_First + 1;\n+                     end loop;\n+                  end if;\n+\n+                  exit;\n+               end if;\n+            end loop;\n+\n+         elsif Q_First <= Q.Last then\n+            Source_File_Name := Q.Table (Q_First).File;\n+            Source_Unit      := Q.Table (Q_First).Unit;\n+            Source_Index     := Q.Table (Q_First).Index;\n+            Q.Table (Q_First).Processed := True;\n+            Q_First := Q_First + 1;\n+            Found := True;\n+         end if;\n+\n+         if Found then\n+            Q_Processed := Q_Processed + 1;\n+         else\n+            Source_File_Name := No_File;\n+            Source_Unit      := No_Unit_Name;\n+            Source_Index     := 0;\n+         end if;\n+\n+         if Found and then Debug.Debug_Flag_Q then\n+            Write_Str (\"   Q := Q - [ \");\n+            Write_Name (Source_File_Name);\n+\n+            if Source_Index /= 0 then\n+               Write_Str (\", \");\n+               Write_Int (Source_Index);\n+            end if;\n+\n+            Write_Str (\" ]\");\n+            Write_Eol;\n+\n+            Write_Str (\"   Q_First =\");\n+            Write_Int (Int (Q_First));\n+            Write_Eol;\n+\n+            Write_Str (\"   Q.Last =\");\n+            Write_Int (Int (Q.Last));\n+            Write_Eol;\n+         end if;\n+      end Extract;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      procedure Initialize (Queue_Per_Obj_Dir : Boolean) is\n+      begin\n+         if not Q_Initialized then\n+            One_Queue_Per_Obj_Dir := Queue_Per_Obj_Dir;\n+            Q.Init;\n+            Q_Initialized := True;\n+            Q_Processed   := 0;\n+            Q_First       := 1;\n+         end if;\n+      end Initialize;\n+\n+      ------------\n+      -- Insert --\n+      ------------\n+\n+      --  This body needs commenting ???\n+\n+      procedure Insert\n+        (Source_File_Name : File_Name_Type;\n+         Project          : Project_Id;\n+         Source_Unit      : Unit_Name_Type := No_Unit_Name;\n+         Index            : Int            := 0)\n+      is\n+      begin\n+         Q.Append\n+           ((File      => Source_File_Name,\n+             Project   => Project,\n+             Unit      => Source_Unit,\n+             Index     => Index,\n+             Processed => False));\n+\n+         if Debug.Debug_Flag_Q then\n+            Write_Str (\"   Q := Q + [ \");\n+            Write_Name (Source_File_Name);\n+\n+            if Index /= 0 then\n+               Write_Str (\", \");\n+               Write_Int (Index);\n+            end if;\n+\n+            Write_Str (\" ] \");\n+            Write_Eol;\n+\n+            Write_Str (\"   Q_First =\");\n+            Write_Int (Int (Q_First));\n+            Write_Eol;\n+\n+            Write_Str (\"   Q.Last =\");\n+            Write_Int (Int (Q.Last));\n+            Write_Eol;\n+         end if;\n+      end Insert;\n+\n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty return Boolean is\n+      begin\n+         if Debug.Debug_Flag_P then\n+            Write_Str (\"   Q := [\");\n+\n+            for J in Q_First .. Q.Last loop\n+               if not Q.Table (J).Processed then\n+                  Write_Str (\" \");\n+                  Write_Name (Q.Table (J).File);\n+                  Write_Eol;\n+                  Write_Str (\"         \");\n+               end if;\n+            end loop;\n+\n+            Write_Str (\"]\");\n+            Write_Eol;\n+         end if;\n+\n+         return Q_First > Q.Last;\n+      end Is_Empty;\n+\n+      ------------------------\n+      -- Is_Virtually_Empty --\n+      ------------------------\n+\n+      function Is_Virtually_Empty return Boolean is\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            for J in Q_First .. Q.Last loop\n+               if not Q.Table (J).Processed\n+                 and then\n+                   (Q.Table (J).Project = No_Project\n+                     or else not\n+                       Busy_Obj_Dirs.Get\n+                         (Q.Table (J).Project.Object_Directory.Name))\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+\n+            return True;\n+\n+         else\n+            return Is_Empty;\n+         end if;\n+      end Is_Virtually_Empty;\n+\n+      ---------------\n+      -- Processed --\n+      ---------------\n+\n+      function Processed return Natural is\n+      begin\n+         return Q_Processed;\n+      end Processed;\n+\n+      ----------------------\n+      -- Set_Obj_Dir_Busy --\n+      ----------------------\n+\n+      procedure Set_Obj_Dir_Busy (Obj_Dir : Path_Name_Type) is\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            Busy_Obj_Dirs.Set (Obj_Dir, True);\n+         end if;\n+      end Set_Obj_Dir_Busy;\n+\n+      ----------------------\n+      -- Set_Obj_Dir_Free --\n+      ----------------------\n+\n+      procedure Set_Obj_Dir_Free (Obj_Dir : Path_Name_Type) is\n+      begin\n+         if One_Queue_Per_Obj_Dir then\n+            Busy_Obj_Dirs.Set (Obj_Dir, False);\n+         end if;\n+      end Set_Obj_Dir_Free;\n+\n+      ----------\n+      -- Size --\n+      ----------\n+\n+      function Size return Natural is\n+      begin\n+         return Q.Last;\n+      end Size;\n+\n+   end Queue;\n+\n    -----------------------------\n    -- Recursive_Compute_Depth --\n    -----------------------------"}, {"sha": "13d53b0229ceafa093d5f6c20927ad2c624c0cd6", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -52,6 +52,11 @@ package Makeutl is\n    --  Command line switch to allow shared library projects to import projects\n    --  that are not shared library projects.\n \n+   Single_Compile_Per_Obj_Dir_Switch : constant String :=\n+                                         \"--single-compile-per-obj-dir\";\n+   --  Switch to forbid simultaneous compilations for the same object directory\n+   --  when project files are used.\n+\n    procedure Add\n      (Option : String_Access;\n       To     : in out String_List_Access;"}, {"sha": "6f0b6d9668853c22bf28487984a6d6bccab7a9c7", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -910,6 +910,12 @@ package Opt is\n    --  GNATMAKE\n    --  Set to True when an object directory is specified with option -D\n \n+   One_Compilation_Per_Obj_Dir : Boolean := False;\n+   --  GNATMAKE, GPRBUILD\n+   --  Set to True with switch --single-compile-per-obj-dir. When True, there\n+   --  cannot be simultaneous compilations with the object files in the same\n+   --  object directory, if project files are used.\n+\n    type Operating_Mode_Type is (Check_Syntax, Check_Semantics, Generate_Code);\n    Operating_Mode : Operating_Mode_Type := Generate_Code;\n    --  GNAT"}, {"sha": "559373b91d8a42ad2442a314d3c00b1e39131ee9", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -10538,7 +10538,9 @@ package body Sem_Util is\n         and then Present (Entity (N2))\n         and then (Ekind (Entity (N1)) = E_Variable\n                     or else\n-                  Ekind (Entity (N1)) = E_Constant)\n+                    Ekind (Entity (N1)) = E_Constant\n+                    or else\n+                    Ekind (Entity (N1)) in Formal_Kind)\n         and then Entity (N1) = Entity (N2)\n       then\n          return True;"}, {"sha": "39188a4ad9d7b4d8275587d373f90382b94f6b23", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -655,6 +655,9 @@ package body Switch.M is\n          elsif Switch_Chars = Makeutl.Unchecked_Shared_Lib_Imports then\n             Opt.Unchecked_Shared_Lib_Imports := True;\n \n+         elsif Switch_Chars = Makeutl.Single_Compile_Per_Obj_Dir_Switch then\n+            Opt.One_Compilation_Per_Obj_Dir := True;\n+\n          elsif Switch_Chars (Ptr) = '-' then\n             Bad_Switch (Switch_Chars);\n "}, {"sha": "d9a290fdcc36dad826c8eceaf16a22eece226b48", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02954c2552424aa9eb56cb613df48c07c8fc6b87/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=02954c2552424aa9eb56cb613df48c07c8fc6b87", "patch": "@@ -4858,6 +4858,9 @@ package VMS_Data is\n    --\n    --   Search the specified directories for both source and object files.\n \n+   S_Make_Single  : aliased constant S := \"/SINGLE_COMPILE_PER_OBJ_DIR \"   &\n+                                            \"--single-compile-per-obj-dir\";\n+\n    S_Make_Skip    : aliased constant S := \"/SKIP_MISSING=*\"                &\n                                             \"-aL*\";\n    --        /SKIP_MISSING=(directory[,...])\n@@ -4977,6 +4980,7 @@ package VMS_Data is\n                       S_Make_Reason  'Access,\n                       S_Make_RTS     'Access,\n                       S_Make_Search  'Access,\n+                      S_Make_Single  'Access,\n                       S_Make_Skip    'Access,\n                       S_Make_Source  'Access,\n                       S_Make_Stand   'Access,"}]}