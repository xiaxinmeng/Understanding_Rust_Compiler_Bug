{"sha": "f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA3MDljYTY1MDk5NmY0ZGYxZDhkOWE3MDE1YjhkYzEyN2VhM2VkMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T10:41:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T10:41:11Z"}, "message": "[multiple changes]\n\n2010-10-12  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb (Process_PPCs): Handle inherited postconditions.\n\n2010-10-12  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_disp.adb (Set_All_DT_Position): Disable emit error message on\n\tabstract inherited private operation in CodePeer mode.\n\nFrom-SVN: r165358", "tree": {"sha": "6a2db5d52e99edf5a8aa22f222c92dd10217a304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a2db5d52e99edf5a8aa22f222c92dd10217a304"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/comments", "author": null, "committer": null, "parents": [{"sha": "7730df143ca83fef65f64299856c8072bf21a453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7730df143ca83fef65f64299856c8072bf21a453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7730df143ca83fef65f64299856c8072bf21a453"}], "stats": {"total": 185, "additions": 151, "deletions": 34}, "files": [{"sha": "bc7f0b4becdf60ec16e51141f70e9cd7cbb021e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "patch": "@@ -1,3 +1,12 @@\n+2010-10-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb (Process_PPCs): Handle inherited postconditions.\n+\n+2010-10-12  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_disp.adb (Set_All_DT_Position): Disable emit error message on\n+\tabstract inherited private operation in CodePeer mode.\n+\n 2010-10-12  Thomas Quinot  <quinot@adacore.com>\n \n \t* a-exetim.ads: Minor reformatting."}, {"sha": "93bada1dfe7cd1d7f54709cd1ba16349ab50b4b8", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "patch": "@@ -7536,7 +7536,11 @@ package body Exp_Disp is\n          --  excluded from this check because interfaces must be visible in\n          --  the public and private part (RM 7.3 (7.3/2))\n \n-         if Is_Abstract_Type (Typ)\n+         --  We disable this check in CodePeer mode, to accomodate legacy\n+         --  Ada code.\n+\n+         if not CodePeer_Mode\n+           and then Is_Abstract_Type (Typ)\n            and then Is_Abstract_Subprogram (Prim)\n            and then Present (Alias (Prim))\n            and then not Is_Interface"}, {"sha": "4b16ae67a65a2eaf7593867d96cf5ff45b2b499d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 137, "deletions": 33, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0709ca650996f4df1d8d9a7015b8dc127ea3ed3/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f0709ca650996f4df1d8d9a7015b8dc127ea3ed3", "patch": "@@ -4636,10 +4636,12 @@ package body Sem_Ch6 is\n         and then (not Is_Hidden (Overridden_Subp)\n                    or else\n                      ((Chars (Overridden_Subp) = Name_Initialize\n-                         or else Chars (Overridden_Subp) = Name_Adjust\n-                         or else Chars (Overridden_Subp) = Name_Finalize)\n-                       and then Present (Alias (Overridden_Subp))\n-                       and then not Is_Hidden (Alias (Overridden_Subp))))\n+                         or else\n+                       Chars (Overridden_Subp) = Name_Adjust\n+                         or else\n+                       Chars (Overridden_Subp) = Name_Finalize)\n+                      and then Present (Alias (Overridden_Subp))\n+                      and then not Is_Hidden (Alias (Overridden_Subp))))\n       then\n          if Must_Not_Override (Spec) then\n             Error_Msg_Sloc := Sloc (Overridden_Subp);\n@@ -8584,25 +8586,58 @@ package body Sem_Ch6 is\n       Body_Id : Entity_Id)\n    is\n       Loc   : constant Source_Ptr := Sloc (N);\n+      Plist : List_Id             := No_List;\n       Prag  : Node_Id;\n-      Plist : List_Id := No_List;\n       Subp  : Entity_Id;\n       Parms : List_Id;\n \n-      function Grab_PPC (Nam : Name_Id) return Node_Id;\n-      --  Prag contains an analyzed precondition or postcondition pragma.\n-      --  This function copies the pragma, changes it to the corresponding\n-      --  Check pragma and returns the Check pragma as the result. The\n-      --  argument Nam is either Name_Precondition or Name_Postcondition.\n+      function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id;\n+      --  Prag contains an analyzed precondition or postcondition pragma. This\n+      --  function copies the pragma, changes it to the corresponding Check\n+      --  pragma and returns the Check pragma as the result. If Pspec is non-\n+      --  empty, this is the case of inheriting a PPC, where we must change\n+      --  references to parameters of the inherited subprogram to point to the\n+      --  corresponding parameters of the current subprogram.\n \n       --------------\n       -- Grab_PPC --\n       --------------\n \n-      function Grab_PPC (Nam : Name_Id) return Node_Id is\n-         CP : constant Node_Id := New_Copy_Tree (Prag);\n+      function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id is\n+         Nam : constant Name_Id := Pragma_Name (Prag);\n+         Map : Elist_Id;\n+         CP  : Node_Id;\n \n       begin\n+         --  Prepare map if this is the case where we have to map entities of\n+         --  arguments in the overridden subprogram to corresponding entities\n+         --  of the current subprogram.\n+\n+         if No (Pspec) then\n+            Map := No_Elist;\n+\n+         else\n+            declare\n+               PF : Entity_Id;\n+               CF : Entity_Id;\n+\n+            begin\n+               Map := New_Elmt_List;\n+               PF := First_Formal (Pspec);\n+               CF := First_Formal (Spec_Id);\n+               while Present (PF) loop\n+                  Append_Elmt (PF, Map);\n+                  Append_Elmt (CF, Map);\n+                  Next_Formal (PF);\n+                  Next_Formal (CF);\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  Now we can copy the tree, doing any required substituations\n+\n+         CP := New_Copy_Tree (Prag, Map => Map, New_Scope => Current_Scope);\n+\n          --  Set Analyzed to false, since we want to reanalyze the check\n          --  procedure. Note that it is only at the outer level that we\n          --  do this fiddling, for the spec cases, the already preanalyzed\n@@ -8630,6 +8665,23 @@ package body Sem_Ch6 is\n            Make_Identifier (Sloc (Prag),\n              Chars => Name_Check));\n \n+         --  If this is inherited case then the current message starts with\n+         --  \"failed p\" and we change this to \"failed inherited p\".\n+\n+         if Present (Pspec) then\n+            String_To_Name_Buffer\n+              (Strval (Expression (Last (Pragma_Argument_Associations (CP)))));\n+            pragma Assert (Name_Buffer (1 .. 8) = \"failed p\");\n+            Name_Len := Name_Len + 10;\n+            Name_Buffer (17 .. Name_Len) := Name_Buffer (7 .. Name_Len - 10);\n+            Name_Buffer (7 .. 16) := \" inherited\";\n+            Set_Strval\n+              (Expression (Last (Pragma_Argument_Associations (CP))),\n+               String_From_Name_Buffer);\n+         end if;\n+\n+         --  Return the check pragma\n+\n          return CP;\n       end Grab_PPC;\n \n@@ -8660,7 +8712,7 @@ package body Sem_Ch6 is\n                --  which is what we want since new entries were chained to\n                --  the head of the list.\n \n-               Prepend (Grab_PPC (Name_Precondition), Declarations (N));\n+               Prepend (Grab_PPC, Declarations (N));\n             end if;\n \n             Prag := Next_Pragma (Prag);\n@@ -8698,13 +8750,13 @@ package body Sem_Ch6 is\n \n                   Analyze (Prag);\n \n-                  --  If expansion is disabled, as in a generic unit,\n-                  --  save pragma for later expansion.\n+                  --  If expansion is disabled, as in a generic unit, save\n+                  --  pragma for later expansion.\n \n                   if not Expander_Active then\n-                     Prepend (Grab_PPC (Name_Postcondition), Declarations (N));\n+                     Prepend (Grab_PPC, Declarations (N));\n                   else\n-                     Append (Grab_PPC (Name_Postcondition), Plist);\n+                     Append (Grab_PPC, Plist);\n                   end if;\n                end if;\n \n@@ -8726,27 +8778,78 @@ package body Sem_Ch6 is\n       --  Now deal with any postconditions from the spec\n \n       if Present (Spec_Id) then\n+         declare\n+            Parent_Op : Node_Id;\n+\n+            procedure Process_Post_Conditions\n+              (Spec  : Node_Id;\n+               Class : Boolean);\n+            --  This processes the Spec_PPC_List from Spec, processing any\n+            --  postconditions from the list. If Class is True, then only\n+            --  postconditions marked with Class_Present are considered.\n+            --  The caller has checked that Spec_PPC_List is non-Empty.\n+\n+            -----------------------------\n+            -- Process_Post_Conditions --\n+            -----------------------------\n+\n+            procedure Process_Post_Conditions\n+              (Spec  : Node_Id;\n+               Class : Boolean)\n+            is\n+               Pspec : Node_Id;\n \n-         --  Loop through PPC pragmas from spec\n-\n-         Prag := Spec_PPC_List (Spec_Id);\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Postcondition\n-              and then Pragma_Enabled (Prag)\n-            then\n-               if Plist = No_List then\n-                  Plist := Empty_List;\n-               end if;\n-\n-               if not Expander_Active then\n-                  Prepend (Grab_PPC (Name_Postcondition), Declarations (N));\n+            begin\n+               if Class then\n+                  Pspec := Spec;\n                else\n-                  Append (Grab_PPC (Name_Postcondition), Plist);\n+                  Pspec := Empty;\n                end if;\n+\n+               --  Loop through PPC pragmas from spec\n+\n+               Prag := Spec_PPC_List (Spec);\n+               loop\n+                  if Pragma_Name (Prag) = Name_Postcondition\n+                    and then Pragma_Enabled (Prag)\n+                    and then (not Class or else Class_Present (Prag))\n+                  then\n+                     if Plist = No_List then\n+                        Plist := Empty_List;\n+                     end if;\n+\n+                     if not Expander_Active then\n+                        Prepend\n+                          (Grab_PPC (Pspec), Declarations (N));\n+                     else\n+                        Append (Grab_PPC (Pspec), Plist);\n+                     end if;\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+                  exit when No (Prag);\n+               end loop;\n+            end Process_Post_Conditions;\n+\n+         begin\n+            if Present (Spec_PPC_List (Spec_Id)) then\n+               Process_Post_Conditions (Spec_Id, Class => False);\n             end if;\n \n-            Prag := Next_Pragma (Prag);\n-         end loop;\n+            --  Process directly inherited specifications\n+\n+            Parent_Op := Spec_Id;\n+            loop\n+               Parent_Op := Overridden_Operation (Parent_Op);\n+               exit when No (Parent_Op);\n+\n+               if Ekind (Parent_Op) /= E_Enumeration_Literal\n+                 and then Present (Spec_PPC_List (Parent_Op))\n+               then\n+                  Process_Post_Conditions (Parent_Op, Class => True);\n+               end if;\n+            end loop;\n+         end;\n       end if;\n \n       --  If we had any postconditions and expansion is enabled, build\n@@ -8773,6 +8876,7 @@ package body Sem_Ch6 is\n                    Make_Defining_Identifier (Loc,\n                      Chars => Name_uPostconditions);\n             --  The entity for the _Postconditions procedure\n+\n          begin\n             Prepend_To (Declarations (N),\n               Make_Subprogram_Body (Loc,"}]}