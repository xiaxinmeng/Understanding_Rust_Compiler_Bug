{"sha": "5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4MWRkZDA3ZmQzOGE5ZjIwY2E5ZTUzZmJlMTM0OGZhNDA4ZWMwNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-01-06T13:38:49Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-01-06T13:38:49Z"}, "message": "2012-01-06  Tobias Burnus <burnus@net-b.de>\n\n        * trans-openmp.c (gfc_omp_clause_dtor,\n        * gfc_trans_omp_array_reduction):\n        Update call to gfc_trans_dealloc_allocated.\n        * trans.c (gfc_allocate_using_malloc): Fix spacing.\n        (gfc_allocate_allocatable): For gfc_allocate_using_lib, jump to\n        label_finish when an error occurs.\n        (gfc_deallocate_with_status): Call caf_deregister for -fcoarray=lib.\n        * trans.h (gfc_allocate_allocatable,\n        * gfc_deallocate_with_status):\n        Update prototype.\n        (gfor_fndecl_caf_deregister): New tree symbol.\n        * trans-expr.c (gfc_conv_procedure_call): Update\n        gfc_deallocate_with_status and gfc_trans_dealloc_allocated calls.\n        * trans-array.c (gfc_array_allocate,\n        * gfc_trans_dealloc_allocated,\n        structure_alloc_comps, gfc_trans_deferred_array): Ditto.\n        (gfc_array_deallocate): Handle coarrays with -fcoarray=lib.\n        * trans-array.h (gfc_array_deallocate, gfc_array_allocate,\n        gfc_trans_dealloc_allocated): Update prototypes.\n        * trans-stmt.c (gfc_trans_sync): Fix indentation.\n        (gfc_trans_allocate): Fix errmsg padding and label handling.\n        (gfc_trans_deallocate): Ditto and handle -fcoarray=lib.\n        * expr.c (gfc_is_coarray): Fix algorithm for BT_CLASS.\n        * libgfortran.h (GFC_STAT_STOPPED_IMAGE): Use large value\n        to avoid other stats accidentally matching this one.\n        * trans-decl.c (gfor_fndecl_caf_deregister): New global var.\n        (gfc_build_builtin_function_decls): Fix prototype decl of caf_register\n        and add decl for caf_deregister.\n        (gfc_trans_deferred_vars): Handle CAF vars with -fcoarrays=lib.\n        * trans-intrinsic.c (conv_intrinsic_move_alloc): Update call to\n        gfc_deallocate_with_status.\n\n2012-01-06  Tobias Burnus <burnus@net-b.de>\n\n        * caf/single.c (_gfortran_caf_register,\n        * _gfortran_caf_deregister):\n        Fix token handling.\n        * caf/mpi.c  (_gfortran_caf_register, _gfortran_caf_deregister):\n        * Ditto.\n        * caf/libcaf.h (STAT_STOPPED_IMAGE): Sync with libgfortran.h.\n        (_gfortran_caf_register, _gfortran_caf_deregister): Update prototype.\n\n2012-01-06  Tobias Burnus <burnus@net-b.de>\n\n        * gfortran.dg/deallocate_stat_2.f90: New.\n        * coarray/allocate_errgmsg.f90: New.\n        * gfortran.dg/coarray_lib_alloc_1.f90: New.\n        * gfortran.dg/coarray_lib_alloc_2.f90: New.\n        * coarray/subobject_1.f90: Fix for num_images > 1.\n        * gfortran.dg/deallocate_stat.f90: Update due to changed\n        stat= handling.\n\nFrom-SVN: r182951", "tree": {"sha": "05910d8ab745d35d99205e6d0f724e44cd6dfb7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05910d8ab745d35d99205e6d0f724e44cd6dfb7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af0aec67b86dbdfb04e9c581590bb9ae2b6fea33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0aec67b86dbdfb04e9c581590bb9ae2b6fea33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af0aec67b86dbdfb04e9c581590bb9ae2b6fea33"}], "stats": {"total": 657, "additions": 488, "deletions": 169}, "files": [{"sha": "19f7d7bf496342e0071d1cd9a9b3ff6020d7a915", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,3 +1,34 @@\n+2012-01-06  Tobias Burnus <burnus@net-b.de>\n+\n+\t* trans-openmp.c (gfc_omp_clause_dtor, gfc_trans_omp_array_reduction):\n+\tUpdate call to gfc_trans_dealloc_allocated.\n+\t* trans.c (gfc_allocate_using_malloc): Fix spacing.\n+\t(gfc_allocate_allocatable): For gfc_allocate_using_lib, jump to\n+\tlabel_finish when an error occurs.\n+\t(gfc_deallocate_with_status): Call caf_deregister for -fcoarray=lib.\n+\t* trans.h (gfc_allocate_allocatable, gfc_deallocate_with_status):\n+\tUpdate prototype.\n+\t(gfor_fndecl_caf_deregister): New tree symbol.\n+\t* trans-expr.c (gfc_conv_procedure_call): Update\n+\tgfc_deallocate_with_status and gfc_trans_dealloc_allocated calls.\n+\t* trans-array.c (gfc_array_allocate, gfc_trans_dealloc_allocated,\n+\tstructure_alloc_comps, gfc_trans_deferred_array): Ditto.\n+\t(gfc_array_deallocate): Handle coarrays with -fcoarray=lib.\n+\t* trans-array.h (gfc_array_deallocate, gfc_array_allocate,\n+\tgfc_trans_dealloc_allocated): Update prototypes.\n+\t* trans-stmt.c (gfc_trans_sync): Fix indentation.\n+\t(gfc_trans_allocate): Fix errmsg padding and label handling.\n+\t(gfc_trans_deallocate): Ditto and handle -fcoarray=lib.\n+\t* expr.c (gfc_is_coarray): Fix algorithm for BT_CLASS.\n+\t* libgfortran.h (GFC_STAT_STOPPED_IMAGE): Use large value\n+\tto avoid other stats accidentally matching this one.\n+\t* trans-decl.c (gfor_fndecl_caf_deregister): New global var.\n+\t(gfc_build_builtin_function_decls): Fix prototype decl of caf_register\n+\tand add decl for caf_deregister.\n+\t(gfc_trans_deferred_vars): Handle CAF vars with -fcoarrays=lib.\n+\t* trans-intrinsic.c (conv_intrinsic_move_alloc): Update call to\n+\tgfc_deallocate_with_status.\n+\n 2012-01-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/PR48946"}, {"sha": "a6baa68168fb02bb896307edff6e73a08e4e3175", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,6 +1,6 @@\n /* Routines for manipulation of expression nodes.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n-   2009, 2010, 2011\n+   2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -4264,13 +4264,17 @@ gfc_is_coarray (gfc_expr *e)\n     {\n       case REF_COMPONENT:\n \tcomp = ref->u.c.component;\n-        if (comp->attr.pointer || comp->attr.allocatable)\n+\tif (comp->ts.type == BT_CLASS && comp->attr.class_ok\n+\t    && (CLASS_DATA (comp)->attr.class_pointer\n+\t\t|| CLASS_DATA (comp)->attr.allocatable))\n \t  {\n \t    coindexed = false;\n-\t    if (comp->ts.type == BT_CLASS && comp->attr.class_ok)\n-\t      coarray = CLASS_DATA (comp)->attr.codimension;\n-\t    else\n-\t      coarray = comp->attr.codimension;\n+\t    coarray = CLASS_DATA (comp)->attr.codimension;\n+\t  }\n+        else if (comp->attr.pointer || comp->attr.allocatable)\n+\t  {\n+\t    coindexed = false;\n+\t    coarray = comp->attr.codimension;\n \t  }\n         break;\n "}, {"sha": "3f36fe88bbf10c1b12286afb61dbc4197affd9ce", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* Header file to the Fortran front-end and runtime library\n-   Copyright (C) 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -105,7 +105,7 @@ typedef enum\n   GFC_STAT_UNLOCKED = 0,\n   GFC_STAT_LOCKED,\n   GFC_STAT_LOCKED_OTHER_IMAGE,\n-  GFC_STAT_STOPPED_IMAGE /* See LIBERROR_INQUIRE_INTERNAL_UNIT above. */\n+  GFC_STAT_STOPPED_IMAGE = 6000 /* See LIBERROR_INQUIRE_INTERNAL_UNIT above. */\n }\n libgfortran_stat_codes;\n "}, {"sha": "b9902b9d52ec9617994a0a2dc00d52cffe7e708e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -4938,7 +4938,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n bool\n gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n-\t\t    tree errlen, gfc_expr *expr3)\n+\t\t    tree errlen, tree label_finish, gfc_expr *expr3)\n {\n   tree tmp;\n   tree pointer;\n@@ -5064,7 +5064,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   /* The allocatable variant takes the old pointer as first argument.  */\n   if (allocatable)\n     gfc_allocate_allocatable (&elseblock, pointer, size, token,\n-\t\t\t      status, errmsg, errlen, expr);\n+\t\t\t      status, errmsg, errlen, label_finish, expr);\n   else\n     gfc_allocate_using_malloc (&elseblock, pointer, size, status);\n \n@@ -5127,24 +5127,40 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n /*GCC ARRAYS*/\n \n tree\n-gfc_array_deallocate (tree descriptor, tree pstat, gfc_expr* expr)\n+gfc_array_deallocate (tree descriptor, tree pstat, tree errmsg, tree errlen,\n+\t\t      tree label_finish, gfc_expr* expr)\n {\n   tree var;\n   tree tmp;\n   stmtblock_t block;\n+  bool coarray = gfc_is_coarray (expr);\n \n   gfc_start_block (&block);\n+\n   /* Get a pointer to the data.  */\n   var = gfc_conv_descriptor_data_get (descriptor);\n   STRIP_NOPS (var);\n \n   /* Parameter is the address of the data component.  */\n-  tmp = gfc_deallocate_with_status (var, pstat, false, expr);\n+  tmp = gfc_deallocate_with_status (coarray ? descriptor : var, pstat, errmsg,\n+\t\t\t\t    errlen, label_finish, false, expr, coarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n-  /* Zero the data pointer.  */\n+  /* Zero the data pointer; only for coarrays an error can occur and then\n+     the allocation status may not be changed.  */\n   tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n \t\t\t var, build_int_cst (TREE_TYPE (var), 0));\n+  if (pstat != NULL_TREE && coarray && gfc_option.coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree cond;\n+      tree stat = build_fold_indirect_ref_loc (input_location, pstat);\n+\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t      stat, build_int_cst (TREE_TYPE (stat), 0));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     cond, tmp, build_empty_stmt (input_location));\n+    }\n+\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -7055,7 +7071,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n /* Generate code to deallocate an array, if it is allocated.  */\n \n tree\n-gfc_trans_dealloc_allocated (tree descriptor)\n+gfc_trans_dealloc_allocated (tree descriptor, bool coarray)\n { \n   tree tmp;\n   tree var;\n@@ -7069,7 +7085,9 @@ gfc_trans_dealloc_allocated (tree descriptor)\n   /* Call array_deallocate with an int * present in the second argument.\n      Although it is ignored here, it's presence ensures that arrays that\n      are already deallocated are ignored.  */\n-  tmp = gfc_deallocate_with_status (var, NULL_TREE, true, NULL);\n+  tmp = gfc_deallocate_with_status (coarray ? descriptor : var, NULL_TREE,\n+\t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE, true,\n+\t\t\t\t    NULL, coarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -7358,7 +7376,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    {\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      tmp = gfc_trans_dealloc_allocated (comp);\n+\t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable)\n@@ -7388,7 +7406,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n \n \t      if (GFC_DESCRIPTOR_TYPE_P(TREE_TYPE (comp)))\n-\t        tmp = gfc_trans_dealloc_allocated (comp);\n+\t        tmp = gfc_trans_dealloc_allocated (comp,\n+\t\t\t\t\tCLASS_DATA (c)->attr.codimension);\n \t      else\n \t\t{\n \t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL, true, NULL,\n@@ -8094,7 +8113,8 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n   if (sym->attr.allocatable && (sym->attr.dimension || sym->attr.codimension)\n       && !sym->attr.save && !sym->attr.result)\n     {\n-      tmp = gfc_trans_dealloc_allocated (sym->backend_decl);\n+      tmp = gfc_trans_dealloc_allocated (sym->backend_decl,\n+\t\t\t\t\t sym->attr.codimension);\n       gfc_add_expr_to_block (&cleanup, tmp);\n     }\n "}, {"sha": "ed922d028143fc9237c2a09052995bb6df4801ef", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* Header for array handling functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -20,11 +20,12 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Generate code to free an array.  */\n-tree gfc_array_deallocate (tree, tree, gfc_expr*);\n+tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*);\n \n /* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n-bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, gfc_expr *);\n+bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, tree,\n+\t\t\t gfc_expr *);\n \n /* Allow the bounds of a loop to be set from a callee's array spec.  */\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,\n@@ -42,7 +43,7 @@ void gfc_trans_dummy_array_bias (gfc_symbol *, tree, gfc_wrapped_block *);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate code to deallocate an array, if it is allocated.  */\n-tree gfc_trans_dealloc_allocated (tree);\n+tree gfc_trans_dealloc_allocated (tree, bool);\n \n tree gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank);\n "}, {"sha": "0761ebb26d1d438c1e3b8570fdf5ea00b9744453", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,6 +1,6 @@\n /* Backend function setup\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -121,6 +121,7 @@ tree gfor_fndecl_associated;\n tree gfor_fndecl_caf_init;\n tree gfor_fndecl_caf_finalize;\n tree gfor_fndecl_caf_register;\n+tree gfor_fndecl_caf_deregister;\n tree gfor_fndecl_caf_critical;\n tree gfor_fndecl_caf_end_critical;\n tree gfor_fndecl_caf_sync_all;\n@@ -3163,7 +3164,11 @@ gfc_build_builtin_function_decls (void)\n       gfor_fndecl_caf_register = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_register\")), \"...WWW\", pvoid_type_node, 6,\n         size_type_node, integer_type_node, ppvoid_type_node, pint_type,\n-        build_pointer_type (pchar_type_node), integer_type_node);\n+        pchar_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_deregister = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_deregister\")), \".WWW\", void_type_node, 4,\n+        ppvoid_type_node, pint_type, pchar_type_node, integer_type_node);\n \n       gfor_fndecl_caf_critical = gfc_build_library_function_decl (\n \tget_identifier (PREFIX(\"caf_critical\")), void_type_node, 0);\n@@ -3688,6 +3693,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t{\n \t  if (!sym->attr.save)\n \t    {\n+\t      tree descriptor = NULL_TREE;\n+\n \t      /* Nullify and automatic deallocation of allocatable\n \t\t scalars.  */\n \t      e = gfc_lval_expr_from_sym (sym);\n@@ -3712,6 +3719,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      else\n \t\t{\n \t\t  gfc_conv_expr (&se, e);\n+\t\t  descriptor = se.expr;\n \t\t  se.expr = gfc_conv_descriptor_data_addr (se.expr);\n \t\t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n \t\t}\n@@ -3761,9 +3769,18 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      /* Deallocate when leaving the scope. Nullifying is not\n \t\t needed.  */\n \t      if (!sym->attr.result && !sym->attr.dummy)\n-\t\ttmp = gfc_deallocate_scalar_with_status (se.expr, NULL, true,\n-\t\t\t\t\t\t\t NULL, sym->ts);\n-\n+\t\t{\n+\t\t  if (sym->ts.type == BT_CLASS\n+\t\t      && CLASS_DATA (sym)->attr.codimension)\n+\t\t    tmp = gfc_deallocate_with_status (descriptor, NULL_TREE,\n+\t\t\t\t\t\t      NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t      NULL_TREE, true, NULL,\n+\t\t\t\t\t\t      true);\n+\t\t  else\n+\t\t    tmp = gfc_deallocate_scalar_with_status (se.expr, NULL,\n+\t\t\t\t\t\t\t     true, NULL,\n+\t\t\t\t\t\t\t     sym->ts);\n+\t\t}\n \t      if (sym->ts.type == BT_CLASS)\n \t\t{\n \t\t  /* Initialize _vptr to declared type.  */"}, {"sha": "14411e05cdee647a7965c6f6a2f418248bc6da23", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -3525,7 +3525,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t\t      gfc_init_block  (&block);\n \t\t      tmp = gfc_deallocate_with_status (parmse.expr, NULL_TREE,\n-\t\t\t\t\t\t\ttrue, NULL);\n+\t\t\t\t\t\t\tNULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t\tNULL_TREE, true, NULL,\n+\t\t\t\t\t\t\tfalse);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n \t\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t\t     void_type_node, parmse.expr,\n@@ -3665,7 +3667,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t     parmse.expr);\n-\t\t  tmp = gfc_trans_dealloc_allocated (tmp);\n+\t\t  tmp = gfc_trans_dealloc_allocated (tmp, false);\n \t\t  if (fsym->attr.optional\n \t\t      && e->expr_type == EXPR_VARIABLE\n \t\t      && e->symtree->n.sym->attr.optional)\n@@ -4335,7 +4337,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t  /* Finally free the temporary's data field.  */\n \t  tmp = gfc_conv_descriptor_data_get (tmp2);\n-\t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, true, NULL);\n+\t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t    NULL_TREE, NULL_TREE, true,\n+\t\t\t\t\t    NULL, false);\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t}\n     }"}, {"sha": "cb742733df88b469b9b0efcbc5efac70f677adf0", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,6 @@\n /* Intrinsic translation\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -7355,7 +7356,8 @@ conv_intrinsic_move_alloc (gfc_code *code)\n   gfc_conv_expr_descriptor (&from_se, from_expr, from_ss);\n \n   tmp = gfc_conv_descriptor_data_get (to_se.expr);\n-  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, true, to_expr);\n+  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t    NULL_TREE, true, to_expr, false);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Move the pointer and update the array descriptor data.  */"}, {"sha": "f8b3e2280d0930faa929975a478e28e269d46127", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* OpenMP directive translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>\n \n@@ -326,7 +326,7 @@ gfc_omp_clause_dtor (tree clause ATTRIBUTE_UNUSED, tree decl)\n \n   /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n      to be deallocated if they were allocated.  */\n-  return gfc_trans_dealloc_allocated (decl);\n+  return gfc_trans_dealloc_allocated (decl, false);\n }\n \n \n@@ -708,7 +708,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       gfc_start_block (&block);\n       gfc_add_expr_to_block (&block, gfc_trans_assignment (e3, e4, false,\n \t\t\t     true));\n-      gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl));\n+      gfc_add_expr_to_block (&block, gfc_trans_dealloc_allocated (decl, false));\n       stmt = gfc_finish_block (&block);\n     }\n   else"}, {"sha": "9456e2d3b059a2cbc400b6009ab718ddeb9d832d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 91, "deletions": 77, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,6 +1,6 @@\n /* Statement translation -- generate GCC trees from gfc_code.\n    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -755,8 +755,8 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n    if (gfc_option.coarray == GFC_FCOARRAY_LIB)\n      {\n        tmp = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n-\ttmp = build_call_expr_loc (input_location, tmp, 0);\n-\tgfc_add_expr_to_block (&se.pre, tmp);\n+       tmp = build_call_expr_loc (input_location, tmp, 0);\n+       gfc_add_expr_to_block (&se.pre, tmp);\n      }\n \n   if (gfc_option.coarray != GFC_FCOARRAY_LIB || type == EXEC_SYNC_MEMORY)\n@@ -4738,10 +4738,10 @@ gfc_trans_allocate (gfc_code * code)\n       if (code->expr2)\n \t{\n \t  gfc_init_se (&se, NULL);\n+\t  se.want_pointer = 1;\n \t  gfc_conv_expr_lhs (&se, code->expr2);\n-\n-\t  errlen = gfc_get_expr_charlen (code->expr2);\n-\t  errmsg = gfc_build_addr_expr (pchar_type_node, se.expr);\n+\t  errmsg = se.expr;\n+\t  errlen = se.string_length;\n \t}\n       else\n \t{\n@@ -4752,8 +4752,7 @@ gfc_trans_allocate (gfc_code * code)\n       /* GOTO destinations.  */\n       label_errmsg = gfc_build_label_decl (NULL_TREE);\n       label_finish = gfc_build_label_decl (NULL_TREE);\n-      TREE_USED (label_errmsg) = 1;\n-      TREE_USED (label_finish) = 1;\n+      TREE_USED (label_finish) = 0;\n     }\n \n   expr3 = NULL_TREE;\n@@ -4772,7 +4771,8 @@ gfc_trans_allocate (gfc_code * code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen, code->expr3))\n+      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen, label_finish,\n+\t\t\t       code->expr3))\n \t{\n \t  /* A scalar or derived type.  */\n \n@@ -4892,7 +4892,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n \t  if (gfc_expr_attr (expr).allocatable)\n \t    gfc_allocate_allocatable (&se.pre, se.expr, memsz, NULL_TREE,\n-\t\t\t\t      stat, errmsg, errlen, expr);\n+\t\t\t\t      stat, errmsg, errlen, label_finish, expr);\n \t  else\n \t    gfc_allocate_using_malloc (&se.pre, se.expr, memsz, stat);\n \n@@ -4919,18 +4919,12 @@ gfc_trans_allocate (gfc_code * code)\n       /* Error checking -- Note: ERRMSG only makes sense with STAT.  */\n       if (code->expr1)\n \t{\n-\t  /* The coarray library already sets the errmsg.  */\n-\t  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n-\t      && gfc_expr_attr (expr).codimension)\n-\t    tmp = build1_v (GOTO_EXPR, label_finish);\n-\t  else\n-\t    tmp = build1_v (GOTO_EXPR, label_errmsg);\n-\n+\t  tmp = build1_v (GOTO_EXPR, label_errmsg);\n \t  parm = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t  boolean_type_node, stat,\n \t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t gfc_unlikely(parm), tmp,\n+\t\t\t\t gfc_unlikely (parm), tmp,\n \t\t\t\t     build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n@@ -5102,26 +5096,24 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_free_expr (expr);\n     }\n \n-  /* STAT  (ERRMSG only makes sense with STAT).  */\n+  /* STAT.  */\n   if (code->expr1)\n     {\n       tmp = build1_v (LABEL_EXPR, label_errmsg);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n-  /* ERRMSG block.  */\n-  if (code->expr2)\n+  /* ERRMSG - only useful if STAT is present.  */\n+  if (code->expr1 && code->expr2)\n     {\n-      /* A better error message may be possible, but not required.  */\n       const char *msg = \"Attempt to allocate an allocated object\";\n-      tree slen, dlen;\n+      tree slen, dlen, errmsg_str;\n+      stmtblock_t errmsg_block;\n \n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_lhs (&se, code->expr2);\n+      gfc_init_block (&errmsg_block);\n \n-      errmsg = gfc_create_var (pchar_type_node, \"ERRMSG\");\n-\n-      gfc_add_modify (&block, errmsg,\n+      errmsg_str = gfc_create_var (pchar_type_node, \"ERRMSG\");\n+      gfc_add_modify (&errmsg_block, errmsg_str,\n \t\tgfc_build_addr_expr (pchar_type_node,\n \t\t\tgfc_build_localized_cstring_const (msg)));\n \n@@ -5130,9 +5122,9 @@ gfc_trans_allocate (gfc_code * code)\n       slen = fold_build2_loc (input_location, MIN_EXPR, TREE_TYPE (slen), dlen,\n \t\t\t      slen);\n \n-      dlen = build_call_expr_loc (input_location,\n-\t\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n-\t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n+      gfc_trans_string_copy (&errmsg_block, dlen, errmsg, code->expr2->ts.kind,\n+\t\t\t     slen, errmsg_str, gfc_default_character_kind);\n+      dlen = gfc_finish_block (&errmsg_block);\n \n       tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n \t\t\t     build_int_cst (TREE_TYPE (stat), 0));\n@@ -5142,16 +5134,15 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n-  /* STAT  (ERRMSG only makes sense with STAT).  */\n-  if (code->expr1)\n-    {\n-      tmp = build1_v (LABEL_EXPR, label_finish);\n-      gfc_add_expr_to_block (&block, tmp);\n-    }\n-\n   /* STAT block.  */\n   if (code->expr1)\n     {\n+      if (TREE_USED (label_finish))\n+\t{\n+\t  tmp = build1_v (LABEL_EXPR, label_finish);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_lhs (&se, code->expr1);\n       tmp = convert (TREE_TYPE (se.expr), stat);\n@@ -5172,29 +5163,39 @@ gfc_trans_deallocate (gfc_code *code)\n {\n   gfc_se se;\n   gfc_alloc *al;\n-  tree apstat, astat, pstat, stat, tmp;\n+  tree apstat, pstat, stat, errmsg, errlen, tmp;\n+  tree label_finish, label_errmsg;\n   stmtblock_t block;\n \n-  pstat = apstat = stat = astat = tmp = NULL_TREE;\n+  pstat = apstat = stat = errmsg = errlen = tmp = NULL_TREE;\n+  label_finish = label_errmsg = NULL_TREE;\n \n   gfc_start_block (&block);\n \n   /* Count the number of failed deallocations.  If deallocate() was\n      called with STAT= , then set STAT to the count.  If deallocate\n      was called with ERRMSG, then set ERRMG to a string.  */\n-  if (code->expr1 || code->expr2)\n+  if (code->expr1)\n     {\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n \n       stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n       pstat = gfc_build_addr_expr (NULL_TREE, stat);\n \n-      /* Running total of possible deallocation failures.  */\n-      astat = gfc_create_var (gfc_int4_type_node, \"astat\");\n-      apstat = gfc_build_addr_expr (NULL_TREE, astat);\n+      /* GOTO destinations.  */\n+      label_errmsg = gfc_build_label_decl (NULL_TREE);\n+      label_finish = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (label_finish) = 0;\n+    }\n \n-      /* Initialize astat to 0.  */\n-      gfc_add_modify (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n+  /* Set ERRMSG - only needed if STAT is available.  */\n+  if (code->expr1 && code->expr2)\n+    {\n+      gfc_init_se (&se, NULL);\n+      se.want_pointer = 1;\n+      gfc_conv_expr_lhs (&se, code->expr2);\n+      errmsg = se.expr;\n+      errlen = se.string_length;\n     }\n \n   for (al = code->ext.alloc.list; al != NULL; al = al->next)\n@@ -5212,7 +5213,7 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (expr->rank || gfc_expr_attr (expr).codimension)\n+      if (expr->rank || gfc_is_coarray (expr))\n \t{\n \t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n \t    {\n@@ -5232,7 +5233,8 @@ gfc_trans_deallocate (gfc_code *code)\n \t\t  gfc_add_expr_to_block (&se.pre, tmp);\n \t\t}\n \t    }\n-\t  tmp = gfc_array_deallocate (se.expr, pstat, expr);\n+\t  tmp = gfc_array_deallocate (se.expr, pstat, errmsg, errlen,\n+\t\t\t\t      label_finish, expr);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \t}\n       else\n@@ -5261,62 +5263,74 @@ gfc_trans_deallocate (gfc_code *code)\n \t    }\n \t}\n \n-      /* Keep track of the number of failed deallocations by adding stat\n-\t of the last deallocation to the running total.  */\n-      if (code->expr1 || code->expr2)\n+      if (code->expr1)\n \t{\n-\t  apstat = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t    TREE_TYPE (stat), astat, stat);\n-\t  gfc_add_modify (&se.pre, astat, apstat);\n+          tree cond;\n+\n+\t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n+\t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t gfc_unlikely (cond),\n+\t\t\t\t build1_v (GOTO_EXPR, label_errmsg),\n+\t\t\t\t build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&se.pre, tmp);\n \t}\n \n       tmp = gfc_finish_block (&se.pre);\n       gfc_add_expr_to_block (&block, tmp);\n       gfc_free_expr (expr);\n     }\n \n-  /* Set STAT.  */\n   if (code->expr1)\n     {\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_lhs (&se, code->expr1);\n-      tmp = convert (TREE_TYPE (se.expr), astat);\n-      gfc_add_modify (&block, se.expr, tmp);\n+      tmp = build1_v (LABEL_EXPR, label_errmsg);\n+      gfc_add_expr_to_block (&block, tmp);\n     }\n \n-  /* Set ERRMSG.  */\n-  if (code->expr2)\n+  /* Set ERRMSG - only needed if STAT is available.  */\n+  if (code->expr1 && code->expr2)\n     {\n-      /* A better error message may be possible, but not required.  */\n       const char *msg = \"Attempt to deallocate an unallocated object\";\n-      tree errmsg, slen, dlen;\n+      stmtblock_t errmsg_block;\n+      tree errmsg_str, slen, dlen, cond;\n \n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_lhs (&se, code->expr2);\n+      gfc_init_block (&errmsg_block);\n \n-      errmsg = gfc_create_var (pchar_type_node, \"ERRMSG\");\n-\n-      gfc_add_modify (&block, errmsg,\n+      errmsg_str = gfc_create_var (pchar_type_node, \"ERRMSG\");\n+      gfc_add_modify (&errmsg_block, errmsg_str,\n \t\tgfc_build_addr_expr (pchar_type_node,\n                         gfc_build_localized_cstring_const (msg)));\n-\n       slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n       dlen = gfc_get_expr_charlen (code->expr2);\n-      slen = fold_build2_loc (input_location, MIN_EXPR, TREE_TYPE (slen), dlen,\n-\t\t\t      slen);\n \n-      dlen = build_call_expr_loc (input_location,\n-\t\t\t\t  builtin_decl_explicit (BUILT_IN_MEMCPY), 3,\n-\t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n+      gfc_trans_string_copy (&errmsg_block, dlen, errmsg, code->expr2->ts.kind,\n+\t\t\t     slen, errmsg_str, gfc_default_character_kind);\n+      tmp = gfc_finish_block (&errmsg_block);\n \n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, astat,\n-\t\t\t     build_int_cst (TREE_TYPE (astat), 0));\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n+\t\t\t     build_int_cst (TREE_TYPE (stat), 0));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     gfc_unlikely (cond), tmp,\n+\t\t\t     build_empty_stmt (input_location));\n \n-      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n \n+  if (code->expr1 && TREE_USED (label_finish))\n+    {\n+      tmp = build1_v (LABEL_EXPR, label_finish);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n+  /* Set STAT.  */\n+  if (code->expr1)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_lhs (&se, code->expr1);\n+      tmp = convert (TREE_TYPE (se.expr), stat);\n+      gfc_add_modify (&block, se.expr, tmp);\n+    }\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "8075dbc32e19edb2bc9f1df946211d75da3992c8", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 119, "deletions": 25, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* Code translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -653,7 +653,7 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n \t\t\t\tboolean_type_node, pointer,\n \t\t\t\tbuild_int_cst (prvoid_type_node, 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t gfc_unlikely(error_cond), on_error,\n+\t\t\t gfc_unlikely (error_cond), on_error,\n \t\t\t build_empty_stmt (input_location));\n \n   gfc_add_expr_to_block (block, tmp);\n@@ -738,7 +738,8 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n     and variable name in case a runtime error has to be printed.  */\n void\n gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n-\t\t\t  tree status, tree errmsg, tree errlen, gfc_expr* expr)\n+\t\t\t  tree status, tree errmsg, tree errlen, tree label_finish,\n+\t\t\t  gfc_expr* expr)\n {\n   stmtblock_t alloc_block;\n   tree tmp, null_mem, alloc, error;\n@@ -757,8 +758,23 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB\n       && gfc_expr_attr (expr).codimension)\n-    gfc_allocate_using_lib (&alloc_block, mem, size, token, status,\n-\t\t\t    errmsg, errlen);\n+    {\n+      tree cond;\n+\n+      gfc_allocate_using_lib (&alloc_block, mem, size, token, status,\n+\t\t\t      errmsg, errlen);\n+      if (status != NULL_TREE)\n+\t{\n+\t  TREE_USED (label_finish) = 1;\n+\t  tmp = build1_v (GOTO_EXPR, label_finish);\n+\t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t  status, build_zero_cst (TREE_TYPE (status)));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t gfc_unlikely (cond), tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&alloc_block, tmp);\n+\t}\n+    }\n   else\n     gfc_allocate_using_malloc (&alloc_block, mem, size, status);\n \n@@ -852,13 +868,27 @@ gfc_call_free (tree var)\n    each procedure).\n    \n    If a runtime-message is possible, `expr' must point to the original\n-   expression being deallocated for its locus and variable name.  */\n+   expression being deallocated for its locus and variable name.\n+\n+   For coarrays, \"pointer\" must be the array descriptor and not its\n+   \"data\" component.  */\n tree\n-gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n-\t\t\t    gfc_expr* expr)\n+gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n+\t\t\t    tree errlen, tree label_finish,\n+\t\t\t    bool can_fail, gfc_expr* expr, bool coarray)\n {\n   stmtblock_t null, non_null;\n   tree cond, tmp, error;\n+  tree status_type = NULL_TREE;\n+  tree caf_decl = NULL_TREE;\n+\n+  if (coarray)\n+    {\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (pointer)));\n+      caf_decl = pointer;\n+      pointer = gfc_conv_descriptor_data_get (caf_decl);\n+      STRIP_NOPS (pointer);\n+    }\n \n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n@@ -884,9 +914,9 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n \n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n-      tree status_type = TREE_TYPE (TREE_TYPE (status));\n       tree cond2;\n \n+      status_type = TREE_TYPE (TREE_TYPE (status));\n       cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n       tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n@@ -901,26 +931,90 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n \n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     builtin_decl_explicit (BUILT_IN_FREE), 1,\n-\t\t\t     fold_convert (pvoid_type_node, pointer));\n-  gfc_add_expr_to_block (&non_null, tmp);\n+  if (!coarray || gfc_option.coarray != GFC_FCOARRAY_LIB)\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,\n+\t\t\t\t fold_convert (pvoid_type_node, pointer));\n+      gfc_add_expr_to_block (&non_null, tmp);\n \n-  if (status != NULL_TREE && !integer_zerop (status))\n+      if (status != NULL_TREE && !integer_zerop (status))\n+\t{\n+\t  /* We set STATUS to zero if it is present.  */\n+\t  tree status_type = TREE_TYPE (TREE_TYPE (status));\n+\t  tree cond2;\n+\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   status,\n+\t\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t\t fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t\t  status_type, status),\n+\t\t\t\t build_int_cst (status_type, 0));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t gfc_unlikely (cond2), tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&non_null, tmp);\n+\t}\n+    }\n+  else\n     {\n-      /* We set STATUS to zero if it is present.  */\n-      tree status_type = TREE_TYPE (TREE_TYPE (status));\n-      tree cond2;\n+      tree caf_type, token, cond2;\n+      tree pstat = null_pointer_node;\n \n-      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n-      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n-\t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t\t      status_type, status),\n-\t\t\t     build_int_cst (status_type, 0));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond2,\n-\t\t\t     tmp, build_empty_stmt (input_location));\n+      if (errmsg == NULL_TREE)\n+\t{\n+\t  gcc_assert (errlen == NULL_TREE);\n+\t  errmsg = null_pointer_node;\n+\t  errlen = build_zero_cst (integer_type_node);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (errlen != NULL_TREE);\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (errmsg)))\n+\t    errmsg = gfc_build_addr_expr (NULL_TREE, errmsg);\n+\t}\n+\n+      caf_type = TREE_TYPE (caf_decl);\n+\n+      if (status != NULL_TREE && !integer_zerop (status))\n+\t{\n+\t  gcc_assert (status_type == integer_type_node);\n+\t  pstat = status;\n+\t}\n+\n+      if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n+\t  && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n+\ttoken = gfc_conv_descriptor_token (caf_decl);\n+      else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t       && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n+\ttoken = GFC_DECL_TOKEN (caf_decl);\n+      else\n+\t{\n+\t  gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n+\t\t      && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) != NULL_TREE);\n+\t  token = GFC_TYPE_ARRAY_CAF_TOKEN (caf_type);\n+\t}\n+\n+      token = gfc_build_addr_expr  (NULL_TREE, token);\n+      tmp = build_call_expr_loc (input_location,\n+\t     gfor_fndecl_caf_deregister, 4,\n+\t     token, pstat, errmsg, errlen);\n       gfc_add_expr_to_block (&non_null, tmp);\n+\n+      if (status != NULL_TREE)\n+\t{\n+\t  tree stat = build_fold_indirect_ref_loc (input_location, status);\n+\n+\t  TREE_USED (label_finish) = 1;\n+\t  tmp = build1_v (GOTO_EXPR, label_finish);\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   stat, build_zero_cst (TREE_TYPE (stat)));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+        \t\t\t gfc_unlikely (cond2), tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&non_null, tmp);\n+\t}\n     }\n \n   return fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,"}, {"sha": "b7c25b344881bb33d199714ce9d5555388079637", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,6 @@\n /* Header for code translation functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -587,14 +588,15 @@ tree gfc_call_malloc (stmtblock_t *, tree, tree);\n tree gfc_build_memcpy_call (tree, tree, tree);\n \n /* Allocate memory for allocatable variables, with optional status variable.  */\n-void gfc_allocate_allocatable (stmtblock_t*, tree, tree, tree,\n+void gfc_allocate_allocatable (stmtblock_t*, tree, tree, tree, tree,\n \t\t\t       tree, tree, tree, gfc_expr*);\n \n /* Allocate memory, with optional status variable.  */\n void gfc_allocate_using_malloc (stmtblock_t *, tree, tree, tree);\n \n /* Generate code to deallocate an array.  */\n-tree gfc_deallocate_with_status (tree, tree, bool, gfc_expr*);\n+tree gfc_deallocate_with_status (tree, tree, tree, tree, tree, bool,\n+\t\t\t\t gfc_expr *, bool);\n tree gfc_deallocate_scalar_with_status (tree, tree, bool, gfc_expr*, gfc_typespec);\n \n /* Generate code to call realloc().  */\n@@ -676,6 +678,7 @@ extern GTY(()) tree gfor_fndecl_associated;\n extern GTY(()) tree gfor_fndecl_caf_init;\n extern GTY(()) tree gfor_fndecl_caf_finalize;\n extern GTY(()) tree gfor_fndecl_caf_register;\n+extern GTY(()) tree gfor_fndecl_caf_deregister;\n extern GTY(()) tree gfor_fndecl_caf_critical;\n extern GTY(()) tree gfor_fndecl_caf_end_critical;\n extern GTY(()) tree gfor_fndecl_caf_sync_all;"}, {"sha": "aeef955360f6b93f6bac001590ddda41ddae743c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,3 +1,13 @@\n+2012-01-06  Tobias Burnus <burnus@net-b.de>\n+\n+\t* gfortran.dg/deallocate_stat_2.f90: New.\n+\t* coarray/allocate_errgmsg.f90: New.\n+\t* gfortran.dg/coarray_lib_alloc_1.f90: New.\n+\t* gfortran.dg/coarray_lib_alloc_2.f90: New.\n+\t* coarray/subobject_1.f90: Fix for num_images > 1.\n+\t* gfortran.dg/deallocate_stat.f90: Update due to changed\n+\tstat= handling.\n+\n 2012-01-06  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* gcc.target/arm/headmerge-2.c: Adjust scan pattern."}, {"sha": "e5a19543742d6eee977f143b99c6b8be1246fb22", "filename": "gcc/testsuite/gfortran.dg/coarray/allocate_errgmsg.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fallocate_errgmsg.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fallocate_errgmsg.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fallocate_errgmsg.f90?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+!\n+! Check handling of errmsg.\n+!\n+implicit none\n+integer, allocatable :: a[:], b(:)[:], c, d(:)\n+integer :: stat\n+character(len=300) :: str\n+\n+allocate(a[*], b(1)[*], c, d(2), stat=stat)\n+\n+str = repeat('X', len(str))\n+allocate(a[*], stat=stat, errmsg=str)\n+!print *, stat, trim(str)\n+if (stat == 0 .or. str /= \"Attempt to allocate an allocated object\") &\n+  call abort ()\n+\n+str = repeat('Y', len(str))\n+allocate(b(2)[*], stat=stat, errmsg=str)\n+!print *, stat, trim(str)\n+if (stat == 0 .or. str /= \"Attempt to allocate an allocated object\") &\n+  call abort ()\n+\n+str = repeat('Q', len(str))\n+allocate(c, stat=stat, errmsg=str)\n+!print *, stat, trim(str)\n+if (stat == 0 .or. str /= \"Attempt to allocate an allocated object\") &\n+  call abort ()\n+\n+str = repeat('P', len(str))\n+allocate(d(3), stat=stat, errmsg=str)\n+!print *, stat, trim(str)\n+if (stat == 0 .or. str /= \"Attempt to allocate an allocated object\") &\n+  call abort ()\n+\n+end"}, {"sha": "028c24a8e65d9d626aadf7e3fdb7e8ad61b78ba4", "filename": "gcc/testsuite/gfortran.dg/coarray/subobject_1.f90", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsubobject_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsubobject_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsubobject_1.f90?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -24,20 +24,20 @@\n   b%a%i = 7\n   if (b%a%i /= 7) call abort\n   if (any (lcobound(b%a) /= (/ lb /))) call abort\n-  if (ucobound(b%a, dim=1) /= this_image() + lb - 1) call abort\n+  if (ucobound(b%a, dim=1) /= num_images() + lb - 1) call abort\n   if (any (lcobound(b%a%i) /= (/ lb /))) call abort\n-  if (ucobound(b%a%i, dim=1) /= this_image() + lb - 1) call abort\n+  if (ucobound(b%a%i, dim=1) /= num_images() + lb - 1) call abort\n   allocate(c%a(la)[lc:*])\n   c%a%i = init\n   if (any(c%a%i /= init)) call abort\n   if (any (lcobound(c%a) /= (/ lc /))) call abort\n-  if (ucobound(c%a, dim=1) /= this_image() + lc - 1) call abort\n+  if (ucobound(c%a, dim=1) /= num_images() + lc - 1) call abort\n   if (any (lcobound(c%a%i) /= (/ lc /))) call abort\n-  if (ucobound(c%a%i, dim=1) /= this_image() + lc - 1) call abort\n+  if (ucobound(c%a%i, dim=1) /= num_images() + lc - 1) call abort\n   if (c%a(2)%i /= init(2)) call abort\n   if (any (lcobound(c%a(2)) /= (/ lc /))) call abort\n-  if (ucobound(c%a(2), dim=1) /= this_image() + lc - 1) call abort\n+  if (ucobound(c%a(2), dim=1) /= num_images() + lc - 1) call abort\n   if (any (lcobound(c%a(2)%i) /= (/ lc /))) call abort\n-  if (ucobound(c%a(2)%i, dim=1) /= this_image() + lc - 1) call abort\n+  if (ucobound(c%a(2)%i, dim=1) /= num_images() + lc - 1) call abort\n   deallocate(b%a, c%a)\n end"}, {"sha": "c0d06a4bd2a706e3fe9599da9617f30008336c26", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+!\n+! Allocate/deallocate with libcaf.\n+!\n+\n+ integer(4), allocatable :: xx[:], yy(:)[:]\n+ integer :: stat\n+ character(len=200) :: errmsg\n+ allocate(xx[*], stat=stat, errmsg=errmsg)\n+ allocate(yy(2)[*], stat=stat, errmsg=errmsg)\n+ deallocate(xx,yy,stat=stat, errmsg=errmsg)\n+ end\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .4, 1, &xx.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .8, 1, &yy.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "3aaff1e8c3511c5464a2cc12737c3ab5394c63cc", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_2.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+!\n+! Allocate/deallocate with libcaf.\n+!\n+\n+ type t\n+ end type t\n+ class(t), allocatable :: xx[:], yy(:)[:]\n+ integer :: stat\n+ character(len=200) :: errmsg\n+ allocate(xx[*], stat=stat, errmsg=errmsg)\n+ allocate(yy(2)[*], stat=stat, errmsg=errmsg)\n+ deallocate(xx,yy,stat=stat, errmsg=errmsg)\n+ end\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .1, 1, &xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register .1, 1, &yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "b2ba95c740aa513950ee087e13aca6c9c6e67a0d", "filename": "gcc/testsuite/gfortran.dg/deallocate_stat.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_stat.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_stat.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_stat.f90?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -69,9 +69,9 @@ program deallocate_stat\n    i = 13\n    deallocate(a1, stat=i) ;         if (i /= 0) call abort\n    deallocate(a2, a1, stat=i) ;     if (i /= 1) call abort\n-   deallocate(a1, a3, a2, stat=i) ; if (i /= 2) call abort\n+   deallocate(a1, a3, a2, stat=i) ; if (i /= 1) call abort\n    deallocate(b4, stat=i) ;         if (i /= 0) call abort\n    deallocate(b4, b5, stat=i) ;     if (i /= 1) call abort\n-   deallocate(b4, b5, b6, stat=i) ; if (i /= 2) call abort\n+   deallocate(b4, b5, b6, stat=i) ; if (i /= 1) call abort\n \n end program deallocate_stat"}, {"sha": "e93f446a8180ae3c2e676d0092a6c9fee2dd54f2", "filename": "gcc/testsuite/gfortran.dg/deallocate_stat_2.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_stat_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_stat_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_stat_2.f90?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+!\n+! Check that the error is properly diagnosed and the strings are correctly padded.\n+!\n+integer, allocatable :: A, B(:)\n+integer :: stat\n+character(len=5) :: sstr\n+character(len=200) :: str\n+\n+str = repeat('X', len(str))\n+deallocate(a, stat=stat, errmsg=str)\n+!print *, stat, trim(str)\n+if (stat == 0 .or. str /= \"Attempt to deallocate an unallocated object\") call abort()\n+\n+str = repeat('Y', len(str))\n+deallocate(b, stat=stat, errmsg=str)\n+!print *, stat, trim(str)\n+if (stat == 0 .or. str /= \"Attempt to deallocate an unallocated object\") call abort()\n+\n+sstr = repeat('Q', len(sstr))\n+deallocate(a, stat=stat, errmsg=sstr)\n+!print *, stat, trim(sstr)\n+if (stat == 0 .or. sstr /= \"Attem\") call abort()\n+\n+sstr = repeat('P', len(sstr))\n+deallocate(b, stat=stat, errmsg=sstr)\n+!print *, stat, trim(sstr)\n+if (stat == 0 .or. sstr /= \"Attem\") call abort()\n+\n+end"}, {"sha": "f6b2a167fa4cc1eea311e2ae224e76ca1e641049", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,3 +1,11 @@\n+2012-01-06  Tobias Burnus <burnus@net-b.de>\n+\n+\t* caf/single.c (_gfortran_caf_register, _gfortran_caf_deregister):\n+\tFix token handling.\n+\t* caf/mpi.c  (_gfortran_caf_register, _gfortran_caf_deregister): Ditto.\n+\t* caf/libcaf.h (STAT_STOPPED_IMAGE): Sync with libgfortran.h.\n+\t(_gfortran_caf_register, _gfortran_caf_deregister): Update prototype.\n+\n 2011-12-22  Janne Blomqvist  <jb@gcc.gnu.org>\n \tTobias Burnus  <burnus@net-b.de>\n "}, {"sha": "caffe17c272d8e243c04d33233a33baad948febb", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* Common declarations for all of GNU Fortran libcaf implementations.\n-   Copyright (C) 2011\n+   Copyright (C) 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n@@ -44,7 +44,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define STAT_UNLOCKED\t\t0\n #define STAT_LOCKED\t\t1\n #define STAT_LOCKED_OTHER_IMAGE\t2\n-#define STAT_STOPPED_IMAGE \t3\n+#define STAT_STOPPED_IMAGE \t6000\n \n /* Describes what type of array we are registerring. Keep in sync with\n    gcc/fortran/trans.h.  */\n@@ -67,9 +67,9 @@ caf_static_t;\n void _gfortran_caf_init (int *, char ***, int *, int *);\n void _gfortran_caf_finalize (void);\n \n-void * _gfortran_caf_register (ptrdiff_t, caf_register_t, void **, int *,\n+void * _gfortran_caf_register (ptrdiff_t, caf_register_t, void ***, int *,\n \t\t\t       char *, int);\n-void _gfortran_caf_deregister (void **, int *, char *, int);\n+void _gfortran_caf_deregister (void ***, int *, char *, int);\n \n \n void _gfortran_caf_sync_all (int *, char *, int);"}, {"sha": "8c9f07b5b22c0b77afde5dec56e5537bc57f781f", "filename": "libgfortran/caf/mpi.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2Fcaf%2Fmpi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2Fcaf%2Fmpi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fmpi.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* MPI implementation of GNU Fortran Coarray Library\n-   Copyright (C) 2011\n+   Copyright (C) 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n@@ -119,7 +119,7 @@ _gfortran_caf_finalize (void)\n \n \n void *\n-_gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n+_gfortran_caf_register (ptrdiff_t size, caf_register_t type, void ***token,\n \t\t\tint *stat, char *errmsg, int errmsg_len)\n {\n   void *local;\n@@ -134,26 +134,27 @@ _gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n \n   /* Token contains only a list of pointers.  */\n   local = malloc (size);\n-  token = malloc (sizeof (void*) * caf_num_images);\n+  *token = malloc (sizeof (void*) * caf_num_images);\n \n-  if (unlikely (local == NULL || token == NULL))\n+  if (unlikely (local == NULL || *token == NULL))\n     goto error;\n \n   /* token[img-1] is the address of the token in image \"img\".  */\n-  err = MPI_Allgather (&local, sizeof (void*), MPI_BYTE, token,\n+  err = MPI_Allgather (&local, sizeof (void*), MPI_BYTE, *token,\n \t\t       sizeof (void*), MPI_BYTE, MPI_COMM_WORLD);\n+\n   if (unlikely (err))\n     {\n       free (local);\n-      free (token);\n+      free (*token);\n       goto error;\n     }\n \n   if (type == CAF_REGTYPE_COARRAY_STATIC)\n     {\n       caf_static_t *tmp = malloc (sizeof (caf_static_t));\n       tmp->prev  = caf_static_list;\n-      tmp->token = token;\n+      tmp->token = *token;\n       caf_static_list = tmp;\n     }\n \n@@ -192,7 +193,7 @@ _gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n \n \n void\n-_gfortran_caf_deregister (void **token, int *stat, char *errmsg, int errmsg_len)\n+_gfortran_caf_deregister (void ***token, int *stat, char *errmsg, int errmsg_len)\n {\n   if (unlikely (caf_is_finalized))\n     {\n@@ -220,8 +221,8 @@ _gfortran_caf_deregister (void **token, int *stat, char *errmsg, int errmsg_len)\n   if (stat)\n     *stat = 0;\n \n-  free (token[caf_this_image-1]);\n-  free (token);\n+  free ((*token)[caf_this_image-1]);\n+  free (*token);\n }\n \n "}, {"sha": "4242fada3f0e3ac67fac7248100a589f867f1be5", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=5d81ddd07fd38a9f20ca9e53fbe1348fa408ec04", "patch": "@@ -1,5 +1,5 @@\n /* Single-image implementation of GNU Fortran Coarray Library\n-   Copyright (C) 2011\n+   Copyright (C) 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Tobias Burnus <burnus@net-b.de>\n \n@@ -81,14 +81,14 @@ _gfortran_caf_finalize (void)\n \n \n void *\n-_gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n+_gfortran_caf_register (ptrdiff_t size, caf_register_t type, void ***token,\n \t\t\tint *stat, char *errmsg, int errmsg_len)\n {\n   void *local;\n \n   local = malloc (size);\n-  token = malloc (sizeof (void*) * 1);\n-  token[0] = local;\n+  *token = malloc (sizeof (void*) * 1);\n+  (*token)[0] = local;\n \n   if (unlikely (local == NULL || token == NULL))\n     {\n@@ -117,20 +117,20 @@ _gfortran_caf_register (ptrdiff_t size, caf_register_t type, void **token,\n     {\n       caf_static_t *tmp = malloc (sizeof (caf_static_t));\n       tmp->prev  = caf_static_list;\n-      tmp->token = token;\n+      tmp->token = *token;\n       caf_static_list = tmp;\n     }\n   return local;\n }\n \n \n void\n-_gfortran_caf_deregister (void **token, int *stat,\n+_gfortran_caf_deregister (void ***token, int *stat,\n \t\t\t  char *errmsg __attribute__ ((unused)),\n \t\t\t  int errmsg_len __attribute__ ((unused)))\n {\n+  free ((*token)[0]);\n   free (*token);\n-  free (token);\n \n   if (stat)\n     *stat = 0;"}]}