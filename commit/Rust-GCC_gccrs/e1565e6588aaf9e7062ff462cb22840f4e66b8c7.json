{"sha": "e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1NjVlNjU4OGFhZjllNzA2MmZmNDYyY2IyMjg0MGY0ZTY2YjhjNw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2000-01-04T20:09:19Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2000-01-04T20:09:19Z"}, "message": "expmed.c (SLOW_UNALIGNED_ACCESS): Add mode and align parameters to default definition.\n\n\t* expmed.c (SLOW_UNALIGNED_ACCESS): Add mode and align parameters\n\tto default definition.\n\t(store_bit_field): Call SLOW_UNALIGNED_ACCESS with mode and alignment.\n\t(store_fixed_bit_field): Call macro with word_mode and alignment.\n\t(extract_bit_field): Call macro with relevant mode and alignment.\n\t* expr.c (SLOW_UNALIGNED_ACCESS): Add mode and align parameters\n\tto default definition.\n\t(move_by_pieces): Call SLOW_UNALIGNED_ACCESS with word_mode\n\tand alignment.\n\t(move_by_pieces_ninsns): Likewise.\n\t(clear_by_pieces): Likewise.\n\t(emit_push_insn): Likewise.\n\t(store_field): Call macro with relevant mode and alignment.\n\t(expand_expr): Likewise.\n\t(expand_expr_unaligned): Likewise.\n\n\t* rs6000.h (HANDLE_PRAGMA_PACK): Define.\n\t(SLOW_UNALIGNED_ACCESS): Define.\n\t(CASE_VECTOR_MODE): Always use 32-bit offsets.\n\t(ASM_FILE_END): Generate 64-bit symbol in 64-bit mode.\n\t(EXTRA_SECTOIN_FUNCTIONS): Indent .csect pseudo-op.\n\t(toc_section): Likewise and .toc pseudo-op.\n\t(ASM_DECLARE_FUNCTION): Likewise.  Align text more strictly in\n\t64-bit mode.\n\t(TEXT_SECTION_ASM_OP): Likewise.\n\t(ASM_OUTPUT_ADD_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Always use\n\t32-bit offsets.\n\n\t* a29k.h (SLOW_UNALIGNED_ACCESS): Add MODE and ALIGN parameters.\n\t* alpha.h (SLOW_UNALIGNED_ACCESS): Likewise.\n\t* arm/thumb.h (SLOW_UNALIGNED_ACCESS): Likewise.\n\t* gmicro.h (SLOW_UNALIGNED_ACCESS): Likewise.\n\t* fr30.h (SLOW_UNALIGNED_ACCESS): Likewise.\n\nFrom-SVN: r31211", "tree": {"sha": "8bb48a44401bc6bcd038457e6237820e598dfc94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb48a44401bc6bcd038457e6237820e598dfc94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/comments", "author": null, "committer": null, "parents": [{"sha": "399b9016a73cf485b8f1863ae21e5cf06e6f6273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399b9016a73cf485b8f1863ae21e5cf06e6f6273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/399b9016a73cf485b8f1863ae21e5cf06e6f6273"}], "stats": {"total": 161, "additions": 107, "deletions": 54}, "files": [{"sha": "606af6e9ed5a857fa4247ea66adacf6db050a848", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,3 +1,39 @@\n+2000-01-04  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* expmed.c (SLOW_UNALIGNED_ACCESS): Add mode and align parameters\n+\tto default definition.\n+\t(store_bit_field): Call SLOW_UNALIGNED_ACCESS with mode and alignment.\n+\t(store_fixed_bit_field): Call macro with word_mode and alignment.\n+\t(extract_bit_field): Call macro with relevant mode and alignment.\n+\t* expr.c (SLOW_UNALIGNED_ACCESS): Add mode and align parameters\n+\tto default definition.\n+\t(move_by_pieces): Call SLOW_UNALIGNED_ACCESS with word_mode\n+\tand alignment.\n+\t(move_by_pieces_ninsns): Likewise.\n+\t(clear_by_pieces): Likewise.\n+\t(emit_push_insn): Likewise.\n+\t(store_field): Call macro with relevant mode and alignment.\n+\t(expand_expr): Likewise.\n+\t(expand_expr_unaligned): Likewise.\n+\n+\t* rs6000.h (HANDLE_PRAGMA_PACK): Define.\n+\t(SLOW_UNALIGNED_ACCESS): Define.\n+\t(CASE_VECTOR_MODE): Always use 32-bit offsets.\n+\t(ASM_FILE_END): Generate 64-bit symbol in 64-bit mode.\n+\t(EXTRA_SECTOIN_FUNCTIONS): Indent .csect pseudo-op.\n+\t(toc_section): Likewise and .toc pseudo-op.\n+\t(ASM_DECLARE_FUNCTION): Likewise.  Align text more strictly in\n+\t64-bit mode.\n+\t(TEXT_SECTION_ASM_OP): Likewise.\n+\t(ASM_OUTPUT_ADD_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT): Always use\n+\t32-bit offsets.\n+\n+\t* a29k.h (SLOW_UNALIGNED_ACCESS): Add MODE and ALIGN parameters.\n+\t* alpha.h (SLOW_UNALIGNED_ACCESS): Likewise.\n+\t* arm/thumb.h (SLOW_UNALIGNED_ACCESS): Likewise.\n+\t* gmicro.h (SLOW_UNALIGNED_ACCESS): Likewise.\n+\t* fr30.h (SLOW_UNALIGNED_ACCESS): Likewise.\n+\n Tue Jan  4 11:44:13 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* regclass.c: Revert my Jan 4 change to loop cost computation."}, {"sha": "3df5d3292c20ef3fac78b7e65893e326b978cb78", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for AMD Am29000 CPU.\n-   Copyright (C) 1988, 90-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 90-98, 2000 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n This file is part of GNU CC.\n@@ -219,7 +219,7 @@ extern int target_flags;\n /* Set this non-zero if unaligned move instructions are extremely slow.\n \n    On the 29k, they trap.  */\n-#define SLOW_UNALIGNED_ACCESS 1\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n \f\n /* Standard register usage.  */\n "}, {"sha": "09f897443f9338e4ceb90fa7d570c991fdd00b59", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for DEC Alpha.\n-   Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-99, 2000 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -537,7 +537,7 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n \n    On the Alpha, they trap.  */\n \n-#define SLOW_UNALIGNED_ACCESS 1\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n \f\n /* Standard register usage.  */\n "}, {"sha": "d9d4ce0d432dffa31bda91771c0e76eb2ddb8983", "filename": "gcc/config/arm/thumb.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for ARM/Thumb.\n-   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n    The basis of this contribution was generated by\n    \t\tRichard Earnshaw, Advanced RISC Machines Ltd\n \n@@ -1082,7 +1082,7 @@ extern struct rtx_def * legitimize_pic_address ();\n \n #define SLOW_BYTE_ACCESS 0\n \n-#define SLOW_UNALIGNED_ACCESS 1\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n \n #define NO_FUNCTION_CSE 1\n "}, {"sha": "625deaffc4d272638a3b4a9bc965dd3ac05e1c47", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 95-98, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Collison (collison@world.std.com).\n \n This file is part of GNU CC.\n@@ -1571,7 +1571,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n \n /* Define this macro if unaligned accesses have a cost many times greater than\n    aligned accesses, for example if they are emulated in a trap handler */\n-/* define SLOW_UNALIGNED_ACCESS */\n+/* define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) */\n \n /* Define this macro to inhibit strength reduction of memory addresses */\n /* #define DONT_REDUCE_ADDR */"}, {"sha": "dfe33efad7508ac73283031ed3a8588865e19a9f", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,7 +1,7 @@\n /*{{{  Comment */ \n \n /* Definitions of FR30 target. \n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n This file is part of GNU CC.\n@@ -2608,7 +2608,7 @@ do\t\t\t\t\t\t\t\t\t\t\\\n    a memory access.\n \n    If the value of this macro is always zero, it need not be defined.  */\n-/* #define SLOW_UNALIGNED_ACCESS */\n+/* #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) */\n \n /* Define this macro to inhibit strength reduction of memory addresses.  (On\n    some machines, such strength reduction seems to do harm rather than good.)  */"}, {"sha": "2a6236a3eaacf072cd28dad0045ccd47927bafa9", "filename": "gcc/config/gmicro/gmicro.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Gmicro (TRON) version.\n-   Copyright (C) 1987, 88, 89, 95-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 95-99, 2000 Free Software Foundation, Inc.\n    Contributed by Masanobu Yuhara, Fujitsu Laboratories LTD.\n    (yuhara@flab.fujitsu.co.jp)\n \n@@ -168,7 +168,7 @@ extern int target_flags;\n    Unaligned data is allowed on Gmicro, though the access is slow. */\n \n #define STRICT_ALIGNMENT 1\n-#define SLOW_UNALIGNED_ACCESS 1\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\"}, {"sha": "2bde60e1788cffa5f6e1e39da1fec456a4d068e2", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -2079,7 +2079,7 @@ while (0)\n \n    If the value of this macro is always zero, it need not be defined.  */\n \n-/* #define SLOW_UNALIGNED_ACCESS 0 */\n+/* #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 0 */\n \n /* Define this macro to inhibit strength reduction of memory\n    addresses.  (On some machines, such strength reduction seems to do"}, {"sha": "d36bfc22152dc742c7f2849b2913f3bd7470f518", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for IBM RS/6000.\n-   Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93-99, 2000 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -508,7 +508,6 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* Define this to change the optimizations performed by default.  */\n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE) optimization_options(LEVEL,SIZE)\n \n-\n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n \f\n@@ -636,6 +635,9 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64\n \n+/* Handle #pragma pack.  */\n+#define HANDLE_PRAGMA_PACK 1\n+\n /* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n #define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n   (TYPE_MODE (TREE_CODE (TREE_TYPE (FIELD)) == ARRAY_TYPE \\\n@@ -677,6 +679,14 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* Non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n+\n+/* Define this macro to be the value 1 if unaligned accesses have a cost\n+   many times greater than aligned accesses, for example if they are\n+   emulated in a trap handler.  */\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN)\t\t\t\\\n+   ((((MODE) == SFmode || (MODE) == DFmode || (MODE) == DImode)\t\\\n+     && (ALIGN) < 4) ? 1 : 0)\n+\n \f\n /* Standard register usage.  */\n \n@@ -861,8 +871,8 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n \n    On the RS/6000, bump this up a bit.  */\n \n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\\\n-  ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+#define MEMORY_MOVE_COST(MODE, CLASS, IN)\t\\\n+  ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n     && (rs6000_cpu == PROCESSOR_RIOS1 || rs6000_cpu == PROCESSOR_PPC601) \\\n     ? 3 : 2) \\\n    + 4)\n@@ -882,7 +892,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    output-dependencies.  In fact, output dependencies on the CR do have\n    a cost, but it is probably not worthwhile to track it.  */\n \n-#define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n+#define ADJUST_COST(INSN, LINK, DEP_INSN, COST)\t\t\t\t\\\n   (COST) = rs6000_adjust_cost (INSN,LINK,DEP_INSN,COST)\n \n /* A C statement (sans semicolon) to update the integer scheduling priority\n@@ -2176,7 +2186,7 @@ do {                                                                    \\\n \n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE (TARGET_32BIT ? SImode : DImode)\n+#define CASE_VECTOR_MODE SImode\n \n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n@@ -2524,7 +2534,8 @@ extern int rs6000_trunc_used;\n   text_section ();\t\t\t\t\t\t\\\n   fputs (\"_section_.text:\\n\", FILE);\t\t\t\t\\\n   data_section ();\t\t\t\t\t\t\\\n-  fputs (\"\\t.long _section_.text\\n\", FILE);\t\t\t\\\n+  fputs (TARGET_32BIT\t\t\t\t\t\t\\\n+\t ? \"\\t.long _section_.text\\n\" : \"\\t.llong _section_.text\\n\", FILE); \\\n }\n \n /* We define this to prevent the name mangler from putting dollar signs into\n@@ -2567,10 +2578,10 @@ extern int rs6000_trunc_used;\n    that we can branch to this function without emitting a no-op after the\n    call.  Do not set this flag if the function is weakly defined. */\n \n-#define ENCODE_SECTION_INFO(DECL)  \\\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\\\n   if (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n       && (TREE_ASM_WRITTEN (DECL) || ! TREE_PUBLIC (DECL)) \\\n-      && !DECL_WEAK (DECL)) \\\n+      && ! DECL_WEAK (DECL))\t\t\t\t\\\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n \n /* Indicate that jump tables go in the text section.  */\n@@ -2587,7 +2598,7 @@ read_only_data_section ()\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (in_section != read_only_data)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \".csect %s[RO],3\\n\",\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RO],3\\n\",\t\\\n \t       xcoff_read_only_section_name);\t\t\\\n       in_section = read_only_data;\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n@@ -2598,7 +2609,7 @@ private_data_section ()\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (in_section != private_data)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \".csect %s[RW],3\\n\",\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RW],3\\n\",\t\\\n \t       xcoff_private_data_section_name);\t\\\n       in_section = private_data;\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n@@ -2609,7 +2620,7 @@ read_only_private_data_section ()\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   if (in_section != read_only_private_data)\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \".csect %s[RO],3\\n\",\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RO],3\\n\",\t\\\n \t       xcoff_private_data_section_name);\t\\\n       in_section = read_only_private_data;\t\t\\\n     }\t\t\t\t\t\t\t\\\n@@ -2625,19 +2636,19 @@ toc_section ()\t\t\t\t\t\t\\\n \t in each file.  */\t\t\t\t\t\t \\\n       if (! toc_initialized)\t\t\t\t\\\n \t{\t\t\t\t\t\t\\\n-\t  fputs (\".toc\\nLCTOC..0:\\n\", asm_out_file);\t\\\n+\t  fputs (\"\\t.toc\\nLCTOC..0:\\n\", asm_out_file);\t\\\n \t  fputs (\"\\t.tc toc_table[TC],toc_table[RW]\\n\", asm_out_file); \\\n \t  toc_initialized = 1;\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n       if (in_section != toc)\t\t\t\t\\\n-\tfprintf (asm_out_file, \".csect toc_table[RW]%s\\n\",\t\\\n+\tfprintf (asm_out_file, \"\\t.csect toc_table[RW]%s\\n\",\t\\\n \t\t (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n     }\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       if (in_section != toc)\t\t\t\t\\\n-        fputs (\".toc\\n\", asm_out_file);\t\t\t\\\n+        fputs (\"\\t.toc\\n\", asm_out_file);\t\t\\\n     }\t\t\t\t\t\t\t\\\n   in_section = toc;\t\t\t\t\t\\\n }\n@@ -2651,9 +2662,10 @@ extern int toc_initialized;\n \n    The csect for the function will have already been created by the\n    `text_section' call previously done.  We do have to go back to that\n-   csect, however.  */\n+   csect, however.\n \n-/* ??? What do the 16 and 044 in the .function line really mean?  */\n+   The third and fourth parameters to the .function pseudo-op (16 and 044)\n+   are placeholders which no longer have any use.  */\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n { if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n@@ -2668,15 +2680,16 @@ extern int toc_initialized;\n       RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n       putc ('\\n', FILE);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  fputs (\".csect \", FILE);\t\t\t\t\t\\\n+  fputs (\"\\t.csect \", FILE);\t\t\t\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (TARGET_32BIT ? \"[DS]\\n\" : \"[DS],3\\n\", FILE);\t\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n   fputs (TARGET_32BIT ? \"\\t.long .\" : \"\\t.llong .\", FILE);\t\\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (\", TOC[tc0], 0\\n\", FILE);\t\t\t\t\\\n-  fputs (\".csect .text[PR]\\n.\", FILE);\t\t\t\t\\\n+  fputs (TARGET_32BIT\t\t\t\t\t\t\\\n+\t ? \"\\t.csect .text[PR]\\n.\" : \"\\t.csect .text[PR],3\\n.\", FILE); \\\n   RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n   fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n   if (write_symbols == XCOFF_DEBUG)\t\t\t\t\\\n@@ -2855,7 +2868,7 @@ do {\t\t\t\t\t\t\\\n    Text section for 64-bit target may contain 64-bit address jump table.  */\n \n #define TEXT_SECTION_ASM_OP (TARGET_32BIT \\\n-\t\t\t     ? \".csect .text[PR]\" : \".csect .text[PR],3\")\n+\t\t\t     ? \"\\t.csect .text[PR]\" : \"\\t.csect .text[PR],3\")\n \n /* Output before writable data.\n    Align entire section to BIGGEST_ALIGNMENT.  */\n@@ -3120,17 +3133,17 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n   do { char buf[100];\t\t\t\t\t\\\n-       fputs (TARGET_32BIT ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n+       fputs (\"\\t.long \", FILE);\t\t\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n        putc ('\\n', FILE);\t\t\t\t\\\n      } while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   do { char buf[100];\t\t\t\t\t\\\n-       fputs (TARGET_32BIT ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n+       fputs (\"\\t.long \", FILE);\t\t\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\\n        assemble_name (FILE, buf);\t\t\t\\\n        putc ('-', FILE);\t\t\t\t\\\n@@ -3323,7 +3336,7 @@ extern struct rtx_def *function_arg ();\n extern int function_arg_partial_nregs ();\n extern int function_arg_pass_by_reference ();\n extern void setup_incoming_varargs ();\n-extern union tree_node *rs6000_va_list ();\n+extern union tree_node *rs6000_build_va_list ();\n extern void rs6000_va_start ();\n extern struct rtx_def *rs6000_va_arg ();\n extern struct rtx_def *rs6000_stack_temp ();"}, {"sha": "2897d77c97a56883dcbaad6a06a738e8989610c6", "filename": "gcc/expmed.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -54,7 +54,7 @@ static void do_cmp_and_jump\t\tPROTO((rtx, rtx, enum rtx_code,\n static int sdiv_pow2_cheap, smod_pow2_cheap;\n \n #ifndef SLOW_UNALIGNED_ACCESS\n-#define SLOW_UNALIGNED_ACCESS STRICT_ALIGNMENT\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n #endif\n \n /* For compilers that support multiple targets with different word sizes,\n@@ -295,7 +295,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n      BITPOS is 0 in a REG bigger than a word.  */\n   if (GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n       && (GET_CODE (op0) != MEM\n-\t  || ! SLOW_UNALIGNED_ACCESS\n+\t  || ! SLOW_UNALIGNED_ACCESS (fieldmode, align)\n \t  || (offset * BITS_PER_UNIT % bitsize == 0\n \t      && align % GET_MODE_SIZE (fieldmode) == 0))\n       && bitpos == 0 && bitsize == GET_MODE_BITSIZE (fieldmode))\n@@ -509,7 +509,8 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t    bestmode = GET_MODE (op0);\n \n \t  if (bestmode == VOIDmode\n-\t      || (SLOW_UNALIGNED_ACCESS && GET_MODE_SIZE (bestmode) > align))\n+\t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n+\t\t  && GET_MODE_SIZE (bestmode) > align))\n \t    goto insv_loses;\n \n \t  /* Adjust address to point to the containing unit of that mode.  */\n@@ -632,7 +633,7 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n   int all_zero = 0;\n   int all_one = 0;\n \n-  if (! SLOW_UNALIGNED_ACCESS)\n+  if (! SLOW_UNALIGNED_ACCESS (word_mode, struct_align))\n     struct_align = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n     \n   /* There is a case not handled here:\n@@ -1052,7 +1053,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n \t\t\t\t  GET_MODE_BITSIZE (GET_MODE (op0))))\n        || (GET_CODE (op0) == MEM\n-\t   && (! SLOW_UNALIGNED_ACCESS\n+\t   && (! SLOW_UNALIGNED_ACCESS (mode, align)\n \t       || (offset * BITS_PER_UNIT % bitsize == 0\n \t\t   && align * BITS_PER_UNIT % bitsize == 0))))\n       && ((bitsize >= BITS_PER_WORD && bitsize == GET_MODE_BITSIZE (mode)\n@@ -1253,7 +1254,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t    bestmode = GET_MODE (xop0);\n \n \t\t  if (bestmode == VOIDmode\n-\t\t      || (SLOW_UNALIGNED_ACCESS && GET_MODE_SIZE (bestmode) > align))\n+\t\t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n+\t\t\t  && GET_MODE_SIZE (bestmode) > align))\n \t\t    goto extzv_loses;\n \n \t\t  /* Compute offset as multiple of this unit,\n@@ -1390,7 +1392,8 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t    bestmode = GET_MODE (xop0);\n \n \t\t  if (bestmode == VOIDmode\n-\t\t      || (SLOW_UNALIGNED_ACCESS && GET_MODE_SIZE (bestmode) > align))\n+\t\t      || (SLOW_UNALIGNED_ACCESS (bestmode, align)\n+\t\t\t  && GET_MODE_SIZE (bestmode) > align))\n \t\t    goto extv_loses;\n \n \t\t  /* Compute offset as multiple of this unit,"}, {"sha": "54a90972cc429c67bd3c4064abb77b24098e76a6", "filename": "gcc/expr.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1565e6588aaf9e7062ff462cb22840f4e66b8c7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e1565e6588aaf9e7062ff462cb22840f4e66b8c7", "patch": "@@ -198,7 +198,7 @@ enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n /* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow.  */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n-#define SLOW_UNALIGNED_ACCESS STRICT_ALIGNMENT\n+#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n #endif\n \f\n /* This is run once per compilation to set up which modes can be used\n@@ -1435,7 +1435,7 @@ move_by_pieces (to, from, len, align)\n \tdata.to_addr = copy_addr_to_reg (to_addr);\n     }\n \n-  if (! SLOW_UNALIGNED_ACCESS\n+  if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n     align = MOVE_MAX;\n \n@@ -1477,7 +1477,7 @@ move_by_pieces_ninsns (l, align)\n   register int n_insns = 0;\n   int max_size = MOVE_MAX + 1;\n \n-  if (! SLOW_UNALIGNED_ACCESS\n+  if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n     align = MOVE_MAX;\n \n@@ -2283,7 +2283,7 @@ clear_by_pieces (to, len, align)\n \tdata.to_addr = copy_addr_to_reg (to_addr);\n     }\n \n-  if (! SLOW_UNALIGNED_ACCESS\n+  if (! SLOW_UNALIGNED_ACCESS (word_mode, align)\n       || align > MOVE_MAX || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n     align = MOVE_MAX;\n \n@@ -2972,7 +2972,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  /* Here we avoid the case of a structure whose weak alignment\n \t     forces many pushes of a small amount of data,\n \t     and such small pushes do rounding that causes trouble.  */\n-\t  && ((! SLOW_UNALIGNED_ACCESS)\n+\t  && ((! SLOW_UNALIGNED_ACCESS (word_mode, align))\n \t      || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT\n \t      || PUSH_ROUNDING (align) == align)\n \t  && PUSH_ROUNDING (INTVAL (size)) == INTVAL (size))\n@@ -4770,10 +4770,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n       || GET_CODE (target) == SUBREG\n       /* If the field isn't aligned enough to store as an ordinary memref,\n \t store it as a bit field.  */\n-      || (mode != BLKmode && SLOW_UNALIGNED_ACCESS\n+      || (mode != BLKmode && SLOW_UNALIGNED_ACCESS (mode, align)\n \t  && (align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode)\n \t      || bitpos % GET_MODE_ALIGNMENT (mode)))\n-      || (mode == BLKmode && SLOW_UNALIGNED_ACCESS\n+      || (mode == BLKmode && SLOW_UNALIGNED_ACCESS (mode, align)\n \t  && (TYPE_ALIGN (TREE_TYPE (exp)) > align * BITS_PER_UNIT\n \t      || bitpos % TYPE_ALIGN (TREE_TYPE (exp)) != 0))\n       /* If the RHS and field are a constant size and the size of the\n@@ -6749,14 +6749,15 @@ expand_expr (exp, target, tmode, modifier)\n \t\t     && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n \t\t    /* If the field isn't aligned enough to fetch as a memref,\n \t\t       fetch it as a bit field.  */\n-\t\t    || (mode1 != BLKmode && SLOW_UNALIGNED_ACCESS\n+\t\t    || (mode1 != BLKmode\n+\t\t\t&& SLOW_UNALIGNED_ACCESS (mode1, alignment)\n \t\t\t&& ((TYPE_ALIGN (TREE_TYPE (tem))\n \t\t\t     < (unsigned int) GET_MODE_ALIGNMENT (mode))\n \t\t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0)))))\n \t    || (modifier != EXPAND_CONST_ADDRESS\n \t\t&& modifier != EXPAND_INITIALIZER\n \t\t&& mode == BLKmode\n-\t\t\t&& SLOW_UNALIGNED_ACCESS\n+\t\t&& SLOW_UNALIGNED_ACCESS (mode, alignment)\n \t\t&& (TYPE_ALIGN (type) > alignment * BITS_PER_UNIT\n \t\t    || bitpos % TYPE_ALIGN (type) != 0)))\n \t  {\n@@ -8689,7 +8690,7 @@ expand_expr_unaligned (exp, palign)\n \t   EXPAND_INITIALIZER), then we must not copy to a temporary.  */\n \tif (mode1 == VOIDmode\n \t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n-\t    || (SLOW_UNALIGNED_ACCESS\n+\t    || (SLOW_UNALIGNED_ACCESS (mode1, alignment)\n \t\t&& (TYPE_ALIGN (type) > alignment * BITS_PER_UNIT\n \t\t    || bitpos % TYPE_ALIGN (type) != 0)))\n \t  {"}]}