{"sha": "783dc7392a04bde7bbf6806d55484f3ab37b62db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgzZGM3MzkyYTA0YmRlN2JiZjY4MDZkNTU0ODRmM2FiMzdiNjJkYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-13T11:45:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-13T11:45:56Z"}, "message": "Rename CLASSTYPE_METHOD_VEC to CLASSTYPE_MEMBER_VEC.\n\n\t* cp-tree.h (struct lang_type): Rename methods to members.\n\t(CLASSTYPE_METHOD_VEC): Rename to ...\n\t(CLASSTYPE_MEMBER_VEC): ... this.\n\t* name-lookup.h (get_method_slot): Rename to ...\n\t(get_member_slot): ... this.\n\t(resort_type_method_vec): Rename to ...\n\t(resort_type_member_vec): ... this.\n\t* class.c (add_method, warn_hidden): Adjust.\n\t* search.c (dfs_locate_field_accessor_pre): Adjust.\n\t* name-lookup.c (method_vec_binary_search): Rename to ...\n\t(member_vec_binary_search): ... this and adjust.\n\t(method_vec_linear_search): Rename to ...\n\t(member_vec_linear_search): ... this and adjust.\n\t(fields_linear_search, get_class_binding_direct): Adjust.\n\t(get_method_slot): Rename to ...\n\t(get_member_slot): ... this and adjust.\n\t(method_name_slot): Rename to ...\n\t(member_name_slot): ... this and adjust.\n\t(resort_type_method_vec): Rename to ...\n\t(resort_type_member_vec): ... this and adjust.\n\t(method_vec_append_class_fields): Rename to ...\n\t(member_vec_append_class_fields): ... this and adjust.\n\t(method_vec_append_enum_values): Rename to ...\n\t(member_vec_append_enum_values): ... this and adjust.\n\t(method_vec_dedup): Rename to ...\n\t(member_vec_dedup): ... this and adjust.\n\t(set_class_bindings, insert_late_enum_def_bindings): Adjust.\n\nFrom-SVN: r252078", "tree": {"sha": "a07513d82a503f550f7d9339094e7fe31d8d15d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a07513d82a503f550f7d9339094e7fe31d8d15d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/783dc7392a04bde7bbf6806d55484f3ab37b62db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783dc7392a04bde7bbf6806d55484f3ab37b62db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/783dc7392a04bde7bbf6806d55484f3ab37b62db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783dc7392a04bde7bbf6806d55484f3ab37b62db/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "491cefb7ea5dc035b2ee5b706aa21efcd49d76c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491cefb7ea5dc035b2ee5b706aa21efcd49d76c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/491cefb7ea5dc035b2ee5b706aa21efcd49d76c3"}], "stats": {"total": 233, "additions": 128, "deletions": 105}, "files": [{"sha": "1318c82ea1b3f68839e4b62ac07e76a6fe3afa72", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=783dc7392a04bde7bbf6806d55484f3ab37b62db", "patch": "@@ -1,3 +1,34 @@\n+2017-09-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRename CLASSTYPE_METHOD_VEC to CLASSTYPE_MEMBER_VEC.\n+\t* cp-tree.h (struct lang_type): Rename methods to members.\n+\t(CLASSTYPE_METHOD_VEC): Rename to ...\n+\t(CLASSTYPE_MEMBER_VEC): ... this.\n+\t* name-lookup.h (get_method_slot): Rename to ...\n+\t(get_member_slot): ... this.\n+\t(resort_type_method_vec): Rename to ...\n+\t(resort_type_member_vec): ... this.\n+\t* class.c (add_method, warn_hidden): Adjust.\n+\t* search.c (dfs_locate_field_accessor_pre): Adjust.\n+\t* name-lookup.c (method_vec_binary_search): Rename to ...\n+\t(member_vec_binary_search): ... this and adjust.\n+\t(method_vec_linear_search): Rename to ...\n+\t(member_vec_linear_search): ... this and adjust.\n+\t(fields_linear_search, get_class_binding_direct): Adjust.\n+\t(get_method_slot): Rename to ...\n+\t(get_member_slot): ... this and adjust.\n+\t(method_name_slot): Rename to ...\n+\t(member_name_slot): ... this and adjust.\n+\t(resort_type_method_vec): Rename to ...\n+\t(resort_type_member_vec): ... this and adjust.\n+\t(method_vec_append_class_fields): Rename to ...\n+\t(member_vec_append_class_fields): ... this and adjust.\n+\t(method_vec_append_enum_values): Rename to ...\n+\t(member_vec_append_enum_values): ... this and adjust.\n+\t(method_vec_dedup): Rename to ...\n+\t(member_vec_dedup): ... this and adjust.\n+\t(set_class_bindings, insert_late_enum_def_bindings): Adjust.\n+\t\n 2017-09-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/70621"}, {"sha": "cd63c21567a8c7f37442971229e504f545793fa1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=783dc7392a04bde7bbf6806d55484f3ab37b62db", "patch": "@@ -1014,7 +1014,7 @@ add_method (tree type, tree method, bool via_using)\n   /* Maintain TYPE_HAS_USER_CONSTRUCTOR, etc.  */\n   grok_special_member_properties (method);\n \n-  tree *slot = get_method_slot (type, DECL_NAME (method));\n+  tree *slot = get_member_slot (type, DECL_NAME (method));\n   tree current_fns = *slot;\n \n   gcc_assert (!DECL_EXTERN_C_P (method));\n@@ -2818,10 +2818,10 @@ check_for_override (tree decl, tree ctype)\n static void\n warn_hidden (tree t)\n {\n-  if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t))\n-    for (unsigned ix = method_vec->length (); ix--;)\n+  if (vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (t))\n+    for (unsigned ix = member_vec->length (); ix--;)\n       {\n-\ttree fns = (*method_vec)[ix];\n+\ttree fns = (*member_vec)[ix];\n \n \tif (!OVL_P (fns))\n \t  continue;\n@@ -4594,7 +4594,7 @@ decl_cloned_function_p (const_tree decl, bool just_testing)\n \n /* Produce declarations for all appropriate clones of FN.  If\n    UPDATE_METHODS is true, the clones are added to the\n-   CLASSTYPE_METHOD_VEC.  */\n+   CLASSTYPE_MEMBER_VEC.  */\n \n void\n clone_function_decl (tree fn, bool update_methods)"}, {"sha": "f4d6f802cbefef019a62dd013c83cf8417fa538d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=783dc7392a04bde7bbf6806d55484f3ab37b62db", "patch": "@@ -2000,7 +2000,7 @@ struct GTY(()) lang_type {\n   tree as_base;\n   vec<tree, va_gc> *pure_virtuals;\n   tree friend_classes;\n-  vec<tree, va_gc> * GTY((reorder (\"resort_type_method_vec\"))) methods;\n+  vec<tree, va_gc> * GTY((reorder (\"resort_type_member_vec\"))) members;\n   tree key_method;\n   tree decl_list;\n   tree befriending_classes;\n@@ -2125,19 +2125,11 @@ struct GTY(()) lang_type {\n    if there is no key function or if this is a class template */\n #define CLASSTYPE_KEY_METHOD(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->key_method)\n \n-/* Vector member functions defined in this class.  Each element is\n-   either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  All\n-   functions with the same name end up in the same slot.  The first\n-   two elements are for constructors, and destructors, respectively.\n-   All template conversion operators to innermost template dependent\n-   types are overloaded on the next slot, if they exist.  Note, the\n-   names for these functions will not all be the same.  The\n-   non-template conversion operators & templated conversions to\n-   non-innermost template types are next, followed by ordinary member\n-   functions.  There may be empty entries at the end of the vector.\n-   The conversion operators are unsorted. The ordinary member\n-   functions are sorted, once the class is complete.  */\n-#define CLASSTYPE_METHOD_VEC(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->methods)\n+/* Vector of members.  During definition, it is unordered and only\n+   member functions are present.  After completion it is sorted and\n+   contains both member functions and non-functions.  STAT_HACK is\n+   involved to preserve oneslot per name invariant.  */\n+#define CLASSTYPE_MEMBER_VEC(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->members)\n \n /* For class templates, this is a TREE_LIST of all member data,\n    functions, types, and friends in the order of declaration."}, {"sha": "d0aaf2b1d16e547442c580732d669290fe91fc7e", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=783dc7392a04bde7bbf6806d55484f3ab37b62db", "patch": "@@ -1113,15 +1113,15 @@ extract_conversion_operator (tree fns, tree type)\n   return convs;\n }\n \n-/* Binary search of (ordered) METHOD_VEC for NAME.  */\n+/* Binary search of (ordered) MEMBER_VEC for NAME.  */\n \n static tree\n-method_vec_binary_search (vec<tree, va_gc> *method_vec, tree name)\n+member_vec_binary_search (vec<tree, va_gc> *member_vec, tree name)\n {\n-  for (unsigned lo = 0, hi = method_vec->length (); lo < hi;)\n+  for (unsigned lo = 0, hi = member_vec->length (); lo < hi;)\n     {\n       unsigned mid = (lo + hi) / 2;\n-      tree binding = (*method_vec)[mid];\n+      tree binding = (*member_vec)[mid];\n       tree binding_name = OVL_NAME (binding);\n \n       if (binding_name > name)\n@@ -1135,17 +1135,17 @@ method_vec_binary_search (vec<tree, va_gc> *method_vec, tree name)\n   return NULL_TREE;\n }\n \n-/* Linear search of (unordered) METHOD_VEC for NAME.  */\n+/* Linear search of (unordered) MEMBER_VEC for NAME.  */\n \n static tree\n-method_vec_linear_search (vec<tree, va_gc> *method_vec, tree name)\n+member_vec_linear_search (vec<tree, va_gc> *member_vec, tree name)\n {\n-  for (int ix = method_vec->length (); ix--;)\n+  for (int ix = member_vec->length (); ix--;)\n     /* We can get a NULL binding during insertion of a new method\n        name, because the identifier_binding machinery performs a\n        lookup.  If we find such a NULL slot, that's the thing we were\n        looking for, so we might as well bail out immediately.  */\n-    if (tree binding = (*method_vec)[ix])\n+    if (tree binding = (*member_vec)[ix])\n       {\n \tif (OVL_NAME (binding) == name)\n \t  return binding;\n@@ -1173,8 +1173,8 @@ fields_linear_search (tree klass, tree name, bool want_type)\n \t  gcc_assert (COMPLETE_TYPE_P (anon));\n \t  tree temp;\n \t  \n-\t  if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (anon))\n-\t    temp = method_vec_linear_search (method_vec, name);\n+\t  if (vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (anon))\n+\t    temp = member_vec_linear_search (member_vec, name);\n \t  else\n \t    temp = fields_linear_search (anon, name, want_type);\n \n@@ -1224,11 +1224,11 @@ get_class_binding_direct (tree klass, tree name, int type_or_fns)\n   bool conv_op = IDENTIFIER_CONV_OP_P (name);\n   tree lookup = conv_op ? conv_op_identifier : name;\n   tree val = NULL_TREE;\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n+  vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n \n-  if (COMPLETE_TYPE_P (klass) && method_vec)\n+  if (COMPLETE_TYPE_P (klass) && member_vec)\n     {\n-      val = method_vec_binary_search (method_vec, lookup);\n+      val = member_vec_binary_search (member_vec, lookup);\n       if (!val)\n \t;\n       else if (type_or_fns > 0)\n@@ -1254,8 +1254,8 @@ get_class_binding_direct (tree klass, tree name, int type_or_fns)\n     }\n   else\n     {\n-      if (method_vec && type_or_fns <= 0)\n-\tval = method_vec_linear_search (method_vec, lookup);\n+      if (member_vec && type_or_fns <= 0)\n+\tval = member_vec_linear_search (member_vec, lookup);\n \n       if (type_or_fns < 0)\n \t/* Don't bother looking for field.  We don't want it.  */;\n@@ -1325,33 +1325,33 @@ get_class_binding (tree klass, tree name, int type_or_fns)\n    conv_op marker handling.  */\n \n tree *\n-get_method_slot (tree klass, tree name)\n+get_member_slot (tree klass, tree name)\n {\n   bool complete_p = COMPLETE_TYPE_P (klass);\n   \n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n-  if (!method_vec)\n+  vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n+  if (!member_vec)\n     {\n-      vec_alloc (method_vec, 8);\n-      CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+      vec_alloc (member_vec, 8);\n+      CLASSTYPE_MEMBER_VEC (klass) = member_vec;\n       if (complete_p)\n \t{\n-\t  /* If the class is complete but had no method_vec, we need\n+\t  /* If the class is complete but had no member_vec, we need\n \t     to add the TYPE_FIELDS into it.  We're also most likely\n \t     to be adding ctors & dtors, so ask for 6 spare slots (the\n \t     abstract cdtors and their clones).  */\n \t  set_class_bindings (klass, 6);\n-\t  method_vec = CLASSTYPE_METHOD_VEC (klass);\n+\t  member_vec = CLASSTYPE_MEMBER_VEC (klass);\n \t}\n     }\n \n   if (IDENTIFIER_CONV_OP_P (name))\n     name = conv_op_identifier;\n \n-  unsigned ix, length = method_vec->length ();\n+  unsigned ix, length = member_vec->length ();\n   for (ix = 0; ix < length; ix++)\n     {\n-      tree *slot = &(*method_vec)[ix];\n+      tree *slot = &(*member_vec)[ix];\n       tree fn_name = OVL_NAME (*slot);\n \n       if (fn_name == name)\n@@ -1381,17 +1381,17 @@ get_method_slot (tree klass, tree name)\n     {\n       /* Do exact allocation when complete, as we don't expect to add\n \t many.  */\n-      vec_safe_reserve_exact (method_vec, 1);\n-      method_vec->quick_insert (ix, NULL_TREE);\n+      vec_safe_reserve_exact (member_vec, 1);\n+      member_vec->quick_insert (ix, NULL_TREE);\n     }\n   else\n     {\n       gcc_checking_assert (ix == length);\n-      vec_safe_push (method_vec, NULL_TREE);\n+      vec_safe_push (member_vec, NULL_TREE);\n     }\n-  CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+  CLASSTYPE_MEMBER_VEC (klass) = member_vec;\n \n-  tree *slot = &(*method_vec)[ix];\n+  tree *slot = &(*member_vec)[ix];\n   if (name == conv_op_identifier)\n     {\n       /* Install the marker prefix.  */\n@@ -1402,13 +1402,13 @@ get_method_slot (tree klass, tree name)\n   return slot;\n }\n \n-/* Comparison function to compare two TYPE_METHOD_VEC entries by\n-   name.  Because we can have duplicates during insertion of\n-   TYPE_FIELDS, we do extra checking so deduping doesn't have to deal\n-   with so many cases.  */\n+/* Comparison function to compare two MEMBER_VEC entries by name.\n+   Because we can have duplicates during insertion of TYPE_FIELDS, we\n+   do extra checking so deduping doesn't have to deal with so many\n+   cases.  */\n \n static int\n-method_name_cmp (const void *a_p, const void *b_p)\n+member_name_cmp (const void *a_p, const void *b_p)\n {\n   tree a = *(const tree *)a_p;\n   tree b = *(const tree *)b_p;\n@@ -1464,12 +1464,12 @@ static struct {\n   void *cookie;\n } resort_data;\n \n-/* This routine compares two fields like method_name_cmp but using the\n+/* This routine compares two fields like member_name_cmp but using the\n    pointer operator in resort_field_decl_data.  We don't have to deal\n    with duplicates here.  */\n \n static int\n-resort_method_name_cmp (const void *a_p, const void *b_p)\n+resort_member_name_cmp (const void *a_p, const void *b_p)\n {\n   tree a = *(const tree *)a_p;\n   tree b = *(const tree *)b_p;\n@@ -1484,18 +1484,18 @@ resort_method_name_cmp (const void *a_p, const void *b_p)\n   return name_a < name_b ? -1 : +1;\n }\n \n-/* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n+/* Resort CLASSTYPE_MEMBER_VEC because pointers have been reordered.  */\n \n void\n-resort_type_method_vec (void *obj, void */*orig_obj*/,\n+resort_type_member_vec (void *obj, void */*orig_obj*/,\n \t\t\tgt_pointer_operator new_value, void* cookie)\n {\n-  if (vec<tree, va_gc> *method_vec = (vec<tree, va_gc> *) obj)\n+  if (vec<tree, va_gc> *member_vec = (vec<tree, va_gc> *) obj)\n     {\n       resort_data.new_value = new_value;\n       resort_data.cookie = cookie;\n-      qsort (method_vec->address (), method_vec->length (),\n-\t     sizeof (tree), resort_method_name_cmp);\n+      qsort (member_vec->address (), member_vec->length (),\n+\t     sizeof (tree), resort_member_name_cmp);\n     }\n }\n \n@@ -1519,41 +1519,41 @@ count_class_fields (tree klass)\n   return n_fields;\n }\n \n-/* Append all the nonfunction members fields of KLASS to METHOD_VEC.\n-   Recurse for anonymous members.  METHOD_VEC must have space.  */\n+/* Append all the nonfunction members fields of KLASS to MEMBER_VEC.\n+   Recurse for anonymous members.  MEMBER_VEC must have space.  */\n \n static void\n-method_vec_append_class_fields (vec<tree, va_gc> *method_vec, tree klass)\n+member_vec_append_class_fields (vec<tree, va_gc> *member_vec, tree klass)\n {\n   for (tree fields = TYPE_FIELDS (klass); fields; fields = DECL_CHAIN (fields))\n     if (DECL_DECLARES_FUNCTION_P (fields))\n       /* Functions are handled separately.  */;\n     else if (TREE_CODE (fields) == FIELD_DECL\n \t     && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n-      method_vec_append_class_fields (method_vec, TREE_TYPE (fields));\n+      member_vec_append_class_fields (member_vec, TREE_TYPE (fields));\n     else if (DECL_NAME (fields))\n       {\n \ttree field = fields;\n \t/* Mark a conv-op USING_DECL with the conv-op-marker.  */\n \tif (TREE_CODE (field) == USING_DECL\n \t    && IDENTIFIER_CONV_OP_P (DECL_NAME (field)))\n \t  field = ovl_make (conv_op_marker, field);\n-\tmethod_vec->quick_push (field);\n+\tmember_vec->quick_push (field);\n       }\n }\n \n-/* Append all of the enum values of ENUMTYPE to METHOD_VEC.\n-   METHOD_VEC must have space.  */\n+/* Append all of the enum values of ENUMTYPE to MEMBER_VEC.\n+   MEMBER_VEC must have space.  */\n \n static void\n-method_vec_append_enum_values (vec<tree, va_gc> *method_vec, tree enumtype)\n+member_vec_append_enum_values (vec<tree, va_gc> *member_vec, tree enumtype)\n {\n   for (tree values = TYPE_VALUES (enumtype);\n        values; values = TREE_CHAIN (values))\n-    method_vec->quick_push (TREE_VALUE (values));\n+    member_vec->quick_push (TREE_VALUE (values));\n }\n \n-/* METHOD_VEC has just had new DECLs added to it, but is sorted.\n+/* MEMBER_VEC has just had new DECLs added to it, but is sorted.\n    DeDup adjacent DECLS of the same name.  We already dealt with\n    conflict resolution when adding the fields or methods themselves.\n    There are three cases (which could all be combined):\n@@ -1562,16 +1562,16 @@ method_vec_append_enum_values (vec<tree, va_gc> *method_vec, tree enumtype)\n    it wins.  Otherwise the OVERLOAD does.\n    3) two USING_DECLS. ...\n \n-   method_name_cmp will have ordered duplicates as\n+   member_name_cmp will have ordered duplicates as\n    <fns><using><type>  */\n \n static void\n-method_vec_dedup (vec<tree, va_gc> *method_vec)\n+member_vec_dedup (vec<tree, va_gc> *member_vec)\n {\n-  unsigned len = method_vec->length ();\n+  unsigned len = member_vec->length ();\n   unsigned store = 0;\n \n-  tree current = (*method_vec)[0], name = OVL_NAME (current);\n+  tree current = (*member_vec)[0], name = OVL_NAME (current);\n   tree next = NULL_TREE, next_name = NULL_TREE;\n   for (unsigned jx, ix = 0; ix < len;\n        ix = jx, current = next, name = next_name)\n@@ -1607,7 +1607,7 @@ method_vec_dedup (vec<tree, va_gc> *method_vec)\n \n       for (jx = ix + 1; jx < len; jx++)\n \t{\n-\t  next = (*method_vec)[jx];\n+\t  next = (*member_vec)[jx];\n \t  next_name = OVL_NAME (next);\n \t  if (next_name != name)\n \t    break;\n@@ -1657,15 +1657,15 @@ method_vec_dedup (vec<tree, va_gc> *method_vec)\n \t  OVL_CHAIN (marker) = current;\n \t  current = marker;\n \t}\n-      (*method_vec)[store++] = current;\n+      (*member_vec)[store++] = current;\n     }\n \n   while (store++ < len)\n-    method_vec->pop ();\n+    member_vec->pop ();\n }\n \n-/* Add the non-function members to CLASSTYPE_METHOD_VEC.  If there is\n-   no existing METHOD_VEC and fewer than 8 fields, do nothing.  We\n+/* Add the non-function members to CLASSTYPE_MEMBER_VEC.  If there is\n+   no existing MEMBER_VEC and fewer than 8 fields, do nothing.  We\n    know there must be at least 1 field -- the self-reference\n    TYPE_DECL, except for anon aggregates, which will have at least\n    one field.  */\n@@ -1674,21 +1674,21 @@ void\n set_class_bindings (tree klass, unsigned extra)\n {\n   unsigned n_fields = count_class_fields (klass);\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n+  vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n \n-  if (method_vec || n_fields >= 8)\n+  if (member_vec || n_fields >= 8)\n     {\n       /* Append the new fields.  */\n-      vec_safe_reserve_exact (method_vec, extra + n_fields);\n-      method_vec_append_class_fields (method_vec, klass);\n+      vec_safe_reserve_exact (member_vec, extra + n_fields);\n+      member_vec_append_class_fields (member_vec, klass);\n     }\n \n-  if (method_vec)\n+  if (member_vec)\n     {\n-      CLASSTYPE_METHOD_VEC (klass) = method_vec;\n-      qsort (method_vec->address (), method_vec->length (),\n-\t     sizeof (tree), method_name_cmp);\n-      method_vec_dedup (method_vec);\n+      CLASSTYPE_MEMBER_VEC (klass) = member_vec;\n+      qsort (member_vec->address (), member_vec->length (),\n+\t     sizeof (tree), member_name_cmp);\n+      member_vec_dedup (member_vec);\n     }\n }\n \n@@ -1698,26 +1698,26 @@ void\n insert_late_enum_def_bindings (tree klass, tree enumtype)\n {\n   int n_fields;\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n+  vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n \n   /* The enum bindings will already be on the TYPE_FIELDS, so don't\n      count them twice.  */\n-  if (!method_vec)\n+  if (!member_vec)\n     n_fields = count_class_fields (klass);\n   else\n     n_fields = list_length (TYPE_VALUES (enumtype));\n \n-  if (method_vec || n_fields >= 8)\n+  if (member_vec || n_fields >= 8)\n     {\n-      vec_safe_reserve_exact (method_vec, n_fields);\n-      if (CLASSTYPE_METHOD_VEC (klass))\n-\tmethod_vec_append_enum_values (method_vec, enumtype);\n+      vec_safe_reserve_exact (member_vec, n_fields);\n+      if (CLASSTYPE_MEMBER_VEC (klass))\n+\tmember_vec_append_enum_values (member_vec, enumtype);\n       else\n-\tmethod_vec_append_class_fields (method_vec, klass);\n-      CLASSTYPE_METHOD_VEC (klass) = method_vec;\n-      qsort (method_vec->address (), method_vec->length (),\n-\t     sizeof (tree), method_name_cmp);\n-      method_vec_dedup (method_vec);\n+\tmember_vec_append_class_fields (member_vec, klass);\n+      CLASSTYPE_MEMBER_VEC (klass) = member_vec;\n+      qsort (member_vec->address (), member_vec->length (),\n+\t     sizeof (tree), member_name_cmp);\n+      member_vec_dedup (member_vec);\n     }\n }\n "}, {"sha": "2e5539fd80e0368e97f6a20e2236b856dd739565", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=783dc7392a04bde7bbf6806d55484f3ab37b62db", "patch": "@@ -321,8 +321,8 @@ extern tree do_class_using_decl (tree, tree);\n extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern tree get_class_binding_direct (tree, tree, int type_or_fns = -1);\n extern tree get_class_binding (tree, tree, int type_or_fns = -1);\n-extern tree *get_method_slot (tree klass, tree name);\n-extern void resort_type_method_vec (void *, void *,\n+extern tree *get_member_slot (tree klass, tree name);\n+extern void resort_type_member_vec (void *, void *,\n \t\t\t\t    gt_pointer_operator, void *);\n extern void set_class_bindings (tree, unsigned extra = 0);\n extern void insert_late_enum_def_bindings (tree, tree);"}, {"sha": "1de04f237d9c1bce9d54fd1ff3ab4e167cb903c5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783dc7392a04bde7bbf6806d55484f3ab37b62db/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=783dc7392a04bde7bbf6806d55484f3ab37b62db", "patch": "@@ -1803,18 +1803,18 @@ dfs_locate_field_accessor_pre (tree binfo, void *data)\n   locate_field_data *lfd = (locate_field_data *)data;\n   tree type = BINFO_TYPE (binfo);\n \n-  vec<tree, va_gc> *method_vec;\n+  vec<tree, va_gc> *member_vec;\n   tree fn;\n   size_t i;\n \n   if (!CLASS_TYPE_P (type))\n     return NULL_TREE;\n \n-  method_vec = CLASSTYPE_METHOD_VEC (type);\n-  if (!method_vec)\n+  member_vec = CLASSTYPE_MEMBER_VEC (type);\n+  if (!member_vec)\n     return NULL_TREE;\n \n-  for (i = 0; vec_safe_iterate (method_vec, i, &fn); ++i)\n+  for (i = 0; vec_safe_iterate (member_vec, i, &fn); ++i)\n     if (fn)\n       if (field_accessor_p (fn, lfd->field_decl, lfd->const_p))\n \treturn fn;"}]}