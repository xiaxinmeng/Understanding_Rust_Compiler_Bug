{"sha": "6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRlODhjNmExYzdmYjAxNzcyMGNmNzlhNmY5M2U1MjIyMWFmZGZiOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-16T17:49:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-16T17:49:06Z"}, "message": "varpool.c (dump_varpool_node): Dump write-only flag.\n\n\n\t* varpool.c (dump_varpool_node): Dump write-only flag.\n\t* lto-cgraph.c (lto_output_varpool_node, input_varpool_node): Stream\n\twrite-only flag.\n\t* tree-cfg.c (execute_fixup_cfg): Remove statements setting write-only variables.\n\n\n\t* gcc.c-torture/execute/20101011-1.c: Update testcase.\n\t* gcc.dg/ira-shrinkwrap-prep-1.c: Update testcase.\n\t* gcc.dg/tree-ssa/writeonly.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-dse-6.c: Update testcase.\n\t* gcc.dg/tree-ssa/pr21559.c: Update testcase.\n\t* gcc.dg/debug/pr35154.c: Update testcase.\n\t* gcc.target/i386/vectorize1.c: Update testcase.\n\t* ipa.c (process_references): New function.\n\t(set_readonly_bit): New function.\n\t(set_writeonly_bit): New function.\n\t(clear_addressable_bit): New function.\n\t(ipa_discover_readonly_nonaddressable_var): Mark write only variables; fix\n\thandling of aliases.\n\t* cgraph.h (struct varpool_node): Add writeonly flag.\n\nFrom-SVN: r210522", "tree": {"sha": "95128482337699b940df1c3ea7402e38fb4ecb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95128482337699b940df1c3ea7402e38fb4ecb88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/comments", "author": null, "committer": null, "parents": [{"sha": "54674a35bd0a8d231ad314064d5f7bb8a60ef5df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54674a35bd0a8d231ad314064d5f7bb8a60ef5df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54674a35bd0a8d231ad314064d5f7bb8a60ef5df"}], "stats": {"total": 213, "additions": 186, "deletions": 27}, "files": [{"sha": "f899ba15db7e7f9902f765880f756a5342db35eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -1,3 +1,10 @@\n+2014-05-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* varpool.c (dump_varpool_node): Dump write-only flag.\n+\t* lto-cgraph.c (lto_output_varpool_node, input_varpool_node): Stream\n+\twrite-only flag.\n+\t* tree-cfg.c (execute_fixup_cfg): Remove statements setting write-only variables.\n+\n 2014-05-16  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/60969"}, {"sha": "a29a31c4b67ac0860aee7eb2acb382b2a9eb73d5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -76,6 +76,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Set once the definition was analyzed.  The list of references and\n      other properties are built during analysis.  */\n   unsigned analyzed : 1;\n+  /* Set for write-only variables.  */\n+  unsigned writeonly : 1;\n \n \n   /*** Visibility and linkage flags.  ***/"}, {"sha": "da424914ce971cf6865f9ac286451a2475f01089", "filename": "gcc/ipa.c", "status": "modified", "additions": 91, "deletions": 23, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -624,6 +624,77 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   return changed;\n }\n \n+/* Process references to VNODE and set flags WRITTEN, ADDRESS_TAKEN, READ\n+   as needed, also clear EXPLICIT_REFS if the references to given variable\n+   do not need to be explicit.  */\n+\n+void\n+process_references (varpool_node *vnode,\n+\t\t    bool *written, bool *address_taken,\n+\t\t    bool *read, bool *explicit_refs)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+\n+  if (!varpool_all_refs_explicit_p (vnode)\n+      || TREE_THIS_VOLATILE (vnode->decl))\n+    *explicit_refs = false;\n+\n+  for (i = 0; ipa_ref_list_referring_iterate (&vnode->ref_list,\n+\t\t\t\t\t     i, ref)\n+\t      && *explicit_refs && (!*written || !*address_taken || !*read); i++)\n+    switch (ref->use)\n+      {\n+      case IPA_REF_ADDR:\n+\t*address_taken = true;\n+\tbreak;\n+      case IPA_REF_LOAD:\n+\t*read = true;\n+\tbreak;\n+      case IPA_REF_STORE:\n+\t*written = true;\n+\tbreak;\n+      case IPA_REF_ALIAS:\n+\tprocess_references (varpool (ref->referring), written, address_taken,\n+\t\t\t    read, explicit_refs);\n+\tbreak;\n+      }\n+}\n+\n+/* Set TREE_READONLY bit.  */\n+\n+bool\n+set_readonly_bit (varpool_node *vnode, void *data ATTRIBUTE_UNUSED)\n+{\n+  TREE_READONLY (vnode->decl) = true;\n+  return false;\n+}\n+\n+/* Set writeonly bit and clear the initalizer, since it will not be needed.  */\n+\n+bool\n+set_writeonly_bit (varpool_node *vnode, void *data ATTRIBUTE_UNUSED)\n+{\n+  vnode->writeonly = true;\n+  if (optimize)\n+    {\n+      DECL_INITIAL (vnode->decl) = NULL;\n+      if (!vnode->alias)\n+\tipa_remove_all_references (&vnode->ref_list);\n+    }\n+  return false;\n+}\n+\n+/* Clear addressale bit of VNODE.  */\n+\n+bool\n+clear_addressable_bit (varpool_node *vnode, void *data ATTRIBUTE_UNUSED)\n+{\n+  vnode->address_taken = false;\n+  TREE_ADDRESSABLE (vnode->decl) = 0;\n+  return false;\n+}\n+\n /* Discover variables that have no longer address taken or that are read only\n    and update their flags.\n \n@@ -640,43 +711,40 @@ ipa_discover_readonly_nonaddressable_vars (void)\n   if (dump_file)\n     fprintf (dump_file, \"Clearing variable flags:\");\n   FOR_EACH_VARIABLE (vnode)\n-    if (vnode->definition && varpool_all_refs_explicit_p (vnode)\n+    if (!vnode->alias\n \t&& (TREE_ADDRESSABLE (vnode->decl)\n+\t    || !vnode->writeonly\n \t    || !TREE_READONLY (vnode->decl)))\n       {\n \tbool written = false;\n \tbool address_taken = false;\n-\tint i;\n-        struct ipa_ref *ref;\n-        for (i = 0; ipa_ref_list_referring_iterate (&vnode->ref_list,\n-\t\t\t\t\t\t   i, ref)\n-\t\t    && (!written || !address_taken); i++)\n-\t  switch (ref->use)\n-\t    {\n-\t    case IPA_REF_ADDR:\n-\t      address_taken = true;\n-\t      break;\n-\t    case IPA_REF_LOAD:\n-\t      break;\n-\t    case IPA_REF_STORE:\n-\t      written = true;\n-\t      break;\n-\t    }\n-\tif (TREE_ADDRESSABLE (vnode->decl) && !address_taken)\n+\tbool read = false;\n+\tbool explicit_refs = true;\n+\n+\tprocess_references (vnode, &written, &address_taken, &read, &explicit_refs);\n+\tif (!explicit_refs)\n+\t  continue;\n+\tif (!address_taken)\n \t  {\n-\t    if (dump_file)\n+\t    if (TREE_ADDRESSABLE (vnode->decl) && dump_file)\n \t      fprintf (dump_file, \" %s (addressable)\", vnode->name ());\n-\t    TREE_ADDRESSABLE (vnode->decl) = 0;\n+\t    varpool_for_node_and_aliases (vnode, clear_addressable_bit, NULL, true);\n \t  }\n-\tif (!TREE_READONLY (vnode->decl) && !address_taken && !written\n+\tif (!address_taken && !written\n \t    /* Making variable in explicit section readonly can cause section\n \t       type conflict. \n \t       See e.g. gcc.c-torture/compile/pr23237.c */\n \t    && DECL_SECTION_NAME (vnode->decl) == NULL)\n \t  {\n-\t    if (dump_file)\n+\t    if (!TREE_READONLY (vnode->decl) && dump_file)\n \t      fprintf (dump_file, \" %s (read-only)\", vnode->name ());\n-\t    TREE_READONLY (vnode->decl) = 1;\n+\t    varpool_for_node_and_aliases (vnode, set_readonly_bit, NULL, true);\n+\t  }\n+\tif (!vnode->writeonly && !read && !address_taken)\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \" %s (write-only)\", vnode->name ());\n+\t    varpool_for_node_and_aliases (vnode, set_writeonly_bit, NULL, true);\n \t  }\n       }\n   if (dump_file)"}, {"sha": "b22eb46ac3e772e30b51f0346bd663289e64529f", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -562,6 +562,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   bp_pack_value (&bp, node->forced_by_abi, 1);\n   bp_pack_value (&bp, node->unique_name, 1);\n   bp_pack_value (&bp, node->body_removed, 1);\n+  bp_pack_value (&bp, node->writeonly, 1);\n   bp_pack_value (&bp, node->definition, 1);\n   alias_p = node->alias && (!boundary_p || node->weakref);\n   bp_pack_value (&bp, alias_p, 1);\n@@ -1153,6 +1154,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->forced_by_abi = bp_unpack_value (&bp, 1);\n   node->unique_name = bp_unpack_value (&bp, 1);\n   node->body_removed = bp_unpack_value (&bp, 1);\n+  node->writeonly = bp_unpack_value (&bp, 1);\n   node->definition = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n   node->weakref = bp_unpack_value (&bp, 1);"}, {"sha": "5aee09ad14c53589238c616736ece627bf2c6b8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -1,3 +1,20 @@\n+2014-05-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.c-torture/execute/20101011-1.c: Update testcase.\n+\t* gcc.dg/ira-shrinkwrap-prep-1.c: Update testcase.\n+\t* gcc.dg/tree-ssa/writeonly.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-dse-6.c: Update testcase.\n+\t* gcc.dg/tree-ssa/pr21559.c: Update testcase.\n+\t* gcc.dg/debug/pr35154.c: Update testcase.\n+\t* gcc.target/i386/vectorize1.c: Update testcase.\n+\t* ipa.c (process_references): New function.\n+\t(set_readonly_bit): New function.\n+\t(set_writeonly_bit): New function.\n+\t(clear_addressable_bit): New function.\n+\t(ipa_discover_readonly_nonaddressable_var): Mark write only variables; fix\n+\thandling of aliases.\n+\t* cgraph.h (struct varpool_node): Add writeonly flag.\n+\n 2014-05-16  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51640"}, {"sha": "9299bb9205a850b6551e765025b359dc1d16fb7c", "filename": "gcc/testsuite/gcc.c-torture/execute/20101011-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -92,7 +92,7 @@ sigfpe (int signum __attribute__ ((unused)))\n    eliminate the assignment to the global k.  */\n static int i;\n static int j;\n-int k;\n+int k __attribute__ ((used));\n \n int\n main ()"}, {"sha": "7f6a6eaa0ecd088fa7389ef4c2fd7c42a1bba68c", "filename": "gcc/testsuite/gcc.dg/debug/pr35154.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr35154.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr35154.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr35154.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -2,6 +2,7 @@\n    proper structure.  These should be lettered G for the struct that gives\n    the name to the .comm, and should be V or S for .lcomm symbols.  */\n \n+__attribute__ ((used))\n static char i_outer;\n struct {\n    char f1;\n@@ -15,7 +16,7 @@ struct {\n int\n main()\n {\n-   static char i_inner[2];\n+   static char i_inner[2] __attribute__ ((used));\n    i_inner[0] = 'a'; i_inner[1] = 'b';\n    opta.f1 = 'c';\n    opta.f2 = 'd';"}, {"sha": "171a2bd5e17419a378a22380557d0023fe331292", "filename": "gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -7,7 +7,7 @@ foo (long a)\n   return a + 5;\n }\n \n-static long g;\n+static long g __attribute__ ((used));\n \n long __attribute__((noinline, noclone))\n bar (long a)"}, {"sha": "a991e0490358da8388b7ffa94a2fe52be9ff421c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21559.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21559.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -9,6 +9,7 @@ void foo (void)\n {\n   int toread;\n   int bytes;\n+  __attribute__ ((used))\n   static char eof_reached = 0;\n \n   toread = blocksize;"}, {"sha": "cf496291f8dd65d4be5f9bfec6dbd2ef73a270df", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-6.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -3,6 +3,7 @@\n \n int foo11 (int c)\n {\n+  __attribute__ ((used))\n   static int local1, local2;\n   local1 = 0;\n   local2 += c;"}, {"sha": "156cf3ef6a8dc8cc38baf0270865b1e04fedc75c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/writeonly.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fwriteonly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fwriteonly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fwriteonly.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+static struct a {int magic1,b;} a;\n+volatile int magic2;\n+static struct b {int a,b,c,d,e,f;} magic3;\n+\n+struct b foo();\n+\n+t()\n+{\n+ a.magic1 = 1;\n+ magic2 = 1;\n+ magic3 = foo();\n+}\n+/* { dg-final { scan-tree-dump-not \"magic1\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-not \"magic3\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \"magic2\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \"foo\" \"optimized\"} } */\n+ \n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "974ffd82628c2553f15a079374121f923066bb5e", "filename": "gcc/testsuite/gcc.target/i386/vectorize1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvectorize1.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -10,6 +10,7 @@ typedef struct\n \n int set_names (void)\n {\n+  __attribute__ ((used))\n   static tx_typ tt1;\n   int ln;\n   for (ln = 0; ln < 8; ln++)"}, {"sha": "9228d41970ccca896e8c161da4e9e898a47e8853", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -8431,7 +8431,7 @@ execute_fixup_cfg (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       bb->count = apply_scale (bb->count, count_scale);\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree decl = is_gimple_call (stmt)\n@@ -8457,9 +8457,46 @@ execute_fixup_cfg (void)\n \t\ttodo |= TODO_cleanup_cfg;\n \t     }\n \n+\t  /* Remove stores to variables we marked write-only.\n+\t     Keep access when store has side effect, i.e. in case when source\n+\t     is volatile.  */\n+\t  if (gimple_store_p (stmt)\n+\t      && !gimple_has_side_effects (stmt))\n+\t    {\n+\t      tree lhs = get_base_address (gimple_get_lhs (stmt));\n+\n+\t      if (TREE_CODE (lhs) == VAR_DECL\n+\t\t  && (TREE_STATIC (lhs) || DECL_EXTERNAL (lhs))\n+\t\t  && varpool_get_node (lhs)->writeonly)\n+\t\t{\n+\t\t  unlink_stmt_vdef (stmt);\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  release_defs (stmt);\n+\t          todo |= TODO_update_ssa | TODO_cleanup_cfg;\n+\t          continue;\n+\t\t}\n+\t    }\n+\t  /* For calls we can simply remove LHS when it is known\n+\t     to be write-only.  */\n+\t  if (is_gimple_call (stmt)\n+\t      && gimple_get_lhs (stmt))\n+\t    {\n+\t      tree lhs = get_base_address (gimple_get_lhs (stmt));\n+\n+\t      if (TREE_CODE (lhs) == VAR_DECL\n+\t\t  && (TREE_STATIC (lhs) || DECL_EXTERNAL (lhs))\n+\t\t  && varpool_get_node (lhs)->writeonly)\n+\t\t{\n+\t\t  gimple_call_set_lhs (stmt, NULL);\n+\t\t  update_stmt (stmt);\n+\t          todo |= TODO_update_ssa | TODO_cleanup_cfg;\n+\t\t}\n+\t    }\n+\n \t  if (maybe_clean_eh_stmt (stmt)\n \t      && gimple_purge_dead_eh_edges (bb))\n \t    todo |= TODO_cleanup_cfg;\n+\t  gsi_next (&gsi);\n \t}\n \n       FOR_EACH_EDGE (e, ei, bb->succs)"}, {"sha": "c4fd11c2946ed21d350f7b9bc73a33b5508dafe9", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de88c6a1c7fb017720cf79a6f93e52221afdfb8/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=6de88c6a1c7fb017720cf79a6f93e52221afdfb8", "patch": "@@ -211,6 +211,8 @@ dump_varpool_node (FILE *f, varpool_node *node)\n     fprintf (f, \" read-only\");\n   if (ctor_for_folding (node->decl) != error_mark_node)\n     fprintf (f, \" const-value-known\");\n+  if (node->writeonly)\n+    fprintf (f, \" write-only\");\n   fprintf (f, \"\\n\");\n }\n "}]}