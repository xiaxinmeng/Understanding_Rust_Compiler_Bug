{"sha": "548cb3d77c81104778f4cbc4d97410cb31a64971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ4Y2IzZDc3YzgxMTA0Nzc4ZjRjYmM0ZDk3NDEwY2IzMWE2NDk3MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-10-10T03:28:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-10-10T03:28:18Z"}, "message": "re PR c++/63207 (ICE in expand_expr_real_l when instantiating a template with a lambda that captures a const variable with a dependent initializer)\n\n\tPR c++/63207\n\t* semantics.c (outer_var_p): Non-static.\n\t(process_outer_var_ref): Split out from finish_id_expression.\n\t* pt.c (tsubst_copy_and_build): Call them.\n\t* cp-tree.h: Declare them.\n\nFrom-SVN: r216056", "tree": {"sha": "5e470a495fe25b3226b27b25383860487fe618cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e470a495fe25b3226b27b25383860487fe618cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/548cb3d77c81104778f4cbc4d97410cb31a64971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548cb3d77c81104778f4cbc4d97410cb31a64971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548cb3d77c81104778f4cbc4d97410cb31a64971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548cb3d77c81104778f4cbc4d97410cb31a64971/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "018e891a75501d357d3035d0e7ee6f98fd390887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/018e891a75501d357d3035d0e7ee6f98fd390887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/018e891a75501d357d3035d0e7ee6f98fd390887"}], "stats": {"total": 214, "additions": 129, "deletions": 85}, "files": [{"sha": "7b2d09f14026a0a65cab8cbd79f7ce20cd6bef2c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=548cb3d77c81104778f4cbc4d97410cb31a64971", "patch": "@@ -1,3 +1,11 @@\n+2014-10-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/63207\n+\t* semantics.c (outer_var_p): Non-static.\n+\t(process_outer_var_ref): Split out from finish_id_expression.\n+\t* pt.c (tsubst_copy_and_build): Call them.\n+\t* cp-tree.h: Declare them.\n+\n 2014-10-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* semantics.c (check_constexpr_ctor_body_1): New."}, {"sha": "6d720c152a624324d70b112b53ed18092982ab8a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=548cb3d77c81104778f4cbc4d97410cb31a64971", "patch": "@@ -5879,6 +5879,8 @@ extern void finish_template_decl\t\t(tree);\n extern tree finish_template_type\t\t(tree, tree, int);\n extern tree finish_base_specifier\t\t(tree, tree, bool);\n extern void finish_member_declaration\t\t(tree);\n+extern bool outer_automatic_var_p\t\t(tree);\n+extern tree process_outer_var_ref\t\t(tree, tsubst_flags_t);\n extern tree finish_id_expression\t\t(tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *,\n \t\t\t\t\t\t bool, bool, bool *,"}, {"sha": "f2c21eec322e446a1492b0c9159d0090d51b4ede", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=548cb3d77c81104778f4cbc4d97410cb31a64971", "patch": "@@ -15460,6 +15460,7 @@ tsubst_copy_and_build (tree t,\n     case PARM_DECL:\n       {\n \ttree r = tsubst_copy (t, args, complain, in_decl);\n+\t/* ??? We're doing a subset of finish_id_expression here.  */\n \tif (VAR_P (r)\n \t    && !processing_template_decl\n \t    && !cp_unevaluated_operand\n@@ -15471,6 +15472,8 @@ tsubst_copy_and_build (tree t,\n \t\t a call to its wrapper.  */\n \t      r = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);\n \t  }\n+\telse if (outer_automatic_var_p (r))\n+\t  r = process_outer_var_ref (r, complain);\n \n \tif (TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n \t  /* If the original type was a reference, we'll be wrapped in"}, {"sha": "ab8c82ae5f6603a52674c972b156a64000097e95", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 95, "deletions": 85, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=548cb3d77c81104778f4cbc4d97410cb31a64971", "patch": "@@ -3067,13 +3067,105 @@ outer_var_p (tree decl)\n \n /* As above, but also checks that DECL is automatic.  */\n \n-static bool\n+bool\n outer_automatic_var_p (tree decl)\n {\n   return (outer_var_p (decl)\n \t  && !TREE_STATIC (decl));\n }\n \n+/* DECL satisfies outer_automatic_var_p.  Possibly complain about it or\n+   rewrite it for lambda capture.  */\n+\n+tree\n+process_outer_var_ref (tree decl, tsubst_flags_t complain)\n+{\n+  if (cp_unevaluated_operand)\n+    /* It's not a use (3.2) if we're in an unevaluated context.  */\n+    return decl;\n+\n+  tree context = DECL_CONTEXT (decl);\n+  tree containing_function = current_function_decl;\n+  tree lambda_stack = NULL_TREE;\n+  tree lambda_expr = NULL_TREE;\n+  tree initializer = convert_from_reference (decl);\n+\n+  /* Mark it as used now even if the use is ill-formed.  */\n+  mark_used (decl);\n+\n+  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n+     support for an approach in which a reference to a local\n+     [constant] automatic variable in a nested class or lambda body\n+     would enter the expression as an rvalue, which would reduce\n+     the complexity of the problem\"\n+\n+     FIXME update for final resolution of core issue 696.  */\n+  if (decl_maybe_constant_var_p (decl))\n+    {\n+      if (processing_template_decl)\n+\t/* In a template, the constant value may not be in a usable\n+\t   form, so wait until instantiation time.  */\n+\treturn decl;\n+      else if (decl_constant_var_p (decl))\n+\treturn integral_constant_value (decl);\n+    }\n+\n+  if (parsing_nsdmi ())\n+    containing_function = NULL_TREE;\n+  else\n+    /* If we are in a lambda function, we can move out until we hit\n+       1. the context,\n+       2. a non-lambda function, or\n+       3. a non-default capturing lambda function.  */\n+    while (context != containing_function\n+\t   && LAMBDA_FUNCTION_P (containing_function))\n+      {\n+\tlambda_expr = CLASSTYPE_LAMBDA_EXPR\n+\t  (DECL_CONTEXT (containing_function));\n+\n+\tif (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr)\n+\t    == CPLD_NONE)\n+\t  break;\n+\n+\tlambda_stack = tree_cons (NULL_TREE,\n+\t\t\t\t  lambda_expr,\n+\t\t\t\t  lambda_stack);\n+\n+\tcontaining_function\n+\t  = decl_function_context (containing_function);\n+      }\n+\n+  if (lambda_expr && TREE_CODE (decl) == VAR_DECL\n+      && DECL_ANON_UNION_VAR_P (decl))\n+    {\n+      if (complain & tf_error)\n+\terror (\"cannot capture member %qD of anonymous union\", decl);\n+      return error_mark_node;\n+    }\n+  if (context == containing_function)\n+    {\n+      decl = add_default_capture (lambda_stack,\n+\t\t\t\t  /*id=*/DECL_NAME (decl),\n+\t\t\t\t  initializer);\n+    }\n+  else if (lambda_expr)\n+    {\n+      if (complain & tf_error)\n+\terror (\"%qD is not captured\", decl);\n+      return error_mark_node;\n+    }\n+  else\n+    {\n+      if (complain & tf_error)\n+\terror (VAR_P (decl)\n+\t       ? G_(\"use of local variable with automatic storage from containing function\")\n+\t       : G_(\"use of parameter from containing function\"));\n+      inform (input_location, \"%q+#D declared here\", decl);\n+      return error_mark_node;\n+    }\n+  return decl;\n+}\n+\n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n    if non-NULL, is the type or namespace used to explicitly qualify\n@@ -3179,90 +3271,8 @@ finish_id_expression (tree id_expression,\n \n       /* Disallow uses of local variables from containing functions, except\n \t within lambda-expressions.  */\n-      if (!outer_var_p (decl))\n-\t/* OK */;\n-      else if (TREE_STATIC (decl)\n-\t       /* It's not a use (3.2) if we're in an unevaluated context.  */\n-\t       || cp_unevaluated_operand)\n-\t/* OK */;\n-      else\n-\t{\n-\t  tree context = DECL_CONTEXT (decl);\n-\t  tree containing_function = current_function_decl;\n-\t  tree lambda_stack = NULL_TREE;\n-\t  tree lambda_expr = NULL_TREE;\n-\t  tree initializer = convert_from_reference (decl);\n-\n-\t  /* Mark it as used now even if the use is ill-formed.  */\n-\t  mark_used (decl);\n-\n-\t  /* Core issue 696: \"[At the July 2009 meeting] the CWG expressed\n-\t     support for an approach in which a reference to a local\n-\t     [constant] automatic variable in a nested class or lambda body\n-\t     would enter the expression as an rvalue, which would reduce\n-\t     the complexity of the problem\"\n-\n-\t     FIXME update for final resolution of core issue 696.  */\n-\t  if (decl_maybe_constant_var_p (decl))\n-\t    {\n-\t      if (processing_template_decl)\n-\t\t/* In a template, the constant value may not be in a usable\n-\t\t   form, so wait until instantiation time.  */\n-\t\treturn decl;\n-\t      else if (decl_constant_var_p (decl))\n-\t\treturn integral_constant_value (decl);\n-\t    }\n-\n-\t  if (parsing_nsdmi ())\n-\t    containing_function = NULL_TREE;\n-\t  /* If we are in a lambda function, we can move out until we hit\n-\t     1. the context,\n-\t     2. a non-lambda function, or\n-\t     3. a non-default capturing lambda function.  */\n-\t  else while (context != containing_function\n-\t\t      && LAMBDA_FUNCTION_P (containing_function))\n-\t    {\n-\t      lambda_expr = CLASSTYPE_LAMBDA_EXPR\n-\t\t(DECL_CONTEXT (containing_function));\n-\n-\t      if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr)\n-\t\t  == CPLD_NONE)\n-\t\tbreak;\n-\n-\t      lambda_stack = tree_cons (NULL_TREE,\n-\t\t\t\t\tlambda_expr,\n-\t\t\t\t\tlambda_stack);\n-\n-\t      containing_function\n-\t\t= decl_function_context (containing_function);\n-\t    }\n-\n-\t  if (lambda_expr && TREE_CODE (decl) == VAR_DECL\n-\t      && DECL_ANON_UNION_VAR_P (decl))\n-\t    {\n-\t      error (\"cannot capture member %qD of anonymous union\", decl);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (context == containing_function)\n-\t    {\n-\t      decl = add_default_capture (lambda_stack,\n-\t\t\t\t\t  /*id=*/DECL_NAME (decl),\n-\t\t\t\t\t  initializer);\n-\t    }\n-\t  else if (lambda_expr)\n-\t    {\n-\t      error (\"%qD is not captured\", decl);\n-\t      return error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      error (VAR_P (decl)\n-\t\t     ? G_(\"use of local variable with automatic storage from containing function\")\n-\t\t     : G_(\"use of parameter from containing function\"));\n-\t      inform (input_location, \"%q+#D declared here\", decl);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n+      if (outer_automatic_var_p (decl))\n+\tdecl = process_outer_var_ref (decl, tf_warning_or_error);\n \n       /* Also disallow uses of function parameters outside the function\n \t body, except inside an unevaluated context (i.e. decltype).  */"}, {"sha": "02ad60224f5697e3ce49b13b2c203194ee929d17", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const4.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548cb3d77c81104778f4cbc4d97410cb31a64971/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const4.C?ref=548cb3d77c81104778f4cbc4d97410cb31a64971", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/63207\n+// { dg-do run { target c++11 } }\n+\n+template <typename T>\n+struct Base {\n+  T value;\n+};\n+\n+template <typename T>\n+struct Test : Base<T> {\n+  T test() {\n+    const int x = this->value;\n+    return ([&]{ return x; })();\n+  }\n+};\n+\n+int main()  {\n+  Test<int> t;\n+  t.value = 0;\n+  return t.test();\n+}"}]}