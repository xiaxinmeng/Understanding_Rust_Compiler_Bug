{"sha": "cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwM2JmN2E3YmY2YmIwYTExZjdmYTkwZWFkNTFlZWM3ZDc3MGFmOQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-11-06T16:10:22Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-11-06T16:10:22Z"}, "message": "allocate_with_source_14.f03: Fixed number mallocs occuring.\n\ngcc/testsuite/ChangeLog:\n\n2016-11-06  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/allocate_with_source_14.f03: Fixed number mallocs\n\toccuring.\n\ngcc/fortran/ChangeLog:\n\n2016-11-06  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* expr.c (is_non_empty_structure_constructor): New function to detect\n\tnon-empty structure constructor.\n\t(gfc_has_default_initializer): Analyse initializers.\n\t* resolve.c (cond_init): Removed.\n\t(resolve_allocate_expr): Removed dead code.  Moved invariant code out\n\tof the loop over all objects to allocate.\n\t(resolve_allocate_deallocate): Added the invariant code remove from\n\tresolve_allocate_expr.\n\t* trans-array.c (gfc_array_allocate): Removed nullify of structure\n\tcomponents in favour of doing this in gfc_trans_allocate for both\n\tscalars and arrays in the same place.\n\t* trans-expr.c (gfc_trans_init_assign): Always using _vptr->copy for\n\tclass objects.\n\t* trans-stmt.c (allocate_get_initializer): Get the initializer\n\texpression for object allocated.\n\t(gfc_trans_allocate): Nullify a derived type only, when no SOURCE=\n\tor MOLD= is present preventing duplicate work.  Moved the creation\n\tof the init-expression here to prevent code for conditions that\n\tcan not occur on freshly allocated object, like checking for the need\n\tto free allocatable components.\n\nFrom-SVN: r241885", "tree": {"sha": "9ac441670f08e2dbbef73cdcca9444907c806f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ac441670f08e2dbbef73cdcca9444907c806f9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/comments", "author": null, "committer": null, "parents": [{"sha": "18bb8b8a2a67091517d60b7192e454ed11e9280d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bb8b8a2a67091517d60b7192e454ed11e9280d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18bb8b8a2a67091517d60b7192e454ed11e9280d"}], "stats": {"total": 204, "additions": 121, "deletions": 83}, "files": [{"sha": "ec91b1fd7852179e7a79b1d534e9e0e9109ce8a2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -1,3 +1,26 @@\n+2016-11-06  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* expr.c (is_non_empty_structure_constructor): New function to detect\n+\tnon-empty structure constructor.\n+\t(gfc_has_default_initializer): Analyse initializers.\n+\t* resolve.c (cond_init): Removed.\n+\t(resolve_allocate_expr): Removed dead code.  Moved invariant code out\n+\tof the loop over all objects to allocate.\n+\t(resolve_allocate_deallocate): Added the invariant code remove from\n+\tresolve_allocate_expr.\n+\t* trans-array.c (gfc_array_allocate): Removed nullify of structure\n+\tcomponents in favour of doing this in gfc_trans_allocate for both\n+\tscalars and arrays in the same place.\n+\t* trans-expr.c (gfc_trans_init_assign): Always using _vptr->copy for\n+\tclass objects.\n+\t* trans-stmt.c (allocate_get_initializer): Get the initializer\n+\texpression for object allocated.\n+\t(gfc_trans_allocate): Nullify a derived type only, when no SOURCE=\n+\tor MOLD= is present preventing duplicate work.  Moved the creation\n+\tof the init-expression here to prevent code for conditions that\n+\tcan not occur on freshly allocated object, like checking for the need\n+\tto free allocatable components.\n+\n 2016-11-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/78221"}, {"sha": "0e94ae8283312468a1b14f8c9f8e9f6ae21b88f5", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -4131,6 +4131,26 @@ gfc_apply_init (gfc_typespec *ts, symbol_attribute *attr, gfc_expr *init)\n }\n \n \n+/* Check whether an expression is a structure constructor and whether it has\n+   other values than NULL.  */\n+\n+bool\n+is_non_empty_structure_constructor (gfc_expr * e)\n+{\n+  if (e->expr_type != EXPR_STRUCTURE)\n+    return false;\n+\n+  gfc_constructor *cons = gfc_constructor_first (e->value.constructor);\n+  while (cons)\n+    {\n+      if (!cons->expr || cons->expr->expr_type != EXPR_NULL)\n+\treturn true;\n+      cons = gfc_constructor_next (cons);\n+    }\n+  return false;\n+}\n+\n+\n /* Check for default initializer; sym->value is not enough\n    as it is also set for EXPR_NULL of allocatables.  */\n \n@@ -4145,7 +4165,9 @@ gfc_has_default_initializer (gfc_symbol *der)\n       {\n         if (!c->attr.pointer && !c->attr.proc_pointer\n \t     && !(c->attr.allocatable && der == c->ts.u.derived)\n-\t     && gfc_has_default_initializer (c->ts.u.derived))\n+\t     && ((c->initializer\n+\t\t  && is_non_empty_structure_constructor (c->initializer))\n+\t\t || gfc_has_default_initializer (c->ts.u.derived)))\n \t  return true;\n \tif (c->attr.pointer && c->initializer)\n \t  return true;"}, {"sha": "9620ce67a0f2478656c4dee39886c94befc3a6d8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 20, "deletions": 63, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -7048,35 +7048,6 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n   return true;\n }\n \n-static void\n-cond_init (gfc_code *code, gfc_expr *e, int pointer, gfc_expr *init_e)\n-{\n-  gfc_code *block;\n-  gfc_expr *cond;\n-  gfc_code *init_st;\n-  gfc_expr *e_to_init = gfc_expr_to_initialize (e);\n-\n-  cond = pointer\n-    ? gfc_build_intrinsic_call (gfc_current_ns, GFC_ISYM_ASSOCIATED,\n-\t\"associated\", code->loc, 2, gfc_copy_expr (e_to_init), NULL)\n-    : gfc_build_intrinsic_call (gfc_current_ns, GFC_ISYM_ALLOCATED,\n-\t\"allocated\", code->loc, 1, gfc_copy_expr (e_to_init));\n-\n-  init_st = gfc_get_code (EXEC_INIT_ASSIGN);\n-  init_st->loc = code->loc;\n-  init_st->expr1 = e_to_init;\n-  init_st->expr2 = init_e;\n-\n-  block = gfc_get_code (EXEC_IF);\n-  block->loc = code->loc;\n-  block->block = gfc_get_code (EXEC_IF);\n-  block->block->loc = code->loc;\n-  block->block->expr1 = cond;\n-  block->block->next = init_st;\n-  block->next = code->next;\n-\n-  code->next = block;\n-}\n \n /* Resolve the expression in an ALLOCATE statement, doing the additional\n    checks to see whether the expression is OK or not.  The expression must\n@@ -7327,34 +7298,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n       /* We have to zero initialize the integer variable.  */\n       code->expr3 = gfc_get_int_expr (gfc_default_integer_kind, &e->where, 0);\n     }\n-  else if (!code->expr3)\n-    {\n-      /* Set up default initializer if needed.  */\n-      gfc_typespec ts;\n-      gfc_expr *init_e;\n-\n-      if (gfc_bt_struct (code->ext.alloc.ts.type))\n-\tts = code->ext.alloc.ts;\n-      else\n-\tts = e->ts;\n-\n-      if (ts.type == BT_CLASS)\n-\tts = ts.u.derived->components->ts;\n-\n-      if (gfc_bt_struct (ts.type) && (init_e = gfc_default_initializer (&ts)))\n-\tcond_init (code, e, pointer, init_e);\n-    }\n-  else if (code->expr3->mold && code->expr3->ts.type == BT_DERIVED)\n-    {\n-      /* Default initialization via MOLD (non-polymorphic).  */\n-      gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts);\n-      if (rhs != NULL)\n-\t{\n-\t  gfc_resolve_expr (rhs);\n-\t  gfc_free_expr (code->expr3);\n-\t  code->expr3 = rhs;\n-\t}\n-    }\n \n   if (e->ts.type == BT_CLASS && !unlimited && !UNLIMITED_POLY (code->expr3))\n     {\n@@ -7366,10 +7309,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n       else if (code->ext.alloc.ts.type == BT_DERIVED)\n \tts = code->ext.alloc.ts;\n \n+      /* Finding the vtab also publishes the type's symbol.  Therefore this\n+\t statement is necessary.  */\n       gfc_find_derived_vtab (ts.u.derived);\n-\n-      if (dimension)\n-\te = gfc_expr_to_initialize (e);\n     }\n   else if (unlimited && !UNLIMITED_POLY (code->expr3))\n     {\n@@ -7383,10 +7325,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n \n       gcc_assert (ts);\n \n+      /* Finding the vtab also publishes the type's symbol.  Therefore this\n+\t statement is necessary.  */\n       gfc_find_vtab (ts);\n-\n-      if (dimension)\n-\te = gfc_expr_to_initialize (e);\n     }\n \n   if (dimension == 0 && codimension == 0)\n@@ -7690,6 +7631,22 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n   if (strcmp (fcn, \"ALLOCATE\") == 0)\n     {\n       bool arr_alloc_wo_spec = false;\n+\n+      /* Resolving the expr3 in the loop over all objects to allocate would\n+\t execute loop invariant code for each loop item.  Therefore do it just\n+\t once here.  */\n+      if (code->expr3 && code->expr3->mold\n+\t  && code->expr3->ts.type == BT_DERIVED)\n+\t{\n+\t  /* Default initialization via MOLD (non-polymorphic).  */\n+\t  gfc_expr *rhs = gfc_default_initializer (&code->expr3->ts);\n+\t  if (rhs != NULL)\n+\t    {\n+\t      gfc_resolve_expr (rhs);\n+\t      gfc_free_expr (code->expr3);\n+\t      code->expr3 = rhs;\n+\t    }\n+\t}\n       for (a = code->ext.alloc.list; a; a = a->next)\n \tresolve_allocate_expr (a->expr, code, &arr_alloc_wo_spec);\n "}, {"sha": "1708f7c8e44488450f384ea0d240d234ee203ef8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -5623,14 +5623,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   else\n       gfc_add_expr_to_block (&se->pre, set_descriptor);\n \n-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp\n-      && !coarray)\n-    {\n-      tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, se->expr,\n-\t\t\t\t    ref->u.ar.as->rank);\n-      gfc_add_expr_to_block (&se->pre, tmp);\n-    }\n-\n   return true;\n }\n "}, {"sha": "61214295f664e7cd8e2a9ffcdc47628d7805008b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -10042,7 +10042,7 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n tree\n gfc_trans_init_assign (gfc_code * code)\n {\n-  return gfc_trans_assignment (code->expr1, code->expr2, true, false);\n+  return gfc_trans_assignment (code->expr1, code->expr2, true, false, true);\n }\n \n tree"}, {"sha": "490b18dae31eb4e567abd0eadf48d37eb8ee35af", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -5450,13 +5450,41 @@ gfc_trans_exit (gfc_code * code)\n }\n \n \n+/* Get the initializer expression for the code and expr of an allocate.\n+   When no initializer is needed return NULL.  */\n+\n+static gfc_expr *\n+allocate_get_initializer (gfc_code * code, gfc_expr * expr)\n+{\n+  if (!gfc_bt_struct (expr->ts.type) && expr->ts.type != BT_CLASS)\n+    return NULL;\n+\n+  /* An explicit type was given in allocate ( T:: object).  */\n+  if (code->ext.alloc.ts.type == BT_DERIVED\n+      && (code->ext.alloc.ts.u.derived->attr.alloc_comp\n+\t  || gfc_has_default_initializer (code->ext.alloc.ts.u.derived)))\n+    return gfc_default_initializer (&code->ext.alloc.ts);\n+\n+  if (gfc_bt_struct (expr->ts.type)\n+      && (expr->ts.u.derived->attr.alloc_comp\n+\t  || gfc_has_default_initializer (expr->ts.u.derived)))\n+    return gfc_default_initializer (&expr->ts);\n+\n+  if (expr->ts.type == BT_CLASS\n+      && (CLASS_DATA (expr)->ts.u.derived->attr.alloc_comp\n+\t  || gfc_has_default_initializer (CLASS_DATA (expr)->ts.u.derived)))\n+    return gfc_default_initializer (&CLASS_DATA (expr)->ts);\n+\n+  return NULL;\n+}\n+\n /* Translate the ALLOCATE statement.  */\n \n tree\n gfc_trans_allocate (gfc_code * code)\n {\n   gfc_alloc *al;\n-  gfc_expr *expr, *e3rhs = NULL;\n+  gfc_expr *expr, *e3rhs = NULL, *init_expr;\n   gfc_se se, se_sz;\n   tree tmp;\n   tree parm;\n@@ -6080,14 +6108,6 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t      label_finish, expr, 0);\n \t  else\n \t    gfc_allocate_using_malloc (&se.pre, se.expr, memsz, stat);\n-\n-\t  if (al->expr->ts.type == BT_DERIVED\n-\t      && expr->ts.u.derived->attr.alloc_comp)\n-\t    {\n-\t      tmp = build_fold_indirect_ref_loc (input_location, se.expr);\n-\t      tmp = gfc_nullify_alloc_comp (expr->ts.u.derived, tmp, 0);\n-\t      gfc_add_expr_to_block (&se.pre, tmp);\n-\t    }\n \t}\n       else\n \t{\n@@ -6217,6 +6237,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t    fold_convert (TREE_TYPE (al_len),\n \t\t\t\t\t  integer_zero_node));\n \t}\n+\n+      init_expr = NULL;\n       if (code->expr3 && !code->expr3->mold && e3_is != E3_MOLD)\n \t{\n \t  /* Initialization via SOURCE block (or static default initializer).\n@@ -6246,6 +6268,23 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_free_statements (ini);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n+      else if ((init_expr = allocate_get_initializer (code, expr)))\n+\t{\n+\t  /* Use class_init_assign to initialize expr.  */\n+\t  gfc_code *ini;\n+\t  int realloc_lhs = flag_realloc_lhs;\n+\t  ini = gfc_get_code (EXEC_INIT_ASSIGN);\n+\t  ini->expr1 = gfc_expr_to_initialize (expr);\n+\t  ini->expr2 = init_expr;\n+\t  flag_realloc_lhs = 0;\n+\t  tmp= gfc_trans_init_assign (ini);\n+\t  flag_realloc_lhs = realloc_lhs;\n+\t  gfc_free_statements (ini);\n+\t  /* Init_expr is freeed by above free_statements, just need to null\n+\t     it here.  */\n+\t  init_expr = NULL;\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n \n       gfc_free_expr (expr);\n     } // for-loop"}, {"sha": "c58fb94966b54fa0f2860e1da98314e275bc6a3c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -1,3 +1,8 @@\n+2016-11-06  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/allocate_with_source_14.f03: Fixed number mallocs\n+\toccuring.\n+\n 2016-11-06  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/78221"}, {"sha": "fd2db7439fe0268e42d290b85662df80ba70b164", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_14.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_14.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_14.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_14.f03?ref=cc03bf7a7bf6bb0a11f7fa90ead51eec7d770af9", "patch": "@@ -210,5 +210,5 @@ program main\n   call v%free()\n   deallocate(av)\n end program\n-! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 23 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 22 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"__builtin_free\" 29 \"original\" } }"}]}