{"sha": "14cf68d935bbe7e74d01ef08da9540a08423dd12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRjZjY4ZDkzNWJiZTdlNzRkMDFlZjA4ZGE5NTQwYTA4NDIzZGQxMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-10-28T13:52:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-10-28T13:52:20Z"}, "message": "tree.c (free_lang_data_in_type): Do not call get_alias_set.\n\n2009-10-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.c (free_lang_data_in_type): Do not call get_alias_set.\n\t(free_lang_data): Unconditionally compute alias sets for all\n\tstandard integer types.  Bail out if gate bailed out previously.\n\tDo not reset the types_compatible_p langhook.\n\t(gate_free_lang_data): Remove.\n\t(struct pass_ipa_free_lang_data): Enable unconditionally.\n\t* gimple.c (gimple_get_alias_set): Use the same alias-set for\n\tall pointer types.\n\nFrom-SVN: r153659", "tree": {"sha": "173b119f1eca7e90448f2b336299d2a06df7254e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/173b119f1eca7e90448f2b336299d2a06df7254e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14cf68d935bbe7e74d01ef08da9540a08423dd12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cf68d935bbe7e74d01ef08da9540a08423dd12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14cf68d935bbe7e74d01ef08da9540a08423dd12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cf68d935bbe7e74d01ef08da9540a08423dd12/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69ba91edf437188d6fb6522153903144353c0f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ba91edf437188d6fb6522153903144353c0f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ba91edf437188d6fb6522153903144353c0f61"}], "stats": {"total": 98, "additions": 60, "deletions": 38}, "files": [{"sha": "65ca8c26ef3529444ce041c67dcebef0abcd03ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cf68d935bbe7e74d01ef08da9540a08423dd12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cf68d935bbe7e74d01ef08da9540a08423dd12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14cf68d935bbe7e74d01ef08da9540a08423dd12", "patch": "@@ -1,3 +1,14 @@\n+2009-10-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.c (free_lang_data_in_type): Do not call get_alias_set.\n+\t(free_lang_data): Unconditionally compute alias sets for all\n+\tstandard integer types.  Bail out if gate bailed out previously.\n+\tDo not reset the types_compatible_p langhook.\n+\t(gate_free_lang_data): Remove.\n+\t(struct pass_ipa_free_lang_data): Enable unconditionally.\n+\t* gimple.c (gimple_get_alias_set): Use the same alias-set for\n+\tall pointer types.\n+\n 2009-10-28  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41855"}, {"sha": "24ac0b80ac69a250430cc37b72d44b0a3aba1c37", "filename": "gcc/gimple.c", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cf68d935bbe7e74d01ef08da9540a08423dd12/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cf68d935bbe7e74d01ef08da9540a08423dd12/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=14cf68d935bbe7e74d01ef08da9540a08423dd12", "patch": "@@ -4131,7 +4131,6 @@ gimple_signed_type (tree type)\n alias_set_type\n gimple_get_alias_set (tree t)\n {\n-  static bool recursing_p;\n   tree u;\n \n   /* Permit type-punning when accessing a union, provided the access\n@@ -4171,15 +4170,9 @@ gimple_get_alias_set (tree t)\n     }\n   else if (POINTER_TYPE_P (t))\n     {\n-      tree t1;\n+      /* From the common C and C++ langhook implementation:\n \n-      /* ???  We can end up creating cycles with TYPE_MAIN_VARIANT\n-\t and TYPE_CANONICAL.  Avoid recursing endlessly between\n-\t this langhook and get_alias_set.  */\n-      if (recursing_p)\n-\treturn -1;\n-\n-      /* Unfortunately, there is no canonical form of a pointer type.\n+\t Unfortunately, there is no canonical form of a pointer type.\n \t In particular, if we have `typedef int I', then `int *', and\n \t `I *' are different types.  So, we have to pick a canonical\n \t representative.  We do this below.\n@@ -4201,15 +4194,36 @@ gimple_get_alias_set (tree t)\n \t can dereference IPP and CIPP.  So, we ignore cv-qualifiers on\n \t the pointed-to types.  This issue has been reported to the\n \t C++ committee.  */\n-      t1 = build_type_no_quals (t);\n-      if (t1 != t)\n-\t{\n-\t  alias_set_type set;\n-\t  recursing_p = true;\n-\t  set = get_alias_set (t1);\n-\t  recursing_p = false;\n-\t  return set;\n-\t}\n+\n+      /* In addition to the above canonicalization issue with LTO\n+         we should also canonicalize `T (*)[]' to `T *' avoiding\n+\t alias issues with pointer-to element types and pointer-to\n+\t array types.\n+\n+\t Likewise we need to deal with the situation of incomplete\n+\t pointed-to types and make `*(struct X **)&a' and\n+\t `*(struct X {} **)&a' alias.  Otherwise we will have to\n+\t guarantee that all pointer-to incomplete type variants\n+\t will be replaced by pointer-to complete type variants if\n+\t they are available.\n+\n+\t With LTO the convenient situation of using `void *' to\n+\t access and store any pointer type will also become\n+\t more appearant (and `void *' is just another pointer-to\n+\t incomplete type).  Assigning alias-set zero to `void *'\n+\t and all pointer-to incomplete types is a not appealing\n+\t solution.  Assigning an effective alias-set zero only\n+\t affecting pointers might be - by recording proper subset\n+\t relationships of all pointer alias-sets.\n+\n+\t Pointer-to function types are another grey area which\n+\t needs caution.  Globbing them all into one alias-set\n+\t or the above effective zero set would work.  */\n+\n+      /* For now just assign the same alias-set to all pointers.\n+         That's simple and avoids all the above problems.  */\n+      if (t != ptr_type_node)\n+\treturn get_alias_set (ptr_type_node);\n     }\n \n   return -1;"}, {"sha": "60797254fa19b35be8c23c2a6744ea79f8795deb", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cf68d935bbe7e74d01ef08da9540a08423dd12/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cf68d935bbe7e74d01ef08da9540a08423dd12/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=14cf68d935bbe7e74d01ef08da9540a08423dd12", "patch": "@@ -4171,11 +4171,6 @@ free_lang_data_in_type (tree type)\n {\n   gcc_assert (TYPE_P (type));\n \n-  /* Fill in the alias-set.  We need to at least track zeroness here\n-     for correctness.  */\n-  if (lang_hooks.get_alias_set (type) == 0)\n-    TYPE_ALIAS_SET (type) = 0;\n-\n   /* Give the FE a chance to remove its own data first.  */\n   lang_hooks.free_lang_data (type);\n \n@@ -4924,6 +4919,20 @@ free_lang_data_in_cgraph (void)\n static unsigned\n free_lang_data (void)\n {\n+  unsigned i;\n+\n+  /* Allocate and assign alias sets to the standard integer types\n+     while the slots are still in the way the frontends generated them.  */\n+  for (i = 0; i < itk_none; ++i)\n+    if (integer_types[i])\n+      TYPE_ALIAS_SET (integer_types[i]) = get_alias_set (integer_types[i]);\n+\n+  /* FIXME.  Remove after save_debug_info is working.  */\n+  if (!(flag_generate_lto\n+\t|| (!in_lto_p\n+\t    && !flag_gtoggle && debug_info_level <= DINFO_LEVEL_TERSE)))\n+    return 0;\n+\n   /* Traverse the IL resetting language specific information for\n      operands, expressions, etc.  */\n   free_lang_data_in_cgraph ();\n@@ -4951,9 +4960,9 @@ free_lang_data (void)\n   else\n     signed_char_type_node = char_type_node;\n \n-  /* Reset some langhooks.  */\n+  /* Reset some langhooks.  Do not reset types_compatible_p, it may\n+     still be used indirectly via the get_alias_set langhook.  */\n   lang_hooks.callgraph.analyze_expr = NULL;\n-  lang_hooks.types_compatible_p = NULL;\n   lang_hooks.dwarf_name = lhd_dwarf_name;\n   lang_hooks.decl_printable_name = gimple_decl_printable_name;\n   lang_hooks.set_decl_assembler_name = lhd_set_decl_assembler_name;\n@@ -4975,24 +4984,12 @@ free_lang_data (void)\n }\n \n \n-/* Gate function for free_lang_data.  */\n-\n-static bool\n-gate_free_lang_data (void)\n-{\n-  /* FIXME.  Remove after save_debug_info is working.  */\n-  return (flag_generate_lto\n-\t  || (!in_lto_p\n-\t      && !flag_gtoggle && debug_info_level <= DINFO_LEVEL_TERSE));\n-}\n-\n-\n struct simple_ipa_opt_pass pass_ipa_free_lang_data = \n {\n  {\n   SIMPLE_IPA_PASS,\n   NULL,\t\t\t\t\t/* name */\n-  gate_free_lang_data,\t\t\t/* gate */\n+  NULL,\t\t\t\t\t/* gate */\n   free_lang_data,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */"}]}