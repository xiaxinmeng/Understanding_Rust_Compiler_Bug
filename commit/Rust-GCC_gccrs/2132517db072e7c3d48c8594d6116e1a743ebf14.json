{"sha": "2132517db072e7c3d48c8594d6116e1a743ebf14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEzMjUxN2RiMDcyZTdjM2Q0OGM4NTk0ZDYxMTZlMWE3NDNlYmYxNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-02T23:11:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-12-02T23:11:17Z"}, "message": "(expand_inline_function): If called function calls alloca, save and\nrestore SP around its call.\n\nFrom-SVN: r8601", "tree": {"sha": "84dc9ac84b1f465a982486be8bb0920bb29da005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84dc9ac84b1f465a982486be8bb0920bb29da005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2132517db072e7c3d48c8594d6116e1a743ebf14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2132517db072e7c3d48c8594d6116e1a743ebf14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2132517db072e7c3d48c8594d6116e1a743ebf14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2132517db072e7c3d48c8594d6116e1a743ebf14/comments", "author": null, "committer": null, "parents": [{"sha": "83b93f40ff739b33969532e40836e45fda586665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83b93f40ff739b33969532e40836e45fda586665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83b93f40ff739b33969532e40836e45fda586665"}], "stats": {"total": 12, "additions": 12, "deletions": 0}, "files": [{"sha": "12f03890f4ca989c7a54b1d0fc630489b184922a", "filename": "gcc/integrate.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2132517db072e7c3d48c8594d6116e1a743ebf14/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2132517db072e7c3d48c8594d6116e1a743ebf14/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=2132517db072e7c3d48c8594d6116e1a743ebf14", "patch": "@@ -1167,6 +1167,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n   int nargs;\n   rtx local_return_label = 0;\n   rtx loc;\n+  rtx stack_save = 0;\n   rtx temp;\n   struct inline_remap *map;\n   rtx cc0_insn = 0;\n@@ -1648,6 +1649,13 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n   global_const_equiv_map = map->const_equiv_map;\n   global_const_equiv_map_size = map->const_equiv_map_size;\n \n+  /* If the called fucntion does an alloca, save and restore the\n+     frame pointer around the call.  This saves stack space, but\n+     also is required if this inline is being done between two\n+     pushes.  */\n+  if (FUNCTION_FLAGS (header) & FUNCTION_FLAGS_CALLS_ALLOCA)\n+    emit_stack_save (SAVE_BLOCK, &stack_save, NULL_RTX);\n+\n   /* Now copy the insns one by one.  Do this in two passes, first the insns and\n      then their REG_NOTES, just like save_for_inline.  */\n \n@@ -1868,6 +1876,10 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n   if (local_return_label)\n     emit_label (local_return_label);\n \n+  /* Restore the stack pointer if we saved it above.  */\n+  if (FUNCTION_FLAGS (header) & FUNCTION_FLAGS_CALLS_ALLOCA)\n+    emit_stack_restore (SAVE_BLOCK, stack_save, NULL_RTX);\n+\n   /* Make copies of the decls of the symbols in the inline function, so that\n      the copies of the variables get declared in the current function.  Set\n      up things so that lookup_static_chain knows that to interpret registers"}]}