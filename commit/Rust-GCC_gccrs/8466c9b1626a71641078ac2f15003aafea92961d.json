{"sha": "8466c9b1626a71641078ac2f15003aafea92961d", "node_id": "C_kwDOANBUbNoAKDg0NjZjOWIxNjI2YTcxNjQxMDc4YWMyZjE1MDAzYWFmZWE5Mjk2MWQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-22T14:34:55Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-22T14:34:55Z"}, "message": "resolver: Move Resolver methods into own source file", "tree": {"sha": "c1d186839fc21c5d8f3c3bb3744867d16998dc7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1d186839fc21c5d8f3c3bb3744867d16998dc7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8466c9b1626a71641078ac2f15003aafea92961d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8466c9b1626a71641078ac2f15003aafea92961d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8466c9b1626a71641078ac2f15003aafea92961d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8466c9b1626a71641078ac2f15003aafea92961d/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3001bb64cc25e9174cf69ad5e12df17ad45ef6b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3001bb64cc25e9174cf69ad5e12df17ad45ef6b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3001bb64cc25e9174cf69ad5e12df17ad45ef6b8"}], "stats": {"total": 684, "additions": 332, "deletions": 352}, "files": [{"sha": "723c460a97468cb676435740dc8f3a29d71611c5", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8466c9b1626a71641078ac2f15003aafea92961d/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8466c9b1626a71641078ac2f15003aafea92961d/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=8466c9b1626a71641078ac2f15003aafea92961d", "patch": "@@ -24,306 +24,12 @@\n #include \"rust-ast-resolve-expr.h\"\n #include \"rust-ast-resolve-struct-expr-field.h\"\n \n-#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X, Linemap::predeclared_location ());        \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::predeclared_location ()));          \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto builtin_type                                                        \\\n-\t= new AST::TypePath (::std::move (segs),                               \\\n-\t\t\t     Linemap::predeclared_location (), false);         \\\n-      _R.push_back (builtin_type);                                             \\\n-      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n-\t\t\t     _TY);                                             \\\n-    }                                                                          \\\n-  while (0)\n-\n extern bool\n saw_errors (void);\n \n namespace Rust {\n namespace Resolver {\n \n-// Resolver\n-\n-Resolver::Resolver ()\n-  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n-    name_scope (Scope (mappings->get_current_crate ())),\n-    type_scope (Scope (mappings->get_current_crate ())),\n-    label_scope (Scope (mappings->get_current_crate ())),\n-    macro_scope (Scope (mappings->get_current_crate ())),\n-    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n-{\n-  generate_builtins ();\n-}\n-\n-Resolver *\n-Resolver::get ()\n-{\n-  static Resolver *instance;\n-  if (instance == nullptr)\n-    instance = new Resolver ();\n-\n-  return instance;\n-}\n-\n-void\n-Resolver::push_new_name_rib (Rib *r)\n-{\n-  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n-  name_ribs[r->get_node_id ()] = r;\n-}\n-\n-void\n-Resolver::push_new_type_rib (Rib *r)\n-{\n-  if (type_ribs.size () == 0)\n-    global_type_node_id = r->get_node_id ();\n-\n-  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n-  type_ribs[r->get_node_id ()] = r;\n-}\n-\n-void\n-Resolver::push_new_label_rib (Rib *r)\n-{\n-  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n-  label_ribs[r->get_node_id ()] = r;\n-}\n-\n-void\n-Resolver::push_new_macro_rib (Rib *r)\n-{\n-  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n-  macro_ribs[r->get_node_id ()] = r;\n-}\n-\n-bool\n-Resolver::find_name_rib (NodeId id, Rib **rib)\n-{\n-  auto it = name_ribs.find (id);\n-  if (it == name_ribs.end ())\n-    return false;\n-\n-  *rib = it->second;\n-  return true;\n-}\n-\n-bool\n-Resolver::find_type_rib (NodeId id, Rib **rib)\n-{\n-  auto it = type_ribs.find (id);\n-  if (it == type_ribs.end ())\n-    return false;\n-\n-  *rib = it->second;\n-  return true;\n-}\n-\n-bool\n-Resolver::find_macro_rib (NodeId id, Rib **rib)\n-{\n-  auto it = macro_ribs.find (id);\n-  if (it == macro_ribs.end ())\n-    return false;\n-\n-  *rib = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_builtin_types (Rib *r)\n-{\n-  auto builtins = get_builtin_types ();\n-  for (auto &builtin : builtins)\n-    {\n-      CanonicalPath builtin_path\n-\t= CanonicalPath::new_seg (builtin->get_node_id (),\n-\t\t\t\t  builtin->as_string ());\n-      r->insert_name (builtin_path, builtin->get_node_id (),\n-\t\t      Linemap::predeclared_location (), false,\n-\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n-    }\n-}\n-\n-std::vector<AST::Type *> &\n-Resolver::get_builtin_types ()\n-{\n-  return builtins;\n-}\n-\n-void\n-Resolver::generate_builtins ()\n-{\n-  auto u8\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n-  auto u16\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n-  auto u32\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n-  auto u64\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U64);\n-  auto u128\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U128);\n-  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n-  auto i16\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n-  auto i32\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n-  auto i64\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I64);\n-  auto i128\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I128);\n-  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n-  auto f32\n-    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n-  auto f64\n-    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n-  auto usize = new TyTy::USizeType (mappings->get_next_hir_id ());\n-  auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n-  auto char_tyty = new TyTy::CharType (mappings->get_next_hir_id ());\n-  auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n-  auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n-\n-  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n-  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n-  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n-  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n-  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n-  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n-  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n-  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n-  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n-  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n-  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n-  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n-  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n-  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n-  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n-  MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n-  MKBUILTIN_TYPE (\"str\", builtins, str);\n-  MKBUILTIN_TYPE (\"!\", builtins, never);\n-\n-  // unit type ()\n-  TyTy::TupleType *unit_tyty\n-    = TyTy::TupleType::get_unit_type (mappings->get_next_hir_id ());\n-  std::vector<std::unique_ptr<AST::Type> > elems;\n-  AST::TupleType *unit_type\n-    = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());\n-  builtins.push_back (unit_type);\n-  tyctx->insert_builtin (unit_tyty->get_ref (), unit_type->get_node_id (),\n-\t\t\t unit_tyty);\n-  set_unit_type_node_id (unit_type->get_node_id ());\n-}\n-\n-void\n-Resolver::insert_new_definition (NodeId id, Definition def)\n-{\n-  auto it = name_definitions.find (id);\n-  if (it != name_definitions.end ())\n-    {\n-      rust_assert (it->second.is_equal (def));\n-      return;\n-    }\n-  name_definitions[id] = def;\n-}\n-\n-bool\n-Resolver::lookup_definition (NodeId id, Definition *def)\n-{\n-  auto it = name_definitions.find (id);\n-  if (it == name_definitions.end ())\n-    return false;\n-\n-  *def = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n-{\n-  resolved_names[refId] = defId;\n-  get_name_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_names.find (refId);\n-  if (it == resolved_names.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n-{\n-  // auto it = resolved_types.find (refId);\n-  // rust_assert (it == resolved_types.end ());\n-\n-  resolved_types[refId] = defId;\n-  get_type_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_types.find (refId);\n-  if (it == resolved_types.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_label (NodeId refId, NodeId defId)\n-{\n-  auto it = resolved_labels.find (refId);\n-  rust_assert (it == resolved_labels.end ());\n-\n-  resolved_labels[refId] = defId;\n-  get_label_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_labels.find (refId);\n-  if (it == resolved_labels.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_macro (NodeId refId, NodeId defId)\n-{\n-  auto it = resolved_macros.find (refId);\n-  rust_assert (it == resolved_macros.end ());\n-\n-  resolved_labels[refId] = defId;\n-  get_label_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_macros.find (refId);\n-  if (it == resolved_macros.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n // NameResolution\n \n NameResolution *"}, {"sha": "10e7297db022ac94602071add0f86eec7d876b98", "filename": "gcc/rust/resolve/rust-name-resolver.cc", "status": "modified", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8466c9b1626a71641078ac2f15003aafea92961d/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8466c9b1626a71641078ac2f15003aafea92961d/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc?ref=8466c9b1626a71641078ac2f15003aafea92961d", "patch": "@@ -17,6 +17,24 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+\n+#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      AST::PathIdentSegment seg (_X, Linemap::predeclared_location ());        \\\n+      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n+\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n+\t\t\t\t  Linemap::predeclared_location ()));          \\\n+      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n+      segs.push_back (::std::move (typePath));                                 \\\n+      auto builtin_type                                                        \\\n+\t= new AST::TypePath (::std::move (segs),                               \\\n+\t\t\t     Linemap::predeclared_location (), false);         \\\n+      _R.push_back (builtin_type);                                             \\\n+      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n+\t\t\t     _TY);                                             \\\n+  } while (0)\n \n namespace Rust {\n namespace Resolver {\n@@ -104,5 +122,314 @@ Rib::decl_was_declared_here (NodeId def) const\n   return false;\n }\n \n+Resolver::Resolver ()\n+  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n+    name_scope (Scope (mappings->get_current_crate ())),\n+    type_scope (Scope (mappings->get_current_crate ())),\n+    label_scope (Scope (mappings->get_current_crate ())),\n+    macro_scope (Scope (mappings->get_current_crate ())),\n+    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n+{\n+  generate_builtins ();\n+}\n+\n+Resolver *\n+Resolver::get ()\n+{\n+  static Resolver *instance;\n+  if (instance == nullptr)\n+    instance = new Resolver ();\n+\n+  return instance;\n+}\n+\n+void\n+Resolver::push_new_name_rib (Rib *r)\n+{\n+  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n+  name_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_type_rib (Rib *r)\n+{\n+  if (type_ribs.size () == 0)\n+    global_type_node_id = r->get_node_id ();\n+\n+  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n+  type_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_label_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  label_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_macro_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  macro_ribs[r->get_node_id ()] = r;\n+}\n+\n+bool\n+Resolver::find_name_rib (NodeId id, Rib **rib)\n+{\n+  auto it = name_ribs.find (id);\n+  if (it == name_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_type_rib (NodeId id, Rib **rib)\n+{\n+  auto it = type_ribs.find (id);\n+  if (it == type_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_macro_rib (NodeId id, Rib **rib)\n+{\n+  auto it = macro_ribs.find (id);\n+  if (it == macro_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_builtin_types (Rib *r)\n+{\n+  auto builtins = get_builtin_types ();\n+  for (auto &builtin : builtins)\n+    {\n+      CanonicalPath builtin_path\n+\t= CanonicalPath::new_seg (builtin->get_node_id (),\n+\t\t\t\t  builtin->as_string ());\n+      r->insert_name (builtin_path, builtin->get_node_id (),\n+\t\t      Linemap::predeclared_location (), false,\n+\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n+    }\n+}\n+\n+std::vector<AST::Type *> &\n+Resolver::get_builtin_types ()\n+{\n+  return builtins;\n+}\n+\n+void\n+Resolver::generate_builtins ()\n+{\n+  auto u8\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n+  auto u16\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n+  auto u32\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n+  auto u64\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U64);\n+  auto u128\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U128);\n+  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n+  auto i16\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n+  auto i32\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n+  auto i64\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I64);\n+  auto i128\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I128);\n+  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n+  auto f32\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n+  auto f64\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n+  auto usize = new TyTy::USizeType (mappings->get_next_hir_id ());\n+  auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n+  auto char_tyty = new TyTy::CharType (mappings->get_next_hir_id ());\n+  auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n+  auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n+\n+  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n+  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n+  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n+  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n+  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n+  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n+  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n+  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n+  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n+  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n+  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n+  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n+  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n+  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n+  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n+  MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n+  MKBUILTIN_TYPE (\"str\", builtins, str);\n+  MKBUILTIN_TYPE (\"!\", builtins, never);\n+\n+  // unit type ()\n+  TyTy::TupleType *unit_tyty\n+    = TyTy::TupleType::get_unit_type (mappings->get_next_hir_id ());\n+  std::vector<std::unique_ptr<AST::Type> > elems;\n+  AST::TupleType *unit_type\n+    = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());\n+  builtins.push_back (unit_type);\n+  tyctx->insert_builtin (unit_tyty->get_ref (), unit_type->get_node_id (),\n+\t\t\t unit_tyty);\n+  set_unit_type_node_id (unit_type->get_node_id ());\n+}\n+\n+void\n+Resolver::insert_new_definition (NodeId id, Definition def)\n+{\n+  auto it = name_definitions.find (id);\n+  if (it != name_definitions.end ())\n+    {\n+      rust_assert (it->second.is_equal (def));\n+      return;\n+    }\n+  name_definitions[id] = def;\n+}\n+\n+bool\n+Resolver::lookup_definition (NodeId id, Definition *def)\n+{\n+  auto it = name_definitions.find (id);\n+  if (it == name_definitions.end ())\n+    return false;\n+\n+  *def = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n+{\n+  resolved_names[refId] = defId;\n+  get_name_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  if (it == resolved_names.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n+{\n+  // auto it = resolved_types.find (refId);\n+  // rust_assert (it == resolved_types.end ());\n+\n+  resolved_types[refId] = defId;\n+  get_type_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  if (it == resolved_types.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_label (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  rust_assert (it == resolved_labels.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  if (it == resolved_labels.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_macro (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  rust_assert (it == resolved_macros.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  if (it == resolved_macros.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::mark_decl_mutability (NodeId id, bool mut)\n+{\n+  rust_assert (decl_mutability.find (id) == decl_mutability.end ());\n+  decl_mutability[id] = mut;\n+}\n+\n+bool\n+Resolver::decl_is_mutable (NodeId id) const\n+{\n+  auto it = decl_mutability.find (id);\n+  rust_assert (it != decl_mutability.end ());\n+  return it->second;\n+}\n+\n+void\n+Resolver::mark_assignment_to_decl (NodeId id, NodeId assignment)\n+{\n+  auto it = assignment_to_decl.find (id);\n+  if (it == assignment_to_decl.end ())\n+    assignment_to_decl[id] = {};\n+\n+  assignment_to_decl[id].insert (assignment);\n+}\n+\n+size_t\n+Resolver::get_num_assignments_to_decl (NodeId id) const\n+{\n+  auto it = assignment_to_decl.find (id);\n+  if (it == assignment_to_decl.end ())\n+    return 0;\n+\n+  return it->second.size ();\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e46d45591edbeb65843447cb39f8b8402f2f4e41", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 5, "deletions": 58, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8466c9b1626a71641078ac2f15003aafea92961d/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8466c9b1626a71641078ac2f15003aafea92961d/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=8466c9b1626a71641078ac2f15003aafea92961d", "patch": "@@ -199,74 +199,21 @@ class Resolver\n   void insert_resolved_macro (NodeId refId, NodeId defId);\n   bool lookup_resolved_macro (NodeId refId, NodeId *defId);\n \n+  void mark_decl_mutability (NodeId id, bool mut);\n+  bool decl_is_mutable (NodeId id) const;\n+  void mark_assignment_to_decl (NodeId id, NodeId assignment);\n+  size_t get_num_assignments_to_decl (NodeId id) const;\n+\n   // proxy for scoping\n   Scope &get_name_scope () { return name_scope; }\n   Scope &get_type_scope () { return type_scope; }\n   Scope &get_label_scope () { return label_scope; }\n   Scope &get_macro_scope () { return macro_scope; }\n \n   NodeId get_global_type_node_id () { return global_type_node_id; }\n-\n   void set_unit_type_node_id (NodeId id) { unit_ty_node_id = id; }\n   NodeId get_unit_type_node_id () { return unit_ty_node_id; }\n \n-  void mark_decl_mutability (NodeId id, bool mut)\n-  {\n-    rust_assert (decl_mutability.find (id) == decl_mutability.end ());\n-    decl_mutability[id] = mut;\n-  }\n-\n-  bool decl_is_mutable (NodeId id) const\n-  {\n-    auto it = decl_mutability.find (id);\n-    rust_assert (it != decl_mutability.end ());\n-    return it->second;\n-  }\n-\n-  void mark_assignment_to_decl (NodeId id, NodeId assignment)\n-  {\n-    auto it = assignment_to_decl.find (id);\n-    if (it == assignment_to_decl.end ())\n-      assignment_to_decl[id] = {};\n-\n-    assignment_to_decl[id].insert (assignment);\n-  }\n-\n-  size_t get_num_assignments_to_decl (NodeId id) const\n-  {\n-    auto it = assignment_to_decl.find (id);\n-    if (it == assignment_to_decl.end ())\n-      return 0;\n-\n-    return it->second.size ();\n-  }\n-\n-  void iterate_name_ribs (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = name_ribs.begin (); it != name_ribs.end (); it++)\n-      if (!cb (it->second))\n-\tbreak;\n-  }\n-\n-  void iterate_type_ribs (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = type_ribs.begin (); it != type_ribs.end (); it++)\n-      {\n-\tif (it->first == global_type_node_id)\n-\t  continue;\n-\n-\tif (!cb (it->second))\n-\t  break;\n-      }\n-  }\n-\n-  void iterate_label_ribs (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = label_ribs.begin (); it != label_ribs.end (); it++)\n-      if (!cb (it->second))\n-\tbreak;\n-  }\n-\n private:\n   Resolver ();\n "}]}