{"sha": "ac5ba373739e0fbfd2385e5fa427629ce328e718", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM1YmEzNzM3MzllMGZiZmQyMzg1ZTVmYTQyNzYyOWNlMzI4ZTcxOA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-10-06T08:55:30Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2007-10-06T08:55:30Z"}, "message": "re PR fortran/25076 (FORALL triplet subscript must not reference any index-name)\n\nPR fortran/25076\nfortran/\n* resolve.c (gfc_find_forall_index): Move towards top,\nrenaming to ...\n(find_forall_index): ... this.  Add check for NULL expr.\n(resolve_forall_iterators): Verify additional constraint.\n(resolve_forall): Remove checks obsoleted by new code in\nresolve_forall_iterators.\ntestsuite/\n* gfortran.dg/forall_11.f90: New.\n\nFrom-SVN: r129050", "tree": {"sha": "0814b58da2ed631921edc7fd958813d9ab83b435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0814b58da2ed631921edc7fd958813d9ab83b435"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac5ba373739e0fbfd2385e5fa427629ce328e718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5ba373739e0fbfd2385e5fa427629ce328e718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac5ba373739e0fbfd2385e5fa427629ce328e718", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5ba373739e0fbfd2385e5fa427629ce328e718/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6116ca65ddba06d9fb1cb85b26ac75964a63f684", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6116ca65ddba06d9fb1cb85b26ac75964a63f684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6116ca65ddba06d9fb1cb85b26ac75964a63f684"}], "stats": {"total": 342, "additions": 199, "deletions": 143}, "files": [{"sha": "9093bed87ac98c7203adf3820ed0fe2e9c229135", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ac5ba373739e0fbfd2385e5fa427629ce328e718", "patch": "@@ -1,3 +1,13 @@\n+2007-10-06  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/25076\n+\t* resolve.c (gfc_find_forall_index): Move towards top,\n+\trenaming to ...\n+\t(find_forall_index): ... this.  Add check for NULL expr.\n+\t(resolve_forall_iterators): Verify additional constraint.\n+\t(resolve_forall): Remove checks obsoleted by new code in\n+\tresolve_forall_iterators.\n+\n 2007-10-05  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* gfortran.h (gfc_get_data_variable, gfc_get_data_value,"}, {"sha": "50164f66949ebab795fe9d8d231cb681e65afcd9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 151, "deletions": 143, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=ac5ba373739e0fbfd2385e5fa427629ce328e718", "patch": "@@ -4296,14 +4296,147 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n }\n \n \n+/* Check whether the FORALL index appears in the expression or not.\n+   Returns SUCCESS if SYM is found in EXPR.  */\n+\n+static try\n+find_forall_index (gfc_expr *expr, gfc_symbol *symbol)\n+{\n+  gfc_array_ref ar;\n+  gfc_ref *tmp;\n+  gfc_actual_arglist *args;\n+  int i;\n+\n+  if (!expr)\n+    return FAILURE;\n+\n+  switch (expr->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      gcc_assert (expr->symtree->n.sym);\n+\n+      /* A scalar assignment  */\n+      if (!expr->ref)\n+\t{\n+\t  if (expr->symtree->n.sym == symbol)\n+\t    return SUCCESS;\n+\t  else\n+\t    return FAILURE;\n+\t}\n+\n+      /* the expr is array ref, substring or struct component.  */\n+      tmp = expr->ref;\n+      while (tmp != NULL)\n+\t{\n+\t  switch (tmp->type)\n+\t    {\n+\t    case  REF_ARRAY:\n+\t      /* Check if the symbol appears in the array subscript.  */\n+\t      ar = tmp->u.ar;\n+\t      for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n+\t\t{\n+\t\t  if (ar.start[i])\n+\t\t    if (find_forall_index (ar.start[i], symbol) == SUCCESS)\n+\t\t      return SUCCESS;\n+\n+\t\t  if (ar.end[i])\n+\t\t    if (find_forall_index (ar.end[i], symbol) == SUCCESS)\n+\t\t      return SUCCESS;\n+\n+\t\t  if (ar.stride[i])\n+\t\t    if (find_forall_index (ar.stride[i], symbol) == SUCCESS)\n+\t\t      return SUCCESS;\n+\t\t}  /* end for  */\n+\t      break;\n+\n+\t    case REF_SUBSTRING:\n+\t      if (expr->symtree->n.sym == symbol)\n+\t\treturn SUCCESS;\n+\t      tmp = expr->ref;\n+\t      /* Check if the symbol appears in the substring section.  */\n+\t      if (find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n+\t\treturn SUCCESS;\n+\t      if (find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n+\t\treturn SUCCESS;\n+\t      break;\n+\n+\t    case REF_COMPONENT:\n+\t      break;\n+\n+\t    default:\n+\t      gfc_error(\"expression reference type error at %L\", &expr->where);\n+\t    }\n+\t  tmp = tmp->next;\n+\t}\n+      break;\n+\n+    /* If the expression is a function call, then check if the symbol\n+       appears in the actual arglist of the function.  */\n+    case EXPR_FUNCTION:\n+      for (args = expr->value.function.actual; args; args = args->next)\n+\t{\n+\t  if (find_forall_index(args->expr,symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t}\n+      break;\n+\n+    /* It seems not to happen.  */\n+    case EXPR_SUBSTRING:\n+      if (expr->ref)\n+\t{\n+\t  tmp = expr->ref;\n+\t  gcc_assert (expr->ref->type == REF_SUBSTRING);\n+\t  if (find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t  if (find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t}\n+      break;\n+\n+    /* It seems not to happen.  */\n+    case EXPR_STRUCTURE:\n+    case EXPR_ARRAY:\n+      gfc_error (\"Unsupported statement while finding forall index in \"\n+\t\t \"expression\");\n+      break;\n+\n+    case EXPR_OP:\n+      /* Find the FORALL index in the first operand.  */\n+      if (expr->value.op.op1)\n+\t{\n+\t  if (find_forall_index (expr->value.op.op1, symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t}\n+\n+      /* Find the FORALL index in the second operand.  */\n+      if (expr->value.op.op2)\n+\t{\n+\t  if (find_forall_index (expr->value.op.op2, symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return FAILURE;\n+}\n+\n+\n /* Resolve a list of FORALL iterators.  The FORALL index-name is constrained\n    to be a scalar INTEGER variable.  The subscripts and stride are scalar\n-   INTEGERs, and if stride is a constant it must be nonzero.  */\n+   INTEGERs, and if stride is a constant it must be nonzero.\n+   Furthermore \"A subscript or stride in a forall-triplet-spec shall\n+   not contain a reference to any index-name in the\n+   forall-triplet-spec-list in which it appears.\" (7.5.4.1)  */\n \n static void\n-resolve_forall_iterators (gfc_forall_iterator *iter)\n+resolve_forall_iterators (gfc_forall_iterator *it)\n {\n-  while (iter)\n+  gfc_forall_iterator *iter, *iter2;\n+\n+  for (iter = it; iter; iter = iter->next)\n     {\n       if (gfc_resolve_expr (iter->var) == SUCCESS\n \t  && (iter->var->ts.type != BT_INTEGER || iter->var->rank != 0))\n@@ -4337,9 +4470,21 @@ resolve_forall_iterators (gfc_forall_iterator *iter)\n \t}\n       if (iter->var->ts.kind != iter->stride->ts.kind)\n \tgfc_convert_type (iter->stride, &iter->var->ts, 2);\n-\n-      iter = iter->next;\n     }\n+\n+  for (iter = it; iter; iter = iter->next)\n+    for (iter2 = iter; iter2; iter2 = iter2->next)\n+      {\n+\tif (find_forall_index (iter2->start,\n+\t\t\t       iter->var->symtree->n.sym) == SUCCESS\n+\t    || find_forall_index (iter2->end,\n+\t\t\t\t  iter->var->symtree->n.sym) == SUCCESS\n+\t    || find_forall_index (iter2->stride,\n+\t\t\t\t  iter->var->symtree->n.sym) == SUCCESS)\n+\t  gfc_error (\"FORALL index '%s' may not appear in triplet \"\n+\t\t     \"specification at %L\", iter->var->symtree->name,\n+\t\t     &iter2->start->where);\n+      }\n }\n \n \n@@ -5529,130 +5674,6 @@ resolve_where (gfc_code *code, gfc_expr *mask)\n }\n \n \n-/* Check whether the FORALL index appears in the expression or not.  */\n-\n-static try\n-gfc_find_forall_index (gfc_expr *expr, gfc_symbol *symbol)\n-{\n-  gfc_array_ref ar;\n-  gfc_ref *tmp;\n-  gfc_actual_arglist *args;\n-  int i;\n-\n-  switch (expr->expr_type)\n-    {\n-    case EXPR_VARIABLE:\n-      gcc_assert (expr->symtree->n.sym);\n-\n-      /* A scalar assignment  */\n-      if (!expr->ref)\n-\t{\n-\t  if (expr->symtree->n.sym == symbol)\n-\t    return SUCCESS;\n-\t  else\n-\t    return FAILURE;\n-\t}\n-\n-      /* the expr is array ref, substring or struct component.  */\n-      tmp = expr->ref;\n-      while (tmp != NULL)\n-\t{\n-\t  switch (tmp->type)\n-\t    {\n-\t    case  REF_ARRAY:\n-\t      /* Check if the symbol appears in the array subscript.  */\n-\t      ar = tmp->u.ar;\n-\t      for (i = 0; i < GFC_MAX_DIMENSIONS; i++)\n-\t\t{\n-\t\t  if (ar.start[i])\n-\t\t    if (gfc_find_forall_index (ar.start[i], symbol) == SUCCESS)\n-\t\t      return SUCCESS;\n-\n-\t\t  if (ar.end[i])\n-\t\t    if (gfc_find_forall_index (ar.end[i], symbol) == SUCCESS)\n-\t\t      return SUCCESS;\n-\n-\t\t  if (ar.stride[i])\n-\t\t    if (gfc_find_forall_index (ar.stride[i], symbol) == SUCCESS)\n-\t\t      return SUCCESS;\n-\t\t}  /* end for  */\n-\t      break;\n-\n-\t    case REF_SUBSTRING:\n-\t      if (expr->symtree->n.sym == symbol)\n-\t\treturn SUCCESS;\n-\t      tmp = expr->ref;\n-\t      /* Check if the symbol appears in the substring section.  */\n-\t      if (gfc_find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n-\t\treturn SUCCESS;\n-\t      if (gfc_find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n-\t\treturn SUCCESS;\n-\t      break;\n-\n-\t    case REF_COMPONENT:\n-\t      break;\n-\n-\t    default:\n-\t      gfc_error(\"expression reference type error at %L\", &expr->where);\n-\t    }\n-\t  tmp = tmp->next;\n-\t}\n-      break;\n-\n-    /* If the expression is a function call, then check if the symbol\n-       appears in the actual arglist of the function.  */\n-    case EXPR_FUNCTION:\n-      for (args = expr->value.function.actual; args; args = args->next)\n-\t{\n-\t  if (gfc_find_forall_index(args->expr,symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-      break;\n-\n-    /* It seems not to happen.  */\n-    case EXPR_SUBSTRING:\n-      if (expr->ref)\n-\t{\n-\t  tmp = expr->ref;\n-\t  gcc_assert (expr->ref->type == REF_SUBSTRING);\n-\t  if (gfc_find_forall_index (tmp->u.ss.start, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t  if (gfc_find_forall_index (tmp->u.ss.end, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-      break;\n-\n-    /* It seems not to happen.  */\n-    case EXPR_STRUCTURE:\n-    case EXPR_ARRAY:\n-      gfc_error (\"Unsupported statement while finding forall index in \"\n-\t\t \"expression\");\n-      break;\n-\n-    case EXPR_OP:\n-      /* Find the FORALL index in the first operand.  */\n-      if (expr->value.op.op1)\n-\t{\n-\t  if (gfc_find_forall_index (expr->value.op.op1, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-\n-      /* Find the FORALL index in the second operand.  */\n-      if (expr->value.op.op2)\n-\t{\n-\t  if (gfc_find_forall_index (expr->value.op.op2, symbol) == SUCCESS)\n-\t    return SUCCESS;\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return FAILURE;\n-}\n-\n-\n /* Resolve assignment in FORALL construct.\n    NVAR is the number of FORALL index variables, and VAR_EXPR records the\n    FORALL index variables.  */\n@@ -5679,7 +5700,7 @@ gfc_resolve_assign_in_forall (gfc_code *code, int nvar, gfc_expr **var_expr)\n \t  /* If one of the FORALL index variables doesn't appear in the\n \t     assignment target, then there will be a many-to-one\n \t     assignment.  */\n-\t  if (gfc_find_forall_index (code->expr, forall_index) == FAILURE)\n+\t  if (find_forall_index (code->expr, forall_index) == FAILURE)\n \t    gfc_error (\"The FORALL with index '%s' cause more than one \"\n \t\t       \"assignment to this object at %L\",\n \t\t       var_expr[n]->symtree->name, &code->expr->where);\n@@ -5785,7 +5806,6 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n   static int total_var = 0;\n   static int nvar = 0;\n   gfc_forall_iterator *fa;\n-  gfc_symbol *forall_index;\n   gfc_code *next;\n   int i;\n \n@@ -5824,18 +5844,6 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n       /* Record the current FORALL index.  */\n       var_expr[nvar] = gfc_copy_expr (fa->var);\n \n-      forall_index = fa->var->symtree->n.sym;\n-\n-      /* Check if the FORALL index appears in start, end or stride.  */\n-      if (gfc_find_forall_index (fa->start, forall_index) == SUCCESS)\n-\tgfc_error (\"A FORALL index must not appear in a limit or stride \"\n-\t\t   \"expression in the same FORALL at %L\", &fa->start->where);\n-      if (gfc_find_forall_index (fa->end, forall_index) == SUCCESS)\n-\tgfc_error (\"A FORALL index must not appear in a limit or stride \"\n-\t\t   \"expression in the same FORALL at %L\", &fa->end->where);\n-      if (gfc_find_forall_index (fa->stride, forall_index) == SUCCESS)\n-\tgfc_error (\"A FORALL index must not appear in a limit or stride \"\n-\t\t   \"expression in the same FORALL at %L\", &fa->stride->where);\n       nvar++;\n     }\n "}, {"sha": "bb6a5886348b3acf3417ca7574300d39453d0ecb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac5ba373739e0fbfd2385e5fa427629ce328e718", "patch": "@@ -1,3 +1,8 @@\n+2007-10-06  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/25076\n+\t* gfortran.dg/forall_11.f90: New.\n+\n 2007-10-05  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/33667"}, {"sha": "4c556951c7e1f04b9e9717696cc7e3550fa95500", "filename": "gcc/testsuite/gfortran.dg/forall_11.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac5ba373739e0fbfd2385e5fa427629ce328e718/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fforall_11.f90?ref=ac5ba373739e0fbfd2385e5fa427629ce328e718", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! PR 25076\n+! We erroneously accepted it when a FORALL index was used in a triplet\n+! specification within the same FORALL header\n+INTEGER :: A(10,10)\n+FORALL(I=1:10,J=I:10) ! { dg-error \"FORALL index 'i' may not appear in triplet specification\" }\n+  A(I,J)=I+J\n+ENDFORALL\n+\n+forall (i=1:10, j=1:i)  ! { dg-error \"FORALL index 'i' may not appear in triplet specification\" }\n+   a(i,j) = 5\n+end forall\n+\n+forall (i=1:10, j=1:10:i)  ! { dg-error \"FORALL index 'i' may not appear in triplet specification\" }\n+   a(i,j) = i - j\n+end forall\n+\n+forall (i=i:10) ! { dg-error \"FORALL index 'i' may not appear in triplet specification\" }\n+   forall (j=1:j:i)  !  { dg-error \"FORALL index 'j' may not appear in triplet specification\" }\n+      a(i,j) = i*j\n+   end forall\n+end forall\n+\n+forall (i=1:10:i) ! { dg-error \"FORALL index 'i' may not appear in triplet specification\" }\n+   a(1,i) = 2\n+end forall\n+\n+forall (i=1:10)\n+   forall (j=i:10)\n+      a(i,j) = i*j\n+   end forall\n+end forall\n+END"}]}