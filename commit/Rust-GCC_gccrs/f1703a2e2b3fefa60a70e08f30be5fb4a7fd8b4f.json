{"sha": "f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3MDNhMmUyYjNmZWZhNjBhNzBlMDhmMzBiZTVmYjRhN2ZkOGI0Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-29T22:33:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-29T22:33:23Z"}, "message": "cgraph.c (cgraph_node::make_local): No name is unique during incremental linking.\n\n\n\t* cgraph.c (cgraph_node::make_local): No name is unique during\n\tincremental linking.\n\t* cgraph.h (can_be_discarded_p): Update comment; also common and\n\tWEAK in named sections can be discarded; when doing incremental\n\tlink do not rely on resolution being the final one.\n\t* varasm.c (default_binds_local_p_3, decl_binds_to_current_def_p):\n\tWhen symbol can be discarded, do not rely on resolution info.\n\t* symtab.c (symtab_node::nonzero_address): Take into account that\n\tsymbol can be discarded.\n\t* ipa-visibility.c (update_visibility_by_resolution_info): Handle\n\tdefinition correctly.\n\t(function_and_variable_visibility): Do not set unique_name when\n\tincrementally linking.\n\nFrom-SVN: r231050", "tree": {"sha": "b119bcfa394a1eeb2b5f120d0165f4e631cf136b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b119bcfa394a1eeb2b5f120d0165f4e631cf136b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/comments", "author": null, "committer": null, "parents": [{"sha": "a4850ce9b58d12158248dc7fbe1015646757c813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4850ce9b58d12158248dc7fbe1015646757c813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4850ce9b58d12158248dc7fbe1015646757c813"}], "stats": {"total": 85, "additions": 58, "deletions": 27}, "files": [{"sha": "3f6024ee3aef63c20fbb3e43308bb890668bc58b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "patch": "@@ -1,3 +1,19 @@\n+2015-11-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_node::make_local): No name is unique during\n+\tincremental linking.\n+\t* cgraph.h (can_be_discarded_p): Update comment; also common and\n+\tWEAK in named sections can be discarded; when doing incremental\n+\tlink do not rely on resolution being the final one.\n+\t* varasm.c (default_binds_local_p_3, decl_binds_to_current_def_p):\n+\tWhen symbol can be discarded, do not rely on resolution info.\n+\t* symtab.c (symtab_node::nonzero_address): Take into account that\n+\tsymbol can be discarded.\n+\t* ipa-visibility.c (update_visibility_by_resolution_info): Handle\n+\tdefinition correctly.\n+\t(function_and_variable_visibility): Do not set unique_name when\n+\tincrementally linking.\n+\n 2015-11-29  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.md (const_0_operand, global_mem_operand,"}, {"sha": "3ee1907c33569a89f606b8a29e99e7b3f9ed9afa", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "patch": "@@ -2253,8 +2253,9 @@ cgraph_node::make_local (cgraph_node *node, void *)\n       node->forced_by_abi = false;\n       node->local.local = true;\n       node->set_section (NULL);\n-      node->unique_name = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t  || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n+      node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t   || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t   && !flag_incremental_link);\n       node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n       gcc_assert (node->get_availability () == AVAIL_LOCAL);\n     }"}, {"sha": "6cff4468cc0b09c71f79b8c862f9d218f06c9046", "filename": "gcc/cgraph.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "patch": "@@ -319,15 +319,23 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return true when there are references to the node.  */\n   bool referred_to_p (bool include_self = true);\n \n-  /* Return true if NODE can be discarded by linker from the binary.  */\n+  /* Return true if symbol can be discarded by linker from the binary.\n+     Assume that symbol is used (so there is no need to take into account\n+     garbage collecting linkers)\n+\n+     This can happen for comdats, commons and weaks when they are previaled\n+     by other definition at static linking time.  */\n   inline bool\n   can_be_discarded_p (void)\n   {\n     return (DECL_EXTERNAL (decl)\n-\t    || (get_comdat_group ()\n-\t\t&& resolution != LDPR_PREVAILING_DEF\n-\t\t&& resolution != LDPR_PREVAILING_DEF_IRONLY\n-\t\t&& resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n+\t    || ((get_comdat_group ()\n+\t\t || DECL_COMMON (decl)\n+\t\t || (DECL_SECTION_NAME (decl) && DECL_WEAK (decl)))\n+\t\t&& ((resolution != LDPR_PREVAILING_DEF\n+\t\t     && resolution != LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t    || flag_incremental_link)\n+\t\t&& resolution != LDPR_PREVAILING_DEF_IRONLY));\n   }\n \n   /* Return true if NODE is local to a particular COMDAT group, and must not"}, {"sha": "2eab214243e94dd446f657e56f729ee539f500d3", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "patch": "@@ -413,10 +413,10 @@ update_visibility_by_resolution_info (symtab_node * node)\n \t    DECL_WEAK (next->decl) = false;\n \t    next->set_comdat_group (NULL);\n \t  }\n-\tif (next->externally_visible\n-\t    && !define)\n+\tif (!define)\n \t  {\n-\t    DECL_EXTERNAL (next->decl) = true;\n+\t    if (next->externally_visible)\n+\t      DECL_EXTERNAL (next->decl) = true;\n \t    next->set_comdat_group (NULL);\n \t  }\n       }\n@@ -513,10 +513,10 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  gcc_assert (whole_program || in_lto_p\n \t\t      || !TREE_PUBLIC (node->decl));\n-\t  node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t|| node->unique_name\n-\t\t\t\t|| node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t&& TREE_PUBLIC (node->decl));\n+\t  node->unique_name |= ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t&& TREE_PUBLIC (node->decl)\n+\t\t\t\t&& !flag_incremental_link);\n \t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t  if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n \t    {\n@@ -532,10 +532,10 @@ function_and_variable_visibility (bool whole_program)\n \t\t  if (!next->alias)\n \t\t    next->set_section (NULL);\n \t\t  next->make_decl_local ();\n-\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t\t|| next->unique_name\n-\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (next->decl));\n+\t\t  next->unique_name |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t\t || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t        && TREE_PUBLIC (next->decl)\n+\t\t\t\t\t&& !flag_incremental_link);\n \t\t}\n \t      /* cgraph_externally_visible_p has already checked all other nodes\n \t         in the group and they will all be made local.  We need to\n@@ -657,10 +657,11 @@ function_and_variable_visibility (bool whole_program)\n \t  && !vnode->weakref)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n-\t  vnode->unique_name = ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t         || vnode->resolution\n+\t  vnode->unique_name |= ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t          || vnode->resolution\n \t\t\t\t      == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t        && TREE_PUBLIC (vnode->decl));\n+\t\t\t         && TREE_PUBLIC (vnode->decl)\n+\t\t\t\t && !flag_incremental_link);\n \t  if (vnode->same_comdat_group && TREE_PUBLIC (vnode->decl))\n \t    {\n \t      symtab_node *next = vnode;\n@@ -675,10 +676,10 @@ function_and_variable_visibility (bool whole_program)\n \t\t  if (!next->alias)\n \t\t    next->set_section (NULL);\n \t\t  next->make_decl_local ();\n-\t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t\t|| next->unique_name\n-\t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t       && TREE_PUBLIC (next->decl));\n+\t\t  next->unique_name |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t\t || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t        && TREE_PUBLIC (next->decl)\n+\t\t\t\t\t&& !flag_incremental_link);\n \t\t}\n \t      vnode->dissolve_same_comdat_group_list ();\n \t    }"}, {"sha": "c188710ea92af35e4654fd0910b3459d91e68a13", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "patch": "@@ -1713,6 +1713,7 @@ symtab_node::nonzero_address ()\n \t      return true;\n \t  if (target->resolution != LDPR_UNKNOWN\n \t      && target->resolution != LDPR_UNDEF\n+\t      && !target->can_be_discarded_p ()\n \t      && flag_delete_null_pointer_checks)\n \t    return true;\n \t  return false;\n@@ -1751,6 +1752,7 @@ symtab_node::nonzero_address ()\n   /* As the last resort, check the resolution info.  */\n   if (resolution != LDPR_UNKNOWN\n       && resolution != LDPR_UNDEF\n+      && !can_be_discarded_p ()\n       && flag_delete_null_pointer_checks)\n     return true;\n   return false;"}, {"sha": "c4c55e7cd06fd1cec6d3664ffe9cacd007a58a6d", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f1703a2e2b3fefa60a70e08f30be5fb4a7fd8b4f", "patch": "@@ -6837,7 +6837,9 @@ default_binds_local_p_3 (const_tree exp, bool shlib, bool weak_dominate,\n     {\n       if (node->in_other_partition)\n \tdefined_locally = true;\n-      if (resolution_to_local_definition_p (node->resolution))\n+      if (node->can_be_discarded_p ())\n+\t;\n+      else if (resolution_to_local_definition_p (node->resolution))\n \tdefined_locally = resolved_locally = true;\n       else if (resolution_local_p (node->resolution))\n \tresolved_locally = true;\n@@ -6930,7 +6932,8 @@ decl_binds_to_current_def_p (const_tree decl)\n   /* When resolution is available, just use it.  */\n   if (symtab_node *node = symtab_node::get (decl))\n     {\n-      if (node->resolution != LDPR_UNKNOWN)\n+      if (node->resolution != LDPR_UNKNOWN\n+\t  && !node->can_be_discarded_p ())\n \treturn resolution_to_local_definition_p (node->resolution);\n     }\n "}]}