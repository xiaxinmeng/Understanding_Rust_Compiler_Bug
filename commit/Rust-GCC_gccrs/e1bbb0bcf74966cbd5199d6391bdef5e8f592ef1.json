{"sha": "e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiYmIwYmNmNzQ5NjZjYmQ1MTk5ZDYzOTFiZGVmNWU4ZjU5MmVmMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2019-02-05T06:11:25Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-02-05T06:11:25Z"}, "message": "[PR87770] test partial specializations for type dependence\n\nWhen instantiating a partial specialization of a template member\nfunction for a full specialization of a class template, we test\nwhether the context of variables local to the partial specialization,\ni.e., the partial specialization itself, is dependent, and this ICEs\nin type_dependent_expression_p, when checking that the function type\nisn't type-dependent because it is not in a type-dependent scope.\n\nWe shouldn't have got that far: the previous block in\ntype_dependent_expression_p catches cases in which the function itself\ntakes template arguments of its own, but it only did so for primary\ntemplates, not for partial specializations.  This patch fixes that.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/87770\n\t* pt.c (instantiates_primary_template_p): New.\n\t(type_dependent_expression_p): Use it.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR c++/87770\n\t* g++.dg/pr87770.C: New.\n\nFrom-SVN: r268529", "tree": {"sha": "743a7747d3c6a4ce4c8fdd73e126c6da2f16539c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/743a7747d3c6a4ce4c8fdd73e126c6da2f16539c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/comments", "author": null, "committer": null, "parents": [{"sha": "ca0107a731027066b62a78d9d8c9bd0e7084b8fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0107a731027066b62a78d9d8c9bd0e7084b8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0107a731027066b62a78d9d8c9bd0e7084b8fa"}], "stats": {"total": 54, "additions": 53, "deletions": 1}, "files": [{"sha": "65a850fc53c8d5abeb66b60ad7388877d2f2e382", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "patch": "@@ -1,3 +1,9 @@\n+2019-02-05  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/87770\n+\t* pt.c (instantiates_primary_template_p): New.\n+\t(type_dependent_expression_p): Use it.\n+\n 2019-02-01  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/88761 - ICE with reference capture of constant."}, {"sha": "b8fbf4046f0790c0262fec99ddf0c2d2cd411f43", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "patch": "@@ -400,6 +400,36 @@ template_class_depth (tree type)\n   return depth;\n }\n \n+/* Return TRUE if NODE instantiates a template that has arguments of\n+   its own, be it directly a primary template or indirectly through a\n+   partial specializations.  */\n+static bool\n+instantiates_primary_template_p (tree node)\n+{\n+  tree tinfo = get_template_info (node);\n+  if (!tinfo)\n+    return false;\n+\n+  tree tmpl = TI_TEMPLATE (tinfo);\n+  if (PRIMARY_TEMPLATE_P (tmpl))\n+    return true;\n+\n+  if (!DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+    return false;\n+\n+  /* So now we know we have a specialization, but it could be a full\n+     or a partial specialization.  To tell which, compare the depth of\n+     its template arguments with those of its context.  */\n+\n+  tree ctxt = DECL_CONTEXT (tmpl);\n+  tree ctinfo = get_template_info (ctxt);\n+  if (!ctinfo)\n+    return true;\n+\n+  return (TMPL_ARGS_DEPTH (TI_ARGS (tinfo))\n+\t  > TMPL_ARGS_DEPTH (TI_ARGS (ctinfo)));\n+}\n+\n /* Subroutine of maybe_begin_member_template_processing.\n    Returns true if processing DECL needs us to push template parms.  */\n \n@@ -25683,7 +25713,7 @@ type_dependent_expression_p (tree expression)\n \t that come from the template-id; the template arguments for the\n \t enclosing class do not make it type-dependent unless they are used in\n \t the type of the decl.  */\n-      if (PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (expression))\n+      if (instantiates_primary_template_p (expression)\n \t  && (any_dependent_template_arguments_p\n \t      (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n \treturn true;"}, {"sha": "8a77c005c3bf391b5163491078a1472d814ee642", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "patch": "@@ -1,3 +1,8 @@\n+2019-02-05  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/87770\n+\t* g++.dg/pr87770.C: New.\n+\n 2019-02-04  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/89077"}, {"sha": "69eff4a786fefc19c312efdd51edb305fe3a5e25", "filename": "gcc/testsuite/g++.dg/pr87770.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr87770.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr87770.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr87770.C?ref=e1bbb0bcf74966cbd5199d6391bdef5e8f592ef1", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+template <typename> struct d {\n+  template <typename e> d(e);\n+};\n+template <> template <typename e> d<int>::d(e);\n+template <> template <typename e> d<int>::d(e) {\n+  long g;\n+  (void)g;\n+}\n+template d<int>::d(char);"}]}