{"sha": "d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdiYjc0OWEzZDZkNTg0MWI2NGQwNDIwYTNhZmYzYTU1OGY4OGUxZQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2002-09-29T18:16:15Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-09-29T18:16:15Z"}, "message": "sibcall-1.c, [...]: New tests.\n\n\t* gcc.dg/sibcall-1.c, gcc.dg/sibcall-2.c, gcc.dg/sibcall-3.c,\n\tgcc.dg/sibcall-4.c: New tests.\n\nFrom-SVN: r57628", "tree": {"sha": "1f8c3e212ab4d46d935609df3b6bf62207373289", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f8c3e212ab4d46d935609df3b6bf62207373289"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/comments", "author": null, "committer": null, "parents": [{"sha": "d7b52625243b9eb0f9dd5334162b0bc00cd590a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b52625243b9eb0f9dd5334162b0bc00cd590a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b52625243b9eb0f9dd5334162b0bc00cd590a0"}], "stats": {"total": 229, "additions": 229, "deletions": 0}, "files": [{"sha": "46400b6191aca96e9480941da781995e147c808d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "patch": "@@ -1,3 +1,8 @@\n+2002-09-29  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* gcc.dg/sibcall-1.c, gcc.dg/sibcall-2.c, gcc.dg/sibcall-3.c,\n+\tgcc.dg/sibcall-4.c: New tests.\n+\n 2002-09-28  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.c-torture/execute/20020720-1.x: No longer skip test on"}, {"sha": "f9b1f7899b4d7ef63d910c1f6a5c84ac39d907c6", "filename": "gcc/testsuite/gcc.dg/sibcall-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-1.c?ref=d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "patch": "@@ -0,0 +1,46 @@\n+/* Simple check that sibling calls are performed from a\n+   void non-leaf-function taking one int argument calling itself.\n+\n+   Copyright (C) 2002 Free Software Foundation Inc.\n+   Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n+\n+/* The option -foptimize-sibling-calls is the default, but serves as\n+   marker.  Self-recursion tail calls are optimized for all targets,\n+   regardless of presence of sibcall patterns.  */\n+\n+extern void recurser_void (int);\n+extern void track (int);\n+\n+int main ()\n+{\n+  recurser_void (0);\n+  exit (0);\n+}\n+\n+void\n+recurser_void (int n)\n+{\n+  if (n == 0 || n == 7)\n+    track (n);\n+\n+  if (n == 10)\n+    return;\n+\n+  recurser_void (n + 1);\n+}\n+\n+void *trackpoint;\n+\n+void\n+track (int n)\n+{\n+  char stackpos[1];\n+\n+  if (n == 0)\n+    trackpoint = stackpos;\n+  else if (n != 7 || trackpoint != stackpos)\n+    abort ();\n+}"}, {"sha": "cb2d1d599c69ae7a65f02e865b4d069360f2d268", "filename": "gcc/testsuite/gcc.dg/sibcall-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-2.c?ref=d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "patch": "@@ -0,0 +1,47 @@\n+/* Simple check that sibling calls are performed from a\n+   void non-leaf-function taking no arguments calling itself.\n+\n+   Copyright (C) 2002 Free Software Foundation Inc.\n+   Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n+\n+/* The option -foptimize-sibling-calls is the default, but serves as\n+   marker.  Self-recursion tail calls are optimized for all targets,\n+   regardless of presence of sibcall patterns.  */\n+\n+extern void recurser_void (void);\n+extern void track (void);\n+\n+int n = 0;\n+int main ()\n+{\n+  recurser_void ();\n+  exit (0);\n+}\n+\n+void\n+recurser_void (void)\n+{\n+  if (n == 0 || n == 7)\n+    track ();\n+\n+  if (n == 10)\n+    return;\n+  n++;\n+  recurser_void ();\n+}\n+\n+void *trackpoint;\n+\n+void\n+track ()\n+{\n+  char stackpos[1];\n+\n+  if (n == 0)\n+    trackpoint = stackpos;\n+  else if (n != 7 || trackpoint != stackpos)\n+    abort ();\n+}"}, {"sha": "b494b4018f249f89692959f32b872d600fc1ce38", "filename": "gcc/testsuite/gcc.dg/sibcall-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c?ref=d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "patch": "@@ -0,0 +1,65 @@\n+/* Simple check that sibling calls are performed from a\n+   void non-leaf-function taking one int argument calling a function which\n+   is about the same as itself.\n+\n+   Copyright (C) 2002 Free Software Foundation Inc.\n+   Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n+\n+/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* i370-*-* i960-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mips*-*-* mn10?00-*-* ns32k-*-* s390*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n+\n+/* The option -foptimize-sibling-calls is the default, but serves as\n+   marker.  This test is xfailed on targets without sibcall patterns\n+   (except targets where the test does not work due to the return address\n+   not saved on the regular stack).  */\n+\n+static void recurser_void1 (int);\n+static void recurser_void2 (int);\n+extern void track (int);\n+\n+int main ()\n+{\n+  recurser_void1 (0);\n+  exit (0);\n+}\n+\n+/* The functions should get the same stack-frame, and best way to make it\n+   reasonably sure is to make them have the same contents (regarding the\n+   n tests).  */\n+\n+static void\n+recurser_void1 (int n)\n+{\n+  if (n == 0 || n == 7 || n == 8)\n+    track (n);\n+\n+  if (n == 10)\n+    return;\n+\n+  recurser_void2 (n + 1);\n+}\n+\n+static void\n+recurser_void2 (int n)\n+{\n+  if (n == 0 || n == 7 || n == 8)\n+    track (n);\n+\n+  if (n == 10)\n+    return;\n+\n+  recurser_void1 (n + 1);\n+}\n+\n+void *trackpoint;\n+\n+void\n+track (int n)\n+{\n+  char stackpos[1];\n+\n+  if (n == 0)\n+    trackpoint = stackpos;\n+  else if ((n != 7 && n != 8) || trackpoint != stackpos)\n+    abort ();\n+}"}, {"sha": "222859d3aba6e26017848661e6d8007ac1ae1d78", "filename": "gcc/testsuite/gcc.dg/sibcall-4.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7bb749a3d6d5841b64d0420a3aff3a558f88e1e/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c?ref=d7bb749a3d6d5841b64d0420a3aff3a558f88e1e", "patch": "@@ -0,0 +1,66 @@\n+/* Simple check that sibling calls are performed from a\n+   void non-leaf-function taking no arguments calling a function which\n+   is about the same as itself.\n+\n+   Copyright (C) 2002 Free Software Foundation Inc.\n+   Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n+\n+/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* i370-*-* i960-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mips*-*-* mn10?00-*-* ns32k-*-* s390*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n+\n+/* The option -foptimize-sibling-calls is the default, but serves as\n+   marker.  This test is xfailed on targets without sibcall patterns\n+   (except targets where the test does not work due to the return address\n+   not saved on the regular stack).  */\n+\n+static void recurser_void1 (void);\n+static void recurser_void2 (void);\n+extern void track (void);\n+\n+int n = 0;\n+int main ()\n+{\n+  recurser_void1 ();\n+  exit (0);\n+}\n+\n+/* The functions should get the same stack-frame, and best way to make it\n+   reasonably sure is to make them have the same contents (regarding the\n+   n tests).  */\n+\n+static void\n+recurser_void1 (void)\n+{\n+  if (n == 0 || n == 7 || n == 8)\n+    track ();\n+\n+  if (n == 10)\n+    return;\n+  n++;\n+  recurser_void2 ();\n+}\n+\n+static void\n+recurser_void2 (void)\n+{\n+  if (n == 0 || n == 7 || n == 8)\n+    track ();\n+\n+  if (n == 10)\n+    return;\n+  n++;\n+  recurser_void1 ();\n+}\n+\n+void *trackpoint;\n+\n+void\n+track ()\n+{\n+  char stackpos[1];\n+\n+  if (n == 0)\n+    trackpoint = stackpos;\n+  else if ((n != 7 && n != 8) || trackpoint != stackpos)\n+    abort ();\n+}"}]}