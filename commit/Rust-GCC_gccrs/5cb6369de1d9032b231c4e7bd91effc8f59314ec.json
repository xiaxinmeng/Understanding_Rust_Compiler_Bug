{"sha": "5cb6369de1d9032b231c4e7bd91effc8f59314ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNiNjM2OWRlMWQ5MDMyYjIzMWM0ZTdiZDkxZWZmYzhmNTkzMTRlYw==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-03T04:34:19Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-03T04:34:19Z"}, "message": "stl_deque.h, [...]: Reformat to (mostly) match C++STYLE.\n\n2002-06-03  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/bits/stl_deque.h, include/bits/stl_list.h,\n\tinclude/bits/stl_vector.h:  Reformat to (mostly) match C++STYLE.\n\tReorder to match 14882.  Doxygen blocks for all public members.\n\nFrom-SVN: r54198", "tree": {"sha": "e100e5df79001aba60cbcd676883805bdfe5a58b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e100e5df79001aba60cbcd676883805bdfe5a58b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cb6369de1d9032b231c4e7bd91effc8f59314ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb6369de1d9032b231c4e7bd91effc8f59314ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cb6369de1d9032b231c4e7bd91effc8f59314ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb6369de1d9032b231c4e7bd91effc8f59314ec/comments", "author": null, "committer": null, "parents": [{"sha": "0fb7aedacd5042be3ac70777f231a96d895d9aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb7aedacd5042be3ac70777f231a96d895d9aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb7aedacd5042be3ac70777f231a96d895d9aa5"}], "stats": {"total": 3477, "additions": 2245, "deletions": 1232}, "files": [{"sha": "bb8f06c8e499e83c6f08e178158dd19f61741663", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5cb6369de1d9032b231c4e7bd91effc8f59314ec", "patch": "@@ -1,3 +1,9 @@\n+2002-06-03  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/bits/stl_deque.h, include/bits/stl_list.h,\n+\tinclude/bits/stl_vector.h:  Reformat to (mostly) match C++STYLE.\n+\tReorder to match 14882.  Doxygen blocks for all public members.\n+\n 2002-05-31  Marcus Meissner  <meissner@suse.de>\n \n \tPR libstdc++/6886"}, {"sha": "7e0c9f9fb4de4af38e7d5fc6cf9f7ffd4b6e3819", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 828, "deletions": 306, "changes": 1134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=5cb6369de1d9032b231c4e7bd91effc8f59314ec", "patch": "@@ -1,4 +1,4 @@\n-// deque implementation -*- C++ -*-\n+// Deque implementation -*- C++ -*-\n \n // Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n@@ -58,13 +58,12 @@\n  *  You should not attempt to use it directly.\n  */\n \n-#include <bits/concept_check.h>\n-#include <bits/stl_iterator_base_types.h>\n-#include <bits/stl_iterator_base_funcs.h>\n-\n #ifndef __GLIBCPP_INTERNAL_DEQUE_H\n #define __GLIBCPP_INTERNAL_DEQUE_H\n \n+#include <bits/concept_check.h>\n+#include <bits/stl_iterator_base_types.h>\n+#include <bits/stl_iterator_base_funcs.h>\n \n // Since this entire file is within namespace std, there's no reason to\n // waste two spaces along the left column.  Thus the leading indentation is\n@@ -76,19 +75,22 @@ namespace std\n  *  @if maint\n  *  @brief This function controls the size of memory nodes.\n  *  @param  size  The size of an element.\n- *  @return   The number (not bytesize) of elements per node.\n+ *  @return   The number (not byte size) of elements per node.\n  *\n  *  This function started off as a compiler kludge from SGI, but seems to\n- *  be a useful wrapper around a repeated constant expression.\n+ *  be a useful wrapper around a repeated constant expression.  The '512' is\n+ *  tuneable (and no other code needs to change), but no investigation has\n+ *  been done since inheriting the SGI code.\n  *  @endif\n */\n inline size_t \n __deque_buf_size(size_t __size) \n-{ return __size < 512 ? size_t(512 / __size) : size_t(1); }\n+  { return __size < 512 ? size_t(512 / __size) : size_t(1); }\n \n \n-/// A deque::iterator.\n /**\n+ *  @brief A deque::iterator.\n+ *\n  *  Quite a bit of intelligence here.  Much of the functionality of deque is\n  *  actually passed off to this class.  A deque holds two of these internally,\n  *  marking its valid range.  Access to elements is done as offsets of either\n@@ -99,7 +101,7 @@ __deque_buf_size(size_t __size)\n  *  @endif\n */\n template <class _Tp, class _Ref, class _Ptr>\n-struct _Deque_iterator\n+  struct _Deque_iterator\n {\n   typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n   typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n@@ -200,15 +202,17 @@ struct _Deque_iterator\n    *  _M_first and _M_last.\n    *  @endif\n   */\n-  void _M_set_node(_Map_pointer __new_node) {\n+  void\n+  _M_set_node(_Map_pointer __new_node)\n+  {\n     _M_node = __new_node;\n     _M_first = *__new_node;\n     _M_last = _M_first + difference_type(_S_buffer_size());\n   }\n };\n \n // Note: we also provide overloads whose operands are of the same type in\n-// order to avoid ambiguos overload resolution when std::rel_ops operators\n+// order to avoid ambiguous overload resolution when std::rel_ops operators\n // are in scope (for additional details, see libstdc++/3628)\n template <class _Tp, class _Ref, class _Ptr>\n inline bool\n@@ -321,14 +325,15 @@ operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n  *  @if maint\n  *  Deque base class.  It has two purposes.  First, its constructor\n  *  and destructor allocate (but don't initialize) storage.  This makes\n- *  exception safety easier.  Second, the base class encapsulates all of\n+ *  %exception safety easier.  Second, the base class encapsulates all of\n  *  the differences between SGI-style allocators and standard-conforming\n- *  allocators.  There are two versions:  this ordinary one, and the\n- *  space-saving specialization for instanceless allocators.\n+ *  allocators.  (See stl_alloc.h for more on this topic.)  There are two\n+ *  versions:  this ordinary one, and the space-saving specialization for\n+ *  instanceless allocators.\n  *  @endif\n */\n template <class _Tp, class _Alloc, bool __is_static>\n-class _Deque_alloc_base\n+  class _Deque_alloc_base\n {\n public:\n   typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n@@ -343,66 +348,85 @@ class _Deque_alloc_base\n   typedef typename _Alloc_traits<_Tp*, _Alloc>::allocator_type\n           _Map_allocator_type;\n \n-  allocator_type      _M_node_allocator;\n-  _Map_allocator_type _M_map_allocator;\n-\n-  _Tp* _M_allocate_node() {\n+  _Tp*\n+  _M_allocate_node()\n+  {\n     return _M_node_allocator.allocate(__deque_buf_size(sizeof(_Tp)));\n   }\n-  void _M_deallocate_node(_Tp* __p) {\n+\n+  void\n+  _M_deallocate_node(_Tp* __p)\n+  {\n     _M_node_allocator.deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n   }\n-  _Tp** _M_allocate_map(size_t __n) \n+\n+  _Tp**\n+  _M_allocate_map(size_t __n) \n     { return _M_map_allocator.allocate(__n); }\n-  void _M_deallocate_map(_Tp** __p, size_t __n) \n+\n+  void\n+  _M_deallocate_map(_Tp** __p, size_t __n) \n     { _M_map_allocator.deallocate(__p, __n); }\n \n-  _Tp** _M_map;\n-  size_t _M_map_size;\n+  _Tp**                _M_map;\n+  size_t               _M_map_size;\n+  allocator_type       _M_node_allocator;\n+  _Map_allocator_type  _M_map_allocator;\n };\n \n /// @if maint Specialization for instanceless allocators.  @endif\n template <class _Tp, class _Alloc>\n-class _Deque_alloc_base<_Tp, _Alloc, true>\n+  class _Deque_alloc_base<_Tp, _Alloc, true>\n {\n public:\n   typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n   allocator_type get_allocator() const { return allocator_type(); }\n \n-  _Deque_alloc_base(const allocator_type&) : _M_map(0), _M_map_size(0) {}\n+  _Deque_alloc_base(const allocator_type&)\n+    : _M_map(0), _M_map_size(0)\n+  {}\n   \n protected:\n-  typedef typename _Alloc_traits<_Tp, _Alloc>::_Alloc_type _Node_alloc_type;\n-  typedef typename _Alloc_traits<_Tp*, _Alloc>::_Alloc_type _Map_alloc_type;\n+  typedef typename _Alloc_traits<_Tp,_Alloc>::_Alloc_type  _Node_alloc_type;\n+  typedef typename _Alloc_traits<_Tp*,_Alloc>::_Alloc_type _Map_alloc_type;\n \n-  _Tp* _M_allocate_node() {\n+  _Tp*\n+  _M_allocate_node()\n+  {\n     return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));\n   }\n-  void _M_deallocate_node(_Tp* __p) {\n+\n+  void\n+  _M_deallocate_node(_Tp* __p)\n+  {\n     _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n   }\n-  _Tp** _M_allocate_map(size_t __n) \n+\n+  _Tp**\n+  _M_allocate_map(size_t __n) \n     { return _Map_alloc_type::allocate(__n); }\n-  void _M_deallocate_map(_Tp** __p, size_t __n) \n+\n+  void\n+  _M_deallocate_map(_Tp** __p, size_t __n) \n     { _Map_alloc_type::deallocate(__p, __n); }\n \n-  _Tp** _M_map;\n-  size_t _M_map_size;\n+  _Tp**   _M_map;\n+  size_t  _M_map_size;\n };\n \n \n /**\n  *  @if maint\n  *  Deque base class.  Using _Alloc_traits in the instantiation of the parent\n  *  class provides the compile-time dispatching mentioned in the parent's docs.\n- *  This class provides the unified face for deque's allocation.\n+ *  This class provides the unified face for %deque's allocation.\n  *\n  *  Nothing in this class ever constructs or destroys an actual Tp element.\n  *  (Deque handles that itself.)  Only/All memory management is performed here.\n  *  @endif\n */\n template <class _Tp, class _Alloc>\n-class _Deque_base\n+  class _Deque_base\n   : public _Deque_alloc_base<_Tp,_Alloc,\n                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n {\n@@ -427,7 +451,6 @@ class _Deque_base\n   void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);\n   enum { _S_initial_map_size = 8 };\n \n-protected:\n   iterator _M_start;\n   iterator _M_finish;\n };\n@@ -436,7 +459,8 @@ class _Deque_base\n template <class _Tp, class _Alloc>\n _Deque_base<_Tp,_Alloc>::~_Deque_base()\n {\n-  if (_M_map) {\n+  if (_M_map)\n+  {\n     _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);\n     _M_deallocate_map(_M_map, _M_map_size);\n   }\n@@ -461,6 +485,10 @@ _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n   _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2);\n   _M_map = _M_allocate_map(_M_map_size);\n \n+  // For \"small\" maps (needing less than _M_map_size nodes), allocation\n+  // starts in the middle elements and grows outwards.  So nstart may be the\n+  // beginning of _M_map, but for small maps it may be as far in as _M_map+3.\n+\n   _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2;\n   _Tp** __nfinish = __nstart + __num_nodes;\n     \n@@ -478,17 +506,18 @@ _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n   _M_finish._M_set_node(__nfinish - 1);\n   _M_start._M_cur = _M_start._M_first;\n   _M_finish._M_cur = _M_finish._M_first +\n-               __num_elements % __deque_buf_size(sizeof(_Tp));\n+                     __num_elements % __deque_buf_size(sizeof(_Tp));\n }\n \n template <class _Tp, class _Alloc>\n void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n {\n   _Tp** __cur;\n-  try {\n-    for (__cur = __nstart; __cur < __nfinish; ++__cur)\n-      *__cur = _M_allocate_node();\n-  }\n+  try\n+    {\n+      for (__cur = __nstart; __cur < __nfinish; ++__cur)\n+        *__cur = _M_allocate_node();\n+    }\n   catch(...)\n     { \n       _M_destroy_nodes(__nstart, __cur);\n@@ -506,6 +535,9 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n \n \n /**\n+ *  @brief  A standard container using fixed-size memory allocation and\n+ *  constant-time manipulation of elements at either end.\n+ *\n  *  @ingroup Containers\n  *  @ingroup Sequences\n  *\n@@ -514,8 +546,6 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *  <a href=\"tables.html#67\">sequence</a>, including the\n  *  <a href=\"tables.html#68\">optional sequence requirements</a>.\n  *\n- *  Placeholder:  see http://www.sgi.com/tech/stl/Deque.html for now.\n- *\n  *  In previous HP/SGI versions of deque, there was an extra template parameter\n  *  so users could control the node size.  This extension turned out to violate\n  *  the C++ standard (it can be detected using template template parameters),\n@@ -529,7 +559,8 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *  - iterator    _M_start, _M_finish\n  *  \n  *  map_size is at least 8.  %map is an array of map_size pointers-to-\"nodes\".\n- *  (The name has nothing to do with the std::map class.)\n+ *  (The name %map has nothing to do with the std::map class, and \"nodes\"\n+ *  should not be confused with std::list's usage of \"node\".)\n  *  \n  *  A \"node\" has no specific type name as such, but it is referred to as\n  *  \"node\" in this file.  It is a simple array-of-Tp.  If Tp is very large,\n@@ -586,32 +617,29 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *  @endif\n */\n template <class _Tp, class _Alloc = allocator<_Tp> >\n-class deque : protected _Deque_base<_Tp, _Alloc>\n+  class deque : protected _Deque_base<_Tp, _Alloc>\n {\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n \n-  typedef _Deque_base<_Tp, _Alloc> _Base;\n+  typedef _Deque_base<_Tp, _Alloc>           _Base;\n \n public:\n   typedef _Tp                                value_type;\n   typedef value_type*                        pointer;\n   typedef const value_type*                  const_pointer;\n-  typedef value_type&                        reference;\n-  typedef const value_type&                  const_reference;\n-  typedef size_t                             size_type;\n-  typedef ptrdiff_t                          difference_type;\n-\n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n-\n   typedef typename _Base::iterator           iterator;\n   typedef typename _Base::const_iterator     const_iterator;\n   typedef reverse_iterator<const_iterator>   const_reverse_iterator;\n   typedef reverse_iterator<iterator>         reverse_iterator;\n+  typedef value_type&                        reference;\n+  typedef const value_type&                  const_reference;\n+  typedef size_t                             size_type;\n+  typedef ptrdiff_t                          difference_type;\n+  typedef typename _Base::allocator_type     allocator_type;\n \n protected:\n-  typedef pointer* _Map_pointer;\n+  typedef pointer*                           _Map_pointer;\n   static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n \n   // Functions controlling memory layout, and nothing else.\n@@ -634,95 +662,91 @@ class deque : protected _Deque_base<_Tp, _Alloc>\n   using _Base::_M_start;\n   using _Base::_M_finish;\n \n-public:                         // Basic accessors\n-  iterator begin() { return _M_start; }\n-  iterator end() { return _M_finish; }\n-  const_iterator begin() const { return _M_start; }\n-  const_iterator end() const { return _M_finish; }\n-\n-  reverse_iterator rbegin() { return reverse_iterator(_M_finish); }\n-  reverse_iterator rend() { return reverse_iterator(_M_start); }\n-  const_reverse_iterator rbegin() const \n-    { return const_reverse_iterator(_M_finish); }\n-  const_reverse_iterator rend() const \n-    { return const_reverse_iterator(_M_start); }\n-\n-  reference operator[](size_type __n)\n-    { return _M_start[difference_type(__n)]; }\n-  const_reference operator[](size_type __n) const \n-    { return _M_start[difference_type(__n)]; }\n-\n-  void _M_range_check(size_type __n) const {\n-    if (__n >= this->size())\n-      __throw_range_error(\"deque\");\n-  }\n-\n-  reference at(size_type __n)\n-    { _M_range_check(__n); return (*this)[__n]; }\n-  const_reference at(size_type __n) const\n-    { _M_range_check(__n); return (*this)[__n]; }\n-\n-  reference front() { return *_M_start; }\n-  reference back() {\n-    iterator __tmp = _M_finish;\n-    --__tmp;\n-    return *__tmp;\n-  }\n-  const_reference front() const { return *_M_start; }\n-  const_reference back() const {\n-    const_iterator __tmp = _M_finish;\n-    --__tmp;\n-    return *__tmp;\n-  }\n-\n-  size_type size() const { return _M_finish - _M_start; }\n-  size_type max_size() const { return size_type(-1); }\n-  bool empty() const { return _M_finish == _M_start; }\n-\n-public:                         // Constructor, destructor.\n-  explicit deque(const allocator_type& __a = allocator_type()) \n+public:\n+  // [23.2.1.1] construct/copy/destroy\n+  // (assign() and get_allocator() are also listed in this section)\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  deque(const allocator_type& __a = allocator_type()) \n     : _Base(__a, 0) {}\n-  deque(const deque& __x) : _Base(__x.get_allocator(), __x.size()) \n-    { uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n+\n+  /**\n+   *  @brief  Create a %deque with copies of an exemplar element.\n+   *  @param  n  The number of elements to initially create.\n+   *  @param  value  An element to copy.\n+   * \n+   *  This constructor fills the %deque with @a n copies of @a value.\n+  */\n   deque(size_type __n, const value_type& __value,\n-        const allocator_type& __a = allocator_type()) : _Base(__a, __n)\n+        const allocator_type& __a = allocator_type())\n+    : _Base(__a, __n)\n     { _M_fill_initialize(__value); }\n \n+  /**\n+   *  @brief  Create a %deque with default elements.\n+   *  @param  n  The number of elements to initially create.\n+   * \n+   *  This constructor fills the %deque with @a n copies of a\n+   *  default-constructed element.\n+  */\n   explicit\n   deque(size_type __n)\n-  : _Base(allocator_type(), __n)\n-  { _M_fill_initialize(value_type()); }\n+    : _Base(allocator_type(), __n)\n+    { _M_fill_initialize(value_type()); }\n+\n+  /**\n+   *  @brief  %Deque copy constructor.\n+   *  @param  x  A %deque of identical element and allocator types.\n+   * \n+   *  The newly-created %deque uses a copy of the allocation object used\n+   *  by @a x.\n+  */\n+  deque(const deque& __x)\n+    : _Base(__x.get_allocator(), __x.size()) \n+    { uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n \n-  // Check whether it's an integral type.  If so, it's not an iterator.\n+  /**\n+   *  @brief  Builds a %deque from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   * \n+   *  Creats a %deque consisting of copies of the elements from [first,last).\n+   *\n+   *  If the iterators are forward, bidirectional, or random-access, then\n+   *  this will call the elements' copy constructor N times (where N is\n+   *  distance(first,last)) and do no memory reallocation.  But if only\n+   *  input iterators are used, then this will do at most 2N calls to the\n+   *  copy constructor, and logN memory reallocations.\n+  */\n   template<class _InputIterator>\n     deque(_InputIterator __first, _InputIterator __last,\n           const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n+      : _Base(__a)\n     {\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_initialize_dispatch(__first, __last, _Integral());\n     }\n \n-  template<class _Integer>\n-    void\n-    _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n-    {\n-      _M_initialize_map(__n);\n-      _M_fill_initialize(__x);\n-    }\n-\n-  template<class _InputIter>\n-    void\n-    _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIter>::iterator_category _IterCategory;\n-      _M_range_initialize(__first, __last, _IterCategory());\n-    }\n-\n-  ~deque()\n-  { _Destroy(_M_start, _M_finish); }\n-\n-  deque& operator= (const deque& __x) {\n+  /**\n+   *  The dtor only erases the elements, and note that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n+  ~deque() { _Destroy(_M_start, _M_finish); }\n+\n+  /**\n+   *  @brief  %Deque assignment operator.\n+   *  @param  x  A %deque of identical element and allocator types.\n+   * \n+   *  All the elements of @a x are copied, but unlike the copy constructor, the\n+   *  allocator object is not copied.\n+  */\n+  deque&\n+  operator=(const deque& __x)  // FIXME move to tcc\n+  {\n     const size_type __len = size();\n     if (&__x != this) {\n       if (__len >= __x.size())\n@@ -736,34 +760,31 @@ class deque : protected _Deque_base<_Tp, _Alloc>\n     return *this;\n   }        \n \n-  void swap(deque& __x) {\n-    std::swap(_M_start, __x._M_start);\n-    std::swap(_M_finish, __x._M_finish);\n-    std::swap(_M_map, __x._M_map);\n-    std::swap(_M_map_size, __x._M_map_size);\n-  }\n-\n-public: \n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n-  void _M_fill_assign(size_type __n, const _Tp& __val) {\n-    if (__n > size()) {\n-      fill(begin(), end(), __val);\n-      insert(end(), __n - size(), __val);\n-    }\n-    else {\n-      erase(begin() + __n, end());\n-      fill(begin(), end(), __val);\n-    }\n-  }\n-\n+  /**\n+   *  @brief  Assigns a given value to a %deque.\n+   *  @param  n  Number of elements to be assigned.\n+   *  @param  val  Value to be assigned.\n+   *\n+   *  This function fills a %deque with @a n copies of the given value.\n+   *  Note that the assignment completely changes the %deque and that the\n+   *  resulting %deque's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n+  */\n   void\n-  assign(size_type __n, const _Tp& __val)\n-  { _M_fill_assign(__n, __val); }\n-\n+  assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n+\n+  /**\n+   *  @brief  Assigns a range to a %deque.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *\n+   *  This function fills a %deque with copies of the elements in the\n+   *  range [first,last).\n+   *\n+   *  Note that the assignment completely changes the %deque and that the\n+   *  resulting %deque's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n+  */\n   template<class _InputIterator>\n     void\n     assign(_InputIterator __first, _InputIterator __last)\n@@ -772,74 +793,247 @@ class deque : protected _Deque_base<_Tp, _Alloc>\n       _M_assign_dispatch(__first, __last, _Integral());\n     }\n \n-private:                        // helper functions for assign() \n+  /// Get a copy of the memory allocation object.\n+  allocator_type\n+  get_allocator() const { return _Base::get_allocator(); }\n \n-  template<class _Integer>\n-    void\n-    _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign(static_cast<size_type>(__n), static_cast<_Tp>(__val)); }\n+  // iterators\n+  /**\n+   *  Returns a read/write iterator that points to the first element in the\n+   *  %deque.  Iteration is done in ordinary element order.\n+  */\n+  iterator\n+  begin() { return _M_start; }\n \n-  template<class _InputIterator>\n-    void\n-    _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n-      _M_assign_aux(__first, __last, _IterCategory());\n-    }\n+  /**\n+   *  Returns a read-only (constant) iterator that points to the first element\n+   *  in the %deque.  Iteration is done in ordinary element order.\n+  */\n+  const_iterator\n+  begin() const { return _M_start; }\n \n-  template <class _InputIterator>\n-  void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-                     input_iterator_tag);\n+  /**\n+   *  Returns a read/write iterator that points one past the last element in\n+   *  the %deque.  Iteration is done in ordinary element order.\n+  */\n+  iterator\n+  end() { return _M_finish; }\n \n-  template <class _ForwardIterator>\n-  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                     forward_iterator_tag) {\n-    size_type __len = distance(__first, __last);\n-    if (__len > size()) {\n-      _ForwardIterator __mid = __first;\n-      advance(__mid, size());\n-      copy(__first, __mid, begin());\n-      insert(end(), __mid, __last);\n-    }\n-    else\n-      erase(copy(__first, __last, begin()), end());\n-  }\n+  /**\n+   *  Returns a read-only (constant) iterator that points one past the last\n+   *  element in the %deque.  Iteration is done in ordinary element order.\n+  */\n+  const_iterator\n+  end() const { return _M_finish; }\n \n-public:                         // push_* and pop_*\n-  \n+  /**\n+   *  Returns a read/write reverse iterator that points to the last element in\n+   *  the %deque.  Iteration is done in reverse element order.\n+  */\n+  reverse_iterator\n+  rbegin() { return reverse_iterator(_M_finish); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to the last\n+   *  element in the %deque.  Iteration is done in reverse element order.\n+  */\n+  const_reverse_iterator\n+  rbegin() const { return const_reverse_iterator(_M_finish); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to one before the\n+   *  first element in the %deque.  Iteration is done in reverse element\n+   *  order.\n+  */\n+  reverse_iterator\n+  rend() { return reverse_iterator(_M_start); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to one\n+   *  before the first element in the %deque.  Iteration is done in reverse\n+   *  element order.\n+  */\n+  const_reverse_iterator\n+  rend() const { return const_reverse_iterator(_M_start); }\n+\n+  // [23.2.1.2] capacity\n+  /**  Returns the number of elements in the %deque.  */\n+  size_type\n+  size() const { return _M_finish - _M_start; }\n+\n+  /**  Returns the size() of the largest possible %deque.  */\n+  size_type\n+  max_size() const { return size_type(-1); }\n+\n+  /**\n+   *  @brief  Resizes the %deque to the specified number of elements.\n+   *  @param  new_size  Number of elements the %deque should contain.\n+   *  @param  x  Data with which new elements should be populated.\n+   *\n+   *  This function will %resize the %deque to the specified number of\n+   *  elements.  If the number is smaller than the %deque's current size the\n+   *  %deque is truncated, otherwise the %deque is extended and new elements\n+   *  are populated with given data.\n+  */\n   void\n-  push_back(const value_type& __t)\n+  resize(size_type __new_size, const value_type& __x)\n   {\n-    if (_M_finish._M_cur != _M_finish._M_last - 1) {\n-      _Construct(_M_finish._M_cur, __t);\n-      ++_M_finish._M_cur;\n-    }\n+    const size_type __len = size();\n+    if (__new_size < __len) \n+      erase(_M_start + __new_size, _M_finish);\n     else\n-      _M_push_back_aux(__t);\n+      insert(_M_finish, __new_size - __len, __x);\n   }\n \n+  /**\n+   *  @brief  Resizes the %deque to the specified number of elements.\n+   *  @param  new_size  Number of elements the %deque should contain.\n+   *\n+   *  This function will resize the %deque to the specified number of\n+   *  elements.  If the number is smaller than the %deque's current size the\n+   *  %deque is truncated, otherwise the %deque is extended and new elements\n+   *  are default-constructed.\n+  */\n   void\n-  push_back()\n+  resize(size_type new_size) { resize(new_size, value_type()); }\n+\n+  /**\n+   *  Returns true if the %deque is empty.  (Thus begin() would equal end().)\n+  */\n+  bool empty() const { return _M_finish == _M_start; }\n+\n+  // element access\n+  /**\n+   *  @brief  Subscript access to the data contained in the %deque.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read/write reference to data.\n+   *\n+   *  This operator allows for easy, array-style, data access.\n+   *  Note that data access with this operator is unchecked and out_of_range\n+   *  lookups are not defined. (For checked lookups see at().)\n+  */\n+  reference\n+  operator[](size_type __n) { return _M_start[difference_type(__n)]; }\n+\n+  /**\n+   *  @brief  Subscript access to the data contained in the %deque.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read-only (constant) reference to data.\n+   *\n+   *  This operator allows for easy, array-style, data access.\n+   *  Note that data access with this operator is unchecked and out_of_range\n+   *  lookups are not defined. (For checked lookups see at().)\n+  */\n+  const_reference\n+  operator[](size_type __n) const { return _M_start[difference_type(__n)]; }\n+\n+protected:\n+  /// @if maint Safety check used only from at().  @endif\n+  void\n+  _M_range_check(size_type __n) const\n   {\n-    if (_M_finish._M_cur != _M_finish._M_last - 1) {\n-      _Construct(_M_finish._M_cur);\n-      ++_M_finish._M_cur;\n-    }\n-    else\n-      _M_push_back_aux();\n+    if (__n >= this->size())\n+      __throw_out_of_range(\"deque [] access out of range\");\n   }\n \n+public:\n+  /**\n+   *  @brief  Provides access to the data contained in the %deque.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read/write reference to data.\n+   *  @throw  std::out_of_range  If @a n is an invalid index.\n+   *\n+   *  This function provides for safer data access.  The parameter is first\n+   *  checked that it is in the range of the deque.  The function throws\n+   *  out_of_range if the check fails.\n+  */\n+  reference\n+  at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n+\n+  /**\n+   *  @brief  Provides access to the data contained in the %deque.\n+   *  @param  n  The index of the element for which data should be accessed.\n+   *  @return  Read-only (constant) reference to data.\n+   *  @throw  std::out_of_range  If @a n is an invalid index.\n+   *\n+   *  This function provides for safer data access.  The parameter is first\n+   *  checked that it is in the range of the deque.  The function throws\n+   *  out_of_range if the check fails.\n+  */\n+  const_reference\n+  at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the first element of the\n+   *  %deque.\n+  */\n+  reference\n+  front() { return *_M_start; }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the %deque.\n+  */\n+  const_reference\n+  front() const { return *_M_start; }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the last element of the\n+   *  %deque.\n+  */\n+  reference\n+  back()\n+  {\n+    iterator __tmp = _M_finish;\n+    --__tmp;\n+    return *__tmp;\n+  }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the last\n+   *  element of the %deque.\n+  */\n+  const_reference\n+  back() const\n+  {\n+    const_iterator __tmp = _M_finish;\n+    --__tmp;\n+    return *__tmp;\n+  }\n+\n+  // [23.2.1.2] modifiers\n+  /**\n+   *  @brief  Add data to the front of the %deque.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical stack operation.  The function creates an element at\n+   *  the front of the %deque and assigns the given data to it.  Due to the\n+   *  nature of a %deque this operation can be done in constant time.\n+  */\n   void\n-  push_front(const value_type& __t) \n+  push_front(const value_type& __x) \n   {\n     if (_M_start._M_cur != _M_start._M_first) {\n-      _Construct(_M_start._M_cur - 1, __t);\n+      _Construct(_M_start._M_cur - 1, __x);\n       --_M_start._M_cur;\n     }\n     else\n-      _M_push_front_aux(__t);\n+      _M_push_front_aux(__x);\n   }\n \n+#ifdef _GLIBCPP_DEPRECATED\n+  /**\n+   *  @brief  Add data to the front of the %deque.\n+   *\n+   *  This is a typical stack operation.  The function creates a\n+   *  default-constructed element at the front of the %deque.  Due to the nature\n+   *  of a %deque this operation can be done in constant time.  You should\n+   *  consider using push_front(value_type()) instead.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n+  */\n   void\n   push_front()\n   {\n@@ -850,19 +1044,60 @@ class deque : protected _Deque_base<_Tp, _Alloc>\n     else\n       _M_push_front_aux();\n   }\n-\n-\n+#endif\n+\n+  /**\n+   *  @brief  Add data to the end of the %deque.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical stack operation.  The function creates an element at\n+   *  the end of the %deque and assigns the given data to it.  Due to the\n+   *  nature of a %deque this operation can be done in constant time.\n+  */\n   void\n-  pop_back()\n+  push_back(const value_type& __x)\n   {\n-    if (_M_finish._M_cur != _M_finish._M_first) {\n-      --_M_finish._M_cur;\n-      _Destroy(_M_finish._M_cur);\n+    if (_M_finish._M_cur != _M_finish._M_last - 1) {\n+      _Construct(_M_finish._M_cur, __x);\n+      ++_M_finish._M_cur;\n     }\n     else\n-      _M_pop_back_aux();\n+      _M_push_back_aux(__x);\n   }\n \n+#ifdef _GLIBCPP_DEPRECATED\n+  /**\n+   *  @brief  Add data to the end of the %deque.\n+   *\n+   *  This is a typical stack operation.  The function creates a\n+   *  default-constructed element at the end of the %deque.  Due to the nature\n+   *  of a %deque this operation can be done in constant time.  You should\n+   *  consider using push_back(value_type()) instead.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n+  */\n+  void\n+  push_back()\n+  {\n+    if (_M_finish._M_cur != _M_finish._M_last - 1) {\n+      _Construct(_M_finish._M_cur);\n+      ++_M_finish._M_cur;\n+    }\n+    else\n+      _M_push_back_aux();\n+  }\n+#endif\n+\n+  /**\n+   *  @brief  Removes first element.\n+   *\n+   *  This is a typical stack operation.  It shrinks the %deque by one.\n+   *\n+   *  Note that no data is returned, and if the first element's data is\n+   *  needed, it should be retrieved before pop_front() is called.\n+  */\n   void\n   pop_front()\n   {\n@@ -874,8 +1109,34 @@ class deque : protected _Deque_base<_Tp, _Alloc>\n       _M_pop_front_aux();\n   }\n \n-public:                         // Insert\n+  /**\n+   *  @brief  Removes last element.\n+   *\n+   *  This is a typical stack operation.  It shrinks the %deque by one.\n+   *\n+   *  Note that no data is returned, and if the last element's data is\n+   *  needed, it should be retrieved before pop_back() is called.\n+  */\n+  void\n+  pop_back()\n+  {\n+    if (_M_finish._M_cur != _M_finish._M_first) {\n+      --_M_finish._M_cur;\n+      _Destroy(_M_finish._M_cur);\n+    }\n+    else\n+      _M_pop_back_aux();\n+  }\n \n+  /**\n+   *  @brief  Inserts given value into %deque before specified iterator.\n+   *  @param  position  An iterator into the %deque.\n+   *  @param  x  Data to be inserted.\n+   *  @return  An iterator that points to the inserted data.\n+   *\n+   *  This function will insert a copy of the given value before the specified\n+   *  location.\n+  */\n   iterator\n   insert(iterator position, const value_type& __x)\n   {\n@@ -894,148 +1155,381 @@ class deque : protected _Deque_base<_Tp, _Alloc>\n     }\n   }\n \n+#ifdef _GLIBCPP_DEPRECATED\n+  /**\n+   *  @brief  Inserts an element into the %deque.\n+   *  @param  position  An iterator into the %deque.\n+   *  @return  An iterator that points to the inserted element.\n+   *\n+   *  This function will insert a default-constructed element before the\n+   *  specified location.  You should consider using\n+   *  insert(position,value_type()) instead.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n+  */\n   iterator\n   insert(iterator __position)\n-  { return insert(__position, value_type()); }\n-\n-  void\n-  insert(iterator __pos, size_type __n, const value_type& __x)\n-  { _M_fill_insert(__pos, __n, __x); }\n-\n+    { return insert(__position, value_type()); }\n+#endif\n+\n+  /**\n+   *  @brief  Inserts a number of copies of given data into the %deque.\n+   *  @param  position  An iterator into the %deque.\n+   *  @param  n  Number of elements to be inserted.\n+   *  @param  x  Data to be inserted.\n+   *\n+   *  This function will insert a specified number of copies of the given data\n+   *  before the location specified by @a position.\n+  */\n   void\n-  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n-\n-  // Check whether it's an integral type.  If so, it's not an iterator.\n+  insert(iterator __position, size_type __n, const value_type& __x)\n+    { _M_fill_insert(__position, __n, __x); }\n+\n+  /**\n+   *  @brief  Inserts a range into the %deque.\n+   *  @param  pos  An iterator into the %deque.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *\n+   *  This function will insert copies of the data in the range [first,last)\n+   *  into the %deque before the location specified by @a pos.  This is\n+   *  known as \"range insert.\"\n+  */\n   template<class _InputIterator>\n     void\n     insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n     {\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_insert_dispatch(__pos, __first, __last, _Integral());\n     }\n \n-  template<class _Integer>\n-    void\n-    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n-    { _M_fill_insert(__pos, static_cast<size_type>(__n), static_cast<value_type>(__x)); }\n-\n-  template<class _InputIterator>\n-    void\n-    _M_insert_dispatch(iterator __pos,\n-                       _InputIterator __first, _InputIterator __last,\n-                       __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n-      insert(__pos, __first, __last, _IterCategory());\n-    }\n-\n-  void resize(size_type __new_size, const value_type& __x) {\n-    const size_type __len = size();\n-    if (__new_size < __len) \n-      erase(_M_start + __new_size, _M_finish);\n-    else\n-      insert(_M_finish, __new_size - __len, __x);\n-  }\n-\n-  void resize(size_type new_size) { resize(new_size, value_type()); }\n-\n-public:                         // Erase\n-  iterator erase(iterator __pos) {\n-    iterator __next = __pos;\n+  /**\n+   *  @brief  Remove element at given position.\n+   *  @param  position  Iterator pointing to element to be erased.\n+   *  @return  An iterator pointing to the next element (or end()).\n+   *\n+   *  This function will erase the element at the given position and thus\n+   *  shorten the %deque by one.\n+   *\n+   *  The user is cautioned that\n+   *  this function only erases the element, and that if the element is itself\n+   *  a pointer, the pointed-to memory is not touched in any way.  Managing\n+   *  the pointer is the user's responsibilty.\n+  */\n+  iterator\n+  erase(iterator __position)\n+  {\n+    iterator __next = __position;\n     ++__next;\n-    size_type __index = __pos - _M_start;\n+    size_type __index = __position - _M_start;\n     if (__index < (size() >> 1)) {\n-      copy_backward(_M_start, __pos, __next);\n+      copy_backward(_M_start, __position, __next);\n       pop_front();\n     }\n     else {\n-      copy(__next, _M_finish, __pos);\n+      copy(__next, _M_finish, __position);\n       pop_back();\n     }\n     return _M_start + __index;\n   }\n \n-  iterator erase(iterator __first, iterator __last);\n+  /**\n+   *  @brief  Remove a range of elements.\n+   *  @param  first  Iterator pointing to the first element to be erased.\n+   *  @param  last  Iterator pointing to one past the last element to be erased.\n+   *  @return  An iterator pointing to the element pointed to by @a last\n+   *           prior to erasing (or end()).\n+   *\n+   *  This function will erase the elements in the range [first,last) and\n+   *  shorten the %deque accordingly.\n+   *\n+   *  The user is cautioned that\n+   *  this function only erases the elements, and that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n+  iterator\n+  erase(iterator __first, iterator __last);\n+\n+  /**\n+   *  @brief  Swaps data with another %deque.\n+   *  @param  x  A %deque of the same element and allocator types.\n+   *\n+   *  This exchanges the elements between two deques in constant time.\n+   *  (Four pointers, so it should be quite fast.)\n+   *  Note that the global std::swap() function is specialized such that\n+   *  std::swap(d1,d2) will feed to this function.\n+  */\n+  void\n+  swap(deque& __x)\n+  {\n+    std::swap(_M_start, __x._M_start);\n+    std::swap(_M_finish, __x._M_finish);\n+    std::swap(_M_map, __x._M_map);\n+    std::swap(_M_map_size, __x._M_map_size);\n+  }\n+\n+  /**\n+   *  Erases all the elements.  Note that this function only erases the\n+   *  elements, and that if the elements themselves are pointers, the\n+   *  pointed-to memory is not touched in any way.  Managing the pointer is\n+   *  the user's responsibilty.\n+  */\n   void clear(); \n \n-protected:                        // Internal construction/destruction\n+protected:\n+  // Internal constructor functions follow.\n \n-  void _M_fill_initialize(const value_type& __value);\n+  // called by the range constructor to implement [23.1.1]/9\n+  template<class _Integer>\n+    void\n+    _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+    {\n+      _M_initialize_map(__n);\n+      _M_fill_initialize(__x);\n+    }\n+\n+  // called by the range constructor to implement [23.1.1]/9\n+  template<class _InputIter>\n+    void\n+    _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::iterator_category\n+                       _IterCategory;\n+      _M_range_initialize(__first, __last, _IterCategory());\n+    }\n \n+  // called by the second initialize_dispatch above\n   template <class _InputIterator>\n-  void _M_range_initialize(_InputIterator __first, _InputIterator __last,\n+    void\n+    _M_range_initialize(_InputIterator __first, _InputIterator __last,\n                         input_iterator_tag);\n \n+  // called by the second initialize_dispatch above\n   template <class _ForwardIterator>\n-  void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n+    void\n+    _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                         forward_iterator_tag);\n \n-protected:                        // Internal push_* and pop_*\n+  /**\n+   *  @if maint\n+   *  @brief Fills the %deque with copies of value.\n+   *  @param  value  Initial value.\n+   *  @return   Nothing.\n+   *  @pre _M_start and _M_finish have already been initialized, but none of\n+   *       the %deque's elements have yet been constructed.\n+   *\n+   *  This function is called only when the user provides an explicit size\n+   *  (with or without an explicit exemplar value).\n+   *  @endif\n+  */\n+  void\n+  _M_fill_initialize(const value_type& __value);\n+\n+\n+  // Internal assign functions follow.  The *_aux functions do the actual\n+  // assignment work for the range versions.\n+\n+  // called by the range assign to implement [23.1.1]/9\n+  template<class _Integer>\n+    void\n+    _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+    {\n+      _M_fill_assign(static_cast<size_type>(__n),\n+                     static_cast<value_type>(__val));\n+    }\n+\n+  // called by the range assign to implement [23.1.1]/9\n+  template<class _InputIter>\n+    void\n+    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::iterator_category\n+                       _IterCategory;\n+      _M_assign_aux(__first, __last, _IterCategory());\n+    }\n+\n+  // called by the second assign_dispatch above\n+  template <class _InputIterator>\n+    void\n+    _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+                  input_iterator_tag);\n+\n+  // called by the second assign_dispatch above\n+  template <class _ForwardIterator>\n+    void\n+    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                  forward_iterator_tag)\n+    {\n+      size_type __len = distance(__first, __last);\n+      if (__len > size()) {\n+        _ForwardIterator __mid = __first;\n+        advance(__mid, size());\n+        copy(__first, __mid, begin());\n+        insert(end(), __mid, __last);\n+      }\n+      else\n+        erase(copy(__first, __last, begin()), end());\n+    }\n \n+  // Called by assign(n,t), and the range assign when it turns out to be the\n+  // same thing.\n+  void\n+  _M_fill_assign(size_type __n, const value_type& __val)\n+  {\n+    if (__n > size())\n+    {\n+      fill(begin(), end(), __val);\n+      insert(end(), __n - size(), __val);\n+    }\n+    else\n+    {\n+      erase(begin() + __n, end());\n+      fill(begin(), end(), __val);\n+    }\n+  }\n+\n+\n+  /** @{\n+   *  @if maint\n+   *  @brief Helper functions for push_* and pop_*.\n+   *  @endif\n+  */\n   void _M_push_back_aux(const value_type&);\n-  void _M_push_back_aux();\n   void _M_push_front_aux(const value_type&);\n+#ifdef _GLIBCPP_DEPRECATED\n+  void _M_push_back_aux();\n   void _M_push_front_aux();\n+#endif\n   void _M_pop_back_aux();\n   void _M_pop_front_aux();\n+  /** @} */\n+\n+\n+  // Internal insert functions follow.  The *_aux functions do the actual\n+  // insertion work when all shortcuts fail.\n+\n+  // called by the range insert to implement [23.1.1]/9\n+  template<class _Integer>\n+    void\n+    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n+    {\n+      _M_fill_insert(__pos, static_cast<size_type>(__n),\n+                     static_cast<value_type>(__x));\n+    }\n \n-protected:                        // Internal insert functions\n+  // called by the range insert to implement [23.1.1]/9\n+  template<class _InputIterator>\n+    void\n+    _M_insert_dispatch(iterator __pos,\n+                       _InputIterator __first, _InputIterator __last,\n+                       __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::iterator_category\n+                       _IterCategory;\n+      _M_range_insert_aux(__pos, __first, __last, _IterCategory());\n+    }\n \n+  // called by the second insert_dispatch above\n   template <class _InputIterator>\n-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last,\n-              input_iterator_tag);\n+    void\n+    _M_range_insert_aux(iterator __pos, _InputIterator __first,\n+                        _InputIterator __last, input_iterator_tag);\n \n+  // called by the second insert_dispatch above\n   template <class _ForwardIterator>\n-  void insert(iterator __pos,\n-              _ForwardIterator __first, _ForwardIterator __last,\n-              forward_iterator_tag);\n+    void\n+    _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n+                        _ForwardIterator __last, forward_iterator_tag);\n \n-  iterator _M_insert_aux(iterator __pos, const value_type& __x);\n-  iterator _M_insert_aux(iterator __pos);\n-  void _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n+  // Called by insert(p,n,x), and the range insert when it turns out to be\n+  // the same thing.  Can use fill functions in optimal situations, otherwise\n+  // passes off to insert_aux(p,n,x).\n+  void\n+  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n+\n+  // called by insert(p,x)\n+  iterator\n+  _M_insert_aux(iterator __pos, const value_type& __x);\n \n+  // called by insert(p,n,x) via fill_insert\n+  void\n+  _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n+\n+  // called by range_insert_aux for forward iterators\n   template <class _ForwardIterator>\n-  void _M_insert_aux(iterator __pos, \n-                     _ForwardIterator __first, _ForwardIterator __last,\n-                     size_type __n);\n+    void\n+    _M_insert_aux(iterator __pos, \n+                  _ForwardIterator __first, _ForwardIterator __last,\n+                  size_type __n);\n \n-  iterator _M_reserve_elements_at_front(size_type __n) {\n+#ifdef _GLIBCPP_DEPRECATED\n+  // unused, see comment in implementation\n+  iterator _M_insert_aux(iterator __pos);\n+#endif\n+\n+  /** @{\n+   *  @if maint\n+   *  @brief Memory-handling helpers for the previous internal insert functions.\n+   *  @endif\n+  */\n+  iterator\n+  _M_reserve_elements_at_front(size_type __n)\n+  {\n     size_type __vacancies = _M_start._M_cur - _M_start._M_first;\n     if (__n > __vacancies) \n       _M_new_elements_at_front(__n - __vacancies);\n     return _M_start - difference_type(__n);\n   }\n \n-  iterator _M_reserve_elements_at_back(size_type __n) {\n+  iterator\n+  _M_reserve_elements_at_back(size_type __n)\n+  {\n     size_type __vacancies = (_M_finish._M_last - _M_finish._M_cur) - 1;\n     if (__n > __vacancies)\n       _M_new_elements_at_back(__n - __vacancies);\n     return _M_finish + difference_type(__n);\n   }\n \n-  void _M_new_elements_at_front(size_type __new_elements);\n-  void _M_new_elements_at_back(size_type __new_elements);\n+  void\n+  _M_new_elements_at_front(size_type __new_elements);\n \n-protected:                      // Allocation of _M_map and nodes\n+  void\n+  _M_new_elements_at_back(size_type __new_elements);\n+  /** @} */\n \n-  // Makes sure the _M_map has space for new nodes.  Does not actually\n-  //  add the nodes.  Can invalidate _M_map pointers.  (And consequently, \n-  //  deque iterators.)\n \n-  void _M_reserve_map_at_back (size_type __nodes_to_add = 1) {\n+  /** @{\n+   *  @if maint\n+   *  @brief Memory-handling helpers for the major %map.\n+   *\n+   *  Makes sure the _M_map has space for new nodes.  Does not actually add\n+   *  the nodes.  Can invalidate _M_map pointers.  (And consequently, %deque\n+   *  iterators.)\n+   *  @endif\n+  */\n+  void\n+  _M_reserve_map_at_back (size_type __nodes_to_add = 1)\n+  {\n     if (__nodes_to_add + 1 > _M_map_size - (_M_finish._M_node - _M_map))\n       _M_reallocate_map(__nodes_to_add, false);\n   }\n \n-  void _M_reserve_map_at_front (size_type __nodes_to_add = 1) {\n+  void\n+  _M_reserve_map_at_front (size_type __nodes_to_add = 1)\n+  {\n     if (__nodes_to_add > size_type(_M_start._M_node - _M_map))\n       _M_reallocate_map(__nodes_to_add, true);\n   }\n \n-  void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n+  void\n+  _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n+  /** @} */\n };\n \n-// Non-inline member functions\n \n template <class _Tp, class _Alloc>\n template <class _InputIter>\n@@ -1055,7 +1549,8 @@ template <class _Tp, class _Alloc>\n void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n                                         size_type __n, const value_type& __x)\n {\n-  if (__pos._M_cur == _M_start._M_cur) {\n+  if (__pos._M_cur == _M_start._M_cur)\n+  {\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n     try {\n       uninitialized_fill(__new_start, _M_start, __x);\n@@ -1067,7 +1562,8 @@ void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n \t__throw_exception_again;\n       }\n   }\n-  else if (__pos._M_cur == _M_finish._M_cur) {\n+  else if (__pos._M_cur == _M_finish._M_cur)\n+  {\n     iterator __new_finish = _M_reserve_elements_at_back(__n);\n     try {\n       uninitialized_fill(_M_finish, __new_finish, __x);\n@@ -1133,18 +1629,6 @@ void deque<_Tp,_Alloc>::clear()\n   _M_finish = _M_start;\n }\n \n-/**\n- *  @if maint\n- *  @brief Fills the deque with copies of value.\n- *  @param  value  Initial value.\n- *  @return   Nothing.\n- *  @pre _M_start and _M_finish have already been initialized, but none of the\n- *       deque's elements have yet been constructed.\n- *\n- *  This function is called only when the user provides an explicit size (with\n- *  or without an explicit exemplar value).\n- *  @endif\n-*/\n template <class _Tp, class _Alloc>\n void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value)\n {\n@@ -1238,6 +1722,7 @@ deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n     }\n }\n \n+#ifdef _GLIBCPP_DEPRECATED\n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n template <class _Tp, class _Alloc>\n void\n@@ -1256,6 +1741,7 @@ deque<_Tp,_Alloc>::_M_push_back_aux()\n       __throw_exception_again;\n     }\n }\n+#endif\n \n // Called only if _M_start._M_cur == _M_start._M_first.\n template <class _Tp, class _Alloc>\n@@ -1278,6 +1764,7 @@ deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)\n     }\n } \n \n+#ifdef _GLIBCPP_DEPRECATED\n // Called only if _M_start._M_cur == _M_start._M_first.\n template <class _Tp, class _Alloc>\n void\n@@ -1297,6 +1784,7 @@ deque<_Tp,_Alloc>::_M_push_front_aux()\n       __throw_exception_again;\n     }\n } \n+#endif\n \n // Called only if _M_finish._M_cur == _M_finish._M_first.\n template <class _Tp, class _Alloc>\n@@ -1322,7 +1810,7 @@ void deque<_Tp,_Alloc>::_M_pop_front_aux()\n }      \n \n template <class _Tp, class _Alloc> template <class _InputIterator>\n-void deque<_Tp,_Alloc>::insert(iterator __pos,\n+void deque<_Tp,_Alloc>::_M_range_insert_aux(iterator __pos,\n                                _InputIterator __first, _InputIterator __last,\n                                input_iterator_tag)\n {\n@@ -1331,7 +1819,7 @@ void deque<_Tp,_Alloc>::insert(iterator __pos,\n \n template <class _Tp, class _Alloc> template <class _ForwardIterator>\n void\n-deque<_Tp,_Alloc>::insert(iterator __pos,\n+deque<_Tp,_Alloc>::_M_range_insert_aux(iterator __pos,\n                           _ForwardIterator __first, _ForwardIterator __last,\n                           forward_iterator_tag) {\n   size_type __n = distance(__first, __last);\n@@ -1368,7 +1856,7 @@ typename deque<_Tp, _Alloc>::iterator\n deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos, const value_type& __x)\n {\n   difference_type __index = __pos - _M_start;\n-  value_type __x_copy = __x;\n+  value_type __x_copy = __x; // XXX copy\n   if (static_cast<size_type>(__index) < size() / 2) {\n     push_front(front());\n     iterator __front1 = _M_start;\n@@ -1393,6 +1881,11 @@ deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos, const value_type& __x)\n   return __pos;\n }\n \n+#ifdef _GLIBCPP_DEPRECATED\n+// Nothing seems to actually use this.  According to the pattern followed by\n+// the rest of the SGI code, it would be called by the deprecated insert(pos)\n+// function, but that has been replaced.  We'll take our time removing this\n+// anyhow; mark for 3.3.  -pme\n template <class _Tp, class _Alloc>\n typename deque<_Tp,_Alloc>::iterator \n deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos)\n@@ -1421,6 +1914,7 @@ deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos)\n   *__pos = value_type();\n   return __pos;\n }\n+#endif\n \n template <class _Tp, class _Alloc>\n void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n@@ -1621,47 +2115,75 @@ void deque<_Tp,_Alloc>::_M_reallocate_map(size_type __nodes_to_add,\n }\n \n \n-// Nonmember functions.\n-\n+/**\n+ *  @brief  Deque equality comparison.\n+ *  @param  x  A %deque.\n+ *  @param  y  A %deque of the same type as @a x.\n+ *  @return  True iff the size and elements of the deques are equal.\n+ *\n+ *  This is an equivalence relation.  It is linear in the size of the\n+ *  deques.  Deques are considered equivalent if their sizes are equal,\n+ *  and if corresponding elements compare equal.\n+*/\n template <class _Tp, class _Alloc>\n inline bool operator==(const deque<_Tp, _Alloc>& __x,\n-                       const deque<_Tp, _Alloc>& __y) {\n+                       const deque<_Tp, _Alloc>& __y)\n+{\n   return __x.size() == __y.size() &&\n          equal(__x.begin(), __x.end(), __y.begin());\n }\n \n+/**\n+ *  @brief  Deque ordering relation.\n+ *  @param  x  A %deque.\n+ *  @param  y  A %deque of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is a total ordering relation.  It is linear in the size of the\n+ *  deques.  The elements must be comparable with @c <.\n+ *\n+ *  See std::lexographical_compare() for how the determination is made.\n+*/\n template <class _Tp, class _Alloc>\n inline bool operator<(const deque<_Tp, _Alloc>& __x,\n-                      const deque<_Tp, _Alloc>& __y) {\n+                      const deque<_Tp, _Alloc>& __y)\n+{\n   return lexicographical_compare(__x.begin(), __x.end(), \n                                  __y.begin(), __y.end());\n }\n \n+/// Based on operator==\n template <class _Tp, class _Alloc>\n inline bool operator!=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n   return !(__x == __y);\n }\n \n+/// Based on operator<\n template <class _Tp, class _Alloc>\n inline bool operator>(const deque<_Tp, _Alloc>& __x,\n                       const deque<_Tp, _Alloc>& __y) {\n   return __y < __x;\n }\n \n+/// Based on operator<\n template <class _Tp, class _Alloc>\n inline bool operator<=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n   return !(__y < __x);\n }\n+\n+/// Based on operator<\n template <class _Tp, class _Alloc>\n inline bool operator>=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n+/// See std::deque::swap().\n template <class _Tp, class _Alloc>\n-inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y) {\n+inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n+{\n   __x.swap(__y);\n }\n "}, {"sha": "26f7ff3598246ca05c8b929d8d18f4190e09f402", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 1232, "deletions": 772, "changes": 2004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=5cb6369de1d9032b231c4e7bd91effc8f59314ec", "patch": "@@ -63,792 +63,1350 @@\n \n #include <bits/concept_check.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n \n-  struct _List_node_base\n-  {\n-    _List_node_base* _M_next;\n-    _List_node_base* _M_prev;\n-  };\n+// Supporting structures are split into common and templated types; the\n+// latter publicly inherits from the former in an effort to reduce code\n+// duplication.  This results in some \"needless\" static_cast'ing later on,\n+// but it's all safe downcasting.\n \n-  template<typename _Tp>\n-    struct _List_node : public _List_node_base\n-    {\n-      _Tp _M_data;\n-    };\n+/// @if maint Common part of a node in the %list.  @endif\n+struct _List_node_base\n+{\n+  _List_node_base* _M_next;   ///< Self-explanatory\n+  _List_node_base* _M_prev;   ///< Self-explanatory\n+};\n+\n+/// @if maint An actual node in the %list.  @endif\n+template<typename _Tp>\n+  struct _List_node : public _List_node_base\n+{\n+  _Tp _M_data;                ///< User's data.\n+};\n \n-  struct _List_iterator_base\n-  {\n-    typedef size_t                     size_type;\n-    typedef ptrdiff_t                  difference_type;\n-    typedef bidirectional_iterator_tag iterator_category;\n \n-    _List_node_base* _M_node;\n+/**\n+ *  @if maint\n+ *  @brief Common part of a list::iterator.\n+ *\n+ *  A simple type to walk a doubly-linked list.  All operations here should\n+ *  be self-explanatory after taking any decent introductory data structures\n+ *  course.\n+ *  @endif\n+*/\n+struct _List_iterator_base\n+{\n+  typedef size_t                        size_type;\n+  typedef ptrdiff_t                     difference_type;\n+  typedef bidirectional_iterator_tag    iterator_category;\n \n-    _List_iterator_base(_List_node_base* __x)\n-    : _M_node(__x)\n-    { }\n+  /// The only member points to the %list element.\n+  _List_node_base* _M_node;\n \n-    _List_iterator_base()\n-    { }\n+  _List_iterator_base(_List_node_base* __x)\n+  : _M_node(__x)\n+  { }\n \n-    void\n-    _M_incr()\n+  _List_iterator_base()\n+  { }\n+\n+  /// Walk the %list forward.\n+  void\n+  _M_incr()\n     { _M_node = _M_node->_M_next; }\n \n-    void\n-    _M_decr()\n+  /// Walk the %list backward.\n+  void\n+  _M_decr()\n     { _M_node = _M_node->_M_prev; }\n \n-    bool\n-    operator==(const _List_iterator_base& __x) const\n+  bool\n+  operator==(const _List_iterator_base& __x) const\n     { return _M_node == __x._M_node; }\n \n-    bool\n-    operator!=(const _List_iterator_base& __x) const\n+  bool\n+  operator!=(const _List_iterator_base& __x) const\n     { return _M_node != __x._M_node; }\n-  };  \n+};\n \n-  template<typename _Tp, typename _Ref, typename _Ptr>\n-    struct _List_iterator : public _List_iterator_base\n-    {\n-      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-      typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n-\n-      typedef _Tp value_type;\n-      typedef _Ptr pointer;\n-      typedef _Ref reference;\n-      typedef _List_node<_Tp> _Node;\n-\n-      _List_iterator(_Node* __x)\n-      : _List_iterator_base(__x)\n-      { }\n-\n-      _List_iterator()\n-      { }\n-\n-      _List_iterator(const iterator& __x)\n-      : _List_iterator_base(__x._M_node)\n-      { }\n-\n-      reference\n-      operator*() const\n-      { return ((_Node*) _M_node)->_M_data; }\n-\n-      pointer\n-      operator->() const\n-      { return &(operator*()); }\n-\n-      _Self&\n-      operator++()\n-      { \n-        this->_M_incr();\n-        return *this;\n-      }\n+/**\n+ *  @brief A list::iterator.\n+ *\n+ *  In addition to being used externally, a list holds one of these internally,\n+ *  pointing to the sequence of data.\n+ *\n+ *  @if maint\n+ *  All the functions are op overloads.\n+ *  @endif\n+*/\n+template<typename _Tp, typename _Ref, typename _Ptr>\n+  struct _List_iterator : public _List_iterator_base\n+{\n+  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+  typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n \n-      _Self\n-      operator++(int)\n-      { \n-        _Self __tmp = *this;\n-        this->_M_incr();\n-        return __tmp;\n-      }\n+  typedef _Tp                                       value_type;\n+  typedef _Ptr                                      pointer;\n+  typedef _Ref                                      reference;\n+  typedef _List_node<_Tp>                           _Node;\n \n-      _Self&\n-      operator--()\n-      { \n-        this->_M_decr();\n-        return *this;\n-      }\n+  _List_iterator(_Node* __x)\n+  : _List_iterator_base(__x)\n+  { }\n \n-      _Self\n-      operator--(int)\n-      { \n-        _Self __tmp = *this;\n-        this->_M_decr();\n-        return __tmp;\n-      }\n-    };\n+  _List_iterator()\n+  { }\n \n+  _List_iterator(const iterator& __x)\n+  : _List_iterator_base(__x._M_node)\n+  { }\n \n-  // Base class that encapsulates details of allocators.  Three cases:\n-  // an ordinary standard-conforming allocator, a standard-conforming\n-  // allocator with no non-static data, and an SGI-style allocator.\n-  // This complexity is necessary only because we're worrying about backward\n-  // compatibility and because we want to avoid wasting storage on an \n-  // allocator instance if it isn't necessary.\n+  reference\n+  operator*() const\n+    { return static_cast<_Node*>(_M_node)->_M_data; }\n+    // Must downcast from List_node_base to _List_node to get to _M_data.\n \n+  pointer\n+  operator->() const\n+    { return &(operator*()); }\n \n-  // Base for general standard-conforming allocators.\n-  template<typename _Tp, typename _Allocator, bool _IsStatic>\n-    class _List_alloc_base\n-    {\n-    public:\n-      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-              allocator_type;\n+  _Self&\n+  operator++()\n+  {\n+    this->_M_incr();\n+    return *this;\n+  }\n \n-      allocator_type\n-      get_allocator() const\n-      { return _Node_allocator; }\n+  _Self\n+  operator++(int)\n+  {\n+    _Self __tmp = *this;\n+    this->_M_incr();\n+    return __tmp;\n+  }\n+\n+  _Self&\n+  operator--()\n+  {\n+    this->_M_decr();\n+    return *this;\n+  }\n \n-      _List_alloc_base(const allocator_type& __a)\n-      : _Node_allocator(__a)\n-      { }\n+  _Self\n+  operator--(int)\n+  {\n+    _Self __tmp = *this;\n+    this->_M_decr();\n+    return __tmp;\n+  }\n+};\n \n-    protected:\n-      _List_node<_Tp>*\n-      _M_get_node()\n-      { return _Node_allocator.allocate(1); }\n \n-      void\n-      _M_put_node(_List_node<_Tp>* __p)\n-      { _Node_allocator.deallocate(__p, 1); }\n+/// @if maint Primary default version.  @endif\n+/**\n+ *  @if maint\n+ *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n+ *  @endif\n+*/\n+template<typename _Tp, typename _Allocator, bool _IsStatic>\n+  class _List_alloc_base\n+{\n+public:\n+  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+          allocator_type;\n+\n+  allocator_type\n+  get_allocator() const { return _M_node_allocator; }\n+\n+  _List_alloc_base(const allocator_type& __a)\n+  : _M_node_allocator(__a)\n+  { }\n+\n+protected:\n+  _List_node<_Tp>*\n+  _M_get_node()\n+    { return _M_node_allocator.allocate(1); }\n+\n+  void\n+  _M_put_node(_List_node<_Tp>* __p)\n+    { _M_node_allocator.deallocate(__p, 1); }\n+\n+  // NOTA BENE\n+  // The stored instance is not actually of \"allocator_type\"'s type.  Instead\n+  // we rebind the type to Allocator<List_node<Tp>>, which according to\n+  // [20.1.5]/4 should probably be the same.  List_node<Tp> is not the same\n+  // size as Tp (it's two pointers larger), and specializations on Tp may go\n+  // unused because List_node<Tp> is being bound instead.\n+  //\n+  // We put this to the test in get_allocator above; if the two types are\n+  // actually different, there had better be a conversion between them.\n+  //\n+  // None of the predefined allocators shipped with the library (as of 3.1)\n+  // use this instantiation anyhow; they're all instanceless.\n+  typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n+           _M_node_allocator;\n+\n+  _List_node<_Tp>* _M_node;\n+};\n+\n+/// @if maint Specialization for instanceless allocators.  @endif\n+template<typename _Tp, typename _Allocator>\n+  class _List_alloc_base<_Tp, _Allocator, true>\n+{\n+public:\n+  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+          allocator_type;\n+\n+  allocator_type\n+  get_allocator() const { return allocator_type(); }\n+\n+  _List_alloc_base(const allocator_type&)\n+  { }\n+\n+protected:\n+  // See comment in primary template class about why this is safe for the\n+  // standard predefined classes.\n+  typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n+          _Alloc_type;\n+\n+  _List_node<_Tp>*\n+  _M_get_node()\n+    { return _Alloc_type::allocate(1); }\n+\n+  void\n+  _M_put_node(_List_node<_Tp>* __p)\n+    { _Alloc_type::deallocate(__p, 1); }\n+\n+  _List_node<_Tp>* _M_node;\n+};\n+\n+\n+/**\n+ *  @if maint\n+ *  See bits/stl_deque.h's _Deque_base for an explanation.\n+ *  @endif\n+*/\n+template <typename _Tp, typename _Alloc>\n+  class _List_base\n+  : public _List_alloc_base<_Tp, _Alloc,\n+                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+{\n+public:\n+  typedef _List_alloc_base<_Tp, _Alloc,\n+                           _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+          _Base;\n+  typedef typename _Base::allocator_type allocator_type;\n+\n+  _List_base(const allocator_type& __a)\n+  : _Base(__a)\n+  {\n+    _M_node = _M_get_node();\n+    _M_node->_M_next = _M_node;\n+    _M_node->_M_prev = _M_node;\n+  }\n \n-    protected:\n-      typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n-               _Node_allocator;\n+  // This is what actually destroys the list.\n+  ~_List_base()\n+  {\n+    __clear();\n+    _M_put_node(_M_node);\n+  }\n \n-      _List_node<_Tp>* _M_node;\n-    };\n+  void\n+  __clear();\n+};\n \n-  // Specialization for instanceless allocators.\n \n-  template<typename _Tp, typename _Allocator>\n-    class _List_alloc_base<_Tp, _Allocator, true>\n+/**\n+ *  @brief  A standard container with linear time access to elements, and\n+ *  fixed time insertion/deletion at any point in the sequence.\n+ *\n+ *  @ingroup Containers\n+ *  @ingroup Sequences\n+ *\n+ *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+ *  <a href=\"tables.html#66\">reversible container</a>, and a\n+ *  <a href=\"tables.html#67\">sequence</a>, including the\n+ *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n+ *  %exception of @c at and @c operator[].\n+ *\n+ *  This is a @e doubly @e linked %list.  Traversal up and down the %list\n+ *  requires linear time, but adding and removing elements (or @e nodes) is\n+ *  done in constant time, regardless of where the change takes place.\n+ *  Unlike std::vector and std::deque, random-access iterators are not\n+ *  provided, so subscripting ( @c [] ) access is not allowed.  For algorithms\n+ *  which only need sequential access, this lack makes no difference.\n+ *\n+ *  Also unlike the other standard containers, std::list provides specialized \n+ *  algorithms %unique to linked lists, such as splicing, sorting, and\n+ *  in-place reversal.\n+ *\n+ *  @if maint\n+ *  A couple points on memory allocation for list<Tp>:\n+ *\n+ *  First, we never actually allocate a Tp, we actally allocate List_node<Tp>'s\n+ *  and trust [20.1.5]/4 to DTRT.  This is to ensure that after elements from\n+ *  %list<X,Alloc1> are spliced into %list<X,Alloc2>, destroying the memory of\n+ *  the second %list is a valid operation, i.e., Alloc1 giveth and Alloc2\n+ *  taketh away.\n+ *\n+ *  Second, a %list conceptually represented as\n+ *  @code\n+ *    A <---> B <---> C <---> D\n+ *  @endcode\n+ *  is actually circular; a link exists between A and D.  The %list class\n+ *  holds (as its only data member) a private list::iterator pointing to\n+ *  @e D, not to @e A!  To get to the head of the %list, we start at the tail\n+ *  and move forward by one.  When this member iterator's next/previous\n+ *  pointers refer to itself, the %list is %empty.\n+ *  @endif\n+*/\n+template<typename _Tp, typename _Alloc = allocator<_Tp> >\n+  class list : protected _List_base<_Tp, _Alloc>\n+{\n+  // concept requirements\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+\n+  typedef _List_base<_Tp, _Alloc>                       _Base;\n+\n+public:\n+  typedef _Tp                                           value_type;\n+  typedef value_type*                                   pointer;\n+  typedef const value_type*                             const_pointer;\n+  typedef _List_iterator<_Tp,_Tp&,_Tp*>                 iterator;\n+  typedef _List_iterator<_Tp,const _Tp&,const _Tp*>     const_iterator;\n+  typedef reverse_iterator<const_iterator>              const_reverse_iterator;\n+  typedef reverse_iterator<iterator>                    reverse_iterator;\n+  typedef value_type&                                   reference;\n+  typedef const value_type&                             const_reference;\n+  typedef size_t                                        size_type;\n+  typedef ptrdiff_t                                     difference_type;\n+  typedef typename _Base::allocator_type                allocator_type;\n+\n+protected:\n+  // Note that pointers-to-_Node's can be ctor-converted to iterator types.\n+  typedef _List_node<_Tp>                               _Node;\n+\n+  /** @if maint\n+   *  One data member plus two memory-handling functions.  If the _Alloc\n+   *  type requires separate instances, then one of those will also be\n+   *  included, accumulated from the topmost parent.\n+   *  @endif\n+  */\n+  using _Base::_M_node;\n+  using _Base::_M_put_node;\n+  using _Base::_M_get_node;\n+\n+  /**\n+   *  @if maint\n+   *  @param  x  An instance of user data.\n+   *\n+   *  Allocates space for a new node and constructs a copy of @a x in it.\n+   *  @endif\n+  */\n+  _Node*\n+  _M_create_node(const value_type& __x)\n+  {\n+    _Node* __p = _M_get_node();\n+    try {\n+      _Construct(&__p->_M_data, __x);\n+    }\n+    catch(...)\n+    {\n+      _M_put_node(__p);\n+      __throw_exception_again;\n+    }\n+    return __p;\n+  }\n+\n+  /**\n+   *  @if maint\n+   *  Allocates space for a new node and default-constructs a new instance\n+   *  of @c value_type in it.\n+   *  @endif\n+  */\n+  _Node*\n+  _M_create_node()\n+  {\n+    _Node* __p = _M_get_node();\n+    try {\n+      _Construct(&__p->_M_data);\n+    }\n+    catch(...)\n     {\n-    public:\n-      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-              allocator_type;\n+      _M_put_node(__p);\n+      __throw_exception_again;\n+    }\n+    return __p;\n+  }\n+\n+public:\n+  // [23.2.2.1] construct/copy/destroy\n+  // (assign() and get_allocator() are also listed in this section)\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  list(const allocator_type& __a = allocator_type())\n+  : _Base(__a) { }\n+\n+  /**\n+   *  @brief  Create a %list with copies of an exemplar element.\n+   *  @param  n  The number of elements to initially create.\n+   *  @param  value  An element to copy.\n+   * \n+   *  This constructor fills the %list with @a n copies of @a value.\n+  */\n+  list(size_type __n, const value_type& __value,\n+       const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    { this->insert(begin(), __n, __value); }\n \n-      allocator_type\n-      get_allocator() const\n-      { return allocator_type(); }\n+  /**\n+   *  @brief  Create a %list with default elements.\n+   *  @param  n  The number of elements to initially create.\n+   * \n+   *  This constructor fills the %list with @a n copies of a\n+   *  default-constructed element.\n+  */\n+  explicit\n+  list(size_type __n)\n+    : _Base(allocator_type())\n+    { this->insert(begin(), __n, value_type()); }\n \n-      _List_alloc_base(const allocator_type&)\n-      { }\n+  /**\n+   *  @brief  %List copy constructor.\n+   *  @param  x  A %list of identical element and allocator types.\n+   * \n+   *  The newly-created %list uses a copy of the allocation object used\n+   *  by @a x.\n+  */\n+  list(const list& __x)\n+    : _Base(__x.get_allocator())\n+    { this->insert(begin(), __x.begin(), __x.end()); }\n \n-    protected:\n-      typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n-              _Alloc_type;\n+  /**\n+   *  @brief  Builds a %list from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   * \n+   *  Creats a %list consisting of copies of the elements from [first,last).\n+   *  This is linear in N (where N is distance(first,last)).\n+   *\n+   *  @if maint\n+   *  We don't need any dispatching tricks here, because insert does all of\n+   *  that anyway.\n+   *  @endif\n+  */\n+  template<typename _InputIterator>\n+    list(_InputIterator __first, _InputIterator __last,\n+         const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    { this->insert(begin(), __first, __last); }\n \n-      _List_node<_Tp>*\n-      _M_get_node()\n-      { return _Alloc_type::allocate(1); }\n+  /**\n+   *  The dtor only erases the elements, and note that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n+  ~list() { }\n \n-      void\n-      _M_put_node(_List_node<_Tp>* __p)\n-      { _Alloc_type::deallocate(__p, 1); }\n+  /**\n+   *  @brief  %List assignment operator.\n+   *  @param  x  A %list of identical element and allocator types.\n+   * \n+   *  All the elements of @a x are copied, but unlike the copy constructor, the\n+   *  allocator object is not copied.\n+  */\n+  list&\n+  operator=(const list& __x);\n \n-    protected:\n-      _List_node<_Tp>* _M_node;\n-    };\n+  /**\n+   *  @brief  Assigns a given value to a %list.\n+   *  @param  n  Number of elements to be assigned.\n+   *  @param  val  Value to be assigned.\n+   *\n+   *  This function fills a %list with @a n copies of the given value.\n+   *  Note that the assignment completely changes the %list and that the\n+   *  resulting %list's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n+  */\n+  void\n+  assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n \n-  template<typename _Tp, typename _Alloc>\n-    class _List_base \n-      : public _List_alloc_base<_Tp, _Alloc,\n-                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+  /**\n+   *  @brief  Assigns a range to a %list.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *\n+   *  This function fills a %list with copies of the elements in the\n+   *  range [first,last).\n+   *\n+   *  Note that the assignment completely changes the %list and that the\n+   *  resulting %list's size is the same as the number of elements assigned.\n+   *  Old data may be lost.\n+  */\n+  template<typename _InputIterator>\n+    void\n+    assign(_InputIterator __first, _InputIterator __last)\n     {\n-    public:\n-      typedef _List_alloc_base<_Tp, _Alloc,\n-                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-              _Base; \n-      typedef typename _Base::allocator_type allocator_type;\n-\n-      _List_base(const allocator_type& __a)\n-      : _Base(__a)\n-      {\n-        _M_node = _M_get_node();\n-        _M_node->_M_next = _M_node;\n-        _M_node->_M_prev = _M_node;\n-      }\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_assign_dispatch(__first, __last, _Integral());\n+    }\n \n-      ~_List_base()\n-      {\n-        clear();\n-        _M_put_node(_M_node);\n-      }\n+  /// Get a copy of the memory allocation object.\n+  allocator_type\n+  get_allocator() const { return _Base::get_allocator(); }\n+\n+  // iterators\n+  /**\n+   *  Returns a read/write iterator that points to the first element in the\n+   *  %list.  Iteration is done in ordinary element order.\n+  */\n+  iterator\n+  begin() { return static_cast<_Node*>(_M_node->_M_next); }\n+\n+  /**\n+   *  Returns a read-only (constant) iterator that points to the first element\n+   *  in the %list.  Iteration is done in ordinary element order.\n+  */\n+  const_iterator\n+  begin() const { return static_cast<_Node*>(_M_node->_M_next); }\n+\n+  /**\n+   *  Returns a read/write iterator that points one past the last element in\n+   *  the %list.  Iteration is done in ordinary element order.\n+  */\n+  iterator\n+  end() { return _M_node; }\n \n-      void clear();\n-    };\n+  /**\n+   *  Returns a read-only (constant) iterator that points one past the last\n+   *  element in the %list.  Iteration is done in ordinary element order.\n+  */\n+  const_iterator\n+  end() const { return _M_node; }\n \n   /**\n-   *  @ingroup Containers\n-   *  @ingroup Sequences\n+   *  Returns a read/write reverse iterator that points to the last element in\n+   *  the %list.  Iteration is done in reverse element order.\n+  */\n+  reverse_iterator\n+  rbegin() { return reverse_iterator(end()); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to the last\n+   *  element in the %list.  Iteration is done in reverse element order.\n+  */\n+  const_reverse_iterator\n+  rbegin() const { return const_reverse_iterator(end()); }\n+\n+  /**\n+   *  Returns a read/write reverse iterator that points to one before the\n+   *  first element in the %list.  Iteration is done in reverse element\n+   *  order.\n+  */\n+  reverse_iterator\n+  rend() { return reverse_iterator(begin()); }\n+\n+  /**\n+   *  Returns a read-only (constant) reverse iterator that points to one\n+   *  before the first element in the %list.  Iteration is done in reverse\n+   *  element order.\n+  */\n+  const_reverse_iterator\n+  rend() const\n+  { return const_reverse_iterator(begin()); }\n+\n+  // [23.2.2.2] capacity\n+  /**\n+   *  Returns true if the %list is empty.  (Thus begin() would equal end().)\n+  */\n+  bool\n+  empty() const { return _M_node->_M_next == _M_node; }\n+\n+  /**  Returns the number of elements in the %list.  */\n+  size_type\n+  size() const { return distance(begin(), end()); }\n+\n+  /**  Returns the size() of the largest possible %list.  */\n+  size_type\n+  max_size() const { return size_type(-1); }\n+\n+  /**\n+   *  @brief  Resizes the %list to the specified number of elements.\n+   *  @param  new_size  Number of elements the %list should contain.\n+   *  @param  x  Data with which new elements should be populated.\n    *\n-   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n-   *  <a href=\"tables.html#66\">reversible container</a>, and a\n-   *  <a href=\"tables.html#67\">sequence</a>, including the\n-   *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n-   *  %exception of @c at and @c operator[].\n+   *  This function will %resize the %list to the specified number of\n+   *  elements.  If the number is smaller than the %list's current size the\n+   *  %list is truncated, otherwise the %list is extended and new elements\n+   *  are populated with given data.\n+  */\n+  void\n+  resize(size_type __new_size, const value_type& __x);\n+\n+  /**\n+   *  @brief  Resizes the %list to the specified number of elements.\n+   *  @param  new_size  Number of elements the %list should contain.\n    *\n-   *  @doctodo\n+   *  This function will resize the %list to the specified number of\n+   *  elements.  If the number is smaller than the %list's current size the\n+   *  %list is truncated, otherwise the %list is extended and new elements\n+   *  are default-constructed.\n+  */\n+  void\n+  resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n+\n+  // element access\n+  /**\n+   *  Returns a read/write reference to the data at the first element of the\n+   *  %list.\n+  */\n+  reference\n+  front() { return *begin(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the %list.\n+  */\n+  const_reference\n+  front() const { return *begin(); }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the last element of the\n+   *  %list.\n+  */\n+  reference\n+  back() { return *(--end()); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the last\n+   *  element of the %list.\n+  */\n+  const_reference\n+  back() const { return *(--end()); }\n+\n+  // [23.2.2.3] modifiers\n+  /**\n+   *  @brief  Add data to the front of the %list.\n+   *  @param  x  Data to be added.\n    *\n+   *  This is a typical stack operation.  The function creates an element at\n+   *  the front of the %list and assigns the given data to it.  Due to the\n+   *  nature of a %list this operation can be done in constant time, and\n+   *  does not invalidate iterators and references.\n   */\n-  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n-    class list : protected _List_base<_Tp, _Alloc>\n-    {\n-      // concept requirements\n-      __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-\n-      typedef _List_base<_Tp, _Alloc> _Base;\n-    protected:\n-      typedef void* _Void_pointer;\n-\n-    public:      \n-      typedef _Tp value_type;\n-      typedef value_type* pointer;\n-      typedef const value_type* const_pointer;\n-      typedef value_type& reference;\n-      typedef const value_type& const_reference;\n-      typedef _List_node<_Tp> _Node;\n-      typedef size_t size_type;\n-      typedef ptrdiff_t difference_type;\n-\n-      typedef typename _Base::allocator_type allocator_type;\n-\n-      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-\n-      typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-      typedef reverse_iterator<iterator>       reverse_iterator;\n-\n-    protected:\n-      using _Base::_M_node;\n-      using _Base::_M_put_node;\n-      using _Base::_M_get_node;\n-\n-    protected:\n-      _Node*\n-      _M_create_node(const _Tp& __x)\n-      {\n-        _Node* __p = _M_get_node();\n-        try {\n-          _Construct(&__p->_M_data, __x);\n-        }\n-        catch(...)\n-        { \n-          _M_put_node(__p);\n-          __throw_exception_again; \n-        }\n-        return __p;\n-      }\n+  void\n+  push_front(const value_type& __x) { this->insert(begin(), __x); }\n \n-      _Node*\n-      _M_create_node()\n-      {\n-        _Node* __p = _M_get_node();\n-        try {\n-          _Construct(&__p->_M_data);\n-        }\n-        catch(...)\n-        { \n-          _M_put_node(__p);\n-          __throw_exception_again; \n-        }\n-        return __p;\n-      }\n+#ifdef _GLIBCPP_DEPRECATED\n+  /**\n+   *  @brief  Add data to the front of the %list.\n+   *\n+   *  This is a typical stack operation.  The function creates a\n+   *  default-constructed element at the front of the %list.  Due to the nature\n+   *  of a %list this operation can be done in constant time.  You should\n+   *  consider using push_front(value_type()) instead.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n+  */\n+  void\n+  push_front() { this->insert(begin(), value_type()); }\n+#endif\n \n-    public:\n-      allocator_type\n-      get_allocator() const\n-      { return _Base::get_allocator(); }\n-\n-      explicit\n-      list(const allocator_type& __a = allocator_type())\n-      : _Base(__a)\n-      { }\n-\n-      iterator\n-      begin()\n-      { return static_cast<_Node*>(_M_node->_M_next); }\n-\n-      const_iterator\n-      begin() const\n-      { return static_cast<_Node*>(_M_node->_M_next); }\n-\n-      iterator\n-      end()\n-      { return _M_node; }\n-\n-      const_iterator\n-      end() const\n-      { return _M_node; }\n-\n-      reverse_iterator\n-      rbegin() \n-      { return reverse_iterator(end()); }\n-\n-      const_reverse_iterator\n-      rbegin() const \n-      { return const_reverse_iterator(end()); }\n-\n-      reverse_iterator\n-      rend()\n-      { return reverse_iterator(begin()); }\n-\n-      const_reverse_iterator\n-      rend() const\n-      { return const_reverse_iterator(begin()); }\n-\n-      bool\n-      empty() const\n-      { return _M_node->_M_next == _M_node; }\n-\n-      size_type\n-      size() const\n-      { return distance(begin(), end()); }\n-\n-      size_type\n-      max_size() const\n-      { return size_type(-1); }\n-\n-      reference\n-      front()\n-      { return *begin(); }\n-\n-      const_reference\n-      front() const\n-      { return *begin(); }\n-\n-      reference\n-      back()\n-      { return *(--end()); }\n-\n-      const_reference\n-      back() const\n-      { return *(--end()); }\n-\n-      void\n-      swap(list<_Tp, _Alloc>& __x)\n-      { std::swap(_M_node, __x._M_node); }\n-\n-      iterator\n-      insert(iterator __position, const _Tp& __x)\n-      {\n-        _Node* __tmp = _M_create_node(__x);\n-        __tmp->_M_next = __position._M_node;\n-        __tmp->_M_prev = __position._M_node->_M_prev;\n-        __position._M_node->_M_prev->_M_next = __tmp;\n-        __position._M_node->_M_prev = __tmp;\n-        return __tmp;\n-      }\n+  /**\n+   *  @brief  Removes first element.\n+   *\n+   *  This is a typical stack operation.  It shrinks the %list by one.\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and only invalidates iterators/references to the element being\n+   *  removed.\n+   *\n+   *  Note that no data is returned, and if the first element's data is\n+   *  needed, it should be retrieved before pop_front() is called.\n+  */\n+  void\n+  pop_front() { this->erase(begin()); }\n+\n+  /**\n+   *  @brief  Add data to the end of the %list.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical stack operation.  The function creates an element at\n+   *  the end of the %list and assigns the given data to it.  Due to the\n+   *  nature of a %list this operation can be done in constant time, and\n+   *  does not invalidate iterators and references.\n+  */\n+  void\n+  push_back(const value_type& __x) { this->insert(end(), __x); }\n+\n+#ifdef _GLIBCPP_DEPRECATED\n+  /**\n+   *  @brief  Add data to the end of the %list.\n+   *\n+   *  This is a typical stack operation.  The function creates a\n+   *  default-constructed element at the end of the %list.  Due to the nature\n+   *  of a %list this operation can be done in constant time.  You should\n+   *  consider using push_back(value_type()) instead.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n+  */\n+  void\n+  push_back() { this->insert(end(), value_type()); }\n+#endif\n+\n+  /**\n+   *  @brief  Removes last element.\n+   *\n+   *  This is a typical stack operation.  It shrinks the %list by one.\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and only invalidates iterators/references to the element being\n+   *  removed.\n+   *\n+   *  Note that no data is returned, and if the last element's data is\n+   *  needed, it should be retrieved before pop_back() is called.\n+  */\n+  void\n+  pop_back()\n+  {\n+    iterator __tmp = end();\n+    this->erase(--__tmp);\n+  }\n+\n+  /**\n+   *  @brief  Inserts given value into %list before specified iterator.\n+   *  @param  position  An iterator into the %list.\n+   *  @param  x  Data to be inserted.\n+   *  @return  An iterator that points to the inserted data.\n+   *\n+   *  This function will insert a copy of the given value before the specified\n+   *  location.\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and does not invalidate iterators and references.\n+  */\n+  iterator\n+  insert(iterator __position, const value_type& __x)\n+  {\n+    _Node* __tmp = _M_create_node(__x);\n+    __tmp->_M_next = __position._M_node;\n+    __tmp->_M_prev = __position._M_node->_M_prev;\n+    __position._M_node->_M_prev->_M_next = __tmp;\n+    __position._M_node->_M_prev = __tmp;\n+    return __tmp;\n+  }\n+\n+#ifdef _GLIBCPP_DEPRECATED\n+  /**\n+   *  @brief  Inserts an element into the %list.\n+   *  @param  position  An iterator into the %list.\n+   *  @return  An iterator that points to the inserted element.\n+   *\n+   *  This function will insert a default-constructed element before the\n+   *  specified location.  You should consider using\n+   *  insert(position,value_type()) instead.\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and does not invalidate iterators and references.\n+   *\n+   *  @note This was deprecated in 3.2 and will be removed in 3.3.  You must\n+   *        define @c _GLIBCPP_DEPRECATED to make this visible in 3.2; see\n+   *        c++config.h.\n+  */\n+  iterator\n+  insert(iterator __position) { return insert(__position, value_type()); }\n+#endif\n \n-      iterator\n-      insert(iterator __position)\n-      { return insert(__position, _Tp()); }\n+  /**\n+   *  @brief  Inserts a number of copies of given data into the %list.\n+   *  @param  position  An iterator into the %list.\n+   *  @param  n  Number of elements to be inserted.\n+   *  @param  x  Data to be inserted.\n+   *\n+   *  This function will insert a specified number of copies of the given data\n+   *  before the location specified by @a position.\n+   *\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and does not invalidate iterators and references.\n+  */\n+  void\n+  insert(iterator __pos, size_type __n, const value_type& __x)\n+    { _M_fill_insert(__pos, __n, __x); }\n \n+  /**\n+   *  @brief  Inserts a range into the %list.\n+   *  @param  pos  An iterator into the %list.\n+   *  @param  first  An input iterator.\n+   *  @param  last   An input iterator.\n+   *\n+   *  This function will insert copies of the data in the range [first,last)\n+   *  into the %list before the location specified by @a pos.\n+   *\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and does not invalidate iterators and references.\n+  */\n+  template<typename _InputIterator>\n+    void\n+    insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+    {\n       // Check whether it's an integral type.  If so, it's not an iterator.\n-      template<typename _Integer>\n-        void\n-        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n-        { _M_fill_insert(__pos, (size_type) __n, (_Tp) __x); }\n-\n-      template<typename _InputIterator>\n-        void\n-        _M_insert_dispatch(iterator __pos,\n-                           _InputIterator __first, _InputIterator __last,\n-                           __false_type);\n-\n-      template<typename _InputIterator>\n-        void\n-        insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n-        {\n-          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-          _M_insert_dispatch(__pos, __first, __last, _Integral());\n-        }\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_insert_dispatch(__pos, __first, __last, _Integral());\n+    }\n \n-      void\n-      insert(iterator __pos, size_type __n, const _Tp& __x)\n-      { _M_fill_insert(__pos, __n, __x); }\n-\n-      void\n-      _M_fill_insert(iterator __pos, size_type __n, const _Tp& __x); \n-\n-      void\n-      push_front(const _Tp& __x)\n-      { insert(begin(), __x); }\n-\n-      void\n-      push_front()\n-      { insert(begin()); }\n-\n-      void\n-      push_back(const _Tp& __x)\n-      { insert(end(), __x); }\n-\n-      void\n-      push_back()\n-      { insert(end()); }\n-\n-      iterator\n-      erase(iterator __position)\n-      {\n-        _List_node_base* __next_node = __position._M_node->_M_next;\n-        _List_node_base* __prev_node = __position._M_node->_M_prev;\n-        _Node* __n = static_cast<_Node*>(__position._M_node);\n-        __prev_node->_M_next = __next_node;\n-        __next_node->_M_prev = __prev_node;\n-        _Destroy(&__n->_M_data);\n-        _M_put_node(__n);\n-        return iterator(static_cast<_Node*>(__next_node));\n-      }\n+  /**\n+   *  @brief  Remove element at given position.\n+   *  @param  position  Iterator pointing to element to be erased.\n+   *  @return  An iterator pointing to the next element (or end()).\n+   *\n+   *  This function will erase the element at the given position and thus\n+   *  shorten the %list by one.\n+   *\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and only invalidates iterators/references to the element being\n+   *  removed.\n+   *  The user is also cautioned that\n+   *  this function only erases the element, and that if the element is itself\n+   *  a pointer, the pointed-to memory is not touched in any way.  Managing\n+   *  the pointer is the user's responsibilty.\n+  */\n+  iterator\n+  erase(iterator __position)\n+  {\n+    _List_node_base* __next_node = __position._M_node->_M_next;\n+    _List_node_base* __prev_node = __position._M_node->_M_prev;\n+    _Node* __n = static_cast<_Node*>(__position._M_node);\n+    __prev_node->_M_next = __next_node;\n+    __next_node->_M_prev = __prev_node;\n+    _Destroy(&__n->_M_data);\n+    _M_put_node(__n);\n+    return iterator(static_cast<_Node*>(__next_node));\n+  }\n \n-      iterator\n-      erase(iterator __first, iterator __last);\n-\n-      void\n-      clear()\n-      { _Base::clear(); }\n-\n-      void\n-      resize(size_type __new_size, const _Tp& __x);\n-      \n-      void\n-      resize(size_type __new_size)\n-      { this->resize(__new_size, _Tp()); }\n-\n-      void\n-      pop_front()\n-      { erase(begin()); }\n-\n-      void\n-      pop_back()\n-      { \n-        iterator __tmp = end();\n-        erase(--__tmp);\n-      }\n+  /**\n+   *  @brief  Remove a range of elements.\n+   *  @param  first  Iterator pointing to the first element to be erased.\n+   *  @param  last  Iterator pointing to one past the last element to be erased.\n+   *  @return  An iterator pointing to the element pointed to by @a last\n+   *           prior to erasing (or end()).\n+   *\n+   *  This function will erase the elements in the range [first,last) and\n+   *  shorten the %list accordingly.\n+   *\n+   *  Due to the nature of a %list this operation can be done in constant\n+   *  time, and only invalidates iterators/references to the element being\n+   *  removed.\n+   *  The user is also cautioned that\n+   *  this function only erases the elements, and that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n+  iterator\n+  erase(iterator __first, iterator __last);\n \n-      list(size_type __n, const _Tp& __value,\n-           const allocator_type& __a = allocator_type())\n-      : _Base(__a)\n-      { insert(begin(), __n, __value); }\n-\n-      explicit\n-      list(size_type __n)\n-      : _Base(allocator_type())\n-      { insert(begin(), __n, _Tp()); }\n-\n-      // We don't need any dispatching tricks here, because insert does all of\n-      // that anyway.  \n-      template<typename _InputIterator>\n-      list(_InputIterator __first, _InputIterator __last,\n-           const allocator_type& __a = allocator_type())\n-      : _Base(__a)\n-      { insert(begin(), __first, __last); }\n-\n-      list(const list<_Tp, _Alloc>& __x)\n-      : _Base(__x.get_allocator())\n-      { insert(begin(), __x.begin(), __x.end()); }\n-\n-      ~list()\n-      { }\n-\n-      list<_Tp, _Alloc>&\n-      operator=(const list<_Tp, _Alloc>& __x);\n-\n-    public:\n-      // assign(), a generalized assignment member function.  Two\n-      // versions: one that takes a count, and one that takes a range.\n-      // The range version is a member template, so we dispatch on whether\n-      // or not the type is an integer.\n-\n-      void\n-      assign(size_type __n, const _Tp& __val)\n-      { _M_fill_assign(__n, __val); }\n-\n-      void\n-      _M_fill_assign(size_type __n, const _Tp& __val);\n-\n-      template<typename _InputIterator>\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n-          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-          _M_assign_dispatch(__first, __last, _Integral());\n-        }\n+  /**\n+   *  @brief  Swaps data with another %list.\n+   *  @param  x  A %list of the same element and allocator types.\n+   *\n+   *  This exchanges the elements between two lists in constant time.\n+   *  (It is only swapping a single pointer, so it should be quite fast.)\n+   *  Note that the global std::swap() function is specialized such that\n+   *  std::swap(l1,l2) will feed to this function.\n+  */\n+  void\n+  swap(list& __x) { std::swap(_M_node, __x._M_node); }\n \n-      template<typename _Integer>\n-        void\n-        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-        { _M_fill_assign((size_type) __n, (_Tp) __val); }\n-\n-      template<typename _InputIterator>\n-        void\n-        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-                           __false_type);\n-\n-    protected:\n-      void\n-      _M_transfer(iterator __position, iterator __first, iterator __last)\n-      {\n-        if (__position != __last) {\n-          // Remove [first, last) from its old position.\n-          __last._M_node->_M_prev->_M_next     = __position._M_node;\n-          __first._M_node->_M_prev->_M_next    = __last._M_node;\n-          __position._M_node->_M_prev->_M_next = __first._M_node; \n-\n-          // Splice [first, last) into its new position.\n-          _List_node_base* __tmp      = __position._M_node->_M_prev;\n-          __position._M_node->_M_prev = __last._M_node->_M_prev;\n-          __last._M_node->_M_prev     = __first._M_node->_M_prev; \n-          __first._M_node->_M_prev    = __tmp;\n-        }\n-      }\n+  /**\n+   *  Erases all the elements.  Note that this function only erases the\n+   *  elements, and that if the elements themselves are pointers, the\n+   *  pointed-to memory is not touched in any way.  Managing the pointer is\n+   *  the user's responsibilty.\n+  */\n+  void\n+  clear() { _Base::__clear(); }\n \n-    public:\n-      void\n-      splice(iterator __position, list& __x)\n-      {\n-        if (!__x.empty()) \n-          this->_M_transfer(__position, __x.begin(), __x.end());\n-      }\n+  // [23.2.2.4] list operations\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  splice(iterator __position, list& __x)\n+  {\n+    if (!__x.empty())\n+      this->_M_transfer(__position, __x.begin(), __x.end());\n+  }\n \n-      void\n-      splice(iterator __position, list&, iterator __i)\n-      {\n-        iterator __j = __i;\n-        ++__j;\n-        if (__position == __i || __position == __j) return;\n-        this->_M_transfer(__position, __i, __j);\n-      }\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  splice(iterator __position, list&, iterator __i)\n+  {\n+    iterator __j = __i;\n+    ++__j;\n+    if (__position == __i || __position == __j) return;\n+    this->_M_transfer(__position, __i, __j);\n+  }\n \n-      void\n-      splice(iterator __position, list&, iterator __first, iterator __last)\n-      {\n-        if (__first != __last) \n-          this->_M_transfer(__position, __first, __last);\n-      }\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  splice(iterator __position, list&, iterator __first, iterator __last)\n+  {\n+    if (__first != __last)\n+      this->_M_transfer(__position, __first, __last);\n+  }\n+\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  remove(const _Tp& __value);\n \n-      void\n-      remove(const _Tp& __value);\n+  /**\n+   *  @doctodo\n+  */\n+  template<typename _Predicate>\n+    void\n+    remove_if(_Predicate);\n \n-      void\n-      unique();\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  unique();\n \n-      void\n-      merge(list& __x);\n+  /**\n+   *  @doctodo\n+  */\n+  template<typename _BinaryPredicate>\n+    void\n+    unique(_BinaryPredicate);\n \n-      void\n-      reverse();\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  merge(list& __x);\n \n-      void\n-      sort();\n+  /**\n+   *  @doctodo\n+  */\n+  template<typename _StrictWeakOrdering>\n+    void\n+    merge(list&, _StrictWeakOrdering);\n \n-      template<typename _Predicate>\n-        void\n-        remove_if(_Predicate);\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  reverse();\n \n-      template<typename _BinaryPredicate>\n-        void\n-        unique(_BinaryPredicate);\n+  /**\n+   *  @doctodo\n+  */\n+  void\n+  sort();\n \n-      template<typename _StrictWeakOrdering>\n-        void\n-        merge(list&, _StrictWeakOrdering);\n+  /**\n+   *  @doctodo\n+  */\n+  template<typename _StrictWeakOrdering>\n+    void\n+    sort(_StrictWeakOrdering);\n \n-      template<typename _StrictWeakOrdering>\n-        void\n-        sort(_StrictWeakOrdering);\n-    };\n+protected:\n+  // Internal assign functions follow.\n \n-  template<typename _Tp, typename _Alloc>\n-    inline bool \n-    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  // called by the range assign to implement [23.1.1]/9\n+  template<typename _Integer>\n+    void\n+    _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n     {\n-      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n-      const_iterator __end1 = __x.end();\n-      const_iterator __end2 = __y.end();\n-\n-      const_iterator __i1 = __x.begin();\n-      const_iterator __i2 = __y.begin();\n-      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n-        ++__i1;\n-        ++__i2;\n-      }\n-      return __i1 == __end1 && __i2 == __end2;\n+      _M_fill_assign(static_cast<size_type>(__n),\n+                     static_cast<value_type>(__val));\n     }\n \n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  // called by the range assign to implement [23.1.1]/9\n+  template<typename _InputIter>\n+    void\n+    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type);\n+\n+  // Called by assign(n,t), and the range assign when it turns out to be the\n+  // same thing.\n+  void\n+  _M_fill_assign(size_type __n, const value_type& __val);\n+\n+\n+  // Internal insert functions follow.\n+\n+  // called by the range insert to implement [23.1.1]/9\n+  template<typename _Integer>\n+    void\n+    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n     {\n-      return lexicographical_compare(__x.begin(), __x.end(),\n-                                     __y.begin(), __y.end());\n+      _M_fill_insert(__pos, static_cast<size_type>(__n),\n+                     static_cast<value_type>(__x));\n     }\n \n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-    { return !(__x == __y); }\n-\n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-    { return __y < __x; }\n+  // called by the range insert to implement [23.1.1]/9\n+  template<typename _InputIterator>\n+    void\n+    _M_insert_dispatch(iterator __pos,\n+                       _InputIterator __first, _InputIterator __last,\n+                       __false_type);\n \n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-    { return !(__y < __x); }\n+  // Called by insert(p,n,x), and the range insert when it turns out to be\n+  // the same thing.\n+  void\n+  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n \n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-    { return !(__x < __y); }\n \n-  template<typename _Tp, typename _Alloc>\n-    inline void \n-    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n-    { __x.swap(__y); }\n+  // Moves the elements from [first,last) before position.\n+  void\n+  _M_transfer(iterator __position, iterator __first, iterator __last)\n+  {\n+    if (__position != __last) {\n+      // Remove [first, last) from its old position.\n+      __last._M_node->_M_prev->_M_next     = __position._M_node;\n+      __first._M_node->_M_prev->_M_next    = __last._M_node;\n+      __position._M_node->_M_prev->_M_next = __first._M_node;\n+\n+      // Splice [first, last) into its new position.\n+      _List_node_base* __tmp      = __position._M_node->_M_prev;\n+      __position._M_node->_M_prev = __last._M_node->_M_prev;\n+      __last._M_node->_M_prev     = __first._M_node->_M_prev;\n+      __first._M_node->_M_prev    = __tmp;\n+    }\n+  }\n+};\n \n-  // move these to stl_list.tcc\n \n-  template<typename _Tp, typename _Alloc>\n-    void _List_base<_Tp,_Alloc>::\n-    clear() \n-    {\n-      _List_node<_Tp>* __cur = static_cast<_List_node<_Tp>*>(_M_node->_M_next);\n-      while (__cur != _M_node) {\n-        _List_node<_Tp>* __tmp = __cur;\n-        __cur = static_cast<_List_node<_Tp>*>(__cur->_M_next);\n-        _Destroy(&__tmp->_M_data);\n-        _M_put_node(__tmp);\n-      }\n-      _M_node->_M_next = _M_node;\n-      _M_node->_M_prev = _M_node;\n+/**\n+ *  @brief  List equality comparison.\n+ *  @param  x  A %list.\n+ *  @param  y  A %list of the same type as @a x.\n+ *  @return  True iff the size and elements of the lists are equal.\n+ *\n+ *  This is an equivalence relation.  It is linear in the size of the\n+ *  lists.  Lists are considered equivalent if their sizes are equal,\n+ *  and if corresponding elements compare equal.\n+*/\n+template<typename _Tp, typename _Alloc>\n+inline bool\n+  operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  {\n+    typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n+    const_iterator __end1 = __x.end();\n+    const_iterator __end2 = __y.end();\n+\n+    const_iterator __i1 = __x.begin();\n+    const_iterator __i2 = __y.begin();\n+    while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n+      ++__i1;\n+      ++__i2;\n     }\n+    return __i1 == __end1 && __i2 == __end2;\n+  }\n \n-  template<typename _Tp, typename _Alloc>\n-    template <typename _InputIter>\n-      void list<_Tp, _Alloc>::\n-      _M_insert_dispatch(iterator __position, _InputIter __first, _InputIter __last,\n-                                            __false_type)\n-      {\n-        for ( ; __first != __last; ++__first)\n-          insert(__position, *__first);\n-      \n-      }\n+/**\n+ *  @brief  List ordering relation.\n+ *  @param  x  A %list.\n+ *  @param  y  A %list of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is a total ordering relation.  It is linear in the size of the\n+ *  lists.  The elements must be comparable with @c <.\n+ *\n+ *  See std::lexographical_compare() for how the determination is made.\n+*/\n+template<typename _Tp, typename _Alloc>\n+  inline bool\n+  operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  {\n+    return lexicographical_compare(__x.begin(), __x.end(),\n+                                   __y.begin(), __y.end());\n+  }\n \n-  template<typename _Tp, typename _Alloc>\n+/// Based on operator==\n+template<typename _Tp, typename _Alloc>\n+  inline bool\n+  operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  { return !(__x == __y); }\n+\n+/// Based on operator<\n+template<typename _Tp, typename _Alloc>\n+  inline bool\n+  operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  { return __y < __x; }\n+\n+/// Based on operator<\n+template<typename _Tp, typename _Alloc>\n+  inline bool\n+  operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  { return !(__y < __x); }\n+\n+/// Based on operator<\n+template<typename _Tp, typename _Alloc>\n+  inline bool\n+  operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+  { return !(__x < __y); }\n+\n+/// See std::list::swap().\n+template<typename _Tp, typename _Alloc>\n+  inline void\n+  swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n+  { __x.swap(__y); }\n+\n+\n+template<typename _Tp, typename _Alloc>\n+  void _List_base<_Tp,_Alloc>::\n+  __clear()\n+  {\n+    _List_node<_Tp>* __cur = static_cast<_List_node<_Tp>*>(_M_node->_M_next);\n+    while (__cur != _M_node) {\n+      _List_node<_Tp>* __tmp = __cur;\n+      __cur = static_cast<_List_node<_Tp>*>(__cur->_M_next);\n+      _Destroy(&__tmp->_M_data);\n+      _M_put_node(__tmp);\n+    }\n+    _M_node->_M_next = _M_node;\n+    _M_node->_M_prev = _M_node;\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _InputIter>\n     void list<_Tp, _Alloc>::\n-    _M_fill_insert(iterator __position, size_type __n, const _Tp& __x)\n+    _M_insert_dispatch(iterator __position, _InputIter __first, _InputIter __last,\n+                                          __false_type)\n     {\n-      for ( ; __n > 0; --__n)\n-        insert(__position, __x);\n+      for ( ; __first != __last; ++__first)\n+        insert(__position, *__first);\n+\n     }\n \n-  template<typename _Tp, typename _Alloc>\n-    typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::\n-    erase(iterator __first, iterator __last)\n-    {\n-      while (__first != __last)\n-        erase(__first++);\n-      return __last;\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  _M_fill_insert(iterator __position, size_type __n, const _Tp& __x)\n+  {\n+    for ( ; __n > 0; --__n)\n+      insert(__position, __x);\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::\n+  erase(iterator __first, iterator __last)\n+  {\n+    while (__first != __last)\n+      erase(__first++);\n+    return __last;\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  resize(size_type __new_size, const _Tp& __x)\n+  {\n+    iterator __i = begin();\n+    size_type __len = 0;\n+    for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n+      ;\n+    if (__len == __new_size)\n+      erase(__i, end());\n+    else                          // __i == end()\n+      insert(end(), __new_size - __len, __x);\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  list<_Tp, _Alloc>& list<_Tp, _Alloc>::\n+  operator=(const list<_Tp, _Alloc>& __x)\n+  {\n+    if (this != &__x) {\n+      iterator __first1 = begin();\n+      iterator __last1 = end();\n+      const_iterator __first2 = __x.begin();\n+      const_iterator __last2 = __x.end();\n+      while (__first1 != __last1 && __first2 != __last2)\n+        *__first1++ = *__first2++;\n+      if (__first2 == __last2)\n+        erase(__first1, __last1);\n+      else\n+        insert(__last1, __first2, __last2);\n     }\n+    return *this;\n+  }\n \n-  template<typename _Tp, typename _Alloc>\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  _M_fill_assign(size_type __n, const _Tp& __val) {\n+    iterator __i = begin();\n+    for ( ; __i != end() && __n > 0; ++__i, --__n)\n+      *__i = __val;\n+    if (__n > 0)\n+      insert(end(), __n, __val);\n+    else\n+      erase(__i, end());\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _InputIter>\n     void list<_Tp, _Alloc>::\n-    resize(size_type __new_size, const _Tp& __x)\n+    _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n     {\n-      iterator __i = begin();\n-      size_type __len = 0;\n-      for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n-        ;\n-      if (__len == __new_size)\n-        erase(__i, end());\n-      else                          // __i == end()\n-        insert(end(), __new_size - __len, __x);\n+      iterator __first1 = begin();\n+      iterator __last1 = end();\n+      for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+        *__first1 = *__first2;\n+      if (__first2 == __last2)\n+        erase(__first1, __last1);\n+      else\n+        insert(__last1, __first2, __last2);\n     }\n \n-  template<typename _Tp, typename _Alloc>\n-    list<_Tp, _Alloc>& list<_Tp, _Alloc>::\n-    operator=(const list<_Tp, _Alloc>& __x)\n-    {\n-      if (this != &__x) {\n-        iterator __first1 = begin();\n-        iterator __last1 = end();\n-        const_iterator __first2 = __x.begin();\n-        const_iterator __last2 = __x.end();\n-        while (__first1 != __last1 && __first2 != __last2) \n-          *__first1++ = *__first2++;\n-        if (__first2 == __last2)\n-          erase(__first1, __last1);\n-        else\n-          insert(__last1, __first2, __last2);\n-      }\n-      return *this;\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  remove(const _Tp& __value)\n+  {\n+    iterator __first = begin();\n+    iterator __last = end();\n+    while (__first != __last) {\n+      iterator __next = __first;\n+      ++__next;\n+      if (*__first == __value) erase(__first);\n+      __first = __next;\n     }\n+  }\n \n-  template<typename _Tp, typename _Alloc>\n-    void list<_Tp, _Alloc>::\n-    _M_fill_assign(size_type __n, const _Tp& __val) {\n-      iterator __i = begin();\n-      for ( ; __i != end() && __n > 0; ++__i, --__n)\n-        *__i = __val;\n-      if (__n > 0)\n-        insert(end(), __n, __val);\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  unique()\n+  {\n+    iterator __first = begin();\n+    iterator __last = end();\n+    if (__first == __last) return;\n+    iterator __next = __first;\n+    while (++__next != __last) {\n+      if (*__first == *__next)\n+        erase(__next);\n       else\n-        erase(__i, end());\n+        __first = __next;\n+      __next = __first;\n     }\n+  }\n \n-  template<typename _Tp, typename _Alloc>\n-    template <typename _InputIter>\n-      void list<_Tp, _Alloc>::\n-      _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n-      {\n-        iterator __first1 = begin();\n-        iterator __last1 = end();\n-        for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n-          *__first1 = *__first2;\n-        if (__first2 == __last2)\n-          erase(__first1, __last1);\n-        else\n-          insert(__last1, __first2, __last2);\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  merge(list<_Tp, _Alloc>& __x)\n+  {\n+    iterator __first1 = begin();\n+    iterator __last1 = end();\n+    iterator __first2 = __x.begin();\n+    iterator __last2 = __x.end();\n+    while (__first1 != __last1 && __first2 != __last2)\n+      if (*__first2 < *__first1) {\n+        iterator __next = __first2;\n+        _M_transfer(__first1, __first2, ++__next);\n+        __first2 = __next;\n       }\n+      else\n+        ++__first1;\n+    if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n+  }\n+\n+inline void\n+__List_base_reverse(_List_node_base* __p)\n+{\n+  _List_node_base* __tmp = __p;\n+  do {\n+    std::swap(__tmp->_M_next, __tmp->_M_prev);\n+    __tmp = __tmp->_M_prev;     // Old next node is now prev.\n+  } while (__tmp != __p);\n+}\n+\n+template<typename _Tp, typename _Alloc>\n+inline void list<_Tp, _Alloc>::\n+reverse()\n+{ __List_base_reverse(this->_M_node); }\n+\n+template<typename _Tp, typename _Alloc>\n+  void list<_Tp, _Alloc>::\n+  sort()\n+  {\n+    // Do nothing if the list has length 0 or 1.\n+    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n+      list<_Tp, _Alloc> __carry;\n+      list<_Tp, _Alloc> __counter[64];\n+      int __fill = 0;\n+      while (!empty()) {\n+        __carry.splice(__carry.begin(), *this, begin());\n+        int __i = 0;\n+        while(__i < __fill && !__counter[__i].empty()) {\n+          __counter[__i].merge(__carry);\n+          __carry.swap(__counter[__i++]);\n+        }\n+        __carry.swap(__counter[__i]);\n+        if (__i == __fill) ++__fill;\n+      }\n+\n+      for (int __i = 1; __i < __fill; ++__i)\n+        __counter[__i].merge(__counter[__i-1]);\n+      swap(__counter[__fill-1]);\n+    }\n+  }\n \n-  template<typename _Tp, typename _Alloc>\n+template<typename _Tp, typename _Alloc>\n+  template <typename _Predicate>\n     void list<_Tp, _Alloc>::\n-    remove(const _Tp& __value)\n+    remove_if(_Predicate __pred)\n     {\n       iterator __first = begin();\n       iterator __last = end();\n       while (__first != __last) {\n         iterator __next = __first;\n         ++__next;\n-        if (*__first == __value) erase(__first);\n+        if (__pred(*__first)) erase(__first);\n         __first = __next;\n       }\n     }\n \n-  template<typename _Tp, typename _Alloc>\n+template<typename _Tp, typename _Alloc>\n+  template <typename _BinaryPredicate>\n     void list<_Tp, _Alloc>::\n-    unique()\n+    unique(_BinaryPredicate __binary_pred)\n     {\n       iterator __first = begin();\n       iterator __last = end();\n       if (__first == __last) return;\n       iterator __next = __first;\n       while (++__next != __last) {\n-        if (*__first == *__next)\n+        if (__binary_pred(*__first, *__next))\n           erase(__next);\n         else\n           __first = __next;\n         __next = __first;\n       }\n     }\n \n-  template<typename _Tp, typename _Alloc>\n+template<typename _Tp, typename _Alloc>\n+  template <typename _StrictWeakOrdering>\n     void list<_Tp, _Alloc>::\n-    merge(list<_Tp, _Alloc>& __x)\n+    merge(list<_Tp, _Alloc>& __x, _StrictWeakOrdering __comp)\n     {\n       iterator __first1 = begin();\n       iterator __last1 = end();\n       iterator __first2 = __x.begin();\n       iterator __last2 = __x.end();\n       while (__first1 != __last1 && __first2 != __last2)\n-        if (*__first2 < *__first1) {\n+        if (__comp(*__first2, *__first1)) {\n           iterator __next = __first2;\n           _M_transfer(__first1, __first2, ++__next);\n           __first2 = __next;\n@@ -858,132 +1416,34 @@ namespace std\n       if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n     }\n \n-  inline void\n-  __List_base_reverse(_List_node_base* __p)\n+template<typename _Tp, typename _Alloc>\n+  template <typename _StrictWeakOrdering>\n+  void list<_Tp, _Alloc>::\n+  sort(_StrictWeakOrdering __comp)\n   {\n-    _List_node_base* __tmp = __p;\n-    do {\n-      std::swap(__tmp->_M_next, __tmp->_M_prev);\n-      __tmp = __tmp->_M_prev;     // Old next node is now prev.\n-    } while (__tmp != __p);\n-  }\n-\n-  template<typename _Tp, typename _Alloc>\n-  inline void list<_Tp, _Alloc>::\n-  reverse() \n-  { __List_base_reverse(this->_M_node); }    \n-\n-  template<typename _Tp, typename _Alloc>\n-    void list<_Tp, _Alloc>::\n-    sort()\n-    {\n-      // Do nothing if the list has length 0 or 1.\n-      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n-        list<_Tp, _Alloc> __carry;\n-        list<_Tp, _Alloc> __counter[64];\n-        int __fill = 0;\n-        while (!empty()) {\n-          __carry.splice(__carry.begin(), *this, begin());\n-          int __i = 0;\n-          while(__i < __fill && !__counter[__i].empty()) {\n-            __counter[__i].merge(__carry);\n-            __carry.swap(__counter[__i++]);\n-          }\n-          __carry.swap(__counter[__i]);         \n-          if (__i == __fill) ++__fill;\n-        } \n-\n-        for (int __i = 1; __i < __fill; ++__i)\n-          __counter[__i].merge(__counter[__i-1]);\n-        swap(__counter[__fill-1]);\n-      }\n-    }\n-\n-  template<typename _Tp, typename _Alloc>\n-    template <typename _Predicate>\n-      void list<_Tp, _Alloc>::\n-      remove_if(_Predicate __pred)\n-      {\n-        iterator __first = begin();\n-        iterator __last = end();\n-        while (__first != __last) {\n-          iterator __next = __first;\n-          ++__next;\n-          if (__pred(*__first)) erase(__first);\n-          __first = __next;\n-        }\n-      }\n-\n-  template<typename _Tp, typename _Alloc>\n-    template <typename _BinaryPredicate>\n-      void list<_Tp, _Alloc>::\n-      unique(_BinaryPredicate __binary_pred)\n-      {\n-        iterator __first = begin();\n-        iterator __last = end();\n-        if (__first == __last) return;\n-        iterator __next = __first;\n-        while (++__next != __last) {\n-          if (__binary_pred(*__first, *__next))\n-            erase(__next);\n-          else\n-            __first = __next;\n-          __next = __first;\n+    // Do nothing if the list has length 0 or 1.\n+    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n+      list<_Tp, _Alloc> __carry;\n+      list<_Tp, _Alloc> __counter[64];\n+      int __fill = 0;\n+      while (!empty()) {\n+        __carry.splice(__carry.begin(), *this, begin());\n+        int __i = 0;\n+        while(__i < __fill && !__counter[__i].empty()) {\n+          __counter[__i].merge(__carry, __comp);\n+          __carry.swap(__counter[__i++]);\n         }\n+        __carry.swap(__counter[__i]);\n+        if (__i == __fill) ++__fill;\n       }\n \n-  template<typename _Tp, typename _Alloc>\n-    template <typename _StrictWeakOrdering>\n-      void list<_Tp, _Alloc>::\n-      merge(list<_Tp, _Alloc>& __x, _StrictWeakOrdering __comp)\n-      {\n-        iterator __first1 = begin();\n-        iterator __last1 = end();\n-        iterator __first2 = __x.begin();\n-        iterator __last2 = __x.end();\n-        while (__first1 != __last1 && __first2 != __last2)\n-          if (__comp(*__first2, *__first1)) {\n-            iterator __next = __first2;\n-            _M_transfer(__first1, __first2, ++__next);\n-            __first2 = __next;\n-          }\n-          else\n-            ++__first1;\n-        if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n-      }\n-\n-  template<typename _Tp, typename _Alloc>\n-    template <typename _StrictWeakOrdering>\n-    void list<_Tp, _Alloc>::\n-    sort(_StrictWeakOrdering __comp)\n-    {\n-      // Do nothing if the list has length 0 or 1.\n-      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n-        list<_Tp, _Alloc> __carry;\n-        list<_Tp, _Alloc> __counter[64];\n-        int __fill = 0;\n-        while (!empty()) {\n-          __carry.splice(__carry.begin(), *this, begin());\n-          int __i = 0;\n-          while(__i < __fill && !__counter[__i].empty()) {\n-            __counter[__i].merge(__carry, __comp);\n-            __carry.swap(__counter[__i++]);\n-          }\n-          __carry.swap(__counter[__i]);         \n-          if (__i == __fill) ++__fill;\n-        } \n-\n-        for (int __i = 1; __i < __fill; ++__i) \n-          __counter[__i].merge(__counter[__i-1], __comp);\n-        swap(__counter[__fill-1]);\n-      }\n+      for (int __i = 1; __i < __fill; ++__i)\n+        __counter[__i].merge(__counter[__i-1], __comp);\n+      swap(__counter[__fill-1]);\n     }\n+  }\n \n-} // namespace std \n+} // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_LIST_H */\n \n-// vi:set ts=2 sw=2:\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "c9c243374209796fe6f1a9eff3396e5d60f4338f", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 179, "deletions": 154, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb6369de1d9032b231c4e7bd91effc8f59314ec/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=5cb6369de1d9032b231c4e7bd91effc8f59314ec", "patch": "@@ -78,7 +78,7 @@ namespace std\n  *  @endif\n */\n template <class _Tp, class _Allocator, bool _IsStatic>\n-class _Vector_alloc_base\n+  class _Vector_alloc_base\n {\n public:\n   typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n@@ -93,9 +93,9 @@ class _Vector_alloc_base\n \n protected:\n   allocator_type _M_data_allocator;\n-  _Tp* _M_start;\n-  _Tp* _M_finish;\n-  _Tp* _M_end_of_storage;\n+  _Tp*           _M_start;\n+  _Tp*           _M_finish;\n+  _Tp*           _M_end_of_storage;\n \n   _Tp*\n   _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }\n@@ -107,7 +107,7 @@ class _Vector_alloc_base\n \n /// @if maint Specialization for instanceless allocators.  @endif\n template <class _Tp, class _Allocator>\n-class _Vector_alloc_base<_Tp, _Allocator, true>\n+  class _Vector_alloc_base<_Tp, _Allocator, true>\n {\n public:\n   typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n@@ -141,10 +141,11 @@ class _Vector_alloc_base<_Tp, _Allocator, true>\n  *  @endif\n */\n template <class _Tp, class _Alloc>\n-struct _Vector_base\n+  struct _Vector_base\n   : public _Vector_alloc_base<_Tp, _Alloc,\n                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n {\n+public:\n   typedef _Vector_alloc_base<_Tp, _Alloc,\n                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n           _Base;\n@@ -183,7 +184,7 @@ struct _Vector_base\n  *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n */\n template <class _Tp, class _Alloc = allocator<_Tp> >\n-class vector : protected _Vector_base<_Tp, _Alloc>\n+  class vector : protected _Vector_base<_Tp, _Alloc>\n {\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n@@ -220,12 +221,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   using _Base::_M_finish;\n   using _Base::_M_end_of_storage;\n \n-protected:\n-  void _M_insert_aux(iterator __position, const _Tp& __x);\n-#ifdef _GLIBCPP_DEPRECATED\n-  void _M_insert_aux(iterator __position);\n-#endif\n-\n public:\n   // [23.2.4.1] construct/copy/destroy\n   // (assign() and get_allocator() are also listed in this section)\n@@ -243,7 +238,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    * \n    *  This constructor fills the %vector with @a n copies of @a value.\n   */\n-  vector(size_type __n, const _Tp& __value,\n+  vector(size_type __n, const value_type& __value,\n          const allocator_type& __a = allocator_type())\n     : _Base(__n, __a)\n     { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n@@ -268,7 +263,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  by @a x.  All the elements of @a x are copied, but any extra memory in\n    *  @a x (for fast expansion) will not be copied.\n   */\n-  vector(const vector<_Tp, _Alloc>& __x)\n+  vector(const vector& __x)\n     : _Base(__x.size(), __x.get_allocator())\n     { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n \n@@ -288,37 +283,15 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   template <class _InputIterator>\n     vector(_InputIterator __first, _InputIterator __last,\n            const allocator_type& __a = allocator_type())\n-\t: _Base(__a)\n+      : _Base(__a)\n     {\n       // Check whether it's an integral type.  If so, it's not an iterator.\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-      _M_initialize_aux(__first, __last, _Integral());\n+      _M_initialize_dispatch(__first, __last, _Integral());\n     }\n \n-protected:\n-  template<class _Integer>\n-    void\n-    _M_initialize_aux(_Integer __n, _Integer __value, __true_type)\n-    {\n-      _M_start = _M_allocate(__n);\n-      _M_end_of_storage = _M_start + __n;\n-      _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n-    }\n-\n-  template<class _InputIterator>\n-    void\n-    _M_initialize_aux(_InputIterator __first,_InputIterator __last,__false_type)\n-    {\n-      typedef typename iterator_traits<_InputIterator>::iterator_category\n-                       _IterCategory;\n-      _M_range_initialize(__first, __last, _IterCategory());\n-    }\n-\n-public:\n   /**\n-   *  Creats a %vector consisting of copies of the elements from [first,last).\n-   *\n-   *  The dtor only erases the elements, and that if the elements\n+   *  The dtor only erases the elements, and note that if the elements\n    *  themselves are pointers, the pointed-to memory is not touched in any\n    *  way.  Managing the pointer is the user's responsibilty.\n   */\n@@ -332,8 +305,8 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  fast expansion) will not be copied.  Unlike the copy constructor, the\n    *  allocator object is not copied.\n   */\n-  vector<_Tp, _Alloc>&\n-  operator=(const vector<_Tp, _Alloc>& __x);\n+  vector&\n+  operator=(const vector& __x);\n \n   /**\n    *  @brief  Assigns a given value to a %vector.\n@@ -346,13 +319,8 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  Old data may be lost.\n   */\n   void\n-  assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n-\n-protected:\n-  void\n-  _M_fill_assign(size_type __n, const _Tp& __val);\n+  assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n \n-public:\n   /**\n    *  @brief  Assigns a range to a %vector.\n    *  @param  first  An input iterator.\n@@ -369,36 +337,11 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     void\n     assign(_InputIterator __first, _InputIterator __last)\n     {\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n       typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n       _M_assign_dispatch(__first, __last, _Integral());\n     }\n \n-protected:\n-  template<class _Integer>\n-    void\n-     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-     { _M_fill_assign((size_type) __n, (_Tp) __val); }\n-\n-  template<class _InputIter>\n-    void\n-    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIter>::iterator_category\n-                       _IterCategory;\n-      _M_assign_aux(__first, __last, _IterCategory());\n-    }\n-\n-  template <class _InputIterator>\n-    void \n-    _M_assign_aux(_InputIterator __first, _InputIterator __last,\n-\t\t  input_iterator_tag);\n-\n-  template <class _ForwardIterator>\n-    void \n-    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t  forward_iterator_tag);\n-\n-public:\n   /// Get a copy of the memory allocation object.\n   allocator_type\n   get_allocator() const { return _Base::get_allocator(); }\n@@ -469,7 +412,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n \n   /**  Returns the size() of the largest possible %vector.  */\n   size_type\n-  max_size() const { return size_type(-1) / sizeof(_Tp); }\n+  max_size() const { return size_type(-1) / sizeof(value_type); }\n \n   /**\n    *  @brief  Resizes the %vector to the specified number of elements.\n@@ -482,7 +425,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  are populated with given data.\n   */\n   void\n-  resize(size_type __new_size, const _Tp& __x)\n+  resize(size_type __new_size, const value_type& __x)\n   {\n     if (__new_size < size())\n       erase(begin() + __new_size, end());\n@@ -500,7 +443,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  are default-constructed.\n   */\n   void\n-  resize(size_type __new_size) { resize(__new_size, _Tp()); }\n+  resize(size_type __new_size) { resize(__new_size, value_type()); }\n \n   /**\n    *  Returns the total number of elements that the %vector can hold before\n@@ -534,7 +477,8 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   void\n   reserve(size_type __n)   // FIXME should be out of class\n   {\n-    if (capacity() < __n) {\n+    if (capacity() < __n)\n+    {\n       const size_type __old_size = size();\n       pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n       _Destroy(_M_start, _M_finish);\n@@ -557,6 +501,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   */\n   reference\n   operator[](size_type __n) { return *(begin() + __n); }\n+  // XXX do we need to convert to normal_iterator first?\n \n   /**\n    *  @brief  Subscript access to the data contained in the %vector.\n@@ -612,6 +557,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   */\n   reference\n   front() { return *begin(); }\n+  // XXX do we need to convert to normal_iterator first?\n \n   /**\n    *  Returns a read-only (constant) reference to the data at the first\n@@ -645,7 +591,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  time if the %vector has preallocated space available.\n   */\n   void\n-  push_back(const _Tp& __x)\n+  push_back(const value_type& __x)\n   {\n     if (_M_finish != _M_end_of_storage) {\n       _Construct(_M_finish, __x);\n@@ -682,15 +628,16 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  it is frequently used the user should consider using std::list.\n   */\n   iterator\n-  insert(iterator __position, const _Tp& __x)\n+  insert(iterator __position, const value_type& __x)\n   {\n     size_type __n = __position - begin();\n-    if (_M_finish != _M_end_of_storage && __position == end()) {\n+    if (_M_finish != _M_end_of_storage && __position == end())\n+    {\n       _Construct(_M_finish, __x);\n       ++_M_finish;\n     }\n     else\n-      _M_insert_aux(iterator(__position), __x);\n+      _M_insert_aux(__position, __x);\n     return begin() + __n;\n   }\n \n@@ -701,8 +648,8 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  @return  An iterator that points to the inserted element.\n    *\n    *  This function will insert a default-constructed element before the\n-   *  specified location.  You should consider using insert(position,Tp())\n-   *  instead.\n+   *  specified location.  You should consider using\n+   *  insert(position,value_type()) instead.\n    *  Note that this kind of operation could be expensive for a vector and if\n    *  it is frequently used the user should consider using std::list.\n    *\n@@ -712,16 +659,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   */\n   iterator\n   insert(iterator __position)\n-  {\n-    size_type __n = __position - begin();\n-    if (_M_finish != _M_end_of_storage && __position == end()) {\n-      _Construct(_M_finish);\n-      ++_M_finish;\n-    }\n-    else\n-      _M_insert_aux(iterator(__position));\n-    return begin() + __n;\n-  }\n+    { return insert(__position, value_type()); }\n #endif\n \n   /**\n@@ -737,14 +675,9 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  it is frequently used the user should consider using std::list.\n   */\n   void\n-  insert (iterator __pos, size_type __n, const _Tp& __x)\n+  insert (iterator __pos, size_type __n, const value_type& __x)\n     { _M_fill_insert(__pos, __n, __x); }\n \n-protected:\n-  void\n-  _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);\n-\n-public:\n   /**\n    *  @brief  Inserts a range into the %vector.\n    *  @param  pos  An iterator into the %vector.\n@@ -766,27 +699,6 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n         _M_insert_dispatch(__pos, __first, __last, _Integral());\n       }\n \n-protected:\n-  template<class _Integer>\n-    void\n-    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n-                       __true_type)\n-    {\n-      _M_fill_insert(__pos, static_cast<size_type>(__n),\n-                            static_cast<_Tp>(__val));\n-    }\n-\n-  template<class _InputIterator>\n-    void\n-    _M_insert_dispatch(iterator __pos, _InputIterator __first,\n-                       _InputIterator __last, __false_type)\n-    {\n-      typedef typename iterator_traits<_InputIterator>::iterator_category\n-                       _IterCategory;\n-      _M_range_insert(__pos, __first, __last, _IterCategory());\n-    }\n-\n-public:\n   /**\n    *  @brief  Remove element at given position.\n    *  @param  position  Iterator pointing to element to be erased.\n@@ -846,7 +758,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n    *  std::swap(v1,v2) will feed to this function.\n   */\n   void\n-  swap(vector<_Tp, _Alloc>& __x)\n+  swap(vector& __x)\n   {\n     std::swap(_M_start, __x._M_start);\n     std::swap(_M_finish, __x._M_finish);\n@@ -863,10 +775,16 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   clear() { erase(begin(), end()); }\n \n protected:\n+  /**\n+   *  @if maint\n+   *  Memory expansion handler.  Uses the member allocation function to\n+   *  obtain @a n bytes of memory, and then copies [first,last) into it.\n+   *  @endif\n+  */\n   template <class _ForwardIterator>\n   pointer\n-    _M_allocate_and_copy(size_type __n, _ForwardIterator __first,\n-                         _ForwardIterator __last)\n+    _M_allocate_and_copy(size_type __n,\n+                         _ForwardIterator __first, _ForwardIterator __last)\n   {\n     pointer __result = _M_allocate(__n);\n     try\n@@ -881,6 +799,30 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       }\n   }\n \n+\n+  // Internal constructor functions follow.\n+\n+  // called by the range constructor to implement [23.1.1]/9\n+  template<class _Integer>\n+    void\n+    _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n+    {\n+      _M_start = _M_allocate(__n);\n+      _M_end_of_storage = _M_start + __n;\n+      _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+    }\n+\n+  // called by the range constructor to implement [23.1.1]/9\n+  template<class _InputIter>\n+    void\n+    _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::iterator_category\n+                       _IterCategory;\n+      _M_range_initialize(__first, __last, _IterCategory());\n+    }\n+\n+  // called by the second initialize_dispatch above\n   template <class _InputIterator>\n   void\n     _M_range_initialize(_InputIterator __first,\n@@ -890,7 +832,7 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n       push_back(*__first);\n   }\n \n-  // This function is only called by the constructor.\n+  // called by the second initialize_dispatch above\n   template <class _ForwardIterator>\n   void _M_range_initialize(_ForwardIterator __first,\n                            _ForwardIterator __last, forward_iterator_tag)\n@@ -901,15 +843,97 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n     _M_finish = uninitialized_copy(__first, __last, _M_start);\n   }\n \n+\n+  // Internal assign functions follow.  The *_aux functions do the actual\n+  // assignment work for the range versions.\n+\n+  // called by the range assign to implement [23.1.1]/9\n+  template<class _Integer>\n+    void\n+     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+     {\n+       _M_fill_assign(static_cast<size_type>(__n),\n+                      static_cast<value_type>(__val));\n+     }\n+\n+  // called by the range assign to implement [23.1.1]/9\n+  template<class _InputIter>\n+    void\n+    _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::iterator_category\n+                       _IterCategory;\n+      _M_assign_aux(__first, __last, _IterCategory());\n+    }\n+\n+  // called by the second assign_dispatch above\n+  template <class _InputIterator>\n+    void \n+    _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\t\t  input_iterator_tag);\n+\n+  // called by the second assign_dispatch above\n+  template <class _ForwardIterator>\n+    void \n+    _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t  forward_iterator_tag);\n+\n+  // Called by assign(n,t), and the range assign when it turns out to be the\n+  // same thing.\n+  void\n+  _M_fill_assign(size_type __n, const value_type& __val);\n+\n+\n+  // Internal insert functions follow.\n+\n+  // called by the range insert to implement [23.1.1]/9\n+  template<class _Integer>\n+    void\n+    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n+                       __true_type)\n+    {\n+      _M_fill_insert(__pos, static_cast<size_type>(__n),\n+                            static_cast<value_type>(__val));\n+    }\n+\n+  // called by the range insert to implement [23.1.1]/9\n+  template<class _InputIterator>\n+    void\n+    _M_insert_dispatch(iterator __pos, _InputIterator __first,\n+                       _InputIterator __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::iterator_category\n+                       _IterCategory;\n+      _M_range_insert(__pos, __first, __last, _IterCategory());\n+    }\n+\n+  // called by the second insert_dispatch above\n   template <class _InputIterator>\n-  void _M_range_insert(iterator __pos,\n-                       _InputIterator __first, _InputIterator __last,\n-                       input_iterator_tag);\n+    void\n+    _M_range_insert(iterator __pos,\n+                    _InputIterator __first, _InputIterator __last,\n+                    input_iterator_tag);\n \n+  // called by the second insert_dispatch above\n   template <class _ForwardIterator>\n-  void _M_range_insert(iterator __pos,\n-                       _ForwardIterator __first, _ForwardIterator __last,\n-                       forward_iterator_tag);\n+    void\n+    _M_range_insert(iterator __pos,\n+                    _ForwardIterator __first, _ForwardIterator __last,\n+                    forward_iterator_tag);\n+\n+  // Called by insert(p,n,x), and the range insert when it turns out to be\n+  // the same thing.\n+  void\n+  _M_fill_insert (iterator __pos, size_type __n, const value_type& __x);\n+\n+  // called by insert(p,x)\n+  void\n+  _M_insert_aux(iterator __position, const value_type& __x);\n+\n+#ifdef _GLIBCPP_DEPRECATED\n+  // unused now (same situation as in deque)\n+  void _M_insert_aux(iterator __position);\n+#endif\n };\n \n \n@@ -924,12 +948,12 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n  *  and if corresponding elements compare equal.\n */\n template <class _Tp, class _Alloc>\n-inline bool\n-operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n-{\n-  return __x.size() == __y.size() &&\n-         equal(__x.begin(), __x.end(), __y.begin());\n-}\n+  inline bool\n+  operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n+  {\n+    return __x.size() == __y.size() &&\n+           equal(__x.begin(), __x.end(), __y.begin());\n+  }\n \n /**\n  *  @brief  Vector ordering relation.\n@@ -943,19 +967,12 @@ operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n  *  See std::lexographical_compare() for how the determination is made.\n */\n template <class _Tp, class _Alloc>\n-inline bool\n-operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n-{\n-  return lexicographical_compare(__x.begin(), __x.end(),\n-                                 __y.begin(), __y.end());\n-}\n-\n-/// See std::vector::swap().\n-template <class _Tp, class _Alloc>\n-inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n-{\n-  __x.swap(__y);\n-}\n+  inline bool\n+  operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n+  {\n+    return lexicographical_compare(__x.begin(), __x.end(),\n+                                   __y.begin(), __y.end());\n+  }\n \n /// Based on operator==\n template <class _Tp, class _Alloc>\n@@ -985,10 +1002,17 @@ operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n-// XXX begin tcc me\n+/// See std::vector::swap().\n+template <class _Tp, class _Alloc>\n+inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n+{\n+  __x.swap(__y);\n+}\n+\n+\n template <class _Tp, class _Alloc>\n vector<_Tp,_Alloc>&\n-vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n+vector<_Tp,_Alloc>::operator=(const vector<_Tp,_Alloc>& __x)\n {\n   if (&__x != this) {\n     const size_type __xlen = __x.size();\n@@ -1013,10 +1037,11 @@ vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n }\n \n template <class _Tp, class _Alloc>\n-void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)\n+void\n+vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)\n {\n   if (__n > capacity()) {\n-    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());\n+    vector __tmp(__n, __val, get_allocator());\n     __tmp.swap(*this);\n   }\n   else if (__n > size()) {"}]}