{"sha": "801881b0081878a508afff5b1c02fd56dc766633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxODgxYjAwODE4NzhhNTA4YWZmZjViMWMwMmZkNTZkYzc2NjYzMw==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2015-01-12T23:47:58Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2015-01-12T23:47:58Z"}, "message": "* Add TARGET_ATOMIC_ASSIGN_EXPAND_FENV hook for sh.\n\nFrom-SVN: r219500", "tree": {"sha": "47f7d1a6ee960775f64d9e730214d990c437dd4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f7d1a6ee960775f64d9e730214d990c437dd4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/801881b0081878a508afff5b1c02fd56dc766633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801881b0081878a508afff5b1c02fd56dc766633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801881b0081878a508afff5b1c02fd56dc766633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801881b0081878a508afff5b1c02fd56dc766633/comments", "author": null, "committer": null, "parents": [{"sha": "f6f2b01933268f73bf439ead94a1a72416a36cd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6f2b01933268f73bf439ead94a1a72416a36cd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6f2b01933268f73bf439ead94a1a72416a36cd5"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "89e22ea7ec56148f7fca8db276cb9b761337bc76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801881b0081878a508afff5b1c02fd56dc766633/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801881b0081878a508afff5b1c02fd56dc766633/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=801881b0081878a508afff5b1c02fd56dc766633", "patch": "@@ -1,3 +1,11 @@\n+2015-01-12  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (sh_atomic_assign_expand_fenv): New function.\n+\t(TARGET_ATOMIC_ASSIGN_EXPAND_FENV): Define.\n+\t(sh_builtin_get_fpscr, sh_builtin_set_fpscr): New variables.\n+\t(sh_init_builtins): Record decls for __builtin_sh_get_fpscr and\n+\t__builtin_sh_set_fpscr.\n+\n 2015-01-12  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi ([-Wsuggest-attribute=]): Don't use parentheses"}, {"sha": "b5fe30a5093f499f6c0000bb1d73889e3c6b70cd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801881b0081878a508afff5b1c02fd56dc766633/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801881b0081878a508afff5b1c02fd56dc766633/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=801881b0081878a508afff5b1c02fd56dc766633", "patch": "@@ -318,6 +318,7 @@ static void sh_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t       tree, int *, int);\n static bool sh_strict_argument_naming (cumulative_args_t);\n static bool sh_pretend_outgoing_varargs_named (cumulative_args_t);\n+static void sh_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static tree sh_build_builtin_va_list (void);\n static void sh_va_start (tree, rtx);\n static tree sh_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n@@ -577,6 +578,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE sh_function_arg_advance\n \n+#undef TARGET_ATOMIC_ASSIGN_EXPAND_FENV\n+#define TARGET_ATOMIC_ASSIGN_EXPAND_FENV sh_atomic_assign_expand_fenv\n+\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST sh_build_builtin_va_list\n #undef TARGET_EXPAND_BUILTIN_VA_START\n@@ -11897,6 +11901,9 @@ static struct builtin_description bdesc[] =\n     CODE_FOR_set_fpscr, \"__builtin_sh_set_fpscr\", SH_BLTIN_VU, 0 },\n };\n \n+static tree sh_builtin_get_fpscr;\n+static tree sh_builtin_set_fpscr;\n+\n static void\n sh_init_builtins (void)\n {\n@@ -11955,9 +11962,84 @@ sh_init_builtins (void)\n       d->fndecl =\n \tadd_builtin_function (d->name, type, d - bdesc, BUILT_IN_MD,\n \t\t\t      NULL, NULL_TREE);\n+      /* Recode {sts,set}_fpscr decls for sh_atomic_assign_expand_fenv.  */\n+      if (d->icode == CODE_FOR_sts_fpscr)\n+\tsh_builtin_get_fpscr = d->fndecl;\n+      else if (d->icode == CODE_FOR_set_fpscr)\n+\tsh_builtin_set_fpscr = d->fndecl;\n     }\n }\n \n+/* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */\n+\n+static void\n+sh_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n+{\n+  const unsigned SH_FE_INVALID = 64;\n+  const unsigned SH_FE_DIVBYZERO = 32;\n+  const unsigned SH_FE_OVERFLOW = 16;\n+  const unsigned SH_FE_UNDERFLOW = 8;\n+  const unsigned SH_FE_INEXACT = 4;\n+  const unsigned HOST_WIDE_INT SH_FE_ALL_EXCEPT = (SH_FE_INVALID\n+\t\t\t\t\t\t   | SH_FE_DIVBYZERO\n+\t\t\t\t\t\t   | SH_FE_OVERFLOW\n+\t\t\t\t\t\t   | SH_FE_UNDERFLOW\n+\t\t\t\t\t\t   | SH_FE_INEXACT);\n+  const unsigned HOST_WIDE_INT SH_FE_EXCEPT_SHIFT = 5;\n+  tree fenv_var, mask, ld_fenv, masked_fenv;\n+  tree new_fenv_var, reload_fenv, restore_fnenv;\n+  tree update_call, atomic_feraiseexcept, hold_fnclex;\n+\n+  if (! TARGET_FPU_ANY)\n+    return;\n+\n+  /* Generate the equivalent of :\n+       unsigned int fenv_var;\n+       fenv_var = __builtin_sh_get_fpscr ();\n+\n+       unsigned int masked_fenv;\n+       masked_fenv = fenv_var & mask;\n+\n+       __builtin_sh_set_fpscr (masked_fenv);  */\n+\n+  fenv_var = create_tmp_var (unsigned_type_node);\n+  mask = build_int_cst (unsigned_type_node,\n+\t\t\t~((SH_FE_ALL_EXCEPT << SH_FE_EXCEPT_SHIFT)\n+\t\t\t  | SH_FE_ALL_EXCEPT));\n+  ld_fenv = build2 (MODIFY_EXPR, unsigned_type_node,\n+\t\t    fenv_var, build_call_expr (sh_builtin_get_fpscr, 0));\n+  masked_fenv = build2 (BIT_AND_EXPR, unsigned_type_node, fenv_var, mask);\n+  hold_fnclex = build_call_expr (sh_builtin_set_fpscr, 1, masked_fenv);\n+  *hold = build2 (COMPOUND_EXPR, void_type_node,\n+\t\t  build2 (COMPOUND_EXPR, void_type_node, masked_fenv, ld_fenv),\n+\t\t  hold_fnclex);\n+\n+  /* Store the value of masked_fenv to clear the exceptions:\n+     __builtin_sh_set_fpscr (masked_fenv);  */\n+\n+  *clear = build_call_expr (sh_builtin_set_fpscr, 1, masked_fenv);\n+\n+  /* Generate the equivalent of :\n+       unsigned int new_fenv_var;\n+       new_fenv_var = __builtin_sh_get_fpscr ();\n+\n+       __builtin_sh_set_fpscr (fenv_var);\n+\n+       __atomic_feraiseexcept (new_fenv_var);  */\n+\n+  new_fenv_var = create_tmp_var (unsigned_type_node);\n+  reload_fenv = build2 (MODIFY_EXPR, unsigned_type_node, new_fenv_var,\n+\t\t\tbuild_call_expr (sh_builtin_get_fpscr, 0));\n+  restore_fnenv = build_call_expr (sh_builtin_set_fpscr, 1, fenv_var);\n+  atomic_feraiseexcept = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);\n+  update_call = build_call_expr (atomic_feraiseexcept, 1,\n+\t\t\t\t fold_convert (integer_type_node,\n+\t\t\t\t\t       new_fenv_var));\n+  *update = build2 (COMPOUND_EXPR, void_type_node,\n+\t\t    build2 (COMPOUND_EXPR, void_type_node,\n+\t\t\t    reload_fenv, restore_fnenv), update_call);\n+}\n+\n /* Implements target hook vector_mode_supported_p.  */\n bool\n sh_vector_mode_supported_p (machine_mode mode)"}]}