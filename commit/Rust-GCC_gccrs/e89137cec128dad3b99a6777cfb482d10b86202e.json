{"sha": "e89137cec128dad3b99a6777cfb482d10b86202e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5MTM3Y2VjMTI4ZGFkM2I5OWE2Nzc3Y2ZiNDgyZDEwYjg2MjAyZQ==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2016-01-13T21:39:50Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2016-01-13T21:39:50Z"}, "message": "libitm: Fix seq-cst MOs/fences in rwlock.\n\nFrom-SVN: r232353", "tree": {"sha": "f3fe271c07e10062083b39e97936296bb9ccdca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3fe271c07e10062083b39e97936296bb9ccdca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e89137cec128dad3b99a6777cfb482d10b86202e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89137cec128dad3b99a6777cfb482d10b86202e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89137cec128dad3b99a6777cfb482d10b86202e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89137cec128dad3b99a6777cfb482d10b86202e/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6683aec5e2b72a0b3ce8cc8d9385482bbfdfe4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6683aec5e2b72a0b3ce8cc8d9385482bbfdfe4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6683aec5e2b72a0b3ce8cc8d9385482bbfdfe4d"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "adcbf1d4f571d9c6c4fa9e634179ae546d3faa2f", "filename": "libitm/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89137cec128dad3b99a6777cfb482d10b86202e/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89137cec128dad3b99a6777cfb482d10b86202e/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=e89137cec128dad3b99a6777cfb482d10b86202e", "patch": "@@ -1,3 +1,9 @@\n+2016-01-13  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (gtm_thread::trycommit): Fix seq_cst fences.\n+\t* config/linux/rwlock.cc (gtm_rwlock::write_lock_generic): Likewise.\n+\t(gtm_rwlock::write_unlock): Likewise.\n+\n 2016-01-13  Richard Henderson  <rth@redhat.com>\n \n \t* Makefile.am (libitm_la_SOURCES) [ARCH_AARCH64]: Add vect128.cc"}, {"sha": "00d28f4efb64d96f37d7be23b0bd897a0ab5cc61", "filename": "libitm/beginend.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89137cec128dad3b99a6777cfb482d10b86202e/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89137cec128dad3b99a6777cfb482d10b86202e/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=e89137cec128dad3b99a6777cfb482d10b86202e", "patch": "@@ -619,8 +619,10 @@ GTM::gtm_thread::trycommit ()\n           // acquisitions).  This ensures that if we read prior to other\n           // reader transactions setting their shared_state to 0, then those\n           // readers will observe our updates.  We can reuse the seq_cst fence\n-          // in serial_lock.read_unlock() however, so we don't need another\n-          // one here.\n+          // in serial_lock.read_unlock() if we performed that; if not, we\n+\t  // issue the fence.\n+\t  if (do_read_unlock)\n+\t    atomic_thread_fence (memory_order_seq_cst);\n \t  // TODO Don't just spin but also block using cond vars / futexes\n \t  // here. Should probably be integrated with the serial lock code.\n \t  for (gtm_thread *it = gtm_thread::list_of_threads; it != 0;"}, {"sha": "b8d31ea7277e269dc9e0576424d6b3b7f58f61e6", "filename": "libitm/config/linux/rwlock.cc", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e89137cec128dad3b99a6777cfb482d10b86202e/libitm%2Fconfig%2Flinux%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e89137cec128dad3b99a6777cfb482d10b86202e/libitm%2Fconfig%2Flinux%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.cc?ref=e89137cec128dad3b99a6777cfb482d10b86202e", "patch": "@@ -122,9 +122,10 @@ gtm_rwlock::read_lock (gtm_thread *tx)\n bool\n gtm_rwlock::write_lock_generic (gtm_thread *tx)\n {\n-  // Try to acquire the write lock.\n+  // Try to acquire the write lock.  Relaxed MO is fine because of the\n+  // additional fence below.\n   int w = 0;\n-  if (unlikely (!writers.compare_exchange_strong (w, 1)))\n+  if (unlikely (!writers.compare_exchange_strong (w, 1, memory_order_relaxed)))\n     {\n       // If this is an upgrade, we must not wait for other writers or\n       // upgrades.\n@@ -135,18 +136,20 @@ gtm_rwlock::write_lock_generic (gtm_thread *tx)\n       // switch to contended mode.  We need seq_cst memory order to make the\n       // Dekker-style synchronization work.\n       if (w != 2)\n-\tw = writers.exchange (2);\n+\tw = writers.exchange (2, memory_order_relaxed);\n       while (w != 0)\n \t{\n \t  futex_wait(&writers, 2);\n-\t  w = writers.exchange (2);\n+\t  w = writers.exchange (2, memory_order_relaxed);\n \t}\n     }\n+  // This fence is both required for the Dekker-like synchronization we do\n+  // here and is the acquire MO required to make us synchronize-with prior\n+  // writers.\n+  atomic_thread_fence (memory_order_seq_cst);\n \n   // We have acquired the writer side of the R/W lock. Now wait for any\n   // readers that might still be active.\n-  // We don't need an extra barrier here because the CAS and the xchg\n-  // operations have full barrier semantics already.\n   // TODO In the worst case, this requires one wait/wake pair for each\n   // active reader. Reduce this!\n   for (gtm_thread *it = gtm_thread::list_of_threads; it != 0;\n@@ -259,28 +262,24 @@ gtm_rwlock::read_unlock (gtm_thread *tx)\n void\n gtm_rwlock::write_unlock ()\n {\n-  // This needs to have seq_cst memory order.\n-  if (writers.fetch_sub (1) == 2)\n+  // Release MO so that we synchronize with subsequent writers.\n+  if (writers.exchange (0, memory_order_release) == 2)\n     {\n-      // There might be waiting writers, so wake them.\n-      writers.store (0, memory_order_relaxed);\n-      if (futex_wake(&writers, 1) == 0)\n-\t{\n-\t  // If we did not wake any waiting writers, we might indeed be the\n-\t  // last writer (this can happen because write_lock_generic()\n-\t  // exchanges 0 or 1 to 2 and thus might go to contended mode even if\n-\t  // no other thread holds the write lock currently). Therefore, we\n-\t  // have to wake up readers here as well.  Execute a barrier after\n-\t  // the previous relaxed reset of writers (Dekker-style), and fall\n-\t  // through to the normal reader wake-up code.\n-\t  atomic_thread_fence (memory_order_seq_cst);\n-\t}\n-      else\n+      // There might be waiting writers, so wake them.  If we woke any thread,\n+      // we assume it to indeed be a writer; waiting writers will never give\n+      // up, so we can assume that they will take care of anything else such\n+      // as waking readers.\n+      if (futex_wake(&writers, 1) > 0)\n \treturn;\n+      // If we did not wake any waiting writers, we might indeed be the last\n+      // writer (this can happen because write_lock_generic() exchanges 0 or 1\n+      // to 2 and thus might go to contended mode even if no other thread\n+      // holds the write lock currently). Therefore, we have to fall through\n+      // to the normal reader wake-up code.\n     }\n+  // This fence is required because we do Dekker-like synchronization here.\n+  atomic_thread_fence (memory_order_seq_cst);\n   // No waiting writers, so wake up all waiting readers.\n-  // Because the fetch_and_sub is a full barrier already, we don't need\n-  // another barrier here (as in read_unlock()).\n   if (readers.load (memory_order_relaxed) > 0)\n     {\n       // No additional barrier needed here.  The previous load must be in"}]}