{"sha": "1a2f01efa63036a5104f203a4789e682c0e0915d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEyZjAxZWZhNjMwMzZhNTEwNGYyMDNhNDc4OWU2ODJjMGUwOTE1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-01-09T01:23:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-09T01:23:08Z"}, "message": "libgo: update to Go1.10beta1\n    \n    Update the Go library to the 1.10beta1 release.\n    \n    Requires a few changes to the compiler for modifications to the map\n    runtime code, and to handle some nowritebarrier cases in the runtime.\n    \n    Reviewed-on: https://go-review.googlesource.com/86455\n\ngotools/:\n\t* Makefile.am (go_cmd_vet_files): New variable.\n\t(go_cmd_buildid_files, go_cmd_test2json_files): New variables.\n\t(s-zdefaultcc): Change from constants to functions.\n\t(noinst_PROGRAMS): Add vet, buildid, and test2json.\n\t(cgo$(EXEEXT)): Link against $(LIBGOTOOL).\n\t(vet$(EXEEXT)): New target.\n\t(buildid$(EXEEXT)): New target.\n\t(test2json$(EXEEXT)): New target.\n\t(install-exec-local): Install all $(noinst_PROGRAMS).\n\t(uninstall-local): Uninstasll all $(noinst_PROGRAMS).\n\t(check-go-tool): Depend on $(noinst_PROGRAMS).  Copy down\n\tobjabi.go.\n\t(check-runtime): Depend on $(noinst_PROGRAMS).\n\t(check-cgo-test, check-carchive-test): Likewise.\n\t(check-vet): New target.\n\t(check): Depend on check-vet.  Look at cmd_vet-testlog.\n\t(.PHONY): Add check-vet.\n\t* Makefile.in: Rebuild.\n\nFrom-SVN: r256365", "tree": {"sha": "373e15778dc8295354584e1f86915ae493b604ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/373e15778dc8295354584e1f86915ae493b604ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a2f01efa63036a5104f203a4789e682c0e0915d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2f01efa63036a5104f203a4789e682c0e0915d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2f01efa63036a5104f203a4789e682c0e0915d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2f01efa63036a5104f203a4789e682c0e0915d/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8799df67f2dab88f9fda11739c501780a85575e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8799df67f2dab88f9fda11739c501780a85575e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8799df67f2dab88f9fda11739c501780a85575e2"}], "stats": {"total": 95997, "additions": 73194, "deletions": 22803}, "files": [{"sha": "d836309e6a0edc1c77eb9ba7ca7f0c985beb3dbc", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -1,4 +1,4 @@\n-1319f36ccc65cf802b8e17ddd3d2da3ca6d82f4c\n+dbc0c7e4329aada2ae3554c20cfb8cfa48041213\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c34a5b01b6763784e25199346f2887ef91891788", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -7483,6 +7483,7 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n \t  return Expression::make_error(this->location());\n \t}\n       len_arg = Expression::make_integer_ul(0, NULL, loc);\n+      len_small = true;\n     }\n   else\n     {\n@@ -7551,9 +7552,23 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n   else if (is_map)\n     {\n       Expression* type_arg = Expression::make_type_descriptor(type, type_loc);\n-      call = Runtime::make_call(Runtime::MAKEMAP, loc, 4, type_arg, len_arg,\n-\t\t\t\tExpression::make_nil(loc),\n-\t\t\t\tExpression::make_nil(loc));\n+      if (!len_small)\n+\tcall = Runtime::make_call(Runtime::MAKEMAP64, loc, 3, type_arg,\n+\t\t\t\t  len_arg,\n+\t\t\t\t  Expression::make_nil(loc));\n+      else\n+\t{\n+\t  Numeric_constant nclen;\n+\t  unsigned long vlen;\n+\t  if (len_arg->numeric_constant_value(&nclen)\n+\t      && nclen.to_unsigned_long(&vlen) == Numeric_constant::NC_UL_VALID\n+\t      && vlen <= Map_type::bucket_size)\n+\t    call = Runtime::make_call(Runtime::MAKEMAP_SMALL, loc, 0);\n+\t  else\n+\t    call = Runtime::make_call(Runtime::MAKEMAP, loc, 3, type_arg,\n+\t\t\t\t      len_arg,\n+\t\t\t\t      Expression::make_nil(loc));\n+\t}\n     }\n   else if (is_chan)\n     {\n@@ -9503,30 +9518,30 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n   // could implement them in normal code, but then we would have to\n   // explicitly unwind the stack.  These functions are intended to be\n   // efficient.  Note that this technique obviously only works for\n-  // direct calls, but that is the only way they are used.  The actual\n-  // argument to these functions is always the address of a parameter;\n-  // we don't need that for the GCC builtin functions, so we just\n-  // ignore it.\n-  if (gogo->compiling_runtime()\n-      && this->args_ != NULL\n-      && this->args_->size() == 1\n-      && gogo->package_name() == \"runtime\")\n+  // direct calls, but that is the only way they are used.\n+  if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n     {\n       Func_expression* fe = this->fn_->func_expression();\n       if (fe != NULL\n \t  && fe->named_object()->is_function_declaration()\n \t  && fe->named_object()->package() == NULL)\n \t{\n \t  std::string n = Gogo::unpack_hidden_name(fe->named_object()->name());\n-\t  if (n == \"getcallerpc\")\n+\t  if ((this->args_ == NULL || this->args_->size() == 0)\n+\t      && n == \"getcallerpc\")\n \t    {\n \t      static Named_object* builtin_return_address;\n \t      return this->lower_to_builtin(&builtin_return_address,\n \t\t\t\t\t    \"__builtin_return_address\",\n \t\t\t\t\t    0);\n \t    }\n-\t  else if (n == \"getcallersp\")\n+\t  else if (this->args_ != NULL\n+\t\t   && this->args_->size() == 1\n+\t\t   && n == \"getcallersp\")\n \t    {\n+\t      // The actual argument to getcallersp is always the\n+\t      // address of a parameter; we don't need that for the\n+\t      // GCC builtin function, so we just ignore it.\n \t      static Named_object* builtin_frame_address;\n \t      return this->lower_to_builtin(&builtin_frame_address,\n \t\t\t\t\t    \"__builtin_frame_address\",\n@@ -10027,7 +10042,7 @@ Call_expression::do_check_types(Gogo*)\n     }\n \n   const Typed_identifier_list* parameters = fntype->parameters();\n-  if (this->args_ == NULL)\n+  if (this->args_ == NULL || this->args_->size() == 0)\n     {\n       if (parameters != NULL && !parameters->empty())\n \tthis->report_error(_(\"not enough arguments\"));"}, {"sha": "605bcff4a0f1921112fba6f677dd4ef91da8b3a8", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -91,9 +91,14 @@ DEF_GO_RUNTIME(MAKESLICE64, \"runtime.makeslice64\", P3(TYPE, INT64, INT64),\n \t       R1(SLICE))\n \n \n-// Make a map.\n-DEF_GO_RUNTIME(MAKEMAP, \"runtime.makemap\", P4(TYPE, INT64, POINTER, POINTER),\n-\t       R1(MAP))\n+// Make a map with a hint and an (optional, unused) map structure.\n+DEF_GO_RUNTIME(MAKEMAP, \"runtime.makemap\", P3(TYPE, INT, POINTER),\n+\t\tR1(MAP))\n+DEF_GO_RUNTIME(MAKEMAP64, \"runtime.makemap64\", P3(TYPE, INT64, POINTER),\n+\t\tR1(MAP))\n+\n+// Make a map with no hint, or a small constant hint.\n+DEF_GO_RUNTIME(MAKEMAP_SMALL, \"runtime.makemap_small\", P0(), R1(MAP))\n \n // Build a map from a composite literal.\n DEF_GO_RUNTIME(CONSTRUCT_MAP, \"__go_construct_map\","}, {"sha": "85273bf55d2077b7c076e1f24d571effc1b70c30", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -7830,7 +7830,7 @@ Map_type::do_get_backend(Gogo* gogo)\n       bfields[7].btype = uintptr_type->get_backend(gogo);\n       bfields[7].location = bloc;\n \n-      bfields[8].name = \"overflow\";\n+      bfields[8].name = \"extra\";\n       bfields[8].btype = bpvt;\n       bfields[8].location = bloc;\n \n@@ -8144,21 +8144,23 @@ Map_type::hmap_type(Type* bucket_type)\n \n   Type* int_type = Type::lookup_integer_type(\"int\");\n   Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+  Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n   Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n   Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n   Type* void_ptr_type = Type::make_pointer_type(Type::make_void_type());\n \n   Type* ptr_bucket_type = Type::make_pointer_type(bucket_type);\n \n-  Struct_type* ret = make_builtin_struct_type(8,\n+  Struct_type* ret = make_builtin_struct_type(9,\n \t\t\t\t\t      \"count\", int_type,\n \t\t\t\t\t      \"flags\", uint8_type,\n \t\t\t\t\t      \"B\", uint8_type,\n+\t\t\t\t\t      \"noverflow\", uint16_type,\n \t\t\t\t\t      \"hash0\", uint32_type,\n \t\t\t\t\t      \"buckets\", ptr_bucket_type,\n \t\t\t\t\t      \"oldbuckets\", ptr_bucket_type,\n \t\t\t\t\t      \"nevacuate\", uintptr_type,\n-\t\t\t\t\t      \"overflow\", void_ptr_type);\n+\t\t\t\t\t      \"extra\", void_ptr_type);\n   ret->set_is_struct_incomparable();\n   this->hmap_type_ = ret;\n   return ret;\n@@ -8191,18 +8193,22 @@ Map_type::hiter_type(Gogo* gogo)\n   Type* hmap_type = this->hmap_type(bucket_type);\n   Type* hmap_ptr_type = Type::make_pointer_type(hmap_type);\n   Type* void_ptr_type = Type::make_pointer_type(Type::make_void_type());\n+  Type* bool_type = Type::lookup_bool_type();\n \n-  Struct_type* ret = make_builtin_struct_type(12,\n+  Struct_type* ret = make_builtin_struct_type(15,\n \t\t\t\t\t      \"key\", key_ptr_type,\n \t\t\t\t\t      \"val\", val_ptr_type,\n \t\t\t\t\t      \"t\", uint8_ptr_type,\n \t\t\t\t\t      \"h\", hmap_ptr_type,\n \t\t\t\t\t      \"buckets\", bucket_ptr_type,\n \t\t\t\t\t      \"bptr\", bucket_ptr_type,\n-\t\t\t\t\t      \"overflow0\", void_ptr_type,\n-\t\t\t\t\t      \"overflow1\", void_ptr_type,\n+\t\t\t\t\t      \"overflow\", void_ptr_type,\n+\t\t\t\t\t      \"oldoverflow\", void_ptr_type,\n \t\t\t\t\t      \"startBucket\", uintptr_type,\n-\t\t\t\t\t      \"stuff\", uintptr_type,\n+\t\t\t\t\t      \"offset\", uint8_type,\n+\t\t\t\t\t      \"wrapped\", bool_type,\n+\t\t\t\t\t      \"B\", uint8_type,\n+\t\t\t\t\t      \"i\", uint8_type,\n \t\t\t\t\t      \"bucket\", uintptr_type,\n \t\t\t\t\t      \"checkBucket\", uintptr_type);\n   ret->set_is_struct_incomparable();"}, {"sha": "08e57019a6ca22705944e24971bb93fb72b3b134", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -2826,6 +2826,9 @@ class Map_type : public Type\n   static Type*\n   make_map_type_descriptor_type();\n \n+  // This must be in  sync with libgo/go/runtime/hashmap.go.\n+  static const int bucket_size = 8;\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2867,7 +2870,6 @@ class Map_type : public Type\n \n  private:\n   // These must be in sync with libgo/go/runtime/hashmap.go.\n-  static const int bucket_size = 8;\n   static const int max_key_size = 128;\n   static const int max_val_size = 128;\n   static const int max_zero_size = 1024;"}, {"sha": "5870661b66e9cf4fca9d2639d0093dfc81bc32a3", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -331,6 +331,25 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n   if (!lhs->type()->has_pointer())\n     return false;\n \n+  // An assignment to a field is handled like an assignment to the\n+  // struct.\n+  while (true)\n+    {\n+      // Nothing to do for a type that can not be in the heap, or a\n+      // pointer to a type that can not be in the heap.  We check this\n+      // at each level of a struct.\n+      if (!lhs->type()->in_heap())\n+\treturn false;\n+      if (lhs->type()->points_to() != NULL\n+\t  && !lhs->type()->points_to()->in_heap())\n+\treturn false;\n+\n+      Field_reference_expression* fre = lhs->field_reference_expression();\n+      if (fre == NULL)\n+\tbreak;\n+      lhs = fre->expr();\n+    }\n+\n   // Nothing to do for an assignment to a temporary.\n   if (lhs->temporary_reference_expression() != NULL)\n     return false;\n@@ -359,12 +378,30 @@ Gogo::assign_needs_write_barrier(Expression* lhs)\n \t}\n     }\n \n-  // Nothing to do for a type that can not be in the heap, or a\n-  // pointer to a type that can not be in the heap.\n-  if (!lhs->type()->in_heap())\n-    return false;\n-  if (lhs->type()->points_to() != NULL && !lhs->type()->points_to()->in_heap())\n-    return false;\n+  // For a struct assignment, we don't need a write barrier if all the\n+  // pointer types can not be in the heap.\n+  Struct_type* st = lhs->type()->struct_type();\n+  if (st != NULL)\n+    {\n+      bool in_heap = false;\n+      const Struct_field_list* fields = st->fields();\n+      for (Struct_field_list::const_iterator p = fields->begin();\n+\t   p != fields->end();\n+\t   p++)\n+\t{\n+\t  Type* ft = p->type();\n+\t  if (!ft->has_pointer())\n+\t    continue;\n+\t  if (!ft->in_heap())\n+\t    continue;\n+\t  if (ft->points_to() != NULL && !ft->points_to()->in_heap())\n+\t    continue;\n+\t  in_heap = true;\n+\t  break;\n+\t}\n+      if (!in_heap)\n+\treturn false;\n+    }\n \n   // Write barrier needed in other cases.\n   return true;"}, {"sha": "70c61160faaa7b6d79423e144fd909530c2f7c8a", "filename": "gotools/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -1,3 +1,24 @@\n+2018-01-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (go_cmd_vet_files): New variable.\n+\t(go_cmd_buildid_files, go_cmd_test2json_files): New variables.\n+\t(s-zdefaultcc): Change from constants to functions.\n+\t(noinst_PROGRAMS): Add vet, buildid, and test2json.\n+\t(cgo$(EXEEXT)): Link against $(LIBGOTOOL).\n+\t(vet$(EXEEXT)): New target.\n+\t(buildid$(EXEEXT)): New target.\n+\t(test2json$(EXEEXT)): New target.\n+\t(install-exec-local): Install all $(noinst_PROGRAMS).\n+\t(uninstall-local): Uninstasll all $(noinst_PROGRAMS).\n+\t(check-go-tool): Depend on $(noinst_PROGRAMS).  Copy down\n+\tobjabi.go.\n+\t(check-runtime): Depend on $(noinst_PROGRAMS).\n+\t(check-cgo-test, check-carchive-test): Likewise.\n+\t(check-vet): New target.\n+\t(check): Depend on check-vet.  Look at cmd_vet-testlog.\n+\t(.PHONY): Add check-vet.\n+\t* Makefile.in: Rebuild.\n+\n 2017-10-25  Ian Lance Taylor  <iant@golang.org>\n \n \t* Makefile.am (check-go-tool): Output colon after ${fl}."}, {"sha": "3cecee681f32349cc5807acada2595e5a7d950e4", "filename": "gotools/Makefile.am", "status": "modified", "additions": 78, "deletions": 19, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -69,16 +69,50 @@ go_cmd_cgo_files = \\\n \t$(cmdsrcdir)/cgo/out.go \\\n \t$(cmdsrcdir)/cgo/util.go\n \n+go_cmd_vet_files = \\\n+\t$(cmdsrcdir)/vet/asmdecl.go \\\n+\t$(cmdsrcdir)/vet/assign.go \\\n+\t$(cmdsrcdir)/vet/atomic.go \\\n+\t$(cmdsrcdir)/vet/bool.go \\\n+\t$(cmdsrcdir)/vet/buildtag.go \\\n+\t$(cmdsrcdir)/vet/cgo.go \\\n+\t$(cmdsrcdir)/vet/composite.go \\\n+\t$(cmdsrcdir)/vet/copylock.go \\\n+\t$(cmdsrcdir)/vet/deadcode.go \\\n+\t$(cmdsrcdir)/vet/dead.go \\\n+\t$(cmdsrcdir)/vet/doc.go \\\n+\t$(cmdsrcdir)/vet/httpresponse.go \\\n+\t$(cmdsrcdir)/vet/lostcancel.go \\\n+\t$(cmdsrcdir)/vet/main.go \\\n+\t$(cmdsrcdir)/vet/method.go \\\n+\t$(cmdsrcdir)/vet/nilfunc.go \\\n+\t$(cmdsrcdir)/vet/print.go \\\n+\t$(cmdsrcdir)/vet/rangeloop.go \\\n+\t$(cmdsrcdir)/vet/shadow.go \\\n+\t$(cmdsrcdir)/vet/shift.go \\\n+\t$(cmdsrcdir)/vet/structtag.go \\\n+\t$(cmdsrcdir)/vet/tests.go \\\n+\t$(cmdsrcdir)/vet/types.go \\\n+\t$(cmdsrcdir)/vet/unsafeptr.go \\\n+\t$(cmdsrcdir)/vet/unused.go\n+\n+go_cmd_buildid_files = \\\n+\t$(cmdsrcdir)/buildid/buildid.go \\\n+\t$(cmdsrcdir)/buildid/doc.go\n+\n+go_cmd_test2json_files = \\\n+\t$(cmdsrcdir)/test2json/main.go\n+\n GCCGO_INSTALL_NAME := $(shell echo gccgo|sed '$(program_transform_name)')\n GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')\n GXX_INSTALL_NAME := $(shell echo g++|sed '$(program_transform_name)')\n \n zdefaultcc.go: s-zdefaultcc; @true\n s-zdefaultcc: Makefile\n \techo 'package main' > zdefaultcc.go.tmp\n-\techo 'const defaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const defaultCC = \"$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const defaultCXX = \"$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'func defaultGCCGO(goos, goarch string) string { return \"$(bindir)/$(GCCGO_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func defaultCC(goos, goarch string) string { return \"$(GCC_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func defaultCXX(goos, goarch string) string { return \"$(GXX_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n \techo 'const defaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n \t$(STAMP) $@ \n@@ -97,23 +131,33 @@ if NATIVE\n # and install them as regular programs.\n \n bin_PROGRAMS = go$(EXEEXT) gofmt$(EXEEXT)\n-noinst_PROGRAMS = cgo$(EXEEXT)\n+noinst_PROGRAMS = cgo$(EXEEXT) vet$(EXEEXT) buildid$(EXEEXT) test2json$(EXEEXT)\n man_MANS = go.1 gofmt.1\n \n go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n \t$(GOLINK) $(go_cmd_go_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n gofmt$(EXEEXT): $(go_cmd_gofmt_files) $(LIBGODEP)\n \t$(GOLINK) $(go_cmd_gofmt_files) $(LIBS) $(NET_LIBS)\n-cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGODEP)\n-\t$(GOLINK) $(go_cmd_cgo_files) zdefaultcc.go $(LIBS) $(NET_LIBS)\n-\n-install-exec-local: cgo$(EXEEXT)\n+cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBGODEP)\n+\t$(GOLINK) $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+vet$(EXEEXT): $(go_cmd_vet_files) $(LIBGOTOOL) $(LIBGODEP)\n+\t$(GOLINK) $(go_cmd_vet_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+buildid$(EXEEXT): $(go_cmd_buildid_files) $(LIBGOTOOL) $(LIBGODEP)\n+\t$(GOLINK) $(go_cmd_buildid_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+test2json$(EXEEXT): $(go_cmd_test2json_files) $(LIBGOTOOL) $(LIBGODEP)\n+\t$(GOLINK) $(go_cmd_test2json_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+\n+install-exec-local: $(noinst_PROGRAMS)\n \t$(MKDIR_P) $(DESTDIR)$(libexecsubdir)\n-\trm -f $(DESTDIR)$(libexecsubdir)/cgo$(exeext)\n-\t$(INSTALL_PROGRAM) cgo$(exeext) $(DESTDIR)$(libexecsubdir)/cgo$(exeext)\n+\tfor f in $(noinst_PROGRAMS); do \\\n+\t  rm -f $(DESTDIR)$(libexecsubdir)/$$f; \\\n+\t  $(INSTALL_PROGRAM) $$f $(DESTDIR)$(libexecsubdir)/$$f; \\\n+\tdone\n \n uninstall-local:\n-\trm -f $(DESTDIR)$(libexecsubdir)/cgo$(exeext)\n+\tfor f in $(noinst_PROGRAMS); do \\\n+\t  rm -f $(DESTDIR)$(libexecsubdir)/$$f; \\\n+\tdone\n \n GOTESTFLAGS =\n \n@@ -177,8 +221,8 @@ CHECK_ENV = \\\n # It assumes that abs_libgodir is set.\n ECHO_ENV = PATH=`echo $(abs_builddir):$${PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'` GCCGO='$(abs_builddir)/check-gccgo' CC='$(abs_builddir)/check-gcc' GCCGOTOOLDIR='$(abs_builddir)' GO_TESTING_GOTOOLS=yes LD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'` GOROOT=`echo $${abs_libgodir}`\n \n-# check-go-tools runs `go test cmd/go` in our environment.\n-check-go-tool: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+# check-go-tool runs `go test cmd/go` in our environment.\n+check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf check-go-dir cmd_go-testlog\n \t$(MKDIR_P) check-go-dir/src/cmd/go\n \tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n@@ -187,6 +231,7 @@ check-go-tool: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n \tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n \tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/\n+\tcp $(libgodir)/objabi.go check-go-dir/src/cmd/internal/objabi/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\\n \techo \"cd check-go-dir/src/cmd/go && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.v\" > cmd_go-testlog\n@@ -200,7 +245,7 @@ check-go-tool: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n # The runtime package is also tested as part of libgo,\n # but the runtime tests use the go tool heavily, so testing\n # here too will catch more problems.\n-check-runtime: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf check-runtime-dir runtime-testlog\n \t$(MKDIR_P) check-runtime-dir\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n@@ -219,7 +264,7 @@ check-runtime: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \tgrep '^--- ' runtime-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n # check-cgo-test runs `go test misc/cgo/test` in our environment.\n-check-cgo-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf cgo-test-dir cgo-testlog\n \t$(MKDIR_P) cgo-test-dir/misc/cgo\n \tcp -r $(libgomiscdir)/cgo/test cgo-test-dir/misc/cgo/\n@@ -233,7 +278,7 @@ check-cgo-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \n # check-carchive-test runs `go test misc/cgo/testcarchive/carchive_test.go`\n # in our environment.\n-check-carchive-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf carchive-test-dir carchive-testlog\n \t$(MKDIR_P) carchive-test-dir/misc/cgo\n \tcp -r $(libgomiscdir)/cgo/testcarchive carchive-test-dir/misc/cgo/\n@@ -245,11 +290,25 @@ check-carchive-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.v carchive_test.go) >> carchive-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n \tgrep '^--- ' carchive-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n+# check-vet runs `go test cmd/vet` in our environment.\n+check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n+\trm -rf check-vet-dir cmd_vet-testlog\n+\t$(MKDIR_P) check-vet-dir/src/cmd\n+\tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n+\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n+\tabs_checkdir=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n+\techo \"cd check-vet-dir/src/cmd/vet && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.v\" > cmd_vet-testlog\n+\t$(CHECK_ENV) \\\n+\tGOPATH=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n+\texport GOPATH; \\\n+\t(cd check-vet-dir/src/cmd/vet && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cmd_vet-testlog 2>&1 || echo \"--- $${fl}: go test cmd/vet (0.00s)\" >> cmd_vet-testlog\n+\tgrep '^--- ' cmd_vet-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n+\n # The check targets runs the tests and assembles the output files.\n-check: check-head check-go-tool check-runtime check-cgo-test check-carchive-test\n+check: check-head check-go-tool check-runtime check-cgo-test check-carchive-test check-vet\n \t@mv gotools.head gotools.sum\n \t@cp gotools.sum gotools.log\n-\t@for file in cmd_go-testlog runtime-testlog cgo-testlog carchive-testlog; do \\\n+\t@for file in cmd_go-testlog runtime-testlog cgo-testlog carchive-testlog cmd_vet-testlog; do \\\n \t  testname=`echo $${file} | sed -e 's/-testlog//' -e 's|_|/|'`; \\\n \t  echo \"Running $${testname}\" >> gotools.sum; \\\n \t  echo \"Running $${testname}\" >> gotools.log; \\\n@@ -275,7 +334,7 @@ check: check-head check-go-tool check-runtime check-cgo-test check-carchive-test\n \t@echo \"runtest completed at `date`\" >> gotools.log\n \t@if grep '^FAIL' gotools.sum >/dev/null 2>&1; then exit 1; fi\n \n-.PHONY: check check-head check-go-tool check-runtime check-cgo-test check-carchive-test\n+.PHONY: check check-head check-go-tool check-runtime check-cgo-test check-carchive-test check-vet\n \n else\n "}, {"sha": "77ebd158ea57509edbabd73bc4ce5a22180b7765", "filename": "gotools/Makefile.in", "status": "modified", "additions": 100, "deletions": 20, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -88,6 +88,9 @@ CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n am__installdirs = \"$(DESTDIR)$(bindir)\" \"$(DESTDIR)$(man1dir)\"\n PROGRAMS = $(bin_PROGRAMS) $(noinst_PROGRAMS)\n+buildid_SOURCES = buildid.c\n+buildid_OBJECTS = buildid.$(OBJEXT)\n+buildid_LDADD = $(LDADD)\n cgo_SOURCES = cgo.c\n cgo_OBJECTS = cgo.$(OBJEXT)\n cgo_LDADD = $(LDADD)\n@@ -97,6 +100,12 @@ go_LDADD = $(LDADD)\n gofmt_SOURCES = gofmt.c\n gofmt_OBJECTS = gofmt.$(OBJEXT)\n gofmt_LDADD = $(LDADD)\n+test2json_SOURCES = test2json.c\n+test2json_OBJECTS = test2json.$(OBJEXT)\n+test2json_LDADD = $(LDADD)\n+vet_SOURCES = vet.c\n+vet_OBJECTS = vet.$(OBJEXT)\n+vet_LDADD = $(LDADD)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n am__depfiles_maybe = depfiles\n@@ -105,7 +114,7 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n \t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n CCLD = $(CC)\n LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n-SOURCES = cgo.c go.c gofmt.c\n+SOURCES = buildid.c cgo.c go.c gofmt.c test2json.c vet.c\n am__can_run_installinfo = \\\n   case $$AM_UPDATE_INFO_DIR in \\\n     n|no|NO) false;; \\\n@@ -288,6 +297,40 @@ go_cmd_cgo_files = \\\n \t$(cmdsrcdir)/cgo/out.go \\\n \t$(cmdsrcdir)/cgo/util.go\n \n+go_cmd_vet_files = \\\n+\t$(cmdsrcdir)/vet/asmdecl.go \\\n+\t$(cmdsrcdir)/vet/assign.go \\\n+\t$(cmdsrcdir)/vet/atomic.go \\\n+\t$(cmdsrcdir)/vet/bool.go \\\n+\t$(cmdsrcdir)/vet/buildtag.go \\\n+\t$(cmdsrcdir)/vet/cgo.go \\\n+\t$(cmdsrcdir)/vet/composite.go \\\n+\t$(cmdsrcdir)/vet/copylock.go \\\n+\t$(cmdsrcdir)/vet/deadcode.go \\\n+\t$(cmdsrcdir)/vet/dead.go \\\n+\t$(cmdsrcdir)/vet/doc.go \\\n+\t$(cmdsrcdir)/vet/httpresponse.go \\\n+\t$(cmdsrcdir)/vet/lostcancel.go \\\n+\t$(cmdsrcdir)/vet/main.go \\\n+\t$(cmdsrcdir)/vet/method.go \\\n+\t$(cmdsrcdir)/vet/nilfunc.go \\\n+\t$(cmdsrcdir)/vet/print.go \\\n+\t$(cmdsrcdir)/vet/rangeloop.go \\\n+\t$(cmdsrcdir)/vet/shadow.go \\\n+\t$(cmdsrcdir)/vet/shift.go \\\n+\t$(cmdsrcdir)/vet/structtag.go \\\n+\t$(cmdsrcdir)/vet/tests.go \\\n+\t$(cmdsrcdir)/vet/types.go \\\n+\t$(cmdsrcdir)/vet/unsafeptr.go \\\n+\t$(cmdsrcdir)/vet/unused.go\n+\n+go_cmd_buildid_files = \\\n+\t$(cmdsrcdir)/buildid/buildid.go \\\n+\t$(cmdsrcdir)/buildid/doc.go\n+\n+go_cmd_test2json_files = \\\n+\t$(cmdsrcdir)/test2json/main.go\n+\n GCCGO_INSTALL_NAME := $(shell echo gccgo|sed '$(program_transform_name)')\n GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')\n GXX_INSTALL_NAME := $(shell echo g++|sed '$(program_transform_name)')\n@@ -300,7 +343,7 @@ MOSTLYCLEANFILES = \\\n # For a native build we build the programs using the newly built libgo\n # and install them as regular programs.\n @NATIVE_TRUE@bin_PROGRAMS = go$(EXEEXT) gofmt$(EXEEXT)\n-@NATIVE_TRUE@noinst_PROGRAMS = cgo$(EXEEXT)\n+@NATIVE_TRUE@noinst_PROGRAMS = cgo$(EXEEXT) vet$(EXEEXT) buildid$(EXEEXT) test2json$(EXEEXT)\n @NATIVE_TRUE@man_MANS = go.1 gofmt.1\n @NATIVE_TRUE@GOTESTFLAGS = \n \n@@ -411,6 +454,9 @@ clean-binPROGRAMS:\n \n clean-noinstPROGRAMS:\n \t-test -z \"$(noinst_PROGRAMS)\" || rm -f $(noinst_PROGRAMS)\n+@NATIVE_FALSE@buildid$(EXEEXT): $(buildid_OBJECTS) $(buildid_DEPENDENCIES) $(EXTRA_buildid_DEPENDENCIES) \n+@NATIVE_FALSE@\t@rm -f buildid$(EXEEXT)\n+@NATIVE_FALSE@\t$(LINK) $(buildid_OBJECTS) $(buildid_LDADD) $(LIBS)\n @NATIVE_FALSE@cgo$(EXEEXT): $(cgo_OBJECTS) $(cgo_DEPENDENCIES) $(EXTRA_cgo_DEPENDENCIES) \n @NATIVE_FALSE@\t@rm -f cgo$(EXEEXT)\n @NATIVE_FALSE@\t$(LINK) $(cgo_OBJECTS) $(cgo_LDADD) $(LIBS)\n@@ -420,16 +466,25 @@ clean-noinstPROGRAMS:\n @NATIVE_FALSE@gofmt$(EXEEXT): $(gofmt_OBJECTS) $(gofmt_DEPENDENCIES) $(EXTRA_gofmt_DEPENDENCIES) \n @NATIVE_FALSE@\t@rm -f gofmt$(EXEEXT)\n @NATIVE_FALSE@\t$(LINK) $(gofmt_OBJECTS) $(gofmt_LDADD) $(LIBS)\n+@NATIVE_FALSE@test2json$(EXEEXT): $(test2json_OBJECTS) $(test2json_DEPENDENCIES) $(EXTRA_test2json_DEPENDENCIES) \n+@NATIVE_FALSE@\t@rm -f test2json$(EXEEXT)\n+@NATIVE_FALSE@\t$(LINK) $(test2json_OBJECTS) $(test2json_LDADD) $(LIBS)\n+@NATIVE_FALSE@vet$(EXEEXT): $(vet_OBJECTS) $(vet_DEPENDENCIES) $(EXTRA_vet_DEPENDENCIES) \n+@NATIVE_FALSE@\t@rm -f vet$(EXEEXT)\n+@NATIVE_FALSE@\t$(LINK) $(vet_OBJECTS) $(vet_LDADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n \n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/buildid.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cgo.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gofmt.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test2json.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vet.Po@am__quote@\n \n .c.o:\n @am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@@ -676,9 +731,9 @@ uninstall-man: uninstall-man1\n zdefaultcc.go: s-zdefaultcc; @true\n s-zdefaultcc: Makefile\n \techo 'package main' > zdefaultcc.go.tmp\n-\techo 'const defaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const defaultCC = \"$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const defaultCXX = \"$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'func defaultGCCGO(goos, goarch string) string { return \"$(bindir)/$(GCCGO_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func defaultCC(goos, goarch string) string { return \"$(GCC_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func defaultCXX(goos, goarch string) string { return \"$(GXX_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n \techo 'const defaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n \t$(STAMP) $@ \n@@ -690,16 +745,26 @@ mostlyclean-local:\n @NATIVE_TRUE@\t$(GOLINK) $(go_cmd_go_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n @NATIVE_TRUE@gofmt$(EXEEXT): $(go_cmd_gofmt_files) $(LIBGODEP)\n @NATIVE_TRUE@\t$(GOLINK) $(go_cmd_gofmt_files) $(LIBS) $(NET_LIBS)\n-@NATIVE_TRUE@cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGODEP)\n-@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_cgo_files) zdefaultcc.go $(LIBS) $(NET_LIBS)\n-\n-@NATIVE_TRUE@install-exec-local: cgo$(EXEEXT)\n+@NATIVE_TRUE@cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBGODEP)\n+@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+@NATIVE_TRUE@vet$(EXEEXT): $(go_cmd_vet_files) $(LIBGOTOOL) $(LIBGODEP)\n+@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_vet_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+@NATIVE_TRUE@buildid$(EXEEXT): $(go_cmd_buildid_files) $(LIBGOTOOL) $(LIBGODEP)\n+@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_buildid_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+@NATIVE_TRUE@test2json$(EXEEXT): $(go_cmd_test2json_files) $(LIBGOTOOL) $(LIBGODEP)\n+@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_test2json_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n+\n+@NATIVE_TRUE@install-exec-local: $(noinst_PROGRAMS)\n @NATIVE_TRUE@\t$(MKDIR_P) $(DESTDIR)$(libexecsubdir)\n-@NATIVE_TRUE@\trm -f $(DESTDIR)$(libexecsubdir)/cgo$(exeext)\n-@NATIVE_TRUE@\t$(INSTALL_PROGRAM) cgo$(exeext) $(DESTDIR)$(libexecsubdir)/cgo$(exeext)\n+@NATIVE_TRUE@\tfor f in $(noinst_PROGRAMS); do \\\n+@NATIVE_TRUE@\t  rm -f $(DESTDIR)$(libexecsubdir)/$$f; \\\n+@NATIVE_TRUE@\t  $(INSTALL_PROGRAM) $$f $(DESTDIR)$(libexecsubdir)/$$f; \\\n+@NATIVE_TRUE@\tdone\n \n @NATIVE_TRUE@uninstall-local:\n-@NATIVE_TRUE@\trm -f $(DESTDIR)$(libexecsubdir)/cgo$(exeext)\n+@NATIVE_TRUE@\tfor f in $(noinst_PROGRAMS); do \\\n+@NATIVE_TRUE@\t  rm -f $(DESTDIR)$(libexecsubdir)/$$f; \\\n+@NATIVE_TRUE@\tdone\n \n # Run tests using the go tool, and frob the output to look like that\n # generated by DejaGNU.  The main output of this is two files:\n@@ -735,8 +800,8 @@ mostlyclean-local:\n @NATIVE_TRUE@\tchmod +x $@.tmp\n @NATIVE_TRUE@\tmv -f $@.tmp $@\n \n-# check-go-tools runs `go test cmd/go` in our environment.\n-@NATIVE_TRUE@check-go-tool: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+# check-go-tool runs `go test cmd/go` in our environment.\n+@NATIVE_TRUE@check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf check-go-dir cmd_go-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/cmd/go\n @NATIVE_TRUE@\tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n@@ -745,6 +810,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/\n+@NATIVE_TRUE@\tcp $(libgodir)/objabi.go check-go-dir/src/cmd/internal/objabi/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\techo \"cd check-go-dir/src/cmd/go && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.v\" > cmd_go-testlog\n@@ -758,7 +824,7 @@ mostlyclean-local:\n # The runtime package is also tested as part of libgo,\n # but the runtime tests use the go tool heavily, so testing\n # here too will catch more problems.\n-@NATIVE_TRUE@check-runtime: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+@NATIVE_TRUE@check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf check-runtime-dir runtime-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) check-runtime-dir\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n@@ -777,7 +843,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\tgrep '^--- ' runtime-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n # check-cgo-test runs `go test misc/cgo/test` in our environment.\n-@NATIVE_TRUE@check-cgo-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+@NATIVE_TRUE@check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf cgo-test-dir cgo-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) cgo-test-dir/misc/cgo\n @NATIVE_TRUE@\tcp -r $(libgomiscdir)/cgo/test cgo-test-dir/misc/cgo/\n@@ -791,7 +857,7 @@ mostlyclean-local:\n \n # check-carchive-test runs `go test misc/cgo/testcarchive/carchive_test.go`\n # in our environment.\n-@NATIVE_TRUE@check-carchive-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n+@NATIVE_TRUE@check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf carchive-test-dir carchive-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) carchive-test-dir/misc/cgo\n @NATIVE_TRUE@\tcp -r $(libgomiscdir)/cgo/testcarchive carchive-test-dir/misc/cgo/\n@@ -803,11 +869,25 @@ mostlyclean-local:\n @NATIVE_TRUE@\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.v carchive_test.go) >> carchive-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n @NATIVE_TRUE@\tgrep '^--- ' carchive-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n+# check-vet runs `go test cmd/vet` in our environment.\n+@NATIVE_TRUE@check-vet: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n+@NATIVE_TRUE@\trm -rf check-vet-dir cmd_vet-testlog\n+@NATIVE_TRUE@\t$(MKDIR_P) check-vet-dir/src/cmd\n+@NATIVE_TRUE@\tcp -r $(cmdsrcdir)/vet check-vet-dir/src/cmd/\n+@NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n+@NATIVE_TRUE@\tabs_checkdir=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n+@NATIVE_TRUE@\techo \"cd check-vet-dir/src/cmd/vet && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.v\" > cmd_vet-testlog\n+@NATIVE_TRUE@\t$(CHECK_ENV) \\\n+@NATIVE_TRUE@\tGOPATH=`cd check-vet-dir && $(PWD_COMMAND)`; \\\n+@NATIVE_TRUE@\texport GOPATH; \\\n+@NATIVE_TRUE@\t(cd check-vet-dir/src/cmd/vet && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cmd_vet-testlog 2>&1 || echo \"--- $${fl}: go test cmd/vet (0.00s)\" >> cmd_vet-testlog\n+@NATIVE_TRUE@\tgrep '^--- ' cmd_vet-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n+\n # The check targets runs the tests and assembles the output files.\n-@NATIVE_TRUE@check: check-head check-go-tool check-runtime check-cgo-test check-carchive-test\n+@NATIVE_TRUE@check: check-head check-go-tool check-runtime check-cgo-test check-carchive-test check-vet\n @NATIVE_TRUE@\t@mv gotools.head gotools.sum\n @NATIVE_TRUE@\t@cp gotools.sum gotools.log\n-@NATIVE_TRUE@\t@for file in cmd_go-testlog runtime-testlog cgo-testlog carchive-testlog; do \\\n+@NATIVE_TRUE@\t@for file in cmd_go-testlog runtime-testlog cgo-testlog carchive-testlog cmd_vet-testlog; do \\\n @NATIVE_TRUE@\t  testname=`echo $${file} | sed -e 's/-testlog//' -e 's|_|/|'`; \\\n @NATIVE_TRUE@\t  echo \"Running $${testname}\" >> gotools.sum; \\\n @NATIVE_TRUE@\t  echo \"Running $${testname}\" >> gotools.log; \\\n@@ -833,7 +913,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\t@echo \"runtest completed at `date`\" >> gotools.log\n @NATIVE_TRUE@\t@if grep '^FAIL' gotools.sum >/dev/null 2>&1; then exit 1; fi\n \n-@NATIVE_TRUE@.PHONY: check check-head check-go-tool check-runtime check-cgo-test check-carchive-test\n+@NATIVE_TRUE@.PHONY: check check-head check-go-tool check-runtime check-cgo-test check-carchive-test check-vet\n \n # For a non-native build we have to build the programs using a\n # previously built host (or build -> host) Go compiler.  We should"}, {"sha": "29faa72cbadfc65717e60b8307bd6c610f5ca439", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -1,4 +1,4 @@\n-c8aec4095e089ff6ac50d18e97c3f46561f14f48\n+9ce6b5c2ed5d3d5251b9a6a0c548d5fb2c8567e8\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "d5ea8f6e9ab72d68b888e013d2b427e86dc94757", "filename": "libgo/Makefile.am", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -400,8 +400,11 @@ toolexeclibgounicode_DATA = \\\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n noinst_DATA = \\\n+\tgolang_org/x/net/internal/nettest.gox \\\n+\tgolang_org/x/net/nettest.gox \\\n \tinternal/testenv.gox \\\n-\tnet/internal/socktest.gox\n+\tnet/internal/socktest.gox \\\n+\tos/signal/internal/pty.gox\n \n if LIBGO_IS_RTEMS\n rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n@@ -533,6 +536,24 @@ s-version: Makefile\n \t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n \t$(STAMP) $@\n \n+objabi.go: s-objabi; @true\n+s-objabi: Makefile\n+\trm -f objabi.go.tmp\n+\techo \"package objabi\" > objabi.go.tmp\n+\techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n+\techo 'const defaultGOROOT = `$(prefix)`' >> objabi.go.tmp\n+\techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n+\techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n+\techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n+\techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n+\techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n+\techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n+\techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n+\techo 'const stackGuardMultiplier = 1' >> objabi.go.tmp\n+\techo 'const goexperiment = ``' >> objabi.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh objabi.go.tmp objabi.go\n+\t$(STAMP) $@\n+\n runtime_sysinfo.go: s-runtime_sysinfo; @true\n s-runtime_sysinfo: $(srcdir)/mkrsysinfo.sh gen-sysinfo.go\n \tGOARCH=$(GOARCH) GOOS=$(GOOS) $(SHELL) $(srcdir)/mkrsysinfo.sh\n@@ -553,10 +574,11 @@ zdefaultcc.go: s-zdefaultcc; @true\n s-zdefaultcc: Makefile\n \techo 'package cfg' > zdefaultcc.go.tmp\n \techo >> zdefaultcc.go.tmp\n-\techo 'const DefaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const DefaultCC = \"$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const DefaultCXX = \"$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'func DefaultGCCGO(goos, goarch string) string { return \"$(bindir)/$(GCCGO_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func DefaultCC(goos, goarch string) string { return \"$(GCC_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func DefaultCXX(goos, goarch string) string { return \"$(GXX_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n \techo 'const DefaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n+\techo 'var OSArchSupportsCgo = map[string]bool{}' >> zdefaultcc.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n \t$(STAMP) $@ \n \n@@ -758,11 +780,15 @@ PACKAGES = \\\n \tgo/types \\\n \tgolang_org/x/crypto/chacha20poly1305 \\\n \tgolang_org/x/crypto/chacha20poly1305/internal/chacha20 \\\n+\tgolang_org/x/crypto/cryptobyte \\\n+\tgolang_org/x/crypto/cryptobyte/asn1 \\\n \tgolang_org/x/crypto/curve25519 \\\n \tgolang_org/x/crypto/poly1305 \\\n \tgolang_org/x/net/http2/hpack \\\n \tgolang_org/x/net/idna \\\n+\tgolang_org/x/net/internal/nettest \\\n \tgolang_org/x/net/lex/httplex \\\n+\tgolang_org/x/net/nettest \\\n \tgolang_org/x/net/proxy \\\n \tgolang_org/x/text/secure/bidirule \\\n \tgolang_org/x/text/transform \\\n@@ -824,6 +850,7 @@ PACKAGES = \\\n \tos \\\n \tos/exec \\\n \tos/signal \\\n+\tos/signal/internal/pty \\\n \tos/user \\\n \tpath \\\n \tpath/filepath \\\n@@ -905,7 +932,7 @@ libgolibbegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n GOTOOL_PACKAGES = \\\n \tcmd/go/internal/base \\\n \tcmd/go/internal/bug \\\n-\tcmd/go/internal/buildid \\\n+\tcmd/go/internal/cache \\\n \tcmd/go/internal/cfg \\\n \tcmd/go/internal/clean \\\n \tcmd/go/internal/cmdflag \\\n@@ -927,7 +954,12 @@ GOTOOL_PACKAGES = \\\n \tcmd/go/internal/web \\\n \tcmd/go/internal/work \\\n \tcmd/internal/browser \\\n-\tcmd/internal/objabi\n+\tcmd/internal/buildid \\\n+\tcmd/internal/edit \\\n+\tcmd/internal/objabi \\\n+\tcmd/internal/test2json \\\n+\tcmd/vet/internal/cfg \\\n+\tcmd/vet/internal/whitelist\n \n libgotool_a_SOURCES =\n libgotool_a_DEPENDENCIES = $(addsuffix .lo,$(GOTOOL_PACKAGES))\n@@ -1136,17 +1168,23 @@ runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n \n+extra_go_files_cmd_internal_objabi = objabi.go\n+cmd/internal/objabi.lo.dep: $(extra_go_files_cmd_internal_objabi)\n+\n extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n \n extra_go_files_cmd_go_internal_load = zstdpkglist.go\n cmd/go/internal/load.lo.dep: $(extra_go_files_cmd_go_internal_load)\n \n+extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n \n+extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n+\n # FIXME: The following C files may as well move to the runtime\n # directory and be treated like other C files.\n \n@@ -1233,10 +1271,12 @@ TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n \tcontext/check \\\n+\tcrypto/check \\\n \terrors/check \\\n \texpvar/check \\\n \tflag/check \\\n \tfmt/check \\\n+\thash/check \\\n \thtml/check \\\n \timage/check \\\n \tio/check \\\n@@ -1258,11 +1298,16 @@ TEST_PACKAGES = \\\n \tunicode/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n+\tcmd/go/internal/cache/check \\\n \tcmd/go/internal/generate/check \\\n \tcmd/go/internal/get/check \\\n \tcmd/go/internal/load/check \\\n \tcmd/go/internal/work/check \\\n+\tcmd/internal/buildid/check \\\n+\tcmd/internal/edit/check \\\n \tcmd/internal/objabi/check \\\n+\tcmd/internal/test2json/check \\\n+\tcmd/vet/internal/cfg/check \\\n \tcompress/bzip2/check \\\n \tcompress/flate/check \\\n \tcompress/gzip/check \\\n@@ -1315,6 +1360,7 @@ TEST_PACKAGES = \\\n \tgo/constant/check \\\n \tgo/doc/check \\\n \tgo/format/check \\\n+\tgo/importer/check \\\n \tgo/internal/gcimporter/check \\\n \tgo/internal/gccgoimporter/check \\\n \tgo/internal/srcimporter/check \\\n@@ -1325,6 +1371,7 @@ TEST_PACKAGES = \\\n \tgo/types/check \\\n \tgolang_org/x/crypto/chacha20poly1305/check \\\n \tgolang_org/x/crypto/chacha20poly1305/internal/chacha20/check \\\n+\tgolang_org/x/crypto/cryptobyte/check \\\n \tgolang_org/x/crypto/curve25519/check \\\n \tgolang_org/x/crypto/poly1305/check \\\n \tgolang_org/x/net/http2/hpack/check \\"}, {"sha": "6e03b89e4074fc03e55008b1498e9e8e5e53fb98", "filename": "libgo/Makefile.in", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -770,7 +770,9 @@ toolexeclibgounicode_DATA = \\\n # Some packages are only needed for tests, so unlike the other\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n-noinst_DATA = internal/testenv.gox net/internal/socktest.gox \\\n+noinst_DATA = golang_org/x/net/internal/nettest.gox \\\n+\tgolang_org/x/net/nettest.gox internal/testenv.gox \\\n+\tnet/internal/socktest.gox os/signal/internal/pty.gox \\\n \tzstdpkglist.go zdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n@@ -909,11 +911,15 @@ PACKAGES = \\\n \tgo/types \\\n \tgolang_org/x/crypto/chacha20poly1305 \\\n \tgolang_org/x/crypto/chacha20poly1305/internal/chacha20 \\\n+\tgolang_org/x/crypto/cryptobyte \\\n+\tgolang_org/x/crypto/cryptobyte/asn1 \\\n \tgolang_org/x/crypto/curve25519 \\\n \tgolang_org/x/crypto/poly1305 \\\n \tgolang_org/x/net/http2/hpack \\\n \tgolang_org/x/net/idna \\\n+\tgolang_org/x/net/internal/nettest \\\n \tgolang_org/x/net/lex/httplex \\\n+\tgolang_org/x/net/nettest \\\n \tgolang_org/x/net/proxy \\\n \tgolang_org/x/text/secure/bidirule \\\n \tgolang_org/x/text/transform \\\n@@ -975,6 +981,7 @@ PACKAGES = \\\n \tos \\\n \tos/exec \\\n \tos/signal \\\n+\tos/signal/internal/pty \\\n \tos/user \\\n \tpath \\\n \tpath/filepath \\\n@@ -1053,7 +1060,7 @@ libgolibbegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n GOTOOL_PACKAGES = \\\n \tcmd/go/internal/base \\\n \tcmd/go/internal/bug \\\n-\tcmd/go/internal/buildid \\\n+\tcmd/go/internal/cache \\\n \tcmd/go/internal/cfg \\\n \tcmd/go/internal/clean \\\n \tcmd/go/internal/cmdflag \\\n@@ -1075,7 +1082,12 @@ GOTOOL_PACKAGES = \\\n \tcmd/go/internal/web \\\n \tcmd/go/internal/work \\\n \tcmd/internal/browser \\\n-\tcmd/internal/objabi\n+\tcmd/internal/buildid \\\n+\tcmd/internal/edit \\\n+\tcmd/internal/objabi \\\n+\tcmd/internal/test2json \\\n+\tcmd/vet/internal/cfg \\\n+\tcmd/vet/internal/whitelist\n \n libgotool_a_SOURCES = \n libgotool_a_DEPENDENCIES = $(addsuffix .lo,$(GOTOOL_PACKAGES))\n@@ -1210,12 +1222,15 @@ runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n+extra_go_files_cmd_internal_objabi = objabi.go\n extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n extra_go_files_cmd_go_internal_load = zstdpkglist.go\n+extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n @HAVE_STAT_TIMESPEC_FALSE@@LIBGO_IS_SOLARIS_TRUE@matchargs_os = \n \n # Solaris 11.4 changed the type of fields in struct stat.\n@@ -1238,10 +1253,12 @@ TEST_PACKAGES = \\\n \tbufio/check \\\n \tbytes/check \\\n \tcontext/check \\\n+\tcrypto/check \\\n \terrors/check \\\n \texpvar/check \\\n \tflag/check \\\n \tfmt/check \\\n+\thash/check \\\n \thtml/check \\\n \timage/check \\\n \tio/check \\\n@@ -1263,11 +1280,16 @@ TEST_PACKAGES = \\\n \tunicode/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n+\tcmd/go/internal/cache/check \\\n \tcmd/go/internal/generate/check \\\n \tcmd/go/internal/get/check \\\n \tcmd/go/internal/load/check \\\n \tcmd/go/internal/work/check \\\n+\tcmd/internal/buildid/check \\\n+\tcmd/internal/edit/check \\\n \tcmd/internal/objabi/check \\\n+\tcmd/internal/test2json/check \\\n+\tcmd/vet/internal/cfg/check \\\n \tcompress/bzip2/check \\\n \tcompress/flate/check \\\n \tcompress/gzip/check \\\n@@ -1320,6 +1342,7 @@ TEST_PACKAGES = \\\n \tgo/constant/check \\\n \tgo/doc/check \\\n \tgo/format/check \\\n+\tgo/importer/check \\\n \tgo/internal/gcimporter/check \\\n \tgo/internal/gccgoimporter/check \\\n \tgo/internal/srcimporter/check \\\n@@ -1330,6 +1353,7 @@ TEST_PACKAGES = \\\n \tgo/types/check \\\n \tgolang_org/x/crypto/chacha20poly1305/check \\\n \tgolang_org/x/crypto/chacha20poly1305/internal/chacha20/check \\\n+\tgolang_org/x/crypto/cryptobyte/check \\\n \tgolang_org/x/crypto/curve25519/check \\\n \tgolang_org/x/crypto/poly1305/check \\\n \tgolang_org/x/net/http2/hpack/check \\\n@@ -3130,6 +3154,24 @@ s-version: Makefile\n \t$(SHELL) $(srcdir)/mvifdiff.sh version.go.tmp version.go\n \t$(STAMP) $@\n \n+objabi.go: s-objabi; @true\n+s-objabi: Makefile\n+\trm -f objabi.go.tmp\n+\techo \"package objabi\" > objabi.go.tmp\n+\techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n+\techo 'const defaultGOROOT = `$(prefix)`' >> objabi.go.tmp\n+\techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n+\techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n+\techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n+\techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n+\techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n+\techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n+\techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n+\techo 'const stackGuardMultiplier = 1' >> objabi.go.tmp\n+\techo 'const goexperiment = ``' >> objabi.go.tmp\n+\t$(SHELL) $(srcdir)/mvifdiff.sh objabi.go.tmp objabi.go\n+\t$(STAMP) $@\n+\n runtime_sysinfo.go: s-runtime_sysinfo; @true\n s-runtime_sysinfo: $(srcdir)/mkrsysinfo.sh gen-sysinfo.go\n \tGOARCH=$(GOARCH) GOOS=$(GOOS) $(SHELL) $(srcdir)/mkrsysinfo.sh\n@@ -3146,10 +3188,11 @@ zdefaultcc.go: s-zdefaultcc; @true\n s-zdefaultcc: Makefile\n \techo 'package cfg' > zdefaultcc.go.tmp\n \techo >> zdefaultcc.go.tmp\n-\techo 'const DefaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const DefaultCC = \"$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n-\techo 'const DefaultCXX = \"$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'func DefaultGCCGO(goos, goarch string) string { return \"$(bindir)/$(GCCGO_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func DefaultCC(goos, goarch string) string { return \"$(GCC_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n+\techo 'func DefaultCXX(goos, goarch string) string { return \"$(GXX_INSTALL_NAME)\" }' >> zdefaultcc.go.tmp\n \techo 'const DefaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n+\techo 'var OSArchSupportsCgo = map[string]bool{}' >> zdefaultcc.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n \t$(STAMP) $@ \n \n@@ -3305,6 +3348,7 @@ $(foreach package,$(GOTOOL_PACKAGES),$(eval $(call PACKAGE_template,$(package)))\n runtime.lo.dep: $(extra_go_files_runtime)\n syscall.lo.dep: $(extra_go_files_syscall)\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n+cmd/internal/objabi.lo.dep: $(extra_go_files_cmd_internal_objabi)\n cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n cmd/go/internal/load.lo.dep: $(extra_go_files_cmd_go_internal_load)\n "}, {"sha": "eb8d74cd88b6574fd0f1bbfbb692879b7d82bea7", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -1 +1 @@\n-go1.9\n+go1.10beta1"}, {"sha": "eeccf25bccc1afad4d4381430cb311d22b5afa43", "filename": "libgo/configure", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -2494,7 +2494,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=12:0:0\n+libtool_VERSION=13:0:0\n \n \n # Default to --enable-multilib\n@@ -13652,7 +13652,7 @@ ALLGOARCHFAMILY=\"I386 ALPHA AMD64 ARM ARM64 IA64 M68K MIPS MIPS64 PPC PPC64 S390\n \n GOARCH=unknown\n GOARCH_FAMILY=unknown\n-GOARCH_BIGENDIAN=0\n+GOARCH_BIGENDIAN=false\n GOARCH_CACHELINESIZE=64\n GOARCH_PHYSPAGESIZE=4096\n GOARCH_PCQUANTUM=1\n@@ -13680,6 +13680,12 @@ case ${host} in\n     GOARCH_CACHELINESIZE=32\n     GOARCH_PCQUANTUM=4\n     GOARCH_MINFRAMESIZE=4\n+    case ${host} in\n+      arm*b*-*-*)\n+\tGOARCH=armbe\n+        GOARCH_BIGENDIAN=true\n+\t;;\n+    esac\n     ;;\n   i[34567]86-*-* | x86_64-*-*)\n     cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n@@ -13712,7 +13718,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n   m68k*-*-*)\n     GOARCH=m68k\n     GOARCH_FAMILY=M68K\n-    GOARCH_BIGENDIAN=1\n+    GOARCH_BIGENDIAN=true\n     GOARCH_CACHELINESIZE=16\n     GOARCH_PCQUANTUM=4\n     GOARCH_INT64ALIGN=2\n@@ -13776,7 +13782,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n         GOARCH=\"${GOARCH}le\"\n         ;;\n     *)\n-\tGOARCH_BIGENDIAN=1\n+\tGOARCH_BIGENDIAN=true\n         ;;\n     esac\n     GOARCH_CACHELINESIZE=32\n@@ -13794,7 +13800,7 @@ _ACEOF\n if ac_fn_c_try_compile \"$LINENO\"; then :\n   GOARCH=ppc\n GOARCH_FAMILY=PPC\n-GOARCH_BIGENDIAN=1\n+GOARCH_BIGENDIAN=true\n \n else\n \n@@ -13811,7 +13817,7 @@ if ac_fn_c_try_compile \"$LINENO\"; then :\n \n else\n   GOARCH=ppc64\n-GOARCH_BIGENDIAN=1\n+GOARCH_BIGENDIAN=true\n \n fi\n rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n@@ -13841,7 +13847,7 @@ GOARCH_MINFRAMESIZE=8\n \n fi\n rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-    GOARCH_BIGENDIAN=1\n+    GOARCH_BIGENDIAN=true\n     GOARCH_CACHELINESIZE=256\n     GOARCH_PCQUANTUM=2\n     ;;\n@@ -13863,7 +13869,7 @@ GOARCH_FAMILY=SPARC64\n \n fi\n rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-    GOARCH_BIGENDIAN=1\n+    GOARCH_BIGENDIAN=true\n     GOARCH_PHYSPAGESIZE=8192\n     GOARCH_PCQUANTUM=4\n     ;;\n@@ -15142,7 +15148,7 @@ fi\n $as_echo \"$libgo_cv_c_fancymath\" >&6; }\n MATH_FLAG=\n if test \"$libgo_cv_c_fancymath\" = yes; then\n-  MATH_FLAG=\"-mfancy-math-387 -funsafe-math-optimizations\"\n+  MATH_FLAG=\"-mfancy-math-387 -funsafe-math-optimizations -fno-math-errno\"\n else\n   MATH_FLAG=\"-ffp-contract=off\"\n fi"}, {"sha": "9a9da38d605783f73f77787f07e3894d53f0608f", "filename": "libgo/configure.ac", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -11,7 +11,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=12:0:0\n+libtool_VERSION=13:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)\n@@ -215,7 +215,7 @@ ALLGOARCHFAMILY=\"I386 ALPHA AMD64 ARM ARM64 IA64 M68K MIPS MIPS64 PPC PPC64 S390\n \n GOARCH=unknown\n GOARCH_FAMILY=unknown\n-GOARCH_BIGENDIAN=0\n+GOARCH_BIGENDIAN=false\n GOARCH_CACHELINESIZE=64\n GOARCH_PHYSPAGESIZE=4096\n GOARCH_PCQUANTUM=1\n@@ -243,6 +243,12 @@ case ${host} in\n     GOARCH_CACHELINESIZE=32\n     GOARCH_PCQUANTUM=4\n     GOARCH_MINFRAMESIZE=4\n+    case ${host} in\n+      arm*b*-*-*)\n+\tGOARCH=armbe\n+        GOARCH_BIGENDIAN=true\n+\t;;\n+    esac\n     ;;\n changequote(,)dnl\n   i[34567]86-*-* | x86_64-*-*)\n@@ -270,7 +276,7 @@ GOARCH_HUGEPAGESIZE=\"1 << 21\"\n   m68k*-*-*)\n     GOARCH=m68k\n     GOARCH_FAMILY=M68K\n-    GOARCH_BIGENDIAN=1\n+    GOARCH_BIGENDIAN=true\n     GOARCH_CACHELINESIZE=16\n     GOARCH_PCQUANTUM=4\n     GOARCH_INT64ALIGN=2\n@@ -313,7 +319,7 @@ GOARCH_HUGEPAGESIZE=\"1 << 21\"\n         GOARCH=\"${GOARCH}le\"\n         ;;\n     *)\n-\tGOARCH_BIGENDIAN=1\n+\tGOARCH_BIGENDIAN=true\n         ;;\n     esac\n     GOARCH_CACHELINESIZE=32\n@@ -327,7 +333,7 @@ GOARCH_HUGEPAGESIZE=\"1 << 21\"\n #endif],\n [GOARCH=ppc\n GOARCH_FAMILY=PPC\n-GOARCH_BIGENDIAN=1\n+GOARCH_BIGENDIAN=true\n ],\n     [\n GOARCH_FAMILY=PPC64\n@@ -338,7 +344,7 @@ AC_COMPILE_IFELSE([\n [GOARCH=ppc64le\n ],\n [GOARCH=ppc64\n-GOARCH_BIGENDIAN=1\n+GOARCH_BIGENDIAN=true\n ])])\n     GOARCH_PHYSPAGESIZE=65536\n     GOARCH_PCQUANTUM=4\n@@ -356,7 +362,7 @@ GOARCH_MINFRAMESIZE=4\n GOARCH_FAMILY=S390X\n GOARCH_MINFRAMESIZE=8\n ])\n-    GOARCH_BIGENDIAN=1\n+    GOARCH_BIGENDIAN=true\n     GOARCH_CACHELINESIZE=256\n     GOARCH_PCQUANTUM=2\n     ;;\n@@ -371,7 +377,7 @@ GOARCH_FAMILY=SPARC\n [GOARCH=sparc64\n GOARCH_FAMILY=SPARC64\n ])\n-    GOARCH_BIGENDIAN=1\n+    GOARCH_BIGENDIAN=true\n     GOARCH_PHYSPAGESIZE=8192\n     GOARCH_PCQUANTUM=4\n     ;;\n@@ -718,7 +724,7 @@ AC_COMPILE_IFELSE([int i;],\n CFLAGS=$CFLAGS_hold])\n MATH_FLAG=\n if test \"$libgo_cv_c_fancymath\" = yes; then\n-  MATH_FLAG=\"-mfancy-math-387 -funsafe-math-optimizations\"\n+  MATH_FLAG=\"-mfancy-math-387 -funsafe-math-optimizations -fno-math-errno\"\n else\n   MATH_FLAG=\"-ffp-contract=off\"\n fi"}, {"sha": "4a2c173bf3a7c669b56db744a2e1627ef4b3f402", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 522, "deletions": 86, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -3,63 +3,523 @@\n // license that can be found in the LICENSE file.\n \n // Package tar implements access to tar archives.\n-// It aims to cover most of the variations, including those produced\n-// by GNU and BSD tars.\n //\n-// References:\n-//   http://www.freebsd.org/cgi/man.cgi?query=tar&sektion=5\n-//   http://www.gnu.org/software/tar/manual/html_node/Standard.html\n-//   http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html\n+// Tape archives (tar) are a file format for storing a sequence of files that\n+// can be read and written in a streaming manner.\n+// This package aims to cover most variations of the format,\n+// including those produced by GNU and BSD tar tools.\n package tar\n \n import (\n \t\"errors\"\n \t\"fmt\"\n+\t\"math\"\n \t\"os\"\n \t\"path\"\n+\t\"reflect\"\n+\t\"strconv\"\n+\t\"strings\"\n \t\"time\"\n )\n \n // BUG: Use of the Uid and Gid fields in Header could overflow on 32-bit\n // architectures. If a large value is encountered when decoding, the result\n // stored in Header will be the truncated version.\n \n-// Header type flags.\n+var (\n+\tErrHeader          = errors.New(\"archive/tar: invalid tar header\")\n+\tErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n+\tErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n+\tErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n+\terrMissData        = errors.New(\"archive/tar: sparse file references non-existent data\")\n+\terrUnrefData       = errors.New(\"archive/tar: sparse file contains unreferenced data\")\n+\terrWriteHole       = errors.New(\"archive/tar: write non-NUL byte in sparse hole\")\n+)\n+\n+type headerError []string\n+\n+func (he headerError) Error() string {\n+\tconst prefix = \"archive/tar: cannot encode header\"\n+\tvar ss []string\n+\tfor _, s := range he {\n+\t\tif s != \"\" {\n+\t\t\tss = append(ss, s)\n+\t\t}\n+\t}\n+\tif len(ss) == 0 {\n+\t\treturn prefix\n+\t}\n+\treturn fmt.Sprintf(\"%s: %v\", prefix, strings.Join(ss, \"; and \"))\n+}\n+\n+// Type flags for Header.Typeflag.\n+const (\n+\t// Type '0' indicates a regular file.\n+\tTypeReg  = '0'\n+\tTypeRegA = '\\x00' // For legacy support; use TypeReg instead\n+\n+\t// Type '1' to '6' are header-only flags and may not have a data body.\n+\tTypeLink    = '1' // Hard link\n+\tTypeSymlink = '2' // Symbolic link\n+\tTypeChar    = '3' // Character device node\n+\tTypeBlock   = '4' // Block device node\n+\tTypeDir     = '5' // Directory\n+\tTypeFifo    = '6' // FIFO node\n+\n+\t// Type '7' is reserved.\n+\tTypeCont = '7'\n+\n+\t// Type 'x' is used by the PAX format to store key-value records that\n+\t// are only relevant to the next file.\n+\t// This package transparently handles these types.\n+\tTypeXHeader = 'x'\n+\n+\t// Type 'g' is used by the PAX format to store key-value records that\n+\t// are relevant to all subsequent files.\n+\t// This package only supports parsing and composing such headers,\n+\t// but does not currently support persisting the global state across files.\n+\tTypeXGlobalHeader = 'g'\n+\n+\t// Type 'S' indicates a sparse file in the GNU format.\n+\tTypeGNUSparse = 'S'\n+\n+\t// Types 'L' and 'K' are used by the GNU format for a meta file\n+\t// used to store the path or link name for the next file.\n+\t// This package transparently handles these types.\n+\tTypeGNULongName = 'L'\n+\tTypeGNULongLink = 'K'\n+)\n+\n+// Keywords for PAX extended header records.\n const (\n-\tTypeReg           = '0'    // regular file\n-\tTypeRegA          = '\\x00' // regular file\n-\tTypeLink          = '1'    // hard link\n-\tTypeSymlink       = '2'    // symbolic link\n-\tTypeChar          = '3'    // character device node\n-\tTypeBlock         = '4'    // block device node\n-\tTypeDir           = '5'    // directory\n-\tTypeFifo          = '6'    // fifo node\n-\tTypeCont          = '7'    // reserved\n-\tTypeXHeader       = 'x'    // extended header\n-\tTypeXGlobalHeader = 'g'    // global extended header\n-\tTypeGNULongName   = 'L'    // Next file has a long name\n-\tTypeGNULongLink   = 'K'    // Next file symlinks to a file w/ a long name\n-\tTypeGNUSparse     = 'S'    // sparse file\n+\tpaxNone     = \"\" // Indicates that no PAX key is suitable\n+\tpaxPath     = \"path\"\n+\tpaxLinkpath = \"linkpath\"\n+\tpaxSize     = \"size\"\n+\tpaxUid      = \"uid\"\n+\tpaxGid      = \"gid\"\n+\tpaxUname    = \"uname\"\n+\tpaxGname    = \"gname\"\n+\tpaxMtime    = \"mtime\"\n+\tpaxAtime    = \"atime\"\n+\tpaxCtime    = \"ctime\"   // Removed from later revision of PAX spec, but was valid\n+\tpaxCharset  = \"charset\" // Currently unused\n+\tpaxComment  = \"comment\" // Currently unused\n+\n+\tpaxSchilyXattr = \"SCHILY.xattr.\"\n+\n+\t// Keywords for GNU sparse files in a PAX extended header.\n+\tpaxGNUSparse          = \"GNU.sparse.\"\n+\tpaxGNUSparseNumBlocks = \"GNU.sparse.numblocks\"\n+\tpaxGNUSparseOffset    = \"GNU.sparse.offset\"\n+\tpaxGNUSparseNumBytes  = \"GNU.sparse.numbytes\"\n+\tpaxGNUSparseMap       = \"GNU.sparse.map\"\n+\tpaxGNUSparseName      = \"GNU.sparse.name\"\n+\tpaxGNUSparseMajor     = \"GNU.sparse.major\"\n+\tpaxGNUSparseMinor     = \"GNU.sparse.minor\"\n+\tpaxGNUSparseSize      = \"GNU.sparse.size\"\n+\tpaxGNUSparseRealSize  = \"GNU.sparse.realsize\"\n )\n \n+// basicKeys is a set of the PAX keys for which we have built-in support.\n+// This does not contain \"charset\" or \"comment\", which are both PAX-specific,\n+// so adding them as first-class features of Header is unlikely.\n+// Users can use the PAXRecords field to set it themselves.\n+var basicKeys = map[string]bool{\n+\tpaxPath: true, paxLinkpath: true, paxSize: true, paxUid: true, paxGid: true,\n+\tpaxUname: true, paxGname: true, paxMtime: true, paxAtime: true, paxCtime: true,\n+}\n+\n // A Header represents a single header in a tar archive.\n // Some fields may not be populated.\n+//\n+// For forward compatibility, users that retrieve a Header from Reader.Next,\n+// mutate it in some ways, and then pass it back to Writer.WriteHeader\n+// should do so by creating a new Header and copying the fields\n+// that they are interested in preserving.\n type Header struct {\n-\tName       string    // name of header file entry\n-\tMode       int64     // permission and mode bits\n-\tUid        int       // user id of owner\n-\tGid        int       // group id of owner\n-\tSize       int64     // length in bytes\n-\tModTime    time.Time // modified time\n-\tTypeflag   byte      // type of header entry\n-\tLinkname   string    // target name of link\n-\tUname      string    // user name of owner\n-\tGname      string    // group name of owner\n-\tDevmajor   int64     // major number of character or block device\n-\tDevminor   int64     // minor number of character or block device\n-\tAccessTime time.Time // access time\n-\tChangeTime time.Time // status change time\n-\tXattrs     map[string]string\n+\tTypeflag byte // Type of header entry (should be TypeReg for most files)\n+\n+\tName     string // Name of file entry\n+\tLinkname string // Target name of link (valid for TypeLink or TypeSymlink)\n+\n+\tSize  int64  // Logical file size in bytes\n+\tMode  int64  // Permission and mode bits\n+\tUid   int    // User ID of owner\n+\tGid   int    // Group ID of owner\n+\tUname string // User name of owner\n+\tGname string // Group name of owner\n+\n+\t// If the Format is unspecified, then Writer.WriteHeader rounds ModTime\n+\t// to the nearest second and ignores the AccessTime and ChangeTime fields.\n+\t//\n+\t// To use AccessTime or ChangeTime, specify the Format as PAX or GNU.\n+\t// To use sub-second resolution, specify the Format as PAX.\n+\tModTime    time.Time // Modification time\n+\tAccessTime time.Time // Access time (requires either PAX or GNU support)\n+\tChangeTime time.Time // Change time (requires either PAX or GNU support)\n+\n+\tDevmajor int64 // Major device number (valid for TypeChar or TypeBlock)\n+\tDevminor int64 // Minor device number (valid for TypeChar or TypeBlock)\n+\n+\t// Xattrs stores extended attributes as PAX records under the\n+\t// \"SCHILY.xattr.\" namespace.\n+\t//\n+\t// The following are semantically equivalent:\n+\t//  h.Xattrs[key] = value\n+\t//  h.PAXRecords[\"SCHILY.xattr.\"+key] = value\n+\t//\n+\t// When Writer.WriteHeader is called, the contents of Xattrs will take\n+\t// precedence over those in PAXRecords.\n+\t//\n+\t// Deprecated: Use PAXRecords instead.\n+\tXattrs map[string]string\n+\n+\t// PAXRecords is a map of PAX extended header records.\n+\t//\n+\t// User-defined records should have keys of the following form:\n+\t//\tVENDOR.keyword\n+\t// Where VENDOR is some namespace in all uppercase, and keyword may\n+\t// not contain the '=' character (e.g., \"GOLANG.pkg.version\").\n+\t// The key and value should be non-empty UTF-8 strings.\n+\t//\n+\t// When Writer.WriteHeader is called, PAX records derived from the\n+\t// the other fields in Header take precedence over PAXRecords.\n+\tPAXRecords map[string]string\n+\n+\t// Format specifies the format of the tar header.\n+\t//\n+\t// This is set by Reader.Next as a best-effort guess at the format.\n+\t// Since the Reader liberally reads some non-compliant files,\n+\t// it is possible for this to be FormatUnknown.\n+\t//\n+\t// If the format is unspecified when Writer.WriteHeader is called,\n+\t// then it uses the first format (in the order of USTAR, PAX, GNU)\n+\t// capable of encoding this Header (see Format).\n+\tFormat Format\n+}\n+\n+// sparseEntry represents a Length-sized fragment at Offset in the file.\n+type sparseEntry struct{ Offset, Length int64 }\n+\n+func (s sparseEntry) endOffset() int64 { return s.Offset + s.Length }\n+\n+// A sparse file can be represented as either a sparseDatas or a sparseHoles.\n+// As long as the total size is known, they are equivalent and one can be\n+// converted to the other form and back. The various tar formats with sparse\n+// file support represent sparse files in the sparseDatas form. That is, they\n+// specify the fragments in the file that has data, and treat everything else as\n+// having zero bytes. As such, the encoding and decoding logic in this package\n+// deals with sparseDatas.\n+//\n+// However, the external API uses sparseHoles instead of sparseDatas because the\n+// zero value of sparseHoles logically represents a normal file (i.e., there are\n+// no holes in it). On the other hand, the zero value of sparseDatas implies\n+// that the file has no data in it, which is rather odd.\n+//\n+// As an example, if the underlying raw file contains the 10-byte data:\n+//\tvar compactFile = \"abcdefgh\"\n+//\n+// And the sparse map has the following entries:\n+//\tvar spd sparseDatas = []sparseEntry{\n+//\t\t{Offset: 2,  Length: 5},  // Data fragment for 2..6\n+//\t\t{Offset: 18, Length: 3},  // Data fragment for 18..20\n+//\t}\n+//\tvar sph sparseHoles = []sparseEntry{\n+//\t\t{Offset: 0,  Length: 2},  // Hole fragment for 0..1\n+//\t\t{Offset: 7,  Length: 11}, // Hole fragment for 7..17\n+//\t\t{Offset: 21, Length: 4},  // Hole fragment for 21..24\n+//\t}\n+//\n+// Then the content of the resulting sparse file with a Header.Size of 25 is:\n+//\tvar sparseFile = \"\\x00\"*2 + \"abcde\" + \"\\x00\"*11 + \"fgh\" + \"\\x00\"*4\n+type (\n+\tsparseDatas []sparseEntry\n+\tsparseHoles []sparseEntry\n+)\n+\n+// validateSparseEntries reports whether sp is a valid sparse map.\n+// It does not matter whether sp represents data fragments or hole fragments.\n+func validateSparseEntries(sp []sparseEntry, size int64) bool {\n+\t// Validate all sparse entries. These are the same checks as performed by\n+\t// the BSD tar utility.\n+\tif size < 0 {\n+\t\treturn false\n+\t}\n+\tvar pre sparseEntry\n+\tfor _, cur := range sp {\n+\t\tswitch {\n+\t\tcase cur.Offset < 0 || cur.Length < 0:\n+\t\t\treturn false // Negative values are never okay\n+\t\tcase cur.Offset > math.MaxInt64-cur.Length:\n+\t\t\treturn false // Integer overflow with large length\n+\t\tcase cur.endOffset() > size:\n+\t\t\treturn false // Region extends beyond the actual size\n+\t\tcase pre.endOffset() > cur.Offset:\n+\t\t\treturn false // Regions cannot overlap and must be in order\n+\t\t}\n+\t\tpre = cur\n+\t}\n+\treturn true\n+}\n+\n+// alignSparseEntries mutates src and returns dst where each fragment's\n+// starting offset is aligned up to the nearest block edge, and each\n+// ending offset is aligned down to the nearest block edge.\n+//\n+// Even though the Go tar Reader and the BSD tar utility can handle entries\n+// with arbitrary offsets and lengths, the GNU tar utility can only handle\n+// offsets and lengths that are multiples of blockSize.\n+func alignSparseEntries(src []sparseEntry, size int64) []sparseEntry {\n+\tdst := src[:0]\n+\tfor _, s := range src {\n+\t\tpos, end := s.Offset, s.endOffset()\n+\t\tpos += blockPadding(+pos) // Round-up to nearest blockSize\n+\t\tif end != size {\n+\t\t\tend -= blockPadding(-end) // Round-down to nearest blockSize\n+\t\t}\n+\t\tif pos < end {\n+\t\t\tdst = append(dst, sparseEntry{Offset: pos, Length: end - pos})\n+\t\t}\n+\t}\n+\treturn dst\n+}\n+\n+// invertSparseEntries converts a sparse map from one form to the other.\n+// If the input is sparseHoles, then it will output sparseDatas and vice-versa.\n+// The input must have been already validated.\n+//\n+// This function mutates src and returns a normalized map where:\n+//\t* adjacent fragments are coalesced together\n+//\t* only the last fragment may be empty\n+//\t* the endOffset of the last fragment is the total size\n+func invertSparseEntries(src []sparseEntry, size int64) []sparseEntry {\n+\tdst := src[:0]\n+\tvar pre sparseEntry\n+\tfor _, cur := range src {\n+\t\tif cur.Length == 0 {\n+\t\t\tcontinue // Skip empty fragments\n+\t\t}\n+\t\tpre.Length = cur.Offset - pre.Offset\n+\t\tif pre.Length > 0 {\n+\t\t\tdst = append(dst, pre) // Only add non-empty fragments\n+\t\t}\n+\t\tpre.Offset = cur.endOffset()\n+\t}\n+\tpre.Length = size - pre.Offset // Possibly the only empty fragment\n+\treturn append(dst, pre)\n+}\n+\n+// fileState tracks the number of logical (includes sparse holes) and physical\n+// (actual in tar archive) bytes remaining for the current file.\n+//\n+// Invariant: LogicalRemaining >= PhysicalRemaining\n+type fileState interface {\n+\tLogicalRemaining() int64\n+\tPhysicalRemaining() int64\n+}\n+\n+// allowedFormats determines which formats can be used.\n+// The value returned is the logical OR of multiple possible formats.\n+// If the value is FormatUnknown, then the input Header cannot be encoded\n+// and an error is returned explaining why.\n+//\n+// As a by-product of checking the fields, this function returns paxHdrs, which\n+// contain all fields that could not be directly encoded.\n+// A value receiver ensures that this method does not mutate the source Header.\n+func (h Header) allowedFormats() (format Format, paxHdrs map[string]string, err error) {\n+\tformat = FormatUSTAR | FormatPAX | FormatGNU\n+\tpaxHdrs = make(map[string]string)\n+\n+\tvar whyNoUSTAR, whyNoPAX, whyNoGNU string\n+\tvar preferPAX bool // Prefer PAX over USTAR\n+\tverifyString := func(s string, size int, name, paxKey string) {\n+\t\t// NUL-terminator is optional for path and linkpath.\n+\t\t// Technically, it is required for uname and gname,\n+\t\t// but neither GNU nor BSD tar checks for it.\n+\t\ttooLong := len(s) > size\n+\t\tallowLongGNU := paxKey == paxPath || paxKey == paxLinkpath\n+\t\tif hasNUL(s) || (tooLong && !allowLongGNU) {\n+\t\t\twhyNoGNU = fmt.Sprintf(\"GNU cannot encode %s=%q\", name, s)\n+\t\t\tformat.mustNotBe(FormatGNU)\n+\t\t}\n+\t\tif !isASCII(s) || tooLong {\n+\t\t\tcanSplitUSTAR := paxKey == paxPath\n+\t\t\tif _, _, ok := splitUSTARPath(s); !canSplitUSTAR || !ok {\n+\t\t\t\twhyNoUSTAR = fmt.Sprintf(\"USTAR cannot encode %s=%q\", name, s)\n+\t\t\t\tformat.mustNotBe(FormatUSTAR)\n+\t\t\t}\n+\t\t\tif paxKey == paxNone {\n+\t\t\t\twhyNoPAX = fmt.Sprintf(\"PAX cannot encode %s=%q\", name, s)\n+\t\t\t\tformat.mustNotBe(FormatPAX)\n+\t\t\t} else {\n+\t\t\t\tpaxHdrs[paxKey] = s\n+\t\t\t}\n+\t\t}\n+\t\tif v, ok := h.PAXRecords[paxKey]; ok && v == s {\n+\t\t\tpaxHdrs[paxKey] = v\n+\t\t}\n+\t}\n+\tverifyNumeric := func(n int64, size int, name, paxKey string) {\n+\t\tif !fitsInBase256(size, n) {\n+\t\t\twhyNoGNU = fmt.Sprintf(\"GNU cannot encode %s=%d\", name, n)\n+\t\t\tformat.mustNotBe(FormatGNU)\n+\t\t}\n+\t\tif !fitsInOctal(size, n) {\n+\t\t\twhyNoUSTAR = fmt.Sprintf(\"USTAR cannot encode %s=%d\", name, n)\n+\t\t\tformat.mustNotBe(FormatUSTAR)\n+\t\t\tif paxKey == paxNone {\n+\t\t\t\twhyNoPAX = fmt.Sprintf(\"PAX cannot encode %s=%d\", name, n)\n+\t\t\t\tformat.mustNotBe(FormatPAX)\n+\t\t\t} else {\n+\t\t\t\tpaxHdrs[paxKey] = strconv.FormatInt(n, 10)\n+\t\t\t}\n+\t\t}\n+\t\tif v, ok := h.PAXRecords[paxKey]; ok && v == strconv.FormatInt(n, 10) {\n+\t\t\tpaxHdrs[paxKey] = v\n+\t\t}\n+\t}\n+\tverifyTime := func(ts time.Time, size int, name, paxKey string) {\n+\t\tif ts.IsZero() {\n+\t\t\treturn // Always okay\n+\t\t}\n+\t\tif !fitsInBase256(size, ts.Unix()) {\n+\t\t\twhyNoGNU = fmt.Sprintf(\"GNU cannot encode %s=%v\", name, ts)\n+\t\t\tformat.mustNotBe(FormatGNU)\n+\t\t}\n+\t\tisMtime := paxKey == paxMtime\n+\t\tfitsOctal := fitsInOctal(size, ts.Unix())\n+\t\tif (isMtime && !fitsOctal) || !isMtime {\n+\t\t\twhyNoUSTAR = fmt.Sprintf(\"USTAR cannot encode %s=%v\", name, ts)\n+\t\t\tformat.mustNotBe(FormatUSTAR)\n+\t\t}\n+\t\tneedsNano := ts.Nanosecond() != 0\n+\t\tif !isMtime || !fitsOctal || needsNano {\n+\t\t\tpreferPAX = true // USTAR may truncate sub-second measurements\n+\t\t\tif paxKey == paxNone {\n+\t\t\t\twhyNoPAX = fmt.Sprintf(\"PAX cannot encode %s=%v\", name, ts)\n+\t\t\t\tformat.mustNotBe(FormatPAX)\n+\t\t\t} else {\n+\t\t\t\tpaxHdrs[paxKey] = formatPAXTime(ts)\n+\t\t\t}\n+\t\t}\n+\t\tif v, ok := h.PAXRecords[paxKey]; ok && v == formatPAXTime(ts) {\n+\t\t\tpaxHdrs[paxKey] = v\n+\t\t}\n+\t}\n+\n+\t// Check basic fields.\n+\tvar blk block\n+\tv7 := blk.V7()\n+\tustar := blk.USTAR()\n+\tgnu := blk.GNU()\n+\tverifyString(h.Name, len(v7.Name()), \"Name\", paxPath)\n+\tverifyString(h.Linkname, len(v7.LinkName()), \"Linkname\", paxLinkpath)\n+\tverifyString(h.Uname, len(ustar.UserName()), \"Uname\", paxUname)\n+\tverifyString(h.Gname, len(ustar.GroupName()), \"Gname\", paxGname)\n+\tverifyNumeric(h.Mode, len(v7.Mode()), \"Mode\", paxNone)\n+\tverifyNumeric(int64(h.Uid), len(v7.UID()), \"Uid\", paxUid)\n+\tverifyNumeric(int64(h.Gid), len(v7.GID()), \"Gid\", paxGid)\n+\tverifyNumeric(h.Size, len(v7.Size()), \"Size\", paxSize)\n+\tverifyNumeric(h.Devmajor, len(ustar.DevMajor()), \"Devmajor\", paxNone)\n+\tverifyNumeric(h.Devminor, len(ustar.DevMinor()), \"Devminor\", paxNone)\n+\tverifyTime(h.ModTime, len(v7.ModTime()), \"ModTime\", paxMtime)\n+\tverifyTime(h.AccessTime, len(gnu.AccessTime()), \"AccessTime\", paxAtime)\n+\tverifyTime(h.ChangeTime, len(gnu.ChangeTime()), \"ChangeTime\", paxCtime)\n+\n+\t// Check for header-only types.\n+\tvar whyOnlyPAX, whyOnlyGNU string\n+\tswitch h.Typeflag {\n+\tcase TypeReg, TypeChar, TypeBlock, TypeFifo, TypeGNUSparse:\n+\t\t// Exclude TypeLink and TypeSymlink, since they may reference directories.\n+\t\tif strings.HasSuffix(h.Name, \"/\") {\n+\t\t\treturn FormatUnknown, nil, headerError{\"filename may not have trailing slash\"}\n+\t\t}\n+\tcase TypeXHeader, TypeGNULongName, TypeGNULongLink:\n+\t\treturn FormatUnknown, nil, headerError{\"cannot manually encode TypeXHeader, TypeGNULongName, or TypeGNULongLink headers\"}\n+\tcase TypeXGlobalHeader:\n+\t\th2 := Header{Name: h.Name, Typeflag: h.Typeflag, Xattrs: h.Xattrs, PAXRecords: h.PAXRecords, Format: h.Format}\n+\t\tif !reflect.DeepEqual(h, h2) {\n+\t\t\treturn FormatUnknown, nil, headerError{\"only PAXRecords should be set for TypeXGlobalHeader\"}\n+\t\t}\n+\t\twhyOnlyPAX = \"only PAX supports TypeXGlobalHeader\"\n+\t\tformat.mayOnlyBe(FormatPAX)\n+\t}\n+\tif !isHeaderOnlyType(h.Typeflag) && h.Size < 0 {\n+\t\treturn FormatUnknown, nil, headerError{\"negative size on header-only type\"}\n+\t}\n+\n+\t// Check PAX records.\n+\tif len(h.Xattrs) > 0 {\n+\t\tfor k, v := range h.Xattrs {\n+\t\t\tpaxHdrs[paxSchilyXattr+k] = v\n+\t\t}\n+\t\twhyOnlyPAX = \"only PAX supports Xattrs\"\n+\t\tformat.mayOnlyBe(FormatPAX)\n+\t}\n+\tif len(h.PAXRecords) > 0 {\n+\t\tfor k, v := range h.PAXRecords {\n+\t\t\tswitch _, exists := paxHdrs[k]; {\n+\t\t\tcase exists:\n+\t\t\t\tcontinue // Do not overwrite existing records\n+\t\t\tcase h.Typeflag == TypeXGlobalHeader:\n+\t\t\t\tpaxHdrs[k] = v // Copy all records\n+\t\t\tcase !basicKeys[k] && !strings.HasPrefix(k, paxGNUSparse):\n+\t\t\t\tpaxHdrs[k] = v // Ignore local records that may conflict\n+\t\t\t}\n+\t\t}\n+\t\twhyOnlyPAX = \"only PAX supports PAXRecords\"\n+\t\tformat.mayOnlyBe(FormatPAX)\n+\t}\n+\tfor k, v := range paxHdrs {\n+\t\tif !validPAXRecord(k, v) {\n+\t\t\treturn FormatUnknown, nil, headerError{fmt.Sprintf(\"invalid PAX record: %q\", k+\" = \"+v)}\n+\t\t}\n+\t}\n+\n+\t// TODO(dsnet): Re-enable this when adding sparse support.\n+\t// See https://golang.org/issue/22735\n+\t/*\n+\t\t// Check sparse files.\n+\t\tif len(h.SparseHoles) > 0 || h.Typeflag == TypeGNUSparse {\n+\t\t\tif isHeaderOnlyType(h.Typeflag) {\n+\t\t\t\treturn FormatUnknown, nil, headerError{\"header-only type cannot be sparse\"}\n+\t\t\t}\n+\t\t\tif !validateSparseEntries(h.SparseHoles, h.Size) {\n+\t\t\t\treturn FormatUnknown, nil, headerError{\"invalid sparse holes\"}\n+\t\t\t}\n+\t\t\tif h.Typeflag == TypeGNUSparse {\n+\t\t\t\twhyOnlyGNU = \"only GNU supports TypeGNUSparse\"\n+\t\t\t\tformat.mayOnlyBe(FormatGNU)\n+\t\t\t} else {\n+\t\t\t\twhyNoGNU = \"GNU supports sparse files only with TypeGNUSparse\"\n+\t\t\t\tformat.mustNotBe(FormatGNU)\n+\t\t\t}\n+\t\t\twhyNoUSTAR = \"USTAR does not support sparse files\"\n+\t\t\tformat.mustNotBe(FormatUSTAR)\n+\t\t}\n+\t*/\n+\n+\t// Check desired format.\n+\tif wantFormat := h.Format; wantFormat != FormatUnknown {\n+\t\tif wantFormat.has(FormatPAX) && !preferPAX {\n+\t\t\twantFormat.mayBe(FormatUSTAR) // PAX implies USTAR allowed too\n+\t\t}\n+\t\tformat.mayOnlyBe(wantFormat) // Set union of formats allowed and format wanted\n+\t}\n+\tif format == FormatUnknown {\n+\t\tswitch h.Format {\n+\t\tcase FormatUSTAR:\n+\t\t\terr = headerError{\"Format specifies USTAR\", whyNoUSTAR, whyOnlyPAX, whyOnlyGNU}\n+\t\tcase FormatPAX:\n+\t\t\terr = headerError{\"Format specifies PAX\", whyNoPAX, whyOnlyGNU}\n+\t\tcase FormatGNU:\n+\t\t\terr = headerError{\"Format specifies GNU\", whyNoGNU, whyOnlyPAX}\n+\t\tdefault:\n+\t\t\terr = headerError{whyNoUSTAR, whyNoPAX, whyNoGNU, whyOnlyPAX, whyOnlyGNU}\n+\t\t}\n+\t}\n+\treturn format, paxHdrs, err\n }\n \n // FileInfo returns an os.FileInfo for the Header.\n@@ -92,63 +552,43 @@ func (fi headerFileInfo) Mode() (mode os.FileMode) {\n \n \t// Set setuid, setgid and sticky bits.\n \tif fi.h.Mode&c_ISUID != 0 {\n-\t\t// setuid\n \t\tmode |= os.ModeSetuid\n \t}\n \tif fi.h.Mode&c_ISGID != 0 {\n-\t\t// setgid\n \t\tmode |= os.ModeSetgid\n \t}\n \tif fi.h.Mode&c_ISVTX != 0 {\n-\t\t// sticky\n \t\tmode |= os.ModeSticky\n \t}\n \n-\t// Set file mode bits.\n-\t// clear perm, setuid, setgid and sticky bits.\n-\tm := os.FileMode(fi.h.Mode) &^ 07777\n-\tif m == c_ISDIR {\n-\t\t// directory\n+\t// Set file mode bits; clear perm, setuid, setgid, and sticky bits.\n+\tswitch m := os.FileMode(fi.h.Mode) &^ 07777; m {\n+\tcase c_ISDIR:\n \t\tmode |= os.ModeDir\n-\t}\n-\tif m == c_ISFIFO {\n-\t\t// named pipe (FIFO)\n+\tcase c_ISFIFO:\n \t\tmode |= os.ModeNamedPipe\n-\t}\n-\tif m == c_ISLNK {\n-\t\t// symbolic link\n+\tcase c_ISLNK:\n \t\tmode |= os.ModeSymlink\n-\t}\n-\tif m == c_ISBLK {\n-\t\t// device file\n+\tcase c_ISBLK:\n \t\tmode |= os.ModeDevice\n-\t}\n-\tif m == c_ISCHR {\n-\t\t// Unix character device\n+\tcase c_ISCHR:\n \t\tmode |= os.ModeDevice\n \t\tmode |= os.ModeCharDevice\n-\t}\n-\tif m == c_ISSOCK {\n-\t\t// Unix domain socket\n+\tcase c_ISSOCK:\n \t\tmode |= os.ModeSocket\n \t}\n \n \tswitch fi.h.Typeflag {\n \tcase TypeSymlink:\n-\t\t// symbolic link\n \t\tmode |= os.ModeSymlink\n \tcase TypeChar:\n-\t\t// character device node\n \t\tmode |= os.ModeDevice\n \t\tmode |= os.ModeCharDevice\n \tcase TypeBlock:\n-\t\t// block device node\n \t\tmode |= os.ModeDevice\n \tcase TypeDir:\n-\t\t// directory\n \t\tmode |= os.ModeDir\n \tcase TypeFifo:\n-\t\t// fifo node\n \t\tmode |= os.ModeNamedPipe\n \t}\n \n@@ -176,33 +616,16 @@ const (\n \tc_ISSOCK = 0140000 // Socket\n )\n \n-// Keywords for the PAX Extended Header\n-const (\n-\tpaxAtime    = \"atime\"\n-\tpaxCharset  = \"charset\"\n-\tpaxComment  = \"comment\"\n-\tpaxCtime    = \"ctime\" // please note that ctime is not a valid pax header.\n-\tpaxGid      = \"gid\"\n-\tpaxGname    = \"gname\"\n-\tpaxLinkpath = \"linkpath\"\n-\tpaxMtime    = \"mtime\"\n-\tpaxPath     = \"path\"\n-\tpaxSize     = \"size\"\n-\tpaxUid      = \"uid\"\n-\tpaxUname    = \"uname\"\n-\tpaxXattr    = \"SCHILY.xattr.\"\n-\tpaxNone     = \"\"\n-)\n-\n // FileInfoHeader creates a partially-populated Header from fi.\n // If fi describes a symlink, FileInfoHeader records link as the link target.\n // If fi describes a directory, a slash is appended to the name.\n-// Because os.FileInfo's Name method returns only the base name of\n-// the file it describes, it may be necessary to modify the Name field\n-// of the returned header to provide the full path name of the file.\n+//\n+// Since os.FileInfo's Name method only returns the base name of\n+// the file it describes, it may be necessary to modify Header.Name\n+// to provide the full path name of the file.\n func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \tif fi == nil {\n-\t\treturn nil, errors.New(\"tar: FileInfo is nil\")\n+\t\treturn nil, errors.New(\"archive/tar: FileInfo is nil\")\n \t}\n \tfm := fi.Mode()\n \th := &Header{\n@@ -265,6 +688,12 @@ func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \t\t\th.Size = 0\n \t\t\th.Linkname = sys.Linkname\n \t\t}\n+\t\tif sys.PAXRecords != nil {\n+\t\t\th.PAXRecords = make(map[string]string)\n+\t\t\tfor k, v := range sys.PAXRecords {\n+\t\t\t\th.PAXRecords[k] = v\n+\t\t\t}\n+\t\t}\n \t}\n \tif sysStat != nil {\n \t\treturn h, sysStat(fi, h)\n@@ -282,3 +711,10 @@ func isHeaderOnlyType(flag byte) bool {\n \t\treturn false\n \t}\n }\n+\n+func min(a, b int64) int64 {\n+\tif a < b {\n+\t\treturn a\n+\t}\n+\treturn b\n+}"}, {"sha": "6e29698a14a54fd4dc8beb7253daa3801ee700f3", "filename": "libgo/go/archive/tar/format.go", "status": "modified", "additions": 140, "deletions": 34, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fformat.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -4,38 +4,133 @@\n \n package tar\n \n+import \"strings\"\n+\n+// Format represents the tar archive format.\n+//\n+// The original tar format was introduced in Unix V7.\n+// Since then, there have been multiple competing formats attempting to\n+// standardize or extend the V7 format to overcome its limitations.\n+// The most common formats are the USTAR, PAX, and GNU formats,\n+// each with their own advantages and limitations.\n+//\n+// The following table captures the capabilities of each format:\n+//\n+//\t                  |  USTAR |       PAX |       GNU\n+//\t------------------+--------+-----------+----------\n+//\tName              |   256B | unlimited | unlimited\n+//\tLinkname          |   100B | unlimited | unlimited\n+//\tSize              | uint33 | unlimited |    uint89\n+//\tMode              | uint21 |    uint21 |    uint57\n+//\tUid/Gid           | uint21 | unlimited |    uint57\n+//\tUname/Gname       |    32B | unlimited |       32B\n+//\tModTime           | uint33 | unlimited |     int89\n+//\tAccessTime        |    n/a | unlimited |     int89\n+//\tChangeTime        |    n/a | unlimited |     int89\n+//\tDevmajor/Devminor | uint21 |    uint21 |    uint57\n+//\t------------------+--------+-----------+----------\n+//\tstring encoding   |  ASCII |     UTF-8 |    binary\n+//\tsub-second times  |     no |       yes |        no\n+//\tsparse files      |     no |       yes |       yes\n+//\n+// The table's upper portion shows the Header fields, where each format reports\n+// the maximum number of bytes allowed for each string field and\n+// the integer type used to store each numeric field\n+// (where timestamps are stored as the number of seconds since the Unix epoch).\n+//\n+// The table's lower portion shows specialized features of each format,\n+// such as supported string encodings, support for sub-second timestamps,\n+// or support for sparse files.\n+//\n+// The Writer currently provides no support for sparse files.\n+type Format int\n+\n // Constants to identify various tar formats.\n const (\n-\t// The format is unknown.\n-\tformatUnknown = (1 << iota) / 2 // Sequence of 0, 1, 2, 4, 8, etc...\n+\t// Deliberately hide the meaning of constants from public API.\n+\t_ Format = (1 << iota) / 4 // Sequence of 0, 0, 1, 2, 4, 8, etc...\n+\n+\t// FormatUnknown indicates that the format is unknown.\n+\tFormatUnknown\n \n \t// The format of the original Unix V7 tar tool prior to standardization.\n \tformatV7\n \n-\t// The old and new GNU formats, which are incompatible with USTAR.\n-\t// This does cover the old GNU sparse extension.\n-\t// This does not cover the GNU sparse extensions using PAX headers,\n-\t// versions 0.0, 0.1, and 1.0; these fall under the PAX format.\n-\tformatGNU\n+\t// FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.\n+\t//\n+\t// While this format is compatible with most tar readers,\n+\t// the format has several limitations making it unsuitable for some usages.\n+\t// Most notably, it cannot support sparse files, files larger than 8GiB,\n+\t// filenames larger than 256 characters, and non-ASCII filenames.\n+\t//\n+\t// Reference:\n+\t//\thttp://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06\n+\tFormatUSTAR\n+\n+\t// FormatPAX represents the PAX header format defined in POSIX.1-2001.\n+\t//\n+\t// PAX extends USTAR by writing a special file with Typeflag TypeXHeader\n+\t// preceding the original header. This file contains a set of key-value\n+\t// records, which are used to overcome USTAR's shortcomings, in addition to\n+\t// providing the ability to have sub-second resolution for timestamps.\n+\t//\n+\t// Some newer formats add their own extensions to PAX by defining their\n+\t// own keys and assigning certain semantic meaning to the associated values.\n+\t// For example, sparse file support in PAX is implemented using keys\n+\t// defined by the GNU manual (e.g., \"GNU.sparse.map\").\n+\t//\n+\t// Reference:\n+\t//\thttp://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n+\tFormatPAX\n+\n+\t// FormatGNU represents the GNU header format.\n+\t//\n+\t// The GNU header format is older than the USTAR and PAX standards and\n+\t// is not compatible with them. The GNU format supports\n+\t// arbitrary file sizes, filenames of arbitrary encoding and length,\n+\t// sparse files, and other features.\n+\t//\n+\t// It is recommended that PAX be chosen over GNU unless the target\n+\t// application can only parse GNU formatted archives.\n+\t//\n+\t// Reference:\n+\t//\thttp://www.gnu.org/software/tar/manual/html_node/Standard.html\n+\tFormatGNU\n \n \t// Schily's tar format, which is incompatible with USTAR.\n \t// This does not cover STAR extensions to the PAX format; these fall under\n \t// the PAX format.\n \tformatSTAR\n \n-\t// USTAR is the former standardization of tar defined in POSIX.1-1988.\n-\t// This is incompatible with the GNU and STAR formats.\n-\tformatUSTAR\n-\n-\t// PAX is the latest standardization of tar defined in POSIX.1-2001.\n-\t// This is an extension of USTAR and is \"backwards compatible\" with it.\n-\t//\n-\t// Some newer formats add their own extensions to PAX, such as GNU sparse\n-\t// files and SCHILY extended attributes. Since they are backwards compatible\n-\t// with PAX, they will be labelled as \"PAX\".\n-\tformatPAX\n+\tformatMax\n )\n \n+func (f Format) has(f2 Format) bool   { return f&f2 != 0 }\n+func (f *Format) mayBe(f2 Format)     { *f |= f2 }\n+func (f *Format) mayOnlyBe(f2 Format) { *f &= f2 }\n+func (f *Format) mustNotBe(f2 Format) { *f &^= f2 }\n+\n+var formatNames = map[Format]string{\n+\tformatV7: \"V7\", FormatUSTAR: \"USTAR\", FormatPAX: \"PAX\", FormatGNU: \"GNU\", formatSTAR: \"STAR\",\n+}\n+\n+func (f Format) String() string {\n+\tvar ss []string\n+\tfor f2 := Format(1); f2 < formatMax; f2 <<= 1 {\n+\t\tif f.has(f2) {\n+\t\t\tss = append(ss, formatNames[f2])\n+\t\t}\n+\t}\n+\tswitch len(ss) {\n+\tcase 0:\n+\t\treturn \"<unknown>\"\n+\tcase 1:\n+\t\treturn ss[0]\n+\tdefault:\n+\t\treturn \"(\" + strings.Join(ss, \" | \") + \")\"\n+\t}\n+}\n+\n // Magics used to identify various formats.\n const (\n \tmagicGNU, versionGNU     = \"ustar \", \" \\x00\"\n@@ -50,6 +145,12 @@ const (\n \tprefixSize = 155 // Max length of the prefix field in USTAR format\n )\n \n+// blockPadding computes the number of bytes needed to pad offset up to the\n+// nearest block edge where 0 <= n < blockSize.\n+func blockPadding(offset int64) (n int64) {\n+\treturn -offset & (blockSize - 1)\n+}\n+\n var zeroBlock block\n \n type block [blockSize]byte\n@@ -63,14 +164,14 @@ func (b *block) Sparse() sparseArray { return (sparseArray)(b[:]) }\n \n // GetFormat checks that the block is a valid tar header based on the checksum.\n // It then attempts to guess the specific format based on magic values.\n-// If the checksum fails, then formatUnknown is returned.\n-func (b *block) GetFormat() (format int) {\n+// If the checksum fails, then FormatUnknown is returned.\n+func (b *block) GetFormat() Format {\n \t// Verify checksum.\n \tvar p parser\n \tvalue := p.parseOctal(b.V7().Chksum())\n \tchksum1, chksum2 := b.ComputeChecksum()\n \tif p.err != nil || (value != chksum1 && value != chksum2) {\n-\t\treturn formatUnknown\n+\t\treturn FormatUnknown\n \t}\n \n \t// Guess the magic values.\n@@ -81,29 +182,29 @@ func (b *block) GetFormat() (format int) {\n \tcase magic == magicUSTAR && trailer == trailerSTAR:\n \t\treturn formatSTAR\n \tcase magic == magicUSTAR:\n-\t\treturn formatUSTAR\n+\t\treturn FormatUSTAR | FormatPAX\n \tcase magic == magicGNU && version == versionGNU:\n-\t\treturn formatGNU\n+\t\treturn FormatGNU\n \tdefault:\n \t\treturn formatV7\n \t}\n }\n \n // SetFormat writes the magic values necessary for specified format\n // and then updates the checksum accordingly.\n-func (b *block) SetFormat(format int) {\n+func (b *block) SetFormat(format Format) {\n \t// Set the magic values.\n-\tswitch format {\n-\tcase formatV7:\n+\tswitch {\n+\tcase format.has(formatV7):\n \t\t// Do nothing.\n-\tcase formatGNU:\n+\tcase format.has(FormatGNU):\n \t\tcopy(b.GNU().Magic(), magicGNU)\n \t\tcopy(b.GNU().Version(), versionGNU)\n-\tcase formatSTAR:\n+\tcase format.has(formatSTAR):\n \t\tcopy(b.STAR().Magic(), magicUSTAR)\n \t\tcopy(b.STAR().Version(), versionUSTAR)\n \t\tcopy(b.STAR().Trailer(), trailerSTAR)\n-\tcase formatUSTAR, formatPAX:\n+\tcase format.has(FormatUSTAR | FormatPAX):\n \t\tcopy(b.USTAR().Magic(), magicUSTAR)\n \t\tcopy(b.USTAR().Version(), versionUSTAR)\n \tdefault:\n@@ -128,12 +229,17 @@ func (b *block) ComputeChecksum() (unsigned, signed int64) {\n \t\tif 148 <= i && i < 156 {\n \t\t\tc = ' ' // Treat the checksum field itself as all spaces.\n \t\t}\n-\t\tunsigned += int64(uint8(c))\n+\t\tunsigned += int64(c)\n \t\tsigned += int64(int8(c))\n \t}\n \treturn unsigned, signed\n }\n \n+// Reset clears the block with all zeros.\n+func (b *block) Reset() {\n+\t*b = block{}\n+}\n+\n type headerV7 [blockSize]byte\n \n func (h *headerV7) Name() []byte     { return h[000:][:100] }\n@@ -187,11 +293,11 @@ func (h *headerUSTAR) Prefix() []byte    { return h[345:][:155] }\n \n type sparseArray []byte\n \n-func (s sparseArray) Entry(i int) sparseNode { return (sparseNode)(s[i*24:]) }\n+func (s sparseArray) Entry(i int) sparseElem { return (sparseElem)(s[i*24:]) }\n func (s sparseArray) IsExtended() []byte     { return s[24*s.MaxEntries():][:1] }\n func (s sparseArray) MaxEntries() int        { return len(s) / 24 }\n \n-type sparseNode []byte\n+type sparseElem []byte\n \n-func (s sparseNode) Offset() []byte   { return s[00:][:12] }\n-func (s sparseNode) NumBytes() []byte { return s[12:][:12] }\n+func (s sparseElem) Offset() []byte { return s[00:][:12] }\n+func (s sparseElem) Length() []byte { return s[12:][:12] }"}, {"sha": "f4eeb557be9805a112bb56eeb1fc14904ce178cd", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 429, "deletions": 396, "changes": 825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -4,102 +4,45 @@\n \n package tar\n \n-// TODO(dsymonds):\n-//   - pax extensions\n-\n import (\n \t\"bytes\"\n-\t\"errors\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"math\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n )\n \n-var (\n-\tErrHeader = errors.New(\"archive/tar: invalid tar header\")\n-)\n-\n-// A Reader provides sequential access to the contents of a tar archive.\n-// A tar archive consists of a sequence of files.\n-// The Next method advances to the next file in the archive (including the first),\n-// and then it can be treated as an io.Reader to access the file's data.\n+// Reader provides sequential access to the contents of a tar archive.\n+// Reader.Next advances to the next file in the archive (including the first),\n+// and then Reader can be treated as an io.Reader to access the file's data.\n type Reader struct {\n \tr    io.Reader\n-\tpad  int64          // amount of padding (ignored) after current file entry\n-\tcurr numBytesReader // reader for current file entry\n-\tblk  block          // buffer to use as temporary local storage\n+\tpad  int64      // Amount of padding (ignored) after current file entry\n+\tcurr fileReader // Reader for current file entry\n+\tblk  block      // Buffer to use as temporary local storage\n \n \t// err is a persistent error.\n \t// It is only the responsibility of every exported method of Reader to\n \t// ensure that this error is sticky.\n \terr error\n }\n \n-// A numBytesReader is an io.Reader with a numBytes method, returning the number\n-// of bytes remaining in the underlying encoded data.\n-type numBytesReader interface {\n+type fileReader interface {\n \tio.Reader\n-\tnumBytes() int64\n-}\n+\tfileState\n \n-// A regFileReader is a numBytesReader for reading file data from a tar archive.\n-type regFileReader struct {\n-\tr  io.Reader // underlying reader\n-\tnb int64     // number of unread bytes for current file entry\n-}\n-\n-// A sparseFileReader is a numBytesReader for reading sparse file data from a\n-// tar archive.\n-type sparseFileReader struct {\n-\trfr   numBytesReader // Reads the sparse-encoded file data\n-\tsp    []sparseEntry  // The sparse map for the file\n-\tpos   int64          // Keeps track of file position\n-\ttotal int64          // Total size of the file\n-}\n-\n-// A sparseEntry holds a single entry in a sparse file's sparse map.\n-//\n-// Sparse files are represented using a series of sparseEntrys.\n-// Despite the name, a sparseEntry represents an actual data fragment that\n-// references data found in the underlying archive stream. All regions not\n-// covered by a sparseEntry are logically filled with zeros.\n-//\n-// For example, if the underlying raw file contains the 10-byte data:\n-//\tvar compactData = \"abcdefgh\"\n-//\n-// And the sparse map has the following entries:\n-//\tvar sp = []sparseEntry{\n-//\t\t{offset: 2,  numBytes: 5} // Data fragment for [2..7]\n-//\t\t{offset: 18, numBytes: 3} // Data fragment for [18..21]\n-//\t}\n-//\n-// Then the content of the resulting sparse file with a \"real\" size of 25 is:\n-//\tvar sparseData = \"\\x00\"*2 + \"abcde\" + \"\\x00\"*11 + \"fgh\" + \"\\x00\"*4\n-type sparseEntry struct {\n-\toffset   int64 // Starting position of the fragment\n-\tnumBytes int64 // Length of the fragment\n+\tWriteTo(io.Writer) (int64, error)\n }\n \n-// Keywords for GNU sparse files in a PAX extended header\n-const (\n-\tpaxGNUSparseNumBlocks = \"GNU.sparse.numblocks\"\n-\tpaxGNUSparseOffset    = \"GNU.sparse.offset\"\n-\tpaxGNUSparseNumBytes  = \"GNU.sparse.numbytes\"\n-\tpaxGNUSparseMap       = \"GNU.sparse.map\"\n-\tpaxGNUSparseName      = \"GNU.sparse.name\"\n-\tpaxGNUSparseMajor     = \"GNU.sparse.major\"\n-\tpaxGNUSparseMinor     = \"GNU.sparse.minor\"\n-\tpaxGNUSparseSize      = \"GNU.sparse.size\"\n-\tpaxGNUSparseRealSize  = \"GNU.sparse.realsize\"\n-)\n-\n // NewReader creates a new Reader reading from r.\n-func NewReader(r io.Reader) *Reader { return &Reader{r: r} }\n+func NewReader(r io.Reader) *Reader {\n+\treturn &Reader{r: r, curr: &regFileReader{r, 0}}\n+}\n \n // Next advances to the next entry in the tar archive.\n+// The Header.Size determines how many bytes can be read for the next file.\n+// Any remaining data in the current file is automatically discarded.\n //\n // io.EOF is returned at the end of the input.\n func (tr *Reader) Next() (*Header, error) {\n@@ -112,62 +55,85 @@ func (tr *Reader) Next() (*Header, error) {\n }\n \n func (tr *Reader) next() (*Header, error) {\n-\tvar extHdrs map[string]string\n+\tvar paxHdrs map[string]string\n+\tvar gnuLongName, gnuLongLink string\n \n \t// Externally, Next iterates through the tar archive as if it is a series of\n \t// files. Internally, the tar format often uses fake \"files\" to add meta\n \t// data that describes the next file. These meta data \"files\" should not\n \t// normally be visible to the outside. As such, this loop iterates through\n \t// one or more \"header files\" until it finds a \"normal file\".\n+\tformat := FormatUSTAR | FormatPAX | FormatGNU\n loop:\n \tfor {\n-\t\tif err := tr.skipUnread(); err != nil {\n+\t\t// Discard the remainder of the file and any padding.\n+\t\tif err := discard(tr.r, tr.curr.PhysicalRemaining()); err != nil {\n \t\t\treturn nil, err\n \t\t}\n+\t\tif _, err := tryReadFull(tr.r, tr.blk[:tr.pad]); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttr.pad = 0\n+\n \t\thdr, rawHdr, err := tr.readHeader()\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\tif err := tr.handleRegularFile(hdr); err != nil {\n \t\t\treturn nil, err\n \t\t}\n+\t\tformat.mayOnlyBe(hdr.Format)\n \n \t\t// Check for PAX/GNU special headers and files.\n \t\tswitch hdr.Typeflag {\n-\t\tcase TypeXHeader:\n-\t\t\textHdrs, err = parsePAX(tr)\n+\t\tcase TypeXHeader, TypeXGlobalHeader:\n+\t\t\tformat.mayOnlyBe(FormatPAX)\n+\t\t\tpaxHdrs, err = parsePAX(tr)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n+\t\t\tif hdr.Typeflag == TypeXGlobalHeader {\n+\t\t\t\tmergePAX(hdr, paxHdrs)\n+\t\t\t\treturn &Header{\n+\t\t\t\t\tName:       hdr.Name,\n+\t\t\t\t\tTypeflag:   hdr.Typeflag,\n+\t\t\t\t\tXattrs:     hdr.Xattrs,\n+\t\t\t\t\tPAXRecords: hdr.PAXRecords,\n+\t\t\t\t\tFormat:     format,\n+\t\t\t\t}, nil\n+\t\t\t}\n \t\t\tcontinue loop // This is a meta header affecting the next header\n \t\tcase TypeGNULongName, TypeGNULongLink:\n+\t\t\tformat.mayOnlyBe(FormatGNU)\n \t\t\trealname, err := ioutil.ReadAll(tr)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \n-\t\t\t// Convert GNU extensions to use PAX headers.\n-\t\t\tif extHdrs == nil {\n-\t\t\t\textHdrs = make(map[string]string)\n-\t\t\t}\n \t\t\tvar p parser\n \t\t\tswitch hdr.Typeflag {\n \t\t\tcase TypeGNULongName:\n-\t\t\t\textHdrs[paxPath] = p.parseString(realname)\n+\t\t\t\tgnuLongName = p.parseString(realname)\n \t\t\tcase TypeGNULongLink:\n-\t\t\t\textHdrs[paxLinkpath] = p.parseString(realname)\n-\t\t\t}\n-\t\t\tif p.err != nil {\n-\t\t\t\treturn nil, p.err\n+\t\t\t\tgnuLongLink = p.parseString(realname)\n \t\t\t}\n \t\t\tcontinue loop // This is a meta header affecting the next header\n \t\tdefault:\n \t\t\t// The old GNU sparse format is handled here since it is technically\n \t\t\t// just a regular file with additional attributes.\n \n-\t\t\tif err := mergePAX(hdr, extHdrs); err != nil {\n+\t\t\tif err := mergePAX(hdr, paxHdrs); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n+\t\t\tif gnuLongName != \"\" {\n+\t\t\t\thdr.Name = gnuLongName\n+\t\t\t}\n+\t\t\tif gnuLongLink != \"\" {\n+\t\t\t\thdr.Linkname = gnuLongLink\n+\t\t\t}\n+\t\t\tif hdr.Typeflag == TypeRegA && strings.HasSuffix(hdr.Name, \"/\") {\n+\t\t\t\thdr.Typeflag = TypeDir // Legacy archives use trailing slash for directories\n+\t\t\t}\n \n \t\t\t// The extended headers may have updated the size.\n \t\t\t// Thus, setup the regFileReader again after merging PAX headers.\n@@ -177,9 +143,15 @@ loop:\n \n \t\t\t// Sparse formats rely on being able to read from the logical data\n \t\t\t// section; there must be a preceding call to handleRegularFile.\n-\t\t\tif err := tr.handleSparseFile(hdr, rawHdr, extHdrs); err != nil {\n+\t\t\tif err := tr.handleSparseFile(hdr, rawHdr); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n+\n+\t\t\t// Set the final guess at the format.\n+\t\t\tif format.has(FormatUSTAR) && format.has(FormatPAX) {\n+\t\t\t\tformat.mayOnlyBe(FormatUSTAR)\n+\t\t\t}\n+\t\t\thdr.Format = format\n \t\t\treturn hdr, nil // This is a file, so stop\n \t\t}\n \t}\n@@ -197,105 +169,86 @@ func (tr *Reader) handleRegularFile(hdr *Header) error {\n \t\treturn ErrHeader\n \t}\n \n-\ttr.pad = -nb & (blockSize - 1) // blockSize is a power of two\n+\ttr.pad = blockPadding(nb)\n \ttr.curr = &regFileReader{r: tr.r, nb: nb}\n \treturn nil\n }\n \n // handleSparseFile checks if the current file is a sparse format of any type\n // and sets the curr reader appropriately.\n-func (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block, extHdrs map[string]string) error {\n-\tvar sp []sparseEntry\n+func (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block) error {\n+\tvar spd sparseDatas\n \tvar err error\n \tif hdr.Typeflag == TypeGNUSparse {\n-\t\tsp, err = tr.readOldGNUSparseMap(hdr, rawHdr)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\tspd, err = tr.readOldGNUSparseMap(hdr, rawHdr)\n \t} else {\n-\t\tsp, err = tr.checkForGNUSparsePAXHeaders(hdr, extHdrs)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t\tspd, err = tr.readGNUSparsePAXHeaders(hdr)\n \t}\n \n \t// If sp is non-nil, then this is a sparse file.\n-\t// Note that it is possible for len(sp) to be zero.\n-\tif sp != nil {\n-\t\ttr.curr, err = newSparseFileReader(tr.curr, sp, hdr.Size)\n+\t// Note that it is possible for len(sp) == 0.\n+\tif err == nil && spd != nil {\n+\t\tif isHeaderOnlyType(hdr.Typeflag) || !validateSparseEntries(spd, hdr.Size) {\n+\t\t\treturn ErrHeader\n+\t\t}\n+\t\tsph := invertSparseEntries(spd, hdr.Size)\n+\t\ttr.curr = &sparseFileReader{tr.curr, sph, 0}\n \t}\n \treturn err\n }\n \n-// checkForGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers. If they are found, then\n-// this function reads the sparse map and returns it. Unknown sparse formats are ignored, causing the file to\n-// be treated as a regular file.\n-func (tr *Reader) checkForGNUSparsePAXHeaders(hdr *Header, headers map[string]string) ([]sparseEntry, error) {\n-\tvar sparseFormat string\n-\n-\t// Check for sparse format indicators\n-\tmajor, majorOk := headers[paxGNUSparseMajor]\n-\tminor, minorOk := headers[paxGNUSparseMinor]\n-\tsparseName, sparseNameOk := headers[paxGNUSparseName]\n-\t_, sparseMapOk := headers[paxGNUSparseMap]\n-\tsparseSize, sparseSizeOk := headers[paxGNUSparseSize]\n-\tsparseRealSize, sparseRealSizeOk := headers[paxGNUSparseRealSize]\n-\n-\t// Identify which, if any, sparse format applies from which PAX headers are set\n-\tif majorOk && minorOk {\n-\t\tsparseFormat = major + \".\" + minor\n-\t} else if sparseNameOk && sparseMapOk {\n-\t\tsparseFormat = \"0.1\"\n-\t} else if sparseSizeOk {\n-\t\tsparseFormat = \"0.0\"\n-\t} else {\n-\t\t// Not a PAX format GNU sparse file.\n-\t\treturn nil, nil\n-\t}\n-\n-\t// Check for unknown sparse format\n-\tif sparseFormat != \"0.0\" && sparseFormat != \"0.1\" && sparseFormat != \"1.0\" {\n-\t\treturn nil, nil\n-\t}\n-\n-\t// Update hdr from GNU sparse PAX headers\n-\tif sparseNameOk {\n-\t\thdr.Name = sparseName\n-\t}\n-\tif sparseSizeOk {\n-\t\trealSize, err := strconv.ParseInt(sparseSize, 10, 64)\n+// readGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers.\n+// If they are found, then this function reads the sparse map and returns it.\n+// This assumes that 0.0 headers have already been converted to 0.1 headers\n+// by the the PAX header parsing logic.\n+func (tr *Reader) readGNUSparsePAXHeaders(hdr *Header) (sparseDatas, error) {\n+\t// Identify the version of GNU headers.\n+\tvar is1x0 bool\n+\tmajor, minor := hdr.PAXRecords[paxGNUSparseMajor], hdr.PAXRecords[paxGNUSparseMinor]\n+\tswitch {\n+\tcase major == \"0\" && (minor == \"0\" || minor == \"1\"):\n+\t\tis1x0 = false\n+\tcase major == \"1\" && minor == \"0\":\n+\t\tis1x0 = true\n+\tcase major != \"\" || minor != \"\":\n+\t\treturn nil, nil // Unknown GNU sparse PAX version\n+\tcase hdr.PAXRecords[paxGNUSparseMap] != \"\":\n+\t\tis1x0 = false // 0.0 and 0.1 did not have explicit version records, so guess\n+\tdefault:\n+\t\treturn nil, nil // Not a PAX format GNU sparse file.\n+\t}\n+\thdr.Format.mayOnlyBe(FormatPAX)\n+\n+\t// Update hdr from GNU sparse PAX headers.\n+\tif name := hdr.PAXRecords[paxGNUSparseName]; name != \"\" {\n+\t\thdr.Name = name\n+\t}\n+\tsize := hdr.PAXRecords[paxGNUSparseSize]\n+\tif size == \"\" {\n+\t\tsize = hdr.PAXRecords[paxGNUSparseRealSize]\n+\t}\n+\tif size != \"\" {\n+\t\tn, err := strconv.ParseInt(size, 10, 64)\n \t\tif err != nil {\n \t\t\treturn nil, ErrHeader\n \t\t}\n-\t\thdr.Size = realSize\n-\t} else if sparseRealSizeOk {\n-\t\trealSize, err := strconv.ParseInt(sparseRealSize, 10, 64)\n-\t\tif err != nil {\n-\t\t\treturn nil, ErrHeader\n-\t\t}\n-\t\thdr.Size = realSize\n+\t\thdr.Size = n\n \t}\n \n-\t// Set up the sparse map, according to the particular sparse format in use\n-\tvar sp []sparseEntry\n-\tvar err error\n-\tswitch sparseFormat {\n-\tcase \"0.0\", \"0.1\":\n-\t\tsp, err = readGNUSparseMap0x1(headers)\n-\tcase \"1.0\":\n-\t\tsp, err = readGNUSparseMap1x0(tr.curr)\n+\t// Read the sparse map according to the appropriate format.\n+\tif is1x0 {\n+\t\treturn readGNUSparseMap1x0(tr.curr)\n \t}\n-\treturn sp, err\n+\treturn readGNUSparseMap0x1(hdr.PAXRecords)\n }\n \n-// mergePAX merges well known headers according to PAX standard.\n-// In general headers with the same name as those found\n-// in the header struct overwrite those found in the header\n-// struct with higher precision or longer values. Esp. useful\n-// for name and linkname fields.\n-func mergePAX(hdr *Header, headers map[string]string) (err error) {\n-\tvar id64 int64\n-\tfor k, v := range headers {\n+// mergePAX merges paxHdrs into hdr for all relevant fields of Header.\n+func mergePAX(hdr *Header, paxHdrs map[string]string) (err error) {\n+\tfor k, v := range paxHdrs {\n+\t\tif v == \"\" {\n+\t\t\tcontinue // Keep the original USTAR value\n+\t\t}\n+\t\tvar id64 int64\n \t\tswitch k {\n \t\tcase paxPath:\n \t\t\thdr.Name = v\n@@ -320,17 +273,18 @@ func mergePAX(hdr *Header, headers map[string]string) (err error) {\n \t\tcase paxSize:\n \t\t\thdr.Size, err = strconv.ParseInt(v, 10, 64)\n \t\tdefault:\n-\t\t\tif strings.HasPrefix(k, paxXattr) {\n+\t\t\tif strings.HasPrefix(k, paxSchilyXattr) {\n \t\t\t\tif hdr.Xattrs == nil {\n \t\t\t\t\thdr.Xattrs = make(map[string]string)\n \t\t\t\t}\n-\t\t\t\thdr.Xattrs[k[len(paxXattr):]] = v\n+\t\t\t\thdr.Xattrs[k[len(paxSchilyXattr):]] = v\n \t\t\t}\n \t\t}\n \t\tif err != nil {\n \t\t\treturn ErrHeader\n \t\t}\n \t}\n+\thdr.PAXRecords = paxHdrs\n \treturn nil\n }\n \n@@ -348,7 +302,7 @@ func parsePAX(r io.Reader) (map[string]string, error) {\n \t// headers since 0.0 headers were not PAX compliant.\n \tvar sparseMap []string\n \n-\textHdrs := make(map[string]string)\n+\tpaxHdrs := make(map[string]string)\n \tfor len(sbuf) > 0 {\n \t\tkey, value, residual, err := parsePAXRecord(sbuf)\n \t\tif err != nil {\n@@ -366,58 +320,13 @@ func parsePAX(r io.Reader) (map[string]string, error) {\n \t\t\t}\n \t\t\tsparseMap = append(sparseMap, value)\n \t\tdefault:\n-\t\t\t// According to PAX specification, a value is stored only if it is\n-\t\t\t// non-empty. Otherwise, the key is deleted.\n-\t\t\tif len(value) > 0 {\n-\t\t\t\textHdrs[key] = value\n-\t\t\t} else {\n-\t\t\t\tdelete(extHdrs, key)\n-\t\t\t}\n+\t\t\tpaxHdrs[key] = value\n \t\t}\n \t}\n \tif len(sparseMap) > 0 {\n-\t\textHdrs[paxGNUSparseMap] = strings.Join(sparseMap, \",\")\n+\t\tpaxHdrs[paxGNUSparseMap] = strings.Join(sparseMap, \",\")\n \t}\n-\treturn extHdrs, nil\n-}\n-\n-// skipUnread skips any unread bytes in the existing file entry, as well as any\n-// alignment padding. It returns io.ErrUnexpectedEOF if any io.EOF is\n-// encountered in the data portion; it is okay to hit io.EOF in the padding.\n-//\n-// Note that this function still works properly even when sparse files are being\n-// used since numBytes returns the bytes remaining in the underlying io.Reader.\n-func (tr *Reader) skipUnread() error {\n-\tdataSkip := tr.numBytes()      // Number of data bytes to skip\n-\ttotalSkip := dataSkip + tr.pad // Total number of bytes to skip\n-\ttr.curr, tr.pad = nil, 0\n-\n-\t// If possible, Seek to the last byte before the end of the data section.\n-\t// Do this because Seek is often lazy about reporting errors; this will mask\n-\t// the fact that the tar stream may be truncated. We can rely on the\n-\t// io.CopyN done shortly afterwards to trigger any IO errors.\n-\tvar seekSkipped int64 // Number of bytes skipped via Seek\n-\tif sr, ok := tr.r.(io.Seeker); ok && dataSkip > 1 {\n-\t\t// Not all io.Seeker can actually Seek. For example, os.Stdin implements\n-\t\t// io.Seeker, but calling Seek always returns an error and performs\n-\t\t// no action. Thus, we try an innocent seek to the current position\n-\t\t// to see if Seek is really supported.\n-\t\tpos1, err := sr.Seek(0, io.SeekCurrent)\n-\t\tif err == nil {\n-\t\t\t// Seek seems supported, so perform the real Seek.\n-\t\t\tpos2, err := sr.Seek(dataSkip-1, io.SeekCurrent)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tseekSkipped = pos2 - pos1\n-\t\t}\n-\t}\n-\n-\tcopySkipped, err := io.CopyN(ioutil.Discard, tr.r, totalSkip-seekSkipped)\n-\tif err == io.EOF && seekSkipped+copySkipped < dataSkip {\n-\t\terr = io.ErrUnexpectedEOF\n-\t}\n-\treturn err\n+\treturn paxHdrs, nil\n }\n \n // readHeader reads the next block header and assumes that the underlying reader\n@@ -445,7 +354,7 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \n \t// Verify the header matches a known format.\n \tformat := tr.blk.GetFormat()\n-\tif format == formatUnknown {\n+\tif format == FormatUnknown {\n \t\treturn nil, nil, ErrHeader\n \t}\n \n@@ -454,59 +363,86 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \n \t// Unpack the V7 header.\n \tv7 := tr.blk.V7()\n+\thdr.Typeflag = v7.TypeFlag()[0]\n \thdr.Name = p.parseString(v7.Name())\n+\thdr.Linkname = p.parseString(v7.LinkName())\n+\thdr.Size = p.parseNumeric(v7.Size())\n \thdr.Mode = p.parseNumeric(v7.Mode())\n \thdr.Uid = int(p.parseNumeric(v7.UID()))\n \thdr.Gid = int(p.parseNumeric(v7.GID()))\n-\thdr.Size = p.parseNumeric(v7.Size())\n \thdr.ModTime = time.Unix(p.parseNumeric(v7.ModTime()), 0)\n-\thdr.Typeflag = v7.TypeFlag()[0]\n-\thdr.Linkname = p.parseString(v7.LinkName())\n-\n-\t// The atime and ctime fields are often left unused. Some versions of Go\n-\t// had a bug in the tar.Writer where it would output an invalid tar file\n-\t// in certain rare situations because the logic incorrectly believed that\n-\t// the old GNU format had a prefix field. This is wrong and leads to\n-\t// an outputted file that actually mangles the atime and ctime fields.\n-\t//\n-\t// In order to continue reading tar files created by a buggy writer, we\n-\t// try to parse the atime and ctime fields, but just return the zero value\n-\t// of time.Time when we cannot parse them.\n-\t//\n-\t// See https://golang.org/issues/12594\n-\ttryParseTime := func(b []byte) time.Time {\n-\t\tvar p parser\n-\t\tn := p.parseNumeric(b)\n-\t\tif b[0] != 0x00 && p.err == nil {\n-\t\t\treturn time.Unix(n, 0)\n-\t\t}\n-\t\treturn time.Time{}\n-\t}\n \n \t// Unpack format specific fields.\n \tif format > formatV7 {\n \t\tustar := tr.blk.USTAR()\n \t\thdr.Uname = p.parseString(ustar.UserName())\n \t\thdr.Gname = p.parseString(ustar.GroupName())\n-\t\tif hdr.Typeflag == TypeChar || hdr.Typeflag == TypeBlock {\n-\t\t\thdr.Devmajor = p.parseNumeric(ustar.DevMajor())\n-\t\t\thdr.Devminor = p.parseNumeric(ustar.DevMinor())\n-\t\t}\n+\t\thdr.Devmajor = p.parseNumeric(ustar.DevMajor())\n+\t\thdr.Devminor = p.parseNumeric(ustar.DevMinor())\n \n \t\tvar prefix string\n-\t\tswitch format {\n-\t\tcase formatUSTAR:\n+\t\tswitch {\n+\t\tcase format.has(FormatUSTAR | FormatPAX):\n+\t\t\thdr.Format = format\n \t\t\tustar := tr.blk.USTAR()\n \t\t\tprefix = p.parseString(ustar.Prefix())\n-\t\tcase formatSTAR:\n+\n+\t\t\t// For Format detection, check if block is properly formatted since\n+\t\t\t// the parser is more liberal than what USTAR actually permits.\n+\t\t\tnotASCII := func(r rune) bool { return r >= 0x80 }\n+\t\t\tif bytes.IndexFunc(tr.blk[:], notASCII) >= 0 {\n+\t\t\t\thdr.Format = FormatUnknown // Non-ASCII characters in block.\n+\t\t\t}\n+\t\t\tnul := func(b []byte) bool { return int(b[len(b)-1]) == 0 }\n+\t\t\tif !(nul(v7.Size()) && nul(v7.Mode()) && nul(v7.UID()) && nul(v7.GID()) &&\n+\t\t\t\tnul(v7.ModTime()) && nul(ustar.DevMajor()) && nul(ustar.DevMinor())) {\n+\t\t\t\thdr.Format = FormatUnknown // Numeric fields must end in NUL\n+\t\t\t}\n+\t\tcase format.has(formatSTAR):\n \t\t\tstar := tr.blk.STAR()\n \t\t\tprefix = p.parseString(star.Prefix())\n \t\t\thdr.AccessTime = time.Unix(p.parseNumeric(star.AccessTime()), 0)\n \t\t\thdr.ChangeTime = time.Unix(p.parseNumeric(star.ChangeTime()), 0)\n-\t\tcase formatGNU:\n+\t\tcase format.has(FormatGNU):\n+\t\t\thdr.Format = format\n+\t\t\tvar p2 parser\n \t\t\tgnu := tr.blk.GNU()\n-\t\t\thdr.AccessTime = tryParseTime(gnu.AccessTime())\n-\t\t\thdr.ChangeTime = tryParseTime(gnu.ChangeTime())\n+\t\t\tif b := gnu.AccessTime(); b[0] != 0 {\n+\t\t\t\thdr.AccessTime = time.Unix(p2.parseNumeric(b), 0)\n+\t\t\t}\n+\t\t\tif b := gnu.ChangeTime(); b[0] != 0 {\n+\t\t\t\thdr.ChangeTime = time.Unix(p2.parseNumeric(b), 0)\n+\t\t\t}\n+\n+\t\t\t// Prior to Go1.8, the Writer had a bug where it would output\n+\t\t\t// an invalid tar file in certain rare situations because the logic\n+\t\t\t// incorrectly believed that the old GNU format had a prefix field.\n+\t\t\t// This is wrong and leads to an output file that mangles the\n+\t\t\t// atime and ctime fields, which are often left unused.\n+\t\t\t//\n+\t\t\t// In order to continue reading tar files created by former, buggy\n+\t\t\t// versions of Go, we skeptically parse the atime and ctime fields.\n+\t\t\t// If we are unable to parse them and the prefix field looks like\n+\t\t\t// an ASCII string, then we fallback on the pre-Go1.8 behavior\n+\t\t\t// of treating these fields as the USTAR prefix field.\n+\t\t\t//\n+\t\t\t// Note that this will not use the fallback logic for all possible\n+\t\t\t// files generated by a pre-Go1.8 toolchain. If the generated file\n+\t\t\t// happened to have a prefix field that parses as valid\n+\t\t\t// atime and ctime fields (e.g., when they are valid octal strings),\n+\t\t\t// then it is impossible to distinguish between an valid GNU file\n+\t\t\t// and an invalid pre-Go1.8 file.\n+\t\t\t//\n+\t\t\t// See https://golang.org/issues/12594\n+\t\t\t// See https://golang.org/issues/21005\n+\t\t\tif p2.err != nil {\n+\t\t\t\thdr.AccessTime, hdr.ChangeTime = time.Time{}, time.Time{}\n+\t\t\t\tustar := tr.blk.USTAR()\n+\t\t\t\tif s := p.parseString(ustar.Prefix()); isASCII(s) {\n+\t\t\t\t\tprefix = s\n+\t\t\t\t}\n+\t\t\t\thdr.Format = FormatUnknown // Buggy file is not GNU\n+\t\t\t}\n \t\t}\n \t\tif len(prefix) > 0 {\n \t\t\thdr.Name = prefix + \"/\" + hdr.Name\n@@ -523,76 +459,73 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n // The Header.Size does not reflect the size of any extended headers used.\n // Thus, this function will read from the raw io.Reader to fetch extra headers.\n // This method mutates blk in the process.\n-func (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) ([]sparseEntry, error) {\n+func (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) (sparseDatas, error) {\n \t// Make sure that the input format is GNU.\n \t// Unfortunately, the STAR format also has a sparse header format that uses\n \t// the same type flag but has a completely different layout.\n-\tif blk.GetFormat() != formatGNU {\n+\tif blk.GetFormat() != FormatGNU {\n \t\treturn nil, ErrHeader\n \t}\n+\thdr.Format.mayOnlyBe(FormatGNU)\n \n \tvar p parser\n \thdr.Size = p.parseNumeric(blk.GNU().RealSize())\n \tif p.err != nil {\n \t\treturn nil, p.err\n \t}\n-\tvar s sparseArray = blk.GNU().Sparse()\n-\tvar sp = make([]sparseEntry, 0, s.MaxEntries())\n+\ts := blk.GNU().Sparse()\n+\tspd := make(sparseDatas, 0, s.MaxEntries())\n \tfor {\n \t\tfor i := 0; i < s.MaxEntries(); i++ {\n \t\t\t// This termination condition is identical to GNU and BSD tar.\n \t\t\tif s.Entry(i).Offset()[0] == 0x00 {\n \t\t\t\tbreak // Don't return, need to process extended headers (even if empty)\n \t\t\t}\n \t\t\toffset := p.parseNumeric(s.Entry(i).Offset())\n-\t\t\tnumBytes := p.parseNumeric(s.Entry(i).NumBytes())\n+\t\t\tlength := p.parseNumeric(s.Entry(i).Length())\n \t\t\tif p.err != nil {\n \t\t\t\treturn nil, p.err\n \t\t\t}\n-\t\t\tsp = append(sp, sparseEntry{offset: offset, numBytes: numBytes})\n+\t\t\tspd = append(spd, sparseEntry{Offset: offset, Length: length})\n \t\t}\n \n \t\tif s.IsExtended()[0] > 0 {\n \t\t\t// There are more entries. Read an extension header and parse its entries.\n-\t\t\tif _, err := io.ReadFull(tr.r, blk[:]); err != nil {\n-\t\t\t\tif err == io.EOF {\n-\t\t\t\t\terr = io.ErrUnexpectedEOF\n-\t\t\t\t}\n+\t\t\tif _, err := mustReadFull(tr.r, blk[:]); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\ts = blk.Sparse()\n \t\t\tcontinue\n \t\t}\n-\t\treturn sp, nil // Done\n+\t\treturn spd, nil // Done\n \t}\n }\n \n // readGNUSparseMap1x0 reads the sparse map as stored in GNU's PAX sparse format\n // version 1.0. The format of the sparse map consists of a series of\n // newline-terminated numeric fields. The first field is the number of entries\n // and is always present. Following this are the entries, consisting of two\n-// fields (offset, numBytes). This function must stop reading at the end\n+// fields (offset, length). This function must stop reading at the end\n // boundary of the block containing the last newline.\n //\n // Note that the GNU manual says that numeric values should be encoded in octal\n // format. However, the GNU tar utility itself outputs these values in decimal.\n // As such, this library treats values as being encoded in decimal.\n-func readGNUSparseMap1x0(r io.Reader) ([]sparseEntry, error) {\n-\tvar cntNewline int64\n-\tvar buf bytes.Buffer\n-\tvar blk = make([]byte, blockSize)\n-\n-\t// feedTokens copies data in numBlock chunks from r into buf until there are\n+func readGNUSparseMap1x0(r io.Reader) (sparseDatas, error) {\n+\tvar (\n+\t\tcntNewline int64\n+\t\tbuf        bytes.Buffer\n+\t\tblk        block\n+\t)\n+\n+\t// feedTokens copies data in blocks from r into buf until there are\n \t// at least cnt newlines in buf. It will not read more blocks than needed.\n-\tvar feedTokens = func(cnt int64) error {\n-\t\tfor cntNewline < cnt {\n-\t\t\tif _, err := io.ReadFull(r, blk); err != nil {\n-\t\t\t\tif err == io.EOF {\n-\t\t\t\t\terr = io.ErrUnexpectedEOF\n-\t\t\t\t}\n+\tfeedTokens := func(n int64) error {\n+\t\tfor cntNewline < n {\n+\t\t\tif _, err := mustReadFull(r, blk[:]); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t\tbuf.Write(blk)\n+\t\t\tbuf.Write(blk[:])\n \t\t\tfor _, c := range blk {\n \t\t\t\tif c == '\\n' {\n \t\t\t\t\tcntNewline++\n@@ -604,10 +537,10 @@ func readGNUSparseMap1x0(r io.Reader) ([]sparseEntry, error) {\n \n \t// nextToken gets the next token delimited by a newline. This assumes that\n \t// at least one newline exists in the buffer.\n-\tvar nextToken = func() string {\n+\tnextToken := func() string {\n \t\tcntNewline--\n \t\ttok, _ := buf.ReadString('\\n')\n-\t\treturn tok[:len(tok)-1] // Cut off newline\n+\t\treturn strings.TrimRight(tok, \"\\n\")\n \t}\n \n \t// Parse for the number of entries.\n@@ -626,197 +559,297 @@ func readGNUSparseMap1x0(r io.Reader) ([]sparseEntry, error) {\n \tif err := feedTokens(2 * numEntries); err != nil {\n \t\treturn nil, err\n \t}\n-\tsp := make([]sparseEntry, 0, numEntries)\n+\tspd := make(sparseDatas, 0, numEntries)\n \tfor i := int64(0); i < numEntries; i++ {\n-\t\toffset, err := strconv.ParseInt(nextToken(), 10, 64)\n-\t\tif err != nil {\n-\t\t\treturn nil, ErrHeader\n-\t\t}\n-\t\tnumBytes, err := strconv.ParseInt(nextToken(), 10, 64)\n-\t\tif err != nil {\n+\t\toffset, err1 := strconv.ParseInt(nextToken(), 10, 64)\n+\t\tlength, err2 := strconv.ParseInt(nextToken(), 10, 64)\n+\t\tif err1 != nil || err2 != nil {\n \t\t\treturn nil, ErrHeader\n \t\t}\n-\t\tsp = append(sp, sparseEntry{offset: offset, numBytes: numBytes})\n+\t\tspd = append(spd, sparseEntry{Offset: offset, Length: length})\n \t}\n-\treturn sp, nil\n+\treturn spd, nil\n }\n \n // readGNUSparseMap0x1 reads the sparse map as stored in GNU's PAX sparse format\n // version 0.1. The sparse map is stored in the PAX headers.\n-func readGNUSparseMap0x1(extHdrs map[string]string) ([]sparseEntry, error) {\n+func readGNUSparseMap0x1(paxHdrs map[string]string) (sparseDatas, error) {\n \t// Get number of entries.\n \t// Use integer overflow resistant math to check this.\n-\tnumEntriesStr := extHdrs[paxGNUSparseNumBlocks]\n+\tnumEntriesStr := paxHdrs[paxGNUSparseNumBlocks]\n \tnumEntries, err := strconv.ParseInt(numEntriesStr, 10, 0) // Intentionally parse as native int\n \tif err != nil || numEntries < 0 || int(2*numEntries) < int(numEntries) {\n \t\treturn nil, ErrHeader\n \t}\n \n \t// There should be two numbers in sparseMap for each entry.\n-\tsparseMap := strings.Split(extHdrs[paxGNUSparseMap], \",\")\n+\tsparseMap := strings.Split(paxHdrs[paxGNUSparseMap], \",\")\n+\tif len(sparseMap) == 1 && sparseMap[0] == \"\" {\n+\t\tsparseMap = sparseMap[:0]\n+\t}\n \tif int64(len(sparseMap)) != 2*numEntries {\n \t\treturn nil, ErrHeader\n \t}\n \n \t// Loop through the entries in the sparse map.\n \t// numEntries is trusted now.\n-\tsp := make([]sparseEntry, 0, numEntries)\n-\tfor i := int64(0); i < numEntries; i++ {\n-\t\toffset, err := strconv.ParseInt(sparseMap[2*i], 10, 64)\n-\t\tif err != nil {\n-\t\t\treturn nil, ErrHeader\n-\t\t}\n-\t\tnumBytes, err := strconv.ParseInt(sparseMap[2*i+1], 10, 64)\n-\t\tif err != nil {\n+\tspd := make(sparseDatas, 0, numEntries)\n+\tfor len(sparseMap) >= 2 {\n+\t\toffset, err1 := strconv.ParseInt(sparseMap[0], 10, 64)\n+\t\tlength, err2 := strconv.ParseInt(sparseMap[1], 10, 64)\n+\t\tif err1 != nil || err2 != nil {\n \t\t\treturn nil, ErrHeader\n \t\t}\n-\t\tsp = append(sp, sparseEntry{offset: offset, numBytes: numBytes})\n+\t\tspd = append(spd, sparseEntry{Offset: offset, Length: length})\n+\t\tsparseMap = sparseMap[2:]\n \t}\n-\treturn sp, nil\n+\treturn spd, nil\n }\n \n-// numBytes returns the number of bytes left to read in the current file's entry\n-// in the tar archive, or 0 if there is no current file.\n-func (tr *Reader) numBytes() int64 {\n-\tif tr.curr == nil {\n-\t\t// No current file, so no bytes\n-\t\treturn 0\n-\t}\n-\treturn tr.curr.numBytes()\n-}\n-\n-// Read reads from the current entry in the tar archive.\n-// It returns 0, io.EOF when it reaches the end of that entry,\n-// until Next is called to advance to the next entry.\n+// Read reads from the current file in the tar archive.\n+// It returns (0, io.EOF) when it reaches the end of that file,\n+// until Next is called to advance to the next file.\n //\n-// Calling Read on special types like TypeLink, TypeSymLink, TypeChar,\n-// TypeBlock, TypeDir, and TypeFifo returns 0, io.EOF regardless of what\n+// If the current file is sparse, then the regions marked as a hole\n+// are read back as NUL-bytes.\n+//\n+// Calling Read on special types like TypeLink, TypeSymlink, TypeChar,\n+// TypeBlock, TypeDir, and TypeFifo returns (0, io.EOF) regardless of what\n // the Header.Size claims.\n func (tr *Reader) Read(b []byte) (int, error) {\n \tif tr.err != nil {\n \t\treturn 0, tr.err\n \t}\n-\tif tr.curr == nil {\n-\t\treturn 0, io.EOF\n-\t}\n-\n \tn, err := tr.curr.Read(b)\n \tif err != nil && err != io.EOF {\n \t\ttr.err = err\n \t}\n \treturn n, err\n }\n \n-func (rfr *regFileReader) Read(b []byte) (n int, err error) {\n-\tif rfr.nb == 0 {\n-\t\t// file consumed\n-\t\treturn 0, io.EOF\n+// writeTo writes the content of the current file to w.\n+// The bytes written matches the number of remaining bytes in the current file.\n+//\n+// If the current file is sparse and w is an io.WriteSeeker,\n+// then writeTo uses Seek to skip past holes defined in Header.SparseHoles,\n+// assuming that skipped regions are filled with NULs.\n+// This always writes the last byte to ensure w is the right size.\n+//\n+// TODO(dsnet): Re-export this when adding sparse file support.\n+// See https://golang.org/issue/22735\n+func (tr *Reader) writeTo(w io.Writer) (int64, error) {\n+\tif tr.err != nil {\n+\t\treturn 0, tr.err\n \t}\n-\tif int64(len(b)) > rfr.nb {\n-\t\tb = b[0:rfr.nb]\n+\tn, err := tr.curr.WriteTo(w)\n+\tif err != nil {\n+\t\ttr.err = err\n \t}\n-\tn, err = rfr.r.Read(b)\n-\trfr.nb -= int64(n)\n+\treturn n, err\n+}\n \n-\tif err == io.EOF && rfr.nb > 0 {\n-\t\terr = io.ErrUnexpectedEOF\n+// regFileReader is a fileReader for reading data from a regular file entry.\n+type regFileReader struct {\n+\tr  io.Reader // Underlying Reader\n+\tnb int64     // Number of remaining bytes to read\n+}\n+\n+func (fr *regFileReader) Read(b []byte) (n int, err error) {\n+\tif int64(len(b)) > fr.nb {\n+\t\tb = b[:fr.nb]\n+\t}\n+\tif len(b) > 0 {\n+\t\tn, err = fr.r.Read(b)\n+\t\tfr.nb -= int64(n)\n+\t}\n+\tswitch {\n+\tcase err == io.EOF && fr.nb > 0:\n+\t\treturn n, io.ErrUnexpectedEOF\n+\tcase err == nil && fr.nb == 0:\n+\t\treturn n, io.EOF\n+\tdefault:\n+\t\treturn n, err\n \t}\n-\treturn\n }\n \n-// numBytes returns the number of bytes left to read in the file's data in the tar archive.\n-func (rfr *regFileReader) numBytes() int64 {\n-\treturn rfr.nb\n+func (fr *regFileReader) WriteTo(w io.Writer) (int64, error) {\n+\treturn io.Copy(w, struct{ io.Reader }{fr})\n }\n \n-// newSparseFileReader creates a new sparseFileReader, but validates all of the\n-// sparse entries before doing so.\n-func newSparseFileReader(rfr numBytesReader, sp []sparseEntry, total int64) (*sparseFileReader, error) {\n-\tif total < 0 {\n-\t\treturn nil, ErrHeader // Total size cannot be negative\n-\t}\n+func (fr regFileReader) LogicalRemaining() int64 {\n+\treturn fr.nb\n+}\n \n-\t// Validate all sparse entries. These are the same checks as performed by\n-\t// the BSD tar utility.\n-\tfor i, s := range sp {\n-\t\tswitch {\n-\t\tcase s.offset < 0 || s.numBytes < 0:\n-\t\t\treturn nil, ErrHeader // Negative values are never okay\n-\t\tcase s.offset > math.MaxInt64-s.numBytes:\n-\t\t\treturn nil, ErrHeader // Integer overflow with large length\n-\t\tcase s.offset+s.numBytes > total:\n-\t\t\treturn nil, ErrHeader // Region extends beyond the \"real\" size\n-\t\tcase i > 0 && sp[i-1].offset+sp[i-1].numBytes > s.offset:\n-\t\t\treturn nil, ErrHeader // Regions can't overlap and must be in order\n-\t\t}\n-\t}\n-\treturn &sparseFileReader{rfr: rfr, sp: sp, total: total}, nil\n+func (fr regFileReader) PhysicalRemaining() int64 {\n+\treturn fr.nb\n+}\n+\n+// sparseFileReader is a fileReader for reading data from a sparse file entry.\n+type sparseFileReader struct {\n+\tfr  fileReader  // Underlying fileReader\n+\tsp  sparseHoles // Normalized list of sparse holes\n+\tpos int64       // Current position in sparse file\n }\n \n-// readHole reads a sparse hole ending at endOffset.\n-func (sfr *sparseFileReader) readHole(b []byte, endOffset int64) int {\n-\tn64 := endOffset - sfr.pos\n-\tif n64 > int64(len(b)) {\n-\t\tn64 = int64(len(b))\n+func (sr *sparseFileReader) Read(b []byte) (n int, err error) {\n+\tfinished := int64(len(b)) >= sr.LogicalRemaining()\n+\tif finished {\n+\t\tb = b[:sr.LogicalRemaining()]\n+\t}\n+\n+\tb0 := b\n+\tendPos := sr.pos + int64(len(b))\n+\tfor endPos > sr.pos && err == nil {\n+\t\tvar nf int // Bytes read in fragment\n+\t\tholeStart, holeEnd := sr.sp[0].Offset, sr.sp[0].endOffset()\n+\t\tif sr.pos < holeStart { // In a data fragment\n+\t\t\tbf := b[:min(int64(len(b)), holeStart-sr.pos)]\n+\t\t\tnf, err = tryReadFull(sr.fr, bf)\n+\t\t} else { // In a hole fragment\n+\t\t\tbf := b[:min(int64(len(b)), holeEnd-sr.pos)]\n+\t\t\tnf, err = tryReadFull(zeroReader{}, bf)\n+\t\t}\n+\t\tb = b[nf:]\n+\t\tsr.pos += int64(nf)\n+\t\tif sr.pos >= holeEnd && len(sr.sp) > 1 {\n+\t\t\tsr.sp = sr.sp[1:] // Ensure last fragment always remains\n+\t\t}\n \t}\n-\tn := int(n64)\n-\tfor i := 0; i < n; i++ {\n-\t\tb[i] = 0\n+\n+\tn = len(b0) - len(b)\n+\tswitch {\n+\tcase err == io.EOF:\n+\t\treturn n, errMissData // Less data in dense file than sparse file\n+\tcase err != nil:\n+\t\treturn n, err\n+\tcase sr.LogicalRemaining() == 0 && sr.PhysicalRemaining() > 0:\n+\t\treturn n, errUnrefData // More data in dense file than sparse file\n+\tcase finished:\n+\t\treturn n, io.EOF\n+\tdefault:\n+\t\treturn n, nil\n \t}\n-\tsfr.pos += n64\n-\treturn n\n }\n \n-// Read reads the sparse file data in expanded form.\n-func (sfr *sparseFileReader) Read(b []byte) (n int, err error) {\n-\t// Skip past all empty fragments.\n-\tfor len(sfr.sp) > 0 && sfr.sp[0].numBytes == 0 {\n-\t\tsfr.sp = sfr.sp[1:]\n+func (sr *sparseFileReader) WriteTo(w io.Writer) (n int64, err error) {\n+\tws, ok := w.(io.WriteSeeker)\n+\tif ok {\n+\t\tif _, err := ws.Seek(0, io.SeekCurrent); err != nil {\n+\t\t\tok = false // Not all io.Seeker can really seek\n+\t\t}\n \t}\n-\n-\t// If there are no more fragments, then it is possible that there\n-\t// is one last sparse hole.\n-\tif len(sfr.sp) == 0 {\n-\t\t// This behavior matches the BSD tar utility.\n-\t\t// However, GNU tar stops returning data even if sfr.total is unmet.\n-\t\tif sfr.pos < sfr.total {\n-\t\t\treturn sfr.readHole(b, sfr.total), nil\n+\tif !ok {\n+\t\treturn io.Copy(w, struct{ io.Reader }{sr})\n+\t}\n+\n+\tvar writeLastByte bool\n+\tpos0 := sr.pos\n+\tfor sr.LogicalRemaining() > 0 && !writeLastByte && err == nil {\n+\t\tvar nf int64 // Size of fragment\n+\t\tholeStart, holeEnd := sr.sp[0].Offset, sr.sp[0].endOffset()\n+\t\tif sr.pos < holeStart { // In a data fragment\n+\t\t\tnf = holeStart - sr.pos\n+\t\t\tnf, err = io.CopyN(ws, sr.fr, nf)\n+\t\t} else { // In a hole fragment\n+\t\t\tnf = holeEnd - sr.pos\n+\t\t\tif sr.PhysicalRemaining() == 0 {\n+\t\t\t\twriteLastByte = true\n+\t\t\t\tnf--\n+\t\t\t}\n+\t\t\t_, err = ws.Seek(nf, io.SeekCurrent)\n \t\t}\n-\t\treturn 0, io.EOF\n+\t\tsr.pos += nf\n+\t\tif sr.pos >= holeEnd && len(sr.sp) > 1 {\n+\t\t\tsr.sp = sr.sp[1:] // Ensure last fragment always remains\n+\t\t}\n+\t}\n+\n+\t// If the last fragment is a hole, then seek to 1-byte before EOF, and\n+\t// write a single byte to ensure the file is the right size.\n+\tif writeLastByte && err == nil {\n+\t\t_, err = ws.Write([]byte{0})\n+\t\tsr.pos++\n \t}\n \n-\t// In front of a data fragment, so read a hole.\n-\tif sfr.pos < sfr.sp[0].offset {\n-\t\treturn sfr.readHole(b, sfr.sp[0].offset), nil\n+\tn = sr.pos - pos0\n+\tswitch {\n+\tcase err == io.EOF:\n+\t\treturn n, errMissData // Less data in dense file than sparse file\n+\tcase err != nil:\n+\t\treturn n, err\n+\tcase sr.LogicalRemaining() == 0 && sr.PhysicalRemaining() > 0:\n+\t\treturn n, errUnrefData // More data in dense file than sparse file\n+\tdefault:\n+\t\treturn n, nil\n \t}\n+}\n+\n+func (sr sparseFileReader) LogicalRemaining() int64 {\n+\treturn sr.sp[len(sr.sp)-1].endOffset() - sr.pos\n+}\n+func (sr sparseFileReader) PhysicalRemaining() int64 {\n+\treturn sr.fr.PhysicalRemaining()\n+}\n+\n+type zeroReader struct{}\n \n-\t// In a data fragment, so read from it.\n-\t// This math is overflow free since we verify that offset and numBytes can\n-\t// be safely added when creating the sparseFileReader.\n-\tendPos := sfr.sp[0].offset + sfr.sp[0].numBytes // End offset of fragment\n-\tbytesLeft := endPos - sfr.pos                   // Bytes left in fragment\n-\tif int64(len(b)) > bytesLeft {\n-\t\tb = b[:bytesLeft]\n+func (zeroReader) Read(b []byte) (int, error) {\n+\tfor i := range b {\n+\t\tb[i] = 0\n \t}\n+\treturn len(b), nil\n+}\n \n-\tn, err = sfr.rfr.Read(b)\n-\tsfr.pos += int64(n)\n+// mustReadFull is like io.ReadFull except it returns\n+// io.ErrUnexpectedEOF when io.EOF is hit before len(b) bytes are read.\n+func mustReadFull(r io.Reader, b []byte) (int, error) {\n+\tn, err := tryReadFull(r, b)\n \tif err == io.EOF {\n-\t\tif sfr.pos < endPos {\n-\t\t\terr = io.ErrUnexpectedEOF // There was supposed to be more data\n-\t\t} else if sfr.pos < sfr.total {\n-\t\t\terr = nil // There is still an implicit sparse hole at the end\n-\t\t}\n+\t\terr = io.ErrUnexpectedEOF\n \t}\n+\treturn n, err\n+}\n \n-\tif sfr.pos == endPos {\n-\t\tsfr.sp = sfr.sp[1:] // We are done with this fragment, so pop it\n+// tryReadFull is like io.ReadFull except it returns\n+// io.EOF when it is hit before len(b) bytes are read.\n+func tryReadFull(r io.Reader, b []byte) (n int, err error) {\n+\tfor len(b) > n && err == nil {\n+\t\tvar nn int\n+\t\tnn, err = r.Read(b[n:])\n+\t\tn += nn\n+\t}\n+\tif len(b) == n && err == io.EOF {\n+\t\terr = nil\n \t}\n \treturn n, err\n }\n \n-// numBytes returns the number of bytes left to read in the sparse file's\n-// sparse-encoded data in the tar archive.\n-func (sfr *sparseFileReader) numBytes() int64 {\n-\treturn sfr.rfr.numBytes()\n+// discard skips n bytes in r, reporting an error if unable to do so.\n+func discard(r io.Reader, n int64) error {\n+\t// If possible, Seek to the last byte before the end of the data section.\n+\t// Do this because Seek is often lazy about reporting errors; this will mask\n+\t// the fact that the stream may be truncated. We can rely on the\n+\t// io.CopyN done shortly afterwards to trigger any IO errors.\n+\tvar seekSkipped int64 // Number of bytes skipped via Seek\n+\tif sr, ok := r.(io.Seeker); ok && n > 1 {\n+\t\t// Not all io.Seeker can actually Seek. For example, os.Stdin implements\n+\t\t// io.Seeker, but calling Seek always returns an error and performs\n+\t\t// no action. Thus, we try an innocent seek to the current position\n+\t\t// to see if Seek is really supported.\n+\t\tpos1, err := sr.Seek(0, io.SeekCurrent)\n+\t\tif pos1 >= 0 && err == nil {\n+\t\t\t// Seek seems supported, so perform the real Seek.\n+\t\t\tpos2, err := sr.Seek(n-1, io.SeekCurrent)\n+\t\t\tif pos2 < 0 || err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tseekSkipped = pos2 - pos1\n+\t\t}\n+\t}\n+\n+\tcopySkipped, err := io.CopyN(ioutil.Discard, r, n-seekSkipped)\n+\tif err == io.EOF && seekSkipped+copySkipped < n {\n+\t\terr = io.ErrUnexpectedEOF\n+\t}\n+\treturn err\n }"}, {"sha": "a6832d33b1b58575ba42dbfb602f2dab770ef992", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 971, "deletions": 457, "changes": 1428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -7,12 +7,15 @@ package tar\n import (\n \t\"bytes\"\n \t\"crypto/md5\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"math\"\n \t\"os\"\n+\t\"path\"\n \t\"reflect\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -36,6 +39,7 @@ func TestReader(t *testing.T) {\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n+\t\t\tFormat:   FormatGNU,\n \t\t}, {\n \t\t\tName:     \"small2.txt\",\n \t\t\tMode:     0640,\n@@ -46,6 +50,7 @@ func TestReader(t *testing.T) {\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"dsymonds\",\n \t\t\tGname:    \"eng\",\n+\t\t\tFormat:   FormatGNU,\n \t\t}},\n \t\tchksums: []string{\n \t\t\t\"e38b27eaccb4391bdec553a7f3ae6b2f\",\n@@ -66,6 +71,7 @@ func TestReader(t *testing.T) {\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t\tFormat:   FormatGNU,\n \t\t}, {\n \t\t\tName:     \"sparse-posix-0.0\",\n \t\t\tMode:     420,\n@@ -79,6 +85,12 @@ func TestReader(t *testing.T) {\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"GNU.sparse.size\":      \"200\",\n+\t\t\t\t\"GNU.sparse.numblocks\": \"95\",\n+\t\t\t\t\"GNU.sparse.map\":       \"1,1,3,1,5,1,7,1,9,1,11,1,13,1,15,1,17,1,19,1,21,1,23,1,25,1,27,1,29,1,31,1,33,1,35,1,37,1,39,1,41,1,43,1,45,1,47,1,49,1,51,1,53,1,55,1,57,1,59,1,61,1,63,1,65,1,67,1,69,1,71,1,73,1,75,1,77,1,79,1,81,1,83,1,85,1,87,1,89,1,91,1,93,1,95,1,97,1,99,1,101,1,103,1,105,1,107,1,109,1,111,1,113,1,115,1,117,1,119,1,121,1,123,1,125,1,127,1,129,1,131,1,133,1,135,1,137,1,139,1,141,1,143,1,145,1,147,1,149,1,151,1,153,1,155,1,157,1,159,1,161,1,163,1,165,1,167,1,169,1,171,1,173,1,175,1,177,1,179,1,181,1,183,1,185,1,187,1,189,1\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}, {\n \t\t\tName:     \"sparse-posix-0.1\",\n \t\t\tMode:     420,\n@@ -92,6 +104,13 @@ func TestReader(t *testing.T) {\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"GNU.sparse.size\":      \"200\",\n+\t\t\t\t\"GNU.sparse.numblocks\": \"95\",\n+\t\t\t\t\"GNU.sparse.map\":       \"1,1,3,1,5,1,7,1,9,1,11,1,13,1,15,1,17,1,19,1,21,1,23,1,25,1,27,1,29,1,31,1,33,1,35,1,37,1,39,1,41,1,43,1,45,1,47,1,49,1,51,1,53,1,55,1,57,1,59,1,61,1,63,1,65,1,67,1,69,1,71,1,73,1,75,1,77,1,79,1,81,1,83,1,85,1,87,1,89,1,91,1,93,1,95,1,97,1,99,1,101,1,103,1,105,1,107,1,109,1,111,1,113,1,115,1,117,1,119,1,121,1,123,1,125,1,127,1,129,1,131,1,133,1,135,1,137,1,139,1,141,1,143,1,145,1,147,1,149,1,151,1,153,1,155,1,157,1,159,1,161,1,163,1,165,1,167,1,169,1,171,1,173,1,175,1,177,1,179,1,181,1,183,1,185,1,187,1,189,1\",\n+\t\t\t\t\"GNU.sparse.name\":      \"sparse-posix-0.1\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}, {\n \t\t\tName:     \"sparse-posix-1.0\",\n \t\t\tMode:     420,\n@@ -105,6 +124,13 @@ func TestReader(t *testing.T) {\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"GNU.sparse.major\":    \"1\",\n+\t\t\t\t\"GNU.sparse.minor\":    \"0\",\n+\t\t\t\t\"GNU.sparse.realsize\": \"200\",\n+\t\t\t\t\"GNU.sparse.name\":     \"sparse-posix-1.0\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}, {\n \t\t\tName:     \"end\",\n \t\t\tMode:     420,\n@@ -118,6 +144,7 @@ func TestReader(t *testing.T) {\n \t\t\tGname:    \"david\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t\tFormat:   FormatGNU,\n \t\t}},\n \t\tchksums: []string{\n \t\t\t\"6f53234398c2449fe67c1812d993012f\",\n@@ -186,6 +213,13 @@ func TestReader(t *testing.T) {\n \t\t\tChangeTime: time.Unix(1350244992, 23960108),\n \t\t\tAccessTime: time.Unix(1350244992, 23960108),\n \t\t\tTypeflag:   TypeReg,\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"path\":  \"a/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n+\t\t\t\t\"mtime\": \"1350244992.023960108\",\n+\t\t\t\t\"atime\": \"1350244992.023960108\",\n+\t\t\t\t\"ctime\": \"1350244992.023960108\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}, {\n \t\t\tName:       \"a/b\",\n \t\t\tMode:       0777,\n@@ -199,6 +233,13 @@ func TestReader(t *testing.T) {\n \t\t\tAccessTime: time.Unix(1350266320, 910238425),\n \t\t\tTypeflag:   TypeSymlink,\n \t\t\tLinkname:   \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"linkpath\": \"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100\",\n+\t\t\t\t\"mtime\":    \"1350266320.910238425\",\n+\t\t\t\t\"atime\":    \"1350266320.910238425\",\n+\t\t\t\t\"ctime\":    \"1350266320.910238425\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}},\n \t}, {\n \t\tfile: \"testdata/pax-bad-hdr-file.tar\",\n@@ -218,10 +259,63 @@ func TestReader(t *testing.T) {\n \t\t\tTypeflag: '0',\n \t\t\tUname:    \"joetsai\",\n \t\t\tGname:    \"eng\",\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"size\": \"000000000000000000000999\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}},\n \t\tchksums: []string{\n \t\t\t\"0afb597b283fe61b5d4879669a350556\",\n \t\t},\n+\t}, {\n+\t\tfile: \"testdata/pax-records.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tTypeflag: TypeReg,\n+\t\t\tName:     \"file\",\n+\t\t\tUname:    strings.Repeat(\"long\", 10),\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"GOLANG.pkg\": \"tar\",\n+\t\t\t\t\"comment\":    \"Hello, \u4e16\u754c\",\n+\t\t\t\t\"uname\":      strings.Repeat(\"long\", 10),\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n+\t\t}},\n+\t}, {\n+\t\tfile: \"testdata/pax-global-records.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tTypeflag:   TypeXGlobalHeader,\n+\t\t\tName:       \"global1\",\n+\t\t\tPAXRecords: map[string]string{\"path\": \"global1\", \"mtime\": \"1500000000.0\"},\n+\t\t\tFormat:     FormatPAX,\n+\t\t}, {\n+\t\t\tTypeflag: TypeReg,\n+\t\t\tName:     \"file1\",\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tFormat:   FormatUSTAR,\n+\t\t}, {\n+\t\t\tTypeflag:   TypeReg,\n+\t\t\tName:       \"file2\",\n+\t\t\tPAXRecords: map[string]string{\"path\": \"file2\"},\n+\t\t\tModTime:    time.Unix(0, 0),\n+\t\t\tFormat:     FormatPAX,\n+\t\t}, {\n+\t\t\tTypeflag:   TypeXGlobalHeader,\n+\t\t\tName:       \"GlobalHead.0.0\",\n+\t\t\tPAXRecords: map[string]string{\"path\": \"\"},\n+\t\t\tFormat:     FormatPAX,\n+\t\t}, {\n+\t\t\tTypeflag: TypeReg,\n+\t\t\tName:     \"file3\",\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tFormat:   FormatUSTAR,\n+\t\t}, {\n+\t\t\tTypeflag:   TypeReg,\n+\t\t\tName:       \"file4\",\n+\t\t\tModTime:    time.Unix(1400000000, 0),\n+\t\t\tPAXRecords: map[string]string{\"mtime\": \"1400000000\"},\n+\t\t\tFormat:     FormatPAX,\n+\t\t}},\n \t}, {\n \t\tfile: \"testdata/nil-uid.tar\", // golang.org/issue/5290\n \t\theaders: []*Header{{\n@@ -237,6 +331,7 @@ func TestReader(t *testing.T) {\n \t\t\tGname:    \"eyefi\",\n \t\t\tDevmajor: 0,\n \t\t\tDevminor: 0,\n+\t\t\tFormat:   FormatGNU,\n \t\t}},\n \t}, {\n \t\tfile: \"testdata/xattrs.tar\",\n@@ -258,6 +353,15 @@ func TestReader(t *testing.T) {\n \t\t\t\t// Interestingly, selinux encodes the terminating null inside the xattr\n \t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n \t\t\t},\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"mtime\":                         \"1386065770.44825232\",\n+\t\t\t\t\"atime\":                         \"1389782991.41987522\",\n+\t\t\t\t\"ctime\":                         \"1389782956.794414986\",\n+\t\t\t\t\"SCHILY.xattr.user.key\":         \"value\",\n+\t\t\t\t\"SCHILY.xattr.user.key2\":        \"value2\",\n+\t\t\t\t\"SCHILY.xattr.security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}, {\n \t\t\tName:       \"small2.txt\",\n \t\t\tMode:       0644,\n@@ -273,6 +377,13 @@ func TestReader(t *testing.T) {\n \t\t\tXattrs: map[string]string{\n \t\t\t\t\"security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n \t\t\t},\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"mtime\": \"1386065770.449252304\",\n+\t\t\t\t\"atime\": \"1389782991.41987522\",\n+\t\t\t\t\"ctime\": \"1386065770.449252304\",\n+\t\t\t\t\"SCHILY.xattr.security.selinux\": \"unconfined_u:object_r:default_t:s0\\x00\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n \t\t}},\n \t}, {\n \t\t// Matches the behavior of GNU, BSD, and STAR tar utilities.\n@@ -282,6 +393,7 @@ func TestReader(t *testing.T) {\n \t\t\tLinkname: \"GNU4/GNU4/long-linkpath-name\",\n \t\t\tModTime:  time.Unix(0, 0),\n \t\t\tTypeflag: '2',\n+\t\t\tFormat:   FormatGNU,\n \t\t}},\n \t}, {\n \t\t// GNU tar file with atime and ctime fields set.\n@@ -300,6 +412,7 @@ func TestReader(t *testing.T) {\n \t\t\tGname:      \"dsnet\",\n \t\t\tAccessTime: time.Unix(1441974501, 0),\n \t\t\tChangeTime: time.Unix(1441973436, 0),\n+\t\t\tFormat:     FormatGNU,\n \t\t}, {\n \t\t\tName:       \"test2/foo\",\n \t\t\tMode:       33188,\n@@ -312,6 +425,7 @@ func TestReader(t *testing.T) {\n \t\t\tGname:      \"dsnet\",\n \t\t\tAccessTime: time.Unix(1441974501, 0),\n \t\t\tChangeTime: time.Unix(1441973436, 0),\n+\t\t\tFormat:     FormatGNU,\n \t\t}, {\n \t\t\tName:       \"test2/sparse\",\n \t\t\tMode:       33188,\n@@ -324,6 +438,7 @@ func TestReader(t *testing.T) {\n \t\t\tGname:      \"dsnet\",\n \t\t\tAccessTime: time.Unix(1441991948, 0),\n \t\t\tChangeTime: time.Unix(1441973436, 0),\n+\t\t\tFormat:     FormatGNU,\n \t\t}},\n \t}, {\n \t\t// Matches the behavior of GNU and BSD tar utilities.\n@@ -333,7 +448,75 @@ func TestReader(t *testing.T) {\n \t\t\tLinkname: \"PAX4/PAX4/long-linkpath-name\",\n \t\t\tModTime:  time.Unix(0, 0),\n \t\t\tTypeflag: '2',\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"linkpath\": \"PAX4/PAX4/long-linkpath-name\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n+\t\t}},\n+\t}, {\n+\t\t// Both BSD and GNU tar truncate long names at first NUL even\n+\t\t// if there is data following that NUL character.\n+\t\t// This is reasonable as GNU long names are C-strings.\n+\t\tfile: \"testdata/gnu-long-nul.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"0123456789\",\n+\t\t\tMode:     0644,\n+\t\t\tUid:      1000,\n+\t\t\tGid:      1000,\n+\t\t\tModTime:  time.Unix(1486082191, 0),\n+\t\t\tTypeflag: '0',\n+\t\t\tUname:    \"rawr\",\n+\t\t\tGname:    \"dsnet\",\n+\t\t\tFormat:   FormatGNU,\n \t\t}},\n+\t}, {\n+\t\t// This archive was generated by Writer but is readable by both\n+\t\t// GNU and BSD tar utilities.\n+\t\t// The archive generated by GNU is nearly byte-for-byte identical\n+\t\t// to the Go version except the Go version sets a negative Devminor\n+\t\t// just to force the GNU format.\n+\t\tfile: \"testdata/gnu-utf8.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName: \"\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\",\n+\t\t\tMode: 0644,\n+\t\t\tUid:  1000, Gid: 1000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tTypeflag: '0',\n+\t\t\tUname:    \"\u263a\",\n+\t\t\tGname:    \"\u26b9\",\n+\t\t\tFormat:   FormatGNU,\n+\t\t}},\n+\t}, {\n+\t\t// This archive was generated by Writer but is readable by both\n+\t\t// GNU and BSD tar utilities.\n+\t\t// The archive generated by GNU is nearly byte-for-byte identical\n+\t\t// to the Go version except the Go version sets a negative Devminor\n+\t\t// just to force the GNU format.\n+\t\tfile: \"testdata/gnu-not-utf8.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"hi\\x80\\x81\\x82\\x83bye\",\n+\t\t\tMode:     0644,\n+\t\t\tUid:      1000,\n+\t\t\tGid:      1000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tTypeflag: '0',\n+\t\t\tUname:    \"rawr\",\n+\t\t\tGname:    \"dsnet\",\n+\t\t\tFormat:   FormatGNU,\n+\t\t}},\n+\t}, {\n+\t\t// BSD tar v3.1.2 and GNU tar v1.27.1 both rejects PAX records\n+\t\t// with NULs in the key.\n+\t\tfile: \"testdata/pax-nul-xattrs.tar\",\n+\t\terr:  ErrHeader,\n+\t}, {\n+\t\t// BSD tar v3.1.2 rejects a PAX path with NUL in the value, while\n+\t\t// GNU tar v1.27.1 simply truncates at first NUL.\n+\t\t// We emulate the behavior of BSD since it is strange doing NUL\n+\t\t// truncations since PAX records are length-prefix strings instead\n+\t\t// of NUL-terminated C-strings.\n+\t\tfile: \"testdata/pax-nul-path.tar\",\n+\t\terr:  ErrHeader,\n \t}, {\n \t\tfile: \"testdata/neg-size.tar\",\n \t\terr:  ErrHeader,\n@@ -346,483 +529,214 @@ func TestReader(t *testing.T) {\n \t}, {\n \t\tfile: \"testdata/issue12435.tar\",\n \t\terr:  ErrHeader,\n-\t}}\n-\n-\tfor i, v := range vectors {\n-\t\tf, err := os.Open(v.file)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"file %s, test %d: unexpected error: %v\", v.file, i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tdefer f.Close()\n-\n-\t\t// Capture all headers and checksums.\n-\t\tvar (\n-\t\t\ttr      = NewReader(f)\n-\t\t\thdrs    []*Header\n-\t\t\tchksums []string\n-\t\t\trdbuf   = make([]byte, 8)\n-\t\t)\n-\t\tfor {\n-\t\t\tvar hdr *Header\n-\t\t\thdr, err = tr.Next()\n-\t\t\tif err != nil {\n-\t\t\t\tif err == io.EOF {\n-\t\t\t\t\terr = nil // Expected error\n-\t\t\t\t}\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\thdrs = append(hdrs, hdr)\n-\n-\t\t\tif v.chksums == nil {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\th := md5.New()\n-\t\t\t_, err = io.CopyBuffer(h, tr, rdbuf) // Effectively an incremental read\n-\t\t\tif err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tchksums = append(chksums, fmt.Sprintf(\"%x\", h.Sum(nil)))\n-\t\t}\n-\n-\t\tfor j, hdr := range hdrs {\n-\t\t\tif j >= len(v.headers) {\n-\t\t\t\tt.Errorf(\"file %s, test %d, entry %d: unexpected header:\\ngot %+v\",\n-\t\t\t\t\tv.file, i, j, *hdr)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif !reflect.DeepEqual(*hdr, *v.headers[j]) {\n-\t\t\t\tt.Errorf(\"file %s, test %d, entry %d: incorrect header:\\ngot  %+v\\nwant %+v\",\n-\t\t\t\t\tv.file, i, j, *hdr, *v.headers[j])\n-\t\t\t}\n-\t\t}\n-\t\tif len(hdrs) != len(v.headers) {\n-\t\t\tt.Errorf(\"file %s, test %d: got %d headers, want %d headers\",\n-\t\t\t\tv.file, i, len(hdrs), len(v.headers))\n-\t\t}\n-\n-\t\tfor j, sum := range chksums {\n-\t\t\tif j >= len(v.chksums) {\n-\t\t\t\tt.Errorf(\"file %s, test %d, entry %d: unexpected sum: got %s\",\n-\t\t\t\t\tv.file, i, j, sum)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif sum != v.chksums[j] {\n-\t\t\t\tt.Errorf(\"file %s, test %d, entry %d: incorrect checksum: got %s, want %s\",\n-\t\t\t\t\tv.file, i, j, sum, v.chksums[j])\n-\t\t\t}\n-\t\t}\n-\n-\t\tif err != v.err {\n-\t\t\tt.Errorf(\"file %s, test %d: unexpected error: got %v, want %v\",\n-\t\t\t\tv.file, i, err, v.err)\n-\t\t}\n-\t\tf.Close()\n-\t}\n-}\n-\n-func TestPartialRead(t *testing.T) {\n-\tf, err := os.Open(\"testdata/gnu.tar\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"Unexpected error: %v\", err)\n-\t}\n-\tdefer f.Close()\n-\n-\ttr := NewReader(f)\n-\n-\t// Read the first four bytes; Next() should skip the last byte.\n-\thdr, err := tr.Next()\n-\tif err != nil || hdr == nil {\n-\t\tt.Fatalf(\"Didn't get first file: %v\", err)\n-\t}\n-\tbuf := make([]byte, 4)\n-\tif _, err := io.ReadFull(tr, buf); err != nil {\n-\t\tt.Fatalf(\"Unexpected error: %v\", err)\n-\t}\n-\tif expected := []byte(\"Kilt\"); !bytes.Equal(buf, expected) {\n-\t\tt.Errorf(\"Contents = %v, want %v\", buf, expected)\n-\t}\n-\n-\t// Second file\n-\thdr, err = tr.Next()\n-\tif err != nil || hdr == nil {\n-\t\tt.Fatalf(\"Didn't get second file: %v\", err)\n-\t}\n-\tbuf = make([]byte, 6)\n-\tif _, err := io.ReadFull(tr, buf); err != nil {\n-\t\tt.Fatalf(\"Unexpected error: %v\", err)\n-\t}\n-\tif expected := []byte(\"Google\"); !bytes.Equal(buf, expected) {\n-\t\tt.Errorf(\"Contents = %v, want %v\", buf, expected)\n-\t}\n-}\n-\n-func TestSparseFileReader(t *testing.T) {\n-\tvectors := []struct {\n-\t\trealSize   int64         // Real size of the output file\n-\t\tsparseMap  []sparseEntry // Input sparse map\n-\t\tsparseData string        // Input compact data\n-\t\texpected   string        // Expected output data\n-\t\terr        error         // Expected error outcome\n-\t}{{\n-\t\trealSize: 8,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 0, numBytes: 2},\n-\t\t\t{offset: 5, numBytes: 3},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\texpected:   \"ab\\x00\\x00\\x00cde\",\n-\t}, {\n-\t\trealSize: 10,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 0, numBytes: 2},\n-\t\t\t{offset: 5, numBytes: 3},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\texpected:   \"ab\\x00\\x00\\x00cde\\x00\\x00\",\n \t}, {\n-\t\trealSize: 8,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 2},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\texpected:   \"\\x00abc\\x00\\x00de\",\n-\t}, {\n-\t\trealSize: 8,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 0},\n-\t\t\t{offset: 6, numBytes: 0},\n-\t\t\t{offset: 6, numBytes: 2},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\texpected:   \"\\x00abc\\x00\\x00de\",\n+\t\t// Ensure that we can read back the original Header as written with\n+\t\t// a buggy pre-Go1.8 tar.Writer.\n+\t\tfile: \"testdata/invalid-go17.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:    \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/foo\",\n+\t\t\tUid:     010000000,\n+\t\t\tModTime: time.Unix(0, 0),\n+\t\t}},\n \t}, {\n-\t\trealSize: 10,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 2},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\texpected:   \"\\x00abc\\x00\\x00de\\x00\\x00\",\n-\t}, {\n-\t\trealSize: 10,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 2},\n-\t\t\t{offset: 8, numBytes: 0},\n-\t\t\t{offset: 8, numBytes: 0},\n-\t\t\t{offset: 8, numBytes: 0},\n-\t\t\t{offset: 8, numBytes: 0},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\texpected:   \"\\x00abc\\x00\\x00de\\x00\\x00\",\n-\t}, {\n-\t\trealSize:   2,\n-\t\tsparseMap:  []sparseEntry{},\n-\t\tsparseData: \"\",\n-\t\texpected:   \"\\x00\\x00\",\n-\t}, {\n-\t\trealSize:  -2,\n-\t\tsparseMap: []sparseEntry{},\n-\t\terr:       ErrHeader,\n-\t}, {\n-\t\trealSize: -10,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 2},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\terr:        ErrHeader,\n+\t\t// USTAR archive with a regular entry with non-zero device numbers.\n+\t\tfile: \"testdata/ustar-file-devs.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"file\",\n+\t\t\tMode:     0644,\n+\t\t\tTypeflag: '0',\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tDevmajor: 1,\n+\t\t\tDevminor: 1,\n+\t\t\tFormat:   FormatUSTAR,\n+\t\t}},\n \t}, {\n-\t\trealSize: 10,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 5},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\terr:        ErrHeader,\n+\t\t// Generated by Go, works on BSD tar v3.1.2 and GNU tar v.1.27.1.\n+\t\tfile: \"testdata/gnu-nil-sparse-data.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"sparse.db\",\n+\t\t\tTypeflag: TypeGNUSparse,\n+\t\t\tSize:     1000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tFormat:   FormatGNU,\n+\t\t}},\n \t}, {\n-\t\trealSize: 35,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: 5},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\terr:        io.ErrUnexpectedEOF,\n+\t\t// Generated by Go, works on BSD tar v3.1.2 and GNU tar v.1.27.1.\n+\t\tfile: \"testdata/gnu-nil-sparse-hole.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"sparse.db\",\n+\t\t\tTypeflag: TypeGNUSparse,\n+\t\t\tSize:     1000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tFormat:   FormatGNU,\n+\t\t}},\n \t}, {\n-\t\trealSize: 35,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: -5},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\terr:        ErrHeader,\n+\t\t// Generated by Go, works on BSD tar v3.1.2 and GNU tar v.1.27.1.\n+\t\tfile: \"testdata/pax-nil-sparse-data.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"sparse.db\",\n+\t\t\tTypeflag: TypeReg,\n+\t\t\tSize:     1000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"size\":                \"1512\",\n+\t\t\t\t\"GNU.sparse.major\":    \"1\",\n+\t\t\t\t\"GNU.sparse.minor\":    \"0\",\n+\t\t\t\t\"GNU.sparse.realsize\": \"1000\",\n+\t\t\t\t\"GNU.sparse.name\":     \"sparse.db\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n+\t\t}},\n \t}, {\n-\t\trealSize: 35,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: math.MaxInt64, numBytes: 3},\n-\t\t\t{offset: 6, numBytes: -5},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\terr:        ErrHeader,\n+\t\t// Generated by Go, works on BSD tar v3.1.2 and GNU tar v.1.27.1.\n+\t\tfile: \"testdata/pax-nil-sparse-hole.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tName:     \"sparse.db\",\n+\t\t\tTypeflag: TypeReg,\n+\t\t\tSize:     1000,\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"size\":                \"512\",\n+\t\t\t\t\"GNU.sparse.major\":    \"1\",\n+\t\t\t\t\"GNU.sparse.minor\":    \"0\",\n+\t\t\t\t\"GNU.sparse.realsize\": \"1000\",\n+\t\t\t\t\"GNU.sparse.name\":     \"sparse.db\",\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n+\t\t}},\n \t}, {\n-\t\trealSize: 10,\n-\t\tsparseMap: []sparseEntry{\n-\t\t\t{offset: 1, numBytes: 3},\n-\t\t\t{offset: 2, numBytes: 2},\n-\t\t},\n-\t\tsparseData: \"abcde\",\n-\t\terr:        ErrHeader,\n+\t\tfile: \"testdata/trailing-slash.tar\",\n+\t\theaders: []*Header{{\n+\t\t\tTypeflag: TypeDir,\n+\t\t\tName:     strings.Repeat(\"123456789/\", 30),\n+\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"path\": strings.Repeat(\"123456789/\", 30),\n+\t\t\t},\n+\t\t\tFormat: FormatPAX,\n+\t\t}},\n \t}}\n \n-\tfor i, v := range vectors {\n-\t\tr := bytes.NewReader([]byte(v.sparseData))\n-\t\trfr := &regFileReader{r: r, nb: int64(len(v.sparseData))}\n-\n-\t\tvar (\n-\t\t\tsfr *sparseFileReader\n-\t\t\terr error\n-\t\t\tbuf []byte\n-\t\t)\n-\n-\t\tsfr, err = newSparseFileReader(rfr, v.sparseMap, v.realSize)\n-\t\tif err != nil {\n-\t\t\tgoto fail\n-\t\t}\n-\t\tif sfr.numBytes() != int64(len(v.sparseData)) {\n-\t\t\tt.Errorf(\"test %d, numBytes() before reading: got %d, want %d\", i, sfr.numBytes(), len(v.sparseData))\n-\t\t}\n-\t\tbuf, err = ioutil.ReadAll(sfr)\n-\t\tif err != nil {\n-\t\t\tgoto fail\n-\t\t}\n-\t\tif string(buf) != v.expected {\n-\t\t\tt.Errorf(\"test %d, ReadAll(): got %q, want %q\", i, string(buf), v.expected)\n-\t\t}\n-\t\tif sfr.numBytes() != 0 {\n-\t\t\tt.Errorf(\"test %d, numBytes() after reading: got %d, want %d\", i, sfr.numBytes(), 0)\n-\t\t}\n+\tfor _, v := range vectors {\n+\t\tt.Run(path.Base(v.file), func(t *testing.T) {\n+\t\t\tf, err := os.Open(v.file)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t\t\t}\n+\t\t\tdefer f.Close()\n \n-\tfail:\n-\t\tif err != v.err {\n-\t\t\tt.Errorf(\"test %d, unexpected error: got %v, want %v\", i, err, v.err)\n-\t\t}\n-\t}\n-}\n+\t\t\t// Capture all headers and checksums.\n+\t\t\tvar (\n+\t\t\t\ttr      = NewReader(f)\n+\t\t\t\thdrs    []*Header\n+\t\t\t\tchksums []string\n+\t\t\t\trdbuf   = make([]byte, 8)\n+\t\t\t)\n+\t\t\tfor {\n+\t\t\t\tvar hdr *Header\n+\t\t\t\thdr, err = tr.Next()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif err == io.EOF {\n+\t\t\t\t\t\terr = nil // Expected error\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\thdrs = append(hdrs, hdr)\n \n-func TestReadOldGNUSparseMap(t *testing.T) {\n-\tconst (\n-\t\tt00 = \"00000000000\\x0000000000000\\x00\"\n-\t\tt11 = \"00000000001\\x0000000000001\\x00\"\n-\t\tt12 = \"00000000001\\x0000000000002\\x00\"\n-\t\tt21 = \"00000000002\\x0000000000001\\x00\"\n-\t)\n+\t\t\t\tif v.chksums == nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\th := md5.New()\n+\t\t\t\t_, err = io.CopyBuffer(h, tr, rdbuf) // Effectively an incremental read\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tchksums = append(chksums, fmt.Sprintf(\"%x\", h.Sum(nil)))\n+\t\t\t}\n \n-\tmkBlk := func(size, sp0, sp1, sp2, sp3, ext string, format int) *block {\n-\t\tvar blk block\n-\t\tcopy(blk.GNU().RealSize(), size)\n-\t\tcopy(blk.GNU().Sparse().Entry(0), sp0)\n-\t\tcopy(blk.GNU().Sparse().Entry(1), sp1)\n-\t\tcopy(blk.GNU().Sparse().Entry(2), sp2)\n-\t\tcopy(blk.GNU().Sparse().Entry(3), sp3)\n-\t\tcopy(blk.GNU().Sparse().IsExtended(), ext)\n-\t\tif format != formatUnknown {\n-\t\t\tblk.SetFormat(format)\n-\t\t}\n-\t\treturn &blk\n-\t}\n+\t\t\tfor i, hdr := range hdrs {\n+\t\t\t\tif i >= len(v.headers) {\n+\t\t\t\t\tt.Fatalf(\"entry %d: unexpected header:\\ngot %+v\", i, *hdr)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif !reflect.DeepEqual(*hdr, *v.headers[i]) {\n+\t\t\t\t\tt.Fatalf(\"entry %d: incorrect header:\\ngot  %+v\\nwant %+v\", i, *hdr, *v.headers[i])\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif len(hdrs) != len(v.headers) {\n+\t\t\t\tt.Fatalf(\"got %d headers, want %d headers\", len(hdrs), len(v.headers))\n+\t\t\t}\n \n-\tvectors := []struct {\n-\t\tdata   string        // Input data\n-\t\trawHdr *block        // Input raw header\n-\t\twant   []sparseEntry // Expected sparse entries to be outputted\n-\t\terr    error         // Expected error to be returned\n-\t}{\n-\t\t{\"\", mkBlk(\"\", \"\", \"\", \"\", \"\", \"\", formatUnknown), nil, ErrHeader},\n-\t\t{\"\", mkBlk(\"1234\", \"fewa\", \"\", \"\", \"\", \"\", formatGNU), nil, ErrHeader},\n-\t\t{\"\", mkBlk(\"0031\", \"\", \"\", \"\", \"\", \"\", formatGNU), nil, nil},\n-\t\t{\"\", mkBlk(\"1234\", t00, t11, \"\", \"\", \"\", formatGNU),\n-\t\t\t[]sparseEntry{{0, 0}, {1, 1}}, nil},\n-\t\t{\"\", mkBlk(\"1234\", t11, t12, t21, t11, \"\", formatGNU),\n-\t\t\t[]sparseEntry{{1, 1}, {1, 2}, {2, 1}, {1, 1}}, nil},\n-\t\t{\"\", mkBlk(\"1234\", t11, t12, t21, t11, \"\\x80\", formatGNU),\n-\t\t\t[]sparseEntry{}, io.ErrUnexpectedEOF},\n-\t\t{t11 + t11,\n-\t\t\tmkBlk(\"1234\", t11, t12, t21, t11, \"\\x80\", formatGNU),\n-\t\t\t[]sparseEntry{}, io.ErrUnexpectedEOF},\n-\t\t{t11 + t21 + strings.Repeat(\"\\x00\", 512),\n-\t\t\tmkBlk(\"1234\", t11, t12, t21, t11, \"\\x80\", formatGNU),\n-\t\t\t[]sparseEntry{{1, 1}, {1, 2}, {2, 1}, {1, 1}, {1, 1}, {2, 1}}, nil},\n-\t}\n+\t\t\tfor i, sum := range chksums {\n+\t\t\t\tif i >= len(v.chksums) {\n+\t\t\t\t\tt.Fatalf(\"entry %d: unexpected sum: got %s\", i, sum)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif sum != v.chksums[i] {\n+\t\t\t\t\tt.Fatalf(\"entry %d: incorrect checksum: got %s, want %s\", i, sum, v.chksums[i])\n+\t\t\t\t}\n+\t\t\t}\n \n-\tfor i, v := range vectors {\n-\t\ttr := Reader{r: strings.NewReader(v.data)}\n-\t\thdr := new(Header)\n-\t\tgot, err := tr.readOldGNUSparseMap(hdr, v.rawHdr)\n-\t\tif !reflect.DeepEqual(got, v.want) && !(len(got) == 0 && len(v.want) == 0) {\n-\t\t\tt.Errorf(\"test %d, readOldGNUSparseMap(...): got %v, want %v\", i, got, v.want)\n-\t\t}\n-\t\tif err != v.err {\n-\t\t\tt.Errorf(\"test %d, unexpected error: got %v, want %v\", i, err, v.err)\n-\t\t}\n+\t\t\tif err != v.err {\n+\t\t\t\tt.Fatalf(\"unexpected error: got %v, want %v\", err, v.err)\n+\t\t\t}\n+\t\t\tf.Close()\n+\t\t})\n \t}\n }\n \n-func TestReadGNUSparseMap0x1(t *testing.T) {\n-\tconst (\n-\t\tmaxUint = ^uint(0)\n-\t\tmaxInt  = int(maxUint >> 1)\n-\t)\n-\tvar (\n-\t\tbig1 = fmt.Sprintf(\"%d\", int64(maxInt))\n-\t\tbig2 = fmt.Sprintf(\"%d\", (int64(maxInt)/2)+1)\n-\t\tbig3 = fmt.Sprintf(\"%d\", (int64(maxInt) / 3))\n-\t)\n-\n+func TestPartialRead(t *testing.T) {\n+\ttype testCase struct {\n+\t\tcnt    int    // Number of bytes to read\n+\t\toutput string // Expected value of string read\n+\t}\n \tvectors := []struct {\n-\t\textHdrs   map[string]string // Input data\n-\t\tsparseMap []sparseEntry     // Expected sparse entries to be outputted\n-\t\terr       error             // Expected errors that may be raised\n+\t\tfile  string\n+\t\tcases []testCase\n \t}{{\n-\t\textHdrs: map[string]string{paxGNUSparseNumBlocks: \"-4\"},\n-\t\terr:     ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{paxGNUSparseNumBlocks: \"fee \"},\n-\t\terr:     ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: big1,\n-\t\t\tpaxGNUSparseMap:       \"0,5,10,5,20,5,30,5\",\n-\t\t},\n-\t\terr: ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: big2,\n-\t\t\tpaxGNUSparseMap:       \"0,5,10,5,20,5,30,5\",\n-\t\t},\n-\t\terr: ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: big3,\n-\t\t\tpaxGNUSparseMap:       \"0,5,10,5,20,5,30,5\",\n-\t\t},\n-\t\terr: ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: \"4\",\n-\t\t\tpaxGNUSparseMap:       \"0.5,5,10,5,20,5,30,5\",\n-\t\t},\n-\t\terr: ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: \"4\",\n-\t\t\tpaxGNUSparseMap:       \"0,5.5,10,5,20,5,30,5\",\n-\t\t},\n-\t\terr: ErrHeader,\n-\t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: \"4\",\n-\t\t\tpaxGNUSparseMap:       \"0,fewafewa.5,fewafw,5,20,5,30,5\",\n+\t\tfile: \"testdata/gnu.tar\",\n+\t\tcases: []testCase{\n+\t\t\t{4, \"Kilt\"},\n+\t\t\t{6, \"Google\"},\n \t\t},\n-\t\terr: ErrHeader,\n \t}, {\n-\t\textHdrs: map[string]string{\n-\t\t\tpaxGNUSparseNumBlocks: \"4\",\n-\t\t\tpaxGNUSparseMap:       \"0,5,10,5,20,5,30,5\",\n+\t\tfile: \"testdata/sparse-formats.tar\",\n+\t\tcases: []testCase{\n+\t\t\t{2, \"\\x00G\"},\n+\t\t\t{4, \"\\x00G\\x00o\"},\n+\t\t\t{6, \"\\x00G\\x00o\\x00G\"},\n+\t\t\t{8, \"\\x00G\\x00o\\x00G\\x00o\"},\n+\t\t\t{4, \"end\\n\"},\n \t\t},\n-\t\tsparseMap: []sparseEntry{{0, 5}, {10, 5}, {20, 5}, {30, 5}},\n \t}}\n \n-\tfor i, v := range vectors {\n-\t\tsp, err := readGNUSparseMap0x1(v.extHdrs)\n-\t\tif !reflect.DeepEqual(sp, v.sparseMap) && !(len(sp) == 0 && len(v.sparseMap) == 0) {\n-\t\t\tt.Errorf(\"test %d, readGNUSparseMap0x1(...): got %v, want %v\", i, sp, v.sparseMap)\n-\t\t}\n-\t\tif err != v.err {\n-\t\t\tt.Errorf(\"test %d, unexpected error: got %v, want %v\", i, err, v.err)\n-\t\t}\n-\t}\n-}\n-\n-func TestReadGNUSparseMap1x0(t *testing.T) {\n-\tsp := []sparseEntry{{1, 2}, {3, 4}}\n-\tfor i := 0; i < 98; i++ {\n-\t\tsp = append(sp, sparseEntry{54321, 12345})\n-\t}\n+\tfor _, v := range vectors {\n+\t\tt.Run(path.Base(v.file), func(t *testing.T) {\n+\t\t\tf, err := os.Open(v.file)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"Open() error: %v\", err)\n+\t\t\t}\n+\t\t\tdefer f.Close()\n \n-\tvectors := []struct {\n-\t\tinput     string        // Input data\n-\t\tsparseMap []sparseEntry // Expected sparse entries to be outputted\n-\t\tcnt       int           // Expected number of bytes read\n-\t\terr       error         // Expected errors that may be raised\n-\t}{{\n-\t\tinput: \"\",\n-\t\tcnt:   0,\n-\t\terr:   io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tinput: \"ab\",\n-\t\tcnt:   2,\n-\t\terr:   io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tinput: strings.Repeat(\"\\x00\", 512),\n-\t\tcnt:   512,\n-\t\terr:   io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tinput: strings.Repeat(\"\\x00\", 511) + \"\\n\",\n-\t\tcnt:   512,\n-\t\terr:   ErrHeader,\n-\t}, {\n-\t\tinput: strings.Repeat(\"\\n\", 512),\n-\t\tcnt:   512,\n-\t\terr:   ErrHeader,\n-\t}, {\n-\t\tinput:     \"0\\n\" + strings.Repeat(\"\\x00\", 510) + strings.Repeat(\"a\", 512),\n-\t\tsparseMap: []sparseEntry{},\n-\t\tcnt:       512,\n-\t}, {\n-\t\tinput:     strings.Repeat(\"0\", 512) + \"0\\n\" + strings.Repeat(\"\\x00\", 510),\n-\t\tsparseMap: []sparseEntry{},\n-\t\tcnt:       1024,\n-\t}, {\n-\t\tinput:     strings.Repeat(\"0\", 1024) + \"1\\n2\\n3\\n\" + strings.Repeat(\"\\x00\", 506),\n-\t\tsparseMap: []sparseEntry{{2, 3}},\n-\t\tcnt:       1536,\n-\t}, {\n-\t\tinput: strings.Repeat(\"0\", 1024) + \"1\\n2\\n\\n\" + strings.Repeat(\"\\x00\", 509),\n-\t\tcnt:   1536,\n-\t\terr:   ErrHeader,\n-\t}, {\n-\t\tinput: strings.Repeat(\"0\", 1024) + \"1\\n2\\n\" + strings.Repeat(\"\\x00\", 508),\n-\t\tcnt:   1536,\n-\t\terr:   io.ErrUnexpectedEOF,\n-\t}, {\n-\t\tinput: \"-1\\n2\\n\\n\" + strings.Repeat(\"\\x00\", 506),\n-\t\tcnt:   512,\n-\t\terr:   ErrHeader,\n-\t}, {\n-\t\tinput: \"1\\nk\\n2\\n\" + strings.Repeat(\"\\x00\", 506),\n-\t\tcnt:   512,\n-\t\terr:   ErrHeader,\n-\t}, {\n-\t\tinput:     \"100\\n1\\n2\\n3\\n4\\n\" + strings.Repeat(\"54321\\n0000000000000012345\\n\", 98) + strings.Repeat(\"\\x00\", 512),\n-\t\tcnt:       2560,\n-\t\tsparseMap: sp,\n-\t}}\n+\t\t\ttr := NewReader(f)\n+\t\t\tfor i, tc := range v.cases {\n+\t\t\t\thdr, err := tr.Next()\n+\t\t\t\tif err != nil || hdr == nil {\n+\t\t\t\t\tt.Fatalf(\"entry %d, Next(): got %v, want %v\", i, err, nil)\n+\t\t\t\t}\n+\t\t\t\tbuf := make([]byte, tc.cnt)\n+\t\t\t\tif _, err := io.ReadFull(tr, buf); err != nil {\n+\t\t\t\t\tt.Fatalf(\"entry %d, ReadFull(): got %v, want %v\", i, err, nil)\n+\t\t\t\t}\n+\t\t\t\tif string(buf) != tc.output {\n+\t\t\t\t\tt.Fatalf(\"entry %d, ReadFull(): got %q, want %q\", i, string(buf), tc.output)\n+\t\t\t\t}\n+\t\t\t}\n \n-\tfor i, v := range vectors {\n-\t\tr := strings.NewReader(v.input)\n-\t\tsp, err := readGNUSparseMap1x0(r)\n-\t\tif !reflect.DeepEqual(sp, v.sparseMap) && !(len(sp) == 0 && len(v.sparseMap) == 0) {\n-\t\t\tt.Errorf(\"test %d, readGNUSparseMap1x0(...): got %v, want %v\", i, sp, v.sparseMap)\n-\t\t}\n-\t\tif numBytes := len(v.input) - r.Len(); numBytes != v.cnt {\n-\t\t\tt.Errorf(\"test %d, bytes read: got %v, want %v\", i, numBytes, v.cnt)\n-\t\t}\n-\t\tif err != v.err {\n-\t\t\tt.Errorf(\"test %d, unexpected error: got %v, want %v\", i, err, v.err)\n-\t\t}\n+\t\t\tif _, err := tr.Next(); err != io.EOF {\n+\t\t\t\tt.Fatalf(\"Next(): got %v, want EOF\", err)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -950,17 +864,17 @@ func TestReadTruncation(t *testing.T) {\n \t\t\t\t}\n \t\t\t\tcnt++\n \t\t\t\tif s2 == \"manual\" {\n-\t\t\t\t\tif _, err = io.Copy(ioutil.Discard, tr); err != nil {\n+\t\t\t\t\tif _, err = tr.writeTo(ioutil.Discard); err != nil {\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif err != v.err {\n-\t\t\t\tt.Errorf(\"test %d, NewReader(%s(...)) with %s discard: got %v, want %v\",\n+\t\t\t\tt.Errorf(\"test %d, NewReader(%s) with %s discard: got %v, want %v\",\n \t\t\t\t\ti, s1, s2, err, v.err)\n \t\t\t}\n \t\t\tif cnt != v.cnt {\n-\t\t\t\tt.Errorf(\"test %d, NewReader(%s(...)) with %s discard: got %d headers, want %d headers\",\n+\t\t\t\tt.Errorf(\"test %d, NewReader(%s) with %s discard: got %d headers, want %d headers\",\n \t\t\t\t\ti, s1, s2, cnt, v.cnt)\n \t\t\t}\n \t\t}\n@@ -1025,19 +939,29 @@ func TestMergePAX(t *testing.T) {\n \t\t\tName:    \"a/b/c\",\n \t\t\tUid:     1000,\n \t\t\tModTime: time.Unix(1350244992, 23960108),\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"path\":  \"a/b/c\",\n+\t\t\t\t\"uid\":   \"1000\",\n+\t\t\t\t\"mtime\": \"1350244992.023960108\",\n+\t\t\t},\n \t\t},\n \t\tok: true,\n \t}, {\n \t\tin: map[string]string{\n \t\t\t\"gid\": \"gtgergergersagersgers\",\n \t\t},\n+\t\tok: false,\n \t}, {\n \t\tin: map[string]string{\n \t\t\t\"missing\":          \"missing\",\n \t\t\t\"SCHILY.xattr.key\": \"value\",\n \t\t},\n \t\twant: &Header{\n \t\t\tXattrs: map[string]string{\"key\": \"value\"},\n+\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\"missing\":          \"missing\",\n+\t\t\t\t\"SCHILY.xattr.key\": \"value\",\n+\t\t\t},\n \t\t},\n \t\tok: true,\n \t}}\n@@ -1070,7 +994,7 @@ func TestParsePAX(t *testing.T) {\n \t\t{\"13 key1=haha\\n13 key2=nana\\n13 key3=kaka\\n\",\n \t\t\tmap[string]string{\"key1\": \"haha\", \"key2\": \"nana\", \"key3\": \"kaka\"}, true},\n \t\t{\"13 key1=val1\\n13 key2=val2\\n8 key1=\\n\",\n-\t\t\tmap[string]string{\"key2\": \"val2\"}, true},\n+\t\t\tmap[string]string{\"key1\": \"\", \"key2\": \"val2\"}, true},\n \t\t{\"22 GNU.sparse.size=10\\n26 GNU.sparse.numblocks=2\\n\" +\n \t\t\t\"23 GNU.sparse.offset=1\\n25 GNU.sparse.numbytes=2\\n\" +\n \t\t\t\"23 GNU.sparse.offset=3\\n25 GNU.sparse.numbytes=4\\n\",\n@@ -1087,10 +1011,600 @@ func TestParsePAX(t *testing.T) {\n \t\tr := strings.NewReader(v.in)\n \t\tgot, err := parsePAX(r)\n \t\tif !reflect.DeepEqual(got, v.want) && !(len(got) == 0 && len(v.want) == 0) {\n-\t\t\tt.Errorf(\"test %d, parsePAX(...):\\ngot  %v\\nwant %v\", i, got, v.want)\n+\t\t\tt.Errorf(\"test %d, parsePAX():\\ngot  %v\\nwant %v\", i, got, v.want)\n \t\t}\n \t\tif ok := err == nil; ok != v.ok {\n-\t\t\tt.Errorf(\"test %d, parsePAX(...): got %v, want %v\", i, ok, v.ok)\n+\t\t\tt.Errorf(\"test %d, parsePAX(): got %v, want %v\", i, ok, v.ok)\n+\t\t}\n+\t}\n+}\n+\n+func TestReadOldGNUSparseMap(t *testing.T) {\n+\tpopulateSparseMap := func(sa sparseArray, sps []string) []string {\n+\t\tfor i := 0; len(sps) > 0 && i < sa.MaxEntries(); i++ {\n+\t\t\tcopy(sa.Entry(i), sps[0])\n+\t\t\tsps = sps[1:]\n+\t\t}\n+\t\tif len(sps) > 0 {\n+\t\t\tcopy(sa.IsExtended(), \"\\x80\")\n+\t\t}\n+\t\treturn sps\n+\t}\n+\n+\tmakeInput := func(format Format, size string, sps ...string) (out []byte) {\n+\t\t// Write the initial GNU header.\n+\t\tvar blk block\n+\t\tgnu := blk.GNU()\n+\t\tsparse := gnu.Sparse()\n+\t\tcopy(gnu.RealSize(), size)\n+\t\tsps = populateSparseMap(sparse, sps)\n+\t\tif format != FormatUnknown {\n+\t\t\tblk.SetFormat(format)\n+\t\t}\n+\t\tout = append(out, blk[:]...)\n+\n+\t\t// Write extended sparse blocks.\n+\t\tfor len(sps) > 0 {\n+\t\t\tvar blk block\n+\t\t\tsps = populateSparseMap(blk.Sparse(), sps)\n+\t\t\tout = append(out, blk[:]...)\n+\t\t}\n+\t\treturn out\n+\t}\n+\n+\tmakeSparseStrings := func(sp []sparseEntry) (out []string) {\n+\t\tvar f formatter\n+\t\tfor _, s := range sp {\n+\t\t\tvar b [24]byte\n+\t\t\tf.formatNumeric(b[:12], s.Offset)\n+\t\t\tf.formatNumeric(b[12:], s.Length)\n+\t\t\tout = append(out, string(b[:]))\n+\t\t}\n+\t\treturn out\n+\t}\n+\n+\tvectors := []struct {\n+\t\tinput    []byte\n+\t\twantMap  sparseDatas\n+\t\twantSize int64\n+\t\twantErr  error\n+\t}{{\n+\t\tinput:   makeInput(FormatUnknown, \"\"),\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinput:    makeInput(FormatGNU, \"1234\", \"fewa\"),\n+\t\twantSize: 01234,\n+\t\twantErr:  ErrHeader,\n+\t}, {\n+\t\tinput:    makeInput(FormatGNU, \"0031\"),\n+\t\twantSize: 031,\n+\t}, {\n+\t\tinput:   makeInput(FormatGNU, \"80\"),\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"1234\",\n+\t\t\tmakeSparseStrings(sparseDatas{{0, 0}, {1, 1}})...),\n+\t\twantMap:  sparseDatas{{0, 0}, {1, 1}},\n+\t\twantSize: 01234,\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"1234\",\n+\t\t\tappend(makeSparseStrings(sparseDatas{{0, 0}, {1, 1}}), []string{\"\", \"blah\"}...)...),\n+\t\twantMap:  sparseDatas{{0, 0}, {1, 1}},\n+\t\twantSize: 01234,\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"3333\",\n+\t\t\tmakeSparseStrings(sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}})...),\n+\t\twantMap:  sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}},\n+\t\twantSize: 03333,\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"\",\n+\t\t\tappend(append(\n+\t\t\t\tmakeSparseStrings(sparseDatas{{0, 1}, {2, 1}}),\n+\t\t\t\t[]string{\"\", \"\"}...),\n+\t\t\t\tmakeSparseStrings(sparseDatas{{4, 1}, {6, 1}})...)...),\n+\t\twantMap: sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}},\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"\",\n+\t\t\tmakeSparseStrings(sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}, {8, 1}, {10, 1}})...)[:blockSize],\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"\",\n+\t\t\tmakeSparseStrings(sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}, {8, 1}, {10, 1}})...)[:3*blockSize/2],\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"\",\n+\t\t\tmakeSparseStrings(sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}, {8, 1}, {10, 1}})...),\n+\t\twantMap: sparseDatas{{0, 1}, {2, 1}, {4, 1}, {6, 1}, {8, 1}, {10, 1}},\n+\t}, {\n+\t\tinput: makeInput(FormatGNU, \"\",\n+\t\t\tmakeSparseStrings(sparseDatas{{10 << 30, 512}, {20 << 30, 512}})...),\n+\t\twantMap: sparseDatas{{10 << 30, 512}, {20 << 30, 512}},\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\tvar blk block\n+\t\tvar hdr Header\n+\t\tv.input = v.input[copy(blk[:], v.input):]\n+\t\ttr := Reader{r: bytes.NewReader(v.input)}\n+\t\tgot, err := tr.readOldGNUSparseMap(&hdr, &blk)\n+\t\tif !equalSparseEntries(got, v.wantMap) {\n+\t\t\tt.Errorf(\"test %d, readOldGNUSparseMap(): got %v, want %v\", i, got, v.wantMap)\n+\t\t}\n+\t\tif err != v.wantErr {\n+\t\t\tt.Errorf(\"test %d, readOldGNUSparseMap() = %v, want %v\", i, err, v.wantErr)\n+\t\t}\n+\t\tif hdr.Size != v.wantSize {\n+\t\t\tt.Errorf(\"test %d, Header.Size = %d, want %d\", i, hdr.Size, v.wantSize)\n+\t\t}\n+\t}\n+}\n+\n+func TestReadGNUSparsePAXHeaders(t *testing.T) {\n+\tpadInput := func(s string) string {\n+\t\treturn s + string(zeroBlock[:blockPadding(int64(len(s)))])\n+\t}\n+\n+\tvectors := []struct {\n+\t\tinputData string\n+\t\tinputHdrs map[string]string\n+\t\twantMap   sparseDatas\n+\t\twantSize  int64\n+\t\twantName  string\n+\t\twantErr   error\n+\t}{{\n+\t\tinputHdrs: nil,\n+\t\twantErr:   nil,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: strconv.FormatInt(math.MaxInt64, 10),\n+\t\t\tpaxGNUSparseMap:       \"0,1,2,3\",\n+\t\t},\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: \"4\\x00\",\n+\t\t\tpaxGNUSparseMap:       \"0,1,2,3\",\n+\t\t},\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: \"4\",\n+\t\t\tpaxGNUSparseMap:       \"0,1,2,3\",\n+\t\t},\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: \"2\",\n+\t\t\tpaxGNUSparseMap:       \"0,1,2,3\",\n+\t\t},\n+\t\twantMap: sparseDatas{{0, 1}, {2, 3}},\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: \"2\",\n+\t\t\tpaxGNUSparseMap:       \"0, 1,2,3\",\n+\t\t},\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: \"2\",\n+\t\t\tpaxGNUSparseMap:       \"0,1,02,3\",\n+\t\t\tpaxGNUSparseRealSize:  \"4321\",\n+\t\t},\n+\t\twantMap:  sparseDatas{{0, 1}, {2, 3}},\n+\t\twantSize: 4321,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseNumBlocks: \"2\",\n+\t\t\tpaxGNUSparseMap:       \"0,one1,2,3\",\n+\t\t},\n+\t\twantErr: ErrHeader,\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseMajor:     \"0\",\n+\t\t\tpaxGNUSparseMinor:     \"0\",\n+\t\t\tpaxGNUSparseNumBlocks: \"2\",\n+\t\t\tpaxGNUSparseMap:       \"0,1,2,3\",\n+\t\t\tpaxGNUSparseSize:      \"1234\",\n+\t\t\tpaxGNUSparseRealSize:  \"4321\",\n+\t\t\tpaxGNUSparseName:      \"realname\",\n+\t\t},\n+\t\twantMap:  sparseDatas{{0, 1}, {2, 3}},\n+\t\twantSize: 1234,\n+\t\twantName: \"realname\",\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseMajor:     \"0\",\n+\t\t\tpaxGNUSparseMinor:     \"0\",\n+\t\t\tpaxGNUSparseNumBlocks: \"1\",\n+\t\t\tpaxGNUSparseMap:       \"10737418240,512\",\n+\t\t\tpaxGNUSparseSize:      \"10737418240\",\n+\t\t\tpaxGNUSparseName:      \"realname\",\n+\t\t},\n+\t\twantMap:  sparseDatas{{10737418240, 512}},\n+\t\twantSize: 10737418240,\n+\t\twantName: \"realname\",\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseMajor:     \"0\",\n+\t\t\tpaxGNUSparseMinor:     \"0\",\n+\t\t\tpaxGNUSparseNumBlocks: \"0\",\n+\t\t\tpaxGNUSparseMap:       \"\",\n+\t\t},\n+\t\twantMap: sparseDatas{},\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseMajor:     \"0\",\n+\t\t\tpaxGNUSparseMinor:     \"1\",\n+\t\t\tpaxGNUSparseNumBlocks: \"4\",\n+\t\t\tpaxGNUSparseMap:       \"0,5,10,5,20,5,30,5\",\n+\t\t},\n+\t\twantMap: sparseDatas{{0, 5}, {10, 5}, {20, 5}, {30, 5}},\n+\t}, {\n+\t\tinputHdrs: map[string]string{\n+\t\t\tpaxGNUSparseMajor:     \"1\",\n+\t\t\tpaxGNUSparseMinor:     \"0\",\n+\t\t\tpaxGNUSparseNumBlocks: \"4\",\n+\t\t\tpaxGNUSparseMap:       \"0,5,10,5,20,5,30,5\",\n+\t\t},\n+\t\twantErr: io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tinputData: padInput(\"0\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap:   sparseDatas{},\n+\t}, {\n+\t\tinputData: padInput(\"0\\n\")[:blockSize-1] + \"#\",\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap:   sparseDatas{},\n+\t}, {\n+\t\tinputData: padInput(\"0\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantErr:   io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tinputData: padInput(\"ab\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantErr:   ErrHeader,\n+\t}, {\n+\t\tinputData: padInput(\"1\\n2\\n3\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap:   sparseDatas{{2, 3}},\n+\t}, {\n+\t\tinputData: padInput(\"1\\n2\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantErr:   io.ErrUnexpectedEOF,\n+\t}, {\n+\t\tinputData: padInput(\"1\\n2\\n\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantErr:   ErrHeader,\n+\t}, {\n+\t\tinputData: string(zeroBlock[:]) + padInput(\"0\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantErr:   ErrHeader,\n+\t}, {\n+\t\tinputData: strings.Repeat(\"0\", blockSize) + padInput(\"1\\n5\\n1\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap:   sparseDatas{{5, 1}},\n+\t}, {\n+\t\tinputData: padInput(fmt.Sprintf(\"%d\\n\", int64(math.MaxInt64))),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantErr:   ErrHeader,\n+\t}, {\n+\t\tinputData: padInput(strings.Repeat(\"0\", 300) + \"1\\n\" + strings.Repeat(\"0\", 1000) + \"5\\n\" + strings.Repeat(\"0\", 800) + \"2\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap:   sparseDatas{{5, 2}},\n+\t}, {\n+\t\tinputData: padInput(\"2\\n10737418240\\n512\\n21474836480\\n512\\n\"),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap:   sparseDatas{{10737418240, 512}, {21474836480, 512}},\n+\t}, {\n+\t\tinputData: padInput(\"100\\n\" + func() string {\n+\t\t\tvar ss []string\n+\t\t\tfor i := 0; i < 100; i++ {\n+\t\t\t\tss = append(ss, fmt.Sprintf(\"%d\\n%d\\n\", int64(i)<<30, 512))\n+\t\t\t}\n+\t\t\treturn strings.Join(ss, \"\")\n+\t\t}()),\n+\t\tinputHdrs: map[string]string{paxGNUSparseMajor: \"1\", paxGNUSparseMinor: \"0\"},\n+\t\twantMap: func() (spd sparseDatas) {\n+\t\t\tfor i := 0; i < 100; i++ {\n+\t\t\t\tspd = append(spd, sparseEntry{int64(i) << 30, 512})\n+\t\t\t}\n+\t\t\treturn spd\n+\t\t}(),\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\tvar hdr Header\n+\t\thdr.PAXRecords = v.inputHdrs\n+\t\tr := strings.NewReader(v.inputData + \"#\") // Add canary byte\n+\t\ttr := Reader{curr: &regFileReader{r, int64(r.Len())}}\n+\t\tgot, err := tr.readGNUSparsePAXHeaders(&hdr)\n+\t\tif !equalSparseEntries(got, v.wantMap) {\n+\t\t\tt.Errorf(\"test %d, readGNUSparsePAXHeaders(): got %v, want %v\", i, got, v.wantMap)\n+\t\t}\n+\t\tif err != v.wantErr {\n+\t\t\tt.Errorf(\"test %d, readGNUSparsePAXHeaders() = %v, want %v\", i, err, v.wantErr)\n+\t\t}\n+\t\tif hdr.Size != v.wantSize {\n+\t\t\tt.Errorf(\"test %d, Header.Size = %d, want %d\", i, hdr.Size, v.wantSize)\n+\t\t}\n+\t\tif hdr.Name != v.wantName {\n+\t\t\tt.Errorf(\"test %d, Header.Name = %s, want %s\", i, hdr.Name, v.wantName)\n+\t\t}\n+\t\tif v.wantErr == nil && r.Len() == 0 {\n+\t\t\tt.Errorf(\"test %d, canary byte unexpectedly consumed\", i)\n+\t\t}\n+\t}\n+}\n+\n+// testNonEmptyReader wraps an io.Reader and ensures that\n+// Read is never called with an empty buffer.\n+type testNonEmptyReader struct{ io.Reader }\n+\n+func (r testNonEmptyReader) Read(b []byte) (int, error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, errors.New(\"unexpected empty Read call\")\n+\t}\n+\treturn r.Reader.Read(b)\n+}\n+\n+func TestFileReader(t *testing.T) {\n+\ttype (\n+\t\ttestRead struct { // Read(cnt) == (wantStr, wantErr)\n+\t\t\tcnt     int\n+\t\t\twantStr string\n+\t\t\twantErr error\n+\t\t}\n+\t\ttestWriteTo struct { // WriteTo(testFile{ops}) == (wantCnt, wantErr)\n+\t\t\tops     fileOps\n+\t\t\twantCnt int64\n+\t\t\twantErr error\n+\t\t}\n+\t\ttestRemaining struct { // LogicalRemaining() == wantLCnt, PhysicalRemaining() == wantPCnt\n+\t\t\twantLCnt int64\n+\t\t\twantPCnt int64\n+\t\t}\n+\t\ttestFnc interface{} // testRead | testWriteTo | testRemaining\n+\t)\n+\n+\ttype (\n+\t\tmakeReg struct {\n+\t\t\tstr  string\n+\t\t\tsize int64\n+\t\t}\n+\t\tmakeSparse struct {\n+\t\t\tmakeReg makeReg\n+\t\t\tspd     sparseDatas\n+\t\t\tsize    int64\n+\t\t}\n+\t\tfileMaker interface{} // makeReg | makeSparse\n+\t)\n+\n+\tvectors := []struct {\n+\t\tmaker fileMaker\n+\t\ttests []testFnc\n+\t}{{\n+\t\tmaker: makeReg{\"\", 0},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{0, 0},\n+\t\t\ttestRead{0, \"\", io.EOF},\n+\t\t\ttestRead{1, \"\", io.EOF},\n+\t\t\ttestWriteTo{nil, 0, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{\"\", 1},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{1, 1},\n+\t\t\ttestRead{5, \"\", io.ErrUnexpectedEOF},\n+\t\t\ttestWriteTo{nil, 0, io.ErrUnexpectedEOF},\n+\t\t\ttestRemaining{1, 1},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{\"hello\", 5},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestRead{5, \"hello\", io.EOF},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{\"hello, world\", 50},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{50, 50},\n+\t\t\ttestRead{7, \"hello, \", nil},\n+\t\t\ttestRemaining{43, 43},\n+\t\t\ttestRead{5, \"world\", nil},\n+\t\t\ttestRemaining{38, 38},\n+\t\t\ttestWriteTo{nil, 0, io.ErrUnexpectedEOF},\n+\t\t\ttestRead{1, \"\", io.ErrUnexpectedEOF},\n+\t\t\ttestRemaining{38, 38},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{\"hello, world\", 5},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestRead{0, \"\", nil},\n+\t\t\ttestRead{4, \"hell\", nil},\n+\t\t\ttestRemaining{1, 1},\n+\t\t\ttestWriteTo{fileOps{\"o\"}, 1, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t\ttestWriteTo{nil, 0, nil},\n+\t\t\ttestRead{0, \"\", io.EOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{0, 2}, {5, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{8, 5},\n+\t\t\ttestRead{3, \"ab\\x00\", nil},\n+\t\t\ttestRead{10, \"\\x00\\x00cde\", io.EOF},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{0, 2}, {5, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{8, 5},\n+\t\t\ttestWriteTo{fileOps{\"ab\", int64(3), \"cde\"}, 8, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{0, 2}, {5, 3}}, 10},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{10, 5},\n+\t\t\ttestRead{100, \"ab\\x00\\x00\\x00cde\\x00\\x00\", io.EOF},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abc\", 5}, sparseDatas{{0, 2}, {5, 3}}, 10},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{10, 5},\n+\t\t\ttestRead{100, \"ab\\x00\\x00\\x00c\", io.ErrUnexpectedEOF},\n+\t\t\ttestRemaining{4, 2},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 2}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{8, 5},\n+\t\t\ttestRead{8, \"\\x00abc\\x00\\x00de\", io.EOF},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 0}, {6, 0}, {6, 2}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{8, 5},\n+\t\t\ttestRead{8, \"\\x00abc\\x00\\x00de\", io.EOF},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 0}, {6, 0}, {6, 2}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{8, 5},\n+\t\t\ttestWriteTo{fileOps{int64(1), \"abc\", int64(2), \"de\"}, 8, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 2}}, 10},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00de\\x00\\x00\", io.EOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 2}}, 10},\n+\t\ttests: []testFnc{\n+\t\t\ttestWriteTo{fileOps{int64(1), \"abc\", int64(2), \"de\", int64(1), \"\\x00\"}, 10, nil},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 2}, {8, 0}, {8, 0}, {8, 0}, {8, 0}}, 10},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00de\\x00\\x00\", io.EOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"\", 0}, sparseDatas{}, 2},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00\\x00\", io.EOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"\", 8}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00\", io.ErrUnexpectedEOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"ab\", 2}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00ab\", errMissData},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"ab\", 8}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00ab\", io.ErrUnexpectedEOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abc\", 3}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00\", errMissData},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abc\", 8}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00\", io.ErrUnexpectedEOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00de\", errMissData},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 5}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestWriteTo{fileOps{int64(1), \"abc\", int64(2), \"de\"}, 8, errMissData},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcde\", 8}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00de\", io.ErrUnexpectedEOF},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcdefghEXTRA\", 13}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{15, 13},\n+\t\t\ttestRead{100, \"\\x00abc\\x00\\x00defgh\\x00\\x00\\x00\\x00\", errUnrefData},\n+\t\t\ttestWriteTo{nil, 0, errUnrefData},\n+\t\t\ttestRemaining{0, 5},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{\"abcdefghEXTRA\", 13}, sparseDatas{{1, 3}, {6, 5}}, 15},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{15, 13},\n+\t\t\ttestWriteTo{fileOps{int64(1), \"abc\", int64(2), \"defgh\", int64(4)}, 15, errUnrefData},\n+\t\t\ttestRead{100, \"\", errUnrefData},\n+\t\t\ttestRemaining{0, 5},\n+\t\t},\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\tvar fr fileReader\n+\t\tswitch maker := v.maker.(type) {\n+\t\tcase makeReg:\n+\t\t\tr := testNonEmptyReader{strings.NewReader(maker.str)}\n+\t\t\tfr = &regFileReader{r, maker.size}\n+\t\tcase makeSparse:\n+\t\t\tif !validateSparseEntries(maker.spd, maker.size) {\n+\t\t\t\tt.Fatalf(\"invalid sparse map: %v\", maker.spd)\n+\t\t\t}\n+\t\t\tsph := invertSparseEntries(maker.spd, maker.size)\n+\t\t\tr := testNonEmptyReader{strings.NewReader(maker.makeReg.str)}\n+\t\t\tfr = &regFileReader{r, maker.makeReg.size}\n+\t\t\tfr = &sparseFileReader{fr, sph, 0}\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"test %d, unknown make operation: %T\", i, maker)\n+\t\t}\n+\n+\t\tfor j, tf := range v.tests {\n+\t\t\tswitch tf := tf.(type) {\n+\t\t\tcase testRead:\n+\t\t\t\tb := make([]byte, tf.cnt)\n+\t\t\t\tn, err := fr.Read(b)\n+\t\t\t\tif got := string(b[:n]); got != tf.wantStr || err != tf.wantErr {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, Read(%d):\\ngot  (%q, %v)\\nwant (%q, %v)\", i, j, tf.cnt, got, err, tf.wantStr, tf.wantErr)\n+\t\t\t\t}\n+\t\t\tcase testWriteTo:\n+\t\t\t\tf := &testFile{ops: tf.ops}\n+\t\t\t\tgot, err := fr.WriteTo(f)\n+\t\t\t\tif _, ok := err.(testError); ok {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, WriteTo(): %v\", i, j, err)\n+\t\t\t\t} else if got != tf.wantCnt || err != tf.wantErr {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, WriteTo() = (%d, %v), want (%d, %v)\", i, j, got, err, tf.wantCnt, tf.wantErr)\n+\t\t\t\t}\n+\t\t\t\tif len(f.ops) > 0 {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, expected %d more operations\", i, j, len(f.ops))\n+\t\t\t\t}\n+\t\t\tcase testRemaining:\n+\t\t\t\tif got := fr.LogicalRemaining(); got != tf.wantLCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, LogicalRemaining() = %d, want %d\", i, j, got, tf.wantLCnt)\n+\t\t\t\t}\n+\t\t\t\tif got := fr.PhysicalRemaining(); got != tf.wantPCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, PhysicalRemaining() = %d, want %d\", i, j, got, tf.wantPCnt)\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tt.Fatalf(\"test %d.%d, unknown test operation: %T\", i, j, tf)\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "cf9cc79c5915bace0af0e81fa4df961f3a68553c", "filename": "libgo/go/archive/tar/stat_actime1.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime1.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "previous_filename": "libgo/go/archive/tar/stat_atim.go"}, {"sha": "6f17dbe30725c120218885cc662587b8c7dcb4d2", "filename": "libgo/go/archive/tar/stat_actime2.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_actime2.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "previous_filename": "libgo/go/archive/tar/stat_atimespec.go"}, {"sha": "868105f338efdc109b77cda051c06247da28d56a", "filename": "libgo/go/archive/tar/stat_unix.go", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstat_unix.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -8,25 +8,89 @@ package tar\n \n import (\n \t\"os\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"strconv\"\n+\t\"sync\"\n \t\"syscall\"\n )\n \n func init() {\n \tsysStat = statUnix\n }\n \n+// userMap and groupMap caches UID and GID lookups for performance reasons.\n+// The downside is that renaming uname or gname by the OS never takes effect.\n+var userMap, groupMap sync.Map // map[int]string\n+\n func statUnix(fi os.FileInfo, h *Header) error {\n \tsys, ok := fi.Sys().(*syscall.Stat_t)\n \tif !ok {\n \t\treturn nil\n \t}\n \th.Uid = int(sys.Uid)\n \th.Gid = int(sys.Gid)\n-\t// TODO(bradfitz): populate username & group.  os/user\n-\t// doesn't cache LookupId lookups, and lacks group\n-\t// lookup functions.\n+\n+\t// Best effort at populating Uname and Gname.\n+\t// The os/user functions may fail for any number of reasons\n+\t// (not implemented on that platform, cgo not enabled, etc).\n+\tif u, ok := userMap.Load(h.Uid); ok {\n+\t\th.Uname = u.(string)\n+\t} else if u, err := user.LookupId(strconv.Itoa(h.Uid)); err == nil {\n+\t\th.Uname = u.Username\n+\t\tuserMap.Store(h.Uid, h.Uname)\n+\t}\n+\tif g, ok := groupMap.Load(h.Gid); ok {\n+\t\th.Gname = g.(string)\n+\t} else if g, err := user.LookupGroupId(strconv.Itoa(h.Gid)); err == nil {\n+\t\th.Gname = g.Name\n+\t\tgroupMap.Store(h.Gid, h.Gname)\n+\t}\n+\n \th.AccessTime = statAtime(sys)\n \th.ChangeTime = statCtime(sys)\n-\t// TODO(bradfitz): major/minor device numbers?\n+\n+\t// Best effort at populating Devmajor and Devminor.\n+\tif h.Typeflag == TypeChar || h.Typeflag == TypeBlock {\n+\t\tdev := uint64(sys.Rdev) // May be int32 or uint32\n+\t\tswitch runtime.GOOS {\n+\t\tcase \"linux\":\n+\t\t\t// Copied from golang.org/x/sys/unix/dev_linux.go.\n+\t\t\tmajor := uint32((dev & 0x00000000000fff00) >> 8)\n+\t\t\tmajor |= uint32((dev & 0xfffff00000000000) >> 32)\n+\t\t\tminor := uint32((dev & 0x00000000000000ff) >> 0)\n+\t\t\tminor |= uint32((dev & 0x00000ffffff00000) >> 12)\n+\t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n+\t\tcase \"darwin\":\n+\t\t\t// Copied from golang.org/x/sys/unix/dev_darwin.go.\n+\t\t\tmajor := uint32((dev >> 24) & 0xff)\n+\t\t\tminor := uint32(dev & 0xffffff)\n+\t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n+\t\tcase \"dragonfly\":\n+\t\t\t// Copied from golang.org/x/sys/unix/dev_dragonfly.go.\n+\t\t\tmajor := uint32((dev >> 8) & 0xff)\n+\t\t\tminor := uint32(dev & 0xffff00ff)\n+\t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n+\t\tcase \"freebsd\":\n+\t\t\t// Copied from golang.org/x/sys/unix/dev_freebsd.go.\n+\t\t\tmajor := uint32((dev >> 8) & 0xff)\n+\t\t\tminor := uint32(dev & 0xffff00ff)\n+\t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n+\t\tcase \"netbsd\":\n+\t\t\t// Copied from golang.org/x/sys/unix/dev_netbsd.go.\n+\t\t\tmajor := uint32((dev & 0x000fff00) >> 8)\n+\t\t\tminor := uint32((dev & 0x000000ff) >> 0)\n+\t\t\tminor |= uint32((dev & 0xfff00000) >> 12)\n+\t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n+\t\tcase \"openbsd\":\n+\t\t\t// Copied from golang.org/x/sys/unix/dev_openbsd.go.\n+\t\t\tmajor := uint32((dev & 0x0000ff00) >> 8)\n+\t\t\tminor := uint32((dev & 0x000000ff) >> 0)\n+\t\t\tminor |= uint32((dev & 0xffff0000) >> 8)\n+\t\t\th.Devmajor, h.Devminor = int64(major), int64(minor)\n+\t\tdefault:\n+\t\t\t// TODO: Implement solaris (see https://golang.org/issue/8106)\n+\t\t}\n+\t}\n \treturn nil\n }"}, {"sha": "d144485a492496def9c647d2ecdfe9674b06cd72", "filename": "libgo/go/archive/tar/strconv.go", "status": "modified", "additions": 102, "deletions": 28, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -12,26 +12,34 @@ import (\n \t\"time\"\n )\n \n+// hasNUL reports whether the NUL character exists within s.\n+func hasNUL(s string) bool {\n+\treturn strings.IndexByte(s, 0) >= 0\n+}\n+\n+// isASCII reports whether the input is an ASCII C-style string.\n func isASCII(s string) bool {\n \tfor _, c := range s {\n-\t\tif c >= 0x80 {\n+\t\tif c >= 0x80 || c == 0x00 {\n \t\t\treturn false\n \t\t}\n \t}\n \treturn true\n }\n \n+// toASCII converts the input to an ASCII C-style string.\n+// This a best effort conversion, so invalid characters are dropped.\n func toASCII(s string) string {\n \tif isASCII(s) {\n \t\treturn s\n \t}\n-\tvar buf bytes.Buffer\n+\tb := make([]byte, 0, len(s))\n \tfor _, c := range s {\n-\t\tif c < 0x80 {\n-\t\t\tbuf.WriteByte(byte(c))\n+\t\tif c < 0x80 && c != 0x00 {\n+\t\t\tb = append(b, byte(c))\n \t\t}\n \t}\n-\treturn buf.String()\n+\treturn string(b)\n }\n \n type parser struct {\n@@ -45,23 +53,28 @@ type formatter struct {\n // parseString parses bytes as a NUL-terminated C-style string.\n // If a NUL byte is not found then the whole slice is returned as a string.\n func (*parser) parseString(b []byte) string {\n-\tn := 0\n-\tfor n < len(b) && b[n] != 0 {\n-\t\tn++\n+\tif i := bytes.IndexByte(b, 0); i >= 0 {\n+\t\treturn string(b[:i])\n \t}\n-\treturn string(b[0:n])\n+\treturn string(b)\n }\n \n-// Write s into b, terminating it with a NUL if there is room.\n+// formatString copies s into b, NUL-terminating if possible.\n func (f *formatter) formatString(b []byte, s string) {\n \tif len(s) > len(b) {\n \t\tf.err = ErrFieldTooLong\n-\t\treturn\n \t}\n-\tascii := toASCII(s)\n-\tcopy(b, ascii)\n-\tif len(ascii) < len(b) {\n-\t\tb[len(ascii)] = 0\n+\tcopy(b, s)\n+\tif len(s) < len(b) {\n+\t\tb[len(s)] = 0\n+\t}\n+\n+\t// Some buggy readers treat regular files with a trailing slash\n+\t// in the V7 path field as a directory even though the full path\n+\t// recorded elsewhere (e.g., via PAX record) contains no trailing slash.\n+\tif len(s) > len(b) && b[len(b)-1] == '/' {\n+\t\tn := len(strings.TrimRight(s[:len(b)], \"/\"))\n+\t\tb[n] = 0 // Replace trailing slash with NUL terminator\n \t}\n }\n \n@@ -73,7 +86,7 @@ func (f *formatter) formatString(b []byte, s string) {\n // that the first byte can only be either 0x80 or 0xff. Thus, the first byte is\n // equivalent to the sign bit in two's complement form.\n func fitsInBase256(n int, x int64) bool {\n-\tvar binBits = uint(n-1) * 8\n+\tbinBits := uint(n-1) * 8\n \treturn n >= 9 || (x >= -1<<binBits && x < 1<<binBits)\n }\n \n@@ -121,8 +134,14 @@ func (p *parser) parseNumeric(b []byte) int64 {\n \treturn p.parseOctal(b)\n }\n \n-// Write x into b, as binary (GNUtar/star extension).\n+// formatNumeric encodes x into b using base-8 (octal) encoding if possible.\n+// Otherwise it will attempt to use base-256 (binary) encoding.\n func (f *formatter) formatNumeric(b []byte, x int64) {\n+\tif fitsInOctal(len(b), x) {\n+\t\tf.formatOctal(b, x)\n+\t\treturn\n+\t}\n+\n \tif fitsInBase256(len(b), x) {\n \t\tfor i := len(b) - 1; i >= 0; i-- {\n \t\t\tb[i] = byte(x)\n@@ -155,6 +174,11 @@ func (p *parser) parseOctal(b []byte) int64 {\n }\n \n func (f *formatter) formatOctal(b []byte, x int64) {\n+\tif !fitsInOctal(len(b), x) {\n+\t\tx = 0 // Last resort, just write zero\n+\t\tf.err = ErrFieldTooLong\n+\t}\n+\n \ts := strconv.FormatInt(x, 8)\n \t// Add leading zeros, but leave room for a NUL.\n \tif n := len(b) - len(s) - 1; n > 0 {\n@@ -163,6 +187,13 @@ func (f *formatter) formatOctal(b []byte, x int64) {\n \tf.formatString(b, s)\n }\n \n+// fitsInOctal reports whether the integer x fits in a field n-bytes long\n+// using octal encoding with the appropriate NUL terminator.\n+func fitsInOctal(n int, x int64) bool {\n+\toctBits := uint(n-1) * 3\n+\treturn x >= 0 && (n >= 22 || x < 1<<octBits)\n+}\n+\n // parsePAXTime takes a string of the form %d.%d as described in the PAX\n // specification. Note that this implementation allows for negative timestamps,\n // which is allowed for by the PAX specification, but not always portable.\n@@ -195,19 +226,32 @@ func parsePAXTime(s string) (time.Time, error) {\n \t}\n \tnsecs, _ := strconv.ParseInt(sn, 10, 64) // Must succeed\n \tif len(ss) > 0 && ss[0] == '-' {\n-\t\treturn time.Unix(secs, -1*int64(nsecs)), nil // Negative correction\n+\t\treturn time.Unix(secs, -1*nsecs), nil // Negative correction\n \t}\n-\treturn time.Unix(secs, int64(nsecs)), nil\n+\treturn time.Unix(secs, nsecs), nil\n }\n \n-// TODO(dsnet): Implement formatPAXTime.\n+// formatPAXTime converts ts into a time of the form %d.%d as described in the\n+// PAX specification. This function is capable of negative timestamps.\n+func formatPAXTime(ts time.Time) (s string) {\n+\tsecs, nsecs := ts.Unix(), ts.Nanosecond()\n+\tif nsecs == 0 {\n+\t\treturn strconv.FormatInt(secs, 10)\n+\t}\n+\n+\t// If seconds is negative, then perform correction.\n+\tsign := \"\"\n+\tif secs < 0 {\n+\t\tsign = \"-\"             // Remember sign\n+\t\tsecs = -(secs + 1)     // Add a second to secs\n+\t\tnsecs = -(nsecs - 1E9) // Take that second away from nsecs\n+\t}\n+\treturn strings.TrimRight(fmt.Sprintf(\"%s%d.%09d\", sign, secs, nsecs), \"0\")\n+}\n \n // parsePAXRecord parses the input PAX record string into a key-value pair.\n // If parsing is successful, it will slice off the currently read record and\n // return the remainder as r.\n-//\n-// A PAX record is of the following form:\n-//\t\"%d %s=%s\\n\" % (size, key, value)\n func parsePAXRecord(s string) (k, v, r string, err error) {\n \t// The size field ends at the first space.\n \tsp := strings.IndexByte(s, ' ')\n@@ -232,21 +276,51 @@ func parsePAXRecord(s string) (k, v, r string, err error) {\n \tif eq == -1 {\n \t\treturn \"\", \"\", s, ErrHeader\n \t}\n-\treturn rec[:eq], rec[eq+1:], rem, nil\n+\tk, v = rec[:eq], rec[eq+1:]\n+\n+\tif !validPAXRecord(k, v) {\n+\t\treturn \"\", \"\", s, ErrHeader\n+\t}\n+\treturn k, v, rem, nil\n }\n \n // formatPAXRecord formats a single PAX record, prefixing it with the\n // appropriate length.\n-func formatPAXRecord(k, v string) string {\n+func formatPAXRecord(k, v string) (string, error) {\n+\tif !validPAXRecord(k, v) {\n+\t\treturn \"\", ErrHeader\n+\t}\n+\n \tconst padding = 3 // Extra padding for ' ', '=', and '\\n'\n \tsize := len(k) + len(v) + padding\n \tsize += len(strconv.Itoa(size))\n-\trecord := fmt.Sprintf(\"%d %s=%s\\n\", size, k, v)\n+\trecord := strconv.Itoa(size) + \" \" + k + \"=\" + v + \"\\n\"\n \n \t// Final adjustment if adding size field increased the record size.\n \tif len(record) != size {\n \t\tsize = len(record)\n-\t\trecord = fmt.Sprintf(\"%d %s=%s\\n\", size, k, v)\n+\t\trecord = strconv.Itoa(size) + \" \" + k + \"=\" + v + \"\\n\"\n+\t}\n+\treturn record, nil\n+}\n+\n+// validPAXRecord reports whether the key-value pair is valid where each\n+// record is formatted as:\n+//\t\"%d %s=%s\\n\" % (size, key, value)\n+//\n+// Keys and values should be UTF-8, but the number of bad writers out there\n+// forces us to be a more liberal.\n+// Thus, we only reject all keys with NUL, and only reject NULs in values\n+// for the PAX version of the USTAR string fields.\n+// The key must not contain an '=' character.\n+func validPAXRecord(k, v string) bool {\n+\tif k == \"\" || strings.IndexByte(k, '=') >= 0 {\n+\t\treturn false\n+\t}\n+\tswitch k {\n+\tcase paxPath, paxLinkpath, paxUname, paxGname:\n+\t\treturn !hasNUL(v)\n+\tdefault:\n+\t\treturn !hasNUL(k)\n \t}\n-\treturn record\n }"}, {"sha": "4cc388cb0f269b88268c3f283f09d86a966dc626", "filename": "libgo/go/archive/tar/strconv_test.go", "status": "modified", "additions": 127, "deletions": 12, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -110,6 +110,25 @@ func TestFormatNumeric(t *testing.T) {\n \t\twant string\n \t\tok   bool\n \t}{\n+\t\t// Test base-8 (octal) encoded values.\n+\t\t{0, \"0\\x00\", true},\n+\t\t{7, \"7\\x00\", true},\n+\t\t{8, \"\\x80\\x08\", true},\n+\t\t{077, \"77\\x00\", true},\n+\t\t{0100, \"\\x80\\x00\\x40\", true},\n+\t\t{0, \"0000000\\x00\", true},\n+\t\t{0123, \"0000123\\x00\", true},\n+\t\t{07654321, \"7654321\\x00\", true},\n+\t\t{07777777, \"7777777\\x00\", true},\n+\t\t{010000000, \"\\x80\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", true},\n+\t\t{0, \"00000000000\\x00\", true},\n+\t\t{000001234567, \"00001234567\\x00\", true},\n+\t\t{076543210321, \"76543210321\\x00\", true},\n+\t\t{012345670123, \"12345670123\\x00\", true},\n+\t\t{077777777777, \"77777777777\\x00\", true},\n+\t\t{0100000000000, \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\", true},\n+\t\t{math.MaxInt64, \"777777777777777777777\\x00\", true},\n+\n \t\t// Test base-256 (binary) encoded values.\n \t\t{-1, \"\\xff\", true},\n \t\t{-1, \"\\xff\\xff\", true},\n@@ -155,6 +174,45 @@ func TestFormatNumeric(t *testing.T) {\n \t}\n }\n \n+func TestFitsInOctal(t *testing.T) {\n+\tvectors := []struct {\n+\t\tinput int64\n+\t\twidth int\n+\t\tok    bool\n+\t}{\n+\t\t{-1, 1, false},\n+\t\t{-1, 2, false},\n+\t\t{-1, 3, false},\n+\t\t{0, 1, true},\n+\t\t{0 + 1, 1, false},\n+\t\t{0, 2, true},\n+\t\t{07, 2, true},\n+\t\t{07 + 1, 2, false},\n+\t\t{0, 4, true},\n+\t\t{0777, 4, true},\n+\t\t{0777 + 1, 4, false},\n+\t\t{0, 8, true},\n+\t\t{07777777, 8, true},\n+\t\t{07777777 + 1, 8, false},\n+\t\t{0, 12, true},\n+\t\t{077777777777, 12, true},\n+\t\t{077777777777 + 1, 12, false},\n+\t\t{math.MaxInt64, 22, true},\n+\t\t{012345670123, 12, true},\n+\t\t{01564164, 12, true},\n+\t\t{-012345670123, 12, false},\n+\t\t{-01564164, 12, false},\n+\t\t{-1564164, 30, false},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tok := fitsInOctal(v.width, v.input)\n+\t\tif ok != v.ok {\n+\t\t\tt.Errorf(\"checkOctal(%d, %d): got %v, want %v\", v.input, v.width, ok, v.ok)\n+\t\t}\n+\t}\n+}\n+\n func TestParsePAXTime(t *testing.T) {\n \tvectors := []struct {\n \t\tin   string\n@@ -236,6 +294,51 @@ func TestParsePAXTime(t *testing.T) {\n \t}\n }\n \n+func TestFormatPAXTime(t *testing.T) {\n+\tvectors := []struct {\n+\t\tsec, nsec int64\n+\t\twant      string\n+\t}{\n+\t\t{1350244992, 0, \"1350244992\"},\n+\t\t{1350244992, 300000000, \"1350244992.3\"},\n+\t\t{1350244992, 23960100, \"1350244992.0239601\"},\n+\t\t{1350244992, 23960108, \"1350244992.023960108\"},\n+\t\t{+1, +1E9 - 1E0, \"1.999999999\"},\n+\t\t{+1, +1E9 - 1E3, \"1.999999\"},\n+\t\t{+1, +1E9 - 1E6, \"1.999\"},\n+\t\t{+1, +0E0 - 0E0, \"1\"},\n+\t\t{+1, +1E6 - 0E0, \"1.001\"},\n+\t\t{+1, +1E3 - 0E0, \"1.000001\"},\n+\t\t{+1, +1E0 - 0E0, \"1.000000001\"},\n+\t\t{0, 1E9 - 1E0, \"0.999999999\"},\n+\t\t{0, 1E9 - 1E3, \"0.999999\"},\n+\t\t{0, 1E9 - 1E6, \"0.999\"},\n+\t\t{0, 0E0, \"0\"},\n+\t\t{0, 1E6 + 0E0, \"0.001\"},\n+\t\t{0, 1E3 + 0E0, \"0.000001\"},\n+\t\t{0, 1E0 + 0E0, \"0.000000001\"},\n+\t\t{-1, -1E9 + 1E0, \"-1.999999999\"},\n+\t\t{-1, -1E9 + 1E3, \"-1.999999\"},\n+\t\t{-1, -1E9 + 1E6, \"-1.999\"},\n+\t\t{-1, -0E0 + 0E0, \"-1\"},\n+\t\t{-1, -1E6 + 0E0, \"-1.001\"},\n+\t\t{-1, -1E3 + 0E0, \"-1.000001\"},\n+\t\t{-1, -1E0 + 0E0, \"-1.000000001\"},\n+\t\t{-1350244992, 0, \"-1350244992\"},\n+\t\t{-1350244992, -300000000, \"-1350244992.3\"},\n+\t\t{-1350244992, -23960100, \"-1350244992.0239601\"},\n+\t\t{-1350244992, -23960108, \"-1350244992.023960108\"},\n+\t}\n+\n+\tfor _, v := range vectors {\n+\t\tgot := formatPAXTime(time.Unix(v.sec, v.nsec))\n+\t\tif got != v.want {\n+\t\t\tt.Errorf(\"formatPAXTime(%ds, %dns): got %q, want %q\",\n+\t\t\t\tv.sec, v.nsec, got, v.want)\n+\t\t}\n+\t}\n+}\n+\n func TestParsePAXRecord(t *testing.T) {\n \tmedName := strings.Repeat(\"CD\", 50)\n \tlongName := strings.Repeat(\"AB\", 100)\n@@ -256,7 +359,7 @@ func TestParsePAXRecord(t *testing.T) {\n \t\t{\"18 foo=b=\\nar=\\n==\\x00\\n\", \"\", \"foo\", \"b=\\nar=\\n==\\x00\", true},\n \t\t{\"27 foo=hello9 foo=ba\\nworld\\n\", \"\", \"foo\", \"hello9 foo=ba\\nworld\", true},\n \t\t{\"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\nmeow mix\", \"meow mix\", \"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", true},\n-\t\t{\"17 \\x00hello=\\x00world\\n\", \"\", \"\\x00hello\", \"\\x00world\", true},\n+\t\t{\"17 \\x00hello=\\x00world\\n\", \"17 \\x00hello=\\x00world\\n\", \"\", \"\", false},\n \t\t{\"1 k=1\\n\", \"1 k=1\\n\", \"\", \"\", false},\n \t\t{\"6 k~1\\n\", \"6 k~1\\n\", \"\", \"\", false},\n \t\t{\"6_k=1\\n\", \"6_k=1\\n\", \"\", \"\", false},\n@@ -296,21 +399,33 @@ func TestFormatPAXRecord(t *testing.T) {\n \t\tinKey string\n \t\tinVal string\n \t\twant  string\n+\t\tok    bool\n \t}{\n-\t\t{\"k\", \"v\", \"6 k=v\\n\"},\n-\t\t{\"path\", \"/etc/hosts\", \"19 path=/etc/hosts\\n\"},\n-\t\t{\"path\", longName, \"210 path=\" + longName + \"\\n\"},\n-\t\t{\"path\", medName, \"110 path=\" + medName + \"\\n\"},\n-\t\t{\"foo\", \"ba\", \"9 foo=ba\\n\"},\n-\t\t{\"foo\", \"bar\", \"11 foo=bar\\n\"},\n-\t\t{\"foo\", \"b=\\nar=\\n==\\x00\", \"18 foo=b=\\nar=\\n==\\x00\\n\"},\n-\t\t{\"foo\", \"hello9 foo=ba\\nworld\", \"27 foo=hello9 foo=ba\\nworld\\n\"},\n-\t\t{\"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", \"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\n\"},\n-\t\t{\"\\x00hello\", \"\\x00world\", \"17 \\x00hello=\\x00world\\n\"},\n+\t\t{\"k\", \"v\", \"6 k=v\\n\", true},\n+\t\t{\"path\", \"/etc/hosts\", \"19 path=/etc/hosts\\n\", true},\n+\t\t{\"path\", longName, \"210 path=\" + longName + \"\\n\", true},\n+\t\t{\"path\", medName, \"110 path=\" + medName + \"\\n\", true},\n+\t\t{\"foo\", \"ba\", \"9 foo=ba\\n\", true},\n+\t\t{\"foo\", \"bar\", \"11 foo=bar\\n\", true},\n+\t\t{\"foo\", \"b=\\nar=\\n==\\x00\", \"18 foo=b=\\nar=\\n==\\x00\\n\", true},\n+\t\t{\"foo\", \"hello9 foo=ba\\nworld\", \"27 foo=hello9 foo=ba\\nworld\\n\", true},\n+\t\t{\"\u263a\u263b\u2639\", \"\u65e5a\u672cb\u8a9e\u00e7\", \"27 \u263a\u263b\u2639=\u65e5a\u672cb\u8a9e\u00e7\\n\", true},\n+\t\t{\"xhello\", \"\\x00world\", \"17 xhello=\\x00world\\n\", true},\n+\t\t{\"path\", \"null\\x00\", \"\", false},\n+\t\t{\"null\\x00\", \"value\", \"\", false},\n+\t\t{paxSchilyXattr + \"key\", \"null\\x00\", \"26 SCHILY.xattr.key=null\\x00\\n\", true},\n \t}\n \n \tfor _, v := range vectors {\n-\t\tgot := formatPAXRecord(v.inKey, v.inVal)\n+\t\tgot, err := formatPAXRecord(v.inKey, v.inVal)\n+\t\tok := (err == nil)\n+\t\tif ok != v.ok {\n+\t\t\tif v.ok {\n+\t\t\t\tt.Errorf(\"formatPAXRecord(%q, %q): got format failure, want success\", v.inKey, v.inVal)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"formatPAXRecord(%q, %q): got format success, want failure\", v.inKey, v.inVal)\n+\t\t\t}\n+\t\t}\n \t\tif got != v.want {\n \t\t\tt.Errorf(\"formatPAXRecord(%q, %q): got %q, want %q\",\n \t\t\t\tv.inKey, v.inVal, got, v.want)"}, {"sha": "af80d6e0c1536a051baf9d7907b5bb7a3e84cd23", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 532, "deletions": 9, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -6,8 +6,12 @@ package tar\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n \t\"internal/testenv\"\n+\t\"io\"\n \t\"io/ioutil\"\n+\t\"math\"\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n@@ -17,6 +21,193 @@ import (\n \t\"time\"\n )\n \n+type testError struct{ error }\n+\n+type fileOps []interface{} // []T where T is (string | int64)\n+\n+// testFile is an io.ReadWriteSeeker where the IO operations performed\n+// on it must match the list of operations in ops.\n+type testFile struct {\n+\tops fileOps\n+\tpos int64\n+}\n+\n+func (f *testFile) Read(b []byte) (int, error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\tif len(f.ops) == 0 {\n+\t\treturn 0, io.EOF\n+\t}\n+\ts, ok := f.ops[0].(string)\n+\tif !ok {\n+\t\treturn 0, errors.New(\"unexpected Read operation\")\n+\t}\n+\n+\tn := copy(b, s)\n+\tif len(s) > n {\n+\t\tf.ops[0] = s[n:]\n+\t} else {\n+\t\tf.ops = f.ops[1:]\n+\t}\n+\tf.pos += int64(len(b))\n+\treturn n, nil\n+}\n+\n+func (f *testFile) Write(b []byte) (int, error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\tif len(f.ops) == 0 {\n+\t\treturn 0, errors.New(\"unexpected Write operation\")\n+\t}\n+\ts, ok := f.ops[0].(string)\n+\tif !ok {\n+\t\treturn 0, errors.New(\"unexpected Write operation\")\n+\t}\n+\n+\tif !strings.HasPrefix(s, string(b)) {\n+\t\treturn 0, testError{fmt.Errorf(\"got Write(%q), want Write(%q)\", b, s)}\n+\t}\n+\tif len(s) > len(b) {\n+\t\tf.ops[0] = s[len(b):]\n+\t} else {\n+\t\tf.ops = f.ops[1:]\n+\t}\n+\tf.pos += int64(len(b))\n+\treturn len(b), nil\n+}\n+\n+func (f *testFile) Seek(pos int64, whence int) (int64, error) {\n+\tif pos == 0 && whence == io.SeekCurrent {\n+\t\treturn f.pos, nil\n+\t}\n+\tif len(f.ops) == 0 {\n+\t\treturn 0, errors.New(\"unexpected Seek operation\")\n+\t}\n+\ts, ok := f.ops[0].(int64)\n+\tif !ok {\n+\t\treturn 0, errors.New(\"unexpected Seek operation\")\n+\t}\n+\n+\tif s != pos || whence != io.SeekCurrent {\n+\t\treturn 0, testError{fmt.Errorf(\"got Seek(%d, %d), want Seek(%d, %d)\", pos, whence, s, io.SeekCurrent)}\n+\t}\n+\tf.pos += s\n+\tf.ops = f.ops[1:]\n+\treturn f.pos, nil\n+}\n+\n+func equalSparseEntries(x, y []sparseEntry) bool {\n+\treturn (len(x) == 0 && len(y) == 0) || reflect.DeepEqual(x, y)\n+}\n+\n+func TestSparseEntries(t *testing.T) {\n+\tvectors := []struct {\n+\t\tin   []sparseEntry\n+\t\tsize int64\n+\n+\t\twantValid    bool          // Result of validateSparseEntries\n+\t\twantAligned  []sparseEntry // Result of alignSparseEntries\n+\t\twantInverted []sparseEntry // Result of invertSparseEntries\n+\t}{{\n+\t\tin: []sparseEntry{}, size: 0,\n+\t\twantValid:    true,\n+\t\twantInverted: []sparseEntry{{0, 0}},\n+\t}, {\n+\t\tin: []sparseEntry{}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantInverted: []sparseEntry{{0, 5000}},\n+\t}, {\n+\t\tin: []sparseEntry{{0, 5000}}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{0, 5000}},\n+\t\twantInverted: []sparseEntry{{5000, 0}},\n+\t}, {\n+\t\tin: []sparseEntry{{1000, 4000}}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{1024, 3976}},\n+\t\twantInverted: []sparseEntry{{0, 1000}, {5000, 0}},\n+\t}, {\n+\t\tin: []sparseEntry{{0, 3000}}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{0, 2560}},\n+\t\twantInverted: []sparseEntry{{3000, 2000}},\n+\t}, {\n+\t\tin: []sparseEntry{{3000, 2000}}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{3072, 1928}},\n+\t\twantInverted: []sparseEntry{{0, 3000}, {5000, 0}},\n+\t}, {\n+\t\tin: []sparseEntry{{2000, 2000}}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{2048, 1536}},\n+\t\twantInverted: []sparseEntry{{0, 2000}, {4000, 1000}},\n+\t}, {\n+\t\tin: []sparseEntry{{0, 2000}, {8000, 2000}}, size: 10000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{0, 1536}, {8192, 1808}},\n+\t\twantInverted: []sparseEntry{{2000, 6000}, {10000, 0}},\n+\t}, {\n+\t\tin: []sparseEntry{{0, 2000}, {2000, 2000}, {4000, 0}, {4000, 3000}, {7000, 1000}, {8000, 0}, {8000, 2000}}, size: 10000,\n+\t\twantValid:    true,\n+\t\twantAligned:  []sparseEntry{{0, 1536}, {2048, 1536}, {4096, 2560}, {7168, 512}, {8192, 1808}},\n+\t\twantInverted: []sparseEntry{{10000, 0}},\n+\t}, {\n+\t\tin: []sparseEntry{{0, 0}, {1000, 0}, {2000, 0}, {3000, 0}, {4000, 0}, {5000, 0}}, size: 5000,\n+\t\twantValid:    true,\n+\t\twantInverted: []sparseEntry{{0, 5000}},\n+\t}, {\n+\t\tin: []sparseEntry{{1, 0}}, size: 0,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{-1, 0}}, size: 100,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{0, -1}}, size: 100,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{0, 0}}, size: -100,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{math.MaxInt64, 3}, {6, -5}}, size: 35,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{1, 3}, {6, -5}}, size: 35,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{math.MaxInt64, math.MaxInt64}}, size: math.MaxInt64,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{3, 3}}, size: 5,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{2, 0}, {1, 0}, {0, 0}}, size: 3,\n+\t\twantValid: false,\n+\t}, {\n+\t\tin: []sparseEntry{{1, 3}, {2, 2}}, size: 10,\n+\t\twantValid: false,\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\tgotValid := validateSparseEntries(v.in, v.size)\n+\t\tif gotValid != v.wantValid {\n+\t\t\tt.Errorf(\"test %d, validateSparseEntries() = %v, want %v\", i, gotValid, v.wantValid)\n+\t\t}\n+\t\tif !v.wantValid {\n+\t\t\tcontinue\n+\t\t}\n+\t\tgotAligned := alignSparseEntries(append([]sparseEntry{}, v.in...), v.size)\n+\t\tif !equalSparseEntries(gotAligned, v.wantAligned) {\n+\t\t\tt.Errorf(\"test %d, alignSparseEntries():\\ngot  %v\\nwant %v\", i, gotAligned, v.wantAligned)\n+\t\t}\n+\t\tgotInverted := invertSparseEntries(append([]sparseEntry{}, v.in...), v.size)\n+\t\tif !equalSparseEntries(gotInverted, v.wantInverted) {\n+\t\t\tt.Errorf(\"test %d, inverseSparseEntries():\\ngot  %v\\nwant %v\", i, gotInverted, v.wantInverted)\n+\t\t}\n+\t}\n+}\n+\n func TestFileInfoHeader(t *testing.T) {\n \tfi, err := os.Stat(\"testdata/small.txt\")\n \tif err != nil {\n@@ -109,15 +300,12 @@ func TestRoundTrip(t *testing.T) {\n \tvar b bytes.Buffer\n \ttw := NewWriter(&b)\n \thdr := &Header{\n-\t\tName: \"file.txt\",\n-\t\tUid:  1 << 21, // too big for 8 octal digits\n-\t\tSize: int64(len(data)),\n-\t\t// AddDate to strip monotonic clock reading,\n-\t\t// and Round to discard sub-second precision,\n-\t\t// both of which are not included in the tar header\n-\t\t// and would otherwise break the round-trip check\n-\t\t// below.\n-\t\tModTime: time.Now().AddDate(0, 0, 0).Round(1 * time.Second),\n+\t\tName:       \"file.txt\",\n+\t\tUid:        1 << 21, // Too big for 8 octal digits\n+\t\tSize:       int64(len(data)),\n+\t\tModTime:    time.Now().Round(time.Second),\n+\t\tPAXRecords: map[string]string{\"uid\": \"2097152\"},\n+\t\tFormat:     FormatPAX,\n \t}\n \tif err := tw.WriteHeader(hdr); err != nil {\n \t\tt.Fatalf(\"tw.WriteHeader: %v\", err)\n@@ -329,3 +517,338 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestHeaderAllowedFormats(t *testing.T) {\n+\tvectors := []struct {\n+\t\theader  *Header           // Input header\n+\t\tpaxHdrs map[string]string // Expected PAX headers that may be needed\n+\t\tformats Format            // Expected formats that can encode the header\n+\t}{{\n+\t\theader:  &Header{},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777, Format: FormatUSTAR},\n+\t\tformats: FormatUSTAR,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777, Format: FormatPAX},\n+\t\tformats: FormatUSTAR | FormatPAX,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777, Format: FormatGNU},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777 + 1},\n+\t\tpaxHdrs: map[string]string{paxSize: \"8589934592\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777 + 1, Format: FormatPAX},\n+\t\tpaxHdrs: map[string]string{paxSize: \"8589934592\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{Size: 077777777777 + 1, Format: FormatGNU},\n+\t\tpaxHdrs: map[string]string{paxSize: \"8589934592\"},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Mode: 07777777},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Mode: 07777777 + 1},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Devmajor: -123},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Devmajor: 1<<56 - 1},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Devmajor: 1 << 56},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Devmajor: -1 << 56},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Devmajor: -1<<56 - 1},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Name: \"\u7528\u6236\u540d\", Devmajor: -1 << 56},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Size: math.MaxInt64},\n+\t\tpaxHdrs: map[string]string{paxSize: \"9223372036854775807\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Size: math.MinInt64},\n+\t\tpaxHdrs: map[string]string{paxSize: \"-9223372036854775808\"},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Uname: \"0123456789abcdef0123456789abcdef\"},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Uname: \"0123456789abcdef0123456789abcdefx\"},\n+\t\tpaxHdrs: map[string]string{paxUname: \"0123456789abcdef0123456789abcdefx\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{Name: \"foobar\"},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Name: strings.Repeat(\"a\", nameSize)},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Name: strings.Repeat(\"a\", nameSize+1)},\n+\t\tpaxHdrs: map[string]string{paxPath: strings.Repeat(\"a\", nameSize+1)},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Linkname: \"\u7528\u6236\u540d\"},\n+\t\tpaxHdrs: map[string]string{paxLinkpath: \"\u7528\u6236\u540d\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Linkname: strings.Repeat(\"\u7528\u6236\u540d\\x00\", nameSize)},\n+\t\tpaxHdrs: map[string]string{paxLinkpath: strings.Repeat(\"\u7528\u6236\u540d\\x00\", nameSize)},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Linkname: \"\\x00hello\"},\n+\t\tpaxHdrs: map[string]string{paxLinkpath: \"\\x00hello\"},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Uid: 07777777},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Uid: 07777777 + 1},\n+\t\tpaxHdrs: map[string]string{paxUid: \"2097152\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Xattrs: nil},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Xattrs: map[string]string{\"foo\": \"bar\"}},\n+\t\tpaxHdrs: map[string]string{paxSchilyXattr + \"foo\": \"bar\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{Xattrs: map[string]string{\"foo\": \"bar\"}, Format: FormatGNU},\n+\t\tpaxHdrs: map[string]string{paxSchilyXattr + \"foo\": \"bar\"},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Xattrs: map[string]string{\"\u7528\u6236\u540d\": \"\\x00hello\"}},\n+\t\tpaxHdrs: map[string]string{paxSchilyXattr + \"\u7528\u6236\u540d\": \"\\x00hello\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{Xattrs: map[string]string{\"foo=bar\": \"baz\"}},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Xattrs: map[string]string{\"foo\": \"\"}},\n+\t\tpaxHdrs: map[string]string{paxSchilyXattr + \"foo\": \"\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(0, 0)},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(077777777777, 0)},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(077777777777+1, 0)},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"8589934592\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(math.MaxInt64, 0)},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"9223372036854775807\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(math.MaxInt64, 0), Format: FormatUSTAR},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"9223372036854775807\"},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(-1, 0)},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"-1\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(1, 500)},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"1.0000005\"},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(1, 0)},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(1, 0), Format: FormatPAX},\n+\t\tformats: FormatUSTAR | FormatPAX,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(1, 500), Format: FormatUSTAR},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"1.0000005\"},\n+\t\tformats: FormatUSTAR,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(1, 500), Format: FormatPAX},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"1.0000005\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(1, 500), Format: FormatGNU},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"1.0000005\"},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(-1, 500)},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"-0.9999995\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ModTime: time.Unix(-1, 500), Format: FormatGNU},\n+\t\tpaxHdrs: map[string]string{paxMtime: \"-0.9999995\"},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{AccessTime: time.Unix(0, 0)},\n+\t\tpaxHdrs: map[string]string{paxAtime: \"0\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{AccessTime: time.Unix(0, 0), Format: FormatUSTAR},\n+\t\tpaxHdrs: map[string]string{paxAtime: \"0\"},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{AccessTime: time.Unix(0, 0), Format: FormatPAX},\n+\t\tpaxHdrs: map[string]string{paxAtime: \"0\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{AccessTime: time.Unix(0, 0), Format: FormatGNU},\n+\t\tpaxHdrs: map[string]string{paxAtime: \"0\"},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{AccessTime: time.Unix(-123, 0)},\n+\t\tpaxHdrs: map[string]string{paxAtime: \"-123\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{AccessTime: time.Unix(-123, 0), Format: FormatPAX},\n+\t\tpaxHdrs: map[string]string{paxAtime: \"-123\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{ChangeTime: time.Unix(123, 456)},\n+\t\tpaxHdrs: map[string]string{paxCtime: \"123.000000456\"},\n+\t\tformats: FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ChangeTime: time.Unix(123, 456), Format: FormatUSTAR},\n+\t\tpaxHdrs: map[string]string{paxCtime: \"123.000000456\"},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{ChangeTime: time.Unix(123, 456), Format: FormatGNU},\n+\t\tpaxHdrs: map[string]string{paxCtime: \"123.000000456\"},\n+\t\tformats: FormatGNU,\n+\t}, {\n+\t\theader:  &Header{ChangeTime: time.Unix(123, 456), Format: FormatPAX},\n+\t\tpaxHdrs: map[string]string{paxCtime: \"123.000000456\"},\n+\t\tformats: FormatPAX,\n+\t}, {\n+\t\theader:  &Header{Name: \"foo/\", Typeflag: TypeDir},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}, {\n+\t\theader:  &Header{Name: \"foo/\", Typeflag: TypeReg},\n+\t\tformats: FormatUnknown,\n+\t}, {\n+\t\theader:  &Header{Name: \"foo/\", Typeflag: TypeSymlink},\n+\t\tformats: FormatUSTAR | FormatPAX | FormatGNU,\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\tformats, paxHdrs, err := v.header.allowedFormats()\n+\t\tif formats != v.formats {\n+\t\t\tt.Errorf(\"test %d, allowedFormats(): got %v, want %v\", i, formats, v.formats)\n+\t\t}\n+\t\tif formats&FormatPAX > 0 && !reflect.DeepEqual(paxHdrs, v.paxHdrs) && !(len(paxHdrs) == 0 && len(v.paxHdrs) == 0) {\n+\t\t\tt.Errorf(\"test %d, allowedFormats():\\ngot  %v\\nwant %s\", i, paxHdrs, v.paxHdrs)\n+\t\t}\n+\t\tif (formats != FormatUnknown) && (err != nil) {\n+\t\t\tt.Errorf(\"test %d, unexpected error: %v\", i, err)\n+\t\t}\n+\t\tif (formats == FormatUnknown) && (err == nil) {\n+\t\t\tt.Errorf(\"test %d, got nil-error, want non-nil error\", i)\n+\t\t}\n+\t}\n+}\n+\n+func Benchmark(b *testing.B) {\n+\ttype file struct {\n+\t\thdr  *Header\n+\t\tbody []byte\n+\t}\n+\n+\tvectors := []struct {\n+\t\tlabel string\n+\t\tfiles []file\n+\t}{{\n+\t\t\"USTAR\",\n+\t\t[]file{{\n+\t\t\t&Header{Name: \"bar\", Mode: 0640, Size: int64(3)},\n+\t\t\t[]byte(\"foo\"),\n+\t\t}, {\n+\t\t\t&Header{Name: \"world\", Mode: 0640, Size: int64(5)},\n+\t\t\t[]byte(\"hello\"),\n+\t\t}},\n+\t}, {\n+\t\t\"GNU\",\n+\t\t[]file{{\n+\t\t\t&Header{Name: \"bar\", Mode: 0640, Size: int64(3), Devmajor: -1},\n+\t\t\t[]byte(\"foo\"),\n+\t\t}, {\n+\t\t\t&Header{Name: \"world\", Mode: 0640, Size: int64(5), Devmajor: -1},\n+\t\t\t[]byte(\"hello\"),\n+\t\t}},\n+\t}, {\n+\t\t\"PAX\",\n+\t\t[]file{{\n+\t\t\t&Header{Name: \"bar\", Mode: 0640, Size: int64(3), Xattrs: map[string]string{\"foo\": \"bar\"}},\n+\t\t\t[]byte(\"foo\"),\n+\t\t}, {\n+\t\t\t&Header{Name: \"world\", Mode: 0640, Size: int64(5), Xattrs: map[string]string{\"foo\": \"bar\"}},\n+\t\t\t[]byte(\"hello\"),\n+\t\t}},\n+\t}}\n+\n+\tb.Run(\"Writer\", func(b *testing.B) {\n+\t\tfor _, v := range vectors {\n+\t\t\tb.Run(v.label, func(b *testing.B) {\n+\t\t\t\tb.ReportAllocs()\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\t// Writing to ioutil.Discard because we want to\n+\t\t\t\t\t// test purely the writer code and not bring in disk performance into this.\n+\t\t\t\t\ttw := NewWriter(ioutil.Discard)\n+\t\t\t\t\tfor _, file := range v.files {\n+\t\t\t\t\t\tif err := tw.WriteHeader(file.hdr); err != nil {\n+\t\t\t\t\t\t\tb.Errorf(\"unexpected WriteHeader error: %v\", err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif _, err := tw.Write(file.body); err != nil {\n+\t\t\t\t\t\t\tb.Errorf(\"unexpected Write error: %v\", err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif err := tw.Close(); err != nil {\n+\t\t\t\t\t\tb.Errorf(\"unexpected Close error: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\tb.Run(\"Reader\", func(b *testing.B) {\n+\t\tfor _, v := range vectors {\n+\t\t\tvar buf bytes.Buffer\n+\t\t\tvar r bytes.Reader\n+\n+\t\t\t// Write the archive to a byte buffer.\n+\t\t\ttw := NewWriter(&buf)\n+\t\t\tfor _, file := range v.files {\n+\t\t\t\ttw.WriteHeader(file.hdr)\n+\t\t\t\ttw.Write(file.body)\n+\t\t\t}\n+\t\t\ttw.Close()\n+\t\t\tb.Run(v.label, func(b *testing.B) {\n+\t\t\t\tb.ReportAllocs()\n+\t\t\t\t// Read from the byte buffer.\n+\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\tr.Reset(buf.Bytes())\n+\t\t\t\t\ttr := NewReader(&r)\n+\t\t\t\t\tif _, err := tr.Next(); err != nil {\n+\t\t\t\t\t\tb.Errorf(\"unexpected Next error: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t\tif _, err := io.Copy(ioutil.Discard, tr); err != nil {\n+\t\t\t\t\t\tb.Errorf(\"unexpected Copy error : %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+}"}, {"sha": "28bc812aa60e81ea324297c81c738486acffc09c", "filename": "libgo/go/archive/tar/testdata/gnu-long-nul.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-long-nul.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-long-nul.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-long-nul.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "df1aa834538e74f20f303e5d9c7fb4ba8fea1e82", "filename": "libgo/go/archive/tar/testdata/gnu-nil-sparse-data.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-nil-sparse-data.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-nil-sparse-data.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-nil-sparse-data.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "496abfeb78a5e1a999ab66bbe766c51474bb9a25", "filename": "libgo/go/archive/tar/testdata/gnu-nil-sparse-hole.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-nil-sparse-hole.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-nil-sparse-hole.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-nil-sparse-hole.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "81cec67d3309502add09e2495ee1bf139389c8cb", "filename": "libgo/go/archive/tar/testdata/gnu-not-utf8.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-not-utf8.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-not-utf8.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-not-utf8.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "1a5cfc96d92983b42dab09b51bec236fe00d24c3", "filename": "libgo/go/archive/tar/testdata/gnu-sparse-big.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-sparse-big.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-sparse-big.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-sparse-big.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2c9c8079cf651d4271ed78ac12bed01df5882f16", "filename": "libgo/go/archive/tar/testdata/gnu-utf8.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-utf8.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-utf8.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fgnu-utf8.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "58f2488e78fb44a10f4e5a7833d5176c4c0ca090", "filename": "libgo/go/archive/tar/testdata/invalid-go17.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Finvalid-go17.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Finvalid-go17.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Finvalid-go17.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3d3d241e65c3a18feae324e8c40c9e5c76515dde", "filename": "libgo/go/archive/tar/testdata/pax-global-records.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-global-records.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-global-records.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-global-records.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "e59bd94117d9e467143592dcfe8e69767ba935ee", "filename": "libgo/go/archive/tar/testdata/pax-nil-sparse-data.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nil-sparse-data.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nil-sparse-data.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nil-sparse-data.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b44327bdbfb343658e5142f2129d7688f3044021", "filename": "libgo/go/archive/tar/testdata/pax-nil-sparse-hole.tar", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nil-sparse-hole.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nil-sparse-hole.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nil-sparse-hole.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "previous_filename": "libgo/go/archive/tar/testdata/ustar.issue12594.tar"}, {"sha": "c78f82b16e85363143404ec50c3e77e5174ba696", "filename": "libgo/go/archive/tar/testdata/pax-nul-path.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nul-path.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nul-path.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nul-path.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "881f51768f9872f8d9bfcd2cbb637a64c88b59fb", "filename": "libgo/go/archive/tar/testdata/pax-nul-xattrs.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nul-xattrs.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nul-xattrs.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-nul-xattrs.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ea5ccf916426a5b6300dd341dffeeb349e51ad90", "filename": "libgo/go/archive/tar/testdata/pax-pos-size-file.tar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-pos-size-file.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-pos-size-file.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-pos-size-file.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "276c211baa388cd4857f60be3355dc710c079adf", "filename": "libgo/go/archive/tar/testdata/pax-records.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-records.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-records.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-records.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "65d1f8eceb084955d03ef41f6efbbed0ab3ab07d", "filename": "libgo/go/archive/tar/testdata/pax-sparse-big.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-sparse-big.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-sparse-big.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fpax-sparse-big.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "bf1b2ec426b4999b111c7f0914fb1f2d52b91728", "filename": "libgo/go/archive/tar/testdata/trailing-slash.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ftrailing-slash.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ftrailing-slash.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Ftrailing-slash.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "146e25b79d8980a5eb0d370d0d9a0b7534c05135", "filename": "libgo/go/archive/tar/testdata/ustar-file-devs.tar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fustar-file-devs.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fustar-file-devs.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fustar-file-devs.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "09fc5dd3dd7fc5de3b6d22461fa23152fd499a41", "filename": "libgo/go/archive/tar/testdata/writer-big-long.tar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big-long.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big-long.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big-long.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "435dcbce6abc74dc5efa1f4dd34129eb7701c697", "filename": "libgo/go/archive/tar/testdata/writer-big.tar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter-big.tar?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "97d23f80388ee86c8be72f080e8d3d53e2f983b6", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 546, "deletions": 272, "changes": 818, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -4,255 +4,391 @@\n \n package tar\n \n-// TODO(dsymonds):\n-// - catch more errors (no first header, etc.)\n-\n import (\n \t\"bytes\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"path\"\n \t\"sort\"\n-\t\"strconv\"\n \t\"strings\"\n \t\"time\"\n )\n \n-var (\n-\tErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n-\tErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n-\tErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n-\terrInvalidHeader   = errors.New(\"archive/tar: header field too long or contains invalid values\")\n-)\n-\n-// A Writer provides sequential writing of a tar archive in POSIX.1 format.\n-// A tar archive consists of a sequence of files.\n-// Call WriteHeader to begin a new file, and then call Write to supply that file's data,\n-// writing at most hdr.Size bytes in total.\n+// Writer provides sequential writing of a tar archive.\n+// Write.WriteHeader begins a new file with the provided Header,\n+// and then Writer can be treated as an io.Writer to supply that file's data.\n type Writer struct {\n-\tw          io.Writer\n-\terr        error\n-\tnb         int64 // number of unwritten bytes for current file entry\n-\tpad        int64 // amount of padding to write after current file entry\n-\tclosed     bool\n-\tusedBinary bool  // whether the binary numeric field extension was used\n-\tpreferPax  bool  // use PAX header instead of binary numeric header\n-\thdrBuff    block // buffer to use in writeHeader when writing a regular header\n-\tpaxHdrBuff block // buffer to use in writeHeader when writing a PAX header\n+\tw    io.Writer\n+\tpad  int64      // Amount of padding to write after current file entry\n+\tcurr fileWriter // Writer for current file entry\n+\thdr  Header     // Shallow copy of Header that is safe for mutations\n+\tblk  block      // Buffer to use as temporary local storage\n+\n+\t// err is a persistent error.\n+\t// It is only the responsibility of every exported method of Writer to\n+\t// ensure that this error is sticky.\n+\terr error\n }\n \n // NewWriter creates a new Writer writing to w.\n-func NewWriter(w io.Writer) *Writer { return &Writer{w: w} }\n+func NewWriter(w io.Writer) *Writer {\n+\treturn &Writer{w: w, curr: &regFileWriter{w, 0}}\n+}\n+\n+type fileWriter interface {\n+\tio.Writer\n+\tfileState\n \n-// Flush finishes writing the current file (optional).\n+\tReadFrom(io.Reader) (int64, error)\n+}\n+\n+// Flush finishes writing the current file's block padding.\n+// The current file must be fully written before Flush can be called.\n+//\n+// This is unnecessary as the next call to WriteHeader or Close\n+// will implicitly flush out the file's padding.\n func (tw *Writer) Flush() error {\n-\tif tw.nb > 0 {\n-\t\ttw.err = fmt.Errorf(\"archive/tar: missed writing %d bytes\", tw.nb)\n+\tif tw.err != nil {\n \t\treturn tw.err\n \t}\n-\n-\tn := tw.nb + tw.pad\n-\tfor n > 0 && tw.err == nil {\n-\t\tnr := n\n-\t\tif nr > blockSize {\n-\t\t\tnr = blockSize\n-\t\t}\n-\t\tvar nw int\n-\t\tnw, tw.err = tw.w.Write(zeroBlock[0:nr])\n-\t\tn -= int64(nw)\n+\tif nb := tw.curr.LogicalRemaining(); nb > 0 {\n+\t\treturn fmt.Errorf(\"archive/tar: missed writing %d bytes\", nb)\n+\t}\n+\tif _, tw.err = tw.w.Write(zeroBlock[:tw.pad]); tw.err != nil {\n+\t\treturn tw.err\n \t}\n-\ttw.nb = 0\n \ttw.pad = 0\n-\treturn tw.err\n+\treturn nil\n }\n \n-var (\n-\tminTime = time.Unix(0, 0)\n-\t// There is room for 11 octal digits (33 bits) of mtime.\n-\tmaxTime = minTime.Add((1<<33 - 1) * time.Second)\n-)\n-\n // WriteHeader writes hdr and prepares to accept the file's contents.\n-// WriteHeader calls Flush if it is not the first header.\n-// Calling after a Close will return ErrWriteAfterClose.\n+// The Header.Size determines how many bytes can be written for the next file.\n+// If the current file is not fully written, then this returns an error.\n+// This implicitly flushes any padding necessary before writing the header.\n func (tw *Writer) WriteHeader(hdr *Header) error {\n-\treturn tw.writeHeader(hdr, true)\n-}\n-\n-// WriteHeader writes hdr and prepares to accept the file's contents.\n-// WriteHeader calls Flush if it is not the first header.\n-// Calling after a Close will return ErrWriteAfterClose.\n-// As this method is called internally by writePax header to allow it to\n-// suppress writing the pax header.\n-func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n-\tif tw.closed {\n-\t\treturn ErrWriteAfterClose\n+\tif err := tw.Flush(); err != nil {\n+\t\treturn err\n \t}\n-\tif tw.err == nil {\n-\t\ttw.Flush()\n+\ttw.hdr = *hdr // Shallow copy of Header\n+\n+\t// Round ModTime and ignore AccessTime and ChangeTime unless\n+\t// the format is explicitly chosen.\n+\t// This ensures nominal usage of WriteHeader (without specifying the format)\n+\t// does not always result in the PAX format being chosen, which\n+\t// causes a 1KiB increase to every header.\n+\tif tw.hdr.Format == FormatUnknown {\n+\t\ttw.hdr.ModTime = tw.hdr.ModTime.Round(time.Second)\n+\t\ttw.hdr.AccessTime = time.Time{}\n+\t\ttw.hdr.ChangeTime = time.Time{}\n \t}\n-\tif tw.err != nil {\n+\n+\tallowedFormats, paxHdrs, err := tw.hdr.allowedFormats()\n+\tswitch {\n+\tcase allowedFormats.has(FormatUSTAR):\n+\t\ttw.err = tw.writeUSTARHeader(&tw.hdr)\n \t\treturn tw.err\n+\tcase allowedFormats.has(FormatPAX):\n+\t\ttw.err = tw.writePAXHeader(&tw.hdr, paxHdrs)\n+\t\treturn tw.err\n+\tcase allowedFormats.has(FormatGNU):\n+\t\ttw.err = tw.writeGNUHeader(&tw.hdr)\n+\t\treturn tw.err\n+\tdefault:\n+\t\treturn err // Non-fatal error\n \t}\n+}\n \n-\t// a map to hold pax header records, if any are needed\n-\tpaxHeaders := make(map[string]string)\n-\n-\t// TODO(dsnet): we might want to use PAX headers for\n-\t// subsecond time resolution, but for now let's just capture\n-\t// too long fields or non ascii characters\n-\n-\t// We need to select which scratch buffer to use carefully,\n-\t// since this method is called recursively to write PAX headers.\n-\t// If allowPax is true, this is the non-recursive call, and we will use hdrBuff.\n-\t// If allowPax is false, we are being called by writePAXHeader, and hdrBuff is\n-\t// already being used by the non-recursive call, so we must use paxHdrBuff.\n-\theader := &tw.hdrBuff\n-\tif !allowPax {\n-\t\theader = &tw.paxHdrBuff\n+func (tw *Writer) writeUSTARHeader(hdr *Header) error {\n+\t// Check if we can use USTAR prefix/suffix splitting.\n+\tvar namePrefix string\n+\tif prefix, suffix, ok := splitUSTARPath(hdr.Name); ok {\n+\t\tnamePrefix, hdr.Name = prefix, suffix\n \t}\n-\tcopy(header[:], zeroBlock[:])\n \n-\t// Wrappers around formatter that automatically sets paxHeaders if the\n-\t// argument extends beyond the capacity of the input byte slice.\n+\t// Pack the main header.\n \tvar f formatter\n-\tvar formatString = func(b []byte, s string, paxKeyword string) {\n-\t\tneedsPaxHeader := paxKeyword != paxNone && len(s) > len(b) || !isASCII(s)\n-\t\tif needsPaxHeader {\n-\t\t\tpaxHeaders[paxKeyword] = s\n+\tblk := tw.templateV7Plus(hdr, f.formatString, f.formatOctal)\n+\tf.formatString(blk.USTAR().Prefix(), namePrefix)\n+\tblk.SetFormat(FormatUSTAR)\n+\tif f.err != nil {\n+\t\treturn f.err // Should never happen since header is validated\n+\t}\n+\treturn tw.writeRawHeader(blk, hdr.Size, hdr.Typeflag)\n+}\n+\n+func (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error {\n+\trealName, realSize := hdr.Name, hdr.Size\n+\n+\t// TODO(dsnet): Re-enable this when adding sparse support.\n+\t// See https://golang.org/issue/22735\n+\t/*\n+\t\t// Handle sparse files.\n+\t\tvar spd sparseDatas\n+\t\tvar spb []byte\n+\t\tif len(hdr.SparseHoles) > 0 {\n+\t\t\tsph := append([]sparseEntry{}, hdr.SparseHoles...) // Copy sparse map\n+\t\t\tsph = alignSparseEntries(sph, hdr.Size)\n+\t\t\tspd = invertSparseEntries(sph, hdr.Size)\n+\n+\t\t\t// Format the sparse map.\n+\t\t\thdr.Size = 0 // Replace with encoded size\n+\t\t\tspb = append(strconv.AppendInt(spb, int64(len(spd)), 10), '\\n')\n+\t\t\tfor _, s := range spd {\n+\t\t\t\thdr.Size += s.Length\n+\t\t\t\tspb = append(strconv.AppendInt(spb, s.Offset, 10), '\\n')\n+\t\t\t\tspb = append(strconv.AppendInt(spb, s.Length, 10), '\\n')\n+\t\t\t}\n+\t\t\tpad := blockPadding(int64(len(spb)))\n+\t\t\tspb = append(spb, zeroBlock[:pad]...)\n+\t\t\thdr.Size += int64(len(spb)) // Accounts for encoded sparse map\n+\n+\t\t\t// Add and modify appropriate PAX records.\n+\t\t\tdir, file := path.Split(realName)\n+\t\t\thdr.Name = path.Join(dir, \"GNUSparseFile.0\", file)\n+\t\t\tpaxHdrs[paxGNUSparseMajor] = \"1\"\n+\t\t\tpaxHdrs[paxGNUSparseMinor] = \"0\"\n+\t\t\tpaxHdrs[paxGNUSparseName] = realName\n+\t\t\tpaxHdrs[paxGNUSparseRealSize] = strconv.FormatInt(realSize, 10)\n+\t\t\tpaxHdrs[paxSize] = strconv.FormatInt(hdr.Size, 10)\n+\t\t\tdelete(paxHdrs, paxPath) // Recorded by paxGNUSparseName\n+\t\t}\n+\t*/\n+\t_ = realSize\n+\n+\t// Write PAX records to the output.\n+\tisGlobal := hdr.Typeflag == TypeXGlobalHeader\n+\tif len(paxHdrs) > 0 || isGlobal {\n+\t\t// Sort keys for deterministic ordering.\n+\t\tvar keys []string\n+\t\tfor k := range paxHdrs {\n+\t\t\tkeys = append(keys, k)\n+\t\t}\n+\t\tsort.Strings(keys)\n+\n+\t\t// Write each record to a buffer.\n+\t\tvar buf bytes.Buffer\n+\t\tfor _, k := range keys {\n+\t\t\trec, err := formatPAXRecord(k, paxHdrs[k])\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tbuf.WriteString(rec)\n \t\t}\n \n-\t\t// Write string in a best-effort manner to satisfy readers that expect\n-\t\t// the field to be non-empty.\n-\t\ts = toASCII(s)\n-\t\tif len(s) > len(b) {\n-\t\t\ts = s[:len(b)]\n+\t\t// Write the extended header file.\n+\t\tvar name string\n+\t\tvar flag byte\n+\t\tif isGlobal {\n+\t\t\tname = realName\n+\t\t\tif name == \"\" {\n+\t\t\t\tname = \"GlobalHead.0.0\"\n+\t\t\t}\n+\t\t\tflag = TypeXGlobalHeader\n+\t\t} else {\n+\t\t\tdir, file := path.Split(realName)\n+\t\t\tname = path.Join(dir, \"PaxHeaders.0\", file)\n+\t\t\tflag = TypeXHeader\n \t\t}\n-\t\tf.formatString(b, s) // Should never error\n-\t}\n-\tvar formatNumeric = func(b []byte, x int64, paxKeyword string) {\n-\t\t// Try octal first.\n-\t\ts := strconv.FormatInt(x, 8)\n-\t\tif len(s) < len(b) {\n-\t\t\tf.formatOctal(b, x)\n-\t\t\treturn\n+\t\tdata := buf.String()\n+\t\tif err := tw.writeRawFile(name, data, flag, FormatPAX); err != nil || isGlobal {\n+\t\t\treturn err // Global headers return here\n \t\t}\n+\t}\n \n-\t\t// If it is too long for octal, and PAX is preferred, use a PAX header.\n-\t\tif paxKeyword != paxNone && tw.preferPax {\n-\t\t\tf.formatOctal(b, 0)\n-\t\t\ts := strconv.FormatInt(x, 10)\n-\t\t\tpaxHeaders[paxKeyword] = s\n-\t\t\treturn\n+\t// Pack the main header.\n+\tvar f formatter // Ignore errors since they are expected\n+\tfmtStr := func(b []byte, s string) { f.formatString(b, toASCII(s)) }\n+\tblk := tw.templateV7Plus(hdr, fmtStr, f.formatOctal)\n+\tblk.SetFormat(FormatPAX)\n+\tif err := tw.writeRawHeader(blk, hdr.Size, hdr.Typeflag); err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// TODO(dsnet): Re-enable this when adding sparse support.\n+\t// See https://golang.org/issue/22735\n+\t/*\n+\t\t// Write the sparse map and setup the sparse writer if necessary.\n+\t\tif len(spd) > 0 {\n+\t\t\t// Use tw.curr since the sparse map is accounted for in hdr.Size.\n+\t\t\tif _, err := tw.curr.Write(spb); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\ttw.curr = &sparseFileWriter{tw.curr, spd, 0}\n \t\t}\n+\t*/\n+\treturn nil\n+}\n \n-\t\ttw.usedBinary = true\n-\t\tf.formatNumeric(b, x)\n+func (tw *Writer) writeGNUHeader(hdr *Header) error {\n+\t// Use long-link files if Name or Linkname exceeds the field size.\n+\tconst longName = \"././@LongLink\"\n+\tif len(hdr.Name) > nameSize {\n+\t\tdata := hdr.Name + \"\\x00\"\n+\t\tif err := tw.writeRawFile(longName, data, TypeGNULongName, FormatGNU); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tif len(hdr.Linkname) > nameSize {\n+\t\tdata := hdr.Linkname + \"\\x00\"\n+\t\tif err := tw.writeRawFile(longName, data, TypeGNULongLink, FormatGNU); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n-\t// Handle out of range ModTime carefully.\n-\tvar modTime int64\n-\tif !hdr.ModTime.Before(minTime) && !hdr.ModTime.After(maxTime) {\n-\t\tmodTime = hdr.ModTime.Unix()\n+\t// Pack the main header.\n+\tvar f formatter // Ignore errors since they are expected\n+\tvar spd sparseDatas\n+\tvar spb []byte\n+\tblk := tw.templateV7Plus(hdr, f.formatString, f.formatNumeric)\n+\tif !hdr.AccessTime.IsZero() {\n+\t\tf.formatNumeric(blk.GNU().AccessTime(), hdr.AccessTime.Unix())\n+\t}\n+\tif !hdr.ChangeTime.IsZero() {\n+\t\tf.formatNumeric(blk.GNU().ChangeTime(), hdr.ChangeTime.Unix())\n+\t}\n+\t// TODO(dsnet): Re-enable this when adding sparse support.\n+\t// See https://golang.org/issue/22735\n+\t/*\n+\t\tif hdr.Typeflag == TypeGNUSparse {\n+\t\t\tsph := append([]sparseEntry{}, hdr.SparseHoles...) // Copy sparse map\n+\t\t\tsph = alignSparseEntries(sph, hdr.Size)\n+\t\t\tspd = invertSparseEntries(sph, hdr.Size)\n+\n+\t\t\t// Format the sparse map.\n+\t\t\tformatSPD := func(sp sparseDatas, sa sparseArray) sparseDatas {\n+\t\t\t\tfor i := 0; len(sp) > 0 && i < sa.MaxEntries(); i++ {\n+\t\t\t\t\tf.formatNumeric(sa.Entry(i).Offset(), sp[0].Offset)\n+\t\t\t\t\tf.formatNumeric(sa.Entry(i).Length(), sp[0].Length)\n+\t\t\t\t\tsp = sp[1:]\n+\t\t\t\t}\n+\t\t\t\tif len(sp) > 0 {\n+\t\t\t\t\tsa.IsExtended()[0] = 1\n+\t\t\t\t}\n+\t\t\t\treturn sp\n+\t\t\t}\n+\t\t\tsp2 := formatSPD(spd, blk.GNU().Sparse())\n+\t\t\tfor len(sp2) > 0 {\n+\t\t\t\tvar spHdr block\n+\t\t\t\tsp2 = formatSPD(sp2, spHdr.Sparse())\n+\t\t\t\tspb = append(spb, spHdr[:]...)\n+\t\t\t}\n+\n+\t\t\t// Update size fields in the header block.\n+\t\t\trealSize := hdr.Size\n+\t\t\thdr.Size = 0 // Encoded size; does not account for encoded sparse map\n+\t\t\tfor _, s := range spd {\n+\t\t\t\thdr.Size += s.Length\n+\t\t\t}\n+\t\t\tcopy(blk.V7().Size(), zeroBlock[:]) // Reset field\n+\t\t\tf.formatNumeric(blk.V7().Size(), hdr.Size)\n+\t\t\tf.formatNumeric(blk.GNU().RealSize(), realSize)\n+\t\t}\n+\t*/\n+\tblk.SetFormat(FormatGNU)\n+\tif err := tw.writeRawHeader(blk, hdr.Size, hdr.Typeflag); err != nil {\n+\t\treturn err\n \t}\n \n-\tv7 := header.V7()\n-\tformatString(v7.Name(), hdr.Name, paxPath)\n-\t// TODO(dsnet): The GNU format permits the mode field to be encoded in\n-\t// base-256 format. Thus, we can use formatNumeric instead of formatOctal.\n-\tf.formatOctal(v7.Mode(), hdr.Mode)\n-\tformatNumeric(v7.UID(), int64(hdr.Uid), paxUid)\n-\tformatNumeric(v7.GID(), int64(hdr.Gid), paxGid)\n-\tformatNumeric(v7.Size(), hdr.Size, paxSize)\n-\t// TODO(dsnet): Consider using PAX for finer time granularity.\n-\tformatNumeric(v7.ModTime(), modTime, paxNone)\n-\tv7.TypeFlag()[0] = hdr.Typeflag\n-\tformatString(v7.LinkName(), hdr.Linkname, paxLinkpath)\n-\n-\tustar := header.USTAR()\n-\tformatString(ustar.UserName(), hdr.Uname, paxUname)\n-\tformatString(ustar.GroupName(), hdr.Gname, paxGname)\n-\tformatNumeric(ustar.DevMajor(), hdr.Devmajor, paxNone)\n-\tformatNumeric(ustar.DevMinor(), hdr.Devminor, paxNone)\n-\n-\t// TODO(dsnet): The logic surrounding the prefix field is broken when trying\n-\t// to encode the header as GNU format. The challenge with the current logic\n-\t// is that we are unsure what format we are using at any given moment until\n-\t// we have processed *all* of the fields. The problem is that by the time\n-\t// all fields have been processed, some work has already been done to handle\n-\t// each field under the assumption that it is for one given format or\n-\t// another. In some situations, this causes the Writer to be confused and\n-\t// encode a prefix field when the format being used is GNU. Thus, producing\n-\t// an invalid tar file.\n-\t//\n-\t// As a short-term fix, we disable the logic to use the prefix field, which\n-\t// will force the badly generated GNU files to become encoded as being\n-\t// the PAX format.\n-\t//\n-\t// As an alternative fix, we could hard-code preferPax to be true. However,\n-\t// this is problematic for the following reasons:\n-\t//\t* The preferPax functionality is not tested at all.\n-\t//\t* This can result in headers that try to use both the GNU and PAX\n-\t//\tfeatures at the same time, which is also wrong.\n-\t//\n-\t// The proper fix for this is to use a two-pass method:\n-\t//\t* The first pass simply determines what set of formats can possibly\n-\t//\tencode the given header.\n-\t//\t* The second pass actually encodes the header as that given format\n-\t//\twithout worrying about violating the format.\n-\t//\n-\t// See the following:\n-\t//\thttps://golang.org/issue/12594\n-\t//\thttps://golang.org/issue/17630\n-\t//\thttps://golang.org/issue/9683\n-\tconst usePrefix = false\n-\n-\t// try to use a ustar header when only the name is too long\n-\t_, paxPathUsed := paxHeaders[paxPath]\n-\tif usePrefix && !tw.preferPax && len(paxHeaders) == 1 && paxPathUsed {\n-\t\tprefix, suffix, ok := splitUSTARPath(hdr.Name)\n-\t\tif ok {\n-\t\t\t// Since we can encode in USTAR format, disable PAX header.\n-\t\t\tdelete(paxHeaders, paxPath)\n-\n-\t\t\t// Update the path fields\n-\t\t\tformatString(v7.Name(), suffix, paxNone)\n-\t\t\tformatString(ustar.Prefix(), prefix, paxNone)\n+\t// Write the extended sparse map and setup the sparse writer if necessary.\n+\tif len(spd) > 0 {\n+\t\t// Use tw.w since the sparse map is not accounted for in hdr.Size.\n+\t\tif _, err := tw.w.Write(spb); err != nil {\n+\t\t\treturn err\n \t\t}\n+\t\ttw.curr = &sparseFileWriter{tw.curr, spd, 0}\n \t}\n+\treturn nil\n+}\n+\n+type (\n+\tstringFormatter func([]byte, string)\n+\tnumberFormatter func([]byte, int64)\n+)\n \n-\tif tw.usedBinary {\n-\t\theader.SetFormat(formatGNU)\n-\t} else {\n-\t\theader.SetFormat(formatUSTAR)\n+// templateV7Plus fills out the V7 fields of a block using values from hdr.\n+// It also fills out fields (uname, gname, devmajor, devminor) that are\n+// shared in the USTAR, PAX, and GNU formats using the provided formatters.\n+//\n+// The block returned is only valid until the next call to\n+// templateV7Plus or writeRawFile.\n+func (tw *Writer) templateV7Plus(hdr *Header, fmtStr stringFormatter, fmtNum numberFormatter) *block {\n+\ttw.blk.Reset()\n+\n+\tmodTime := hdr.ModTime\n+\tif modTime.IsZero() {\n+\t\tmodTime = time.Unix(0, 0)\n \t}\n \n-\t// Check if there were any formatting errors.\n-\tif f.err != nil {\n-\t\ttw.err = f.err\n-\t\treturn tw.err\n+\tv7 := tw.blk.V7()\n+\tv7.TypeFlag()[0] = hdr.Typeflag\n+\tfmtStr(v7.Name(), hdr.Name)\n+\tfmtStr(v7.LinkName(), hdr.Linkname)\n+\tfmtNum(v7.Mode(), hdr.Mode)\n+\tfmtNum(v7.UID(), int64(hdr.Uid))\n+\tfmtNum(v7.GID(), int64(hdr.Gid))\n+\tfmtNum(v7.Size(), hdr.Size)\n+\tfmtNum(v7.ModTime(), modTime.Unix())\n+\n+\tustar := tw.blk.USTAR()\n+\tfmtStr(ustar.UserName(), hdr.Uname)\n+\tfmtStr(ustar.GroupName(), hdr.Gname)\n+\tfmtNum(ustar.DevMajor(), hdr.Devmajor)\n+\tfmtNum(ustar.DevMinor(), hdr.Devminor)\n+\n+\treturn &tw.blk\n+}\n+\n+// writeRawFile writes a minimal file with the given name and flag type.\n+// It uses format to encode the header format and will write data as the body.\n+// It uses default values for all of the other fields (as BSD and GNU tar does).\n+func (tw *Writer) writeRawFile(name, data string, flag byte, format Format) error {\n+\ttw.blk.Reset()\n+\n+\t// Best effort for the filename.\n+\tname = toASCII(name)\n+\tif len(name) > nameSize {\n+\t\tname = name[:nameSize]\n \t}\n+\tname = strings.TrimRight(name, \"/\")\n \n-\tif allowPax {\n-\t\tfor k, v := range hdr.Xattrs {\n-\t\t\tpaxHeaders[paxXattr+k] = v\n-\t\t}\n+\tvar f formatter\n+\tv7 := tw.blk.V7()\n+\tv7.TypeFlag()[0] = flag\n+\tf.formatString(v7.Name(), name)\n+\tf.formatOctal(v7.Mode(), 0)\n+\tf.formatOctal(v7.UID(), 0)\n+\tf.formatOctal(v7.GID(), 0)\n+\tf.formatOctal(v7.Size(), int64(len(data))) // Must be < 8GiB\n+\tf.formatOctal(v7.ModTime(), 0)\n+\ttw.blk.SetFormat(format)\n+\tif f.err != nil {\n+\t\treturn f.err // Only occurs if size condition is violated\n \t}\n \n-\tif len(paxHeaders) > 0 {\n-\t\tif !allowPax {\n-\t\t\treturn errInvalidHeader\n-\t\t}\n-\t\tif err := tw.writePAXHeader(hdr, paxHeaders); err != nil {\n-\t\t\treturn err\n-\t\t}\n+\t// Write the header and data.\n+\tif err := tw.writeRawHeader(&tw.blk, int64(len(data)), flag); err != nil {\n+\t\treturn err\n \t}\n-\ttw.nb = hdr.Size\n-\ttw.pad = (blockSize - (tw.nb % blockSize)) % blockSize\n+\t_, err := io.WriteString(tw, data)\n+\treturn err\n+}\n \n-\t_, tw.err = tw.w.Write(header[:])\n-\treturn tw.err\n+// writeRawHeader writes the value of blk, regardless of its value.\n+// It sets up the Writer such that it can accept a file of the given size.\n+// If the flag is a special header-only flag, then the size is treated as zero.\n+func (tw *Writer) writeRawHeader(blk *block, size int64, flag byte) error {\n+\tif err := tw.Flush(); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := tw.w.Write(blk[:]); err != nil {\n+\t\treturn err\n+\t}\n+\tif isHeaderOnlyType(flag) {\n+\t\tsize = 0\n+\t}\n+\ttw.curr = &regFileWriter{tw.w, size}\n+\ttw.pad = blockPadding(size)\n+\treturn nil\n }\n \n // splitUSTARPath splits a path according to USTAR prefix and suffix rules.\n@@ -276,95 +412,233 @@ func splitUSTARPath(name string) (prefix, suffix string, ok bool) {\n \treturn name[:i], name[i+1:], true\n }\n \n-// writePaxHeader writes an extended pax header to the\n-// archive.\n-func (tw *Writer) writePAXHeader(hdr *Header, paxHeaders map[string]string) error {\n-\t// Prepare extended header\n-\text := new(Header)\n-\text.Typeflag = TypeXHeader\n-\t// Setting ModTime is required for reader parsing to\n-\t// succeed, and seems harmless enough.\n-\text.ModTime = hdr.ModTime\n-\t// The spec asks that we namespace our pseudo files\n-\t// with the current pid. However, this results in differing outputs\n-\t// for identical inputs. As such, the constant 0 is now used instead.\n-\t// golang.org/issue/12358\n-\tdir, file := path.Split(hdr.Name)\n-\tfullName := path.Join(dir, \"PaxHeaders.0\", file)\n-\n-\tascii := toASCII(fullName)\n-\tif len(ascii) > nameSize {\n-\t\tascii = ascii[:nameSize]\n-\t}\n-\text.Name = ascii\n-\t// Construct the body\n-\tvar buf bytes.Buffer\n-\n-\t// Keys are sorted before writing to body to allow deterministic output.\n-\tkeys := make([]string, 0, len(paxHeaders))\n-\tfor k := range paxHeaders {\n-\t\tkeys = append(keys, k)\n-\t}\n-\tsort.Strings(keys)\n-\n-\tfor _, k := range keys {\n-\t\tfmt.Fprint(&buf, formatPAXRecord(k, paxHeaders[k]))\n-\t}\n-\n-\text.Size = int64(len(buf.Bytes()))\n-\tif err := tw.writeHeader(ext, false); err != nil {\n-\t\treturn err\n-\t}\n-\tif _, err := tw.Write(buf.Bytes()); err != nil {\n-\t\treturn err\n+// Write writes to the current file in the tar archive.\n+// Write returns the error ErrWriteTooLong if more than\n+// Header.Size bytes are written after WriteHeader.\n+//\n+// Calling Write on special types like TypeLink, TypeSymlink, TypeChar,\n+// TypeBlock, TypeDir, and TypeFifo returns (0, ErrWriteTooLong) regardless\n+// of what the Header.Size claims.\n+func (tw *Writer) Write(b []byte) (int, error) {\n+\tif tw.err != nil {\n+\t\treturn 0, tw.err\n \t}\n-\tif err := tw.Flush(); err != nil {\n-\t\treturn err\n+\tn, err := tw.curr.Write(b)\n+\tif err != nil && err != ErrWriteTooLong {\n+\t\ttw.err = err\n \t}\n-\treturn nil\n+\treturn n, err\n }\n \n-// Write writes to the current entry in the tar archive.\n-// Write returns the error ErrWriteTooLong if more than\n-// hdr.Size bytes are written after WriteHeader.\n-func (tw *Writer) Write(b []byte) (n int, err error) {\n-\tif tw.closed {\n-\t\terr = ErrWriteAfterClose\n-\t\treturn\n-\t}\n-\toverwrite := false\n-\tif int64(len(b)) > tw.nb {\n-\t\tb = b[0:tw.nb]\n-\t\toverwrite = true\n-\t}\n-\tn, err = tw.w.Write(b)\n-\ttw.nb -= int64(n)\n-\tif err == nil && overwrite {\n-\t\terr = ErrWriteTooLong\n-\t\treturn\n-\t}\n-\ttw.err = err\n-\treturn\n+// readFrom populates the content of the current file by reading from r.\n+// The bytes read must match the number of remaining bytes in the current file.\n+//\n+// If the current file is sparse and r is an io.ReadSeeker,\n+// then readFrom uses Seek to skip past holes defined in Header.SparseHoles,\n+// assuming that skipped regions are all NULs.\n+// This always reads the last byte to ensure r is the right size.\n+//\n+// TODO(dsnet): Re-export this when adding sparse file support.\n+// See https://golang.org/issue/22735\n+func (tw *Writer) readFrom(r io.Reader) (int64, error) {\n+\tif tw.err != nil {\n+\t\treturn 0, tw.err\n+\t}\n+\tn, err := tw.curr.ReadFrom(r)\n+\tif err != nil && err != ErrWriteTooLong {\n+\t\ttw.err = err\n+\t}\n+\treturn n, err\n }\n \n-// Close closes the tar archive, flushing any unwritten\n-// data to the underlying writer.\n+// Close closes the tar archive by flushing the padding, and writing the footer.\n+// If the current file (from a prior call to WriteHeader) is not fully written,\n+// then this returns an error.\n func (tw *Writer) Close() error {\n-\tif tw.err != nil || tw.closed {\n-\t\treturn tw.err\n+\tif tw.err == ErrWriteAfterClose {\n+\t\treturn nil\n \t}\n-\ttw.Flush()\n-\ttw.closed = true\n \tif tw.err != nil {\n \t\treturn tw.err\n \t}\n \n-\t// trailer: two zero blocks\n-\tfor i := 0; i < 2; i++ {\n-\t\t_, tw.err = tw.w.Write(zeroBlock[:])\n-\t\tif tw.err != nil {\n-\t\t\tbreak\n+\t// Trailer: two zero blocks.\n+\terr := tw.Flush()\n+\tfor i := 0; i < 2 && err == nil; i++ {\n+\t\t_, err = tw.w.Write(zeroBlock[:])\n+\t}\n+\n+\t// Ensure all future actions are invalid.\n+\ttw.err = ErrWriteAfterClose\n+\treturn err // Report IO errors\n+}\n+\n+// regFileWriter is a fileWriter for writing data to a regular file entry.\n+type regFileWriter struct {\n+\tw  io.Writer // Underlying Writer\n+\tnb int64     // Number of remaining bytes to write\n+}\n+\n+func (fw *regFileWriter) Write(b []byte) (n int, err error) {\n+\toverwrite := int64(len(b)) > fw.nb\n+\tif overwrite {\n+\t\tb = b[:fw.nb]\n+\t}\n+\tif len(b) > 0 {\n+\t\tn, err = fw.w.Write(b)\n+\t\tfw.nb -= int64(n)\n+\t}\n+\tswitch {\n+\tcase err != nil:\n+\t\treturn n, err\n+\tcase overwrite:\n+\t\treturn n, ErrWriteTooLong\n+\tdefault:\n+\t\treturn n, nil\n+\t}\n+}\n+\n+func (fw *regFileWriter) ReadFrom(r io.Reader) (int64, error) {\n+\treturn io.Copy(struct{ io.Writer }{fw}, r)\n+}\n+\n+func (fw regFileWriter) LogicalRemaining() int64 {\n+\treturn fw.nb\n+}\n+func (fw regFileWriter) PhysicalRemaining() int64 {\n+\treturn fw.nb\n+}\n+\n+// sparseFileWriter is a fileWriter for writing data to a sparse file entry.\n+type sparseFileWriter struct {\n+\tfw  fileWriter  // Underlying fileWriter\n+\tsp  sparseDatas // Normalized list of data fragments\n+\tpos int64       // Current position in sparse file\n+}\n+\n+func (sw *sparseFileWriter) Write(b []byte) (n int, err error) {\n+\toverwrite := int64(len(b)) > sw.LogicalRemaining()\n+\tif overwrite {\n+\t\tb = b[:sw.LogicalRemaining()]\n+\t}\n+\n+\tb0 := b\n+\tendPos := sw.pos + int64(len(b))\n+\tfor endPos > sw.pos && err == nil {\n+\t\tvar nf int // Bytes written in fragment\n+\t\tdataStart, dataEnd := sw.sp[0].Offset, sw.sp[0].endOffset()\n+\t\tif sw.pos < dataStart { // In a hole fragment\n+\t\t\tbf := b[:min(int64(len(b)), dataStart-sw.pos)]\n+\t\t\tnf, err = zeroWriter{}.Write(bf)\n+\t\t} else { // In a data fragment\n+\t\t\tbf := b[:min(int64(len(b)), dataEnd-sw.pos)]\n+\t\t\tnf, err = sw.fw.Write(bf)\n+\t\t}\n+\t\tb = b[nf:]\n+\t\tsw.pos += int64(nf)\n+\t\tif sw.pos >= dataEnd && len(sw.sp) > 1 {\n+\t\t\tsw.sp = sw.sp[1:] // Ensure last fragment always remains\n+\t\t}\n+\t}\n+\n+\tn = len(b0) - len(b)\n+\tswitch {\n+\tcase err == ErrWriteTooLong:\n+\t\treturn n, errMissData // Not possible; implies bug in validation logic\n+\tcase err != nil:\n+\t\treturn n, err\n+\tcase sw.LogicalRemaining() == 0 && sw.PhysicalRemaining() > 0:\n+\t\treturn n, errUnrefData // Not possible; implies bug in validation logic\n+\tcase overwrite:\n+\t\treturn n, ErrWriteTooLong\n+\tdefault:\n+\t\treturn n, nil\n+\t}\n+}\n+\n+func (sw *sparseFileWriter) ReadFrom(r io.Reader) (n int64, err error) {\n+\trs, ok := r.(io.ReadSeeker)\n+\tif ok {\n+\t\tif _, err := rs.Seek(0, io.SeekCurrent); err != nil {\n+\t\t\tok = false // Not all io.Seeker can really seek\n+\t\t}\n+\t}\n+\tif !ok {\n+\t\treturn io.Copy(struct{ io.Writer }{sw}, r)\n+\t}\n+\n+\tvar readLastByte bool\n+\tpos0 := sw.pos\n+\tfor sw.LogicalRemaining() > 0 && !readLastByte && err == nil {\n+\t\tvar nf int64 // Size of fragment\n+\t\tdataStart, dataEnd := sw.sp[0].Offset, sw.sp[0].endOffset()\n+\t\tif sw.pos < dataStart { // In a hole fragment\n+\t\t\tnf = dataStart - sw.pos\n+\t\t\tif sw.PhysicalRemaining() == 0 {\n+\t\t\t\treadLastByte = true\n+\t\t\t\tnf--\n+\t\t\t}\n+\t\t\t_, err = rs.Seek(nf, io.SeekCurrent)\n+\t\t} else { // In a data fragment\n+\t\t\tnf = dataEnd - sw.pos\n+\t\t\tnf, err = io.CopyN(sw.fw, rs, nf)\n \t\t}\n+\t\tsw.pos += nf\n+\t\tif sw.pos >= dataEnd && len(sw.sp) > 1 {\n+\t\t\tsw.sp = sw.sp[1:] // Ensure last fragment always remains\n+\t\t}\n+\t}\n+\n+\t// If the last fragment is a hole, then seek to 1-byte before EOF, and\n+\t// read a single byte to ensure the file is the right size.\n+\tif readLastByte && err == nil {\n+\t\t_, err = mustReadFull(rs, []byte{0})\n+\t\tsw.pos++\n+\t}\n+\n+\tn = sw.pos - pos0\n+\tswitch {\n+\tcase err == io.EOF:\n+\t\treturn n, io.ErrUnexpectedEOF\n+\tcase err == ErrWriteTooLong:\n+\t\treturn n, errMissData // Not possible; implies bug in validation logic\n+\tcase err != nil:\n+\t\treturn n, err\n+\tcase sw.LogicalRemaining() == 0 && sw.PhysicalRemaining() > 0:\n+\t\treturn n, errUnrefData // Not possible; implies bug in validation logic\n+\tdefault:\n+\t\treturn n, ensureEOF(rs)\n+\t}\n+}\n+\n+func (sw sparseFileWriter) LogicalRemaining() int64 {\n+\treturn sw.sp[len(sw.sp)-1].endOffset() - sw.pos\n+}\n+func (sw sparseFileWriter) PhysicalRemaining() int64 {\n+\treturn sw.fw.PhysicalRemaining()\n+}\n+\n+// zeroWriter may only be written with NULs, otherwise it returns errWriteHole.\n+type zeroWriter struct{}\n+\n+func (zeroWriter) Write(b []byte) (int, error) {\n+\tfor i, c := range b {\n+\t\tif c != 0 {\n+\t\t\treturn i, errWriteHole\n+\t\t}\n+\t}\n+\treturn len(b), nil\n+}\n+\n+// ensureEOF checks whether r is at EOF, reporting ErrWriteTooLong if not so.\n+func ensureEOF(r io.Reader) error {\n+\tn, err := tryReadFull(r, []byte{0})\n+\tswitch {\n+\tcase n > 0:\n+\t\treturn ErrWriteTooLong\n+\tcase err == io.EOF:\n+\t\treturn nil\n+\tdefault:\n+\t\treturn err\n \t}\n-\treturn tw.err\n }"}, {"sha": "24e8da271c220798f84f2f01ef48357c68e00219", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 825, "deletions": 170, "changes": 995, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -6,10 +6,12 @@ package tar\n \n import (\n \t\"bytes\"\n-\t\"fmt\"\n+\t\"encoding/hex\"\n+\t\"errors\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"path\"\n \t\"reflect\"\n \t\"sort\"\n \t\"strings\"\n@@ -18,120 +20,127 @@ import (\n \t\"time\"\n )\n \n-// Render byte array in a two-character hexadecimal string, spaced for easy visual inspection.\n-func bytestr(offset int, b []byte) string {\n-\tconst rowLen = 32\n-\ts := fmt.Sprintf(\"%04x \", offset)\n-\tfor _, ch := range b {\n-\t\tswitch {\n-\t\tcase '0' <= ch && ch <= '9', 'A' <= ch && ch <= 'Z', 'a' <= ch && ch <= 'z':\n-\t\t\ts += fmt.Sprintf(\"  %c\", ch)\n-\t\tdefault:\n-\t\t\ts += fmt.Sprintf(\" %02x\", ch)\n+func bytediff(a, b []byte) string {\n+\tconst (\n+\t\tuniqueA  = \"-  \"\n+\t\tuniqueB  = \"+  \"\n+\t\tidentity = \"   \"\n+\t)\n+\tvar ss []string\n+\tsa := strings.Split(strings.TrimSpace(hex.Dump(a)), \"\\n\")\n+\tsb := strings.Split(strings.TrimSpace(hex.Dump(b)), \"\\n\")\n+\tfor len(sa) > 0 && len(sb) > 0 {\n+\t\tif sa[0] == sb[0] {\n+\t\t\tss = append(ss, identity+sa[0])\n+\t\t} else {\n+\t\t\tss = append(ss, uniqueA+sa[0])\n+\t\t\tss = append(ss, uniqueB+sb[0])\n \t\t}\n+\t\tsa, sb = sa[1:], sb[1:]\n+\t}\n+\tfor len(sa) > 0 {\n+\t\tss = append(ss, uniqueA+sa[0])\n+\t\tsa = sa[1:]\n+\t}\n+\tfor len(sb) > 0 {\n+\t\tss = append(ss, uniqueB+sb[0])\n+\t\tsb = sb[1:]\n \t}\n-\treturn s\n+\treturn strings.Join(ss, \"\\n\")\n }\n \n-// Render a pseudo-diff between two blocks of bytes.\n-func bytediff(a []byte, b []byte) string {\n-\tconst rowLen = 32\n-\ts := fmt.Sprintf(\"(%d bytes vs. %d bytes)\\n\", len(a), len(b))\n-\tfor offset := 0; len(a)+len(b) > 0; offset += rowLen {\n-\t\tna, nb := rowLen, rowLen\n-\t\tif na > len(a) {\n-\t\t\tna = len(a)\n+func TestWriter(t *testing.T) {\n+\ttype (\n+\t\ttestHeader struct { // WriteHeader(hdr) == wantErr\n+\t\t\thdr     Header\n+\t\t\twantErr error\n \t\t}\n-\t\tif nb > len(b) {\n-\t\t\tnb = len(b)\n+\t\ttestWrite struct { // Write(str) == (wantCnt, wantErr)\n+\t\t\tstr     string\n+\t\t\twantCnt int\n+\t\t\twantErr error\n \t\t}\n-\t\tsa := bytestr(offset, a[0:na])\n-\t\tsb := bytestr(offset, b[0:nb])\n-\t\tif sa != sb {\n-\t\t\ts += fmt.Sprintf(\"-%v\\n+%v\\n\", sa, sb)\n+\t\ttestReadFrom struct { // ReadFrom(testFile{ops}) == (wantCnt, wantErr)\n+\t\t\tops     fileOps\n+\t\t\twantCnt int64\n+\t\t\twantErr error\n \t\t}\n-\t\ta = a[na:]\n-\t\tb = b[nb:]\n-\t}\n-\treturn s\n-}\n-\n-func TestWriter(t *testing.T) {\n-\ttype entry struct {\n-\t\theader   *Header\n-\t\tcontents string\n-\t}\n+\t\ttestClose struct { // Close() == wantErr\n+\t\t\twantErr error\n+\t\t}\n+\t\ttestFnc interface{} // testHeader | testWrite | testReadFrom | testClose\n+\t)\n \n \tvectors := []struct {\n-\t\tfile    string // filename of expected output\n-\t\tentries []*entry\n+\t\tfile  string // Optional filename of expected output\n+\t\ttests []testFnc\n \t}{{\n \t\t// The writer test file was produced with this command:\n \t\t// tar (GNU tar) 1.26\n \t\t//   ln -s small.txt link.txt\n \t\t//   tar -b 1 --format=ustar -c -f writer.tar small.txt small2.txt link.txt\n \t\tfile: \"testdata/writer.tar\",\n-\t\tentries: []*entry{{\n-\t\t\theader: &Header{\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n \t\t\t\tName:     \"small.txt\",\n+\t\t\t\tSize:     5,\n \t\t\t\tMode:     0640,\n \t\t\t\tUid:      73025,\n \t\t\t\tGid:      5000,\n-\t\t\t\tSize:     5,\n-\t\t\t\tModTime:  time.Unix(1246508266, 0),\n-\t\t\t\tTypeflag: '0',\n \t\t\t\tUname:    \"dsymonds\",\n \t\t\t\tGname:    \"eng\",\n-\t\t\t},\n-\t\t\tcontents: \"Kilts\",\n-\t\t}, {\n-\t\t\theader: &Header{\n+\t\t\t\tModTime:  time.Unix(1246508266, 0),\n+\t\t\t}, nil},\n+\t\t\ttestWrite{\"Kilts\", 5, nil},\n+\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n \t\t\t\tName:     \"small2.txt\",\n+\t\t\t\tSize:     11,\n \t\t\t\tMode:     0640,\n \t\t\t\tUid:      73025,\n-\t\t\t\tGid:      5000,\n-\t\t\t\tSize:     11,\n-\t\t\t\tModTime:  time.Unix(1245217492, 0),\n-\t\t\t\tTypeflag: '0',\n \t\t\t\tUname:    \"dsymonds\",\n \t\t\t\tGname:    \"eng\",\n-\t\t\t},\n-\t\t\tcontents: \"Google.com\\n\",\n-\t\t}, {\n-\t\t\theader: &Header{\n+\t\t\t\tGid:      5000,\n+\t\t\t\tModTime:  time.Unix(1245217492, 0),\n+\t\t\t}, nil},\n+\t\t\ttestWrite{\"Google.com\\n\", 11, nil},\n+\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeSymlink,\n \t\t\t\tName:     \"link.txt\",\n+\t\t\t\tLinkname: \"small.txt\",\n \t\t\t\tMode:     0777,\n \t\t\t\tUid:      1000,\n \t\t\t\tGid:      1000,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1314603082, 0),\n-\t\t\t\tTypeflag: '2',\n-\t\t\t\tLinkname: \"small.txt\",\n \t\t\t\tUname:    \"strings\",\n \t\t\t\tGname:    \"strings\",\n-\t\t\t},\n-\t\t\t// no contents\n-\t\t}},\n+\t\t\t\tModTime:  time.Unix(1314603082, 0),\n+\t\t\t}, nil},\n+\t\t\ttestWrite{\"\", 0, nil},\n+\n+\t\t\ttestClose{nil},\n+\t\t},\n \t}, {\n \t\t// The truncated test file was produced using these commands:\n \t\t//   dd if=/dev/zero bs=1048576 count=16384 > /tmp/16gig.txt\n \t\t//   tar -b 1 -c -f- /tmp/16gig.txt | dd bs=512 count=8 > writer-big.tar\n \t\tfile: \"testdata/writer-big.tar\",\n-\t\tentries: []*entry{{\n-\t\t\theader: &Header{\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n \t\t\t\tName:     \"tmp/16gig.txt\",\n+\t\t\t\tSize:     16 << 30,\n \t\t\t\tMode:     0640,\n \t\t\t\tUid:      73025,\n \t\t\t\tGid:      5000,\n-\t\t\t\tSize:     16 << 30,\n-\t\t\t\tModTime:  time.Unix(1254699560, 0),\n-\t\t\t\tTypeflag: '0',\n \t\t\t\tUname:    \"dsymonds\",\n \t\t\t\tGname:    \"eng\",\n-\t\t\t},\n-\t\t\t// fake contents\n-\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n-\t\t}},\n+\t\t\t\tModTime:  time.Unix(1254699560, 0),\n+\t\t\t\tFormat:   FormatGNU,\n+\t\t\t}, nil},\n+\t\t},\n \t}, {\n \t\t// This truncated file was produced using this library.\n \t\t// It was verified to work with GNU tar 1.27.1 and BSD tar 3.1.2.\n@@ -141,117 +150,377 @@ func TestWriter(t *testing.T) {\n \t\t//\n \t\t// This file is in PAX format.\n \t\tfile: \"testdata/writer-big-long.tar\",\n-\t\tentries: []*entry{{\n-\t\t\theader: &Header{\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n \t\t\t\tName:     strings.Repeat(\"longname/\", 15) + \"16gig.txt\",\n+\t\t\t\tSize:     16 << 30,\n \t\t\t\tMode:     0644,\n \t\t\t\tUid:      1000,\n \t\t\t\tGid:      1000,\n-\t\t\t\tSize:     16 << 30,\n-\t\t\t\tModTime:  time.Unix(1399583047, 0),\n-\t\t\t\tTypeflag: '0',\n \t\t\t\tUname:    \"guillaume\",\n \t\t\t\tGname:    \"guillaume\",\n-\t\t\t},\n-\t\t\t// fake contents\n-\t\t\tcontents: strings.Repeat(\"\\x00\", 4<<10),\n-\t\t}},\n-\t}, {\n-\t\t// TODO(dsnet): The Writer output should match the following file.\n-\t\t// To fix an issue (see https://golang.org/issue/12594), we disabled\n-\t\t// prefix support, which alters the generated output.\n-\t\t/*\n-\t\t\t// This file was produced using gnu tar 1.17\n-\t\t\t// gnutar  -b 4 --format=ustar (longname/)*15 + file.txt\n-\t\t\tfile: \"testdata/ustar.tar\"\n-\t\t*/\n-\t\tfile: \"testdata/ustar.issue12594.tar\", // This is a valid tar file, but not expected\n-\t\tentries: []*entry{{\n-\t\t\theader: &Header{\n+\t\t\t\tModTime:  time.Unix(1399583047, 0),\n+\t\t\t}, nil},\n+\t\t},\n+\t}, {\n+\t\t// This file was produced using GNU tar v1.17.\n+\t\t//\tgnutar -b 4 --format=ustar (longname/)*15 + file.txt\n+\t\tfile: \"testdata/ustar.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n \t\t\t\tName:     strings.Repeat(\"longname/\", 15) + \"file.txt\",\n+\t\t\t\tSize:     6,\n \t\t\t\tMode:     0644,\n-\t\t\t\tUid:      0765,\n-\t\t\t\tGid:      024,\n-\t\t\t\tSize:     06,\n-\t\t\t\tModTime:  time.Unix(1360135598, 0),\n-\t\t\t\tTypeflag: '0',\n+\t\t\t\tUid:      501,\n+\t\t\t\tGid:      20,\n \t\t\t\tUname:    \"shane\",\n \t\t\t\tGname:    \"staff\",\n-\t\t\t},\n-\t\t\tcontents: \"hello\\n\",\n-\t\t}},\n-\t}, {\n-\t\t// This file was produced using gnu tar 1.26\n-\t\t// echo \"Slartibartfast\" > file.txt\n-\t\t// ln file.txt hard.txt\n-\t\t// tar -b 1 --format=ustar -c -f hardlink.tar file.txt hard.txt\n+\t\t\t\tModTime:  time.Unix(1360135598, 0),\n+\t\t\t}, nil},\n+\t\t\ttestWrite{\"hello\\n\", 6, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n+\t}, {\n+\t\t// This file was produced using GNU tar v1.26:\n+\t\t//\techo \"Slartibartfast\" > file.txt\n+\t\t//\tln file.txt hard.txt\n+\t\t//\ttar -b 1 --format=ustar -c -f hardlink.tar file.txt hard.txt\n \t\tfile: \"testdata/hardlink.tar\",\n-\t\tentries: []*entry{{\n-\t\t\theader: &Header{\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n \t\t\t\tName:     \"file.txt\",\n+\t\t\t\tSize:     15,\n \t\t\t\tMode:     0644,\n \t\t\t\tUid:      1000,\n \t\t\t\tGid:      100,\n-\t\t\t\tSize:     15,\n-\t\t\t\tModTime:  time.Unix(1425484303, 0),\n-\t\t\t\tTypeflag: '0',\n \t\t\t\tUname:    \"vbatts\",\n \t\t\t\tGname:    \"users\",\n-\t\t\t},\n-\t\t\tcontents: \"Slartibartfast\\n\",\n-\t\t}, {\n-\t\t\theader: &Header{\n+\t\t\t\tModTime:  time.Unix(1425484303, 0),\n+\t\t\t}, nil},\n+\t\t\ttestWrite{\"Slartibartfast\\n\", 15, nil},\n+\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeLink,\n \t\t\t\tName:     \"hard.txt\",\n+\t\t\t\tLinkname: \"file.txt\",\n \t\t\t\tMode:     0644,\n \t\t\t\tUid:      1000,\n \t\t\t\tGid:      100,\n-\t\t\t\tSize:     0,\n-\t\t\t\tModTime:  time.Unix(1425484303, 0),\n-\t\t\t\tTypeflag: '1',\n-\t\t\t\tLinkname: \"file.txt\",\n \t\t\t\tUname:    \"vbatts\",\n \t\t\t\tGname:    \"users\",\n-\t\t\t},\n-\t\t\t// no contents\n-\t\t}},\n+\t\t\t\tModTime:  time.Unix(1425484303, 0),\n+\t\t\t}, nil},\n+\t\t\ttestWrite{\"\", 0, nil},\n+\n+\t\t\ttestClose{nil},\n+\t\t},\n+\t}, {\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\tName:     \"bad-null.txt\",\n+\t\t\t\tXattrs:   map[string]string{\"null\\x00null\\x00\": \"fizzbuzz\"},\n+\t\t\t}, headerError{}},\n+\t\t},\n+\t}, {\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\tName:     \"null\\x00.txt\",\n+\t\t\t}, headerError{}},\n+\t\t},\n+\t}, {\n+\t\tfile: \"testdata/pax-records.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\tName:     \"file\",\n+\t\t\t\tUname:    strings.Repeat(\"long\", 10),\n+\t\t\t\tPAXRecords: map[string]string{\n+\t\t\t\t\t\"path\":           \"FILE\", // Should be ignored\n+\t\t\t\t\t\"GNU.sparse.map\": \"0,0\",  // Should be ignored\n+\t\t\t\t\t\"comment\":        \"Hello, \u4e16\u754c\",\n+\t\t\t\t\t\"GOLANG.pkg\":     \"tar\",\n+\t\t\t\t},\n+\t\t\t}, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n+\t}, {\n+\t\t// Craft a theoretically valid PAX archive with global headers.\n+\t\t// The GNU and BSD tar tools do not parse these the same way.\n+\t\t//\n+\t\t// BSD tar v3.1.2 parses and ignores all global headers;\n+\t\t// the behavior is verified by researching the source code.\n+\t\t//\n+\t\t//\t$ bsdtar -tvf pax-global-records.tar\n+\t\t//\t----------  0 0      0           0 Dec 31  1969 file1\n+\t\t//\t----------  0 0      0           0 Dec 31  1969 file2\n+\t\t//\t----------  0 0      0           0 Dec 31  1969 file3\n+\t\t//\t----------  0 0      0           0 May 13  2014 file4\n+\t\t//\n+\t\t// GNU tar v1.27.1 applies global headers to subsequent records,\n+\t\t// but does not do the following properly:\n+\t\t//\t* It does not treat an empty record as deletion.\n+\t\t//\t* It does not use subsequent global headers to update previous ones.\n+\t\t//\n+\t\t//\t$ gnutar -tvf pax-global-records.tar\n+\t\t//\t---------- 0/0               0 2017-07-13 19:40 global1\n+\t\t//\t---------- 0/0               0 2017-07-13 19:40 file2\n+\t\t//\tgnutar: Substituting `.' for empty member name\n+\t\t//\t---------- 0/0               0 1969-12-31 16:00\n+\t\t//\tgnutar: Substituting `.' for empty member name\n+\t\t//\t---------- 0/0               0 2014-05-13 09:53\n+\t\t//\n+\t\t// According to the PAX specification, this should have been the result:\n+\t\t//\t---------- 0/0               0 2017-07-13 19:40 global1\n+\t\t//\t---------- 0/0               0 2017-07-13 19:40 file2\n+\t\t//\t---------- 0/0               0 2017-07-13 19:40 file3\n+\t\t//\t---------- 0/0               0 2014-05-13 09:53 file4\n+\t\tfile: \"testdata/pax-global-records.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag:   TypeXGlobalHeader,\n+\t\t\t\tPAXRecords: map[string]string{\"path\": \"global1\", \"mtime\": \"1500000000.0\"},\n+\t\t\t}, nil},\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg, Name: \"file1\",\n+\t\t\t}, nil},\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag:   TypeReg,\n+\t\t\t\tName:       \"file2\",\n+\t\t\t\tPAXRecords: map[string]string{\"path\": \"file2\"},\n+\t\t\t}, nil},\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag:   TypeXGlobalHeader,\n+\t\t\t\tPAXRecords: map[string]string{\"path\": \"\"}, // Should delete \"path\", but keep \"mtime\"\n+\t\t\t}, nil},\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg, Name: \"file3\",\n+\t\t\t}, nil},\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag:   TypeReg,\n+\t\t\t\tName:       \"file4\",\n+\t\t\t\tModTime:    time.Unix(1400000000, 0),\n+\t\t\t\tPAXRecords: map[string]string{\"mtime\": \"1400000000\"},\n+\t\t\t}, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n+\t}, {\n+\t\tfile: \"testdata/gnu-utf8.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\tName:     \"\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\u263a\u263b\u2639\",\n+\t\t\t\tMode:     0644,\n+\t\t\t\tUid:      1000, Gid: 1000,\n+\t\t\t\tUname:   \"\u263a\",\n+\t\t\t\tGname:   \"\u26b9\",\n+\t\t\t\tModTime: time.Unix(0, 0),\n+\t\t\t\tFormat:  FormatGNU,\n+\t\t\t}, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n+\t}, {\n+\t\tfile: \"testdata/gnu-not-utf8.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{\n+\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\tName:     \"hi\\x80\\x81\\x82\\x83bye\",\n+\t\t\t\tMode:     0644,\n+\t\t\t\tUid:      1000,\n+\t\t\t\tGid:      1000,\n+\t\t\t\tUname:    \"rawr\",\n+\t\t\t\tGname:    \"dsnet\",\n+\t\t\t\tModTime:  time.Unix(0, 0),\n+\t\t\t\tFormat:   FormatGNU,\n+\t\t\t}, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n+\t\t// TODO(dsnet): Re-enable this test when adding sparse support.\n+\t\t// See https://golang.org/issue/22735\n+\t\t/*\n+\t\t\t}, {\n+\t\t\t\tfile: \"testdata/gnu-nil-sparse-data.tar\",\n+\t\t\t\ttests: []testFnc{\n+\t\t\t\t\ttestHeader{Header{\n+\t\t\t\t\t\tTypeflag:    TypeGNUSparse,\n+\t\t\t\t\t\tName:        \"sparse.db\",\n+\t\t\t\t\t\tSize:        1000,\n+\t\t\t\t\t\tSparseHoles: []sparseEntry{{Offset: 1000, Length: 0}},\n+\t\t\t\t\t}, nil},\n+\t\t\t\t\ttestWrite{strings.Repeat(\"0123456789\", 100), 1000, nil},\n+\t\t\t\t\ttestClose{},\n+\t\t\t\t},\n+\t\t\t}, {\n+\t\t\t\tfile: \"testdata/gnu-nil-sparse-hole.tar\",\n+\t\t\t\ttests: []testFnc{\n+\t\t\t\t\ttestHeader{Header{\n+\t\t\t\t\t\tTypeflag:    TypeGNUSparse,\n+\t\t\t\t\t\tName:        \"sparse.db\",\n+\t\t\t\t\t\tSize:        1000,\n+\t\t\t\t\t\tSparseHoles: []sparseEntry{{Offset: 0, Length: 1000}},\n+\t\t\t\t\t}, nil},\n+\t\t\t\t\ttestWrite{strings.Repeat(\"\\x00\", 1000), 1000, nil},\n+\t\t\t\t\ttestClose{},\n+\t\t\t\t},\n+\t\t\t}, {\n+\t\t\t\tfile: \"testdata/pax-nil-sparse-data.tar\",\n+\t\t\t\ttests: []testFnc{\n+\t\t\t\t\ttestHeader{Header{\n+\t\t\t\t\t\tTypeflag:    TypeReg,\n+\t\t\t\t\t\tName:        \"sparse.db\",\n+\t\t\t\t\t\tSize:        1000,\n+\t\t\t\t\t\tSparseHoles: []sparseEntry{{Offset: 1000, Length: 0}},\n+\t\t\t\t\t}, nil},\n+\t\t\t\t\ttestWrite{strings.Repeat(\"0123456789\", 100), 1000, nil},\n+\t\t\t\t\ttestClose{},\n+\t\t\t\t},\n+\t\t\t}, {\n+\t\t\t\tfile: \"testdata/pax-nil-sparse-hole.tar\",\n+\t\t\t\ttests: []testFnc{\n+\t\t\t\t\ttestHeader{Header{\n+\t\t\t\t\t\tTypeflag:    TypeReg,\n+\t\t\t\t\t\tName:        \"sparse.db\",\n+\t\t\t\t\t\tSize:        1000,\n+\t\t\t\t\t\tSparseHoles: []sparseEntry{{Offset: 0, Length: 1000}},\n+\t\t\t\t\t}, nil},\n+\t\t\t\t\ttestWrite{strings.Repeat(\"\\x00\", 1000), 1000, nil},\n+\t\t\t\t\ttestClose{},\n+\t\t\t\t},\n+\t\t\t}, {\n+\t\t\t\tfile: \"testdata/gnu-sparse-big.tar\",\n+\t\t\t\ttests: []testFnc{\n+\t\t\t\t\ttestHeader{Header{\n+\t\t\t\t\t\tTypeflag: TypeGNUSparse,\n+\t\t\t\t\t\tName:     \"gnu-sparse\",\n+\t\t\t\t\t\tSize:     6e10,\n+\t\t\t\t\t\tSparseHoles: []sparseEntry{\n+\t\t\t\t\t\t\t{Offset: 0e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 1e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 2e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 3e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 4e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 5e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}, nil},\n+\t\t\t\t\ttestReadFrom{fileOps{\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t}, 6e10, nil},\n+\t\t\t\t\ttestClose{nil},\n+\t\t\t\t},\n+\t\t\t}, {\n+\t\t\t\tfile: \"testdata/pax-sparse-big.tar\",\n+\t\t\t\ttests: []testFnc{\n+\t\t\t\t\ttestHeader{Header{\n+\t\t\t\t\t\tTypeflag: TypeReg,\n+\t\t\t\t\t\tName:     \"pax-sparse\",\n+\t\t\t\t\t\tSize:     6e10,\n+\t\t\t\t\t\tSparseHoles: []sparseEntry{\n+\t\t\t\t\t\t\t{Offset: 0e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 1e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 2e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 3e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 4e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t\t{Offset: 5e10, Length: 1e10 - 100},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t}, nil},\n+\t\t\t\t\ttestReadFrom{fileOps{\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t\tint64(1e10 - blockSize),\n+\t\t\t\t\t\tstrings.Repeat(\"\\x00\", blockSize-100) + strings.Repeat(\"0123456789\", 10),\n+\t\t\t\t\t}, 6e10, nil},\n+\t\t\t\t\ttestClose{nil},\n+\t\t\t\t},\n+\t\t*/\n+\t}, {\n+\t\tfile: \"testdata/trailing-slash.tar\",\n+\t\ttests: []testFnc{\n+\t\t\ttestHeader{Header{Name: strings.Repeat(\"123456789/\", 30)}, nil},\n+\t\t\ttestClose{nil},\n+\t\t},\n \t}}\n \n-testLoop:\n-\tfor i, v := range vectors {\n-\t\texpected, err := ioutil.ReadFile(v.file)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %d: Unexpected error: %v\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tbuf := new(bytes.Buffer)\n-\t\ttw := NewWriter(iotest.TruncateWriter(buf, 4<<10)) // only catch the first 4 KB\n-\t\tbig := false\n-\t\tfor j, entry := range v.entries {\n-\t\t\tbig = big || entry.header.Size > 1<<10\n-\t\t\tif err := tw.WriteHeader(entry.header); err != nil {\n-\t\t\t\tt.Errorf(\"test %d, entry %d: Failed writing header: %v\", i, j, err)\n-\t\t\t\tcontinue testLoop\n-\t\t\t}\n-\t\t\tif _, err := io.WriteString(tw, entry.contents); err != nil {\n-\t\t\t\tt.Errorf(\"test %d, entry %d: Failed writing contents: %v\", i, j, err)\n-\t\t\t\tcontinue testLoop\n-\t\t\t}\n-\t\t}\n-\t\t// Only interested in Close failures for the small tests.\n-\t\tif err := tw.Close(); err != nil && !big {\n-\t\t\tt.Errorf(\"test %d: Failed closing archive: %v\", i, err)\n-\t\t\tcontinue testLoop\n+\tequalError := func(x, y error) bool {\n+\t\t_, ok1 := x.(headerError)\n+\t\t_, ok2 := y.(headerError)\n+\t\tif ok1 || ok2 {\n+\t\t\treturn ok1 && ok2\n \t\t}\n+\t\treturn x == y\n+\t}\n+\tfor _, v := range vectors {\n+\t\tt.Run(path.Base(v.file), func(t *testing.T) {\n+\t\t\tconst maxSize = 10 << 10 // 10KiB\n+\t\t\tbuf := new(bytes.Buffer)\n+\t\t\ttw := NewWriter(iotest.TruncateWriter(buf, maxSize))\n \n-\t\tactual := buf.Bytes()\n-\t\tif !bytes.Equal(expected, actual) {\n-\t\t\tt.Errorf(\"test %d: Incorrect result: (-=expected, +=actual)\\n%v\",\n-\t\t\t\ti, bytediff(expected, actual))\n-\t\t}\n-\t\tif testing.Short() { // The second test is expensive.\n-\t\t\tbreak\n-\t\t}\n+\t\t\tfor i, tf := range v.tests {\n+\t\t\t\tswitch tf := tf.(type) {\n+\t\t\t\tcase testHeader:\n+\t\t\t\t\terr := tw.WriteHeader(&tf.hdr)\n+\t\t\t\t\tif !equalError(err, tf.wantErr) {\n+\t\t\t\t\t\tt.Fatalf(\"test %d, WriteHeader() = %v, want %v\", i, err, tf.wantErr)\n+\t\t\t\t\t}\n+\t\t\t\tcase testWrite:\n+\t\t\t\t\tgot, err := tw.Write([]byte(tf.str))\n+\t\t\t\t\tif got != tf.wantCnt || !equalError(err, tf.wantErr) {\n+\t\t\t\t\t\tt.Fatalf(\"test %d, Write() = (%d, %v), want (%d, %v)\", i, got, err, tf.wantCnt, tf.wantErr)\n+\t\t\t\t\t}\n+\t\t\t\tcase testReadFrom:\n+\t\t\t\t\tf := &testFile{ops: tf.ops}\n+\t\t\t\t\tgot, err := tw.readFrom(f)\n+\t\t\t\t\tif _, ok := err.(testError); ok {\n+\t\t\t\t\t\tt.Errorf(\"test %d, ReadFrom(): %v\", i, err)\n+\t\t\t\t\t} else if got != tf.wantCnt || !equalError(err, tf.wantErr) {\n+\t\t\t\t\t\tt.Errorf(\"test %d, ReadFrom() = (%d, %v), want (%d, %v)\", i, got, err, tf.wantCnt, tf.wantErr)\n+\t\t\t\t\t}\n+\t\t\t\t\tif len(f.ops) > 0 {\n+\t\t\t\t\t\tt.Errorf(\"test %d, expected %d more operations\", i, len(f.ops))\n+\t\t\t\t\t}\n+\t\t\t\tcase testClose:\n+\t\t\t\t\terr := tw.Close()\n+\t\t\t\t\tif !equalError(err, tf.wantErr) {\n+\t\t\t\t\t\tt.Fatalf(\"test %d, Close() = %v, want %v\", i, err, tf.wantErr)\n+\t\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\tt.Fatalf(\"test %d, unknown test operation: %T\", i, tf)\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif v.file != \"\" {\n+\t\t\t\twant, err := ioutil.ReadFile(v.file)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"ReadFile() = %v, want nil\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := buf.Bytes()\n+\t\t\t\tif !bytes.Equal(want, got) {\n+\t\t\t\t\tt.Fatalf(\"incorrect result: (-got +want)\\n%v\", bytediff(got, want))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -546,21 +815,104 @@ func TestValidTypeflagWithPAXHeader(t *testing.T) {\n \t}\n }\n \n-func TestWriteAfterClose(t *testing.T) {\n-\tvar buffer bytes.Buffer\n-\ttw := NewWriter(&buffer)\n+// failOnceWriter fails exactly once and then always reports success.\n+type failOnceWriter bool\n \n-\thdr := &Header{\n-\t\tName: \"small.txt\",\n-\t\tSize: 5,\n-\t}\n-\tif err := tw.WriteHeader(hdr); err != nil {\n-\t\tt.Fatalf(\"Failed to write header: %s\", err)\n-\t}\n-\ttw.Close()\n-\tif _, err := tw.Write([]byte(\"Kilts\")); err != ErrWriteAfterClose {\n-\t\tt.Fatalf(\"Write: got %v; want ErrWriteAfterClose\", err)\n+func (w *failOnceWriter) Write(b []byte) (int, error) {\n+\tif !*w {\n+\t\treturn 0, io.ErrShortWrite\n \t}\n+\t*w = true\n+\treturn len(b), nil\n+}\n+\n+func TestWriterErrors(t *testing.T) {\n+\tt.Run(\"HeaderOnly\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(bytes.Buffer))\n+\t\thdr := &Header{Name: \"dir/\", Typeflag: TypeDir}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\tt.Fatalf(\"WriteHeader() = %v, want nil\", err)\n+\t\t}\n+\t\tif _, err := tw.Write([]byte{0x00}); err != ErrWriteTooLong {\n+\t\t\tt.Fatalf(\"Write() = %v, want %v\", err, ErrWriteTooLong)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"NegativeSize\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(bytes.Buffer))\n+\t\thdr := &Header{Name: \"small.txt\", Size: -1}\n+\t\tif err := tw.WriteHeader(hdr); err == nil {\n+\t\t\tt.Fatalf(\"WriteHeader() = nil, want non-nil error\")\n+\t\t}\n+\t})\n+\n+\tt.Run(\"BeforeHeader\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(bytes.Buffer))\n+\t\tif _, err := tw.Write([]byte(\"Kilts\")); err != ErrWriteTooLong {\n+\t\t\tt.Fatalf(\"Write() = %v, want %v\", err, ErrWriteTooLong)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"AfterClose\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(bytes.Buffer))\n+\t\thdr := &Header{Name: \"small.txt\"}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\tt.Fatalf(\"WriteHeader() = %v, want nil\", err)\n+\t\t}\n+\t\tif err := tw.Close(); err != nil {\n+\t\t\tt.Fatalf(\"Close() = %v, want nil\", err)\n+\t\t}\n+\t\tif _, err := tw.Write([]byte(\"Kilts\")); err != ErrWriteAfterClose {\n+\t\t\tt.Fatalf(\"Write() = %v, want %v\", err, ErrWriteAfterClose)\n+\t\t}\n+\t\tif err := tw.Flush(); err != ErrWriteAfterClose {\n+\t\t\tt.Fatalf(\"Flush() = %v, want %v\", err, ErrWriteAfterClose)\n+\t\t}\n+\t\tif err := tw.Close(); err != nil {\n+\t\t\tt.Fatalf(\"Close() = %v, want nil\", err)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"PrematureFlush\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(bytes.Buffer))\n+\t\thdr := &Header{Name: \"small.txt\", Size: 5}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\tt.Fatalf(\"WriteHeader() = %v, want nil\", err)\n+\t\t}\n+\t\tif err := tw.Flush(); err == nil {\n+\t\t\tt.Fatalf(\"Flush() = %v, want non-nil error\", err)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"PrematureClose\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(bytes.Buffer))\n+\t\thdr := &Header{Name: \"small.txt\", Size: 5}\n+\t\tif err := tw.WriteHeader(hdr); err != nil {\n+\t\t\tt.Fatalf(\"WriteHeader() = %v, want nil\", err)\n+\t\t}\n+\t\tif err := tw.Close(); err == nil {\n+\t\t\tt.Fatalf(\"Close() = %v, want non-nil error\", err)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"Persistence\", func(t *testing.T) {\n+\t\ttw := NewWriter(new(failOnceWriter))\n+\t\tif err := tw.WriteHeader(&Header{}); err != io.ErrShortWrite {\n+\t\t\tt.Fatalf(\"WriteHeader() = %v, want %v\", err, io.ErrShortWrite)\n+\t\t}\n+\t\tif err := tw.WriteHeader(&Header{Name: \"small.txt\"}); err == nil {\n+\t\t\tt.Errorf(\"WriteHeader() = got %v, want non-nil error\", err)\n+\t\t}\n+\t\tif _, err := tw.Write(nil); err == nil {\n+\t\t\tt.Errorf(\"Write() = %v, want non-nil error\", err)\n+\t\t}\n+\t\tif err := tw.Flush(); err == nil {\n+\t\t\tt.Errorf(\"Flush() = %v, want non-nil error\", err)\n+\t\t}\n+\t\tif err := tw.Close(); err == nil {\n+\t\t\tt.Errorf(\"Close() = %v, want non-nil error\", err)\n+\t\t}\n+\t})\n }\n \n func TestSplitUSTARPath(t *testing.T) {\n@@ -631,7 +983,7 @@ func TestIssue12594(t *testing.T) {\n \t\tif i := strings.IndexByte(prefix, 0); i >= 0 {\n \t\t\tprefix = prefix[:i] // Truncate at the NUL terminator\n \t\t}\n-\t\tif blk.GetFormat() == formatGNU && len(prefix) > 0 && strings.HasPrefix(name, prefix) {\n+\t\tif blk.GetFormat() == FormatGNU && len(prefix) > 0 && strings.HasPrefix(name, prefix) {\n \t\t\tt.Errorf(\"test %d, found prefix in GNU format: %s\", i, prefix)\n \t\t}\n \n@@ -645,3 +997,306 @@ func TestIssue12594(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// testNonEmptyWriter wraps an io.Writer and ensures that\n+// Write is never called with an empty buffer.\n+type testNonEmptyWriter struct{ io.Writer }\n+\n+func (w testNonEmptyWriter) Write(b []byte) (int, error) {\n+\tif len(b) == 0 {\n+\t\treturn 0, errors.New(\"unexpected empty Write call\")\n+\t}\n+\treturn w.Writer.Write(b)\n+}\n+\n+func TestFileWriter(t *testing.T) {\n+\ttype (\n+\t\ttestWrite struct { // Write(str) == (wantCnt, wantErr)\n+\t\t\tstr     string\n+\t\t\twantCnt int\n+\t\t\twantErr error\n+\t\t}\n+\t\ttestReadFrom struct { // ReadFrom(testFile{ops}) == (wantCnt, wantErr)\n+\t\t\tops     fileOps\n+\t\t\twantCnt int64\n+\t\t\twantErr error\n+\t\t}\n+\t\ttestRemaining struct { // LogicalRemaining() == wantLCnt, PhysicalRemaining() == wantPCnt\n+\t\t\twantLCnt int64\n+\t\t\twantPCnt int64\n+\t\t}\n+\t\ttestFnc interface{} // testWrite | testReadFrom | testRemaining\n+\t)\n+\n+\ttype (\n+\t\tmakeReg struct {\n+\t\t\tsize    int64\n+\t\t\twantStr string\n+\t\t}\n+\t\tmakeSparse struct {\n+\t\t\tmakeReg makeReg\n+\t\t\tsph     sparseHoles\n+\t\t\tsize    int64\n+\t\t}\n+\t\tfileMaker interface{} // makeReg | makeSparse\n+\t)\n+\n+\tvectors := []struct {\n+\t\tmaker fileMaker\n+\t\ttests []testFnc\n+\t}{{\n+\t\tmaker: makeReg{0, \"\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{0, 0},\n+\t\t\ttestWrite{\"\", 0, nil},\n+\t\t\ttestWrite{\"a\", 0, ErrWriteTooLong},\n+\t\t\ttestReadFrom{fileOps{\"\"}, 0, nil},\n+\t\t\ttestReadFrom{fileOps{\"a\"}, 0, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{1, \"a\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{1, 1},\n+\t\t\ttestWrite{\"\", 0, nil},\n+\t\t\ttestWrite{\"a\", 1, nil},\n+\t\t\ttestWrite{\"bcde\", 0, ErrWriteTooLong},\n+\t\t\ttestWrite{\"\", 0, nil},\n+\t\t\ttestReadFrom{fileOps{\"\"}, 0, nil},\n+\t\t\ttestReadFrom{fileOps{\"a\"}, 0, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{5, \"hello\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestWrite{\"hello\", 5, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{5, \"\\x00\\x00\\x00\\x00\\x00\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestReadFrom{fileOps{\"\\x00\\x00\\x00\\x00\\x00\"}, 5, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{5, \"\\x00\\x00\\x00\\x00\\x00\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestReadFrom{fileOps{\"\\x00\\x00\\x00\\x00\\x00extra\"}, 5, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{5, \"abc\\x00\\x00\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestWrite{\"abc\", 3, nil},\n+\t\t\ttestRemaining{2, 2},\n+\t\t\ttestReadFrom{fileOps{\"\\x00\\x00\"}, 2, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeReg{5, \"\\x00\\x00abc\"},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{5, 5},\n+\t\t\ttestWrite{\"\\x00\\x00\", 2, nil},\n+\t\t\ttestRemaining{3, 3},\n+\t\t\ttestWrite{\"abc\", 3, nil},\n+\t\t\ttestReadFrom{fileOps{\"z\"}, 0, ErrWriteTooLong},\n+\t\t\ttestWrite{\"z\", 0, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{5, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{8, 5},\n+\t\t\ttestWrite{\"ab\\x00\\x00\\x00cde\", 8, nil},\n+\t\t\ttestWrite{\"a\", 0, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{5, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"ab\\x00\\x00\\x00cdez\", 8, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{5, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"ab\\x00\", 3, nil},\n+\t\t\ttestRemaining{5, 3},\n+\t\t\ttestWrite{\"\\x00\\x00cde\", 5, nil},\n+\t\t\ttestWrite{\"a\", 0, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{5, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"ab\", 2, nil},\n+\t\t\ttestRemaining{6, 3},\n+\t\t\ttestReadFrom{fileOps{int64(3), \"cde\"}, 6, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{5, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestReadFrom{fileOps{\"ab\", int64(3), \"cde\"}, 8, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{5, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestReadFrom{fileOps{\"ab\", int64(3), \"cdeX\"}, 8, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{4, \"abcd\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestReadFrom{fileOps{\"ab\", int64(3), \"cd\"}, 7, io.ErrUnexpectedEOF},\n+\t\t\ttestRemaining{1, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{4, \"abcd\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestReadFrom{fileOps{\"ab\", int64(3), \"cde\"}, 7, errMissData},\n+\t\t\ttestRemaining{1, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{6, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestReadFrom{fileOps{\"ab\", int64(3), \"cde\"}, 8, errUnrefData},\n+\t\t\ttestRemaining{0, 1},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{4, \"abcd\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"ab\", 2, nil},\n+\t\t\ttestRemaining{6, 2},\n+\t\t\ttestWrite{\"\\x00\\x00\\x00\", 3, nil},\n+\t\t\ttestRemaining{3, 2},\n+\t\t\ttestWrite{\"cde\", 2, errMissData},\n+\t\t\ttestRemaining{1, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{6, \"abcde\"}, sparseHoles{{2, 3}}, 8},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"ab\", 2, nil},\n+\t\t\ttestRemaining{6, 4},\n+\t\t\ttestWrite{\"\\x00\\x00\\x00\", 3, nil},\n+\t\t\ttestRemaining{3, 4},\n+\t\t\ttestWrite{\"cde\", 3, errUnrefData},\n+\t\t\ttestRemaining{0, 1},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{3, \"abc\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{7, 3},\n+\t\t\ttestWrite{\"\\x00\\x00abc\\x00\\x00\", 7, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{3, \"abc\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestRemaining{7, 3},\n+\t\t\ttestReadFrom{fileOps{int64(2), \"abc\", int64(1), \"\\x00\"}, 7, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{3, \"\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"abcdefg\", 0, errWriteHole},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{3, \"abc\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"\\x00\\x00abcde\", 5, errWriteHole},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{3, \"abc\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"\\x00\\x00abc\\x00\\x00z\", 7, ErrWriteTooLong},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{3, \"abc\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"\\x00\\x00\", 2, nil},\n+\t\t\ttestRemaining{5, 3},\n+\t\t\ttestWrite{\"abc\", 3, nil},\n+\t\t\ttestRemaining{2, 0},\n+\t\t\ttestWrite{\"\\x00\\x00\", 2, nil},\n+\t\t\ttestRemaining{0, 0},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{2, \"ab\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"\\x00\\x00\", 2, nil},\n+\t\t\ttestWrite{\"abc\", 2, errMissData},\n+\t\t\ttestWrite{\"\\x00\\x00\", 0, errMissData},\n+\t\t},\n+\t}, {\n+\t\tmaker: makeSparse{makeReg{4, \"abc\"}, sparseHoles{{0, 2}, {5, 2}}, 7},\n+\t\ttests: []testFnc{\n+\t\t\ttestWrite{\"\\x00\\x00\", 2, nil},\n+\t\t\ttestWrite{\"abc\", 3, nil},\n+\t\t\ttestWrite{\"\\x00\\x00\", 2, errUnrefData},\n+\t\t},\n+\t}}\n+\n+\tfor i, v := range vectors {\n+\t\tvar wantStr string\n+\t\tbb := new(bytes.Buffer)\n+\t\tw := testNonEmptyWriter{bb}\n+\t\tvar fw fileWriter\n+\t\tswitch maker := v.maker.(type) {\n+\t\tcase makeReg:\n+\t\t\tfw = &regFileWriter{w, maker.size}\n+\t\t\twantStr = maker.wantStr\n+\t\tcase makeSparse:\n+\t\t\tif !validateSparseEntries(maker.sph, maker.size) {\n+\t\t\t\tt.Fatalf(\"invalid sparse map: %v\", maker.sph)\n+\t\t\t}\n+\t\t\tspd := invertSparseEntries(maker.sph, maker.size)\n+\t\t\tfw = &regFileWriter{w, maker.makeReg.size}\n+\t\t\tfw = &sparseFileWriter{fw, spd, 0}\n+\t\t\twantStr = maker.makeReg.wantStr\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"test %d, unknown make operation: %T\", i, maker)\n+\t\t}\n+\n+\t\tfor j, tf := range v.tests {\n+\t\t\tswitch tf := tf.(type) {\n+\t\t\tcase testWrite:\n+\t\t\t\tgot, err := fw.Write([]byte(tf.str))\n+\t\t\t\tif got != tf.wantCnt || err != tf.wantErr {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, Write(%s):\\ngot  (%d, %v)\\nwant (%d, %v)\", i, j, tf.str, got, err, tf.wantCnt, tf.wantErr)\n+\t\t\t\t}\n+\t\t\tcase testReadFrom:\n+\t\t\t\tf := &testFile{ops: tf.ops}\n+\t\t\t\tgot, err := fw.ReadFrom(f)\n+\t\t\t\tif _, ok := err.(testError); ok {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, ReadFrom(): %v\", i, j, err)\n+\t\t\t\t} else if got != tf.wantCnt || err != tf.wantErr {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, ReadFrom() = (%d, %v), want (%d, %v)\", i, j, got, err, tf.wantCnt, tf.wantErr)\n+\t\t\t\t}\n+\t\t\t\tif len(f.ops) > 0 {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, expected %d more operations\", i, j, len(f.ops))\n+\t\t\t\t}\n+\t\t\tcase testRemaining:\n+\t\t\t\tif got := fw.LogicalRemaining(); got != tf.wantLCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, LogicalRemaining() = %d, want %d\", i, j, got, tf.wantLCnt)\n+\t\t\t\t}\n+\t\t\t\tif got := fw.PhysicalRemaining(); got != tf.wantPCnt {\n+\t\t\t\t\tt.Errorf(\"test %d.%d, PhysicalRemaining() = %d, want %d\", i, j, got, tf.wantPCnt)\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tt.Fatalf(\"test %d.%d, unknown test operation: %T\", i, j, tf)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif got := bb.String(); got != wantStr {\n+\t\t\tt.Fatalf(\"test %d, String() = %q, want %q\", i, got, wantStr)\n+\t\t}\n+\t}\n+}"}, {"sha": "1563e74dfceda7d29f81ed8a367924c15a9115e3", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 127, "deletions": 38, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"hash/crc32\"\n \t\"io\"\n \t\"os\"\n+\t\"time\"\n )\n \n var (\n@@ -94,7 +95,7 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \n \t// The count of files inside a zip is truncated to fit in a uint16.\n \t// Gloss over this by reading headers until we encounter\n-\t// a bad one, and then only report a ErrFormat or UnexpectedEOF if\n+\t// a bad one, and then only report an ErrFormat or UnexpectedEOF if\n \t// the file count modulo 65536 is incorrect.\n \tfor {\n \t\tf := &File{zip: z, zipr: r, zipsize: size}\n@@ -280,52 +281,128 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \tf.Extra = d[filenameLen : filenameLen+extraLen]\n \tf.Comment = string(d[filenameLen+extraLen:])\n \n+\t// Determine the character encoding.\n+\tutf8Valid1, utf8Require1 := detectUTF8(f.Name)\n+\tutf8Valid2, utf8Require2 := detectUTF8(f.Comment)\n+\tswitch {\n+\tcase !utf8Valid1 || !utf8Valid2:\n+\t\t// Name and Comment definitely not UTF-8.\n+\t\tf.NonUTF8 = true\n+\tcase !utf8Require1 && !utf8Require2:\n+\t\t// Name and Comment use only single-byte runes that overlap with UTF-8.\n+\t\tf.NonUTF8 = false\n+\tdefault:\n+\t\t// Might be UTF-8, might be some other encoding; preserve existing flag.\n+\t\t// Some ZIP writers use UTF-8 encoding without setting the UTF-8 flag.\n+\t\t// Since it is impossible to always distinguish valid UTF-8 from some\n+\t\t// other encoding (e.g., GBK or Shift-JIS), we trust the flag.\n+\t\tf.NonUTF8 = f.Flags&0x800 == 0\n+\t}\n+\n \tneedUSize := f.UncompressedSize == ^uint32(0)\n \tneedCSize := f.CompressedSize == ^uint32(0)\n \tneedHeaderOffset := f.headerOffset == int64(^uint32(0))\n \n-\tif len(f.Extra) > 0 {\n-\t\t// Best effort to find what we need.\n-\t\t// Other zip authors might not even follow the basic format,\n-\t\t// and we'll just ignore the Extra content in that case.\n-\t\tb := readBuf(f.Extra)\n-\t\tfor len(b) >= 4 { // need at least tag and size\n-\t\t\ttag := b.uint16()\n-\t\t\tsize := b.uint16()\n-\t\t\tif int(size) > len(b) {\n-\t\t\t\tbreak\n+\t// Best effort to find what we need.\n+\t// Other zip authors might not even follow the basic format,\n+\t// and we'll just ignore the Extra content in that case.\n+\tvar modified time.Time\n+parseExtras:\n+\tfor extra := readBuf(f.Extra); len(extra) >= 4; { // need at least tag and size\n+\t\tfieldTag := extra.uint16()\n+\t\tfieldSize := int(extra.uint16())\n+\t\tif len(extra) < fieldSize {\n+\t\t\tbreak\n+\t\t}\n+\t\tfieldBuf := extra.sub(fieldSize)\n+\n+\t\tswitch fieldTag {\n+\t\tcase zip64ExtraID:\n+\t\t\t// update directory values from the zip64 extra block.\n+\t\t\t// They should only be consulted if the sizes read earlier\n+\t\t\t// are maxed out.\n+\t\t\t// See golang.org/issue/13367.\n+\t\t\tif needUSize {\n+\t\t\t\tneedUSize = false\n+\t\t\t\tif len(fieldBuf) < 8 {\n+\t\t\t\t\treturn ErrFormat\n+\t\t\t\t}\n+\t\t\t\tf.UncompressedSize64 = fieldBuf.uint64()\n \t\t\t}\n-\t\t\tif tag == zip64ExtraId {\n-\t\t\t\t// update directory values from the zip64 extra block.\n-\t\t\t\t// They should only be consulted if the sizes read earlier\n-\t\t\t\t// are maxed out.\n-\t\t\t\t// See golang.org/issue/13367.\n-\t\t\t\teb := readBuf(b[:size])\n-\n-\t\t\t\tif needUSize {\n-\t\t\t\t\tneedUSize = false\n-\t\t\t\t\tif len(eb) < 8 {\n-\t\t\t\t\t\treturn ErrFormat\n-\t\t\t\t\t}\n-\t\t\t\t\tf.UncompressedSize64 = eb.uint64()\n+\t\t\tif needCSize {\n+\t\t\t\tneedCSize = false\n+\t\t\t\tif len(fieldBuf) < 8 {\n+\t\t\t\t\treturn ErrFormat\n \t\t\t\t}\n-\t\t\t\tif needCSize {\n-\t\t\t\t\tneedCSize = false\n-\t\t\t\t\tif len(eb) < 8 {\n-\t\t\t\t\t\treturn ErrFormat\n-\t\t\t\t\t}\n-\t\t\t\t\tf.CompressedSize64 = eb.uint64()\n+\t\t\t\tf.CompressedSize64 = fieldBuf.uint64()\n+\t\t\t}\n+\t\t\tif needHeaderOffset {\n+\t\t\t\tneedHeaderOffset = false\n+\t\t\t\tif len(fieldBuf) < 8 {\n+\t\t\t\t\treturn ErrFormat\n \t\t\t\t}\n-\t\t\t\tif needHeaderOffset {\n-\t\t\t\t\tneedHeaderOffset = false\n-\t\t\t\t\tif len(eb) < 8 {\n-\t\t\t\t\t\treturn ErrFormat\n-\t\t\t\t\t}\n-\t\t\t\t\tf.headerOffset = int64(eb.uint64())\n+\t\t\t\tf.headerOffset = int64(fieldBuf.uint64())\n+\t\t\t}\n+\t\tcase ntfsExtraID:\n+\t\t\tif len(fieldBuf) < 4 {\n+\t\t\t\tcontinue parseExtras\n+\t\t\t}\n+\t\t\tfieldBuf.uint32()        // reserved (ignored)\n+\t\t\tfor len(fieldBuf) >= 4 { // need at least tag and size\n+\t\t\t\tattrTag := fieldBuf.uint16()\n+\t\t\t\tattrSize := int(fieldBuf.uint16())\n+\t\t\t\tif len(fieldBuf) < attrSize {\n+\t\t\t\t\tcontinue parseExtras\n+\t\t\t\t}\n+\t\t\t\tattrBuf := fieldBuf.sub(attrSize)\n+\t\t\t\tif attrTag != 1 || attrSize != 24 {\n+\t\t\t\t\tcontinue // Ignore irrelevant attributes\n \t\t\t\t}\n-\t\t\t\tbreak\n+\n+\t\t\t\tconst ticksPerSecond = 1e7    // Windows timestamp resolution\n+\t\t\t\tts := int64(attrBuf.uint64()) // ModTime since Windows epoch\n+\t\t\t\tsecs := int64(ts / ticksPerSecond)\n+\t\t\t\tnsecs := (1e9 / ticksPerSecond) * int64(ts%ticksPerSecond)\n+\t\t\t\tepoch := time.Date(1601, time.January, 1, 0, 0, 0, 0, time.UTC)\n+\t\t\t\tmodified = time.Unix(epoch.Unix()+secs, nsecs)\n+\t\t\t}\n+\t\tcase unixExtraID:\n+\t\t\tif len(fieldBuf) < 8 {\n+\t\t\t\tcontinue parseExtras\n \t\t\t}\n-\t\t\tb = b[size:]\n+\t\t\tfieldBuf.uint32()              // AcTime (ignored)\n+\t\t\tts := int64(fieldBuf.uint32()) // ModTime since Unix epoch\n+\t\t\tmodified = time.Unix(ts, 0)\n+\t\tcase extTimeExtraID:\n+\t\t\tif len(fieldBuf) < 5 || fieldBuf.uint8()&1 == 0 {\n+\t\t\t\tcontinue parseExtras\n+\t\t\t}\n+\t\t\tts := int64(fieldBuf.uint32()) // ModTime since Unix epoch\n+\t\t\tmodified = time.Unix(ts, 0)\n+\t\tcase infoZipUnixExtraID:\n+\t\t\tif len(fieldBuf) < 4 {\n+\t\t\t\tcontinue parseExtras\n+\t\t\t}\n+\t\t\tts := int64(fieldBuf.uint32()) // ModTime since Unix epoch\n+\t\t\tmodified = time.Unix(ts, 0)\n+\t\t}\n+\t}\n+\n+\tmsdosModified := msDosTimeToTime(f.ModifiedDate, f.ModifiedTime)\n+\tf.Modified = msdosModified\n+\tif !modified.IsZero() {\n+\t\tf.Modified = modified.UTC()\n+\n+\t\t// If legacy MS-DOS timestamps are set, we can use the delta between\n+\t\t// the legacy and extended versions to estimate timezone offset.\n+\t\t//\n+\t\t// A non-UTC timezone is always used (even if offset is zero).\n+\t\t// Thus, FileHeader.Modified.Location() == time.UTC is useful for\n+\t\t// determining whether extended timestamps are present.\n+\t\t// This is necessary for users that need to do additional time\n+\t\t// calculations when dealing with legacy ZIP formats.\n+\t\tif f.ModifiedTime != 0 || f.ModifiedDate != 0 {\n+\t\t\tf.Modified = modified.In(timeZone(msdosModified.Sub(modified)))\n \t\t}\n \t}\n \n@@ -508,6 +585,12 @@ func findSignatureInBlock(b []byte) int {\n \n type readBuf []byte\n \n+func (b *readBuf) uint8() uint8 {\n+\tv := (*b)[0]\n+\t*b = (*b)[1:]\n+\treturn v\n+}\n+\n func (b *readBuf) uint16() uint16 {\n \tv := binary.LittleEndian.Uint16(*b)\n \t*b = (*b)[2:]\n@@ -525,3 +608,9 @@ func (b *readBuf) uint64() uint64 {\n \t*b = (*b)[8:]\n \treturn v\n }\n+\n+func (b *readBuf) sub(n int) readBuf {\n+\tb2 := (*b)[:n]\n+\t*b = (*b)[n:]\n+\treturn b2\n+}"}, {"sha": "0d9040f76740c0e913117296ee0e19ffe6117c36", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 309, "deletions": 120, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -27,9 +27,11 @@ type ZipTest struct {\n }\n \n type ZipTestFile struct {\n-\tName  string\n-\tMode  os.FileMode\n-\tMtime string // optional, modified time in format \"mm-dd-yy hh:mm:ss\"\n+\tName     string\n+\tMode     os.FileMode\n+\tNonUTF8  bool\n+\tModTime  time.Time\n+\tModified time.Time\n \n \t// Information describing expected zip file content.\n \t// First, reading the entire content should produce the error ContentErr.\n@@ -47,32 +49,22 @@ type ZipTestFile struct {\n \tSize       uint64\n }\n \n-// Caution: The Mtime values found for the test files should correspond to\n-//          the values listed with unzip -l <zipfile>. However, the values\n-//          listed by unzip appear to be off by some hours. When creating\n-//          fresh test files and testing them, this issue is not present.\n-//          The test files were created in Sydney, so there might be a time\n-//          zone issue. The time zone information does have to be encoded\n-//          somewhere, because otherwise unzip -l could not provide a different\n-//          time from what the archive/zip package provides, but there appears\n-//          to be no documentation about this.\n-\n var tests = []ZipTest{\n \t{\n \t\tName:    \"test.zip\",\n \t\tComment: \"This is a zipfile comment.\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"test.txt\",\n-\t\t\t\tContent: []byte(\"This is a test text file.\\n\"),\n-\t\t\t\tMtime:   \"09-05-10 12:12:02\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte(\"This is a test text file.\\n\"),\n+\t\t\t\tModified: time.Date(2010, 9, 5, 12, 12, 1, 0, timeZone(+10*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:  \"gophercolor16x16.png\",\n-\t\t\t\tFile:  \"gophercolor16x16.png\",\n-\t\t\t\tMtime: \"09-05-10 15:52:58\",\n-\t\t\t\tMode:  0644,\n+\t\t\t\tName:     \"gophercolor16x16.png\",\n+\t\t\t\tFile:     \"gophercolor16x16.png\",\n+\t\t\t\tModified: time.Date(2010, 9, 5, 15, 52, 58, 0, timeZone(+10*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n@@ -81,16 +73,16 @@ var tests = []ZipTest{\n \t\tComment: \"This is a zipfile comment.\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"test.txt\",\n-\t\t\t\tContent: []byte(\"This is a test text file.\\n\"),\n-\t\t\t\tMtime:   \"09-05-10 12:12:02\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte(\"This is a test text file.\\n\"),\n+\t\t\t\tModified: time.Date(2010, 9, 5, 12, 12, 1, 0, timeZone(+10*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:  \"gophercolor16x16.png\",\n-\t\t\t\tFile:  \"gophercolor16x16.png\",\n-\t\t\t\tMtime: \"09-05-10 15:52:58\",\n-\t\t\t\tMode:  0644,\n+\t\t\t\tName:     \"gophercolor16x16.png\",\n+\t\t\t\tFile:     \"gophercolor16x16.png\",\n+\t\t\t\tModified: time.Date(2010, 9, 5, 15, 52, 58, 0, timeZone(+10*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n@@ -99,20 +91,21 @@ var tests = []ZipTest{\n \t\tSource: returnRecursiveZip,\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"r/r.zip\",\n-\t\t\t\tContent: rZipBytes(),\n-\t\t\t\tMtime:   \"03-04-10 00:24:16\",\n-\t\t\t\tMode:    0666,\n+\t\t\t\tName:     \"r/r.zip\",\n+\t\t\t\tContent:  rZipBytes(),\n+\t\t\t\tModified: time.Date(2010, 3, 4, 0, 24, 16, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n \t\t\t},\n \t\t},\n \t},\n \t{\n \t\tName: \"symlink.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"symlink\",\n-\t\t\t\tContent: []byte(\"../target\"),\n-\t\t\t\tMode:    0777 | os.ModeSymlink,\n+\t\t\t\tName:     \"symlink\",\n+\t\t\t\tContent:  []byte(\"../target\"),\n+\t\t\t\tModified: time.Date(2012, 2, 3, 19, 56, 48, 0, timeZone(-2*time.Hour)),\n+\t\t\t\tMode:     0777 | os.ModeSymlink,\n \t\t\t},\n \t\t},\n \t},\n@@ -127,39 +120,89 @@ var tests = []ZipTest{\n \t\tName: \"dd.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"filename\",\n-\t\t\t\tContent: []byte(\"This is a test textfile.\\n\"),\n-\t\t\t\tMtime:   \"02-02-11 13:06:20\",\n-\t\t\t\tMode:    0666,\n+\t\t\t\tName:     \"filename\",\n+\t\t\t\tContent:  []byte(\"This is a test textfile.\\n\"),\n+\t\t\t\tModified: time.Date(2011, 2, 2, 13, 6, 20, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n \t\t\t},\n \t\t},\n \t},\n \t{\n \t\t// created in windows XP file manager.\n \t\tName: \"winxp.zip\",\n-\t\tFile: crossPlatform,\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"hello\",\n+\t\t\t\tContent:  []byte(\"world \\r\\n\"),\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 4, 24, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:     \"dir/bar\",\n+\t\t\t\tContent:  []byte(\"foo \\r\\n\"),\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 4, 50, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:     \"dir/empty/\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 8, 6, 0, time.UTC),\n+\t\t\t\tMode:     os.ModeDir | 0777,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:     \"readonly\",\n+\t\t\t\tContent:  []byte(\"important \\r\\n\"),\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 6, 8, 0, time.UTC),\n+\t\t\t\tMode:     0444,\n+\t\t\t},\n+\t\t},\n \t},\n \t{\n \t\t// created by Zip 3.0 under Linux\n \t\tName: \"unix.zip\",\n-\t\tFile: crossPlatform,\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"hello\",\n+\t\t\t\tContent:  []byte(\"world \\r\\n\"),\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 4, 24, 0, timeZone(0)),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:     \"dir/bar\",\n+\t\t\t\tContent:  []byte(\"foo \\r\\n\"),\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 4, 50, 0, timeZone(0)),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:     \"dir/empty/\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 8, 6, 0, timeZone(0)),\n+\t\t\t\tMode:     os.ModeDir | 0777,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tName:     \"readonly\",\n+\t\t\t\tContent:  []byte(\"important \\r\\n\"),\n+\t\t\t\tModified: time.Date(2011, 12, 8, 10, 6, 8, 0, timeZone(0)),\n+\t\t\t\tMode:     0444,\n+\t\t\t},\n+\t\t},\n \t},\n \t{\n \t\t// created by Go, before we wrote the \"optional\" data\n \t\t// descriptor signatures (which are required by OS X)\n \t\tName: \"go-no-datadesc-sig.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"foo.txt\",\n-\t\t\t\tContent: []byte(\"foo\\n\"),\n-\t\t\t\tMtime:   \"03-08-12 16:59:10\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"foo.txt\",\n+\t\t\t\tContent:  []byte(\"foo\\n\"),\n+\t\t\t\tModified: time.Date(2012, 3, 8, 16, 59, 10, 0, timeZone(-8*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:    \"bar.txt\",\n-\t\t\t\tContent: []byte(\"bar\\n\"),\n-\t\t\t\tMtime:   \"03-08-12 16:59:12\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"bar.txt\",\n+\t\t\t\tContent:  []byte(\"bar\\n\"),\n+\t\t\t\tModified: time.Date(2012, 3, 8, 16, 59, 12, 0, timeZone(-8*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n@@ -169,14 +212,16 @@ var tests = []ZipTest{\n \t\tName: \"go-with-datadesc-sig.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"foo.txt\",\n-\t\t\t\tContent: []byte(\"foo\\n\"),\n-\t\t\t\tMode:    0666,\n+\t\t\t\tName:     \"foo.txt\",\n+\t\t\t\tContent:  []byte(\"foo\\n\"),\n+\t\t\t\tModified: time.Date(1979, 11, 30, 0, 0, 0, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:    \"bar.txt\",\n-\t\t\t\tContent: []byte(\"bar\\n\"),\n-\t\t\t\tMode:    0666,\n+\t\t\t\tName:     \"bar.txt\",\n+\t\t\t\tContent:  []byte(\"bar\\n\"),\n+\t\t\t\tModified: time.Date(1979, 11, 30, 0, 0, 0, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n \t\t\t},\n \t\t},\n \t},\n@@ -187,13 +232,15 @@ var tests = []ZipTest{\n \t\t\t{\n \t\t\t\tName:       \"foo.txt\",\n \t\t\t\tContent:    []byte(\"foo\\n\"),\n+\t\t\t\tModified:   time.Date(1979, 11, 30, 0, 0, 0, 0, time.UTC),\n \t\t\t\tMode:       0666,\n \t\t\t\tContentErr: ErrChecksum,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:    \"bar.txt\",\n-\t\t\t\tContent: []byte(\"bar\\n\"),\n-\t\t\t\tMode:    0666,\n+\t\t\t\tName:     \"bar.txt\",\n+\t\t\t\tContent:  []byte(\"bar\\n\"),\n+\t\t\t\tModified: time.Date(1979, 11, 30, 0, 0, 0, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n \t\t\t},\n \t\t},\n \t},\n@@ -203,16 +250,16 @@ var tests = []ZipTest{\n \t\tName: \"crc32-not-streamed.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"foo.txt\",\n-\t\t\t\tContent: []byte(\"foo\\n\"),\n-\t\t\t\tMtime:   \"03-08-12 16:59:10\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"foo.txt\",\n+\t\t\t\tContent:  []byte(\"foo\\n\"),\n+\t\t\t\tModified: time.Date(2012, 3, 8, 16, 59, 10, 0, timeZone(-8*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:    \"bar.txt\",\n-\t\t\t\tContent: []byte(\"bar\\n\"),\n-\t\t\t\tMtime:   \"03-08-12 16:59:12\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"bar.txt\",\n+\t\t\t\tContent:  []byte(\"bar\\n\"),\n+\t\t\t\tModified: time.Date(2012, 3, 8, 16, 59, 12, 0, timeZone(-8*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n@@ -225,26 +272,26 @@ var tests = []ZipTest{\n \t\t\t{\n \t\t\t\tName:       \"foo.txt\",\n \t\t\t\tContent:    []byte(\"foo\\n\"),\n-\t\t\t\tMtime:      \"03-08-12 16:59:10\",\n+\t\t\t\tModified:   time.Date(2012, 3, 8, 16, 59, 10, 0, timeZone(-8*time.Hour)),\n \t\t\t\tMode:       0644,\n \t\t\t\tContentErr: ErrChecksum,\n \t\t\t},\n \t\t\t{\n-\t\t\t\tName:    \"bar.txt\",\n-\t\t\t\tContent: []byte(\"bar\\n\"),\n-\t\t\t\tMtime:   \"03-08-12 16:59:12\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"bar.txt\",\n+\t\t\t\tContent:  []byte(\"bar\\n\"),\n+\t\t\t\tModified: time.Date(2012, 3, 8, 16, 59, 12, 0, timeZone(-8*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n \t{\n \t\tName: \"zip64.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"README\",\n-\t\t\t\tContent: []byte(\"This small file is in ZIP64 format.\\n\"),\n-\t\t\t\tMtime:   \"08-10-12 14:33:32\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"README\",\n+\t\t\t\tContent:  []byte(\"This small file is in ZIP64 format.\\n\"),\n+\t\t\t\tModified: time.Date(2012, 8, 10, 14, 33, 32, 0, time.UTC),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n@@ -253,10 +300,10 @@ var tests = []ZipTest{\n \t\tName: \"zip64-2.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"README\",\n-\t\t\t\tContent: []byte(\"This small file is in ZIP64 format.\\n\"),\n-\t\t\t\tMtime:   \"08-10-12 14:33:32\",\n-\t\t\t\tMode:    0644,\n+\t\t\t\tName:     \"README\",\n+\t\t\t\tContent:  []byte(\"This small file is in ZIP64 format.\\n\"),\n+\t\t\t\tModified: time.Date(2012, 8, 10, 14, 33, 32, 0, timeZone(-4*time.Hour)),\n+\t\t\t\tMode:     0644,\n \t\t\t},\n \t\t},\n \t},\n@@ -266,41 +313,179 @@ var tests = []ZipTest{\n \t\tSource: returnBigZipBytes,\n \t\tFile: []ZipTestFile{\n \t\t\t{\n-\t\t\t\tName:    \"big.file\",\n-\t\t\t\tContent: nil,\n-\t\t\t\tSize:    1<<32 - 1,\n-\t\t\t\tMode:    0666,\n+\t\t\t\tName:     \"big.file\",\n+\t\t\t\tContent:  nil,\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(1979, 11, 30, 0, 0, 0, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"utf8-7zip.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"\u4e16\u754c\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tMode:     0666,\n+\t\t\t\tModified: time.Date(2017, 11, 6, 13, 9, 27, 867862500, timeZone(-8*time.Hour)),\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"utf8-infozip.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"\u4e16\u754c\",\n+\t\t\t\tContent: []byte{},\n+\t\t\t\tMode:    0644,\n+\t\t\t\t// Name is valid UTF-8, but format does not have UTF-8 flag set.\n+\t\t\t\t// We don't do\u00a0UTF-8 detection for multi-byte runes due to\n+\t\t\t\t// false-positives with other encodings (e.g., Shift-JIS).\n+\t\t\t\t// Format says encoding is not UTF-8, so we trust it.\n+\t\t\t\tNonUTF8:  true,\n+\t\t\t\tModified: time.Date(2017, 11, 6, 13, 9, 27, 0, timeZone(-8*time.Hour)),\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"utf8-osx.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"\u4e16\u754c\",\n+\t\t\t\tContent: []byte{},\n+\t\t\t\tMode:    0644,\n+\t\t\t\t// Name is valid UTF-8, but format does not have UTF-8 set.\n+\t\t\t\tNonUTF8:  true,\n+\t\t\t\tModified: time.Date(2017, 11, 6, 13, 9, 27, 0, timeZone(-8*time.Hour)),\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"utf8-winrar.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"\u4e16\u754c\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tMode:     0666,\n+\t\t\t\tModified: time.Date(2017, 11, 6, 13, 9, 27, 867862500, timeZone(-8*time.Hour)),\n \t\t\t},\n \t\t},\n \t},\n-}\n-\n-var crossPlatform = []ZipTestFile{\n \t{\n-\t\tName:    \"hello\",\n-\t\tContent: []byte(\"world \\r\\n\"),\n-\t\tMode:    0666,\n+\t\tName: \"utf8-winzip.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"\u4e16\u754c\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tMode:     0666,\n+\t\t\t\tModified: time.Date(2017, 11, 6, 13, 9, 27, 867000000, timeZone(-8*time.Hour)),\n+\t\t\t},\n+\t\t},\n \t},\n \t{\n-\t\tName:    \"dir/bar\",\n-\t\tContent: []byte(\"foo \\r\\n\"),\n-\t\tMode:    0666,\n+\t\tName: \"time-7zip.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 244817900, timeZone(-7*time.Hour)),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t},\n \t},\n \t{\n-\t\tName:    \"dir/empty/\",\n-\t\tContent: []byte{},\n-\t\tMode:    os.ModeDir | 0777,\n+\t\tName: \"time-infozip.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 0, timeZone(-7*time.Hour)),\n+\t\t\t\tMode:     0644,\n+\t\t\t},\n+\t\t},\n \t},\n \t{\n-\t\tName:    \"readonly\",\n-\t\tContent: []byte(\"important \\r\\n\"),\n-\t\tMode:    0444,\n+\t\tName: \"time-osx.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 17, 27, 0, timeZone(-7*time.Hour)),\n+\t\t\t\tMode:     0644,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"time-win7.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 58, 0, time.UTC),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"time-winrar.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 244817900, timeZone(-7*time.Hour)),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"time-winzip.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 244000000, timeZone(-7*time.Hour)),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"time-go.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"test.txt\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tSize:     1<<32 - 1,\n+\t\t\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 0, timeZone(-7*time.Hour)),\n+\t\t\t\tMode:     0666,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"time-22738.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:     \"file\",\n+\t\t\t\tContent:  []byte{},\n+\t\t\t\tMode:     0666,\n+\t\t\t\tModified: time.Date(1999, 12, 31, 19, 0, 0, 0, timeZone(-5*time.Hour)),\n+\t\t\t\tModTime:  time.Date(1999, 12, 31, 19, 0, 0, 0, time.UTC),\n+\t\t\t},\n+\t\t},\n \t},\n }\n \n func TestReader(t *testing.T) {\n \tfor _, zt := range tests {\n-\t\treadTestZip(t, zt)\n+\t\tt.Run(zt.Name, func(t *testing.T) {\n+\t\t\treadTestZip(t, zt)\n+\t\t})\n \t}\n }\n \n@@ -319,7 +504,7 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\t}\n \t}\n \tif err != zt.Error {\n-\t\tt.Errorf(\"%s: error=%v, want %v\", zt.Name, err, zt.Error)\n+\t\tt.Errorf(\"error=%v, want %v\", err, zt.Error)\n \t\treturn\n \t}\n \n@@ -335,16 +520,19 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t}\n \n \tif z.Comment != zt.Comment {\n-\t\tt.Errorf(\"%s: comment=%q, want %q\", zt.Name, z.Comment, zt.Comment)\n+\t\tt.Errorf(\"comment=%q, want %q\", z.Comment, zt.Comment)\n \t}\n \tif len(z.File) != len(zt.File) {\n-\t\tt.Fatalf(\"%s: file count=%d, want %d\", zt.Name, len(z.File), len(zt.File))\n+\t\tt.Fatalf(\"file count=%d, want %d\", len(z.File), len(zt.File))\n \t}\n \n \t// test read of each file\n \tfor i, ft := range zt.File {\n \t\treadTestFile(t, zt, ft, z.File[i])\n \t}\n+\tif t.Failed() {\n+\t\treturn\n+\t}\n \n \t// test simultaneous reads\n \tn := 0\n@@ -363,23 +551,24 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t}\n }\n \n+func equalTimeAndZone(t1, t2 time.Time) bool {\n+\tname1, offset1 := t1.Zone()\n+\tname2, offset2 := t2.Zone()\n+\treturn t1.Equal(t2) && name1 == name2 && offset1 == offset2\n+}\n+\n func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \tif f.Name != ft.Name {\n-\t\tt.Errorf(\"%s: name=%q, want %q\", zt.Name, f.Name, ft.Name)\n+\t\tt.Errorf(\"name=%q, want %q\", f.Name, ft.Name)\n \t}\n-\n-\tif ft.Mtime != \"\" {\n-\t\tmtime, err := time.Parse(\"01-02-06 15:04:05\", ft.Mtime)\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t\treturn\n-\t\t}\n-\t\tif ft := f.ModTime(); !ft.Equal(mtime) {\n-\t\t\tt.Errorf(\"%s: %s: mtime=%s, want %s\", zt.Name, f.Name, ft, mtime)\n-\t\t}\n+\tif !ft.Modified.IsZero() && !equalTimeAndZone(f.Modified, ft.Modified) {\n+\t\tt.Errorf(\"%s: Modified=%s, want %s\", f.Name, f.Modified, ft.Modified)\n+\t}\n+\tif !ft.ModTime.IsZero() && !equalTimeAndZone(f.ModTime(), ft.ModTime) {\n+\t\tt.Errorf(\"%s: ModTime=%s, want %s\", f.Name, f.ModTime(), ft.ModTime)\n \t}\n \n-\ttestFileMode(t, zt.Name, f, ft.Mode)\n+\ttestFileMode(t, f, ft.Mode)\n \n \tsize := uint64(f.UncompressedSize)\n \tif size == uint32max {\n@@ -390,7 +579,7 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \n \tr, err := f.Open()\n \tif err != nil {\n-\t\tt.Errorf(\"%s: %v\", zt.Name, err)\n+\t\tt.Errorf(\"%v\", err)\n \t\treturn\n \t}\n \n@@ -408,7 +597,7 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \tvar b bytes.Buffer\n \t_, err = io.Copy(&b, r)\n \tif err != ft.ContentErr {\n-\t\tt.Errorf(\"%s: copying contents: %v (want %v)\", zt.Name, err, ft.ContentErr)\n+\t\tt.Errorf(\"copying contents: %v (want %v)\", err, ft.ContentErr)\n \t}\n \tif err != nil {\n \t\treturn\n@@ -440,12 +629,12 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \t}\n }\n \n-func testFileMode(t *testing.T, zipName string, f *File, want os.FileMode) {\n+func testFileMode(t *testing.T, f *File, want os.FileMode) {\n \tmode := f.Mode()\n \tif want == 0 {\n-\t\tt.Errorf(\"%s: %s mode: got %v, want none\", zipName, f.Name, mode)\n+\t\tt.Errorf(\"%s mode: got %v, want none\", f.Name, mode)\n \t} else if mode != want {\n-\t\tt.Errorf(\"%s: %s mode: want %v, got %v\", zipName, f.Name, want, mode)\n+\t\tt.Errorf(\"%s mode: want %v, got %v\", f.Name, want, mode)\n \t}\n }\n "}, {"sha": "f613ebdc3444f3e71998769216ac52025d327291", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 82, "deletions": 22, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -27,8 +27,8 @@ import (\n \n // Compression methods.\n const (\n-\tStore   uint16 = 0\n-\tDeflate uint16 = 8\n+\tStore   uint16 = 0 // no compression\n+\tDeflate uint16 = 8 // DEFLATE compressed\n )\n \n const (\n@@ -46,48 +46,86 @@ const (\n \tdirectory64LocLen        = 20         //\n \tdirectory64EndLen        = 56         // + extra\n \n-\t// Constants for the first byte in CreatorVersion\n+\t// Constants for the first byte in CreatorVersion.\n \tcreatorFAT    = 0\n \tcreatorUnix   = 3\n \tcreatorNTFS   = 11\n \tcreatorVFAT   = 14\n \tcreatorMacOSX = 19\n \n-\t// version numbers\n+\t// Version numbers.\n \tzipVersion20 = 20 // 2.0\n \tzipVersion45 = 45 // 4.5 (reads and writes zip64 archives)\n \n-\t// limits for non zip64 files\n+\t// Limits for non zip64 files.\n \tuint16max = (1 << 16) - 1\n \tuint32max = (1 << 32) - 1\n \n-\t// extra header id's\n-\tzip64ExtraId = 0x0001 // zip64 Extended Information Extra Field\n+\t// Extra header IDs.\n+\t//\n+\t// IDs 0..31 are reserved for official use by PKWARE.\n+\t// IDs above that range are defined by third-party vendors.\n+\t// Since ZIP lacked high precision timestamps (nor a official specification\n+\t// of the timezone used for the date fields), many competing extra fields\n+\t// have been invented. Pervasive use effectively makes them \"official\".\n+\t//\n+\t// See http://mdfs.net/Docs/Comp/Archiving/Zip/ExtraField\n+\tzip64ExtraID       = 0x0001 // Zip64 extended information\n+\tntfsExtraID        = 0x000a // NTFS\n+\tunixExtraID        = 0x000d // UNIX\n+\textTimeExtraID     = 0x5455 // Extended timestamp\n+\tinfoZipUnixExtraID = 0x5855 // Info-ZIP Unix extension\n )\n \n // FileHeader describes a file within a zip file.\n // See the zip spec for details.\n type FileHeader struct {\n \t// Name is the name of the file.\n-\t// It must be a relative path: it must not start with a drive\n-\t// letter (e.g. C:) or leading slash, and only forward slashes\n-\t// are allowed.\n+\t// It must be a relative path, not start with a drive letter (e.g. C:),\n+\t// and must use forward slashes instead of back slashes.\n \tName string\n \n-\tCreatorVersion     uint16\n-\tReaderVersion      uint16\n-\tFlags              uint16\n-\tMethod             uint16\n-\tModifiedTime       uint16 // MS-DOS time\n-\tModifiedDate       uint16 // MS-DOS date\n+\t// Comment is any arbitrary user-defined string shorter than 64KiB.\n+\tComment string\n+\n+\t// NonUTF8 indicates that Name and Comment are not encoded in UTF-8.\n+\t//\n+\t// By specification, the only other encoding permitted should be CP-437,\n+\t// but historically many ZIP readers interpret Name and Comment as whatever\n+\t// the system's local character encoding happens to be.\n+\t//\n+\t// This flag should only be set if the user intends to encode a non-portable\n+\t// ZIP file for a specific localized region. Otherwise, the Writer\n+\t// automatically sets the ZIP format's UTF-8 flag for valid UTF-8 strings.\n+\tNonUTF8 bool\n+\n+\tCreatorVersion uint16\n+\tReaderVersion  uint16\n+\tFlags          uint16\n+\n+\t// Method is the compression method. If zero, Store is used.\n+\tMethod uint16\n+\n+\t// Modified is the modified time of the file.\n+\t//\n+\t// When reading, an extended timestamp is preferred over the legacy MS-DOS\n+\t// date field, and the offset between the times is used as the timezone.\n+\t// If only the MS-DOS date is present, the timezone is assumed to be UTC.\n+\t//\n+\t// When writing, an extended timestamp (which is timezone-agnostic) is\n+\t// always emitted. The legacy MS-DOS date field is encoded according to the\n+\t// location of the Modified time.\n+\tModified     time.Time\n+\tModifiedTime uint16 // Deprecated: Legacy MS-DOS date; use Modified instead.\n+\tModifiedDate uint16 // Deprecated: Legacy MS-DOS time; use Modified instead.\n+\n \tCRC32              uint32\n \tCompressedSize     uint32 // Deprecated: Use CompressedSize64 instead.\n \tUncompressedSize   uint32 // Deprecated: Use UncompressedSize64 instead.\n \tCompressedSize64   uint64\n \tUncompressedSize64 uint64\n \tExtra              []byte\n \tExternalAttrs      uint32 // Meaning depends on CreatorVersion\n-\tComment            string\n }\n \n // FileInfo returns an os.FileInfo for the FileHeader.\n@@ -117,6 +155,8 @@ func (fi headerFileInfo) Sys() interface{}   { return fi.fh }\n // Because os.FileInfo's Name method returns only the base name of\n // the file it describes, it may be necessary to modify the Name field\n // of the returned header to provide the full path name of the file.\n+// If compression is desired, callers should set the FileHeader.Method\n+// field; it is unset by default.\n func FileInfoHeader(fi os.FileInfo) (*FileHeader, error) {\n \tsize := fi.Size()\n \tfh := &FileHeader{\n@@ -144,6 +184,21 @@ type directoryEnd struct {\n \tcomment            string\n }\n \n+// timeZone returns a *time.Location based on the provided offset.\n+// If the offset is non-sensible, then this uses an offset of zero.\n+func timeZone(offset time.Duration) *time.Location {\n+\tconst (\n+\t\tminOffset   = -12 * time.Hour  // E.g., Baker island at -12:00\n+\t\tmaxOffset   = +14 * time.Hour  // E.g., Line island at +14:00\n+\t\toffsetAlias = 15 * time.Minute // E.g., Nepal at +5:45\n+\t)\n+\toffset = offset.Round(offsetAlias)\n+\tif offset < minOffset || maxOffset < offset {\n+\t\toffset = 0\n+\t}\n+\treturn time.FixedZone(\"\", int(offset/time.Second))\n+}\n+\n // msDosTimeToTime converts an MS-DOS date and time into a time.Time.\n // The resolution is 2s.\n // See: http://msdn.microsoft.com/en-us/library/ms724247(v=VS.85).aspx\n@@ -168,21 +223,26 @@ func msDosTimeToTime(dosDate, dosTime uint16) time.Time {\n // The resolution is 2s.\n // See: http://msdn.microsoft.com/en-us/library/ms724274(v=VS.85).aspx\n func timeToMsDosTime(t time.Time) (fDate uint16, fTime uint16) {\n-\tt = t.In(time.UTC)\n \tfDate = uint16(t.Day() + int(t.Month())<<5 + (t.Year()-1980)<<9)\n \tfTime = uint16(t.Second()/2 + t.Minute()<<5 + t.Hour()<<11)\n \treturn\n }\n \n-// ModTime returns the modification time in UTC.\n-// The resolution is 2s.\n+// ModTime returns the modification time in UTC using the legacy\n+// ModifiedDate and ModifiedTime fields.\n+//\n+// Deprecated: Use Modified instead.\n func (h *FileHeader) ModTime() time.Time {\n \treturn msDosTimeToTime(h.ModifiedDate, h.ModifiedTime)\n }\n \n-// SetModTime sets the ModifiedTime and ModifiedDate fields to the given time in UTC.\n-// The resolution is 2s.\n+// SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields\n+// to the given time in UTC.\n+//\n+// Deprecated: Use Modified instead.\n func (h *FileHeader) SetModTime(t time.Time) {\n+\tt = t.UTC() // Convert to UTC for compatibility\n+\th.Modified = t\n \th.ModifiedDate, h.ModifiedTime = timeToMsDosTime(t)\n }\n "}, {"sha": "eb85b57103e11a48eb210439f5d81f691c0cedc0", "filename": "libgo/go/archive/zip/testdata/time-22738.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-22738.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-22738.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-22738.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4f74819d11dbe46d53897bcd0569bb14c9e13639", "filename": "libgo/go/archive/zip/testdata/time-7zip.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-7zip.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-7zip.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-7zip.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f008805fa42c982a0e28e5abe025425dbc1a9ad9", "filename": "libgo/go/archive/zip/testdata/time-go.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-go.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-go.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-go.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8e6394891f0f1000d5aff4c14fff25659a00ac7c", "filename": "libgo/go/archive/zip/testdata/time-infozip.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-infozip.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-infozip.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-infozip.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "e82c5c229e0917b8e33029e7666e755961ab9e48", "filename": "libgo/go/archive/zip/testdata/time-osx.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-osx.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-osx.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-osx.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8ba222b224674153fb65b5be87ca89f434fcb110", "filename": "libgo/go/archive/zip/testdata/time-win7.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-win7.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-win7.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-win7.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "a8a19b0f8e2e9cca1cb49b4c85bbf67cb86781fc", "filename": "libgo/go/archive/zip/testdata/time-winrar.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-winrar.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-winrar.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-winrar.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f6e8f8ba067e462fe7a9727159390919571b8270", "filename": "libgo/go/archive/zip/testdata/time-winzip.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-winzip.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-winzip.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Ftime-winzip.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "0e97884559fa599f7376daf2478cf6cf516dc817", "filename": "libgo/go/archive/zip/testdata/utf8-7zip.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-7zip.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-7zip.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-7zip.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "25a892646cec2a10d19add86db7acb516556bea6", "filename": "libgo/go/archive/zip/testdata/utf8-infozip.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-infozip.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-infozip.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-infozip.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "9b0c058b5b5744d389e73e8afd9f6963426aaebf", "filename": "libgo/go/archive/zip/testdata/utf8-osx.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-osx.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-osx.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-osx.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4bad6c3a5e05f5e3749ee71079409eaca16fa943", "filename": "libgo/go/archive/zip/testdata/utf8-winrar.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-winrar.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-winrar.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-winrar.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "909d52ed2d9a6db86fdc7669bb355e7da2338a6e", "filename": "libgo/go/archive/zip/testdata/utf8-winzip.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-winzip.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-winzip.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Futf8-winzip.zip?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "14a5ee48c117a3af1a99ff75532a3ba160607837", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 114, "deletions": 23, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -14,13 +14,19 @@ import (\n \t\"unicode/utf8\"\n )\n \n+var (\n+\terrLongName  = errors.New(\"zip: FileHeader.Name too long\")\n+\terrLongExtra = errors.New(\"zip: FileHeader.Extra too long\")\n+)\n+\n // Writer implements a zip file writer.\n type Writer struct {\n \tcw          *countWriter\n \tdir         []*header\n \tlast        *fileWriter\n \tclosed      bool\n \tcompressors map[uint16]Compressor\n+\tcomment     string\n \n \t// testHookCloseSizeOffset if non-nil is called with the size\n \t// of offset of the central directory at Close.\n@@ -54,6 +60,16 @@ func (w *Writer) Flush() error {\n \treturn w.cw.w.(*bufio.Writer).Flush()\n }\n \n+// SetComment sets the end-of-central-directory comment field.\n+// It can only be called before Close.\n+func (w *Writer) SetComment(comment string) error {\n+\tif len(comment) > uint16max {\n+\t\treturn errors.New(\"zip: Writer.Comment too long\")\n+\t}\n+\tw.comment = comment\n+\treturn nil\n+}\n+\n // Close finishes writing the zip file by writing the central directory.\n // It does not (and cannot) close the underlying writer.\n func (w *Writer) Close() error {\n@@ -91,7 +107,7 @@ func (w *Writer) Close() error {\n \t\t\t// append a zip64 extra block to Extra\n \t\t\tvar buf [28]byte // 2x uint16 + 3x uint64\n \t\t\teb := writeBuf(buf[:])\n-\t\t\teb.uint16(zip64ExtraId)\n+\t\t\teb.uint16(zip64ExtraID)\n \t\t\teb.uint16(24) // size = 3x uint64\n \t\t\teb.uint64(h.UncompressedSize64)\n \t\t\teb.uint64(h.CompressedSize64)\n@@ -172,21 +188,25 @@ func (w *Writer) Close() error {\n \tvar buf [directoryEndLen]byte\n \tb := writeBuf(buf[:])\n \tb.uint32(uint32(directoryEndSignature))\n-\tb = b[4:]                 // skip over disk number and first disk number (2x uint16)\n-\tb.uint16(uint16(records)) // number of entries this disk\n-\tb.uint16(uint16(records)) // number of entries total\n-\tb.uint32(uint32(size))    // size of directory\n-\tb.uint32(uint32(offset))  // start of directory\n-\t// skipped size of comment (always zero)\n+\tb = b[4:]                        // skip over disk number and first disk number (2x uint16)\n+\tb.uint16(uint16(records))        // number of entries this disk\n+\tb.uint16(uint16(records))        // number of entries total\n+\tb.uint32(uint32(size))           // size of directory\n+\tb.uint32(uint32(offset))         // start of directory\n+\tb.uint16(uint16(len(w.comment))) // byte size of EOCD comment\n \tif _, err := w.cw.Write(buf[:]); err != nil {\n \t\treturn err\n \t}\n+\tif _, err := io.WriteString(w.cw, w.comment); err != nil {\n+\t\treturn err\n+\t}\n \n \treturn w.cw.w.(*bufio.Writer).Flush()\n }\n \n // Create adds a file to the zip file using the provided name.\n // It returns a Writer to which the file contents should be written.\n+// The file contents will be compressed using the Deflate method.\n // The name must be a relative path: it must not start with a drive\n // letter (e.g. C:) or leading slash, and only forward slashes are\n // allowed.\n@@ -200,27 +220,36 @@ func (w *Writer) Create(name string) (io.Writer, error) {\n \treturn w.CreateHeader(header)\n }\n \n-func hasValidUTF8(s string) bool {\n-\tn := 0\n-\tfor _, r := range s {\n-\t\t// By default, ZIP uses CP437, which is only identical to ASCII for the printable characters.\n-\t\tif r < 0x20 || r >= 0x7f {\n-\t\t\tif !utf8.ValidRune(r) {\n-\t\t\t\treturn false\n+// detectUTF8 reports whether s is a valid UTF-8 string, and whether the string\n+// must be considered UTF-8 encoding (i.e., not compatible with CP-437, ASCII,\n+// or any other common encoding).\n+func detectUTF8(s string) (valid, require bool) {\n+\tfor i := 0; i < len(s); {\n+\t\tr, size := utf8.DecodeRuneInString(s[i:])\n+\t\ti += size\n+\t\t// Officially, ZIP uses CP-437, but many readers use the system's\n+\t\t// local character encoding. Most encoding are compatible with a large\n+\t\t// subset of CP-437, which itself is ASCII-like.\n+\t\t//\n+\t\t// Forbid 0x7e and 0x5c since EUC-KR and Shift-JIS replace those\n+\t\t// characters with localized currency and overline characters.\n+\t\tif r < 0x20 || r > 0x7d || r == 0x5c {\n+\t\t\tif !utf8.ValidRune(r) || (r == utf8.RuneError && size == 1) {\n+\t\t\t\treturn false, false\n \t\t\t}\n-\t\t\tn++\n+\t\t\trequire = true\n \t\t}\n \t}\n-\treturn n > 0\n+\treturn true, require\n }\n \n-// CreateHeader adds a file to the zip file using the provided FileHeader\n-// for the file metadata.\n-// It returns a Writer to which the file contents should be written.\n+// CreateHeader adds a file to the zip archive using the provided FileHeader\n+// for the file metadata. Writer takes ownership of fh and may mutate\n+// its fields. The caller must not modify fh after calling CreateHeader.\n //\n+// This returns a Writer to which the file contents should be written.\n // The file's contents must be written to the io.Writer before the next\n-// call to Create, CreateHeader, or Close. The provided FileHeader fh\n-// must not be modified after a call to CreateHeader.\n+// call to Create, CreateHeader, or Close.\n func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \tif w.last != nil && !w.last.closed {\n \t\tif err := w.last.close(); err != nil {\n@@ -234,13 +263,62 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \n \tfh.Flags |= 0x8 // we will write a data descriptor\n \n-\tif hasValidUTF8(fh.Name) || hasValidUTF8(fh.Comment) {\n-\t\tfh.Flags |= 0x800 // filename or comment have valid utf-8 string\n+\t// The ZIP format has a sad state of affairs regarding character encoding.\n+\t// Officially, the name and comment fields are supposed to be encoded\n+\t// in CP-437 (which is mostly compatible with ASCII), unless the UTF-8\n+\t// flag bit is set. However, there are several problems:\n+\t//\n+\t//\t* Many ZIP readers still do not support UTF-8.\n+\t//\t* If the UTF-8 flag is cleared, several readers simply interpret the\n+\t//\tname and comment fields as whatever the local system encoding is.\n+\t//\n+\t// In order to avoid breaking readers without UTF-8 support,\n+\t// we avoid setting the UTF-8 flag if the strings are CP-437 compatible.\n+\t// However, if the strings require multibyte UTF-8 encoding and is a\n+\t// valid UTF-8 string, then we set the UTF-8 bit.\n+\t//\n+\t// For the case, where the user explicitly wants to specify the encoding\n+\t// as UTF-8, they will need to set the flag bit themselves.\n+\tutf8Valid1, utf8Require1 := detectUTF8(fh.Name)\n+\tutf8Valid2, utf8Require2 := detectUTF8(fh.Comment)\n+\tswitch {\n+\tcase fh.NonUTF8:\n+\t\tfh.Flags &^= 0x800\n+\tcase (utf8Require1 || utf8Require2) && (utf8Valid1 && utf8Valid2):\n+\t\tfh.Flags |= 0x800\n \t}\n \n \tfh.CreatorVersion = fh.CreatorVersion&0xff00 | zipVersion20 // preserve compatibility byte\n \tfh.ReaderVersion = zipVersion20\n \n+\t// If Modified is set, this takes precedence over MS-DOS timestamp fields.\n+\tif !fh.Modified.IsZero() {\n+\t\t// Contrary to the FileHeader.SetModTime method, we intentionally\n+\t\t// do not convert to UTC, because we assume the user intends to encode\n+\t\t// the date using the specified timezone. A user may want this control\n+\t\t// because many legacy ZIP readers interpret the timestamp according\n+\t\t// to the local timezone.\n+\t\t//\n+\t\t// The timezone is only non-UTC if a user directly sets the Modified\n+\t\t// field directly themselves. All other approaches sets UTC.\n+\t\tfh.ModifiedDate, fh.ModifiedTime = timeToMsDosTime(fh.Modified)\n+\n+\t\t// Use \"extended timestamp\" format since this is what Info-ZIP uses.\n+\t\t// Nearly every major ZIP implementation uses a different format,\n+\t\t// but at least most seem to be able to understand the other formats.\n+\t\t//\n+\t\t// This format happens to be identical for both local and central header\n+\t\t// if modification time is the only timestamp being encoded.\n+\t\tvar mbuf [9]byte // 2*SizeOf(uint16) + SizeOf(uint8) + SizeOf(uint32)\n+\t\tmt := uint32(fh.Modified.Unix())\n+\t\teb := writeBuf(mbuf[:])\n+\t\teb.uint16(extTimeExtraID)\n+\t\teb.uint16(5)  // Size: SizeOf(uint8) + SizeOf(uint32)\n+\t\teb.uint8(1)   // Flags: ModTime\n+\t\teb.uint32(mt) // ModTime\n+\t\tfh.Extra = append(fh.Extra, mbuf[:]...)\n+\t}\n+\n \tfw := &fileWriter{\n \t\tzipw:      w.cw,\n \t\tcompCount: &countWriter{w: w.cw},\n@@ -273,6 +351,14 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n }\n \n func writeHeader(w io.Writer, h *FileHeader) error {\n+\tconst maxUint16 = 1<<16 - 1\n+\tif len(h.Name) > maxUint16 {\n+\t\treturn errLongName\n+\t}\n+\tif len(h.Extra) > maxUint16 {\n+\t\treturn errLongExtra\n+\t}\n+\n \tvar buf [fileHeaderLen]byte\n \tb := writeBuf(buf[:])\n \tb.uint32(uint32(fileHeaderSignature))\n@@ -402,6 +488,11 @@ func (w nopCloser) Close() error {\n \n type writeBuf []byte\n \n+func (b *writeBuf) uint8(v uint8) {\n+\t(*b)[0] = v\n+\t*b = (*b)[1:]\n+}\n+\n func (b *writeBuf) uint16(v uint16) {\n \tbinary.LittleEndian.PutUint16(*b, v)\n \t*b = (*b)[2:]"}, {"sha": "38f32296fa87d263cedfde48c1476e71e81c4bb4", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 110, "deletions": 14, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -6,11 +6,14 @@ package zip\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"math/rand\"\n \t\"os\"\n+\t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n // TODO(adg): a more sophisticated test suite\n@@ -57,8 +60,8 @@ var writeTests = []WriteTest{\n \n func TestWriter(t *testing.T) {\n \tlargeData := make([]byte, 1<<17)\n-\tfor i := range largeData {\n-\t\tlargeData[i] = byte(rand.Int())\n+\tif _, err := rand.Read(largeData); err != nil {\n+\t\tt.Fatal(\"rand.Read failed:\", err)\n \t}\n \twriteTests[1].Data = largeData\n \tdefer func() {\n@@ -87,31 +90,100 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n+// TestWriterComment is test for EOCD comment read/write.\n+func TestWriterComment(t *testing.T) {\n+\tvar tests = []struct {\n+\t\tcomment string\n+\t\tok      bool\n+\t}{\n+\t\t{\"hi, hello\", true},\n+\t\t{\"hi, \u3053\u3093\u306b\u3061\u308f\", true},\n+\t\t{strings.Repeat(\"a\", uint16max), true},\n+\t\t{strings.Repeat(\"a\", uint16max+1), false},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\t// write a zip file\n+\t\tbuf := new(bytes.Buffer)\n+\t\tw := NewWriter(buf)\n+\t\tif err := w.SetComment(test.comment); err != nil {\n+\t\t\tif test.ok {\n+\t\t\t\tt.Fatalf(\"SetComment: unexpected error %v\", err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t} else {\n+\t\t\tif !test.ok {\n+\t\t\t\tt.Fatalf(\"SetComment: unexpected success, want error\")\n+\t\t\t}\n+\t\t}\n+\n+\t\tif err := w.Close(); test.ok == (err != nil) {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tif w.closed != test.ok {\n+\t\t\tt.Fatalf(\"Writer.closed: got %v, want %v\", w.closed, test.ok)\n+\t\t}\n+\n+\t\t// skip read test in failure cases\n+\t\tif !test.ok {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// read it back\n+\t\tr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif r.Comment != test.comment {\n+\t\t\tt.Fatalf(\"Reader.Comment: got %v, want %v\", r.Comment, test.comment)\n+\t\t}\n+\t}\n+}\n+\n func TestWriterUTF8(t *testing.T) {\n \tvar utf8Tests = []struct {\n \t\tname    string\n \t\tcomment string\n-\t\texpect  uint16\n+\t\tnonUTF8 bool\n+\t\tflags   uint16\n \t}{\n \t\t{\n \t\t\tname:    \"hi, hello\",\n \t\t\tcomment: \"in the world\",\n-\t\t\texpect:  0x8,\n+\t\t\tflags:   0x8,\n \t\t},\n \t\t{\n \t\t\tname:    \"hi, \u3053\u3093\u306b\u3061\u308f\",\n \t\t\tcomment: \"in the world\",\n-\t\t\texpect:  0x808,\n+\t\t\tflags:   0x808,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"hi, \u3053\u3093\u306b\u3061\u308f\",\n+\t\t\tcomment: \"in the world\",\n+\t\t\tnonUTF8: true,\n+\t\t\tflags:   0x8,\n \t\t},\n \t\t{\n \t\t\tname:    \"hi, hello\",\n \t\t\tcomment: \"in the \u4e16\u754c\",\n-\t\t\texpect:  0x808,\n+\t\t\tflags:   0x808,\n \t\t},\n \t\t{\n \t\t\tname:    \"hi, \u3053\u3093\u306b\u3061\u308f\",\n \t\t\tcomment: \"in the \u4e16\u754c\",\n-\t\t\texpect:  0x808,\n+\t\t\tflags:   0x808,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"the replacement rune is \ufffd\",\n+\t\t\tcomment: \"the replacement rune is \ufffd\",\n+\t\t\tflags:   0x808,\n+\t\t},\n+\t\t{\n+\t\t\t// Name is Japanese encoded in Shift JIS.\n+\t\t\tname:    \"\\x93\\xfa\\x96{\\x8c\\xea.txt\",\n+\t\t\tcomment: \"in the \u4e16\u754c\",\n+\t\t\tflags:   0x008, // UTF-8 must not be set\n \t\t},\n \t}\n \n@@ -123,6 +195,7 @@ func TestWriterUTF8(t *testing.T) {\n \t\th := &FileHeader{\n \t\t\tName:    test.name,\n \t\t\tComment: test.comment,\n+\t\t\tNonUTF8: test.nonUTF8,\n \t\t\tMethod:  Deflate,\n \t\t}\n \t\tw, err := w.CreateHeader(h)\n@@ -142,18 +215,41 @@ func TestWriterUTF8(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \tfor i, test := range utf8Tests {\n-\t\tgot := r.File[i].Flags\n-\t\tt.Logf(\"name %v, comment %v\", test.name, test.comment)\n-\t\tif got != test.expect {\n-\t\t\tt.Fatalf(\"Flags: got %v, want %v\", got, test.expect)\n+\t\tflags := r.File[i].Flags\n+\t\tif flags != test.flags {\n+\t\t\tt.Errorf(\"CreateHeader(name=%q comment=%q nonUTF8=%v): flags=%#x, want %#x\", test.name, test.comment, test.nonUTF8, flags, test.flags)\n \t\t}\n \t}\n }\n \n+func TestWriterTime(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\th := &FileHeader{\n+\t\tName:     \"test.txt\",\n+\t\tModified: time.Date(2017, 10, 31, 21, 11, 57, 0, timeZone(-7*time.Hour)),\n+\t}\n+\tw := NewWriter(&buf)\n+\tif _, err := w.CreateHeader(h); err != nil {\n+\t\tt.Fatalf(\"unexpected CreateHeader error: %v\", err)\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatalf(\"unexpected Close error: %v\", err)\n+\t}\n+\n+\twant, err := ioutil.ReadFile(\"testdata/time-go.zip\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected ReadFile error: %v\", err)\n+\t}\n+\tif got := buf.Bytes(); !bytes.Equal(got, want) {\n+\t\tfmt.Printf(\"%x\\n%x\\n\", got, want)\n+\t\tt.Error(\"contents of time-go.zip differ\")\n+\t}\n+}\n+\n func TestWriterOffset(t *testing.T) {\n \tlargeData := make([]byte, 1<<17)\n-\tfor i := range largeData {\n-\t\tlargeData[i] = byte(rand.Int())\n+\tif _, err := rand.Read(largeData); err != nil {\n+\t\tt.Fatal(\"rand.Read failed:\", err)\n \t}\n \twriteTests[1].Data = largeData\n \tdefer func() {\n@@ -225,7 +321,7 @@ func testReadFile(t *testing.T, f *File, wt *WriteTest) {\n \tif f.Name != wt.Name {\n \t\tt.Fatalf(\"File name: got %q, want %q\", f.Name, wt.Name)\n \t}\n-\ttestFileMode(t, wt.Name, f, wt.Mode)\n+\ttestFileMode(t, f, wt.Mode)\n \trc, err := f.Open()\n \tif err != nil {\n \t\tt.Fatal(\"opening:\", err)"}, {"sha": "7e02cb0eeaae24368c616851741ebac20f605ad4", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -645,16 +645,54 @@ func TestHeaderTooShort(t *testing.T) {\n \th := FileHeader{\n \t\tName:   \"foo.txt\",\n \t\tMethod: Deflate,\n-\t\tExtra:  []byte{zip64ExtraId}, // missing size and second half of tag, but Extra is best-effort parsing\n+\t\tExtra:  []byte{zip64ExtraID}, // missing size and second half of tag, but Extra is best-effort parsing\n \t}\n \ttestValidHeader(&h, t)\n }\n \n+func TestHeaderTooLongErr(t *testing.T) {\n+\tvar headerTests = []struct {\n+\t\tname    string\n+\t\textra   []byte\n+\t\twanterr error\n+\t}{\n+\t\t{\n+\t\t\tname:    strings.Repeat(\"x\", 1<<16),\n+\t\t\textra:   []byte{},\n+\t\t\twanterr: errLongName,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"long_extra\",\n+\t\t\textra:   bytes.Repeat([]byte{0xff}, 1<<16),\n+\t\t\twanterr: errLongExtra,\n+\t\t},\n+\t}\n+\n+\t// write a zip file\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriter(buf)\n+\n+\tfor _, test := range headerTests {\n+\t\th := &FileHeader{\n+\t\t\tName:  test.name,\n+\t\t\tExtra: test.extra,\n+\t\t}\n+\t\t_, err := w.CreateHeader(h)\n+\t\tif err != test.wanterr {\n+\t\t\tt.Errorf(\"error=%v, want %v\", err, test.wanterr)\n+\t\t}\n+\t}\n+\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n func TestHeaderIgnoredSize(t *testing.T) {\n \th := FileHeader{\n \t\tName:   \"foo.txt\",\n \t\tMethod: Deflate,\n-\t\tExtra:  []byte{zip64ExtraId & 0xFF, zip64ExtraId >> 8, 24, 0, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8}, // bad size but shouldn't be consulted\n+\t\tExtra:  []byte{zip64ExtraID & 0xFF, zip64ExtraID >> 8, 24, 0, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8}, // bad size but shouldn't be consulted\n \t}\n \ttestValidHeader(&h, t)\n }"}, {"sha": "ad9c9f5ddf79692b38bc445fbe75c8b4ee996ec0", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -62,6 +62,9 @@ func NewReader(rd io.Reader) *Reader {\n \treturn NewReaderSize(rd, defaultBufSize)\n }\n \n+// Size returns the size of the underlying buffer in bytes.\n+func (r *Reader) Size() int { return len(r.buf) }\n+\n // Reset discards any buffered data, resets all state, and switches\n // the buffered reader to read from r.\n func (b *Reader) Reset(r io.Reader) {\n@@ -548,6 +551,9 @@ func NewWriter(w io.Writer) *Writer {\n \treturn NewWriterSize(w, defaultBufSize)\n }\n \n+// Size returns the size of the underlying buffer in bytes.\n+func (b *Writer) Size() int { return len(b.buf) }\n+\n // Reset discards any unflushed buffered data, clears any error, and\n // resets b to write its output to w.\n func (b *Writer) Reset(w io.Writer) {"}, {"sha": "c829d2b0648ab7c10e55ab006a677776c1c94062", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -1418,6 +1418,24 @@ func TestReaderDiscard(t *testing.T) {\n \n }\n \n+func TestReaderSize(t *testing.T) {\n+\tif got, want := NewReader(nil).Size(), DefaultBufSize; got != want {\n+\t\tt.Errorf(\"NewReader's Reader.Size = %d; want %d\", got, want)\n+\t}\n+\tif got, want := NewReaderSize(nil, 1234).Size(), 1234; got != want {\n+\t\tt.Errorf(\"NewReaderSize's Reader.Size = %d; want %d\", got, want)\n+\t}\n+}\n+\n+func TestWriterSize(t *testing.T) {\n+\tif got, want := NewWriter(nil).Size(), DefaultBufSize; got != want {\n+\t\tt.Errorf(\"NewWriter's Writer.Size = %d; want %d\", got, want)\n+\t}\n+\tif got, want := NewWriterSize(nil, 1234).Size(), 1234; got != want {\n+\t\tt.Errorf(\"NewWriterSize's Writer.Size = %d; want %d\", got, want)\n+\t}\n+}\n+\n // An onlyReader only implements io.Reader, no matter what other methods the underlying implementation may have.\n type onlyReader struct {\n \tio.Reader"}, {"sha": "1667f01a841e07cba04c62e8cf7da7ab3593ca2b", "filename": "libgo/go/bufio/export_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fexport_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -11,6 +11,8 @@ import (\n \n var IsSpace = isSpace\n \n+const DefaultBufSize = defaultBufSize\n+\n func (s *Scanner) MaxTokenSize(n int) {\n \tif n < utf8.UTFMax || n > 1e9 {\n \t\tpanic(\"bad max token size\")"}, {"sha": "40aaa4ab817b81c10dbdff502be0f8b164082f1b", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -123,8 +123,9 @@ var ErrFinalToken = errors.New(\"final token\")\n // After Scan returns false, the Err method will return any error that\n // occurred during scanning, except that if it was io.EOF, Err\n // will return nil.\n-// Scan panics if the split function returns 100 empty tokens without\n-// advancing the input. This is a common error mode for scanners.\n+// Scan panics if the split function returns too many empty\n+// tokens without advancing the input. This is a common error mode for\n+// scanners.\n func (s *Scanner) Scan() bool {\n \tif s.done {\n \t\treturn false\n@@ -156,8 +157,8 @@ func (s *Scanner) Scan() bool {\n \t\t\t\t} else {\n \t\t\t\t\t// Returning tokens not advancing input at EOF.\n \t\t\t\t\ts.empties++\n-\t\t\t\t\tif s.empties > 100 {\n-\t\t\t\t\t\tpanic(\"bufio.Scan: 100 empty tokens without progressing\")\n+\t\t\t\t\tif s.empties > maxConsecutiveEmptyReads {\n+\t\t\t\t\t\tpanic(\"bufio.Scan: too many empty tokens without progressing\")\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\treturn true"}, {"sha": "4578c855a9e5763daca1b1b4fb01a380e149c6c7", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -171,8 +171,9 @@ func cap(v Type) int\n //\tSlice: The size specifies the length. The capacity of the slice is\n //\tequal to its length. A second integer argument may be provided to\n //\tspecify a different capacity; it must be no smaller than the\n-//\tlength, so make([]int, 0, 10) allocates a slice of length 0 and\n-//\tcapacity 10.\n+//\tlength. For example, make([]int, 0, 10) allocates an underlying array\n+//\tof size 10 and returns a slice of length 0 and capacity 10 that is\n+//\tbacked by this underlying array.\n //\tMap: An empty map is allocated with enough space to hold the\n //\tspecified number of elements. The size may be omitted, in which case\n //\ta small starting size is allocated."}, {"sha": "ea84f1e40fd856d3f2a173e83fc965c89ffcc00d", "filename": "libgo/go/bytes/boundary_test.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fboundary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fboundary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fboundary_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+//\n+// +build linux\n+\n+package bytes_test\n+\n+import (\n+\t. \"bytes\"\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+// This file tests the situation where byte operations are checking\n+// data very near to a page boundary. We want to make sure those\n+// operations do not read across the boundary and cause a page\n+// fault where they shouldn't.\n+\n+// These tests run only on linux. The code being tested is\n+// not OS-specific, so it does not need to be tested on all\n+// operating systems.\n+\n+// dangerousSlice returns a slice which is immediately\n+// preceded and followed by a faulting page.\n+func dangerousSlice(t *testing.T) []byte {\n+\tpagesize := syscall.Getpagesize()\n+\tb, err := syscall.Mmap(0, 0, 3*pagesize, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_ANONYMOUS|syscall.MAP_PRIVATE)\n+\tif err != nil {\n+\t\tt.Fatalf(\"mmap failed %s\", err)\n+\t}\n+\terr = syscall.Mprotect(b[:pagesize], syscall.PROT_NONE)\n+\tif err != nil {\n+\t\tt.Fatalf(\"mprotect low failed %s\\n\", err)\n+\t}\n+\terr = syscall.Mprotect(b[2*pagesize:], syscall.PROT_NONE)\n+\tif err != nil {\n+\t\tt.Fatalf(\"mprotect high failed %s\\n\", err)\n+\t}\n+\treturn b[pagesize : 2*pagesize]\n+}\n+\n+func TestEqualNearPageBoundary(t *testing.T) {\n+\tt.Parallel()\n+\tb := dangerousSlice(t)\n+\tfor i := range b {\n+\t\tb[i] = 'A'\n+\t}\n+\tfor i := 0; i <= len(b); i++ {\n+\t\tEqual(b[:i], b[len(b)-i:])\n+\t\tEqual(b[len(b)-i:], b[:i])\n+\t}\n+}\n+\n+func TestIndexByteNearPageBoundary(t *testing.T) {\n+\tt.Parallel()\n+\tb := dangerousSlice(t)\n+\tfor i := range b {\n+\t\tidx := IndexByte(b[i:], 1)\n+\t\tif idx != -1 {\n+\t\t\tt.Fatalf(\"IndexByte(b[%d:])=%d, want -1\\n\", i, idx)\n+\t\t}\n+\t}\n+}\n+\n+func TestIndexNearPageBoundary(t *testing.T) {\n+\tt.Parallel()\n+\tvar q [64]byte\n+\tb := dangerousSlice(t)\n+\tif len(b) > 256 {\n+\t\t// Only worry about when we're near the end of a page.\n+\t\tb = b[len(b)-256:]\n+\t}\n+\tfor j := 1; j < len(q); j++ {\n+\t\tq[j-1] = 1 // difference is only found on the last byte\n+\t\tfor i := range b {\n+\t\t\tidx := Index(b[i:], q[:j])\n+\t\t\tif idx != -1 {\n+\t\t\t\tt.Fatalf(\"Index(b[%d:], q[:%d])=%d, want -1\\n\", i, j, idx)\n+\t\t\t}\n+\t\t}\n+\t\tq[j-1] = 0\n+\t}\n+}"}, {"sha": "dc9d5e95d32ba1c457bbf12e6e011f493397da0b", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -15,34 +15,37 @@ import (\n // A Buffer is a variable-sized buffer of bytes with Read and Write methods.\n // The zero value for Buffer is an empty buffer ready to use.\n type Buffer struct {\n-\tbuf      []byte // contents are the bytes buf[off : len(buf)]\n-\toff      int    // read at &buf[off], write at &buf[len(buf)]\n-\tlastRead readOp // last read operation, so that Unread* can work correctly.\n-\t// FIXME: lastRead can fit in a single byte\n+\tbuf       []byte   // contents are the bytes buf[off : len(buf)]\n+\toff       int      // read at &buf[off], write at &buf[len(buf)]\n+\tbootstrap [64]byte // memory to hold first slice; helps small buffers avoid allocation.\n+\tlastRead  readOp   // last read operation, so that Unread* can work correctly.\n \n-\t// memory to hold first slice; helps small buffers avoid allocation.\n \t// FIXME: it would be advisable to align Buffer to cachelines to avoid false\n \t// sharing.\n-\tbootstrap [64]byte\n }\n \n // The readOp constants describe the last action performed on\n // the buffer, so that UnreadRune and UnreadByte can check for\n // invalid usage. opReadRuneX constants are chosen such that\n // converted to int they correspond to the rune size that was read.\n-type readOp int\n+type readOp int8\n \n+// Don't use iota for these, as the values need to correspond with the\n+// names and comments, which is easier to see when being explicit.\n const (\n \topRead      readOp = -1 // Any other read operation.\n-\topInvalid          = 0  // Non-read operation.\n-\topReadRune1        = 1  // Read rune of size 1.\n-\topReadRune2        = 2  // Read rune of size 2.\n-\topReadRune3        = 3  // Read rune of size 3.\n-\topReadRune4        = 4  // Read rune of size 4.\n+\topInvalid   readOp = 0  // Non-read operation.\n+\topReadRune1 readOp = 1  // Read rune of size 1.\n+\topReadRune2 readOp = 2  // Read rune of size 2.\n+\topReadRune3 readOp = 3  // Read rune of size 3.\n+\topReadRune4 readOp = 4  // Read rune of size 4.\n )\n \n // ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.\n var ErrTooLarge = errors.New(\"bytes.Buffer: too large\")\n+var errNegativeRead = errors.New(\"bytes.Buffer: reader returned negative count from Read\")\n+\n+const maxInt = int(^uint(0) >> 1)\n \n // Bytes returns a slice of length b.Len() holding the unread portion of the buffer.\n // The slice is valid for use only until the next buffer modification (that is,\n@@ -53,6 +56,8 @@ func (b *Buffer) Bytes() []byte { return b.buf[b.off:] }\n \n // String returns the contents of the unread portion of the buffer\n // as a string. If the Buffer is a nil pointer, it returns \"<nil>\".\n+//\n+// To build strings more efficiently, see the strings.Builder type.\n func (b *Buffer) String() string {\n \tif b == nil {\n \t\t// Special case, useful in debugging.\n@@ -61,6 +66,9 @@ func (b *Buffer) String() string {\n \treturn string(b.buf[b.off:])\n }\n \n+// empty returns whether the unread portion of the buffer is empty.\n+func (b *Buffer) empty() bool { return len(b.buf) <= b.off }\n+\n // Len returns the number of bytes of the unread portion of the buffer;\n // b.Len() == len(b.Bytes()).\n func (b *Buffer) Len() int { return len(b.buf) - b.off }\n@@ -81,7 +89,7 @@ func (b *Buffer) Truncate(n int) {\n \tif n < 0 || n > b.Len() {\n \t\tpanic(\"bytes.Buffer: truncation out of range\")\n \t}\n-\tb.buf = b.buf[0 : b.off+n]\n+\tb.buf = b.buf[:b.off+n]\n }\n \n // Reset resets the buffer to be empty,\n@@ -97,7 +105,7 @@ func (b *Buffer) Reset() {\n // internal buffer only needs to be resliced.\n // It returns the index where bytes should be written and whether it succeeded.\n func (b *Buffer) tryGrowByReslice(n int) (int, bool) {\n-\tif l := len(b.buf); l+n <= cap(b.buf) {\n+\tif l := len(b.buf); n <= cap(b.buf)-l {\n \t\tb.buf = b.buf[:l+n]\n \t\treturn l, true\n \t}\n@@ -122,15 +130,18 @@ func (b *Buffer) grow(n int) int {\n \t\tb.buf = b.bootstrap[:n]\n \t\treturn 0\n \t}\n-\tif m+n <= cap(b.buf)/2 {\n+\tc := cap(b.buf)\n+\tif n <= c/2-m {\n \t\t// We can slide things down instead of allocating a new\n-\t\t// slice. We only need m+n <= cap(b.buf) to slide, but\n+\t\t// slice. We only need m+n <= c to slide, but\n \t\t// we instead let capacity get twice as large so we\n \t\t// don't spend all our time copying.\n-\t\tcopy(b.buf[:], b.buf[b.off:])\n+\t\tcopy(b.buf, b.buf[b.off:])\n+\t} else if c > maxInt-c-n {\n+\t\tpanic(ErrTooLarge)\n \t} else {\n \t\t// Not enough space anywhere, we need to allocate.\n-\t\tbuf := makeSlice(2*cap(b.buf) + n)\n+\t\tbuf := makeSlice(2*c + n)\n \t\tcopy(buf, b.buf[b.off:])\n \t\tb.buf = buf\n \t}\n@@ -150,7 +161,7 @@ func (b *Buffer) Grow(n int) {\n \t\tpanic(\"bytes.Buffer.Grow: negative count\")\n \t}\n \tm := b.grow(n)\n-\tb.buf = b.buf[0:m]\n+\tb.buf = b.buf[:m]\n }\n \n // Write appends the contents of p to the buffer, growing the buffer as\n@@ -189,34 +200,22 @@ const MinRead = 512\n // buffer becomes too large, ReadFrom will panic with ErrTooLarge.\n func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n \tb.lastRead = opInvalid\n-\t// If buffer is empty, reset to recover space.\n-\tif b.off >= len(b.buf) {\n-\t\tb.Reset()\n-\t}\n \tfor {\n-\t\tif free := cap(b.buf) - len(b.buf); free < MinRead {\n-\t\t\t// not enough space at end\n-\t\t\tnewBuf := b.buf\n-\t\t\tif b.off+free < MinRead {\n-\t\t\t\t// not enough space using beginning of buffer;\n-\t\t\t\t// double buffer capacity\n-\t\t\t\tnewBuf = makeSlice(2*cap(b.buf) + MinRead)\n-\t\t\t}\n-\t\t\tcopy(newBuf, b.buf[b.off:])\n-\t\t\tb.buf = newBuf[:len(b.buf)-b.off]\n-\t\t\tb.off = 0\n+\t\ti := b.grow(MinRead)\n+\t\tm, e := r.Read(b.buf[i:cap(b.buf)])\n+\t\tif m < 0 {\n+\t\t\tpanic(errNegativeRead)\n \t\t}\n-\t\tm, e := r.Read(b.buf[len(b.buf):cap(b.buf)])\n-\t\tb.buf = b.buf[0 : len(b.buf)+m]\n+\n+\t\tb.buf = b.buf[:i+m]\n \t\tn += int64(m)\n \t\tif e == io.EOF {\n-\t\t\tbreak\n+\t\t\treturn n, nil // e is EOF, so return nil explicitly\n \t\t}\n \t\tif e != nil {\n \t\t\treturn n, e\n \t\t}\n \t}\n-\treturn n, nil // err is EOF, so return nil explicitly\n }\n \n // makeSlice allocates a slice of size n. If the allocation fails, it panics\n@@ -237,8 +236,7 @@ func makeSlice(n int) []byte {\n // encountered during the write is also returned.\n func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n \tb.lastRead = opInvalid\n-\tif b.off < len(b.buf) {\n-\t\tnBytes := b.Len()\n+\tif nBytes := b.Len(); nBytes > 0 {\n \t\tm, e := w.Write(b.buf[b.off:])\n \t\tif m > nBytes {\n \t\t\tpanic(\"bytes.Buffer.WriteTo: invalid Write count\")\n@@ -256,7 +254,7 @@ func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n \t}\n \t// Buffer is now empty; reset.\n \tb.Reset()\n-\treturn\n+\treturn n, nil\n }\n \n // WriteByte appends the byte c to the buffer, growing the buffer as needed.\n@@ -298,11 +296,11 @@ func (b *Buffer) WriteRune(r rune) (n int, err error) {\n // otherwise it is nil.\n func (b *Buffer) Read(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n-\tif b.off >= len(b.buf) {\n+\tif b.empty() {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Reset()\n \t\tif len(p) == 0 {\n-\t\t\treturn\n+\t\t\treturn 0, nil\n \t\t}\n \t\treturn 0, io.EOF\n \t}\n@@ -311,7 +309,7 @@ func (b *Buffer) Read(p []byte) (n int, err error) {\n \tif n > 0 {\n \t\tb.lastRead = opRead\n \t}\n-\treturn\n+\treturn n, nil\n }\n \n // Next returns a slice containing the next n bytes from the buffer,\n@@ -335,8 +333,7 @@ func (b *Buffer) Next(n int) []byte {\n // ReadByte reads and returns the next byte from the buffer.\n // If no byte is available, it returns error io.EOF.\n func (b *Buffer) ReadByte() (byte, error) {\n-\tb.lastRead = opInvalid\n-\tif b.off >= len(b.buf) {\n+\tif b.empty() {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Reset()\n \t\treturn 0, io.EOF\n@@ -353,8 +350,7 @@ func (b *Buffer) ReadByte() (byte, error) {\n // If the bytes are an erroneous UTF-8 encoding, it\n // consumes one byte and returns U+FFFD, 1.\n func (b *Buffer) ReadRune() (r rune, size int, err error) {\n-\tb.lastRead = opInvalid\n-\tif b.off >= len(b.buf) {\n+\tif b.empty() {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Reset()\n \t\treturn 0, 0, io.EOF\n@@ -413,7 +409,7 @@ func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) {\n \t// return a copy of slice. The buffer's backing array may\n \t// be overwritten by later calls.\n \tline = append(line, slice...)\n-\treturn\n+\treturn line, err\n }\n \n // readSlice is like ReadBytes but returns a reference to internal buffer data."}, {"sha": "e4bbc12f6a13524f6009c805468a5d7574b1a276", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -6,25 +6,27 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n-\t\"internal/testenv\"\n \t\"io\"\n \t\"math/rand\"\n-\t\"os/exec\"\n \t\"runtime\"\n \t\"testing\"\n \t\"unicode/utf8\"\n )\n \n-const N = 10000      // make this bigger for a larger (and slower) test\n-var data string      // test data for write tests\n-var testBytes []byte // test data; same as data but as a slice.\n+const N = 10000       // make this bigger for a larger (and slower) test\n+var testString string // test data for write tests\n+var testBytes []byte  // test data; same as testString but as a slice.\n+\n+type negativeReader struct{}\n+\n+func (r *negativeReader) Read([]byte) (int, error) { return -1, nil }\n \n func init() {\n \ttestBytes = make([]byte, N)\n \tfor i := 0; i < N; i++ {\n \t\ttestBytes[i] = 'a' + byte(i%26)\n \t}\n-\tdata = string(testBytes)\n+\ttestString = string(testBytes)\n }\n \n // Verify that contents of buf match the string s.\n@@ -88,12 +90,12 @@ func fillBytes(t *testing.T, testname string, buf *Buffer, s string, n int, fub\n \n func TestNewBuffer(t *testing.T) {\n \tbuf := NewBuffer(testBytes)\n-\tcheck(t, \"NewBuffer\", buf, data)\n+\tcheck(t, \"NewBuffer\", buf, testString)\n }\n \n func TestNewBufferString(t *testing.T) {\n-\tbuf := NewBufferString(data)\n-\tcheck(t, \"NewBufferString\", buf, data)\n+\tbuf := NewBufferString(testString)\n+\tcheck(t, \"NewBufferString\", buf, testString)\n }\n \n // Empty buf through repeated reads into fub.\n@@ -128,7 +130,7 @@ func TestBasicOperations(t *testing.T) {\n \t\tbuf.Truncate(0)\n \t\tcheck(t, \"TestBasicOperations (3)\", &buf, \"\")\n \n-\t\tn, err := buf.Write([]byte(data[0:1]))\n+\t\tn, err := buf.Write(testBytes[0:1])\n \t\tif n != 1 {\n \t\t\tt.Errorf(\"wrote 1 byte, but n == %d\", n)\n \t\t}\n@@ -137,30 +139,30 @@ func TestBasicOperations(t *testing.T) {\n \t\t}\n \t\tcheck(t, \"TestBasicOperations (4)\", &buf, \"a\")\n \n-\t\tbuf.WriteByte(data[1])\n+\t\tbuf.WriteByte(testString[1])\n \t\tcheck(t, \"TestBasicOperations (5)\", &buf, \"ab\")\n \n-\t\tn, err = buf.Write([]byte(data[2:26]))\n+\t\tn, err = buf.Write(testBytes[2:26])\n \t\tif n != 24 {\n-\t\t\tt.Errorf(\"wrote 25 bytes, but n == %d\", n)\n+\t\t\tt.Errorf(\"wrote 24 bytes, but n == %d\", n)\n \t\t}\n-\t\tcheck(t, \"TestBasicOperations (6)\", &buf, string(data[0:26]))\n+\t\tcheck(t, \"TestBasicOperations (6)\", &buf, testString[0:26])\n \n \t\tbuf.Truncate(26)\n-\t\tcheck(t, \"TestBasicOperations (7)\", &buf, string(data[0:26]))\n+\t\tcheck(t, \"TestBasicOperations (7)\", &buf, testString[0:26])\n \n \t\tbuf.Truncate(20)\n-\t\tcheck(t, \"TestBasicOperations (8)\", &buf, string(data[0:20]))\n+\t\tcheck(t, \"TestBasicOperations (8)\", &buf, testString[0:20])\n \n-\t\tempty(t, \"TestBasicOperations (9)\", &buf, string(data[0:20]), make([]byte, 5))\n+\t\tempty(t, \"TestBasicOperations (9)\", &buf, testString[0:20], make([]byte, 5))\n \t\tempty(t, \"TestBasicOperations (10)\", &buf, \"\", make([]byte, 100))\n \n-\t\tbuf.WriteByte(data[1])\n+\t\tbuf.WriteByte(testString[1])\n \t\tc, err := buf.ReadByte()\n \t\tif err != nil {\n \t\t\tt.Error(\"ReadByte unexpected eof\")\n \t\t}\n-\t\tif c != data[1] {\n+\t\tif c != testString[1] {\n \t\t\tt.Errorf(\"ReadByte wrong value c=%v\", c)\n \t\t}\n \t\tc, err = buf.ReadByte()\n@@ -177,8 +179,8 @@ func TestLargeStringWrites(t *testing.T) {\n \t\tlimit = 9\n \t}\n \tfor i := 3; i < limit; i += 3 {\n-\t\ts := fillString(t, \"TestLargeWrites (1)\", &buf, \"\", 5, data)\n-\t\tempty(t, \"TestLargeStringWrites (2)\", &buf, s, make([]byte, len(data)/i))\n+\t\ts := fillString(t, \"TestLargeWrites (1)\", &buf, \"\", 5, testString)\n+\t\tempty(t, \"TestLargeStringWrites (2)\", &buf, s, make([]byte, len(testString)/i))\n \t}\n \tcheck(t, \"TestLargeStringWrites (3)\", &buf, \"\")\n }\n@@ -191,16 +193,16 @@ func TestLargeByteWrites(t *testing.T) {\n \t}\n \tfor i := 3; i < limit; i += 3 {\n \t\ts := fillBytes(t, \"TestLargeWrites (1)\", &buf, \"\", 5, testBytes)\n-\t\tempty(t, \"TestLargeByteWrites (2)\", &buf, s, make([]byte, len(data)/i))\n+\t\tempty(t, \"TestLargeByteWrites (2)\", &buf, s, make([]byte, len(testString)/i))\n \t}\n \tcheck(t, \"TestLargeByteWrites (3)\", &buf, \"\")\n }\n \n func TestLargeStringReads(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n-\t\ts := fillString(t, \"TestLargeReads (1)\", &buf, \"\", 5, data[0:len(data)/i])\n-\t\tempty(t, \"TestLargeReads (2)\", &buf, s, make([]byte, len(data)))\n+\t\ts := fillString(t, \"TestLargeReads (1)\", &buf, \"\", 5, testString[0:len(testString)/i])\n+\t\tempty(t, \"TestLargeReads (2)\", &buf, s, make([]byte, len(testString)))\n \t}\n \tcheck(t, \"TestLargeStringReads (3)\", &buf, \"\")\n }\n@@ -209,7 +211,7 @@ func TestLargeByteReads(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n \t\ts := fillBytes(t, \"TestLargeReads (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n-\t\tempty(t, \"TestLargeReads (2)\", &buf, s, make([]byte, len(data)))\n+\t\tempty(t, \"TestLargeReads (2)\", &buf, s, make([]byte, len(testString)))\n \t}\n \tcheck(t, \"TestLargeByteReads (3)\", &buf, \"\")\n }\n@@ -218,14 +220,14 @@ func TestMixedReadsAndWrites(t *testing.T) {\n \tvar buf Buffer\n \ts := \"\"\n \tfor i := 0; i < 50; i++ {\n-\t\twlen := rand.Intn(len(data))\n+\t\twlen := rand.Intn(len(testString))\n \t\tif i%2 == 0 {\n-\t\t\ts = fillString(t, \"TestMixedReadsAndWrites (1)\", &buf, s, 1, data[0:wlen])\n+\t\t\ts = fillString(t, \"TestMixedReadsAndWrites (1)\", &buf, s, 1, testString[0:wlen])\n \t\t} else {\n \t\t\ts = fillBytes(t, \"TestMixedReadsAndWrites (1)\", &buf, s, 1, testBytes[0:wlen])\n \t\t}\n \n-\t\trlen := rand.Intn(len(data))\n+\t\trlen := rand.Intn(len(testString))\n \t\tfub := make([]byte, rlen)\n \t\tn, _ := buf.Read(fub)\n \t\ts = s[n:]\n@@ -263,17 +265,37 @@ func TestReadFrom(t *testing.T) {\n \t\ts := fillBytes(t, \"TestReadFrom (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n \t\tvar b Buffer\n \t\tb.ReadFrom(&buf)\n-\t\tempty(t, \"TestReadFrom (2)\", &b, s, make([]byte, len(data)))\n+\t\tempty(t, \"TestReadFrom (2)\", &b, s, make([]byte, len(testString)))\n \t}\n }\n \n+func TestReadFromNegativeReader(t *testing.T) {\n+\tvar b Buffer\n+\tdefer func() {\n+\t\tswitch err := recover().(type) {\n+\t\tcase nil:\n+\t\t\tt.Fatal(\"bytes.Buffer.ReadFrom didn't panic\")\n+\t\tcase error:\n+\t\t\t// this is the error string of errNegativeRead\n+\t\t\twantError := \"bytes.Buffer: reader returned negative count from Read\"\n+\t\t\tif err.Error() != wantError {\n+\t\t\t\tt.Fatalf(\"recovered panic: got %v, want %v\", err.Error(), wantError)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"unexpected panic value: %#v\", err)\n+\t\t}\n+\t}()\n+\n+\tb.ReadFrom(new(negativeReader))\n+}\n+\n func TestWriteTo(t *testing.T) {\n \tvar buf Buffer\n \tfor i := 3; i < 30; i += 3 {\n \t\ts := fillBytes(t, \"TestWriteTo (1)\", &buf, \"\", 5, testBytes[0:len(testBytes)/i])\n \t\tvar b Buffer\n \t\tbuf.WriteTo(&b)\n-\t\tempty(t, \"TestWriteTo (2)\", &b, s, make([]byte, len(data)))\n+\t\tempty(t, \"TestWriteTo (2)\", &b, s, make([]byte, len(testString)))\n \t}\n }\n \n@@ -473,6 +495,18 @@ func TestGrow(t *testing.T) {\n \t}\n }\n \n+func TestGrowOverflow(t *testing.T) {\n+\tdefer func() {\n+\t\tif err := recover(); err != ErrTooLarge {\n+\t\t\tt.Errorf(\"after too-large Grow, recover() = %v; want %v\", err, ErrTooLarge)\n+\t\t}\n+\t}()\n+\n+\tbuf := NewBuffer(make([]byte, 1))\n+\tconst maxInt = int(^uint(0) >> 1)\n+\tbuf.Grow(maxInt)\n+}\n+\n // Was a bug: used to give EOF reading empty slice at EOF.\n func TestReadEmptyAtEOF(t *testing.T) {\n \tb := new(Buffer)\n@@ -548,26 +582,6 @@ func TestBufferGrowth(t *testing.T) {\n \t}\n }\n \n-// Test that tryGrowByReslice is inlined.\n-// Only execute on \"linux-amd64\" builder in order to avoid breakage.\n-func TestTryGrowByResliceInlined(t *testing.T) {\n-\ttargetBuilder := \"linux-amd64\"\n-\tif testenv.Builder() != targetBuilder {\n-\t\tt.Skipf(\"%q gets executed on %q builder only\", t.Name(), targetBuilder)\n-\t}\n-\tt.Parallel()\n-\tgoBin := testenv.GoToolPath(t)\n-\tout, err := exec.Command(goBin, \"tool\", \"nm\", goBin).CombinedOutput()\n-\tif err != nil {\n-\t\tt.Fatalf(\"go tool nm: %v: %s\", err, out)\n-\t}\n-\t// Verify this doesn't exist:\n-\tsym := \"bytes.(*Buffer).tryGrowByReslice\"\n-\tif Contains(out, []byte(sym)) {\n-\t\tt.Errorf(\"found symbol %q in cmd/go, but should be inlined\", sym)\n-\t}\n-}\n-\n func BenchmarkWriteByte(b *testing.B) {\n \tconst n = 4 << 10\n \tb.SetBytes(n)"}, {"sha": "9af177fa882d7e17376649395721e183332211e3", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 200, "deletions": 92, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -39,7 +39,7 @@ func explode(s []byte, n int) [][]byte {\n \t\t\tbreak\n \t\t}\n \t\t_, size = utf8.DecodeRune(s)\n-\t\ta[na] = s[0:size]\n+\t\ta[na] = s[0:size:size]\n \t\ts = s[size:]\n \t\tna++\n \t}\n@@ -68,12 +68,12 @@ func Contains(b, subslice []byte) bool {\n \treturn Index(b, subslice) != -1\n }\n \n-// ContainsAny reports whether any of the UTF-8-encoded Unicode code points in chars are within b.\n+// ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n func ContainsAny(b []byte, chars string) bool {\n \treturn IndexAny(b, chars) >= 0\n }\n \n-// ContainsRune reports whether the Unicode code point r is within b.\n+// ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n func ContainsRune(b []byte, r rune) bool {\n \treturn IndexRune(b, r) >= 0\n }\n@@ -112,7 +112,7 @@ func LastIndexByte(s []byte, c byte) int {\n \treturn -1\n }\n \n-// IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points.\n+// IndexRune interprets s as a sequence of UTF-8-encoded code points.\n // It returns the byte index of the first occurrence in s of the given rune.\n // It returns -1 if rune is not present in s.\n // If r is utf8.RuneError, it returns the first instance of any\n@@ -144,29 +144,31 @@ func IndexRune(s []byte, r rune) int {\n // code points in chars. It returns -1 if chars is empty or if there is no code\n // point in common.\n func IndexAny(s []byte, chars string) int {\n-\tif len(chars) > 0 {\n-\t\tif len(s) > 8 {\n-\t\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n-\t\t\t\tfor i, c := range s {\n-\t\t\t\t\tif as.contains(c) {\n-\t\t\t\t\t\treturn i\n-\t\t\t\t\t}\n+\tif chars == \"\" {\n+\t\t// Avoid scanning all of s.\n+\t\treturn -1\n+\t}\n+\tif len(s) > 8 {\n+\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n+\t\t\tfor i, c := range s {\n+\t\t\t\tif as.contains(c) {\n+\t\t\t\t\treturn i\n \t\t\t\t}\n-\t\t\t\treturn -1\n \t\t\t}\n+\t\t\treturn -1\n \t\t}\n-\t\tvar width int\n-\t\tfor i := 0; i < len(s); i += width {\n-\t\t\tr := rune(s[i])\n-\t\t\tif r < utf8.RuneSelf {\n-\t\t\t\twidth = 1\n-\t\t\t} else {\n-\t\t\t\tr, width = utf8.DecodeRune(s[i:])\n-\t\t\t}\n-\t\t\tfor _, ch := range chars {\n-\t\t\t\tif r == ch {\n-\t\t\t\t\treturn i\n-\t\t\t\t}\n+\t}\n+\tvar width int\n+\tfor i := 0; i < len(s); i += width {\n+\t\tr := rune(s[i])\n+\t\tif r < utf8.RuneSelf {\n+\t\t\twidth = 1\n+\t\t} else {\n+\t\t\tr, width = utf8.DecodeRune(s[i:])\n+\t\t}\n+\t\tfor _, ch := range chars {\n+\t\t\tif r == ch {\n+\t\t\t\treturn i\n \t\t\t}\n \t\t}\n \t}\n@@ -178,24 +180,26 @@ func IndexAny(s []byte, chars string) int {\n // the Unicode code points in chars. It returns -1 if chars is empty or if\n // there is no code point in common.\n func LastIndexAny(s []byte, chars string) int {\n-\tif len(chars) > 0 {\n-\t\tif len(s) > 8 {\n-\t\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n-\t\t\t\tfor i := len(s) - 1; i >= 0; i-- {\n-\t\t\t\t\tif as.contains(s[i]) {\n-\t\t\t\t\t\treturn i\n-\t\t\t\t\t}\n+\tif chars == \"\" {\n+\t\t// Avoid scanning all of s.\n+\t\treturn -1\n+\t}\n+\tif len(s) > 8 {\n+\t\tif as, isASCII := makeASCIISet(chars); isASCII {\n+\t\t\tfor i := len(s) - 1; i >= 0; i-- {\n+\t\t\t\tif as.contains(s[i]) {\n+\t\t\t\t\treturn i\n \t\t\t\t}\n-\t\t\t\treturn -1\n \t\t\t}\n+\t\t\treturn -1\n \t\t}\n-\t\tfor i := len(s); i > 0; {\n-\t\t\tr, size := utf8.DecodeLastRune(s[:i])\n-\t\t\ti -= size\n-\t\t\tfor _, c := range chars {\n-\t\t\t\tif r == c {\n-\t\t\t\t\treturn i\n-\t\t\t\t}\n+\t}\n+\tfor i := len(s); i > 0; {\n+\t\tr, size := utf8.DecodeLastRune(s[:i])\n+\t\ti -= size\n+\t\tfor _, c := range chars {\n+\t\t\tif r == c {\n+\t\t\t\treturn i\n \t\t\t}\n \t\t}\n \t}\n@@ -223,7 +227,7 @@ func genSplit(s, sep []byte, sepSave, n int) [][]byte {\n \t\tif m < 0 {\n \t\t\tbreak\n \t\t}\n-\t\ta[i] = s[:m+sepSave]\n+\t\ta[i] = s[: m+sepSave : m+sepSave]\n \t\ts = s[m+len(sep):]\n \t\ti++\n \t}\n@@ -265,52 +269,112 @@ func SplitAfter(s, sep []byte) [][]byte {\n \treturn genSplit(s, sep, len(sep), -1)\n }\n \n-// Fields splits the slice s around each instance of one or more consecutive white space\n-// characters, returning a slice of subslices of s or an empty list if s contains only white space.\n+var asciiSpace = [256]uint8{'\\t': 1, '\\n': 1, '\\v': 1, '\\f': 1, '\\r': 1, ' ': 1}\n+\n+// Fields interprets s as a sequence of UTF-8-encoded code points.\n+// It splits the slice s around each instance of one or more consecutive white space\n+// characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\n+// empty slice if s contains only white space.\n func Fields(s []byte) [][]byte {\n-\treturn FieldsFunc(s, unicode.IsSpace)\n+\t// First count the fields.\n+\t// This is an exact count if s is ASCII, otherwise it is an approximation.\n+\tn := 0\n+\twasSpace := 1\n+\t// setBits is used to track which bits are set in the bytes of s.\n+\tsetBits := uint8(0)\n+\tfor i := 0; i < len(s); i++ {\n+\t\tr := s[i]\n+\t\tsetBits |= r\n+\t\tisSpace := int(asciiSpace[r])\n+\t\tn += wasSpace & ^isSpace\n+\t\twasSpace = isSpace\n+\t}\n+\n+\tif setBits >= utf8.RuneSelf {\n+\t\t// Some runes in the input slice are not ASCII.\n+\t\treturn FieldsFunc(s, unicode.IsSpace)\n+\t}\n+\n+\t// ASCII fast path\n+\ta := make([][]byte, n)\n+\tna := 0\n+\tfieldStart := 0\n+\ti := 0\n+\t// Skip spaces in the front of the input.\n+\tfor i < len(s) && asciiSpace[s[i]] != 0 {\n+\t\ti++\n+\t}\n+\tfieldStart = i\n+\tfor i < len(s) {\n+\t\tif asciiSpace[s[i]] == 0 {\n+\t\t\ti++\n+\t\t\tcontinue\n+\t\t}\n+\t\ta[na] = s[fieldStart:i:i]\n+\t\tna++\n+\t\ti++\n+\t\t// Skip spaces in between fields.\n+\t\tfor i < len(s) && asciiSpace[s[i]] != 0 {\n+\t\t\ti++\n+\t\t}\n+\t\tfieldStart = i\n+\t}\n+\tif fieldStart < len(s) { // Last field might end at EOF.\n+\t\ta[na] = s[fieldStart:len(s):len(s)]\n+\t}\n+\treturn a\n }\n \n-// FieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n+// FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\n // It splits the slice s at each run of code points c satisfying f(c) and\n // returns a slice of subslices of s. If all code points in s satisfy f(c), or\n // len(s) == 0, an empty slice is returned.\n // FieldsFunc makes no guarantees about the order in which it calls f(c).\n // If f does not return consistent results for a given c, FieldsFunc may crash.\n func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n-\tn := 0\n-\tinField := false\n-\tfor i := 0; i < len(s); {\n-\t\tr, size := utf8.DecodeRune(s[i:])\n-\t\twasInField := inField\n-\t\tinField = !f(r)\n-\t\tif inField && !wasInField {\n-\t\t\tn++\n-\t\t}\n-\t\ti += size\n+\t// A span is used to record a slice of s of the form s[start:end].\n+\t// The start index is inclusive and the end index is exclusive.\n+\ttype span struct {\n+\t\tstart int\n+\t\tend   int\n \t}\n+\tspans := make([]span, 0, 32)\n \n-\ta := make([][]byte, n)\n-\tna := 0\n-\tfieldStart := -1\n-\tfor i := 0; i <= len(s) && na < n; {\n-\t\tr, size := utf8.DecodeRune(s[i:])\n-\t\tif fieldStart < 0 && size > 0 && !f(r) {\n-\t\t\tfieldStart = i\n-\t\t\ti += size\n-\t\t\tcontinue\n-\t\t}\n-\t\tif fieldStart >= 0 && (size == 0 || f(r)) {\n-\t\t\ta[na] = s[fieldStart:i]\n-\t\t\tna++\n-\t\t\tfieldStart = -1\n+\t// Find the field start and end indices.\n+\twasField := false\n+\tfromIndex := 0\n+\tfor i := 0; i < len(s); {\n+\t\tsize := 1\n+\t\tr := rune(s[i])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, size = utf8.DecodeRune(s[i:])\n \t\t}\n-\t\tif size == 0 {\n-\t\t\tbreak\n+\t\tif f(r) {\n+\t\t\tif wasField {\n+\t\t\t\tspans = append(spans, span{start: fromIndex, end: i})\n+\t\t\t\twasField = false\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif !wasField {\n+\t\t\t\tfromIndex = i\n+\t\t\t\twasField = true\n+\t\t\t}\n \t\t}\n \t\ti += size\n \t}\n-\treturn a[0:na]\n+\n+\t// Last field might end at EOF.\n+\tif wasField {\n+\t\tspans = append(spans, span{fromIndex, len(s)})\n+\t}\n+\n+\t// Create subslices from recorded field indices.\n+\ta := make([][]byte, len(spans))\n+\tfor i, span := range spans {\n+\t\ta[i] = s[span.start:span.end:span.end]\n+\t}\n+\n+\treturn a\n }\n \n // Join concatenates the elements of s to create a new byte slice. The separator\n@@ -349,8 +413,8 @@ func HasSuffix(s, suffix []byte) bool {\n \n // Map returns a copy of the byte slice s with all its characters modified\n // according to the mapping function. If mapping returns a negative value, the character is\n-// dropped from the string with no replacement. The characters in s and the\n-// output are interpreted as UTF-8-encoded Unicode code points.\n+// dropped from the byte slice with no replacement. The characters in s and the\n+// output are interpreted as UTF-8-encoded code points.\n func Map(mapping func(r rune) rune, s []byte) []byte {\n \t// In the worst case, the slice can grow when mapped, making\n \t// things unpleasant. But it's so rare we barge in assuming it's\n@@ -408,28 +472,28 @@ func Repeat(b []byte, count int) []byte {\n \treturn nb\n }\n \n-// ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.\n+// ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n func ToUpper(s []byte) []byte { return Map(unicode.ToUpper, s) }\n \n-// ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.\n+// ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n func ToLower(s []byte) []byte { return Map(unicode.ToLower, s) }\n \n-// ToTitle returns a copy of the byte slice s with all Unicode letters mapped to their title case.\n+// ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n func ToTitle(s []byte) []byte { return Map(unicode.ToTitle, s) }\n \n-// ToUpperSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n+// ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\n // upper case, giving priority to the special casing rules.\n func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r rune) rune { return c.ToUpper(r) }, s)\n }\n \n-// ToLowerSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n+// ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\n // lower case, giving priority to the special casing rules.\n func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r rune) rune { return c.ToLower(r) }, s)\n }\n \n-// ToTitleSpecial returns a copy of the byte slice s with all Unicode letters mapped to their\n+// ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\n // title case, giving priority to the special casing rules.\n func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte {\n \treturn Map(func(r rune) rune { return c.ToTitle(r) }, s)\n@@ -460,8 +524,8 @@ func isSeparator(r rune) bool {\n \treturn unicode.IsSpace(r)\n }\n \n-// Title returns a copy of s with all Unicode letters that begin words\n-// mapped to their title case.\n+// Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\n+// words mapped to their title case.\n //\n // BUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n func Title(s []byte) []byte {\n@@ -481,8 +545,8 @@ func Title(s []byte) []byte {\n \t\ts)\n }\n \n-// TrimLeftFunc returns a subslice of s by slicing off all leading UTF-8-encoded\n-// Unicode code points c that satisfy f(c).\n+// TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\n+// all leading UTF-8-encoded code points c that satisfy f(c).\n func TrimLeftFunc(s []byte, f func(r rune) bool) []byte {\n \ti := indexFunc(s, f, false)\n \tif i == -1 {\n@@ -491,8 +555,8 @@ func TrimLeftFunc(s []byte, f func(r rune) bool) []byte {\n \treturn s[i:]\n }\n \n-// TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8\n-// encoded Unicode code points c that satisfy f(c).\n+// TrimRightFunc returns a subslice of s by slicing off all trailing\n+// UTF-8-encoded code points c that satisfy f(c).\n func TrimRightFunc(s []byte, f func(r rune) bool) []byte {\n \ti := lastIndexFunc(s, f, false)\n \tif i >= 0 && s[i] >= utf8.RuneSelf {\n@@ -505,7 +569,7 @@ func TrimRightFunc(s []byte, f func(r rune) bool) []byte {\n }\n \n // TrimFunc returns a subslice of s by slicing off all leading and trailing\n-// UTF-8-encoded Unicode code points c that satisfy f(c).\n+// UTF-8-encoded code points c that satisfy f(c).\n func TrimFunc(s []byte, f func(r rune) bool) []byte {\n \treturn TrimRightFunc(TrimLeftFunc(s, f), f)\n }\n@@ -528,14 +592,14 @@ func TrimSuffix(s, suffix []byte) []byte {\n \treturn s\n }\n \n-// IndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n+// IndexFunc interprets s as a sequence of UTF-8-encoded code points.\n // It returns the byte index in s of the first Unicode\n // code point satisfying f(c), or -1 if none do.\n func IndexFunc(s []byte, f func(r rune) bool) int {\n \treturn indexFunc(s, f, true)\n }\n \n-// LastIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n+// LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\n // It returns the byte index in s of the last Unicode\n // code point satisfying f(c), or -1 if none do.\n func LastIndexFunc(s []byte, f func(r rune) bool) int {\n@@ -626,19 +690,19 @@ func makeCutsetFunc(cutset string) func(r rune) bool {\n }\n \n // Trim returns a subslice of s by slicing off all leading and\n-// trailing UTF-8-encoded Unicode code points contained in cutset.\n+// trailing UTF-8-encoded code points contained in cutset.\n func Trim(s []byte, cutset string) []byte {\n \treturn TrimFunc(s, makeCutsetFunc(cutset))\n }\n \n // TrimLeft returns a subslice of s by slicing off all leading\n-// UTF-8-encoded Unicode code points contained in cutset.\n+// UTF-8-encoded code points contained in cutset.\n func TrimLeft(s []byte, cutset string) []byte {\n \treturn TrimLeftFunc(s, makeCutsetFunc(cutset))\n }\n \n // TrimRight returns a subslice of s by slicing off all trailing\n-// UTF-8-encoded Unicode code points that are contained in cutset.\n+// UTF-8-encoded code points that are contained in cutset.\n func TrimRight(s []byte, cutset string) []byte {\n \treturn TrimRightFunc(s, makeCutsetFunc(cutset))\n }\n@@ -649,7 +713,8 @@ func TrimSpace(s []byte) []byte {\n \treturn TrimFunc(s, unicode.IsSpace)\n }\n \n-// Runes returns a slice of runes (Unicode code points) equivalent to s.\n+// Runes interprets s as a sequence of UTF-8-encoded code points.\n+// It returns a slice of runes (Unicode code points) equivalent to s.\n func Runes(s []byte) []rune {\n \tt := make([]rune, utf8.RuneCount(s))\n \ti := 0\n@@ -758,3 +823,46 @@ func EqualFold(s, t []byte) bool {\n \t// One string is empty. Are both?\n \treturn len(s) == len(t)\n }\n+\n+func indexRabinKarp(s, sep []byte) int {\n+\t// Rabin-Karp search\n+\thashsep, pow := hashStr(sep)\n+\tn := len(sep)\n+\tvar h uint32\n+\tfor i := 0; i < n; i++ {\n+\t\th = h*primeRK + uint32(s[i])\n+\t}\n+\tif h == hashsep && Equal(s[:n], sep) {\n+\t\treturn 0\n+\t}\n+\tfor i := n; i < len(s); {\n+\t\th *= primeRK\n+\t\th += uint32(s[i])\n+\t\th -= pow * uint32(s[i-n])\n+\t\ti++\n+\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n+\t\t\treturn i - n\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+// primeRK is the prime base used in Rabin-Karp algorithm.\n+const primeRK = 16777619\n+\n+// hashStr returns the hash and the appropriate multiplicative\n+// factor for use in Rabin-Karp algorithm.\n+func hashStr(sep []byte) (uint32, uint32) {\n+\thash := uint32(0)\n+\tfor i := 0; i < len(sep); i++ {\n+\t\thash = hash*primeRK + uint32(sep[i])\n+\t}\n+\tvar pow, sq uint32 = 1, primeRK\n+\tfor i := len(sep); i > 0; i >>= 1 {\n+\t\tif i&1 != 0 {\n+\t\t\tpow *= sq\n+\t\t}\n+\t\tsq *= sq\n+\t}\n+\treturn hash, pow\n+}"}, {"sha": "2fbbbb0d877cf843ffe97eb801b99a8a1e228995", "filename": "libgo/go/bytes/bytes_amd64.go", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -77,52 +77,14 @@ func Index(s, sep []byte) int {\n \t\t}\n \t\treturn -1\n \t}\n-\t// Rabin-Karp search\n-\thashsep, pow := hashStr(sep)\n-\tvar h uint32\n-\tfor i := 0; i < n; i++ {\n-\t\th = h*primeRK + uint32(s[i])\n-\t}\n-\tif h == hashsep && Equal(s[:n], sep) {\n-\t\treturn 0\n-\t}\n-\tfor i := n; i < len(s); {\n-\t\th *= primeRK\n-\t\th += uint32(s[i])\n-\t\th -= pow * uint32(s[i-n])\n-\t\ti++\n-\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n-\t\t\treturn i - n\n-\t\t}\n-\t}\n-\treturn -1\n+\treturn indexRabinKarp(s, sep)\n }\n \n // Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n+// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n func Count(s, sep []byte) int {\n \tif len(sep) == 1 && cpu.X86.HasPOPCNT {\n \t\treturn countByte(s, sep[0])\n \t}\n \treturn countGeneric(s, sep)\n }\n-\n-// primeRK is the prime base used in Rabin-Karp algorithm.\n-const primeRK = 16777619\n-\n-// hashStr returns the hash and the appropriate multiplicative\n-// factor for use in Rabin-Karp algorithm.\n-func hashStr(sep []byte) (uint32, uint32) {\n-\thash := uint32(0)\n-\tfor i := 0; i < len(sep); i++ {\n-\t\thash = hash*primeRK + uint32(sep[i])\n-\t}\n-\tvar pow, sq uint32 = 1, primeRK\n-\tfor i := len(sep); i > 0; i >>= 1 {\n-\t\tif i&1 != 0 {\n-\t\t\tpow *= sq\n-\t\t}\n-\t\tsq *= sq\n-\t}\n-\treturn hash, pow\n-}"}, {"sha": "1213b067a9dce9dd77484f1e4645f1ec42d0519f", "filename": "libgo/go/bytes/bytes_arm64.go", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_arm64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_arm64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_arm64.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package bytes\n+\n+func countByte(s []byte, c byte) int // bytes_arm64.s\n+\n+// Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n+func Index(s, sep []byte) int {\n+\tn := len(sep)\n+\tswitch {\n+\tcase n == 0:\n+\t\treturn 0\n+\tcase n == 1:\n+\t\treturn IndexByte(s, sep[0])\n+\tcase n == len(s):\n+\t\tif Equal(sep, s) {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\tcase n > len(s):\n+\t\treturn -1\n+\t}\n+\tc := sep[0]\n+\ti := 0\n+\tfails := 0\n+\tt := s[:len(s)-n+1]\n+\tfor i < len(t) {\n+\t\tif t[i] != c {\n+\t\t\to := IndexByte(t[i:], c)\n+\t\t\tif o < 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\ti += o\n+\t\t}\n+\t\tif Equal(s[i:i+n], sep) {\n+\t\t\treturn i\n+\t\t}\n+\t\ti++\n+\t\tfails++\n+\t\tif fails >= 4+i>>4 && i < len(t) {\n+\t\t\t// Give up on IndexByte, it isn't skipping ahead\n+\t\t\t// far enough to be better than Rabin-Karp.\n+\t\t\t// Experiments (using IndexPeriodic) suggest\n+\t\t\t// the cutover is about 16 byte skips.\n+\t\t\t// TODO: if large prefixes of sep are matching\n+\t\t\t// we should cutover at even larger average skips,\n+\t\t\t// because Equal becomes that much more expensive.\n+\t\t\t// This code does not take that effect into account.\n+\t\t\tj := indexRabinKarp(s[i:], sep)\n+\t\t\tif j < 0 {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\treturn i + j\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+// Count counts the number of non-overlapping instances of sep in s.\n+// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n+func Count(s, sep []byte) int {\n+\tif len(sep) == 1 {\n+\t\treturn countByte(s, sep[0])\n+\t}\n+\treturn countGeneric(s, sep)\n+}"}, {"sha": "b52d93965208011d9ffc70b2f004b2eb66f16c0b", "filename": "libgo/go/bytes/bytes_generic.go", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_generic.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -2,27 +2,29 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// -build !amd64,!s390x\n+// -build !amd64,!s390x,!arm64\n \n package bytes\n \n-// TODO: implements short string optimization on non amd64 platforms\n-// and get rid of bytes_amd64.go\n-\n // Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n func Index(s, sep []byte) int {\n \tn := len(sep)\n-\tif n == 0 {\n+\tswitch {\n+\tcase n == 0:\n \t\treturn 0\n-\t}\n-\tif n > len(s) {\n+\tcase n == 1:\n+\t\treturn IndexByte(s, sep[0])\n+\tcase n == len(s):\n+\t\tif Equal(sep, s) {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\tcase n > len(s):\n \t\treturn -1\n \t}\n \tc := sep[0]\n-\tif n == 1 {\n-\t\treturn IndexByte(s, c)\n-\t}\n \ti := 0\n+\tfails := 0\n \tt := s[:len(s)-n+1]\n \tfor i < len(t) {\n \t\tif t[i] != c {\n@@ -36,12 +38,28 @@ func Index(s, sep []byte) int {\n \t\t\treturn i\n \t\t}\n \t\ti++\n+\t\tfails++\n+\t\tif fails >= 4+i>>4 && i < len(t) {\n+\t\t\t// Give up on IndexByte, it isn't skipping ahead\n+\t\t\t// far enough to be better than Rabin-Karp.\n+\t\t\t// Experiments (using IndexPeriodic) suggest\n+\t\t\t// the cutover is about 16 byte skips.\n+\t\t\t// TODO: if large prefixes of sep are matching\n+\t\t\t// we should cutover at even larger average skips,\n+\t\t\t// because Equal becomes that much more expensive.\n+\t\t\t// This code does not take that effect into account.\n+\t\t\tj := indexRabinKarp(s[i:], sep)\n+\t\t\tif j < 0 {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\treturn i + j\n+\t\t}\n \t}\n \treturn -1\n }\n \n // Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n+// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n func Count(s, sep []byte) int {\n \treturn countGeneric(s, sep)\n }"}, {"sha": "0c228486fc3be5f7c0565fde177487b9c01a53c1", "filename": "libgo/go/bytes/bytes_s390x.go", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -78,49 +78,11 @@ func Index(s, sep []byte) int {\n \t\t}\n \t\treturn -1\n \t}\n-\t// Rabin-Karp search\n-\thashsep, pow := hashStr(sep)\n-\tvar h uint32\n-\tfor i := 0; i < n; i++ {\n-\t\th = h*primeRK + uint32(s[i])\n-\t}\n-\tif h == hashsep && Equal(s[:n], sep) {\n-\t\treturn 0\n-\t}\n-\tfor i := n; i < len(s); {\n-\t\th *= primeRK\n-\t\th += uint32(s[i])\n-\t\th -= pow * uint32(s[i-n])\n-\t\ti++\n-\t\tif h == hashsep && Equal(s[i-n:i], sep) {\n-\t\t\treturn i - n\n-\t\t}\n-\t}\n-\treturn -1\n+\treturn indexRabinKarp(s, sep)\n }\n \n // Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n+// If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n func Count(s, sep []byte) int {\n \treturn countGeneric(s, sep)\n }\n-\n-// primeRK is the prime base used in Rabin-Karp algorithm.\n-const primeRK = 16777619\n-\n-// hashStr returns the hash and the appropriate multiplicative\n-// factor for use in Rabin-Karp algorithm.\n-func hashStr(sep []byte) (uint32, uint32) {\n-\thash := uint32(0)\n-\tfor i := 0; i < len(sep); i++ {\n-\t\thash = hash*primeRK + uint32(sep[i])\n-\t}\n-\tvar pow, sq uint32 = 1, primeRK\n-\tfor i := len(sep); i > 0; i >>= 1 {\n-\t\tif i&1 != 0 {\n-\t\t\tpow *= sq\n-\t\t}\n-\t\tsq *= sq\n-\t}\n-\treturn hash, pow\n-}"}, {"sha": "23fce29e319cceaf1d4dca5d15ad83e3ebe594e6", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 124, "deletions": 9, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -140,6 +140,9 @@ var indexTests = []BinOpTest{\n \t{\"barfoobarfooyyyzzzyyyzzzyyyzzzyyyxxxzzzyyy\", \"x\", 33},\n \t{\"foofyfoobarfoobar\", \"y\", 4},\n \t{\"oooooooooooooooooooooo\", \"r\", -1},\n+\t// test fallback to Rabin-Karp.\n+\t{\"oxoxoxoxoxoxoxoxoxoxoxoy\", \"oy\", 22},\n+\t{\"oxoxoxoxoxoxoxoxoxoxoxox\", \"oy\", -1},\n }\n \n var lastIndexTests = []BinOpTest{\n@@ -741,6 +744,13 @@ var splittests = []SplitTest{\n func TestSplit(t *testing.T) {\n \tfor _, tt := range splittests {\n \t\ta := SplitN([]byte(tt.s), []byte(tt.sep), tt.n)\n+\n+\t\t// Appending to the results should not change future results.\n+\t\tvar x []byte\n+\t\tfor _, v := range a {\n+\t\t\tx = append(v, 'z')\n+\t\t}\n+\n \t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n@@ -749,6 +759,11 @@ func TestSplit(t *testing.T) {\n \t\tif tt.n == 0 {\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif want := tt.a[len(tt.a)-1] + \"z\"; string(x) != want {\n+\t\t\tt.Errorf(\"last appended result was %s; want %s\", x, want)\n+\t\t}\n+\n \t\ts := Join(a, []byte(tt.sep))\n \t\tif string(s) != tt.s {\n \t\t\tt.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)\n@@ -787,11 +802,23 @@ var splitaftertests = []SplitTest{\n func TestSplitAfter(t *testing.T) {\n \tfor _, tt := range splitaftertests {\n \t\ta := SplitAfterN([]byte(tt.s), []byte(tt.sep), tt.n)\n+\n+\t\t// Appending to the results should not change future results.\n+\t\tvar x []byte\n+\t\tfor _, v := range a {\n+\t\t\tx = append(v, 'z')\n+\t\t}\n+\n \t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif want := tt.a[len(tt.a)-1] + \"z\"; string(x) != want {\n+\t\t\tt.Errorf(\"last appended result was %s; want %s\", x, want)\n+\t\t}\n+\n \t\ts := Join(a, nil)\n \t\tif string(s) != tt.s {\n \t\t\tt.Errorf(`Join(Split(%q, %q, %d), %q) = %q`, tt.s, tt.sep, tt.n, tt.sep, s)\n@@ -826,12 +853,29 @@ var fieldstests = []FieldsTest{\n \n func TestFields(t *testing.T) {\n \tfor _, tt := range fieldstests {\n-\t\ta := Fields([]byte(tt.s))\n+\t\tb := []byte(tt.s)\n+\t\ta := Fields(b)\n+\n+\t\t// Appending to the results should not change future results.\n+\t\tvar x []byte\n+\t\tfor _, v := range a {\n+\t\t\tx = append(v, 'z')\n+\t\t}\n+\n \t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(\"Fields(%q) = %v; want %v\", tt.s, a, tt.a)\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif string(b) != tt.s {\n+\t\t\tt.Errorf(\"slice changed to %s; want %s\", string(b), tt.s)\n+\t\t}\n+\t\tif len(tt.a) > 0 {\n+\t\t\tif want := tt.a[len(tt.a)-1] + \"z\"; string(x) != want {\n+\t\t\t\tt.Errorf(\"last appended result was %s; want %s\", x, want)\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -852,11 +896,28 @@ func TestFieldsFunc(t *testing.T) {\n \t\t{\"aXXbXXXcX\", []string{\"a\", \"b\", \"c\"}},\n \t}\n \tfor _, tt := range fieldsFuncTests {\n-\t\ta := FieldsFunc([]byte(tt.s), pred)\n+\t\tb := []byte(tt.s)\n+\t\ta := FieldsFunc(b, pred)\n+\n+\t\t// Appending to the results should not change future results.\n+\t\tvar x []byte\n+\t\tfor _, v := range a {\n+\t\t\tx = append(v, 'z')\n+\t\t}\n+\n \t\tresult := sliceOfString(a)\n \t\tif !eq(result, tt.a) {\n \t\t\tt.Errorf(\"FieldsFunc(%q) = %v, want %v\", tt.s, a, tt.a)\n \t\t}\n+\n+\t\tif string(b) != tt.s {\n+\t\t\tt.Errorf(\"slice changed to %s; want %s\", b, tt.s)\n+\t\t}\n+\t\tif len(tt.a) > 0 {\n+\t\t\tif want := tt.a[len(tt.a)-1] + \"z\"; string(x) != want {\n+\t\t\t\tt.Errorf(\"last appended result was %s; want %s\", x, want)\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n@@ -1507,19 +1568,58 @@ var makeFieldsInput = func() []byte {\n \treturn x\n }\n \n-var fieldsInput = makeFieldsInput()\n+var makeFieldsInputASCII = func() []byte {\n+\tx := make([]byte, 1<<20)\n+\t// Input is ~10% space, rest ASCII non-space.\n+\tfor i := range x {\n+\t\tif rand.Intn(10) == 0 {\n+\t\t\tx[i] = ' '\n+\t\t} else {\n+\t\t\tx[i] = 'x'\n+\t\t}\n+\t}\n+\treturn x\n+}\n+\n+var bytesdata = []struct {\n+\tname string\n+\tdata []byte\n+}{\n+\t{\"ASCII\", makeFieldsInputASCII()},\n+\t{\"Mixed\", makeFieldsInput()},\n+}\n \n func BenchmarkFields(b *testing.B) {\n-\tb.SetBytes(int64(len(fieldsInput)))\n-\tfor i := 0; i < b.N; i++ {\n-\t\tFields(fieldsInput)\n+\tfor _, sd := range bytesdata {\n+\t\tb.Run(sd.name, func(b *testing.B) {\n+\t\t\tfor j := 1 << 4; j <= 1<<20; j <<= 4 {\n+\t\t\t\tb.Run(fmt.Sprintf(\"%d\", j), func(b *testing.B) {\n+\t\t\t\t\tb.ReportAllocs()\n+\t\t\t\t\tb.SetBytes(int64(j))\n+\t\t\t\t\tdata := sd.data[:j]\n+\t\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\t\tFields(data)\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n func BenchmarkFieldsFunc(b *testing.B) {\n-\tb.SetBytes(int64(len(fieldsInput)))\n-\tfor i := 0; i < b.N; i++ {\n-\t\tFieldsFunc(fieldsInput, unicode.IsSpace)\n+\tfor _, sd := range bytesdata {\n+\t\tb.Run(sd.name, func(b *testing.B) {\n+\t\t\tfor j := 1 << 4; j <= 1<<20; j <<= 4 {\n+\t\t\t\tb.Run(fmt.Sprintf(\"%d\", j), func(b *testing.B) {\n+\t\t\t\t\tb.ReportAllocs()\n+\t\t\t\t\tb.SetBytes(int64(j))\n+\t\t\t\t\tdata := sd.data[:j]\n+\t\t\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\t\t\tFieldsFunc(data, unicode.IsSpace)\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -1638,3 +1738,18 @@ func BenchmarkTrimASCII(b *testing.B) {\n \t\t}\n \t}\n }\n+\n+func BenchmarkIndexPeriodic(b *testing.B) {\n+\tkey := []byte{1, 1}\n+\tfor _, skip := range [...]int{2, 4, 8, 16, 32, 64} {\n+\t\tb.Run(fmt.Sprintf(\"IndexPeriodic%d\", skip), func(b *testing.B) {\n+\t\t\tbuf := make([]byte, 1<<16)\n+\t\t\tfor i := 0; i < len(buf); i += skip {\n+\t\t\t\tbuf[i] = 1\n+\t\t\t}\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tIndex(buf, key)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "9fdead8a6040a968104da61755edced2775a40de", "filename": "libgo/go/bytes/equal_test.go", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8799df67f2dab88f9fda11739c501780a85575e2/libgo%2Fgo%2Fbytes%2Fequal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8799df67f2dab88f9fda11739c501780a85575e2/libgo%2Fgo%2Fbytes%2Fequal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fequal_test.go?ref=8799df67f2dab88f9fda11739c501780a85575e2", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2013 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-//\n-// +build linux\n-\n-package bytes_test\n-\n-import (\n-\t. \"bytes\"\n-\t\"syscall\"\n-\t\"testing\"\n-\t\"unsafe\"\n-)\n-\n-// This file tests the situation where memeq is checking\n-// data very near to a page boundary. We want to make sure\n-// equal does not read across the boundary and cause a page\n-// fault where it shouldn't.\n-\n-// This test runs only on linux. The code being tested is\n-// not OS-specific, so it does not need to be tested on all\n-// operating systems.\n-\n-func TestEqualNearPageBoundary(t *testing.T) {\n-\tpagesize := syscall.Getpagesize()\n-\tb := make([]byte, 4*pagesize)\n-\ti := pagesize\n-\tfor ; uintptr(unsafe.Pointer(&b[i]))%uintptr(pagesize) != 0; i++ {\n-\t}\n-\tsyscall.Mprotect(b[i-pagesize:i], 0)\n-\tsyscall.Mprotect(b[i+pagesize:i+2*pagesize], 0)\n-\tdefer syscall.Mprotect(b[i-pagesize:i], syscall.PROT_READ|syscall.PROT_WRITE)\n-\tdefer syscall.Mprotect(b[i+pagesize:i+2*pagesize], syscall.PROT_READ|syscall.PROT_WRITE)\n-\n-\t// both of these should fault\n-\t//pagesize += int(b[i-1])\n-\t//pagesize += int(b[i+pagesize])\n-\n-\tfor j := 0; j < pagesize; j++ {\n-\t\tb[i+j] = 'A'\n-\t}\n-\tfor j := 0; j <= pagesize; j++ {\n-\t\tEqual(b[i:i+j], b[i+pagesize-j:i+pagesize])\n-\t\tEqual(b[i+pagesize-j:i+pagesize], b[i:i+j])\n-\t}\n-}"}, {"sha": "5b7a46058f5c73b44ec111b411d9580ae5c3f7ff", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -119,6 +119,32 @@ func ExampleContains() {\n \t// true\n }\n \n+func ExampleContainsAny() {\n+\tfmt.Println(bytes.ContainsAny([]byte(\"I like seafood.\"), \"f\u00c4o!\"))\n+\tfmt.Println(bytes.ContainsAny([]byte(\"I like seafood.\"), \"\u53bb\u662f\u4f1f\u5927\u7684.\"))\n+\tfmt.Println(bytes.ContainsAny([]byte(\"I like seafood.\"), \"\"))\n+\tfmt.Println(bytes.ContainsAny([]byte(\"\"), \"\"))\n+\t// Output:\n+\t// true\n+\t// true\n+\t// false\n+\t// false\n+}\n+\n+func ExampleContainsRune() {\n+\tfmt.Println(bytes.ContainsRune([]byte(\"I like seafood.\"), 'f'))\n+\tfmt.Println(bytes.ContainsRune([]byte(\"I like seafood.\"), '\u00f6'))\n+\tfmt.Println(bytes.ContainsRune([]byte(\"\u53bb\u662f\u4f1f\u5927\u7684!\"), '\u5927'))\n+\tfmt.Println(bytes.ContainsRune([]byte(\"\u53bb\u662f\u4f1f\u5927\u7684!\"), '!'))\n+\tfmt.Println(bytes.ContainsRune([]byte(\"\"), '@'))\n+\t// Output:\n+\t// true\n+\t// false\n+\t// true\n+\t// true\n+\t// false\n+}\n+\n func ExampleCount() {\n \tfmt.Println(bytes.Count([]byte(\"cheese\"), []byte(\"e\")))\n \tfmt.Println(bytes.Count([]byte(\"five\"), []byte(\"\"))) // before & after each rune\n@@ -127,6 +153,14 @@ func ExampleCount() {\n \t// 5\n }\n \n+func ExampleEqual() {\n+\tfmt.Println(bytes.Equal([]byte(\"Go\"), []byte(\"Go\")))\n+\tfmt.Println(bytes.Equal([]byte(\"Go\"), []byte(\"C++\")))\n+\t// Output:\n+\t// true\n+\t// false\n+}\n+\n func ExampleEqualFold() {\n \tfmt.Println(bytes.EqualFold([]byte(\"Go\"), []byte(\"go\")))\n \t// Output: true\n@@ -162,6 +196,14 @@ func ExampleIndex() {\n \t// -1\n }\n \n+func ExampleIndexByte() {\n+\tfmt.Println(bytes.IndexByte([]byte(\"chicken\"), byte('k')))\n+\tfmt.Println(bytes.IndexByte([]byte(\"chicken\"), byte('g')))\n+\t// Output:\n+\t// 4\n+\t// -1\n+}\n+\n func ExampleIndexFunc() {\n \tf := func(c rune) bool {\n \t\treturn unicode.Is(unicode.Han, c)\n@@ -199,6 +241,36 @@ func ExampleLastIndex() {\n \t// -1\n }\n \n+func ExampleLastIndexAny() {\n+\tfmt.Println(bytes.LastIndexAny([]byte(\"go gopher\"), \"M\u00fcQp\"))\n+\tfmt.Println(bytes.LastIndexAny([]byte(\"go \u5730\u9f20\"), \"\u5730\u5927\"))\n+\tfmt.Println(bytes.LastIndexAny([]byte(\"go gopher\"), \"z,!.\"))\n+\t// Output:\n+\t// 5\n+\t// 3\n+\t// -1\n+}\n+\n+func ExampleLastIndexByte() {\n+\tfmt.Println(bytes.LastIndexByte([]byte(\"go gopher\"), byte('g')))\n+\tfmt.Println(bytes.LastIndexByte([]byte(\"go gopher\"), byte('r')))\n+\tfmt.Println(bytes.LastIndexByte([]byte(\"go gopher\"), byte('z')))\n+\t// Output:\n+\t// 3\n+\t// 8\n+\t// -1\n+}\n+\n+func ExampleLastIndexFunc() {\n+\tfmt.Println(bytes.LastIndexFunc([]byte(\"go gopher!\"), unicode.IsLetter))\n+\tfmt.Println(bytes.LastIndexFunc([]byte(\"go gopher!\"), unicode.IsPunct))\n+\tfmt.Println(bytes.LastIndexFunc([]byte(\"go gopher!\"), unicode.IsNumber))\n+\t// Output:\n+\t// 8\n+\t// 9\n+\t// -1\n+}\n+\n func ExampleJoin() {\n \ts := [][]byte{[]byte(\"foo\"), []byte(\"bar\"), []byte(\"baz\")}\n \tfmt.Printf(\"%s\", bytes.Join(s, []byte(\", \")))\n@@ -218,6 +290,23 @@ func ExampleReplace() {\n \t// moo moo moo\n }\n \n+func ExampleRunes() {\n+\trs := bytes.Runes([]byte(\"go gopher\"))\n+\tfor _, r := range rs {\n+\t\tfmt.Printf(\"%#U\\n\", r)\n+\t}\n+\t// Output:\n+\t// U+0067 'g'\n+\t// U+006F 'o'\n+\t// U+0020 ' '\n+\t// U+0067 'g'\n+\t// U+006F 'o'\n+\t// U+0070 'p'\n+\t// U+0068 'h'\n+\t// U+0065 'e'\n+\t// U+0072 'r'\n+}\n+\n func ExampleSplit() {\n \tfmt.Printf(\"%q\\n\", bytes.Split([]byte(\"a,b,c\"), []byte(\",\")))\n \tfmt.Printf(\"%q\\n\", bytes.Split([]byte(\"a man a plan a canal panama\"), []byte(\"a \")))\n@@ -267,6 +356,18 @@ func ExampleTrim() {\n \t// Output: [\"Achtung! Achtung\"]\n }\n \n+func ExampleTrimFunc() {\n+\tfmt.Println(string(bytes.TrimFunc([]byte(\"go-gopher!\"), unicode.IsLetter)))\n+\tfmt.Println(string(bytes.TrimFunc([]byte(\"\\\"go-gopher!\\\"\"), unicode.IsLetter)))\n+\tfmt.Println(string(bytes.TrimFunc([]byte(\"go-gopher!\"), unicode.IsPunct)))\n+\tfmt.Println(string(bytes.TrimFunc([]byte(\"1234go-gopher!567\"), unicode.IsNumber)))\n+\t// Output:\n+\t// -gopher!\n+\t// \"go-gopher!\"\n+\t// go-gopher\n+\t// go-gopher!\n+}\n+\n func ExampleMap() {\n \trot13 := func(r rune) rune {\n \t\tswitch {\n@@ -281,11 +382,43 @@ func ExampleMap() {\n \t// Output: 'Gjnf oevyyvt naq gur fyvgul tbcure...\n }\n \n+func ExampleTrimLeft() {\n+\tfmt.Print(string(bytes.TrimLeft([]byte(\"453gopher8257\"), \"0123456789\")))\n+\t// Output:\n+\t// gopher8257\n+}\n+\n+func ExampleTrimLeftFunc() {\n+\tfmt.Println(string(bytes.TrimLeftFunc([]byte(\"go-gopher\"), unicode.IsLetter)))\n+\tfmt.Println(string(bytes.TrimLeftFunc([]byte(\"go-gopher!\"), unicode.IsPunct)))\n+\tfmt.Println(string(bytes.TrimLeftFunc([]byte(\"1234go-gopher!567\"), unicode.IsNumber)))\n+\t// Output:\n+\t// -gopher\n+\t// go-gopher!\n+\t// go-gopher!567\n+}\n+\n func ExampleTrimSpace() {\n \tfmt.Printf(\"%s\", bytes.TrimSpace([]byte(\" \\t\\n a lone gopher \\n\\t\\r\\n\")))\n \t// Output: a lone gopher\n }\n \n+func ExampleTrimRight() {\n+\tfmt.Print(string(bytes.TrimRight([]byte(\"453gopher8257\"), \"0123456789\")))\n+\t// Output:\n+\t// 453gopher\n+}\n+\n+func ExampleTrimRightFunc() {\n+\tfmt.Println(string(bytes.TrimRightFunc([]byte(\"go-gopher\"), unicode.IsLetter)))\n+\tfmt.Println(string(bytes.TrimRightFunc([]byte(\"go-gopher!\"), unicode.IsPunct)))\n+\tfmt.Println(string(bytes.TrimRightFunc([]byte(\"1234go-gopher!567\"), unicode.IsNumber)))\n+\t// Output:\n+\t// go-\n+\t// go-gopher\n+\t// 1234go-gopher!\n+}\n+\n func ExampleToUpper() {\n \tfmt.Printf(\"%s\", bytes.ToUpper([]byte(\"Gopher\")))\n \t// Output: GOPHER\n@@ -295,3 +428,11 @@ func ExampleToLower() {\n \tfmt.Printf(\"%s\", bytes.ToLower([]byte(\"Gopher\")))\n \t// Output: gopher\n }\n+\n+func ExampleReader_Len() {\n+\tfmt.Println(bytes.NewReader([]byte(\"Hi!\")).Len())\n+\tfmt.Println(bytes.NewReader([]byte(\"\u3053\u3093\u306b\u3061\u306f!\")).Len())\n+\t// Output:\n+\t// 3\n+\t// 16\n+}"}, {"sha": "08464c2402d74648eb84f620419c6b4a00a0875a", "filename": "libgo/go/bytes/reader.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -35,6 +35,7 @@ func (r *Reader) Len() int {\n // to any other method.\n func (r *Reader) Size() int64 { return int64(len(r.s)) }\n \n+// Read implements the io.Reader interface.\n func (r *Reader) Read(b []byte) (n int, err error) {\n \tif r.i >= int64(len(r.s)) {\n \t\treturn 0, io.EOF\n@@ -45,6 +46,7 @@ func (r *Reader) Read(b []byte) (n int, err error) {\n \treturn\n }\n \n+// ReadAt implements the io.ReaderAt interface.\n func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {\n \t// cannot modify state - see io.ReaderAt\n \tif off < 0 {\n@@ -60,6 +62,7 @@ func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {\n \treturn\n }\n \n+// ReadByte implements the io.ByteReader interface.\n func (r *Reader) ReadByte() (byte, error) {\n \tr.prevRune = -1\n \tif r.i >= int64(len(r.s)) {\n@@ -70,6 +73,7 @@ func (r *Reader) ReadByte() (byte, error) {\n \treturn b, nil\n }\n \n+// UnreadByte complements ReadByte in implementing the io.ByteScanner interface.\n func (r *Reader) UnreadByte() error {\n \tr.prevRune = -1\n \tif r.i <= 0 {\n@@ -79,6 +83,7 @@ func (r *Reader) UnreadByte() error {\n \treturn nil\n }\n \n+// ReadRune implements the io.RuneReader interface.\n func (r *Reader) ReadRune() (ch rune, size int, err error) {\n \tif r.i >= int64(len(r.s)) {\n \t\tr.prevRune = -1\n@@ -94,6 +99,7 @@ func (r *Reader) ReadRune() (ch rune, size int, err error) {\n \treturn\n }\n \n+// UnreadRune complements ReadRune in implementing the io.RuneScanner interface.\n func (r *Reader) UnreadRune() error {\n \tif r.prevRune < 0 {\n \t\treturn errors.New(\"bytes.Reader.UnreadRune: previous operation was not ReadRune\")"}, {"sha": "8806876ff13c73fa630ec765b6179092fe65fda0", "filename": "libgo/go/bytes/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fbytes%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Freader_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -140,9 +140,9 @@ func TestReaderWriteTo(t *testing.T) {\n \tfor i := 0; i < 30; i += 3 {\n \t\tvar l int\n \t\tif i > 0 {\n-\t\t\tl = len(data) / i\n+\t\t\tl = len(testString) / i\n \t\t}\n-\t\ts := data[:l]\n+\t\ts := testString[:l]\n \t\tr := NewReader(testBytes[:l])\n \t\tvar b Buffer\n \t\tn, err := r.WriteTo(&b)"}, {"sha": "8d810ffdd9900f1ac5a91627ce34a2577bf6fa39", "filename": "libgo/go/cmd/buildid/buildid.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fbuildid%2Fbuildid.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"cmd/internal/buildid\"\n+)\n+\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: go tool buildid [-w] file\\n\")\n+\tflag.PrintDefaults()\n+\tos.Exit(2)\n+}\n+\n+var wflag = flag.Bool(\"w\", false, \"write build ID\")\n+\n+func main() {\n+\tlog.SetPrefix(\"buildid: \")\n+\tlog.SetFlags(0)\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\tif flag.NArg() != 1 {\n+\t\tusage()\n+\t}\n+\n+\tfile := flag.Arg(0)\n+\tid, err := buildid.ReadFile(file)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif !*wflag {\n+\t\tfmt.Printf(\"%s\\n\", id)\n+\t\treturn\n+\t}\n+\n+\tf, err := os.Open(file)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tmatches, hash, err := buildid.FindAndHash(f, id, 0)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tf.Close()\n+\n+\ttail := id\n+\tif i := strings.LastIndex(id, \".\"); i >= 0 {\n+\t\ttail = tail[i+1:]\n+\t}\n+\tif len(tail) != len(hash)*2 {\n+\t\tlog.Fatalf(\"%s: cannot find %d-byte hash in id %s\", file, len(hash), id)\n+\t}\n+\tnewID := id[:len(id)-len(tail)] + fmt.Sprintf(\"%x\", hash)\n+\n+\tf, err = os.OpenFile(file, os.O_WRONLY, 0)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif err := buildid.Rewrite(f, matches, newID); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "d1ec155c97617c4fe1a394811a0f674074cd02c6", "filename": "libgo/go/cmd/buildid/doc.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fbuildid%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fbuildid%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fbuildid%2Fdoc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Buildid displays or updates the build ID stored in a Go package or binary.\n+\n+Usage:\n+\tgo tool buildid [-w] file\n+\n+By default, buildid prints the build ID found in the named file.\n+If the -w option is given, buildid rewrites the build ID found in\n+the file to accurately record a content hash of the file.\n+\n+This tool is only intended for use by the go command or\n+other build systems.\n+*/\n+package main"}, {"sha": "58e0ee78cb74cc8c77f27b172e943f81d523ec05", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 156, "deletions": 116, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -58,11 +58,14 @@ func (f *File) ParseGo(name string, src []byte) {\n \t// so we use ast1 to look for the doc comments on import \"C\"\n \t// and on exported functions, and we use ast2 for translating\n \t// and reprinting.\n+\t// In cgo mode, we ignore ast2 and just apply edits directly\n+\t// the text behind ast1. In godefs mode we modify and print ast2.\n \tast1 := parse(name, src, parser.ParseComments)\n \tast2 := parse(name, src, 0)\n \n \tf.Package = ast1.Name.Name\n \tf.Name = make(map[string]*Name)\n+\tf.NamePos = make(map[*Name]token.Pos)\n \n \t// In ast1, find the import \"C\" line and get any extra C preamble.\n \tsawC := false\n@@ -96,45 +99,62 @@ func (f *File) ParseGo(name string, src []byte) {\n \t}\n \n \t// In ast2, strip the import \"C\" line.\n-\tw := 0\n-\tfor _, decl := range ast2.Decls {\n-\t\td, ok := decl.(*ast.GenDecl)\n-\t\tif !ok {\n-\t\t\tast2.Decls[w] = decl\n+\tif *godefs {\n+\t\tw := 0\n+\t\tfor _, decl := range ast2.Decls {\n+\t\t\td, ok := decl.(*ast.GenDecl)\n+\t\t\tif !ok {\n+\t\t\t\tast2.Decls[w] = decl\n+\t\t\t\tw++\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tws := 0\n+\t\t\tfor _, spec := range d.Specs {\n+\t\t\t\ts, ok := spec.(*ast.ImportSpec)\n+\t\t\t\tif !ok || s.Path.Value != `\"C\"` {\n+\t\t\t\t\td.Specs[ws] = spec\n+\t\t\t\t\tws++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif ws == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\td.Specs = d.Specs[0:ws]\n+\t\t\tast2.Decls[w] = d\n \t\t\tw++\n-\t\t\tcontinue\n \t\t}\n-\t\tws := 0\n-\t\tfor _, spec := range d.Specs {\n-\t\t\ts, ok := spec.(*ast.ImportSpec)\n-\t\t\tif !ok || s.Path.Value != `\"C\"` {\n-\t\t\t\td.Specs[ws] = spec\n-\t\t\t\tws++\n+\t\tast2.Decls = ast2.Decls[0:w]\n+\t} else {\n+\t\tfor _, decl := range ast2.Decls {\n+\t\t\td, ok := decl.(*ast.GenDecl)\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfor _, spec := range d.Specs {\n+\t\t\t\tif s, ok := spec.(*ast.ImportSpec); ok && s.Path.Value == `\"C\"` {\n+\t\t\t\t\t// Replace \"C\" with _ \"unsafe\", to keep program valid.\n+\t\t\t\t\t// (Deleting import statement or clause is not safe if it is followed\n+\t\t\t\t\t// in the source by an explicit semicolon.)\n+\t\t\t\t\tf.Edit.Replace(f.offset(s.Path.Pos()), f.offset(s.Path.End()), `_ \"unsafe\"`)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif ws == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\td.Specs = d.Specs[0:ws]\n-\t\tast2.Decls[w] = d\n-\t\tw++\n \t}\n-\tast2.Decls = ast2.Decls[0:w]\n \n \t// Accumulate pointers to uses of C.x.\n \tif f.Ref == nil {\n \t\tf.Ref = make([]*Ref, 0, 8)\n \t}\n-\tf.walk(ast2, \"prog\", (*File).saveExprs)\n+\tf.walk(ast2, ctxProg, (*File).saveExprs)\n \n \t// Accumulate exported functions.\n \t// The comments are only on ast1 but we need to\n \t// save the function bodies from ast2.\n \t// The first walk fills in ExpFunc, and the\n \t// second walk changes the entries to\n \t// refer to ast2 instead.\n-\tf.walk(ast1, \"prog\", (*File).saveExport)\n-\tf.walk(ast2, \"prog\", (*File).saveExport2)\n+\tf.walk(ast1, ctxProg, (*File).saveExport)\n+\tf.walk(ast2, ctxProg, (*File).saveExport2)\n \n \tf.Comments = ast1.Comments\n \tf.AST = ast2\n@@ -143,9 +163,6 @@ func (f *File) ParseGo(name string, src []byte) {\n // Like ast.CommentGroup's Text method but preserves\n // leading blank lines, so that line numbers line up.\n func commentText(g *ast.CommentGroup) string {\n-\tif g == nil {\n-\t\treturn \"\"\n-\t}\n \tvar pieces []string\n \tfor _, com := range g.List {\n \t\tc := com.Text\n@@ -165,7 +182,7 @@ func commentText(g *ast.CommentGroup) string {\n }\n \n // Save various references we are going to need later.\n-func (f *File) saveExprs(x interface{}, context string) {\n+func (f *File) saveExprs(x interface{}, context astContext) {\n \tswitch x := x.(type) {\n \tcase *ast.Expr:\n \t\tswitch (*x).(type) {\n@@ -178,7 +195,7 @@ func (f *File) saveExprs(x interface{}, context string) {\n }\n \n // Save references to C.xxx for later processing.\n-func (f *File) saveRef(n *ast.Expr, context string) {\n+func (f *File) saveRef(n *ast.Expr, context astContext) {\n \tsel := (*n).(*ast.SelectorExpr)\n \t// For now, assume that the only instance of capital C is when\n \t// used as the imported package identifier.\n@@ -188,10 +205,10 @@ func (f *File) saveRef(n *ast.Expr, context string) {\n \tif l, ok := sel.X.(*ast.Ident); !ok || l.Name != \"C\" {\n \t\treturn\n \t}\n-\tif context == \"as2\" {\n-\t\tcontext = \"expr\"\n+\tif context == ctxAssign2 {\n+\t\tcontext = ctxExpr\n \t}\n-\tif context == \"embed-type\" {\n+\tif context == ctxEmbedType {\n \t\terror_(sel.Pos(), \"cannot embed C type\")\n \t}\n \tgoname := sel.Sel.Name\n@@ -212,6 +229,7 @@ func (f *File) saveRef(n *ast.Expr, context string) {\n \t\t\tGo: goname,\n \t\t}\n \t\tf.Name[goname] = name\n+\t\tf.NamePos[name] = sel.Pos()\n \t}\n \tf.Ref = append(f.Ref, &Ref{\n \t\tName:    name,\n@@ -221,20 +239,20 @@ func (f *File) saveRef(n *ast.Expr, context string) {\n }\n \n // Save calls to C.xxx for later processing.\n-func (f *File) saveCall(call *ast.CallExpr, context string) {\n+func (f *File) saveCall(call *ast.CallExpr, context astContext) {\n \tsel, ok := call.Fun.(*ast.SelectorExpr)\n \tif !ok {\n \t\treturn\n \t}\n \tif l, ok := sel.X.(*ast.Ident); !ok || l.Name != \"C\" {\n \t\treturn\n \t}\n-\tc := &Call{Call: call, Deferred: context == \"defer\"}\n+\tc := &Call{Call: call, Deferred: context == ctxDefer}\n \tf.Calls = append(f.Calls, c)\n }\n \n // If a function should be exported add it to ExpFunc.\n-func (f *File) saveExport(x interface{}, context string) {\n+func (f *File) saveExport(x interface{}, context astContext) {\n \tn, ok := x.(*ast.FuncDecl)\n \tif !ok {\n \t\treturn\n@@ -274,7 +292,7 @@ func (f *File) saveExport(x interface{}, context string) {\n }\n \n // Make f.ExpFunc[i] point at the Func from this AST instead of the other one.\n-func (f *File) saveExport2(x interface{}, context string) {\n+func (f *File) saveExport2(x interface{}, context astContext) {\n \tn, ok := x.(*ast.FuncDecl)\n \tif !ok {\n \t\treturn\n@@ -288,8 +306,30 @@ func (f *File) saveExport2(x interface{}, context string) {\n \t}\n }\n \n+type astContext int\n+\n+const (\n+\tctxProg astContext = iota\n+\tctxEmbedType\n+\tctxType\n+\tctxStmt\n+\tctxExpr\n+\tctxField\n+\tctxParam\n+\tctxAssign2 // assignment of a single expression to two variables\n+\tctxSwitch\n+\tctxTypeSwitch\n+\tctxFile\n+\tctxDecl\n+\tctxSpec\n+\tctxDefer\n+\tctxCall  // any function call other than ctxCall2\n+\tctxCall2 // function call whose result is assigned to two variables\n+\tctxSelector\n+)\n+\n // walk walks the AST x, calling visit(f, x, context) for each node.\n-func (f *File) walk(x interface{}, context string, visit func(*File, interface{}, string)) {\n+func (f *File) walk(x interface{}, context astContext, visit func(*File, interface{}, astContext)) {\n \tvisit(f, x, context)\n \tswitch n := x.(type) {\n \tcase *ast.Expr:\n@@ -304,10 +344,10 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \n \t// These are ordered and grouped to match ../../go/ast/ast.go\n \tcase *ast.Field:\n-\t\tif len(n.Names) == 0 && context == \"field\" {\n-\t\t\tf.walk(&n.Type, \"embed-type\", visit)\n+\t\tif len(n.Names) == 0 && context == ctxField {\n+\t\t\tf.walk(&n.Type, ctxEmbedType, visit)\n \t\t} else {\n-\t\t\tf.walk(&n.Type, \"type\", visit)\n+\t\t\tf.walk(&n.Type, ctxType, visit)\n \t\t}\n \tcase *ast.FieldList:\n \t\tfor _, field := range n.List {\n@@ -318,163 +358,163 @@ func (f *File) walk(x interface{}, context string, visit func(*File, interface{}\n \tcase *ast.Ellipsis:\n \tcase *ast.BasicLit:\n \tcase *ast.FuncLit:\n-\t\tf.walk(n.Type, \"type\", visit)\n-\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(n.Type, ctxType, visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n \tcase *ast.CompositeLit:\n-\t\tf.walk(&n.Type, \"type\", visit)\n-\t\tf.walk(n.Elts, \"expr\", visit)\n+\t\tf.walk(&n.Type, ctxType, visit)\n+\t\tf.walk(n.Elts, ctxExpr, visit)\n \tcase *ast.ParenExpr:\n \t\tf.walk(&n.X, context, visit)\n \tcase *ast.SelectorExpr:\n-\t\tf.walk(&n.X, \"selector\", visit)\n+\t\tf.walk(&n.X, ctxSelector, visit)\n \tcase *ast.IndexExpr:\n-\t\tf.walk(&n.X, \"expr\", visit)\n-\t\tf.walk(&n.Index, \"expr\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n+\t\tf.walk(&n.Index, ctxExpr, visit)\n \tcase *ast.SliceExpr:\n-\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n \t\tif n.Low != nil {\n-\t\t\tf.walk(&n.Low, \"expr\", visit)\n+\t\t\tf.walk(&n.Low, ctxExpr, visit)\n \t\t}\n \t\tif n.High != nil {\n-\t\t\tf.walk(&n.High, \"expr\", visit)\n+\t\t\tf.walk(&n.High, ctxExpr, visit)\n \t\t}\n \t\tif n.Max != nil {\n-\t\t\tf.walk(&n.Max, \"expr\", visit)\n+\t\t\tf.walk(&n.Max, ctxExpr, visit)\n \t\t}\n \tcase *ast.TypeAssertExpr:\n-\t\tf.walk(&n.X, \"expr\", visit)\n-\t\tf.walk(&n.Type, \"type\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n+\t\tf.walk(&n.Type, ctxType, visit)\n \tcase *ast.CallExpr:\n-\t\tif context == \"as2\" {\n-\t\t\tf.walk(&n.Fun, \"call2\", visit)\n+\t\tif context == ctxAssign2 {\n+\t\t\tf.walk(&n.Fun, ctxCall2, visit)\n \t\t} else {\n-\t\t\tf.walk(&n.Fun, \"call\", visit)\n+\t\t\tf.walk(&n.Fun, ctxCall, visit)\n \t\t}\n-\t\tf.walk(n.Args, \"expr\", visit)\n+\t\tf.walk(n.Args, ctxExpr, visit)\n \tcase *ast.StarExpr:\n \t\tf.walk(&n.X, context, visit)\n \tcase *ast.UnaryExpr:\n-\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n \tcase *ast.BinaryExpr:\n-\t\tf.walk(&n.X, \"expr\", visit)\n-\t\tf.walk(&n.Y, \"expr\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n+\t\tf.walk(&n.Y, ctxExpr, visit)\n \tcase *ast.KeyValueExpr:\n-\t\tf.walk(&n.Key, \"expr\", visit)\n-\t\tf.walk(&n.Value, \"expr\", visit)\n+\t\tf.walk(&n.Key, ctxExpr, visit)\n+\t\tf.walk(&n.Value, ctxExpr, visit)\n \n \tcase *ast.ArrayType:\n-\t\tf.walk(&n.Len, \"expr\", visit)\n-\t\tf.walk(&n.Elt, \"type\", visit)\n+\t\tf.walk(&n.Len, ctxExpr, visit)\n+\t\tf.walk(&n.Elt, ctxType, visit)\n \tcase *ast.StructType:\n-\t\tf.walk(n.Fields, \"field\", visit)\n+\t\tf.walk(n.Fields, ctxField, visit)\n \tcase *ast.FuncType:\n-\t\tf.walk(n.Params, \"param\", visit)\n+\t\tf.walk(n.Params, ctxParam, visit)\n \t\tif n.Results != nil {\n-\t\t\tf.walk(n.Results, \"param\", visit)\n+\t\t\tf.walk(n.Results, ctxParam, visit)\n \t\t}\n \tcase *ast.InterfaceType:\n-\t\tf.walk(n.Methods, \"field\", visit)\n+\t\tf.walk(n.Methods, ctxField, visit)\n \tcase *ast.MapType:\n-\t\tf.walk(&n.Key, \"type\", visit)\n-\t\tf.walk(&n.Value, \"type\", visit)\n+\t\tf.walk(&n.Key, ctxType, visit)\n+\t\tf.walk(&n.Value, ctxType, visit)\n \tcase *ast.ChanType:\n-\t\tf.walk(&n.Value, \"type\", visit)\n+\t\tf.walk(&n.Value, ctxType, visit)\n \n \tcase *ast.BadStmt:\n \tcase *ast.DeclStmt:\n-\t\tf.walk(n.Decl, \"decl\", visit)\n+\t\tf.walk(n.Decl, ctxDecl, visit)\n \tcase *ast.EmptyStmt:\n \tcase *ast.LabeledStmt:\n-\t\tf.walk(n.Stmt, \"stmt\", visit)\n+\t\tf.walk(n.Stmt, ctxStmt, visit)\n \tcase *ast.ExprStmt:\n-\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n \tcase *ast.SendStmt:\n-\t\tf.walk(&n.Chan, \"expr\", visit)\n-\t\tf.walk(&n.Value, \"expr\", visit)\n+\t\tf.walk(&n.Chan, ctxExpr, visit)\n+\t\tf.walk(&n.Value, ctxExpr, visit)\n \tcase *ast.IncDecStmt:\n-\t\tf.walk(&n.X, \"expr\", visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n \tcase *ast.AssignStmt:\n-\t\tf.walk(n.Lhs, \"expr\", visit)\n+\t\tf.walk(n.Lhs, ctxExpr, visit)\n \t\tif len(n.Lhs) == 2 && len(n.Rhs) == 1 {\n-\t\t\tf.walk(n.Rhs, \"as2\", visit)\n+\t\t\tf.walk(n.Rhs, ctxAssign2, visit)\n \t\t} else {\n-\t\t\tf.walk(n.Rhs, \"expr\", visit)\n+\t\t\tf.walk(n.Rhs, ctxExpr, visit)\n \t\t}\n \tcase *ast.GoStmt:\n-\t\tf.walk(n.Call, \"expr\", visit)\n+\t\tf.walk(n.Call, ctxExpr, visit)\n \tcase *ast.DeferStmt:\n-\t\tf.walk(n.Call, \"defer\", visit)\n+\t\tf.walk(n.Call, ctxDefer, visit)\n \tcase *ast.ReturnStmt:\n-\t\tf.walk(n.Results, \"expr\", visit)\n+\t\tf.walk(n.Results, ctxExpr, visit)\n \tcase *ast.BranchStmt:\n \tcase *ast.BlockStmt:\n \t\tf.walk(n.List, context, visit)\n \tcase *ast.IfStmt:\n-\t\tf.walk(n.Init, \"stmt\", visit)\n-\t\tf.walk(&n.Cond, \"expr\", visit)\n-\t\tf.walk(n.Body, \"stmt\", visit)\n-\t\tf.walk(n.Else, \"stmt\", visit)\n+\t\tf.walk(n.Init, ctxStmt, visit)\n+\t\tf.walk(&n.Cond, ctxExpr, visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n+\t\tf.walk(n.Else, ctxStmt, visit)\n \tcase *ast.CaseClause:\n-\t\tif context == \"typeswitch\" {\n-\t\t\tcontext = \"type\"\n+\t\tif context == ctxTypeSwitch {\n+\t\t\tcontext = ctxType\n \t\t} else {\n-\t\t\tcontext = \"expr\"\n+\t\t\tcontext = ctxExpr\n \t\t}\n \t\tf.walk(n.List, context, visit)\n-\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n \tcase *ast.SwitchStmt:\n-\t\tf.walk(n.Init, \"stmt\", visit)\n-\t\tf.walk(&n.Tag, \"expr\", visit)\n-\t\tf.walk(n.Body, \"switch\", visit)\n+\t\tf.walk(n.Init, ctxStmt, visit)\n+\t\tf.walk(&n.Tag, ctxExpr, visit)\n+\t\tf.walk(n.Body, ctxSwitch, visit)\n \tcase *ast.TypeSwitchStmt:\n-\t\tf.walk(n.Init, \"stmt\", visit)\n-\t\tf.walk(n.Assign, \"stmt\", visit)\n-\t\tf.walk(n.Body, \"typeswitch\", visit)\n+\t\tf.walk(n.Init, ctxStmt, visit)\n+\t\tf.walk(n.Assign, ctxStmt, visit)\n+\t\tf.walk(n.Body, ctxTypeSwitch, visit)\n \tcase *ast.CommClause:\n-\t\tf.walk(n.Comm, \"stmt\", visit)\n-\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(n.Comm, ctxStmt, visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n \tcase *ast.SelectStmt:\n-\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n \tcase *ast.ForStmt:\n-\t\tf.walk(n.Init, \"stmt\", visit)\n-\t\tf.walk(&n.Cond, \"expr\", visit)\n-\t\tf.walk(n.Post, \"stmt\", visit)\n-\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(n.Init, ctxStmt, visit)\n+\t\tf.walk(&n.Cond, ctxExpr, visit)\n+\t\tf.walk(n.Post, ctxStmt, visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n \tcase *ast.RangeStmt:\n-\t\tf.walk(&n.Key, \"expr\", visit)\n-\t\tf.walk(&n.Value, \"expr\", visit)\n-\t\tf.walk(&n.X, \"expr\", visit)\n-\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\tf.walk(&n.Key, ctxExpr, visit)\n+\t\tf.walk(&n.Value, ctxExpr, visit)\n+\t\tf.walk(&n.X, ctxExpr, visit)\n+\t\tf.walk(n.Body, ctxStmt, visit)\n \n \tcase *ast.ImportSpec:\n \tcase *ast.ValueSpec:\n-\t\tf.walk(&n.Type, \"type\", visit)\n+\t\tf.walk(&n.Type, ctxType, visit)\n \t\tif len(n.Names) == 2 && len(n.Values) == 1 {\n-\t\t\tf.walk(&n.Values[0], \"as2\", visit)\n+\t\t\tf.walk(&n.Values[0], ctxAssign2, visit)\n \t\t} else {\n-\t\t\tf.walk(n.Values, \"expr\", visit)\n+\t\t\tf.walk(n.Values, ctxExpr, visit)\n \t\t}\n \tcase *ast.TypeSpec:\n-\t\tf.walk(&n.Type, \"type\", visit)\n+\t\tf.walk(&n.Type, ctxType, visit)\n \n \tcase *ast.BadDecl:\n \tcase *ast.GenDecl:\n-\t\tf.walk(n.Specs, \"spec\", visit)\n+\t\tf.walk(n.Specs, ctxSpec, visit)\n \tcase *ast.FuncDecl:\n \t\tif n.Recv != nil {\n-\t\t\tf.walk(n.Recv, \"param\", visit)\n+\t\t\tf.walk(n.Recv, ctxParam, visit)\n \t\t}\n-\t\tf.walk(n.Type, \"type\", visit)\n+\t\tf.walk(n.Type, ctxType, visit)\n \t\tif n.Body != nil {\n-\t\t\tf.walk(n.Body, \"stmt\", visit)\n+\t\t\tf.walk(n.Body, ctxStmt, visit)\n \t\t}\n \n \tcase *ast.File:\n-\t\tf.walk(n.Decls, \"decl\", visit)\n+\t\tf.walk(n.Decls, ctxDecl, visit)\n \n \tcase *ast.Package:\n \t\tfor _, file := range n.Files {\n-\t\t\tf.walk(file, \"file\", visit)\n+\t\t\tf.walk(file, ctxFile, visit)\n \t\t}\n \n \tcase []ast.Decl:"}, {"sha": "c1bdf0659fa0d809ddf1965d8b8d0251486395a4", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 215, "deletions": 70, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -102,11 +102,13 @@ the use of cgo, and to 0 to disable it. The go tool will set the\n build constraint \"cgo\" if cgo is enabled.\n \n When cross-compiling, you must specify a C cross-compiler for cgo to\n-use. You can do this by setting the CC_FOR_TARGET environment\n-variable when building the toolchain using make.bash, or by setting\n-the CC environment variable any time you run the go tool. The\n-CXX_FOR_TARGET and CXX environment variables work in a similar way for\n-C++ code.\n+use. You can do this by setting the generic CC_FOR_TARGET or the\n+more specific CC_FOR_${GOOS}_${GOARCH} (for example, CC_FOR_linux_arm)\n+environment variable when building the toolchain using make.bash,\n+or you can set the CC environment variable any time you run the go tool.\n+\n+The CXX_FOR_TARGET, CXX_FOR_${GOOS}_${GOARCH}, and CXX\n+environment variables work in a similar way for C++ code.\n \n Go references to C\n \n@@ -126,12 +128,29 @@ C.complexfloat (complex float), and C.complexdouble (complex double).\n The C type void* is represented by Go's unsafe.Pointer.\n The C types __int128_t and __uint128_t are represented by [16]byte.\n \n+A few special C types which would normally be represented by a pointer\n+type in Go are instead represented by a uintptr.  See the Special\n+cases section below.\n+\n To access a struct, union, or enum type directly, prefix it with\n struct_, union_, or enum_, as in C.struct_stat.\n \n The size of any C type T is available as C.sizeof_T, as in\n C.sizeof_struct_stat.\n \n+A C function may be declared in the Go file with a parameter type of\n+the special name _GoString_. This function may be called with an\n+ordinary Go string value. The string length, and a pointer to the\n+string contents, may be accessed by calling the C functions\n+\n+\tsize_t _GoStringLen(_GoString_ s);\n+\tconst char *_GoStringPtr(_GoString_ s);\n+\n+These functions are only available in the preamble, not in other C\n+files. The C code must not modify the contents of the pointer returned\n+by _GoStringPtr. Note that the string contents may not have a trailing\n+NUL byte.\n+\n As Go doesn't have support for C's union type in the general case,\n C's union types are represented as a Go byte array with the same length.\n \n@@ -241,7 +260,16 @@ They will be available in the C code as:\n found in the _cgo_export.h generated header, after any preambles\n copied from the cgo input files. Functions with multiple\n return values are mapped to functions returning a struct.\n+\n Not all Go types can be mapped to C types in a useful way.\n+Go struct types are not supported; use a C struct type.\n+Go array types are not supported; use a C pointer.\n+\n+Go functions that take arguments of type string may be called with the\n+C type _GoString_, described above. The _GoString_ type will be\n+automatically defined in the preamble. Note that there is no way for C\n+code to create a value of this type; this is only useful for passing\n+string values from Go to C and back to Go.\n \n Using //export in a file places a restriction on the preamble:\n since it is copied into two different C output files, it must not\n@@ -264,6 +292,14 @@ pointer is a Go pointer or a C pointer is a dynamic property\n determined by how the memory was allocated; it has nothing to do with\n the type of the pointer.\n \n+Note that values of some Go types, other than the type's zero value,\n+always include Go pointers. This is true of string, slice, interface,\n+channel, map, and function types. A pointer type may hold a Go pointer\n+or a C pointer. Array and struct types may or may not include Go\n+pointers, depending on the element types. All the discussion below\n+about Go pointers applies not just to pointer types, but also to other\n+types that include Go pointers.\n+\n Go code may pass a Go pointer to C provided the Go memory to which it\n points does not contain any Go pointers. The C code must preserve\n this property: it must not store any Go pointers in Go memory, even\n@@ -274,14 +310,17 @@ the Go memory in question is the entire array or the entire backing\n array of the slice.\n \n C code may not keep a copy of a Go pointer after the call returns.\n-\n-A Go function called by C code may not return a Go pointer. A Go\n-function called by C code may take C pointers as arguments, and it may\n-store non-pointer or C pointer data through those pointers, but it may\n-not store a Go pointer in memory pointed to by a C pointer. A Go\n-function called by C code may take a Go pointer as an argument, but it\n-must preserve the property that the Go memory to which it points does\n-not contain any Go pointers.\n+This includes the _GoString_ type, which, as noted above, includes a\n+Go pointer; _GoString_ values may not be retained by C code.\n+\n+A Go function called by C code may not return a Go pointer (which\n+implies that it may not return a string, slice, channel, and so\n+forth). A Go function called by C code may take C pointers as\n+arguments, and it may store non-pointer or C pointer data through\n+those pointers, but it may not store a Go pointer in memory pointed to\n+by a C pointer. A Go function called by C code may take a Go pointer\n+as an argument, but it must preserve the property that the Go memory\n+to which it points does not contain any Go pointers.\n \n Go code may not store a Go pointer in C memory. C code may store Go\n pointers in C memory, subject to the rule above: it must stop storing\n@@ -299,6 +338,84 @@ and of course there is nothing stopping the C code from doing anything\n it likes. However, programs that break these rules are likely to fail\n in unexpected and unpredictable ways.\n \n+Special cases\n+\n+A few special C types which would normally be represented by a pointer\n+type in Go are instead represented by a uintptr. Those types are\n+the CF*Ref types from the CoreFoundation library on Darwin, including:\n+\n+\tCFAllocatorRef\n+\tCFArrayRef\n+\tCFAttributedStringRef\n+\tCFBagRef\n+\tCFBinaryHeapRef\n+\tCFBitVectorRef\n+\tCFBooleanRef\n+\tCFBundleRef\n+\tCFCalendarRef\n+\tCFCharacterSetRef\n+\tCFDataRef\n+\tCFDateFormatterRef\n+\tCFDateRef\n+\tCFDictionaryRef\n+\tCFErrorRef\n+\tCFFileDescriptorRef\n+\tCFFileSecurityRef\n+\tCFLocaleRef\n+\tCFMachPortRef\n+\tCFMessagePortRef\n+\tCFMutableArrayRef\n+\tCFMutableAttributedStringRef\n+\tCFMutableBagRef\n+\tCFMutableBitVectorRef\n+\tCFMutableCharacterSetRef\n+\tCFMutableDataRef\n+\tCFMutableDictionaryRef\n+\tCFMutableSetRef\n+\tCFMutableStringRef\n+\tCFNotificationCenterRef\n+\tCFNullRef\n+\tCFNumberFormatterRef\n+\tCFNumberRef\n+\tCFPlugInInstanceRef\n+\tCFPlugInRef\n+\tCFPropertyListRef\n+\tCFReadStreamRef\n+\tCFRunLoopObserverRef\n+\tCFRunLoopRef\n+\tCFRunLoopSourceRef\n+\tCFRunLoopTimerRef\n+\tCFSetRef\n+\tCFSocketRef\n+\tCFStringRef\n+\tCFStringTokenizerRef\n+\tCFTimeZoneRef\n+\tCFTreeRef\n+\tCFTypeRef\n+\tCFURLCreateFromFSRef\n+\tCFURLEnumeratorRef\n+\tCFURLGetFSRef\n+\tCFURLRef\n+\tCFUUIDRef\n+\tCFUserNotificationRef\n+\tCFWriteStreamRef\n+\tCFXMLNodeRef\n+\tCFXMLParserRef\n+\tCFXMLTreeRef\n+\n+These types are uintptr on the Go side because they would otherwise\n+confuse the Go garbage collector; they are sometimes not really\n+pointers but data structures encoded in a pointer type. All operations\n+on these types must happen in C. The proper constant to initialize an\n+empty such reference is 0, not nil.\n+\n+This special case was introduced in Go 1.10. For auto-updating code\n+from Go 1.9 and earlier, use the cftype rewrite in the Go fix tool:\n+\n+\tgo tool fix -r cftype <pkg>\n+\n+It will replace nil with 0 in the appropriate places.\n+\n Using cgo directly\n \n Usage:\n@@ -312,49 +429,49 @@ invoking the C compiler to compile the C parts of the package.\n \n The following options are available when running cgo directly:\n \n+\t-V\n+\t\tPrint cgo version and exit.\n+\t-debug-define\n+\t\tDebugging option. Print #defines.\n+\t-debug-gcc\n+\t\tDebugging option. Trace C compiler execution and output.\n \t-dynimport file\n \t\tWrite list of symbols imported by file. Write to\n \t\t-dynout argument or to standard output. Used by go\n \t\tbuild when building a cgo package.\n+\t-dynlinker\n+\t\tWrite dynamic linker as part of -dynimport output.\n \t-dynout file\n \t\tWrite -dynimport output to file.\n \t-dynpackage package\n \t\tSet Go package for -dynimport output.\n-\t-dynlinker\n-\t\tWrite dynamic linker as part of -dynimport output.\n-\t-godefs\n-\t\tWrite out input file in Go syntax replacing C package\n-\t\tnames with real values. Used to generate files in the\n-\t\tsyscall package when bootstrapping a new target.\n-\t-srcdir directory\n-\t\tFind the Go input files, listed on the command line,\n-\t\tin directory.\n-\t-objdir directory\n-\t\tPut all generated files in directory.\n-\t-importpath string\n-\t\tThe import path for the Go package. Optional; used for\n-\t\tnicer comments in the generated files.\n \t-exportheader file\n \t\tIf there are any exported functions, write the\n \t\tgenerated export declarations to file.\n \t\tC code can #include this to see the declarations.\n+\t-importpath string\n+\t\tThe import path for the Go package. Optional; used for\n+\t\tnicer comments in the generated files.\n+\t-import_runtime_cgo\n+\t\tIf set (which it is by default) import runtime/cgo in\n+\t\tgenerated output.\n+\t-import_syscall\n+\t\tIf set (which it is by default) import syscall in\n+\t\tgenerated output.\n \t-gccgo\n \t\tGenerate output for the gccgo compiler rather than the\n \t\tgc compiler.\n \t-gccgoprefix prefix\n \t\tThe -fgo-prefix option to be used with gccgo.\n \t-gccgopkgpath path\n \t\tThe -fgo-pkgpath option to be used with gccgo.\n-\t-import_runtime_cgo\n-\t\tIf set (which it is by default) import runtime/cgo in\n-\t\tgenerated output.\n-\t-import_syscall\n-\t\tIf set (which it is by default) import syscall in\n-\t\tgenerated output.\n-\t-debug-define\n-\t\tDebugging option. Print #defines.\n-\t-debug-gcc\n-\t\tDebugging option. Trace C compiler execution and output.\n+\t-godefs\n+\t\tWrite out input file in Go syntax replacing C package\n+\t\tnames with real values. Used to generate files in the\n+\t\tsyscall package when bootstrapping a new target.\n+\t-objdir directory\n+\t\tPut all generated files in directory.\n+\t-srcdir directory\n */\n package main\n \n@@ -403,21 +520,19 @@ about simple #defines for constants and the like. These are recorded\n for later use.\n \n Next, cgo needs to identify the kinds for each identifier. For the\n-identifiers C.foo and C.bar, cgo generates this C program:\n+identifiers C.foo, cgo generates this C program:\n \n \t<preamble>\n \t#line 1 \"not-declared\"\n-\tvoid __cgo_f_xxx_1(void) { __typeof__(foo) *__cgo_undefined__; }\n+\tvoid __cgo_f_1_1(void) { __typeof__(foo) *__cgo_undefined__1; }\n \t#line 1 \"not-type\"\n-\tvoid __cgo_f_xxx_2(void) { foo *__cgo_undefined__; }\n-\t#line 1 \"not-const\"\n-\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (foo)*1 }; }\n-\t#line 2 \"not-declared\"\n-\tvoid __cgo_f_xxx_1(void) { __typeof__(bar) *__cgo_undefined__; }\n-\t#line 2 \"not-type\"\n-\tvoid __cgo_f_xxx_2(void) { bar *__cgo_undefined__; }\n-\t#line 2 \"not-const\"\n-\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (bar)*1 }; }\n+\tvoid __cgo_f_1_2(void) { foo *__cgo_undefined__2; }\n+\t#line 1 \"not-int-const\"\n+\tvoid __cgo_f_1_3(void) { enum { __cgo_undefined__3 = (foo)*1 }; }\n+\t#line 1 \"not-num-const\"\n+\tvoid __cgo_f_1_4(void) { static const double __cgo_undefined__4 = (foo); }\n+\t#line 1 \"not-str-lit\"\n+\tvoid __cgo_f_1_5(void) { static const char __cgo_undefined__5[] = (foo); }\n \n This program will not compile, but cgo can use the presence or absence\n of an error message on a given line to deduce the information it\n@@ -427,45 +542,72 @@ errors that might stop parsing early.\n \n An error on not-declared:1 indicates that foo is undeclared.\n An error on not-type:1 indicates that foo is not a type (if declared at all, it is an identifier).\n-An error on not-const:1 indicates that foo is not an integer constant.\n+An error on not-int-const:1 indicates that foo is not an integer constant.\n+An error on not-num-const:1 indicates that foo is not a number constant.\n+An error on not-str-lit:1 indicates that foo is not a string literal.\n+An error on not-signed-int-const:1 indicates that foo is not a signed integer constant.\n \n-The line number specifies the name involved. In the example, 1 is foo and 2 is bar.\n+The line number specifies the name involved. In the example, 1 is foo.\n \n Next, cgo must learn the details of each type, variable, function, or\n constant. It can do this by reading object files. If cgo has decided\n-that t1 is a type, v2 and v3 are variables or functions, and c4, c5,\n-and c6 are constants, it generates:\n+that t1 is a type, v2 and v3 are variables or functions, and i4, i5\n+are integer constants, u6 is an unsigned integer constant, and f7 and f8\n+are float constants, and s9 and s10 are string constants, it generates:\n \n \t<preamble>\n \t__typeof__(t1) *__cgo__1;\n \t__typeof__(v2) *__cgo__2;\n \t__typeof__(v3) *__cgo__3;\n-\t__typeof__(c4) *__cgo__4;\n-\tenum { __cgo_enum__4 = c4 };\n-\t__typeof__(c5) *__cgo__5;\n-\tenum { __cgo_enum__5 = c5 };\n-\t__typeof__(c6) *__cgo__6;\n-\tenum { __cgo_enum__6 = c6 };\n-\n-\tlong long __cgo_debug_data[] = {\n+\t__typeof__(i4) *__cgo__4;\n+\tenum { __cgo_enum__4 = i4 };\n+\t__typeof__(i5) *__cgo__5;\n+\tenum { __cgo_enum__5 = i5 };\n+\t__typeof__(u6) *__cgo__6;\n+\tenum { __cgo_enum__6 = u6 };\n+\t__typeof__(f7) *__cgo__7;\n+\t__typeof__(f8) *__cgo__8;\n+\t__typeof__(s9) *__cgo__9;\n+\t__typeof__(s10) *__cgo__10;\n+\n+\tlong long __cgodebug_ints[] = {\n \t\t0, // t1\n \t\t0, // v2\n \t\t0, // v3\n-\t\tc4,\n-\t\tc5,\n-\t\tc6,\n+\t\ti4,\n+\t\ti5,\n+\t\tu6,\n+\t\t0, // f7\n+\t\t0, // f8\n+\t\t0, // s9\n+\t\t0, // s10\n \t\t1\n \t};\n \n+\tdouble __cgodebug_floats[] = {\n+\t\t0, // t1\n+\t\t0, // v2\n+\t\t0, // v3\n+\t\t0, // i4\n+\t\t0, // i5\n+\t\t0, // u6\n+\t\tf7,\n+\t\tf8,\n+\t\t0, // s9\n+\t\t0, // s10\n+\t\t1\n+\t};\n+\n+\tconst char __cgodebug_str__9[] = s9;\n+\tconst unsigned long long __cgodebug_strlen__9 = sizeof(s9)-1;\n+\tconst char __cgodebug_str__10[] = s10;\n+\tconst unsigned long long __cgodebug_strlen__10 = sizeof(s10)-1;\n+\n and again invokes the system C compiler, to produce an object file\n containing debug information. Cgo parses the DWARF debug information\n for __cgo__N to learn the type of each identifier. (The types also\n-distinguish functions from global variables.) If using a standard gcc,\n-cgo can parse the DWARF debug information for the __cgo_enum__N to\n-learn the identifier's value. The LLVM-based gcc on OS X emits\n-incomplete DWARF information for enums; in that case cgo reads the\n-constant values from the __cgo_debug_data from the object file's data\n-segment.\n+distinguish functions from global variables.) Cgo reads the constant\n+values from the __cgodebug_* from the object file's data segment.\n \n At this point cgo knows the meaning of each C.xxx well enough to start\n the translation process.\n@@ -550,9 +692,12 @@ _cgo_main.c:\n \n \tint main() { return 0; }\n \tvoid crosscall2(void(*fn)(void*, int, uintptr_t), void *a, int c, uintptr_t ctxt) { }\n-\tuintptr_t _cgo_wait_runtime_init_done() { }\n+\tuintptr_t _cgo_wait_runtime_init_done() { return 0; }\n+\tvoid _cgo_release_context(uintptr_t ctxt) { }\n+\tchar* _cgo_topofstack(void) { return (char*)0; }\n \tvoid _cgo_allocate(void *a, int c) { }\n \tvoid _cgo_panic(void *a, int c) { }\n+\tvoid _cgo_reginit(void) { }\n \n The extra functions here are stubs to satisfy the references in the C\n code generated for gcc. The build process links this stub, along with"}, {"sha": "f3bb528b4d53b61ab3b3c0dfc32312559c33d3ee", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 155, "deletions": 122, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -188,21 +188,8 @@ func (p *Package) Translate(f *File) {\n \t\tp.loadDWARF(f, needType)\n \t}\n \tif p.rewriteCalls(f) {\n-\t\t// Add `import _cgo_unsafe \"unsafe\"` as the first decl\n-\t\t// after the package statement.\n-\t\timp := &ast.GenDecl{\n-\t\t\tTok: token.IMPORT,\n-\t\t\tSpecs: []ast.Spec{\n-\t\t\t\t&ast.ImportSpec{\n-\t\t\t\t\tName: ast.NewIdent(\"_cgo_unsafe\"),\n-\t\t\t\t\tPath: &ast.BasicLit{\n-\t\t\t\t\t\tKind:  token.STRING,\n-\t\t\t\t\t\tValue: `\"unsafe\"`,\n-\t\t\t\t\t},\n-\t\t\t\t},\n-\t\t\t},\n-\t\t}\n-\t\tf.AST.Decls = append([]ast.Decl{imp}, f.AST.Decls...)\n+\t\t// Add `import _cgo_unsafe \"unsafe\"` after the package statement.\n+\t\tf.Edit.Insert(f.offset(f.AST.Name.End()), \"; import _cgo_unsafe \\\"unsafe\\\"\")\n \t}\n \tp.rewriteRef(f)\n }\n@@ -211,8 +198,8 @@ func (p *Package) Translate(f *File) {\n // in the file f and saves relevant renamings in f.Name[name].Define.\n func (p *Package) loadDefines(f *File) {\n \tvar b bytes.Buffer\n-\tb.WriteString(f.Preamble)\n \tb.WriteString(builtinProlog)\n+\tb.WriteString(f.Preamble)\n \tstdout := p.gccDefines(b.Bytes())\n \n \tfor _, line := range strings.Split(stdout, \"\\n\") {\n@@ -283,10 +270,6 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tif n.IsConst() {\n \t\t\t\tcontinue\n \t\t\t}\n-\n-\t\t\tif isName(n.Define) {\n-\t\t\t\tn.C = n.Define\n-\t\t\t}\n \t\t}\n \n \t\t// If this is a struct, union, or enum type name, no need to guess the kind.\n@@ -315,57 +298,45 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t// For each name, we generate these lines, where xxx is the index in toSniff plus one.\n \t//\n \t//\t#line xxx \"not-declared\"\n-\t//\tvoid __cgo_f_xxx_1(void) { __typeof__(name) *__cgo_undefined__; }\n+\t//\tvoid __cgo_f_xxx_1(void) { __typeof__(name) *__cgo_undefined__1; }\n \t//\t#line xxx \"not-type\"\n-\t//\tvoid __cgo_f_xxx_2(void) { name *__cgo_undefined__; }\n+\t//\tvoid __cgo_f_xxx_2(void) { name *__cgo_undefined__2; }\n \t//\t#line xxx \"not-int-const\"\n-\t//\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (name)*1 }; }\n+\t//\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__3 = (name)*1 }; }\n \t//\t#line xxx \"not-num-const\"\n-\t//\tvoid __cgo_f_xxx_4(void) { static const double x = (name); }\n+\t//\tvoid __cgo_f_xxx_4(void) { static const double __cgo_undefined__4 = (name); }\n \t//\t#line xxx \"not-str-lit\"\n-\t//\tvoid __cgo_f_xxx_5(void) { static const char x[] = (name); }\n-\t//\t#line xxx \"not-signed-int-const\"\n-\t//\t#if 0 < -(name)\n-\t//\t#line xxx \"not-signed-int-const\"\n-\t//\t#error found unsigned int\n-\t//\t#endif\n+\t//\tvoid __cgo_f_xxx_5(void) { static const char __cgo_undefined__5[] = (name); }\n \t//\n \t// If we see an error at not-declared:xxx, the corresponding name is not declared.\n \t// If we see an error at not-type:xxx, the corresponding name is a type.\n \t// If we see an error at not-int-const:xxx, the corresponding name is not an integer constant.\n \t// If we see an error at not-num-const:xxx, the corresponding name is not a number constant.\n \t// If we see an error at not-str-lit:xxx, the corresponding name is not a string literal.\n-\t// If we see an error at not-signed-int-const:xxx, the corresponding name is not a signed integer literal.\n \t//\n \t// The specific input forms are chosen so that they are valid C syntax regardless of\n \t// whether name denotes a type or an expression.\n \n \tvar b bytes.Buffer\n-\tb.WriteString(f.Preamble)\n \tb.WriteString(builtinProlog)\n+\tb.WriteString(f.Preamble)\n \n \tfor i, n := range names {\n \t\tfmt.Fprintf(&b, \"#line %d \\\"not-declared\\\"\\n\"+\n-\t\t\t\"void __cgo_f_%d_1(void) { __typeof__(%s) *__cgo_undefined__; }\\n\"+\n+\t\t\t\"void __cgo_f_%d_1(void) { __typeof__(%s) *__cgo_undefined__1; }\\n\"+\n \t\t\t\"#line %d \\\"not-type\\\"\\n\"+\n-\t\t\t\"void __cgo_f_%d_2(void) { %s *__cgo_undefined__; }\\n\"+\n+\t\t\t\"void __cgo_f_%d_2(void) { %s *__cgo_undefined__2; }\\n\"+\n \t\t\t\"#line %d \\\"not-int-const\\\"\\n\"+\n-\t\t\t\"void __cgo_f_%d_3(void) { enum { __cgo_undefined__ = (%s)*1 }; }\\n\"+\n+\t\t\t\"void __cgo_f_%d_3(void) { enum { __cgo_undefined__3 = (%s)*1 }; }\\n\"+\n \t\t\t\"#line %d \\\"not-num-const\\\"\\n\"+\n-\t\t\t\"void __cgo_f_%d_4(void) { static const double x = (%s); }\\n\"+\n+\t\t\t\"void __cgo_f_%d_4(void) { static const double __cgo_undefined__4 = (%s); }\\n\"+\n \t\t\t\"#line %d \\\"not-str-lit\\\"\\n\"+\n-\t\t\t\"void __cgo_f_%d_5(void) { static const char s[] = (%s); }\\n\"+\n-\t\t\t\"#line %d \\\"not-signed-int-const\\\"\\n\"+\n-\t\t\t\"#if 0 < (%s)\\n\"+\n-\t\t\t\"#line %d \\\"not-signed-int-const\\\"\\n\"+\n-\t\t\t\"#error found unsigned int\\n\"+\n-\t\t\t\"#endif\\n\",\n+\t\t\t\"void __cgo_f_%d_5(void) { static const char __cgo_undefined__5[] = (%s); }\\n\",\n \t\t\ti+1, i+1, n.C,\n \t\t\ti+1, i+1, n.C,\n \t\t\ti+1, i+1, n.C,\n \t\t\ti+1, i+1, n.C,\n \t\t\ti+1, i+1, n.C,\n-\t\t\ti+1, n.C, i+1,\n \t\t)\n \t}\n \tfmt.Fprintf(&b, \"#line 1 \\\"completed\\\"\\n\"+\n@@ -384,7 +355,6 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\tnotNumConst\n \t\tnotStrLiteral\n \t\tnotDeclared\n-\t\tnotSignedIntConst\n \t)\n \tsawUnmatchedErrors := false\n \tfor _, line := range strings.Split(stderr, \"\\n\") {\n@@ -438,8 +408,6 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tsniff[i] |= notNumConst\n \t\tcase \"not-str-lit\":\n \t\t\tsniff[i] |= notStrLiteral\n-\t\tcase \"not-signed-int-const\":\n-\t\t\tsniff[i] |= notSignedIntConst\n \t\tdefault:\n \t\t\tif isError {\n \t\t\t\tsawUnmatchedErrors = true\n@@ -455,22 +423,11 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t}\n \n \tfor i, n := range names {\n-\t\tswitch sniff[i] &^ notSignedIntConst {\n+\t\tswitch sniff[i] {\n \t\tdefault:\n-\t\t\tvar tpos token.Pos\n-\t\t\tfor _, ref := range f.Ref {\n-\t\t\t\tif ref.Name == n {\n-\t\t\t\t\ttpos = ref.Pos()\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\terror_(tpos, \"could not determine kind of name for C.%s\", fixGo(n.Go))\n+\t\t\terror_(f.NamePos[n], \"could not determine kind of name for C.%s\", fixGo(n.Go))\n \t\tcase notStrLiteral | notType:\n-\t\t\tif sniff[i]&notSignedIntConst != 0 {\n-\t\t\t\tn.Kind = \"uconst\"\n-\t\t\t} else {\n-\t\t\t\tn.Kind = \"iconst\"\n-\t\t\t}\n+\t\t\tn.Kind = \"iconst\"\n \t\tcase notIntConst | notStrLiteral | notType:\n \t\t\tn.Kind = \"fconst\"\n \t\tcase notIntConst | notNumConst | notType:\n@@ -510,12 +467,12 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t// for each entry in names and then dereference the type we\n \t// learn for __cgo__i.\n \tvar b bytes.Buffer\n-\tb.WriteString(f.Preamble)\n \tb.WriteString(builtinProlog)\n+\tb.WriteString(f.Preamble)\n \tb.WriteString(\"#line 1 \\\"cgo-dwarf-inference\\\"\\n\")\n \tfor i, n := range names {\n \t\tfmt.Fprintf(&b, \"__typeof__(%s) *__cgo__%d;\\n\", n.C, i)\n-\t\tif n.Kind == \"iconst\" || n.Kind == \"uconst\" {\n+\t\tif n.Kind == \"iconst\" {\n \t\t\tfmt.Fprintf(&b, \"enum { __cgo_enum__%d = %s };\\n\", i, n.C)\n \t\t}\n \t}\n@@ -524,7 +481,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t// so we can read them out of the object file.\n \tfmt.Fprintf(&b, \"long long __cgodebug_ints[] = {\\n\")\n \tfor _, n := range names {\n-\t\tif n.Kind == \"iconst\" || n.Kind == \"uconst\" {\n+\t\tif n.Kind == \"iconst\" {\n \t\t\tfmt.Fprintf(&b, \"\\t%s,\\n\", n.C)\n \t\t} else {\n \t\t\tfmt.Fprintf(&b, \"\\t0,\\n\")\n@@ -562,14 +519,6 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \n \t// Scan DWARF info for top-level TagVariable entries with AttrName __cgo__i.\n \ttypes := make([]dwarf.Type, len(names))\n-\tnameToIndex := make(map[*Name]int)\n-\tfor i, n := range names {\n-\t\tnameToIndex[n] = i\n-\t}\n-\tnameToRef := make(map[*Name]*Ref)\n-\tfor _, ref := range f.Ref {\n-\t\tnameToRef[ref.Name] = ref\n-\t}\n \tr := d.Reader()\n \tfor {\n \t\te, err := r.Next()\n@@ -620,10 +569,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\tif types[i] == nil {\n \t\t\tcontinue\n \t\t}\n-\t\tpos := token.NoPos\n-\t\tif ref, ok := nameToRef[n]; ok {\n-\t\t\tpos = ref.Pos()\n-\t\t}\n+\t\tpos := f.NamePos[n]\n \t\tf, fok := types[i].(*dwarf.FuncType)\n \t\tif n.Kind != \"type\" && fok {\n \t\t\tn.Kind = \"func\"\n@@ -633,11 +579,11 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\tswitch n.Kind {\n \t\t\tcase \"iconst\":\n \t\t\t\tif i < len(ints) {\n-\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", ints[i])\n-\t\t\t\t}\n-\t\t\tcase \"uconst\":\n-\t\t\t\tif i < len(ints) {\n-\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", uint64(ints[i]))\n+\t\t\t\t\tif _, ok := types[i].(*dwarf.UintType); ok {\n+\t\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", uint64(ints[i]))\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", ints[i])\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\tcase \"fconst\":\n \t\t\t\tif i < len(floats) {\n@@ -778,8 +724,9 @@ func (p *Package) rewriteCall(f *File, call *Call, name *Name) bool {\n \t\tstmts = append(stmts, stmt)\n \t}\n \n+\tconst cgoMarker = \"__cgo__###__marker__\"\n \tfcall := &ast.CallExpr{\n-\t\tFun:  call.Call.Fun,\n+\t\tFun:  ast.NewIdent(cgoMarker),\n \t\tArgs: nargs,\n \t}\n \tftype := &ast.FuncType{\n@@ -801,31 +748,26 @@ func (p *Package) rewriteCall(f *File, call *Call, name *Name) bool {\n \t\t}\n \t}\n \n-\t// There is a Ref pointing to the old call.Call.Fun.\n+\t// If this call expects two results, we have to\n+\t// adjust the results of the function we generated.\n \tfor _, ref := range f.Ref {\n-\t\tif ref.Expr == &call.Call.Fun {\n-\t\t\tref.Expr = &fcall.Fun\n-\n-\t\t\t// If this call expects two results, we have to\n-\t\t\t// adjust the results of the function we generated.\n-\t\t\tif ref.Context == \"call2\" {\n-\t\t\t\tif ftype.Results == nil {\n-\t\t\t\t\t// An explicit void argument\n-\t\t\t\t\t// looks odd but it seems to\n-\t\t\t\t\t// be how cgo has worked historically.\n-\t\t\t\t\tftype.Results = &ast.FieldList{\n-\t\t\t\t\t\tList: []*ast.Field{\n-\t\t\t\t\t\t\t&ast.Field{\n-\t\t\t\t\t\t\t\tType: ast.NewIdent(\"_Ctype_void\"),\n-\t\t\t\t\t\t\t},\n+\t\tif ref.Expr == &call.Call.Fun && ref.Context == ctxCall2 {\n+\t\t\tif ftype.Results == nil {\n+\t\t\t\t// An explicit void argument\n+\t\t\t\t// looks odd but it seems to\n+\t\t\t\t// be how cgo has worked historically.\n+\t\t\t\tftype.Results = &ast.FieldList{\n+\t\t\t\t\tList: []*ast.Field{\n+\t\t\t\t\t\t&ast.Field{\n+\t\t\t\t\t\t\tType: ast.NewIdent(\"_Ctype_void\"),\n \t\t\t\t\t\t},\n-\t\t\t\t\t}\n+\t\t\t\t\t},\n \t\t\t\t}\n-\t\t\t\tftype.Results.List = append(ftype.Results.List,\n-\t\t\t\t\t&ast.Field{\n-\t\t\t\t\t\tType: ast.NewIdent(\"error\"),\n-\t\t\t\t\t})\n \t\t\t}\n+\t\t\tftype.Results.List = append(ftype.Results.List,\n+\t\t\t\t&ast.Field{\n+\t\t\t\t\tType: ast.NewIdent(\"error\"),\n+\t\t\t\t})\n \t\t}\n \t}\n \n@@ -839,14 +781,16 @@ func (p *Package) rewriteCall(f *File, call *Call, name *Name) bool {\n \t\t\tResults: []ast.Expr{fcall},\n \t\t}\n \t}\n-\tcall.Call.Fun = &ast.FuncLit{\n+\tlit := &ast.FuncLit{\n \t\tType: ftype,\n \t\tBody: &ast.BlockStmt{\n \t\t\tList: append(stmts, fbody),\n \t\t},\n \t}\n-\tcall.Call.Lparen = token.NoPos\n-\tcall.Call.Rparen = token.NoPos\n+\ttext := strings.Replace(gofmt(lit), \"\\n\", \";\", -1)\n+\trepl := strings.Split(text, cgoMarker)\n+\tf.Edit.Insert(f.offset(call.Call.Fun.Pos()), repl[0])\n+\tf.Edit.Insert(f.offset(call.Call.Fun.End()), repl[1])\n \n \treturn needsUnsafe\n }\n@@ -1000,8 +944,8 @@ func (p *Package) checkAddrArgs(f *File, args []ast.Expr, x ast.Expr) []ast.Expr\n // effect is a function call.\n func (p *Package) hasSideEffects(f *File, x ast.Expr) bool {\n \tfound := false\n-\tf.walk(x, \"expr\",\n-\t\tfunc(f *File, x interface{}, context string) {\n+\tf.walk(x, ctxExpr,\n+\t\tfunc(f *File, x interface{}, context astContext) {\n \t\t\tswitch x.(type) {\n \t\t\tcase *ast.CallExpr:\n \t\t\t\tfound = true\n@@ -1110,7 +1054,17 @@ func (p *Package) rewriteRef(f *File) {\n \t// Assign mangled names.\n \tfor _, n := range f.Name {\n \t\tif n.Kind == \"not-type\" {\n-\t\t\tn.Kind = \"var\"\n+\t\t\tif n.Define == \"\" {\n+\t\t\t\tn.Kind = \"var\"\n+\t\t\t} else {\n+\t\t\t\tn.Kind = \"macro\"\n+\t\t\t\tn.FuncType = &FuncType{\n+\t\t\t\t\tResult: n.Type,\n+\t\t\t\t\tGo: &ast.FuncType{\n+\t\t\t\t\t\tResults: &ast.FieldList{List: []*ast.Field{{Type: n.Type.Go}}},\n+\t\t\t\t\t},\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tif n.Mangle == \"\" {\n \t\t\tp.mangleName(n)\n@@ -1130,10 +1084,10 @@ func (p *Package) rewriteRef(f *File) {\n \t\t}\n \t\tvar expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default\n \t\tswitch r.Context {\n-\t\tcase \"call\", \"call2\":\n+\t\tcase ctxCall, ctxCall2:\n \t\t\tif r.Name.Kind != \"func\" {\n \t\t\t\tif r.Name.Kind == \"type\" {\n-\t\t\t\t\tr.Context = \"type\"\n+\t\t\t\t\tr.Context = ctxType\n \t\t\t\t\tif r.Name.Type == nil {\n \t\t\t\t\t\terror_(r.Pos(), \"invalid conversion to C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n \t\t\t\t\t\tbreak\n@@ -1145,7 +1099,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tfunctions[r.Name.Go] = true\n-\t\t\tif r.Context == \"call2\" {\n+\t\t\tif r.Context == ctxCall2 {\n \t\t\t\tif r.Name.Go == \"_CMalloc\" {\n \t\t\t\t\terror_(r.Pos(), \"no two-result form for C.malloc\")\n \t\t\t\t\tbreak\n@@ -1163,8 +1117,9 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\tr.Name = n\n \t\t\t\tbreak\n \t\t\t}\n-\t\tcase \"expr\":\n-\t\t\tif r.Name.Kind == \"func\" {\n+\t\tcase ctxExpr:\n+\t\t\tswitch r.Name.Kind {\n+\t\t\tcase \"func\":\n \t\t\t\tif builtinDefs[r.Name.C] != \"\" {\n \t\t\t\t\terror_(r.Pos(), \"use of builtin '%s' not in function call\", fixGo(r.Name.C))\n \t\t\t\t}\n@@ -1191,25 +1146,25 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\t\tFun:  &ast.Ident{NamePos: (*r.Expr).Pos(), Name: \"_Cgo_ptr\"},\n \t\t\t\t\tArgs: []ast.Expr{ast.NewIdent(name.Mangle)},\n \t\t\t\t}\n-\t\t\t} else if r.Name.Kind == \"type\" {\n+\t\t\tcase \"type\":\n \t\t\t\t// Okay - might be new(T)\n \t\t\t\tif r.Name.Type == nil {\n \t\t\t\t\terror_(r.Pos(), \"expression C.%s: undefined C type '%s'\", fixGo(r.Name.Go), r.Name.C)\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\texpr = r.Name.Type.Go\n-\t\t\t} else if r.Name.Kind == \"var\" {\n+\t\t\tcase \"var\":\n \t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n+\t\t\tcase \"macro\":\n+\t\t\t\texpr = &ast.CallExpr{Fun: expr}\n \t\t\t}\n-\n-\t\tcase \"selector\":\n+\t\tcase ctxSelector:\n \t\t\tif r.Name.Kind == \"var\" {\n \t\t\t\texpr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}\n \t\t\t} else {\n \t\t\t\terror_(r.Pos(), \"only C variables allowed in selector expression %s\", fixGo(r.Name.Go))\n \t\t\t}\n-\n-\t\tcase \"type\":\n+\t\tcase ctxType:\n \t\t\tif r.Name.Kind != \"type\" {\n \t\t\t\terror_(r.Pos(), \"expression C.%s used as type\", fixGo(r.Name.Go))\n \t\t\t} else if r.Name.Type == nil {\n@@ -1224,6 +1179,7 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t\terror_(r.Pos(), \"must call C.%s\", fixGo(r.Name.Go))\n \t\t\t}\n \t\t}\n+\n \t\tif *godefs {\n \t\t\t// Substitute definition for mangled type name.\n \t\t\tif id, ok := expr.(*ast.Ident); ok {\n@@ -1245,7 +1201,17 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\texpr = &ast.Ident{NamePos: pos, Name: x.Name}\n \t\t}\n \n+\t\t// Change AST, because some later processing depends on it,\n+\t\t// and also because -godefs mode still prints the AST.\n+\t\told := *r.Expr\n \t\t*r.Expr = expr\n+\n+\t\t// Record source-level edit for cgo output.\n+\t\trepl := gofmt(expr)\n+\t\tif r.Name.Kind != \"type\" {\n+\t\t\trepl = \"(\" + repl + \")\"\n+\t\t}\n+\t\tf.Edit.Replace(f.offset(old.Pos()), f.offset(old.End()), repl)\n \t}\n \n \t// Remove functions only used as expressions, so their respective\n@@ -1270,7 +1236,7 @@ func (p *Package) gccBaseCmd() []string {\n \tif ret := strings.Fields(os.Getenv(\"GCC\")); len(ret) > 0 {\n \t\treturn ret\n \t}\n-\treturn strings.Fields(defaultCC)\n+\treturn strings.Fields(defaultCC(goos, goarch))\n }\n \n // gccMachine returns the gcc -m flag to use, either \"-m32\", \"-m64\" or \"-marm\".\n@@ -2186,6 +2152,12 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tname := c.Ident(\"_Ctype_\" + dt.Name)\n \t\tgoIdent[name.Name] = name\n \t\tsub := c.Type(dt.Type, pos)\n+\t\tif badPointerTypedef(dt.Name) {\n+\t\t\t// Treat this typedef as a uintptr.\n+\t\t\ts := *sub\n+\t\t\ts.Go = c.uintptr\n+\t\t\tsub = &s\n+\t\t}\n \t\tt.Go = name\n \t\tif unionWithPointer[sub.Go] {\n \t\t\tunionWithPointer[t.Go] = true\n@@ -2266,7 +2238,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\tif ss, ok := dwarfToName[s]; ok {\n \t\t\t\ts = ss\n \t\t\t}\n-\t\t\ts = strings.Join(strings.Split(s, \" \"), \"\") // strip spaces\n+\t\t\ts = strings.Replace(s, \" \", \"\", -1)\n \t\t\tname := c.Ident(\"_Ctype_\" + s)\n \t\t\ttt := *t\n \t\t\ttypedef[name.Name] = &tt\n@@ -2344,6 +2316,17 @@ func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\tif _, void := base(ptr.Type).(*dwarf.VoidType); void {\n \t\t\t\tbreak\n \t\t\t}\n+\t\t\t// ...or the typedef is one in which we expect bad pointers.\n+\t\t\t// It will be a uintptr instead of *X.\n+\t\t\tif badPointerTypedef(dt.Name) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\t// If we already know the typedef for t just use that.\n+\t\t\t// See issue 19832.\n+\t\t\tif def := typedef[t.Go.(*ast.Ident).Name]; def != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n \n \t\t\tt = c.Type(ptr, pos)\n \t\t\tif t == nil {\n@@ -2500,7 +2483,9 @@ func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.Struct\n \t\tsize := t.Size\n \t\ttalign := t.Align\n \t\tif f.BitSize > 0 {\n-\t\t\tif f.BitSize%8 != 0 {\n+\t\t\tswitch f.BitSize {\n+\t\t\tcase 8, 16, 32, 64:\n+\t\t\tdefault:\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tsize = f.BitSize / 8\n@@ -2676,3 +2661,51 @@ func fieldPrefix(fld []*ast.Field) string {\n \t}\n \treturn prefix\n }\n+\n+// badPointerTypedef reports whether t is a C typedef that should not be considered a pointer in Go.\n+// A typedef is bad if C code sometimes stores non-pointers in this type.\n+// TODO: Currently our best solution is to find these manually and list them as\n+// they come up. A better solution is desired.\n+func badPointerTypedef(t string) bool {\n+\t// The real bad types are CFNumberRef and CFTypeRef.\n+\t// Sometimes non-pointers are stored in these types.\n+\t// CFTypeRef is a supertype of those, so it can have bad pointers in it as well.\n+\t// We return true for the other CF*Ref types just so casting between them is easier.\n+\t// See comment below for details about the bad pointers.\n+\treturn goos == \"darwin\" && strings.HasPrefix(t, \"CF\") && strings.HasSuffix(t, \"Ref\")\n+}\n+\n+// Comment from Darwin's CFInternal.h\n+/*\n+// Tagged pointer support\n+// Low-bit set means tagged object, next 3 bits (currently)\n+// define the tagged object class, next 4 bits are for type\n+// information for the specific tagged object class.  Thus,\n+// the low byte is for type info, and the rest of a pointer\n+// (32 or 64-bit) is for payload, whatever the tagged class.\n+//\n+// Note that the specific integers used to identify the\n+// specific tagged classes can and will change from release\n+// to release (that's why this stuff is in CF*Internal*.h),\n+// as can the definition of type info vs payload above.\n+//\n+#if __LP64__\n+#define CF_IS_TAGGED_OBJ(PTR)\t((uintptr_t)(PTR) & 0x1)\n+#define CF_TAGGED_OBJ_TYPE(PTR)\t((uintptr_t)(PTR) & 0xF)\n+#else\n+#define CF_IS_TAGGED_OBJ(PTR)\t0\n+#define CF_TAGGED_OBJ_TYPE(PTR)\t0\n+#endif\n+\n+enum {\n+    kCFTaggedObjectID_Invalid = 0,\n+    kCFTaggedObjectID_Atom = (0 << 1) + 1,\n+    kCFTaggedObjectID_Undefined3 = (1 << 1) + 1,\n+    kCFTaggedObjectID_Undefined2 = (2 << 1) + 1,\n+    kCFTaggedObjectID_Integer = (3 << 1) + 1,\n+    kCFTaggedObjectID_DateTS = (4 << 1) + 1,\n+    kCFTaggedObjectID_ManagedObjectID = (5 << 1) + 1, // Core Data\n+    kCFTaggedObjectID_Date = (6 << 1) + 1,\n+    kCFTaggedObjectID_Undefined7 = (7 << 1) + 1,\n+};\n+*/"}, {"sha": "7e522a35f9983f7f2ec7364a229666b726a84ec5", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -24,6 +24,9 @@ import (\n \t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n+\n+\t\"cmd/internal/edit\"\n+\t\"cmd/internal/objabi\"\n )\n \n // A Package collects information about the package we're going to write.\n@@ -54,6 +57,12 @@ type File struct {\n \tCalls    []*Call             // all calls to C.xxx in AST\n \tExpFunc  []*ExpFunc          // exported functions for this file\n \tName     map[string]*Name    // map from Go name to Name\n+\tNamePos  map[*Name]token.Pos // map from Name to position of the first reference\n+\tEdit     *edit.Buffer\n+}\n+\n+func (f *File) offset(p token.Pos) int {\n+\treturn fset.Position(p).Offset\n }\n \n func nameKeys(m map[string]*Name) []string {\n@@ -75,7 +84,7 @@ type Call struct {\n type Ref struct {\n \tName    *Name\n \tExpr    *ast.Expr\n-\tContext string // \"type\", \"expr\", \"call\", or \"call2\"\n+\tContext astContext\n }\n \n func (r *Ref) Pos() token.Pos {\n@@ -88,7 +97,7 @@ type Name struct {\n \tMangle   string // name used in generated Go\n \tC        string // name used in C\n \tDefine   string // #define expansion\n-\tKind     string // \"iconst\", \"uconst\", \"fconst\", \"sconst\", \"type\", \"var\", \"fpvar\", \"func\", \"not-type\"\n+\tKind     string // \"iconst\", \"fconst\", \"sconst\", \"type\", \"var\", \"fpvar\", \"func\", \"macro\", \"not-type\"\n \tType     *Type  // the type of xxx\n \tFuncType *FuncType\n \tAddError bool\n@@ -100,12 +109,12 @@ func (n *Name) IsVar() bool {\n \treturn n.Kind == \"var\" || n.Kind == \"fpvar\"\n }\n \n-// IsConst reports whether Kind is either \"iconst\", \"uconst\", \"fconst\" or \"sconst\"\n+// IsConst reports whether Kind is either \"iconst\", \"fconst\" or \"sconst\"\n func (n *Name) IsConst() bool {\n \treturn strings.HasSuffix(n.Kind, \"const\")\n }\n \n-// A ExpFunc is an exported function, callable from C.\n+// An ExpFunc is an exported function, callable from C.\n // Such functions are identified in the Go input file\n // by doc comments containing the line //export ExpName\n type ExpFunc struct {\n@@ -214,6 +223,7 @@ var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generat\n var goarch, goos string\n \n func main() {\n+\tobjabi.AddVersionFlag() // -V\n \tflag.Usage = usage\n \tflag.Parse()\n \n@@ -294,6 +304,7 @@ func main() {\n \t\t}\n \n \t\tf := new(File)\n+\t\tf.Edit = edit.NewBuffer(b)\n \t\tf.ParseGo(input, b)\n \t\tf.DiscardCgoDirectives()\n \t\tfs[i] = f\n@@ -314,11 +325,13 @@ func main() {\n \t\tp.Translate(f)\n \t\tfor _, cref := range f.Ref {\n \t\t\tswitch cref.Context {\n-\t\t\tcase \"call\", \"call2\":\n+\t\t\tcase ctxCall, ctxCall2:\n \t\t\t\tif cref.Name.Kind != \"type\" {\n \t\t\t\t\tbreak\n \t\t\t\t}\n+\t\t\t\told := *cref.Expr\n \t\t\t\t*cref.Expr = cref.Name.Type.Go\n+\t\t\t\tf.Edit.Replace(f.offset(old.Pos()), f.offset(old.End()), gofmt(cref.Name.Type.Go))\n \t\t\t}\n \t\t}\n \t\tif nerrors > 0 {"}, {"sha": "81eff779a806bf6fe1994ec632476efcf8aa10a1", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 77, "deletions": 27, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"go/token\"\n \t\"io\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n )\n@@ -116,7 +117,13 @@ func (p *Package) writeDefs() {\n \t\t// Which is not useful. Moreover we never override source info,\n \t\t// so subsequent source code uses the same source info.\n \t\t// Moreover, empty file name makes compile emit no source debug info at all.\n-\t\tnoSourceConf.Fprint(fgo2, fset, def.Go)\n+\t\tvar buf bytes.Buffer\n+\t\tnoSourceConf.Fprint(&buf, fset, def.Go)\n+\t\tif bytes.HasPrefix(buf.Bytes(), []byte(\"_Ctype_\")) {\n+\t\t\t// This typedef is of the form `typedef a b` and should be an alias.\n+\t\t\tfmt.Fprintf(fgo2, \"= \")\n+\t\t}\n+\t\tfmt.Fprintf(fgo2, \"%s\", buf.Bytes())\n \t\tfmt.Fprintf(fgo2, \"\\n\\n\")\n \t}\n \tif *gccgo {\n@@ -424,10 +431,12 @@ func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name, callsMalloc *bool) {\n \tinProlog := builtinDefs[name] != \"\"\n \tcname := fmt.Sprintf(\"_cgo%s%s\", cPrefix, n.Mangle)\n \tparamnames := []string(nil)\n-\tfor i, param := range d.Type.Params.List {\n-\t\tparamName := fmt.Sprintf(\"p%d\", i)\n-\t\tparam.Names = []*ast.Ident{ast.NewIdent(paramName)}\n-\t\tparamnames = append(paramnames, paramName)\n+\tif d.Type.Params != nil {\n+\t\tfor i, param := range d.Type.Params.List {\n+\t\t\tparamName := fmt.Sprintf(\"p%d\", i)\n+\t\t\tparam.Names = []*ast.Ident{ast.NewIdent(paramName)}\n+\t\t\tparamnames = append(paramnames, paramName)\n+\t\t}\n \t}\n \n \tif *gccgo {\n@@ -526,8 +535,10 @@ func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name, callsMalloc *bool) {\n \t\tfmt.Fprintf(fgo2, \"\\tif errno != 0 { r2 = syscall.Errno(errno) }\\n\")\n \t}\n \tfmt.Fprintf(fgo2, \"\\tif _Cgo_always_false {\\n\")\n-\tfor i := range d.Type.Params.List {\n-\t\tfmt.Fprintf(fgo2, \"\\t\\t_Cgo_use(p%d)\\n\", i)\n+\tif d.Type.Params != nil {\n+\t\tfor i := range d.Type.Params.List {\n+\t\t\tfmt.Fprintf(fgo2, \"\\t\\t_Cgo_use(p%d)\\n\", i)\n+\t\t}\n \t}\n \tfmt.Fprintf(fgo2, \"\\t}\\n\")\n \tfmt.Fprintf(fgo2, \"\\treturn\\n\")\n@@ -540,7 +551,7 @@ func (p *Package) writeOutput(f *File, srcfile string) {\n \tif strings.HasSuffix(base, \".go\") {\n \t\tbase = base[0 : len(base)-3]\n \t}\n-\tbase = strings.Map(slashToUnderscore, base)\n+\tbase = filepath.Base(base)\n \tfgo1 := creat(*objDir + base + \".cgo1.go\")\n \tfgcc := creat(*objDir + base + \".cgo2.c\")\n \n@@ -549,10 +560,12 @@ func (p *Package) writeOutput(f *File, srcfile string) {\n \n \t// Write Go output: Go input with rewrites of C.xxx to _C_xxx.\n \tfmt.Fprintf(fgo1, \"// Created by cgo - DO NOT EDIT\\n\\n\")\n-\tconf.Fprint(fgo1, fset, f.AST)\n+\tfmt.Fprintf(fgo1, \"//line %s:1\\n\", srcfile)\n+\tfgo1.Write(f.Edit.Bytes())\n \n \t// While we process the vars and funcs, also write gcc output.\n \t// Gcc output starts with the preamble.\n+\tfmt.Fprintf(fgcc, \"%s\\n\", builtinProlog)\n \tfmt.Fprintf(fgcc, \"%s\\n\", f.Preamble)\n \tfmt.Fprintf(fgcc, \"%s\\n\", gccProlog)\n \tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n@@ -639,14 +652,18 @@ func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {\n \t\t\tfmt.Fprint(fgcc, \"(__typeof__(a->r)) \")\n \t\t}\n \t}\n-\tfmt.Fprintf(fgcc, \"%s(\", n.C)\n-\tfor i := range n.FuncType.Params {\n-\t\tif i > 0 {\n-\t\t\tfmt.Fprintf(fgcc, \", \")\n+\tif n.Kind == \"macro\" {\n+\t\tfmt.Fprintf(fgcc, \"%s;\\n\", n.C)\n+\t} else {\n+\t\tfmt.Fprintf(fgcc, \"%s(\", n.C)\n+\t\tfor i := range n.FuncType.Params {\n+\t\t\tif i > 0 {\n+\t\t\t\tfmt.Fprintf(fgcc, \", \")\n+\t\t\t}\n+\t\t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n \t\t}\n-\t\tfmt.Fprintf(fgcc, \"a->p%d\", i)\n+\t\tfmt.Fprintf(fgcc, \");\\n\")\n \t}\n-\tfmt.Fprintf(fgcc, \");\\n\")\n \tif n.AddError {\n \t\tfmt.Fprintf(fgcc, \"\\t_cgo_errno = errno;\\n\")\n \t}\n@@ -702,14 +719,18 @@ func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {\n \t\t\tfmt.Fprintf(fgcc, \"(void*)\")\n \t\t}\n \t}\n-\tfmt.Fprintf(fgcc, \"%s(\", n.C)\n-\tfor i := range n.FuncType.Params {\n-\t\tif i > 0 {\n-\t\t\tfmt.Fprintf(fgcc, \", \")\n+\tif n.Kind == \"macro\" {\n+\t\tfmt.Fprintf(fgcc, \"%s;\\n\", n.C)\n+\t} else {\n+\t\tfmt.Fprintf(fgcc, \"%s(\", n.C)\n+\t\tfor i := range n.FuncType.Params {\n+\t\t\tif i > 0 {\n+\t\t\t\tfmt.Fprintf(fgcc, \", \")\n+\t\t\t}\n+\t\t\tfmt.Fprintf(fgcc, \"p%d\", i)\n \t\t}\n-\t\tfmt.Fprintf(fgcc, \"p%d\", i)\n+\t\tfmt.Fprintf(fgcc, \");\\n\")\n \t}\n-\tfmt.Fprintf(fgcc, \");\\n\")\n \tfmt.Fprintf(fgcc, \"\\t_cgo_tsan_release();\\n\")\n \tif t := n.FuncType.Result; t != nil {\n \t\tfmt.Fprintf(fgcc, \"\\treturn \")\n@@ -1009,7 +1030,7 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\tdefault:\n \t\t\t// Declare a result struct.\n \t\t\tfmt.Fprintf(fgcch, \"\\n/* Return type for %s */\\n\", exp.ExpName)\n-\t\t\tfmt.Fprintf(fgcch, \"struct %s_result {\\n\", exp.ExpName)\n+\t\t\tfmt.Fprintf(fgcch, \"struct %s_return {\\n\", exp.ExpName)\n \t\t\tforFieldList(fntype.Results,\n \t\t\t\tfunc(i int, aname string, atype ast.Expr) {\n \t\t\t\t\tt := p.cgoType(atype)\n@@ -1020,7 +1041,7 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t\t\t\tfmt.Fprint(fgcch, \"\\n\")\n \t\t\t\t})\n \t\t\tfmt.Fprintf(fgcch, \"};\\n\")\n-\t\t\tfmt.Fprintf(cdeclBuf, \"struct %s_result\", exp.ExpName)\n+\t\t\tfmt.Fprintf(cdeclBuf, \"struct %s_return\", exp.ExpName)\n \t\t}\n \n \t\tcRet := cdeclBuf.String()\n@@ -1046,7 +1067,7 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t\tfmt.Fprintf(fgcch, \"\\n%s\", exp.Doc)\n \t\t}\n \n-\t\tfmt.Fprintf(fgcch, \"extern %s %s %s;\\n\", cRet, exp.ExpName, cParams)\n+\t\tfmt.Fprintf(fgcch, \"extern %s %s%s;\\n\", cRet, exp.ExpName, cParams)\n \n \t\t// We need to use a name that will be exported by the\n \t\t// Go code; otherwise gccgo will make it static and we\n@@ -1155,6 +1176,7 @@ func (p *Package) writeExportHeader(fgcch io.Writer) {\n \t\tpkg = p.PackagePath\n \t}\n \tfmt.Fprintf(fgcch, \"/* package %s */\\n\\n\", pkg)\n+\tfmt.Fprintf(fgcch, \"%s\\n\", builtinExportProlog)\n \n \tfmt.Fprintf(fgcch, \"/* Start of preamble from import \\\"C\\\" comments.  */\\n\\n\")\n \tfmt.Fprintf(fgcch, \"%s\\n\", p.Preamble)\n@@ -1247,8 +1269,9 @@ func (p *Package) cgoType(e ast.Expr) *Type {\n \t\t\t// Slice: pointer, len, cap.\n \t\t\treturn &Type{Size: p.PtrSize * 3, Align: p.PtrSize, C: c(\"GoSlice\")}\n \t\t}\n+\t\t// Non-slice array types are not supported.\n \tcase *ast.StructType:\n-\t\t// TODO\n+\t\t// Not supported.\n \tcase *ast.FuncType:\n \t\treturn &Type{Size: p.PtrSize, Align: p.PtrSize, C: c(\"void*\")}\n \tcase *ast.InterfaceType:\n@@ -1398,14 +1421,20 @@ const builtinProlog = `\n /* Define intgo when compiling with GCC.  */\n typedef ptrdiff_t intgo;\n \n-typedef struct { char *p; intgo n; } _GoString_;\n+typedef struct { const char *p; intgo n; } _GoString_;\n typedef struct { char *p; intgo n; intgo c; } _GoBytes_;\n _GoString_ GoString(char *p);\n _GoString_ GoStringN(char *p, int l);\n _GoBytes_ GoBytes(void *p, int n);\n char *CString(_GoString_);\n void *CBytes(_GoBytes_);\n void *_CMalloc(size_t);\n+\n+__attribute__ ((unused))\n+static size_t _GoStringLen(_GoString_ s) { return s.n; }\n+\n+__attribute__ ((unused))\n+static const char *_GoStringPtr(_GoString_ s) { return s.p; }\n `\n \n const goProlog = `\n@@ -1637,6 +1666,27 @@ void localCgoCheckResult(Eface val) {\n }\n `\n \n+// builtinExportProlog is a shorter version of builtinProlog,\n+// to be put into the _cgo_export.h file.\n+// For historical reasons we can't use builtinProlog in _cgo_export.h,\n+// because _cgo_export.h defines GoString as a struct while builtinProlog\n+// defines it as a function. We don't change this to avoid unnecessarily\n+// breaking existing code.\n+const builtinExportProlog = `\n+#line 1 \"cgo-builtin-prolog\"\n+\n+#include <stddef.h> /* for ptrdiff_t below */\n+\n+#ifndef GO_CGO_EXPORT_PROLOGUE_H\n+#define GO_CGO_EXPORT_PROLOGUE_H\n+\n+typedef ptrdiff_t intgo;\n+\n+typedef struct { const char *p; intgo n; } _GoString_;\n+\n+#endif\n+`\n+\n func (p *Package) gccExportHeaderProlog() string {\n \treturn strings.Replace(gccExportHeaderProlog, \"GOINTBITS\", fmt.Sprint(8*p.IntSize), -1)\n }\n@@ -1670,7 +1720,7 @@ typedef double _Complex GoComplex128;\n */\n typedef char _check_for_GOINTBITS_bit_pointer_matching_GoInt[sizeof(void*)==GOINTBITS/8 ? 1:-1];\n \n-typedef struct { const char *p; GoInt n; } GoString;\n+typedef _GoString_ GoString;\n typedef void *GoMap;\n typedef void *GoChan;\n typedef struct { void *t; void *v; } GoInterface;"}, {"sha": "8b310d46c926fa75bcb0a758c50d83e01d194972", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 115, "deletions": 32, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -14,12 +14,12 @@\n // The commands are:\n //\n // \tbuild       compile packages and dependencies\n-// \tclean       remove object files\n+// \tclean       remove object files and cached files\n // \tdoc         show documentation for package or symbol\n // \tenv         print Go environment information\n // \tbug         start a bug report\n-// \tfix         run go tool fix on packages\n-// \tfmt         run gofmt on package sources\n+// \tfix         update packages to use new APIs\n+// \tfmt         gofmt (reformat) package sources\n // \tgenerate    generate Go files by processing source\n // \tget         download and install packages and dependencies\n // \tinstall     compile and install packages and dependencies\n@@ -28,7 +28,7 @@\n // \ttest        test packages\n // \ttool        run specified go tool\n // \tversion     print Go version\n-// \tvet         run go tool vet on packages\n+// \tvet         report likely mistakes in packages\n //\n // Use \"go help [command]\" for more information about a command.\n //\n@@ -104,15 +104,15 @@\n // \t-x\n // \t\tprint the commands.\n //\n-// \t-asmflags 'flag list'\n+// \t-asmflags '[pattern=]arg list'\n // \t\targuments to pass on each go tool asm invocation.\n // \t-buildmode mode\n // \t\tbuild mode to use. See 'go help buildmode' for more.\n // \t-compiler name\n // \t\tname of compiler to use, as in runtime.Compiler (gccgo or gc).\n-// \t-gccgoflags 'arg list'\n+// \t-gccgoflags '[pattern=]arg list'\n // \t\targuments to pass on each gccgo compiler/linker invocation.\n-// \t-gcflags 'arg list'\n+// \t-gcflags '[pattern=]arg list'\n // \t\targuments to pass on each go tool compile invocation.\n // \t-installsuffix suffix\n // \t\ta suffix to use in the name of the package installation directory,\n@@ -121,7 +121,7 @@\n // \t\tor, if set explicitly, has _race appended to it. Likewise for the -msan\n // \t\tflag. Using a -buildmode option that requires non-default compile flags\n // \t\thas a similar effect.\n-// \t-ldflags 'flag list'\n+// \t-ldflags '[pattern=]arg list'\n // \t\targuments to pass on each go tool link invocation.\n // \t-linkshared\n // \t\tlink against shared libraries previously created with\n@@ -139,9 +139,21 @@\n // \t\tFor example, instead of running asm, the go command will run\n // \t\t'cmd args /path/to/asm <arguments for asm>'.\n //\n-// All the flags that take a list of arguments accept a space-separated\n-// list of strings. To embed spaces in an element in the list, surround\n-// it with either single or double quotes.\n+// The -asmflags, -gccgoflags, -gcflags, and -ldflags flags accept a\n+// space-separated list of arguments to pass to an underlying tool\n+// during the build. To embed spaces in an element in the list, surround\n+// it with either single or double quotes. The argument list may be\n+// preceded by a package pattern and an equal sign, which restricts\n+// the use of that argument list to the building of packages matching\n+// that pattern (see 'go help packages' for a description of package\n+// patterns). Without a pattern, the argument list applies only to the\n+// packages named on the command line. The flags may be repeated\n+// with different patterns in order to specify different arguments for\n+// different sets of packages. If a package matches patterns given in\n+// multiple flags, the latest match on the command line wins.\n+// For example, 'go build -gcflags=-S fmt' prints the disassembly\n+// only for package fmt, while 'go build -gcflags=all=-S fmt'\n+// prints the disassembly for fmt and all its dependencies.\n //\n // For more about specifying packages, see 'go help packages'.\n // For more about where packages and binaries are installed,\n@@ -158,11 +170,11 @@\n // See also: go install, go get, go clean.\n //\n //\n-// Remove object files\n+// Remove object files and cached files\n //\n // Usage:\n //\n-// \tgo clean [-i] [-r] [-n] [-x] [build flags] [packages]\n+// \tgo clean [-i] [-r] [-n] [-x] [-cache] [-testcache] [build flags] [packages]\n //\n // Clean removes object files from package source directories.\n // The go command builds most objects in a temporary directory,\n@@ -200,6 +212,11 @@\n //\n // The -x flag causes clean to print remove commands as it executes them.\n //\n+// The -cache flag causes clean to remove the entire go build cache.\n+//\n+// The -testcache flag causes clean to expire all test results in the\n+// go build cache.\n+//\n // For more about build flags, see 'go help build'.\n //\n // For more about specifying packages, see 'go help packages'.\n@@ -328,6 +345,8 @@\n // The -json flag prints the environment in JSON format\n // instead of as a shell script.\n //\n+// For more about environment variables, see 'go help environment'.\n+//\n //\n // Start a bug report\n //\n@@ -339,7 +358,7 @@\n // The report includes useful system information.\n //\n //\n-// Run go tool fix on packages\n+// Update packages to use new APIs\n //\n // Usage:\n //\n@@ -355,7 +374,7 @@\n // See also: go fmt, go vet.\n //\n //\n-// Run gofmt on package sources\n+// Gofmt (reformat) package sources\n //\n // Usage:\n //\n@@ -543,10 +562,11 @@\n //\n // Usage:\n //\n-// \tgo install [build flags] [packages]\n+// \tgo install [-i] [build flags] [packages]\n //\n-// Install compiles and installs the packages named by the import paths,\n-// along with their dependencies.\n+// Install compiles and installs the packages named by the import paths.\n+//\n+// The -i flag installs the dependencies of the named packages as well.\n //\n // For more about the build flags, see 'go help build'.\n // For more about specifying packages, see 'go help packages'.\n@@ -719,22 +739,57 @@\n //\n // 'Go test' recompiles each package along with any files with names matching\n // the file pattern \"*_test.go\".\n-// Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n // These additional files can contain test functions, benchmark functions, and\n // example functions. See 'go help testfunc' for more.\n // Each listed package causes the execution of a separate test binary.\n+// Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n //\n // Test files that declare a package with the suffix \"_test\" will be compiled as a\n // separate package, and then linked and run with the main test binary.\n //\n // The go tool will ignore a directory named \"testdata\", making it available\n // to hold ancillary data needed by the tests.\n //\n-// By default, go test needs no arguments. It compiles and tests the package\n-// with source in the current directory, including tests, and runs the tests.\n-//\n-// The package is built in a temporary directory so it does not interfere with the\n-// non-test installation.\n+// As part of building a test binary, go test runs go vet on the package\n+// and its test source files to identify significant problems. If go vet\n+// finds any problems, go test reports those and does not run the test binary.\n+// Only a high-confidence subset of the default go vet checks are used.\n+// To disable the running of go vet, use the -vet=off flag.\n+//\n+// Go test runs in two different modes: local directory mode when invoked with\n+// no package arguments (for example, 'go test'), and package list mode when\n+// invoked with package arguments (for example 'go test math', 'go test ./...',\n+// and even 'go test .').\n+//\n+// In local directory mode, go test compiles and tests the package sources\n+// found in the current directory and then runs the resulting test binary.\n+// In this mode, caching (discussed below) is disabled. After the package test\n+// finishes, go test prints a summary line showing the test status ('ok' or 'FAIL'),\n+// package name, and elapsed time.\n+//\n+// In package list mode, go test compiles and tests each of the packages\n+// listed on the command line. If a package test passes, go test prints only\n+// the final 'ok' summary line. If a package test fails, go test prints the\n+// full test output. If invoked with the -bench or -v flag, go test prints\n+// the full output even for passing package tests, in order to display the\n+// requested benchmark results or verbose logging.\n+//\n+// All test output and summary lines are printed to the go command's standard\n+// output, even if the test printed them to its own standard error.\n+// (The go command's standard error is reserved for printing errors building\n+// the tests.)\n+//\n+// In package list mode, go test also caches successful package test results.\n+// If go test has cached a previous test run using the same test binary and\n+// the same command line consisting entirely of cacheable test flags\n+// (defined as -cpu, -list, -parallel, -run, -short, and -v),\n+// go test will redisplay the previous output instead of running the test\n+// binary again. In the summary line, go test prints '(cached)' in place of\n+// the elapsed time. To disable test caching, use any test flag or argument\n+// other than the cacheable flags. The idiomatic way to disable test caching\n+// explicitly is to use -count=1. A cached result is treated as executing in\n+// no time at all, so a successful package test result will be cached and reused\n+// regardless of -timeout setting.\n //\n // In addition to the build flags, the flags handled by 'go test' itself are:\n //\n@@ -757,6 +812,10 @@\n // \t    Install packages that are dependencies of the test.\n // \t    Do not run the test.\n //\n+// \t-json\n+// \t    Convert test output to JSON suitable for automated processing.\n+// \t    See 'go doc test2json' for the encoding details.\n+//\n // \t-o file\n // \t    Compile the test binary to the named file.\n // \t    The test still runs (unless -c or -i is specified).\n@@ -782,7 +841,7 @@\n // The -n flag causes tool to print the command that would be\n // executed but not execute it.\n //\n-// For more about each tool command, see 'go tool command -h'.\n+// For more about each tool command, see 'go doc cmd/<command>'.\n //\n //\n // Print Go version\n@@ -794,7 +853,7 @@\n // Version prints the Go version, as reported by runtime.Version.\n //\n //\n-// Run go tool vet on packages\n+// Report likely mistakes in packages\n //\n // Usage:\n //\n@@ -808,7 +867,9 @@\n // The -n flag prints commands that would be executed.\n // The -x flag prints commands as they are executed.\n //\n-// For more about build flags, see 'go help build'.\n+// The build flags supported by go vet are those that control package resolution\n+// and execution, such as -n, -x, -v, -tags, and -toolexec.\n+// For more about these flags, see 'go help build'.\n //\n // See also: go fmt, go fix.\n //\n@@ -917,8 +978,10 @@\n // comment, indicating that the package sources are included\n // for documentation only and must not be used to build the\n // package binary. This enables distribution of Go packages in\n-// their compiled form alone. See the go/build package documentation\n-// for more details.\n+// their compiled form alone. Even binary-only packages require\n+// accurate import blocks listing required dependencies, so that\n+// those dependencies can be supplied when linking the resulting\n+// command.\n //\n //\n // GOPATH environment variable\n@@ -1096,6 +1159,12 @@\n // \t\tSee https://golang.org/doc/articles/race_detector.html.\n // \tGOROOT\n // \t\tThe root of the go tree.\n+// \tGOTMPDIR\n+// \t\tThe directory where the go command will write\n+// \t\ttemporary source files, packages, and binaries.\n+// \tGOCACHE\n+// \t\tThe directory where the go command will store\n+// \t\tcached information for reuse in future builds.\n //\n // Environment variables for use with cgo:\n //\n@@ -1130,6 +1199,9 @@\n // \tGO386\n // \t\tFor GOARCH=386, the floating point instruction set.\n // \t\tValid values are 387, sse2.\n+// \tGOMIPS\n+// \t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n+// \t\tValid values are hardfloat (default), softfloat.\n //\n // Special-purpose environment variables:\n //\n@@ -1460,17 +1532,20 @@\n // \t\t\tsignificantly more expensive.\n // \t    Sets -cover.\n //\n-// \t-coverpkg pkg1,pkg2,pkg3\n-// \t    Apply coverage analysis in each test to the given list of packages.\n+// \t-coverpkg pattern1,pattern2,pattern3\n+// \t    Apply coverage analysis in each test to packages matching the patterns.\n // \t    The default is for each test to analyze only the package being tested.\n-// \t    Packages are specified as import paths.\n+// \t    See 'go help packages' for a description of package patterns.\n // \t    Sets -cover.\n //\n // \t-cpu 1,2,4\n // \t    Specify a list of GOMAXPROCS values for which the tests or\n // \t    benchmarks should be executed. The default is the current value\n // \t    of GOMAXPROCS.\n //\n+// \t-failfast\n+// \t    Do not start new tests after the first test failure.\n+//\n // \t-list regexp\n // \t    List tests, benchmarks, or examples matching the regular expression.\n // \t    No tests, benchmarks or examples will be run. This will only\n@@ -1503,12 +1578,20 @@\n //\n // \t-timeout d\n // \t    If a test binary runs longer than duration d, panic.\n+// \t    If d is 0, the timeout is disabled.\n // \t    The default is 10 minutes (10m).\n //\n // \t-v\n // \t    Verbose output: log all tests as they are run. Also print all\n // \t    text from Log and Logf calls even if the test succeeds.\n //\n+// \t-vet list\n+// \t    Configure the invocation of \"go vet\" during \"go test\"\n+// \t    to use the comma-separated list of vet checks.\n+// \t    If list is empty, \"go test\" runs \"go vet\" with a curated list of\n+// \t    checks believed to be always worth addressing.\n+// \t    If list is \"off\", \"go test\" does not run \"go vet\" at all.\n+//\n // The following flags are also recognized by 'go test' and can be used to\n // profile the tests during execution:\n //"}, {"sha": "509bd0b50beeb9b3f79d1beada6a02b382d4742c", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 1167, "deletions": 142, "changes": 1309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -6,6 +6,8 @@ package main_test\n \n import (\n \t\"bytes\"\n+\t\"debug/elf\"\n+\t\"debug/macho\"\n \t\"fmt\"\n \t\"go/format\"\n \t\"internal/race\"\n@@ -27,6 +29,7 @@ var (\n \tcanRun  = true  // whether we can run go or ./testgo\n \tcanRace = false // whether we can run the race detector\n \tcanCgo  = false // whether we can use cgo\n+\tcanMSan = false // whether we can run the memory sanitizer\n \n \texeSuffix string // \".exe\" on Windows\n \n@@ -83,25 +86,61 @@ var testCC string\n // The TestMain function creates a go command for testing purposes and\n // deletes it after the tests have been run.\n func TestMain(m *testing.M) {\n+\tif os.Getenv(\"GO_GCFLAGS\") != \"\" {\n+\t\tfmt.Fprintf(os.Stderr, \"testing: warning: no tests to run\\n\") // magic string for cmd/go\n+\t\tfmt.Printf(\"cmd/go test is not compatible with $GO_GCFLAGS being set\\n\")\n+\t\tfmt.Printf(\"SKIP\\n\")\n+\t\treturn\n+\t}\n+\n \tif canRun {\n \t\targs := []string{\"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\" + exeSuffix}\n \t\tif race.Enabled {\n \t\t\targs = append(args, \"-race\")\n \t\t}\n-\t\tout, err := exec.Command(\"go\", args...).CombinedOutput()\n+\t\tgotool, err := testenv.GoTool()\n \t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"building testgo failed: %v\\n%s\", err, out)\n+\t\t\tfmt.Fprintln(os.Stderr, err)\n \t\t\tos.Exit(2)\n \t\t}\n \n-\t\tout, err = exec.Command(\"go\", \"env\", \"GOROOT\").CombinedOutput()\n+\t\tgoEnv := func(name string) string {\n+\t\t\tout, err := exec.Command(gotool, \"env\", name).CombinedOutput()\n+\t\t\tif err != nil {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"go env %s: %v\\n%s\", name, err, out)\n+\t\t\t\tos.Exit(2)\n+\t\t\t}\n+\t\t\treturn strings.TrimSpace(string(out))\n+\t\t}\n+\t\ttestGOROOT = goEnv(\"GOROOT\")\n+\n+\t\t// The whole GOROOT/pkg tree was installed using the GOHOSTOS/GOHOSTARCH\n+\t\t// toolchain (installed in GOROOT/pkg/tool/GOHOSTOS_GOHOSTARCH).\n+\t\t// The testgo.exe we are about to create will be built for GOOS/GOARCH,\n+\t\t// which means it will use the GOOS/GOARCH toolchain\n+\t\t// (installed in GOROOT/pkg/tool/GOOS_GOARCH).\n+\t\t// If these are not the same toolchain, then the entire standard library\n+\t\t// will look out of date (the compilers in those two different tool directories\n+\t\t// are built for different architectures and have different buid IDs),\n+\t\t// which will cause many tests to do unnecessary rebuilds and some\n+\t\t// tests to attempt to overwrite the installed standard library.\n+\t\t// Bail out entirely in this case.\n+\t\thostGOOS := goEnv(\"GOHOSTOS\")\n+\t\thostGOARCH := goEnv(\"GOHOSTARCH\")\n+\t\tif hostGOOS != runtime.GOOS || hostGOARCH != runtime.GOARCH {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: warning: no tests to run\\n\") // magic string for cmd/go\n+\t\t\tfmt.Printf(\"cmd/go test is not compatible with GOOS/GOARCH != GOHOSTOS/GOHOSTARCH (%s/%s != %s/%s)\\n\", runtime.GOOS, runtime.GOARCH, hostGOOS, hostGOARCH)\n+\t\t\tfmt.Printf(\"SKIP\\n\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\tout, err := exec.Command(gotool, args...).CombinedOutput()\n \t\tif err != nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"could not find testing GOROOT: %v\\n%s\", err, out)\n+\t\t\tfmt.Fprintf(os.Stderr, \"building testgo failed: %v\\n%s\", err, out)\n \t\t\tos.Exit(2)\n \t\t}\n-\t\ttestGOROOT = strings.TrimSpace(string(out))\n \n-\t\tout, err = exec.Command(\"go\", \"env\", \"CC\").CombinedOutput()\n+\t\tout, err = exec.Command(gotool, \"env\", \"CC\").CombinedOutput()\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"could not find testing CC: %v\\n%s\", err, out)\n \t\t\tos.Exit(2)\n@@ -118,14 +157,17 @@ func TestMain(m *testing.M) {\n \t\t\t}\n \t\t}\n \n+\t\t// As of Sept 2017, MSan is only supported on linux/amd64.\n+\t\t// https://github.com/google/sanitizers/wiki/MemorySanitizer#getting-memorysanitizer\n+\t\tcanMSan = canCgo && runtime.GOOS == \"linux\" && runtime.GOARCH == \"amd64\"\n+\n \t\tswitch runtime.GOOS {\n \t\tcase \"linux\", \"darwin\", \"freebsd\", \"windows\":\n \t\t\t// The race detector doesn't work on Alpine Linux:\n \t\t\t// golang.org/issue/14481\n \t\t\tcanRace = canCgo && runtime.GOARCH == \"amd64\" && !isAlpineLinux() && runtime.Compiler != \"gccgo\"\n \t\t}\n \t}\n-\n \t// Don't let these environment variables confuse the test.\n \tos.Unsetenv(\"GOBIN\")\n \tos.Unsetenv(\"GOPATH\")\n@@ -137,6 +179,9 @@ func TestMain(m *testing.M) {\n \t\tos.Setenv(\"CCACHE_DIR\", filepath.Join(home, \".ccache\"))\n \t}\n \tos.Setenv(\"HOME\", \"/test-go-home-does-not-exist\")\n+\tif os.Getenv(\"GOCACHE\") == \"\" {\n+\t\tos.Setenv(\"GOCACHE\", \"off\") // because $HOME is gone\n+\t}\n \n \tr := m.Run()\n \n@@ -182,31 +227,35 @@ func skipIfGccgo(t *testing.T, msg string) {\n \n // testgo sets up for a test that runs testgo.\n func testgo(t *testing.T) *testgoData {\n+\tt.Helper()\n \ttestenv.MustHaveGoBuild(t)\n \n \tif skipExternal {\n-\t\tt.Skip(\"skipping external tests on %s/%s\", runtime.GOOS, runtime.GOARCH)\n+\t\tt.Skipf(\"skipping external tests on %s/%s\", runtime.GOOS, runtime.GOARCH)\n \t}\n \n \treturn &testgoData{t: t}\n }\n \n // must gives a fatal error if err is not nil.\n func (tg *testgoData) must(err error) {\n+\ttg.t.Helper()\n \tif err != nil {\n \t\ttg.t.Fatal(err)\n \t}\n }\n \n // check gives a test non-fatal error if err is not nil.\n func (tg *testgoData) check(err error) {\n+\ttg.t.Helper()\n \tif err != nil {\n \t\ttg.t.Error(err)\n \t}\n }\n \n // parallel runs the test in parallel by calling t.Parallel.\n func (tg *testgoData) parallel() {\n+\ttg.t.Helper()\n \tif tg.ran {\n \t\ttg.t.Fatal(\"internal testsuite error: call to parallel after run\")\n \t}\n@@ -227,6 +276,7 @@ func (tg *testgoData) parallel() {\n \n // pwd returns the current directory.\n func (tg *testgoData) pwd() string {\n+\ttg.t.Helper()\n \twd, err := os.Getwd()\n \tif err != nil {\n \t\ttg.t.Fatalf(\"could not get working directory: %v\", err)\n@@ -238,6 +288,7 @@ func (tg *testgoData) pwd() string {\n // using this means that the test must not be run in parallel with any\n // other tests.\n func (tg *testgoData) cd(dir string) {\n+\ttg.t.Helper()\n \tif tg.inParallel {\n \t\ttg.t.Fatal(\"internal testsuite error: changing directory when running in parallel\")\n \t}\n@@ -261,6 +312,7 @@ func (tg *testgoData) sleep() {\n // setenv sets an environment variable to use when running the test go\n // command.\n func (tg *testgoData) setenv(name, val string) {\n+\ttg.t.Helper()\n \tif tg.inParallel && (name == \"GOROOT\" || name == \"GOPATH\" || name == \"GOBIN\") && (strings.HasPrefix(val, \"testdata\") || strings.HasPrefix(val, \"./testdata\")) {\n \t\ttg.t.Fatalf(\"internal testsuite error: call to setenv with testdata (%s=%s) after parallel\", name, val)\n \t}\n@@ -291,6 +343,7 @@ func (tg *testgoData) goTool() string {\n // doRun runs the test go command, recording stdout and stderr and\n // returning exit status.\n func (tg *testgoData) doRun(args []string) error {\n+\ttg.t.Helper()\n \tif !canRun {\n \t\tpanic(\"testgoData.doRun called but canRun false\")\n \t}\n@@ -336,6 +389,7 @@ func (tg *testgoData) doRun(args []string) error {\n \n // run runs the test go command, and expects it to succeed.\n func (tg *testgoData) run(args ...string) {\n+\ttg.t.Helper()\n \tif status := tg.doRun(args); status != nil {\n \t\ttg.t.Logf(\"go %v failed unexpectedly: %v\", args, status)\n \t\ttg.t.FailNow()\n@@ -344,6 +398,7 @@ func (tg *testgoData) run(args ...string) {\n \n // runFail runs the test go command, and expects it to fail.\n func (tg *testgoData) runFail(args ...string) {\n+\ttg.t.Helper()\n \tif status := tg.doRun(args); status == nil {\n \t\ttg.t.Fatal(\"testgo succeeded unexpectedly\")\n \t} else {\n@@ -353,6 +408,7 @@ func (tg *testgoData) runFail(args ...string) {\n \n // runGit runs a git command, and expects it to succeed.\n func (tg *testgoData) runGit(dir string, args ...string) {\n+\ttg.t.Helper()\n \tcmd := exec.Command(\"git\", args...)\n \ttg.stdout.Reset()\n \ttg.stderr.Reset()\n@@ -377,6 +433,7 @@ func (tg *testgoData) runGit(dir string, args ...string) {\n \n // getStdout returns standard output of the testgo run as a string.\n func (tg *testgoData) getStdout() string {\n+\ttg.t.Helper()\n \tif !tg.ran {\n \t\ttg.t.Fatal(\"internal testsuite error: stdout called before run\")\n \t}\n@@ -385,6 +442,7 @@ func (tg *testgoData) getStdout() string {\n \n // getStderr returns standard error of the testgo run as a string.\n func (tg *testgoData) getStderr() string {\n+\ttg.t.Helper()\n \tif !tg.ran {\n \t\ttg.t.Fatal(\"internal testsuite error: stdout called before run\")\n \t}\n@@ -395,6 +453,7 @@ func (tg *testgoData) getStderr() string {\n // whether it is found. The regular expression is matched against\n // each line separately, as with the grep command.\n func (tg *testgoData) doGrepMatch(match string, b *bytes.Buffer) bool {\n+\ttg.t.Helper()\n \tif !tg.ran {\n \t\ttg.t.Fatal(\"internal testsuite error: grep called before run\")\n \t}\n@@ -412,6 +471,7 @@ func (tg *testgoData) doGrepMatch(match string, b *bytes.Buffer) bool {\n // searching, \"output\" or \"error\". The msg argument is logged on\n // failure.\n func (tg *testgoData) doGrep(match string, b *bytes.Buffer, name, msg string) {\n+\ttg.t.Helper()\n \tif !tg.doGrepMatch(match, b) {\n \t\ttg.t.Log(msg)\n \t\ttg.t.Logf(\"pattern %v not found in standard %s\", match, name)\n@@ -422,18 +482,21 @@ func (tg *testgoData) doGrep(match string, b *bytes.Buffer, name, msg string) {\n // grepStdout looks for a regular expression in the test run's\n // standard output and fails, logging msg, if it is not found.\n func (tg *testgoData) grepStdout(match, msg string) {\n+\ttg.t.Helper()\n \ttg.doGrep(match, &tg.stdout, \"output\", msg)\n }\n \n // grepStderr looks for a regular expression in the test run's\n // standard error and fails, logging msg, if it is not found.\n func (tg *testgoData) grepStderr(match, msg string) {\n+\ttg.t.Helper()\n \ttg.doGrep(match, &tg.stderr, \"error\", msg)\n }\n \n // grepBoth looks for a regular expression in the test run's standard\n // output or stand error and fails, logging msg, if it is not found.\n func (tg *testgoData) grepBoth(match, msg string) {\n+\ttg.t.Helper()\n \tif !tg.doGrepMatch(match, &tg.stdout) && !tg.doGrepMatch(match, &tg.stderr) {\n \t\ttg.t.Log(msg)\n \t\ttg.t.Logf(\"pattern %v not found in standard output or standard error\", match)\n@@ -444,6 +507,7 @@ func (tg *testgoData) grepBoth(match, msg string) {\n // doGrepNot looks for a regular expression in a buffer and fails if\n // it is found. The name and msg arguments are as for doGrep.\n func (tg *testgoData) doGrepNot(match string, b *bytes.Buffer, name, msg string) {\n+\ttg.t.Helper()\n \tif tg.doGrepMatch(match, b) {\n \t\ttg.t.Log(msg)\n \t\ttg.t.Logf(\"pattern %v found unexpectedly in standard %s\", match, name)\n@@ -454,19 +518,22 @@ func (tg *testgoData) doGrepNot(match string, b *bytes.Buffer, name, msg string)\n // grepStdoutNot looks for a regular expression in the test run's\n // standard output and fails, logging msg, if it is found.\n func (tg *testgoData) grepStdoutNot(match, msg string) {\n+\ttg.t.Helper()\n \ttg.doGrepNot(match, &tg.stdout, \"output\", msg)\n }\n \n // grepStderrNot looks for a regular expression in the test run's\n // standard error and fails, logging msg, if it is found.\n func (tg *testgoData) grepStderrNot(match, msg string) {\n+\ttg.t.Helper()\n \ttg.doGrepNot(match, &tg.stderr, \"error\", msg)\n }\n \n // grepBothNot looks for a regular expression in the test run's\n // standard output or stand error and fails, logging msg, if it is\n // found.\n func (tg *testgoData) grepBothNot(match, msg string) {\n+\ttg.t.Helper()\n \tif tg.doGrepMatch(match, &tg.stdout) || tg.doGrepMatch(match, &tg.stderr) {\n \t\ttg.t.Log(msg)\n \t\ttg.t.Fatalf(\"pattern %v found unexpectedly in standard output or standard error\", match)\n@@ -475,6 +542,7 @@ func (tg *testgoData) grepBothNot(match, msg string) {\n \n // doGrepCount counts the number of times a regexp is seen in a buffer.\n func (tg *testgoData) doGrepCount(match string, b *bytes.Buffer) int {\n+\ttg.t.Helper()\n \tif !tg.ran {\n \t\ttg.t.Fatal(\"internal testsuite error: doGrepCount called before run\")\n \t}\n@@ -491,6 +559,7 @@ func (tg *testgoData) doGrepCount(match string, b *bytes.Buffer) int {\n // grepCountBoth returns the number of times a regexp is seen in both\n // standard output and standard error.\n func (tg *testgoData) grepCountBoth(match string) int {\n+\ttg.t.Helper()\n \treturn tg.doGrepCount(match, &tg.stdout) + tg.doGrepCount(match, &tg.stderr)\n }\n \n@@ -499,6 +568,7 @@ func (tg *testgoData) grepCountBoth(match string) int {\n // removed. When the test completes, the file or directory will be\n // removed if it exists.\n func (tg *testgoData) creatingTemp(path string) {\n+\ttg.t.Helper()\n \tif filepath.IsAbs(path) && !strings.HasPrefix(path, tg.tempdir) {\n \t\ttg.t.Fatalf(\"internal testsuite error: creatingTemp(%q) with absolute path not in temporary directory\", path)\n \t}\n@@ -515,6 +585,7 @@ func (tg *testgoData) creatingTemp(path string) {\n // makeTempdir makes a temporary directory for a run of testgo. If\n // the temporary directory was already created, this does nothing.\n func (tg *testgoData) makeTempdir() {\n+\ttg.t.Helper()\n \tif tg.tempdir == \"\" {\n \t\tvar err error\n \t\ttg.tempdir, err = ioutil.TempDir(\"\", \"gotest\")\n@@ -524,6 +595,7 @@ func (tg *testgoData) makeTempdir() {\n \n // tempFile adds a temporary file for a run of testgo.\n func (tg *testgoData) tempFile(path, contents string) {\n+\ttg.t.Helper()\n \ttg.makeTempdir()\n \ttg.must(os.MkdirAll(filepath.Join(tg.tempdir, filepath.Dir(path)), 0755))\n \tbytes := []byte(contents)\n@@ -538,6 +610,7 @@ func (tg *testgoData) tempFile(path, contents string) {\n \n // tempDir adds a temporary directory for a run of testgo.\n func (tg *testgoData) tempDir(path string) {\n+\ttg.t.Helper()\n \ttg.makeTempdir()\n \tif err := os.MkdirAll(filepath.Join(tg.tempdir, path), 0755); err != nil && !os.IsExist(err) {\n \t\ttg.t.Fatal(err)\n@@ -547,6 +620,7 @@ func (tg *testgoData) tempDir(path string) {\n // path returns the absolute pathname to file with the temporary\n // directory.\n func (tg *testgoData) path(name string) string {\n+\ttg.t.Helper()\n \tif tg.tempdir == \"\" {\n \t\ttg.t.Fatalf(\"internal testsuite error: path(%q) with no tempdir\", name)\n \t}\n@@ -558,6 +632,7 @@ func (tg *testgoData) path(name string) string {\n \n // mustExist fails if path does not exist.\n func (tg *testgoData) mustExist(path string) {\n+\ttg.t.Helper()\n \tif _, err := os.Stat(path); err != nil {\n \t\tif os.IsNotExist(err) {\n \t\t\ttg.t.Fatalf(\"%s does not exist but should\", path)\n@@ -568,13 +643,28 @@ func (tg *testgoData) mustExist(path string) {\n \n // mustNotExist fails if path exists.\n func (tg *testgoData) mustNotExist(path string) {\n+\ttg.t.Helper()\n \tif _, err := os.Stat(path); err == nil || !os.IsNotExist(err) {\n \t\ttg.t.Fatalf(\"%s exists but should not (%v)\", path, err)\n \t}\n }\n \n+// mustHaveContent succeeds if filePath is a path to a file,\n+// and that file is readable and not empty.\n+func (tg *testgoData) mustHaveContent(filePath string) {\n+\ttg.mustExist(filePath)\n+\tf, err := os.Stat(filePath)\n+\tif err != nil {\n+\t\ttg.t.Fatal(err)\n+\t}\n+\tif f.Size() == 0 {\n+\t\ttg.t.Fatalf(\"expected %s to have data, but is empty\", filePath)\n+\t}\n+}\n+\n // wantExecutable fails with msg if path is not executable.\n func (tg *testgoData) wantExecutable(path, msg string) {\n+\ttg.t.Helper()\n \tif st, err := os.Stat(path); err != nil {\n \t\tif !os.IsNotExist(err) {\n \t\t\ttg.t.Log(err)\n@@ -589,6 +679,7 @@ func (tg *testgoData) wantExecutable(path, msg string) {\n \n // wantArchive fails if path is not an archive.\n func (tg *testgoData) wantArchive(path string) {\n+\ttg.t.Helper()\n \tf, err := os.Open(path)\n \tif err != nil {\n \t\ttg.t.Fatal(err)\n@@ -603,6 +694,7 @@ func (tg *testgoData) wantArchive(path string) {\n \n // isStale reports whether pkg is stale, and why\n func (tg *testgoData) isStale(pkg string) (bool, string) {\n+\ttg.t.Helper()\n \ttg.run(\"list\", \"-f\", \"{{.Stale}}:{{.StaleReason}}\", pkg)\n \tv := strings.TrimSpace(tg.getStdout())\n \tf := strings.SplitN(v, \":\", 2)\n@@ -620,6 +712,7 @@ func (tg *testgoData) isStale(pkg string) (bool, string) {\n \n // wantStale fails with msg if pkg is not stale.\n func (tg *testgoData) wantStale(pkg, reason, msg string) {\n+\ttg.t.Helper()\n \tstale, why := tg.isStale(pkg)\n \tif !stale {\n \t\ttg.t.Fatal(msg)\n@@ -631,6 +724,7 @@ func (tg *testgoData) wantStale(pkg, reason, msg string) {\n \n // wantNotStale fails with msg if pkg is stale.\n func (tg *testgoData) wantNotStale(pkg, reason, msg string) {\n+\ttg.t.Helper()\n \tstale, why := tg.isStale(pkg)\n \tif stale {\n \t\ttg.t.Fatal(msg)\n@@ -642,6 +736,7 @@ func (tg *testgoData) wantNotStale(pkg, reason, msg string) {\n \n // cleanup cleans up a test that runs testgo.\n func (tg *testgoData) cleanup() {\n+\ttg.t.Helper()\n \tif tg.wd != \"\" {\n \t\tif err := os.Chdir(tg.wd); err != nil {\n \t\t\t// We are unlikely to be able to continue.\n@@ -660,6 +755,7 @@ func (tg *testgoData) cleanup() {\n // failSSH puts an ssh executable in the PATH that always fails.\n // This is to stub out uses of ssh by go get.\n func (tg *testgoData) failSSH() {\n+\ttg.t.Helper()\n \twd, err := os.Getwd()\n \tif err != nil {\n \t\ttg.t.Fatal(err)\n@@ -668,6 +764,20 @@ func (tg *testgoData) failSSH() {\n \ttg.setenv(\"PATH\", fmt.Sprintf(\"%v%c%v\", fail, filepath.ListSeparator, os.Getenv(\"PATH\")))\n }\n \n+func TestBuildComplex(t *testing.T) {\n+\t// Simple smoke test for build configuration.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"build\", \"-x\", \"-o\", os.DevNull, \"complex\")\n+\n+\tif _, err := exec.LookPath(\"gccgo\"); err == nil {\n+\t\tt.Skip(\"golang.org/issue/22472\")\n+\t\ttg.run(\"build\", \"-x\", \"-o\", os.DevNull, \"-compiler=gccgo\", \"complex\")\n+\t}\n+}\n+\n func TestFileLineInErrorMessages(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -767,40 +877,36 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t\t}\n \t}\n \n-\ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"1\")\n-\n \ttg.tempFile(\"d1/src/p1/p1.go\", `package p1`)\n \ttg.setenv(\"GOPATH\", tg.path(\"d1\"))\n \ttg.run(\"install\", \"-a\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly\")\n-\ttg.sleep()\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, before any changes\")\n \n-\t// Changing mtime and content of runtime/internal/sys/sys.go\n-\t// should have no effect: we're in a release, which doesn't rebuild\n-\t// for general mtime or content changes.\n+\t// Changing mtime of runtime/internal/sys/sys.go\n+\t// should have no effect: only the content matters.\n+\t// In fact this should be true even outside a release branch.\n \tsys := runtime.GOROOT() + \"/src/runtime/internal/sys/sys.go\"\n+\ttg.sleep()\n \trestore := addNL(sys)\n-\tdefer restore()\n-\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after updating runtime/internal/sys/sys.go\")\n \trestore()\n-\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after restoring runtime/internal/sys/sys.go\")\n+\ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after updating mtime of runtime/internal/sys/sys.go\")\n \n-\t// But changing runtime/internal/sys/zversion.go should have an effect:\n-\t// that's how we tell when we flip from one release to another.\n-\tzversion := runtime.GOROOT() + \"/src/runtime/internal/sys/zversion.go\"\n-\trestore = addNL(zversion)\n+\t// But changing content of any file should have an effect.\n+\t// Previously zversion.go was the only one that mattered;\n+\t// now they all matter, so keep using sys.go.\n+\trestore = addNL(sys)\n \tdefer restore()\n-\ttg.wantStale(\"p1\", \"build ID mismatch\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to new release\")\n+\ttg.wantStale(\"p1\", \"stale dependency: runtime/internal/sys\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing sys.go\")\n \trestore()\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly, after changing back to old release\")\n-\taddNL(zversion)\n-\ttg.wantStale(\"p1\", \"build ID mismatch\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing again to new release\")\n+\taddNL(sys)\n+\ttg.wantStale(\"p1\", \"stale dependency: runtime/internal/sys\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing sys.go again\")\n \ttg.run(\"install\", \"p1\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with new release\")\n \n \t// Restore to \"old\" release.\n \trestore()\n-\ttg.wantStale(\"p1\", \"build ID mismatch\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to old release after new build\")\n+\ttg.wantStale(\"p1\", \"stale dependency: runtime/internal/sys\", \"./testgo list claims p1 is NOT stale, incorrectly, after restoring sys.go\")\n \ttg.run(\"install\", \"p1\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with old release\")\n \n@@ -887,7 +993,7 @@ func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n \t\tfunc F() {}`)\n \tsep := string(filepath.ListSeparator)\n \ttg.setenv(\"GOPATH\", tg.path(\"d1\")+sep+tg.path(\"d2\"))\n-\ttg.run(\"install\", \"p1\")\n+\ttg.run(\"install\", \"-i\", \"p1\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale, incorrectly\")\n \ttg.wantNotStale(\"p2\", \"\", \"./testgo list claims p2 is stale, incorrectly\")\n \ttg.sleep()\n@@ -898,10 +1004,10 @@ func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n \t} else {\n \t\ttg.must(f.Close())\n \t}\n-\ttg.wantStale(\"p2\", \"newer source file\", \"./testgo list claims p2 is NOT stale, incorrectly\")\n-\ttg.wantStale(\"p1\", \"stale dependency\", \"./testgo list claims p1 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p2\", \"build ID mismatch\", \"./testgo list claims p2 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p1\", \"stale dependency: p2\", \"./testgo list claims p1 is NOT stale, incorrectly\")\n \n-\ttg.run(\"install\", \"p1\")\n+\ttg.run(\"install\", \"-i\", \"p1\")\n \ttg.wantNotStale(\"p2\", \"\", \"./testgo list claims p2 is stale after reinstall, incorrectly\")\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after reinstall, incorrectly\")\n }\n@@ -999,6 +1105,7 @@ func TestGoInstallDetectsRemovedFilesInPackageMain(t *testing.T) {\n }\n \n func testLocalRun(tg *testgoData, exepath, local, match string) {\n+\ttg.t.Helper()\n \tout, err := exec.Command(exepath).Output()\n \tif err != nil {\n \t\ttg.t.Fatalf(\"error running %v: %v\", exepath, err)\n@@ -1010,27 +1117,31 @@ func testLocalRun(tg *testgoData, exepath, local, match string) {\n }\n \n func testLocalEasy(tg *testgoData, local string) {\n+\ttg.t.Helper()\n \texepath := \"./easy\" + exeSuffix\n \ttg.creatingTemp(exepath)\n \ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"easy.go\"))\n \ttestLocalRun(tg, exepath, local, `(?m)^easysub\\.Hello`)\n }\n \n func testLocalEasySub(tg *testgoData, local string) {\n+\ttg.t.Helper()\n \texepath := \"./easysub\" + exeSuffix\n \ttg.creatingTemp(exepath)\n \ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"easysub\", \"main.go\"))\n \ttestLocalRun(tg, exepath, local, `(?m)^easysub\\.Hello`)\n }\n \n func testLocalHard(tg *testgoData, local string) {\n+\ttg.t.Helper()\n \texepath := \"./hard\" + exeSuffix\n \ttg.creatingTemp(exepath)\n \ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"hard.go\"))\n \ttestLocalRun(tg, exepath, local, `(?m)^sub\\.Hello`)\n }\n \n func testLocalInstall(tg *testgoData, local string) {\n+\ttg.t.Helper()\n \ttg.runFail(\"install\", filepath.Join(\"testdata\", local, \"easy.go\"))\n }\n \n@@ -1061,6 +1172,7 @@ func TestLocalImportsGoInstallShouldFail(t *testing.T) {\n const badDirName = `#$%:, &()*;<=>?\\^{}`\n \n func copyBad(tg *testgoData) {\n+\ttg.t.Helper()\n \tif runtime.GOOS == \"windows\" {\n \t\ttg.t.Skipf(\"skipping test because %q is an invalid directory name\", badDirName)\n \t}\n@@ -1176,7 +1288,7 @@ func testMove(t *testing.T, vcs, url, base, config string) {\n \ttg.runFail(\"get\", \"-d\", \"-u\", url)\n \ttg.grepStderr(\"is a custom import path for\", \"go get -d -u \"+url+\" failed for wrong reason\")\n \ttg.runFail(\"get\", \"-d\", \"-f\", \"-u\", url)\n-\ttg.grepStderr(\"validating server certificate|not found\", \"go get -d -f -u \"+url+\" failed for wrong reason\")\n+\ttg.grepStderr(\"validating server certificate|[nN]ot [fF]ound\", \"go get -d -f -u \"+url+\" failed for wrong reason\")\n }\n \n func TestInternalPackageErrorsAreHandled(t *testing.T) {\n@@ -1197,10 +1309,9 @@ func TestMoveGit(t *testing.T) {\n \ttestMove(t, \"git\", \"rsc.io/pdf\", \"pdf\", \"rsc.io/pdf/.git/config\")\n }\n \n-// TODO(rsc): Set up a test case on bitbucket for hg.\n-// func TestMoveHG(t *testing.T) {\n-// \ttestMove(t, \"hg\", \"rsc.io/x86/x86asm\", \"x86\", \"rsc.io/x86/.hg/hgrc\")\n-// }\n+func TestMoveHG(t *testing.T) {\n+\ttestMove(t, \"hg\", \"vcs-test.golang.org/go/custom-hg-hello\", \"custom-hg-hello\", \"vcs-test.golang.org/go/custom-hg-hello/.hg/hgrc\")\n+}\n \n // TODO(rsc): Set up a test case on SourceForge (?) for svn.\n // func testMoveSVN(t *testing.T) {\n@@ -1329,6 +1440,25 @@ func TestGetGitDefaultBranch(t *testing.T) {\n \ttg.grepStdout(`\\* another-branch`, \"not on correct default branch\")\n }\n \n+func TestAccidentalGitCheckout(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\tif _, err := exec.LookPath(\"git\"); err != nil {\n+\t\tt.Skip(\"skipping because git binary not found\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\ttg.runFail(\"get\", \"-u\", \"vcs-test.golang.org/go/test1-svn-git\")\n+\ttg.grepStderr(\"src[\\\\\\\\/]vcs-test.* uses git, but parent .*src[\\\\\\\\/]vcs-test.* uses svn\", \"get did not fail for right reason\")\n+\n+\ttg.runFail(\"get\", \"-u\", \"vcs-test.golang.org/go/test2-svn-git/test2main\")\n+\ttg.grepStderr(\"src[\\\\\\\\/]vcs-test.* uses git, but parent .*src[\\\\\\\\/]vcs-test.* uses svn\", \"get did not fail for right reason\")\n+}\n+\n func TestErrorMessageForSyntaxErrorInTestGoFileSaysFAIL(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1355,6 +1485,10 @@ func TestRelativeImportsGoTest(t *testing.T) {\n func TestRelativeImportsGoTestDashI(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\n+\t// don't let test -i overwrite runtime\n+\ttg.wantNotStale(\"runtime\", \"\", \"must be non-stale before test -i\")\n+\n \ttg.run(\"test\", \"-i\", \"./testdata/testimport\")\n }\n \n@@ -1401,6 +1535,28 @@ func TestInstallFailsWithNoBuildableFiles(t *testing.T) {\n \ttg.grepStderr(\"build constraints exclude all Go files\", \"go install cgotest did not report 'build constraints exclude all Go files'\")\n }\n \n+// Issue 21895\n+func TestMSanAndRaceRequireCgo(t *testing.T) {\n+\tif !canMSan && !canRace {\n+\t\tt.Skip(\"skipping because both msan and the race detector are not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempFile(\"triv.go\", `package main; func main() {}`)\n+\ttg.setenv(\"CGO_ENABLED\", \"0\")\n+\tif canRace {\n+\t\ttg.runFail(\"install\", \"-race\", \"triv.go\")\n+\t\ttg.grepStderr(\"-race requires cgo\", \"did not correctly report that -race requires cgo\")\n+\t\ttg.grepStderrNot(\"-msan\", \"reported that -msan instead of -race requires cgo\")\n+\t}\n+\tif canMSan {\n+\t\ttg.runFail(\"install\", \"-msan\", \"triv.go\")\n+\t\ttg.grepStderr(\"-msan requires cgo\", \"did not correctly report that -msan requires cgo\")\n+\t\ttg.grepStderrNot(\"-race\", \"reported that -race instead of -msan requires cgo\")\n+\t}\n+}\n+\n func TestRelativeGOBINFail(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1458,19 +1614,16 @@ func TestPackageNotStaleWithTrailingSlash(t *testing.T) {\n \tdefer tg.cleanup()\n \n \t// Make sure the packages below are not stale.\n-\ttg.run(\"install\", \"runtime\", \"os\", \"io\")\n+\ttg.wantNotStale(\"runtime\", \"\", \"must be non-stale before test runs\")\n+\ttg.wantNotStale(\"os\", \"\", \"must be non-stale before test runs\")\n+\ttg.wantNotStale(\"io\", \"\", \"must be non-stale before test runs\")\n \n \tgoroot := runtime.GOROOT()\n \ttg.setenv(\"GOROOT\", goroot+\"/\")\n \n-\twant := \"\"\n-\tif isGoRelease {\n-\t\twant = \"standard package in Go release distribution\"\n-\t}\n-\n-\ttg.wantNotStale(\"runtime\", want, \"with trailing slash in GOROOT, runtime listed as stale\")\n-\ttg.wantNotStale(\"os\", want, \"with trailing slash in GOROOT, os listed as stale\")\n-\ttg.wantNotStale(\"io\", want, \"with trailing slash in GOROOT, io listed as stale\")\n+\ttg.wantNotStale(\"runtime\", \"\", \"with trailing slash in GOROOT, runtime listed as stale\")\n+\ttg.wantNotStale(\"os\", \"\", \"with trailing slash in GOROOT, os listed as stale\")\n+\ttg.wantNotStale(\"io\", \"\", \"with trailing slash in GOROOT, io listed as stale\")\n }\n \n // With $GOBIN set, binaries get installed to $GOBIN.\n@@ -1612,6 +1765,27 @@ func TestRejectRelativePathsInGOPATHCommandLinePackage(t *testing.T) {\n \ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n }\n \n+// Issue 21928.\n+func TestRejectBlankPathsInGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", \" \"+sep+filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"build\", \"go-cmd-test\")\n+\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n+}\n+\n+// Issue 21928.\n+func TestIgnoreEmptyPathsInGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.creatingTemp(\"testdata/bin/go-cmd-test\" + exeSuffix)\n+\tsep := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", \"\"+sep+filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"install\", \"go-cmd-test\")\n+\ttg.wantExecutable(\"testdata/bin/go-cmd-test\"+exeSuffix, \"go install go-cmd-test did not write to testdata/bin/go-cmd-test\")\n+}\n+\n // Issue 4104.\n func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n \ttg := testgo(t)\n@@ -1671,6 +1845,20 @@ func TestGoListDedupsPackages(t *testing.T) {\n \t}\n }\n \n+func TestGoListDeps(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempDir(\"src/p1/p2/p3/p4\")\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.tempFile(\"src/p1/p.go\", \"package p1\\nimport _ \\\"p1/p2\\\"\\n\")\n+\ttg.tempFile(\"src/p1/p2/p.go\", \"package p2\\nimport _ \\\"p1/p2/p3\\\"\\n\")\n+\ttg.tempFile(\"src/p1/p2/p3/p.go\", \"package p3\\nimport _ \\\"p1/p2/p3/p4\\\"\\n\")\n+\ttg.tempFile(\"src/p1/p2/p3/p4/p.go\", \"package p4\\n\")\n+\ttg.run(\"list\", \"-f\", \"{{.Deps}}\", \"p1\")\n+\ttg.grepStdout(\"p1/p2/p3/p4\", \"Deps(p1) does not mention p4\")\n+}\n+\n // Issue 4096. Validate the output of unsuccessful go install foo/quxx.\n func TestUnsuccessfulGoInstallShouldMentionMissingPackage(t *testing.T) {\n \ttg := testgo(t)\n@@ -1906,6 +2094,16 @@ func TestGoTestMutexprofileDashOControlsBinaryLocation(t *testing.T) {\n \ttg.wantExecutable(\"myerrors.test\"+exeSuffix, \"go test -mutexprofile -o myerrors.test did not create myerrors.test\")\n }\n \n+func TestGoBuildNonMain(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"build\", \"-buildmode=exe\", \"-o\", \"not_main\"+exeSuffix, \"not_main\")\n+\ttg.grepStderr(\"-buildmode=exe requires exactly one main package\", \"go build with -o and -buildmode=exe should on a non-main package should throw an error\")\n+\ttg.mustNotExist(\"not_main\" + exeSuffix)\n+}\n+\n func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n \ttg := testgo(t)\n@@ -1932,6 +2130,10 @@ func TestGoTestDashIDashOWritesBinary(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.parallel()\n \ttg.makeTempdir()\n+\n+\t// don't let test -i overwrite runtime\n+\ttg.wantNotStale(\"runtime\", \"\", \"must be non-stale before test -i\")\n+\n \ttg.run(\"test\", \"-v\", \"-i\", \"-o\", tg.path(\"myerrors.test\"+exeSuffix), \"errors\")\n \ttg.grepBothNot(\"PASS|FAIL\", \"test should not have run\")\n \ttg.wantExecutable(tg.path(\"myerrors.test\"+exeSuffix), \"go test -o myerrors.test did not create myerrors.test\")\n@@ -2104,7 +2306,7 @@ func TestSymlinkWarning(t *testing.T) {\n \ttg.tempDir(\"yy/zz\")\n \ttg.tempFile(\"yy/zz/zz.go\", \"package zz\\n\")\n \tif err := os.Symlink(tg.path(\"yy\"), tg.path(\"src/example/xx/yy\")); err != nil {\n-\t\tt.Skip(\"symlink failed: %v\", err)\n+\t\tt.Skipf(\"symlink failed: %v\", err)\n \t}\n \ttg.run(\"list\", \"example/xx/z...\")\n \ttg.grepStdoutNot(\".\", \"list should not have matched anything\")\n@@ -2199,16 +2401,17 @@ func TestSourceFileNameOrderPreserved(t *testing.T) {\n // Check that coverage analysis works at all.\n // Don't worry about the exact numbers but require not 0.0%.\n func checkCoverage(tg *testgoData, data string) {\n+\ttg.t.Helper()\n \tif regexp.MustCompile(`[^0-9]0\\.0%`).MatchString(data) {\n \t\ttg.t.Error(\"some coverage results are 0.0%\")\n \t}\n-\ttg.t.Log(data)\n }\n \n func TestCoverageRuns(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"don't build libraries for coverage in short mode\")\n \t}\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.run(\"test\", \"-short\", \"-coverpkg=strings\", \"strings\", \"regexp\")\n@@ -2219,21 +2422,32 @@ func TestCoverageRuns(t *testing.T) {\n }\n \n // Check that coverage analysis uses set mode.\n+// Also check that coverage profiles merge correctly.\n func TestCoverageUsesSetMode(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"don't build libraries for coverage in short mode\")\n \t}\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.creatingTemp(\"testdata/cover.out\")\n-\ttg.run(\"test\", \"-short\", \"-cover\", \"encoding/binary\", \"-coverprofile=testdata/cover.out\")\n+\ttg.run(\"test\", \"-short\", \"-cover\", \"encoding/binary\", \"errors\", \"-coverprofile=testdata/cover.out\")\n \tdata := tg.getStdout() + tg.getStderr()\n \tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n \t\tt.Error(err)\n \t} else {\n \t\tif !bytes.Contains(out, []byte(\"mode: set\")) {\n \t\t\tt.Error(\"missing mode: set\")\n \t\t}\n+\t\tif !bytes.Contains(out, []byte(\"errors.go\")) {\n+\t\t\tt.Error(\"missing errors.go\")\n+\t\t}\n+\t\tif !bytes.Contains(out, []byte(\"binary.go\")) {\n+\t\t\tt.Error(\"missing binary.go\")\n+\t\t}\n+\t\tif bytes.Count(out, []byte(\"mode: set\")) != 1 {\n+\t\t\tt.Error(\"too many mode: set\")\n+\t\t}\n \t}\n \tcheckCoverage(tg, data)\n }\n@@ -2245,6 +2459,7 @@ func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n \tif !canRace {\n \t\tt.Skip(\"skipping because race detector not supported\")\n \t}\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2261,7 +2476,17 @@ func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n \tcheckCoverage(tg, data)\n }\n \n+func TestCoverageSyncAtomicImport(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"-short\", \"-cover\", \"-covermode=atomic\", \"-coverpkg=coverdep/p1\", \"coverdep\")\n+}\n+\n func TestCoverageImportMainLoop(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n@@ -2271,6 +2496,76 @@ func TestCoverageImportMainLoop(t *testing.T) {\n \ttg.grepStderr(\"not an importable package\", \"did not detect import main\")\n }\n \n+func TestCoveragePattern(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\t// If coverpkg=sleepy... expands by package loading\n+\t// (as opposed to pattern matching on deps)\n+\t// then it will try to load sleepybad, which does not compile,\n+\t// and the test command will fail.\n+\ttg.run(\"test\", \"-coverprofile=\"+filepath.Join(tg.tempdir, \"cover.out\"), \"-coverpkg=sleepy...\", \"-run=^$\", \"sleepy1\")\n+}\n+\n+func TestCoverageErrorLine(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GOTMPDIR\", tg.tempdir)\n+\n+\ttg.runFail(\"test\", \"coverbad\")\n+\ttg.grepStderr(`coverbad[\\\\/]p\\.go:4`, \"did not find coverbad/p.go:4\")\n+\tif canCgo {\n+\t\ttg.grepStderr(`coverbad[\\\\/]p1\\.go:6`, \"did not find coverbad/p1.go:6\")\n+\t}\n+\ttg.grepStderrNot(regexp.QuoteMeta(tg.tempdir), \"found temporary directory in error\")\n+\tstderr := tg.getStderr()\n+\n+\ttg.runFail(\"test\", \"-cover\", \"coverbad\")\n+\tstderr2 := tg.getStderr()\n+\n+\t// It's OK that stderr2 drops the character position in the error,\n+\t// because of the //line directive (see golang.org/issue/22662).\n+\tstderr = strings.Replace(stderr, \"p.go:4:2:\", \"p.go:4:\", -1)\n+\tif stderr != stderr2 {\n+\t\tt.Logf(\"test -cover changed error messages:\\nbefore:\\n%s\\n\\nafter:\\n%s\", stderr, stderr2)\n+\t\tt.Skip(\"golang.org/issue/22660\")\n+\t\tt.FailNow()\n+\t}\n+}\n+\n+func TestTestBuildFailureOutput(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\t// Doesn't build, -x output should not claim to run test.\n+\ttg.runFail(\"test\", \"-x\", \"coverbad\")\n+\ttg.grepStderrNot(`[\\\\/]coverbad\\.test( |$)`, \"claimed to run test\")\n+}\n+\n+func TestCoverageFunc(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\ttg.run(\"test\", \"-outputdir=\"+tg.tempdir, \"-coverprofile=cover.out\", \"coverasm\")\n+\ttg.run(\"tool\", \"cover\", \"-func=\"+filepath.Join(tg.tempdir, \"cover.out\"))\n+\ttg.grepStdout(`\\tg\\t*100.0%`, \"did not find g 100% covered\")\n+\ttg.grepStdoutNot(`\\tf\\t*[0-9]`, \"reported coverage for assembly function f\")\n+}\n+\n func TestPluginNonMain(t *testing.T) {\n \twd, err := os.Getwd()\n \tif err != nil {\n@@ -2509,14 +2804,64 @@ func main() {\n \ttg.run(\"run\", tg.path(\"foo.go\"))\n }\n \n-// \"go test -c -test.bench=XXX errors\" should not hang\n+// \"go test -c -test.bench=XXX errors\" should not hang.\n+// \"go test -c\" should also produce reproducible binaries.\n+// \"go test -c\" should also appear to write a new binary every time,\n+// even if it's really just updating the mtime on an existing up-to-date binary.\n func TestIssue6480(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no standard packages\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \t// TODO: tg.parallel()\n \ttg.makeTempdir()\n \ttg.cd(tg.path(\".\"))\n \ttg.run(\"test\", \"-c\", \"-test.bench=XXX\", \"errors\")\n+\ttg.run(\"test\", \"-c\", \"-o\", \"errors2.test\", \"errors\")\n+\n+\tdata1, err := ioutil.ReadFile(\"errors.test\" + exeSuffix)\n+\ttg.must(err)\n+\tdata2, err := ioutil.ReadFile(\"errors2.test\") // no exeSuffix because -o above doesn't have it\n+\ttg.must(err)\n+\tif !bytes.Equal(data1, data2) {\n+\t\tt.Fatalf(\"go test -c errors produced different binaries when run twice\")\n+\t}\n+\n+\tstart := time.Now()\n+\ttg.run(\"test\", \"-x\", \"-c\", \"-test.bench=XXX\", \"errors\")\n+\ttg.grepStderrNot(`[\\\\/]link|gccgo`, \"incorrectly relinked up-to-date test binary\")\n+\tinfo, err := os.Stat(\"errors.test\" + exeSuffix)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tstart = truncateLike(start, info.ModTime())\n+\tif info.ModTime().Before(start) {\n+\t\tt.Fatalf(\"mtime of errors.test predates test -c command (%v < %v)\", info.ModTime(), start)\n+\t}\n+\n+\tstart = time.Now()\n+\ttg.run(\"test\", \"-x\", \"-c\", \"-o\", \"errors2.test\", \"errors\")\n+\ttg.grepStderrNot(`[\\\\/]link|gccgo`, \"incorrectly relinked up-to-date test binary\")\n+\tinfo, err = os.Stat(\"errors2.test\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tstart = truncateLike(start, info.ModTime())\n+\tif info.ModTime().Before(start) {\n+\t\tt.Fatalf(\"mtime of errors2.test predates test -c command (%v < %v)\", info.ModTime(), start)\n+\t}\n+}\n+\n+// truncateLike returns the result of truncating t to the apparent precision of p.\n+func truncateLike(t, p time.Time) time.Time {\n+\tnano := p.UnixNano()\n+\td := 1 * time.Nanosecond\n+\tfor nano%int64(d) == 0 && d < 1*time.Second {\n+\t\td *= 10\n+\t}\n+\tfor nano%int64(d) == 0 && d < 2*time.Second {\n+\t\td *= 2\n+\t}\n+\treturn t.Truncate(d)\n }\n \n // cmd/cgo: undefined reference when linking a C-library using gccgo\n@@ -2527,6 +2872,7 @@ func TestIssue7573(t *testing.T) {\n \tif _, err := exec.LookPath(\"gccgo\"); err != nil {\n \t\tt.Skip(\"skipping because no gccgo compiler found\")\n \t}\n+\tt.Skip(\"golang.org/issue/22472\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2609,17 +2955,21 @@ func TestBuildDashIInstallsDependencies(t *testing.T) {\n \t\tfunc F() { foo.F() }`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \n+\t// don't let build -i overwrite runtime\n+\ttg.wantNotStale(\"runtime\", \"\", \"must be non-stale before build -i\")\n+\n \tcheckbar := func(desc string) {\n-\t\ttg.sleep()\n-\t\ttg.must(os.Chtimes(tg.path(\"src/x/y/foo/foo.go\"), time.Now(), time.Now()))\n-\t\ttg.sleep()\n \t\ttg.run(\"build\", \"-v\", \"-i\", \"x/y/bar\")\n \t\ttg.grepBoth(\"x/y/foo\", \"first build -i \"+desc+\" did not build x/y/foo\")\n \t\ttg.run(\"build\", \"-v\", \"-i\", \"x/y/bar\")\n \t\ttg.grepBothNot(\"x/y/foo\", \"second build -i \"+desc+\" built x/y/foo\")\n \t}\n \tcheckbar(\"pkg\")\n+\n \ttg.creatingTemp(\"bar\" + exeSuffix)\n+\ttg.sleep()\n+\ttg.tempFile(\"src/x/y/foo/foo.go\", `package foo\n+\t\tfunc F() { F() }`)\n \ttg.tempFile(\"src/x/y/bar/bar.go\", `package main\n \t\timport \"x/y/foo\"\n \t\tfunc main() { foo.F() }`)\n@@ -2650,6 +3000,21 @@ func TestGoTestFooTestWorks(t *testing.T) {\n \ttg.run(\"test\", \"testdata/standalone_test.go\")\n }\n \n+// Issue 22388\n+func TestGoTestMainWithWrongSignature(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.runFail(\"test\", \"testdata/standalone_main_wrong_test.go\")\n+\ttg.grepStderr(`wrong signature for TestMain, must be: func TestMain\\(m \\*testing.M\\)`, \"detected wrong error message\")\n+}\n+\n+func TestGoTestMainAsNormalTest(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"testdata/standalone_main_normal_test.go\")\n+\ttg.grepBoth(okPattern, \"go test did not say ok\")\n+}\n+\n func TestGoTestFlagsAfterPackage(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2773,40 +3138,36 @@ func TestGoVetWithExternalTests(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n-\ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"vet\", \"vetpkg\")\n-\ttg.grepBoth(\"missing argument for Printf\", \"go vet vetpkg did not find missing argument for Printf\")\n+\ttg.grepBoth(\"Printf\", \"go vet vetpkg did not find missing argument for Printf\")\n }\n \n func TestGoVetWithTags(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have vet\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n-\ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"vet\", \"-tags\", \"tagtest\", \"vetpkg\")\n-\ttg.grepBoth(`c\\.go.*wrong number of args for format`, \"go vet vetpkg did not run scan tagged file\")\n+\ttg.grepBoth(`c\\.go.*Printf`, \"go vet vetpkg did not run scan tagged file\")\n }\n \n func TestGoVetWithFlagsOn(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have vet\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n-\ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"vet\", \"-printf\", \"vetpkg\")\n-\ttg.grepBoth(\"missing argument for Printf\", \"go vet -printf vetpkg did not find missing argument for Printf\")\n+\ttg.grepBoth(\"Printf\", \"go vet -printf vetpkg did not find missing argument for Printf\")\n }\n \n func TestGoVetWithFlagsOff(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have vet\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n-\ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.run(\"vet\", \"-printf=false\", \"vetpkg\")\n }\n@@ -2857,7 +3218,7 @@ func TestImportMain(t *testing.T) {\n \t\tfunc TestFoo(t *testing.T) {}\n \t`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.creatingTemp(\"x\")\n+\ttg.creatingTemp(\"x\" + exeSuffix)\n \ttg.run(\"build\", \"x\")\n \ttg.run(\"test\", \"x\")\n \n@@ -3153,11 +3514,12 @@ func TestGoInstallPkgdir(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \tpkg := tg.path(\".\")\n-\ttg.run(\"install\", \"-pkgdir\", pkg, \"errors\")\n-\t_, err := os.Stat(filepath.Join(pkg, \"errors.a\"))\n-\ttg.must(err)\n-\t_, err = os.Stat(filepath.Join(pkg, \"runtime.a\"))\n-\ttg.must(err)\n+\ttg.run(\"install\", \"-pkgdir\", pkg, \"sync\")\n+\ttg.mustExist(filepath.Join(pkg, \"sync.a\"))\n+\ttg.mustNotExist(filepath.Join(pkg, \"sync/atomic.a\"))\n+\ttg.run(\"install\", \"-i\", \"-pkgdir\", pkg, \"sync\")\n+\ttg.mustExist(filepath.Join(pkg, \"sync.a\"))\n+\ttg.mustExist(filepath.Join(pkg, \"sync/atomic.a\"))\n }\n \n func TestGoTestRaceInstallCgo(t *testing.T) {\n@@ -3469,16 +3831,6 @@ func TestGoBuildARM(t *testing.T) {\n \ttg.grepStderrNot(\"unable to find math.a\", \"did not build math.a correctly\")\n }\n \n-func TestIssue13655(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no standard packages\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tfor _, pkg := range []string{\"runtime\", \"runtime/internal/atomic\"} {\n-\t\ttg.run(\"list\", \"-f\", \"{{.Deps}}\", pkg)\n-\t\ttg.grepStdout(\"runtime/internal/sys\", \"did not find required dependency of \"+pkg+\" on runtime/internal/sys\")\n-\t}\n-}\n-\n // For issue 14337.\n func TestParallelTest(t *testing.T) {\n \ttg := testgo(t)\n@@ -3576,9 +3928,9 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \n \t\tpackage p1\n \t`)\n-\ttg.wantStale(\"p1\", \"cannot access install target\", \"p1 is binary-only but has no binary, should be stale\")\n+\ttg.wantStale(\"p1\", \"missing or invalid binary-only package\", \"p1 is binary-only but has no binary, should be stale\")\n \ttg.runFail(\"install\", \"p1\")\n-\ttg.grepStderr(\"missing or invalid package binary\", \"did not report attempt to compile binary-only package\")\n+\ttg.grepStderr(\"missing or invalid binary-only package\", \"did not report attempt to compile binary-only package\")\n \n \ttg.tempFile(\"src/p1/p1.go\", `\n \t\tpackage p1\n@@ -3601,11 +3953,12 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \ttg.tempFile(\"src/p1/missing.go\", `//go:binary-only-package\n \n \t\tpackage p1\n+\t\timport _ \"fmt\"\n \t\tfunc G()\n \t`)\n-\ttg.wantNotStale(\"p1\", \"no source code\", \"should NOT want to rebuild p1 (first)\")\n+\ttg.wantNotStale(\"p1\", \"binary-only package\", \"should NOT want to rebuild p1 (first)\")\n \ttg.run(\"install\", \"-x\", \"p1\") // no-op, up to date\n-\ttg.grepBothNot(\"/compile\", \"should not have run compiler\")\n+\ttg.grepBothNot(`[\\\\/]compile`, \"should not have run compiler\")\n \ttg.run(\"install\", \"p2\") // does not rebuild p1 (or else p2 will fail)\n \ttg.wantNotStale(\"p2\", \"\", \"should NOT want to rebuild p2\")\n \n@@ -3615,7 +3968,7 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \t\tpackage p1\n \t\tfunc H()\n \t`)\n-\ttg.wantNotStale(\"p1\", \"no source code\", \"should NOT want to rebuild p1 (second)\")\n+\ttg.wantNotStale(\"p1\", \"binary-only package\", \"should NOT want to rebuild p1 (second)\")\n \ttg.wantNotStale(\"p2\", \"\", \"should NOT want to rebuild p2\")\n \n \ttg.tempFile(\"src/p3/p3.go\", `\n@@ -3635,9 +3988,11 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \ttg.grepStdout(\"hello from p1\", \"did not see message from p1\")\n \n \ttg.tempFile(\"src/p4/p4.go\", `package main`)\n+\t// The odd string split below avoids vet complaining about\n+\t// a // +build line appearing too late in this source file.\n \ttg.tempFile(\"src/p4/p4not.go\", `//go:binary-only-package\n \n-\t\t// +build asdf\n+\t\t/`+`/ +build asdf\n \n \t\tpackage main\n \t`)\n@@ -3723,6 +4078,7 @@ func TestGoEnv(t *testing.T) {\n \ttg := testgo(t)\n \ttg.parallel()\n \tdefer tg.cleanup()\n+\ttg.setenv(\"GOOS\", \"freebsd\") // to avoid invalid pair errors\n \ttg.setenv(\"GOARCH\", \"arm\")\n \ttg.run(\"env\", \"GOARCH\")\n \ttg.grepStdout(\"^arm$\", \"GOARCH not honored\")\n@@ -3877,6 +4233,24 @@ func TestBenchTimeout(t *testing.T) {\n \ttg.run(\"test\", \"-bench\", \".\", \"-timeout\", \"750ms\", \"testdata/timeoutbench_test.go\")\n }\n \n+// Issue 19394\n+func TestWriteProfilesOnTimeout(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempDir(\"profiling\")\n+\ttg.tempFile(\"profiling/timeouttest_test.go\", `package timeouttest_test\n+import \"testing\"\n+import \"time\"\n+func TestSleep(t *testing.T) { time.Sleep(time.Second) }`)\n+\ttg.cd(tg.path(\"profiling\"))\n+\ttg.runFail(\n+\t\t\"test\",\n+\t\t\"-cpuprofile\", tg.path(\"profiling/cpu.pprof\"), \"-memprofile\", tg.path(\"profiling/mem.pprof\"),\n+\t\t\"-timeout\", \"1ms\")\n+\ttg.mustHaveContent(tg.path(\"profiling/cpu.pprof\"))\n+\ttg.mustHaveContent(tg.path(\"profiling/mem.pprof\"))\n+}\n+\n func TestLinkXImportPathEscape(t *testing.T) {\n \t// golang.org/issue/16710\n \tskipIfGccgo(t, \"gccgo does not support -ldflags -X\")\n@@ -4023,9 +4397,7 @@ func TestBuildTagsNoComma(t *testing.T) {\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n-\ttg.run(\"install\", \"-tags\", \"tag1 tag2\", \"math\")\n-\ttg.runFail(\"install\", \"-tags\", \"tag1,tag2\", \"math\")\n-\ttg.grepBoth(\"space-separated list contains comma\", \"-tags with a comma-separated list didn't error\")\n+\ttg.run(\"build\", \"-tags\", \"tag1 tag2\", \"math\")\n \ttg.runFail(\"build\", \"-tags\", \"tag1,tag2\", \"math\")\n \ttg.grepBoth(\"space-separated list contains comma\", \"-tags with a comma-separated list didn't error\")\n }\n@@ -4105,7 +4477,7 @@ func TestExecutableGOROOT(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n-\t\tm := regexp.MustCompile(\"const DefaultGoroot = `([^`]+)`\").FindStringSubmatch(string(data))\n+\t\tm := regexp.MustCompile(\"var DefaultGoroot = `([^`]+)`\").FindStringSubmatch(string(data))\n \t\tif m == nil {\n \t\t\tt.Fatal(\"cannot find DefaultGoroot in ../../runtime/internal/sys/zversion.go\")\n \t\t}\n@@ -4130,6 +4502,43 @@ func TestExecutableGOROOT(t *testing.T) {\n \t\t}\n \t\tcheck(t, symGoTool, newRoot)\n \t})\n+\n+\ttg.must(os.RemoveAll(tg.path(\"new/pkg\")))\n+\n+\t// Binaries built in the new tree should report the\n+\t// new tree when they call runtime.GOROOT().\n+\t// This is implemented by having the go tool pass a -X option\n+\t// to the linker setting runtime/internal/sys.DefaultGoroot.\n+\tt.Run(\"RuntimeGoroot\", func(t *testing.T) {\n+\t\t// Build a working GOROOT the easy way, with symlinks.\n+\t\ttestenv.MustHaveSymlink(t)\n+\t\tif err := os.Symlink(filepath.Join(testGOROOT, \"src\"), tg.path(\"new/src\")); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif err := os.Symlink(filepath.Join(testGOROOT, \"pkg\"), tg.path(\"new/pkg\")); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tcmd := exec.Command(newGoTool, \"run\", \"testdata/print_goroot.go\")\n+\t\tcmd.Env = env\n+\t\tout, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%s run testdata/print_goroot.go: %v, %s\", newGoTool, err, out)\n+\t\t}\n+\t\tgoroot, err := filepath.EvalSymlinks(strings.TrimSpace(string(out)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\twant, err := filepath.EvalSymlinks(tg.path(\"new\"))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif !strings.EqualFold(goroot, want) {\n+\t\t\tt.Errorf(\"go run testdata/print_goroot.go:\\nhave %s\\nwant %s\", goroot, want)\n+\t\t} else {\n+\t\t\tt.Logf(\"go run testdata/print_goroot.go: %s\", goroot)\n+\t\t}\n+\t})\n }\n \n func TestNeedVersion(t *testing.T) {\n@@ -4158,7 +4567,8 @@ func TestUserOverrideFlags(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n-\ttg.parallel()\n+\t// Don't call tg.parallel, as creating override.h and override.a may\n+\t// confuse other tests.\n \ttg.tempFile(\"override.go\", `package main\n \n import \"C\"\n@@ -4169,77 +4579,30 @@ func GoFunc() {}\n func main() {}`)\n \ttg.creatingTemp(\"override.a\")\n \ttg.creatingTemp(\"override.h\")\n-\ttg.run(\"build\", \"-x\", \"-buildmode=c-archive\", \"-gcflags=-shared=false\", tg.path(\"override.go\"))\n+\ttg.run(\"build\", \"-x\", \"-buildmode=c-archive\", \"-gcflags=all=-shared=false\", tg.path(\"override.go\"))\n \ttg.grepStderr(\"compile .*-shared .*-shared=false\", \"user can not override code generation flag\")\n }\n \n func TestCgoFlagContainsSpace(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n-\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n-\tccName := filepath.Base(testCC)\n-\n-\ttg.tempFile(fmt.Sprintf(\"src/%s/main.go\", ccName), fmt.Sprintf(`package main\n-\t\timport (\n-\t\t\t\"os\"\n-\t\t\t\"os/exec\"\n-\t\t\t\"path/filepath\"\n-\t\t\t\"strings\"\n-\t\t)\n-\n-\t\tfunc main() {\n-\t\t\tcmd := exec.Command(%q, os.Args[1:]...)\n-\t\t\tcmd.Stdin = os.Stdin\n-\t\t\tcmd.Stdout = os.Stdout\n-\t\t\tcmd.Stderr = os.Stderr\n-\t\t\terr := cmd.Run()\n-\t\t\tif err != nil {\n-\t\t\t\tpanic(err)\n-\t\t\t}\n-\n-\t\t\tif os.Args[len(os.Args)-1] == \"trivial.c\" {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif filepath.Base(os.Args[len(os.Args)-1]) == \"_cgo_defun.c\" {\n-\t\t\t\treturn\n-\t\t\t}\n-\n-\t\t\tvar success bool\n-\t\t\tfor _, arg := range os.Args {\n-\t\t\t\tswitch {\n-\t\t\t\tcase strings.Contains(arg, \"c flags\"):\n-\t\t\t\t\tif success {\n-\t\t\t\t\t\tpanic(\"duplicate CFLAGS\")\n-\t\t\t\t\t}\n-\t\t\t\t\tsuccess = true\n-\t\t\t\tcase strings.Contains(arg, \"ld flags\"):\n-\t\t\t\t\tif success {\n-\t\t\t\t\t\tpanic(\"duplicate LDFLAGS\")\n-\t\t\t\t\t}\n-\t\t\t\t\tsuccess = true\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif !success {\n-\t\t\t\tpanic(\"args should contains '-Ic flags' or '-Lld flags'\")\n-\t\t\t}\n-\t\t}\n-\t`, testCC))\n-\ttg.cd(tg.path(fmt.Sprintf(\"src/%s\", ccName)))\n-\ttg.run(\"build\")\n-\ttg.setenv(\"CC\", tg.path(fmt.Sprintf(\"src/%s/%s\", ccName, ccName)))\n-\n-\ttg.tempFile(\"src/cgo/main.go\", `package main\n+\ttg.makeTempdir()\n+\ttg.cd(tg.path(\".\"))\n+\ttg.tempFile(\"main.go\", `package main\n \t\t// #cgo CFLAGS: -I\"c flags\"\n \t\t// #cgo LDFLAGS: -L\"ld flags\"\n \t\timport \"C\"\n \t\tfunc main() {}\n \t`)\n-\ttg.cd(tg.path(\"src/cgo\"))\n-\ttg.run(\"run\", \"main.go\")\n+\ttg.run(\"run\", \"-x\", \"main.go\")\n+\ttg.grepStderr(`\"-I[^\"]+c flags\"`, \"did not find quoted c flags\")\n+\ttg.grepStderrNot(`\"-I[^\"]+c flags\".*\"-I[^\"]+c flags\"`, \"found too many quoted c flags\")\n+\ttg.grepStderr(`\"-L[^\"]+ld flags\"`, \"did not find quoted ld flags\")\n+\ttg.grepStderrNot(`\"-L[^\"]+c flags\".*\"-L[^\"]+c flags\"`, \"found too many quoted ld flags\")\n }\n \n // Issue #20435.\n@@ -4280,7 +4643,7 @@ func main() {}`)\n \t\t\tbefore()\n \t\t\ttg.run(\"install\", \"mycmd\")\n \t\t\tafter()\n-\t\t\ttg.wantStale(\"mycmd\", \"build ID mismatch\", \"should be stale after environment variable change\")\n+\t\t\ttg.wantStale(\"mycmd\", \"stale dependency: runtime/internal/sys\", \"should be stale after environment variable change\")\n \t\t}\n \t}\n \n@@ -4373,3 +4736,665 @@ func TestListTests(t *testing.T) {\n \tt.Run(\"Example1\", testWith(\"Example\", \"ExampleSimple\"))\n \tt.Run(\"Example2\", testWith(\"Example\", \"ExampleWithEmptyOutput\"))\n }\n+\n+func TestBuildmodePIE(t *testing.T) {\n+\tplatform := fmt.Sprintf(\"%s/%s\", runtime.GOOS, runtime.GOARCH)\n+\tswitch platform {\n+\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\",\n+\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\":\n+\tcase \"darwin/amd64\":\n+\tdefault:\n+\t\tt.Skipf(\"skipping test because buildmode=pie is not supported on %s\", platform)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"main.go\", `package main; func main() { print(\"hello\") }`)\n+\tsrc := tg.path(\"main.go\")\n+\tobj := tg.path(\"main\")\n+\ttg.run(\"build\", \"-buildmode=pie\", \"-o\", obj, src)\n+\n+\tswitch runtime.GOOS {\n+\tcase \"linux\", \"android\":\n+\t\tf, err := elf.Open(obj)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tif f.Type != elf.ET_DYN {\n+\t\t\tt.Errorf(\"PIE type must be ET_DYN, but %s\", f.Type)\n+\t\t}\n+\tcase \"darwin\":\n+\t\tf, err := macho.Open(obj)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer f.Close()\n+\t\tif f.Flags&macho.FlagDyldLink == 0 {\n+\t\t\tt.Error(\"PIE must have DyldLink flag, but not\")\n+\t\t}\n+\t\tif f.Flags&macho.FlagPIE == 0 {\n+\t\t\tt.Error(\"PIE must have PIE flag, but not\")\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"unreachable\")\n+\t}\n+\n+\tout, err := exec.Command(obj).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif string(out) != \"hello\" {\n+\t\tt.Errorf(\"got %q; want %q\", out, \"hello\")\n+\t}\n+}\n+\n+func TestExecBuildX(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n+\t\tt.Skipf(\"skipping because unix shell is not supported on %s\", runtime.GOOS)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"main.go\", `package main; import \"C\"; func main() { print(\"hello\") }`)\n+\tsrc := tg.path(\"main.go\")\n+\tobj := tg.path(\"main\")\n+\ttg.run(\"build\", \"-x\", \"-o\", obj, src)\n+\tsh := tg.path(\"test.sh\")\n+\terr := ioutil.WriteFile(sh, []byte(tg.getStderr()), 0666)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tout, err := exec.Command(obj).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(out) != \"hello\" {\n+\t\tt.Fatalf(\"got %q; want %q\", out, \"hello\")\n+\t}\n+\n+\terr = os.Remove(obj)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tout, err = exec.Command(\"/usr/bin/env\", \"bash\", \"-x\", sh).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"/bin/sh %s: %v\\n%s\", sh, err, out)\n+\t}\n+\tt.Logf(\"shell output:\\n%s\", out)\n+\n+\tout, err = exec.Command(obj).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(out) != \"hello\" {\n+\t\tt.Fatalf(\"got %q; want %q\", out, \"hello\")\n+\t}\n+}\n+\n+func TestParallelNumber(t *testing.T) {\n+\tfor _, n := range [...]string{\"-1\", \"0\"} {\n+\t\tt.Run(n, func(t *testing.T) {\n+\t\t\ttg := testgo(t)\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.runFail(\"test\", \"-parallel\", n, \"testdata/standalone_parallel_sub_test.go\")\n+\t\t\ttg.grepBoth(\"-parallel can only be given\", \"go test -parallel with N<1 did not error\")\n+\t\t})\n+\t}\n+}\n+\n+func TestWrongGOOSErrorBeforeLoadError(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo assumes cross-compilation is always possible\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.setenv(\"GOOS\", \"windwos\")\n+\ttg.runFail(\"build\", \"exclude\")\n+\ttg.grepStderr(\"unsupported GOOS/GOARCH pair\", \"GOOS=windwos go build exclude did not report 'unsupported GOOS/GOARCH pair'\")\n+}\n+\n+func TestUpxCompression(t *testing.T) {\n+\tif runtime.GOOS != \"linux\" || runtime.GOARCH != \"amd64\" {\n+\t\tt.Skipf(\"skipping upx test on %s/%s\", runtime.GOOS, runtime.GOARCH)\n+\t}\n+\n+\tout, err := exec.Command(\"upx\", \"--version\").CombinedOutput()\n+\tif err != nil {\n+\t\tt.Skip(\"skipping because upx is not available\")\n+\t}\n+\n+\t// upx --version prints `upx <version>` in the first line of output:\n+\t//   upx 3.94\n+\t//   [...]\n+\tre := regexp.MustCompile(`([[:digit:]]+)\\.([[:digit:]]+)`)\n+\tupxVersion := re.FindStringSubmatch(string(out))\n+\tif len(upxVersion) != 3 {\n+\t\tt.Errorf(\"bad upx version string: %s\", upxVersion)\n+\t}\n+\n+\tmajor, err1 := strconv.Atoi(upxVersion[1])\n+\tminor, err2 := strconv.Atoi(upxVersion[2])\n+\tif err1 != nil || err2 != nil {\n+\t\tt.Errorf(\"bad upx version string: %s\", upxVersion[0])\n+\t}\n+\n+\t// Anything below 3.94 is known not to work with go binaries\n+\tif (major < 3) || (major == 3 && minor < 94) {\n+\t\tt.Skipf(\"skipping because upx version %v.%v is too old\", major, minor)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"main.go\", `package main; import \"fmt\"; func main() { fmt.Print(\"hello upx\") }`)\n+\tsrc := tg.path(\"main.go\")\n+\tobj := tg.path(\"main\")\n+\ttg.run(\"build\", \"-o\", obj, src)\n+\n+\tout, err = exec.Command(\"upx\", obj).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"executing upx\\n%s\\n\", out)\n+\t\tt.Fatalf(\"upx failed with %v\", err)\n+\t}\n+\n+\tout, err = exec.Command(obj).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatalf(\"running compressed go binary failed with error %s\", err)\n+\t}\n+\tif string(out) != \"hello upx\" {\n+\t\tt.Fatalf(\"bad output from compressed go binary:\\ngot %q; want %q\", out, \"hello upx\")\n+\t}\n+}\n+\n+func TestGOTMPDIR(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOTMPDIR\", tg.tempdir)\n+\ttg.setenv(\"GOCACHE\", \"off\")\n+\n+\t// complex/x is a trivial non-main package.\n+\ttg.run(\"build\", \"-work\", \"-x\", \"complex/w\")\n+\ttg.grepStderr(\"WORK=\"+regexp.QuoteMeta(tg.tempdir), \"did not work in $GOTMPDIR\")\n+}\n+\n+func TestBuildCache(t *testing.T) {\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\n+\t// complex/w is a trivial non-main package.\n+\t// It imports nothing, so there should be no Deps.\n+\ttg.run(\"list\", \"-f={{join .Deps \\\" \\\"}}\", \"complex/w\")\n+\ttg.grepStdoutNot(\".+\", \"complex/w depends on unexpected packages\")\n+\n+\ttg.run(\"build\", \"-x\", \"complex/w\")\n+\ttg.grepStderr(`[\\\\/]compile|gccgo`, \"did not run compiler\")\n+\n+\ttg.run(\"build\", \"-x\", \"complex/w\")\n+\ttg.grepStderrNot(`[\\\\/]compile|gccgo`, \"ran compiler incorrectly\")\n+\n+\ttg.run(\"build\", \"-a\", \"-x\", \"complex/w\")\n+\ttg.grepStderr(`[\\\\/]compile|gccgo`, \"did not run compiler with -a\")\n+\n+\t// complex is a non-trivial main package.\n+\t// the link step should not be cached.\n+\ttg.run(\"build\", \"-o\", os.DevNull, \"-x\", \"complex\")\n+\ttg.grepStderr(`[\\\\/]link|gccgo`, \"did not run linker\")\n+\n+\ttg.run(\"build\", \"-o\", os.DevNull, \"-x\", \"complex\")\n+\ttg.grepStderr(`[\\\\/]link|gccgo`, \"did not run linker\")\n+}\n+\n+func TestCacheOutput(t *testing.T) {\n+\t// Test that command output is cached and replayed too.\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\n+\ttg.run(\"build\", \"-gcflags=-m\", \"errors\")\n+\tstdout1 := tg.getStdout()\n+\tstderr1 := tg.getStderr()\n+\n+\ttg.run(\"build\", \"-gcflags=-m\", \"errors\")\n+\tstdout2 := tg.getStdout()\n+\tstderr2 := tg.getStderr()\n+\n+\tif stdout2 != stdout1 || stderr2 != stderr1 {\n+\t\tt.Errorf(\"cache did not reproduce output:\\n\\nstdout1:\\n%s\\n\\nstdout2:\\n%s\\n\\nstderr1:\\n%s\\n\\nstderr2:\\n%s\",\n+\t\t\tstdout1, stdout2, stderr1, stderr2)\n+\t}\n+}\n+\n+func TestCacheCoverage(t *testing.T) {\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.makeTempdir()\n+\n+\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"c1\"))\n+\ttg.run(\"test\", \"-cover\", \"strings\")\n+\ttg.run(\"test\", \"-cover\", \"math\", \"strings\")\n+}\n+\n+func TestIssue22588(t *testing.T) {\n+\t// Don't get confused by stderr coming from tools.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\tif _, err := os.Stat(\"/usr/bin/time\"); err != nil {\n+\t\tt.Skip(err)\n+\t}\n+\n+\ttg.run(\"list\", \"-f={{.Stale}}\", \"runtime\")\n+\ttg.run(\"list\", \"-toolexec=/usr/bin/time\", \"-f={{.Stale}}\", \"runtime\")\n+\ttg.grepStdout(\"false\", \"incorrectly reported runtime as stale\")\n+}\n+\n+func TestIssue22531(t *testing.T) {\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.tempdir)\n+\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"cache\"))\n+\ttg.tempFile(\"src/m/main.go\", \"package main /* c1 */; func main() {}\\n\")\n+\ttg.run(\"install\", \"-x\", \"m\")\n+\ttg.run(\"list\", \"-f\", \"{{.Stale}}\", \"m\")\n+\ttg.grepStdout(\"false\", \"reported m as stale after install\")\n+\ttg.run(\"tool\", \"buildid\", filepath.Join(tg.tempdir, \"bin/m\"+exeSuffix))\n+\n+\t// The link action ID did not include the full main build ID,\n+\t// even though the full main build ID is written into the\n+\t// eventual binary. That caused the following install to\n+\t// be a no-op, thinking the gofmt binary was up-to-date,\n+\t// even though .Stale could see it was not.\n+\ttg.tempFile(\"src/m/main.go\", \"package main /* c2 */; func main() {}\\n\")\n+\ttg.run(\"install\", \"-x\", \"m\")\n+\ttg.run(\"list\", \"-f\", \"{{.Stale}}\", \"m\")\n+\ttg.grepStdout(\"false\", \"reported m as stale after reinstall\")\n+\ttg.run(\"tool\", \"buildid\", filepath.Join(tg.tempdir, \"bin/m\"+exeSuffix))\n+}\n+\n+func TestIssue22596(t *testing.T) {\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"cache\"))\n+\ttg.tempFile(\"gopath1/src/p/p.go\", \"package p; func F(){}\\n\")\n+\ttg.tempFile(\"gopath2/src/p/p.go\", \"package p; func F(){}\\n\")\n+\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.tempdir, \"gopath1\"))\n+\ttg.run(\"list\", \"-f={{.Target}}\", \"p\")\n+\ttarget1 := strings.TrimSpace(tg.getStdout())\n+\ttg.run(\"install\", \"p\")\n+\ttg.wantNotStale(\"p\", \"\", \"p stale after install\")\n+\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.tempdir, \"gopath2\"))\n+\ttg.run(\"list\", \"-f={{.Target}}\", \"p\")\n+\ttarget2 := strings.TrimSpace(tg.getStdout())\n+\ttg.must(os.MkdirAll(filepath.Dir(target2), 0777))\n+\ttg.must(copyFile(target1, target2, 0666))\n+\ttg.wantStale(\"p\", \"build ID mismatch\", \"p not stale after copy from gopath1\")\n+\ttg.run(\"install\", \"p\")\n+\ttg.wantNotStale(\"p\", \"\", \"p stale after install2\")\n+}\n+\n+func TestTestCache(t *testing.T) {\n+\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n+\t\tt.Skip(\"GODEBUG gocacheverify\")\n+\t}\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.tempdir)\n+\ttg.setenv(\"GOCACHE\", filepath.Join(tg.tempdir, \"cache\"))\n+\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\t// timeout here should not affect result being cached\n+\t\t// or being retrieved later.\n+\t\ttg.run(\"test\", \"-x\", \"-timeout=10s\", \"errors\")\n+\t\ttg.grepStderr(`[\\\\/](compile|gccgo) `, \"did not run compiler\")\n+\t\ttg.grepStderr(`[\\\\/](link|gccgo) `, \"did not run linker\")\n+\t\ttg.grepStderr(`errors\\.test`, \"did not run test\")\n+\n+\t\ttg.run(\"test\", \"-x\", \"errors\")\n+\t\ttg.grepStdout(`ok  \\terrors\\t\\(cached\\)`, \"did not report cached result\")\n+\t\ttg.grepStderrNot(`[\\\\/](compile|gccgo) `, \"incorrectly ran compiler\")\n+\t\ttg.grepStderrNot(`[\\\\/](link|gccgo) `, \"incorrectly ran linker\")\n+\t\ttg.grepStderrNot(`errors\\.test`, \"incorrectly ran test\")\n+\t\ttg.grepStderrNot(\"DO NOT USE\", \"poisoned action status leaked\")\n+\n+\t\t// Even very low timeouts do not disqualify cached entries.\n+\t\ttg.run(\"test\", \"-timeout=1ns\", \"-x\", \"errors\")\n+\t\ttg.grepStderrNot(`errors\\.test`, \"incorrectly ran test\")\n+\n+\t\ttg.run(\"clean\", \"-testcache\")\n+\t\ttg.run(\"test\", \"-x\", \"errors\")\n+\t\ttg.grepStderr(`errors\\.test`, \"did not run test\")\n+\t}\n+\n+\t// The -p=1 in the commands below just makes the -x output easier to read.\n+\n+\tt.Log(\"\\n\\nINITIAL\\n\\n\")\n+\n+\ttg.tempFile(\"src/p1/p1.go\", \"package p1\\nvar X =  1\\n\")\n+\ttg.tempFile(\"src/p2/p2.go\", \"package p2\\nimport _ \\\"p1\\\"\\nvar X = 1\\n\")\n+\ttg.tempFile(\"src/t/t1/t1_test.go\", \"package t\\nimport \\\"testing\\\"\\nfunc Test1(*testing.T) {}\\n\")\n+\ttg.tempFile(\"src/t/t2/t2_test.go\", \"package t\\nimport _ \\\"p1\\\"\\nimport \\\"testing\\\"\\nfunc Test2(*testing.T) {}\\n\")\n+\ttg.tempFile(\"src/t/t3/t3_test.go\", \"package t\\nimport \\\"p1\\\"\\nimport \\\"testing\\\"\\nfunc Test3(t *testing.T) {t.Log(p1.X)}\\n\")\n+\ttg.tempFile(\"src/t/t4/t4_test.go\", \"package t\\nimport \\\"p2\\\"\\nimport \\\"testing\\\"\\nfunc Test4(t *testing.T) {t.Log(p2.X)}\")\n+\ttg.run(\"test\", \"-x\", \"-v\", \"-short\", \"t/...\")\n+\n+\tt.Log(\"\\n\\nREPEAT\\n\\n\")\n+\n+\ttg.run(\"test\", \"-x\", \"-v\", \"-short\", \"t/...\")\n+\ttg.grepStdout(`ok  \\tt/t1\\t\\(cached\\)`, \"did not cache t1\")\n+\ttg.grepStdout(`ok  \\tt/t2\\t\\(cached\\)`, \"did not cache t2\")\n+\ttg.grepStdout(`ok  \\tt/t3\\t\\(cached\\)`, \"did not cache t3\")\n+\ttg.grepStdout(`ok  \\tt/t4\\t\\(cached\\)`, \"did not cache t4\")\n+\ttg.grepStderrNot(`[\\\\/](compile|gccgo) `, \"incorrectly ran compiler\")\n+\ttg.grepStderrNot(`[\\\\/](link|gccgo) `, \"incorrectly ran linker\")\n+\ttg.grepStderrNot(`p[0-9]\\.test`, \"incorrectly ran test\")\n+\n+\tt.Log(\"\\n\\nCOMMENT\\n\\n\")\n+\n+\t// Changing the program text without affecting the compiled package\n+\t// should result in the package being rebuilt but nothing more.\n+\ttg.tempFile(\"src/p1/p1.go\", \"package p1\\nvar X = 01\\n\")\n+\ttg.run(\"test\", \"-p=1\", \"-x\", \"-v\", \"-short\", \"t/...\")\n+\ttg.grepStdout(`ok  \\tt/t1\\t\\(cached\\)`, \"did not cache t1\")\n+\ttg.grepStdout(`ok  \\tt/t2\\t\\(cached\\)`, \"did not cache t2\")\n+\ttg.grepStdout(`ok  \\tt/t3\\t\\(cached\\)`, \"did not cache t3\")\n+\ttg.grepStdout(`ok  \\tt/t4\\t\\(cached\\)`, \"did not cache t4\")\n+\ttg.grepStderrNot(`([\\\\/](compile|gccgo) ).*t[0-9]_test\\.go`, \"incorrectly ran compiler\")\n+\ttg.grepStderrNot(`[\\\\/](link|gccgo) `, \"incorrectly ran linker\")\n+\ttg.grepStderrNot(`t[0-9]\\.test.*test\\.short`, \"incorrectly ran test\")\n+\n+\tt.Log(\"\\n\\nCHANGE\\n\\n\")\n+\n+\t// Changing the actual package should have limited effects.\n+\ttg.tempFile(\"src/p1/p1.go\", \"package p1\\nvar X = 02\\n\")\n+\ttg.run(\"test\", \"-p=1\", \"-x\", \"-v\", \"-short\", \"t/...\")\n+\n+\t// p2 should have been rebuilt.\n+\ttg.grepStderr(`([\\\\/]compile|gccgo).*p2.go`, \"did not recompile p2\")\n+\n+\t// t1 does not import anything, should not have been rebuilt.\n+\ttg.grepStderrNot(`([\\\\/]compile|gccgo).*t1_test.go`, \"incorrectly recompiled t1\")\n+\ttg.grepStderrNot(`([\\\\/]link|gccgo).*t1_test`, \"incorrectly relinked t1_test\")\n+\ttg.grepStdout(`ok  \\tt/t1\\t\\(cached\\)`, \"did not cache t/t1\")\n+\n+\t// t2 imports p1 and must be rebuilt and relinked,\n+\t// but the change should not have any effect on the test binary,\n+\t// so the test should not have been rerun.\n+\ttg.grepStderr(`([\\\\/]compile|gccgo).*t2_test.go`, \"did not recompile t2\")\n+\ttg.grepStderr(`([\\\\/]link|gccgo).*t2\\.test`, \"did not relink t2_test\")\n+\t// This check does not currently work with gccgo, as garbage\n+\t// collection of unused variables is not turned on by default.\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\ttg.grepStdout(`ok  \\tt/t2\\t\\(cached\\)`, \"did not cache t/t2\")\n+\t}\n+\n+\t// t3 imports p1, and changing X changes t3's test binary.\n+\ttg.grepStderr(`([\\\\/]compile|gccgo).*t3_test.go`, \"did not recompile t3\")\n+\ttg.grepStderr(`([\\\\/]link|gccgo).*t3\\.test`, \"did not relink t3_test\")\n+\ttg.grepStderr(`t3\\.test.*-test.short`, \"did not rerun t3_test\")\n+\ttg.grepStdoutNot(`ok  \\tt/t3\\t\\(cached\\)`, \"reported cached t3_test result\")\n+\n+\t// t4 imports p2, but p2 did not change, so t4 should be relinked, not recompiled,\n+\t// and not rerun.\n+\ttg.grepStderrNot(`([\\\\/]compile|gccgo).*t4_test.go`, \"incorrectly recompiled t4\")\n+\ttg.grepStderr(`([\\\\/]link|gccgo).*t4\\.test`, \"did not relink t4_test\")\n+\t// This check does not currently work with gccgo, as garbage\n+\t// collection of unused variables is not turned on by default.\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\ttg.grepStdout(`ok  \\tt/t4\\t\\(cached\\)`, \"did not cache t/t4\")\n+\t}\n+}\n+\n+func TestTestVet(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.tempFile(\"p1_test.go\", `\n+\t\tpackage p\n+\t\timport \"testing\"\n+\t\tfunc Test(t *testing.T) {\n+\t\t\tt.Logf(\"%d\") // oops\n+\t\t}\n+\t`)\n+\n+\ttg.runFail(\"test\", filepath.Join(tg.tempdir, \"p1_test.go\"))\n+\ttg.grepStderr(`Logf format %d`, \"did not diagnose bad Logf\")\n+\ttg.run(\"test\", \"-vet=off\", filepath.Join(tg.tempdir, \"p1_test.go\"))\n+\ttg.grepStdout(`^ok`, \"did not print test summary\")\n+\n+\ttg.tempFile(\"p1.go\", `\n+\t\tpackage p\n+\t\timport \"fmt\"\n+\t\tfunc F() {\n+\t\t\tfmt.Printf(\"%d\") // oops\n+\t\t}\n+\t`)\n+\ttg.runFail(\"test\", filepath.Join(tg.tempdir, \"p1.go\"))\n+\ttg.grepStderr(`Printf format %d`, \"did not diagnose bad Printf\")\n+\ttg.run(\"test\", \"-x\", \"-vet=shift\", filepath.Join(tg.tempdir, \"p1.go\"))\n+\ttg.grepStderr(`[\\\\/]vet.*-shift`, \"did not run vet with -shift\")\n+\ttg.grepStdout(`\\[no test files\\]`, \"did not print test summary\")\n+\ttg.run(\"test\", \"-vet=off\", filepath.Join(tg.tempdir, \"p1.go\"))\n+\ttg.grepStdout(`\\[no test files\\]`, \"did not print test summary\")\n+\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"vetcycle\") // must not fail; #22890\n+}\n+\n+func TestInstallDeps(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.tempdir)\n+\n+\ttg.tempFile(\"src/p1/p1.go\", \"package p1\\nvar X =  1\\n\")\n+\ttg.tempFile(\"src/p2/p2.go\", \"package p2\\nimport _ \\\"p1\\\"\\n\")\n+\ttg.tempFile(\"src/main1/main.go\", \"package main\\nimport _ \\\"p2\\\"\\nfunc main() {}\\n\")\n+\n+\ttg.run(\"list\", \"-f={{.Target}}\", \"p1\")\n+\tp1 := strings.TrimSpace(tg.getStdout())\n+\ttg.run(\"list\", \"-f={{.Target}}\", \"p2\")\n+\tp2 := strings.TrimSpace(tg.getStdout())\n+\ttg.run(\"list\", \"-f={{.Target}}\", \"main1\")\n+\tmain1 := strings.TrimSpace(tg.getStdout())\n+\n+\ttg.run(\"install\", \"main1\")\n+\n+\ttg.mustExist(main1)\n+\ttg.mustNotExist(p2)\n+\ttg.mustNotExist(p1)\n+\n+\ttg.run(\"install\", \"p2\")\n+\ttg.mustExist(p2)\n+\ttg.mustNotExist(p1)\n+\n+\t// don't let install -i overwrite runtime\n+\ttg.wantNotStale(\"runtime\", \"\", \"must be non-stale before install -i\")\n+\n+\ttg.run(\"install\", \"-i\", \"main1\")\n+\ttg.mustExist(p1)\n+\ttg.must(os.Remove(p1))\n+\n+\ttg.run(\"install\", \"-i\", \"p2\")\n+\ttg.mustExist(p1)\n+}\n+\n+func TestFmtLoadErrors(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"fmt\", \"does-not-exist\")\n+\ttg.run(\"fmt\", \"-n\", \"exclude\")\n+}\n+\n+func TestRelativePkgdir(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", \"off\")\n+\ttg.cd(tg.tempdir)\n+\n+\ttg.run(\"build\", \"-i\", \"-pkgdir=.\", \"runtime\")\n+}\n+\n+func TestGcflagsPatterns(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", \"\")\n+\ttg.setenv(\"GOCACHE\", \"off\")\n+\n+\ttg.run(\"build\", \"-v\", \"-gcflags= \\t\\r\\n -e\", \"fmt\")\n+\ttg.grepStderr(\"fmt\", \"did not rebuild fmt\")\n+\ttg.grepStderrNot(\"reflect\", \"incorrectly rebuilt reflect\")\n+\n+\ttg.run(\"build\", \"-v\", \"-gcflags=-e\", \"fmt\", \"reflect\")\n+\ttg.grepStderr(\"fmt\", \"did not rebuild fmt\")\n+\ttg.grepStderr(\"reflect\", \"did not rebuild reflect\")\n+\ttg.grepStderrNot(\"runtime\", \"incorrectly rebuilt runtime\")\n+\n+\ttg.run(\"build\", \"-x\", \"-v\", \"-gcflags= \\t\\r\\n reflect \\t\\r\\n = \\t\\r\\n -N\", \"fmt\")\n+\ttg.grepStderr(\"fmt\", \"did not rebuild fmt\")\n+\ttg.grepStderr(\"reflect\", \"did not rebuild reflect\")\n+\ttg.grepStderr(\"compile.* -N .*-p reflect\", \"did not build reflect with -N flag\")\n+\ttg.grepStderrNot(\"compile.* -N .*-p fmt\", \"incorrectly built fmt with -N flag\")\n+\n+\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=-N\", \"strings\")\n+\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not build strings_test package with -N flag\")\n+\n+\ttg.run(\"test\", \"-c\", \"-n\", \"-gcflags=strings=-N\", \"strings\")\n+\ttg.grepStderr(\"compile.* -N .*compare_test.go\", \"did not build strings_test package with -N flag\")\n+}\n+\n+func TestGoTestMinusN(t *testing.T) {\n+\t// Intent here is to verify that 'go test -n' works without crashing.\n+\t// This reuses flag_test.go, but really any test would do.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"testdata/flag_test.go\", \"-n\", \"-args\", \"-v=7\")\n+}\n+\n+func TestGoTestJSON(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not have standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOCACHE\", tg.tempdir)\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\t// It would be nice to test that the output is interlaced\n+\t// but it seems to be impossible to do that in a short test\n+\t// that isn't also flaky. Just check that we get JSON output.\n+\ttg.run(\"test\", \"-json\", \"-short\", \"-v\", \"errors\", \"empty/pkg\", \"skipper\")\n+\ttg.grepStdout(`\"Package\":\"errors\"`, \"did not see JSON output\")\n+\ttg.grepStdout(`\"Action\":\"run\"`, \"did not see JSON output\")\n+\n+\ttg.grepStdout(`\"Action\":\"output\",\"Package\":\"empty/pkg\",\"Output\":\".*no test files`, \"did not see no test files print\")\n+\ttg.grepStdout(`\"Action\":\"skip\",\"Package\":\"empty/pkg\"`, \"did not see skip\")\n+\n+\ttg.grepStdout(`\"Action\":\"output\",\"Package\":\"skipper\",\"Test\":\"Test\",\"Output\":\"--- SKIP:`, \"did not see SKIP output\")\n+\ttg.grepStdout(`\"Action\":\"skip\",\"Package\":\"skipper\",\"Test\":\"Test\"`, \"did not see skip result for Test\")\n+\n+\ttg.run(\"test\", \"-json\", \"-bench=NONE\", \"-short\", \"-v\", \"errors\")\n+\ttg.grepStdout(`\"Package\":\"errors\"`, \"did not see JSON output\")\n+\ttg.grepStdout(`\"Action\":\"run\"`, \"did not see JSON output\")\n+\n+\ttg.run(\"test\", \"-o\", filepath.Join(tg.tempdir, \"errors.test.exe\"), \"-c\", \"errors\")\n+\ttg.run(\"tool\", \"test2json\", \"-p\", \"errors\", filepath.Join(tg.tempdir, \"errors.test.exe\"), \"-test.v\", \"-test.short\")\n+\ttg.grepStdout(`\"Package\":\"errors\"`, \"did not see JSON output\")\n+\ttg.grepStdout(`\"Action\":\"run\"`, \"did not see JSON output\")\n+\ttg.grepStdout(`\\{\"Action\":\"pass\",\"Package\":\"errors\"\\}`, \"did not see final pass\")\n+}\n+\n+func TestFailFast(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttests := []struct {\n+\t\trun      string\n+\t\tfailfast bool\n+\t\tnfail    int\n+\t}{\n+\t\t{\"TestFailingA\", true, 1},\n+\t\t{\"TestFailing[AB]\", true, 1},\n+\t\t{\"TestFailing[AB]\", false, 2},\n+\t\t// mix with non-failing tests:\n+\t\t{\"TestA|TestFailing[AB]\", true, 1},\n+\t\t{\"TestA|TestFailing[AB]\", false, 2},\n+\t\t// mix with parallel tests:\n+\t\t{\"TestFailingB|TestParallelFailingA\", true, 2},\n+\t\t{\"TestFailingB|TestParallelFailingA\", false, 2},\n+\t\t{\"TestFailingB|TestParallelFailing[AB]\", true, 3},\n+\t\t{\"TestFailingB|TestParallelFailing[AB]\", false, 3},\n+\t\t// mix with parallel sub-tests\n+\t\t{\"TestFailingB|TestParallelFailing[AB]|TestParallelFailingSubtestsA\", true, 3},\n+\t\t{\"TestFailingB|TestParallelFailing[AB]|TestParallelFailingSubtestsA\", false, 5},\n+\t\t{\"TestParallelFailingSubtestsA\", true, 1},\n+\t\t// only parallels:\n+\t\t{\"TestParallelFailing[AB]\", false, 2},\n+\t\t// non-parallel subtests:\n+\t\t{\"TestFailingSubtestsA\", true, 1},\n+\t\t{\"TestFailingSubtestsA\", false, 2},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.run, func(t *testing.T) {\n+\t\t\ttg.runFail(\"test\", \"./testdata/src/failfast_test.go\", \"-run=\"+tt.run, \"-failfast=\"+strconv.FormatBool(tt.failfast))\n+\n+\t\t\tnfail := strings.Count(tg.getStdout(), \"FAIL - \")\n+\n+\t\t\tif nfail != tt.nfail {\n+\t\t\t\tt.Errorf(\"go test -run=%s -failfast=%t printed %d FAILs, want %d\", tt.run, tt.failfast, nfail, tt.nfail)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "aa68a195802aea70108138fcad1a97aafe4ec299", "filename": "libgo/go/cmd/go/go_windows_test.go", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -5,12 +5,14 @@\n package main\n \n import (\n+\t\"fmt\"\n \t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n+\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -54,3 +56,82 @@ func TestAbsolutePath(t *testing.T) {\n \t\tt.Fatalf(\"wrong output found: %v %v\", err, string(output))\n \t}\n }\n+\n+func isWindowsXP(t *testing.T) bool {\n+\tv, err := syscall.GetVersion()\n+\tif err != nil {\n+\t\tt.Fatalf(\"GetVersion failed: %v\", err)\n+\t}\n+\tmajor := byte(v)\n+\treturn major < 6\n+}\n+\n+func runIcacls(t *testing.T, args ...string) string {\n+\tt.Helper()\n+\tout, err := exec.Command(\"icacls\", args...).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"icacls failed: %v\\n%v\", err, string(out))\n+\t}\n+\treturn string(out)\n+}\n+\n+func runGetACL(t *testing.T, path string) string {\n+\tt.Helper()\n+\tcmd := fmt.Sprintf(`Get-Acl \"%s\" | Select -expand AccessToString`, path)\n+\tout, err := exec.Command(\"powershell\", \"-Command\", cmd).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get-Acl failed: %v\\n%v\", err, string(out))\n+\t}\n+\treturn string(out)\n+}\n+\n+// For issue 22343: verify that executable file created by \"go build\" command\n+// has discretionary access control list (DACL) set as if the file\n+// was created in the destination directory.\n+func TestACL(t *testing.T) {\n+\tif isWindowsXP(t) {\n+\t\tt.Skip(\"Windows XP does not have powershell command\")\n+\t}\n+\n+\ttmpdir, err := ioutil.TempDir(\"\", \"TestACL\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmpdir)\n+\n+\tnewtmpdir := filepath.Join(tmpdir, \"tmp\")\n+\terr = os.Mkdir(newtmpdir, 0777)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// When TestACL/tmp directory is created, it will have\n+\t// the same security attributes as TestACL.\n+\t// Add Guest account full access to TestACL/tmp - this\n+\t// will make all files created in TestACL/tmp have different\n+\t// security attributes to the files created in TestACL.\n+\trunIcacls(t, newtmpdir,\n+\t\t\"/grant\", \"guest:(oi)(ci)f\", // add Guest user to have full access\n+\t)\n+\n+\tsrc := filepath.Join(tmpdir, \"main.go\")\n+\terr = ioutil.WriteFile(src, []byte(\"package main; func main() { }\\n\"), 0644)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\texe := filepath.Join(tmpdir, \"main.exe\")\n+\tcmd := exec.Command(testenv.GoToolPath(t), \"build\", \"-o\", exe, src)\n+\tcmd.Env = append(os.Environ(),\n+\t\t\"TMP=\"+newtmpdir,\n+\t\t\"TEMP=\"+newtmpdir,\n+\t)\n+\tout, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"go command failed: %v\\n%v\", err, string(out))\n+\t}\n+\n+\t// exe file is expected to have the same security attributes as the src.\n+\tif got, expected := runGetACL(t, exe), runGetACL(t, src); got != expected {\n+\t\tt.Fatalf(\"expected Get-Acl output of \\n%v\\n, got \\n%v\\n\", expected, got)\n+\t}\n+}"}, {"sha": "286efbc04104177167afed208168662f1efba1d8", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -62,8 +62,8 @@ func (c *Command) Name() string {\n }\n \n func (c *Command) Usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\\n\", c.UsageLine)\n-\tfmt.Fprintf(os.Stderr, \"%s\\n\", strings.TrimSpace(c.Long))\n+\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", c.UsageLine)\n+\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' for details.\\n\", c.Name())\n \tos.Exit(2)\n }\n "}, {"sha": "7a51181c9736e9cdf8549a7192f9bdcf67f419ce", "filename": "libgo/go/cmd/go/internal/base/path.go", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -44,28 +44,6 @@ func RelPaths(paths []string) []string {\n \treturn out\n }\n \n-// FilterDotUnderscoreFiles returns a slice containing all elements\n-// of path whose base name doesn't begin with \".\" or \"_\".\n-func FilterDotUnderscoreFiles(path []string) []string {\n-\tvar out []string // lazily initialized\n-\tfor i, p := range path {\n-\t\tbase := filepath.Base(p)\n-\t\tif strings.HasPrefix(base, \".\") || strings.HasPrefix(base, \"_\") {\n-\t\t\tif out == nil {\n-\t\t\t\tout = append(make([]string, 0, len(path)), path[:i]...)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif out != nil {\n-\t\t\tout = append(out, p)\n-\t\t}\n-\t}\n-\tif out == nil {\n-\t\treturn path\n-\t}\n-\treturn out\n-}\n-\n // IsTestFile reports whether the source file is a set of tests and should therefore\n // be excluded from coverage analysis.\n func IsTestFile(file string) bool {"}, {"sha": "d0da65e03ced64a930867913843e534dd5701bd9", "filename": "libgo/go/cmd/go/internal/base/tool.go", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -36,18 +36,9 @@ func Tool(toolName string) string {\n \t}\n \t// Give a nice message if there is no tool with that name.\n \tif _, err := os.Stat(toolPath); err != nil {\n-\t\tif isInGoToolsRepo(toolName) {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q; to install:\\n\\tgo get golang.org/x/tools/cmd/%s\\n\", toolName, toolName)\n-\t\t} else {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n-\t\t}\n+\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n \t\tSetExitStatus(2)\n \t\tExit()\n \t}\n \treturn toolPath\n }\n-\n-// TODO: Delete.\n-func isInGoToolsRepo(toolName string) bool {\n-\treturn false\n-}"}, {"sha": "794d63d20b0378a6a44b67b63a7e8f87153d1eb7", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,453 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cache implements a build artifact cache.\n+package cache\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// An ActionID is a cache action key, the hash of a complete description of a\n+// repeatable computation (command line, environment variables,\n+// input file contents, executable contents).\n+type ActionID [HashSize]byte\n+\n+// An OutputID is a cache output key, the hash of an output of a computation.\n+type OutputID [HashSize]byte\n+\n+// A Cache is a package cache, backed by a file system directory tree.\n+type Cache struct {\n+\tdir string\n+\tlog *os.File\n+\tnow func() time.Time\n+}\n+\n+// Open opens and returns the cache in the given directory.\n+//\n+// It is safe for multiple processes on a single machine to use the\n+// same cache directory in a local file system simultaneously.\n+// They will coordinate using operating system file locks and may\n+// duplicate effort but will not corrupt the cache.\n+//\n+// However, it is NOT safe for multiple processes on different machines\n+// to share a cache directory (for example, if the directory were stored\n+// in a network file system). File locking is notoriously unreliable in\n+// network file systems and may not suffice to protect the cache.\n+//\n+func Open(dir string) (*Cache, error) {\n+\tinfo, err := os.Stat(dir)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif !info.IsDir() {\n+\t\treturn nil, &os.PathError{Op: \"open\", Path: dir, Err: fmt.Errorf(\"not a directory\")}\n+\t}\n+\tfor i := 0; i < 256; i++ {\n+\t\tname := filepath.Join(dir, fmt.Sprintf(\"%02x\", i))\n+\t\tif err := os.MkdirAll(name, 0777); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tf, err := os.OpenFile(filepath.Join(dir, \"log.txt\"), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tc := &Cache{\n+\t\tdir: dir,\n+\t\tlog: f,\n+\t\tnow: time.Now,\n+\t}\n+\treturn c, nil\n+}\n+\n+// fileName returns the name of the file corresponding to the given id.\n+func (c *Cache) fileName(id [HashSize]byte, key string) string {\n+\treturn filepath.Join(c.dir, fmt.Sprintf(\"%02x\", id[0]), fmt.Sprintf(\"%x\", id)+\"-\"+key)\n+}\n+\n+var errMissing = errors.New(\"cache entry not found\")\n+\n+const (\n+\t// action entry file is \"v1 <hex id> <hex out> <decimal size space-padded to 20 bytes> <unixnano space-padded to 20 bytes>\\n\"\n+\thexSize   = HashSize * 2\n+\tentrySize = 2 + 1 + hexSize + 1 + hexSize + 1 + 20 + 1 + 20 + 1\n+)\n+\n+// verify controls whether to run the cache in verify mode.\n+// In verify mode, the cache always returns errMissing from Get\n+// but then double-checks in Put that the data being written\n+// exactly matches any existing entry. This provides an easy\n+// way to detect program behavior that would have been different\n+// had the cache entry been returned from Get.\n+//\n+// verify is enabled by setting the environment variable\n+// GODEBUG=gocacheverify=1.\n+var verify = false\n+\n+func init() { initEnv() }\n+\n+func initEnv() {\n+\tverify = false\n+\tdebugHash = false\n+\tdebug := strings.Split(os.Getenv(\"GODEBUG\"), \",\")\n+\tfor _, f := range debug {\n+\t\tif f == \"gocacheverify=1\" {\n+\t\t\tverify = true\n+\t\t}\n+\t\tif f == \"gocachehash=1\" {\n+\t\t\tdebugHash = true\n+\t\t}\n+\t}\n+}\n+\n+// Get looks up the action ID in the cache,\n+// returning the corresponding output ID and file size, if any.\n+// Note that finding an output ID does not guarantee that the\n+// saved file for that output ID is still available.\n+func (c *Cache) Get(id ActionID) (Entry, error) {\n+\tif verify {\n+\t\treturn Entry{}, errMissing\n+\t}\n+\treturn c.get(id)\n+}\n+\n+type Entry struct {\n+\tOutputID OutputID\n+\tSize     int64\n+\tTime     time.Time\n+}\n+\n+// get is Get but does not respect verify mode, so that Put can use it.\n+func (c *Cache) get(id ActionID) (Entry, error) {\n+\tmissing := func() (Entry, error) {\n+\t\tfmt.Fprintf(c.log, \"%d miss %x\\n\", c.now().Unix(), id)\n+\t\treturn Entry{}, errMissing\n+\t}\n+\tf, err := os.Open(c.fileName(id, \"a\"))\n+\tif err != nil {\n+\t\treturn missing()\n+\t}\n+\tdefer f.Close()\n+\tentry := make([]byte, entrySize+1) // +1 to detect whether f is too long\n+\tif n, err := io.ReadFull(f, entry); n != entrySize || err != io.ErrUnexpectedEOF {\n+\t\treturn missing()\n+\t}\n+\tif entry[0] != 'v' || entry[1] != '1' || entry[2] != ' ' || entry[3+hexSize] != ' ' || entry[3+hexSize+1+hexSize] != ' ' || entry[3+hexSize+1+hexSize+1+20] != ' ' || entry[entrySize-1] != '\\n' {\n+\t\treturn missing()\n+\t}\n+\teid, entry := entry[3:3+hexSize], entry[3+hexSize:]\n+\teout, entry := entry[1:1+hexSize], entry[1+hexSize:]\n+\tesize, entry := entry[1:1+20], entry[1+20:]\n+\tetime, entry := entry[1:1+20], entry[1+20:]\n+\tvar buf [HashSize]byte\n+\tif _, err := hex.Decode(buf[:], eid); err != nil || buf != id {\n+\t\treturn missing()\n+\t}\n+\tif _, err := hex.Decode(buf[:], eout); err != nil {\n+\t\treturn missing()\n+\t}\n+\ti := 0\n+\tfor i < len(esize) && esize[i] == ' ' {\n+\t\ti++\n+\t}\n+\tsize, err := strconv.ParseInt(string(esize[i:]), 10, 64)\n+\tif err != nil || size < 0 {\n+\t\treturn missing()\n+\t}\n+\ti = 0\n+\tfor i < len(etime) && etime[i] == ' ' {\n+\t\ti++\n+\t}\n+\ttm, err := strconv.ParseInt(string(etime[i:]), 10, 64)\n+\tif err != nil || size < 0 {\n+\t\treturn missing()\n+\t}\n+\n+\tfmt.Fprintf(c.log, \"%d get %x\\n\", c.now().Unix(), id)\n+\n+\tc.used(c.fileName(id, \"a\"))\n+\n+\treturn Entry{buf, size, time.Unix(0, tm)}, nil\n+}\n+\n+// GetBytes looks up the action ID in the cache and returns\n+// the corresponding output bytes.\n+// GetBytes should only be used for data that can be expected to fit in memory.\n+func (c *Cache) GetBytes(id ActionID) ([]byte, Entry, error) {\n+\tentry, err := c.Get(id)\n+\tif err != nil {\n+\t\treturn nil, entry, err\n+\t}\n+\tdata, _ := ioutil.ReadFile(c.OutputFile(entry.OutputID))\n+\tif sha256.Sum256(data) != entry.OutputID {\n+\t\treturn nil, entry, errMissing\n+\t}\n+\treturn data, entry, nil\n+}\n+\n+// OutputFile returns the name of the cache file storing output with the given OutputID.\n+func (c *Cache) OutputFile(out OutputID) string {\n+\tfile := c.fileName(out, \"d\")\n+\tc.used(file)\n+\treturn file\n+}\n+\n+// Time constants for cache expiration.\n+//\n+// We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),\n+// to avoid causing many unnecessary inode updates. The mtimes therefore\n+// roughly reflect \"time of last use\" but may in fact be older by at most an hour.\n+//\n+// We scan the cache for entries to delete at most once per trimInterval (1 day).\n+//\n+// When we do scan the cache, we delete entries that have not been used for\n+// at least trimLimit (5 days). Statistics gathered from a month of usage by\n+// Go developers found that essentially all reuse of cached entries happened\n+// within 5 days of the previous reuse. See golang.org/issue/22990.\n+const (\n+\tmtimeInterval = 1 * time.Hour\n+\ttrimInterval  = 24 * time.Hour\n+\ttrimLimit     = 5 * 24 * time.Hour\n+)\n+\n+// used makes a best-effort attempt to update mtime on file,\n+// so that mtime reflects cache access time.\n+//\n+// Because the reflection only needs to be approximate,\n+// and to reduce the amount of disk activity caused by using\n+// cache entries, used only updates the mtime if the current\n+// mtime is more than an hour old. This heuristic eliminates\n+// nearly all of the mtime updates that would otherwise happen,\n+// while still keeping the mtimes useful for cache trimming.\n+func (c *Cache) used(file string) {\n+\tinfo, err := os.Stat(file)\n+\tif err == nil && c.now().Sub(info.ModTime()) < mtimeInterval {\n+\t\treturn\n+\t}\n+\tos.Chtimes(file, c.now(), c.now())\n+}\n+\n+// Trim removes old cache entries that are likely not to be reused.\n+func (c *Cache) Trim() {\n+\tnow := c.now()\n+\n+\t// We maintain in dir/trim.txt the time of the last completed cache trim.\n+\t// If the cache has been trimmed recently enough, do nothing.\n+\t// This is the common case.\n+\tdata, _ := ioutil.ReadFile(filepath.Join(c.dir, \"trim.txt\"))\n+\tt, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 64)\n+\tif err == nil && now.Sub(time.Unix(t, 0)) < trimInterval {\n+\t\treturn\n+\t}\n+\n+\t// Trim each of the 256 subdirectories.\n+\t// We subtract an additional mtimeInterval\n+\t// to account for the imprecision of our \"last used\" mtimes.\n+\tcutoff := now.Add(-trimLimit - mtimeInterval)\n+\tfor i := 0; i < 256; i++ {\n+\t\tsubdir := filepath.Join(c.dir, fmt.Sprintf(\"%02x\", i))\n+\t\tc.trimSubdir(subdir, cutoff)\n+\t}\n+\n+\tioutil.WriteFile(filepath.Join(c.dir, \"trim.txt\"), []byte(fmt.Sprintf(\"%d\", now.Unix())), 0666)\n+}\n+\n+// trimSubdir trims a single cache subdirectory.\n+func (c *Cache) trimSubdir(subdir string, cutoff time.Time) {\n+\t// Read all directory entries from subdir before removing\n+\t// any files, in case removing files invalidates the file offset\n+\t// in the directory scan. Also, ignore error from f.Readdirnames,\n+\t// because we don't care about reporting the error and we still\n+\t// want to process any entries found before the error.\n+\tf, err := os.Open(subdir)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tnames, _ := f.Readdirnames(-1)\n+\tf.Close()\n+\n+\tfor _, name := range names {\n+\t\t// Remove only cache entries (xxxx-a and xxxx-d).\n+\t\tif !strings.HasSuffix(name, \"-a\") && !strings.HasSuffix(name, \"-d\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tentry := filepath.Join(subdir, name)\n+\t\tinfo, err := os.Stat(entry)\n+\t\tif err == nil && info.ModTime().Before(cutoff) {\n+\t\t\tos.Remove(entry)\n+\t\t}\n+\t}\n+}\n+\n+// putIndexEntry adds an entry to the cache recording that executing the action\n+// with the given id produces an output with the given output id (hash) and size.\n+func (c *Cache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify bool) error {\n+\t// Note: We expect that for one reason or another it may happen\n+\t// that repeating an action produces a different output hash\n+\t// (for example, if the output contains a time stamp or temp dir name).\n+\t// While not ideal, this is also not a correctness problem, so we\n+\t// don't make a big deal about it. In particular, we leave the action\n+\t// cache entries writable specifically so that they can be overwritten.\n+\t//\n+\t// Setting GODEBUG=gocacheverify=1 does make a big deal:\n+\t// in verify mode we are double-checking that the cache entries\n+\t// are entirely reproducible. As just noted, this may be unrealistic\n+\t// in some cases but the check is also useful for shaking out real bugs.\n+\tentry := []byte(fmt.Sprintf(\"v1 %x %x %20d %20d\\n\", id, out, size, time.Now().UnixNano()))\n+\tif verify && allowVerify {\n+\t\told, err := c.get(id)\n+\t\tif err == nil && (old.OutputID != out || old.Size != size) {\n+\t\t\t// panic to show stack trace, so we can see what code is generating this cache entry.\n+\t\t\tmsg := fmt.Sprintf(\"go: internal cache error: cache verify failed: id=%x changed:<<<\\n%s\\n>>>\\nold: %x %d\\nnew: %x %d\", id, reverseHash(id), out, size, old.OutputID, old.Size)\n+\t\t\tpanic(msg)\n+\t\t}\n+\t}\n+\tfile := c.fileName(id, \"a\")\n+\tif err := ioutil.WriteFile(file, entry, 0666); err != nil {\n+\t\tos.Remove(file)\n+\t\treturn err\n+\t}\n+\tos.Chtimes(file, c.now(), c.now()) // mainly for tests\n+\n+\tfmt.Fprintf(c.log, \"%d put %x %x %d\\n\", c.now().Unix(), id, out, size)\n+\treturn nil\n+}\n+\n+// Put stores the given output in the cache as the output for the action ID.\n+// It may read file twice. The content of file must not change between the two passes.\n+func (c *Cache) Put(id ActionID, file io.ReadSeeker) (OutputID, int64, error) {\n+\treturn c.put(id, file, true)\n+}\n+\n+// PutNoVerify is like Put but disables the verify check\n+// when GODEBUG=goverifycache=1 is set.\n+// It is meant for data that is OK to cache but that we expect to vary slightly from run to run,\n+// like test output containing times and the like.\n+func (c *Cache) PutNoVerify(id ActionID, file io.ReadSeeker) (OutputID, int64, error) {\n+\treturn c.put(id, file, false)\n+}\n+\n+func (c *Cache) put(id ActionID, file io.ReadSeeker, allowVerify bool) (OutputID, int64, error) {\n+\t// Compute output ID.\n+\th := sha256.New()\n+\tif _, err := file.Seek(0, 0); err != nil {\n+\t\treturn OutputID{}, 0, err\n+\t}\n+\tsize, err := io.Copy(h, file)\n+\tif err != nil {\n+\t\treturn OutputID{}, 0, err\n+\t}\n+\tvar out OutputID\n+\th.Sum(out[:0])\n+\n+\t// Copy to cached output file (if not already present).\n+\tif err := c.copyFile(file, out, size); err != nil {\n+\t\treturn out, size, err\n+\t}\n+\n+\t// Add to cache index.\n+\treturn out, size, c.putIndexEntry(id, out, size, allowVerify)\n+}\n+\n+// PutBytes stores the given bytes in the cache as the output for the action ID.\n+func (c *Cache) PutBytes(id ActionID, data []byte) error {\n+\t_, _, err := c.Put(id, bytes.NewReader(data))\n+\treturn err\n+}\n+\n+// copyFile copies file into the cache, expecting it to have the given\n+// output ID and size, if that file is not present already.\n+func (c *Cache) copyFile(file io.ReadSeeker, out OutputID, size int64) error {\n+\tname := c.fileName(out, \"d\")\n+\tinfo, err := os.Stat(name)\n+\tif err == nil && info.Size() == size {\n+\t\t// Check hash.\n+\t\tif f, err := os.Open(name); err == nil {\n+\t\t\th := sha256.New()\n+\t\t\tio.Copy(h, f)\n+\t\t\tf.Close()\n+\t\t\tvar out2 OutputID\n+\t\t\th.Sum(out2[:0])\n+\t\t\tif out == out2 {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t\t// Hash did not match. Fall through and rewrite file.\n+\t}\n+\n+\t// Copy file to cache directory.\n+\tmode := os.O_RDWR | os.O_CREATE\n+\tif err == nil && info.Size() > size { // shouldn't happen but fix in case\n+\t\tmode |= os.O_TRUNC\n+\t}\n+\tf, err := os.OpenFile(name, mode, 0666)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\tif size == 0 {\n+\t\t// File now exists with correct size.\n+\t\t// Only one possible zero-length file, so contents are OK too.\n+\t\t// Early return here makes sure there's a \"last byte\" for code below.\n+\t\treturn nil\n+\t}\n+\n+\t// From here on, if any of the I/O writing the file fails,\n+\t// we make a best-effort attempt to truncate the file f\n+\t// before returning, to avoid leaving bad bytes in the file.\n+\n+\t// Copy file to f, but also into h to double-check hash.\n+\tif _, err := file.Seek(0, 0); err != nil {\n+\t\tf.Truncate(0)\n+\t\treturn err\n+\t}\n+\th := sha256.New()\n+\tw := io.MultiWriter(f, h)\n+\tif _, err := io.CopyN(w, file, size-1); err != nil {\n+\t\tf.Truncate(0)\n+\t\treturn err\n+\t}\n+\t// Check last byte before writing it; writing it will make the size match\n+\t// what other processes expect to find and might cause them to start\n+\t// using the file.\n+\tbuf := make([]byte, 1)\n+\tif _, err := file.Read(buf); err != nil {\n+\t\tf.Truncate(0)\n+\t\treturn err\n+\t}\n+\th.Write(buf)\n+\tsum := h.Sum(nil)\n+\tif !bytes.Equal(sum, out[:]) {\n+\t\tf.Truncate(0)\n+\t\treturn fmt.Errorf(\"file content changed underfoot\")\n+\t}\n+\n+\t// Commit cache file entry.\n+\tif _, err := f.Write(buf); err != nil {\n+\t\tf.Truncate(0)\n+\t\treturn err\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\t// Data might not have been written,\n+\t\t// but file may look like it is the right size.\n+\t\t// To be extra careful, remove cached file.\n+\t\tos.Remove(name)\n+\t\treturn err\n+\t}\n+\tos.Chtimes(name, c.now(), c.now()) // mainly for tests\n+\n+\treturn nil\n+}"}, {"sha": "d3dafccd137f2116c228862f08179a4bea3162e5", "filename": "libgo/go/cmd/go/internal/cache/cache_test.go", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,319 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cache\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func init() {\n+\tverify = false // even if GODEBUG is set\n+}\n+\n+func TestBasic(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\t_, err = Open(filepath.Join(dir, \"notexist\"))\n+\tif err == nil {\n+\t\tt.Fatal(`Open(\"tmp/notexist\") succeeded, want failure`)\n+\t}\n+\n+\tcdir := filepath.Join(dir, \"c1\")\n+\tif err := os.Mkdir(cdir, 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tc1, err := Open(cdir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open(c1) (create): %v\", err)\n+\t}\n+\tif err := c1.putIndexEntry(dummyID(1), dummyID(12), 13, true); err != nil {\n+\t\tt.Fatalf(\"addIndexEntry: %v\", err)\n+\t}\n+\tif err := c1.putIndexEntry(dummyID(1), dummyID(2), 3, true); err != nil { // overwrite entry\n+\t\tt.Fatalf(\"addIndexEntry: %v\", err)\n+\t}\n+\tif entry, err := c1.Get(dummyID(1)); err != nil || entry.OutputID != dummyID(2) || entry.Size != 3 {\n+\t\tt.Fatalf(\"c1.Get(1) = %x, %v, %v, want %x, %v, nil\", entry.OutputID, entry.Size, err, dummyID(2), 3)\n+\t}\n+\n+\tc2, err := Open(cdir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open(c2) (reuse): %v\", err)\n+\t}\n+\tif entry, err := c2.Get(dummyID(1)); err != nil || entry.OutputID != dummyID(2) || entry.Size != 3 {\n+\t\tt.Fatalf(\"c2.Get(1) = %x, %v, %v, want %x, %v, nil\", entry.OutputID, entry.Size, err, dummyID(2), 3)\n+\t}\n+\tif err := c2.putIndexEntry(dummyID(2), dummyID(3), 4, true); err != nil {\n+\t\tt.Fatalf(\"addIndexEntry: %v\", err)\n+\t}\n+\tif entry, err := c1.Get(dummyID(2)); err != nil || entry.OutputID != dummyID(3) || entry.Size != 4 {\n+\t\tt.Fatalf(\"c1.Get(2) = %x, %v, %v, want %x, %v, nil\", entry.OutputID, entry.Size, err, dummyID(3), 4)\n+\t}\n+}\n+\n+func TestGrowth(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tc, err := Open(dir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open: %v\", err)\n+\t}\n+\n+\tn := 10000\n+\tif testing.Short() {\n+\t\tn = 1000\n+\t}\n+\n+\tfor i := 0; i < n; i++ {\n+\t\tif err := c.putIndexEntry(dummyID(i), dummyID(i*99), int64(i)*101, true); err != nil {\n+\t\t\tt.Fatalf(\"addIndexEntry: %v\", err)\n+\t\t}\n+\t\tid := ActionID(dummyID(i))\n+\t\tentry, err := c.Get(id)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Get(%x): %v\", id, err)\n+\t\t}\n+\t\tif entry.OutputID != dummyID(i*99) || entry.Size != int64(i)*101 {\n+\t\t\tt.Errorf(\"Get(%x) = %x, %d, want %x, %d\", id, entry.OutputID, entry.Size, dummyID(i*99), int64(i)*101)\n+\t\t}\n+\t}\n+\tfor i := 0; i < n; i++ {\n+\t\tid := ActionID(dummyID(i))\n+\t\tentry, err := c.Get(id)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Get2(%x): %v\", id, err)\n+\t\t}\n+\t\tif entry.OutputID != dummyID(i*99) || entry.Size != int64(i)*101 {\n+\t\t\tt.Errorf(\"Get2(%x) = %x, %d, want %x, %d\", id, entry.OutputID, entry.Size, dummyID(i*99), int64(i)*101)\n+\t\t}\n+\t}\n+}\n+\n+func TestVerifyPanic(t *testing.T) {\n+\tos.Setenv(\"GODEBUG\", \"gocacheverify=1\")\n+\tinitEnv()\n+\tdefer func() {\n+\t\tos.Unsetenv(\"GODEBUG\")\n+\t\tverify = false\n+\t}()\n+\n+\tif !verify {\n+\t\tt.Fatal(\"initEnv did not set verify\")\n+\t}\n+\n+\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tc, err := Open(dir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open: %v\", err)\n+\t}\n+\n+\tid := ActionID(dummyID(1))\n+\tif err := c.PutBytes(id, []byte(\"abc\")); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tdefer func() {\n+\t\tif err := recover(); err != nil {\n+\t\t\tt.Log(err)\n+\t\t\treturn\n+\t\t}\n+\t}()\n+\tc.PutBytes(id, []byte(\"def\"))\n+\tt.Fatal(\"mismatched Put did not panic in verify mode\")\n+}\n+\n+func TestCacheLog(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tc, err := Open(dir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open: %v\", err)\n+\t}\n+\tc.now = func() time.Time { return time.Unix(1e9, 0) }\n+\n+\tid := ActionID(dummyID(1))\n+\tc.Get(id)\n+\tc.PutBytes(id, []byte(\"abc\"))\n+\tc.Get(id)\n+\n+\tc, err = Open(dir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open #2: %v\", err)\n+\t}\n+\tc.now = func() time.Time { return time.Unix(1e9+1, 0) }\n+\tc.Get(id)\n+\n+\tid2 := ActionID(dummyID(2))\n+\tc.Get(id2)\n+\tc.PutBytes(id2, []byte(\"abc\"))\n+\tc.Get(id2)\n+\tc.Get(id)\n+\n+\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"log.txt\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\twant := `1000000000 miss 0100000000000000000000000000000000000000000000000000000000000000\n+1000000000 put 0100000000000000000000000000000000000000000000000000000000000000 ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad 3\n+1000000000 get 0100000000000000000000000000000000000000000000000000000000000000\n+1000000001 get 0100000000000000000000000000000000000000000000000000000000000000\n+1000000001 miss 0200000000000000000000000000000000000000000000000000000000000000\n+1000000001 put 0200000000000000000000000000000000000000000000000000000000000000 ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad 3\n+1000000001 get 0200000000000000000000000000000000000000000000000000000000000000\n+1000000001 get 0100000000000000000000000000000000000000000000000000000000000000\n+`\n+\tif string(data) != want {\n+\t\tt.Fatalf(\"log:\\n%s\\nwant:\\n%s\", string(data), want)\n+\t}\n+}\n+\n+func dummyID(x int) [HashSize]byte {\n+\tvar out [HashSize]byte\n+\tbinary.LittleEndian.PutUint64(out[:], uint64(x))\n+\treturn out\n+}\n+\n+func TestCacheTrim(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tc, err := Open(dir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open: %v\", err)\n+\t}\n+\tconst start = 1000000000\n+\tnow := int64(start)\n+\tc.now = func() time.Time { return time.Unix(now, 0) }\n+\n+\tcheckTime := func(name string, mtime int64) {\n+\t\tt.Helper()\n+\t\tfile := filepath.Join(c.dir, name[:2], name)\n+\t\tinfo, err := os.Stat(file)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif info.ModTime().Unix() != mtime {\n+\t\t\tt.Fatalf(\"%s mtime = %d, want %d\", name, info.ModTime().Unix(), mtime)\n+\t\t}\n+\t}\n+\n+\tid := ActionID(dummyID(1))\n+\tc.PutBytes(id, []byte(\"abc\"))\n+\tentry, _ := c.Get(id)\n+\tc.PutBytes(ActionID(dummyID(2)), []byte(\"def\"))\n+\tmtime := now\n+\tcheckTime(fmt.Sprintf(\"%x-a\", id), mtime)\n+\tcheckTime(fmt.Sprintf(\"%x-d\", entry.OutputID), mtime)\n+\n+\t// Get should not change recent mtimes.\n+\tnow = start + 10\n+\tc.Get(id)\n+\tcheckTime(fmt.Sprintf(\"%x-a\", id), mtime)\n+\tcheckTime(fmt.Sprintf(\"%x-d\", entry.OutputID), mtime)\n+\n+\t// Get should change distant mtimes.\n+\tnow = start + 5000\n+\tmtime2 := now\n+\tif _, err := c.Get(id); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.OutputFile(entry.OutputID)\n+\tcheckTime(fmt.Sprintf(\"%x-a\", id), mtime2)\n+\tcheckTime(fmt.Sprintf(\"%x-d\", entry.OutputID), mtime2)\n+\n+\t// Trim should leave everything alone: it's all too new.\n+\tc.Trim()\n+\tif _, err := c.Get(id); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.OutputFile(entry.OutputID)\n+\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"trim.txt\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tcheckTime(fmt.Sprintf(\"%x-a\", dummyID(2)), start)\n+\n+\t// Trim less than a day later should not do any work at all.\n+\tnow = start + 80000\n+\tc.Trim()\n+\tif _, err := c.Get(id); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.OutputFile(entry.OutputID)\n+\tdata2, err := ioutil.ReadFile(filepath.Join(dir, \"trim.txt\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !bytes.Equal(data, data2) {\n+\t\tt.Fatalf(\"second trim did work: %q -> %q\", data, data2)\n+\t}\n+\n+\t// Fast forward and do another trim just before the 5 day cutoff.\n+\t// Note that because of usedQuantum the cutoff is actually 5 days + 1 hour.\n+\t// We used c.Get(id) just now, so 5 days later it should still be kept.\n+\t// On the other hand almost a full day has gone by since we wrote dummyID(2)\n+\t// and we haven't looked at it since, so 5 days later it should be gone.\n+\tnow += 5 * 86400\n+\tcheckTime(fmt.Sprintf(\"%x-a\", dummyID(2)), start)\n+\tc.Trim()\n+\tif _, err := c.Get(id); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tc.OutputFile(entry.OutputID)\n+\tmtime3 := now\n+\tif _, err := c.Get(dummyID(2)); err == nil { // haven't done a Get for this since original write above\n+\t\tt.Fatalf(\"Trim did not remove dummyID(2)\")\n+\t}\n+\n+\t// The c.Get(id) refreshed id's mtime again.\n+\t// Check that another 5 days later it is still not gone,\n+\t// but check by using checkTime, which doesn't bring mtime forward.\n+\tnow += 5 * 86400\n+\tc.Trim()\n+\tcheckTime(fmt.Sprintf(\"%x-a\", id), mtime3)\n+\tcheckTime(fmt.Sprintf(\"%x-d\", entry.OutputID), mtime3)\n+\n+\t// Half a day later Trim should still be a no-op, because there was a Trim recently.\n+\t// Even though the entry for id is now old enough to be trimmed,\n+\t// it gets a reprieve until the time comes for a new Trim scan.\n+\tnow += 86400 / 2\n+\tc.Trim()\n+\tcheckTime(fmt.Sprintf(\"%x-a\", id), mtime3)\n+\tcheckTime(fmt.Sprintf(\"%x-d\", entry.OutputID), mtime3)\n+\n+\t// Another half a day later, Trim should actually run, and it should remove id.\n+\tnow += 86400/2 + 1\n+\tc.Trim()\n+\tif _, err := c.Get(dummyID(1)); err == nil {\n+\t\tt.Fatal(\"Trim did not remove dummyID(1)\")\n+\t}\n+}"}, {"sha": "6411ec7a563d1e9271dd6c24ad3d0e3d755e200d", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cache\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"sync\"\n+)\n+\n+// Default returns the default cache to use, or nil if no cache should be used.\n+func Default() *Cache {\n+\tdefaultOnce.Do(initDefaultCache)\n+\treturn defaultCache\n+}\n+\n+var (\n+\tdefaultOnce  sync.Once\n+\tdefaultCache *Cache\n+)\n+\n+// cacheREADME is a message stored in a README in the cache directory.\n+// Because the cache lives outside the normal Go trees, we leave the\n+// README as a courtesy to explain where it came from.\n+const cacheREADME = `This directory holds cached build artifacts from the Go build system.\n+Run \"go clean -cache\" if the directory is getting too large.\n+See golang.org to learn more about Go.\n+`\n+\n+// initDefaultCache does the work of finding the default cache\n+// the first time Default is called.\n+func initDefaultCache() {\n+\tdir := DefaultDir()\n+\tif dir == \"off\" {\n+\t\treturn\n+\t}\n+\tif err := os.MkdirAll(dir, 0777); err != nil {\n+\t\tbase.Fatalf(\"initializing cache in $GOCACHE: %s\", err)\n+\t}\n+\tif _, err := os.Stat(filepath.Join(dir, \"README\")); err != nil {\n+\t\t// Best effort.\n+\t\tioutil.WriteFile(filepath.Join(dir, \"README\"), []byte(cacheREADME), 0666)\n+\t}\n+\n+\tc, err := Open(dir)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"initializing cache in $GOCACHE: %s\", err)\n+\t}\n+\tdefaultCache = c\n+}\n+\n+// DefaultDir returns the effective GOCACHE setting.\n+// It returns \"off\" if the cache is disabled.\n+func DefaultDir() string {\n+\tdir := os.Getenv(\"GOCACHE\")\n+\tif dir != \"\" {\n+\t\treturn dir\n+\t}\n+\n+\t// Compute default location.\n+\t// TODO(rsc): This code belongs somewhere else,\n+\t// like maybe ioutil.CacheDir or os.CacheDir.\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n+\t\tdir = os.Getenv(\"LocalAppData\")\n+\n+\tcase \"darwin\":\n+\t\tdir = os.Getenv(\"HOME\")\n+\t\tif dir == \"\" {\n+\t\t\treturn \"off\"\n+\t\t}\n+\t\tdir += \"/Library/Caches\"\n+\n+\tcase \"plan9\":\n+\t\tdir = os.Getenv(\"home\")\n+\t\tif dir == \"\" {\n+\t\t\treturn \"off\"\n+\t\t}\n+\t\t// Plan 9 has no established per-user cache directory,\n+\t\t// but $home/lib/xyz is the usual equivalent of $HOME/.xyz on Unix.\n+\t\tdir += \"/lib/cache\"\n+\n+\tdefault: // Unix\n+\t\t// https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n+\t\tdir = os.Getenv(\"XDG_CACHE_HOME\")\n+\t\tif dir == \"\" {\n+\t\t\tdir = os.Getenv(\"HOME\")\n+\t\t\tif dir == \"\" {\n+\t\t\t\treturn \"off\"\n+\t\t\t}\n+\t\t\tdir += \"/.cache\"\n+\t\t}\n+\t}\n+\treturn filepath.Join(dir, \"go-build\")\n+}"}, {"sha": "0e45e7db5478bded54657517f3f23c786d5a5d7f", "filename": "libgo/go/cmd/go/internal/cache/hash.go", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cache\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/sha256\"\n+\t\"fmt\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"sync\"\n+)\n+\n+var debugHash = false // set when GODEBUG=gocachehash=1\n+\n+// HashSize is the number of bytes in a hash.\n+const HashSize = 32\n+\n+// A Hash provides access to the canonical hash function used to index the cache.\n+// The current implementation uses salted SHA256, but clients must not assume this.\n+type Hash struct {\n+\th    hash.Hash\n+\tname string        // for debugging\n+\tbuf  *bytes.Buffer // for verify\n+}\n+\n+// hashSalt is a salt string added to the beginning of every hash\n+// created by NewHash. Using the Go version makes sure that different\n+// versions of the go command (or even different Git commits during\n+// work on the development branch) do not address the same cache\n+// entries, so that a bug in one version does not affect the execution\n+// of other versions. This salt will result in additional ActionID files\n+// in the cache, but not additional copies of the large output files,\n+// which are still addressed by unsalted SHA256.\n+var hashSalt = []byte(runtime.Version())\n+\n+// Subkey returns an action ID corresponding to mixing a parent\n+// action ID with a string description of the subkey.\n+func Subkey(parent ActionID, desc string) ActionID {\n+\th := sha256.New()\n+\th.Write([]byte(\"subkey:\"))\n+\th.Write(parent[:])\n+\th.Write([]byte(desc))\n+\tvar out ActionID\n+\th.Sum(out[:0])\n+\tif debugHash {\n+\t\tfmt.Fprintf(os.Stderr, \"HASH subkey %x %q = %x\\n\", parent, desc, out)\n+\t}\n+\tif verify {\n+\t\thashDebug.Lock()\n+\t\thashDebug.m[out] = fmt.Sprintf(\"subkey %x %q\", parent, desc)\n+\t\thashDebug.Unlock()\n+\t}\n+\treturn out\n+}\n+\n+// NewHash returns a new Hash.\n+// The caller is expected to Write data to it and then call Sum.\n+func NewHash(name string) *Hash {\n+\th := &Hash{h: sha256.New(), name: name}\n+\tif debugHash {\n+\t\tfmt.Fprintf(os.Stderr, \"HASH[%s]\\n\", h.name)\n+\t}\n+\th.Write(hashSalt)\n+\tif verify {\n+\t\th.buf = new(bytes.Buffer)\n+\t}\n+\treturn h\n+}\n+\n+// Write writes data to the running hash.\n+func (h *Hash) Write(b []byte) (int, error) {\n+\tif debugHash {\n+\t\tfmt.Fprintf(os.Stderr, \"HASH[%s]: %q\\n\", h.name, b)\n+\t}\n+\tif h.buf != nil {\n+\t\th.buf.Write(b)\n+\t}\n+\treturn h.h.Write(b)\n+}\n+\n+// Sum returns the hash of the data written previously.\n+func (h *Hash) Sum() [HashSize]byte {\n+\tvar out [HashSize]byte\n+\th.h.Sum(out[:0])\n+\tif debugHash {\n+\t\tfmt.Fprintf(os.Stderr, \"HASH[%s]: %x\\n\", h.name, out)\n+\t}\n+\tif h.buf != nil {\n+\t\thashDebug.Lock()\n+\t\tif hashDebug.m == nil {\n+\t\t\thashDebug.m = make(map[[HashSize]byte]string)\n+\t\t}\n+\t\thashDebug.m[out] = h.buf.String()\n+\t\thashDebug.Unlock()\n+\t}\n+\treturn out\n+}\n+\n+// In GODEBUG=gocacheverify=1 mode,\n+// hashDebug holds the input to every computed hash ID,\n+// so that we can work backward from the ID involved in a\n+// cache entry mismatch to a description of what should be there.\n+var hashDebug struct {\n+\tsync.Mutex\n+\tm map[[HashSize]byte]string\n+}\n+\n+// reverseHash returns the input used to compute the hash id.\n+func reverseHash(id [HashSize]byte) string {\n+\thashDebug.Lock()\n+\ts := hashDebug.m[id]\n+\thashDebug.Unlock()\n+\treturn s\n+}\n+\n+var hashFileCache struct {\n+\tsync.Mutex\n+\tm map[string][HashSize]byte\n+}\n+\n+// HashFile returns the hash of the named file.\n+// It caches repeated lookups for a given file,\n+// and the cache entry for a file can be initialized\n+// using SetFileHash.\n+// The hash used by FileHash is not the same as\n+// the hash used by NewHash.\n+func FileHash(file string) ([HashSize]byte, error) {\n+\thashFileCache.Lock()\n+\tout, ok := hashFileCache.m[file]\n+\thashFileCache.Unlock()\n+\n+\tif ok {\n+\t\treturn out, nil\n+\t}\n+\n+\th := sha256.New()\n+\tf, err := os.Open(file)\n+\tif err != nil {\n+\t\tif debugHash {\n+\t\t\tfmt.Fprintf(os.Stderr, \"HASH %s: %v\\n\", file, err)\n+\t\t}\n+\t\treturn [HashSize]byte{}, err\n+\t}\n+\t_, err = io.Copy(h, f)\n+\tf.Close()\n+\tif err != nil {\n+\t\tif debugHash {\n+\t\t\tfmt.Fprintf(os.Stderr, \"HASH %s: %v\\n\", file, err)\n+\t\t}\n+\t\treturn [HashSize]byte{}, err\n+\t}\n+\th.Sum(out[:0])\n+\tif debugHash {\n+\t\tfmt.Fprintf(os.Stderr, \"HASH %s: %x\\n\", file, out)\n+\t}\n+\n+\tSetFileHash(file, out)\n+\treturn out, nil\n+}\n+\n+// SetFileHash sets the hash returned by FileHash for file.\n+func SetFileHash(file string, sum [HashSize]byte) {\n+\thashFileCache.Lock()\n+\tif hashFileCache.m == nil {\n+\t\thashFileCache.m = make(map[string][HashSize]byte)\n+\t}\n+\thashFileCache.m[file] = sum\n+\thashFileCache.Unlock()\n+}"}, {"sha": "3bf7143039ca22b6fb648898516251b9799c7680", "filename": "libgo/go/cmd/go/internal/cache/hash_test.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fhash_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cache\n+\n+import (\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestHash(t *testing.T) {\n+\toldSalt := hashSalt\n+\thashSalt = nil\n+\tdefer func() {\n+\t\thashSalt = oldSalt\n+\t}()\n+\n+\th := NewHash(\"alice\")\n+\th.Write([]byte(\"hello world\"))\n+\tsum := fmt.Sprintf(\"%x\", h.Sum())\n+\twant := \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\"\n+\tif sum != want {\n+\t\tt.Errorf(\"hash(hello world) = %v, want %v\", sum, want)\n+\t}\n+}\n+\n+func TestHashFile(t *testing.T) {\n+\tf, err := ioutil.TempFile(\"\", \"cmd-go-test-\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tname := f.Name()\n+\tfmt.Fprintf(f, \"hello world\")\n+\tdefer os.Remove(name)\n+\tif err := f.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tvar h ActionID // make sure hash result is assignable to ActionID\n+\th, err = FileHash(name)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tsum := fmt.Sprintf(\"%x\", h)\n+\twant := \"b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\"\n+\tif sum != want {\n+\t\tt.Errorf(\"hash(hello world) = %v, want %v\", sum, want)\n+\t}\n+}"}, {"sha": "45161ae26b7e0c00884188fc375007518e5be22a", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -22,7 +22,6 @@ var (\n \tBuildBuildmode         string // -buildmode flag\n \tBuildContext           = build.Default\n \tBuildI                 bool               // -i flag\n-\tBuildLdflags           []string           // -ldflags flag\n \tBuildLinkshared        bool               // -linkshared flag\n \tBuildMSan              bool               // -msan flag\n \tBuildN                 bool               // -n flag\n@@ -37,6 +36,10 @@ var (\n \tBuildV                 bool // -v flag\n \tBuildWork              bool // -work flag\n \tBuildX                 bool // -x flag\n+\n+\tCmdName string // \"build\", \"install\", \"list\", etc.\n+\n+\tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n )\n \n func init() {\n@@ -80,8 +83,9 @@ var (\n \tGOROOTsrc = filepath.Join(GOROOT, \"src\")\n \n \t// Used in envcmd.MkEnv and build ID computations.\n-\tGOARM = fmt.Sprint(objabi.GOARM)\n-\tGO386 = objabi.GO386\n+\tGOARM  = fmt.Sprint(objabi.GOARM)\n+\tGO386  = objabi.GO386\n+\tGOMIPS = objabi.GOMIPS\n )\n \n // Update build context to use our computed GOROOT.\n@@ -100,24 +104,44 @@ func findGOROOT() string {\n \tif env := os.Getenv(\"GOROOT\"); env != \"\" {\n \t\treturn filepath.Clean(env)\n \t}\n-\tif runtime.Compiler != \"gccgo\" {\n-\t\texe, err := os.Executable()\n+\tdef := filepath.Clean(runtime.GOROOT())\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\treturn def\n+\t}\n+\texe, err := os.Executable()\n+\tif err == nil {\n+\t\texe, err = filepath.Abs(exe)\n \t\tif err == nil {\n-\t\t\texe, err = filepath.Abs(exe)\n+\t\t\tif dir := filepath.Join(exe, \"../..\"); isGOROOT(dir) {\n+\t\t\t\t// If def (runtime.GOROOT()) and dir are the same\n+\t\t\t\t// directory, prefer the spelling used in def.\n+\t\t\t\tif isSameDir(def, dir) {\n+\t\t\t\t\treturn def\n+\t\t\t\t}\n+\t\t\t\treturn dir\n+\t\t\t}\n+\t\t\texe, err = filepath.EvalSymlinks(exe)\n \t\t\tif err == nil {\n \t\t\t\tif dir := filepath.Join(exe, \"../..\"); isGOROOT(dir) {\n-\t\t\t\t\treturn dir\n-\t\t\t\t}\n-\t\t\t\texe, err = filepath.EvalSymlinks(exe)\n-\t\t\t\tif err == nil {\n-\t\t\t\t\tif dir := filepath.Join(exe, \"../..\"); isGOROOT(dir) {\n-\t\t\t\t\t\treturn dir\n+\t\t\t\t\tif isSameDir(def, dir) {\n+\t\t\t\t\t\treturn def\n \t\t\t\t\t}\n+\t\t\t\t\treturn dir\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n-\treturn filepath.Clean(runtime.GOROOT())\n+\treturn def\n+}\n+\n+// isSameDir reports whether dir1 and dir2 are the same directory.\n+func isSameDir(dir1, dir2 string) bool {\n+\tif dir1 == dir2 {\n+\t\treturn true\n+\t}\n+\tinfo1, err1 := os.Stat(dir1)\n+\tinfo2, err2 := os.Stat(dir2)\n+\treturn err1 == nil && err2 == nil && os.SameFile(info1, info2)\n }\n \n // isGOROOT reports whether path looks like a GOROOT."}, {"sha": "fa5af944af6c90f36d5e0792554ca2f551de0840", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -11,16 +11,18 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/work\"\n )\n \n var CmdClean = &base.Command{\n-\tUsageLine: \"clean [-i] [-r] [-n] [-x] [build flags] [packages]\",\n-\tShort:     \"remove object files\",\n+\tUsageLine: \"clean [-i] [-r] [-n] [-x] [-cache] [-testcache] [build flags] [packages]\",\n+\tShort:     \"remove object files and cached files\",\n \tLong: `\n Clean removes object files from package source directories.\n The go command builds most objects in a temporary directory,\n@@ -58,21 +60,33 @@ dependencies of the packages named by the import paths.\n \n The -x flag causes clean to print remove commands as it executes them.\n \n+The -cache flag causes clean to remove the entire go build cache.\n+\n+The -testcache flag causes clean to expire all test results in the\n+go build cache.\n+\n For more about build flags, see 'go help build'.\n \n For more about specifying packages, see 'go help packages'.\n \t`,\n }\n \n-var cleanI bool // clean -i flag\n-var cleanR bool // clean -r flag\n+var (\n+\tcleanI         bool // clean -i flag\n+\tcleanR         bool // clean -r flag\n+\tcleanCache     bool // clean -cache flag\n+\tcleanTestcache bool // clean -testcache flag\n+)\n \n func init() {\n \t// break init cycle\n \tCmdClean.Run = runClean\n \n \tCmdClean.Flag.BoolVar(&cleanI, \"i\", false, \"\")\n \tCmdClean.Flag.BoolVar(&cleanR, \"r\", false, \"\")\n+\tCmdClean.Flag.BoolVar(&cleanCache, \"cache\", false, \"\")\n+\tCmdClean.Flag.BoolVar(&cleanTestcache, \"testcache\", false, \"\")\n+\n \t// -n and -x are important enough to be\n \t// mentioned explicitly in the docs but they\n \t// are part of the build flags.\n@@ -84,6 +98,46 @@ func runClean(cmd *base.Command, args []string) {\n \tfor _, pkg := range load.PackagesAndErrors(args) {\n \t\tclean(pkg)\n \t}\n+\n+\tif cleanCache {\n+\t\tvar b work.Builder\n+\t\tb.Print = fmt.Print\n+\t\tdir := cache.DefaultDir()\n+\t\tif dir != \"off\" {\n+\t\t\t// Remove the cache subdirectories but not the top cache directory.\n+\t\t\t// The top cache directory may have been created with special permissions\n+\t\t\t// and not something that we want to remove. Also, we'd like to preserve\n+\t\t\t// the access log for future analysis, even if the cache is cleared.\n+\t\t\tsubdirs, _ := filepath.Glob(filepath.Join(dir, \"[0-9a-f][0-9a-f]\"))\n+\t\t\tif len(subdirs) > 0 {\n+\t\t\t\tif cfg.BuildN || cfg.BuildX {\n+\t\t\t\t\tb.Showcmd(\"\", \"rm -r %s\", strings.Join(subdirs, \" \"))\n+\t\t\t\t}\n+\t\t\t\tprintedErrors := false\n+\t\t\t\tfor _, d := range subdirs {\n+\t\t\t\t\t// Only print the first error - there may be many.\n+\t\t\t\t\t// This also mimics what os.RemoveAll(dir) would do.\n+\t\t\t\t\tif err := os.RemoveAll(d); err != nil && !printedErrors {\n+\t\t\t\t\t\tprintedErrors = true\n+\t\t\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif cleanTestcache && !cleanCache {\n+\t\t// Instead of walking through the entire cache looking for test results,\n+\t\t// we write a file to the cache indicating that all test results from before\n+\t\t// right now are to be ignored.\n+\t\tdir := cache.DefaultDir()\n+\t\tif dir != \"off\" {\n+\t\t\terr := ioutil.WriteFile(filepath.Join(dir, \"testexpire.txt\"), []byte(fmt.Sprintf(\"%d\\n\", time.Now().UnixNano())), 0666)\n+\t\t\tif err != nil {\n+\t\t\t\tbase.Errorf(\"go clean -testcache: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n var cleaned = map[*load.Package]bool{}\n@@ -213,12 +267,12 @@ func clean(p *load.Package) {\n \t\t}\n \t}\n \n-\tif cleanI && p.Internal.Target != \"\" {\n+\tif cleanI && p.Target != \"\" {\n \t\tif cfg.BuildN || cfg.BuildX {\n-\t\t\tb.Showcmd(\"\", \"rm -f %s\", p.Internal.Target)\n+\t\t\tb.Showcmd(\"\", \"rm -f %s\", p.Target)\n \t\t}\n \t\tif !cfg.BuildN {\n-\t\t\tremoveFile(p.Internal.Target)\n+\t\t\tremoveFile(p.Target)\n \t\t}\n \t}\n "}, {"sha": "fa19bebe218fcf8fc130cba5f123d8dcd330dd51", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/work\"\n@@ -31,6 +32,8 @@ each named variable on its own line.\n \n The -json flag prints the environment in JSON format\n instead of as a shell script.\n+\n+For more about environment variables, see 'go help environment'.\n \t`,\n }\n \n@@ -47,13 +50,15 @@ func MkEnv() []cfg.EnvVar {\n \tenv := []cfg.EnvVar{\n \t\t{Name: \"GOARCH\", Value: cfg.Goarch},\n \t\t{Name: \"GOBIN\", Value: cfg.GOBIN},\n+\t\t{Name: \"GOCACHE\", Value: cache.DefaultDir()},\n \t\t{Name: \"GOEXE\", Value: cfg.ExeSuffix},\n \t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n \t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n \t\t{Name: \"GOOS\", Value: cfg.Goos},\n \t\t{Name: \"GOPATH\", Value: cfg.BuildContext.GOPATH},\n \t\t{Name: \"GORACE\", Value: os.Getenv(\"GORACE\")},\n \t\t{Name: \"GOROOT\", Value: cfg.GOROOT},\n+\t\t{Name: \"GOTMPDIR\", Value: os.Getenv(\"GOTMPDIR\")},\n \t\t{Name: \"GOTOOLDIR\", Value: base.ToolDir},\n \n \t\t// disable escape codes in clang errors\n@@ -71,13 +76,20 @@ func MkEnv() []cfg.EnvVar {\n \t\tenv = append(env, cfg.EnvVar{Name: \"GOARM\", Value: cfg.GOARM})\n \tcase \"386\":\n \t\tenv = append(env, cfg.EnvVar{Name: \"GO386\", Value: cfg.GO386})\n+\tcase \"mips\", \"mipsle\":\n+\t\tenv = append(env, cfg.EnvVar{Name: \"GOMIPS\", Value: cfg.GOMIPS})\n \t}\n \n-\tcmd := b.GccCmd(\".\")\n-\tenv = append(env, cfg.EnvVar{Name: \"CC\", Value: cmd[0]})\n-\tenv = append(env, cfg.EnvVar{Name: \"GOGCCFLAGS\", Value: strings.Join(cmd[3:], \" \")})\n-\tcmd = b.GxxCmd(\".\")\n-\tenv = append(env, cfg.EnvVar{Name: \"CXX\", Value: cmd[0]})\n+\tcc := cfg.DefaultCC(cfg.Goos, cfg.Goarch)\n+\tif env := strings.Fields(os.Getenv(\"CC\")); len(env) > 0 {\n+\t\tcc = env[0]\n+\t}\n+\tcxx := cfg.DefaultCXX(cfg.Goos, cfg.Goarch)\n+\tif env := strings.Fields(os.Getenv(\"CXX\")); len(env) > 0 {\n+\t\tcxx = env[0]\n+\t}\n+\tenv = append(env, cfg.EnvVar{Name: \"CC\", Value: cc})\n+\tenv = append(env, cfg.EnvVar{Name: \"CXX\", Value: cxx})\n \n \tif cfg.BuildContext.CgoEnabled {\n \t\tenv = append(env, cfg.EnvVar{Name: \"CGO_ENABLED\", Value: \"1\"})\n@@ -102,19 +114,45 @@ func ExtraEnvVars() []cfg.EnvVar {\n \tvar b work.Builder\n \tb.Init()\n \tcppflags, cflags, cxxflags, fflags, ldflags := b.CFlags(&load.Package{})\n+\tcmd := b.GccCmd(\".\", \"\")\n \treturn []cfg.EnvVar{\n+\t\t// Note: Update the switch in runEnv below when adding to this list.\n \t\t{Name: \"CGO_CFLAGS\", Value: strings.Join(cflags, \" \")},\n \t\t{Name: \"CGO_CPPFLAGS\", Value: strings.Join(cppflags, \" \")},\n \t\t{Name: \"CGO_CXXFLAGS\", Value: strings.Join(cxxflags, \" \")},\n \t\t{Name: \"CGO_FFLAGS\", Value: strings.Join(fflags, \" \")},\n \t\t{Name: \"CGO_LDFLAGS\", Value: strings.Join(ldflags, \" \")},\n \t\t{Name: \"PKG_CONFIG\", Value: b.PkgconfigCmd()},\n+\t\t{Name: \"GOGCCFLAGS\", Value: strings.Join(cmd[3:], \" \")},\n \t}\n }\n \n func runEnv(cmd *base.Command, args []string) {\n \tenv := cfg.CmdEnv\n-\tenv = append(env, ExtraEnvVars()...)\n+\n+\t// Do we need to call ExtraEnvVars, which is a bit expensive?\n+\t// Only if we're listing all environment variables (\"go env\")\n+\t// or the variables being requested are in the extra list.\n+\tneedExtra := true\n+\tif len(args) > 0 {\n+\t\tneedExtra = false\n+\t\tfor _, arg := range args {\n+\t\t\tswitch arg {\n+\t\t\tcase \"CGO_CFLAGS\",\n+\t\t\t\t\"CGO_CPPFLAGS\",\n+\t\t\t\t\"CGO_CXXFLAGS\",\n+\t\t\t\t\"CGO_FFLAGS\",\n+\t\t\t\t\"CGO_LDFLAGS\",\n+\t\t\t\t\"PKG_CONFIG\",\n+\t\t\t\t\"GOGCCFLAGS\":\n+\t\t\t\tneedExtra = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif needExtra {\n+\t\tenv = append(env, ExtraEnvVars()...)\n+\t}\n+\n \tif len(args) > 0 {\n \t\tif *envJson {\n \t\t\tvar es []cfg.EnvVar"}, {"sha": "99c7ca51acf38084ba06852bc9c1f9383c4e3b91", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -15,7 +15,7 @@ import (\n var CmdFix = &base.Command{\n \tRun:       runFix,\n \tUsageLine: \"fix [packages]\",\n-\tShort:     \"run go tool fix on packages\",\n+\tShort:     \"update packages to use new APIs\",\n \tLong: `\n Fix runs the Go fix command on the packages named by the import paths.\n \n@@ -33,7 +33,7 @@ func runFix(cmd *base.Command, args []string) {\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n-\t\tfiles := base.FilterDotUnderscoreFiles(base.RelPaths(pkg.Internal.AllGoFiles))\n+\t\tfiles := base.RelPaths(pkg.InternalAllGoFiles())\n \t\tbase.Run(str.StringList(cfg.BuildToolexec, base.Tool(\"fix\"), files))\n \t}\n }"}, {"sha": "eb96823fa6aa12f1f005ea6da3dbe4f7100aaec1", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -8,6 +8,9 @@ package fmtcmd\n import (\n \t\"os\"\n \t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -22,7 +25,7 @@ func init() {\n var CmdFmt = &base.Command{\n \tRun:       runFmt,\n \tUsageLine: \"fmt [-n] [-x] [packages]\",\n-\tShort:     \"run gofmt on package sources\",\n+\tShort:     \"gofmt (reformat) package sources\",\n \tLong: `\n Fmt runs the command 'gofmt -l -w' on the packages named\n by the import paths. It prints the names of the files that are modified.\n@@ -41,13 +44,38 @@ See also: go fix, go vet.\n \n func runFmt(cmd *base.Command, args []string) {\n \tgofmt := gofmtPath()\n-\tfor _, pkg := range load.Packages(args) {\n+\tprocs := runtime.GOMAXPROCS(0)\n+\tvar wg sync.WaitGroup\n+\twg.Add(procs)\n+\tfileC := make(chan string, 2*procs)\n+\tfor i := 0; i < procs; i++ {\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor file := range fileC {\n+\t\t\t\tbase.Run(str.StringList(gofmt, \"-l\", \"-w\", file))\n+\t\t\t}\n+\t\t}()\n+\t}\n+\tfor _, pkg := range load.PackagesAndErrors(args) {\n+\t\tif pkg.Error != nil {\n+\t\t\tif strings.HasPrefix(pkg.Error.Err, \"build constraints exclude all Go files\") {\n+\t\t\t\t// Skip this error, as we will format\n+\t\t\t\t// all files regardless.\n+\t\t\t} else {\n+\t\t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n-\t\tfiles := base.FilterDotUnderscoreFiles(base.RelPaths(pkg.Internal.AllGoFiles))\n-\t\tbase.Run(str.StringList(gofmt, \"-l\", \"-w\", files))\n+\t\tfiles := base.RelPaths(pkg.InternalAllGoFiles())\n+\t\tfor _, file := range files {\n+\t\t\tfileC <- file\n+\t\t}\n \t}\n+\tclose(fileC)\n+\twg.Wait()\n }\n \n func gofmtPath() string {"}, {"sha": "75c0d3b09d685788f72238bc4328ebd293957e8f", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -153,7 +153,7 @@ func runGenerate(cmd *base.Command, args []string) {\n \t}\n \t// Even if the arguments are .go files, this loop suffices.\n \tfor _, pkg := range load.Packages(args) {\n-\t\tfor _, file := range pkg.Internal.GoFiles {\n+\t\tfor _, file := range pkg.InternalGoFiles() {\n \t\t\tif !generate(pkg.Name, file) {\n \t\t\t\tbreak\n \t\t\t}\n@@ -385,7 +385,7 @@ func (g *Generator) setShorthand(words []string) {\n \t}\n \tcommand := words[1]\n \tif g.commands[command] != nil {\n-\t\tg.errorf(\"command %q defined multiply defined\", command)\n+\t\tg.errorf(\"command %q multiply defined\", command)\n \t}\n \tg.commands[command] = words[2:len(words):len(words)] // force later append to make copy\n }"}, {"sha": "d42dae6e61ff510f6123b935a269940f80c7ba25", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -90,8 +90,7 @@ func init() {\n }\n \n func runGet(cmd *base.Command, args []string) {\n-\twork.InstrumentInit()\n-\twork.BuildModeInit()\n+\twork.BuildInit()\n \n \tif *getF && !*getU {\n \t\tbase.Fatalf(\"go get: cannot use -f flag without -u\")\n@@ -301,7 +300,7 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t// due to wildcard expansion.\n \tfor _, p := range pkgs {\n \t\tif *getFix {\n-\t\t\tfiles := base.FilterDotUnderscoreFiles(base.RelPaths(p.Internal.AllGoFiles))\n+\t\t\tfiles := base.RelPaths(p.InternalAllGoFiles())\n \t\t\tbase.Run(cfg.BuildToolexec, str.StringList(base.Tool(\"fix\"), files))\n \n \t\t\t// The imports might have changed, so reload again.\n@@ -439,6 +438,11 @@ func downloadPackage(p *load.Package) error {\n \t\tp.Internal.Build.PkgRoot = filepath.Join(list[0], \"pkg\")\n \t}\n \troot := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))\n+\n+\tif err := checkNestedVCS(vcs, root, p.Internal.Build.SrcRoot); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// If we've considered this repository already, don't do it again.\n \tif downloadRootCache[root] {\n \t\treturn nil\n@@ -452,12 +456,8 @@ func downloadPackage(p *load.Package) error {\n \t// Check that this is an appropriate place for the repo to be checked out.\n \t// The target directory must either not exist or have a repo checked out already.\n \tmeta := filepath.Join(root, \".\"+vcs.cmd)\n-\tst, err := os.Stat(meta)\n-\tif err == nil && !st.IsDir() {\n-\t\treturn fmt.Errorf(\"%s exists but is not a directory\", meta)\n-\t}\n-\tif err != nil {\n-\t\t// Metadata directory does not exist. Prepare to checkout new copy.\n+\tif _, err := os.Stat(meta); err != nil {\n+\t\t// Metadata file or directory does not exist. Prepare to checkout new copy.\n \t\t// Some version control tools require the target directory not to exist.\n \t\t// We require that too, just to avoid stepping on existing work.\n \t\tif _, err := os.Stat(root); err == nil {"}, {"sha": "26693b13a93d82d1ceaa4c586d857d373b06d2e7", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 111, "deletions": 5, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -93,6 +93,7 @@ var vcsList = []*vcsCmd{\n \tvcsGit,\n \tvcsSvn,\n \tvcsBzr,\n+\tvcsFossil,\n }\n \n // vcsByCmd returns the version control system for the given\n@@ -324,6 +325,34 @@ func svnRemoteRepo(vcsSvn *vcsCmd, rootDir string) (remoteRepo string, err error\n \treturn strings.TrimSpace(out), nil\n }\n \n+// fossilRepoName is the name go get associates with a fossil repository. In the\n+// real world the file can be named anything.\n+const fossilRepoName = \".fossil\"\n+\n+// vcsFossil describes how to use Fossil (fossil-scm.org)\n+var vcsFossil = &vcsCmd{\n+\tname: \"Fossil\",\n+\tcmd:  \"fossil\",\n+\n+\tcreateCmd:   []string{\"-go-internal-mkdir {dir} clone {repo} \" + filepath.Join(\"{dir}\", fossilRepoName), \"-go-internal-cd {dir} open .fossil\"},\n+\tdownloadCmd: []string{\"up\"},\n+\n+\ttagCmd:         []tagCmd{{\"tag ls\", `(.*)`}},\n+\ttagSyncCmd:     []string{\"up tag:{tag}\"},\n+\ttagSyncDefault: []string{\"up trunk\"},\n+\n+\tscheme:     []string{\"https\", \"http\"},\n+\tremoteRepo: fossilRemoteRepo,\n+}\n+\n+func fossilRemoteRepo(vcsFossil *vcsCmd, rootDir string) (remoteRepo string, err error) {\n+\tout, err := vcsFossil.runOutput(rootDir, \"remote-url\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn strings.TrimSpace(string(out)), nil\n+}\n+\n func (v *vcsCmd) String() string {\n \treturn v.name\n }\n@@ -362,6 +391,19 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \t\targs[i] = expand(m, arg)\n \t}\n \n+\tif len(args) >= 2 && args[0] == \"-go-internal-mkdir\" {\n+\t\tvar err error\n+\t\tif filepath.IsAbs(args[1]) {\n+\t\t\terr = os.Mkdir(args[1], os.ModePerm)\n+\t\t} else {\n+\t\t\terr = os.Mkdir(filepath.Join(dir, args[1]), os.ModePerm)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\targs = args[2:]\n+\t}\n+\n \tif len(args) >= 2 && args[0] == \"-go-internal-cd\" {\n \t\tif filepath.IsAbs(args[1]) {\n \t\t\tdir = args[1]\n@@ -506,11 +548,28 @@ func vcsFromDir(dir, srcRoot string) (vcs *vcsCmd, root string, err error) {\n \t\treturn nil, \"\", fmt.Errorf(\"directory %q is outside source root %q\", dir, srcRoot)\n \t}\n \n+\tvar vcsRet *vcsCmd\n+\tvar rootRet string\n+\n \torigDir := dir\n \tfor len(dir) > len(srcRoot) {\n \t\tfor _, vcs := range vcsList {\n \t\t\tif _, err := os.Stat(filepath.Join(dir, \".\"+vcs.cmd)); err == nil {\n-\t\t\t\treturn vcs, filepath.ToSlash(dir[len(srcRoot)+1:]), nil\n+\t\t\t\troot := filepath.ToSlash(dir[len(srcRoot)+1:])\n+\t\t\t\t// Record first VCS we find, but keep looking,\n+\t\t\t\t// to detect mistakes like one kind of VCS inside another.\n+\t\t\t\tif vcsRet == nil {\n+\t\t\t\t\tvcsRet = vcs\n+\t\t\t\t\trootRet = root\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Allow .git inside .git, which can arise due to submodules.\n+\t\t\t\tif vcsRet == vcs && vcs.cmd == \"git\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Otherwise, we have one VCS inside a different VCS.\n+\t\t\t\treturn nil, \"\", fmt.Errorf(\"directory %q uses %s, but parent %q uses %s\",\n+\t\t\t\t\tfilepath.Join(srcRoot, rootRet), vcsRet.cmd, filepath.Join(srcRoot, root), vcs.cmd)\n \t\t\t}\n \t\t}\n \n@@ -523,9 +582,48 @@ func vcsFromDir(dir, srcRoot string) (vcs *vcsCmd, root string, err error) {\n \t\tdir = ndir\n \t}\n \n+\tif vcsRet != nil {\n+\t\treturn vcsRet, rootRet, nil\n+\t}\n+\n \treturn nil, \"\", fmt.Errorf(\"directory %q is not using a known version control system\", origDir)\n }\n \n+// checkNestedVCS checks for an incorrectly-nested VCS-inside-VCS\n+// situation for dir, checking parents up until srcRoot.\n+func checkNestedVCS(vcs *vcsCmd, dir, srcRoot string) error {\n+\tif len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {\n+\t\treturn fmt.Errorf(\"directory %q is outside source root %q\", dir, srcRoot)\n+\t}\n+\n+\totherDir := dir\n+\tfor len(otherDir) > len(srcRoot) {\n+\t\tfor _, otherVCS := range vcsList {\n+\t\t\tif _, err := os.Stat(filepath.Join(otherDir, \".\"+otherVCS.cmd)); err == nil {\n+\t\t\t\t// Allow expected vcs in original dir.\n+\t\t\t\tif otherDir == dir && otherVCS == vcs {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Allow .git inside .git, which can arise due to submodules.\n+\t\t\t\tif otherVCS == vcs && vcs.cmd == \"git\" {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Otherwise, we have one VCS inside a different VCS.\n+\t\t\t\treturn fmt.Errorf(\"directory %q uses %s, but parent %q uses %s\", dir, vcs.cmd, otherDir, otherVCS.cmd)\n+\t\t\t}\n+\t\t}\n+\t\t// Move to parent.\n+\t\tnewDir := filepath.Dir(otherDir)\n+\t\tif len(newDir) >= len(otherDir) {\n+\t\t\t// Shouldn't happen, but just in case, stop.\n+\t\t\tbreak\n+\t\t}\n+\t\totherDir = newDir\n+\t}\n+\n+\treturn nil\n+}\n+\n // repoRoot represents a version control system, a repo, and a root of\n // where to put it on disk.\n type repoRoot struct {\n@@ -872,7 +970,7 @@ var vcsPaths = []*vcsPath{\n \n \t// IBM DevOps Services (JazzHub)\n \t{\n-\t\tprefix: \"hub.jazz.net/git\",\n+\t\tprefix: \"hub.jazz.net/git/\",\n \t\tre:     `^(?P<root>hub.jazz.net/git/[a-z0-9]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n@@ -881,24 +979,32 @@ var vcsPaths = []*vcsPath{\n \n \t// Git at Apache\n \t{\n-\t\tprefix: \"git.apache.org\",\n+\t\tprefix: \"git.apache.org/\",\n \t\tre:     `^(?P<root>git.apache.org/[a-z0-9_.\\-]+\\.git)(/[A-Za-z0-9_.\\-]+)*$`,\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t},\n \n \t// Git at OpenStack\n \t{\n-\t\tprefix: \"git.openstack.org\",\n+\t\tprefix: \"git.openstack.org/\",\n \t\tre:     `^(?P<root>git\\.openstack\\.org/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(\\.git)?(/[A-Za-z0-9_.\\-]+)*$`,\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t},\n \n+\t// chiselapp.com for fossil\n+\t{\n+\t\tprefix: \"chiselapp.com/\",\n+\t\tre:     `^(?P<root>chiselapp\\.com/user/[A-Za-z0-9]+/repository/[A-Za-z0-9_.\\-]+)$`,\n+\t\tvcs:    \"fossil\",\n+\t\trepo:   \"https://{root}\",\n+\t},\n+\n \t// General syntax for any server.\n \t// Must be last.\n \t{\n-\t\tre:   `^(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\\-]+)+?)\\.(?P<vcs>bzr|git|hg|svn))(/~?[A-Za-z0-9_.\\-]+)*$`,\n+\t\tre:   `^(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\\-]+)+?)\\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\\-]+)*$`,\n \t\tping: true,\n \t},\n }"}, {"sha": "e29338aec19464e460a048ef91e03b414474eb95", "filename": "libgo/go/cmd/go/internal/get/vcs_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -154,6 +154,22 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\trepo: \"https://git.apache.org/package-name_2.x.git\",\n \t\t\t},\n \t\t},\n+\t\t{\n+\t\t\t\"chiselapp.com/user/kyle/repository/fossilgg\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsFossil,\n+\t\t\t\trepo: \"https://chiselapp.com/user/kyle/repository/fossilgg\",\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t// must have a user/$name/repository/$repo path\n+\t\t\t\"chiselapp.com/kyle/repository/fossilgg\",\n+\t\t\tnil,\n+\t\t},\n+\t\t{\n+\t\t\t\"chiselapp.com/user/kyle/fossilgg\",\n+\t\t\tnil,\n+\t\t},\n \t}\n \n \tfor _, test := range tests {\n@@ -241,6 +257,8 @@ func TestIsSecure(t *testing.T) {\n \t\t{vcsGit, \"example.com:path/to/repo.git\", false},\n \t\t{vcsGit, \"path/that/contains/a:colon/repo.git\", false},\n \t\t{vcsHg, \"ssh://user@example.com/path/to/repo.hg\", true},\n+\t\t{vcsFossil, \"http://example.com/foo\", false},\n+\t\t{vcsFossil, \"https://example.com/foo\", true},\n \t}\n \n \tfor _, test := range tests {"}, {"sha": "6dcba3722c63b750704eeabb1df5d7a2a6e7e0fd", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -471,6 +471,12 @@ General-purpose environment variables:\n \t\tSee https://golang.org/doc/articles/race_detector.html.\n \tGOROOT\n \t\tThe root of the go tree.\n+\tGOTMPDIR\n+\t\tThe directory where the go command will write\n+\t\ttemporary source files, packages, and binaries.\n+\tGOCACHE\n+\t\tThe directory where the go command will store\n+\t\tcached information for reuse in future builds.\n \n Environment variables for use with cgo:\n \n@@ -505,6 +511,9 @@ Architecture-specific environment variables:\n \tGO386\n \t\tFor GOARCH=386, the floating point instruction set.\n \t\tValid values are 387, sse2.\n+\tGOMIPS\n+\t\tFor GOARCH=mips{,le}, whether to use floating point instructions.\n+\t\tValid values are hardfloat (default), softfloat.\n \n Special-purpose environment variables:\n \n@@ -568,8 +577,10 @@ Non-test Go source files can also include a //go:binary-only-package\n comment, indicating that the package sources are included\n for documentation only and must not be used to build the\n package binary. This enables distribution of Go packages in\n-their compiled form alone. See the go/build package documentation\n-for more details.\n+their compiled form alone. Even binary-only packages require\n+accurate import blocks listing required dependencies, so that\n+those dependencies can be supplied when linking the resulting\n+command.\n \t`,\n }\n "}, {"sha": "7435273000421cabbe44e4526ebefb2d9e4a9180", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -152,7 +152,7 @@ var listJson = CmdList.Flag.Bool(\"json\", false, \"\")\n var nl = []byte{'\\n'}\n \n func runList(cmd *base.Command, args []string) {\n-\twork.BuildModeInit()\n+\twork.BuildInit()\n \tout := newTrackingWriter(os.Stdout)\n \tdefer out.w.Flush()\n \n@@ -194,12 +194,29 @@ func runList(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n-\tloadpkgs := load.Packages\n+\tvar pkgs []*load.Package\n \tif *listE {\n-\t\tloadpkgs = load.PackagesAndErrors\n+\t\tpkgs = load.PackagesAndErrors(args)\n+\t} else {\n+\t\tpkgs = load.Packages(args)\n+\t}\n+\n+\t// Estimate whether staleness information is needed,\n+\t// since it's a little bit of work to compute.\n+\tneedStale := *listJson || strings.Contains(*listFmt, \".Stale\")\n+\tif needStale {\n+\t\tvar b work.Builder\n+\t\tb.Init()\n+\t\tb.ComputeStaleOnly = true\n+\t\ta := &work.Action{}\n+\t\t// TODO: Use pkgsFilter?\n+\t\tfor _, p := range pkgs {\n+\t\t\ta.Deps = append(a.Deps, b.AutoAction(work.ModeInstall, work.ModeInstall, p))\n+\t\t}\n+\t\tb.Do(a)\n \t}\n \n-\tfor _, pkg := range loadpkgs(args) {\n+\tfor _, pkg := range pkgs {\n \t\t// Show vendor-expanded paths in listing\n \t\tpkg.TestImports = pkg.Vendored(pkg.TestImports)\n \t\tpkg.XTestImports = pkg.Vendored(pkg.XTestImports)"}, {"sha": "7ad4208ccc0bc61c2e4d639e014d3b04677ab5da", "filename": "libgo/go/cmd/go/internal/load/flag.go", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/str\"\n+\t\"fmt\"\n+\t\"strings\"\n+)\n+\n+var (\n+\tBuildAsmflags   PerPackageFlag // -asmflags\n+\tBuildGcflags    PerPackageFlag // -gcflags\n+\tBuildLdflags    PerPackageFlag // -ldflags\n+\tBuildGccgoflags PerPackageFlag // -gccgoflags\n+)\n+\n+// A PerPackageFlag is a command-line flag implementation (a flag.Value)\n+// that allows specifying different effective flags for different packages.\n+// See 'go help build' for more details about per-package flags.\n+type PerPackageFlag struct {\n+\tpresent bool\n+\tvalues  []ppfValue\n+}\n+\n+// A ppfValue is a single <pattern>=<flags> per-package flag value.\n+type ppfValue struct {\n+\tmatch func(*Package) bool // compiled pattern\n+\tflags []string\n+}\n+\n+// Set is called each time the flag is encountered on the command line.\n+func (f *PerPackageFlag) Set(v string) error {\n+\treturn f.set(v, base.Cwd)\n+}\n+\n+// set is the implementation of Set, taking a cwd (current working directory) for easier testing.\n+func (f *PerPackageFlag) set(v, cwd string) error {\n+\tf.present = true\n+\tmatch := func(p *Package) bool { return p.Internal.CmdlinePkg || p.Internal.CmdlineFiles } // default predicate with no pattern\n+\t// For backwards compatibility with earlier flag splitting, ignore spaces around flags.\n+\tv = strings.TrimSpace(v)\n+\tif v == \"\" {\n+\t\t// Special case: -gcflags=\"\" means no flags for command-line arguments\n+\t\t// (overrides previous -gcflags=\"-whatever\").\n+\t\tf.values = append(f.values, ppfValue{match, []string{}})\n+\t\treturn nil\n+\t}\n+\tif !strings.HasPrefix(v, \"-\") {\n+\t\ti := strings.Index(v, \"=\")\n+\t\tif i < 0 {\n+\t\t\treturn fmt.Errorf(\"missing =<value> in <pattern>=<value>\")\n+\t\t}\n+\t\tif i == 0 {\n+\t\t\treturn fmt.Errorf(\"missing <pattern> in <pattern>=<value>\")\n+\t\t}\n+\t\tpattern := strings.TrimSpace(v[:i])\n+\t\tmatch = MatchPackage(pattern, cwd)\n+\t\tv = v[i+1:]\n+\t}\n+\tflags, err := str.SplitQuotedFields(v)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif flags == nil {\n+\t\tflags = []string{}\n+\t}\n+\tf.values = append(f.values, ppfValue{match, flags})\n+\treturn nil\n+}\n+\n+// String is required to implement flag.Value.\n+// It is not used, because cmd/go never calls flag.PrintDefaults.\n+func (f *PerPackageFlag) String() string { return \"<PerPackageFlag>\" }\n+\n+// Present reports whether the flag appeared on the command line.\n+func (f *PerPackageFlag) Present() bool {\n+\treturn f.present\n+}\n+\n+// For returns the flags to use for the given package.\n+func (f *PerPackageFlag) For(p *Package) []string {\n+\tflags := []string{}\n+\tfor _, v := range f.values {\n+\t\tif v.match(p) {\n+\t\t\tflags = v.flags\n+\t\t}\n+\t}\n+\treturn flags\n+}\n+\n+var cmdlineMatchers []func(*Package) bool\n+\n+// SetCmdlinePatterns records the set of patterns given on the command line,\n+// for use by the PerPackageFlags.\n+func SetCmdlinePatterns(args []string) {\n+\tsetCmdlinePatterns(args, base.Cwd)\n+}\n+\n+func setCmdlinePatterns(args []string, cwd string) {\n+\tif len(args) == 0 {\n+\t\targs = []string{\".\"}\n+\t}\n+\tcmdlineMatchers = nil // allow reset for testing\n+\tfor _, arg := range args {\n+\t\tcmdlineMatchers = append(cmdlineMatchers, MatchPackage(arg, cwd))\n+\t}\n+}\n+\n+// isCmdlinePkg reports whether p is a package listed on the command line.\n+func isCmdlinePkg(p *Package) bool {\n+\tfor _, m := range cmdlineMatchers {\n+\t\tif m(p) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "d3223e12d52ec999bd4e29d5e1c62274f580eb93", "filename": "libgo/go/cmd/go/internal/load/flag_test.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fflag_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"fmt\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+type ppfTestPackage struct {\n+\tpath    string\n+\tdir     string\n+\tcmdline bool\n+\tflags   []string\n+}\n+\n+type ppfTest struct {\n+\targs []string\n+\tpkgs []ppfTestPackage\n+}\n+\n+var ppfTests = []ppfTest{\n+\t// -gcflags=-S applies only to packages on command line.\n+\t{\n+\t\targs: []string{\"-S\"},\n+\t\tpkgs: []ppfTestPackage{\n+\t\t\t{cmdline: true, flags: []string{\"-S\"}},\n+\t\t\t{cmdline: false, flags: []string{}},\n+\t\t},\n+\t},\n+\n+\t// -gcflags=-S -gcflags= overrides the earlier -S.\n+\t{\n+\t\targs: []string{\"-S\", \"\"},\n+\t\tpkgs: []ppfTestPackage{\n+\t\t\t{cmdline: true, flags: []string{}},\n+\t\t},\n+\t},\n+\n+\t// -gcflags=net=-S applies only to package net\n+\t{\n+\t\targs: []string{\"net=-S\"},\n+\t\tpkgs: []ppfTestPackage{\n+\t\t\t{path: \"math\", cmdline: true, flags: []string{}},\n+\t\t\t{path: \"net\", flags: []string{\"-S\"}},\n+\t\t},\n+\t},\n+\n+\t// -gcflags=net=-S -gcflags=net= also overrides the earlier -S\n+\t{\n+\t\targs: []string{\"net=-S\", \"net=\"},\n+\t\tpkgs: []ppfTestPackage{\n+\t\t\t{path: \"net\", flags: []string{}},\n+\t\t},\n+\t},\n+\n+\t// -gcflags=net/...=-S net math\n+\t// applies -S to net and net/http but not math\n+\t{\n+\t\targs: []string{\"net/...=-S\"},\n+\t\tpkgs: []ppfTestPackage{\n+\t\t\t{path: \"net\", flags: []string{\"-S\"}},\n+\t\t\t{path: \"net/http\", flags: []string{\"-S\"}},\n+\t\t\t{path: \"math\", flags: []string{}},\n+\t\t},\n+\t},\n+\n+\t// -gcflags=net/...=-S -gcflags=-m net math\n+\t// applies -m to net and math and -S to other packages matching net/...\n+\t// (net matches too, but it was grabbed by the later -gcflags).\n+\t{\n+\t\targs: []string{\"net/...=-S\", \"-m\"},\n+\t\tpkgs: []ppfTestPackage{\n+\t\t\t{path: \"net\", cmdline: true, flags: []string{\"-m\"}},\n+\t\t\t{path: \"math\", cmdline: true, flags: []string{\"-m\"}},\n+\t\t\t{path: \"net\", cmdline: false, flags: []string{\"-S\"}},\n+\t\t\t{path: \"net/http\", flags: []string{\"-S\"}},\n+\t\t\t{path: \"math\", flags: []string{}},\n+\t\t},\n+\t},\n+\n+\t// relative path patterns\n+\t// ppfDirTest(pattern, n, dirs...) says the first n dirs should match and the others should not.\n+\tppfDirTest(\".\", 1, \"/my/test/dir\", \"/my/test\", \"/my/test/other\", \"/my/test/dir/sub\"),\n+\tppfDirTest(\"..\", 1, \"/my/test\", \"/my/test/dir\", \"/my/test/other\", \"/my/test/dir/sub\"),\n+\tppfDirTest(\"./sub\", 1, \"/my/test/dir/sub\", \"/my/test\", \"/my/test/dir\", \"/my/test/other\", \"/my/test/dir/sub/sub\"),\n+\tppfDirTest(\"../other\", 1, \"/my/test/other\", \"/my/test\", \"/my/test/dir\", \"/my/test/other/sub\", \"/my/test/dir/other\", \"/my/test/dir/sub\"),\n+\tppfDirTest(\"./...\", 3, \"/my/test/dir\", \"/my/test/dir/sub\", \"/my/test/dir/sub/sub\", \"/my/test/other\", \"/my/test/other/sub\"),\n+\tppfDirTest(\"../...\", 4, \"/my/test/dir\", \"/my/test/other\", \"/my/test/dir/sub\", \"/my/test/other/sub\", \"/my/other/test\"),\n+\tppfDirTest(\"../...sub...\", 3, \"/my/test/dir/sub\", \"/my/test/othersub\", \"/my/test/yellowsubmarine\", \"/my/other/test\"),\n+}\n+\n+func ppfDirTest(pattern string, nmatch int, dirs ...string) ppfTest {\n+\tvar pkgs []ppfTestPackage\n+\tfor i, d := range dirs {\n+\t\tflags := []string{}\n+\t\tif i < nmatch {\n+\t\t\tflags = []string{\"-S\"}\n+\t\t}\n+\t\tpkgs = append(pkgs, ppfTestPackage{path: \"p\", dir: d, flags: flags})\n+\t}\n+\treturn ppfTest{args: []string{pattern + \"=-S\"}, pkgs: pkgs}\n+}\n+\n+func TestPerPackageFlag(t *testing.T) {\n+\tnativeDir := func(d string) string {\n+\t\tif filepath.Separator == '\\\\' {\n+\t\t\treturn `C:` + filepath.FromSlash(d)\n+\t\t}\n+\t\treturn d\n+\t}\n+\n+\tfor i, tt := range ppfTests {\n+\t\tt.Run(fmt.Sprintf(\"#%d\", i), func(t *testing.T) {\n+\t\t\tppFlags := new(PerPackageFlag)\n+\t\t\tfor _, arg := range tt.args {\n+\t\t\t\tt.Logf(\"set(%s)\", arg)\n+\t\t\t\tif err := ppFlags.set(arg, nativeDir(\"/my/test/dir\")); err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor _, p := range tt.pkgs {\n+\t\t\t\tdir := nativeDir(p.dir)\n+\t\t\t\tflags := ppFlags.For(&Package{PackagePublic: PackagePublic{ImportPath: p.path, Dir: dir}, Internal: PackageInternal{CmdlinePkg: p.cmdline}})\n+\t\t\t\tif !reflect.DeepEqual(flags, p.flags) {\n+\t\t\t\t\tt.Errorf(\"For(%v, %v, %v) = %v, want %v\", p.path, dir, p.cmdline, flags, p.flags)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "0b346df077253ca380ed17f46e041e0f1165c9d9", "filename": "libgo/go/cmd/go/internal/load/icfg.go", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ficfg.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"errors\"\n+\t\"io/ioutil\"\n+)\n+\n+// DebugDeprecatedImportcfg is installed as the undocumented -debug-deprecated-importcfg build flag.\n+// It is useful for debugging subtle problems in the go command logic but not something\n+// we want users to depend on. The hope is that the \"deprecated\" will make that clear.\n+// We intend to remove this flag in Go 1.11.\n+var DebugDeprecatedImportcfg debugDeprecatedImportcfgFlag\n+\n+type debugDeprecatedImportcfgFlag struct {\n+\tenabled bool\n+\tpkgs    map[string]*debugDeprecatedImportcfgPkg\n+}\n+\n+type debugDeprecatedImportcfgPkg struct {\n+\tDir    string\n+\tImport map[string]string\n+}\n+\n+var (\n+\tdebugDeprecatedImportcfgMagic = []byte(\"# debug-deprecated-importcfg\\n\")\n+\terrImportcfgSyntax            = errors.New(\"malformed syntax\")\n+)\n+\n+func (f *debugDeprecatedImportcfgFlag) String() string { return \"\" }\n+\n+func (f *debugDeprecatedImportcfgFlag) Set(x string) error {\n+\tif x == \"\" {\n+\t\t*f = debugDeprecatedImportcfgFlag{}\n+\t\treturn nil\n+\t}\n+\tdata, err := ioutil.ReadFile(x)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif !bytes.HasPrefix(data, debugDeprecatedImportcfgMagic) {\n+\t\treturn errImportcfgSyntax\n+\t}\n+\tdata = data[len(debugDeprecatedImportcfgMagic):]\n+\n+\tf.pkgs = nil\n+\tif err := json.Unmarshal(data, &f.pkgs); err != nil {\n+\t\treturn errImportcfgSyntax\n+\t}\n+\tf.enabled = true\n+\treturn nil\n+}\n+\n+func (f *debugDeprecatedImportcfgFlag) lookup(parent *Package, path string) (dir, newPath string) {\n+\tif parent == nil {\n+\t\tif p1 := f.pkgs[path]; p1 != nil {\n+\t\t\treturn p1.Dir, path\n+\t\t}\n+\t\treturn \"\", \"\"\n+\t}\n+\tif p1 := f.pkgs[parent.ImportPath]; p1 != nil {\n+\t\tif newPath := p1.Import[path]; newPath != \"\" {\n+\t\t\tif p2 := f.pkgs[newPath]; p2 != nil {\n+\t\t\t\treturn p2.Dir, newPath\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn \"\", \"\"\n+}"}, {"sha": "8ea56f240732c97c11e65c4e8dd655f8750e4676", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 266, "deletions": 709, "changes": 975, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -6,7 +6,6 @@\n package load\n \n import (\n-\t\"crypto/sha1\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/token\"\n@@ -20,7 +19,6 @@ import (\n \t\"unicode\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/buildid\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/str\"\n )\n@@ -42,16 +40,20 @@ type PackagePublic struct {\n \tImportComment string `json:\",omitempty\"` // path in import comment on package statement\n \tName          string `json:\",omitempty\"` // package name\n \tDoc           string `json:\",omitempty\"` // package documentation string\n-\tTarget        string `json:\",omitempty\"` // install path\n+\tTarget        string `json:\",omitempty\"` // installed target for this package (may be executable)\n \tShlib         string `json:\",omitempty\"` // the shared library that contains this package (only set when -linkshared)\n \tGoroot        bool   `json:\",omitempty\"` // is this package found in the Go root?\n \tStandard      bool   `json:\",omitempty\"` // is this package part of the standard Go library?\n-\tStale         bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n-\tStaleReason   string `json:\",omitempty\"` // why is Stale true?\n \tRoot          string `json:\",omitempty\"` // Go root or Go path dir containing this package\n \tConflictDir   string `json:\",omitempty\"` // Dir is hidden by this other directory\n \tBinaryOnly    bool   `json:\",omitempty\"` // package cannot be recompiled\n \n+\t// Stale and StaleReason remain here *only* for the list command.\n+\t// They are only initialized in preparation for list execution.\n+\t// The regular build determines staleness on the fly during action execution.\n+\tStale       bool   `json:\",omitempty\"` // would 'go install' do anything for this package?\n+\tStaleReason string `json:\",omitempty\"` // why is Stale true?\n+\n \t// Source files\n \tGoFiles        []string `json:\",omitempty\"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n \tCgoFiles       []string `json:\",omitempty\"` // .go sources files that import \"C\"\n@@ -93,25 +95,23 @@ type PackagePublic struct {\n type PackageInternal struct {\n \t// Unexported fields are not part of the public API.\n \tBuild        *build.Package\n-\tPkgdir       string // overrides build.PkgDir\n-\tImports      []*Package\n-\tDeps         []*Package\n-\tGoFiles      []string // GoFiles+CgoFiles+TestGoFiles+XTestGoFiles files, absolute paths\n-\tSFiles       []string\n-\tAllGoFiles   []string             // gofiles + IgnoredGoFiles, absolute paths\n-\tTarget       string               // installed file for this package (may be executable)\n-\tFake         bool                 // synthesized package\n-\tExternal     bool                 // synthesized external test package\n+\tImports      []*Package           // this package's direct imports\n+\tRawImports   []string             // this package's original imports as they appear in the text of the program\n \tForceLibrary bool                 // this package is a library (even if named \"main\")\n-\tCmdline      bool                 // defined by files listed on command line\n+\tCmdlineFiles bool                 // package built from files listed on command line\n+\tCmdlinePkg   bool                 // package listed on command line\n \tLocal        bool                 // imported via local path (./ or ../)\n \tLocalPrefix  string               // interpret ./ and ../ imports relative to this prefix\n \tExeName      string               // desired name for temporary executable\n \tCoverMode    string               // preprocess Go source files with the coverage tool in this mode\n \tCoverVars    map[string]*CoverVar // variables created by coverage analysis\n \tOmitDebug    bool                 // tell linker not to write debug information\n-\tBuildID      string               // expected build ID for generated package\n \tGobinSubdir  bool                 // install target would be subdir of GOBIN\n+\n+\tAsmflags   []string // -asmflags for this package\n+\tGcflags    []string // -gcflags for this package\n+\tLdflags    []string // -ldflags for this package\n+\tGccgoflags []string // -gccgoflags for this package\n }\n \n type NoGoError struct {\n@@ -219,6 +219,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \t// We modify p.Imports in place, so make copy now.\n \tp.Imports = make([]string, len(pp.Imports))\n \tcopy(p.Imports, pp.Imports)\n+\tp.Internal.RawImports = pp.Imports\n \tp.TestGoFiles = pp.TestGoFiles\n \tp.TestImports = pp.TestImports\n \tp.XTestGoFiles = pp.XTestGoFiles\n@@ -354,7 +355,7 @@ func makeImportValid(r rune) rune {\n \n // Mode flags for loadImport and download (in get.go).\n const (\n-\t// useVendor means that loadImport should do vendor expansion\n+\t// UseVendor means that loadImport should do vendor expansion\n \t// (provided the vendoring experiment is enabled).\n \t// That is, useVendor means that the import path came from\n \t// a source file and has not been vendor-expanded yet.\n@@ -365,12 +366,12 @@ const (\n \t// disallowVendor will reject direct use of paths containing /vendor/.\n \tUseVendor = 1 << iota\n \n-\t// getTestDeps is for download (part of \"go get\") and indicates\n+\t// GetTestDeps is for download (part of \"go get\") and indicates\n \t// that test dependencies should be fetched too.\n \tGetTestDeps\n )\n \n-// loadImport scans the directory named by path, which must be an import path,\n+// LoadImport scans the directory named by path, which must be an import path,\n // but possibly a local import path (an absolute file system path or one beginning\n // with ./ or ../). A local relative path is interpreted relative to srcDir.\n // It returns a *Package describing the package found in that directory.\n@@ -386,8 +387,14 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \timportPath := path\n \torigPath := path\n \tisLocal := build.IsLocalImport(path)\n+\tvar debugDeprecatedImportcfgDir string\n \tif isLocal {\n \t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n+\t} else if DebugDeprecatedImportcfg.enabled {\n+\t\tif d, i := DebugDeprecatedImportcfg.lookup(parent, path); d != \"\" {\n+\t\t\tdebugDeprecatedImportcfgDir = d\n+\t\t\timportPath = i\n+\t\t}\n \t} else if mode&UseVendor != 0 {\n \t\t// We do our own vendor resolution, because we want to\n \t\t// find out the key to use in packageCache without the\n@@ -409,20 +416,23 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\t// Load package.\n \t\t// Import always returns bp != nil, even if an error occurs,\n \t\t// in order to return partial information.\n-\t\t//\n-\t\t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n-\t\t// See issue 3268 for mistakes to avoid.\n-\t\tbuildMode := build.ImportComment\n-\t\tif mode&UseVendor == 0 || path != origPath {\n-\t\t\t// Not vendoring, or we already found the vendored path.\n-\t\t\tbuildMode |= build.IgnoreVendor\n-\t\t}\n-\t\tbp, err := cfg.BuildContext.Import(path, srcDir, buildMode)\n+\t\tvar bp *build.Package\n+\t\tvar err error\n+\t\tif debugDeprecatedImportcfgDir != \"\" {\n+\t\t\tbp, err = cfg.BuildContext.ImportDir(debugDeprecatedImportcfgDir, 0)\n+\t\t} else {\n+\t\t\tbuildMode := build.ImportComment\n+\t\t\tif mode&UseVendor == 0 || path != origPath {\n+\t\t\t\t// Not vendoring, or we already found the vendored path.\n+\t\t\t\tbuildMode |= build.IgnoreVendor\n+\t\t\t}\n+\t\t\tbp, err = cfg.BuildContext.Import(path, srcDir, buildMode)\n+\t\t}\n \t\tbp.ImportPath = importPath\n \t\tif cfg.GOBIN != \"\" {\n \t\t\tbp.BinDir = cfg.GOBIN\n \t\t}\n-\t\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n+\t\tif debugDeprecatedImportcfgDir == \"\" && err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n \t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n \t\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n \t\t}\n@@ -431,7 +441,7 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\t\tp = setErrorPos(p, importPos)\n \t\t}\n \n-\t\tif origPath != cleanImport(origPath) {\n+\t\tif debugDeprecatedImportcfgDir == \"\" && origPath != cleanImport(origPath) {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", origPath, pathpkg.Clean(origPath)),\n@@ -806,45 +816,27 @@ func FindVendor(path string) (index int, ok bool) {\n \treturn 0, false\n }\n \n-type targetDir int\n+type TargetDir int\n \n const (\n-\tToRoot    targetDir = iota // to bin dir inside package root (default)\n-\tToTool                     // GOROOT/pkg/tool\n-\tStalePath                  // the old import path; fail to build\n+\tToTool    TargetDir = iota // to GOROOT/pkg/tool (default for cmd/*)\n+\tToBin                      // to bin dir inside package root (default for non-cmd/*)\n+\tStalePath                  // an old import path; fail to build\n )\n \n-// goTools is a map of Go program import path to install target directory.\n-var GoTools = map[string]targetDir{\n-\t\"cmd/addr2line\": ToTool,\n-\t\"cmd/api\":       ToTool,\n-\t\"cmd/asm\":       ToTool,\n-\t\"cmd/compile\":   ToTool,\n-\t\"cmd/cgo\":       ToTool,\n-\t\"cmd/cover\":     ToTool,\n-\t\"cmd/dist\":      ToTool,\n-\t\"cmd/doc\":       ToTool,\n-\t\"cmd/fix\":       ToTool,\n-\t\"cmd/link\":      ToTool,\n-\t\"cmd/newlink\":   ToTool,\n-\t\"cmd/nm\":        ToTool,\n-\t\"cmd/objdump\":   ToTool,\n-\t\"cmd/pack\":      ToTool,\n-\t\"cmd/pprof\":     ToTool,\n-\t\"cmd/trace\":     ToTool,\n-\t\"cmd/vet\":       ToTool,\n-\t\"code.google.com/p/go.tools/cmd/cover\": StalePath,\n-\t\"code.google.com/p/go.tools/cmd/godoc\": StalePath,\n-\t\"code.google.com/p/go.tools/cmd/vet\":   StalePath,\n-}\n-\n-var raceExclude = map[string]bool{\n-\t\"runtime/race\": true,\n-\t\"runtime/msan\": true,\n-\t\"runtime/cgo\":  true,\n-\t\"cmd/cgo\":      true,\n-\t\"syscall\":      true,\n-\t\"errors\":       true,\n+// InstallTargetDir reports the target directory for installing the command p.\n+func InstallTargetDir(p *Package) TargetDir {\n+\tif strings.HasPrefix(p.ImportPath, \"code.google.com/p/go.tools/cmd/\") {\n+\t\treturn StalePath\n+\t}\n+\tif p.Goroot && strings.HasPrefix(p.ImportPath, \"cmd/\") && p.Name == \"main\" {\n+\t\tswitch p.ImportPath {\n+\t\tcase \"cmd/go\", \"cmd/gofmt\":\n+\t\t\treturn ToBin\n+\t\t}\n+\t\treturn ToTool\n+\t}\n+\treturn ToBin\n }\n \n var cgoExclude = map[string]bool{\n@@ -861,7 +853,7 @@ var foldPath = make(map[string]string)\n \n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n-func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package {\n+func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \tp.copyBuild(bp)\n \n \t// When using gccgo the go/build package will not be able to\n@@ -871,9 +863,31 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\terr = nil\n \t}\n \n+\t// Decide whether p was listed on the command line.\n+\t// Given that load is called while processing the command line,\n+\t// you might think we could simply pass a flag down into load\n+\t// saying whether we are loading something named on the command\n+\t// line or something to satisfy an import. But the first load of a\n+\t// package named on the command line may be as a dependency\n+\t// of an earlier package named on the command line, not when we\n+\t// get to that package during command line processing.\n+\t// For example \"go test fmt reflect\" will load reflect as a dependency\n+\t// of fmt before it attempts to load as a command-line argument.\n+\t// Because loads are cached, the later load will be a no-op,\n+\t// so it is important that the first load can fill in CmdlinePkg correctly.\n+\t// Hence the call to an explicit matching check here.\n+\tp.Internal.CmdlinePkg = isCmdlinePkg(p)\n+\n+\tp.Internal.Asmflags = BuildAsmflags.For(p)\n+\tp.Internal.Gcflags = BuildGcflags.For(p)\n+\tp.Internal.Ldflags = BuildLdflags.For(p)\n+\tp.Internal.Gccgoflags = BuildGccgoflags.For(p)\n+\n \t// The localPrefix is the path we interpret ./ imports relative to.\n \t// Synthesized main packages sometimes override this.\n-\tp.Internal.LocalPrefix = dirToImportPath(p.Dir)\n+\tif p.Internal.Local {\n+\t\tp.Internal.LocalPrefix = dirToImportPath(p.Dir)\n+\t}\n \n \tif err != nil {\n \t\tif _, ok := err.(*build.NoGoError); ok {\n@@ -885,7 +899,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         err.Error(),\n \t\t}\n-\t\treturn p\n+\t\treturn\n \t}\n \n \tuseBindir := p.Name == \"main\"\n@@ -898,11 +912,11 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \n \tif useBindir {\n \t\t// Report an error when the old code.google.com/p/go.tools paths are used.\n-\t\tif GoTools[p.ImportPath] == StalePath {\n+\t\tif InstallTargetDir(p) == StalePath {\n \t\t\tnewPath := strings.Replace(p.ImportPath, \"code.google.com/p/go.\", \"golang.org/x/\", 1)\n \t\t\te := fmt.Sprintf(\"the %v command has moved; use %v instead.\", p.ImportPath, newPath)\n \t\t\tp.Error = &PackageError{Err: e}\n-\t\t\treturn p\n+\t\t\treturn\n \t\t}\n \t\t_, elem := filepath.Split(p.Dir)\n \t\tfull := cfg.BuildContext.GOOS + \"_\" + cfg.BuildContext.GOARCH + \"/\" + elem\n@@ -912,128 +926,85 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\t}\n \t\tif p.Internal.Build.BinDir != \"\" {\n \t\t\t// Install to GOBIN or bin of GOPATH entry.\n-\t\t\tp.Internal.Target = filepath.Join(p.Internal.Build.BinDir, elem)\n+\t\t\tp.Target = filepath.Join(p.Internal.Build.BinDir, elem)\n \t\t\tif !p.Goroot && strings.Contains(elem, \"/\") && cfg.GOBIN != \"\" {\n \t\t\t\t// Do not create $GOBIN/goos_goarch/elem.\n-\t\t\t\tp.Internal.Target = \"\"\n+\t\t\t\tp.Target = \"\"\n \t\t\t\tp.Internal.GobinSubdir = true\n \t\t\t}\n \t\t}\n-\t\tif GoTools[p.ImportPath] == ToTool {\n+\t\tif InstallTargetDir(p) == ToTool {\n \t\t\t// This is for 'go tool'.\n \t\t\t// Override all the usual logic and force it into the tool directory.\n \t\t\tif cfg.BuildToolchainName == \"gccgo\" {\n-\t\t\t\tp.Internal.Target = filepath.Join(runtime.GCCGOTOOLDIR, elem)\n+\t\t\t\tp.Target = filepath.Join(runtime.GCCGOTOOLDIR, elem)\n \t\t\t} else {\n-\t\t\t\tp.Internal.Target = filepath.Join(cfg.GOROOTpkg, \"tool\", full)\n+\t\t\t\tp.Target = filepath.Join(cfg.GOROOTpkg, \"tool\", full)\n \t\t\t}\n \t\t}\n-\t\tif p.Internal.Target != \"\" && cfg.BuildContext.GOOS == \"windows\" {\n-\t\t\tp.Internal.Target += \".exe\"\n+\t\tif p.Target != \"\" && cfg.BuildContext.GOOS == \"windows\" {\n+\t\t\tp.Target += \".exe\"\n \t\t}\n \t} else if p.Internal.Local {\n \t\t// Local import turned into absolute path.\n \t\t// No permanent install target.\n-\t\tp.Internal.Target = \"\"\n+\t\tp.Target = \"\"\n \t} else {\n-\t\tp.Internal.Target = p.Internal.Build.PkgObj\n+\t\tp.Target = p.Internal.Build.PkgObj\n \t\tif cfg.BuildLinkshared {\n-\t\t\tshlibnamefile := p.Internal.Target[:len(p.Internal.Target)-2] + \".shlibname\"\n+\t\t\tshlibnamefile := p.Target[:len(p.Target)-2] + \".shlibname\"\n \t\t\tshlib, err := ioutil.ReadFile(shlibnamefile)\n+\t\t\tif err != nil && !os.IsNotExist(err) {\n+\t\t\t\tbase.Fatalf(\"reading shlibname: %v\", err)\n+\t\t\t}\n \t\t\tif err == nil {\n \t\t\t\tlibname := strings.TrimSpace(string(shlib))\n \t\t\t\tif cfg.BuildContext.Compiler == \"gccgo\" {\n \t\t\t\t\tp.Shlib = filepath.Join(p.Internal.Build.PkgTargetRoot, \"shlibs\", libname)\n \t\t\t\t} else {\n \t\t\t\t\tp.Shlib = filepath.Join(p.Internal.Build.PkgTargetRoot, libname)\n-\n \t\t\t\t}\n-\t\t\t} else if !os.IsNotExist(err) {\n-\t\t\t\tbase.Fatalf(\"unexpected error reading %s: %v\", shlibnamefile, err)\n \t\t\t}\n \t\t}\n \t}\n \n-\tImportPaths := p.Imports\n-\t// Packages that use cgo import runtime/cgo implicitly.\n-\t// Packages that use cgo also import syscall implicitly,\n-\t// to wrap errno.\n-\t// Exclude certain packages to avoid circular dependencies.\n-\tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoExclude[p.ImportPath]) {\n-\t\tImportPaths = append(ImportPaths, \"runtime/cgo\")\n-\t}\n-\tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n-\t\tImportPaths = append(ImportPaths, \"syscall\")\n-\t}\n-\n-\tif cfg.BuildContext.CgoEnabled && p.Name == \"main\" && !p.Goroot {\n-\t\t// Currently build modes c-shared, pie (on systems that do not\n-\t\t// support PIE with internal linking mode), plugin, and\n-\t\t// -linkshared force external linking mode, as of course does\n-\t\t// -ldflags=-linkmode=external. External linking mode forces\n-\t\t// an import of runtime/cgo.\n-\t\tpieCgo := cfg.BuildBuildmode == \"pie\" && (cfg.BuildContext.GOOS != \"linux\" || cfg.BuildContext.GOARCH != \"amd64\")\n-\t\tlinkmodeExternal := false\n-\t\tfor i, a := range cfg.BuildLdflags {\n-\t\t\tif a == \"-linkmode=external\" {\n-\t\t\t\tlinkmodeExternal = true\n+\t// Build augmented import list to add implicit dependencies.\n+\t// Be careful not to add imports twice, just to avoid confusion.\n+\timportPaths := p.Imports\n+\taddImport := func(path string) {\n+\t\tfor _, p := range importPaths {\n+\t\t\tif path == p {\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\tif a == \"-linkmode\" && i+1 < len(cfg.BuildLdflags) && cfg.BuildLdflags[i+1] == \"external\" {\n-\t\t\t\tlinkmodeExternal = true\n-\t\t\t}\n-\t\t}\n-\t\tif cfg.BuildBuildmode == \"c-shared\" || cfg.BuildBuildmode == \"plugin\" || pieCgo || cfg.BuildLinkshared || linkmodeExternal {\n-\t\t\tImportPaths = append(ImportPaths, \"runtime/cgo\")\n \t\t}\n+\t\timportPaths = append(importPaths, path)\n \t}\n \n-\t// Everything depends on runtime, except runtime, its internal\n-\t// subpackages, and unsafe.\n-\tif !p.Standard || (p.ImportPath != \"runtime\" && !strings.HasPrefix(p.ImportPath, \"runtime/internal/\") && p.ImportPath != \"unsafe\") {\n-\t\tImportPaths = append(ImportPaths, \"runtime\")\n-\t\t// When race detection enabled everything depends on runtime/race.\n-\t\t// Exclude certain packages to avoid circular dependencies.\n-\t\tif cfg.BuildRace && (!p.Standard || !raceExclude[p.ImportPath]) {\n-\t\t\tImportPaths = append(ImportPaths, \"runtime/race\")\n-\t\t}\n-\t\t// MSan uses runtime/msan.\n-\t\tif cfg.BuildMSan && (!p.Standard || !raceExclude[p.ImportPath]) {\n-\t\t\tImportPaths = append(ImportPaths, \"runtime/msan\")\n-\t\t}\n-\t\t// On ARM with GOARM=5, everything depends on math for the link.\n-\t\tif p.Name == \"main\" && cfg.Goarch == \"arm\" {\n-\t\t\tImportPaths = append(ImportPaths, \"math\")\n-\t\t}\n+\t// Cgo translation adds imports of \"runtime/cgo\" and \"syscall\",\n+\t// except for certain packages, to avoid circular dependencies.\n+\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) {\n+\t\taddImport(\"runtime/cgo\")\n \t}\n-\n-\t// Runtime and its internal packages depend on runtime/internal/sys,\n-\t// so that they pick up the generated zversion.go file.\n-\t// This can be an issue particularly for runtime/internal/atomic;\n-\t// see issue 13655.\n-\tif p.Standard && (p.ImportPath == \"runtime\" || strings.HasPrefix(p.ImportPath, \"runtime/internal/\")) && p.ImportPath != \"runtime/internal/sys\" {\n-\t\tImportPaths = append(ImportPaths, \"runtime/internal/sys\")\n+\tif p.UsesCgo() && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n+\t\taddImport(\"syscall\")\n \t}\n \n-\t// Build list of full paths to all Go files in the package,\n-\t// for use by commands like go fmt.\n-\tp.Internal.GoFiles = str.StringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles)\n-\tfor i := range p.Internal.GoFiles {\n-\t\tp.Internal.GoFiles[i] = filepath.Join(p.Dir, p.Internal.GoFiles[i])\n-\t}\n-\tsort.Strings(p.Internal.GoFiles)\n+\t// SWIG adds imports of some standard packages.\n+\tif p.UsesSwig() {\n+\t\taddImport(\"runtime/cgo\")\n+\t\taddImport(\"syscall\")\n+\t\taddImport(\"sync\")\n \n-\tp.Internal.SFiles = str.StringList(p.SFiles)\n-\tfor i := range p.Internal.SFiles {\n-\t\tp.Internal.SFiles[i] = filepath.Join(p.Dir, p.Internal.SFiles[i])\n+\t\t// TODO: The .swig and .swigcxx files can use\n+\t\t// %go_import directives to import other packages.\n \t}\n-\tsort.Strings(p.Internal.SFiles)\n \n-\tp.Internal.AllGoFiles = str.StringList(p.IgnoredGoFiles)\n-\tfor i := range p.Internal.AllGoFiles {\n-\t\tp.Internal.AllGoFiles[i] = filepath.Join(p.Dir, p.Internal.AllGoFiles[i])\n+\t// The linker loads implicit dependencies.\n+\tif p.Name == \"main\" && !p.Internal.ForceLibrary {\n+\t\tfor _, dep := range LinkerDeps(p) {\n+\t\t\taddImport(dep)\n+\t\t}\n \t}\n-\tp.Internal.AllGoFiles = append(p.Internal.AllGoFiles, p.Internal.GoFiles...)\n-\tsort.Strings(p.Internal.AllGoFiles)\n \n \t// Check for case-insensitive collision of input files.\n \t// To avoid problems on case-insensitive files, we reject any package\n@@ -1060,23 +1031,12 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         fmt.Sprintf(\"case-insensitive file name collision: %q and %q\", f1, f2),\n \t\t}\n-\t\treturn p\n+\t\treturn\n \t}\n \n \t// Build list of imported packages and full dependency list.\n \timports := make([]*Package, 0, len(p.Imports))\n-\tdeps := make(map[string]*Package)\n-\tsave := func(path string, p1 *Package) {\n-\t\t// The same import path could produce an error or not,\n-\t\t// depending on what tries to import it.\n-\t\t// Prefer to record entries with errors, so we can report them.\n-\t\tp0 := deps[path]\n-\t\tif p0 == nil || p1.Error != nil && (p0.Error == nil || len(p0.Error.ImportStack) > len(p1.Error.ImportStack)) {\n-\t\t\tdeps[path] = p1\n-\t\t}\n-\t}\n-\n-\tfor i, path := range ImportPaths {\n+\tfor i, path := range importPaths {\n \t\tif path == \"C\" {\n \t\t\tcontinue\n \t\t}\n@@ -1096,22 +1056,38 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\t}\n \n \t\tpath = p1.ImportPath\n-\t\tImportPaths[i] = path\n+\t\timportPaths[i] = path\n \t\tif i < len(p.Imports) {\n \t\t\tp.Imports[i] = path\n \t\t}\n \n-\t\tsave(path, p1)\n \t\timports = append(imports, p1)\n-\t\tfor _, dep := range p1.Internal.Deps {\n-\t\t\tsave(dep.ImportPath, dep)\n-\t\t}\n \t\tif p1.Incomplete {\n \t\t\tp.Incomplete = true\n \t\t}\n \t}\n \tp.Internal.Imports = imports\n \n+\tdeps := make(map[string]*Package)\n+\tvar q []*Package\n+\tq = append(q, imports...)\n+\tfor i := 0; i < len(q); i++ {\n+\t\tp1 := q[i]\n+\t\tpath := p1.ImportPath\n+\t\t// The same import path could produce an error or not,\n+\t\t// depending on what tries to import it.\n+\t\t// Prefer to record entries with errors, so we can report them.\n+\t\tp0 := deps[path]\n+\t\tif p0 == nil || p1.Error != nil && (p0.Error == nil || len(p0.Error.ImportStack) > len(p1.Error.ImportStack)) {\n+\t\t\tdeps[path] = p1\n+\t\t\tfor _, p2 := range p1.Internal.Imports {\n+\t\t\t\tif deps[p2.ImportPath] != p2 {\n+\t\t\t\t\tq = append(q, p2)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tp.Deps = make([]string, 0, len(deps))\n \tfor dep := range deps {\n \t\tp.Deps = append(p.Deps, dep)\n@@ -1122,17 +1098,15 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\tif p1 == nil {\n \t\t\tpanic(\"impossible: missing entry in package cache for \" + dep + \" imported by \" + p.ImportPath)\n \t\t}\n-\t\tp.Internal.Deps = append(p.Internal.Deps, p1)\n \t\tif p1.Error != nil {\n \t\t\tp.DepsErrors = append(p.DepsErrors, p1.Error)\n \t\t}\n \t}\n \n \t// unsafe is a fake package.\n \tif p.Standard && (p.ImportPath == \"unsafe\" || cfg.BuildContext.Compiler == \"gccgo\") {\n-\t\tp.Internal.Target = \"\"\n+\t\tp.Target = \"\"\n \t}\n-\tp.Target = p.Internal.Target\n \n \t// If cgo is not enabled, ignore cgo supporting sources\n \t// just as we ignore go files containing import \"C\".\n@@ -1148,37 +1122,137 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package\n \t\t// code; see issue #16050).\n \t}\n \n-\t// The gc toolchain only permits C source files with cgo.\n-\tif len(p.CFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() && cfg.BuildContext.Compiler == \"gc\" {\n+\tsetError := func(msg string) {\n \t\tp.Error = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CFiles, \" \")),\n+\t\t\tErr:         msg,\n \t\t}\n-\t\treturn p\n+\t}\n+\n+\t// The gc toolchain only permits C source files with cgo or SWIG.\n+\tif len(p.CFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() && cfg.BuildContext.Compiler == \"gc\" {\n+\t\tsetError(fmt.Sprintf(\"C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CFiles, \" \")))\n+\t\treturn\n+\t}\n+\n+\t// C++, Objective-C, and Fortran source files are permitted only with cgo or SWIG,\n+\t// regardless of toolchain.\n+\tif len(p.CXXFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() {\n+\t\tsetError(fmt.Sprintf(\"C++ source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CXXFiles, \" \")))\n+\t\treturn\n+\t}\n+\tif len(p.MFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() {\n+\t\tsetError(fmt.Sprintf(\"Objective-C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.MFiles, \" \")))\n+\t\treturn\n+\t}\n+\tif len(p.FFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() {\n+\t\tsetError(fmt.Sprintf(\"Fortran source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.FFiles, \" \")))\n+\t\treturn\n \t}\n \n \t// Check for case-insensitive collisions of import paths.\n \tfold := str.ToFold(p.ImportPath)\n \tif other := foldPath[fold]; other == \"\" {\n \t\tfoldPath[fold] = p.ImportPath\n \t} else if other != p.ImportPath {\n-\t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"case-insensitive import collision: %q and %q\", p.ImportPath, other),\n+\t\tsetError(fmt.Sprintf(\"case-insensitive import collision: %q and %q\", p.ImportPath, other))\n+\t\treturn\n+\t}\n+}\n+\n+// LinkerDeps returns the list of linker-induced dependencies for main package p.\n+func LinkerDeps(p *Package) []string {\n+\t// Everything links runtime.\n+\tdeps := []string{\"runtime\"}\n+\n+\t// External linking mode forces an import of runtime/cgo.\n+\tif externalLinkingForced(p) {\n+\t\tdeps = append(deps, \"runtime/cgo\")\n+\t}\n+\t// On ARM with GOARM=5, it forces an import of math, for soft floating point.\n+\tif cfg.Goarch == \"arm\" {\n+\t\tdeps = append(deps, \"math\")\n+\t}\n+\t// Using the race detector forces an import of runtime/race.\n+\tif cfg.BuildRace {\n+\t\tdeps = append(deps, \"runtime/race\")\n+\t}\n+\t// Using memory sanitizer forces an import of runtime/msan.\n+\tif cfg.BuildMSan {\n+\t\tdeps = append(deps, \"runtime/msan\")\n+\t}\n+\n+\treturn deps\n+}\n+\n+// externalLinkingForced reports whether external linking is being\n+// forced even for programs that do not use cgo.\n+func externalLinkingForced(p *Package) bool {\n+\t// Some targets must use external linking even inside GOROOT.\n+\tswitch cfg.BuildContext.GOOS {\n+\tcase \"android\":\n+\t\treturn true\n+\tcase \"darwin\":\n+\t\tswitch cfg.BuildContext.GOARCH {\n+\t\tcase \"arm\", \"arm64\":\n+\t\t\treturn true\n \t\t}\n-\t\treturn p\n \t}\n \n-\tif p.BinaryOnly {\n-\t\t// For binary-only package, use build ID from supplied package binary.\n-\t\tbuildID, err := buildid.ReadBuildID(p.Name, p.Target)\n-\t\tif err == nil {\n-\t\t\tp.Internal.BuildID = buildID\n+\tif !cfg.BuildContext.CgoEnabled {\n+\t\treturn false\n+\t}\n+\t// Currently build modes c-shared, pie (on systems that do not\n+\t// support PIE with internal linking mode (currently all\n+\t// systems: issue #18968)), plugin, and -linkshared force\n+\t// external linking mode, as of course does\n+\t// -ldflags=-linkmode=external. External linking mode forces\n+\t// an import of runtime/cgo.\n+\tpieCgo := cfg.BuildBuildmode == \"pie\"\n+\tlinkmodeExternal := false\n+\tif p != nil {\n+\t\tldflags := BuildLdflags.For(p)\n+\t\tfor i, a := range ldflags {\n+\t\t\tif a == \"-linkmode=external\" {\n+\t\t\t\tlinkmodeExternal = true\n+\t\t\t}\n+\t\t\tif a == \"-linkmode\" && i+1 < len(ldflags) && ldflags[i+1] == \"external\" {\n+\t\t\t\tlinkmodeExternal = true\n+\t\t\t}\n \t\t}\n-\t} else {\n-\t\tcomputeBuildID(p)\n \t}\n-\treturn p\n+\n+\treturn cfg.BuildBuildmode == \"c-shared\" || cfg.BuildBuildmode == \"plugin\" || pieCgo || cfg.BuildLinkshared || linkmodeExternal\n+}\n+\n+// mkAbs rewrites list, which must be paths relative to p.Dir,\n+// into a sorted list of absolute paths. It edits list in place but for\n+// convenience also returns list back to its caller.\n+func (p *Package) mkAbs(list []string) []string {\n+\tfor i, f := range list {\n+\t\tlist[i] = filepath.Join(p.Dir, f)\n+\t}\n+\tsort.Strings(list)\n+\treturn list\n+}\n+\n+// InternalGoFiles returns the list of Go files being built for the package,\n+// using absolute paths.\n+func (p *Package) InternalGoFiles() []string {\n+\treturn p.mkAbs(str.StringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n+}\n+\n+// InternalGoFiles returns the list of all Go files possibly relevant for the package,\n+// using absolute paths. \"Possibly relevant\" means that files are not excluded\n+// due to build tags, but files with names beginning with . or _ are still excluded.\n+func (p *Package) InternalAllGoFiles() []string {\n+\tvar extra []string\n+\tfor _, f := range p.IgnoredGoFiles {\n+\t\tif f != \"\" && f[0] != '.' || f[0] != '_' {\n+\t\t\textra = append(extra, f)\n+\t\t}\n+\t}\n+\treturn p.mkAbs(str.StringList(extra, p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles))\n }\n \n // usesSwig reports whether the package needs to run SWIG.\n@@ -1213,517 +1287,6 @@ func PackageList(roots []*Package) []*Package {\n \treturn all\n }\n \n-// computeStale computes the Stale flag in the package dag that starts\n-// at the named pkgs (command-line arguments).\n-func ComputeStale(pkgs ...*Package) {\n-\tfor _, p := range PackageList(pkgs) {\n-\t\tp.Stale, p.StaleReason = isStale(p)\n-\t}\n-}\n-\n-// The runtime version string takes one of two forms:\n-// \"go1.X[.Y]\" for Go releases, and \"devel +hash\" at tip.\n-// Determine whether we are in a released copy by\n-// inspecting the version.\n-var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n-\n-// isStale and computeBuildID\n-//\n-// Theory of Operation\n-//\n-// There is an installed copy of the package (or binary).\n-// Can we reuse the installed copy, or do we need to build a new one?\n-//\n-// We can use the installed copy if it matches what we'd get\n-// by building a new one. The hard part is predicting that without\n-// actually running a build.\n-//\n-// To start, we must know the set of inputs to the build process that can\n-// affect the generated output. At a minimum, that includes the source\n-// files for the package and also any compiled packages imported by those\n-// source files. The *Package has these, and we use them. One might also\n-// argue for including in the input set: the build tags, whether the race\n-// detector is in use, the target operating system and architecture, the\n-// compiler and linker binaries being used, the additional flags being\n-// passed to those, the cgo binary being used, the additional flags cgo\n-// passes to the host C compiler, the host C compiler being used, the set\n-// of host C include files and installed C libraries, and so on.\n-// We include some but not all of this information.\n-//\n-// Once we have decided on a set of inputs, we must next decide how to\n-// tell whether the content of that set has changed since the last build\n-// of p. If there have been no changes, then we assume a new build would\n-// produce the same result and reuse the installed package or binary.\n-// But if there have been changes, then we assume a new build might not\n-// produce the same result, so we rebuild.\n-//\n-// There are two common ways to decide whether the content of the set has\n-// changed: modification times and content hashes. We use a mixture of both.\n-//\n-// The use of modification times (mtimes) was pioneered by make:\n-// assuming that a file's mtime is an accurate record of when that file was last written,\n-// and assuming that the modification time of an installed package or\n-// binary is the time that it was built, if the mtimes of the inputs\n-// predate the mtime of the installed object, then the build of that\n-// object saw those versions of the files, and therefore a rebuild using\n-// those same versions would produce the same object. In contrast, if any\n-// mtime of an input is newer than the mtime of the installed object, a\n-// change has occurred since the build, and the build should be redone.\n-//\n-// Modification times are attractive because the logic is easy to\n-// understand and the file system maintains the mtimes automatically\n-// (less work for us). Unfortunately, there are a variety of ways in\n-// which the mtime approach fails to detect a change and reuses a stale\n-// object file incorrectly. (Making the opposite mistake, rebuilding\n-// unnecessarily, is only a performance problem and not a correctness\n-// problem, so we ignore that one.)\n-//\n-// As a warmup, one problem is that to be perfectly precise, we need to\n-// compare the input mtimes against the time at the beginning of the\n-// build, but the object file time is the time at the end of the build.\n-// If an input file changes after being read but before the object is\n-// written, the next build will see an object newer than the input and\n-// will incorrectly decide that the object is up to date. We make no\n-// attempt to detect or solve this problem.\n-//\n-// Another problem is that due to file system imprecision, an input and\n-// output that are actually ordered in time have the same mtime.\n-// This typically happens on file systems with 1-second (or, worse,\n-// 2-second) mtime granularity and with automated scripts that write an\n-// input and then immediately run a build, or vice versa. If an input and\n-// an output have the same mtime, the conservative behavior is to treat\n-// the output as out-of-date and rebuild. This can cause one or more\n-// spurious rebuilds, but only for 1 second, until the object finally has\n-// an mtime later than the input.\n-//\n-// Another problem is that binary distributions often set the mtime on\n-// all files to the same time. If the distribution includes both inputs\n-// and cached build outputs, the conservative solution to the previous\n-// problem will cause unnecessary rebuilds. Worse, in such a binary\n-// distribution, those rebuilds might not even have permission to update\n-// the cached build output. To avoid these write errors, if an input and\n-// output have the same mtime, we assume the output is up-to-date.\n-// This is the opposite of what the previous problem would have us do,\n-// but binary distributions are more common than instances of the\n-// previous problem.\n-//\n-// A variant of the last problem is that some binary distributions do not\n-// set the mtime on all files to the same time. Instead they let the file\n-// system record mtimes as the distribution is unpacked. If the outputs\n-// are unpacked before the inputs, they'll be older and a build will try\n-// to rebuild them. That rebuild might hit the same write errors as in\n-// the last scenario. We don't make any attempt to solve this, and we\n-// haven't had many reports of it. Perhaps the only time this happens is\n-// when people manually unpack the distribution, and most of the time\n-// that's done as the same user who will be using it, so an initial\n-// rebuild on first use succeeds quietly.\n-//\n-// More generally, people and programs change mtimes on files. The last\n-// few problems were specific examples of this, but it's a general problem.\n-// For example, instead of a binary distribution, copying a home\n-// directory from one directory or machine to another might copy files\n-// but not preserve mtimes. If the inputs are new than the outputs on the\n-// first machine but copied first, they end up older than the outputs on\n-// the second machine.\n-//\n-// Because many other build systems have the same sensitivity to mtimes,\n-// most programs manipulating source code take pains not to break the\n-// mtime assumptions. For example, Git does not set the mtime of files\n-// during a checkout operation, even when checking out an old version of\n-// the code. This decision was made specifically to work well with\n-// mtime-based build systems.\n-//\n-// The killer problem, though, for mtime-based build systems is that the\n-// build only has access to the mtimes of the inputs that still exist.\n-// If it is possible to remove an input without changing any other inputs,\n-// a later build will think the object is up-to-date when it is not.\n-// This happens for Go because a package is made up of all source\n-// files in a directory. If a source file is removed, there is no newer\n-// mtime available recording that fact. The mtime on the directory could\n-// be used, but it also changes when unrelated files are added to or\n-// removed from the directory, so including the directory mtime would\n-// cause unnecessary rebuilds, possibly many. It would also exacerbate\n-// the problems mentioned earlier, since even programs that are careful\n-// to maintain mtimes on files rarely maintain mtimes on directories.\n-//\n-// A variant of the last problem is when the inputs change for other\n-// reasons. For example, Go 1.4 and Go 1.5 both install $GOPATH/src/mypkg\n-// into the same target, $GOPATH/pkg/$GOOS_$GOARCH/mypkg.a.\n-// If Go 1.4 has built mypkg into mypkg.a, a build using Go 1.5 must\n-// rebuild mypkg.a, but from mtimes alone mypkg.a looks up-to-date.\n-// If Go 1.5 has just been installed, perhaps the compiler will have a\n-// newer mtime; since the compiler is considered an input, that would\n-// trigger a rebuild. But only once, and only the last Go 1.4 build of\n-// mypkg.a happened before Go 1.5 was installed. If a user has the two\n-// versions installed in different locations and flips back and forth,\n-// mtimes alone cannot tell what to do. Changing the toolchain is\n-// changing the set of inputs, without affecting any mtimes.\n-//\n-// To detect the set of inputs changing, we turn away from mtimes and to\n-// an explicit data comparison. Specifically, we build a list of the\n-// inputs to the build, compute its SHA1 hash, and record that as the\n-// ``build ID'' in the generated object. At the next build, we can\n-// recompute the build ID and compare it to the one in the generated\n-// object. If they differ, the list of inputs has changed, so the object\n-// is out of date and must be rebuilt.\n-//\n-// Because this build ID is computed before the build begins, the\n-// comparison does not have the race that mtime comparison does.\n-//\n-// Making the build sensitive to changes in other state is\n-// straightforward: include the state in the build ID hash, and if it\n-// changes, so does the build ID, triggering a rebuild.\n-//\n-// To detect changes in toolchain, we include the toolchain version in\n-// the build ID hash for package runtime, and then we include the build\n-// IDs of all imported packages in the build ID for p.\n-//\n-// It is natural to think about including build tags in the build ID, but\n-// the naive approach of just dumping the tags into the hash would cause\n-// spurious rebuilds. For example, 'go install' and 'go install -tags neverusedtag'\n-// produce the same binaries (assuming neverusedtag is never used).\n-// A more precise approach would be to include only tags that have an\n-// effect on the build. But the effect of a tag on the build is to\n-// include or exclude a file from the compilation, and that file list is\n-// already in the build ID hash. So the build ID is already tag-sensitive\n-// in a perfectly precise way. So we do NOT explicitly add build tags to\n-// the build ID hash.\n-//\n-// We do not include as part of the build ID the operating system,\n-// architecture, or whether the race detector is enabled, even though all\n-// three have an effect on the output, because that information is used\n-// to decide the install location. Binaries for linux and binaries for\n-// darwin are written to different directory trees; including that\n-// information in the build ID is unnecessary (although it would be\n-// harmless).\n-//\n-// TODO(rsc): Investigate the cost of putting source file content into\n-// the build ID hash as a replacement for the use of mtimes. Using the\n-// file content would avoid all the mtime problems, but it does require\n-// reading all the source files, something we avoid today (we read the\n-// beginning to find the build tags and the imports, but we stop as soon\n-// as we see the import block is over). If the package is stale, the compiler\n-// is going to read the files anyway. But if the package is up-to-date, the\n-// read is overhead.\n-//\n-// TODO(rsc): Investigate the complexity of making the build more\n-// precise about when individual results are needed. To be fully precise,\n-// there are two results of a compilation: the entire .a file used by the link\n-// and the subpiece used by later compilations (__.PKGDEF only).\n-// If a rebuild is needed but produces the previous __.PKGDEF, then\n-// no more recompilation due to the rebuilt package is needed, only\n-// relinking. To date, there is nothing in the Go command to express this.\n-//\n-// Special Cases\n-//\n-// When the go command makes the wrong build decision and does not\n-// rebuild something it should, users fall back to adding the -a flag.\n-// Any common use of the -a flag should be considered prima facie evidence\n-// that isStale is returning an incorrect false result in some important case.\n-// Bugs reported in the behavior of -a itself should prompt the question\n-// ``Why is -a being used at all? What bug does that indicate?''\n-//\n-// There is a long history of changes to isStale to try to make -a into a\n-// suitable workaround for bugs in the mtime-based decisions.\n-// It is worth recording that history to inform (and, as much as possible, deter) future changes.\n-//\n-// (1) Before the build IDs were introduced, building with alternate tags\n-// would happily reuse installed objects built without those tags.\n-// For example, \"go build -tags netgo myprog.go\" would use the installed\n-// copy of package net, even if that copy had been built without netgo.\n-// (The netgo tag controls whether package net uses cgo or pure Go for\n-// functionality such as name resolution.)\n-// Using the installed non-netgo package defeats the purpose.\n-//\n-// Users worked around this with \"go build -tags netgo -a myprog.go\".\n-//\n-// Build IDs have made that workaround unnecessary:\n-// \"go build -tags netgo myprog.go\"\n-// cannot use a non-netgo copy of package net.\n-//\n-// (2) Before the build IDs were introduced, building with different toolchains,\n-// especially changing between toolchains, tried to reuse objects stored in\n-// $GOPATH/pkg, resulting in link-time errors about object file mismatches.\n-//\n-// Users worked around this with \"go install -a ./...\".\n-//\n-// Build IDs have made that workaround unnecessary:\n-// \"go install ./...\" will rebuild any objects it finds that were built against\n-// a different toolchain.\n-//\n-// (3) The common use of \"go install -a ./...\" led to reports of problems\n-// when the -a forced the rebuild of the standard library, which for some\n-// users was not writable. Because we didn't understand that the real\n-// problem was the bug -a was working around, we changed -a not to\n-// apply to the standard library.\n-//\n-// (4) The common use of \"go build -tags netgo -a myprog.go\" broke\n-// when we changed -a not to apply to the standard library, because\n-// if go build doesn't rebuild package net, it uses the non-netgo version.\n-//\n-// Users worked around this with \"go build -tags netgo -installsuffix barf myprog.go\".\n-// The -installsuffix here is making the go command look for packages\n-// in pkg/$GOOS_$GOARCH_barf instead of pkg/$GOOS_$GOARCH.\n-// Since the former presumably doesn't exist, go build decides to rebuild\n-// everything, including the standard library. Since go build doesn't\n-// install anything it builds, nothing is ever written to pkg/$GOOS_$GOARCH_barf,\n-// so repeated invocations continue to work.\n-//\n-// If the use of -a wasn't a red flag, the use of -installsuffix to point to\n-// a non-existent directory in a command that installs nothing should\n-// have been.\n-//\n-// (5) Now that (1) and (2) no longer need -a, we have removed the kludge\n-// introduced in (3): once again, -a means ``rebuild everything,'' not\n-// ``rebuild everything except the standard library.'' Only Go 1.4 had\n-// the restricted meaning.\n-//\n-// In addition to these cases trying to trigger rebuilds, there are\n-// special cases trying NOT to trigger rebuilds. The main one is that for\n-// a variety of reasons (see above), the install process for a Go release\n-// cannot be relied upon to set the mtimes such that the go command will\n-// think the standard library is up to date. So the mtime evidence is\n-// ignored for the standard library if we find ourselves in a release\n-// version of Go. Build ID-based staleness checks still apply to the\n-// standard library, even in release versions. This makes\n-// 'go build -tags netgo' work, among other things.\n-\n-// isStale reports whether package p needs to be rebuilt,\n-// along with the reason why.\n-func isStale(p *Package) (bool, string) {\n-\tif p.Standard && (p.ImportPath == \"unsafe\" || cfg.BuildContext.Compiler == \"gccgo\") {\n-\t\t// fake, builtin package\n-\t\treturn false, \"builtin package\"\n-\t}\n-\tif p.Error != nil {\n-\t\treturn true, \"errors loading package\"\n-\t}\n-\tif p.Stale {\n-\t\treturn true, p.StaleReason\n-\t}\n-\n-\t// If this is a package with no source code, it cannot be rebuilt.\n-\t// If the binary is missing, we mark the package stale so that\n-\t// if a rebuild is needed, that rebuild attempt will produce a useful error.\n-\t// (Some commands, such as 'go list', do not attempt to rebuild.)\n-\tif p.BinaryOnly {\n-\t\tif p.Internal.Target == \"\" {\n-\t\t\t// Fail if a build is attempted.\n-\t\t\treturn true, \"no source code for package, but no install target\"\n-\t\t}\n-\t\tif _, err := os.Stat(p.Internal.Target); err != nil {\n-\t\t\t// Fail if a build is attempted.\n-\t\t\treturn true, \"no source code for package, but cannot access install target: \" + err.Error()\n-\t\t}\n-\t\treturn false, \"no source code for package\"\n-\t}\n-\n-\t// If the -a flag is given, rebuild everything.\n-\tif cfg.BuildA {\n-\t\treturn true, \"build -a flag in use\"\n-\t}\n-\n-\t// If there's no install target, we have to rebuild.\n-\tif p.Internal.Target == \"\" {\n-\t\treturn true, \"no install target\"\n-\t}\n-\n-\t// Package is stale if completely unbuilt.\n-\tfi, err := os.Stat(p.Internal.Target)\n-\tif err != nil {\n-\t\treturn true, \"cannot stat install target\"\n-\t}\n-\n-\t// Package is stale if the expected build ID differs from the\n-\t// recorded build ID. This catches changes like a source file\n-\t// being removed from a package directory. See issue 3895.\n-\t// It also catches changes in build tags that affect the set of\n-\t// files being compiled. See issue 9369.\n-\t// It also catches changes in toolchain, like when flipping between\n-\t// two versions of Go compiling a single GOPATH.\n-\t// See issue 8290 and issue 10702.\n-\ttargetBuildID, err := buildid.ReadBuildID(p.Name, p.Target)\n-\tif err == nil && targetBuildID != p.Internal.BuildID {\n-\t\treturn true, \"build ID mismatch\"\n-\t}\n-\n-\t// Package is stale if a dependency is.\n-\tfor _, p1 := range p.Internal.Deps {\n-\t\tif p1.Stale {\n-\t\t\treturn true, \"stale dependency\"\n-\t\t}\n-\t}\n-\n-\t// The checks above are content-based staleness.\n-\t// We assume they are always accurate.\n-\t//\n-\t// The checks below are mtime-based staleness.\n-\t// We hope they are accurate, but we know that they fail in the case of\n-\t// prebuilt Go installations that don't preserve the build mtimes\n-\t// (for example, if the pkg/ mtimes are before the src/ mtimes).\n-\t// See the large comment above isStale for details.\n-\n-\t// If we are running a release copy of Go and didn't find a content-based\n-\t// reason to rebuild the standard packages, do not rebuild them.\n-\t// They may not be writable anyway, but they are certainly not changing.\n-\t// This makes 'go build' skip the standard packages when\n-\t// using an official release, even when the mtimes have been changed.\n-\t// See issue 3036, issue 3149, issue 4106, issue 8290.\n-\t// (If a change to a release tree must be made by hand, the way to force the\n-\t// install is to run make.bash, which will remove the old package archives\n-\t// before rebuilding.)\n-\tif p.Standard && isGoRelease {\n-\t\treturn false, \"standard package in Go release distribution\"\n-\t}\n-\n-\t// Time-based staleness.\n-\n-\tbuilt := fi.ModTime()\n-\n-\tolderThan := func(file string) bool {\n-\t\tfi, err := os.Stat(file)\n-\t\treturn err != nil || fi.ModTime().After(built)\n-\t}\n-\n-\t// Package is stale if a dependency is, or if a dependency is newer.\n-\tfor _, p1 := range p.Internal.Deps {\n-\t\tif p1.Internal.Target != \"\" && olderThan(p1.Internal.Target) {\n-\t\t\treturn true, \"newer dependency\"\n-\t\t}\n-\t}\n-\n-\t// As a courtesy to developers installing new versions of the compiler\n-\t// frequently, define that packages are stale if they are\n-\t// older than the compiler, and commands if they are older than\n-\t// the linker. This heuristic will not work if the binaries are\n-\t// back-dated, as some binary distributions may do, but it does handle\n-\t// a very common case.\n-\t// See issue 3036.\n-\t// Exclude $GOROOT, under the assumption that people working on\n-\t// the compiler may want to control when everything gets rebuilt,\n-\t// and people updating the Go repository will run make.bash or all.bash\n-\t// and get a full rebuild anyway.\n-\t// Excluding $GOROOT used to also fix issue 4106, but that's now\n-\t// taken care of above (at least when the installed Go is a released version).\n-\tif p.Root != cfg.GOROOT {\n-\t\tif olderThan(cfg.BuildToolchainCompiler()) {\n-\t\t\treturn true, \"newer compiler\"\n-\t\t}\n-\t\tif p.Internal.Build.IsCommand() && olderThan(cfg.BuildToolchainLinker()) {\n-\t\t\treturn true, \"newer linker\"\n-\t\t}\n-\t}\n-\n-\t// Note: Until Go 1.5, we had an additional shortcut here.\n-\t// We built a list of the workspace roots ($GOROOT, each $GOPATH)\n-\t// containing targets directly named on the command line,\n-\t// and if p were not in any of those, it would be treated as up-to-date\n-\t// as long as it is built. The goal was to avoid rebuilding a system-installed\n-\t// $GOROOT, unless something from $GOROOT were explicitly named\n-\t// on the command line (like go install math).\n-\t// That's now handled by the isGoRelease clause above.\n-\t// The other effect of the shortcut was to isolate different entries in\n-\t// $GOPATH from each other. This had the unfortunate effect that\n-\t// if you had (say), GOPATH listing two entries, one for commands\n-\t// and one for libraries, and you did a 'git pull' in the library one\n-\t// and then tried 'go install commands/...', it would build the new libraries\n-\t// during the first build (because they wouldn't have been installed at all)\n-\t// but then subsequent builds would not rebuild the libraries, even if the\n-\t// mtimes indicate they are stale, because the different GOPATH entries\n-\t// were treated differently. This behavior was confusing when using\n-\t// non-trivial GOPATHs, which were particularly common with some\n-\t// code management conventions, like the original godep.\n-\t// Since the $GOROOT case (the original motivation) is handled separately,\n-\t// we no longer put a barrier between the different $GOPATH entries.\n-\t//\n-\t// One implication of this is that if there is a system directory for\n-\t// non-standard Go packages that is included in $GOPATH, the mtimes\n-\t// on those compiled packages must be no earlier than the mtimes\n-\t// on the source files. Since most distributions use the same mtime\n-\t// for all files in a tree, they will be unaffected. People using plain\n-\t// tar x to extract system-installed packages will need to adjust mtimes,\n-\t// but it's better to force them to get the mtimes right than to ignore\n-\t// the mtimes and thereby do the wrong thing in common use cases.\n-\t//\n-\t// So there is no GOPATH vs GOPATH shortcut here anymore.\n-\t//\n-\t// If something needs to come back here, we could try writing a dummy\n-\t// file with a random name to the $GOPATH/pkg directory (and removing it)\n-\t// to test for write access, and then skip GOPATH roots we don't have write\n-\t// access to. But hopefully we can just use the mtimes always.\n-\n-\tsrcs := str.StringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.FFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n-\tfor _, src := range srcs {\n-\t\tif olderThan(filepath.Join(p.Dir, src)) {\n-\t\t\treturn true, \"newer source file\"\n-\t\t}\n-\t}\n-\n-\treturn false, \"\"\n-}\n-\n-// computeBuildID computes the build ID for p, leaving it in p.Internal.BuildID.\n-// Build ID is a hash of the information we want to detect changes in.\n-// See the long comment in isStale for details.\n-func computeBuildID(p *Package) {\n-\th := sha1.New()\n-\n-\t// Include the list of files compiled as part of the package.\n-\t// This lets us detect removed files. See issue 3895.\n-\tinputFiles := str.StringList(\n-\t\tp.GoFiles,\n-\t\tp.CgoFiles,\n-\t\tp.CFiles,\n-\t\tp.CXXFiles,\n-\t\tp.FFiles,\n-\t\tp.MFiles,\n-\t\tp.HFiles,\n-\t\tp.SFiles,\n-\t\tp.SysoFiles,\n-\t\tp.SwigFiles,\n-\t\tp.SwigCXXFiles,\n-\t)\n-\tfor _, file := range inputFiles {\n-\t\tfmt.Fprintf(h, \"file %s\\n\", file)\n-\t}\n-\n-\t// Include the content of runtime/internal/sys/zversion.go in the hash\n-\t// for package runtime. This will give package runtime a\n-\t// different build ID in each Go release.\n-\tif p.Standard && p.ImportPath == \"runtime/internal/sys\" && cfg.BuildContext.Compiler != \"gccgo\" {\n-\t\tdata, err := ioutil.ReadFile(filepath.Join(p.Dir, \"zversion.go\"))\n-\t\tif os.IsNotExist(err) {\n-\t\t\tp.Stale = true\n-\t\t\tp.StaleReason = fmt.Sprintf(\"missing zversion.go\")\n-\t\t} else if err != nil {\n-\t\t\tbase.Fatalf(\"go: %s\", err)\n-\t\t}\n-\t\tfmt.Fprintf(h, \"zversion %q\\n\", string(data))\n-\n-\t\t// Add environment variables that affect code generation.\n-\t\tswitch cfg.BuildContext.GOARCH {\n-\t\tcase \"arm\":\n-\t\t\tfmt.Fprintf(h, \"GOARM=%s\\n\", cfg.GOARM)\n-\t\tcase \"386\":\n-\t\t\tfmt.Fprintf(h, \"GO386=%s\\n\", cfg.GO386)\n-\t\t}\n-\t}\n-\n-\t// Include the build IDs of any dependencies in the hash.\n-\t// This, combined with the runtime/zversion content,\n-\t// will cause packages to have different build IDs when\n-\t// compiled with different Go releases.\n-\t// This helps the go command know to recompile when\n-\t// people use the same GOPATH but switch between\n-\t// different Go releases. See issue 10702.\n-\t// This is also a better fix for issue 8290.\n-\tfor _, p1 := range p.Internal.Deps {\n-\t\tfmt.Fprintf(h, \"dep %s %s\\n\", p1.ImportPath, p1.Internal.BuildID)\n-\t}\n-\n-\tp.Internal.BuildID = fmt.Sprintf(\"%x\", h.Sum(nil))\n-}\n-\n var cmdCache = map[string]*Package{}\n \n func ClearCmdCache() {\n@@ -1842,7 +1405,6 @@ func PackagesAndErrors(args []string) []*Package {\n \t\tseenPkg[pkg] = true\n \t\tpkgs = append(pkgs, pkg)\n \t}\n-\tComputeStale(pkgs...)\n \n \treturn pkgs\n }\n@@ -1943,13 +1505,13 @@ func GoFilesPackage(gofiles []string) *Package {\n \tbp, err := ctxt.ImportDir(dir, 0)\n \tpkg := new(Package)\n \tpkg.Internal.Local = true\n-\tpkg.Internal.Cmdline = true\n+\tpkg.Internal.CmdlineFiles = true\n \tstk.Push(\"main\")\n \tpkg.load(&stk, bp, err)\n \tstk.Pop()\n \tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n \tpkg.ImportPath = \"command-line-arguments\"\n-\tpkg.Internal.Target = \"\"\n+\tpkg.Target = \"\"\n \n \tif pkg.Name == \"main\" {\n \t\t_, elem := filepath.Split(gofiles[0])\n@@ -1958,14 +1520,9 @@ func GoFilesPackage(gofiles []string) *Package {\n \t\t\tcfg.BuildO = exe\n \t\t}\n \t\tif cfg.GOBIN != \"\" {\n-\t\t\tpkg.Internal.Target = filepath.Join(cfg.GOBIN, exe)\n+\t\t\tpkg.Target = filepath.Join(cfg.GOBIN, exe)\n \t\t}\n \t}\n \n-\tpkg.Target = pkg.Internal.Target\n-\tpkg.Stale = true\n-\tpkg.StaleReason = \"files named on command line\"\n-\n-\tComputeStale(pkg)\n \treturn pkg\n }"}, {"sha": "595de079046607819192ff3ee35b72de8d8f6ac3", "filename": "libgo/go/cmd/go/internal/load/search.go", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -266,6 +266,50 @@ func matchPattern(pattern string) func(name string) bool {\n \t}\n }\n \n+// MatchPackage(pattern, cwd)(p) reports whether package p matches pattern in the working directory cwd.\n+func MatchPackage(pattern, cwd string) func(*Package) bool {\n+\tswitch {\n+\tcase strings.HasPrefix(pattern, \"./\") || strings.HasPrefix(pattern, \"../\") || pattern == \".\" || pattern == \"..\":\n+\t\t// Split pattern into leading pattern-free directory path\n+\t\t// (including all . and .. elements) and the final pattern.\n+\t\tvar dir string\n+\t\ti := strings.Index(pattern, \"...\")\n+\t\tif i < 0 {\n+\t\t\tdir, pattern = pattern, \"\"\n+\t\t} else {\n+\t\t\tj := strings.LastIndex(pattern[:i], \"/\")\n+\t\t\tdir, pattern = pattern[:j], pattern[j+1:]\n+\t\t}\n+\t\tdir = filepath.Join(cwd, dir)\n+\t\tif pattern == \"\" {\n+\t\t\treturn func(p *Package) bool { return p.Dir == dir }\n+\t\t}\n+\t\tmatchPath := matchPattern(pattern)\n+\t\treturn func(p *Package) bool {\n+\t\t\t// Compute relative path to dir and see if it matches the pattern.\n+\t\t\trel, err := filepath.Rel(dir, p.Dir)\n+\t\t\tif err != nil {\n+\t\t\t\t// Cannot make relative - e.g. different drive letters on Windows.\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\trel = filepath.ToSlash(rel)\n+\t\t\tif rel == \"..\" || strings.HasPrefix(rel, \"../\") {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\treturn matchPath(rel)\n+\t\t}\n+\tcase pattern == \"all\":\n+\t\treturn func(p *Package) bool { return true }\n+\tcase pattern == \"std\":\n+\t\treturn func(p *Package) bool { return p.Standard }\n+\tcase pattern == \"cmd\":\n+\t\treturn func(p *Package) bool { return p.Standard && strings.HasPrefix(p.ImportPath, \"cmd/\") }\n+\tdefault:\n+\t\tmatchPath := matchPattern(pattern)\n+\t\treturn func(p *Package) bool { return matchPath(p.ImportPath) }\n+\t}\n+}\n+\n // replaceVendor returns the result of replacing\n // non-trailing vendor path elements in x with repl.\n func replaceVendor(x, repl string) string {\n@@ -302,6 +346,9 @@ func ImportPaths(args []string) []string {\n // ImportPathsNoDotExpansion returns the import paths to use for the given\n // command line, but it does no ... expansion.\n func ImportPathsNoDotExpansion(args []string) []string {\n+\tif cmdlineMatchers == nil {\n+\t\tSetCmdlinePatterns(args)\n+\t}\n \tif len(args) == 0 {\n \t\treturn []string{\".\"}\n \t}\n@@ -332,7 +379,7 @@ func ImportPathsNoDotExpansion(args []string) []string {\n \treturn out\n }\n \n-// isMetaPackage checks if name is a reserved package name that expands to multiple packages.\n+// IsMetaPackage checks if name is a reserved package name that expands to multiple packages.\n func IsMetaPackage(name string) bool {\n \treturn name == \"std\" || name == \"cmd\" || name == \"all\"\n }"}, {"sha": "7734048f5c98d99a246ea21fa3779edef936944e", "filename": "libgo/go/cmd/go/internal/load/testgo.go", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8799df67f2dab88f9fda11739c501780a85575e2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8799df67f2dab88f9fda11739c501780a85575e2/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftestgo.go?ref=8799df67f2dab88f9fda11739c501780a85575e2", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains extra hooks for testing the go command.\n-// It is compiled into the Go binary only when building the\n-// test copy; it does not get compiled into the standard go\n-// command, so these testing hooks are not present in the\n-// go command that everyone uses.\n-\n-// +build testgo\n-\n-package load\n-\n-import \"os\"\n-\n-func init() {\n-\tif v := os.Getenv(\"TESTGO_IS_GO_RELEASE\"); v != \"\" {\n-\t\tisGoRelease = v == \"1\"\n-\t}\n-}"}, {"sha": "ce24748f4e33af58498ab15b7de6dbb9c7ff1b50", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -52,8 +52,7 @@ func printStderr(args ...interface{}) (int, error) {\n }\n \n func runRun(cmd *base.Command, args []string) {\n-\twork.InstrumentInit()\n-\twork.BuildModeInit()\n+\twork.BuildInit()\n \tvar b work.Builder\n \tb.Init()\n \tb.Print = printStderr\n@@ -94,7 +93,7 @@ func runRun(cmd *base.Command, args []string) {\n \tif p.Name != \"main\" {\n \t\tbase.Fatalf(\"go run: cannot run non-main package\")\n \t}\n-\tp.Internal.Target = \"\" // must build - not up to date\n+\tp.Target = \"\" // must build - not up to date\n \tvar src string\n \tif len(p.GoFiles) > 0 {\n \t\tsrc = p.GoFiles[0]\n@@ -110,8 +109,8 @@ func runRun(cmd *base.Command, args []string) {\n \t\tbase.Fatalf(\"go run: no suitable source files%s\", hint)\n \t}\n \tp.Internal.ExeName = src[:len(src)-len(\".go\")] // name temporary executable for first go file\n-\ta1 := b.Action(work.ModeBuild, work.ModeBuild, p)\n-\ta := &work.Action{Func: buildRunProgram, Args: cmdArgs, Deps: []*work.Action{a1}}\n+\ta1 := b.LinkAction(work.ModeBuild, work.ModeBuild, p)\n+\ta := &work.Action{Mode: \"go run\", Func: buildRunProgram, Args: cmdArgs, Deps: []*work.Action{a1}}\n \tb.Do(a)\n }\n "}, {"sha": "12538b4656421562bc20d87fa5c6e47f418ca0de", "filename": "libgo/go/cmd/go/internal/test/cover.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Fcover.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package test\n+\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sync\"\n+)\n+\n+var coverMerge struct {\n+\tf          *os.File\n+\tsync.Mutex // for f.Write\n+}\n+\n+// initCoverProfile initializes the test coverage profile.\n+// It must be run before any calls to mergeCoverProfile or closeCoverProfile.\n+// Using this function clears the profile in case it existed from a previous run,\n+// or in case it doesn't exist and the test is going to fail to create it (or not run).\n+func initCoverProfile() {\n+\tif testCoverProfile == \"\" {\n+\t\treturn\n+\t}\n+\tif !filepath.IsAbs(testCoverProfile) && testOutputDir != \"\" {\n+\t\ttestCoverProfile = filepath.Join(testOutputDir, testCoverProfile)\n+\t}\n+\n+\t// No mutex - caller's responsibility to call with no racing goroutines.\n+\tf, err := os.Create(testCoverProfile)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"%v\", err)\n+\t}\n+\t_, err = fmt.Fprintf(f, \"mode: %s\\n\", testCoverMode)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"%v\", err)\n+\t}\n+\tcoverMerge.f = f\n+}\n+\n+// mergeCoverProfile merges file into the profile stored in testCoverProfile.\n+// It prints any errors it encounters to ew.\n+func mergeCoverProfile(ew io.Writer, file string) {\n+\tif coverMerge.f == nil {\n+\t\treturn\n+\t}\n+\tcoverMerge.Lock()\n+\tdefer coverMerge.Unlock()\n+\n+\texpect := fmt.Sprintf(\"mode: %s\\n\", testCoverMode)\n+\tbuf := make([]byte, len(expect))\n+\tr, err := os.Open(file)\n+\tif err != nil {\n+\t\t// Test did not create profile, which is OK.\n+\t\treturn\n+\t}\n+\tdefer r.Close()\n+\n+\tn, err := io.ReadFull(r, buf)\n+\tif n == 0 {\n+\t\treturn\n+\t}\n+\tif err != nil || string(buf) != expect {\n+\t\tfmt.Fprintf(ew, \"error: test wrote malformed coverage profile.\\n\")\n+\t\treturn\n+\t}\n+\t_, err = io.Copy(coverMerge.f, r)\n+\tif err != nil {\n+\t\tfmt.Fprintf(ew, \"error: saving coverage profile: %v\\n\", err)\n+\t}\n+}\n+\n+func closeCoverProfile() {\n+\tif coverMerge.f == nil {\n+\t\treturn\n+\t}\n+\tif err := coverMerge.f.Close(); err != nil {\n+\t\tbase.Errorf(\"closing coverage profile: %v\", err)\n+\t}\n+}"}, {"sha": "3e08a72154545203a2be8ea952365495c5026a4f", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8a908f7e215de4354278d741b3d91604c7ed567d", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4c7d0897e054a6f587af8752df20edc69258120d", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "db734c9d846d7f726874214da10104bb7c01ae6b", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "36ee04ede77cf2add6e42905959d1f3cdaea6cc9", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fa7fd0c2e4a92595e987862be4a6eac63effb3ec", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "added", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "57b7b00879121a6ca1acf919ff773e23a3bb1c9b", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 95, "deletions": 3501, "changes": 3596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3f5ba37c64122d90b6cafc6ba860c83a1775f2e5", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "878dbeada2cf9cc00de5071ec1c5fedb0a2a9df4", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f955573e297d2211933f380e9f40fa9770723a32", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "added", "additions": 2366, "deletions": 0, "changes": 2366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "49258b30fd08954b6d08354f9d171078ab1fc922", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "added", "additions": 500, "deletions": 0, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "9e42842e3f7d561ae574955ece9613107769a881", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "c2beb3be6e7bf9f5a17875abf95657e713c53284", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "09147ee5f91e9829794a02e885f7b49848e4eb9d", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "7ef4c641d7d4f98c6e862cc8b66b3bdef373d9c7", "filename": "libgo/go/cmd/go/note_test.go", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "547729106090d4deed7baaf53e16ab7a78604af7", "filename": "libgo/go/cmd/go/testdata/print_goroot.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "c38df019480af51bdb20a7f96ee9383ce724642d", "filename": "libgo/go/cmd/go/testdata/src/complex/main.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fmain.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "94943ec1bbe238c74b2c41ed0a48d4baa36d9123", "filename": "libgo/go/cmd/go/testdata/src/complex/nest/sub/test12/p.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Ftest12%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Ftest12%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Ftest12%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8801a4812af4d2b2d8c6d10b3b7c3e46d6d01bb0", "filename": "libgo/go/cmd/go/testdata/src/complex/nest/sub/test23/p.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Ftest23%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Ftest23%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Ftest23%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2991871710e2880f383c0a20aff5239f5cdc36f3", "filename": "libgo/go/cmd/go/testdata/src/complex/nest/sub/vendor/v2/v2.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Fvendor%2Fv2%2Fv2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Fvendor%2Fv2%2Fv2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fsub%2Fvendor%2Fv2%2Fv2.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "a55f5290a9ae101760c28285b62b801e46d9100c", "filename": "libgo/go/cmd/go/testdata/src/complex/nest/vendor/v1/v1.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv1%2Fv1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv1%2Fv1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv1%2Fv1.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ac94def4e3e501886b8032274521414cf255f767", "filename": "libgo/go/cmd/go/testdata/src/complex/nest/vendor/v2/v2.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv2%2Fv2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv2%2Fv2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv2%2Fv2.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "abf99b95745c3dbf08852e5dbec22d4c055b4c32", "filename": "libgo/go/cmd/go/testdata/src/complex/nest/vendor/v3/v3.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv3%2Fv3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv3%2Fv3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fnest%2Fvendor%2Fv3%2Fv3.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "bb20d86f25a7678f1be2a0dc134b643c01905963", "filename": "libgo/go/cmd/go/testdata/src/complex/vendor/v/v.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fvendor%2Fv%2Fv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fvendor%2Fv%2Fv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fvendor%2Fv%2Fv.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "a9c7fbb309483c42fc2e34c968911604939e3fd4", "filename": "libgo/go/cmd/go/testdata/src/complex/w/w.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fw%2Fw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fw%2Fw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcomplex%2Fw%2Fw.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ab0c300d7231da8edee43ac960c2ef91ca21bb54", "filename": "libgo/go/cmd/go/testdata/src/coverasm/p.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5e728f9946d95f08b347a21e208e3b9737bf8f5a", "filename": "libgo/go/cmd/go/testdata/src/coverasm/p.s", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3cb3bd5664baf792d7b9411b36eae1084be7c887", "filename": "libgo/go/cmd/go/testdata/src/coverasm/p_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverasm%2Fp_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "16504a401eb39a97e697effecf767e7500bb598c", "filename": "libgo/go/cmd/go/testdata/src/coverbad/p.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2d25c8e1908e8559d7060c7f1f21145ef6e03caf", "filename": "libgo/go/cmd/go/testdata/src/coverbad/p1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp1.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3a876d6296c100d761af10f52948f36c50c87089", "filename": "libgo/go/cmd/go/testdata/src/coverbad/p_test.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverbad%2Fp_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "6baf6d5f0c7fb787fac7c40692c9b3b75fcd3586", "filename": "libgo/go/cmd/go/testdata/src/coverdep/p.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8ae793d55d7809cba552baf9dcec69f2c542170a", "filename": "libgo/go/cmd/go/testdata/src/coverdep/p1/p1.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp1%2Fp1.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "11a14343ea9f3305a7c2211bcfc2fe91ed39726c", "filename": "libgo/go/cmd/go/testdata/src/coverdep/p_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcoverdep%2Fp_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fef4d2a35e1cd117262827073c49565a85fe6d6a", "filename": "libgo/go/cmd/go/testdata/src/failfast_test.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ffailfast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ffailfast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ffailfast_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "007a86a5da8f128febcddc0ad00597e32a1a7338", "filename": "libgo/go/cmd/go/testdata/src/multimain/multimain_test.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmultimain%2Fmultimain_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmultimain%2Fmultimain_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmultimain%2Fmultimain_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "75a397c6cbac4528e38f31665e41e9a85b3fe700", "filename": "libgo/go/cmd/go/testdata/src/not_main/not_main.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnot_main%2Fnot_main.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnot_main%2Fnot_main.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnot_main%2Fnot_main.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "58e6dc505b7f51af99241a085044a4ab8ab182d4", "filename": "libgo/go/cmd/go/testdata/src/skipper/skip_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fskipper%2Fskip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fskipper%2Fskip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fskipper%2Fskip_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "333be7d8e4c67190059b20f1e352e2aacd762a8c", "filename": "libgo/go/cmd/go/testdata/src/sleepy1/p_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy1%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy1%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy1%2Fp_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "333be7d8e4c67190059b20f1e352e2aacd762a8c", "filename": "libgo/go/cmd/go/testdata/src/sleepy2/p_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy2%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy2%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy2%2Fp_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "e05b403e3928670c24c4cc041604d3757d8643c4", "filename": "libgo/go/cmd/go/testdata/src/sleepybad/p.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepybad%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepybad%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepybad%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "9b2d1ea78243d9bc251d59cabad0e079c1a70190", "filename": "libgo/go/cmd/go/testdata/src/testcache/testcache_test.go", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcache%2Ftestcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcache%2Ftestcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcache%2Ftestcache_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "7ec0c6d17a33505ac351db73a26176ca3ff8e1d6", "filename": "libgo/go/cmd/go/testdata/src/testrace/race_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5b058e7806e97c0d6ffc7beffa736cb1b9aaa112", "filename": "libgo/go/cmd/go/testdata/src/vetcycle/p.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetcycle%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetcycle%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetcycle%2Fp.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "248317b779a3a4424c66c4fad6e983f4cd03ac12", "filename": "libgo/go/cmd/go/testdata/src/vetfail/p1/p1.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp1%2Fp1.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "88b1cc2373677046b027ba925e11d6acd8a7d7c8", "filename": "libgo/go/cmd/go/testdata/src/vetfail/p2/p2.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fde0d1a73f316b6acb639b3e8a74b9a893cf6073", "filename": "libgo/go/cmd/go/testdata/src/vetfail/p2/p2_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fvetfail%2Fp2%2Fp2_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "018ce75b2e361ae54eb4b041dc532de92371f4fd", "filename": "libgo/go/cmd/go/testdata/standalone_main_normal_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_normal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_normal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_normal_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "59998873f94f0a9bedba583b3ba7e50640033b77", "filename": "libgo/go/cmd/go/testdata/standalone_main_wrong_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_wrong_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_wrong_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fstandalone_main_wrong_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fa3d7f37ec60d8b51423e862d9ea46fd145029f8", "filename": "libgo/go/cmd/internal/buildid/buildid.go", "status": "renamed", "additions": 88, "deletions": 51, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "previous_filename": "libgo/go/cmd/go/internal/buildid/buildid.go"}, {"sha": "15481dd76239b160fa91c33a7cd1a4142b68163a", "filename": "libgo/go/cmd/internal/buildid/buildid_test.go", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f0439fb0bfb936804e3c763ea35b62eb08e6d595", "filename": "libgo/go/cmd/internal/buildid/note.go", "status": "renamed", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fnote.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d", "previous_filename": "libgo/go/cmd/go/internal/buildid/note.go"}, {"sha": "5be54552a6dda45fa8ebf87ffa30b38a7c62c2c7", "filename": "libgo/go/cmd/internal/buildid/rewrite.go", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Frewrite.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f63128921aaee5027de1ae83995b183531c0a70f", "filename": "libgo/go/cmd/internal/buildid/testdata/a.elf", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.elf?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fbbd57c1fe370341514eda23e41eedb66f94c006", "filename": "libgo/go/cmd/internal/buildid/testdata/a.macho", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.macho", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.macho", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.macho?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "91202728c3f394c393a5546124f434166bac4ced", "filename": "libgo/go/cmd/internal/buildid/testdata/a.pe", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.pe?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2d470f4c8a9ec1feeab7b6c8905c5f32937d7b51", "filename": "libgo/go/cmd/internal/edit/edit.go", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fedit%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fedit%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fedit%2Fedit.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "0e0c564d98704693d2c1179e824c289b8c13a35f", "filename": "libgo/go/cmd/internal/edit/edit_test.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fedit%2Fedit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fedit%2Fedit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fedit%2Fedit_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "1b46b0ffece3bc79ce706cd7d2390b55a526623a", "filename": "libgo/go/cmd/internal/objabi/autotype.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "1bd4bc9063ae15f4312a8b13b6e0433ae665a9fd", "filename": "libgo/go/cmd/internal/objabi/flag.go", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "1c671b211f8310cfb72048b055afa5716728e9db", "filename": "libgo/go/cmd/internal/objabi/line.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2e0b916f7c1a896c24927dc17b2afdb5dfef2039", "filename": "libgo/go/cmd/internal/objabi/reloctype.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "a6efe9cad046767869382de4611212b994ee8955", "filename": "libgo/go/cmd/internal/objabi/reloctype_string.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ea180d0bf862c64a3686282f029225f64a48b7fa", "filename": "libgo/go/cmd/internal/objabi/symkind.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3064c8ee0517fd584433caf4a18a96894d6d3ed3", "filename": "libgo/go/cmd/internal/objabi/symkind_string.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f8949e05a2b360fb14cbe73df044e88211199415", "filename": "libgo/go/cmd/internal/objabi/util.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "56450fac61850a4ceec897628557def8290db60a", "filename": "libgo/go/cmd/internal/objabi/zbootstrap.go", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8799df67f2dab88f9fda11739c501780a85575e2/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fzbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8799df67f2dab88f9fda11739c501780a85575e2/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fzbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fzbootstrap.go?ref=8799df67f2dab88f9fda11739c501780a85575e2"}, {"sha": "3e09c8d91517f9e6bffc58fa2523bb3350e78ba1", "filename": "libgo/go/cmd/internal/test2json/test2json.go", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftest2json.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftest2json.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftest2json.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4683907888cdb618c910a2a7e04b5a8c3c94898c", "filename": "libgo/go/cmd/internal/test2json/test2json_test.go", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftest2json_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftest2json_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftest2json_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "67fccfc11212e760f17f51760567020129e9970f", "filename": "libgo/go/cmd/internal/test2json/testdata/ascii.json", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fascii.json", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fascii.json", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fascii.json?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4ff7453430cc8bbb92d089587edc39fa12eda7fc", "filename": "libgo/go/cmd/internal/test2json/testdata/ascii.test", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fascii.test", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fascii.test", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fascii.test?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "afa990d7c03f12bc73032214a1b77f463dfaad86", "filename": "libgo/go/cmd/internal/test2json/testdata/smiley.json", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fsmiley.json", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fsmiley.json", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fsmiley.json?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "05edf5a312f01821ed6e02b35158b20cad1be99c", "filename": "libgo/go/cmd/internal/test2json/testdata/smiley.test", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fsmiley.test", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fsmiley.test", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fsmiley.test?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "9cfb5f2d498d1cf45573920d9d0abb5c9faf8e05", "filename": "libgo/go/cmd/internal/test2json/testdata/unicode.json", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Funicode.json", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Funicode.json", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Funicode.json?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "58c620d5f743cb679d232041455689e83f59f580", "filename": "libgo/go/cmd/internal/test2json/testdata/unicode.test", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Funicode.test", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Funicode.test", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Funicode.test?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8c5921d686f6a399f8f53759ae43451df8532d98", "filename": "libgo/go/cmd/internal/test2json/testdata/vet.json", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fvet.json", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fvet.json", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fvet.json?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3389559cb81bebc5853c06e98048e4f6d8ea09be", "filename": "libgo/go/cmd/internal/test2json/testdata/vet.test", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fvet.test", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fvet.test", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Ftest2json%2Ftestdata%2Fvet.test?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "7bdc867bbe5a55e37099afce5d9a388959d18ed5", "filename": "libgo/go/cmd/test2json/main.go", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Ftest2json%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Ftest2json%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Ftest2json%2Fmain.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5ab75494d3ee2b7a37025aedb63de765a7962ca7", "filename": "libgo/go/cmd/vet/README", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2FREADME?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "09167af6d53e632d81bd2e11eb522d896899a4f8", "filename": "libgo/go/cmd/vet/all/main.go", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fmain.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "505856f36862190daf469dab9736866275884748", "filename": "libgo/go/cmd/vet/all/whitelist/386.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2F386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2F386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2F386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "6792d263a5e76c680e342481bf71bd39ec520561", "filename": "libgo/go/cmd/vet/all/whitelist/all.txt", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fall.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fall.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fall.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ebde7be58b0273e2e84d51bb5aad5353c0462a13", "filename": "libgo/go/cmd/vet/all/whitelist/amd64.txt", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Famd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Famd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Famd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5095f2fc0c7941fa29add451868e2197f7984ab4", "filename": "libgo/go/cmd/vet/all/whitelist/android_386.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "90dabb02090a9aa40e73e2cf7cd26ced1054065d", "filename": "libgo/go/cmd/vet/all/whitelist/android_amd64.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fbd569e60468743d228354079e11a7f0640b97c7", "filename": "libgo/go/cmd/vet/all/whitelist/android_arm.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fandroid_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "839346c2d499022e0c943ccd6b2c69ec1f233a73", "filename": "libgo/go/cmd/vet/all/whitelist/arm.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Farm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Farm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Farm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "24fc6f42235f9bfd74e387f590fceea6979aeb30", "filename": "libgo/go/cmd/vet/all/whitelist/arm64.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Farm64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Farm64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Farm64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "d19d7d7bd0475c3cd7973f9646e2d114a8209ec8", "filename": "libgo/go/cmd/vet/all/whitelist/darwin_386.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "94a4e8fa75bb95861d1c1b36540d680e4deb3a94", "filename": "libgo/go/cmd/vet/all/whitelist/darwin_amd64.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "0e619be46236a01e8bc7d8b2b4230a7ba94d2db9", "filename": "libgo/go/cmd/vet/all/whitelist/darwin_arm.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "793cccf8dd84a9e247cb1b920d3c73c5a7985722", "filename": "libgo/go/cmd/vet/all/whitelist/darwin_arm64.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_arm64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_arm64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdarwin_arm64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "6c44159793999d71e29a2bd8a381158177ade35f", "filename": "libgo/go/cmd/vet/all/whitelist/dragonfly_amd64.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdragonfly_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdragonfly_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fdragonfly_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "d37132cebb2ce94e44cfd76216aec4a489103621", "filename": "libgo/go/cmd/vet/all/whitelist/freebsd_386.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "a910f48ca5d7503d3fffcf9354aeccce8e9f459a", "filename": "libgo/go/cmd/vet/all/whitelist/freebsd_amd64.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "11e5c42fd82e82946648d2007d069e160c8f66a6", "filename": "libgo/go/cmd/vet/all/whitelist/freebsd_arm.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Ffreebsd_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "a5111ca876377d16478f06badc091c79c02fa776", "filename": "libgo/go/cmd/vet/all/whitelist/linux_386.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "69ba65d54be6c4e26bcd440ab817b0cfe3451490", "filename": "libgo/go/cmd/vet/all/whitelist/linux_amd64.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fbf0e270aa911b522079b477eabb63a78261170b", "filename": "libgo/go/cmd/vet/all/whitelist/linux_arm.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "67280b72731b08a3b320ee5b2d73743d4213e0d7", "filename": "libgo/go/cmd/vet/all/whitelist/linux_arm64.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_arm64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_arm64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_arm64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "21e87e37d8c8369c79be2a27685a6e7beca74955", "filename": "libgo/go/cmd/vet/all/whitelist/linux_ppc64x.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_ppc64x.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_ppc64x.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Flinux_ppc64x.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ad29336ad1bcd8d9c0b70758c18e1c15c998ef25", "filename": "libgo/go/cmd/vet/all/whitelist/mips.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmips.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmips.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmips.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5354d21c6428f628fa12c73c99e9eea34258ae4b", "filename": "libgo/go/cmd/vet/all/whitelist/mips64x.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmips64x.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmips64x.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmips64x.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "929216905e6b78a6a3cb2c70e5582cbedd22aec6", "filename": "libgo/go/cmd/vet/all/whitelist/mipsle.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmipsle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmipsle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmipsle.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "860f8399211076c1bff473a5770d11d1cccf22af", "filename": "libgo/go/cmd/vet/all/whitelist/mipsx.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmipsx.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmipsx.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fmipsx.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "68bba518ac6739ce997e04a64157cdc0bbc7d7a4", "filename": "libgo/go/cmd/vet/all/whitelist/nacl_386.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4b2aad2aacd9305464d426c0489433206f301881", "filename": "libgo/go/cmd/vet/all/whitelist/nacl_amd64p32.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_amd64p32.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_amd64p32.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_amd64p32.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "cc0fcbab7f2fe9202fb6f716563931f383acf1b9", "filename": "libgo/go/cmd/vet/all/whitelist/nacl_arm.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnacl_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "48bfde5017f6e100e216defced3bd56504765352", "filename": "libgo/go/cmd/vet/all/whitelist/netbsd.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "1d1f323d7ca6a2b3db58920d5c8f3dbacad3cacc", "filename": "libgo/go/cmd/vet/all/whitelist/netbsd_386.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "8b14dc506df0fb586a259d1753acc2ef5b6add5c", "filename": "libgo/go/cmd/vet/all/whitelist/netbsd_amd64.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "c0a0aa2114e51703a82e3bcf461b79b73aa5d420", "filename": "libgo/go/cmd/vet/all/whitelist/netbsd_arm.txt", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fnetbsd_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b5c0a736c2f630604c14b2bcbeb991ad39210014", "filename": "libgo/go/cmd/vet/all/whitelist/openbsd_386.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "433f62ca07a8ad21d2c151631fe38792d746a79c", "filename": "libgo/go/cmd/vet/all/whitelist/openbsd_amd64.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "16bf26c73490c4bc8f80023bf0612060af546ef1", "filename": "libgo/go/cmd/vet/all/whitelist/openbsd_arm.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fopenbsd_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "153116100d4c3d1a6ad2e2a78408d3c4ffa18e49", "filename": "libgo/go/cmd/vet/all/whitelist/plan9_386.txt", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "39fc8e2c3c57b39ee6e490de8fcf016cafb7de08", "filename": "libgo/go/cmd/vet/all/whitelist/plan9_amd64.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5af32717606b5b9d2d06d7a141d28f83321ddbef", "filename": "libgo/go/cmd/vet/all/whitelist/plan9_arm.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_arm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_arm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fplan9_arm.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4f6444e10264acf929da079ee0064faf4c49b590", "filename": "libgo/go/cmd/vet/all/whitelist/ppc64x.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fppc64x.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fppc64x.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fppc64x.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4f83757dbc25ef0995bc44d13f2da48adf9b1bf1", "filename": "libgo/go/cmd/vet/all/whitelist/readme.txt", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Freadme.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f18236c4f112dee1c1fdf7e68d40eb2560de4218", "filename": "libgo/go/cmd/vet/all/whitelist/s390x.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fs390x.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fs390x.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fs390x.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "26a9da42710bd10776712e03dd34b84d51eace18", "filename": "libgo/go/cmd/vet/all/whitelist/solaris_amd64.txt", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fsolaris_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fsolaris_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fsolaris_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2c101aeb980c0e937fc322fe08c2b878cfcd3bb1", "filename": "libgo/go/cmd/vet/all/whitelist/windows.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "788684a49d95b3448c0d08e213c70ce8a06f6e04", "filename": "libgo/go/cmd/vet/all/whitelist/windows_386.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows_386.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows_386.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows_386.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3be4602579eb71da46cbbb2441fee8714062a66a", "filename": "libgo/go/cmd/vet/all/whitelist/windows_amd64.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows_amd64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows_amd64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fall%2Fwhitelist%2Fwindows_amd64.txt?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b01d23d342ba5372f2c06ffbf829ab2e5d8bc1dc", "filename": "libgo/go/cmd/vet/asmdecl.go", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fasmdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fasmdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fasmdecl.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "bfa5b3032938e22eb37dffa586c1b4699bf80152", "filename": "libgo/go/cmd/vet/assign.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fassign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fassign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fassign.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b2ca2d80f304ec35ec54267c48d3a751fb47f1cd", "filename": "libgo/go/cmd/vet/atomic.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fatomic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fatomic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fatomic.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "07c2a93dffa3c2218d86244f1d8f2fed90b4aa88", "filename": "libgo/go/cmd/vet/bool.go", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fbool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fbool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fbool.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "80d8f819240c4eec9f1f816ae7b1515938509fc3", "filename": "libgo/go/cmd/vet/buildtag.go", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fbuildtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fbuildtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fbuildtag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "76364ff6ed8bec5cf26c143828f9cc1717780ff8", "filename": "libgo/go/cmd/vet/cgo.go", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fcgo.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f704f181bf0599155cf24184728c20c2e7b942b2", "filename": "libgo/go/cmd/vet/composite.go", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fcomposite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fcomposite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fcomposite.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ce14e1af3439b0a0107371ba0792c5ce40d42287", "filename": "libgo/go/cmd/vet/copylock.go", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fcopylock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fcopylock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fcopylock.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "130f619626db53c3d51ed8460c852238721e39d4", "filename": "libgo/go/cmd/vet/dead.go", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fdead.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fdead.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fdead.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b1077aef38fdc4737a4dcec9586e4afd5db5c91f", "filename": "libgo/go/cmd/vet/deadcode.go", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fdeadcode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fdeadcode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fdeadcode.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3df975cacc4357fb825e224c5ab996ba9ebadba5", "filename": "libgo/go/cmd/vet/doc.go", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fdoc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "791d11d5bdef047349a8fd9c5a8ff6f6360fe568", "filename": "libgo/go/cmd/vet/httpresponse.go", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fhttpresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fhttpresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fhttpresponse.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "da1cc7e6384df279092fcfa16322771e66f2ec20", "filename": "libgo/go/cmd/vet/internal/cfg/builder.go", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fbuilder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fbuilder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fbuilder.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "e4d5bfe5d2d3b8f626a708d657745f170e0bb0f0", "filename": "libgo/go/cmd/vet/internal/cfg/cfg.go", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2400fed6f4b2fc6c6012bbdc4f059ba29ff27870", "filename": "libgo/go/cmd/vet/internal/cfg/cfg_test.go", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fcfg%2Fcfg_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fdd65d373233e5effbcba96e99e0a478c998fd8a", "filename": "libgo/go/cmd/vet/internal/whitelist/whitelist.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fwhitelist%2Fwhitelist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fwhitelist%2Fwhitelist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Finternal%2Fwhitelist%2Fwhitelist.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "ee0342035fe3729efb3774e0d51f1cea10cd0ef3", "filename": "libgo/go/cmd/vet/lostcancel.go", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Flostcancel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Flostcancel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Flostcancel.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "9d28ebd7876444b5944c194ae1ab896d0d44e038", "filename": "libgo/go/cmd/vet/main.go", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b13ce2fcb56cc0d5ea8a552c8dfe34e184eae2b8", "filename": "libgo/go/cmd/vet/method.go", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fmethod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fmethod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fmethod.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "bfe05e3353da9a098ac2c84e749876cdbae93ad7", "filename": "libgo/go/cmd/vet/nilfunc.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fnilfunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fnilfunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fnilfunc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "456fbcc044de5410caa214517fa03bf8449f060e", "filename": "libgo/go/cmd/vet/print.go", "status": "added", "additions": 780, "deletions": 0, "changes": 780, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fprint.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "53a41364dfe1b84e79d2d0bdfa4ac25694e7b29b", "filename": "libgo/go/cmd/vet/rangeloop.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Frangeloop.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Frangeloop.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Frangeloop.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "29c952fd8858eae7fb8a4d1747d7798e141e8444", "filename": "libgo/go/cmd/vet/shadow.go", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fshadow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fshadow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fshadow.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "1e48d325242bde32fdacf24431ef3ab2e1e07f9b", "filename": "libgo/go/cmd/vet/shift.go", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fshift.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fshift.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fshift.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3bc30c47405d8f6707adb653617abcba80210317", "filename": "libgo/go/cmd/vet/structtag.go", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fstructtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Fstructtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fstructtag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "e6d6d031061227fc201dc9cc4d1e4c379ff801e6", "filename": "libgo/go/cmd/vet/testdata/asm/asm.go", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "cac6ed22cd0031f16c37689e4e750cb0ee15682f", "filename": "libgo/go/cmd/vet/testdata/asm/asm1.s", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm1.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm1.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm1.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "c33c02a70b27e34ad5205501eb0bd935750be51d", "filename": "libgo/go/cmd/vet/testdata/asm/asm2.s", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm2.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm2.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm2.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "3d69356a0f93f811fdf1e727964e7da5acc3a5e3", "filename": "libgo/go/cmd/vet/testdata/asm/asm3.s", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm3.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm3.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm3.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "044b050b6b99e1426f1cc653bb4c25428dd1b52d", "filename": "libgo/go/cmd/vet/testdata/asm/asm4.s", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm4.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm4.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm4.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "c6176e9669f57268c2fa3e9499c27605a7a57f22", "filename": "libgo/go/cmd/vet/testdata/asm/asm5.s", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm5.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm5.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm5.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4e85ab3dcf967731e1e2227075d6fa221f6e79fb", "filename": "libgo/go/cmd/vet/testdata/asm/asm6.s", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm6.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm6.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm6.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "d5ff5460a565d70091195d9fcaf13b4feba0d5b1", "filename": "libgo/go/cmd/vet/testdata/asm/asm7.s", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm7.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm7.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm%2Fasm7.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "550d92a8d2daa6fcc8b714486ba8e534e7850a6e", "filename": "libgo/go/cmd/vet/testdata/asm8.s", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm8.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm8.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fasm8.s?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "6140ad4db8cc0cd7e257556229dc74f69e27baee", "filename": "libgo/go/cmd/vet/testdata/assign.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fassign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fassign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fassign.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "d5a8e61184477d5fb9b9dc085fe5e52658f6992e", "filename": "libgo/go/cmd/vet/testdata/atomic.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fatomic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fatomic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fatomic.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "af6cc011dd60c4d95fcdae7400945b4c943d1e67", "filename": "libgo/go/cmd/vet/testdata/bool.go", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbool.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f12f895dfb19b6de3dd3148b5ce1cbe41c273731", "filename": "libgo/go/cmd/vet/testdata/buildtag/buildtag.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "fbe10cf748f58b1a1291117d4d684b0dc941c782", "filename": "libgo/go/cmd/vet/testdata/buildtag/buildtag_bad.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag_bad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag_bad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fbuildtag%2Fbuildtag_bad.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "d0df7cf6787fe00f12054f9fed434a8b8e1edad7", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "4f27116893138361a13a404e7cada585f4e13426", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo2.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo2.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "0b1518e1f930a572b5497da80346805b6ceab7f3", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo3.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo3.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "67b54506abae1ad4d25282dcbce60eea0e8b1af3", "filename": "libgo/go/cmd/vet/testdata/cgo/cgo4.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcgo%2Fcgo4.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2e6ce262cc12866c566e0dc603f67d41fcb5071c", "filename": "libgo/go/cmd/vet/testdata/composite.go", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcomposite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcomposite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcomposite.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "e9902a27f10dd204a77138beb28aabdbefc946f3", "filename": "libgo/go/cmd/vet/testdata/copylock.go", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "280747a3bf46d3b54539a4c0af140f919674e3d7", "filename": "libgo/go/cmd/vet/testdata/copylock_func.go", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_func.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_func.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_func.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "f127381213cd7571e4d5ed350f615420be7279ad", "filename": "libgo/go/cmd/vet/testdata/copylock_range.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_range.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_range.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fcopylock_range.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "5370bc32f6577e37222d0ee10ac7ac3d4a0b657d", "filename": "libgo/go/cmd/vet/testdata/deadcode.go", "status": "added", "additions": 2125, "deletions": 0, "changes": 2125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdeadcode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdeadcode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdeadcode.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "0efe0f838d56ee6017b22aab81d9fe94dc1e1bd2", "filename": "libgo/go/cmd/vet/testdata/divergent/buf.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b75d55eaf4f2dd4e7314a98cba17e55a3b02cd57", "filename": "libgo/go/cmd/vet/testdata/divergent/buf_test.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fdivergent%2Fbuf_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "7302a64a3b6a59a6f1f9ae7a432790468cccc0d5", "filename": "libgo/go/cmd/vet/testdata/httpresponse.go", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fhttpresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fhttpresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fhttpresponse.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "445502b39ecdef8f037228fa9521eeeb37607acb", "filename": "libgo/go/cmd/vet/testdata/incomplete/examples_test.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fincomplete%2Fexamples_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fincomplete%2Fexamples_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fincomplete%2Fexamples_test.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "b7549c00511127819183818ba3895b5c03536ba8", "filename": "libgo/go/cmd/vet/testdata/lostcancel.go", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Flostcancel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Flostcancel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Flostcancel.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "52b500df272803645f904ae22e9323117bdc83e6", "filename": "libgo/go/cmd/vet/testdata/method.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fmethod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fmethod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fmethod.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}, {"sha": "2ce7bc8ca82eccc641e7d6879ac7dcdb02f5399d", "filename": "libgo/go/cmd/vet/testdata/nilfunc.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fnilfunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a2f01efa63036a5104f203a4789e682c0e0915d/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fnilfunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Ftestdata%2Fnilfunc.go?ref=1a2f01efa63036a5104f203a4789e682c0e0915d"}]}