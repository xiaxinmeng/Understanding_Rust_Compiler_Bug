{"sha": "a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQwZWQwZjMxMDNiMDRlMjQ5ZjJhZDc4YWUzNmUzMjhmMmQ2ZjFjZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-03-06T08:58:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-03-06T08:58:40Z"}, "message": "200x-xx-xx Kazu Hirata <kazu@codesourcery.com> Richard Sandiford <richard@codesourcery.com>\n\ngcc/\n200x-xx-xx  Kazu Hirata  <kazu@codesourcery.com>\n\t    Richard Sandiford  <richard@codesourcery.com>\n\n\t* config/m68k/m68k-protos.h (m68k_interrupt_function_p): Declare.\n\t(m68k_movem_pattern_p, m68k_output_movem): Likewise.\n\t(m68k_expand_prologue, m68k_expand_epilogue): Likewise.\n\t* config/m68k/m68k.h (EPILOGUE_USES): Define.  Treat all registers\n\tas being live on exit from an interrupt function.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Return true for '?'.\n\t* config/m68k/m68k.c (MIN_MOVEM_REGS, MIN_FMOVEM_REGS): New macros.\n\t(m68k_frame): Remove reg_rev_mask and fpu_rev_mask.\n\t(TARGET_ASM_FUNCTION_PROLOGUE, TARGET_ASM_FUNCTION_EPILOGUE): Delete.\n\t(m68k_interrupt_function_p): Globalize.\n\t(m68k_compute_frame_layout): Remove reverse mask code.\n\t(m68k_emit_movem, m68k_set_frame_related): New functions.\n\t(m68k_output_function_prologue): Delete in favor of...\n\t(m68k_expand_prologue): ...this new function.\n\t(m68k_output_function_epilogue): Delete in favor of...\n\t(m68k_expand_epilogue): ...this new function.\n\t(m68k_split_offset, m68k_movem_pattern_p, m68k_output_movem): New\n\tfunctions.\n\t(print_operand): Handle %?.\n\t* config/m68k/m68k.md (UNSPEC_SIN, UNSPEC_COS): Remove excess space.\n\t(UNSPEC_GOT, A1_REG, PIC_REG, FP0_REG): New constants.\n\t(prologue, epilogue): New patterns.\n\t(return): Turn into a define_expand.\n\t(*return): New pattern, derived from old \"return\" pattern.  Use rte\n\trather than rts for interrupt functions.  Only use rtd if the pop\n\tcount is nonzero.\n\t(*m68k_store_multiple, *m68k_store_multiple_automod): New patterns.\n\t(*m68k_load_multiple, *m68k_load_multiple_automod): Likewise.\n\t(link, *link, unlink, *unlink, load_got): Likewise.\n\nCo-Authored-By: Richard Sandiford <richard@codesourcery.com>\n\nFrom-SVN: r122605", "tree": {"sha": "4ec6be1791e9c668d0c60ecc8d9f725a3d0d2609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ec6be1791e9c668d0c60ecc8d9f725a3d0d2609"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/comments", "author": null, "committer": null, "parents": [{"sha": "fc2241eb94b9b29bd2613ea02224a78fdb242a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2241eb94b9b29bd2613ea02224a78fdb242a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2241eb94b9b29bd2613ea02224a78fdb242a95"}], "stats": {"total": 1133, "additions": 678, "deletions": 455}, "files": [{"sha": "cd09c8d84b316c1f4a8d57e78596bd0bdff0a543", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "patch": "@@ -1,3 +1,36 @@\n+2007-03-06  Kazu Hirata  <kazu@codesourcery.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/m68k/m68k-protos.h (m68k_interrupt_function_p): Declare.\n+\t(m68k_movem_pattern_p, m68k_output_movem): Likewise.\n+\t(m68k_expand_prologue, m68k_expand_epilogue): Likewise.\n+\t* config/m68k/m68k.h (EPILOGUE_USES): Define.  Treat all registers\n+\tas being live on exit from an interrupt function.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Return true for '?'.\n+\t* config/m68k/m68k.c (MIN_MOVEM_REGS, MIN_FMOVEM_REGS): New macros.\n+\t(m68k_frame): Remove reg_rev_mask and fpu_rev_mask.\n+\t(TARGET_ASM_FUNCTION_PROLOGUE, TARGET_ASM_FUNCTION_EPILOGUE): Delete.\n+\t(m68k_interrupt_function_p): Globalize.\n+\t(m68k_compute_frame_layout): Remove reverse mask code.\n+\t(m68k_emit_movem, m68k_set_frame_related): New functions.\n+\t(m68k_output_function_prologue): Delete in favor of...\n+\t(m68k_expand_prologue): ...this new function.\n+\t(m68k_output_function_epilogue): Delete in favor of...\n+\t(m68k_expand_epilogue): ...this new function.\n+\t(m68k_split_offset, m68k_movem_pattern_p, m68k_output_movem): New\n+\tfunctions.\n+\t(print_operand): Handle %?.\n+\t* config/m68k/m68k.md (UNSPEC_SIN, UNSPEC_COS): Remove excess space.\n+\t(UNSPEC_GOT, A1_REG, PIC_REG, FP0_REG): New constants.\n+\t(prologue, epilogue): New patterns.\n+\t(return): Turn into a define_expand.\n+\t(*return): New pattern, derived from old \"return\" pattern.  Use rte\n+\trather than rts for interrupt functions.  Only use rtd if the pop\n+\tcount is nonzero.\n+\t(*m68k_store_multiple, *m68k_store_multiple_automod): New patterns.\n+\t(*m68k_load_multiple, *m68k_load_multiple_automod): Likewise.\n+\t(link, *link, unlink, *unlink, load_got): Likewise.\n+\n 2007-03-06  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR target/23482"}, {"sha": "a6705c0f1a086f7796b318a97c5b34877613de31", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02110-1301, USA.  */\n /* Define functions defined in aux-output.c and used in templates.  */\n \n #ifdef RTX_CODE\n+extern bool m68k_interrupt_function_p (tree);\n extern HOST_WIDE_INT m68k_initial_elimination_offset (int from, int to);\n \n extern void split_di (rtx[], int, rtx[], rtx[]);\n@@ -61,12 +62,16 @@ extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n extern rtx m68k_libcall_value (enum machine_mode);\n extern rtx m68k_function_value (tree, tree);\n extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n+extern bool m68k_movem_pattern_p (rtx, rtx, HOST_WIDE_INT, bool);\n+extern const char *m68k_output_movem (rtx *, rtx, HOST_WIDE_INT, bool);\n \n #endif /* RTX_CODE */\n \n extern bool m68k_regno_mode_ok (int, enum machine_mode);\n extern int flags_in_68881 (void);\n+extern void m68k_expand_prologue (void);\n extern bool m68k_use_return_insn (void);\n+extern void m68k_expand_epilogue (void);\n extern void override_options (void);\n extern const char *m68k_cpp_cpu_ident (const char *);\n extern const char *m68k_cpp_cpu_family (const char *);"}, {"sha": "1d6c03546d5fd61e397aaffb990fb5fbe511faea", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 481, "deletions": 448, "changes": 929, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "patch": "@@ -70,6 +70,16 @@ enum reg_class regno_reg_class[] =\n #endif\n \n \n+/* The minimum number of integer registers that we want to save with the\n+   movem instruction.  Using two movel instructions instead of a single\n+   moveml is about 15% faster for the 68020 and 68030 at no expense in\n+   code size.  */\n+#define MIN_MOVEM_REGS 3\n+\n+/* The minimum number of floating point registers that we want to save\n+   with the fmovem instruction.  */\n+#define MIN_FMOVEM_REGS 1\n+\n /* Structure describing stack frame layout.  */\n struct m68k_frame\n {\n@@ -85,12 +95,10 @@ struct m68k_frame\n   /* Data and address register.  */\n   int reg_no;\n   unsigned int reg_mask;\n-  unsigned int reg_rev_mask;\n \n   /* FPU registers.  */\n   int fpu_no;\n   unsigned int fpu_mask;\n-  unsigned int fpu_rev_mask;\n \n   /* Offsets relative to ARG_POINTER.  */\n   HOST_WIDE_INT frame_pointer_offset;\n@@ -127,15 +135,12 @@ struct m68k_address {\n static bool m68k_handle_option (size_t, const char *, int);\n static rtx find_addr_reg (rtx);\n static const char *singlemove_string (rtx *);\n-static void m68k_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void m68k_output_function_epilogue (FILE *, HOST_WIDE_INT);\n #ifdef M68K_TARGET_COFF\n static void m68k_coff_asm_named_section (const char *, unsigned int, tree);\n #endif /* M68K_TARGET_COFF */\n static void m68k_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t  HOST_WIDE_INT, tree);\n static rtx m68k_struct_value_rtx (tree, int);\n-static bool m68k_interrupt_function_p (tree func);\n static tree m68k_handle_fndecl_attribute (tree *node, tree name,\n \t\t\t\t\t  tree args, int flags,\n \t\t\t\t\t  bool *no_add_attrs);\n@@ -182,11 +187,6 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_ASM_UNALIGNED_SI_OP\n #define TARGET_ASM_UNALIGNED_SI_OP TARGET_ASM_ALIGNED_SI_OP\n \n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE m68k_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE m68k_output_function_epilogue\n-\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK m68k_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n@@ -631,8 +631,8 @@ m68k_cpp_cpu_family (const char *prefix)\n \f\n /* Return nonzero if FUNC is an interrupt function as specified by the\n    \"interrupt_handler\" attribute.  */\n-static bool\n-m68k_interrupt_function_p(tree func)\n+bool\n+m68k_interrupt_function_p (tree func)\n {\n   tree a;\n \n@@ -665,7 +665,7 @@ static void\n m68k_compute_frame_layout (void)\n {\n   int regno, saved;\n-  unsigned int mask, rmask;\n+  unsigned int mask;\n   bool interrupt_handler = m68k_interrupt_function_p (current_function_decl);\n \n   /* Only compute the frame once per function.\n@@ -676,36 +676,32 @@ m68k_compute_frame_layout (void)\n \n   current_frame.size = (get_frame_size () + 3) & -4;\n \n-  mask = rmask = saved = 0;\n+  mask = saved = 0;\n   for (regno = 0; regno < 16; regno++)\n     if (m68k_save_reg (regno, interrupt_handler))\n       {\n-\tmask |= 1 << regno;\n-\trmask |= 1 << (15 - regno);\n+\tmask |= 1 << (regno - D0_REG);\n \tsaved++;\n       }\n   current_frame.offset = saved * 4;\n   current_frame.reg_no = saved;\n   current_frame.reg_mask = mask;\n-  current_frame.reg_rev_mask = rmask;\n \n   current_frame.foffset = 0;\n-  mask = rmask = saved = 0;\n+  mask = saved = 0;\n   if (TARGET_HARD_FLOAT)\n     {\n       for (regno = 16; regno < 24; regno++)\n \tif (m68k_save_reg (regno, interrupt_handler))\n \t  {\n-\t    mask |= 1 << (regno - 16);\n-\t    rmask |= 1 << (23 - regno);\n+\t    mask |= 1 << (regno - FP0_REG);\n \t    saved++;\n \t  }\n       current_frame.foffset = saved * TARGET_FP_REG_SIZE;\n       current_frame.offset += current_frame.foffset;\n     }\n   current_frame.fpu_no = saved;\n   current_frame.fpu_mask = mask;\n-  current_frame.fpu_rev_mask = rmask;\n \n   /* Remember what function this frame refers to.  */\n   current_frame.funcdef_no = current_function_funcdef_no;\n@@ -793,154 +789,158 @@ m68k_save_reg (unsigned int regno, bool interrupt_handler)\n   return !call_used_regs[regno];\n }\n \n-/* This function generates the assembly code for function entry.\n-   STREAM is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.  */\n+/* Emit RTL for a MOVEM or FMOVEM instruction.  BASE + OFFSET represents\n+   the lowest memory address.  COUNT is the number of registers to be\n+   moved, with register REGNO + I being moved if bit I of MASK is set.\n+   STORE_P specifies the direction of the move and ADJUST_STACK_P says\n+   whether or not this is pre-decrement (if STORE_P) or post-increment\n+   (if !STORE_P) operation.  */\n+\n+static rtx\n+m68k_emit_movem (rtx base, HOST_WIDE_INT offset,\n+\t\t unsigned int count, unsigned int regno,\n+\t\t unsigned int mask, bool store_p, bool adjust_stack_p)\n+{\n+  int i;\n+  rtx body, addr, src, operands[2];\n+  enum machine_mode mode;\n+\n+  body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (adjust_stack_p + count));\n+  mode = reg_raw_mode[regno];\n+  i = 0;\n+\n+  if (adjust_stack_p)\n+    {\n+      src = plus_constant (base, (count\n+\t\t\t\t  * GET_MODE_SIZE (mode)\n+\t\t\t\t  * (HOST_WIDE_INT) (store_p ? -1 : 1)));\n+      XVECEXP (body, 0, i++) = gen_rtx_SET (VOIDmode, base, src);\n+    }\n+\n+  for (; mask != 0; mask >>= 1, regno++)\n+    if (mask & 1)\n+      {\n+\taddr = plus_constant (base, offset);\n+\toperands[!store_p] = gen_frame_mem (mode, addr);\n+\toperands[store_p] = gen_rtx_REG (mode, regno);\n+\tXVECEXP (body, 0, i++)\n+\t  = gen_rtx_SET (VOIDmode, operands[0], operands[1]);\n+\toffset += GET_MODE_SIZE (mode);\n+      }\n+  gcc_assert (i == XVECLEN (body, 0));\n+\n+  return emit_insn (body);\n+}\n+\n+/* Make INSN a frame-related instruction.  */\n \n static void\n-m68k_output_function_prologue (FILE *stream,\n-\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+m68k_set_frame_related (rtx insn)\n+{\n+  rtx body;\n+  int i;\n+\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  body = PATTERN (insn);\n+  if (GET_CODE (body) == PARALLEL)\n+    for (i = 0; i < XVECLEN (body, 0); i++)\n+      RTX_FRAME_RELATED_P (XVECEXP (body, 0, i)) = 1;\n+}\n+\n+/* Emit RTL for the \"prologue\" define_expand.  */\n+\n+void\n+m68k_expand_prologue (void)\n {\n   HOST_WIDE_INT fsize_with_regs;\n-  HOST_WIDE_INT cfa_offset = INCOMING_FRAME_SP_OFFSET;\n+  rtx limit, src, dest, insn;\n \n-  m68k_compute_frame_layout();\n+  m68k_compute_frame_layout ();\n \n   /* If the stack limit is a symbol, we can check it here,\n      before actually allocating the space.  */\n   if (current_function_limit_stack\n       && GET_CODE (stack_limit_rtx) == SYMBOL_REF)\n-    asm_fprintf (stream, \"\\tcmp\" ASM_DOT \"l %I%s+%wd,%Rsp\\n\\ttrapcs\\n\",\n-\t\t XSTR (stack_limit_rtx, 0), current_frame.size + 4);\n+    {\n+      limit = plus_constant (stack_limit_rtx, current_frame.size + 4);\n+      if (!LEGITIMATE_CONSTANT_P (limit))\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (Pmode, D0_REG), limit);\n+\t  limit = gen_rtx_REG (Pmode, D0_REG);\n+\t}\n+      emit_insn (gen_cmpsi (stack_pointer_rtx, limit));\n+      emit_insn (gen_conditional_trap (gen_rtx_LTU (VOIDmode,\n+\t\t\t\t\t\t    cc0_rtx, const0_rtx),\n+\t\t\t\t       const1_rtx));\n+    }\n \n-  /* On ColdFire add register save into initial stack frame setup, if possible.  */\n   fsize_with_regs = current_frame.size;\n   if (TARGET_COLDFIRE)\n     {\n-      if (current_frame.reg_no > 2)\n-\tfsize_with_regs += current_frame.reg_no * 4;\n-      if (current_frame.fpu_no)\n-\tfsize_with_regs += current_frame.fpu_no * 8;\n+      /* ColdFire's move multiple instructions do not allow pre-decrement\n+\t addressing.  Add the size of movem saves to the initial stack\n+\t allocation instead.  */\n+      if (current_frame.reg_no >= MIN_MOVEM_REGS)\n+\tfsize_with_regs += current_frame.reg_no * GET_MODE_SIZE (SImode);\n+      if (current_frame.fpu_no >= MIN_FMOVEM_REGS)\n+\tfsize_with_regs += current_frame.fpu_no * GET_MODE_SIZE (DFmode);\n     }\n \n   if (frame_pointer_needed)\n     {\n-      if (current_frame.size == 0 && TUNE_68040)\n-\t/* on the 68040, pea + move is faster than link.w 0 */\n-\tfprintf (stream, (MOTOROLA\n-\t\t\t  ? \"\\tpea (%s)\\n\\tmove.l %s,%s\\n\"\n-\t\t\t  : \"\\tpea %s@\\n\\tmovel %s,%s\\n\"),\n-\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t M68K_REGNAME (STACK_POINTER_REGNUM),\n-\t\t M68K_REGNAME (FRAME_POINTER_REGNUM));\n-      else if (fsize_with_regs < 0x8000)\n-\tasm_fprintf (stream, \"\\tlink\" ASM_DOTW \" %s,%I%wd\\n\",\n-\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM), -fsize_with_regs);\n-      else if (TARGET_68020)\n-\tasm_fprintf (stream, \"\\tlink\" ASM_DOTL \" %s,%I%wd\\n\",\n-\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM), -fsize_with_regs);\n-      else\n-\t/* Adding negative number is faster on the 68040.  */\n-\tasm_fprintf (stream,\n-\t\t     \"\\tlink\" ASM_DOTW \" %s,%I0\\n\"\n-\t\t     \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n-\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM), -fsize_with_regs);\n-    }\n-  else if (fsize_with_regs) /* !frame_pointer_needed */\n-    {\n-      if (fsize_with_regs < 0x8000)\n+      if (fsize_with_regs == 0 && TUNE_68040)\n \t{\n-\t  if (fsize_with_regs <= 8)\n-\t    {\n-\t      if (!TARGET_COLDFIRE)\n-\t\tasm_fprintf (stream, \"\\tsubq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n-\t\t             fsize_with_regs);\n-\t      else\n-\t\tasm_fprintf (stream, \"\\tsubq\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n-\t\t             fsize_with_regs);\n-\t    }\n-\t  else if (fsize_with_regs <= 16 && TUNE_CPU32)\n-\t    /* On the CPU32 it is faster to use two subqw instructions to\n-\t       subtract a small integer (8 < N <= 16) to a register.  */\n-\t    asm_fprintf (stream,\n-\t\t\t \"\\tsubq\" ASM_DOT \"w %I8,%Rsp\\n\"\n-\t\t\t \"\\tsubq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n-\t\t\t fsize_with_regs - 8);\n-\t  else if (TUNE_68040)\n-\t    /* Adding negative number is faster on the 68040.  */\n-\t    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n-\t\t\t -fsize_with_regs);\n-\t  else\n-\t    asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t  ? \"\\tlea (%wd,%Rsp),%Rsp\\n\"\n-\t\t\t\t  : \"\\tlea %Rsp@(%wd),%Rsp\\n\"),\n-\t\t\t -fsize_with_regs);\n+\t  /* On the 68040, two separate moves are faster than link.w 0.  */\n+\t  dest = gen_frame_mem (Pmode,\n+\t\t\t\tgen_rtx_PRE_DEC (Pmode, stack_pointer_rtx));\n+\t  m68k_set_frame_related (emit_move_insn (dest, frame_pointer_rtx));\n+\t  m68k_set_frame_related (emit_move_insn (frame_pointer_rtx,\n+\t\t\t\t\t\t  stack_pointer_rtx));\n \t}\n-      else /* fsize_with_regs >= 0x8000 */\n-\tasm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n-\t\t     -fsize_with_regs);\n-    } /* !frame_pointer_needed */\n-\n-  if (dwarf2out_do_frame ())\n-    {\n-      if (frame_pointer_needed)\n-\t{\n-\t  char *l;\n-\t  l = (char *) dwarf2out_cfi_label ();\n-\t  cfa_offset += 4;\n-\t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM, -cfa_offset);\n-\t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, cfa_offset);\n-\t  cfa_offset += current_frame.size;\n-        }\n+      else if (fsize_with_regs < 0x8000 || TARGET_68020)\n+\tm68k_set_frame_related\n+\t  (emit_insn (gen_link (frame_pointer_rtx,\n+\t\t\t\tGEN_INT (-4 - fsize_with_regs))));\n       else\n-        {\n-\t  cfa_offset += current_frame.size;\n-\t  dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, cfa_offset);\n-        }\n+ \t{\n+\t  m68k_set_frame_related\n+\t    (emit_insn (gen_link (frame_pointer_rtx, GEN_INT (-4))));\n+\t  m68k_set_frame_related\n+\t    (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-fsize_with_regs))));\n+\t}\n     }\n+  else if (fsize_with_regs != 0)\n+    m68k_set_frame_related\n+      (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t      stack_pointer_rtx,\n+\t\t\t      GEN_INT (-fsize_with_regs))));\n \n   if (current_frame.fpu_mask)\n     {\n+      gcc_assert (current_frame.fpu_no >= MIN_FMOVEM_REGS);\n       if (TARGET_68881)\n-\t{\n-\t  asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t? \"\\tfmovm %I0x%x,-(%Rsp)\\n\"\n-\t\t\t\t: \"\\tfmovem %I0x%x,%Rsp@-\\n\"),\n-\t\t       current_frame.fpu_mask);\n-\t}\n+\tm68k_set_frame_related\n+\t  (m68k_emit_movem (stack_pointer_rtx,\n+\t\t\t    current_frame.fpu_no * -GET_MODE_SIZE (XFmode),\n+\t\t\t    current_frame.fpu_no, FP0_REG,\n+\t\t\t    current_frame.fpu_mask, true, true));\n       else\n \t{\n \t  int offset;\n \n-\t  /* stack already has registers in it.  Find the offset from\n-\t     the bottom of stack to where the FP registers go */\n-\t  if (current_frame.reg_no <= 2)\n+\t  /* If we're using moveml to save the integer registers,\n+\t     the stack pointer will point to the bottom of the moveml\n+\t     save area.  Find the stack offset of the first FP register.  */\n+\t  if (current_frame.reg_no < MIN_MOVEM_REGS)\n \t    offset = 0;\n \t  else\n-\t    offset = current_frame.reg_no * 4;\n-\t  if (offset)\n-\t    asm_fprintf (stream,\n-\t\t\t \"\\tfmovem %I0x%x,%d(%Rsp)\\n\",\n-\t\t\t current_frame.fpu_rev_mask,\n-\t\t\t offset);\n-\t  else\n-\t    asm_fprintf (stream,\n-\t\t\t \"\\tfmovem %I0x%x,(%Rsp)\\n\",\n-\t\t\t current_frame.fpu_rev_mask);\n-\t}\n-\n-      if (dwarf2out_do_frame ())\n-\t{\n-\t  char *l = (char *) dwarf2out_cfi_label ();\n-\t  int n_regs, regno;\n-\n-\t  cfa_offset += current_frame.fpu_no * TARGET_FP_REG_SIZE;\n-\t  if (! frame_pointer_needed)\n-\t    dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n-\t  for (regno = 16, n_regs = 0; regno < 24; regno++)\n-\t    if (current_frame.fpu_mask & (1 << (regno - 16)))\n-\t      dwarf2out_reg_save (l, regno, -cfa_offset\n-\t\t\t\t  + n_regs++ * TARGET_FP_REG_SIZE);\n+\t    offset = current_frame.reg_no * GET_MODE_SIZE (SImode);\n+\t  m68k_set_frame_related\n+\t    (m68k_emit_movem (stack_pointer_rtx, offset,\n+\t\t\t      current_frame.fpu_no, FP0_REG,\n+\t\t\t      current_frame.fpu_mask, true, false));\n \t}\n     }\n \n@@ -949,96 +949,56 @@ m68k_output_function_prologue (FILE *stream,\n   if (current_function_limit_stack)\n     {\n       if (REG_P (stack_limit_rtx))\n-\tasm_fprintf (stream, \"\\tcmp\" ASM_DOT \"l %s,%Rsp\\n\\ttrapcs\\n\",\n-\t\t     M68K_REGNAME (REGNO (stack_limit_rtx)));\n+\t{\n+\t  emit_insn (gen_cmpsi (stack_pointer_rtx, stack_limit_rtx));\n+\t  emit_insn (gen_conditional_trap (gen_rtx_LTU (VOIDmode,\n+\t\t\t\t\t\t\tcc0_rtx, const0_rtx),\n+\t\t\t\t\t   const1_rtx));\n+\t}\n       else if (GET_CODE (stack_limit_rtx) != SYMBOL_REF)\n \twarning (0, \"stack limit expression is not supported\");\n     }\n \n-  if (current_frame.reg_no <= 2)\n+  if (current_frame.reg_no < MIN_MOVEM_REGS)\n     {\n-      /* Store each separately in the same order moveml uses.\n-         Using two movel instructions instead of a single moveml\n-         is about 15% faster for the 68020 and 68030 at no expense\n-         in code size.  */\n-\n+      /* Store each register separately in the same order moveml does.  */\n       int i;\n \n-      for (i = 0; i < 16; i++)\n-        if (current_frame.reg_rev_mask & (1 << i))\n+      for (i = 16; i-- > 0; )\n+\tif (current_frame.reg_mask & (1 << i))\n \t  {\n-\t    asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t  ? \"\\t%Omove.l %s,-(%Rsp)\\n\"\n-\t\t\t\t  : \"\\tmovel %s,%Rsp@-\\n\"),\n-\t\t\t M68K_REGNAME (15 - i));\n-\t    if (dwarf2out_do_frame ())\n-\t      {\n-\t\tchar *l = (char *) dwarf2out_cfi_label ();\n-\n-\t\tcfa_offset += 4;\n-\t\tif (! frame_pointer_needed)\n-\t\t  dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n-\t\tdwarf2out_reg_save (l, 15 - i, -cfa_offset);\n-\t      }\n+\t    src = gen_rtx_REG (SImode, D0_REG + i);\n+\t    dest = gen_frame_mem (SImode,\n+\t\t\t\t  gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx));\n+\t    m68k_set_frame_related (emit_insn (gen_movsi (dest, src)));\n \t  }\n     }\n-  else if (current_frame.reg_rev_mask)\n+  else\n     {\n       if (TARGET_COLDFIRE)\n-\t/* The ColdFire does not support the predecrement form of the\n-\t   MOVEM instruction, so we must adjust the stack pointer and\n-\t   then use the plain address register indirect mode.\n-\t   The required register save space was combined earlier with\n-\t   the fsize_with_regs amount.  */\n-\n-\tasm_fprintf (stream, (MOTOROLA\n-\t\t\t      ? \"\\tmovm.l %I0x%x,(%Rsp)\\n\"\n-\t\t\t      : \"\\tmoveml %I0x%x,%Rsp@\\n\"),\n-\t\t     current_frame.reg_mask);\n+\t/* The required register save space has already been allocated.\n+\t   The first register should be stored at (%sp).  */\n+\tm68k_set_frame_related\n+\t  (m68k_emit_movem (stack_pointer_rtx, 0,\n+\t\t\t    current_frame.reg_no, D0_REG,\n+\t\t\t    current_frame.reg_mask, true, false));\n       else\n-\tasm_fprintf (stream, (MOTOROLA\n-\t\t\t      ? \"\\tmovm.l %I0x%x,-(%Rsp)\\n\"\n-\t\t\t      : \"\\tmoveml %I0x%x,%Rsp@-\\n\"),\n-\t\t     current_frame.reg_rev_mask);\n-      if (dwarf2out_do_frame ())\n-\t{\n-\t  char *l = (char *) dwarf2out_cfi_label ();\n-\t  int n_regs, regno;\n-\n-\t  cfa_offset += current_frame.reg_no * 4;\n-\t  if (! frame_pointer_needed)\n-\t    dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n-\t  for (regno = 0, n_regs = 0; regno < 16; regno++)\n-\t    if (current_frame.reg_mask & (1 << regno))\n-\t      dwarf2out_reg_save (l, regno, -cfa_offset + n_regs++ * 4);\n-\t}\n+\tm68k_set_frame_related\n+\t  (m68k_emit_movem (stack_pointer_rtx,\n+\t\t\t    current_frame.reg_no * -GET_MODE_SIZE (SImode),\n+\t\t\t    current_frame.reg_no, D0_REG,\n+\t\t\t    current_frame.reg_mask, true, true));\n     }\n-  if (!TARGET_SEP_DATA && flag_pic\n+\n+  if (flag_pic\n+      && !TARGET_SEP_DATA\n       && (current_function_uses_pic_offset_table\n \t  || (!current_function_is_leaf && TARGET_ID_SHARED_LIBRARY)))\n     {\n-      if (TARGET_ID_SHARED_LIBRARY)\n-\t{\n-\t  asm_fprintf (stream, \"\\tmovel %s@(%s), %s\\n\",\n-\t\t       M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM),\n-\t\t       m68k_library_id_string,\n-\t\t       M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n-\t}\n-      else\n-\t{\n-\t  if (MOTOROLA)\n-\t    asm_fprintf (stream,\n-\t\t\t \"\\t%Olea (%Rpc, %U_GLOBAL_OFFSET_TABLE_@GOTPC), %s\\n\",\n-\t\t\t M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n-\t  else\n-\t    {\n-\t      asm_fprintf (stream, \"\\tmovel %I%U_GLOBAL_OFFSET_TABLE_, %s\\n\",\n-\t\t\t   M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n-\t      asm_fprintf (stream, \"\\tlea %Rpc@(0,%s:l),%s\\n\",\n-\t\t\t   M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM),\n-\t\t\t   M68K_REGNAME (PIC_OFFSET_TABLE_REGNUM));\n-\t    }\n-\t}\n+      insn = emit_insn (gen_load_got (pic_offset_table_rtx));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n+\t\t\t\t\t    const0_rtx,\n+\t\t\t\t\t    REG_NOTES (insn));\n     }\n }\n \f\n@@ -1055,301 +1015,173 @@ m68k_use_return_insn (void)\n   return current_frame.offset == 0;\n }\n \n-/* This function generates the assembly code for function exit,\n-   on machines that need it.\n+/* Emit RTL for the \"epilogue\" define_expand.\n \n    The function epilogue should not depend on the current stack pointer!\n    It should use the frame pointer only, if there is a frame pointer.\n    This is mandatory because of alloca; we also take advantage of it to\n    omit stack adjustments before returning.  */\n \n-static void\n-m68k_output_function_epilogue (FILE *stream,\n-\t\t\t       HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+void\n+m68k_expand_epilogue (void)\n {\n   HOST_WIDE_INT fsize, fsize_with_regs;\n-  bool big = false;\n-  bool restore_from_sp = false;\n-  rtx insn = get_last_insn ();\n+  bool big, restore_from_sp;\n \n   m68k_compute_frame_layout ();\n \n-  /* If the last insn was a BARRIER, we don't have to write any code.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn && GET_CODE (insn) == BARRIER)\n-    return;\n-\n   fsize = current_frame.size;\n+  big = false;\n+  restore_from_sp = false;\n \n-  /* FIXME: leaf_function_p below is too strong.\n+  /* FIXME : current_function_is_leaf below is too strong.\n      What we really need to know there is if there could be pending\n      stack adjustment needed at that point.  */\n-  restore_from_sp\n-    = (! frame_pointer_needed\n-       || (! current_function_calls_alloca && leaf_function_p ()));\n+  restore_from_sp = (!frame_pointer_needed\n+\t\t     || (!current_function_calls_alloca\n+\t\t\t && current_function_is_leaf));\n \n   /* fsize_with_regs is the size we need to adjust the sp when\n      popping the frame.  */\n   fsize_with_regs = fsize;\n-\n-  /* Because the ColdFire doesn't support moveml with\n-     complex address modes, we must adjust the stack manually\n-     after restoring registers. When the frame pointer isn't used,\n-     we can merge movem adjustment into frame unlinking\n-     made immediately after it.  */\n   if (TARGET_COLDFIRE && restore_from_sp)\n     {\n-      if (current_frame.reg_no > 2)\n-\tfsize_with_regs += current_frame.reg_no * 4;\n-      if (current_frame.fpu_no)\n-\tfsize_with_regs += current_frame.fpu_no * 8;\n+      /* ColdFire's move multiple instructions do not allow post-increment\n+\t addressing.  Add the size of movem loads to the final deallocation\n+\t instead.  */\n+      if (current_frame.reg_no >= MIN_MOVEM_REGS)\n+\tfsize_with_regs += current_frame.reg_no * GET_MODE_SIZE (SImode);\n+      if (current_frame.fpu_no >= MIN_FMOVEM_REGS)\n+\tfsize_with_regs += current_frame.fpu_no * GET_MODE_SIZE (DFmode);\n     }\n \n   if (current_frame.offset + fsize >= 0x8000\n-      && ! restore_from_sp\n+      && !restore_from_sp\n       && (current_frame.reg_mask || current_frame.fpu_mask))\n     {\n-      /* Because the ColdFire doesn't support moveml with\n-         complex address modes we make an extra correction here.  */\n-      if (TARGET_COLDFIRE)\n-        fsize += current_frame.offset;\n-\n-      asm_fprintf (stream, \"\\t%Omove\" ASM_DOT \"l %I%wd,%Ra1\\n\", -fsize);\n-      fsize = 0, big = true;\n+      if (TARGET_COLDFIRE\n+\t  && (current_frame.reg_no >= MIN_MOVEM_REGS\n+\t      || current_frame.fpu_no >= MIN_FMOVEM_REGS))\n+\t{\n+\t  /* ColdFire's move multiple instructions do not support the\n+\t     (d8,Ax,Xi) addressing mode, so we're as well using a normal\n+\t     stack-based restore.  */\n+\t  emit_move_insn (gen_rtx_REG (Pmode, A1_REG),\n+\t\t\t  GEN_INT (-(current_frame.offset + fsize)));\n+\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t gen_rtx_REG (Pmode, A1_REG),\n+\t\t\t\t frame_pointer_rtx));\n+\t  restore_from_sp = true;\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (Pmode, A1_REG), GEN_INT (-fsize));\n+\t  fsize = 0;\n+\t  big = true;\n+\t}\n     }\n-  if (current_frame.reg_no <= 2)\n-    {\n-      /* Restore each separately in the same order moveml does.\n-         Using two movel instructions instead of a single moveml\n-         is about 15% faster for the 68020 and 68030 at no expense\n-         in code size.  */\n \n+  if (current_frame.reg_no < MIN_MOVEM_REGS)\n+    {\n+      /* Restore each register separately in the same order moveml does.  */\n       int i;\n-      HOST_WIDE_INT offset = current_frame.offset + fsize;\n+      HOST_WIDE_INT offset;\n \n+      offset = current_frame.offset + fsize;\n       for (i = 0; i < 16; i++)\n         if (current_frame.reg_mask & (1 << i))\n           {\n-            if (big)\n-\t      {\n-\t\tif (MOTOROLA)\n-\t\t  asm_fprintf (stream, \"\\t%Omove.l -%wd(%s,%Ra1.l),%s\\n\",\n-\t\t\t       offset,\n-\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t       M68K_REGNAME (i));\n-\t\telse\n-\t\t  asm_fprintf (stream, \"\\tmovel %s@(-%wd,%Ra1:l),%s\\n\",\n-\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t       offset,\n-\t\t\t       M68K_REGNAME (i));\n-\t      }\n-            else if (restore_from_sp)\n-\t      asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t    ? \"\\t%Omove.l (%Rsp)+,%s\\n\"\n-\t\t\t\t    : \"\\tmovel %Rsp@+,%s\\n\"),\n-\t\t\t   M68K_REGNAME (i));\n-            else\n+\t    rtx addr;\n+\n+\t    if (big)\n \t      {\n-\t        if (MOTOROLA)\n-\t\t  asm_fprintf (stream, \"\\t%Omove.l -%wd(%s),%s\\n\",\n-\t\t\t       offset,\n-\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t       M68K_REGNAME (i));\n-\t\telse\n-\t\t  asm_fprintf (stream, \"\\tmovel %s@(-%wd),%s\\n\",\n-\t\t\t       M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t       offset,\n-\t\t\t       M68K_REGNAME (i));\n+\t\t/* Generate the address -OFFSET(%fp,%a1.l).  */\n+\t\taddr = gen_rtx_REG (Pmode, A1_REG);\n+\t\taddr = gen_rtx_PLUS (Pmode, addr, frame_pointer_rtx);\n+\t\taddr = plus_constant (addr, -offset);\n \t      }\n-            offset -= 4;\n-          }\n+\t    else if (restore_from_sp)\n+\t      addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\t    else\n+\t      addr = plus_constant (frame_pointer_rtx, -offset);\n+\t    emit_move_insn (gen_rtx_REG (SImode, D0_REG + i),\n+\t\t\t    gen_frame_mem (SImode, addr));\n+\t    offset -= GET_MODE_SIZE (SImode);\n+\t  }\n     }\n   else if (current_frame.reg_mask)\n     {\n-      /* The ColdFire requires special handling due to its limited moveml\n-\t insn.  */\n-      if (TARGET_COLDFIRE)\n-        {\n-          if (big)\n-            {\n-              asm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %s,%Ra1\\n\",\n-\t\t\t   M68K_REGNAME (FRAME_POINTER_REGNUM));\n-              asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t    ? \"\\tmovm.l (%Ra1),%I0x%x\\n\"\n-\t\t\t\t    : \"\\tmoveml %Ra1@,%I0x%x\\n\"),\n-\t\t\t   current_frame.reg_mask);\n-\t     }\n-\t   else if (restore_from_sp)\n-\t     asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t   ? \"\\tmovm.l (%Rsp),%I0x%x\\n\"\n-\t\t\t\t   : \"\\tmoveml %Rsp@,%I0x%x\\n\"),\n-\t\t\t  current_frame.reg_mask);\n-          else\n-            {\n-\t      if (MOTOROLA)\n-\t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n-\t\t\t     current_frame.offset + fsize,\n-\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t     current_frame.reg_mask);\n-\t      else\n-\t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t     current_frame.offset + fsize,\n-\t\t\t     current_frame.reg_mask);\n-\t    }\n-        }\n-      else /* !TARGET_COLDFIRE */\n-\t{\n-\t  if (big)\n-\t    {\n-\t      if (MOTOROLA)\n-\t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s,%Ra1.l),%I0x%x\\n\",\n-\t\t\t     current_frame.offset + fsize,\n-\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t     current_frame.reg_mask);\n-\t      else\n-\t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t     current_frame.offset + fsize,\n-\t\t\t     current_frame.reg_mask);\n-\t    }\n-\t  else if (restore_from_sp)\n-\t    {\n-\t      asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t    ? \"\\tmovm.l (%Rsp)+,%I0x%x\\n\"\n-\t\t\t\t    : \"\\tmoveml %Rsp@+,%I0x%x\\n\"),\n-\t\t\t   current_frame.reg_mask);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (MOTOROLA)\n-\t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n-\t\t\t     current_frame.offset + fsize,\n-\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t     current_frame.reg_mask);\n-\t      else\n-\t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t\t     M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t     current_frame.offset + fsize,\n-\t\t\t     current_frame.reg_mask);\n-\t    }\n-\t}\n+      if (big)\n+\tm68k_emit_movem (gen_rtx_PLUS (Pmode,\n+\t\t\t\t       gen_rtx_REG (Pmode, A1_REG),\n+\t\t\t\t       frame_pointer_rtx),\n+\t\t\t -(current_frame.offset + fsize),\n+\t\t\t current_frame.reg_no, D0_REG,\n+\t\t\t current_frame.reg_mask, false, false);\n+      else if (restore_from_sp)\n+\tm68k_emit_movem (stack_pointer_rtx, 0,\n+\t\t\t current_frame.reg_no, D0_REG,\n+\t\t\t current_frame.reg_mask, false,\n+\t\t\t !TARGET_COLDFIRE);\n+      else\n+\tm68k_emit_movem (frame_pointer_rtx,\n+\t\t\t -(current_frame.offset + fsize),\n+\t\t\t current_frame.reg_no, D0_REG,\n+\t\t\t current_frame.reg_mask, false, false);\n     }\n-  if (current_frame.fpu_rev_mask)\n+\n+  if (current_frame.fpu_no > 0)\n     {\n       if (big)\n-\t{\n-\t  if (TARGET_COLDFIRE)\n-\t    {\n-\t      if (current_frame.reg_no)\n-\t\tasm_fprintf (stream, MOTOROLA ?\n-\t\t\t     \"\\tfmovem.d %d(%Ra1),%I0x%x\\n\" :\n-\t\t\t     \"\\tfmovmd (%d,%Ra1),%I0x%x\\n\",\n-\t\t\t     current_frame.reg_no * 4,\n-\t\t\t     current_frame.fpu_rev_mask);\n-\t      else\n-\t\tasm_fprintf (stream, MOTOROLA ?\n-\t\t\t     \"\\tfmovem.d (%Ra1),%I0x%x\\n\" :\n-\t\t\t     \"\\tfmovmd (%Ra1),%I0x%x\\n\",\n-\t\t\t     current_frame.fpu_rev_mask);\n-\t    }\n-\t  else if (MOTOROLA)\n-\t    asm_fprintf (stream, \"\\tfmovm -%wd(%s,%Ra1.l),%I0x%x\\n\",\n-\t\t         current_frame.foffset + fsize,\n-\t\t         M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t         current_frame.fpu_rev_mask);\n-\t  else\n-\t    asm_fprintf (stream, \"\\tfmovem %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t current_frame.foffset + fsize,\n-\t\t\t current_frame.fpu_rev_mask);\n-\t}\n+\tm68k_emit_movem (gen_rtx_PLUS (Pmode,\n+\t\t\t\t       gen_rtx_REG (Pmode, A1_REG),\n+\t\t\t\t       frame_pointer_rtx),\n+\t\t\t -(current_frame.foffset + fsize),\n+\t\t\t current_frame.fpu_no, FP0_REG,\n+\t\t\t current_frame.fpu_mask, false, false);\n       else if (restore_from_sp)\n \t{\n \t  if (TARGET_COLDFIRE)\n \t    {\n \t      int offset;\n \n-\t      /* Stack already has registers in it.  Find the offset from\n-\t\t the bottom of stack to where the FP registers go.  */\n-\t      if (current_frame.reg_no <= 2)\n+\t      /* If we used moveml to restore the integer registers, the\n+\t\t stack pointer will still point to the bottom of the moveml\n+\t\t save area.  Find the stack offset of the first FP\n+\t\t register.  */\n+\t      if (current_frame.reg_no < MIN_MOVEM_REGS)\n \t\toffset = 0;\n \t      else\n-\t\toffset = current_frame.reg_no * 4;\n-\t      if (offset)\n-\t\tasm_fprintf (stream,\n-\t\t\t     \"\\tfmovem %Rsp@(%d), %I0x%x\\n\",\n-\t\t\t     offset, current_frame.fpu_rev_mask);\n-\t      else\n-\t\tasm_fprintf (stream,\n-\t\t\t     \"\\tfmovem %Rsp@, %I0x%x\\n\",\n-\t\t\t     current_frame.fpu_rev_mask);\n+\t\toffset = current_frame.reg_no * GET_MODE_SIZE (SImode);\n+\t      m68k_emit_movem (stack_pointer_rtx, offset,\n+\t\t\t       current_frame.fpu_no, FP0_REG,\n+\t\t\t       current_frame.fpu_mask, false, false);\n \t    }\n \t  else\n-\t    asm_fprintf (stream, MOTOROLA ?\n-\t\t\t \"\\tfmovm (%Rsp)+,%I0x%x\\n\" :\n-\t\t\t \"\\tfmovem %Rsp@+,%I0x%x\\n\",\n-\t\t\t current_frame.fpu_rev_mask);\n+\t    m68k_emit_movem (stack_pointer_rtx, 0,\n+\t\t\t     current_frame.fpu_no, FP0_REG,\n+\t\t\t     current_frame.fpu_mask, false, true);\n \t}\n       else\n-\t{\n-\t  if (MOTOROLA && !TARGET_COLDFIRE)\n-\t    asm_fprintf (stream, \"\\tfmovm -%wd(%s),%I0x%x\\n\",\n-\t\t\t current_frame.foffset + fsize,\n-\t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t current_frame.fpu_rev_mask);\n-\t  else\n-\t    asm_fprintf (stream, \"\\tfmovem %s@(-%wd),%I0x%x\\n\",\n-\t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n-\t\t\t current_frame.foffset + fsize,\n-\t\t\t current_frame.fpu_rev_mask);\n-\t}\n+\tm68k_emit_movem (frame_pointer_rtx,\n+\t\t\t -(current_frame.foffset + fsize),\n+\t\t\t current_frame.fpu_no, FP0_REG,\n+\t\t\t current_frame.fpu_mask, false, false);\n     }\n+\n   if (frame_pointer_needed)\n-    fprintf (stream, \"\\tunlk %s\\n\", M68K_REGNAME (FRAME_POINTER_REGNUM));\n+    emit_insn (gen_unlink (frame_pointer_rtx));\n   else if (fsize_with_regs)\n-    {\n-      if (fsize_with_regs <= 8)\n-\t{\n-\t  if (!TARGET_COLDFIRE)\n-\t    asm_fprintf (stream, \"\\taddq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n-\t\t\t fsize_with_regs);\n-\t  else\n-\t    asm_fprintf (stream, \"\\taddq\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n-\t\t\t fsize_with_regs);\n-\t}\n-      else if (fsize_with_regs <= 16 && TUNE_CPU32)\n-\t{\n-\t  /* On the CPU32 it is faster to use two addqw instructions to\n-\t     add a small integer (8 < N <= 16) to a register.  */\n-\t  asm_fprintf (stream,\n-\t\t       \"\\taddq\" ASM_DOT \"w %I8,%Rsp\\n\"\n-\t\t       \"\\taddq\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n-\t\t       fsize_with_regs - 8);\n-\t}\n-      else if (fsize_with_regs < 0x8000)\n-\t{\n-\t  if (TUNE_68040)\n-\t    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"w %I%wd,%Rsp\\n\",\n-\t\t\t fsize_with_regs);\n-\t  else\n-\t    asm_fprintf (stream, (MOTOROLA\n-\t\t\t\t  ? \"\\tlea (%wd,%Rsp),%Rsp\\n\"\n-\t\t\t\t  : \"\\tlea %Rsp@(%wd),%Rsp\\n\"),\n-\t\t\t fsize_with_regs);\n-\t}\n-      else\n-\tasm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\", fsize_with_regs);\n-    }\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   GEN_INT (fsize_with_regs)));\n+\n   if (current_function_calls_eh_return)\n-    asm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %Ra0,%Rsp\\n\");\n-  if (m68k_interrupt_function_p (current_function_decl))\n-    fprintf (stream, \"\\trte\\n\");\n-  else if (current_function_pops_args)\n-    asm_fprintf (stream, \"\\trtd %I%d\\n\", current_function_pops_args);\n-  else\n-    fprintf (stream, \"\\trts\\n\");\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   EH_RETURN_STACKADJ_RTX));\n+\n+  emit_insn (gen_rtx_RETURN (VOIDmode));\n }\n \f\n /* Return true if X is a valid comparison operator for the dbcc \n@@ -3110,6 +2942,204 @@ split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n     }\n }\n \n+/* Split X into a base and a constant offset, storing them in *BASE\n+   and *OFFSET respectively.  */\n+\n+static void\n+m68k_split_offset (rtx x, rtx *base, HOST_WIDE_INT *offset)\n+{\n+  *offset = 0;\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *offset += INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+  *base = x;\n+}\n+\n+/* Return true if PATTERN is a PARALLEL suitable for a movem or fmovem\n+   instruction.  STORE_P says whether the move is a load or store.\n+\n+   If the instruction uses post-increment or pre-decrement addressing,\n+   AUTOMOD_BASE is the base register and AUTOMOD_OFFSET is the total\n+   adjustment.  This adjustment will be made by the first element of\n+   PARALLEL, with the loads or stores starting at element 1.  If the\n+   instruction does not use post-increment or pre-decrement addressing,\n+   AUTOMOD_BASE is null, AUTOMOD_OFFSET is 0, and the loads or stores\n+   start at element 0.  */\n+\n+bool\n+m68k_movem_pattern_p (rtx pattern, rtx automod_base,\n+\t\t      HOST_WIDE_INT automod_offset, bool store_p)\n+{\n+  rtx base, mem_base, set, mem, reg, last_reg;\n+  HOST_WIDE_INT offset, mem_offset;\n+  int i, first, len;\n+  enum reg_class rclass;\n+\n+  len = XVECLEN (pattern, 0);\n+  first = (automod_base != NULL);\n+\n+  if (automod_base)\n+    {\n+      /* Stores must be pre-decrement and loads must be post-increment.  */\n+      if (store_p != (automod_offset < 0))\n+\treturn false;\n+\n+      /* Work out the base and offset for lowest memory location.  */\n+      base = automod_base;\n+      offset = (automod_offset < 0 ? automod_offset : 0);\n+    }\n+  else\n+    {\n+      /* Allow any valid base and offset in the first access.  */\n+      base = NULL;\n+      offset = 0;\n+    }\n+\n+  last_reg = NULL;\n+  rclass = NO_REGS;\n+  for (i = first; i < len; i++)\n+    {\n+      /* We need a plain SET.  */\n+      set = XVECEXP (pattern, 0, i);\n+      if (GET_CODE (set) != SET)\n+\treturn false;\n+\n+      /* Check that we have a memory location...  */\n+      mem = XEXP (set, !store_p);\n+      if (!MEM_P (mem) || !memory_operand (mem, VOIDmode))\n+\treturn false;\n+\n+      /* ...with the right address.  */\n+      if (base == NULL)\n+\t{\n+\t  m68k_split_offset (XEXP (mem, 0), &base, &offset);\n+\t  /* The ColdFire instruction only allows (An) and (d16,An) modes.\n+\t     There are no mode restrictions for 680x0 besides the\n+\t     automodification rules enforced above.  */\n+\t  if (TARGET_COLDFIRE\n+\t      && !m68k_legitimate_base_reg_p (base, reload_completed))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  m68k_split_offset (XEXP (mem, 0), &mem_base, &mem_offset);\n+\t  if (!rtx_equal_p (base, mem_base) || offset != mem_offset)\n+\t    return false;\n+\t}\n+\n+      /* Check that we have a register of the required mode and class.  */\n+      reg = XEXP (set, store_p);\n+      if (!REG_P (reg)\n+\t  || !HARD_REGISTER_P (reg)\n+\t  || GET_MODE (reg) != reg_raw_mode[REGNO (reg)])\n+\treturn false;\n+\n+      if (last_reg)\n+\t{\n+\t  /* The register must belong to RCLASS and have a higher number\n+\t     than the register in the previous SET.  */\n+\t  if (!TEST_HARD_REG_BIT (reg_class_contents[rclass], REGNO (reg))\n+\t      || REGNO (last_reg) >= REGNO (reg))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  /* Work out which register class we need.  */\n+\t  if (INT_REGNO_P (REGNO (reg)))\n+\t    rclass = GENERAL_REGS;\n+\t  else if (FP_REGNO_P (REGNO (reg)))\n+\t    rclass = FP_REGS;\n+\t  else\n+\t    return false;\n+\t}\n+\n+      last_reg = reg;\n+      offset += GET_MODE_SIZE (GET_MODE (reg));\n+    }\n+\n+  /* If we have an automodification, check whether the final offset is OK.  */\n+  if (automod_base && offset != (automod_offset < 0 ? 0 : automod_offset))\n+    return false;\n+\n+  /* Reject unprofitable cases.  */\n+  if (len < first + (rclass == FP_REGS ? MIN_FMOVEM_REGS : MIN_MOVEM_REGS))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return the assembly code template for a movem or fmovem instruction\n+   whose pattern is given by PATTERN.  Store the template's operands\n+   in OPERANDS.\n+\n+   If the instruction uses post-increment or pre-decrement addressing,\n+   AUTOMOD_OFFSET is the total adjustment, otherwise it is 0.  STORE_P\n+   is true if this is a store instruction.  */\n+\n+const char *\n+m68k_output_movem (rtx *operands, rtx pattern,\n+\t\t   HOST_WIDE_INT automod_offset, bool store_p)\n+{\n+  unsigned int mask;\n+  int i, first;\n+\n+  gcc_assert (GET_CODE (pattern) == PARALLEL);\n+  mask = 0;\n+  first = (automod_offset != 0);\n+  for (i = first; i < XVECLEN (pattern, 0); i++)\n+    {\n+      /* When using movem with pre-decrement addressing, register X + D0_REG\n+\t is controlled by bit 15 - X.  For all other addressing modes,\n+\t register X + D0_REG is controlled by bit X.  Confusingly, the\n+\t register mask for fmovem is in the opposite order to that for\n+\t movem.  */\n+      unsigned int regno;\n+\n+      gcc_assert (MEM_P (XEXP (XVECEXP (pattern, 0, i), !store_p)));\n+      gcc_assert (REG_P (XEXP (XVECEXP (pattern, 0, i), store_p)));\n+      regno = REGNO (XEXP (XVECEXP (pattern, 0, i), store_p));\n+      if (automod_offset < 0)\n+\t{\n+\t  if (FP_REGNO_P (regno))\n+\t    mask |= 1 << (regno - FP0_REG);\n+\t  else\n+\t    mask |= 1 << (15 - (regno - D0_REG));\n+\t}\n+      else\n+\t{\n+\t  if (FP_REGNO_P (regno))\n+\t    mask |= 1 << (7 - (regno - FP0_REG));\n+\t  else\n+\t    mask |= 1 << (regno - D0_REG);\n+\t}\n+    }\n+  CC_STATUS_INIT;\n+\n+  if (automod_offset == 0)\n+    operands[0] = XEXP (XEXP (XVECEXP (pattern, 0, first), !store_p), 0);\n+  else if (automod_offset < 0)\n+    operands[0] = gen_rtx_PRE_DEC (Pmode, SET_DEST (XVECEXP (pattern, 0, 0)));\n+  else\n+    operands[0] = gen_rtx_POST_INC (Pmode, SET_DEST (XVECEXP (pattern, 0, 0)));\n+  operands[1] = GEN_INT (mask);\n+  if (FP_REGNO_P (REGNO (XEXP (XVECEXP (pattern, 0, first), store_p))))\n+    {\n+      if (store_p)\n+\treturn MOTOROLA ? \"fmovm %1,%a0\" : \"fmovem %1,%a0\";\n+      else\n+\treturn MOTOROLA ? \"fmovm %a0,%1\" : \"fmovem %a0,%1\";\n+    }\n+  else\n+    {\n+      if (store_p)\n+\treturn MOTOROLA ? \"movm.l %1,%a0\" : \"moveml %1,%a0\";\n+      else\n+\treturn MOTOROLA ? \"movm.l %a0,%1\" : \"moveml %a0,%1\";\n+    }\n+}\n+\n /* Return a REG that occurs in ADDR with coefficient 1.\n    ADDR can be effectively incremented by incrementing REG.  */\n \n@@ -3481,6 +3511,7 @@ floating_exact_log2 (rtx x)\n    '$' for the letter `s' in an op code, but only on the 68040.\n    '&' for the letter `d' in an op code, but only on the 68040.\n    '/' for register prefix needed by longlong.h.\n+   '?' for m68k_library_id_string\n \n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n@@ -3520,6 +3551,8 @@ print_operand (FILE *file, rtx op, int letter)\n     }\n   else if (letter == '/')\n     asm_fprintf (file, \"%R\");\n+  else if (letter == '?')\n+    asm_fprintf (file, m68k_library_id_string);\n   else if (letter == 'p')\n     {\n       output_addr_const (file, op);"}, {"sha": "c4b1e14842cd33f9ac8f03a94c9b6a47f257a990", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "patch": "@@ -987,6 +987,10 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n /* Before the prologue, the top of the frame is at 4(%sp).  */\n #define INCOMING_FRAME_SP_OFFSET 4\n \n+/* All registers are live on exit from an interrupt routine.  */\n+#define EPILOGUE_USES(REGNO) \\\n+  (reload_completed && m68k_interrupt_function_p (current_function_decl))\n+\n /* Describe how we implement __builtin_eh_return.  */\n #define EH_RETURN_DATA_REGNO(N) \\\n   ((N) < 2 ? (N) : INVALID_REGNUM)\n@@ -1123,6 +1127,7 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n    '$' for the letter `s' in an op code, but only on the 68040.\n    '&' for the letter `d' in an op code, but only on the 68040.\n    '/' for register prefix needed by longlong.h.\n+   '?' for m68k_library_id_string\n \n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n@@ -1133,7 +1138,7 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n   ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n    || (CODE) == '+' || (CODE) == '@' || (CODE) == '!'\t\t\t\\\n-   || (CODE) == '$' || (CODE) == '&' || (CODE) == '/')\n+   || (CODE) == '$' || (CODE) == '&' || (CODE) == '/' || (CODE) == '?')\n \n \n /* See m68k.c for the m68k specific codes.  */"}, {"sha": "4c0878a1df2becaad6be87420e2a7782a29fdc97", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 153, "deletions": 6, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=a40ed0f3103b04e249f2ad78ae36e328f2d6f1cd", "patch": "@@ -112,8 +112,9 @@\n ;; UNSPEC usage:\n \n (define_constants\n-  [(UNSPEC_SIN  1)\n-   (UNSPEC_COS  2)\n+  [(UNSPEC_SIN 1)\n+   (UNSPEC_COS 2)\n+   (UNSPEC_GOT 3)\n   ])\n \n ;; UNSPEC_VOLATILE usage:\n@@ -126,7 +127,10 @@\n (define_constants\n   [(D0_REG\t\t0)\n    (A0_REG\t\t8)\n+   (A1_REG\t\t9)\n+   (PIC_REG\t\t13)\n    (SP_REG\t\t15)\n+   (FP0_REG\t\t16)\n   ])\n \n (include \"predicates.md\")\n@@ -6756,15 +6760,158 @@\n   \"\"\n   \"nop\")\n \n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  m68k_expand_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  m68k_expand_epilogue ();\n+  DONE;\n+})\n+\n ;; Used for frameless functions which save no regs and allocate no locals.\n-(define_insn \"return\"\n+(define_expand \"return\"\n   [(return)]\n   \"m68k_use_return_insn ()\"\n+  \"\")\n+\n+(define_insn \"*return\"\n+  [(return)]\n+  \"\"\n {\n-  if (current_function_pops_args == 0)\n+  if (m68k_interrupt_function_p (current_function_decl))\n+    return \"rte\";\n+  else if (current_function_pops_args)\n+    {\n+      operands[0] = GEN_INT (current_function_pops_args);\n+      return \"rtd %0\";\n+    }\n+  else\n     return \"rts\";\n-  operands[0] = GEN_INT (current_function_pops_args);\n-  return \"rtd %0\";\n+})\n+\n+(define_insn \"*m68k_store_multiple\"\n+  [(match_parallel 0 \"\" [(match_operand 1 \"\")])]\n+  \"m68k_movem_pattern_p (operands[0], NULL, 0, true)\"\n+{\n+  return m68k_output_movem (operands, operands[0], 0, true);\n+})\n+\n+(define_insn \"*m68k_store_multiple_automod\"\n+  [(match_parallel 0 \"\"\n+     [(set (match_operand:SI 1 \"register_operand\" \"=a\")\n+\t   (plus:SI (match_operand:SI 2 \"register_operand\" \"1\")\n+\t\t    (match_operand:SI 3 \"const_int_operand\")))])]\n+  \"m68k_movem_pattern_p (operands[0], operands[1], INTVAL (operands[3]), true)\"\n+{\n+  return m68k_output_movem (operands, operands[0], INTVAL (operands[3]), true);\n+})\n+\n+(define_insn \"*m68k_load_multiple\"\n+  [(match_parallel 0 \"\" [(match_operand 1 \"\")])]\n+  \"m68k_movem_pattern_p (operands[0], NULL, 0, false)\"\n+{\n+  return m68k_output_movem (operands, operands[0], 0, false);\n+})\n+\n+(define_insn \"*m68k_load_multiple_automod\"\n+  [(match_parallel 0 \"\"\n+     [(set (match_operand:SI 1 \"register_operand\" \"=a\")\n+\t   (plus:SI (match_operand:SI 2 \"register_operand\" \"1\")\n+\t\t    (match_operand:SI 3 \"const_int_operand\")))])]\n+  \"m68k_movem_pattern_p (operands[0], operands[1],\n+\t\t\t INTVAL (operands[3]), false)\"\n+{\n+  return m68k_output_movem (operands, operands[0],\n+\t\t\t    INTVAL (operands[3]), false);\n+})\n+\n+(define_expand \"link\"\n+  [(parallel\n+       [(set (match_operand:SI 0 \"register_operand\")\n+\t     (plus:SI (reg:SI SP_REG) (const_int -4)))\n+\t(set (match_dup 2)\n+\t     (match_dup 0))\n+\t(set (reg:SI SP_REG)\n+\t     (plus:SI (reg:SI SP_REG)\n+\t\t      (match_operand:SI 1 \"const_int_operand\")))])]\n+  \"TARGET_68020 || INTVAL (operands[1]) >= -0x8004\"\n+{\n+  operands[2] = gen_frame_mem (SImode, plus_constant (stack_pointer_rtx, -4));\n+})\n+\n+(define_insn \"*link\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t(plus:SI (reg:SI SP_REG) (const_int -4)))\n+   (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))\n+\t(match_dup 0))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 1 \"const_int_operand\")))]\n+  \"TARGET_68020 || INTVAL (operands[1]) >= -0x8004\"\n+{\n+  operands[1] = GEN_INT (INTVAL (operands[1]) + 4);\n+  if (!MOTOROLA)\n+    return \"link %0,%1\";\n+  else if (INTVAL (operands[1]) >= -0x8000)\n+    return \"link.w %0,%1\";\n+  else\n+    return \"link.l %0,%1\";\n+})\n+\n+(define_expand \"unlink\"\n+  [(parallel\n+      [(set (match_operand:SI 0 \"register_operand\")\n+\t    (match_dup 1))\n+       (set (reg:SI SP_REG)\n+\t    (plus:SI (match_dup 0)\n+\t\t     (const_int 4)))])]\n+  \"\"\n+{\n+  operands[1] = gen_frame_mem (SImode, copy_rtx (operands[0]));\n+})\n+\n+(define_insn \"*unlink\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t(mem:SI (match_dup 0)))\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 4)))]\n+  \"\"\n+  \"unlk %0\")\n+\n+(define_insn \"load_got\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_GOT))]\n+  \"\"\n+{\n+  if (TARGET_ID_SHARED_LIBRARY)\n+    {\n+      operands[1] = gen_rtx_REG (Pmode, PIC_REG);\n+      return MOTOROLA ? \"move.l %?(%1),%0\" : \"movel %1@(%?), %0\";\n+    }\n+  else if (MOTOROLA)\n+    {\n+      if (TARGET_COLDFIRE)\n+\t/* Load the full 32-bit PC-relative offset of\n+\t   _GLOBAL_OFFSET_TABLE_ into the PIC register, then use it to\n+\t   calculate the absolute value.  The offset and \"lea\"\n+\t   operation word together occupy 6 bytes.  */\n+\treturn (\"move.l #_GLOBAL_OFFSET_TABLE_@GOTPC, %0\\n\\t\"\n+\t\t\"lea (-6, %%pc, %0), %0\");\n+      else\n+\treturn \"lea (%%pc, _GLOBAL_OFFSET_TABLE_@GOTPC), %0\";\n+    }\n+  else\n+    return (\"movel #_GLOBAL_OFFSET_TABLE_, %0\\n\\t\"\n+\t    \"lea %%pc@(0,%0:l),%0\");\n })\n \n (define_insn \"indirect_jump\""}]}