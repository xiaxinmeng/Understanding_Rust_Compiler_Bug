{"sha": "eab5c70a03b09cdff6668c76fde6337e486dcdb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFiNWM3MGEwM2IwOWNkZmY2NjY4Yzc2ZmRlNjMzN2U0ODZkY2RiNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-03-14T18:36:18Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-03-14T18:36:18Z"}, "message": "Add cselib; use it in loop and reload_cse_regs\n\nFrom-SVN: r32538", "tree": {"sha": "096b43f896f53dc9a7da616fc0b4de3800ddcee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/096b43f896f53dc9a7da616fc0b4de3800ddcee1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eab5c70a03b09cdff6668c76fde6337e486dcdb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab5c70a03b09cdff6668c76fde6337e486dcdb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab5c70a03b09cdff6668c76fde6337e486dcdb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab5c70a03b09cdff6668c76fde6337e486dcdb4/comments", "author": null, "committer": null, "parents": [{"sha": "4bdf01f2105ab88bb5ce4ea1bfeae1675482a9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdf01f2105ab88bb5ce4ea1bfeae1675482a9b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdf01f2105ab88bb5ce4ea1bfeae1675482a9b0"}], "stats": {"total": 2423, "additions": 1650, "deletions": 773}, "files": [{"sha": "e9e1852cc59a91c9bb21a99bc6f40f0a3ae442ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -1,3 +1,67 @@\n+2000-03-14  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* cselib.h: New file.\n+\t* alias.c: Include \"cselib.h\".\n+\t(fixed_scalar_and_varying_struct_p): Accept the addresses of the\n+\tMEMs as two new arguments.\n+\t(get_addr): New static function.\n+\t(find_base_term): Handle VALUEs.\n+\t(memrefs_conflict_p): Likewise.\n+\t(true_dependence): Call get_addr on the addresses.\n+\tCall fixed_scalar_and_varying_struct_p with addresses that have been\n+\tpassed through get_addr and canon_rtx.\n+\t(write_dependence_p): Move DIFFERENT_ALIAS_SETS_P test for consistency\n+\twith true_dependence.\n+\tCall get_addr on the addresses; don't call canon_rtx on the MEMs.\n+\t* loop.c: Include \"cselib.h\".\n+\t(load_mems): Process extended basic block that enters the loop with\n+\tcselib.  Use that information to change initialization of the shadow\n+\tregister so that a constant equivalence is seen by later passes.\n+\t* reload1.c: Include \"cselib.h\".\n+\t(reload_cse_invalidate_regno): Delete function.\n+\t(reload_cse_mem_conflict_p): Likewise.\n+\t(reload_cse_invalidate_mem): Likewise.\n+\t(reload_cse_invalidate_rtx): Likewise.\n+\t(reload_cse_regno_equal_p): Likewise.\n+\t(reload_cse_check_clobber): Likewise.\n+\t(reload_cse_record_set): Likewise.\n+\t(reg_values): Delete static variable.\n+\t(invalidate_regno_rtx): Likewise.\n+\t(reload_cse_delete_noop_set): New static function.\n+\t(reload_cse_simplify): New static function, broken out of\n+\treload_cse_regs_1.\n+\t(reload_cse_noop_set_p): Delete unused argument INSN.\n+\tJust call rtx_equal_for_cselib_p on set source and destination.\n+\t(reload_cse_regs_1): Break out some code into reload_cse_simplify and\n+\treload_cse_delete_noop_set.  Delete code to keep track of values; use\n+\tcselib functions instead.  Delete code to push/pop obstacks.\n+\t(reload_cse_simplify_set): Use cselib to find equivalent values.\n+\tDelete code to push/pop obstacks.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t* rtl.def (VALUE): New rtx code.\n+\t* rtl.h (union rtunion_def): New elt rt_cselib.\n+\t(X0CSELIB, CSELIB_VAL_PTR): New macros.\n+\t* simplify_rtx.c: Include \"ggc.h\", \"obstack.h\", \"cselib.h\".\n+\t(new_elt_list, new_elt_loc_list, unchain_one_value, clear_table,\n+\tunchain_one_elt_list, unchain_one_elt_loc_list, check_useless_values,\n+\tdiscard_useless_locs, discard_useless_values, entry_and_rtx_equal_p,\n+\thash_rtx, new_cselib_val, add_mem_for_addr, get_value_hash,\n+\tcselib_lookup_mem, cselib_subst_to_values, cselib_invalidate_regno,\n+\tcselib_mem_conflict_p, cselib_invalidate_mem, cselib_invalidate_rtx,\n+\tcselib_record_set, cselib_record_sets): New static functions.\n+\t(cselib_lookup, cselib_update_varray_sizes, cselib_init,\n+\tcselib_finish, cselib_process_insn, rtx_equal_for_cselib_p,\n+\treferences_value_p): New functions.\n+\t(MAX_USELESS_VALUES, REG_VALUES): New macros.\n+\t(table, cselib_current_insn, next_unknown_value, cselib_nregs,\n+\tn_useless_values, reg_values, callmem, cselib_obstack,\n+\tcselib_startobj, empty_vals, empty_elt_lists, empty_elt_loc_lists):\n+\tNew static variables.\n+\t* varray.h (union varray_data_tag): New elt te.\n+\t(VARRAY_ELT_LIST_INIT, VARRAY_ELT_LIST): New macros.\n+\t* Makefile.in (reload1.o, loop.o, simplify-rtx.o, alias.o): Update\n+\tdependencies.\n+\n 2000-03-14  Nick Clifton  <nickc@cygnus.com>\n \n \t* gcc.c (do_spec_1): Catch the case where %* is used in a"}, {"sha": "356ef9b885a2226c8660568ae5ce8fd6cf0df661", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -1556,7 +1556,7 @@ jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n-   output.h function.h \n+   output.h function.h cselib.h ggc.h $(srcdir)/../include/obstack.h\n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h ggc.h\n gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n@@ -1574,7 +1574,7 @@ profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    ggc.h\n loop.o : loop.c $(CONFIG_H) system.h $(RTL_H) flags.h $(LOOP_H) insn-config.h \\\n    insn-flags.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) real.h \\\n-   $(BASIC_BLOCK_H) function.h toplev.h varray.h except.h\n+   $(BASIC_BLOCK_H) function.h toplev.h varray.h except.h cselib.h\n unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    $(INTEGRATE_H) $(REGS_H) $(RECOG_H) flags.h $(EXPR_H) $(LOOP_H) toplev.h \\\n    varray.h \n@@ -1600,15 +1600,16 @@ reload.o : reload.c $(CONFIG_H) system.h $(RTL_H) flags.h output.h $(EXPR_H) \\\n    function.h real.h toplev.h\n reload1.o : reload1.c $(CONFIG_H) system.h $(RTL_H) real.h flags.h $(EXPR_H) \\\n    reload.h $(REGS_H) hard-reg-set.h insn-config.h insn-flags.h insn-codes.h \\\n-   $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h\n+   $(BASIC_BLOCK_H) $(RECOG_H) output.h function.h toplev.h cselib.h\n caller-save.o : caller-save.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n    $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) function.h \\\n    $(RECOG_H) reload.h $(EXPR_H) toplev.h\n reorg.o : reorg.c $(CONFIG_H) system.h $(RTL_H) conditions.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h insn-attr.h insn-flags.h \\\n    $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h\n alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n-   $(REGS_H) toplev.h output.h $(EXPR_H) insn-flags.h ggc.h function.h\n+   $(REGS_H) toplev.h output.h $(EXPR_H) insn-flags.h ggc.h function.h \\\n+   cselib.h\n regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n    $(RECOG_H) output.h reload.h $(REGS_H) hard-reg-set.h flags.h function.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h"}, {"sha": "ac09d798a279b229c0448a3032226bfab4c27cdd", "filename": "gcc/alias.c", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"cselib.h\"\n #include \"splay-tree.h\"\n #include \"ggc.h\"\n \n@@ -81,6 +82,7 @@ typedef struct alias_set_entry\n static rtx canon_rtx\t\t\tPARAMS ((rtx));\n static int rtx_equal_for_memref_p\tPARAMS ((rtx, rtx));\n static rtx find_symbolic_term\t\tPARAMS ((rtx));\n+static rtx get_addr\t\t\tPARAMS ((rtx));\n static int memrefs_conflict_p\t\tPARAMS ((int, rtx, int, rtx,\n \t\t\t\t\t\t HOST_WIDE_INT));\n static void record_set\t\t\tPARAMS ((rtx, rtx, void *));\n@@ -91,7 +93,8 @@ static rtx find_base_value\t\tPARAMS ((rtx));\n static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n static alias_set_entry get_alias_set_entry PARAMS ((int));\n-static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, int (*)(rtx)));\n+static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n+\t\t\t\t\t\t      int (*)(rtx)));\n static int aliases_everything_p         PARAMS ((rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n static int nonlocal_reference_p         PARAMS ((rtx));\n@@ -737,6 +740,9 @@ static rtx\n find_base_term (x)\n      register rtx x;\n {\n+  cselib_val *val;\n+  struct elt_loc_list *l;\n+\n   switch (GET_CODE (x))\n     {\n     case REG:\n@@ -751,6 +757,13 @@ find_base_term (x)\n     case POST_DEC:\n       return find_base_term (XEXP (x, 0));\n \n+    case VALUE:\n+      val = CSELIB_VAL_PTR (x);\n+      for (l = val->locs; l; l = l->next)\n+\tif ((x = find_base_term (l->loc)) != 0)\n+\t  return x;\n+      return 0;\n+\n     case CONST:\n       x = XEXP (x, 0);\n       if (GET_CODE (x) != PLUS && GET_CODE (x) != MINUS)\n@@ -905,6 +918,30 @@ base_alias_check (x, y, x_mode, y_mode)\n   return ! (GET_MODE (x_base) == VOIDmode && GET_MODE (y_base) == VOIDmode);\n }\n \n+/* Convert the address X into something we can use.  This is done by returning\n+   it unchanged unless it is a value; in the latter case we call cselib to get\n+   a more useful rtx.  */\n+static rtx\n+get_addr (x)\n+     rtx x;\n+{\n+  cselib_val *v;\n+  struct elt_loc_list *l;\n+\n+  if (GET_CODE (x) != VALUE)\n+    return x;\n+  v = CSELIB_VAL_PTR (x);\n+  for (l = v->locs; l; l = l->next)\n+    if (CONSTANT_P (l->loc))\n+      return l->loc;\n+  for (l = v->locs; l; l = l->next)\n+    if (GET_CODE (l->loc) != REG && GET_CODE (l->loc) != MEM)\n+      return l->loc;\n+  if (v->locs)\n+    return v->locs->loc;\n+  return x;\n+}\n+\n /*  Return the address of the (N_REFS + 1)th memory reference to ADDR\n     where SIZE is the size in bytes of the memory reference.  If ADDR\n     is not modified by the memory reference then ADDR is returned.  */\n@@ -961,13 +998,16 @@ addr_side_effect_eval (addr, size, n_refs)\n    Nice to notice that varying addresses cannot conflict with fp if no\n    local variables had their addresses taken, but that's too hard now.  */\n \n-\n static int\n memrefs_conflict_p (xsize, x, ysize, y, c)\n      register rtx x, y;\n      int xsize, ysize;\n      HOST_WIDE_INT c;\n {\n+  if (GET_CODE (x) == VALUE)\n+    x = get_addr (x);\n+  if (GET_CODE (y) == VALUE)\n+    y = get_addr (y);\n   if (GET_CODE (x) == HIGH)\n     x = XEXP (x, 0);\n   else if (GET_CODE (x) == LO_SUM)\n@@ -1185,17 +1225,15 @@ read_dependence (mem, x)\n    MEM2 if vice versa.  Otherwise, returns NULL_RTX.  If a non-NULL\n    value is returned MEM1 and MEM2 can never alias.  VARIES_P is used\n    to decide whether or not an address may vary; it should return\n-   nonzero whenever variation is possible.  */\n-\n+   nonzero whenever variation is possible.\n+   MEM1_ADDR and MEM2_ADDR are the addresses of MEM1 and MEM2.  */\n+  \n static rtx\n-fixed_scalar_and_varying_struct_p (mem1, mem2, varies_p)\n-     rtx mem1;\n-     rtx mem2;\n+fixed_scalar_and_varying_struct_p (mem1, mem2, mem1_addr, mem2_addr, varies_p)\n+     rtx mem1, mem2;\n+     rtx mem1_addr, mem2_addr;\n      int (*varies_p) PARAMS ((rtx));\n-{\n-  rtx mem1_addr = XEXP (mem1, 0);\n-  rtx mem2_addr = XEXP (mem2, 0);\n-  \n+{  \n   if (MEM_SCALAR_P (mem1) && MEM_IN_STRUCT_P (mem2) \n       && !varies_p (mem1_addr) && varies_p (mem2_addr))\n     /* MEM1 is a scalar at a fixed address; MEM2 is a struct at a\n@@ -1260,11 +1298,14 @@ true_dependence (mem, mem_mode, x, varies)\n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n-  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x), mem_mode))\n+  x_addr = get_addr (XEXP (x, 0));\n+  mem_addr = get_addr (XEXP (mem, 0));\n+\n+  if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))\n     return 0;\n \n-  x_addr = canon_rtx (XEXP (x, 0));\n-  mem_addr = canon_rtx (XEXP (mem, 0));\n+  x_addr = canon_rtx (x_addr);\n+  mem_addr = canon_rtx (mem_addr);\n \n   if (! memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n \t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n@@ -1283,7 +1324,8 @@ true_dependence (mem, mem_mode, x, varies)\n   if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n     return 1;\n \n-  return !fixed_scalar_and_varying_struct_p (mem, x, varies);\n+  return ! fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n+\t\t\t\t\t      varies);\n }\n \n /* Returns non-zero if a write to X might alias a previous read from\n@@ -1301,32 +1343,33 @@ write_dependence_p (mem, x, writep)\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n+  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+    return 0;\n+\n   /* If MEM is an unchanging read, then it can't possibly conflict with\n      the store to X, because there is at most one store to MEM, and it must\n      have occurred somewhere before MEM.  */\n   if (!writep && RTX_UNCHANGING_P (mem))\n     return 0;\n \n-  if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0), GET_MODE (x),\n-\t\t\t  GET_MODE (mem)))\n-    return 0;\n-\n-  x = canon_rtx (x);\n-  mem = canon_rtx (mem);\n+  x_addr = get_addr (XEXP (x, 0));\n+  mem_addr = get_addr (XEXP (mem, 0));\n \n-  if (DIFFERENT_ALIAS_SETS_P (x, mem))\n+  if (! base_alias_check (x_addr, mem_addr, GET_MODE (x),\n+\t\t\t  GET_MODE (mem)))\n     return 0;\n \n-  x_addr = XEXP (x, 0);\n-  mem_addr = XEXP (mem, 0);\n+  x_addr = canon_rtx (x_addr);\n+  mem_addr = canon_rtx (mem_addr);\n \n   if (!memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n \t\t\t   SIZE_FOR_MODE (x), x_addr, 0))\n     return 0;\n \n   fixed_scalar \n-    = fixed_scalar_and_varying_struct_p (mem, x, rtx_addr_varies_p);\n-  \n+    = fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n+\t\t\t\t\t rtx_addr_varies_p);\n+\n   return (!(fixed_scalar == mem && !aliases_everything_p (x))\n \t  && !(fixed_scalar == x && !aliases_everything_p (mem)));\n }"}, {"sha": "879b9c6c3d5d2b77ff55c26381944aadedaa68d0", "filename": "gcc/cselib.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -0,0 +1,66 @@\n+/* Common subexpression elimination for GNU compiler.\n+   Copyright (C) 1987, 88, 89, 92-7, 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Describe a value.  */\n+typedef struct cselib_val_struct\n+{\n+  /* The hash value.  */\n+  unsigned int value;\n+  union\n+  {\n+    /* A VALUE rtx that points back to this structure.  */\n+    rtx val_rtx;\n+    /* Used to keep a list of free cselib_val structures.  */\n+    struct cselib_val_struct *next_free;\n+  } u;\n+\n+  /* All rtl expressions that hold this value at the current time during a\n+     scan.  */\n+  struct elt_loc_list *locs;\n+  /* If this value is used as an address, points to a list of values that\n+     use it as an address in a MEM.  */\n+  struct elt_list *addr_list;\n+} cselib_val;\n+\n+/* A list of rtl expressions that hold the same value.  */\n+struct elt_loc_list\n+{\n+  /* Next element in the list.  */\n+  struct elt_loc_list *next;\n+  /* An rtl expression that holds the value.  */\n+  rtx loc;\n+  /* The insn that made the equivalence.  */\n+  rtx setting_insn;\n+};\n+\n+/* A list of cselib_val structures.  */\n+struct elt_list\n+{\n+  struct elt_list *next;\n+  cselib_val *elt;\n+};\n+\n+extern cselib_val *cselib_lookup\tPARAMS ((rtx, enum machine_mode, int));\n+extern void cselib_update_varray_sizes\tPARAMS ((void));\n+extern void cselib_init\t\t\tPARAMS ((void));\n+extern void cselib_finish\t\tPARAMS ((void));\n+extern void cselib_process_insn\t\tPARAMS ((rtx));\n+extern int rtx_equal_for_cselib_p\tPARAMS ((rtx, rtx));\n+extern int references_value_p\t\tPARAMS ((rtx, int));"}, {"sha": "f7a12ded4cc2b05547e98c6eed6b88c38099b17d", "filename": "gcc/loop.c", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -51,6 +51,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"real.h\"\n #include \"loop.h\"\n+#include \"cselib.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n \n@@ -9773,6 +9774,19 @@ load_mems (loop)\n   if (loop_mems_idx == 0)\n     return;\n \n+  /* Find start of the extended basic block that enters the loop.  */\n+  for (p = loop->start;\n+       PREV_INSN (p) && GET_CODE (p) != CODE_LABEL;\n+       p = PREV_INSN (p))\n+    ;\n+\n+  cselib_init ();\n+\n+  /* Build table of mems that get set to constant values before the\n+     loop.  */\n+  for (; p != loop->start; p = NEXT_INSN (p))\n+    cselib_process_insn (p);\n+\n   /* Check to see if it's possible that some instructions in the\n      loop are never executed.  */\n   for (p = next_insn_in_loop (loop, loop->scan_start); \n@@ -9924,13 +9938,49 @@ load_mems (loop)\n \tloop_mems[i].optimize = 0;\n       else\n \t{\n-\t  int j;\n-\t  rtx set;\n-\n \t  /* Load the memory immediately before LOOP->START, which is\n \t     the NOTE_LOOP_BEG.  */\n-\t  set = gen_move_insn (reg, mem);\n-\t  emit_insn_before (set, loop->start);\n+\t  cselib_val *e = cselib_lookup (mem, VOIDmode, 0);\n+\t  rtx set;\n+\t  rtx best = mem;\n+\t  int j;\n+\t  struct elt_loc_list *const_equiv = 0;\n+\n+\t  if (e)\n+\t    {\n+\t      struct elt_loc_list *equiv;\n+\t      struct elt_loc_list *best_equiv = 0;\n+\t      for (equiv = e->locs; equiv; equiv = equiv->next)\n+\t\t{\n+\t\t  if (CONSTANT_P (equiv->loc))\n+\t\t    const_equiv = equiv;\n+\t\t  else if (GET_CODE (equiv->loc) == REG)\n+\t\t    best_equiv = equiv;\n+\t\t}\n+\t      /* Use the constant equivalence if that is cheap enough.  */\n+\t      if (! best_equiv)\n+\t\tbest_equiv = const_equiv;\n+\t      else if (const_equiv\n+\t\t       && (rtx_cost (const_equiv->loc, SET)\n+\t\t\t   <= rtx_cost (best_equiv->loc, SET)))\n+\t\t{\n+\t\t  best_equiv = const_equiv;\n+\t\t  const_equiv = 0;\n+\t\t}\n+\n+\t      /* If best_equiv is nonzero, we know that MEM is set to a\n+\t\t constant or register before the loop.  We will use this\n+\t\t knowledge to initialize the shadow register with that\n+\t\t constant or reg rather than by loading from MEM.  */\n+\t      if (best_equiv)\n+\t\tbest = copy_rtx (best_equiv->loc);\n+\t    }\n+\t  set = gen_move_insn (reg, best);\n+\t  set = emit_insn_before (set, loop->start);\n+\t  if (const_equiv)\n+\t    REG_NOTES (set) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t\t copy_rtx (const_equiv->loc),\n+\t\t\t\t\t\t REG_NOTES (set));\n \n \t  if (written)\n \t    {\n@@ -9992,6 +10042,8 @@ load_mems (loop)\n \t    JUMP_LABEL (p) = label;\n \t}\n     }\n+\n+  cselib_finish ();\n }\n \n /* For communication between note_reg_stored and its caller.  */"}, {"sha": "37670e8cc8a87da6a6c86fef248d5570fd0cf3ba", "filename": "gcc/reload1.c", "status": "modified", "additions": 146, "deletions": 738, "changes": 884, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -39,6 +39,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"reload.h\"\n #include \"recog.h\"\n #include \"output.h\"\n+#include \"cselib.h\"\n #include \"real.h\"\n #include \"toplev.h\"\n \n@@ -430,16 +431,9 @@ static void delete_address_reloads_1\tPARAMS ((rtx, rtx, rtx));\n static rtx inc_for_reload\t\tPARAMS ((rtx, rtx, rtx, int));\n static int constraint_accepts_reg_p\tPARAMS ((const char *, rtx));\n static void reload_cse_regs_1\t\tPARAMS ((rtx));\n-static void reload_cse_invalidate_regno\tPARAMS ((int, enum machine_mode, int));\n-static int reload_cse_mem_conflict_p\tPARAMS ((rtx, rtx));\n-static void reload_cse_invalidate_mem\tPARAMS ((rtx));\n-static void reload_cse_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n-static int reload_cse_regno_equal_p\tPARAMS ((int, rtx, enum machine_mode));\n-static int reload_cse_noop_set_p\tPARAMS ((rtx, rtx));\n+static int reload_cse_noop_set_p\tPARAMS ((rtx));\n static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n static int reload_cse_simplify_operands\tPARAMS ((rtx));\n-static void reload_cse_check_clobber\tPARAMS ((rtx, rtx, void *));\n-static void reload_cse_record_set\tPARAMS ((rtx, rtx));\n static void reload_combine PARAMS ((void));\n static void reload_combine_note_use PARAMS ((rtx *, rtx));\n static void reload_combine_note_store PARAMS ((rtx, rtx, void *));\n@@ -7842,229 +7836,110 @@ count_occurrences (x, find)\n   return count;\n }\n \f\n-/* This array holds values which are equivalent to a hard register\n-   during reload_cse_regs.  Each array element is an EXPR_LIST of\n-   values.  Each time a hard register is set, we set the corresponding\n-   array element to the value.  Each time a hard register is copied\n-   into memory, we add the memory location to the corresponding array\n-   element.  We don't store values or memory addresses with side\n-   effects in this array.\n-\n-   If the value is a CONST_INT, then the mode of the containing\n-   EXPR_LIST is the mode in which that CONST_INT was referenced.\n-\n-   We sometimes clobber a specific entry in a list.  In that case, we\n-   just set XEXP (list-entry, 0) to 0.  */\n-\n-static rtx *reg_values;\n-\n-/* This is a preallocated REG rtx which we use as a temporary in\n-   reload_cse_invalidate_regno, so that we don't need to allocate a\n-   new one each time through a loop in that function.  */\n-\n-static rtx invalidate_regno_rtx;\n-\n-/* Invalidate any entries in reg_values which depend on REGNO,\n-   including those for REGNO itself.  This is called if REGNO is\n-   changing.  If CLOBBER is true, then always forget anything we\n-   currently know about REGNO.  MODE is the mode of the assignment to\n-   REGNO, which is used to determine how many hard registers are being\n-   changed.  If MODE is VOIDmode, then only REGNO is being changed;\n-   this is used when invalidating call clobbered registers across a\n-   call.  */\n-\n+/* INSN is a no-op; delete it.\n+   If this sets the return value of the function, we must keep a USE around,\n+   in case this is in a different basic block than the final USE.  Otherwise,\n+   we could loose important register lifeness information on\n+   SMALL_REGISTER_CLASSES machines, where return registers might be used as\n+   spills:  subsequent passes assume that spill registers are dead at the end\n+   of a basic block.\n+   VALUE must be the return value in such a case, NULL otherwise.  */\n static void\n-reload_cse_invalidate_regno (regno, mode, clobber)\n-     int regno;\n-     enum machine_mode mode;\n-     int clobber;\n+reload_cse_delete_noop_set (insn, value)\n+     rtx insn, value;\n {\n-  int endregno;\n-  register int i;\n-\n-  /* Our callers don't always go through true_regnum; we may see a\n-     pseudo-register here from a CLOBBER or the like.  We probably\n-     won't ever see a pseudo-register that has a real register number,\n-     for we check anyhow for safety.  */\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    regno = reg_renumber[regno];\n-  if (regno < 0)\n-    return;\n-\n-  if (mode == VOIDmode)\n-    endregno = regno + 1;\n-  else\n-    endregno = regno + HARD_REGNO_NREGS (regno, mode);\n-\n-  if (clobber)\n-    for (i = regno; i < endregno; i++)\n-      reg_values[i] = 0;\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+  if (value)\n     {\n-      rtx x;\n-\n-      for (x = reg_values[i]; x; x = XEXP (x, 1))\n-\t{\n-\t  if (XEXP (x, 0) != 0\n-\t      && refers_to_regno_p (regno, endregno, XEXP (x, 0), NULL_PTR))\n-\t    {\n-\t      /* If this is the only entry on the list, clear\n-\t\t reg_values[i].  Otherwise, just clear this entry on\n-\t\t the list.  */\n-\t      if (XEXP (x, 1) == 0 && x == reg_values[i])\n-\t\t{\n-\t\t  reg_values[i] = 0;\n-\t\t  break;\n-\t\t}\n-\t      XEXP (x, 0) = 0;\n-\t    }\n-\t}\n+      PATTERN (insn) = gen_rtx_USE (VOIDmode, value);\n+      INSN_CODE (insn) = -1;\n+      REG_NOTES (insn) = NULL_RTX;\n     }\n-\n-  /* We must look at earlier registers, in case REGNO is part of a\n-     multi word value but is not the first register.  If an earlier\n-     register has a value in a mode which overlaps REGNO, then we must\n-     invalidate that earlier register.  Note that we do not need to\n-     check REGNO or later registers (we must not check REGNO itself,\n-     because we would incorrectly conclude that there was a conflict).  */\n-\n-  for (i = 0; i < regno; i++)\n+  else\n     {\n-      rtx x;\n-\n-      for (x = reg_values[i]; x; x = XEXP (x, 1))\n-\t{\n-\t  if (XEXP (x, 0) != 0)\n-\t    {\n-\t      PUT_MODE (invalidate_regno_rtx, GET_MODE (x));\n-\t      REGNO (invalidate_regno_rtx) = i;\n-\t      if (refers_to_regno_p (regno, endregno, invalidate_regno_rtx,\n-\t\t\t\t     NULL_PTR))\n-\t\t{\n-\t\t  reload_cse_invalidate_regno (i, VOIDmode, 1);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (insn) = 0;\n     }\n }\n \n-/* The memory at address MEM_BASE is being changed.\n-   Return whether this change will invalidate VAL.  */\n-\n+/* See whether a single set SET is a noop.  */\n static int\n-reload_cse_mem_conflict_p (mem_base, val)\n-     rtx mem_base;\n-     rtx val;\n+reload_cse_noop_set_p (set)\n+     rtx set;\n {\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i;\n-\n-  code = GET_CODE (val);\n-  switch (code)\n-    {\n-      /* Get rid of a few simple cases quickly. */\n-    case REG:\n-    case PC:\n-    case CC0:\n-    case SCRATCH:\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 0;\n-\n-    case MEM:\n-      if (GET_MODE (mem_base) == BLKmode\n-\t  || GET_MODE (val) == BLKmode)\n-\treturn 1;\n-      if (anti_dependence (val, mem_base))\n-\treturn 1;\n-      /* The address may contain nested MEMs.  */\n-      break;\n-\n-    default:\n-      break;\n-    }\n+  return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));\n+}\n \n-  fmt = GET_RTX_FORMAT (code);\n+/* Try to simplify INSN.  */\n+static void\n+reload_cse_simplify (insn)\n+     rtx insn;\n+{\n+  rtx body = PATTERN (insn);\n \n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+  if (GET_CODE (body) == SET)\n     {\n-      if (fmt[i] == 'e')\n+      int count = 0;\n+      if (reload_cse_noop_set_p (body))\n \t{\n-\t  if (reload_cse_mem_conflict_p (mem_base, XEXP (val, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\n-\t  for (j = 0; j < XVECLEN (val, i); j++)\n-\t    if (reload_cse_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n-\t      return 1;\n+\t  rtx value = SET_DEST (body);\n+\t  if (! REG_FUNCTION_VALUE_P (SET_DEST (body)))\n+\t    value = 0;\n+\t  reload_cse_delete_noop_set (insn, value);\n+\t  return;\n \t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Invalidate any entries in reg_values which are changed because of a\n-   store to MEM_RTX.  If this is called because of a non-const call\n-   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n \n-static void\n-reload_cse_invalidate_mem (mem_rtx)\n-     rtx mem_rtx;\n-{\n-  register int i;\n+      /* It's not a no-op, but we can try to simplify it.  */\n+      count += reload_cse_simplify_set (body, insn);\n \n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (count > 0)\n+\tapply_change_group ();\n+      else\n+\treload_cse_simplify_operands (insn);\n+    }\n+  else if (GET_CODE (body) == PARALLEL)\n     {\n-      rtx x;\n+      int i;\n+      int count = 0;\n+      rtx value = NULL_RTX;\n \n-      for (x = reg_values[i]; x; x = XEXP (x, 1))\n+      /* If every action in a PARALLEL is a noop, we can delete\n+\t the entire PARALLEL.  */\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t{\n-\t  if (XEXP (x, 0) != 0\n-\t      && reload_cse_mem_conflict_p (mem_rtx, XEXP (x, 0)))\n+\t  rtx part = XVECEXP (body, 0, i);\n+\t  if (GET_CODE (part) == SET)\n \t    {\n-\t      /* If this is the only entry on the list, clear\n-\t\t reg_values[i].  Otherwise, just clear this entry on\n-\t\t the list.  */\n-\t      if (XEXP (x, 1) == 0 && x == reg_values[i])\n+\t      if (! reload_cse_noop_set_p (part))\n+\t\tbreak;\n+\t      if (REG_FUNCTION_VALUE_P (SET_DEST (part)))\n \t\t{\n-\t\t  reg_values[i] = 0;\n-\t\t  break;\n+\t\t  if (value)\n+\t\t    break;\n+\t\t  value = SET_DEST (part);\n \t\t}\n-\t      XEXP (x, 0) = 0;\n \t    }\n+\t  else if (GET_CODE (part) != CLOBBER)\n+\t    break;\n \t}\n-    }\n-}\n \n-/* Invalidate DEST, which is being assigned to or clobbered.  The\n-   second parameter exists so that this function can be passed to\n-   note_stores; it is ignored.  */\n+      if (i < 0)\n+\t{\n+\t  reload_cse_delete_noop_set (insn, value);\n+\t  /* We're done with this insn.  */\n+\t  return;\n+\t}\n \n-static void\n-reload_cse_invalidate_rtx (dest, ignore, data)\n-     rtx dest;\n-     rtx ignore ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  while (GET_CODE (dest) == STRICT_LOW_PART\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n-\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SUBREG)\n-    dest = XEXP (dest, 0);\n-\n-  if (GET_CODE (dest) == REG)\n-    reload_cse_invalidate_regno (REGNO (dest), GET_MODE (dest), 1);\n-  else if (GET_CODE (dest) == MEM)\n-    reload_cse_invalidate_mem (dest);\n+      /* It's not a no-op, but we can try to simplify it.  */\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\tif (GET_CODE (XVECEXP (body, 0, i)) == SET)\n+\t  count += reload_cse_simplify_set (XVECEXP (body, 0, i), insn);\n+\n+      if (count > 0)\n+\tapply_change_group ();\n+      else\n+\treload_cse_simplify_operands (insn);\n+    }\n }\n \n /* Do a very simple CSE pass over the hard registers.\n@@ -8088,223 +7963,22 @@ static void\n reload_cse_regs_1 (first)\n      rtx first;\n {\n-  char *firstobj;\n-  rtx callmem;\n-  register int i;\n   rtx insn;\n \n+  cselib_init ();  \n   init_alias_analysis ();\n \n-  reg_values = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n-  bzero ((char *)reg_values, FIRST_PSEUDO_REGISTER * sizeof (rtx));\n-\n-  /* Create our EXPR_LIST structures on reload_obstack, so that we can\n-     free them when we are done.  */\n-  push_obstacks (&reload_obstack, &reload_obstack);\n-  firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n-\n-  /* We pass this to reload_cse_invalidate_mem to invalidate all of\n-     memory for a non-const call instruction.  */\n-  callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n-\n-  /* This is used in reload_cse_invalidate_regno to avoid consing a\n-     new REG in a loop in that function.  */\n-  invalidate_regno_rtx = gen_rtx_REG (VOIDmode, 0);\n-\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n-      rtx body;\n-\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\t{\n-\t  /* Forget all the register values at a code label.  We don't\n-\t     try to do anything clever around jumps.  */\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    reg_values[i] = 0;\n-\n-\t  continue;\n-\t}\n-\n-#ifdef NON_SAVING_SETJMP\n-      if (NON_SAVING_SETJMP && GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n-\t{\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    reg_values[i] = 0;\n-\n-\t  continue;\n-\t}\n-#endif\n-\n-      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\tcontinue;\n-\n-      /* If this is a call instruction, forget anything stored in a\n-\t call clobbered register, or, if this is not a const call, in\n-\t memory.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (call_used_regs[i])\n-\t      reload_cse_invalidate_regno (i, VOIDmode, 1);\n-\n-\t  if (! CONST_CALL_P (insn))\n-\t    reload_cse_invalidate_mem (callmem);\n-\t}\n-\n-\n-      /* Forget all the register values at a volatile asm.  */\n-      if (GET_CODE (insn) == INSN\n-\t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n-\t  && MEM_VOLATILE_P (PATTERN (insn)))\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  reg_values[i] = 0;\n-\n-      body = PATTERN (insn);\n-      if (GET_CODE (body) == SET)\n-\t{\n-\t  int count = 0;\n-\t  if (reload_cse_noop_set_p (body, insn))\n-\t    {\n-\t      /* If this sets the return value of the function, we must keep\n-\t\t a USE around, in case this is in a different basic block\n-\t\t than the final USE.  Otherwise, we could loose important\n-\t\t register lifeness information on SMALL_REGISTER_CLASSES\n-\t\t machines, where return registers might be used as spills:\n-\t\t subsequent passes assume that spill registers are dead at\n-\t\t the end of a basic block.  */\n-\t      if (REG_FUNCTION_VALUE_P (SET_DEST (body)))\n-\t\t{\n-\t\t  pop_obstacks ();\n-\t\t  PATTERN (insn) = gen_rtx_USE (VOIDmode, SET_DEST (body));\n-\t\t  INSN_CODE (insn) = -1;\n-\t\t  REG_NOTES (insn) = NULL_RTX;\n-\t\t  push_obstacks (&reload_obstack, &reload_obstack);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t}\n-\n-\t      /* We're done with this insn.  */\n-\t      continue;\n-\t    }\n-\n-\t  /* It's not a no-op, but we can try to simplify it.  */\n-\t  count += reload_cse_simplify_set (body, insn);\n-\n-\t  if (count > 0)\n-\t    apply_change_group ();\n-\t  else\n-\t    reload_cse_simplify_operands (insn);\n-\n-\t  reload_cse_record_set (body, body);\n-\t}\n-      else if (GET_CODE (body) == PARALLEL)\n-\t{\n-\t  int count = 0;\n-\t  rtx value = NULL_RTX;\n-\n-\t  /* If every action in a PARALLEL is a noop, we can delete\n-\t     the entire PARALLEL.  */\n-\t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t    {\n-\t      rtx part = XVECEXP (body, 0, i);\n-\t      if (GET_CODE (part) == SET)\n-\t\t{\n-\t\t  if (! reload_cse_noop_set_p (part, insn))\n-\t\t    break;\n-\t\t  if (REG_FUNCTION_VALUE_P (SET_DEST (part)))\n-\t\t    {\n-\t\t      if (value)\n-\t\t\tbreak;\n-\t\t      value = SET_DEST (part);\n-\t\t    }\n-\t\t}\n-\t      else if (GET_CODE (part) != CLOBBER)\n-\t\tbreak;\n-\t    }\n-\t  if (i < 0)\n-\t    {\n-\t      if (value)\n-\t\t{\n-\t\t  pop_obstacks ();\n-\t\t  PATTERN (insn) = gen_rtx_USE (VOIDmode, value);\n-\t\t  INSN_CODE (insn) = -1;\n-\t\t  REG_NOTES (insn) = NULL_RTX;\n-\t\t  push_obstacks (&reload_obstack, &reload_obstack);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t}\n-\n-\t      /* We're done with this insn.  */\n-\t      continue;\n-\t    }\n-\n-\t  /* It's not a no-op, but we can try to simplify it.  */\n-\t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t    if (GET_CODE (XVECEXP (body, 0, i)) == SET)\n-\t      count += reload_cse_simplify_set (XVECEXP (body, 0, i), insn);\n-\n-\t  if (count > 0)\n-\t    apply_change_group ();\n-\t  else\n-\t    reload_cse_simplify_operands (insn);\n-\n-\t  /* Look through the PARALLEL and record the values being\n-\t     set, if possible.  Also handle any CLOBBERs.  */\n-\t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t    {\n-\t      rtx x = XVECEXP (body, 0, i);\n-\n-\t      if (GET_CODE (x) == SET)\n-\t\treload_cse_record_set (x, body);\n-\t      else\n-\t\tnote_stores (x, reload_cse_invalidate_rtx, NULL);\n-\t    }\n-\t}\n-      else\n-\tnote_stores (body, reload_cse_invalidate_rtx, NULL);\n-\n-#ifdef AUTO_INC_DEC\n-      /* Clobber any registers which appear in REG_INC notes.  We\n-\t could keep track of the changes to their values, but it is\n-\t unlikely to help.  */\n-      {\n-\trtx x;\n-\n-\tfor (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n-\t  if (REG_NOTE_KIND (x) == REG_INC)\n-\t    reload_cse_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n-      }\n-#endif\n-\n-      /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n-\t after we have processed the insn.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  rtx x;\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\treload_cse_simplify (insn);\n \n-\t  for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n-\t    if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\t      reload_cse_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX,\n-\t\t\t\t\t NULL);\n-\t}\n+      cselib_process_insn (insn);\n     }\n \n   /* Clean up.  */\n   end_alias_analysis ();\n-\n-  /* Free all the temporary structures we created, and go back to the\n-     regular obstacks.  */\n-  obstack_free (&reload_obstack, firstobj);\n-  pop_obstacks ();\n+  cselib_finish ();\n }\n \n /* Call cse / combine like post-reload optimization phases.\n@@ -8320,127 +7994,6 @@ reload_cse_regs (first)\n     reload_cse_regs_1 (first);\n }\n \n-/* Return whether the values known for REGNO are equal to VAL.  MODE\n-   is the mode of the object that VAL is being copied to; this matters\n-   if VAL is a CONST_INT.  */\n-\n-static int\n-reload_cse_regno_equal_p (regno, val, mode)\n-     int regno;\n-     rtx val;\n-     enum machine_mode mode;\n-{\n-  rtx x;\n-\n-  if (val == 0)\n-    return 0;\n-\n-  for (x = reg_values[regno]; x; x = XEXP (x, 1))\n-    if (XEXP (x, 0) != 0\n-\t&& rtx_equal_p (XEXP (x, 0), val)\n-\t&& (! flag_float_store || GET_CODE (XEXP (x, 0)) != MEM\n-\t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT)\n-\t&& (GET_CODE (val) != CONST_INT\n-\t    || mode == GET_MODE (x)\n-\t    || (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x))\n-\t\t/* On a big endian machine if the value spans more than\n-\t\t   one register then this register holds the high part of\n-\t\t   it and we can't use it.\n-\n-\t\t   ??? We should also compare with the high part of the\n-\t\t   value.  */\n-\t\t&& !(WORDS_BIG_ENDIAN\n-\t\t     && HARD_REGNO_NREGS (regno, GET_MODE (x)) > 1)\n-\t\t&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t  GET_MODE_BITSIZE (GET_MODE (x))))))\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* See whether a single set is a noop.  SET is the set instruction we\n-   are should check, and INSN is the instruction from which it came.  */\n-\n-static int\n-reload_cse_noop_set_p (set, insn)\n-     rtx set;\n-     rtx insn ATTRIBUTE_UNUSED;\n-{\n-  rtx src, dest;\n-  enum machine_mode dest_mode;\n-  int dreg, sreg;\n-  int ret;\n-\n-  src = SET_SRC (set);\n-  dest = SET_DEST (set);\n-  dest_mode = GET_MODE (dest);\n-\n-  if (side_effects_p (src))\n-    return 0;\n-\n-  dreg = true_regnum (dest);\n-  sreg = true_regnum (src);\n-\n-  /* Check for setting a register to itself.  In this case, we don't\n-     have to worry about REG_DEAD notes.  */\n-  if (dreg >= 0 && dreg == sreg)\n-    return 1;\n-\n-  ret = 0;\n-  if (dreg >= 0)\n-    {\n-      /* Check for setting a register to itself.  */\n-      if (dreg == sreg)\n-\tret = 1;\n-\n-      /* Check for setting a register to a value which we already know\n-\t is in the register.  */\n-      else if (reload_cse_regno_equal_p (dreg, src, dest_mode))\n-\tret = 1;\n-\n-      /* Check for setting a register DREG to another register SREG\n-\t where SREG is equal to a value which is already in DREG.  */\n-      else if (sreg >= 0)\n-\t{\n-\t  rtx x;\n-\n-\t  for (x = reg_values[sreg]; x; x = XEXP (x, 1))\n-\t    {\n-\t      rtx tmp;\n-\n-\t      if (XEXP (x, 0) == 0)\n-\t\tcontinue;\n-\n-\t      if (dest_mode == GET_MODE (x))\n-\t\ttmp = XEXP (x, 0);\n-\t      else if (GET_MODE_BITSIZE (dest_mode)\n-\t\t       < GET_MODE_BITSIZE (GET_MODE (x)))\n-\t\ttmp = gen_lowpart_common (dest_mode, XEXP (x, 0));\n-\t      else\n-\t\tcontinue;\n-\n-\t      if (tmp\n-\t\t  && reload_cse_regno_equal_p (dreg, tmp, dest_mode))\n-\t\t{\n-\t\t  ret = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  else if (GET_CODE (dest) == MEM)\n-    {\n-      /* Check for storing a register to memory when we know that the\n-\t register is equivalent to the memory location. */\n-      if (sreg >= 0\n-\t  && reload_cse_regno_equal_p (sreg, dest, dest_mode)\n-\t  && ! side_effects_p (dest))\n-\tret = 1;\n-    }\n-\n-  return ret;\n-}\n-\n /* Try to simplify a single SET instruction.  SET is the set pattern.\n    INSN is the instruction it came from.\n    This function only handles one case: if we set a register to a value\n@@ -8452,11 +8005,13 @@ reload_cse_simplify_set (set, insn)\n      rtx set;\n      rtx insn;\n {\n+  int did_change = 0;\n   int dreg;\n   rtx src;\n-  enum machine_mode dest_mode;\n   enum reg_class dclass;\n-  register int i;\n+  int old_cost;\n+  cselib_val *val;\n+  struct elt_loc_list *l;\n \n   dreg = true_regnum (SET_DEST (set));\n   if (dreg < 0)\n@@ -8469,39 +8024,40 @@ reload_cse_simplify_set (set, insn)\n   dclass = REGNO_REG_CLASS (dreg);\n \n   /* If memory loads are cheaper than register copies, don't change them.  */\n-  if (GET_CODE (src) == MEM\n-      && MEMORY_MOVE_COST (GET_MODE (src), dclass, 1) < 2)\n-    return 0;\n+  if (GET_CODE (src) == MEM)\n+    old_cost = MEMORY_MOVE_COST (GET_MODE (src), dclass, 1);\n+  else if (CONSTANT_P (src))\n+    old_cost = rtx_cost (src, SET);\n+  else if (GET_CODE (src) == REG)\n+    old_cost = REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (src)), dclass);\n+  else\n+    /* ???   */\n+    old_cost = rtx_cost (src, SET);\n \n-  /* If the constant is cheaper than a register, don't change it.  */\n-  if (CONSTANT_P (src)\n-      && rtx_cost (src, SET) < 2)\n+  val = cselib_lookup (src, VOIDmode, 0);\n+  if (! val)\n     return 0;\n-\n-  dest_mode = GET_MODE (SET_DEST (set));\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (i != dreg\n-\t  && REGISTER_MOVE_COST (REGNO_REG_CLASS (i), dclass) == 2\n-\t  && reload_cse_regno_equal_p (i, src, dest_mode))\n-\t{\n-\t  int validated;\n-\n-\t  /* Pop back to the real obstacks while changing the insn.  */\n-\t  pop_obstacks ();\n-\n-\t  validated = validate_change (insn, &SET_SRC (set),\n-\t\t\t\t       gen_rtx_REG (dest_mode, i), 1);\n-\n-\t  /* Go back to the obstack we are using for temporary\n-\t     storage.  */\n-\t  push_obstacks (&reload_obstack, &reload_obstack);\n-\n-\t  if (validated)\n-\t    return 1;\n-\t}\n+  for (l = val->locs; l; l = l->next)\n+    {\n+      int this_cost;\n+      if (CONSTANT_P (l->loc) && ! references_value_p (l->loc, 0))\n+\tthis_cost = rtx_cost (l->loc, SET);\n+      else if (GET_CODE (l->loc) == REG)\n+\tthis_cost = REGISTER_MOVE_COST (REGNO_REG_CLASS (REGNO (l->loc)),\n+\t\t\t\t\tdclass);\n+      else\n+\tcontinue;\n+      /* If equal costs, prefer registers over anything else.  That tends to\n+\t lead to smaller instructions on some machines.  */\n+      if ((this_cost < old_cost\n+\t   || (this_cost == old_cost\n+\t       && GET_CODE (l->loc) == REG\n+\t       && GET_CODE (SET_SRC (set)) != REG))\n+      \t  && validate_change (insn, &SET_SRC (set), copy_rtx (l->loc), 1))\n+\told_cost = this_cost, did_change = 1;\n     }\n-  return 0;\n+\n+  return did_change;\n }\n \n /* Try to replace operands in INSN with equivalent values that are already\n@@ -8521,6 +8077,9 @@ reload_cse_simplify_operands (insn)\n {\n   int i,j;\n \n+  /* For each operand, all registers that are equivalent to it.  */\n+  HARD_REG_SET equiv_regs[MAX_RECOG_OPERANDS];\n+\n   const char *constraints[MAX_RECOG_OPERANDS];\n \n   /* Vector recording how bad an alternative is.  */\n@@ -8544,13 +8103,35 @@ reload_cse_simplify_operands (insn)\n   /* Figure out which alternative currently matches.  */\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n-\n+  \n   alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   bzero ((char *)alternative_reject, recog_data.n_alternatives * sizeof (int));\n   bzero ((char *)alternative_nregs, recog_data.n_alternatives * sizeof (int));\n \n+  /* For each operand, find out which regs are equivalent.  */\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      cselib_val *v;\n+      struct elt_loc_list *l;\n+\n+      CLEAR_HARD_REG_SET (equiv_regs[i]);\n+\n+      /* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem\n+\t right, so avoid the problem here.  */\n+      if (GET_CODE (recog_data.operand[i]) == CODE_LABEL)\n+\tcontinue;\n+\n+      v = cselib_lookup (recog_data.operand[i], recog_data.operand_mode[i], 0);\n+      if (! v)\n+\tcontinue;\n+\n+      for (l = v->locs; l; l = l->next)\n+\tif (GET_CODE (l->loc) == REG)\n+\t  SET_HARD_REG_BIT (equiv_regs[i], REGNO (l->loc));\n+    }\n+\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       enum machine_mode mode;\n@@ -8590,7 +8171,7 @@ reload_cse_simplify_operands (insn)\n \t{\n \t  int class = (int) NO_REGS;\n \n-\t  if (! reload_cse_regno_equal_p (regno, recog_data.operand[i], mode))\n+\t  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))\n \t    continue;\n \n \t  REGNO (reg) = regno;\n@@ -8696,9 +8277,6 @@ reload_cse_simplify_operands (insn)\n      alternative.  */\n   j = alternative_order[0];\n \n-  /* Pop back to the real obstacks while changing the insn.  */\n-  pop_obstacks ();\n-\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       enum machine_mode mode = recog_data.operand_mode[i];\n@@ -8721,178 +8299,8 @@ reload_cse_simplify_operands (insn)\n \t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n     }\n \n-  /* Go back to the obstack we are using for temporary\n-     storage.  */\n-  push_obstacks (&reload_obstack, &reload_obstack);\n-\n   return apply_change_group ();\n }\n-\n-/* These two variables are used to pass information from\n-   reload_cse_record_set to reload_cse_check_clobber.  */\n-\n-static int reload_cse_check_clobbered;\n-static rtx reload_cse_check_src;\n-\n-/* See if DEST overlaps with RELOAD_CSE_CHECK_SRC. If it does, set\n-   RELOAD_CSE_CHECK_CLOBBERED.  This is called via note_stores.  The\n-   second argument, which is passed by note_stores, is ignored.  */\n-\n-static void\n-reload_cse_check_clobber (dest, ignore, data)\n-     rtx dest;\n-     rtx ignore ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  if (reg_overlap_mentioned_p (dest, reload_cse_check_src))\n-    reload_cse_check_clobbered = 1;\n-}\n-\n-/* Record the result of a SET instruction.  SET is the set pattern.\n-   BODY is the pattern of the insn that it came from.  */\n-\n-static void\n-reload_cse_record_set (set, body)\n-     rtx set;\n-     rtx body;\n-{\n-  rtx dest, src, x;\n-  int dreg, sreg;\n-  enum machine_mode dest_mode;\n-\n-  dest = SET_DEST (set);\n-  src = SET_SRC (set);\n-  dreg = true_regnum (dest);\n-  sreg = true_regnum (src);\n-  dest_mode = GET_MODE (dest);\n-\n-  /* Some machines don't define AUTO_INC_DEC, but they still use push\n-     instructions.  We need to catch that case here in order to\n-     invalidate the stack pointer correctly.  Note that invalidating\n-     the stack pointer is different from invalidating DEST.  */\n-  x = dest;\n-  while (GET_CODE (x) == SUBREG\n-\t || GET_CODE (x) == ZERO_EXTRACT\n-\t || GET_CODE (x) == SIGN_EXTRACT\n-\t || GET_CODE (x) == STRICT_LOW_PART)\n-    x = XEXP (x, 0);\n-  if (push_operand (x, GET_MODE (x)))\n-    {\n-      reload_cse_invalidate_rtx (stack_pointer_rtx, NULL_RTX, NULL);\n-      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n-      return;\n-    }\n-\n-  /* We can only handle an assignment to a register, or a store of a\n-     register to a memory location.  For other cases, we just clobber\n-     the destination.  We also have to just clobber if there are side\n-     effects in SRC or DEST.  */\n-  if ((dreg < 0 && GET_CODE (dest) != MEM)\n-      || side_effects_p (src)\n-      || side_effects_p (dest))\n-    {\n-      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n-      return;\n-    }\n-\n-#ifdef HAVE_cc0\n-  /* We don't try to handle values involving CC, because it's a pain\n-     to keep track of when they have to be invalidated.  */\n-  if (reg_mentioned_p (cc0_rtx, src)\n-      || reg_mentioned_p (cc0_rtx, dest))\n-    {\n-      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n-      return;\n-    }\n-#endif\n-\n-  /* If BODY is a PARALLEL, then we need to see whether the source of\n-     SET is clobbered by some other instruction in the PARALLEL.  */\n-  if (GET_CODE (body) == PARALLEL)\n-    {\n-      int i;\n-\n-      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t{\n-\t  rtx x;\n-\n-\t  x = XVECEXP (body, 0, i);\n-\t  if (x == set)\n-\t    continue;\n-\n-\t  reload_cse_check_clobbered = 0;\n-\t  reload_cse_check_src = src;\n-\t  note_stores (x, reload_cse_check_clobber, NULL);\n-\t  if (reload_cse_check_clobbered)\n-\t    {\n-\t      reload_cse_invalidate_rtx (dest, NULL_RTX, NULL);\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  if (dreg >= 0)\n-    {\n-      int i;\n-\n-      /* This is an assignment to a register.  Update the value we\n-\t have stored for the register.  */\n-      if (sreg >= 0)\n-\t{\n-\t  rtx x;\n-\n-\t  /* This is a copy from one register to another.  Any values\n-\t     which were valid for SREG are now valid for DREG.  If the\n-\t     mode changes, we use gen_lowpart_common to extract only\n-\t     the part of the value that is copied.  */\n-\t  reg_values[dreg] = 0;\n-\t  for (x = reg_values[sreg]; x; x = XEXP (x, 1))\n-\t    {\n-\t      rtx tmp;\n-\n-\t      if (XEXP (x, 0) == 0)\n-\t\tcontinue;\n-\t      if (dest_mode == GET_MODE (XEXP (x, 0)))\n-\t\ttmp = XEXP (x, 0);\n-\t      else if (GET_MODE_BITSIZE (dest_mode)\n-\t\t\t> GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n-\t\tcontinue;\n-\t      else\n-\t\ttmp = gen_lowpart_common (dest_mode, XEXP (x, 0));\n-\t      if (tmp)\n-\t\treg_values[dreg] = gen_rtx_EXPR_LIST (dest_mode, tmp,\n-\t\t\t\t\t\t      reg_values[dreg]);\n-\t    }\n-\t}\n-      else\n-\treg_values[dreg] = gen_rtx_EXPR_LIST (dest_mode, src, NULL_RTX);\n-\n-      /* We've changed DREG, so invalidate any values held by other\n-\t registers that depend upon it.  */\n-      reload_cse_invalidate_regno (dreg, dest_mode, 0);\n-\n-      /* If this assignment changes more than one hard register,\n-\t forget anything we know about the others.  */\n-      for (i = 1; i < HARD_REGNO_NREGS (dreg, dest_mode); i++)\n-\treg_values[dreg + i] = 0;\n-    }\n-  else if (GET_CODE (dest) == MEM)\n-    {\n-      /* Invalidate conflicting memory locations.  */\n-      reload_cse_invalidate_mem (dest);\n-\n-      /* If we're storing a register to memory, add DEST to the list\n-\t in REG_VALUES.  */\n-      if (sreg >= 0 && ! side_effects_p (dest))\n-\treg_values[sreg] = gen_rtx_EXPR_LIST (dest_mode, dest,\n-\t\t\t\t    reg_values[sreg]);\n-    }\n-  else\n-    {\n-      /* We should have bailed out earlier.  */\n-      abort ();\n-    }\n-}\n \f\n /* If reload couldn't use reg+reg+offset addressing, try to use reg+reg\n    addressing now."}, {"sha": "ba68ca0eba2ca7368c92aef1126020323fd344d2", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -530,6 +530,9 @@ DEF_RTL_EXPR(CONST, \"const\", \"e\", 'o')\n    by a SET whose first operand is (PC).  */\n DEF_RTL_EXPR(PC, \"pc\", \"\", 'o')\n \n+/* Used in the cselib routines to describe a value.  */\n+DEF_RTL_EXPR(VALUE, \"value\", \"0\", 'o')\n+\n /* A register.  The \"operand\" is the register number, accessed with\n    the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n    than a hardware register is being referred to.  The second operand"}, {"sha": "158ea7ead0fb9324ac20284a8a9f4c802f7fbdeb", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -92,6 +92,7 @@ typedef union rtunion_def\n   struct rtvec_def *rtvec;\n   enum machine_mode rttype;\n   addr_diff_vec_flags rt_addr_diff_vec_flags;\n+  struct cselib_val_struct *rt_cselib;\n   struct bitmap_head_def *rtbit;\n   union tree_node *rttree;\n   struct basic_block_def *bb;\n@@ -330,6 +331,7 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n #define X0TREE(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rttree)\n #define X0BBDEF(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').bb)\n #define X0ADVFLAGS(RTX, N) (RTL_CHECK1(RTX, N, '0').rt_addr_diff_vec_flags)\n+#define X0CSELIB(RTX, N)   (RTL_CHECK1(RTX, N, '0').rt_cselib)\n \n #define XCWINT(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rtwint)\n #define XCINT(RTX, N, C)      (RTL_CHECKC1(RTX, N, C).rtint)\n@@ -341,6 +343,7 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n #define XCTREE(RTX, N, C)     (RTL_CHECKC1(RTX, N, C).rttree)\n #define XCBBDEF(RTX, N, C)    (RTL_CHECKC1(RTX, N, C).bb)\n #define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1(RTX, N, C).rt_addr_diff_vec_flags)\n+#define XCCSELIB(RTX, N, C)   (RTL_CHECKC1(RTX, N, C).rt_cselib)\n \n #define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n #define XCVECLEN(RTX, N, C)\tGET_NUM_ELEM (XCVEC (RTX, N, C))\n@@ -470,6 +473,8 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \n #define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n \n+#define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n+\n /* Don't forget to change reg_note_name in rtl.c.  */\n enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n \t\tREG_EQUAL = 5, REG_RETVAL = 6, REG_LIBCALL = 7,"}, {"sha": "f9ed9318080dbe328cf4abcaa629d983187ad910", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1230, "deletions": 0, "changes": 1230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -37,6 +37,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"ggc.h\"\n+#include \"obstack.h\"\n+#include \"hashtab.h\"\n+#include \"cselib.h\"\n \n /* Simplification and canonicalization of RTL.  */\n \n@@ -1957,3 +1961,1229 @@ simplify_rtx (x)\n       return NULL;\n     }\n }\n+\f\n+static int entry_and_rtx_equal_p\tPARAMS ((const void *, const void *));\n+static unsigned int get_value_hash\tPARAMS ((const void *));\n+static struct elt_list *new_elt_list\tPARAMS ((struct elt_list *, cselib_val *));\n+static struct elt_loc_list *new_elt_loc_list\tPARAMS ((struct elt_loc_list *, rtx));\n+static void unchain_one_value\t\tPARAMS ((cselib_val *));\n+static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n+static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n+static void clear_table\t\t\tPARAMS ((void));\n+static int check_value_useless\t\tPARAMS ((cselib_val *));\n+static int discard_useless_locs\t\tPARAMS ((void **, void *));\n+static int discard_useless_values\tPARAMS ((void **, void *));\n+static void remove_useless_values\tPARAMS ((void));\n+static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n+static cselib_val *new_cselib_val\tPARAMS ((unsigned int, enum machine_mode));\n+static void add_mem_for_addr\t\tPARAMS ((cselib_val *, cselib_val *, rtx));\n+static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n+static rtx cselib_subst_to_values\tPARAMS ((rtx));\n+static void cselib_invalidate_regno\tPARAMS ((int, enum machine_mode));\n+static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n+static int cselib_invalidate_mem_1\tPARAMS ((void **, void *));\n+static void cselib_invalidate_mem\tPARAMS ((rtx));\n+static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n+static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *, cselib_val *));\n+static void cselib_record_sets\t\tPARAMS ((rtx));\n+\n+/* There are three ways in which cselib can look up an rtx:\n+   - for a REG, the reg_values table (which is indexed by regno) is used\n+   - for a MEM, we recursively look up its address and then follow the\n+     addr_list of that value\n+   - for everything else, we compute a hash value and go through the hash\n+     table.  Since different rtx's can still have the same hash value,\n+     this involves walking the table entries for a given value and comparing\n+     the locations of the entries with the rtx we are looking up.  */\n+\n+/* A table that enables us to look up elts by their value.  */\n+static htab_t hash_table;\n+\n+/* This is a global so we don't have to pass this through every function.\n+   It is used in new_elt_loc_list to set SETTING_INSN.  */\n+static rtx cselib_current_insn;\n+\n+/* Every new unknown value gets a unique number.  */\n+static unsigned int next_unknown_value;\n+\n+/* The number of registers we had when the varrays were last resized.  */\n+static int cselib_nregs;\n+\n+/* Count values without known locations.  Whenever this grows too big, we\n+   remove these useless values from the table.  */\n+static int n_useless_values;\n+\n+/* Number of useless values before we remove them from the hash table.  */\n+#define MAX_USELESS_VALUES 32\n+\n+/* This table maps from register number to values.  It does not contain\n+   pointers to cselib_val structures, but rather elt_lists.  The purpose is\n+   to be able to refer to the same register in different modes.  */\n+static varray_type reg_values;\n+#define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n+\n+/* We pass this to cselib_invalidate_mem to invalidate all of\n+   memory for a non-const call instruction.  */\n+static rtx callmem;\n+\n+/* Memory for our structures is allocated from this obstack.  */\n+static struct obstack cselib_obstack;\n+\n+/* Used to quickly free all memory.  */\n+static char *cselib_startobj;\n+\n+/* Caches for unused structures.  */\n+static cselib_val *empty_vals;\n+static struct elt_list *empty_elt_lists;\n+static struct elt_loc_list *empty_elt_loc_lists;\n+\n+/* Allocate a struct elt_list and fill in its two elements with the\n+   arguments.  */\n+static struct elt_list *\n+new_elt_list (next, elt)\n+     struct elt_list *next;\n+     cselib_val *elt;\n+{\n+  struct elt_list *el = empty_elt_lists;\n+  if (el)\n+    empty_elt_lists = el->next;\n+  else\n+    el = (struct elt_list *) obstack_alloc (&cselib_obstack,\n+\t\t\t\t\t    sizeof (struct elt_list));\n+  el->next = next;\n+  el->elt = elt;\n+  return el;\n+}\n+\n+/* Allocate a struct elt_loc_list and fill in its two elements with the\n+   arguments.  */\n+static struct elt_loc_list *\n+new_elt_loc_list (next, loc)\n+     struct elt_loc_list *next;\n+     rtx loc;\n+{\n+  struct elt_loc_list *el = empty_elt_loc_lists;\n+  if (el)\n+    empty_elt_loc_lists = el->next;\n+  else\n+    el = (struct elt_loc_list *) obstack_alloc (&cselib_obstack,\n+\t\t\t\t\t\tsizeof (struct elt_loc_list));\n+  el->next = next;\n+  el->loc = loc;\n+  el->setting_insn = cselib_current_insn;\n+  return el;\n+}\n+\n+/* The elt_list at *PL is no longer needed.  Unchain it and free its\n+   storage.  */\n+static void\n+unchain_one_elt_list (pl)\n+     struct elt_list **pl;\n+{\n+  struct elt_list *l = *pl;\n+  *pl = l->next;\n+  l->next = empty_elt_lists;\n+  empty_elt_lists = l;\n+}\n+\n+/* Likewise for elt_loc_lists.  */\n+static void\n+unchain_one_elt_loc_list (pl)\n+     struct elt_loc_list **pl;\n+{\n+  struct elt_loc_list *l = *pl;\n+  *pl = l->next;\n+  l->next = empty_elt_loc_lists;\n+  empty_elt_loc_lists = l;\n+}\n+\n+/* Likewise for cselib_vals.  This also frees the addr_list associated with\n+   V.  */\n+static void\n+unchain_one_value (v)\n+     cselib_val *v;\n+{\n+  while (v->addr_list)\n+    unchain_one_elt_list (&v->addr_list);\n+\n+  v->u.next_free = empty_vals;\n+  empty_vals = v;\n+}\n+\n+/* Remove all entries from the hash table.  Also used during\n+   initialization.  */\n+static void\n+clear_table ()\n+{\n+  int i;\n+  for (i = 0; i < cselib_nregs; i++)\n+    REG_VALUES (i) = 0;\n+\n+  htab_empty (hash_table);\n+  obstack_free (&cselib_obstack, cselib_startobj);\n+\n+  empty_vals = 0;\n+  empty_elt_lists = 0;\n+  empty_elt_loc_lists = 0;\n+  n_useless_values = 0;\n+\n+  next_unknown_value = 0;\n+}\n+\n+/* The equality test for our hash table.  The first argument ENTRY is a table\n+   element (i.e. a cselib_val), while the second arg X is an rtx.  */\n+static int\n+entry_and_rtx_equal_p (entry, x_arg)\n+     const void *entry, *x_arg;\n+{\n+  struct elt_loc_list *l;\n+  cselib_val *v = (cselib_val *)entry;\n+  rtx x = (rtx)x_arg;\n+\n+  /* We don't guarantee that distinct rtx's have different hash values,\n+     so we need to do a comparison.  */\n+  for (l = v->locs; l; l = l->next)\n+    if (rtx_equal_for_cselib_p (l->loc, x))\n+      return 1;\n+  return 0;\n+}\n+\n+/* The hash function for our hash table.  The value is always computed with\n+   hash_rtx when adding an element; this function just extracts the hash\n+   value from a cselib_val structure.  */\n+static unsigned int\n+get_value_hash (entry)\n+     const void *entry;\n+{\n+  cselib_val *v = (cselib_val *) entry;\n+  return v->value;\n+}\n+\n+/* If there are no more locations that hold a value, the value has become\n+   useless.  See whether that is the case for V.  Return 1 if this has\n+   just become useless.  */\n+static int\n+check_value_useless (v)\n+     cselib_val *v;\n+{\n+  if (v->locs != 0)\n+    return 0;\n+\n+  if (v->value == 0)\n+    return 0;\n+\n+  /* This is a marker to indicate that the value will be reclaimed.  */\n+  v->value = 0;\n+  n_useless_values++;\n+  return 1;\n+}\n+\n+/* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we\n+   only return true for values which point to a cselib_val whose value\n+   element has been set to zero, which implies the cselib_val will be\n+   removed.  */\n+int\n+references_value_p (x, only_useless)\n+     rtx x;\n+     int only_useless;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  int i;\n+\n+  if (GET_CODE (x) == VALUE\n+      && (! only_useless || CSELIB_VAL_PTR (x)->value == 0))\n+    return 1;\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (references_value_p (XEXP (x, i), only_useless))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (references_value_p (XVECEXP (x, i, j), only_useless))\n+\t      return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Set by discard_useless_locs if it deleted the last location of any\n+   value.  */\n+static int values_became_useless;\n+\n+/* For all locations found in X, delete locations that reference useless\n+   values (i.e. values without any location).  Called through\n+   htab_traverse.  */\n+static int\n+discard_useless_locs (x, info)\n+     void **x;\n+     void *info ATTRIBUTE_UNUSED;\n+{\n+  cselib_val *v = (cselib_val *)*x;\n+  struct elt_loc_list **p = &v->locs;\n+\n+  while (*p)\n+    {\n+      if (references_value_p ((*p)->loc, 1))\n+\tunchain_one_elt_loc_list (p);\n+      else\n+\tp = &(*p)->next;\n+    }\n+  if (check_value_useless (v))\n+    values_became_useless = 1;\n+\n+  return 1;\n+}\n+\n+/* If X is a value with no locations, remove it from the hashtable.  */\n+\n+static int\n+discard_useless_values (x, info)\n+     void **x;\n+     void *info ATTRIBUTE_UNUSED;\n+{\n+  cselib_val *v = (cselib_val *)*x;\n+\n+  if (v->value == 0)\n+    {\n+      htab_clear_slot (hash_table, x);\n+      unchain_one_value (v);\n+      n_useless_values--;\n+    }\n+  return 1;\n+}\n+\n+/* Clean out useless values (i.e. those which no longer have locations\n+   associated with them) from the hash table.  */\n+static void\n+remove_useless_values ()\n+{\n+  /* First pass: eliminate locations that reference the value.  That in\n+     turn can make more values useless.  */\n+  do\n+    {\n+      values_became_useless = 0;\n+      htab_traverse (hash_table, discard_useless_locs, 0);\n+    }\n+  while (values_became_useless);\n+\n+  /* Second pass: actually remove the values.  */\n+  htab_traverse (hash_table, discard_useless_values, 0);\n+\n+  if (n_useless_values != 0)\n+    abort ();\n+}\n+\n+/* Return nonzero if we can prove that X and Y contain the same value, taking\n+   our gathered information into account.  */\n+int\n+rtx_equal_for_cselib_p (x, y)\n+     rtx x, y;\n+{\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i;\n+  \n+  if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n+    {\n+      cselib_val *e = cselib_lookup (x, VOIDmode, 0);\n+      if (e)\n+\tx = e->u.val_rtx;\n+    }\n+  if (GET_CODE (y) == REG || GET_CODE (y) == MEM)\n+    {\n+      cselib_val *e = cselib_lookup (y, VOIDmode, 0);\n+      if (e)\n+\ty = e->u.val_rtx;\n+    }\n+\n+  if (x == y)\n+    return 1;\n+\n+  if (GET_CODE (x) == VALUE && GET_CODE (y) == VALUE)\n+    return CSELIB_VAL_PTR (x) == CSELIB_VAL_PTR (y);\n+\n+  if (GET_CODE (x) == VALUE)\n+    {\n+      cselib_val *e = CSELIB_VAL_PTR (x);\n+      struct elt_loc_list *l;\n+\n+      for (l = e->locs; l; l = l->next)\n+\t{\n+\t  rtx t = l->loc;\n+\n+\t  /* Avoid infinite recursion.  */\n+\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n+\t    continue;\n+\n+\t  if (rtx_equal_for_cselib_p (t, y))\n+\t    return 1;\n+\t}\n+      \n+      return 0;\n+    }\n+\n+  if (GET_CODE (y) == VALUE)\n+    {\n+      cselib_val *e = CSELIB_VAL_PTR (y);\n+      struct elt_loc_list *l;\n+\n+      for (l = e->locs; l; l = l->next)\n+\t{\n+\t  rtx t = l->loc;\n+\n+\t  if (GET_CODE (t) == REG || GET_CODE (t) == MEM)\n+\t    continue;\n+\n+\t  if (rtx_equal_for_cselib_p (x, t))\n+\t    return 1;\n+\t}\n+      \n+      return 0;\n+    }\n+\n+  if (GET_CODE (x) != GET_CODE (y)\n+      || GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* This won't be handled correctly by the code below.  */\n+  if (GET_CODE (x) == LABEL_REF)\n+    return XEXP (x, 0) == XEXP (y, 0);\n+  \n+  code = GET_CODE (x);\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      int j;\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (! rtx_equal_for_cselib_p (XVECEXP (x, i, j),\n+\t\t\t\t\t  XVECEXP (y, i, j)))\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (! rtx_equal_for_cselib_p (XEXP (x, i), XEXP (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n+   For registers and memory locations, we look up their cselib_val structure\n+   and return its VALUE element.\n+   Possible reasons for return 0 are: the object is volatile, or we couldn't\n+   find a register or memory location in the table and CREATE is zero.  If\n+   CREATE is nonzero, table elts are created for regs and mem.\n+   MODE is used in hashing for CONST_INTs only;\n+   otherwise the mode of X is used.  */\n+static unsigned int\n+hash_rtx (x, mode, create)\n+     rtx x;\n+     enum machine_mode mode;\n+     int create;\n+{\n+  cselib_val *e;\n+  int i, j;\n+  unsigned int hash = 0;\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt = GET_RTX_FORMAT (code);\n+\n+  /* repeat is used to turn tail-recursion into iteration.  */\n+ repeat:\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case MEM:\n+    case REG:\n+      e = cselib_lookup (x, GET_MODE (x), create);\n+      if (! e)\n+\treturn 0;\n+      return e->value;\n+\n+    case CONST_INT:\n+      {\n+\tunsigned HOST_WIDE_INT tem = INTVAL (x);\n+\thash += ((unsigned) CONST_INT << 7) + (unsigned) mode + tem;\n+\treturn hash ? hash : CONST_INT;\n+      }\n+\n+    case CONST_DOUBLE:\n+      /* This is like the general case, except that it only counts\n+\t the integers representing the constant.  */\n+      hash += (unsigned) code + (unsigned) GET_MODE (x);\n+      if (GET_MODE (x) != VOIDmode)\n+\tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n+\t  {\n+\t    unsigned HOST_WIDE_INT tem = XWINT (x, i);\n+\t    hash += tem;\n+\t  }\n+      else\n+\thash += ((unsigned) CONST_DOUBLE_LOW (x)\n+\t\t + (unsigned) CONST_DOUBLE_HIGH (x));\n+      return hash ? hash : CONST_DOUBLE;\n+\n+      /* Assume there is only one rtx object for any given label.  */\n+    case LABEL_REF:\n+      hash\n+\t+= ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);\n+      return hash ? hash : LABEL_REF;\n+\n+    case SYMBOL_REF:\n+      hash\n+\t+= ((unsigned) SYMBOL_REF << 7) + (unsigned long) XSTR (x, 0);\n+      return hash ? hash : SYMBOL_REF;\n+\n+    case PRE_DEC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case POST_INC:\n+    case PC:\n+    case CC0:\n+    case CALL:\n+    case UNSPEC_VOLATILE:\n+      return 0;\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 0;\n+\n+      break;\n+      \n+    default:\n+      break;\n+    }\n+\n+  i = GET_RTX_LENGTH (code) - 1;\n+  hash += (unsigned) code + (unsigned) GET_MODE (x);\n+  fmt = GET_RTX_FORMAT (code);\n+  for (; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  unsigned int tem_hash;\n+\t  rtx tem = XEXP (x, i);\n+\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function  is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = tem;\n+\t      goto repeat;\n+\t    }\n+\t  tem_hash = hash_rtx (tem, 0, create);\n+\t  if (tem_hash == 0)\n+\t    return 0;\n+\t  hash += tem_hash;\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  {\n+\t    unsigned int tem_hash = hash_rtx (XVECEXP (x, i, j), 0, create);\n+\t    if (tem_hash == 0)\n+\t      return 0;\n+\t    hash += tem_hash;\n+\t  }\n+      else if (fmt[i] == 's')\n+\t{\n+\t  unsigned char *p = (unsigned char *) XSTR (x, i);\n+\t  if (p)\n+\t    while (*p)\n+\t      hash += *p++;\n+\t}\n+      else if (fmt[i] == 'i')\n+\t{\n+\t  unsigned int tem = XINT (x, i);\n+\t  hash += tem;\n+\t}\n+      else if (fmt[i] == '0' || fmt[i] == 't')\n+\t/* unused */;\n+      else\n+\tabort ();\n+    }\n+  return hash ? hash : 1 + GET_CODE (x);\n+}\n+\n+/* Create a new value structure for VALUE and initialize it.  The mode of the\n+   value is MODE.  */\n+static cselib_val *\n+new_cselib_val (value, mode)\n+     unsigned int value;\n+     enum machine_mode mode;\n+{\n+  cselib_val *e = empty_vals;\n+  if (e)\n+    empty_vals = e->u.next_free;\n+  else\n+    e = (cselib_val *) obstack_alloc (&cselib_obstack, sizeof (cselib_val));\n+  if (value == 0)\n+    abort ();\n+  e->value = value;\n+  e->u.val_rtx = gen_rtx_VALUE (mode);\n+  CSELIB_VAL_PTR (e->u.val_rtx) = e;\n+\n+  e->addr_list = 0;\n+  e->locs = 0;\n+  return e;\n+}\n+\n+/* ADDR_ELT is a value that is used as address.  MEM_ELT is the value that\n+   contains the data at this address.  X is a MEM that represents the\n+   value.  Update the two value structures to represent this situation.  */\n+static void\n+add_mem_for_addr (addr_elt, mem_elt, x)\n+     cselib_val *addr_elt, *mem_elt;\n+     rtx x;\n+{\n+  rtx new;\n+  struct elt_loc_list *l;\n+\n+  /* Avoid duplicates.  */\n+  for (l = mem_elt->locs; l; l = l->next)\n+    if (GET_CODE (l->loc) == MEM\n+\t&& CSELIB_VAL_PTR (XEXP (l->loc, 0)) == addr_elt)\n+      return;\n+\n+  new = gen_rtx_MEM (GET_MODE (x), addr_elt->u.val_rtx);\n+  addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n+\n+  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n+  MEM_COPY_ATTRIBUTES (new, x);\n+\n+  mem_elt->locs = new_elt_loc_list (mem_elt->locs, new);\n+}\n+\n+/* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx.\n+   If CREATE, make a new one if we haven't seen it before.  */\n+static cselib_val *\n+cselib_lookup_mem (x, create)\n+     rtx x;\n+     int create;\n+{\n+  void **slot;\n+  cselib_val *addr;\n+  cselib_val *mem_elt;\n+  struct elt_list *l;\n+\n+  if (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode)\n+    return 0;\n+  if (FLOAT_MODE_P (GET_MODE (x)) && flag_float_store)\n+    return 0;\n+\n+  /* Look up the value for the address.  */\n+  addr = cselib_lookup (XEXP (x, 0), GET_MODE (x), create);\n+  if (! addr)\n+    return 0;\n+\n+  /* Find a value that describes a value of our mode at that address.  */\n+  for (l = addr->addr_list; l; l = l->next)\n+    if (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n+      return l->elt;\n+  if (! create)\n+    return 0;\n+  mem_elt = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+  add_mem_for_addr (addr, mem_elt, x);\n+  slot = htab_find_slot_with_hash (hash_table, x, mem_elt->value, 1);\n+  *slot = mem_elt;\n+  return mem_elt;\n+}\n+\n+/* Walk rtx X and replace all occurrences of REG and MEM subexpressions\n+   with VALUE expressions.  This way, it becomes independent of changes\n+   to registers and memory.\n+   X isn't actually modified; if modifications are needed, new rtl is\n+   allocated.  However, the return value can share rtl with X.  */\n+static rtx\n+cselib_subst_to_values (x)\n+     rtx x;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  cselib_val *e;\n+  struct elt_list *l;\n+  rtx copy = x;\n+  int i;\n+\n+  switch (code)\n+    {\n+    case REG:\n+      i = REGNO (x);\n+      for (l = REG_VALUES (i); l; l = l->next)\n+\tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n+\t  return l->elt->u.val_rtx;\n+      abort ();\n+\n+    case MEM:\n+      e = cselib_lookup_mem (x, 0);\n+      if (! e)\n+\tabort ();\n+      return e->u.val_rtx;\n+\n+      /* CONST_DOUBLEs must be special-cased here so that we won't try to\n+\t look up the CONST_DOUBLE_MEM inside.  */\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+      return x;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  rtx t = cselib_subst_to_values (XEXP (x, i));\n+\t  if (t != XEXP (x, i) && x == copy)\n+\t    copy = shallow_copy_rtx (x);\n+\t  XEXP (copy, i) = t;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j, k;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    {\n+\t      rtx t = cselib_subst_to_values (XVECEXP (x, i, j));\n+\t      if (t != XVECEXP (x, i, j) && XVEC (x, i) == XVEC (copy, i))\n+\t\t{\n+\t\t  if (x == copy)\n+\t\t    copy = shallow_copy_rtx (x);\n+\t\t  XVEC (copy, i) = rtvec_alloc (XVECLEN (x, i));\n+\t\t  for (k = 0; k < j; k++)\n+\t\t    XVECEXP (copy, i, k) = XVECEXP (x, i, k);\n+\t\t}\n+\t      XVECEXP (copy, i, j) = t;\n+\t    }\n+\t}\n+    }\n+  return copy;\n+}\n+\n+/* Look up the rtl expression X in our tables and return the value it has.\n+   If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n+   we create a new one if possible, using mode MODE if X doesn't have a mode\n+   (i.e. because it's a constant).  */\n+cselib_val *\n+cselib_lookup (x, mode, create)\n+     rtx x;\n+     enum machine_mode mode;\n+     int create;\n+{\n+  void **slot;\n+  cselib_val *e;\n+  unsigned int hashval;\n+\n+  if (GET_MODE (x) != VOIDmode)\n+    mode = GET_MODE (x);\n+\n+  if (GET_CODE (x) == VALUE)\n+    return CSELIB_VAL_PTR (x);\n+\n+  if (GET_CODE (x) == REG)\n+    {\n+      struct elt_list *l;\n+      int i = REGNO (x);\n+      for (l = REG_VALUES (i); l; l = l->next)\n+\tif (mode == GET_MODE (l->elt->u.val_rtx))\n+\t  return l->elt;\n+      if (! create)\n+\treturn 0;\n+      e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+      e->locs = new_elt_loc_list (e->locs, x);\n+      REG_VALUES (i) = new_elt_list (REG_VALUES (i), e);\n+      slot = htab_find_slot_with_hash (hash_table, x, e->value, 1);\n+      *slot = e;\n+      return e;\n+    }\n+\n+  if (GET_CODE (x) == MEM)\n+    return cselib_lookup_mem (x, create);\n+\n+  hashval = hash_rtx (x, mode, create);\n+  /* Can't even create if hashing is not possible.  */\n+  if (! hashval)\n+    return 0;\n+\n+  slot = htab_find_slot_with_hash (hash_table, x, hashval, create);\n+  if (slot == 0)\n+    return 0;\n+  e = (cselib_val *) *slot;\n+  if (e)\n+    return e;\n+\n+  e = new_cselib_val (hashval, mode);\n+  e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n+  *slot = (void *) e;\n+  return e;\n+}\n+\n+/* Invalidate any entries in reg_values that overlap REGNO.  This is called\n+   if REGNO is changing.  MODE is the mode of the assignment to REGNO, which\n+   is used to determine how many hard registers are being changed.  If MODE\n+   is VOIDmode, then only REGNO is being changed; this is used when\n+   invalidating call clobbered registers across a call.  */\n+static void\n+cselib_invalidate_regno (regno, mode)\n+     int regno;\n+     enum machine_mode mode;\n+{\n+  int endregno;\n+  int i;\n+\n+  /* If we see pseudos after reload, something is _wrong_.  */\n+  if (reload_completed && regno >= FIRST_PSEUDO_REGISTER\n+      && reg_renumber[regno] >= 0)\n+    abort ();\n+\n+  /* Determine the range of registers that must be invalidated.  For\n+     pseudos, only REGNO is affected.  For hard regs, we must take MODE\n+     into account, and we must also invalidate lower register numbers\n+     if they contain values that overlap REGNO.  */\n+  endregno = regno + 1;\n+  if (regno < FIRST_PSEUDO_REGISTER && mode != VOIDmode) \n+    endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\n+  for (i = 0; i < endregno; i++)\n+    {\n+      struct elt_list **l = &REG_VALUES (i);\n+\n+      /* Go through all known values for this reg; if it overlaps the range\n+\t we're invalidating, remove the value.  */\n+      while (*l)\n+\t{\n+\t  cselib_val *v = (*l)->elt;\n+\t  struct elt_loc_list **p;\n+\t  int this_last = i;\n+\n+\t  if (i < FIRST_PSEUDO_REGISTER)\n+\t    this_last += HARD_REGNO_NREGS (i, GET_MODE (v->u.val_rtx)) - 1;\n+\t  if (this_last < regno)\n+\t    {\n+\t      l = &(*l)->next;\n+\t      continue;\n+\t    }\n+\t  /* We have an overlap.  */\n+\t  unchain_one_elt_list (l);\n+\n+\t  /* Now, we clear the mapping from value to reg.  It must exist, so\n+\t     this code will crash intentionally if it doesn't.  */\n+\t  for (p = &v->locs; ; p = &(*p)->next)\n+\t    {\n+\t      rtx x = (*p)->loc;\n+\t      if (GET_CODE (x) == REG && REGNO (x) == i)\n+\t\t{\n+\t\t  unchain_one_elt_loc_list (p);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  check_value_useless (v);\n+\t}\n+    }\n+}\n+\n+/* The memory at address MEM_BASE is being changed.\n+   Return whether this change will invalidate VAL.  */\n+static int\n+cselib_mem_conflict_p (mem_base, val)\n+     rtx mem_base;\n+     rtx val;\n+{\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i;\n+\n+  code = GET_CODE (val);\n+  switch (code)\n+    {\n+      /* Get rid of a few simple cases quickly. */\n+    case REG:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case MEM:\n+      if (GET_MODE (mem_base) == BLKmode\n+\t  || GET_MODE (val) == BLKmode)\n+\treturn 1;\n+      if (anti_dependence (val, mem_base))\n+\treturn 1;\n+      /* The address may contain nested MEMs.  */\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (cselib_mem_conflict_p (mem_base, XEXP (val, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = 0; j < XVECLEN (val, i); j++)\n+\t    if (cselib_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* For the value found in SLOT, walk its locations to determine if any overlap\n+   INFO (which is a MEM rtx).  */\n+static int\n+cselib_invalidate_mem_1 (slot, info)\n+     void **slot;\n+     void *info;\n+{\n+  cselib_val *v = (cselib_val *) *slot;\n+  rtx mem_rtx = (rtx) info;\n+  struct elt_loc_list **p = &v->locs;\n+\n+  while (*p)\n+    {\n+      cselib_val *addr;\n+      struct elt_list **mem_chain;\n+      rtx x = (*p)->loc;\n+\n+      /* MEMs may occur in locations only at the top level; below\n+\t that every MEM or REG is substituted by its VALUE.  */\n+      if (GET_CODE (x) != MEM\n+\t  || ! cselib_mem_conflict_p (mem_rtx, x))\n+\t{\n+\t  p = &(*p)->next;\n+\t  continue;\n+\t}\n+\n+      /* This one overlaps.  */\n+      /* We must have a mapping from this MEM's address to the\n+\t value (E).  Remove that, too.  */\n+      addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);\n+      mem_chain = &addr->addr_list;\n+      for (;;)\n+\t{\n+\t  if ((*mem_chain)->elt == v)\n+\t    {\n+\t      unchain_one_elt_list (mem_chain);\n+\t      break;\n+\t    }\n+\t  mem_chain = &(*mem_chain)->next;\n+\t}\n+      unchain_one_elt_loc_list (p);\n+    }\n+  check_value_useless (v);\n+  return 1;\n+}\n+\n+/* Invalidate any locations in the table which are changed because of a\n+   store to MEM_RTX.  If this is called because of a non-const call\n+   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n+static void\n+cselib_invalidate_mem (mem_rtx)\n+     rtx mem_rtx;\n+{\n+  htab_traverse (hash_table, cselib_invalidate_mem_1, mem_rtx);\n+}\n+\n+/* Invalidate DEST, which is being assigned to or clobbered.  The second and\n+   the third parameter exist so that this function can be passed to\n+   note_stores; they are ignored.  */\n+static void\n+cselib_invalidate_rtx (dest, ignore, data)\n+     rtx dest;\n+     rtx ignore ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  while (GET_CODE (dest) == STRICT_LOW_PART\n+\t || GET_CODE (dest) == SIGN_EXTRACT\n+\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t || GET_CODE (dest) == SUBREG)\n+    dest = XEXP (dest, 0);\n+\n+  if (GET_CODE (dest) == REG)\n+    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n+  else if (GET_CODE (dest) == MEM)\n+    cselib_invalidate_mem (dest);\n+\n+  /* Some machines don't define AUTO_INC_DEC, but they still use push\n+     instructions.  We need to catch that case here in order to\n+     invalidate the stack pointer correctly.  Note that invalidating\n+     the stack pointer is different from invalidating DEST.  */\n+  if (push_operand (dest, GET_MODE (dest)))\n+    cselib_invalidate_rtx (stack_pointer_rtx, NULL_RTX, NULL);\n+}\n+\n+/* Record the result of a SET instruction.  DEST is being set; the source\n+   contains the value described by SRC_ELT.  If DEST is a MEM, DEST_ADDR_ELT\n+   describes its address.  */\n+static void\n+cselib_record_set (dest, src_elt, dest_addr_elt)\n+     rtx dest;\n+     cselib_val *src_elt, *dest_addr_elt;\n+{\n+  int dreg = GET_CODE (dest) == REG ? REGNO (dest) : -1;\n+\n+  if (src_elt == 0 || side_effects_p (dest))\n+    return;\n+\n+  if (dreg >= 0)\n+    {\n+      REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n+      src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n+    }\n+  else if (GET_CODE (dest) == MEM && dest_addr_elt != 0)\n+    add_mem_for_addr (dest_addr_elt, src_elt, dest);\n+}\n+\n+/* Describe a single set that is part of an insn.  */\n+struct set\n+{\n+  rtx src;\n+  rtx dest;\n+  cselib_val *src_elt;\n+  cselib_val *dest_addr_elt;\n+};\n+\n+/* There is no good way to determine how many elements there can be\n+   in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n+#define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)\n+\n+/* Record the effects of any sets in INSN.  */\n+static void\n+cselib_record_sets (insn)\n+     rtx insn;\n+{\n+  int n_sets = 0;\n+  int i;\n+  struct set sets[MAX_SETS];\n+  rtx body = PATTERN (insn);\n+\n+  body = PATTERN (insn);\n+  /* Find all sets.  */\n+  if (GET_CODE (body) == SET)\n+    {\n+      sets[0].src = SET_SRC (body);\n+      sets[0].dest = SET_DEST (body);\n+      n_sets = 1;\n+    }\n+  else if (GET_CODE (body) == PARALLEL)\n+    {\n+      /* Look through the PARALLEL and record the values being\n+\t set, if possible.  Also handle any CLOBBERs.  */\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\t{\n+\t  rtx x = XVECEXP (body, 0, i);\n+\n+\t  if (GET_CODE (x) == SET)\n+\t    {\n+\t      sets[n_sets].src = SET_SRC (x);\n+\t      sets[n_sets].dest = SET_DEST (x);\n+\t      n_sets++;\n+\t    }\n+\t}\n+    }\n+\n+  /* Look up the values that are read.  Do this before invalidating the\n+     locations that are written.  */\n+  for (i = 0; i < n_sets; i++)\n+    {\n+      sets[i].src_elt = cselib_lookup (sets[i].src, GET_MODE (sets[i].dest),\n+\t\t\t\t       1);\n+      if (GET_CODE (sets[i].dest) == MEM)\n+\tsets[i].dest_addr_elt = cselib_lookup (XEXP (sets[i].dest, 0), Pmode,\n+\t\t\t\t\t       1);\n+      else\n+\tsets[i].dest_addr_elt = 0;\n+    }\n+\n+  /* Invalidate all locations written by this insn.  Note that the elts we\n+     looked up in the previous loop aren't affected, just some of their\n+     locations may go away.  */\n+  note_stores (body, cselib_invalidate_rtx, NULL);\n+\n+  /* Now enter the equivalences in our tables.  */\n+  for (i = 0; i < n_sets; i++)\n+    cselib_record_set (sets[i].dest, sets[i].src_elt, sets[i].dest_addr_elt);\n+}\n+\n+/* Record the effects of INSN.  */\n+void\n+cselib_process_insn (insn)\n+     rtx insn;\n+{\n+  int i;\n+\n+  cselib_current_insn = insn;\n+\n+  /* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */\n+  if (GET_CODE (insn) == CODE_LABEL\n+      || (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+      || (GET_CODE (insn) == INSN\n+\t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n+\t  && MEM_VOLATILE_P (PATTERN (insn))))\n+    {\n+      clear_table ();\n+      return;\n+    }\n+\n+  if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+    {\n+      cselib_current_insn = 0;\n+      return;\n+    }\n+  /* If this is a call instruction, forget anything stored in a\n+     call clobbered register, or, if this is not a const call, in\n+     memory.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    {\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (call_used_regs[i])\n+\t  cselib_invalidate_regno (i, VOIDmode);\n+\n+      if (! CONST_CALL_P (insn))\n+\tcselib_invalidate_mem (callmem);\n+    }\n+\n+  cselib_record_sets (insn);\n+\n+#ifdef AUTO_INC_DEC\n+  /* Clobber any registers which appear in REG_INC notes.  We\n+     could keep track of the changes to their values, but it is\n+     unlikely to help.  */\n+  {\n+    rtx x;\n+\n+    for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n+      if (REG_NOTE_KIND (x) == REG_INC)\n+\tcselib_invalidate_rtx (XEXP (x, 0), NULL_RTX, NULL);\n+  }\n+#endif\n+\n+  /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n+     after we have processed the insn.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    {\n+      rtx x;\n+\n+      for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n+\tif (GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\t  cselib_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX,\n+\t\t\t\t     NULL);\n+    }\n+\n+  cselib_current_insn = 0;\n+\n+  if (n_useless_values > MAX_USELESS_VALUES)\n+    remove_useless_values ();\n+}\n+\n+/* Make sure our varrays are big enough.  Not called from any cselib routines;\n+   it must be called by the user if it allocated new registers.  */\n+void\n+cselib_update_varray_sizes ()\n+{\n+  int nregs = max_reg_num ();\n+  if (nregs == cselib_nregs)\n+    return;\n+  cselib_nregs = nregs;\n+  VARRAY_GROW (reg_values, nregs);\n+}\n+\n+/* Initialize cselib for one pass.  The caller must also call\n+   init_alias_analysis.  */\n+void\n+cselib_init ()\n+{\n+  /* These are only created once.  */\n+  if (! callmem)\n+    {\n+      extern struct obstack permanent_obstack;\n+      gcc_obstack_init (&cselib_obstack);\n+      cselib_startobj = obstack_alloc (&cselib_obstack, 0);\n+\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n+      pop_obstacks ();\n+      ggc_add_rtx_root (&callmem, 1);\n+    }\n+\n+  cselib_nregs = max_reg_num ();\n+  VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n+  hash_table = htab_create (31, get_value_hash, entry_and_rtx_equal_p, NULL);\n+  clear_table ();\n+}\n+\n+/* Called when the current user is done with cselib.  */\n+void\n+cselib_finish ()\n+{\n+  clear_table ();\n+  htab_delete (hash_table);\n+}"}, {"sha": "69482a9a3157af0dbf7be5b5ee2a44d733dcac53", "filename": "gcc/varray.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eab5c70a03b09cdff6668c76fde6337e486dcdb4/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=eab5c70a03b09cdff6668c76fde6337e486dcdb4", "patch": "@@ -76,6 +76,7 @@ typedef union varray_data_tag {\n   struct reg_info_def\t *reg[1];\n   struct const_equiv_data const_equiv[1];\n   struct basic_block_def *bb[1];\n+  struct elt_list       *te[1];\n } varray_data;\n \n /* Virtual array of pointers header.  */\n@@ -152,6 +153,9 @@ extern varray_type varray_init\tPARAMS ((size_t, size_t, const char *));\n #define VARRAY_BB_INIT(va, num, name) \\\n   va = varray_init (num, sizeof (struct basic_block_def *), name)\n \n+#define VARRAY_ELT_LIST_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct elt_list *), name)\n+\n /* Free up memory allocated by the virtual array, but do not free any of the\n    elements involved.  */\n #define VARRAY_FREE(vp) \\\n@@ -219,6 +223,7 @@ extern void varray_check_failed PARAMS ((varray_type, size_t,\n #define VARRAY_REG(VA, N)\t\tVARRAY_CHECK (VA, N, reg)\n #define VARRAY_CONST_EQUIV(VA, N)\tVARRAY_CHECK (VA, N, const_equiv)\n #define VARRAY_BB(VA, N)\t\tVARRAY_CHECK (VA, N, bb)\n+#define VARRAY_ELT_LIST(VA, N)\t\tVARRAY_CHECK (VA, N, te)\n \n /* Push a new element on the end of VA, extending it if necessary.  */\n #define VARRAY_PUSH_CHAR(VA, X)\t\tVARRAY_PUSH (VA, c, X)"}]}