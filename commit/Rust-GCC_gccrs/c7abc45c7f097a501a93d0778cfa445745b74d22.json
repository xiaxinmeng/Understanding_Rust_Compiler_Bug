{"sha": "c7abc45c7f097a501a93d0778cfa445745b74d22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhYmM0NWM3ZjA5N2E1MDFhOTNkMDc3OGNmYTQ0NTc0NWI3NGQyMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2007-12-20T08:13:09Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-12-20T08:13:09Z"}, "message": "re PR fortran/34482 (FAIL: gfortran.dg/nan_4.f90  -O tests for errors)\n\n2007-12-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34482\n        * gfortran.texi (BOZ): Document behavior for complex\n        numbers.\n        * target-memory.h (gfc_convert_boz): Update prototype.\n        * target-memory.c (gfc_convert_boz): Add error check\n        and convert BOZ to smallest possible bit size.\n        * resolve.c (resolve_ordinary_assign): Check return value.\n        * expr.c (gfc_check_assign): Ditto.\n        * simplify.c (simplify_cmplx, gfc_simplify_dble,\n        gfc_simplify_float, gfc_simplify_real): Ditto.\n\n2007-12-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/34482\n        * gfortran.dg/boz_8.f90: Add error-check check.\n        * gfortran.dg/boz_9.f90: Shorten BOZ where needed, replace\n        stop by call abort.\n\nFrom-SVN: r131098", "tree": {"sha": "c1105d7d38643842a8a83544615c0aaec01a6b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1105d7d38643842a8a83544615c0aaec01a6b80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7abc45c7f097a501a93d0778cfa445745b74d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7abc45c7f097a501a93d0778cfa445745b74d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7abc45c7f097a501a93d0778cfa445745b74d22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7abc45c7f097a501a93d0778cfa445745b74d22/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f411364823c12f94105779db7f8e812b6acbe1a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f411364823c12f94105779db7f8e812b6acbe1a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f411364823c12f94105779db7f8e812b6acbe1a8"}], "stats": {"total": 183, "additions": 121, "deletions": 62}, "files": [{"sha": "4701a2f00c8c98407915b4ce846808ad7297798b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -1,3 +1,16 @@\n+2007-12-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34482\n+\t* gfortran.texi (BOZ): Document behavior for complex\n+\tnumbers.\n+\t* target-memory.h (gfc_convert_boz): Update prototype.\n+\t* target-memory.c (gfc_convert_boz): Add error check\n+\tand convert BOZ to smallest possible bit size.\n+\t* resolve.c (resolve_ordinary_assign): Check return value.\n+\t* expr.c (gfc_check_assign): Ditto.\n+\t* simplify.c (simplify_cmplx, gfc_simplify_dble,\n+\tgfc_simplify_float, gfc_simplify_real): Ditto.\n+\n 2007-12-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/34325"}, {"sha": "8ae84649c80e60ea4405effdcf4d776ae0803c2e", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -2777,7 +2777,8 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n         gfc_warning (\"BOZ literal at %L is bitwise transferred \"\n                      \"non-integer symbol '%s'\", &rvalue->where,\n                      lvalue->symtree->n.sym->name);\n-      gfc_convert_boz (rvalue, &lvalue->ts);\n+      if (!gfc_convert_boz (rvalue, &lvalue->ts))\n+\treturn FAILURE;\n       if ((rc = gfc_range_check (rvalue)) != ARITH_OK)\n \t{\n \t  if (rc == ARITH_UNDERFLOW)"}, {"sha": "43e3d3a1ff6a99063d0ce0ad34769e13768341bd", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -1115,8 +1115,9 @@ DATA statements and the four intrinsic functions allowed by Fortran 2003.\n In DATA statements, in direct assignments, where the right-hand side\n only contains a BOZ literal constant, and for old-style initializers of\n the form @code{integer i /o'0173'/}, the constant is transferred\n-as if @code{TRANSFER} had been used. In all other cases, the BOZ literal\n-constant is converted to an @code{INTEGER} value with\n+as if @code{TRANSFER} had been used; for @code{COMPLEX} numbers, only\n+the real part is initialized unless @code{CMPLX} is used. In all other\n+cases, the BOZ literal constant is converted to an @code{INTEGER} value with\n the largest decimal representation.  This value is then converted\n numerically to the type and kind of the variable in question.\n (For instance @code{real :: r = b'0000001' + 1} initializes @code{r}"}, {"sha": "6289d5d18d6757e71f9a3141506f6ef3d7325294", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -5932,7 +5932,8 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t\t     \"non-integer symbol '%s'\", &code->loc,\n \t\t     lhs->symtree->n.sym->name);\n \n-      gfc_convert_boz (rhs, &lhs->ts);\n+      if (!gfc_convert_boz (rhs, &lhs->ts))\n+\treturn false;\n       if ((rc = gfc_range_check (rhs)) != ARITH_OK)\n \t{\n \t  if (rc == ARITH_UNDERFLOW)"}, {"sha": "be0b18f89ff89f73ce98a65e1acf9b528687704f", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -781,7 +781,8 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n       gfc_typespec ts;\n       ts.kind = result->ts.kind;\n       ts.type = BT_REAL;\n-      gfc_convert_boz (x, &ts);\n+      if (!gfc_convert_boz (x, &ts))\n+\treturn &gfc_bad_expr;\n       mpfr_set (result->value.complex.r, x->value.real, GFC_RND_MODE);\n     }\n \n@@ -790,7 +791,8 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n       gfc_typespec ts;\n       ts.kind = result->ts.kind;\n       ts.type = BT_REAL;\n-      gfc_convert_boz (y, &ts);\n+      if (!gfc_convert_boz (y, &ts))\n+\treturn &gfc_bad_expr;\n       mpfr_set (result->value.complex.i, y->value.real, GFC_RND_MODE);\n     }\n \n@@ -961,7 +963,8 @@ gfc_simplify_dble (gfc_expr *e)\n       ts.type = BT_REAL;\n       ts.kind = gfc_default_double_kind;\n       result = gfc_copy_expr (e);\n-      gfc_convert_boz (result, &ts);\n+      if (!gfc_convert_boz (result, &ts))\n+\treturn &gfc_bad_expr;\n     }\n \n   return range_check (result, \"DBLE\");\n@@ -1150,7 +1153,8 @@ gfc_simplify_float (gfc_expr *a)\n       ts.kind = gfc_default_real_kind;\n \n       result = gfc_copy_expr (a);\n-      gfc_convert_boz (result, &ts);\n+      if (!gfc_convert_boz (result, &ts))\n+\treturn &gfc_bad_expr;\n     }\n   else\n     result = gfc_int2real (a, gfc_default_real_kind);\n@@ -3019,7 +3023,8 @@ gfc_simplify_real (gfc_expr *e, gfc_expr *k)\n       ts.type = BT_REAL;\n       ts.kind = kind;\n       result = gfc_copy_expr (e);\n-      gfc_convert_boz (result, &ts);\n+      if (!gfc_convert_boz (result, &ts))\n+\treturn &gfc_bad_expr;\n     }\n   return range_check (result, \"REAL\");\n }"}, {"sha": "762587767433fb04515bf8b965c6232040ea3467", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -596,26 +596,54 @@ gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, unsigned char *data,\n   return len;\n }\n \n-void\n+\n+/* Transfer the bitpattern of a (integer) BOZ to real or complex variables.\n+   When successful, no BOZ or nothing to do, true is returned.  */\n+\n+bool\n gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n {\n-  size_t buffer_size;\n+  size_t buffer_size, boz_bit_size, ts_bit_size;\n+  int index;\n   unsigned char *buffer;\n \n   if (!expr->is_boz)\n-    return;\n+    return true;\n \n   gcc_assert (expr->expr_type == EXPR_CONSTANT\n \t      && expr->ts.type == BT_INTEGER);\n \n   /* Don't convert BOZ to logical, character, derived etc.  */\n   if (ts->type == BT_REAL)\n-    buffer_size = size_float (ts->kind);\n+    {\n+      buffer_size = size_float (ts->kind);\n+      ts_bit_size = buffer_size * 8;\n+    }\n   else if (ts->type == BT_COMPLEX)\n-    buffer_size = size_complex (ts->kind);\n+    {\n+      buffer_size = size_complex (ts->kind);\n+      ts_bit_size = buffer_size * 8 / 2;\n+    }\n   else\n-    return;\n+    return true;\n+\n+  /* Convert BOZ to the smallest possible integer kind.  */\n+  boz_bit_size = mpz_sizeinbase (expr->value.integer, 2);\n \n+  if (boz_bit_size > ts_bit_size)\n+    {\n+      gfc_error_now (\"BOZ constant at %L is too large (%ld vs %ld bits)\",\n+\t\t     &expr->where, (long) boz_bit_size, (long) ts_bit_size);\n+      return false;\n+    }\n+\n+  for (index = 0; gfc_integer_kinds[index].kind != 0; ++index)\n+    {\n+\tif ((unsigned) gfc_integer_kinds[index].bit_size >= ts_bit_size)\n+\t  break;\n+    }\n+\n+  expr->ts.kind = gfc_integer_kinds[index].kind;\n   buffer_size = MAX (buffer_size, size_integer (expr->ts.kind));\n \n   buffer = (unsigned char*)alloca (buffer_size);\n@@ -637,4 +665,6 @@ gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n   expr->is_boz = 0;  \n   expr->ts.type = ts->type;\n   expr->ts.kind = ts->kind;\n+\n+  return true;\n }"}, {"sha": "a693563bc9b9b1d26894f77bdd8b4fd4831bb750", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n \n /* Convert a BOZ to REAL or COMPLEX.  */\n-void gfc_convert_boz (gfc_expr *, gfc_typespec *);\n+bool gfc_convert_boz (gfc_expr *, gfc_typespec *);\n \n /* Return the size of an expression in its target representation.  */\n size_t gfc_target_expr_size (gfc_expr *);"}, {"sha": "231375bc37420a96184a3dfb980be271c6ee37d1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -1,3 +1,10 @@\n+2007-12-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/34482\n+\t* gfortran.dg/boz_8.f90: Add error-check check.\n+\t* gfortran.dg/boz_9.f90: Shorten BOZ where needed, replace\n+\tstop by call abort.\n+\n 2007-12-19  Zdenek Dvorak  <ook@ucw.cz>\n \n \t* gcc.dg/gomp/combined-1.c: New test."}, {"sha": "effce2ddcd9126b89fd00db9846ed9c46ba3f8bf", "filename": "gcc/testsuite/gfortran.dg/boz_8.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_8.f90?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -13,4 +13,5 @@\n data i/z'111'/, r/z'4455'/ ! { dg-error \"BOZ literal at .1. used to initialize non-integer variable 'r'\" }\n r = z'FFFF' ! { dg-error \"outside a DATA statement\" }\n i = z'4455' ! { dg-error \"outside a DATA statement\" }\n+r = real(z'FFFFFFFFF') ! { dg-error \"is too large\" }\n end"}, {"sha": "e1b0592e67af8a018b8bc5cfbf04157d42a83d73", "filename": "gcc/testsuite/gfortran.dg/boz_9.f90", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abc45c7f097a501a93d0778cfa445745b74d22/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fboz_9.f90?ref=c7abc45c7f097a501a93d0778cfa445745b74d22", "patch": "@@ -20,29 +20,29 @@ program f2003\n complex          :: z1 = cmplx(b'10101',-4.0)\n complex          :: z2 = cmplx(5.0, o'01245')\n \n-if (r2c /= 13107.0) stop '1'\n-if (rc  /= 1.83668190E-41) stop '2'\n-if (dc /= 0.30102999566398120) stop '3'\n-if (real(z1c) /= 2.94272678E-44 .or. aimag(z1c) /= -4.0) stop '4'\n-if (real(z2c) /= 5.0 .or. aimag(z2c) /= 9.48679060E-43) stop '5'\n-\n-if (r2 /= 13107.0) stop '1'\n-if (r  /= 1.83668190E-41) stop '2'\n-if (d /= 0.30102999566398120) stop '3'\n-if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) stop '4'\n-if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) stop '5'\n+if (r2c /= 13107.0) call abort()\n+if (rc  /= 1.83668190E-41) call abort()\n+if (dc /= 0.30102999566398120) call abort()\n+if (real(z1c) /= 2.94272678E-44 .or. aimag(z1c) /= -4.0) call abort()\n+if (real(z2c) /= 5.0 .or. aimag(z2c) /= 9.48679060E-43) call abort()\n+\n+if (r2 /= 13107.0) call abort()\n+if (r  /= 1.83668190E-41) call abort()\n+if (d /= 0.30102999566398120) call abort()\n+if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) call abort()\n+if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) call abort()\n \n r2 = dble(int(z'3333'))\n r = real(z'3333')\n d = dble(Z'3FD34413509F79FF')\n z1 = cmplx(b'10101',-4.0)\n z2 = cmplx(5.0, o'01245')\n \n-if (r2 /= 13107.0) stop '1'\n-if (r  /= 1.83668190E-41) stop '2'\n-if (d /= 0.30102999566398120) stop '3'\n-if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) stop '4'\n-if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) stop '5'\n+if (r2 /= 13107.0) call abort()\n+if (r  /= 1.83668190E-41) call abort()\n+if (d /= 0.30102999566398120) call abort()\n+if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) call abort()\n+if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) call abort()\n \n call test4()\n call test8()\n@@ -60,58 +60,58 @@ subroutine test4\n complex          :: z1 = cmplx(b'10101',-4.0, kind=4)\n complex          :: z2 = cmplx(5.0, o'01245', kind=4)\n \n-if (r2c /= 13107.0) stop '1'\n-if (rc  /= 1.83668190E-41) stop '2'\n-if (real(z1c) /= 2.94272678E-44 .or. aimag(z1c) /= -4.0) stop '4'\n-if (real(z2c) /= 5.0 .or. aimag(z2c) /= 9.48679060E-43) stop '5'\n+if (r2c /= 13107.0) call abort()\n+if (rc  /= 1.83668190E-41) call abort()\n+if (real(z1c) /= 2.94272678E-44 .or. aimag(z1c) /= -4.0) call abort()\n+if (real(z2c) /= 5.0 .or. aimag(z2c) /= 9.48679060E-43) call abort()\n \n-if (r2 /= 13107.0) stop '1'\n-if (r  /= 1.83668190E-41) stop '2'\n-if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) stop '4'\n-if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) stop '5'\n+if (r2 /= 13107.0) call abort()\n+if (r  /= 1.83668190E-41) call abort()\n+if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) call abort()\n+if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) call abort()\n \n r2 = real(int(z'3333'), kind=4)\n r = real(z'3333', kind=4)\n z1 = cmplx(b'10101',-4.0, kind=4)\n z2 = cmplx(5.0, o'01245', kind=4)\n \n-if (r2 /= 13107.0) stop '1'\n-if (r  /= 1.83668190E-41) stop '2'\n-if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) stop '4'\n-if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) stop '5'\n+if (r2 /= 13107.0) call abort()\n+if (r  /= 1.83668190E-41) call abort()\n+if (real(z1) /= 2.94272678E-44 .or. aimag(z1) /= -4.0) call abort()\n+if (real(z2) /= 5.0 .or. aimag(z2) /= 9.48679060E-43) call abort()\n end subroutine test4\n \n \n subroutine test8\n real(8),parameter     :: r2c = real(int(z'FFFFFF3333', kind=8), kind=8)\n-real(8),parameter     :: rc  = real(z'AAAAAAAAAAAAAAAAFFFFFFF3333', kind=8)\n+real(8),parameter     :: rc  = real(z'AAAAAFFFFFFF3333', kind=8)\n complex(8),parameter  :: z1c = cmplx(b'11111011111111111111111111111111111111111111111111111111110101',-4.0, kind=8)\n-complex(8),parameter  :: z2c = cmplx(5.0, o'444444444442222222222233301245', kind=8)\n+complex(8),parameter  :: z2c = cmplx(5.0, o'442222222222233301245', kind=8)\n \n real(8)             :: r2 = real(int(z'FFFFFF3333',kind=8),kind=8)\n-real(8)             :: r  = real(z'AAAAAAAAAAAAAAAAFFFFFFF3333', kind=8)\n+real(8)             :: r  = real(z'AAAAAFFFFFFF3333', kind=8)\n complex(8)          :: z1 = cmplx(b'11111011111111111111111111111111111111111111111111111111110101',-4.0, kind=8)\n-complex(8)          :: z2 = cmplx(5.0, o'444444444442222222222233301245', kind=8)\n+complex(8)          :: z2 = cmplx(5.0, o'442222222222233301245', kind=8)\n \n-if (r2c /= 1099511575347.0d0) stop '1'\n-if (rc  /= -3.72356884822177915d-103) stop '2'\n-if (real(z1c) /= 3.05175781249999627d-5 .or. aimag(z1c) /= -4.0) stop '4'\n-if (real(z2c) /= 5.0 .or. aimag(z2c) /= 3.98227593015308981d41) stop '5'\n+if (r2c /= 1099511575347.0d0) call abort()\n+if (rc  /= -3.72356884822177915d-103) call abort()\n+if (real(z1c) /= 3.05175781249999627d-5 .or. aimag(z1c) /= -4.0) call abort()\n+if (real(z2c) /= 5.0 .or. aimag(z2c) /= 3.98227593015308981d41) call abort()\n \n-if (r2 /= 1099511575347.0d0) stop '1'\n-if (r  /= -3.72356884822177915d-103) stop '2'\n-if (real(z1) /= 3.05175781249999627d-5 .or. aimag(z1) /= -4.0) stop '4'\n-if (real(z2) /= 5.0 .or. aimag(z2) /= 3.98227593015308981d41) stop '5'\n+if (r2 /= 1099511575347.0d0) call abort()\n+if (r  /= -3.72356884822177915d-103) call abort()\n+if (real(z1) /= 3.05175781249999627d-5 .or. aimag(z1) /= -4.0) call abort()\n+if (real(z2) /= 5.0 .or. aimag(z2) /= 3.98227593015308981d41) call abort()\n \n r2 = real(int(z'FFFFFF3333',kind=8),kind=8)\n-r  = real(z'AAAAAAAAAAAAAAAAFFFFFFF3333', kind=8)\n+r  = real(z'AAAAAFFFFFFF3333', kind=8)\n z1 = cmplx(b'11111011111111111111111111111111111111111111111111111111110101',-4.0, kind=8)\n-z2 = cmplx(5.0, o'444444444442222222222233301245', kind=8)\n+z2 = cmplx(5.0, o'442222222222233301245', kind=8)\n \n-if (r2 /= 1099511575347.0d0) stop '1'\n-if (r  /= -3.72356884822177915d-103) stop '2'\n-if (real(z1) /= 3.05175781249999627d-5 .or. aimag(z1) /= -4.0) stop '4'\n-if (real(z2) /= 5.0 .or. aimag(z2) /= 3.98227593015308981d41) stop '5'\n+if (r2 /= 1099511575347.0d0) call abort()\n+if (r  /= -3.72356884822177915d-103) call abort()\n+if (real(z1) /= 3.05175781249999627d-5 .or. aimag(z1) /= -4.0) call abort()\n+if (real(z2) /= 5.0 .or. aimag(z2) /= 3.98227593015308981d41) call abort()\n \n end subroutine test8\n "}]}