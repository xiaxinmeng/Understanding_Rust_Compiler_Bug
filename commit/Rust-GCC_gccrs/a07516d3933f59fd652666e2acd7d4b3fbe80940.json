{"sha": "a07516d3933f59fd652666e2acd7d4b3fbe80940", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA3NTE2ZDM5MzNmNTlmZDY1MjY2NmUyYWNkN2Q0YjNmYmU4MDk0MA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-12-15T21:13:42Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-12-15T21:13:42Z"}, "message": "loop.c (consec_sets_giv): New argument last_consec_insn.\n\n\t* loop.c (consec_sets_giv): New argument last_consec_insn.\n\t(strength_reduce): Provide / use it.\n\nFrom-SVN: r24335", "tree": {"sha": "67ee29efafd184cb8e26398b858d9a2610d40fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67ee29efafd184cb8e26398b858d9a2610d40fd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a07516d3933f59fd652666e2acd7d4b3fbe80940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07516d3933f59fd652666e2acd7d4b3fbe80940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a07516d3933f59fd652666e2acd7d4b3fbe80940", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a07516d3933f59fd652666e2acd7d4b3fbe80940/comments", "author": null, "committer": null, "parents": [{"sha": "ebc5a9c1d3bbe348b3e4d0858821dc8184191923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc5a9c1d3bbe348b3e4d0858821dc8184191923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc5a9c1d3bbe348b3e4d0858821dc8184191923"}], "stats": {"total": 30, "additions": 14, "deletions": 16}, "files": [{"sha": "828390a78517346756a076daeb7b0f614fffcb5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a07516d3933f59fd652666e2acd7d4b3fbe80940/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a07516d3933f59fd652666e2acd7d4b3fbe80940/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a07516d3933f59fd652666e2acd7d4b3fbe80940", "patch": "@@ -1,3 +1,8 @@\n+Wed Dec 16 05:11:04 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (consec_sets_giv): New argument last_consec_insn.\n+\t(strength_reduce): Provide / use it.\n+\n Wed Dec 16 17:24:07 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.h (loop_info): New field 'vtop'."}, {"sha": "83d5cf6453439c20fa2c42be69ba1e448ac53cb7", "filename": "gcc/loop.c", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a07516d3933f59fd652666e2acd7d4b3fbe80940/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a07516d3933f59fd652666e2acd7d4b3fbe80940/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a07516d3933f59fd652666e2acd7d4b3fbe80940", "patch": "@@ -311,7 +311,7 @@ static void update_giv_derive PROTO((rtx));\n static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, rtx *));\n static rtx simplify_giv_expr PROTO((rtx, int *));\n static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n-static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *));\n+static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *, rtx *));\n static int check_dbra_loop PROTO((rtx, int, rtx, struct loop_info *));\n static rtx express_from_1 PROTO((rtx, rtx, rtx));\n static rtx express_from PROTO((struct induction *, struct induction *));\n@@ -3900,6 +3900,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  rtx mult_val;\n \t  int benefit;\n \t  rtx regnote = 0;\n+\t  rtx last_consec_insn;\n \n \t  dest_reg = SET_DEST (set);\n \t  if (REGNO (dest_reg) < FIRST_PSEUDO_REGISTER)\n@@ -3923,7 +3924,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t  /* or all sets must be consecutive and make a giv.  */\n \t\t  || (benefit = consec_sets_giv (benefit, p,\n \t\t\t\t\t\t src_reg, dest_reg,\n-\t\t\t\t\t\t &add_val, &mult_val))))\n+\t\t\t\t\t\t &add_val, &mult_val,\n+\t\t\t\t\t\t &last_consec_insn))))\n \t    {\n \t      int count;\n \t      struct induction *v\n@@ -3935,19 +3937,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\tbenefit += libcall_benefit (p);\n \n \t      /* Skip the consecutive insns, if there are any.  */\n-\t      for (count = VARRAY_INT (n_times_set, REGNO (dest_reg)) - 1;\n-\t\t   count > 0; count--)\n-\t\t{\n-\t\t  /* If first insn of libcall sequence, skip to end.\n-\t\t     Do this at start of loop, since INSN is guaranteed to\n-\t\t     be an insn here.  */\n-\t\t  if (GET_CODE (p) != NOTE\n-\t\t      && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n-\t\t    p = XEXP (temp, 0);\n-\n-\t\t  do p = NEXT_INSN (p);\n-\t\t  while (GET_CODE (p) == NOTE);\n-\t\t}\n+\t      if (VARRAY_INT (n_times_set, REGNO (dest_reg)) != 1)\n+\t\tp = last_consec_insn;\n \n \t      record_giv (v, p, src_reg, dest_reg, mult_val, add_val, benefit,\n \t\t\t  DEST_REG, not_every_iteration, NULL_PTR, loop_start,\n@@ -5997,13 +5988,14 @@ sge_plus (mode, x, y)\n \n static int\n consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n-\t\t add_val, mult_val)\n+\t\t add_val, mult_val, last_consec_insn)\n      int first_benefit;\n      rtx p;\n      rtx src_reg;\n      rtx dest_reg;\n      rtx *add_val;\n      rtx *mult_val;\n+     rtx *last_consec_insn;\n {\n   int count;\n   enum rtx_code code;\n@@ -6077,6 +6069,7 @@ consec_sets_giv (first_benefit, p, src_reg, dest_reg,\n \t}\n     }\n \n+  *last_consec_insn = p;\n   return v->benefit;\n }\n \f"}]}