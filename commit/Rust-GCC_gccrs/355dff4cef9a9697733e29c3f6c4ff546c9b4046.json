{"sha": "355dff4cef9a9697733e29c3f6c4ff546c9b4046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1ZGZmNGNlZjlhOTY5NzczM2UyOWMzZjZjNGZmNTQ2YzliNDA0Ng==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-01-26T23:56:36Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-01-26T23:56:36Z"}, "message": "method.h (JvNumMethods): Moved from Class.h.\n\n\t* gcj/method.h (JvNumMethods): Moved from Class.h.\n\t(JvGetFirstMethod): Likewise.\n\t* java/lang/Class.h (Object): Updated decl of\n\t_Jv_JNI_ToReflectedField.\n\t(Object): Added _Jv_JNI_ToReflectedMethod as a friend.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (java/lang/reflect/Field.h): Added `jboolean'\n\targument of _Jv_JNI_ToReflectedField.\n\t(java/lang/reflect/Constructor.h): Added _Jv_JNI_ToReflectedMethod\n\tas a friend.\n\t(java/lang/reflect/Method.h): Likewise.\n\t* include/jni.h (class _Jv_JNIEnv): Added `klass' member.  Use\n\t__GCJ_JNI_IMPL__.\n\t(jweak): New typedef.\n\t(struct JNINativeInterface): Correctly declare remaining entries.\n\t* jni.cc: Include Class.h, ClassLoader.h.\n\t(_Jv_JNI_FindClass): New function.\n\t(_Jv_JNI_DefineClass): New function.\n\t(_Jv_JNI_conversion_call): New function.\n\t(_Jv_JNI_FindClass): Use current class loader to find class.\n\t(_Jv_JNI_ExceptionCheck): New function.\n\t(_Jv_JNI_FromReflectedField): Now static.\n\t(MethodClass): New define.\n\t(_Jv_JNI_FromReflectedMethod): New function.\n\t(_Jv_JNI_ToReflectedMethod): Likewise.\n\tInclude Method.h.\n\t(_Jv_JNI_IsAssignableFrom): Renamed.\n\t(_Jv_JNI_GetStringRegion): New function.\n\tInclude StringIndexOutOfBoundsException.h.\n\t(_Jv_JNI_GetStringUTFRegion): New function.\n\t(_Jv_JNIFunctions): Updated for new functions.\n\t(_Jv_JNI_GetPrimitiveArrayCritical): New function\n\t(_Jv_JNI_ReleasePrimitiveArrayCritical): Likewise.\n\t(_Jv_JNI_GetStringCritical): New function.\n\t(_Jv_JNI_ReleaseStringCritical): Likewise.\n\t(get_throwable): Removed.\n\t(GCJ_JV_JNIENV_FRIEND): Removed.\n\t(__GCJ_JNI_IMPL__): Define.\n\tInclude method.h.\n\nFrom-SVN: r31638", "tree": {"sha": "183896886d52c6412a2339fe8a27adf081f0cb6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/183896886d52c6412a2339fe8a27adf081f0cb6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355dff4cef9a9697733e29c3f6c4ff546c9b4046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355dff4cef9a9697733e29c3f6c4ff546c9b4046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355dff4cef9a9697733e29c3f6c4ff546c9b4046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355dff4cef9a9697733e29c3f6c4ff546c9b4046/comments", "author": null, "committer": null, "parents": [{"sha": "673fdf6d778614d291d139ed4beecea7df6a014d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673fdf6d778614d291d139ed4beecea7df6a014d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673fdf6d778614d291d139ed4beecea7df6a014d"}], "stats": {"total": 459, "additions": 367, "deletions": 92}, "files": [{"sha": "bfd61f03c1cca8cbb36a91c8bc8496c42063bf58", "filename": "libjava/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -1,5 +1,45 @@\n 2000-01-26  Tom Tromey  <tromey@cygnus.com>\n \n+\t* gcj/method.h (JvNumMethods): Moved from Class.h.\n+\t(JvGetFirstMethod): Likewise.\n+\t* java/lang/Class.h (Object): Updated decl of\n+\t_Jv_JNI_ToReflectedField.\n+\t(Object): Added _Jv_JNI_ToReflectedMethod as a friend.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (java/lang/reflect/Field.h): Added `jboolean'\n+\targument of _Jv_JNI_ToReflectedField.\n+\t(java/lang/reflect/Constructor.h): Added _Jv_JNI_ToReflectedMethod\n+\tas a friend.\n+\t(java/lang/reflect/Method.h): Likewise.\n+\t* include/jni.h (class _Jv_JNIEnv): Added `klass' member.  Use\n+\t__GCJ_JNI_IMPL__.\n+\t(jweak): New typedef.\n+\t(struct JNINativeInterface): Correctly declare remaining entries.\n+\t* jni.cc: Include Class.h, ClassLoader.h.\n+\t(_Jv_JNI_FindClass): New function.\n+\t(_Jv_JNI_DefineClass): New function.\n+\t(_Jv_JNI_conversion_call): New function.\n+\t(_Jv_JNI_FindClass): Use current class loader to find class.\n+\t(_Jv_JNI_ExceptionCheck): New function.\n+\t(_Jv_JNI_FromReflectedField): Now static.\n+\t(MethodClass): New define.\n+\t(_Jv_JNI_FromReflectedMethod): New function.\n+\t(_Jv_JNI_ToReflectedMethod): Likewise.\n+\tInclude Method.h.\n+\t(_Jv_JNI_IsAssignableFrom): Renamed.\n+\t(_Jv_JNI_GetStringRegion): New function.\n+\tInclude StringIndexOutOfBoundsException.h.\n+\t(_Jv_JNI_GetStringUTFRegion): New function.\n+\t(_Jv_JNIFunctions): Updated for new functions.\n+\t(_Jv_JNI_GetPrimitiveArrayCritical): New function\n+\t(_Jv_JNI_ReleasePrimitiveArrayCritical): Likewise.\n+\t(_Jv_JNI_GetStringCritical): New function.\n+\t(_Jv_JNI_ReleaseStringCritical): Likewise.\n+\t(get_throwable): Removed.\n+\t(GCJ_JV_JNIENV_FRIEND): Removed.\n+\t(__GCJ_JNI_IMPL__): Define.\n+\tInclude method.h.\n+\n \t* resolve.cc (get_ffi_type_from_signature): Handle case where\n \tboolean is an int.\n "}, {"sha": "a8765a2447885e6b184a65c8cb1433d86f7e2e4b", "filename": "libjava/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -235,19 +235,21 @@ java/lang/reflect/Constructor.h: java/lang/reflect/Constructor.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);' \\\n \t    -friend 'java::lang::Class;' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);' \\\n \t    $(basename $<)\n \n java/lang/reflect/Field.h: java/lang/reflect/Field.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);' \\\n-\t    -friend 'jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv*, jclass, jfieldID);' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv*, jclass, jfieldID, jboolean);' \\\n \t    -friend 'java::lang::Class;' \\\n \t    $(basename $<)\n \n java/lang/reflect/Method.h: java/lang/reflect/Method.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);' \\\n \t    -friend 'java::lang::Class;' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);' \\\n \t    $(basename $<)\n \n gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class libgcj.zip"}, {"sha": "f6818b36b51bb3feb7e13aa2641ed9200831eea1", "filename": "libjava/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -1553,19 +1553,21 @@ java/lang/reflect/Constructor.h: java/lang/reflect/Constructor.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jmethodID _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *);' \\\n \t    -friend 'java::lang::Class;' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);' \\\n \t    $(basename $<)\n \n java/lang/reflect/Field.h: java/lang/reflect/Field.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);' \\\n-\t    -friend 'jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv*, jclass, jfieldID);' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv*, jclass, jfieldID, jboolean);' \\\n \t    -friend 'java::lang::Class;' \\\n \t    $(basename $<)\n \n java/lang/reflect/Method.h: java/lang/reflect/Method.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);' \\\n \t    -friend 'java::lang::Class;' \\\n+\t    -friend 'jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID, jboolean);' \\\n \t    $(basename $<)\n \n gnu/gcj/runtime/VMClassLoader.h: gnu/gcj/runtime/VMClassLoader.class libgcj.zip"}, {"sha": "fa3484dcff01a2c39907b0f32ba168bfccd18780", "filename": "libjava/gcj/method.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Fgcj%2Fmethod.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Fgcj%2Fmethod.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fmethod.h?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -27,4 +27,16 @@ _Jv_FromReflectedConstructor (java::lang::reflect::Constructor *constructor)\n     ((char *) constructor->declaringClass->methods + constructor->offset);\n }\n \n+extern inline jint\n+JvNumMethods (jclass klass)\n+{\n+  return klass->method_count;\n+}\n+\n+extern inline jmethodID\n+JvGetFirstMethod (jclass klass)\n+{\n+  return &klass->methods[0];\n+}\n+\n #endif /* __GCJ_METHOD_H__ */"}, {"sha": "60b2302754a80bc46c97d7246b743bcebcb21617", "filename": "libjava/include/jni.h", "status": "modified", "additions": 68, "deletions": 35, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -65,6 +65,9 @@ typedef const struct JNINativeInterface *JNIEnv;\n \n #endif /* __cplusplus */\n \n+/* FIXME: this is wrong.  */\n+typedef jobject jweak;\n+\n /* Version numbers.  */\n #define JNI_VERSION_1_1 0x00010001\n #define JNI_VERSION_1_2 0x00010002\n@@ -88,35 +91,57 @@ typedef union jvalue\n \n typedef void * (*_Jv_func)(...);\n \n+/* This structure is used when registering native methods.  */\n+typedef struct\n+{\n+  char *name;\n+  char *signature;\n+  void *fnPtr;\t\t\t/* Sigh.  */\n+} JNINativeMethod;\n+\n+/* FIXME: this is just a placeholder.  */\n+typedef int JavaVM;\n+\n struct JNINativeInterface\n {\n   _Jv_func reserved0;\n   _Jv_func reserved1;\n   _Jv_func reserved2;\n   _Jv_func reserved3;\n-  jint     (*GetVersion)                   (JNIEnv*);\n-  _Jv_func DefineClass;\n-  _Jv_func FindClass;\n-  _Jv_func reserved4;\n-  _Jv_func reserved5;\n-  _Jv_func reserved6;\n-  jclass   (*GetSuperclass)                (JNIEnv*, jclass);\n-  jboolean (*IsAssignableFrom)             (JNIEnv*, jclass, jclass);\n-  _Jv_func reserved7;\n-  jint     (*Throw)                        (JNIEnv*, jthrowable);\n-  jint     (*ThrowNew)                     (JNIEnv*, jclass, const char *);\n+\n+  jint     (*GetVersion)                   (JNIEnv *);\n+  jclass   (*DefineClass)                  (JNIEnv *, jobject,\n+\t\t\t\t\t    const jbyte *, jsize);\n+  jclass   (*FindClass)                    (JNIEnv *, const char *);\n+\n+  jmethodID (*FromReflectedMethod)\t   (JNIEnv *, jobject);\n+  jfieldID  (*FromReflectedField)\t   (JNIEnv *, jobject);\n+  jobject   (*ToReflectedMethod)\t   (JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jboolean);\n+\n+  jclass   (*GetSuperclass)                (JNIEnv *, jclass);\n+  jboolean (*IsAssignableFrom)             (JNIEnv *, jclass, jclass);\n+\n+  jobject  (*ToReflectedField)\t\t   (JNIEnv *, jclass, jfieldID,\n+\t\t\t\t\t    jboolean);\n+\n+  jint     (*Throw)                        (JNIEnv *, jthrowable);\n+  jint     (*ThrowNew)                     (JNIEnv *, jclass, const char *);\n   jthrowable (*ExceptionOccurred)          (JNIEnv *);\n   void     (*ExceptionDescribe)            (JNIEnv *);\n   void     (*ExceptionClear)               (JNIEnv *);\n   void     (*FatalError)                   (JNIEnv *, const char *);\n-  _Jv_func reserved8;\n-  _Jv_func reserved9;\n-  _Jv_func NewGlobalRef;\n-  _Jv_func DeleteGlobalRef;\n-  _Jv_func DeleteLocalRef;\n+\n+  jint     (*PushLocalFrame)\t\t   (JNIEnv *, jint);\n+  jobject  (*PopLocalFrame)\t\t   (JNIEnv *, jobject result);\n+\n+  jobject  (*NewGlobalRef)                 (JNIEnv *, jobject);\n+  void     (*DeleteGlobalRef)              (JNIEnv *, jobject);\n+  void     (*DeleteLocalRef)               (JNIEnv *, jobject);;\n   jboolean (*IsSameObject)                 (JNIEnv *, jobject, jobject);\n-  _Jv_func reserved10;\n-  _Jv_func reserved11;\n+\n+  jobject  (*NewLocalRef)\t\t   (JNIEnv *, jobject);\n+  jint     (*EnsureLocalCapacity)\t   (JNIEnv *, jint);\n \n   jobject  (*AllocObject)                  (JNIEnv *, jclass);\n   jobject (*NewObject)\t\t\t   (JNIEnv *, jclass, jmethodID, ...);\n@@ -471,20 +496,29 @@ struct JNINativeInterface\n   void \t\t(*SetDoubleArrayRegion)\t   (JNIEnv *, jbooleanArray,\n \t\t\t\t\t    jsize, jsize, jboolean *);\n \n-  _Jv_func RegisterNatives;\n-  _Jv_func UnregisterNatives;\n+  jint     (*RegisterNatives)              (JNIEnv *, jclass,\n+\t\t\t\t\t    const JNINativeMethod *, jint);\n+  jint     (*UnregisterNatives)            (JNIEnv *, jclass);\n   jint     (*MonitorEnter)                 (JNIEnv *, jobject);\n   jint     (*MonitorExit)                  (JNIEnv *, jobject);\n-  _Jv_func GetJavaVM;\n-};\n+  jint     (*GetJavaVM)                    (JNIEnv *, JavaVM **);\n \n-/* This structure is used when registering native methods.  */\n-typedef struct\n-{\n-  char *name;\n-  char *signature;\n-  void *fnPtr;\t\t\t/* Sigh.  */\n-} JNINativeMethod;\n+  void\t   (*GetStringRegion)\t           (JNIEnv *, jstring, jsize,\n+\t\t\t\t\t    jsize, jchar *);\n+  void     (*GetStringUTFRegion)\t   (JNIEnv *, jstring, jsize,\n+\t\t\t\t\t    jsize, char *);\n+\n+  void * (*GetPrimitiveArrayCritical)      (JNIEnv *, jarray, jboolean *);\n+  void   (*ReleasePrimitiveArrayCritical)  (JNIEnv *, jarray, void *, jint);\n+\n+  const jchar * (*GetStringCritical)       (JNIEnv *, jstring, jboolean *);\n+  void          (*ReleaseStringCritical)   (JNIEnv *, jstring, const jchar *);\n+\n+  jweak  (*NewWeakGlobalRef)               (JNIEnv *, jobject);\n+  void   (*DeleteWeakGlobalRef)            (JNIEnv *, jweak);\n+\n+  jboolean\t(*ExceptionCheck)\t   (JNIEnv *);\n+};\n \n #ifdef __cplusplus\n \n@@ -494,16 +528,15 @@ class _Jv_JNIEnv\n   /* The method table.  */\n   struct JNINativeInterface *p;\n \n+  /* FIXME: this is really ugly.  */\n+#ifndef __GCJ_JNI_IMPL__\n private:\n+#endif\n   /* The current exception.  */\n   jthrowable ex;\n \n-  /* This doesn't really protect the private contents, because anybody\n-     can set this macro.  However, if they do set it then they at\n-     least know they are doing something unportable.  */\n-#ifdef GCJ_JV_JNIENV_FRIEND\n-  GCJ_JV_JNIENV_FRIEND;\n-#endif\n+  /* The class of the current native method.  */\n+  jclass klass;\n \n public:\n   jclass GetSuperclass (jclass cl)"}, {"sha": "2ad6c5d64009fa64c7917045ed8519e781988b08", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -177,7 +177,11 @@ class java::lang::Class : public java::lang::Object\n   friend jobject _Jv_AllocObject (jclass, jint);\n   friend jobjectArray _Jv_NewObjectArray (jsize, jclass, jobject);\n   friend jobject _Jv_NewPrimArray (jclass, jint);\n-  friend jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv *, jclass, jfieldID);\n+\n+  friend jobject _Jv_JNI_ToReflectedField (_Jv_JNIEnv *, jclass, jfieldID,\n+\t\t\t\t\t   jboolean);\n+  friend jobject _Jv_JNI_ToReflectedMethod (_Jv_JNIEnv *, jclass, jmethodID,\n+\t\t\t\t\t    jboolean);\n   friend jfieldID _Jv_FromReflectedField (java::lang::reflect::Field *);\n \n   friend jmethodID _Jv_FromReflectedMethod (java::lang::reflect::Method *);\n@@ -266,17 +270,4 @@ class java::lang::Class : public java::lang::Object\n   java::lang::Thread *thread;\n };\n \n-\n-extern inline jint\n-JvNumMethods (jclass klass)\n-{\n-  return klass->method_count;\n-}\n-\n-extern inline jmethodID\n-JvGetFirstMethod (jclass klass)\n-{\n-  return &klass->methods[0];\n-}\n-\n #endif /* __JAVA_LANG_CLASS_H__ */"}, {"sha": "e67bd8cc7a878f1b526a5ab8abb7b8858b79de74", "filename": "libjava/jni.cc", "status": "modified", "additions": 236, "deletions": 41, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355dff4cef9a9697733e29c3f6c4ff546c9b4046/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=355dff4cef9a9697733e29c3f6c4ff546c9b4046", "patch": "@@ -18,28 +18,37 @@ details.  */\n \n #include <stddef.h>\n \n-// Must define this before jni.h.\n-#define GCJ_JV_JNIENV_FRIEND \\\n-    friend jthrowable &get_throwable (JNIEnv *)\n+// Define this before including jni.h.\n+#define __GCJ_JNI_IMPL__\n \n #include <gcj/cni.h>\n #include <jvm.h>\n #include <java-assert.h>\n #include <jni.h>\n-#include <gcj/field.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/ClassLoader.h>\n #include <java/lang/Throwable.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/StringIndexOutOfBoundsException.h>\n #include <java/lang/InstantiationException.h>\n #include <java/lang/NoSuchFieldError.h>\n #include <java/lang/NoSuchMethodError.h>\n #include <java/lang/reflect/Constructor.h>\n+#include <java/lang/reflect/Method.h>\n #include <java/lang/reflect/Modifier.h>\n \n+#include <gcj/method.h>\n+#include <gcj/field.h>\n+\n #define ClassClass _CL_Q34java4lang5Class\n extern java::lang::Class ClassClass;\n #define ObjectClass _CL_Q34java4lang6Object\n extern java::lang::Class ObjectClass;\n \n+#define MethodClass _CL_Q44java4lang7reflect6Method\n+extern java::lang::Class MethodClass;\n+\n // This enum is used to select different template instantiations in\n // the invocation code.\n enum invocation_type\n@@ -50,6 +59,9 @@ enum invocation_type\n   constructor\n };\n \n+// Forward declaration.\n+extern struct JNINativeInterface _Jv_JNIFunctions;\n+\n \f\n \n // Tell the GC that a certain pointer is live.\n@@ -66,13 +78,6 @@ unmark_for_gc (void *)\n   // FIXME.\n }\n \n-// Return throwable in env.\n-jthrowable &\n-get_throwable (JNIEnv *env)\n-{\n-  return env->ex;\n-}\n-\n \f\n \n static jint\n@@ -81,22 +86,64 @@ _Jv_JNI_GetVersion (JNIEnv *)\n   return JNI_VERSION_1_2;\n }\n \n+static jclass\n+_Jv_JNI_DefineClass (JNIEnv *, jobject loader, \n+\t\t     const jbyte *buf, jsize bufLen)\n+{\n+  jbyteArray bytes = JvNewByteArray (bufLen);\n+  jbyte *elts = elements (bytes);\n+  memcpy (elts, buf, bufLen * sizeof (jbyte));\n+\n+  java::lang::ClassLoader *l\n+    = reinterpret_cast<java::lang::ClassLoader *> (loader);\n+\n+  // FIXME: exception processing.\n+  jclass result = l->defineClass (bytes, 0, bufLen);\n+  return result;\n+}\n+\n+static jclass\n+_Jv_JNI_FindClass (JNIEnv *env, const char *name)\n+{\n+  // FIXME: assume that NAME isn't too long.\n+  int len = strlen (name);\n+  char s[len + 1];\n+  for (int i = 0; i <= len; ++i)\n+    s[i] = (name[i] == '/') ? '.' : name[i];\n+  jstring n = JvNewStringUTF (s);\n+\n+  java::lang::ClassLoader *loader;\n+  if (env->klass == NULL)\n+    {\n+      // FIXME: should use getBaseClassLoader, but we don't have that\n+      // yet.\n+      loader = java::lang::ClassLoader::getSystemClassLoader ();\n+    }\n+  else\n+    loader = env->klass->getClassLoader ();\n+\n+  // FIXME: exception processing.\n+  jclass r = loader->findClass (n);\n+\n+  return r;\n+}\n+\n static jclass\n _Jv_JNI_GetSuperclass (JNIEnv *, jclass clazz)\n {\n   return clazz->getSuperclass ();\n }\n \n static jboolean\n-IsAssignableFrom(JNIEnv *, jclass clazz1, jclass clazz2)\n+_Jv_JNI_IsAssignableFrom(JNIEnv *, jclass clazz1, jclass clazz2)\n {\n   return clazz1->isAssignableFrom (clazz2);\n }\n \n static jint\n _Jv_JNI_Throw (JNIEnv *env, jthrowable obj)\n {\n-  get_throwable (env) = obj;\n+  env->ex = obj;\n   return 0;\n }\n \n@@ -121,27 +168,34 @@ _Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n   // FIXME: exception processing.\n   jobject obj = cons->newInstance (values);\n \n-  get_throwable (env) = reinterpret_cast<jthrowable> (obj);\n+  env->ex = reinterpret_cast<jthrowable> (obj);\n   return 0;\n }\n \n static jthrowable\n _Jv_JNI_ExceptionOccurred (JNIEnv *env)\n {\n-  return get_throwable (env);\n+  // FIXME: create local reference.\n+  return env->ex;\n }\n \n static void\n _Jv_JNI_ExceptionDescribe (JNIEnv *env)\n {\n-  if (get_throwable (env) != NULL)\n-    get_throwable (env)->printStackTrace();\n+  if (env->ex != NULL)\n+    env->ex->printStackTrace();\n }\n \n static void\n _Jv_JNI_ExceptionClear (JNIEnv *env)\n {\n-  get_throwable (env) = NULL;\n+  env->ex = NULL;\n+}\n+\n+static jboolean\n+_Jv_JNI_ExceptionCheck (JNIEnv *env)\n+{\n+  return env->ex != NULL;\n }\n \n static void\n@@ -162,7 +216,7 @@ _Jv_JNI_AllocObject (JNIEnv *env, jclass clazz)\n   jobject obj = NULL;\n   using namespace java::lang::reflect;\n   if (clazz->isInterface() || Modifier::isAbstract(clazz->getModifiers()))\n-    get_throwable (env) = new java::lang::InstantiationException ();\n+    env->ex = new java::lang::InstantiationException ();\n   else\n     {\n       // FIXME: exception processing.\n@@ -225,7 +279,7 @@ _Jv_JNI_GetAnyMethodID (JNIEnv *env, jclass clazz,\n       clazz = clazz->getSuperclass ();\n     }\n \n-  get_throwable (env) = new java::lang::NoSuchMethodError ();\n+  env->ex = new java::lang::NoSuchMethodError ();\n   return NULL;\n }\n \n@@ -290,7 +344,7 @@ _Jv_JNI_CallAnyMethodV (JNIEnv *env, jobject obj, jclass klass,\n \t\t\t\t      arg_types, args, &result);\n \n   if (ex != NULL)\n-    get_throwable (env) = ex;\n+    env->ex = ex;\n \n   // We cheat a little here.  FIXME.\n   return * (T *) &result;\n@@ -334,7 +388,7 @@ _Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n \t\t\t\t      arg_types, args, &result);\n \n   if (ex != NULL)\n-    get_throwable (env) = ex;\n+    env->ex = ex;\n \n   // We cheat a little here.  FIXME.\n   return * (T *) &result;\n@@ -365,7 +419,7 @@ _Jv_JNI_CallAnyVoidMethodV (JNIEnv *env, jobject obj, jclass klass,\n \t\t\t\t      arg_types, args, NULL);\n \n   if (ex != NULL)\n-    get_throwable (env) = ex;\n+    env->ex = ex;\n }\n \n template<invocation_type style>\n@@ -402,7 +456,7 @@ _Jv_JNI_CallAnyVoidMethodA (JNIEnv *env, jobject obj, jclass klass,\n \t\t\t\t      arg_types, args, NULL);\n \n   if (ex != NULL)\n-    get_throwable (env) = ex;\n+    env->ex = ex;\n }\n \n // Functions with this signature are used to implement functions in\n@@ -617,7 +671,7 @@ _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n       clazz = clazz->getSuperclass ();\n     }\n \n-  get_throwable (env) = new java::lang::NoSuchFieldError ();\n+  env->ex = new java::lang::NoSuchFieldError ();\n   return NULL;\n }\n \n@@ -702,6 +756,44 @@ _Jv_JNI_ReleaseStringUTFChars (JNIEnv *, jstring, const char *utf)\n   _Jv_Free ((void *) utf);\n }\n \n+static void\n+_Jv_JNI_GetStringRegion (JNIEnv *env, jstring string, jsize start, jsize len,\n+\t\t\t jchar *buf)\n+{\n+  jchar *result = _Jv_GetStringChars (string);\n+  if (start < 0 || start > string->length ()\n+      || len < 0 || start + len > string->length ())\n+    env->ex = new java::lang::StringIndexOutOfBoundsException ();\n+  else\n+    memcpy (buf, &result[start], len * sizeof (jchar));\n+}\n+\n+static void\n+_Jv_JNI_GetStringUTFRegion (JNIEnv *env, jstring str, jsize start,\n+\t\t\t    jsize len, char *buf)\n+{\n+  if (start < 0 || start > str->length ()\n+      || len < 0 || start + len > str->length ())\n+    env->ex = new java::lang::StringIndexOutOfBoundsException ();\n+  else\n+    _Jv_GetStringUTFRegion (str, start, len, buf);\n+}\n+\n+static const jchar *\n+_Jv_JNI_GetStringCritical (JNIEnv *, jstring str, jboolean *isCopy)\n+{\n+  jchar *result = _Jv_GetStringChars (str);\n+  if (isCopy)\n+    *isCopy = false;\n+  return result;\n+}\n+\n+static void\n+_Jv_JNI_ReleaseStringCritical (JNIEnv *, jstring, const jchar *)\n+{\n+  // Nothing.\n+}\n+\n static jsize\n _Jv_JNI_GetArrayLength (JNIEnv *, jarray array)\n {\n@@ -776,7 +868,7 @@ _Jv_JNI_GetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n   if (start < 0 || len >= array->length || start + len >= array->length)\n     {\n       // FIXME: index.\n-      get_throwable (env) = new java::lang::ArrayIndexOutOfBoundsException ();\n+      env->ex = new java::lang::ArrayIndexOutOfBoundsException ();\n     }\n   else\n     {\n@@ -793,7 +885,7 @@ _Jv_JNI_SetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n   if (start < 0 || len >= array->length || start + len >= array->length)\n     {\n       // FIXME: index.\n-      get_throwable (env) = new java::lang::ArrayIndexOutOfBoundsException ();\n+      env->ex = new java::lang::ArrayIndexOutOfBoundsException ();\n     }\n   else\n     {\n@@ -802,6 +894,25 @@ _Jv_JNI_SetPrimitiveArrayRegion (JNIEnv *env, JArray<T> *array,\n     }\n }\n \n+static void *\n+_Jv_JNI_GetPrimitiveArrayCritical (JNIEnv *, jarray array,\n+\t\t\t\t   jboolean *isCopy)\n+{\n+  // FIXME: does this work?\n+  jclass klass = array->getClass()->getComponentType();\n+  JvAssert (klass->isPrimitive ());\n+  char *r = _Jv_GetArrayElementFromElementType (array, klass);\n+  if (isCopy)\n+    *isCopy = false;\n+  return r;\n+}\n+\n+static void\n+_Jv_JNI_ReleasePrimitiveArrayCritical (JNIEnv *, jarray, void *, jint)\n+{\n+  // Nothing.\n+}\n+\n static jint\n _Jv_JNI_MonitorEnter (JNIEnv *, jobject obj)\n {\n@@ -820,22 +931,94 @@ _Jv_JNI_MonitorExit (JNIEnv *, jobject obj)\n \n // JDK 1.2\n jobject\n-_Jv_JNI_ToReflectedField (JNIEnv *, jclass cls, jfieldID fieldID)\n+_Jv_JNI_ToReflectedField (JNIEnv *, jclass cls, jfieldID fieldID,\n+\t\t\t  jboolean)\n {\n+  // FIXME: exception processing.\n   java::lang::reflect::Field *field = new java::lang::reflect::Field();\n   field->declaringClass = cls;\n   field->offset = (char*) fieldID - (char *) cls->fields;\n   field->name = _Jv_NewStringUtf8Const (fieldID->getNameUtf8Const (cls));\n+  // FIXME: make a local reference.\n   return field;\n }\n \n // JDK 1.2\n-jfieldID\n-_Jv_JNI_FromReflectedField (JNIEnv *, java::lang::reflect::Field *field)\n+static jfieldID\n+_Jv_JNI_FromReflectedField (JNIEnv *, jobject f)\n {\n+  using namespace java::lang::reflect;\n+\n+  Field *field = reinterpret_cast<Field *> (f);\n   return _Jv_FromReflectedField (field);\n }\n \n+jobject\n+_Jv_JNI_ToReflectedMethod (JNIEnv *, jclass klass, jmethodID id,\n+\t\t\t   jboolean)\n+{\n+  using namespace java::lang::reflect;\n+\n+  // FIXME.\n+  static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n+\n+  jobject result;\n+  if (_Jv_equalUtf8Consts (id->name, init_name))\n+    {\n+      // A constructor.\n+      Constructor *cons = new Constructor ();\n+      cons->offset = (char *) id - (char *) &klass->methods;\n+      cons->declaringClass = klass;\n+      result = cons;\n+    }\n+  else\n+    {\n+      Method *meth = new Method ();\n+      meth->offset = (char *) id - (char *) &klass->methods;\n+      meth->declaringClass = klass;\n+      result = meth;\n+    }\n+\n+  // FIXME: make a local reference.\n+  return result;\n+}\n+\n+static jmethodID\n+_Jv_JNI_FromReflectedMethod (JNIEnv *, jobject method)\n+{\n+  using namespace java::lang::reflect;\n+  if ((&MethodClass)->isInstance (method))\n+    return _Jv_FromReflectedMethod (reinterpret_cast<Method *> (method));\n+  return\n+    _Jv_FromReflectedConstructor (reinterpret_cast<Constructor *> (method));\n+}\n+\n+\f\n+\n+// This function is the stub which is used to turn an ordinary (CNI)\n+// method call into a JNI call.\n+#if 0\n+template<typename T>\n+static T\n+_Jv_JNI_conversion_call (fixme)\n+{\n+  JNIEnv env;\n+\n+  env.p = &_Jv_JNIFunctions;\n+  env.ex = NULL;\n+  env.klass = FIXME;\n+\n+  T result = FIXME_ffi_call (args);\n+\n+  if (env.ex)\n+    JvThrow (env.ex);\n+\n+  return T;\n+}\n+#endif\n+\n+\f\n+\n #define NOT_IMPL NULL\n #define RESERVED NULL\n \n@@ -846,28 +1029,28 @@ struct JNINativeInterface _Jv_JNIFunctions =\n   RESERVED,\n   RESERVED,\n   _Jv_JNI_GetVersion,\n-  NOT_IMPL /* DefineClass */,\n-  NOT_IMPL /* FindClass */,\n-  RESERVED,\n-  RESERVED,\n-  RESERVED,\n+  _Jv_JNI_DefineClass,\n+  _Jv_JNI_FindClass,\n+  _Jv_JNI_FromReflectedMethod,\n+  _Jv_JNI_FromReflectedField,\n+  _Jv_JNI_ToReflectedMethod,\n   _Jv_JNI_GetSuperclass,\n-  IsAssignableFrom,\n-  RESERVED,\n+  _Jv_JNI_IsAssignableFrom,\n+  _Jv_JNI_ToReflectedField,\n   _Jv_JNI_Throw,\n   _Jv_JNI_ThrowNew,\n   _Jv_JNI_ExceptionOccurred,\n   _Jv_JNI_ExceptionDescribe,\n   _Jv_JNI_ExceptionClear,\n   _Jv_JNI_FatalError,\n-  RESERVED,\n-  RESERVED,\n+  NOT_IMPL,\n+  NOT_IMPL,\n   NOT_IMPL /* NewGlobalRef */,\n   NOT_IMPL /* DeleteGlobalRef */,\n   NOT_IMPL /* DeleteLocalRef */,\n   _Jv_JNI_IsSameObject,\n-  RESERVED,\n-  RESERVED,\n+  NOT_IMPL,\n+  NOT_IMPL,\n   _Jv_JNI_AllocObject,\n   _Jv_JNI_NewObject,\n   _Jv_JNI_NewObjectV,\n@@ -1067,4 +1250,16 @@ struct JNINativeInterface _Jv_JNIFunctions =\n   _Jv_JNI_MonitorEnter,\n   _Jv_JNI_MonitorExit,\n   NOT_IMPL /* GetJavaVM */,\n+\n+  _Jv_JNI_GetStringRegion,\n+  _Jv_JNI_GetStringUTFRegion,\n+  _Jv_JNI_GetPrimitiveArrayCritical,\n+  _Jv_JNI_ReleasePrimitiveArrayCritical,\n+  _Jv_JNI_GetStringCritical,\n+  _Jv_JNI_ReleaseStringCritical,\n+\n+  NOT_IMPL /* newweakglobalref */,\n+  NOT_IMPL /* deleteweakglobalref */,\n+\n+  _Jv_JNI_ExceptionCheck\n };"}]}