{"sha": "63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyODdlMTBhODUyN2Y5ZWQ5ZDdjMzkzOTk0M2FiMWJjNjZhYTQ2Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-12-31T18:05:10Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-12-31T18:05:10Z"}, "message": "re PR fortran/34558 (ICE with same TYPE in both program and interface)\n\n2007-12-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34558\n\t* interface.c (gfc_compare_types): Prevent linked lists from\n\tputting this function into an endless recursive loop.\n\n2007-12-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34558\n\t* gfortran.dg/linked_list_1.f90: New test.\n\nFrom-SVN: r131238", "tree": {"sha": "daf721ae8c46819c335ccc6f7647203507b90390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daf721ae8c46819c335ccc6f7647203507b90390"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/comments", "author": null, "committer": null, "parents": [{"sha": "881466d851f3c806692bda4569a4534d89848104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/881466d851f3c806692bda4569a4534d89848104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/881466d851f3c806692bda4569a4534d89848104"}], "stats": {"total": 55, "additions": 54, "deletions": 1}, "files": [{"sha": "8b92ad1aa3188f34d2a7fd3e2046b4fee574d790", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "patch": "@@ -1,3 +1,9 @@\n+2007-12-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34558\n+\t* interface.c (gfc_compare_types): Prevent linked lists from\n+\tputting this function into an endless recursive loop.\n+\n 2007-12-26  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/34532"}, {"sha": "717f3b78258d2ccc5e340dec10be47518e5d3c2e", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "patch": "@@ -407,7 +407,17 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n       if (dt1->dimension && gfc_compare_array_spec (dt1->as, dt2->as) == 0)\n \treturn 0;\n \n-      if (gfc_compare_types (&dt1->ts, &dt2->ts) == 0)\n+      /* Make sure that link lists do not put this function in an\n+\t endless loop!  */\n+      if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived)\n+\t    && !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.derived)\n+\t    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)\n+\treturn 0;\n+\n+      else if (dt1->ts.type != BT_DERIVED\n+\t\t || derived1 != dt1->ts.derived\n+\t\t || dt2->ts.type != BT_DERIVED\n+\t\t || derived2 != dt2->ts.derived)\n \treturn 0;\n \n       dt1 = dt1->next;"}, {"sha": "c7a8e3e2ffe72dc81397ec535723838b2116d64f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "patch": "@@ -1,3 +1,8 @@\n+2007-12-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34558\n+\t* gfortran.dg/linked_list_1.f90: New test.\n+\n 2007-12-29  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* lib/objc.exp (objc_libgcc_s_path): Set objc_libgcc_s_path"}, {"sha": "8066bcb39548cd958cccd018786602ad0b16b070", "filename": "gcc/testsuite/gfortran.dg/linked_list_1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ftestsuite%2Fgfortran.dg%2Flinked_list_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63287e10a8527f9ed9d7c3939943ab1bc66aa46b/gcc%2Ftestsuite%2Fgfortran.dg%2Flinked_list_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flinked_list_1.f90?ref=63287e10a8527f9ed9d7c3939943ab1bc66aa46b", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+! Regression. ICE on valid code.\n+! The following worked with 4.1.3 and 4.2.2, but failed\n+! (segmentation fault) with 4.3.0 because the type comparison\n+! tried to comparethe types of the components of type(node), even\n+! though the only component is of type(node).\n+!\n+! Found using the Fortran Company Fortran 90 Test Suite (Lite),\n+! Version 1.4\n+!\n+! Reported by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+program error\n+  implicit none\n+  type node\n+    sequence\n+    type(node), pointer :: next\n+  end type\n+  type(node), pointer :: list\n+\n+  interface\n+    subroutine insert(ptr)\n+      implicit none\n+      type node\n+        sequence\n+        type(node), pointer :: next\n+      end type\n+      type(node), pointer :: ptr\n+    end subroutine insert\n+  end interface\n+  allocate (list);\n+end program error"}]}