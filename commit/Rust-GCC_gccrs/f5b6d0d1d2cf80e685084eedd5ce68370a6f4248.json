{"sha": "f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjViNmQwZDFkMmNmODBlNjg1MDg0ZWVkZDVjZTY4MzcwYTZmNDI0OA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2013-05-16T06:14:49Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2013-05-16T06:14:49Z"}, "message": "PR c++/56782 - Regression with empty pack expansions\n\nIn the example of the patch below, during the instantiation of\nis_convertible at #1, we see at some point Tuple<>.  (Let's note '{}'\nan empty argument pack.)  In that context, during the partial\nspecialization the member template\n\ntemplate<class... U>\nTuple<>::Tuple<U,\n\t       typename enable_if<and_<is_convertible<U, {}>...\n                                      >::value,\n                                  int\n\t\t\t         >::type\n              >\n\nLet's look at what happens to the expansion \"is_convertible<U, {}>....\"\n\nTo express the result of that expansion tsubst_pack_expansion receives\nthe expansion is_convertible<U, T>, with the argument list [{}].  This\nfunction should detect that we have an empty argument pack for the\nparameter pack T and no argument pack for the parameter pack U.  It\nshould thus return a pack expansion \"is_convertible<U,T>...\" that has this\ninformation: \"I have gotten an argument list, that is not complete\nbecause U doesn't have any argument pack; the argument pack for T is\n'{}', so I'll wait for the next time I am passed to\ntsubst_pack_expansion with enough additional argument packs, to really\nperform the substitution\".  That information is conveyed by attaching\nthe the '{}' to the PACK_EXPANSION_EXTRA property of the pack expansion\nreturned by tsubst_pack_expansion.\n\nThe problem in this report is that we are not setting\nPACK_EXPANSION_EXTRA when the non-complete argument pack list is made\nof an empty argument pack, because use_pack_expansion_extra_args_p\ndoesn't detect this case.\n\nFixed thus.\n\ngcc/cp/\n\n\t* pt.c (use_pack_expansion_extra_args_p): When at least a\n\tparameter pack has an empty argument pack, and another parameter\n\tpack has no argument pack at all, use the PACK_EXPANSION_EXTRA\n\tmechanism.\n\nFrom-SVN: r198956", "tree": {"sha": "c6b464617b7d00a515b81b19e8d79595d99f21d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6b464617b7d00a515b81b19e8d79595d99f21d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/comments", "author": null, "committer": null, "parents": [{"sha": "ad56ed7ebca514b172e13172f2486951218d3c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad56ed7ebca514b172e13172f2486951218d3c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad56ed7ebca514b172e13172f2486951218d3c8b"}], "stats": {"total": 86, "additions": 79, "deletions": 7}, "files": [{"sha": "3609fa5e6753c3122f7164c594de460ee334cbdf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "patch": "@@ -1,3 +1,11 @@\n+2013-05-16  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/56782 - Regression with empty pack expansions\n+\t* pt.c (use_pack_expansion_extra_args_p): When at least a\n+\tparameter pack has an empty argument pack, and another parameter\n+\tpack has no argument pack at all, use the PACK_EXPANSION_EXTRA\n+\tmechanism.\n+\n 2013-05-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* name-lookup.c (pushdecl_maybe_friend_1): Replace pairs of"}, {"sha": "b0be950b59085a92c5a16083a00d3e23e552a6bd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "patch": "@@ -9202,8 +9202,15 @@ use_pack_expansion_extra_args_p (tree parm_packs,\n \t\t\t\t int arg_pack_len,\n \t\t\t\t bool has_empty_arg)\n {\n+  /* If one pack has an expansion and another pack has a normal\n+     argument or if one pack has an empty argument and an another\n+     one hasn't then tsubst_pack_expansion cannot perform the\n+     substitution and need to fall back on the\n+     PACK_EXPANSION_EXTRA mechanism.  */\n   if (parm_packs == NULL_TREE)\n     return false;\n+  else if (has_empty_arg)\n+    return true;\n \n   bool has_expansion_arg = false;\n   for (int i = 0 ; i < arg_pack_len; ++i)\n@@ -9221,13 +9228,7 @@ use_pack_expansion_extra_args_p (tree parm_packs,\n \t    has_non_expansion_arg = true;\n \t}\n \n-      /* If one pack has an expansion and another pack has a normal\n-\t argument or if one pack has an empty argument another one\n-\t hasn't then tsubst_pack_expansion cannot perform the\n-\t substitution and need to fall back on the\n-\t PACK_EXPANSION_EXTRA mechanism.  */\n-      if ((has_expansion_arg && has_non_expansion_arg)\n-\t  || (has_empty_arg && (has_expansion_arg || has_non_expansion_arg)))\n+      if (has_expansion_arg && has_non_expansion_arg)\n \treturn true;\n     }\n   return false;"}, {"sha": "7737b4cacf41097c8a1cb9676983772d3afaa2a2", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic143.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic143.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b6d0d1d2cf80e685084eedd5ce68370a6f4248/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic143.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic143.C?ref=f5b6d0d1d2cf80e685084eedd5ce68370a6f4248", "patch": "@@ -0,0 +1,63 @@\n+// PR c++/56782\n+// { dg-options -std=c++0x }\n+\n+template<class T>\n+T&& declval();\n+\n+struct is_convertible_impl {\n+  template<class T>\n+  static void sink(T);\n+\n+  template<class T, class U, class = decltype(sink<U>(declval<T>()))>\n+  static auto test(int) -> char;\n+\n+  template<class, class>\n+  static auto test(...) -> char(&)[2];\n+};\n+\n+template<class T, class U>\n+struct is_convertible : is_convertible_impl\n+{\n+  static const bool value = sizeof(test<T, U>(0)) == 1;\n+};\n+\n+template<bool, class>\n+struct enable_if {};\n+\n+template<class T>\n+struct enable_if<true, T> { typedef T type; };\n+\n+template<bool, class If, class Else>\n+struct conditional { typedef If type; };\n+\n+template<class If, class Else>\n+struct conditional<false, If, Else> { typedef Else type; };\n+\n+template<class...>\n+struct and_;\n+\n+template<>\n+struct and_<>\n+{\n+  static const bool value = true;\n+};\n+\n+template<class P>\n+struct and_<P> : P\n+{\n+};\n+\n+template<class P1, class P2>\n+struct and_<P1, P2> : conditional<P1::value, P2, P1>::type\n+{\n+};\n+\n+template<class... T>\n+struct Tuple {\n+  template<class... U,\n+\t   class = typename enable_if<and_<is_convertible<U, T>... >::value, int>::type\n+\t   >\n+  Tuple(U&&...){}\n+};\n+\n+static_assert(is_convertible<Tuple<>, Tuple<>>::value, \"Ouch\"); //#1"}]}