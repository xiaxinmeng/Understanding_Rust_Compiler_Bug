{"sha": "39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlhZDE2NjU3YzlkZThiOGMxNzM2ZTIxNDVmOGU4ZjM4Y2I4YmZmMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-25T15:14:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-25T15:14:44Z"}, "message": "[multiple changes]\n\n2012-04-25  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb, csinfo.adb, lib-writ.adb, sem_ch12.adb,\n\tlib-xref.adb: Minor reformatting.\n\n2012-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch9.adb: Rename Lock_Free_Sub_Type\n\tto Lock_Free_Subprogram. Remove type Subprogram_Id.\n\tRename LF_Sub_Table to Lock_Free_Subprogram_Table.\n\t(Allow_Lock_Free_Implementation): Renamed to\n\tAllows_Lock_Free_Implementation.  Update the comment on\n\tlock-free restrictions. Code clean up and restructuring.\n\t(Build_Lock_Free_Protected_Subprogram_Body): Update the\n\tprofile and related comments. Code clean up and restructuring.\n\t(Build_Lock_Free_Unprotected_Subprogram_Body): Update the\n\tprofile and related comments. Code clean up and restructuring.\n\t(Comp_Of): Removed.\n\nFrom-SVN: r186828", "tree": {"sha": "a2ec87a172580f2d22c3107911ec0a58fdb2ff15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2ec87a172580f2d22c3107911ec0a58fdb2ff15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/comments", "author": null, "committer": null, "parents": [{"sha": "d024b1268cedd1e5720d9f6968bef11d8a159c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d024b1268cedd1e5720d9f6968bef11d8a159c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d024b1268cedd1e5720d9f6968bef11d8a159c15"}], "stats": {"total": 1243, "additions": 605, "deletions": 638}, "files": [{"sha": "3831a9e3d235e73cca875f73a0199b725e3df3f0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -1,3 +1,22 @@\n+2012-04-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb, csinfo.adb, lib-writ.adb, sem_ch12.adb,\n+\tlib-xref.adb: Minor reformatting.\n+\n+2012-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch9.adb: Rename Lock_Free_Sub_Type\n+\tto Lock_Free_Subprogram. Remove type Subprogram_Id.\n+\tRename LF_Sub_Table to Lock_Free_Subprogram_Table.\n+\t(Allow_Lock_Free_Implementation): Renamed to\n+\tAllows_Lock_Free_Implementation.  Update the comment on\n+\tlock-free restrictions. Code clean up and restructuring.\n+\t(Build_Lock_Free_Protected_Subprogram_Body): Update the\n+\tprofile and related comments. Code clean up and restructuring.\n+\t(Build_Lock_Free_Unprotected_Subprogram_Body): Update the\n+\tprofile and related comments. Code clean up and restructuring.\n+\t(Comp_Of): Removed.\n+\n 2012-04-25  Vincent Celier  <celier@adacore.com>\n \n \t* sem_ch12.adb (Inherit_Context): Compare library units, not"}, {"sha": "1a71a2ef6db955deb34aa6b1c51ee09faa9089f1", "filename": "gcc/ada/csinfo.adb", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fcsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fcsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsinfo.adb?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -199,36 +199,36 @@ begin\n    --  by Csinfo, since they are specially handled. This means that any field\n    --  definition or subprogram with a matching name is ignored.\n \n-   Set (Special, \"Analyzed\",                  True);\n-   Set (Special, \"Assignment_OK\",             True);\n-   Set (Special, \"Associated_Node\",           True);\n-   Set (Special, \"Cannot_Be_Constant\",        True);\n-   Set (Special, \"Chars\",                     True);\n-   Set (Special, \"Comes_From_Source\",         True);\n-   Set (Special, \"Do_Overflow_Check\",         True);\n-   Set (Special, \"Do_Range_Check\",            True);\n-   Set (Special, \"Entity\",                    True);\n-   Set (Special, \"Entity_Or_Associated_Node\", True);\n-   Set (Special, \"Error_Posted\",              True);\n-   Set (Special, \"Etype\",                     True);\n-   Set (Special, \"Evaluate_Once\",             True);\n-   Set (Special, \"First_Itype\",               True);\n-   Set (Special, \"Has_Aspect_Specifications\", True);\n-   Set (Special, \"Has_Dynamic_Itype\",         True);\n-   Set (Special, \"Has_Dynamic_Range_Check\",   True);\n-   Set (Special, \"Has_Dynamic_Length_Check\",  True);\n-   Set (Special, \"Has_Private_View\",          True);\n+   Set (Special, \"Analyzed\",                         True);\n+   Set (Special, \"Assignment_OK\",                    True);\n+   Set (Special, \"Associated_Node\",                  True);\n+   Set (Special, \"Cannot_Be_Constant\",               True);\n+   Set (Special, \"Chars\",                            True);\n+   Set (Special, \"Comes_From_Source\",                True);\n+   Set (Special, \"Do_Overflow_Check\",                True);\n+   Set (Special, \"Do_Range_Check\",                   True);\n+   Set (Special, \"Entity\",                           True);\n+   Set (Special, \"Entity_Or_Associated_Node\",        True);\n+   Set (Special, \"Error_Posted\",                     True);\n+   Set (Special, \"Etype\",                            True);\n+   Set (Special, \"Evaluate_Once\",                    True);\n+   Set (Special, \"First_Itype\",                      True);\n+   Set (Special, \"Has_Aspect_Specifications\",        True);\n+   Set (Special, \"Has_Dynamic_Itype\",                True);\n+   Set (Special, \"Has_Dynamic_Range_Check\",          True);\n+   Set (Special, \"Has_Dynamic_Length_Check\",         True);\n+   Set (Special, \"Has_Private_View\",                 True);\n    Set (Special, \"Implicit_With_From_Instantiation\", True);\n-   Set (Special, \"Is_Controlling_Actual\",     True);\n-   Set (Special, \"Is_Overloaded\",             True);\n-   Set (Special, \"Is_Static_Expression\",      True);\n-   Set (Special, \"Left_Opnd\",                 True);\n-   Set (Special, \"Must_Not_Freeze\",           True);\n-   Set (Special, \"Nkind_In\",                  True);\n-   Set (Special, \"Parens\",                    True);\n-   Set (Special, \"Pragma_Name\",               True);\n-   Set (Special, \"Raises_Constraint_Error\",   True);\n-   Set (Special, \"Right_Opnd\",                True);\n+   Set (Special, \"Is_Controlling_Actual\",            True);\n+   Set (Special, \"Is_Overloaded\",                    True);\n+   Set (Special, \"Is_Static_Expression\",             True);\n+   Set (Special, \"Left_Opnd\",                        True);\n+   Set (Special, \"Must_Not_Freeze\",                  True);\n+   Set (Special, \"Nkind_In\",                         True);\n+   Set (Special, \"Parens\",                           True);\n+   Set (Special, \"Pragma_Name\",                      True);\n+   Set (Special, \"Raises_Constraint_Error\",          True);\n+   Set (Special, \"Right_Opnd\",                       True);\n \n    --  Loop to acquire information from node definitions in sinfo.ads,\n    --  checking for consistency in Op/Flag assignments to each synonym\n@@ -627,7 +627,6 @@ begin\n \n    declare\n       List : constant TV.Table_Array := Convert_To_Array (Fields1);\n-\n    begin\n       if List'Length /= 0 then\n          Put_Line (\"Missing procedure Set_\" & List (1).Name & \" in body\");"}, {"sha": "d926abe766d1e06c7a4b5efc35c4ae60172f694a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 550, "deletions": 603, "changes": 1153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -81,29 +81,24 @@ package body Exp_Ch9 is\n    -- Lock Free Data Structure --\n    ------------------------------\n \n-   --  A data structure used for the Lock Free (LF) implementation of protected\n-   --  objects. Since a protected subprogram can only access a single protected\n-   --  component in the LF implementation, this structure stores each protected\n-   --  subprogram and its accessed protected component when the protected\n-   --  object allows the LF implementation.\n-\n-   type Lock_Free_Sub_Type is record\n+   type Lock_Free_Subprogram is record\n       Sub_Body : Node_Id;\n       Comp_Id  : Entity_Id;\n    end record;\n+   --  This data structure and its fields must be documented, ALL global\n+   --  data structures must be documented. We never rely on guessing what\n+   --  things mean from their names.\n \n-   subtype Subprogram_Id is Nat;\n-\n-   --  The following table used for the Lock Free implementation of protected\n-   --  objects maps Lock_Free_Sub_Type to Subprogram_Id.\n+   --  The following table establishes a relation between a subprogram body and\n+   --  an unique protected component referenced in this body.\n \n-   package LF_Sub_Table is new Table.Table (\n-     Table_Component_Type => Lock_Free_Sub_Type,\n-     Table_Index_Type     => Subprogram_Id,\n+   package Lock_Free_Subprogram_Table is new Table.Table (\n+     Table_Component_Type => Lock_Free_Subprogram,\n+     Table_Index_Type     => Nat,\n      Table_Low_Bound      => 1,\n      Table_Initial        => 5,\n      Table_Increment      => 5,\n-     Table_Name           => \"LF_Sub_Table\");\n+     Table_Name           => \"Lock_Free_Subprogram_Table\");\n \n    -----------------------\n    -- Local Subprograms --\n@@ -139,9 +134,19 @@ package body Exp_Ch9 is\n    --    Decls is the list of declarations to be enhanced.\n    --    Ent is the entity for the original entry body.\n \n-   function Allow_Lock_Free_Implementation (N : Node_Id) return Boolean;\n-   --  Given a protected body N, return True if N permits a lock free\n-   --  implementation.\n+   function Allows_Lock_Free_Implementation (N : Node_Id) return Boolean;\n+   --  Given a protected body N, return True if N satisfies the following list\n+   --  of lock-free restrictions:\n+   --\n+   --    1) Protected type\n+   --         May not contain entries\n+   --         May contain only scalar components\n+   --         Component types must support atomic compare and exchange\n+   --\n+   --    2) Protected subprograms\n+   --         May not have side effects\n+   --         May not contain loop statements or procedure calls\n+   --         Function calls and attribute references must be static\n \n    function Build_Accept_Body (Astat : Node_Id) return Node_Id;\n    --  Transform accept statement into a block with added exception handler.\n@@ -189,20 +194,20 @@ package body Exp_Ch9 is\n    --  Build subprogram declaration for previous one\n \n    function Build_Lock_Free_Protected_Subprogram_Body\n-     (N         : Node_Id;\n-      Pid       : Node_Id;\n-      N_Op_Spec : Node_Id) return Node_Id;\n-   --  This function is used to construct the lock free version of a protected\n-   --  subprogram when the protected type denoted by Pid allows the lock free\n-   --  implementation. It only contains a call to the unprotected version of\n-   --  the subprogram body.\n+     (N           : Node_Id;\n+      Prot_Typ    : Node_Id;\n+      Unprot_Spec : Node_Id) return Node_Id;\n+   --  N denotes a subprogram body of protected type Prot_Typ. Unprot_Spec is\n+   --  the subprogram specification of the unprotected version of N. Transform\n+   --  N such that it invokes the unprotected version of the body.\n \n    function Build_Lock_Free_Unprotected_Subprogram_Body\n-     (N : Node_Id;\n-      Pid : Node_Id) return Node_Id;\n-   --  This function is used to construct the lock free version of an\n-   --  unprotected subprogram when the protected type denoted by Pid allows the\n-   --  lock free implementation.\n+     (N        : Node_Id;\n+      Prot_Typ : Node_Id) return Node_Id;\n+   --  N denotes a subprogram body of protected type Prot_Typ. Build a version\n+   --  of N where the original statements of N are synchronized through atomic\n+   --  actions such as compare and exchange. Prior to invoking this routine, it\n+   --  has been established that N can be implemented in a lock-free fashion.\n \n    function Build_Parameter_Block\n      (Loc     : Source_Ptr;\n@@ -349,10 +354,6 @@ package body Exp_Ch9 is\n    --  For each entry family in a concurrent type, create an anonymous array\n    --  type of the right size, and add a component to the corresponding_record.\n \n-   function Comp_Of (Sub_Body : Node_Id) return Entity_Id;\n-   --  For the lock free implementation, return the protected component entity\n-   --  referenced in Sub_Body using LF_Sub_Table.\n-\n    function Concurrent_Object\n      (Spec_Id  : Entity_Id;\n       Conc_Typ : Entity_Id) return Entity_Id;\n@@ -819,221 +820,180 @@ package body Exp_Ch9 is\n       Prepend_To (Decls, Decl);\n    end Add_Object_Pointer;\n \n-   ------------------------------------\n-   -- Allow_Lock_Free_Implementation --\n-   ------------------------------------\n-\n-   --  Here are the restrictions for the Lock Free implementation\n-\n-   --    Implementation Restrictions on protected declaration\n-\n-   --       There must be only protected scalar components (at least one)\n-\n-   --       Component types must support an atomic compare_exchange primitive\n-   --       (size equals to 1, 2, 4 or 8 bytes).\n-\n-   --       No entries\n-\n-   --    Implementation Restrictions on protected operations\n-\n-   --       Cannot refer to non-constant outside of the scope of the protected\n-   --       operation.\n-\n-   --       Can only access a single protected component: all protected\n-   --       component names appearing in a scope (including nested scopes)\n-   --       must statically denote the same protected component.\n-\n-   --    Fundamental Restrictions on protected operations\n-\n-   --      No loop and procedure call statements\n-\n-   --      Any function call and attribute reference must be static\n-\n-   function Allow_Lock_Free_Implementation (N : Node_Id) return Boolean is\n-      Decls     : constant List_Id := Declarations (N);\n-      Spec      : constant Entity_Id := Corresponding_Spec (N);\n-      Pro_Def   : constant Node_Id := Protected_Definition (Parent (Spec));\n-      Pri_Decls : constant List_Id := Private_Declarations (Pro_Def);\n-      Vis_Decls : constant List_Id := Visible_Declarations (Pro_Def);\n-\n-      Comp_Id      : Entity_Id;\n-      Comp_Size    : Int;\n-      Comp_Type    : Entity_Id;\n-      No_Component : Boolean := True;\n-      N_Decl       : Node_Id;\n-\n-      function Permit_Lock_Free (Sub_Body : Node_Id) return Boolean;\n-      --  Return True if the protected subprogram body Sub_Body doesn't\n-      --  prevent the lock free code expansion, i.e. Sub_Body meets all the\n-      --  restrictions listed below that allow the lock free implementation.\n-      --\n-      --    Can only access a single protected component\n-      --\n-      --    No loop and procedure call statements\n+   -------------------------------------\n+   -- Allows_Lock_Free_Implementation --\n+   -------------------------------------\n \n-      --    Any function call and attribute reference must be static\n+   function Allows_Lock_Free_Implementation (N : Node_Id) return Boolean is\n+      Spec       : constant Entity_Id := Corresponding_Spec (N);\n+      Prot_Def   : constant Node_Id   := Protected_Definition (Parent (Spec));\n+      Priv_Decls : constant List_Id   := Private_Declarations (Prot_Def);\n \n-      --    Cannot refer to non-constant outside of the scope of the protected\n-      --    subprogram.\n+      function Satisfies_Lock_Free_Requirements\n+        (Sub_Body : Node_Id) return Boolean;\n+      --  Return True if protected subprogram body Sub_Body satisfies all\n+      --  requirements of a lock-free implementation.\n \n-      ----------------------\n-      -- Permit_Lock_Free --\n-      ----------------------\n+      --------------------------------------\n+      -- Satisfies_Lock_Free_Requirements --\n+      --------------------------------------\n \n-      function Permit_Lock_Free (Sub_Body : Node_Id) return Boolean is\n-         Sub_Id  : constant Entity_Id := Corresponding_Spec (Sub_Body);\n-         Comp_Id : Entity_Id := Empty;\n-         LF_Sub  : Lock_Free_Sub_Type;\n+      function Satisfies_Lock_Free_Requirements\n+        (Sub_Body : Node_Id) return Boolean\n+      is\n+         Comp : Entity_Id := Empty;\n+         --  Track the current component which the body references\n \n          function Check_Node (N : Node_Id) return Traverse_Result;\n-         --  Check the node N meet the lock free restrictions\n-\n-         function Check_All_Nodes is new Traverse_Func (Check_Node);\n+         --  Check that node N meets the lock free restrictions\n \n          ----------------\n          -- Check_Node --\n          ----------------\n \n          function Check_Node (N : Node_Id) return Traverse_Result is\n-            Comp_Decl : Node_Id;\n-            Id        : Entity_Id;\n-\n          begin\n-            case Nkind (N) is\n-\n-               --  Function call or attribute reference case\n+            --  Function calls and attribute references must be static\n+            --  ??? what about side-effects\n \n-               when N_Function_Call | N_Attribute_Reference =>\n-\n-                  --  Any function call and attribute reference must be static\n-\n-                  if not Is_Static_Expression (N) then\n-                     return Abandon;\n-                  end if;\n-\n-               --  Loop and procedure call statement case\n+            if Nkind_In (N, N_Attribute_Reference, N_Function_Call)\n+              and then not Is_Static_Expression (N)\n+            then\n+               return Abandon;\n \n-               when N_Procedure_Call_Statement | N_Loop_Statement =>\n-                  --  No loop and procedure call statements\n-                  return Abandon;\n+            --  Loop statements and procedure calls are prohibited\n \n-               --  Identifier case\n+            elsif Nkind_In (N, N_Loop_Statement,\n+                               N_Procedure_Call_Statement)\n+            then\n+               return Abandon;\n \n-               when N_Identifier =>\n-                  if Present (Entity (N)) then\n-                     Id := Entity (N);\n+            --  References\n \n-                     --  Cannot refer to non-constant entities outside of the\n-                     --  scope of the protected subprogram.\n+            elsif Nkind (N) = N_Identifier\n+              and then Present (Entity (N))\n+            then\n+               declare\n+                  Id     : constant Entity_Id := Entity (N);\n+                  Sub_Id : constant Entity_Id := Corresponding_Spec (Sub_Body);\n \n-                     if Ekind (Id) in Assignable_Kind\n-                       and then Sloc (Scope (Id)) > No_Location\n-                       and then not Scope_Within_Or_Same (Scope (Id), Sub_Id)\n-                       and then not Scope_Within_Or_Same (Scope (Id),\n-                                      Protected_Body_Subprogram (Sub_Id))\n-                     then\n-                        return Abandon;\n-                     end if;\n+               begin\n+                  --  Prohibit references to non-constant entities outside the\n+                  --  protected subprogram scope.\n \n-                     --  Can only access a single protected component\n+                  if Ekind (Id) in Assignable_Kind\n+                    and then not Scope_Within_Or_Same (Scope (Id), Sub_Id)\n+                    and then not Scope_Within_Or_Same (Scope (Id),\n+                                   Protected_Body_Subprogram (Sub_Id))\n+                  then\n+                     return Abandon;\n \n-                     if Ekind_In (Id, E_Constant, E_Variable)\n-                       and then Present (Prival_Link (Id))\n-                     then\n-                        Comp_Decl := Parent (Prival_Link (Id));\n+                  --  A protected subprogram may reference only one component\n+                  --  of the protected type.\n \n+                  elsif Ekind_In (Id, E_Constant, E_Variable)\n+                    and then Present (Prival_Link (Id))\n+                  then\n+                     declare\n+                        Comp_Decl : constant Node_Id :=\n+                                      Parent (Prival_Link (Id));\n+                     begin\n                         if Nkind (Comp_Decl) = N_Component_Declaration\n                           and then Is_List_Member (Comp_Decl)\n-                          and then List_Containing (Comp_Decl) = Pri_Decls\n+                          and then List_Containing (Comp_Decl) = Priv_Decls\n                         then\n+                           if No (Comp) then\n+                              Comp := Prival_Link (Id);\n+\n                            --  Check if another protected component has already\n                            --  been accessed by the subprogram body.\n \n-                           if Present (Comp_Id)\n-                             and then Comp_Id /= Prival_Link (Id)\n-                           then\n+                           elsif Comp /= Prival_Link (Id) then\n                               return Abandon;\n-\n-                           elsif not Present (Comp_Id) then\n-                              Comp_Id := Prival_Link (Id);\n                            end if;\n                         end if;\n-                     end if;\n+                     end;\n                   end if;\n-\n-               --  Ok for all other nodes\n-\n-               when others => return OK;\n-            end case;\n+               end;\n+            end if;\n \n             return OK;\n          end Check_Node;\n \n-      --  Start of processing for Permit_Lock_Free\n+         function Check_All_Nodes is new Traverse_Func (Check_Node);\n+\n+      --  Start of processing for Satisfies_Lock_Free_Requirements\n \n       begin\n          if Check_All_Nodes (Sub_Body) = OK then\n \n-            --  Fill LF_Sub with Sub_Body and its corresponding protected\n-            --  component entity and then store LF_Sub in the lock free\n-            --  subprogram table LF_Sub_Table.\n+            --  Establish a relation between the subprogram body and the unique\n+            --  protected component it references.\n \n-            LF_Sub.Sub_Body := Sub_Body;\n-            LF_Sub.Comp_Id := Comp_Id;\n-            LF_Sub_Table.Append (LF_Sub);\n-            return True;\n+            if Present (Comp) then\n+               Lock_Free_Subprogram_Table.Append\n+                 (Lock_Free_Subprogram'(Sub_Body, Comp));\n+            end if;\n \n+            return True;\n          else\n             return False;\n          end if;\n-      end Permit_Lock_Free;\n+      end Satisfies_Lock_Free_Requirements;\n+\n+      --  Local variables\n+\n+      Decls     : constant List_Id   := Declarations (N);\n+      Vis_Decls : constant List_Id   := Visible_Declarations (Prot_Def);\n+\n+      Comp_Id       : Entity_Id;\n+      Comp_Size     : Int;\n+      Comp_Type     : Entity_Id;\n+      Decl          : Node_Id;\n+      Has_Component : Boolean := False;\n \n-   --  Start of processing for Allow_Lock_Free_Implementation\n+   --  Start of processing for Allows_Lock_Free_Implementation\n \n    begin\n-      --  Debug switch -gnatd9 enables Lock Free implementation\n+      --  The lock-free implementation is currently enabled through a debug\n+      --  flag.\n \n       if not Debug_Flag_9 then\n          return False;\n       end if;\n \n-      --  Look for any entries declared in the visible part of the protected\n-      --  declaration.\n+      --  Examine the visible declarations. Entries and entry families are not\n+      --  allowed by the lock-free restrictions.\n \n-      N_Decl := First (Vis_Decls);\n-      while Present (N_Decl) loop\n-         if Nkind (N_Decl) = N_Entry_Declaration then\n+      Decl := First (Vis_Decls);\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Entry_Declaration then\n             return False;\n          end if;\n \n-         N_Decl := Next (N_Decl);\n+         Next (Decl);\n       end loop;\n \n-      --  Look for any entry, plus look for any scalar component declared in\n-      --  the private part of the protected declaration.\n+      --  Examine the private declarations\n \n-      N_Decl := First (Pri_Decls);\n-      while Present (N_Decl) loop\n+      Decl := First (Priv_Decls);\n+      while Present (Decl) loop\n \n-         --  Check at least one scalar component is declared\n+         --  The protected type must define at least one scalar component\n \n-         if Nkind (N_Decl) = N_Component_Declaration then\n-            if No_Component then\n-               No_Component := False;\n-            end if;\n+         if Nkind (Decl) = N_Component_Declaration then\n+            Has_Component := True;\n \n-            Comp_Id := Defining_Identifier (N_Decl);\n+            Comp_Id   := Defining_Identifier (Decl);\n             Comp_Type := Etype (Comp_Id);\n \n-            --  Verify the component is a scalar\n-\n             if not Is_Scalar_Type (Comp_Type) then\n                return False;\n             end if;\n \n             Comp_Size := UI_To_Int (Esize (Base_Type (Comp_Type)));\n \n-            --  Check the size of the component is 8, 16, 32 or 64 bits\n+            --  Check that the size of the component is 8, 16, 32 or 64 bits\n \n             case Comp_Size is\n                when 8 | 16 | 32 | 64 =>\n@@ -1042,39 +1002,37 @@ package body Exp_Ch9 is\n                   return False;\n             end case;\n \n-         --  Check there is no entry declared in the private part.\n+         --  Entries and entry families are not allowed\n \n-         else\n-            if Nkind (N_Decl) = N_Entry_Declaration then\n-               return False;\n-            end if;\n+         elsif Nkind (Decl) = N_Entry_Declaration then\n+            return False;\n          end if;\n \n-         N_Decl := Next (N_Decl);\n+         Next (Decl);\n       end loop;\n \n-      --  One scalar component must be present\n+      --  At least one scalar component must be present\n \n-      if No_Component then\n+      if not Has_Component then\n          return False;\n       end if;\n \n-      --  Ensure all protected subprograms meet the restrictions that allow the\n-      --  lock free implementation.\n+      --  Ensure that all protected subprograms meet the restrictions of the\n+      --  lock-free implementation.\n \n-      N_Decl := First (Decls);\n-      while Present (N_Decl) loop\n-         if Nkind (N_Decl) = N_Subprogram_Body\n-           and then not Permit_Lock_Free (N_Decl)\n+      Decl := First (Decls);\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Subprogram_Body\n+           and then not Satisfies_Lock_Free_Requirements (Decl)\n          then\n             return False;\n          end if;\n \n-         Next (N_Decl);\n+         Next (Decl);\n       end loop;\n \n       return True;\n-   end Allow_Lock_Free_Implementation;\n+   end Allows_Lock_Free_Implementation;\n \n    -----------------------\n    -- Build_Accept_Body --\n@@ -3189,520 +3147,524 @@ package body Exp_Ch9 is\n    -----------------------------------------------\n \n    function Build_Lock_Free_Protected_Subprogram_Body\n-     (N         : Node_Id;\n-      Pid       : Node_Id;\n-      N_Op_Spec : Node_Id) return Node_Id\n+     (N           : Node_Id;\n+      Prot_Typ    : Node_Id;\n+      Unprot_Spec : Node_Id) return Node_Id\n    is\n-      Loc          : constant Source_Ptr := Sloc (N);\n-      Op_Spec      : Node_Id;\n-      P_Op_Spec    : Node_Id;\n-      Uactuals     : List_Id;\n-      Pformal      : Node_Id;\n-      Unprot_Call  : Node_Id;\n-      R            : Node_Id;\n-      Return_Stmt  : Node_Id := Empty;    -- init to avoid gcc 3 warning\n-      Exc_Safe     : Boolean;\n+      Actuals   : constant List_Id    := New_List;\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Spec      : constant Node_Id    := Specification (N);\n+      Unprot_Id : constant Entity_Id  := Defining_Unit_Name (Unprot_Spec);\n+      Formal    : Node_Id;\n+      Prot_Spec : Node_Id;\n+      Stmt      : Node_Id;\n \n    begin\n-      Op_Spec := Specification (N);\n-      Exc_Safe := Is_Exception_Safe (N);\n+      --  Create the protected version of the body\n \n-      P_Op_Spec :=\n-        Build_Protected_Sub_Specification (N, Pid, Protected_Mode);\n+      Prot_Spec :=\n+        Build_Protected_Sub_Specification (N, Prot_Typ, Protected_Mode);\n \n-      --  Build a list of the formal parameters of the protected version of\n-      --  the subprogram to use as the actual parameters of the unprotected\n-      --  version.\n+      --  Build the actual parameters which appear in the call to the\n+      --  unprotected version of the body.\n \n-      Uactuals := New_List;\n-      Pformal := First (Parameter_Specifications (P_Op_Spec));\n-      while Present (Pformal) loop\n-         Append_To (Uactuals,\n-           Make_Identifier (Loc, Chars (Defining_Identifier (Pformal))));\n-         Next (Pformal);\n-      end loop;\n+      Formal := First (Parameter_Specifications (Prot_Spec));\n+      while Present (Formal) loop\n+         Append_To (Actuals,\n+           Make_Identifier (Loc, Chars (Defining_Identifier (Formal))));\n \n-      --  Make a call to the unprotected version of the subprogram built above\n-      --  for use by the protected version built below.\n+         Next (Formal);\n+      end loop;\n \n-      if Nkind (Op_Spec) = N_Function_Specification then\n-         if Exc_Safe then\n-            R := Make_Temporary (Loc, 'R');\n-            Unprot_Call :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => R,\n-                Constant_Present => True,\n-                Object_Definition => New_Copy (Result_Definition (N_Op_Spec)),\n-                Expression =>\n-                  Make_Function_Call (Loc,\n-                    Name => Make_Identifier (Loc,\n-                      Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n-                    Parameter_Associations => Uactuals));\n+      --  Function case, generate:\n+      --    return <Unprot_Func_Call>;\n \n-            Return_Stmt :=\n-              Make_Simple_Return_Statement (Loc,\n-                Expression => New_Reference_To (R, Loc));\n+      if Nkind (Spec) = N_Function_Specification then\n+         Stmt :=\n+           Make_Simple_Return_Statement (Loc,\n+             Expression =>\n+               Make_Function_Call (Loc,\n+                 Name                   =>\n+                   Make_Identifier (Loc, Chars (Unprot_Id)),\n+                 Parameter_Associations => Actuals));\n \n-         else\n-            Unprot_Call := Make_Simple_Return_Statement (Loc,\n-              Expression => Make_Function_Call (Loc,\n-                Name =>\n-                  Make_Identifier (Loc,\n-                    Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n-                Parameter_Associations => Uactuals));\n-         end if;\n+      --  Procedure case, call the unprotected version\n \n       else\n-         Unprot_Call :=\n+         Stmt :=\n            Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               Make_Identifier (Loc, Chars (Defining_Unit_Name (N_Op_Spec))),\n-             Parameter_Associations => Uactuals);\n-      end if;\n-\n-      if Nkind (Op_Spec) = N_Function_Specification\n-        and then Exc_Safe\n-      then\n-         Unprot_Call :=\n-           Make_Block_Statement (Loc,\n-             Declarations               => New_List (Unprot_Call),\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (Return_Stmt)));\n+             Name                   =>\n+               Make_Identifier (Loc, Chars (Unprot_Id)),\n+             Parameter_Associations => Actuals);\n       end if;\n \n       return\n         Make_Subprogram_Body (Loc,\n-          Declarations => Empty_List,\n-          Specification => P_Op_Spec,\n+          Declarations               => Empty_List,\n+          Specification              => Prot_Spec,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Unprot_Call)));\n+              Statements => New_List (Stmt)));\n    end Build_Lock_Free_Protected_Subprogram_Body;\n \n    -------------------------------------------------\n    -- Build_Lock_Free_Unprotected_Subprogram_Body --\n    -------------------------------------------------\n \n+   --  Procedures which meet the lock-free implementation requirements and\n+   --  reference a unique scalar component Comp are expanded in the following\n+   --  manner:\n+\n+   --    procedure P (...) is\n+   --       <original declarations>\n+   --    begin\n+   --       loop\n+   --          declare\n+   --             Saved_Comp   : constant ... := Atomic_Load (Comp'Address);\n+   --             Current_Comp : ... := Saved_Comp;\n+   --          begin\n+   --             <original statements>\n+   --             exit when Atomic_Compare (Comp, Saved_Comp, Current_Comp);\n+   --          end;\n+   --          <<L0>>\n+   --       end loop;\n+   --    end P;\n+\n+   --  References to Comp which appear in the original statements are replaced\n+   --  with references to Current_Comp. Each return and raise statement of P is\n+   --  transformed into an atomic status check:\n+\n+   --    if Atomic_Compare (Comp, Saved_Comp, Current_Comp) then\n+   --       <original statement>\n+   --    else\n+   --       goto L0;\n+   --    end if;\n+\n+   --  Functions which meet the lock-free implementation requirements and\n+   --  reference a unique scalar component Comp are expanded in the following\n+   --  manner:\n+\n+   --    function F (...) return ... is\n+   --       <original declarations>\n+   --       Saved_Comp : constant ... := Atomic_Load (Comp'Address);\n+   --    begin\n+   --       <original statements>\n+   --    end F;\n+\n+   --  References to Comp which appear in the original statements are replaced\n+   --  with references to Saved_Comp.\n+\n    function Build_Lock_Free_Unprotected_Subprogram_Body\n-     (N : Node_Id;\n-      Pid : Node_Id) return Node_Id\n+     (N        : Node_Id;\n+      Prot_Typ : Node_Id) return Node_Id\n    is\n-      Decls        : constant List_Id := Declarations (N);\n-      Is_Procedure : constant Boolean :=\n+      Is_Procedure : constant Boolean    :=\n                        Ekind (Corresponding_Spec (N)) = E_Procedure;\n       Loc          : constant Source_Ptr := Sloc (N);\n+      Label_Id     : Entity_Id := Empty;\n+\n+      procedure Process_Stmts\n+        (Stmts        : List_Id;\n+         Compare      : Entity_Id;\n+         Unsigned     : Entity_Id;\n+         Comp         : Entity_Id;\n+         Saved_Comp   : Entity_Id;\n+         Current_Comp : Entity_Id);\n+      --  Given a statement sequence Stmts, wrap any return or raise statements\n+      --  in the following manner:\n+      --\n+      --    if System.Atomic_Primitives.Atomic_Compare_Exchange\n+      --         (Comp'Address,\n+      --          Interfaces.Unsigned (Saved_Comp),\n+      --          Interfaces.Unsigned (Current_Comp))\n+      --    then\n+      --       <Stmt>;\n+      --    else\n+      --       goto L0;\n+      --    end if;\n+      --\n+      --  Replace all references to Comp with a reference to Current_Comp.\n \n-      function Ren_Comp_Id (Decls : List_Id) return Entity_Id;\n-      --  Given the list of delaration Decls, return the renamed entity\n-      --  of the protected component accessed by the subprogram body.\n+      function Referenced_Component (N : Node_Id) return Entity_Id;\n+      --  Subprograms which meet the lock-free implementation criteria are\n+      --  allowed to reference only one unique component. Return the prival\n+      --  of the said component.\n \n-      -----------------\n-      -- Ren_Comp_Id --\n-      -----------------\n+      -------------------\n+      -- Process_Stmts --\n+      -------------------\n \n-      function Ren_Comp_Id (Decls : List_Id) return Entity_Id is\n-         N_Decl       : Node_Id;\n-         Pri_Link     : Node_Id;\n+      procedure Process_Stmts\n+        (Stmts        : List_Id;\n+         Compare      : Entity_Id;\n+         Unsigned     : Entity_Id;\n+         Comp         : Entity_Id;\n+         Saved_Comp   : Entity_Id;\n+         Current_Comp : Entity_Id)\n+      is\n+         function Process_Node (N : Node_Id) return Traverse_Result;\n+         --  Transform a single node if it is a return statement, a raise\n+         --  statement or a reference to Comp.\n \n-      begin\n-         N_Decl := First (Decls);\n-         while Present (N_Decl) loop\n+         ------------------\n+         -- Process_Node --\n+         ------------------\n \n-            --  Look for a renaming declaration\n+         function Process_Node (N : Node_Id) return Traverse_Result is\n \n-            if Nkind (N_Decl) = N_Object_Renaming_Declaration then\n-               Pri_Link := Prival_Link (Defining_Identifier (N_Decl));\n+            procedure Wrap_Statement (Stmt : Node_Id);\n+            --  Wrap an arbitrary statement inside an if statement where the\n+            --  condition does an atomic check on the state of the object.\n \n-               --  Compare the renamed entity and the accessed component entity\n-               --  in the LF_Sub_Table.\n+            --------------------\n+            -- Wrap_Statement --\n+            --------------------\n \n-               if Present (Pri_Link) and then Pri_Link = Comp_Of (N) then\n-                  return Defining_Identifier (N_Decl);\n+            procedure Wrap_Statement (Stmt : Node_Id) is\n+            begin\n+               --  The first time through, create the declaration of a label\n+               --  which is used to skip the remainder of source statements if\n+               --  the state of the object has changed.\n+\n+               if No (Label_Id) then\n+                  Label_Id :=\n+                    Make_Identifier (Loc, New_External_Name ('L', 0));\n+                  Set_Entity (Label_Id,\n+                    Make_Defining_Identifier (Loc, Chars (Label_Id)));\n                end if;\n-            end if;\n-\n-            Next (N_Decl);\n-         end loop;\n-\n-         return Empty;\n-      end Ren_Comp_Id;\n-\n-      Obj_Id      : constant Entity_Id := Ren_Comp_Id (Decls);\n-      At_Comp_Id  : Entity_Id;\n-      At_Load_Id  : Entity_Id;\n-      Copy_Id     : Entity_Id;\n-      Exit_Stmt   : Node_Id;\n-      Label       : Node_Id := Empty;\n-      Label_Id    : Entity_Id;\n-      New_Body    : Node_Id;\n-      New_Decls   : List_Id;\n-      New_Stmts   : List_Id;\n-      Obj_Typ     : Entity_Id;\n-      Old_Id      : Entity_Id;\n-      Typ_Size    : Int;\n-      Unsigned_Id : Entity_Id;\n-\n-      function Make_If (Stmt : Node_Id) return Node_Id;\n-      --  Given the statement Stmt, return an if statement with Stmt at the end\n-      --  of the list of statements.\n-\n-      procedure Process_Stmts (Stmts : List_Id);\n-      --  Wrap each return and raise statements in Stmts into an if statement\n-      --  generated by Make_If. Replace all references to the protected object\n-      --  Obj by a reference to its copy Obj_Copy.\n-\n-      -------------\n-      -- Make_If --\n-      -------------\n-\n-      function Make_If (Stmt : Node_Id) return Node_Id is\n-      begin\n-         --  Generate (for Typ_Size = 32):\n-\n-         --  if System.Atomic_Primitives.Atomic_Compare_Exchange_32\n-         --       (Obj'Address,\n-         --        Interfaces.Unsigned_32! (Obj_Old),\n-         --        Interfaces.Unsigned_32! (Obj_Copy));\n-         --  then\n-         --     < Stmt >\n-         --  else\n-         --     goto L0;\n-         --  end if;\n-\n-         --  Check whether a label has already been created\n-\n-         if not Present (Label) then\n-\n-            --  Create a label which will point just after the last\n-            --  statement of the loop statement generated in step 3.\n-\n-            --  Generate:\n-\n-            --  L0 : Label;\n-\n-            Label_Id :=\n-              Make_Identifier (Loc, New_External_Name ('L', 0));\n-\n-            Set_Entity (Label_Id,\n-              Make_Defining_Identifier (Loc, Chars (Label_Id)));\n-            Label := Make_Label (Loc, Label_Id);\n-\n-            Append_To (Decls,\n-              Make_Implicit_Label_Declaration (Loc,\n-                Defining_Identifier => Entity (Label_Id),\n-                Label_Construct     => Label));\n-         end if;\n-\n-         return\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               Make_Function_Call (Loc,\n-                 Name                   => New_Reference_To (At_Comp_Id, Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Reference_To (Obj_Id, Loc),\n-                     Attribute_Name => Name_Address),\n-                   Unchecked_Convert_To (Unsigned_Id,\n-                     New_Reference_To (Old_Id, Loc)),\n-                   Unchecked_Convert_To (Unsigned_Id,\n-                     New_Reference_To (Copy_Id, Loc)))),\n \n-             Then_Statements => New_List (\n-               Relocate_Node (Stmt)),\n+               --  Generate:\n \n-             Else_Statements => New_List (\n-               Make_Goto_Statement (Loc,\n-                 Name => New_Reference_To (Entity (Label_Id), Loc))));\n-      end Make_If;\n+               --    if System.Atomic_Primitives.Atomic_Compare_Exchange\n+               --         (Comp'Address,\n+               --          Interfaces.Unsigned (Saved_Comp),\n+               --          Interfaces.Unsigned (Current_Comp))\n+               --    then\n+               --       <Stmt>;\n+               --    else\n+               --       goto L0;\n+               --    end if;\n+\n+               Rewrite (Stmt,\n+                 Make_If_Statement (Loc,\n+                   Condition =>\n+                     Make_Function_Call (Loc,\n+                       Name                   =>\n+                         New_Reference_To (Compare, Loc),\n+                       Parameter_Associations => New_List (\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix         => New_Reference_To (Comp, Loc),\n+                           Attribute_Name => Name_Address),\n \n-      -------------------\n-      -- Process_Stmts --\n-      -------------------\n+                         Unchecked_Convert_To (Unsigned,\n+                           New_Reference_To (Saved_Comp, Loc)),\n \n-      procedure Process_Stmts (Stmts : List_Id) is\n-         Stmt : Node_Id;\n+                         Unchecked_Convert_To (Unsigned,\n+                           New_Reference_To (Current_Comp, Loc)))),\n \n-         function Check_Node (N : Node_Id) return Traverse_Result;\n-         --  Recognize a return and raise statement and wrap it into an if\n-         --  statement. Replace all references to the protected object by\n-         --  a reference to its copy. Reset all Analyzed flags in order to\n-         --  reanalyze statments inside the new unprotected subprogram body.\n+                   Then_Statements => New_List (Relocate_Node (Stmt)),\n \n-         procedure Process_Nodes is\n-           new Traverse_Proc (Check_Node);\n+                   Else_Statements => New_List (\n+                     Make_Goto_Statement (Loc,\n+                       Name => New_Reference_To (Entity (Label_Id), Loc)))));\n+            end Wrap_Statement;\n \n-         ----------------\n-         -- Check_Node --\n-         ----------------\n+         --  Start of processing for Process_Node\n \n-         function Check_Node (N : Node_Id) return Traverse_Result is\n          begin\n-            --  In case of a procedure, wrap each return and raise statements\n-            --  inside an if statement created by Make_If.\n+            --  Wrap each return and raise statement that appear inside a\n+            --  procedure. Skip the last return statement which is added by\n+            --  default since it is transformed into an exit statement.\n \n             if Is_Procedure\n-             and then Nkind_In (N, N_Simple_Return_Statement,\n-                                   N_Extended_Return_Statement,\n-                                   N_Raise_Statement)\n-             and then\n-               (Nkind (N) /= N_Simple_Return_Statement\n-                 or else N /= Last (Stmts))\n+              and then Nkind_In (N, N_Simple_Return_Statement,\n+                                    N_Extended_Return_Statement,\n+                                    N_Raise_Statement)\n+              and then Nkind (Last (Stmts)) /= N_Simple_Return_Statement\n             then\n-               Rewrite (N, Make_If (N));\n+               Wrap_Statement (N);\n                return Skip;\n \n-            --  Replace all references to the protected object by a reference\n-            --  to the new copy.\n+            --  Replace all references to the original component by a reference\n+            --  to the current state of the component.\n \n             elsif Nkind (N) = N_Identifier\n               and then Present (Entity (N))\n-              and then Entity (N) = Obj_Id\n+              and then Entity (N) = Comp\n             then\n-               Rewrite (N, Make_Identifier (Loc, Chars (Copy_Id)));\n+               Rewrite (N, Make_Identifier (Loc, Chars (Current_Comp)));\n                return Skip;\n             end if;\n \n-            --  We mark the node as unanalyzed in order to reanalyze it inside\n-            --  the unprotected subprogram body.\n+            --  Force reanalysis\n \n             Set_Analyzed (N, False);\n \n             return OK;\n-         end Check_Node;\n+         end Process_Node;\n+\n+         procedure Process_Nodes is new Traverse_Proc (Process_Node);\n+\n+         --  Local variables\n+\n+         Stmt : Node_Id;\n \n       --  Start of processing for Process_Stmts\n \n       begin\n-         --  Process_Nodes for each statement in Stmts\n-\n          Stmt := First (Stmts);\n          while Present (Stmt) loop\n             Process_Nodes (Stmt);\n             Next (Stmt);\n          end loop;\n       end Process_Stmts;\n \n+      --------------------------\n+      -- Referenced_Component --\n+      --------------------------\n+\n+      function Referenced_Component (N : Node_Id) return Entity_Id is\n+         Comp        : Entity_Id;\n+         Decl        : Node_Id;\n+         Source_Comp : Entity_Id := Empty;\n+\n+      begin\n+         --  Find the unique source component which N references in its\n+         --  statements.\n+\n+         for Index in 1 .. Lock_Free_Subprogram_Table.Last loop\n+            declare\n+               Element : Lock_Free_Subprogram renames\n+                         Lock_Free_Subprogram_Table.Table (Index);\n+            begin\n+               if Element.Sub_Body = N then\n+                  Source_Comp := Element.Comp_Id;\n+                  exit;\n+               end if;\n+            end;\n+         end loop;\n+\n+         if No (Source_Comp) then\n+            return Empty;\n+         end if;\n+\n+         --  Find the prival which corresponds to the source component within\n+         --  the declarations of N.\n+\n+         Decl := First (Declarations (N));\n+         while Present (Decl) loop\n+\n+            --  Privals appear as object renamings\n+\n+            if Nkind (Decl) = N_Object_Renaming_Declaration then\n+               Comp := Defining_Identifier (Decl);\n+\n+               if Present (Prival_Link (Comp))\n+                 and then Prival_Link (Comp) = Source_Comp\n+               then\n+                  return Comp;\n+               end if;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+         return Empty;\n+      end Referenced_Component;\n+\n+      --  Local variables\n+\n+      Comp  : constant Entity_Id := Referenced_Component (N);\n+      Decls : constant List_Id   := Declarations (N);\n+      Stmts : List_Id;\n+\n    --  Start of processing for Build_Lock_Free_Unprotected_Subprogram_Body\n \n    begin\n-      New_Stmts := New_Copy_List (Statements (Handled_Statement_Sequence (N)));\n+      Stmts := New_Copy_List (Statements (Handled_Statement_Sequence (N)));\n \n-      --  Do the transformation only if the subprogram accesses a protected\n-      --  component.\n+      --  Perform the lock-free expansion when the subprogram references a\n+      --  protected component.\n \n-      if not Present (Obj_Id) then\n-         goto Continue;\n-      end if;\n-\n-      Copy_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Obj_Id), Suffix => \"_copy\"));\n+      if Present (Comp) then\n+         declare\n+            Comp_Typ     : constant Entity_Id := Etype (Comp);\n+            Typ_Size     : constant Int       := UI_To_Int (Esize (Comp_Typ));\n+            Block_Decls  : List_Id;\n+            Compare      : Entity_Id;\n+            Current_Comp : Entity_Id;\n+            Decl         : Node_Id;\n+            Label        : Node_Id;\n+            Load         : Entity_Id;\n+            Saved_Comp   : Entity_Id;\n+            Stmt         : Node_Id;\n+            Unsigned     : Entity_Id;\n \n-      Obj_Typ  := Etype (Obj_Id);\n-      Typ_Size := UI_To_Int (Esize (Base_Type (Obj_Typ)));\n+         begin\n+            --  Retrieve all relevant atomic routines and types\n \n-      Process_Stmts (New_Stmts);\n+            case Typ_Size is\n+               when 8 =>\n+                  Compare  := RTE (RE_Atomic_Compare_Exchange_8);\n+                  Load     := RTE (RE_Atomic_Load_8);\n+                  Unsigned := RTE (RE_Uint8);\n \n-      --  Procedure case\n+               when 16 =>\n+                  Compare  := RTE (RE_Atomic_Compare_Exchange_16);\n+                  Load     := RTE (RE_Atomic_Load_16);\n+                  Unsigned := RTE (RE_Uint16);\n \n-      if Is_Procedure then\n-         case Typ_Size is\n-            when 8 =>\n-               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_8);\n-               At_Load_Id  := RTE (RE_Atomic_Load_8);\n-               Unsigned_Id := RTE (RE_Uint8);\n+               when 32 =>\n+                  Compare  := RTE (RE_Atomic_Compare_Exchange_32);\n+                  Load     := RTE (RE_Atomic_Load_32);\n+                  Unsigned := RTE (RE_Uint32);\n \n-            when 16 =>\n-               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_16);\n-               At_Load_Id  := RTE (RE_Atomic_Load_16);\n-               Unsigned_Id := RTE (RE_Uint16);\n+               when 64 =>\n+                  Compare  := RTE (RE_Atomic_Compare_Exchange_64);\n+                  Load     := RTE (RE_Atomic_Load_64);\n+                  Unsigned := RTE (RE_Uint64);\n \n-            when 32 =>\n-               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_32);\n-               At_Load_Id  := RTE (RE_Atomic_Load_32);\n-               Unsigned_Id := RTE (RE_Uint32);\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n \n-            when 64 =>\n-               At_Comp_Id  := RTE (RE_Atomic_Compare_Exchange_64);\n-               At_Load_Id  := RTE (RE_Atomic_Load_64);\n-               Unsigned_Id := RTE (RE_Uint64);\n-            when others => null;\n-         end case;\n+            --  Generate:\n+            --    Saved_Comp : constant Comp_Typ :=\n+            --                   Comp_Typ (Atomic_Load (Comp'Address));\n \n-         --  Generate (e.g. for Typ_Size = 32):\n-\n-         --  begin\n-         --     loop\n-         --        declare\n-         --           Obj_Old  : constant Obj_Typ :=\n-         --                        Obj_Typ!\n-         --                          (System.Atomic_Primitives.Atomic_Load_32\n-         --                            (Obj'Address));\n-         --           Obj_Copy : Obj_Typ := Obj_Old;\n-         --        begin\n-         --           < New_Stmts >\n-         --           exit when\n-         --             System.Atomic_Primitives.Atomic_Compare_Exchange_32\n-         --               (Obj'Address,\n-         --                Interfaces.Unsigned_32! (Obj_Old),\n-         --                Interfaces.Unsigned_32! (Obj_Copy));\n-         --        end;\n-         --     end loop;\n-         --  end;\n-\n-         --  Step 1: Define a copy and save the old value of the protected\n-         --  object. The copy replaces all the references to the object present\n-         --  in the body of the procedure.\n+            Saved_Comp :=\n+              Make_Defining_Identifier (Loc,\n+                New_External_Name (Chars (Comp), Suffix => \"_saved\"));\n \n-         --  Generate:\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Saved_Comp,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (Comp_Typ, Loc),\n+                Expression          =>\n+                  Unchecked_Convert_To (Comp_Typ,\n+                    Make_Function_Call (Loc,\n+                      Name                   => New_Reference_To (Load, Loc),\n+                      Parameter_Associations => New_List (\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix         => New_Reference_To (Comp, Loc),\n+                          Attribute_Name => Name_Address)))));\n \n-         --  Obj_Old  : constant Obj_Typ :=\n-         --               Obj_Typ!\n-         --                 (System.Atomic_Primitives.Atomic_Load_32\n-         --                   (Obj'Address));\n-         --  Obj_Copy : Obj_Typ := Obj_Old;\n+            --  Protected procedures\n \n-         Old_Id   := Make_Defining_Identifier (Loc,\n-                       New_External_Name (Chars (Obj_Id), Suffix => \"_old\"));\n+            if Is_Procedure then\n+               Block_Decls := New_List (Decl);\n \n-         New_Decls := New_List (\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Old_Id,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Reference_To (Obj_Typ, Loc),\n-             Expression          => Unchecked_Convert_To (Obj_Typ,\n-               Make_Function_Call (Loc,\n-                 Name                   => New_Reference_To (At_Load_Id, Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Reference_To (Obj_Id, Loc),\n-                     Attribute_Name => Name_Address))))),\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Copy_Id,\n-             Object_Definition   => New_Reference_To (Obj_Typ, Loc),\n-             Expression          => New_Reference_To (Old_Id, Loc)));\n+               --  Generate:\n+               --    Current_Comp : Comp_Typ := Saved_Comp;\n \n-         --  Step 2: Create an exit statement of the loop statement generated\n-         --  in step 3.\n+               Current_Comp :=\n+                 Make_Defining_Identifier (Loc,\n+                   New_External_Name (Chars (Comp), Suffix => \"_current\"));\n \n-         --  Generate (for Typ_Size = 32):\n+               Append_To (Block_Decls,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Current_Comp,\n+                   Object_Definition   => New_Reference_To (Comp_Typ, Loc),\n+                   Expression          => New_Reference_To (Saved_Comp, Loc)));\n \n-         --  exit when System.Atomic_Primitives.Atomic_Compare_Exchange_32\n-         --              (Obj'Address,\n-         --               Interfaces.Unsigned_32! (Obj_Old),\n-         --               Interfaces.Unsigned_32! (Obj_Copy));\n+            --  Protected function\n \n-         Exit_Stmt :=\n-           Make_Exit_Statement (Loc,\n-             Condition =>\n-               Make_Function_Call (Loc,\n-                 Name                   => New_Reference_To (At_Comp_Id, Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Reference_To (Obj_Id, Loc),\n-                     Attribute_Name => Name_Address),\n-                   Unchecked_Convert_To (Unsigned_Id,\n-                     New_Reference_To (Old_Id, Loc)),\n-                   Unchecked_Convert_To (Unsigned_Id,\n-                     New_Reference_To (Copy_Id, Loc)))));\n-\n-         --  Check the last statement is a return statement\n-\n-         if Nkind (Last (New_Stmts)) = N_Simple_Return_Statement then\n-            Rewrite (Last (New_Stmts), Exit_Stmt);\n-         else\n-            Append_To (New_Stmts, Exit_Stmt);\n-         end if;\n+            else\n+               Append_To (Decls, Decl);\n+               Current_Comp := Saved_Comp;\n+            end if;\n \n-         --  Step 3: Create the loop statement which encloses a block\n-         --  declaration that contains all the statements of the original\n-         --  procedure body.\n+            Process_Stmts\n+              (Stmts, Compare, Unsigned, Comp, Saved_Comp, Current_Comp);\n \n-         --  Generate:\n+            --  Generate:\n+            --    exit when System.Atomic_Primitives.Atomic_Compare_Exchange\n+            --                (Comp'Address,\n+            --                 Interfaces.Unsigned (Saved_Comp),\n+            --                 Interfaces.Unsigned (Current_Comp))\n \n-         --  loop\n-         --     declare\n-         --        < New_Decls >\n-         --     begin\n-         --        < New_Stmts >\n-         --     end;\n-         --  end loop;\n+            if Is_Procedure then\n+               Stmt :=\n+                 Make_Exit_Statement (Loc,\n+                   Condition =>\n+                     Make_Function_Call (Loc,\n+                       Name                   =>\n+                         New_Reference_To (Compare, Loc),\n+                       Parameter_Associations => New_List (\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix         => New_Reference_To (Comp, Loc),\n+                           Attribute_Name => Name_Address),\n \n-         New_Stmts := New_List (\n-           Make_Loop_Statement (Loc,\n-             Statements => New_List (\n-               Make_Block_Statement (Loc,\n-                 Declarations               => New_Decls,\n-                 Handled_Statement_Sequence =>\n-                   Make_Handled_Sequence_Of_Statements (Loc,\n-                     Statements => New_Stmts))),\n-             End_Label  => Empty));\n+                         Unchecked_Convert_To (Unsigned,\n+                           New_Reference_To (Saved_Comp, Loc)),\n \n-         --  Append the label to the statements of the loop when needed\n+                         Unchecked_Convert_To (Unsigned,\n+                           New_Reference_To (Current_Comp, Loc)))));\n \n-         if Present (Label) then\n-            Append_To (Statements (First (New_Stmts)), Label);\n-         end if;\n+               --  Small optimization: transform the default return statement\n+               --  of a procedure into the atomic exit statement.\n \n-      --  Function case\n+               if Nkind (Last (Stmts)) = N_Simple_Return_Statement then\n+                  Rewrite (Last (Stmts), Stmt);\n+               else\n+                  Append_To (Stmts, Stmt);\n+               end if;\n+            end if;\n \n-      else\n-         case Typ_Size is\n-            when 8 =>\n-               At_Load_Id := RTE (RE_Atomic_Load_8);\n-            when 16 =>\n-               At_Load_Id := RTE (RE_Atomic_Load_16);\n-            when 32 =>\n-               At_Load_Id := RTE (RE_Atomic_Load_32);\n-            when 64 =>\n-               At_Load_Id := RTE (RE_Atomic_Load_64);\n-            when others => null;\n-         end case;\n+            --  Create the declaration of the label used to skip the rest of\n+            --  the source statements when the object state changes.\n \n-         --  Define a copy of the protected object which replaces all the\n-         --  references to the object present in the body of the function.\n+            if Present (Label_Id) then\n+               Label := Make_Label (Loc, Label_Id);\n \n-         --  Generate:\n+               Append_To (Decls,\n+                 Make_Implicit_Label_Declaration (Loc,\n+                   Defining_Identifier => Entity (Label_Id),\n+                   Label_Construct     => Label));\n \n-         --  Obj_Copy : constant Obj_Typ :=\n-         --               Obj_Typ!\n-         --                 (System.Atomic_Primitives.Atomic_Load_32\n-         --                   (Obj'Address));\n+               Append_To (Stmts, Label);\n+            end if;\n \n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Copy_Id,\n-             Constant_Present => True,\n-             Object_Definition => New_Reference_To (Obj_Typ, Loc),\n-             Expression => Unchecked_Convert_To (Obj_Typ,\n-               Make_Function_Call (Loc,\n-                 Name => New_Reference_To (At_Load_Id, Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix => New_Reference_To (Obj_Id, Loc),\n-                     Attribute_Name => Name_Address))))));\n+            --  Generate:\n+            --    loop\n+            --       declare\n+            --          <Decls>\n+            --       begin\n+            --          <Stmts>\n+            --       end;\n+            --    end loop;\n+\n+            if Is_Procedure then\n+               Stmts := New_List (\n+                 Make_Loop_Statement (Loc,\n+                   Statements => New_List (\n+                     Make_Block_Statement (Loc,\n+                       Declarations               => Block_Decls,\n+                       Handled_Statement_Sequence =>\n+                         Make_Handled_Sequence_Of_Statements (Loc,\n+                           Statements => Stmts))),\n+                   End_Label  => Empty));\n+            end if;\n+         end;\n       end if;\n \n-      << Continue >>\n-\n-      --  Add renamings for the Protection object, discriminals, privals and\n+      --  Add renamings for the protection object, discriminals, privals and\n       --  the entry index constant for use by debugger.\n \n       Debug_Private_Data_Declarations (Decls);\n \n       --  Make an unprotected version of the subprogram for use within the same\n       --  object, with new name and extra parameter representing the object.\n \n-      New_Body :=\n+      return\n         Make_Subprogram_Body (Loc,\n           Specification              =>\n-            Build_Protected_Sub_Specification (N, Pid, Unprotected_Mode),\n+            Build_Protected_Sub_Specification (N, Prot_Typ, Unprotected_Mode),\n           Declarations               => Decls,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_Stmts));\n-      return New_Body;\n+              Statements => Stmts));\n    end Build_Lock_Free_Unprotected_Subprogram_Body;\n \n    -------------------------\n@@ -5436,21 +5398,6 @@ package body Exp_Ch9 is\n       end loop;\n    end Collect_Entry_Families;\n \n-   -------------\n-   -- Comp_Of --\n-   -------------\n-\n-   function Comp_Of (Sub_Body : Node_Id) return Entity_Id is\n-   begin\n-      for Sub_Id in 1 .. LF_Sub_Table.Last loop\n-         if Sub_Body = LF_Sub_Table.Table (Sub_Id).Sub_Body then\n-            return LF_Sub_Table.Table (Sub_Id).Comp_Id;\n-         end if;\n-      end loop;\n-\n-      return Empty;\n-   end Comp_Of;\n-\n    -----------------------\n    -- Concurrent_Object --\n    -----------------------\n@@ -8468,7 +8415,7 @@ package body Exp_Ch9 is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Pid          : constant Entity_Id  := Corresponding_Spec (N);\n \n-      Lock_Free_On : constant Boolean := Allow_Lock_Free_Implementation (N);\n+      Lock_Free_On : constant Boolean := Allows_Lock_Free_Implementation (N);\n       --  This flag indicates whether the lock free implementation is active\n \n       Current_Node : Node_Id;"}, {"sha": "29b435a1bc52794281be8dad3426fb10e890aa43", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -197,8 +197,9 @@ package body Lib.Writ is\n       --  Array of flags to show which units have Elaborate_All_Desirable set\n \n       type Yes_No is (Unknown, Yes, No);\n-\n       Implicit_With : array (Units.First .. Last_Unit) of Yes_No;\n+      --  Indicates if an implicit with has been given for the unit. Yes if\n+      --  certainly present, no if certainly absent, unkonwn if not known.\n \n       Sdep_Table : Unit_Ref_Table (1 .. Pos (Last_Unit - Units.First + 2));\n       --  Sorted table of source dependencies. One extra entry in case we\n@@ -284,7 +285,6 @@ package body Lib.Writ is\n                if Implicit_With (Unum) /= Yes then\n                   if Implicit_With_From_Instantiation (Item) then\n                      Implicit_With (Unum) := Yes;\n-\n                   else\n                      Implicit_With (Unum) := No;\n                   end if;"}, {"sha": "66fd9e20e38ef4ab47fa48ec2eb2fbd4964f7d85", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -1731,9 +1731,9 @@ package body Lib.Xref is\n          --  since at the time the reference or definition is made, private\n          --  types may be swapped, and the Sloc value may be incorrect. We\n          --  also set up the pointer vector for the sort.\n-         --  For user-defined operators we need to skip the initial\n-         --  quote and point to the first character of the name, for\n-         --  navigation purposes.\n+\n+         --  For user-defined operators we need to skip the initial quote and\n+         --  point to the first character of the name, for navigation purposes.\n \n          for J in 1 .. Nrefs loop\n             declare"}, {"sha": "4d8320ad05270936055380d5bad56a4f4294a4b1", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -7790,6 +7790,7 @@ package body Sem_Ch12 is\n                --  Take care to prevent direct cyclic with's\n \n                if Lib_Unit /= Current_Unit then\n+\n                   --  Do not add a unit if it is already in the context\n \n                   Clause := First (Current_Context);"}, {"sha": "233d5ffba7f7f8cbb80125948bbcfd4bd80d6514", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ad16657c9de8b8c1736e2145f8e8f38cb8bff1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=39ad16657c9de8b8c1736e2145f8e8f38cb8bff1", "patch": "@@ -7755,6 +7755,7 @@ package body Sem_Ch3 is\n \n          declare\n             Parent_Full : Entity_Id;\n+\n          begin\n             --  Ekind (Parent_Base) is not necessarily E_Record_Type since\n             --  Parent_Base can be a private type or private extension. Go"}]}