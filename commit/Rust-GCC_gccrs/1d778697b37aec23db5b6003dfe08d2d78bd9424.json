{"sha": "1d778697b37aec23db5b6003dfe08d2d78bd9424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3Nzg2OTdiMzdhZWMyM2RiNWI2MDAzZGZlMDhkMmQ3OGJkOTQyNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-20T12:59:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-20T12:59:45Z"}, "message": "Move code out of vect_slp_analyze_bb_1\n\nAfter the previous patch, it seems more natural to apply the\nPARAM_SLP_MAX_INSNS_IN_BB threshold as soon as we know what\nthe region is, rather than delaying it to vect_slp_analyze_bb_1.\n(But rather than carve out the biggest region possible and then\nreject it, wouldn't it be better to stop when the region gets\ntoo big, to at least give us a chance of vectorising something?)\n\nIt also seems more natural for vect_slp_bb_region to create the\nbb_vec_info itself rather than (a) having to pass bits of data down\nfor the initialisation and (b) forcing vect_slp_analyze_bb_1 to free\non every failure return.\n\n2019-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Take a bb_vec_info\n\tand return a boolean success value.  Move the allocation and\n\tinitialization of the bb_vec_info to...\n\t(vect_slp_bb_region): ...here.  Update call accordingly.\n\t(vect_slp_bb): Apply PARAM_SLP_MAX_INSNS_IN_BB here rather\n\tthan in vect_slp_analyze_bb_1.\n\nFrom-SVN: r277211", "tree": {"sha": "2b0566046eeeaadf0ee073ece8d50e0dbe07d7ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b0566046eeeaadf0ee073ece8d50e0dbe07d7ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d778697b37aec23db5b6003dfe08d2d78bd9424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d778697b37aec23db5b6003dfe08d2d78bd9424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d778697b37aec23db5b6003dfe08d2d78bd9424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d778697b37aec23db5b6003dfe08d2d78bd9424/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa0c8df71d4f0476834db0b7cd88524878b46cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0c8df71d4f0476834db0b7cd88524878b46cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa0c8df71d4f0476834db0b7cd88524878b46cf7"}], "stats": {"total": 106, "additions": 44, "deletions": 62}, "files": [{"sha": "f35cb40e2d64e395d590b8cf09014ac6a76a6dca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d778697b37aec23db5b6003dfe08d2d78bd9424/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d778697b37aec23db5b6003dfe08d2d78bd9424/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d778697b37aec23db5b6003dfe08d2d78bd9424", "patch": "@@ -1,3 +1,12 @@\n+2019-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Take a bb_vec_info\n+\tand return a boolean success value.  Move the allocation and\n+\tinitialization of the bb_vec_info to...\n+\t(vect_slp_bb_region): ...here.  Update call accordingly.\n+\t(vect_slp_bb): Apply PARAM_SLP_MAX_INSNS_IN_BB here rather\n+\tthan in vect_slp_analyze_bb_1.\n+\n 2019-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-slp.c (vect_slp_analyze_bb_1): Call save_datarefs"}, {"sha": "5b4b37fab2b9dd9eb25b124f81b0cea54ea4d982", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 35, "deletions": 62, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d778697b37aec23db5b6003dfe08d2d78bd9424/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d778697b37aec23db5b6003dfe08d2d78bd9424/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=1d778697b37aec23db5b6003dfe08d2d78bd9424", "patch": "@@ -2836,47 +2836,24 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   return true;\n }\n \n-/* Check if the basic block can be vectorized.  Returns a bb_vec_info\n-   if so and sets fatal to true if failure is independent of\n-   current_vector_size.  */\n-\n-static bb_vec_info\n-vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n-\t\t       gimple_stmt_iterator region_end,\n-\t\t       vec<data_reference_p> datarefs, int n_stmts,\n-\t\t       bool &fatal, vec_info_shared *shared)\n+/* Check if the region described by BB_VINFO can be vectorized, returning\n+   true if so.  When returning false, set FATAL to true if the same failure\n+   would prevent vectorization at other vector sizes, false if it is still\n+   worth trying other sizes.  N_STMTS is the number of statements in the\n+   region.  */\n+\n+static bool\n+vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n {\n   DUMP_VECT_SCOPE (\"vect_slp_analyze_bb\");\n \n-  bb_vec_info bb_vinfo;\n   slp_instance instance;\n   int i;\n   poly_uint64 min_vf = 2;\n-  bool first_time_p = shared->datarefs.is_empty ();\n \n   /* The first group of checks is independent of the vector size.  */\n   fatal = true;\n \n-  if (n_stmts > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: too many instructions in \"\n-\t\t\t \"basic block.\\n\");\n-      free_data_refs (datarefs);\n-      return NULL;\n-    }\n-\n-  bb_vinfo = new _bb_vec_info (region_begin, region_end, shared);\n-  if (!bb_vinfo)\n-    return NULL;\n-\n-  BB_VINFO_DATAREFS (bb_vinfo) = datarefs;\n-  if (first_time_p)\n-    bb_vinfo->shared->save_datarefs ();\n-  else\n-    bb_vinfo->shared->check_datarefs ();\n-\n   /* Analyze the data references.  */\n \n   if (!vect_analyze_data_refs (bb_vinfo, &min_vf, NULL))\n@@ -2885,9 +2862,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: unhandled data-ref in basic \"\n \t\t\t \"block.\\n\");\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   if (BB_VINFO_DATAREFS (bb_vinfo).length () < 2)\n@@ -2896,9 +2871,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: not enough data-refs in \"\n \t\t\t \"basic block.\\n\");\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   if (!vect_analyze_data_ref_accesses (bb_vinfo))\n@@ -2907,9 +2880,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\"not vectorized: unhandled data access in \"\n \t\t\t\"basic block.\\n\");\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   /* If there are no grouped stores in the region there is no need\n@@ -2921,9 +2892,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: no grouped stores in \"\n \t\t\t \"basic block.\\n\");\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   /* While the rest of the analysis below depends on it in some way.  */\n@@ -2943,9 +2912,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t\t   \"not vectorized: failed to find SLP opportunities \"\n \t\t\t   \"in basic block.\\n\");\n \t}\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   vect_record_base_alignments (bb_vinfo);\n@@ -2976,19 +2943,14 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       i++;\n     }\n   if (! BB_VINFO_SLP_INSTANCES (bb_vinfo).length ())\n-    {\n-      delete bb_vinfo;\n-      return NULL;\n-    }\n+    return false;\n \n   if (!vect_slp_analyze_operations (bb_vinfo))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: bad operation in basic block.\\n\");\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   /* Cost model: check if the vectorization is worthwhile.  */\n@@ -2999,16 +2961,13 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: vectorization is not \"\n \t\t\t \"profitable.\\n\");\n-\n-      delete bb_vinfo;\n-      return NULL;\n+      return false;\n     }\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"Basic block will be vectorized using SLP\\n\");\n-\n-  return bb_vinfo;\n+  return true;\n }\n \n /* Subroutine of vect_slp_bb.  Try to vectorize the statements between\n@@ -3037,9 +2996,16 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n     {\n       bool vectorized = false;\n       bool fatal = false;\n-      bb_vinfo = vect_slp_analyze_bb_1 (region_begin, region_end,\n-\t\t\t\t\tdatarefs, n_stmts, fatal, &shared);\n-      if (bb_vinfo\n+      bb_vinfo = new _bb_vec_info (region_begin, region_end, &shared);\n+\n+      bool first_time_p = shared.datarefs.is_empty ();\n+      BB_VINFO_DATAREFS (bb_vinfo) = datarefs;\n+      if (first_time_p)\n+\tbb_vinfo->shared->save_datarefs ();\n+      else\n+\tbb_vinfo->shared->check_datarefs ();\n+\n+      if (vect_slp_analyze_bb_1 (bb_vinfo, n_stmts, fatal)\n \t  && dbg_cnt (vect_slp))\n \t{\n \t  if (dump_enabled_p ())\n@@ -3132,7 +3098,14 @@ vect_slp_bb (basic_block bb)\n \n       gimple_stmt_iterator region_end = gsi;\n \n-      if (vect_slp_bb_region (region_begin, region_end, datarefs, insns))\n+      if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: too many instructions in \"\n+\t\t\t     \"basic block.\\n\");\n+\t}\n+      else if (vect_slp_bb_region (region_begin, region_end, datarefs, insns))\n \tany_vectorized = true;\n \n       if (gsi_end_p (region_end))"}]}