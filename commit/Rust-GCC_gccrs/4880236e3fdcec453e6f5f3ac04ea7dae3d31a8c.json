{"sha": "4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4MDIzNmUzZmRjZWM0NTNlNmY1ZjNhYzA0ZWE3ZGFlM2QzMWE4Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-07-09T10:13:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-07-09T10:13:01Z"}, "message": "re PR libstdc++/49668 ([C++0x] std::thread does not forward its args as rvalues)\n\n2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\tPR libstdc++/49668\n\t* include/std/functional (__bind_simple): Define.\n\t* include/std/future (_Task_setter): Parameterize by type of result\n\tpointer instead of state object.\n\t(_S_task_setter): Type deduction helper.\n\t(_Task_state): Use _S_task_setter and __bind_simple.\n\t(_Deferred_state, _Async_state): Store call wrapper directly not as\n\tstd::function. Use _S_task_setter and __bind_simple.\n\t(_S_make_deferred_state, _S_make_async_state): Type deduction helpers.\n\t(async): Use new functions and __bind_simple.\n\t* include/std/mutex (call_once): Use __bind_simple.\n\t* include/std/thread (thread): Likewise. Remove unused headers.\n\t* src/thread.cc: Add header.\n\t* testsuite/30_threads/async/49668.cc: New.\n\t* testsuite/30_threads/call_once/49668.cc: New.\n\t* testsuite/30_threads/thread/cons/49668.cc: New.\n\t* testsuite/30_threads/thread/cons/moveable.cc: Remove unused bool.\n\nFrom-SVN: r176073", "tree": {"sha": "220d98d77838ae389eb4bbbfd1acdd2be8814bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/220d98d77838ae389eb4bbbfd1acdd2be8814bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4063e61bc63c3803f8ab2d625ebe8432ac06b3da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4063e61bc63c3803f8ab2d625ebe8432ac06b3da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4063e61bc63c3803f8ab2d625ebe8432ac06b3da"}], "stats": {"total": 428, "additions": 381, "deletions": 47}, "files": [{"sha": "663683f4a6ba3adbe9750d11a5825c432cd53cec", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -1,3 +1,23 @@\n+2011-07-09  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/49668\n+\t* include/std/functional (__bind_simple): Define.\n+\t* include/std/future (_Task_setter): Parameterize by type of result\n+\tpointer instead of state object.\n+\t(_S_task_setter): Type deduction helper.\n+\t(_Task_state): Use _S_task_setter and __bind_simple.\n+\t(_Deferred_state, _Async_state): Store call wrapper directly not as\n+\tstd::function. Use _S_task_setter and __bind_simple.\n+\t(_S_make_deferred_state, _S_make_async_state): Type deduction helpers.\n+\t(async): Use new functions and __bind_simple.\n+\t* include/std/mutex (call_once): Use __bind_simple.\n+\t* include/std/thread (thread): Likewise. Remove unused headers.\n+\t* src/thread.cc: Add header.\n+\t* testsuite/30_threads/async/49668.cc: New.\n+\t* testsuite/30_threads/call_once/49668.cc: New.\n+\t* testsuite/30_threads/thread/cons/49668.cc: New.\n+\t* testsuite/30_threads/thread/cons/moveable.cc: Remove unused bool.\n+\n 2011-07-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.host (abi_baseline_subdir_switch): Describe."}, {"sha": "df3f9ceb7b43248a94be5430368f6289e945b4e9", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -1499,6 +1499,77 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t\t\t   std::forward<_BoundArgs>(__args)...);\n     }\n \n+  template<typename _Signature>\n+    struct _Bind_simple;\n+\n+  template<typename _Callable, typename... _Args>\n+    struct _Bind_simple<_Callable(_Args...)>\n+    {\n+      typedef typename result_of<_Callable(_Args...)>::type result_type;\n+\n+      template<typename... _Args2, typename = typename\n+               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>\n+        explicit\n+        _Bind_simple(const _Callable& __callable, _Args2&&... __args)\n+        : _M_bound(__callable, std::forward<_Args2>(__args)...)\n+        { }\n+\n+      template<typename... _Args2, typename = typename\n+               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>\n+        explicit\n+        _Bind_simple(_Callable&& __callable, _Args2&&... __args)\n+        : _M_bound(std::move(__callable), std::forward<_Args2>(__args)...)\n+        { }\n+\n+      _Bind_simple(const _Bind_simple&) = default;\n+      _Bind_simple(_Bind_simple&&) = default;\n+\n+      result_type\n+      operator()()\n+      {\n+        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;\n+        return _M_invoke(_Indices());\n+      }\n+\n+    private:\n+\n+      template<int... _Indices>\n+        typename result_of<_Callable(_Args...)>::type\n+        _M_invoke(_Index_tuple<_Indices...>)\n+        {\n+\t  // std::bind always forwards bound arguments as lvalues,\n+\t  // but this type can call functions which only accept rvalues.\n+          return std::forward<_Callable>(std::get<0>(_M_bound))(\n+              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);\n+        }\n+\n+      std::tuple<_Callable, _Args...> _M_bound;\n+    };\n+\n+  template<typename _Func, typename... _BoundArgs>\n+    struct _Bind_simple_helper\n+    {\n+      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>\n+        __maybe_type;\n+      typedef typename __maybe_type::type __func_type;\n+      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>\n+       \t__type;\n+    };\n+\n+  // Simplified version of std::bind for internal use, without support for\n+  // unbound arguments, placeholders or nested bind expressions.\n+  template<typename _Callable, typename... _Args>\n+    typename _Bind_simple_helper<_Callable, _Args...>::__type\n+    __bind_simple(_Callable&& __callable, _Args&&... __args)\n+    {\n+      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;\n+      typedef typename __helper_type::__maybe_type __maybe_type;\n+      typedef typename __helper_type::__type __result_type;\n+      return __result_type(\n+          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),\n+          std::forward<_Args>(__args)...);\n+    }\n+\n   /**\n    *  @brief Exception class thrown when class template function's\n    *  operator() is called with an empty target."}, {"sha": "fc2d3248b0195cb34f29f135f04ea20fb6548ec7", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 72, "deletions": 39, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -488,17 +488,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       virtual void _M_run_deferred() { }\n     };\n \n-    template<typename _Res>\n+    template<typename _BoundFn, typename = typename _BoundFn::result_type>\n       class _Deferred_state;\n \n-    template<typename _Res>\n+    template<typename _BoundFn, typename = typename _BoundFn::result_type>\n       class _Async_state;\n \n     template<typename _Signature>\n       class _Task_state;\n \n-    template<typename _StateT, typename _Res = typename _StateT::_Res_type>\n+    template<typename _BoundFn>\n+      static std::shared_ptr<_State_base>\n+      _S_make_deferred_state(_BoundFn&& __fn);\n+\n+    template<typename _BoundFn>\n+      static std::shared_ptr<_State_base>\n+      _S_make_async_state(_BoundFn&& __fn);\n+\n+    template<typename _Res_ptr, typename _Res>\n       struct _Task_setter;\n+\n+    template<typename _Res_ptr, typename _BoundFn>\n+      class _Task_setter_helper\n+      {\n+\ttypedef typename remove_reference<_BoundFn>::type::result_type __res;\n+      public:\n+\ttypedef _Task_setter<_Res_ptr, __res> __type;\n+      };\n+\n+    template<typename _Res_ptr, typename _BoundFn>\n+      static typename _Task_setter_helper<_Res_ptr, _BoundFn>::__type\n+      _S_task_setter(_Res_ptr& __ptr, _BoundFn&& __call)\n+      {\n+\ttypedef _Task_setter_helper<_Res_ptr, _BoundFn> __helper_type;\n+\ttypedef typename __helper_type::__type _Setter;\n+\treturn _Setter{ __ptr, std::ref(__call) };\n+      }\n   };\n \n   /// Partial specialization for reference types.\n@@ -1165,41 +1190,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   }\n \n \n-  template<typename _StateT, typename _Res>\n+  template<typename _Ptr_type, typename _Res>\n     struct __future_base::_Task_setter\n     {\n-      typename _StateT::_Ptr_type operator()()\n+      _Ptr_type operator()()\n       {\n         __try\n \t  {\n-\t    _M_state->_M_result->_M_set(_M_fn());\n+\t    _M_result->_M_set(_M_fn());\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_state->_M_result->_M_error = current_exception();\n+\t    _M_result->_M_error = current_exception();\n \t  }\n-        return std::move(_M_state->_M_result);\n+        return std::move(_M_result);\n       }\n-      _StateT*                  _M_state;\n+      _Ptr_type&                _M_result;\n       std::function<_Res()>     _M_fn;\n     };\n \n-  template<typename _StateT>\n-    struct __future_base::_Task_setter<_StateT, void>\n+  template<typename _Ptr_type>\n+    struct __future_base::_Task_setter<_Ptr_type, void>\n     {\n-      typename _StateT::_Ptr_type operator()()\n+      _Ptr_type operator()()\n       {\n         __try\n \t  {\n \t    _M_fn();\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_state->_M_result->_M_error = current_exception();\n+\t    _M_result->_M_error = current_exception();\n \t  }\n-\treturn std::move(_M_state->_M_result);\n+\treturn std::move(_M_result);\n       }\n-      _StateT*                  _M_state;\n+      _Ptr_type&                _M_result;\n       std::function<void()>     _M_fn;\n     };\n \n@@ -1223,13 +1248,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_run(_Args... __args)\n       {\n         // bound arguments decay so wrap lvalue references\n-        auto __bound = std::bind<_Res>(std::ref(_M_task),\n-            _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n-        _Task_setter<_Task_state> __setter{ this, std::move(__bound) };\n+\tauto __boundfn = std::__bind_simple(std::ref(_M_task),\n+\t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n+        auto __setter = _S_task_setter(_M_result, std::move(__boundfn));\n         _M_set_result(std::move(__setter));\n       }\n \n-      template<typename, typename> friend class _Task_setter;\n       typedef typename __future_base::_Ptr<_Result<_Res>>::type _Ptr_type;\n       _Ptr_type _M_result;\n       std::function<_Res(_Args...)> _M_task;\n@@ -1331,40 +1355,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public true_type { };\n \n \n-  template<typename _Res>\n+  template<typename _BoundFn, typename _Res>\n     class __future_base::_Deferred_state : public __future_base::_State_base\n     {\n     public:\n-      typedef _Res _Res_type;\n-\n       explicit\n-      _Deferred_state(std::function<_Res()>&& __fn)\n+      _Deferred_state(_BoundFn&& __fn)\n       : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))\n       { }\n \n     private:\n-      template<typename, typename> friend class _Task_setter;\n       typedef typename __future_base::_Ptr<_Result<_Res>>::type _Ptr_type;\n       _Ptr_type _M_result;\n-      std::function<_Res()> _M_fn;\n+      _BoundFn _M_fn;\n \n       virtual void\n       _M_run_deferred()\n       {\n-        _Task_setter<_Deferred_state> __setter{ this, _M_fn };\n         // safe to call multiple times so ignore failure\n-        _M_set_result(std::move(__setter), true);\n+        _M_set_result(_S_task_setter(_M_result, _M_fn), true);\n       }\n     };\n \n-  template<typename _Res>\n+  template<typename _BoundFn, typename _Res>\n     class __future_base::_Async_state : public __future_base::_State_base\n     {\n     public:\n-      typedef _Res _Res_type;\n-\n       explicit\n-      _Async_state(std::function<_Res()>&& __fn)\n+      _Async_state(_BoundFn&& __fn)\n       : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn)),\n \t_M_thread(mem_fn(&_Async_state::_M_do_run), this)\n       { }\n@@ -1374,17 +1392,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       void _M_do_run()\n       {\n-        _Task_setter<_Async_state> __setter{ this, std::move(_M_fn) };\n-        _M_set_result(std::move(__setter));\n+        _M_set_result(_S_task_setter(_M_result, _M_fn));\n       }\n \n-      template<typename, typename> friend class _Task_setter;\n       typedef typename __future_base::_Ptr<_Result<_Res>>::type _Ptr_type;\n       _Ptr_type _M_result;\n-      std::function<_Res()> _M_fn;\n+      _BoundFn _M_fn;\n       thread _M_thread;\n     };\n \n+  template<typename _BoundFn>\n+    inline std::shared_ptr<__future_base::_State_base>\n+    __future_base::_S_make_deferred_state(_BoundFn&& __fn)\n+    {\n+      typedef typename remove_reference<_BoundFn>::type __fn_type;\n+      typedef _Deferred_state<__fn_type> __state_type;\n+      return std::make_shared<__state_type>(std::move(__fn));\n+    }\n+\n+  template<typename _BoundFn>\n+    inline std::shared_ptr<__future_base::_State_base>\n+    __future_base::_S_make_async_state(_BoundFn&& __fn)\n+    {\n+      typedef typename remove_reference<_BoundFn>::type __fn_type;\n+      typedef _Async_state<__fn_type> __state_type;\n+      return std::make_shared<__state_type>(std::move(__fn));\n+    }\n+\n+\n   /// async\n   template<typename _Fn, typename... _Args>\n     future<typename result_of<_Fn(_Args...)>::type>\n@@ -1394,14 +1429,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::shared_ptr<__future_base::_State_base> __state;\n       if ((__policy & (launch::async|launch::deferred)) == launch::async)\n \t{\n-\t  typedef typename __future_base::_Async_state<result_type> _State;\n-\t  __state = std::make_shared<_State>(std::bind<result_type>(\n+\t  __state = __future_base::_S_make_async_state(std::__bind_simple(\n               std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));\n \t}\n       else\n \t{\n-\t  typedef typename __future_base::_Deferred_state<result_type> _State;\n-\t  __state = std::make_shared<_State>(std::bind<result_type>(\n+\t  __state = __future_base::_S_make_deferred_state(std::__bind_simple(\n               std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));\n \t}\n       return future<result_type>(__state);"}, {"sha": "1c66afc9e2ceb6e266ec942b28c9ae7b09069d11", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -801,13 +801,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)\n     {\n #ifdef _GLIBCXX_HAVE_TLS\n-      auto __bound_functor = std::bind<void>(std::forward<_Callable>(__f),\n+      auto __bound_functor = std::__bind_simple(std::forward<_Callable>(__f),\n           std::forward<_Args>(__args)...);\n       __once_callable = &__bound_functor;\n       __once_call = &__once_call_impl<decltype(__bound_functor)>;\n #else\n       unique_lock<mutex> __functor_lock(__get_once_mutex());\n-      __once_functor = std::bind<void>(std::forward<_Callable>(__f),\n+      __once_functor = std::__bind_simple(std::forward<_Callable>(__f),\n           std::forward<_Args>(__args)...);\n       __set_once_functor_lock_ptr(&__functor_lock);\n #endif"}, {"sha": "8cc06903ebf9ada993ecce79bc8df95f7f777c16", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -38,8 +38,6 @@\n #include <chrono>\n #include <functional>\n #include <memory>\n-#include <mutex>\n-#include <condition_variable>\n #include <bits/functexcept.h>\n #include <bits/functional_hash.h>\n #include <bits/gthr.h>\n@@ -132,7 +130,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       explicit \n       thread(_Callable&& __f, _Args&&... __args)\n       {\n-        _M_start_thread(_M_make_routine(std::bind<void>(\n+        _M_start_thread(_M_make_routine(std::__bind_simple(\n                 std::forward<_Callable>(__f),\n                 std::forward<_Args>(__args)...)));\n       }"}, {"sha": "09e7fc5909daa859c46feabc42b39f7651e77b09", "filename": "libstdc++-v3/src/thread.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -24,6 +24,7 @@\n \n \n #include <thread>\n+#include <system_error>\n #include <cerrno>\n \n #if defined(_GLIBCXX_USE_GET_NPROCS)"}, {"sha": "4d5bd0515ea28d7ccd15e09e72a28c17af081d3e", "filename": "libstdc++-v3/testsuite/30_threads/async/49668.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2F49668.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2F49668.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2F49668.cc?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <future>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct moveable\n+{\n+  moveable() = default;\n+  moveable(moveable&&) = default;\n+  moveable(const moveable&) = delete;\n+};\n+\n+using std::launch;\n+namespace ph = std::placeholders;\n+\n+typedef decltype(ph::_1) placeholder_type;\n+\n+bool f(moveable, placeholder_type) { return true; }\n+\n+void test01()\n+{\n+  auto fut = std::async(launch::async, f, moveable(), ph::_1);\n+  bool test = fut.get();\n+  VERIFY( test );\n+}\n+\n+void test02()\n+{\n+  auto fut = std::async(launch::deferred, f, moveable(), ph::_1);\n+  bool test = fut.get();\n+  VERIFY( test );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "3215182f01d59e4d752fa8828a4b698d40500075", "filename": "libstdc++-v3/testsuite/30_threads/call_once/49668.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F49668.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F49668.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F49668.cc?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <mutex>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct moveable\n+{\n+  moveable() = default;\n+  moveable(moveable&&) = default;\n+  moveable(const moveable&) = delete;\n+};\n+\n+typedef decltype(std::placeholders::_1) placeholder_type;\n+\n+void f(moveable, placeholder_type, bool& b) { b = true; }\n+\n+void test01()\n+{\n+  bool test = false;\n+  std::once_flag once;\n+  std::call_once(once, f, moveable(), std::placeholders::_1, std::ref(test));\n+  VERIFY( test );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "55a2f07c1e8b8226bb9aaee239246444dd32aac0", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/49668.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2F49668.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2F49668.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2F49668.cc?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+struct moveable\n+{\n+  moveable() = default;\n+  moveable(moveable&&) = default;\n+};\n+\n+typedef decltype(std::placeholders::_1) placeholder_type;\n+\n+bool f(moveable, placeholder_type) { return true; }\n+\n+void test01()\n+{\n+  std::packaged_task<bool(moveable, placeholder_type)> p(f);\n+  p(moveable(), std::placeholders::_1);\n+  bool test = p.get_future().get();\n+  VERIFY( test );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "f6faa8c182e2588a2f58c59e8ba5e32ca5b6e0af", "filename": "libstdc++-v3/testsuite/30_threads/thread/cons/49668.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthread%2Fcons%2F49668.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthread%2Fcons%2F49668.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthread%2Fcons%2F49668.cc?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -0,0 +1,51 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <thread>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct moveable\n+{\n+  moveable() = default;\n+  moveable(moveable&&) = default;\n+  moveable(const moveable&) = delete;\n+};\n+\n+typedef decltype(std::placeholders::_1) placeholder_type;\n+\n+void f(moveable, placeholder_type, bool& b) { b = true; }\n+\n+void test01()\n+{\n+  bool test = false;\n+  std::thread t(f, moveable(), std::placeholders::_1, std::ref(test));\n+  t.join();\n+  VERIFY( test );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "961ae0259bf3f6d79d582570470d429e31f6b0b9", "filename": "libstdc++-v3/testsuite/30_threads/thread/cons/moveable.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthread%2Fcons%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthread%2Fcons%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthread%2Fcons%2Fmoveable.cc?ref=4880236e3fdcec453e6f5f3ac04ea7dae3d31a8c", "patch": "@@ -5,7 +5,7 @@\n // { dg-require-cstdint \"\" }\n // { dg-require-gthreads \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,8 +27,6 @@\n #include <utility>\n #include <testsuite_hooks.h>\n \n-bool functor_was_called = false;\n-\n struct moveable\n {\n   moveable() = default;"}]}