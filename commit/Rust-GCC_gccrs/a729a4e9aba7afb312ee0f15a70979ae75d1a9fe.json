{"sha": "a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcyOWE0ZTlhYmE3YWZiMzEyZWUwZjE1YTcwOTc5YWU3NWQxYTlmZQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2000-08-19T18:19:42Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-08-19T18:19:42Z"}, "message": "Attributes.java, [...]: Imported from Classpath.\n\nSat Aug 19 11:00:53 2000  Anthony Green  <green@redhat.com>\n\n\t* java/util/jar/Attributes.java, java/util/jar/JarEntry.java,\n\tjava/util/jar/JarException.java, java/util/jar/JarFile.java,\n\tjava/util/jar/JarInputStream.java,\n\tjava/util/jar/JarOutputStream.java, java/util/jar/Manifest.java,\n\tjava/util/Set.java, java/util/Map.java, java/util/Bucket.java,\n\tjava/util/AbstractSet.java, java/util/BasicMapEntry.java,\n\tjava/security/cert/CRL.java, java/security/cert/CRLException.java,\n\tjava/security/cert/Certificate.java,\n\tjava/security/cert/CertificateEncodingException.java,\n\tjava/security/cert/CertificateException.java,\n\tjava/security/cert/CertificateExpiredException.java,\n\tjava/security/cert/CertificateFactory.java,\n\tjava/security/cert/CertificateFactorySpi.java,\n\tjava/security/cert/CertificateNotYetValidException.java,\n\tjava/security/cert/CertificateParsingException.java,\n\tjava/security/cert/X509CRL.java,\n\tjava/security/cert/X509CRLEntry.java,\n\tjava/security/cert/X509Certificate.java,\n\tjava/security/cert/X509Extension.java: Imported from Classpath.\n\t* java/util/Hashtable.java: Imported from Classpath.\n\n\t* java/util/zip/ZipInputStream.java: Create stub for\n\tcreateZipEntry.\n\n\t* gcj/javaprims.h: Updated class list.\n\n\t* Makefile.in, gcj/Makefile.in: Rebuilt.\n\t* Makefile.am (ordinary_java_source_files): Add these new classes.\n\nFrom-SVN: r35809", "tree": {"sha": "2dff323eee68e61f9225ea0c6c7f15f7c6bcd624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dff323eee68e61f9225ea0c6c7f15f7c6bcd624"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e76d9acbe9055e6f0ec35f4e5d0893ca10baf643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76d9acbe9055e6f0ec35f4e5d0893ca10baf643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e76d9acbe9055e6f0ec35f4e5d0893ca10baf643"}], "stats": {"total": 6605, "additions": 5890, "deletions": 715}, "files": [{"sha": "4ca76d32785c44c276fe14edd2f1a1fe5f9491d5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -1,3 +1,34 @@\n+Sat Aug 19 11:00:53 2000  Anthony Green  <green@redhat.com>\n+\n+\t* java/util/jar/Attributes.java, java/util/jar/JarEntry.java,\n+\tjava/util/jar/JarException.java, java/util/jar/JarFile.java,\n+\tjava/util/jar/JarInputStream.java,\n+\tjava/util/jar/JarOutputStream.java, java/util/jar/Manifest.java,\n+\tjava/util/Set.java, java/util/Map.java, java/util/Bucket.java,\n+\tjava/util/AbstractSet.java, java/util/BasicMapEntry.java,\n+\tjava/security/cert/CRL.java, java/security/cert/CRLException.java,\n+\tjava/security/cert/Certificate.java,\n+\tjava/security/cert/CertificateEncodingException.java,\n+\tjava/security/cert/CertificateException.java,\n+\tjava/security/cert/CertificateExpiredException.java,\n+\tjava/security/cert/CertificateFactory.java,\n+\tjava/security/cert/CertificateFactorySpi.java,\n+\tjava/security/cert/CertificateNotYetValidException.java,\n+\tjava/security/cert/CertificateParsingException.java,\n+\tjava/security/cert/X509CRL.java,\n+\tjava/security/cert/X509CRLEntry.java,\n+\tjava/security/cert/X509Certificate.java,\n+\tjava/security/cert/X509Extension.java: Imported from Classpath.\n+\t* java/util/Hashtable.java: Imported from Classpath.\n+\n+\t* java/util/zip/ZipInputStream.java: Create stub for\n+\tcreateZipEntry.\n+\n+\t* gcj/javaprims.h: Updated class list.\n+\n+\t* Makefile.in, gcj/Makefile.in: Rebuilt.\n+\t* Makefile.am (ordinary_java_source_files): Add these new classes.\n+\t\n 2000-08-16  Rolf W. Rasmussen  <rolfwr@ii.uib.no>\n \n \t* gnu/gcj/awt/ComponentDataBlitOp.java: New file."}, {"sha": "8c04f661da5d081d98c77474b1849679fb3a1ca8", "filename": "libjava/Makefile.am", "status": "modified", "additions": 171, "deletions": 148, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -718,12 +718,20 @@ built_java_source_files = java/lang/ConcreteProcess.java\n ## header, please list it in special_java_source_files.\n ordinary_java_source_files =  $(convert_source_files) \\\n $(awt_java_source_files) \\\n-gnu/gcj/protocol/http/Connection.java \\\n-gnu/gcj/protocol/http/Handler.java \\\n+gnu/gcj/RawData.java \\\n+gnu/gcj/io/DefaultMimeTypes.java \\\n+gnu/gcj/io/MimeTypes.java \\\n+gnu/gcj/io/SimpleSHSStream.java\t\\\n+gnu/gcj/jni/NativeThread.java \\\n+gnu/gcj/math/MPN.java \\\n gnu/gcj/protocol/file/Connection.java \\\n gnu/gcj/protocol/file/Handler.java \\\n+gnu/gcj/protocol/http/Connection.java \\\n+gnu/gcj/protocol/http/Handler.java \\\n gnu/gcj/protocol/jar/Connection.java \\\n gnu/gcj/protocol/jar/Handler.java \\\n+gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/runtime/VMClassLoader.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n@@ -732,23 +740,16 @@ gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n gnu/gcj/util/EnumerationChain.java \\\n-gnu/gcj/RawData.java \\\n-gnu/gcj/math/MPN.java \\\n-gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/runtime/FirstThread.java \\\n-gnu/gcj/jni/NativeThread.java \\\n-gnu/gcj/io/DefaultMimeTypes.java \\\n-gnu/gcj/io/MimeTypes.java \\\n-gnu/gcj/io/SimpleSHSStream.java\t\\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n-gnu/java/lang/reflect/TypeSignature.java \\\n gnu/java/lang/ArrayHelper.java \\\n gnu/java/lang/ClassHelper.java \\\n+gnu/java/lang/reflect/TypeSignature.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+java/io/BlockDataException.java\t\\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n java/io/BufferedReader.java \\\n@@ -763,7 +764,9 @@ java/io/DataInputStream.java \\\n java/io/DataOutput.java\t\\\n java/io/DataOutputStream.java \\\n java/io/EOFException.java \\\n+java/io/Externalizable.java \\\n java/io/File.java \\\n+java/io/FileDescriptor.java \\\n java/io/FileInputStream.java \\\n java/io/FileNotFoundException.java \\\n java/io/FileOutputStream.java \\\n@@ -778,12 +781,25 @@ java/io/IOException.java \\\n java/io/InputStream.java \\\n java/io/InputStreamReader.java \\\n java/io/InterruptedIOException.java \\\n+java/io/InvalidClassException.java \\\n+java/io/InvalidObjectException.java \\\n java/io/LineNumberInputStream.java \\\n java/io/LineNumberReader.java \\\n+java/io/NotActiveException.java\t\\\n+java/io/NotSerializableException.java \\\n+java/io/ObjectInput.java \\\n+java/io/ObjectInputStream.java \\\n+java/io/ObjectInputValidation.java \\\n+java/io/ObjectOutput.java \\\n+java/io/ObjectOutputStream.java\t\\\n+java/io/ObjectStreamClass.java \\\n+java/io/ObjectStreamConstants.java \\\n+java/io/ObjectStreamException.java \\\n+java/io/ObjectStreamField.java \\\n+java/io/OptionalDataException.java \\\n java/io/OutputStream.java \\\n java/io/OutputStreamWriter.java\t\\\n-java/io/Externalizable.java \\\n-java/io/FileDescriptor.java \\\n+java/io/PipedInputStream.java \\\n java/io/PipedOutputStream.java \\\n java/io/PipedReader.java \\\n java/io/PipedWriter.java \\\n@@ -793,45 +809,21 @@ java/io/PushbackInputStream.java \\\n java/io/PushbackReader.java \\\n java/io/RandomAccessFile.java \\\n java/io/Reader.java \\\n+java/io/Replaceable.java \\\n+java/io/Resolvable.java\t\\\n java/io/SequenceInputStream.java \\\n java/io/Serializable.java \\\n+java/io/SerializablePermission.java \\\n+java/io/StreamCorruptedException.java \\\n java/io/StreamTokenizer.java \\\n java/io/StringBufferInputStream.java \\\n java/io/StringReader.java \\\n java/io/StringWriter.java \\\n java/io/SyncFailedException.java \\\n java/io/UTFDataFormatException.java \\\n java/io/UnsupportedEncodingException.java \\\n-java/io/Writer.java \\\n-java/io/ObjectStreamException.java \\\n-java/io/OptionalDataException.java \\\n-java/io/StreamCorruptedException.java \\\n-java/io/BlockDataException.java\t\\\n-java/io/InvalidClassException.java \\\n-java/io/InvalidObjectException.java \\\n-java/io/NotActiveException.java\t\\\n-java/io/NotSerializableException.java \\\n-java/io/ObjectInput.java \\\n-java/io/ObjectInputStream.java \\\n-java/io/ObjectInputValidation.java \\\n-java/io/ObjectOutput.java \\\n-java/io/ObjectOutputStream.java\t\\\n-java/io/ObjectStreamClass.java \\\n-java/io/ObjectStreamConstants.java \\\n-java/io/ObjectStreamField.java \\\n-java/io/Replaceable.java \\\n-java/io/Resolvable.java\t\\\n-java/io/SerializablePermission.java \\\n java/io/WriteAbortedException.java \\\n-java/io/PipedInputStream.java \\\n-java/lang/reflect/Constructor.java \\\n-java/lang/reflect/AccessibleObject.java\t\\\n-java/lang/reflect/Array.java \\\n-java/lang/reflect/Method.java \\\n-java/lang/reflect/Field.java \\\n-java/lang/reflect/InvocationTargetException.java \\\n-java/lang/reflect/Member.java \\\n-java/lang/reflect/Modifier.java\t\\\n+java/io/Writer.java \\\n java/lang/AbstractMethodError.java \\\n java/lang/ArithmeticException.java \\\n java/lang/ArrayIndexOutOfBoundsException.java \\\n@@ -860,10 +852,10 @@ java/lang/IllegalMonitorStateException.java \\\n java/lang/IllegalStateException.java \\\n java/lang/IllegalThreadStateException.java \\\n java/lang/IncompatibleClassChangeError.java \\\n-java/lang/InstantiationError.java \\\n-java/lang/Integer.java \\\n java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InstantiationError.java \\\n java/lang/InstantiationException.java \\\n+java/lang/Integer.java \\\n java/lang/InternalError.java \\\n java/lang/InterruptedException.java \\\n java/lang/LinkageError.java \\\n@@ -901,126 +893,54 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/Void.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Modifier.java\t\\\n+java/math/BigDecimal.java \\\n+java/math/BigInteger.java \\\n java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n java/net/ContentHandlerFactory.java \\\n+java/net/DatagramPacket.java \\\n+java/net/DatagramSocket.java \\\n+java/net/DatagramSocketImpl.java \\\n java/net/FileNameMap.java \\\n java/net/HttpURLConnection.java\t\\\n java/net/InetAddress.java \\\n+java/net/JarURLConnection.java \\\n java/net/MalformedURLException.java \\\n+java/net/MulticastSocket.java \\\n java/net/NoRouteToHostException.java \\\n+java/net/PlainDatagramSocketImpl.java \\\n java/net/PlainSocketImpl.java \\\n java/net/ProtocolException.java\t\\\n java/net/ServerSocket.java \\\n-java/net/URL.java \\\n java/net/Socket.java \\\n java/net/SocketException.java \\\n java/net/SocketImpl.java \\\n java/net/SocketImplFactory.java\t\\\n+java/net/SocketOptions.java \\\n+java/net/URL.java \\\n+java/net/URLClassLoader.java \\\n java/net/URLConnection.java \\\n+java/net/URLDecoder.java \\\n+java/net/URLEncoder.java \\\n java/net/URLStreamHandler.java \\\n java/net/URLStreamHandlerFactory.java \\\n java/net/UnknownHostException.java \\\n java/net/UnknownServiceException.java \\\n-java/net/URLDecoder.java \\\n-java/net/URLEncoder.java \\\n-java/net/DatagramPacket.java \\\n-java/net/DatagramSocket.java \\\n-java/net/DatagramSocketImpl.java \\\n-java/net/MulticastSocket.java \\\n-java/net/PlainDatagramSocketImpl.java \\\n-java/net/SocketOptions.java \\\n-java/net/JarURLConnection.java \\\n-java/net/URLClassLoader.java \\\n-java/text/Collator.java\t\\\n-java/text/BreakIterator.java \\\n-java/text/CharacterIterator.java \\\n-java/text/ChoiceFormat.java \\\n-java/text/DateFormat.java \\\n-java/text/DateFormatSymbols.java \\\n-java/text/DecimalFormat.java \\\n-java/text/DecimalFormatSymbols.java \\\n-java/text/FieldPosition.java \\\n-java/text/Format.java \\\n-java/text/MessageFormat.java \\\n-java/text/NumberFormat.java \\\n-java/text/ParseException.java \\\n-java/text/ParsePosition.java \\\n-java/text/SimpleDateFormat.java\t\\\n-java/text/StringCharacterIterator.java \\\n-java/text/CollationElementIterator.java\t\\\n-java/text/CollationKey.java \\\n-java/text/RuleBasedCollator.java \\\n-java/util/zip/Adler32.java \\\n-java/util/zip/CRC32.java \\\n-java/util/zip/Checksum.java \\\n-java/util/zip/Deflater.java \\\n-java/util/zip/DeflaterOutputStream.java\t\\\n-java/util/zip/ZipConstants.java\t\\\n-java/util/zip/ZipEntry.java \\\n-java/util/zip/ZipException.java\t\\\n-java/util/zip/ZipFile.java \\\n-java/util/zip/ZipOutputStream.java \\\n-java/util/zip/InflaterInputStream.java \\\n-java/util/zip/ZipInputStream.java \\\n-java/util/zip/DataFormatException.java \\\n-java/util/zip/CheckedInputStream.java \\\n-java/util/zip/CheckedOutputStream.java \\\n-java/util/zip/Inflater.java \\\n-java/util/zip/GZIPInputStream.java \\\n-java/util/zip/GZIPOutputStream.java \\\n-java/util/jar/JarEntry.java \\\n-java/util/jar/JarFile.java \\\n-java/util/jar/JarInputStream.java \\\n-java/util/BitSet.java \\\n-java/util/Calendar.java\t\\\n-java/util/ConcurrentModificationException.java \\\n-java/util/Date.java \\\n-java/util/Dictionary.java \\\n-java/util/EmptyStackException.java \\\n-java/util/Enumeration.java \\\n-java/util/EventListener.java \\\n-java/util/EventObject.java \\\n-java/util/GregorianCalendar.java \\\n-java/util/Hashtable.java \\\n-java/util/ListResourceBundle.java \\\n-java/util/Locale.java \\\n-java/util/MissingResourceException.java\t\\\n-java/util/NoSuchElementException.java \\\n-java/util/Observable.java \\\n-java/util/Observer.java\t\\\n-java/util/Properties.java \\\n-java/util/Random.java \\\n-java/util/ResourceBundle.java \\\n-java/util/SimpleTimeZone.java \\\n-java/util/Stack.java \\\n-java/util/StringTokenizer.java \\\n-java/util/TimeZone.java\t\\\n-java/util/TooManyListenersException.java \\\n-java/util/Vector.java \\\n-java/util/List.java \\\n-java/util/Collection.java \\\n-java/util/Comparator.java \\\n-java/util/Iterator.java\t\\\n-java/util/PropertyResourceBundle.java \\\n-java/util/Arrays.java \\\n-java/util/ListIterator.java \\\n-java/util/AbstractCollection.java \\\n-java/util/AbstractList.java \\\n-java/security/MessageDigest.java \\\n-java/security/NoSuchAlgorithmException.java \\\n-java/security/SecureClassLoader.java \\\n-java/security/interfaces/DSAKey.java \\\n-java/security/interfaces/DSAParams.java\t\\\n-java/security/interfaces/DSAPrivateKey.java \\\n-java/security/interfaces/DSAPublicKey.java \\\n-java/security/interfaces/RSAPrivateCrtKey.java \\\n-java/security/interfaces/RSAPrivateKey.java \\\n-java/security/interfaces/RSAPublicKey.java \\\n java/security/AlgorithmParameterGeneratorSpi.java \\\n+java/security/BasicPermission.java \\\n java/security/DigestException.java \\\n+java/security/DigestOutputStream.java \\\n java/security/GeneralSecurityException.java \\\n+java/security/Guard.java \\\n java/security/InvalidAlgorithmParameterException.java \\\n java/security/InvalidKeyException.java \\\n java/security/InvalidParameterException.java \\\n@@ -1029,29 +949,48 @@ java/security/KeyException.java\t\\\n java/security/KeyPair.java \\\n java/security/KeyPairGenerator.java \\\n java/security/KeyPairGeneratorSpi.java \\\n+java/security/MessageDigest.java \\\n+java/security/NoSuchAlgorithmException.java \\\n java/security/NoSuchProviderException.java \\\n+java/security/Permission.java \\\n+java/security/PermissionCollection.java\t\\\n java/security/Principal.java \\\n java/security/PrivateKey.java \\\n java/security/Provider.java \\\n java/security/PublicKey.java \\\n+java/security/SecureClassLoader.java \\\n java/security/SecureRandom.java\t\\\n java/security/Security.java \\\n java/security/Signature.java \\\n java/security/SignatureException.java \\\n+java/security/cert/CRL.java \\\n+java/security/cert/CRLException.java \\\n+java/security/cert/Certificate.java \\\n+java/security/cert/CertificateEncodingException.java \\\n+java/security/cert/CertificateException.java \\\n+java/security/cert/CertificateExpiredException.java \\\n+java/security/cert/CertificateFactory.java \\\n+java/security/cert/CertificateFactorySpi.java \\\n+java/security/cert/CertificateNotYetValidException.java \\\n+java/security/cert/CertificateParsingException.java \\\n+java/security/cert/X509CRL.java \\\n+java/security/cert/X509CRLEntry.java \\\n+java/security/cert/X509Certificate.java \\\n+java/security/cert/X509Extension.java \\\n+java/security/interfaces/DSAKey.java \\\n+java/security/interfaces/DSAParams.java\t\\\n+java/security/interfaces/DSAPrivateKey.java \\\n+java/security/interfaces/DSAPublicKey.java \\\n+java/security/interfaces/RSAPrivateCrtKey.java \\\n+java/security/interfaces/RSAPrivateKey.java \\\n+java/security/interfaces/RSAPublicKey.java \\\n java/security/spec/AlgorithmParameterSpec.java \\\n java/security/spec/InvalidKeySpecException.java\t\\\n java/security/spec/InvalidParameterSpecException.java \\\n java/security/spec/KeySpec.java\t\\\n java/security/spec/RSAPrivateCrtKeySpec.java \\\n java/security/spec/RSAPrivateKeySpec.java \\\n java/security/spec/RSAPublicKeySpec.java \\\n-java/security/BasicPermission.java \\\n-java/security/Guard.java \\\n-java/security/DigestOutputStream.java \\\n-java/security/Permission.java \\\n-java/security/PermissionCollection.java\t\\\n-java/math/BigDecimal.java \\\n-java/math/BigInteger.java \\\n java/sql/CallableStatement.java\t\\\n java/sql/Connection.java \\\n java/sql/DataTruncation.java \\\n@@ -1068,7 +1007,91 @@ java/sql/SQLWarning.java \\\n java/sql/Statement.java\t\\\n java/sql/Time.java \\\n java/sql/Timestamp.java\t\\\n-java/sql/Types.java\n+java/sql/Types.java \\\n+java/text/BreakIterator.java \\\n+java/text/CharacterIterator.java \\\n+java/text/ChoiceFormat.java \\\n+java/text/CollationElementIterator.java\t\\\n+java/text/CollationKey.java \\\n+java/text/Collator.java\t\\\n+java/text/DateFormat.java \\\n+java/text/DateFormatSymbols.java \\\n+java/text/DecimalFormat.java \\\n+java/text/DecimalFormatSymbols.java \\\n+java/text/FieldPosition.java \\\n+java/text/Format.java \\\n+java/text/MessageFormat.java \\\n+java/text/NumberFormat.java \\\n+java/text/ParseException.java \\\n+java/text/ParsePosition.java \\\n+java/text/RuleBasedCollator.java \\\n+java/text/SimpleDateFormat.java\t\\\n+java/text/StringCharacterIterator.java \\\n+java/util/AbstractCollection.java \\\n+java/util/AbstractList.java \\\n+java/util/AbstractSet.java \\\n+java/util/Arrays.java \\\n+java/util/BasicMapEntry.java \\\n+java/util/BitSet.java \\\n+java/util/Bucket.java \\\n+java/util/Calendar.java\t\\\n+java/util/Collection.java \\\n+java/util/Comparator.java \\\n+java/util/ConcurrentModificationException.java \\\n+java/util/Date.java \\\n+java/util/Dictionary.java \\\n+java/util/EmptyStackException.java \\\n+java/util/Enumeration.java \\\n+java/util/EventListener.java \\\n+java/util/EventObject.java \\\n+java/util/GregorianCalendar.java \\\n+java/util/Hashtable.java \\\n+java/util/Iterator.java\t\\\n+java/util/List.java \\\n+java/util/ListIterator.java \\\n+java/util/ListResourceBundle.java \\\n+java/util/Locale.java \\\n+java/util/Map.java \\\n+java/util/MissingResourceException.java\t\\\n+java/util/NoSuchElementException.java \\\n+java/util/Observable.java \\\n+java/util/Observer.java\t\\\n+java/util/Properties.java \\\n+java/util/PropertyResourceBundle.java \\\n+java/util/Random.java \\\n+java/util/ResourceBundle.java \\\n+java/util/Set.java \\\n+java/util/SimpleTimeZone.java \\\n+java/util/Stack.java \\\n+java/util/StringTokenizer.java \\\n+java/util/TimeZone.java\t\\\n+java/util/TooManyListenersException.java \\\n+java/util/Vector.java \\\n+java/util/jar/Attributes.java \\\n+java/util/jar/JarEntry.java \\\n+java/util/jar/JarException.java \\\n+java/util/jar/JarFile.java \\\n+java/util/jar/JarInputStream.java \\\n+java/util/jar/JarOutputStream.java \\\n+java/util/jar/Manifest.java \\\n+java/util/zip/Adler32.java \\\n+java/util/zip/CRC32.java \\\n+java/util/zip/CheckedInputStream.java \\\n+java/util/zip/CheckedOutputStream.java \\\n+java/util/zip/Checksum.java \\\n+java/util/zip/DataFormatException.java \\\n+java/util/zip/Deflater.java \\\n+java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/GZIPInputStream.java \\\n+java/util/zip/GZIPOutputStream.java \\\n+java/util/zip/Inflater.java \\\n+java/util/zip/InflaterInputStream.java \\\n+java/util/zip/ZipConstants.java\t\\\n+java/util/zip/ZipEntry.java \\\n+java/util/zip/ZipException.java\t\\\n+java/util/zip/ZipFile.java \\\n+java/util/zip/ZipInputStream.java \\\n+java/util/zip/ZipOutputStream.java\n \n java_source_files = $(ordinary_java_source_files) $(special_java_source_files)\n "}, {"sha": "f35fab45dbf6cdd64156afe6a94840322e8a0daf", "filename": "libjava/Makefile.in", "status": "modified", "additions": 200, "deletions": 159, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -488,12 +488,20 @@ built_java_source_files = java/lang/ConcreteProcess.java\n \n ordinary_java_source_files = $(convert_source_files) \\\n $(awt_java_source_files) \\\n-gnu/gcj/protocol/http/Connection.java \\\n-gnu/gcj/protocol/http/Handler.java \\\n+gnu/gcj/RawData.java \\\n+gnu/gcj/io/DefaultMimeTypes.java \\\n+gnu/gcj/io/MimeTypes.java \\\n+gnu/gcj/io/SimpleSHSStream.java\t\\\n+gnu/gcj/jni/NativeThread.java \\\n+gnu/gcj/math/MPN.java \\\n gnu/gcj/protocol/file/Connection.java \\\n gnu/gcj/protocol/file/Handler.java \\\n+gnu/gcj/protocol/http/Connection.java \\\n+gnu/gcj/protocol/http/Handler.java \\\n gnu/gcj/protocol/jar/Connection.java \\\n gnu/gcj/protocol/jar/Handler.java \\\n+gnu/gcj/runtime/FirstThread.java \\\n+gnu/gcj/runtime/VMClassLoader.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n@@ -502,23 +510,16 @@ gnu/gcj/text/LocaleData_en_US.java \\\n gnu/gcj/text/SentenceBreakIterator.java\t\\\n gnu/gcj/text/WordBreakIterator.java \\\n gnu/gcj/util/EnumerationChain.java \\\n-gnu/gcj/RawData.java \\\n-gnu/gcj/math/MPN.java \\\n-gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/runtime/FirstThread.java \\\n-gnu/gcj/jni/NativeThread.java \\\n-gnu/gcj/io/DefaultMimeTypes.java \\\n-gnu/gcj/io/MimeTypes.java \\\n-gnu/gcj/io/SimpleSHSStream.java\t\\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n gnu/java/io/NullOutputStream.java \\\n gnu/java/io/ObjectIdentityWrapper.java \\\n-gnu/java/lang/reflect/TypeSignature.java \\\n gnu/java/lang/ArrayHelper.java \\\n gnu/java/lang/ClassHelper.java \\\n+gnu/java/lang/reflect/TypeSignature.java \\\n gnu/java/security/provider/Gnu.java \\\n gnu/java/security/provider/SHA.java \\\n gnu/java/security/provider/SHA1PRNG.java \\\n+java/io/BlockDataException.java\t\\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n java/io/BufferedReader.java \\\n@@ -533,7 +534,9 @@ java/io/DataInputStream.java \\\n java/io/DataOutput.java\t\\\n java/io/DataOutputStream.java \\\n java/io/EOFException.java \\\n+java/io/Externalizable.java \\\n java/io/File.java \\\n+java/io/FileDescriptor.java \\\n java/io/FileInputStream.java \\\n java/io/FileNotFoundException.java \\\n java/io/FileOutputStream.java \\\n@@ -548,12 +551,25 @@ java/io/IOException.java \\\n java/io/InputStream.java \\\n java/io/InputStreamReader.java \\\n java/io/InterruptedIOException.java \\\n+java/io/InvalidClassException.java \\\n+java/io/InvalidObjectException.java \\\n java/io/LineNumberInputStream.java \\\n java/io/LineNumberReader.java \\\n+java/io/NotActiveException.java\t\\\n+java/io/NotSerializableException.java \\\n+java/io/ObjectInput.java \\\n+java/io/ObjectInputStream.java \\\n+java/io/ObjectInputValidation.java \\\n+java/io/ObjectOutput.java \\\n+java/io/ObjectOutputStream.java\t\\\n+java/io/ObjectStreamClass.java \\\n+java/io/ObjectStreamConstants.java \\\n+java/io/ObjectStreamException.java \\\n+java/io/ObjectStreamField.java \\\n+java/io/OptionalDataException.java \\\n java/io/OutputStream.java \\\n java/io/OutputStreamWriter.java\t\\\n-java/io/Externalizable.java \\\n-java/io/FileDescriptor.java \\\n+java/io/PipedInputStream.java \\\n java/io/PipedOutputStream.java \\\n java/io/PipedReader.java \\\n java/io/PipedWriter.java \\\n@@ -563,45 +579,21 @@ java/io/PushbackInputStream.java \\\n java/io/PushbackReader.java \\\n java/io/RandomAccessFile.java \\\n java/io/Reader.java \\\n+java/io/Replaceable.java \\\n+java/io/Resolvable.java\t\\\n java/io/SequenceInputStream.java \\\n java/io/Serializable.java \\\n+java/io/SerializablePermission.java \\\n+java/io/StreamCorruptedException.java \\\n java/io/StreamTokenizer.java \\\n java/io/StringBufferInputStream.java \\\n java/io/StringReader.java \\\n java/io/StringWriter.java \\\n java/io/SyncFailedException.java \\\n java/io/UTFDataFormatException.java \\\n java/io/UnsupportedEncodingException.java \\\n-java/io/Writer.java \\\n-java/io/ObjectStreamException.java \\\n-java/io/OptionalDataException.java \\\n-java/io/StreamCorruptedException.java \\\n-java/io/BlockDataException.java\t\\\n-java/io/InvalidClassException.java \\\n-java/io/InvalidObjectException.java \\\n-java/io/NotActiveException.java\t\\\n-java/io/NotSerializableException.java \\\n-java/io/ObjectInput.java \\\n-java/io/ObjectInputStream.java \\\n-java/io/ObjectInputValidation.java \\\n-java/io/ObjectOutput.java \\\n-java/io/ObjectOutputStream.java\t\\\n-java/io/ObjectStreamClass.java \\\n-java/io/ObjectStreamConstants.java \\\n-java/io/ObjectStreamField.java \\\n-java/io/Replaceable.java \\\n-java/io/Resolvable.java\t\\\n-java/io/SerializablePermission.java \\\n java/io/WriteAbortedException.java \\\n-java/io/PipedInputStream.java \\\n-java/lang/reflect/Constructor.java \\\n-java/lang/reflect/AccessibleObject.java\t\\\n-java/lang/reflect/Array.java \\\n-java/lang/reflect/Method.java \\\n-java/lang/reflect/Field.java \\\n-java/lang/reflect/InvocationTargetException.java \\\n-java/lang/reflect/Member.java \\\n-java/lang/reflect/Modifier.java\t\\\n+java/io/Writer.java \\\n java/lang/AbstractMethodError.java \\\n java/lang/ArithmeticException.java \\\n java/lang/ArrayIndexOutOfBoundsException.java \\\n@@ -630,10 +622,10 @@ java/lang/IllegalMonitorStateException.java \\\n java/lang/IllegalStateException.java \\\n java/lang/IllegalThreadStateException.java \\\n java/lang/IncompatibleClassChangeError.java \\\n-java/lang/InstantiationError.java \\\n-java/lang/Integer.java \\\n java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InstantiationError.java \\\n java/lang/InstantiationException.java \\\n+java/lang/Integer.java \\\n java/lang/InternalError.java \\\n java/lang/InterruptedException.java \\\n java/lang/LinkageError.java \\\n@@ -671,126 +663,54 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/Void.java \\\n+java/lang/reflect/AccessibleObject.java\t\\\n+java/lang/reflect/Array.java \\\n+java/lang/reflect/Constructor.java \\\n+java/lang/reflect/Field.java \\\n+java/lang/reflect/InvocationTargetException.java \\\n+java/lang/reflect/Member.java \\\n+java/lang/reflect/Method.java \\\n+java/lang/reflect/Modifier.java\t\\\n+java/math/BigDecimal.java \\\n+java/math/BigInteger.java \\\n java/net/BindException.java \\\n java/net/ConnectException.java \\\n java/net/ContentHandler.java \\\n java/net/ContentHandlerFactory.java \\\n+java/net/DatagramPacket.java \\\n+java/net/DatagramSocket.java \\\n+java/net/DatagramSocketImpl.java \\\n java/net/FileNameMap.java \\\n java/net/HttpURLConnection.java\t\\\n java/net/InetAddress.java \\\n+java/net/JarURLConnection.java \\\n java/net/MalformedURLException.java \\\n+java/net/MulticastSocket.java \\\n java/net/NoRouteToHostException.java \\\n+java/net/PlainDatagramSocketImpl.java \\\n java/net/PlainSocketImpl.java \\\n java/net/ProtocolException.java\t\\\n java/net/ServerSocket.java \\\n-java/net/URL.java \\\n java/net/Socket.java \\\n java/net/SocketException.java \\\n java/net/SocketImpl.java \\\n java/net/SocketImplFactory.java\t\\\n+java/net/SocketOptions.java \\\n+java/net/URL.java \\\n+java/net/URLClassLoader.java \\\n java/net/URLConnection.java \\\n+java/net/URLDecoder.java \\\n+java/net/URLEncoder.java \\\n java/net/URLStreamHandler.java \\\n java/net/URLStreamHandlerFactory.java \\\n java/net/UnknownHostException.java \\\n java/net/UnknownServiceException.java \\\n-java/net/URLDecoder.java \\\n-java/net/URLEncoder.java \\\n-java/net/DatagramPacket.java \\\n-java/net/DatagramSocket.java \\\n-java/net/DatagramSocketImpl.java \\\n-java/net/MulticastSocket.java \\\n-java/net/PlainDatagramSocketImpl.java \\\n-java/net/SocketOptions.java \\\n-java/net/JarURLConnection.java \\\n-java/net/URLClassLoader.java \\\n-java/text/Collator.java\t\\\n-java/text/BreakIterator.java \\\n-java/text/CharacterIterator.java \\\n-java/text/ChoiceFormat.java \\\n-java/text/DateFormat.java \\\n-java/text/DateFormatSymbols.java \\\n-java/text/DecimalFormat.java \\\n-java/text/DecimalFormatSymbols.java \\\n-java/text/FieldPosition.java \\\n-java/text/Format.java \\\n-java/text/MessageFormat.java \\\n-java/text/NumberFormat.java \\\n-java/text/ParseException.java \\\n-java/text/ParsePosition.java \\\n-java/text/SimpleDateFormat.java\t\\\n-java/text/StringCharacterIterator.java \\\n-java/text/CollationElementIterator.java\t\\\n-java/text/CollationKey.java \\\n-java/text/RuleBasedCollator.java \\\n-java/util/zip/Adler32.java \\\n-java/util/zip/CRC32.java \\\n-java/util/zip/Checksum.java \\\n-java/util/zip/Deflater.java \\\n-java/util/zip/DeflaterOutputStream.java\t\\\n-java/util/zip/ZipConstants.java\t\\\n-java/util/zip/ZipEntry.java \\\n-java/util/zip/ZipException.java\t\\\n-java/util/zip/ZipFile.java \\\n-java/util/zip/ZipOutputStream.java \\\n-java/util/zip/InflaterInputStream.java \\\n-java/util/zip/ZipInputStream.java \\\n-java/util/zip/DataFormatException.java \\\n-java/util/zip/CheckedInputStream.java \\\n-java/util/zip/CheckedOutputStream.java \\\n-java/util/zip/Inflater.java \\\n-java/util/zip/GZIPInputStream.java \\\n-java/util/zip/GZIPOutputStream.java \\\n-java/util/jar/JarEntry.java \\\n-java/util/jar/JarFile.java \\\n-java/util/jar/JarInputStream.java \\\n-java/util/BitSet.java \\\n-java/util/Calendar.java\t\\\n-java/util/ConcurrentModificationException.java \\\n-java/util/Date.java \\\n-java/util/Dictionary.java \\\n-java/util/EmptyStackException.java \\\n-java/util/Enumeration.java \\\n-java/util/EventListener.java \\\n-java/util/EventObject.java \\\n-java/util/GregorianCalendar.java \\\n-java/util/Hashtable.java \\\n-java/util/ListResourceBundle.java \\\n-java/util/Locale.java \\\n-java/util/MissingResourceException.java\t\\\n-java/util/NoSuchElementException.java \\\n-java/util/Observable.java \\\n-java/util/Observer.java\t\\\n-java/util/Properties.java \\\n-java/util/Random.java \\\n-java/util/ResourceBundle.java \\\n-java/util/SimpleTimeZone.java \\\n-java/util/Stack.java \\\n-java/util/StringTokenizer.java \\\n-java/util/TimeZone.java\t\\\n-java/util/TooManyListenersException.java \\\n-java/util/Vector.java \\\n-java/util/List.java \\\n-java/util/Collection.java \\\n-java/util/Comparator.java \\\n-java/util/Iterator.java\t\\\n-java/util/PropertyResourceBundle.java \\\n-java/util/Arrays.java \\\n-java/util/ListIterator.java \\\n-java/util/AbstractCollection.java \\\n-java/util/AbstractList.java \\\n-java/security/MessageDigest.java \\\n-java/security/NoSuchAlgorithmException.java \\\n-java/security/SecureClassLoader.java \\\n-java/security/interfaces/DSAKey.java \\\n-java/security/interfaces/DSAParams.java\t\\\n-java/security/interfaces/DSAPrivateKey.java \\\n-java/security/interfaces/DSAPublicKey.java \\\n-java/security/interfaces/RSAPrivateCrtKey.java \\\n-java/security/interfaces/RSAPrivateKey.java \\\n-java/security/interfaces/RSAPublicKey.java \\\n java/security/AlgorithmParameterGeneratorSpi.java \\\n+java/security/BasicPermission.java \\\n java/security/DigestException.java \\\n+java/security/DigestOutputStream.java \\\n java/security/GeneralSecurityException.java \\\n+java/security/Guard.java \\\n java/security/InvalidAlgorithmParameterException.java \\\n java/security/InvalidKeyException.java \\\n java/security/InvalidParameterException.java \\\n@@ -799,29 +719,48 @@ java/security/KeyException.java\t\\\n java/security/KeyPair.java \\\n java/security/KeyPairGenerator.java \\\n java/security/KeyPairGeneratorSpi.java \\\n+java/security/MessageDigest.java \\\n+java/security/NoSuchAlgorithmException.java \\\n java/security/NoSuchProviderException.java \\\n+java/security/Permission.java \\\n+java/security/PermissionCollection.java\t\\\n java/security/Principal.java \\\n java/security/PrivateKey.java \\\n java/security/Provider.java \\\n java/security/PublicKey.java \\\n+java/security/SecureClassLoader.java \\\n java/security/SecureRandom.java\t\\\n java/security/Security.java \\\n java/security/Signature.java \\\n java/security/SignatureException.java \\\n+java/security/cert/CRL.java \\\n+java/security/cert/CRLException.java \\\n+java/security/cert/Certificate.java \\\n+java/security/cert/CertificateEncodingException.java \\\n+java/security/cert/CertificateException.java \\\n+java/security/cert/CertificateExpiredException.java \\\n+java/security/cert/CertificateFactory.java \\\n+java/security/cert/CertificateFactorySpi.java \\\n+java/security/cert/CertificateNotYetValidException.java \\\n+java/security/cert/CertificateParsingException.java \\\n+java/security/cert/X509CRL.java \\\n+java/security/cert/X509CRLEntry.java \\\n+java/security/cert/X509Certificate.java \\\n+java/security/cert/X509Extension.java \\\n+java/security/interfaces/DSAKey.java \\\n+java/security/interfaces/DSAParams.java\t\\\n+java/security/interfaces/DSAPrivateKey.java \\\n+java/security/interfaces/DSAPublicKey.java \\\n+java/security/interfaces/RSAPrivateCrtKey.java \\\n+java/security/interfaces/RSAPrivateKey.java \\\n+java/security/interfaces/RSAPublicKey.java \\\n java/security/spec/AlgorithmParameterSpec.java \\\n java/security/spec/InvalidKeySpecException.java\t\\\n java/security/spec/InvalidParameterSpecException.java \\\n java/security/spec/KeySpec.java\t\\\n java/security/spec/RSAPrivateCrtKeySpec.java \\\n java/security/spec/RSAPrivateKeySpec.java \\\n java/security/spec/RSAPublicKeySpec.java \\\n-java/security/BasicPermission.java \\\n-java/security/Guard.java \\\n-java/security/DigestOutputStream.java \\\n-java/security/Permission.java \\\n-java/security/PermissionCollection.java\t\\\n-java/math/BigDecimal.java \\\n-java/math/BigInteger.java \\\n java/sql/CallableStatement.java\t\\\n java/sql/Connection.java \\\n java/sql/DataTruncation.java \\\n@@ -838,7 +777,91 @@ java/sql/SQLWarning.java \\\n java/sql/Statement.java\t\\\n java/sql/Time.java \\\n java/sql/Timestamp.java\t\\\n-java/sql/Types.java\n+java/sql/Types.java \\\n+java/text/BreakIterator.java \\\n+java/text/CharacterIterator.java \\\n+java/text/ChoiceFormat.java \\\n+java/text/CollationElementIterator.java\t\\\n+java/text/CollationKey.java \\\n+java/text/Collator.java\t\\\n+java/text/DateFormat.java \\\n+java/text/DateFormatSymbols.java \\\n+java/text/DecimalFormat.java \\\n+java/text/DecimalFormatSymbols.java \\\n+java/text/FieldPosition.java \\\n+java/text/Format.java \\\n+java/text/MessageFormat.java \\\n+java/text/NumberFormat.java \\\n+java/text/ParseException.java \\\n+java/text/ParsePosition.java \\\n+java/text/RuleBasedCollator.java \\\n+java/text/SimpleDateFormat.java\t\\\n+java/text/StringCharacterIterator.java \\\n+java/util/AbstractCollection.java \\\n+java/util/AbstractList.java \\\n+java/util/AbstractSet.java \\\n+java/util/Arrays.java \\\n+java/util/BasicMapEntry.java \\\n+java/util/BitSet.java \\\n+java/util/Bucket.java \\\n+java/util/Calendar.java\t\\\n+java/util/Collection.java \\\n+java/util/Comparator.java \\\n+java/util/ConcurrentModificationException.java \\\n+java/util/Date.java \\\n+java/util/Dictionary.java \\\n+java/util/EmptyStackException.java \\\n+java/util/Enumeration.java \\\n+java/util/EventListener.java \\\n+java/util/EventObject.java \\\n+java/util/GregorianCalendar.java \\\n+java/util/Hashtable.java \\\n+java/util/Iterator.java\t\\\n+java/util/List.java \\\n+java/util/ListIterator.java \\\n+java/util/ListResourceBundle.java \\\n+java/util/Locale.java \\\n+java/util/Map.java \\\n+java/util/MissingResourceException.java\t\\\n+java/util/NoSuchElementException.java \\\n+java/util/Observable.java \\\n+java/util/Observer.java\t\\\n+java/util/Properties.java \\\n+java/util/PropertyResourceBundle.java \\\n+java/util/Random.java \\\n+java/util/ResourceBundle.java \\\n+java/util/Set.java \\\n+java/util/SimpleTimeZone.java \\\n+java/util/Stack.java \\\n+java/util/StringTokenizer.java \\\n+java/util/TimeZone.java\t\\\n+java/util/TooManyListenersException.java \\\n+java/util/Vector.java \\\n+java/util/jar/Attributes.java \\\n+java/util/jar/JarEntry.java \\\n+java/util/jar/JarException.java \\\n+java/util/jar/JarFile.java \\\n+java/util/jar/JarInputStream.java \\\n+java/util/jar/JarOutputStream.java \\\n+java/util/jar/Manifest.java \\\n+java/util/zip/Adler32.java \\\n+java/util/zip/CRC32.java \\\n+java/util/zip/CheckedInputStream.java \\\n+java/util/zip/CheckedOutputStream.java \\\n+java/util/zip/Checksum.java \\\n+java/util/zip/DataFormatException.java \\\n+java/util/zip/Deflater.java \\\n+java/util/zip/DeflaterOutputStream.java\t\\\n+java/util/zip/GZIPInputStream.java \\\n+java/util/zip/GZIPOutputStream.java \\\n+java/util/zip/Inflater.java \\\n+java/util/zip/InflaterInputStream.java \\\n+java/util/zip/ZipConstants.java\t\\\n+java/util/zip/ZipEntry.java \\\n+java/util/zip/ZipException.java\t\\\n+java/util/zip/ZipFile.java \\\n+java/util/zip/ZipInputStream.java \\\n+java/util/zip/ZipOutputStream.java\n \n \n java_source_files = $(ordinary_java_source_files) $(special_java_source_files)\n@@ -1001,7 +1024,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1357,7 +1380,20 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/security/SecureClassLoader.P \\\n .deps/java/security/SecureRandom.P .deps/java/security/Security.P \\\n .deps/java/security/Signature.P \\\n-.deps/java/security/SignatureException.P \\\n+.deps/java/security/SignatureException.P .deps/java/security/cert/CRL.P \\\n+.deps/java/security/cert/CRLException.P \\\n+.deps/java/security/cert/Certificate.P \\\n+.deps/java/security/cert/CertificateEncodingException.P \\\n+.deps/java/security/cert/CertificateException.P \\\n+.deps/java/security/cert/CertificateExpiredException.P \\\n+.deps/java/security/cert/CertificateFactory.P \\\n+.deps/java/security/cert/CertificateFactorySpi.P \\\n+.deps/java/security/cert/CertificateNotYetValidException.P \\\n+.deps/java/security/cert/CertificateParsingException.P \\\n+.deps/java/security/cert/X509CRL.P \\\n+.deps/java/security/cert/X509CRLEntry.P \\\n+.deps/java/security/cert/X509Certificate.P \\\n+.deps/java/security/cert/X509Extension.P \\\n .deps/java/security/interfaces/DSAKey.P \\\n .deps/java/security/interfaces/DSAParams.P \\\n .deps/java/security/interfaces/DSAPrivateKey.P \\\n@@ -1392,25 +1428,30 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/text/RuleBasedCollator.P .deps/java/text/SimpleDateFormat.P \\\n .deps/java/text/StringCharacterIterator.P \\\n .deps/java/util/AbstractCollection.P .deps/java/util/AbstractList.P \\\n-.deps/java/util/Arrays.P .deps/java/util/BitSet.P \\\n-.deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n-.deps/java/util/Comparator.P \\\n+.deps/java/util/AbstractSet.P .deps/java/util/Arrays.P \\\n+.deps/java/util/BasicMapEntry.P .deps/java/util/BitSet.P \\\n+.deps/java/util/Bucket.P .deps/java/util/Calendar.P \\\n+.deps/java/util/Collection.P .deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n .deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n .deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n .deps/java/util/EventListener.P .deps/java/util/EventObject.P \\\n .deps/java/util/GregorianCalendar.P .deps/java/util/Hashtable.P \\\n .deps/java/util/Iterator.P .deps/java/util/List.P \\\n .deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n-.deps/java/util/Locale.P .deps/java/util/MissingResourceException.P \\\n+.deps/java/util/Locale.P .deps/java/util/Map.P \\\n+.deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyResourceBundle.P .deps/java/util/Random.P \\\n-.deps/java/util/ResourceBundle.P .deps/java/util/SimpleTimeZone.P \\\n-.deps/java/util/Stack.P .deps/java/util/StringTokenizer.P \\\n-.deps/java/util/TimeZone.P .deps/java/util/TooManyListenersException.P \\\n-.deps/java/util/Vector.P .deps/java/util/jar/JarEntry.P \\\n-.deps/java/util/jar/JarFile.P .deps/java/util/jar/JarInputStream.P \\\n+.deps/java/util/ResourceBundle.P .deps/java/util/Set.P \\\n+.deps/java/util/SimpleTimeZone.P .deps/java/util/Stack.P \\\n+.deps/java/util/StringTokenizer.P .deps/java/util/TimeZone.P \\\n+.deps/java/util/TooManyListenersException.P .deps/java/util/Vector.P \\\n+.deps/java/util/jar/Attributes.P .deps/java/util/jar/JarEntry.P \\\n+.deps/java/util/jar/JarException.P .deps/java/util/jar/JarFile.P \\\n+.deps/java/util/jar/JarInputStream.P \\\n+.deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n .deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\\n .deps/java/util/zip/CheckedInputStream.P \\\n .deps/java/util/zip/CheckedOutputStream.P \\"}, {"sha": "bd13f3d9e6693e72902dcbc2a568df3c8dfc8852", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -129,7 +129,7 @@ DIST_COMMON =  Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -198,7 +198,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "e3d01abf1ecc42741678efdefeb514a4fd364d03", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 103, "deletions": 2, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -214,9 +214,13 @@ extern \"Java\"\n       class AbstractCollection;\n       class AbstractList;\n       class AbstractList$SubList;\n+      class AbstractSet;\n       class Arrays;\n       class Arrays$ListImpl;\n+      class BasicMapEntry;\n       class BitSet;\n+      class Bucket;\n+      class Bucket$Node;\n       class Calendar;\n       class Collection;\n       class Comparator;\n@@ -229,13 +233,18 @@ extern \"Java\"\n       class EventObject;\n       class GregorianCalendar;\n       class Hashtable;\n-      class HashtableEntry;\n-      class HashtableEnumeration;\n+      class Hashtable$HashtableCollection;\n+      class Hashtable$HashtableEntry;\n+      class Hashtable$HashtableEnumeration;\n+      class Hashtable$HashtableIterator;\n+      class Hashtable$HashtableSet;\n       class Iterator;\n       class List;\n       class ListIterator;\n       class ListResourceBundle;\n       class Locale;\n+      class Map;\n+      class Map$Entry;\n       class MissingResourceException;\n       class NoSuchElementException;\n       class Observable;\n@@ -244,6 +253,7 @@ extern \"Java\"\n       class PropertyResourceBundle;\n       class Random;\n       class ResourceBundle;\n+      class Set;\n       class SimpleTimeZone;\n       class Stack;\n       class StringTokenizer;\n@@ -253,9 +263,14 @@ extern \"Java\"\n       class VectorEnumeration;\n       namespace jar\n       {\n+\tclass Attributes;\n         class JarEntry;\n+        class JarException;\n         class JarFile;\n+        class JarFile$JarEnumeration;\n         class JarInputStream;\n+        class JarOutputStream;\n+        class Manifest;\n       };\n \n       namespace zip\n@@ -282,6 +297,92 @@ extern \"Java\"\n       };\n     };\n   };\n+  namespace java\n+  {\n+    namespace io\n+    {\n+      class BlockDataException;\n+      class BufferedInputStream;\n+      class BufferedOutputStream;\n+      class BufferedReader;\n+      class BufferedWriter;\n+      class ByteArrayInputStream;\n+      class ByteArrayOutputStream;\n+      class CharArrayReader;\n+      class CharArrayWriter;\n+      class CharConversionException;\n+      class DataInput;\n+      class DataInputStream;\n+      class DataOutput;\n+      class DataOutputStream;\n+      class EOFException;\n+      class Externalizable;\n+      class File;\n+      class FileDescriptor;\n+      class FileInputStream;\n+      class FileNotFoundException;\n+      class FileOutputStream;\n+      class FileReader;\n+      class FileWriter;\n+      class FilenameFilter;\n+      class FilterInputStream;\n+      class FilterOutputStream;\n+      class FilterReader;\n+      class FilterWriter;\n+      class IOException;\n+      class InputStream;\n+      class InputStreamReader;\n+      class InterfaceComparator;\n+      class InterruptedIOException;\n+      class InvalidClassException;\n+      class InvalidObjectException;\n+      class LineNumberInputStream;\n+      class LineNumberReader;\n+      class MemberComparator;\n+      class NotActiveException;\n+      class NotSerializableException;\n+      class ObjectInput;\n+      class ObjectInputStream;\n+      class ObjectInputStream$GetField;\n+      class ObjectInputValidation;\n+      class ObjectOutput;\n+      class ObjectOutputStream;\n+      class ObjectOutputStream$PutField;\n+      class ObjectStreamClass;\n+      class ObjectStreamConstants;\n+      class ObjectStreamException;\n+      class ObjectStreamField;\n+      class OptionalDataException;\n+      class OutputStream;\n+      class OutputStreamWriter;\n+      class PipedInputStream;\n+      class PipedOutputStream;\n+      class PipedReader;\n+      class PipedWriter;\n+      class PrintStream;\n+      class PrintWriter;\n+      class PushbackInputStream;\n+      class PushbackReader;\n+      class RandomAccessFile;\n+      class Reader;\n+      class Replaceable;\n+      class Resolvable;\n+      class SequenceInputStream;\n+      class Serializable;\n+      class SerializablePermission;\n+      class StreamCorruptedException;\n+      class StreamTokenizer;\n+      class StringBufferInputStream;\n+      class StringReader;\n+      class StringWriter;\n+      class SyncFailedException;\n+      class UTFDataFormatException;\n+      class UnsupportedEncodingException;\n+      class ValidatorAndPriority;\n+      class WriteAbortedException;\n+      class Writer;\n+    };\n+  };\n };\n \n typedef struct java::lang::Object* jobject;"}, {"sha": "dc184e5a1522a34ca740321abdda3cd6de0f82c4", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -128,7 +128,7 @@ DIST_COMMON =  ./stamp-h.in Makefile.am Makefile.in config.h.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -225,7 +225,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "f5cde15a4b0a7075808b0ee498adf3d098ea80ab", "filename": "libjava/java/security/cert/CRL.java", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCRL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCRL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCRL.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,87 @@\n+/* CRL.java --- Certificate Revocation List\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+   Certificate Revocation List class for managing CRLs that\n+   have different formats but the same general use. They\n+   all serve as lists of revoked certificates and can\n+   be queried for a given certificate.\n+   \n+   Specialized CRLs extend this class.\n+   \n+   @author Mark Benvenuto\n+   \n+   @since JDK 1.2\n+*/\n+public abstract class CRL\n+{\n+\n+  private String type;\n+\n+  /**\n+     Creates a new CRL for the specified type. An example\n+     is \"X.509\".\n+\n+     @param type the standard name for the CRL type. \n+  */\n+  protected CRL(String type)\n+  {\n+    this.type = type;\n+  }\n+\n+  /**\n+     Returns the CRL type.\n+\n+     @return a string representing the CRL type\n+  */\n+  public final String getType()\n+  {\n+    return type;\n+  }\n+\n+  /**\n+     Returns a string representing the CRL.\n+\n+     @return a string representing the CRL.\n+  */\n+  public abstract String toString();\n+\n+  /**\n+     Determines whether or not the specified Certificate\n+     is revoked.\n+\n+     @param cert A certificate to check if it is revoked\n+\n+     @return true if the certificate is revoked,\n+     false otherwise.\t\n+  */\n+  public abstract boolean isRevoked(Certificate cert);\n+\n+\n+}"}, {"sha": "376e25a6dfd4c65f4cbea42c145060a9b131ef4f", "filename": "libjava/java/security/cert/CRLException.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCRLException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCRLException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCRLException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,59 @@\n+/* CRLException.java --- Certificate Revocation List Exception\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.security.GeneralSecurityException;\n+\n+/**\n+   Exception for a Certificate Revocation List.\n+\n+   @since JDK 1.2\n+\n+   @author Mark Benvenuto\n+*/\n+public class CRLException extends GeneralSecurityException\n+{\n+\n+  /**\n+     Constructs an CRLExceptionwithout a message string.\n+  */\n+  public CRLException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+     Constructs an CRLException with a message string.\n+\n+     @param msg A message to display with exception\n+  */\n+  public CRLException(String msg)\n+  {\n+    super( msg );\n+  }\n+\n+}"}, {"sha": "2fb2a201f2163bfb4e1802cbcaab1b5b183f0d6b", "filename": "libjava/java/security/cert/Certificate.java", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificate.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,237 @@\n+/* Certificate.java --- Certificate class\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.security.PublicKey;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchProviderException;\n+import java.security.SignatureException;\n+import java.io.ObjectInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectStreamException;\n+\n+/**\n+   The Certificate class is an abstract class used to manage \n+   identity certificates. An identity certificate is a\n+   combination of a principal and a public key which is \n+   certified by another principal. This is the puprose of \n+   Certificate Authorities (CA).\n+   \n+   This class is used to manage different types of certificates\n+   but have important common puposes. Different types of \n+   certificates like X.509 and OpenPGP share general certificate\n+   functions (like encoding and verifying) and information like\n+   public keys.\n+   \n+   X.509, OpenPGP, and SDSI can be implemented by subclassing this\n+   class even though they differ in storage methods and information\n+   stored.\n+   \n+   @since JDK 1.2\n+   \n+   @author Mark Benvenuto\n+*/\n+public abstract class Certificate\n+{\n+\n+  private String type;\n+  /**\n+     Constructs a new certificate of the specified type. An example\n+     is \"X.509\".\n+\n+     @param type a valid standard name for a certificate.\n+  */\n+  protected Certificate(String type)\n+  {\n+    this.type = type;\n+  }\n+\n+  /**\n+     Returns the Certificate type.\n+\n+     @return a string representing the Certificate type\n+  */\n+  public final String getType()\n+  {\n+    return type;\n+  }\n+\n+  /**\n+     Compares this Certificate to other. It checks if the\n+     object if instanceOf Certificate and then checks if\n+     the encoded form matches.\n+\n+     @param other An Object to test for equality\n+\n+     @return true if equal, false otherwise\n+  */\n+  public boolean equals(Object other)\n+  {\n+    if( other instanceof Certificate ) {\n+      try {\n+\tCertificate x = (Certificate) other;\n+\tif( getEncoded().length != x.getEncoded().length )\n+\t  return false;\n+\n+\tbyte b1[] = getEncoded();\n+\tbyte b2[] = x.getEncoded();\n+\n+\tfor( int i = 0; i < b1.length; i++ )\n+\t  if( b1[i] != b2[i] )\n+\t    return false;\n+\n+      } catch( CertificateEncodingException cee ) { \n+\treturn false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+     Returns a hash code for this Certificate in its encoded\n+     form.\n+\n+     @return A hash code of this class\n+  */\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  /**\n+     Gets the DER ASN.1 encoded format for this Certificate.\n+     It assumes each certificate has only one encoding format.\n+     Ex: X.509 is encoded as ASN.1 DER\n+\n+     @return byte array containg encoded form\n+\n+     @throws CertificateEncodingException if an error occurs\n+  */\n+  public abstract byte[] getEncoded() throws CertificateEncodingException;\n+\n+  /**\n+     Verifies that this Certificate was properly signed with the\n+     PublicKey that corresponds to its private key. \n+\n+     @param key PublicKey to verify with\n+\n+     @throws CertificateException encoding error\n+     @throws NoSuchAlgorithmException unsupported algorithm\n+     @throws InvalidKeyException incorrect key\n+     @throws NoSuchProviderException no provider\n+     @throws SignatureException signature error\n+  */\n+  public abstract void verify(PublicKey key)\n+    throws CertificateException,\n+    NoSuchAlgorithmException,\n+    InvalidKeyException,\n+    NoSuchProviderException,\n+    SignatureException;\n+\n+  /**\n+     Verifies that this Certificate was properly signed with the\n+     PublicKey that corresponds to its private key and uses\n+     the signature engine provided by the provider. \n+\n+     @param key PublicKey to verify with\n+     @param sigProvider Provider to use for signature algorithm\n+\n+     @throws CertificateException encoding error\n+     @throws NoSuchAlgorithmException unsupported algorithm\n+     @throws InvalidKeyException incorrect key\n+     @throws NoSuchProviderException incorrect provider\n+     @throws SignatureException signature error\n+  */\n+  public abstract void verify(PublicKey key,\n+\t\t\t      String sigProvider)\n+    throws CertificateException,\n+    NoSuchAlgorithmException,\n+    InvalidKeyException,\n+    NoSuchProviderException,\n+    SignatureException;\n+\n+  /**\n+     Returns a string representing the Certificate.\n+\n+     @return a string representing the Certificate.\n+  */\n+  public abstract String toString();\n+\n+\n+  /**\n+     Returns the public key stored in the Certificate.\n+\n+     @return The public key\n+  */\n+  public abstract PublicKey getPublicKey();\n+\n+\n+  /* INNER CLASS */\n+  /**\n+     Certificate.CertificateRep is an inner class used to provide an alternate\n+     storage mechanism for serialized Certificates.\n+  */\n+  protected static class CertificateRep implements java.io.Serializable\n+  {\n+    private String type;\n+    private byte[] data;\n+\n+    /**\n+       Create an alternate Certificate class to store a serialized Certificate\n+\n+       @param type the name of certificate type\n+       @param data the certificate data\n+    */\n+    protected CertificateRep(String type,\n+\t\t\t     byte[] data)\n+    {\n+      this.type = type;\n+      this.data = data;\n+    }\n+\n+    /**\n+       Return the stored Certificate\n+\n+       @return the stored certificate\n+\n+       @throws ObjectStreamException if certificate cannot be resolved\n+    */\n+    protected Object readResolve()\n+      throws ObjectStreamException\n+    {\n+      try {\n+\treturn new ObjectInputStream( new ByteArrayInputStream( data ) ).readObject();\n+      } catch ( Exception e ) {\n+\te.printStackTrace();\n+\tthrow new RuntimeException ( e.toString() );\n+      }\n+    }\n+  }\n+\n+}"}, {"sha": "ab8843fe38d286ca87d91bd071bc73c2f85a1264", "filename": "libjava/java/security/cert/CertificateEncodingException.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateEncodingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateEncodingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateEncodingException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,58 @@\n+/* CertificateEncodingException.java --- Certificate Encoding Exception\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+\tException for a Certificate Encoding.\n+\n+\t@since JDK 1.2\n+\n+\t@author Mark Benvenuto\n+*/\n+public class CertificateEncodingException extends CertificateException\n+{\n+\n+  /**\n+     Constructs an CertificateEncodingException without a message string.\n+  */\n+  public CertificateEncodingException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+     Constructs an CertificateEncodingException with a message string.\n+\n+     @param msg A message to display with exception\n+  */\n+  public CertificateEncodingException(String msg)\n+  {\n+    super( msg );\n+  }\n+\n+}"}, {"sha": "ab584d2cbbf7ed26845ab2d76c90348e1dbeaa80", "filename": "libjava/java/security/cert/CertificateException.java", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,59 @@\n+/* CertificateException.java --- Certificate Exception\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.security.GeneralSecurityException;\n+\n+/**\n+\tException for a Certificate.\n+\n+\t@since JDK 1.2\n+\n+\t@author Mark Benvenuto\n+*/\n+public class CertificateException extends GeneralSecurityException\n+{\n+\n+  /**\n+     Constructs an CertificateException without a message string.\n+  */\n+  public CertificateException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+     Constructs an CertificateException with a message string.\n+\n+     @param msg A message to display with exception\n+  */\n+  public CertificateException(String msg)\n+  {\n+    super( msg );\n+  }\n+\n+}"}, {"sha": "c5b67f3573b1d7335762a6c1e96197c4b1b433dd", "filename": "libjava/java/security/cert/CertificateExpiredException.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateExpiredException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateExpiredException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateExpiredException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,58 @@\n+/* CertificateExpiredException.java --- Certificate Expired Exception\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+   Exception for a Certificate Expiring.\n+   \n+   @since JDK 1.2\n+   \n+   @author Mark Benvenuto\n+*/\n+public class CertificateExpiredException extends CertificateException\n+{\n+\n+  /**\n+     Constructs an CertificateExpiredException without a message string.\n+  */\n+  public CertificateExpiredException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+     Constructs an CertificateExpiredException with a message string.\n+\n+     @param msg A message to display with exception\n+  */\n+  public CertificateExpiredException(String msg)\n+  {\n+    super( msg );\n+  }\n+\n+}"}, {"sha": "b5fe2e3518ed6d906185f41da5e24a12da09892e", "filename": "libjava/java/security/cert/CertificateFactory.java", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactory.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,259 @@\n+/* CertificateFactory.java --- Certificate Factory Class\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.io.InputStream;\n+import java.util.Collection;\n+\n+/**\n+   This class implments the CertificateFactory class interface\n+   used to generate certificates and certificate revocation\n+   list (CRL) objects from their encodings.\n+   \n+   A certifcate factory for X.509 returns certificates of the \n+   java.security.cert.X509Certificate class, and CRLs of the \n+   java.security.cert.X509CRL class. \n+   \n+   @since JDK 1.2\n+\n+   @author Mark Benvenuto\n+*/\n+public class CertificateFactory\n+{\n+\n+  private CertificateFactorySpi certFacSpi;\n+  private Provider provider;\n+  private String type;\n+\n+  /**\n+     Creates an instance of CertificateFactory\n+\n+     @param certFacSpi A CertificateFactory engine to use\n+     @param provider A provider to use\n+     @param type The type of Certificate\n+  */\n+  protected CertificateFactory(CertificateFactorySpi certFacSpi, Provider provider, String type)\n+  {\n+    this.certFacSpi = certFacSpi;\n+    this.provider = provider;\n+    this.type = type;\n+  }\n+\n+\n+  /** \n+      Gets an instance of the CertificateFactory class representing\n+      the specified certificate factory. If the type is not \n+      found then, it throws CertificateException.\n+\n+      @param type the type of certificate to choose\n+\n+      @return a CertificateFactory repesenting the desired type\n+\n+      @throws CertificateException if the type of certificate is not implemented by providers\n+  */\n+  public static final CertificateFactory getInstance(String type) throws CertificateException\n+  {\n+    Provider[] p = Security.getProviders ();\n+\n+    for (int i = 0; i < p.length; i++)\n+      {\n+\tString classname = p[i].getProperty (\"CertificateFactory.\" + type);\n+\tif (classname != null)\n+\t  return getInstance (classname, type, p[i]);\n+      }\n+\n+    throw new CertificateException(type);\n+  }\n+\n+\n+\n+  /** \n+      Gets an instance of the CertificateFactory class representing\n+      the specified certificate factory from the specified provider. \n+      If the type is not found then, it throws CertificateException. \n+      If the provider is not found, then it throws \n+      NoSuchProviderException.\n+\n+      @param type the type of certificate to choose\n+\n+      @return a CertificateFactory repesenting the desired type\n+\n+      @throws CertificateException if the type of certificate is not implemented by providers\n+      @throws NoSuchProviderException if the provider is not found\n+  */\n+  public static final CertificateFactory getInstance(String type, String provider) \n+    throws CertificateException, NoSuchProviderException\n+  {\n+    Provider p = Security.getProvider(provider);\n+    if( p == null)\n+      throw new NoSuchProviderException();\n+\n+    return getInstance (p.getProperty (\"CertificateFactory.\" + type),\n+\t\t\ttype, p);\n+  }\n+\n+  private static CertificateFactory getInstance (String classname,\n+\t\t\t\t\t\t String type,\n+\t\t\t\t\t\t Provider provider)\n+    throws CertificateException\n+  {\n+    try {\n+      return new CertificateFactory( (CertificateFactorySpi)Class.forName( classname ).newInstance(), provider, type );\n+    } catch( ClassNotFoundException cnfe) {\n+      throw new CertificateException(\"Class not found\");\n+    } catch( InstantiationException ie) {\n+      throw new CertificateException(\"Class instantiation failed\");\n+    } catch( IllegalAccessException iae) {\n+      throw new CertificateException(\"Illegal Access\");\n+    }\n+  }\n+\n+\n+  /**\n+     Gets the provider that the class is from.\n+\n+     @return the provider of this class\n+  */\n+  public final Provider getProvider()\n+  {\n+    return provider;\n+  }\n+\n+  /**\n+     Returns the type of the certificate supported\n+\n+     @return A string with the type of certificate\n+  */\n+  public final String getType()\n+  {\n+    return type;\n+  }\n+\n+  /**\n+     Generates a Certificate based on the encoded data read\n+     from the InputStream.\n+\n+     The input stream must contain only one certificate.\n+\n+     If there exists a specialized certificate class for the\n+     certificate format handled by the certificate factory\n+     then the return Ceritificate should be a typecast of it.\n+     Ex: A X.509 CertificateFactory should return X509Certificate.\n+\n+     For X.509 certificates, the certificate in inStream must be\n+     DER encoded and supplied in binary or printable (Base64) \n+     encoding. If the certificate is in Base64 encoding, it must be \n+     bounded by -----BEGINCERTIFICATE-----, and \n+     -----END CERTIFICATE-----. \n+\n+     @param inStream an input stream containing the certificate data\n+\n+     @return a certificate initialized with InputStream data.\n+\n+     @throws CertificateException Certificate parsing error\n+  */\n+  public final Certificate generateCertificate(InputStream inStream)\n+    throws CertificateException\n+  {\n+    return certFacSpi.engineGenerateCertificate( inStream );\n+  }\n+\n+  /**\n+     Returns a collection of certificates that were read from the \n+     input stream. It may be empty, have only one, or have \n+     multiple certificates.\n+\n+     For a X.509 certificate factory, the stream may contain a\n+     single DER encoded certificate or a PKCS#7 certificate \n+     chain. This is a PKCS#7 <I>SignedData</I> object with the \n+     most significant field being <I>certificates</I>. If no \n+     CRLs are present, then an empty collection is returned.\n+\t\n+     @param inStream an input stream containing the certificates\n+\n+     @return a collection of certificates initialized with \n+     the InputStream data.\n+\n+     @throws CertificateException Certificate parsing error\n+  */\n+  public final Collection generateCertificates(InputStream inStream)\n+    throws CertificateException\n+  {\n+    return certFacSpi.engineGenerateCertificates( inStream );\n+  }\n+\n+  /**\n+     Generates a CRL based on the encoded data read\n+     from the InputStream.\n+\n+     The input stream must contain only one CRL.\n+\n+     If there exists a specialized CRL class for the\n+     CRL format handled by the certificate factory\n+     then the return CRL should be a typecast of it.\n+     Ex: A X.509 CertificateFactory should return X509CRL.\n+\n+     @param inStream an input stream containing the CRL data\n+\n+     @return a CRL initialized with InputStream data.\n+\n+     @throws CRLException CRL parsing error\n+  */\n+  public final CRL generateCRL(InputStream inStream)\n+    throws CRLException\n+  {\n+    return certFacSpi.engineGenerateCRL( inStream );\n+  }\n+\n+\n+  /**\n+     Generates CRLs based on the encoded data read\n+     from the InputStream.\n+\n+     For a X.509 certificate factory, the stream may contain a\n+     single DER encoded CRL or a PKCS#7 CRL set. This is a \n+     PKCS#7 <I>SignedData</I> object with the most significant \n+     field being <I>crls</I>. If no CRLs are present, then an\n+     empty collection is returned.\n+\n+     @param inStream an input stream containing the CRLs\n+\n+     @return a collection of CRLs initialized with \n+     the InputStream data.\n+\n+     @throws CRLException CRL parsing error\n+  */\n+  public final Collection generateCRLs(InputStream inStream)\n+    throws CRLException\n+  {\n+    return certFacSpi.engineGenerateCRLs( inStream );\n+  }\n+\n+}"}, {"sha": "5fb5b966ab6487b15b17e172fd3253001397dfc3", "filename": "libjava/java/security/cert/CertificateFactorySpi.java", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactorySpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactorySpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateFactorySpi.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,142 @@\n+/* CertificateFactorySpi.java --- Certificate Factory Class\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.io.InputStream;\n+import java.util.Collection;\n+\n+/**\n+   CertificateFactorySpi is the abstract class Service Provider\n+   Interface (SPI) for the CertificateFactory class. A provider\n+   must implment all the abstract methods if they wish to \n+   supply a certificate factory for a particular certificate\n+   type. Ex: X.509\n+   \n+   Certificate factories are used to generate certificates and\n+   certificate revocation lists (CRL) from their encoding.\n+   \n+   @since JDK 1.2\n+   \n+   @author Mark Benvenuto\n+*/\n+public abstract class CertificateFactorySpi\n+{\n+\n+  /**\n+     Constructs a new CertificateFactorySpi\n+  */\n+  public CertificateFactorySpi()\n+  {}\n+\n+  /**\n+     Generates a Certificate based on the encoded data read\n+     from the InputStream.\n+\n+     The input stream must contain only one certificate.\n+\n+     If there exists a specialized certificate class for the\n+     certificate format handled by the certificate factory\n+     then the return Ceritificate should be a typecast of it.\n+     Ex: A X.509 CertificateFactory should return X509Certificate.\n+\n+     For X.509 certificates, the certificate in inStream must be\n+     DER encoded and supplied in binary or printable (Base64) \n+     encoding. If the certificate is in Base64 encoding, it must be \n+     bounded by -----BEGINCERTIFICATE-----, and \n+     -----END CERTIFICATE-----. \n+\n+     @param inStream an input stream containing the certificate data\n+\n+     @return a certificate initialized with InputStream data.\n+\n+     @throws CertificateException Certificate parsing error\n+  */\n+  public abstract Certificate engineGenerateCertificate(InputStream inStream)\n+    throws CertificateException;\n+\n+  /**\n+     Returns a collection of certificates that were read from the \n+     input stream. It may be empty, have only one, or have \n+     multiple certificates.\n+\n+     For a X.509 certificate factory, the stream may contain a\n+     single DER encoded certificate or a PKCS#7 certificate \n+     chain. This is a PKCS#7 <I>SignedData</I> object with the \n+     most significant field being <I>certificates</I>. If no \n+     CRLs are present, then an empty collection is returned.\n+\t\n+     @param inStream an input stream containing the certificates\n+\n+     @return a collection of certificates initialized with \n+     the InputStream data.\n+\n+     @throws CertificateException Certificate parsing error\n+  */\n+  public abstract Collection engineGenerateCertificates(InputStream inStream)\n+    throws CertificateException;\n+\n+  /**\n+     Generates a CRL based on the encoded data read\n+     from the InputStream.\n+\n+     The input stream must contain only one CRL.\n+\n+     If there exists a specialized CRL class for the\n+     CRL format handled by the certificate factory\n+     then the return CRL should be a typecast of it.\n+     Ex: A X.509 CertificateFactory should return X509CRL.\n+\n+     @param inStream an input stream containing the CRL data\n+\n+     @return a CRL initialized with InputStream data.\n+\n+     @throws CRLException CRL parsing error\n+  */\n+  public abstract CRL engineGenerateCRL(InputStream inStream)\n+    throws CRLException;\n+\n+  /**\n+     Generates CRLs based on the encoded data read\n+     from the InputStream.\n+\n+     For a X.509 certificate factory, the stream may contain a\n+     single DER encoded CRL or a PKCS#7 CRL set. This is a \n+     PKCS#7 <I>SignedData</I> object with the most significant \n+     field being <I>crls</I>. If no CRLs are present, then an\n+     empty collection is returned.\n+\n+     @param inStream an input stream containing the CRLs\n+\n+     @return a collection of CRLs initialized with \n+     the InputStream data.\n+\n+     @throws CRLException CRL parsing error\n+  */\n+  public abstract Collection engineGenerateCRLs(InputStream inStream)\n+    throws CRLException;\n+}\n+"}, {"sha": "ec2cc2121432bfdfc5f62fb3136552a45acf325f", "filename": "libjava/java/security/cert/CertificateNotYetValidException.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateNotYetValidException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateNotYetValidException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateNotYetValidException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,58 @@\n+/* CertificateNotYetValidException.java --- Certificate Not Yet Valid Exception\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+   Exception for a Certificate being not yet valid.\n+   \n+   @since JDK 1.2\n+   \n+   @author Mark Benvenuto\n+*/\n+public class CertificateNotYetValidException extends CertificateException\n+{\n+\n+  /**\n+     Constructs an CertificateNotYetValidException without a message string.\n+  */\n+  public CertificateNotYetValidException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+     Constructs an CertificateNotYetValidException with a message string.\n+\n+     @param msg A message to display with exception\n+  */\n+  public CertificateNotYetValidException(String msg)\n+  {\n+    super( msg );\n+  }\n+\n+}"}, {"sha": "6184e01d2a464b8a62498e1832c990eb7f7e6b37", "filename": "libjava/java/security/cert/CertificateParsingException.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateParsingException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateParsingException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FCertificateParsingException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,58 @@\n+/* CertificateParsingException.java --- Certificate Parsing Exception\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+\n+/**\n+   Exception for a Certificate Parsing.\n+   \n+   @since JDK 1.2\n+   \n+   @author Mark Benvenuto\n+*/\n+public class CertificateParsingException extends CertificateException\n+{\n+\n+  /**\n+     Constructs an CertificateParsingException without a message string.\n+  */\n+  public CertificateParsingException()\n+  {\n+    super();\n+  }\n+\n+  /**\n+     Constructs an CertificateParsingException with a message string.\n+\n+     @param msg A message to display with exception\n+  */\n+  public CertificateParsingException(String msg)\n+  {\n+    super( msg );\n+  }\n+\n+}"}, {"sha": "c3b715351aa41071411e1feb1b842e1baca77e18", "filename": "libjava/java/security/cert/X509CRL.java", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRL.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,370 @@\n+/* X509CRL.java --- X.509 Certificate Revocation List\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.math.BigInteger;\n+import java.security.Principal;\n+import java.security.PublicKey;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchProviderException;\n+import java.security.SignatureException;\n+import java.util.Date;\n+import java.util.Set;\n+\n+/**\n+   The X509CRL class is the abstract class used to manage\n+   X.509 Certificate Revocation Lists. The CRL is a list of\n+   time stamped entries which indicate which lists have been\n+   revoked. The list is signed by a Certificate Authority (CA)\n+   and made publically available in a repository.\n+   \n+   Each revoked certificate in the CRL is identified by its \n+   certificate serial number. When a piece of code uses a \n+   certificate, the certificates validity is checked by \n+   validating its signature and determing that it is not\n+   only a recently acquired CRL. The recently aquired CRL\n+   is depends on the local policy in affect. The CA issues\n+   a new CRL periodically and entries are removed as the \n+   certificate expiration date is reached\n+   \n+   \n+   A description of the X.509 v2 CRL follows below from rfc2459.\n+   \n+   \"The X.509 v2 CRL syntax is as follows.  For signature calculation,\n+   the data that is to be signed is ASN.1 DER encoded.  ASN.1 DER\n+   encoding is a tag, length, value encoding system for each element.\n+   \n+\t   CertificateList  ::=  SEQUENCE  {\n+        \ttbsCertList          TBSCertList,\n+\t        signatureAlgorithm   AlgorithmIdentifier,\n+        \tsignatureValue       BIT STRING  }\n+\t\n+\t   TBSCertList  ::=  SEQUENCE  {\n+        \tversion                 Version OPTIONAL,\n+                                     -- if present, shall be v2\n+\t        signature               AlgorithmIdentifier,\n+        \tissuer                  Name,\n+\t        thisUpdate              Time,\n+\t        nextUpdate              Time OPTIONAL,\n+\t        revokedCertificates     SEQUENCE OF SEQUENCE  {\n+\t             userCertificate         CertificateSerialNumber,\n+\t             revocationDate          Time,\n+\t             crlEntryExtensions      Extensions OPTIONAL\n+\t                                           -- if present, shall be v2\n+\t                                  }  OPTIONAL,\n+\t        crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n+\t                                           -- if present, shall be v2\n+\t                                  }\"\n+\n+\t@author Mark Benvenuto\n+\n+\t@since JDK 1.2\n+*/\n+public abstract class X509CRL extends CRL implements X509Extension\n+{\n+\n+  /**\n+     Constructs a new X509CRL.\n+  */\n+  protected X509CRL()\n+  {\n+    super(\"X.509\");\n+  }\n+\n+  /**\n+     Compares this X509CRL to other. It checks if the\n+     object if instanceOf X509CRL and then checks if\n+     the encoded form matches.\n+\n+     @param other An Object to test for equality\n+\n+     @return true if equal, false otherwise\n+  */\n+  public boolean equals(Object other)\n+  {\n+    if( other instanceof X509CRL ) {\n+      try {\n+\tX509CRL x = (X509CRL) other;\n+\tif( getEncoded().length != x.getEncoded().length )\n+\t  return false;\n+\n+\tbyte b1[] = getEncoded();\n+\tbyte b2[] = x.getEncoded();\n+\n+\tfor( int i = 0; i < b1.length; i++ )\n+\t  if( b1[i] != b2[i] )\n+\t    return false;\n+\n+      } catch( CRLException crle ) { \n+\treturn false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+     Returns a hash code for this X509CRL in its encoded\n+     form.\n+\n+     @return A hash code of this class\n+  */\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  /**\n+     Gets the DER ASN.1 encoded format for this X.509 CRL.\n+\n+     @return byte array containg encoded form\n+\n+     @throws CRLException if an error occurs\n+  */\n+  public abstract byte[] getEncoded() throws CRLException;\n+\n+  /**\n+     Verifies that this CRL was properly signed with the\n+     PublicKey that corresponds to its private key. \n+\n+     @param key PublicKey to verify with\n+\n+     @throws CRLException encoding error\n+     @throws NoSuchAlgorithmException unsupported algorithm\n+     @throws InvalidKeyException incorrect key\n+     @throws NoSuchProviderException no provider\n+     @throws SignatureException signature error\n+  */\n+  public abstract void verify(PublicKey key)\n+    throws CRLException,\n+    NoSuchAlgorithmException,\n+    InvalidKeyException,\n+    NoSuchProviderException,\n+    SignatureException;\n+\n+  /**\n+     Verifies that this CRL was properly signed with the\n+     PublicKey that corresponds to its private key and uses\n+     the signature engine provided by the provider. \n+\n+     @param key PublicKey to verify with\n+     @param sigProvider Provider to use for signature algorithm\n+\n+     @throws CRLException encoding error\n+     @throws NoSuchAlgorithmException unsupported algorithm\n+     @throws InvalidKeyException incorrect key\n+     @throws NoSuchProviderException incorrect provider\n+     @throws SignatureException signature error\n+  */\n+  public abstract void verify(PublicKey key,\n+\t\t\t      String sigProvider)\n+    throws CRLException,\n+    NoSuchAlgorithmException,\n+    InvalidKeyException,\n+    NoSuchProviderException,\n+    SignatureException;\n+\n+  /**\n+     Gets the version of this CRL.\n+\n+     The ASN.1 encoding is:\n+\n+     version                 Version OPTIONAL,\n+     -- if present, shall be v2\n+\n+     Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the version number, Ex: 1 or 2\n+  */\n+  public abstract int getVersion();\n+\n+  /**\n+     Returns the issuer (issuer distinguished name) of the CRL.\n+     The issuer is the entity who signed and issued the \n+     Certificate Revocation List.\n+\n+     The ASN.1 DER encoding is:\n+\n+     issuer                  Name,\n+\n+     Name ::= CHOICE {\n+     RDNSequence }\n+\n+     RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n+\n+     RelativeDistinguishedName ::=\n+     SET OF AttributeTypeAndValue\n+\n+     AttributeTypeAndValue ::= SEQUENCE {\n+     type     AttributeType,\n+     value    AttributeValue }\n+\n+     AttributeType ::= OBJECT IDENTIFIER\n+\n+     AttributeValue ::= ANY DEFINED BY AttributeType\n+\n+     DirectoryString ::= CHOICE {\n+     teletexString           TeletexString (SIZE (1..MAX)),\n+     printableString         PrintableString (SIZE (1..MAX)),\n+     universalString         UniversalString (SIZE (1..MAX)),\n+     utf8String              UTF8String (SIZE (1.. MAX)),\n+     bmpString               BMPString (SIZE (1..MAX)) }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the issuer in the Principal class\n+  */\n+  public abstract Principal getIssuerDN();\n+\n+  /**\n+     Returns the thisUpdate date of the CRL.\n+\n+     The ASN.1 DER encoding is:\n+\n+     thisUpdate              Time,\n+\n+     Time ::= CHOICE {\n+     utcTime        UTCTime,\n+     generalTime    GeneralizedTime }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the thisUpdate date\n+  */\n+  public abstract Date getThisUpdate();\n+\n+  /*\n+    Gets the nextUpdate field\n+\n+    The ASN.1 DER encoding is:\n+\n+    nextUpdate              Time OPTIONAL,\n+\n+    Time ::= CHOICE {\n+    utcTime        UTCTime,\n+    generalTime    GeneralizedTime }\n+\n+    Consult rfc2459 for more information.\n+\n+    @return the nextUpdate date\n+  */\n+  public abstract Date getNextUpdate();\n+\n+  /**\n+     Gets the requeste dX509Entry for the specified\n+     certificate serial number.\n+\n+     @return a X509CRLEntry representing the X.509 CRL entry\n+  */\n+  public abstract X509CRLEntry getRevokedCertificate(BigInteger serialNumber);\n+\n+  /**\n+     Returns a Set of revoked certificates.\n+\n+     @return a set of revoked certificates.\n+  */\n+  public abstract Set getRevokedCertificates();\n+\n+  /**\n+     Returns the DER ASN.1 encoded tbsCertList which is \n+     the basic information of the list and associated certificates\n+     in the encoded state. See top for more information.\n+\n+     The ASN.1 DER encoding is:\n+\n+     tbsCertList          TBSCertList,\n+\n+     Consult rfc2459 for more information.\n+\n+     @return byte array representing tbsCertList\n+  */\n+  public abstract byte[] getTBSCertList() throws CRLException;\n+\n+\n+  /**\n+     Returns the signature for the CRL. \n+\n+     The ASN.1 DER encoding is:\n+\n+     signatureValue       BIT STRING\n+\n+     Consult rfc2459 for more information.\n+  */\n+  public abstract byte[] getSignature();\n+\n+  /**\n+     Returns the signature algorithm used to sign the CRL. \n+     An examples is \"SHA-1/DSA\".\n+\n+     The ASN.1 DER encoding is:\n+\n+     signatureAlgorithm   AlgorithmIdentifier,\n+\n+     AlgorithmIdentifier  ::=  SEQUENCE  {\n+     algorithm               OBJECT IDENTIFIER,\n+     parameters              ANY DEFINED BY algorithm OPTIONAL  }\n+\n+     Consult rfc2459 for more information.\n+\n+     The algorithm name is determined from the OID.\n+\n+     @return a string with the signature algorithm name\n+  */\n+  public abstract String getSigAlgName();\n+\n+  /**\n+     Returns the OID for the signature algorithm used.\n+     Example \"1.2.840.10040.4.3\" is return for SHA-1 with DSA.\\\n+\n+     The ASN.1 DER encoding for the example is:\n+\n+     id-dsa-with-sha1 ID  ::=  {\n+     iso(1) member-body(2) us(840) x9-57 (10040)\n+     x9cm(4) 3 }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return a string containing the OID.\n+  */\n+  public abstract String getSigAlgOID();\n+\n+  /**\n+     Returns the AlgorithmParameters in the encoded form\n+     for the signature algorithm used. \n+\n+     If access to the parameters is need, create an \n+     instance of AlgorithmParameters.\n+\n+     @return byte array containing algorithm parameters, null\n+     if no parameters are present in CRL\n+  */\n+  public abstract byte[] getSigAlgParams();\n+\n+}"}, {"sha": "2fbe64199fde723bc3e87df2d4528902fae297d9", "filename": "libjava/java/security/cert/X509CRLEntry.java", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRLEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRLEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509CRLEntry.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,157 @@\n+/* X509CRLEntry.java --- X.509 Certificate Revocation List Entry\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.math.BigInteger;\n+import java.util.Date;\n+\n+/**\n+\tAbstract class for entries in the CRL (Certificate Revocation \n+\tList). The ASN.1 definition for <I>revokedCertificates</I> is\n+\n+        revokedCertificates     SEQUENCE OF SEQUENCE  {\n+             userCertificate         CertificateSerialNumber,\n+             revocationDate          Time,\n+             crlEntryExtensions      Extensions OPTIONAL\n+                                           -- if present, shall be v2\n+                                  }  OPTIONAL,\n+\n+\tCertificateSerialNumber  ::=  INTEGER\n+\n+\tTime ::= CHOICE {\n+             utcTime        UTCTime,\n+\t     generalTime    GeneralizedTime }\n+\n+\tExtensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n+\n+\tExtension  ::=  SEQUENCE  {\n+\t     extnID      OBJECT IDENTIFIER,\n+             critical    BOOLEAN DEFAULT FALSE,\n+             extnValue   OCTET STRING  }\n+ \n+\tFor more information consult rfc2459.\n+\n+\t@author Mark Benvenuto\n+\n+\t@since JDK 1.2\n+*/\n+public abstract class X509CRLEntry implements X509Extension\n+{\n+\n+  /**\n+     Creates a new X509CRLEntry\n+  */\n+  public X509CRLEntry()\n+  {}\n+\n+  /**\n+     Compares this X509CRLEntry to other. It checks if the\n+     object if instanceOf X509CRLEntry and then checks if\n+     the encoded form( the inner SEQUENCE) matches.\n+\n+     @param other An Object to test for equality\n+\n+     @return true if equal, false otherwise\n+  */\n+  public boolean equals(Object other)\n+  {\n+    if( other instanceof X509CRLEntry ) {\n+      try {\n+\tX509CRLEntry xe = (X509CRLEntry) other;\n+\tif( getEncoded().length != xe.getEncoded().length )\n+\t  return false;\n+\n+\tbyte b1[] = getEncoded();\n+\tbyte b2[] = xe.getEncoded();\n+\n+\tfor( int i = 0; i < b1.length; i++ )\n+\t  if( b1[i] != b2[i] )\n+\t    return false;\n+\n+      } catch( CRLException crle ) { \n+\treturn false;\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+     Returns a hash code for this X509CRLEntry in its encoded\n+     form.\n+\n+     @return A hash code of this class\n+  */\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  /**\n+     Gets the DER ASN.1 encoded format for this CRL Entry,\n+     the inner SEQUENCE.\n+\n+     @return byte array containg encoded form\n+\n+     @throws CRLException if an error occurs\n+  */\n+  public abstract byte[] getEncoded() throws CRLException;\n+\n+  /**\n+     Gets the serial number for <I>userCertificate</I> in\n+     this X509CRLEntry.\n+\n+     @return the serial number for this X509CRLEntry.\n+  */\n+  public abstract BigInteger getSerialNumber();\n+\n+\n+  /**\n+     Gets the revocation date in <I>revocationDate</I> for\n+     this X509CRLEntry.\n+\n+     @return the revocation date for this X509CRLEntry.\n+  */\n+  public abstract Date getRevocationDate();\n+\n+\n+  /**\n+     Checks if this X509CRLEntry has extensions.\n+\n+     @return true if it has extensions, false otherwise\n+  */\n+  public abstract boolean hasExtensions();\n+\n+\n+  /**\n+     Returns a string that represents this X509CRLEntry.\n+\n+     @return a string representing this X509CRLEntry.\n+  */\n+  public abstract String toString();\n+\n+}"}, {"sha": "46f47f615d56239979224b1489d04231b3f7fee4", "filename": "libjava/java/security/cert/X509Certificate.java", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Certificate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Certificate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Certificate.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,444 @@\n+/* X509Certificate.java --- X.509 Certificate class\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.math.BigInteger;\n+import java.security.Principal;\n+import java.security.PublicKey;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchProviderException;\n+import java.security.SignatureException;\n+import java.util.Date;\n+\n+/**\n+\tX509Certificate is the abstract class for X.509 certificates.\n+\tThis provides a stanard class interface for accessing all \n+\tthe attributes of X.509 certificates.\n+\n+\tIn June 1996, the basic X.509 v3 format was finished by \n+\tISO/IEC and ANSI X.9. The ASN.1 DER format is below:\n+\n+\t   Certificate  ::=  SEQUENCE  {\n+        \ttbsCertificate       TBSCertificate,\n+\t        signatureAlgorithm   AlgorithmIdentifier,\n+        \tsignatureValue       BIT STRING  }\n+\n+\tThese certificates are widely used in various Internet \n+\tprotocols to support authentication. It is used in \n+\tPrivacy Enhanced Mail (PEM), Transport Layer Security (TLS),\n+\tSecure Sockets Layer (SSL), code signing for trusted software\n+\tdistribution, and Secure Electronic Transactions (SET).\n+\n+\tThe certificates are managed and vouched for by \n+\t<I>Certificate Authorities</I> (CAs). CAs are companies or \n+\tgroups that create certificates by placing the data in the \n+\tX.509 certificate format and signing it with their private\n+\tkey. CAs serve as trusted third parties by certifying that\n+\tthe person or group specified in the certificate is who\n+\tthey say they are. \n+\n+\tThe ASN.1 defintion for <I>tbsCertificate</I> is\n+\t\n+   TBSCertificate  ::=  SEQUENCE  {\n+        version         [0]  EXPLICIT Version DEFAULT v1,\n+        serialNumber         CertificateSerialNumber,\n+        signature            AlgorithmIdentifier,\n+        issuer               Name,\n+        validity             Validity,\n+        subject              Name,\n+        subjectPublicKeyInfo SubjectPublicKeyInfo,\n+        issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n+                             -- If present, version shall be v2 or v3\n+        subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n+                             -- If present, version shall be v2 or v3\n+        extensions      [3]  EXPLICIT Extensions OPTIONAL\n+                             -- If present, version shall be v3\n+        }\n+\n+   Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n+\n+   CertificateSerialNumber  ::=  INTEGER\n+\n+   Validity ::= SEQUENCE {\n+        notBefore      Time,\n+        notAfter       Time }\n+\n+   Time ::= CHOICE {\n+        utcTime        UTCTime,\n+        generalTime    GeneralizedTime }\n+\n+   UniqueIdentifier  ::=  BIT STRING\n+\n+   SubjectPublicKeyInfo  ::=  SEQUENCE  {\n+        algorithm            AlgorithmIdentifier,\n+        subjectPublicKey     BIT STRING  }\n+\n+   Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n+\n+   Extension  ::=  SEQUENCE  {\n+        extnID      OBJECT IDENTIFIER,\n+        critical    BOOLEAN DEFAULT FALSE,\n+        extnValue   OCTET STRING  }\n+\n+\n+\tCertificates are created with the CertificateFactory.\n+\tFor more information about X.509 certificates, consult\n+\trfc2459.\n+\n+\t@since JDK 1.2\n+\n+\t@author Mark Benvenuto\n+*/\n+public abstract class X509Certificate extends Certificate implements X509Extension\n+{\n+\n+  /**\n+     Constructs a new certificate of the specified type.\n+  */\n+  protected X509Certificate()\n+  {\n+    super( \"X.509\" );\n+  }\n+\n+  /**\n+     Checks the validity of the X.509 certificate. It is valid\n+     if the current date and time are within the period specified\n+     by the certificate.\n+\n+     The ASN.1 DER encoding is:\n+\n+     validity             Validity,\n+\n+     Validity ::= SEQUENCE {\n+     notBefore      Time,\n+     notAfter       Time }\n+\n+     Time ::= CHOICE {\n+     utcTime        UTCTime,\n+     generalTime    GeneralizedTime }\n+\n+     Consult rfc2459 for more information.\n+\n+     @throws CertificateExpiredException if the certificate expired\n+     @throws CertificateNotYetValidException if the certificate is \n+     not yet valid\n+  */\n+  public abstract void checkValidity()\n+    throws CertificateExpiredException,\n+    CertificateNotYetValidException;\n+\n+  /**\n+     Checks the validity of the X.509 certificate for the \n+     specified time and date. It is valid if the specified \n+     date and time are within the period specified by \n+     the certificate.\n+\n+     @throws CertificateExpiredException if the certificate expired \n+     based on the date\n+     @throws CertificateNotYetValidException if the certificate is \n+     not yet valid based on the date\n+  */\n+  public abstract void checkValidity(Date date)\n+    throws CertificateExpiredException,\n+    CertificateNotYetValidException;\n+\n+  /**\n+     Returns the version of this certificate.\n+\n+     The ASN.1 DER encoding is:\n+\n+     version         [0]  EXPLICIT Version DEFAULT v1,\n+\n+     Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return version number of certificate\t\n+  */\n+  public abstract int getVersion();\n+\n+  /**\n+     Gets the serial number for serial Number in\n+     this Certifcate. It must be a unique number \n+     unique other serial numbers from the granting CA.\n+\n+     The ASN.1 DER encoding is:\n+\n+     serialNumber         CertificateSerialNumber,\n+\n+     CertificateSerialNumber  ::=  INTEGER\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the serial number for this X509CRLEntry.\n+  */\n+  public abstract BigInteger getSerialNumber();\n+\n+  /**\n+     Returns the issuer (issuer distinguished name) of the \n+     Certificate. The issuer is the entity who signed \n+     and issued the Certificate.\n+\n+     The ASN.1 DER encoding is:\n+\n+     issuer                  Name,\n+\n+     Name ::= CHOICE {\n+     RDNSequence }\n+\n+     RDNSequence ::= SEQUENCE OF RelativeDistinguishedName\n+\n+     RelativeDistinguishedName ::=\n+     SET OF AttributeTypeAndValue\n+\n+     AttributeTypeAndValue ::= SEQUENCE {\n+     type     AttributeType,\n+     value    AttributeValue }\n+\n+     AttributeType ::= OBJECT IDENTIFIER\n+\n+     AttributeValue ::= ANY DEFINED BY AttributeType\n+\n+     DirectoryString ::= CHOICE {\n+     teletexString           TeletexString (SIZE (1..MAX)),\n+     printableString         PrintableString (SIZE (1..MAX)),\n+     universalString         UniversalString (SIZE (1..MAX)),\n+     utf8String              UTF8String (SIZE (1.. MAX)),\n+     bmpString               BMPString (SIZE (1..MAX)) }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the issuer in the Principal class\n+  */\n+  public abstract Principal getIssuerDN();\n+\n+  /**\n+     Returns the subject (subject distinguished name) of the \n+     Certificate. The subject is the entity who the Certificate\n+     identifies.\n+\n+     The ASN.1 DER encoding is:\n+\n+     subject              Name,\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the issuer in the Principal class\n+  */\n+  public abstract Principal getSubjectDN();\n+\n+  /**\n+     Returns the date that this certificate is not to be used\n+     before, <I>notBefore</I>.\n+\n+     The ASN.1 DER encoding is:\n+\n+     validity             Validity,\n+\n+     Validity ::= SEQUENCE {\n+     notBefore      Time,\n+     notAfter       Time }\n+\n+     Time ::= CHOICE {\n+     utcTime        UTCTime,\n+     generalTime    GeneralizedTime }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the date <I>notBefore</I>\n+  */\n+  public abstract Date getNotBefore();\n+\n+  /**\n+     Returns the date that this certificate is not to be used\n+     after, <I>notAfter</I>.\n+\n+     @return the date <I>notAfter</I>\n+  */\n+  public abstract Date getNotAfter();\n+\n+\n+  /**\n+     Returns the <I>tbsCertificate</I> from the certificate.\n+\n+     @return the DER encoded tbsCertificate\n+\n+     @throws CertificateEncodingException if encoding error occured\n+  */\n+  public abstract byte[] getTBSCertificate() throws CertificateEncodingException;\n+\n+  /**\n+     Returns the signature in its raw DER encoded format.\n+\n+     The ASN.1 DER encoding is:\n+\n+     signatureValue       BIT STRING\n+\n+     Consult rfc2459 for more information.\n+\n+     @return byte array representing signature\n+  */\n+  public abstract byte[] getSignature();\n+\n+  /**\n+     Returns the signature algorithm used to sign the CRL. \n+     An examples is \"SHA-1/DSA\".\n+\n+     The ASN.1 DER encoding is:\n+\n+     signatureAlgorithm   AlgorithmIdentifier,\n+\n+     AlgorithmIdentifier  ::=  SEQUENCE  {\n+     algorithm               OBJECT IDENTIFIER,\n+     parameters              ANY DEFINED BY algorithm OPTIONAL  }\n+\n+     Consult rfc2459 for more information.\n+\n+     The algorithm name is determined from the OID.\n+\n+     @return a string with the signature algorithm name\n+  */\n+  public abstract String getSigAlgName();\n+\n+\n+  /**\n+     Returns the OID for the signature algorithm used.\n+     Example \"1.2.840.10040.4.3\" is return for SHA-1 with DSA.\\\n+\n+     The ASN.1 DER encoding for the example is:\n+\n+     id-dsa-with-sha1 ID  ::=  {\n+     iso(1) member-body(2) us(840) x9-57 (10040)\n+     x9cm(4) 3 }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return a string containing the OID.\n+  */\n+  public abstract String getSigAlgOID();\n+\n+\n+  /**\n+     Returns the AlgorithmParameters in the encoded form\n+     for the signature algorithm used. \n+\n+     If access to the parameters is need, create an \n+     instance of AlgorithmParameters.\n+\n+     @return byte array containing algorithm parameters, null\n+     if no parameters are present in certificate\n+  */\n+  public abstract byte[] getSigAlgParams();\n+\n+\n+  /**\n+     Returns the issuer unique ID for this certificate.\n+\n+     The ASN.1 DER encoding is:\n+\n+     issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n+     -- If present, version shall be v2 or v3\n+\n+     UniqueIdentifier  ::=  BIT STRING\n+\t\n+     Consult rfc2459 for more information.\n+\n+     @return bit representation of <I>issuerUniqueID</I>\n+  */\n+  public abstract boolean[] getIssuerUniqueID();\n+\n+  /**\n+     Returns the subject unique ID for this certificate.\n+\n+     The ASN.1 DER encoding is:\n+\n+     subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,\n+     -- If present, version shall be v2 or v3\n+\n+     UniqueIdentifier  ::=  BIT STRING\n+\t\n+     Consult rfc2459 for more information.\n+\n+     @return bit representation of <I>subjectUniqueID</I>\n+  */\n+  public abstract boolean[] getSubjectUniqueID();\n+\n+  /**\n+     Returns a boolean array representing the <I>KeyUsage</I> \n+     extension for the certificate. The KeyUsage (OID = 2.5.29.15)\n+     defines the purpose of the key in the certificate.\n+\n+     The ASN.1 DER encoding is:\n+\n+     id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }\n+\n+     KeyUsage ::= BIT STRING {\n+     digitalSignature        (0),\n+     nonRepudiation          (1),\n+     keyEncipherment         (2),\n+     dataEncipherment        (3),\n+     keyAgreement            (4),\n+     keyCertSign             (5),\n+     cRLSign                 (6),\n+     encipherOnly            (7),\n+     decipherOnly            (8) }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return bit representation of <I>KeyUsage</I>\n+  */\n+  public abstract boolean[] getKeyUsage();\n+\n+  /**\n+     Returns the certificate constraints path length from the\n+     critical BasicConstraints extension, (OID = 2.5.29.19).\t\n+\n+     The basic constraints extensions is used to determine if \n+     the subject of the certificate is a Certificate Authority (CA) \n+     and how deep the certification path may exist. The \n+     <I>pathLenConstraint</I> only takes affect if <I>cA</I>\n+     is set to true. \"A value of zero indicates that only an \n+     end-entity certificate may follow in the path.\" (rfc2459)\n+\t\n+     The ASN.1 DER encoding is:\n+\n+     id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }\n+\n+     BasicConstraints ::= SEQUENCE {\n+     cA                      BOOLEAN DEFAULT FALSE,\n+     pathLenConstraint       INTEGER (0..MAX) OPTIONAL }\n+\n+     Consult rfc2459 for more information.\n+\n+     @return the length of the path constraint if BasicConstraints\n+     is present and cA is TRUE. Otherwise returns -1.\n+  */\n+  public abstract int getBasicConstraints();\n+\n+\n+}"}, {"sha": "bba72c010aa1dfc49a8df7c6c659cfee8500d805", "filename": "libjava/java/security/cert/X509Extension.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Extension.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Extension.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2Fcert%2FX509Extension.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,102 @@\n+/* X509Extension.java --- X.509 Extension\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.security.cert;\n+import java.util.Set;\n+\n+/**\n+\tPublic abstract interface for the X.509 Extension.\n+\n+\tThis is used for X.509 v3 Certificates and CRL v2 (Certificate\n+\tRevocation Lists) for managing attributes assoicated with\n+\tCertificates, for managing the hierarchy of certificates,\n+\tand for managing the distribution of CRL. This extension\n+\tformat is used to define private extensions.\n+\n+\tEach extensions for a certificate or CRL must be marked\n+\teither critical or non-critical. If the certificate/CRL \n+\tsystem encounters a critical extension not recognized then \n+\tit must reject the certificate. A non-critical extension\n+\tmay be just ignored if not recognized.\n+\n+\n+\tThe ASN.1 definition for this class is: \n+\n+\t Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n+\n+\t Extension  ::=  SEQUENCE  {\n+\t     extnId        OBJECT IDENTIFIER,\n+\t     critical      BOOLEAN DEFAULT FALSE,\n+\t     extnValue     OCTET STRING\n+\t                   -- contains a DER encoding of a value\n+\t                   -- of the type registered for use with\n+\t                   -- the extnId object identifier value\n+\t }\n+ \t\n+\t@author Mark Benvenuto\n+\n+\t@since JDK 1.2\n+*/\n+public abstract interface X509Extension\n+{\n+\n+  /**\n+     Returns true if the certificate contains a critical extension\n+     that is not supported.\n+\n+     @return true if has unsupported extension, false otherwise\t\n+  */\n+  public boolean hasUnsupportedCriticalExtension();\n+\n+  /**\n+     Returns a set of the CRITICAL extension OIDs from the \n+     certificate/CRL that the object implementing this interface\n+     manages.\n+\n+     @return A Set containing the OIDs. If there are no CRITICAL\n+     extensions or extensions at all this returns null.\n+  */\n+  public Set getCriticalExtensionOIDs();\n+\n+  /**\n+     Returns a set of the NON-CRITICAL extension OIDs from the \n+     certificate/CRL that the object implementing this interface\n+     manages.\n+\n+     @return A Set containing the OIDs. If there are no NON-CRITICAL\n+     extensions or extensions at all this returns null.\n+  */\n+  public Set getNonCriticalExtensionOIDs();\n+\n+  /**\n+     Returns the DER encoded OCTET string for the specified\n+     extension value identified by a OID. The OID is a string\n+     of number seperated by periods. Ex: 12.23.45.67\n+  */\n+  public byte[] getExtensionValue(String oid);\n+\n+}"}, {"sha": "b2dd30b7ffa54a1b062e211ca0c7c9d6c3049247", "filename": "libjava/java/util/AbstractSet.java", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FAbstractSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FAbstractSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FAbstractSet.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,83 @@\n+/* AbstractSet.java -- Abstract implementation of most of Set\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+/**\n+ * An abstract implementation of Set to make it easier to create your own\n+ * implementations. In order to create a Set, subclass AbstractSet and\n+ * implement the same methods that are required for AbstractCollection\n+ * (although these methods must of course meet the requirements that Set puts\n+ * on them - specifically, no element may be in the set more than once). This\n+ * class simply provides implementations of equals() and hashCode() to fulfil\n+ * the requirements placed on them by the Set interface.\n+ */\n+public abstract class AbstractSet extends AbstractCollection implements Set {\n+\n+  /**\n+   * Tests whether the given object is equal to this Set. This implementation\n+   * first checks whether this set <em>is</em> the given object, and returns\n+   * true if so. Otherwise, if o is a Set and is the same size as this one, it\n+   * returns the result of calling containsAll on the given Set. Otherwise, it\n+   * returns false.\n+   *\n+   * @param o the Object to be tested for equality with this Set\n+   * @return true if the given object is equal to this Set\n+   */\n+  public boolean equals(Object o) {\n+    if (o == this) {\n+      return true;\n+    } else if (o instanceof Set && ((Set)o).size() == size()) {\n+      throw new Error (\"FIXME: compiler error - AbstractSet.equals\");\n+      /*  FIXME: this is the correct implementation, but a compiler\n+\t  error prevents us from building it.\n+\t  return containsAll((Collection)o);  */\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Returns a hash code for this Set. The hash code of a Set is the sum of the\n+   * hash codes of all its elements, except that the hash code of null is\n+   * defined to be zero. This implementation obtains an Iterator over the Set,\n+   * and sums the results.\n+   *\n+   * @return a hash code for this Set\n+   */\n+  public int hashCode() {\n+    int hash = 0;\n+    Iterator i = iterator();\n+    while (i.hasNext()) {\n+      try {\n+        hash += i.next().hashCode();\n+      } catch (NullPointerException e) {\n+      }\n+    }\n+    return hash;\n+  }\n+}"}, {"sha": "2d6d0e51904e5c49510c3081238c92b0cdc76850", "filename": "libjava/java/util/BasicMapEntry.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBasicMapEntry.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,135 @@\n+/* BasicMapEntry.java -- a class providing a plain-vanilla implementation of\n+   the Map.Entry interface; could be used anywhere in java.util\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+/**\n+ * a class which implements Map.Entry\n+ *\n+ * @author      Jon Zeppieri\n+ * @version     $Revision: 1.3 $\n+ * @modified    $Id: BasicMapEntry.java,v 1.3 2000/03/15 21:59:07 rao Exp $\n+ */\n+class BasicMapEntry implements Map.Entry\n+{\n+    /** the key */\n+    Object key;\n+    /** the value */\n+    Object value;\n+    \n+    /**\n+     * construct a new BasicMapEntry with the given key and value\n+     *\n+     * @param     newKey       the key of this Entry\n+     * @param     newValue     the value of this Entry\n+     */\n+    BasicMapEntry(Object newKey, Object newValue)\n+    {\n+\tkey = newKey;\n+\tvalue = newValue;\n+    }\n+    \n+    /**\n+     * returns true if <pre>o</pre> is a Map.Entry and \n+     * <pre> \n+     * (((o.getKey == null) ? (key == null) : \n+     * o.getKey().equals(key)) && \n+     * ((o.getValue() == null) ? (value == null) : \n+     * o.getValue().equals(value)))\n+     * </pre>\n+     *\n+     * NOTE: the calls to getKey() and getValue() in this implementation\n+     * are <i>NOT</i> superfluous and should not be removed.  They insure \n+     * that subclasses such as HashMapEntry work correctly\n+     *\n+     * @param      o        the Object being tested for equality\n+     */\n+    public boolean equals(Object o)\n+    {\n+\tMap.Entry tester;\n+\tObject oTestingKey, oTestingValue;\n+\tObject oKey, oValue;\n+\tif (o instanceof Map.Entry)\n+\t    {\n+\t\ttester = (Map.Entry) o;\n+\t\toKey = getKey();\n+\t\toValue = getValue();\n+\t\toTestingKey = tester.getKey();\n+\t\toTestingValue = tester.getValue();\n+\t\treturn (((oTestingKey == null) ? (oKey == null) : \n+\t\t\t oTestingKey.equals(oKey)) && \n+\t\t\t((oTestingValue == null) ? (oValue == null) : \n+\t\t\t oTestingValue.equals(oValue)));\n+\t    }\n+\t    return false;\n+    }\n+\n+    /** returns the key */\n+    public Object getKey()\n+\t{\n+\t    return key;\n+\t}\n+    \n+    /** returns the value */\n+    public Object getValue()\n+    {\n+\treturn value;\n+    }\n+    \n+    /** the hashCode() for a Map.Entry is \n+     * <pre> \n+     * ((getKey() == null) ? 0 : getKey().hashCode()) ^ \n+     * ((getValue() == null) ? 0 : getValue().hashCode());\n+     * </pre>\n+     *\n+     * NOTE: the calls to getKey() and getValue() in this implementation\n+     * are <i>NOT</i> superfluous and should not be removed.  They insure \n+     * that subclasses such as HashMapEntry work correctly\n+     */\n+    public int hashCode()\n+    {\n+\tObject oKey = getKey();\n+\tObject oValue = getValue();\n+\treturn ((oKey == null) ? 0 : oKey.hashCode()) ^ \n+\t    ((oValue == null) ? 0 : oValue.hashCode());\n+    }\n+    \n+    /** \n+     * sets the value of this Map.Entry \n+     *\n+     * @param     newValue         the new value of this Map.Entry\n+     */\n+    public Object setValue(Object newValue)\n+\tthrows java.lang.UnsupportedOperationException, ClassCastException, \n+\t       IllegalArgumentException, NullPointerException\n+    {\n+\tObject oVal = value;\n+\tvalue = newValue;\n+\treturn oVal;\n+    }\n+}"}, {"sha": "8c0edf4a676437a823f45afcb02e6cbbec5153ac", "filename": "libjava/java/util/Bucket.java", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FBucket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FBucket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBucket.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,199 @@\n+/* Bucket.java -- a class providing a hash-bucket data structure \n+   (a lightweight linked list)\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+/**\n+ * a class representing a simple, lightweight linked-list, using Node\n+ * objects as its linked nodes; this is used by Hashtable and HashMap\n+ *\n+ * @author        Jon Zeppieri\n+ * @version       $Revision: 1.3 $\n+ * @modified      $Id: Bucket.java,v 1.3 2000/03/15 21:59:08 rao Exp $\n+ */\n+class Bucket\n+{\n+    /** the first node of the lined list, originally null */\n+    Node first;\n+    \n+    /** trivial constructor for a Bucket */\n+    Bucket()\n+    {\n+    }\n+    \n+    /** add this key / value pair to the list\n+     *\n+     * @param    newNode    a Node object to be added to this list\n+     * @return the old value mapped to the key if there was one, \n+     *  otherwise null.\n+     */\n+    Object add(Node newNode)\n+    {\n+\tObject oKey;\n+\tObject oTestKey = newNode.getKey();\n+\tNode it = first;\n+\tNode prev = null;\n+\tif (it == null) // if the list is empty (the ideal case), we make a new single-node list\n+\t    {\n+\t\tfirst = newNode;\n+\t\treturn null;\n+\t    }\n+\telse // otherwise try to find where this key already exists in the list,\n+\t    {// and if it does, replace the value with the new one (and return the old one)\n+\t\twhile (it != null)  \n+\t\t    {\n+\t\t\toKey = it.getKey();\n+\t\t\tif ((oKey == null) ? (oTestKey == null) :\n+\t\t\t    oKey.equals(oTestKey))\n+\t\t\t    {\n+\t\t\t        Object oldValue = it.value;\n+\t\t\t\tit.value = newNode.getValue();\n+\t\t\t\treturn oldValue;\n+\t\t\t    }\n+\t\t\tprev = it;  \n+\t\t\tit = it.next;\n+\t\t    }\n+\t\tprev.next = newNode; // otherwise, just stick this at the \n+\t\treturn null;                   // end of the list\n+\t    }\n+    }\n+    \n+    /**\n+     * remove a Map.Entry in this list with the supplied key and return its value,\n+     * if it exists, else return null\n+     *\n+     * @param     key       the key we are looking for in this list\n+     */\n+    Object removeByKey(Object key)\n+    {\n+\tObject oEntryKey;\n+\tNode prev = null;\n+\tNode it = first;\n+\twhile (it != null)\n+\t    {\n+\t\toEntryKey = it.getKey();\n+\t\tif ((oEntryKey == null) ? (key == null) : oEntryKey.equals(key))\n+\t\t    {\n+\t\t\tif (prev == null) // we are removing the first element\n+\t\t\t    first = it.next;\n+\t\t\telse\n+\t\t\t    prev.next = it.next;\n+\t\t\treturn it.getValue();\n+\t\t    }\n+\t\telse\n+\t\t    {\n+\t\t\tprev = it;\n+\t\t\tit = it.next;\n+\t\t    }\n+\t    }\n+\treturn null;\n+    }\n+    \n+    /**\n+     * return the value which the supplied key maps to, if it maps to anything in this list,\n+     * otherwise, return null\n+     *\n+     * @param      key       the key mapping to a value that we are looking for\n+     */\n+    Object getValueByKey(Object key)\n+    {\n+\tNode entry = getEntryByKey(key);\n+\treturn (entry == null) ? null : entry.getValue();\n+    }\n+\n+    /**\n+     * return the Map.Entry which the supplied key is a part of, if such a Map.Entry exists,\n+     * null otherwise\n+     *\n+     * this method is important for HashMap, which can hold null values and the null key\n+     *\n+     * @param      key         the key for which we are finding the corresponding Map.Entry\n+     */\n+    Node getEntryByKey(Object key)\n+    {\n+\tObject oEntryKey;\n+\tNode it = first;\n+\twhile (it != null)\n+\t    {\n+\t\toEntryKey = it.getKey();\n+\t\tif ((oEntryKey == null) ? (key == null) : oEntryKey.equals(key))\n+\t\t    return it;\n+\t\tit = it.next;\n+\t    }\n+\treturn null;\n+    }\n+    \n+    /**\n+     * return true if this list has a Map.Entry whose value equals() the supplied value\n+     *\n+     * @param      value         the value we are looking to match in this list\n+     */\n+    boolean containsValue(Object value)\n+    {\n+\tObject oEntryValue;\n+\tNode it = first;\n+\twhile (it != null)\n+\t    {\n+\t\toEntryValue = it.getValue();\n+\t\tif ((oEntryValue == null) ? (value == null) : oEntryValue.equals(value))\n+\t\t    return true;\n+\t\tit = it.next;\n+\t    }\n+\treturn false;\n+    }\n+\n+    // INNSER CLASSES ----------------------------------------------------------\n+    \n+    /**\n+     * a class represnting a node in our lightweight linked-list\n+     * that we use for hash buckets;  a Node object contains a Map.Entry as its\n+     * <pre>value</pre> property and a reference (possibly, even hopefully, null) \n+     * to another Node as its <pre>next</pre> property.\n+     *\n+     * There <i>is</i> a reason for not using a highly generic \"LinkedNode\" type\n+     * class:  we want to eliminate runtime typechecks.\n+     *\n+     * @author       Jon Zeppieri\n+     * @version      $Revision: 1.3 $\n+     * @modified     $Id: Bucket.java,v 1.3 2000/03/15 21:59:08 rao Exp $\n+     */\n+    static class Node extends BasicMapEntry implements Map.Entry\n+    {\n+\t/** a reference to the next node in the linked list */\n+\tNode next;\n+\t\n+\t/** non-trivial contructor -- sets the <pre>value</pre> of the Bucket upon instantiation */\n+\tNode(Object key, Object value)\n+\t{\n+\t    super(key, value);\n+\t}\n+\n+\t\n+    }\n+    // EOF ------------------------------------------------------------------------\n+}"}, {"sha": "2767b5b821b08d86eab3fd2ab61f85339d0d0c94", "filename": "libjava/java/util/Hashtable.java", "status": "modified", "additions": 997, "deletions": 313, "changes": 1310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -1,392 +1,1076 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Hashtable.java -- a class providing a basic hashtable data structure,\n+   mapping Object --> Object\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n \n+import java.io.IOException;\n import java.io.Serializable;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamField;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 24, 1998.\n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct\n+ * a class which implements a Hashtable data structure\n+ *\n+ * This implementation of Hashtable uses a hash-bucket approach. That is:\n+ * linear probing and rehashing is avoided; instead, each hashed value maps\n+ * to a simple linked-list which, in the best case, only has one node.\n+ * Assuming a large enough table, low enough load factor, and / or well\n+ * implemented hashCode() methods, Hashtable should provide O(1) \n+ * insertion, deletion, and searching of keys.  Hashtable is O(n) in\n+ * the worst case for all of these (if all keys has to the same bucket).\n+ *\n+ * This is a JDK-1.2 compliant implementation of Hashtable.  As such, it \n+ * belongs, partially, to the Collections framework (in that it implements\n+ * Map).  For backwards compatibility, it inherits from the obsolete and \n+ * utterly useless Dictionary class.\n+ *\n+ * Being a hybrid of old and new, Hashtable has methods which provide redundant\n+ * capability, but with subtle and even crucial differences.\n+ * For example, one can iterate over various aspects of a Hashtable with\n+ * either an Iterator (which is the JDK-1.2 way of doing things) or with an\n+ * Enumeration.  The latter can end up in an undefined state if the Hashtable\n+ * changes while the Enumeration is open.\n+ *\n+ * @author      Jon Zeppieri\n+ * @version     $Revision: 1.7 $\n+ * @modified    $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n  */\n-\n-final class HashtableEntry\n+public class Hashtable extends Dictionary \n+  implements Map, Cloneable, Serializable\n {\n-  public Object key;\n-  public Object value;\n-  public HashtableEntry nextEntry = null;\n-\n-  public HashtableEntry(Object key, Object value)\n-  {\n-    this.key = key;\n-    this.value = value;\n-  }\n-}\n-\n-final class HashtableEnumeration implements Enumeration\n-{\n-  // TBD: Enumeration is not safe if new elements are put in the table as\n-  // this could cause a rehash and we'd completely lose our place.  Even\n-  // without a rehash, it is undetermined if a new element added would\n-  // appear in the enumeration.  The spec says nothing about this, but\n-  // the \"Java Class Libraries\" book infers that modifications to the\n-  // hashtable during enumeration causes indeterminate results.  Don't do it!\n-  // A safer way would be to make a copy of the table (e.g. into a vector)\n-  // but this is a fair bit  more expensive.\n-  private HashtableEntry[] bucket;\n-  private int bucketIndex;\n-  private HashtableEntry elem;\n-  private int enumCount;\n+  // STATIC VARIABLES\n+  // ----------------\n+  \n+  /**\n+   * the default capacity of a Hashtable\n+   *\n+   * This value strikes me as absurdly low, an invitation to all manner of\n+   * hash collisions.  Perhaps it should be raised.  I set it to 11 since the\n+   * JDK-1.2b4 specification uses that value in the third constructor \n+   * Hashtable(Map t) if the given Map is small. */\n+  private static final int DEFAULT_CAPACITY = 11;\n+  \n+  /** the defaulty load factor; this is explicitly specified by Sun */\n+  private static final float DEFAULT_LOAD_FACTOR = 0.75F;\n+  \n+  // used internally for parameterizing inner classes\n+  private static final int KEYS = 0;\n+  private static final int VALUES = 1;\n+  private static final int ENTRIES = 2; \n+  \n+  // used for serializing instances of this class\n+  private static final ObjectStreamField[] serialPersistentFields =\n+  { new ObjectStreamField(\"loadFactor\", float.class),\n+    new ObjectStreamField(\"threshold\", int.class) };\n+  private static final long serialVersionUID = 1421746759512286392L;\n+  \n+  // INSTANCE VARIABLES\n+  // ------------------\n+  \n+  /** the capacity of this Hashtable:  denotes the size of the bucket array */\n+  private int capacity;\n+  \n+  /** the size of this Hashtable:  denotes the number of elements currently in\n+   * <pre>this</pre> */\n   private int size;\n-  private boolean values;\n-\n-  public HashtableEnumeration(HashtableEntry[] bkt, int sz, boolean isValues)\n+  \n+  /** the load factor of this Hashtable:  used in computing the threshold */\n+  private float loadFactor;\n+  \n+  /* the rounded product of the capacity and the load factor; when the\n+   * number of elements exceeds the threshold, the Hashtable calls\n+   * <pre>rehash()</pre> */\n+  private int threshold;\n+  \n+  /** where the data is actually stored; Bucket implements\n+   * a very simple, lightweight (and hopefully fast) linked-list */\n+  Bucket[] buckets;\n+  \n+  /** counts the number of modifications this Hashtable has undergone;\n+   * used by Iterators to know when to throw\n+   * ConcurrentModificationExceptions (idea ripped-off from Stuart\n+   * Ballard's AbstractList implementation) */\n+  int modCount;\n+  \n+    /**\n+     * construct a new Hashtable with the default capacity and the\n+     * default load factor */\n+  public Hashtable()\n   {\n-    bucket = bkt;\n-    bucketIndex = -1;\n-    enumCount = 0;\n-    elem = null;\n-    size = sz;\n-    values = isValues;\n+    init (DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n   }\n-\n-  public boolean hasMoreElements()\n+  \n+  /**\n+   * construct a new Hashtable with a specific inital capacity and load factor\n+   *\n+   * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n+   * @param   initialLoadFactor   the load factor of this Hashtable \n+   *                              (a misnomer, really, since the load factor of\n+   *                              a Hashtable does not change)\n+   * \n+   * @throws   IllegalArgumentException    if (initialCapacity < 0) ||\n+   *                                          (initialLoadFactor > 1.0) ||\n+   *                                          (initialLoadFactor <= 0.0)\n+   */\n+  public Hashtable(int initialCapacity, float initialLoadFactor)\n+    throws IllegalArgumentException\n   {\n-    return enumCount < size;\n+    if (initialCapacity < 0 || initialLoadFactor <= 0 || initialLoadFactor > 1)\n+      throw new IllegalArgumentException();\n+    else\n+      init(initialCapacity, initialLoadFactor);\n   }\n-\n-  public Object nextElement()\n+  \n+  /**\n+   * construct a new Hashtable with a specific inital capacity \n+   *\n+   * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n+   *\n+   * @throws   IllegalArgumentException    if (initialCapacity < 0)\n+   */\n+  public Hashtable(int initialCapacity)\t\n+    throws IllegalArgumentException \n   {\n-    if (!hasMoreElements())\n-      throw new NoSuchElementException();\n-\n-    // Find next element\n-    if (elem != null)\t\t// In the middle of a bucket\n-      elem = elem.nextEntry;\n-    while (elem == null)\t// Find the next non-empty bucket\n-      elem = bucket[++bucketIndex];\n-\n-    enumCount++;\n-    return values ? elem.value : elem.key;\n+    if (initialCapacity < 0)\n+      throw new IllegalArgumentException();\n+    else\n+      init(initialCapacity, DEFAULT_LOAD_FACTOR);\n   }\n-}\n-\n-// TBD: The algorithm used here closely reflects what is described in\n-// the \"Java Class Libraries\" book.  The \"Java Language Spec\" is much\n-// less specific about the implementation.  Because of this freedom\n-// provided by the actual spec, hash table algorithms should be\n-// investigated to see if there is a better alternative to this one.\n-\n-// TODO12:\n-// public class Hashtable extends Dictionary\n-//\t\t\timplements Map, Cloneable, Serializable\n-\n-public class Hashtable extends Dictionary implements Cloneable, Serializable\n-{\n-  private HashtableEntry bucket[];\n-  private float loadFactor;\n-  private int hsize = 0;\n-\n-  public Hashtable()\n+  \n+  /**\n+   * construct a new Hashtable from the given Map\n+   * \n+   * every element in Map t will be put into this new Hashtable\n+   *\n+   * @param     t        a Map whose key / value pairs will be put into\n+   *                     the new Hashtable.  <b>NOTE: key / value pairs\n+   *                     are not cloned in this constructor</b>\n+   */\n+  public Hashtable(Map t)\n   {\n-    // The \"Java Class Libraries\" book (p. 919) says that initial size in this\n-    // case is 101 (a prime number to increase the odds of even distribution).\n-    this(101, 0.75F);\n+    int mapSize = t.size() * 2;\n+    init (((mapSize > DEFAULT_CAPACITY) ? mapSize : DEFAULT_CAPACITY), \n+\t  DEFAULT_LOAD_FACTOR);\n+    putAll (t);\n   }\n-\n-  public Hashtable(int initialSize)\n+  \n+  \n+  /** returns the number of key / value pairs stored in this Hashtable */\n+  public synchronized int size()\n   {\n-    this(initialSize, 0.75F);\n+    return size;\n   }\n-\n-  public Hashtable(int initialSize, float loadFactor)\n+  \n+  /** returns true if this Hashtable is empty (size() == 0), false otherwise */\n+  public synchronized boolean isEmpty()\n   {\n-    if (initialSize < 0 || loadFactor <= 0.0 || loadFactor > 1.0)\n-      throw new IllegalArgumentException();\n-\n-    bucket = new HashtableEntry[initialSize];\n-    this.loadFactor = loadFactor;\n+    return size == 0;\n   }\n-\n-  // TODO12:\n-  // public Hashtable(Map t)\n-  // {\n-  // }\n-\n-  public synchronized void clear()\n+  \n+  /** returns an Enumeration of the keys in this Hashtable\n+   *\n+   * <b>WARNING: if a Hashtable is changed while an Enumeration is\n+   * iterating over it, the behavior of the Enumeration is undefined.\n+   * Use keySet().iterator() if you want to be safe.</b> */\n+  public synchronized Enumeration keys()\n   {\n-    // Aid the GC by nulling out the entries in the hash table.\n-    for (int i = 0; i < bucket.length; i++)\n-      {\n-        HashtableEntry elem = bucket[i];\n-\tbucket[i] = null;\t\t\t// May already be null.\n-\twhile (elem != null)\n-\t  {\n-\t    HashtableEntry next = elem.nextEntry;\n-\t    elem.nextEntry = null;\t\t// May already be null.\n-\t    elem = next;\n-\t  }\n-      }\n-    hsize = 0;\n+    return new HashtableEnumeration(KEYS);\n   }\n-\n-  public synchronized Object clone()\n+  \n+  /**\n+   * returns an Enumeration of the values in this Hashtable\n+   *\n+   * <b>WARNING: if a Hashtable is changed while an Enumeration is\n+   * iterating over it, the behavior of the Enumeration is undefined.\n+   * Use values().ieterator() if you want to be safe.</b> */\n+  public synchronized Enumeration elements()\n   {\n-    // New hashtable will have same initialCapacity and loadFactor.\n-    Hashtable newTable = new Hashtable(bucket.length, loadFactor);\n-\n-    HashtableEntry newElem, prev = null;\n-    for (int i = 0; i < bucket.length; i++)\n-      for (HashtableEntry elem = bucket[i]; elem != null; elem = elem.nextEntry)\n-\t{\n-\t  // An easy but expensive method is newTable.put(elem.key, elem.value);\n-\t  // Since the hash tables are the same size, the buckets and collisions\n-\t  // will be the same in the new one, so we can just clone directly.\n-\t  // This is much cheaper than using put.\n-\t  newElem = new HashtableEntry(elem.key, elem.value);\n-\t  if (newTable.bucket[i] == null)\n-\t    prev = newTable.bucket[i] = newElem;\n-\t  else\n-\t    prev = prev.nextEntry = newElem;\n-\t}\n-\n-    newTable.hsize = this.hsize;\n-    return newTable;\n+    return new HashtableEnumeration(VALUES);\n   }\n-\n-  public synchronized boolean contains(Object value)\n-    throws NullPointerException\n+  \n+  /**\n+   * returns true if this Hashtable contains a value <pre>o</pre>,\n+   * such that <pre>o.equals(value)</pre>.\n+   *\n+   * Note: this is one of the <i>old</i> Hashtable methods which does\n+   * not like null values; it throws NullPointerException if the\n+   * supplied parameter is null.\n+   *\n+   * @param     value        the value to search for in this Hashtable\n+   *\n+   * @throws NullPointerException if <pre>value</pre> is null */\n+  public boolean contains(Object value) throws NullPointerException\n   {\n-    // An exception is thrown here according to the JDK 1.2 doc.\n     if (value == null)\n       throw new NullPointerException();\n-\n-    for (int i = 0; i < bucket.length; i++)\n-      for (HashtableEntry elem = bucket[i]; elem != null; elem = elem.nextEntry)\n-\tif (elem.value.equals(value))\n+    else\n+      return containsValue(value);\n+  }\n+  \n+  /**\n+   * behaves identically to <pre>contains()</pre>, except it does not\n+   * throw a NullPointerException when given a null argument (Note:\n+   * Sun's implementation (JDK1.2beta4) <i>does</i> throw a\n+   * NullPointerException when given a null argument, but this seems\n+   * to go against the Collections Framework specifications, so I have\n+   * not reproduced this behavior.  I have submitted a bug report to\n+   * Sun on the mater, but have not received any response yet (26\n+   * September 1998)\n+   *\n+   * @param value the value to search for in this Hashtable */\n+  public synchronized boolean containsValue(Object value)\n+  {\n+    int i;\n+    Bucket list;\n+    \n+    for (i = 0; i < capacity; i++)\n+      {\n+\tlist = buckets[i];\n+\tif (list != null && list.containsValue(value))\n \t  return true;\n-\n+      }\n     return false;\n   }\n-\n+  \n+  /**\n+   * returns true if the supplied key is found in this Hashtable\n+   * (strictly, if there exists a key <pre>k</pre> in the Hashtable,\n+   * such that <pre>k.equals(key)</pre>)\n+   *\n+   * @param key the key to search for in this Hashtable */\n   public synchronized boolean containsKey(Object key)\n   {\n-    for (HashtableEntry elem = bucket[Math.abs(key.hashCode()\n-\t\t\t\t\t       % bucket.length)];\n-\t elem != null; elem = elem.nextEntry)\n-      if (elem.key.equals(key))\n-\treturn true;\n-\n-    return false;\n+    return (internalGet(key) != null);\n   }\n-\n-  public synchronized Enumeration elements()\n+  \n+  /**\n+   * a private method used by inner class HashtableSet to implement\n+   * its own <pre>contains(Map.Entry)</pre> method; returns true if\n+   * the supplied key / value pair is found in this Hashtable (again,\n+   * using <pre>equals()</pre>, rather than <pre>==</pre>)\n+   *\n+   * @param      entry      a Map.Entry to match against key / value pairs in \n+   *                        this Hashtable */\n+  private synchronized boolean containsEntry(Map.Entry entry)\n   {\n-    return new HashtableEnumeration(bucket, hsize, true);\n+    Object o;\n+    if (entry == null)\n+      {\n+\treturn false;\n+      }\n+    else\n+      {\n+\to = internalGet(entry.getKey());\n+\treturn (o != null && o.equals(entry.getValue()));\n+      }\n   }\n-\n+  \n+  /*\n+   * return the value in this Hashtable associated with the supplied\n+   * key, or <pre>null</pre> if the key maps to nothing\n+   *\n+   * @param key the key for which to fetch an associated value */\n   public synchronized Object get(Object key)\n   {\n-    for (HashtableEntry elem = bucket[Math.abs (key.hashCode()\n-\t\t\t\t\t\t% bucket.length)];\n-\t elem != null; elem = elem.nextEntry)\n-      if (elem.key.equals(key))\n-\treturn elem.value;\n-\n-    return null;\n+    return internalGet(key);\n   }\n-\n-  public boolean isEmpty()\n+  \n+  /** \n+   * a private method which does the \"dirty work\" (or some of it\n+   * anyway) of fetching a value with a key\n+   *\n+   *  @param key the key for which to fetch an associated value */\n+  private Object internalGet(Object key)\n   {\n-    return this.hsize <= 0;\n+    Bucket list;\n+    if (key == null || size == 0)\n+      {\n+\treturn null;\n+      }\n+    else\n+      {\n+\tlist = buckets[hash(key)];\n+\treturn (list == null) ? null : list.getValueByKey(key);\n+      }\n   }\n-\n-  public synchronized Enumeration keys()\n+  \n+  /** \n+   * increases the size of the Hashtable and rehashes all keys to new\n+   * array indices; this is called when the addition of a new value\n+   * would cause size() > threshold */\n+  protected void rehash()\n   {\n-    return new HashtableEnumeration(bucket, hsize, false);\n+    int i;\n+    Bucket[] data = buckets;\n+    Bucket.Node node;\n+    \n+    modCount++;\n+    capacity = (capacity * 2) + 1;\n+    size = 0;\n+    threshold = (int) ((float) capacity * loadFactor);\n+    buckets = new Bucket[capacity];\n+    for (i = 0; i < data.length; i++)\n+      {\n+\tif (data[i] != null)\n+\t  {\n+\t    node = data[i].first;\n+\t    while (node != null)\n+\t      {\n+\t\tinternalPut(node.getKey(), node.getValue());\n+\t\tnode = node.next;\n+\t      }\n+\t  }\n+      }\n   }\n-\n-  public synchronized Object put(Object key, Object value)\n+  \n+  /**\n+   * puts the supplied value into the Hashtable, mapped by the\n+   * supplied key; neither the key nore the value is allowed to be\n+   * <pre>null</pre>, otherwise a <pre>NullPointerException</pre> will\n+   * be thrown\n+   *\n+   * @param       key        the Hashtable key used to locate the value\n+   * @param value the value to be stored in the Hashtable */\n+  public synchronized Object put(Object key, Object value) \n     throws NullPointerException\n   {\n-    // We could really just check `value == null', but checking both\n-    // is a bit clearer.\n     if (key == null || value == null)\n       throw new NullPointerException();\n-\n-    HashtableEntry prevElem = null;\n-    final int index = Math.abs(key.hashCode() % bucket.length);\n-\n-    for (HashtableEntry elem = bucket[index]; elem != null;\n-\t prevElem = elem, elem = elem.nextEntry)\n-      if (elem.key.equals(key))\n-\t{\n-\t  // Update with the new value and then return the old one.\n-\t  Object oldVal = elem.value;\n-\t  elem.value = value;\n-\t  return oldVal;\n-\t}\n-\n-    // At this point, we know we need to add a new element.\n-    HashtableEntry newElem = new HashtableEntry(key, value);\n-    if (bucket[index] == null)\n-      bucket[index] = newElem;\n     else\n-      prevElem.nextEntry = newElem;\n-\n-    if (++hsize > loadFactor * bucket.length)\n+      return internalPut(key, value);\n+  }\n+  \n+  /** \n+   * A private method with a semi-interesting history (it's at least\n+   * two hours old now); orginally, this functionality was in the\n+   * public <pre>put()</pre> method, but while searching (fruitlessly)\n+   * on the JDC for some clarification of Javasoft's bizarre\n+   * Serialization documentation, I instead came across a JDK bug\n+   * which had been fixed in JDK-1.2b3.  Extending Hashtable was a\n+   * pain, because <pre>put()</pre> was apparently being used\n+   * internally by the class when the Hashtable was rehashed, and this\n+   * was causing odd behavior for people who had overridden\n+   * <pre>put()</pre> in a Hashtable subclass.  Well, I was also\n+   * calling <pre>put()</pre> internally, and realized that my code\n+   * would have the same problem. [No, I have never looked at the\n+   * Javasoft code; it was just the easiest thing to do].  So I put\n+   * the real work in a private method, and I call <i>this</i> for\n+   * internal use.  Except...not all the time.  What about\n+   * <pre>putAll()</pre>?  Well, it seems reasonably clear from the\n+   * Collections spec that <pre>putAll()</pre> is <i>supposed</i> to\n+   * call <pre>put()</pre>.  So, it still does.  Confused yet?\n+   *\n+   * @param       key        the Hashtable key used to locate the value\n+   * @param value the value to be stored in the Hashtable */\n+  private Object internalPut(Object key, Object value)\n+  {\n+    HashtableEntry entry;\n+    Bucket list;\n+    int hashIndex;\n+    Object oResult;\n+    \n+    modCount++;\n+    if (size == threshold)\n       rehash();\n-\n-    return null;\n+    entry = new HashtableEntry(key, value);\n+    hashIndex = hash(key);\n+    list = buckets[hashIndex];\n+    if (list == null)\n+      {\n+\tlist = new Bucket();\n+\tbuckets[hashIndex] = list;\n+      }\n+    oResult = list.add(entry);\n+    if (oResult == null)\n+      {\n+\tsize++;\n+\treturn null;\n+      }\n+    else\n+      {\n+\treturn oResult;\n+      }\n   }\n-\n-  protected void rehash()\n+  \n+  /**\n+   * removes from the Hashtable and returns the value which is mapped\n+   * by the supplied key; if the key maps to nothing, then the\n+   * Hashtable remains unchanged, and <pre>null</pre> is returned\n+   *\n+   * @param key the key used to locate the value to remove from the Hashtable */\n+  public synchronized Object remove(Object key)\n   {\n-    // Create a new table which is twice the size (plus one) of the old.\n-    // One is added to make the new array length odd so it thus has at least\n-    // a (small) possibility of being a prime number.\n-    HashtableEntry oldBucket[] = bucket;\n-    bucket = new HashtableEntry[bucket.length * 2 + 1];\n-\n-    // Copy over each entry into the new table\n-    HashtableEntry elem;\n-    for (int i = 0; i < oldBucket.length; i++)\n-      for (elem = oldBucket[i]; elem != null; elem = elem.nextEntry)\n+    Bucket list;\n+    int index;\n+    Object result = null;\n+    if (key != null && size > 0)\n+      {\n+\tindex = hash(key);\n+\tlist = buckets[index];\n+\tif (list != null)\n+\t  {\n+\t    result = list.removeByKey(key);\n+\t    if (result != null)\n+\t      {\n+\t\tsize--;\n+\t\tmodCount++;\n+\t\tif (list.first == null)\n+\t\t  buckets[index] = null;\n+\t      }\n+\t  }\n+      }\n+    return result;\n+  }\n+  \n+  /**\n+   * part of the Map interface; for each Map.Entry in t, the key/value\n+   * pair is added to this Hashtable, <b>using the <pre>put()</pre>\n+   * method -- this may not be you want, so be warned (see notes to\n+   * <pre>internalPut()</pre>, above</b>\n+   *\n+   * @param t a Map whose key/value pairs will be added to this Hashtable */\n+  public synchronized void putAll(Map t) throws NullPointerException\n+  {\n+    Map.Entry entry;\n+    Iterator it = t.entrySet().iterator();\n+    while (it.hasNext())\n+      {\n+\tentry = (Map.Entry) it.next();\n+\tput(entry.getKey(), entry.getValue());\n+      }\n+  }\n+  \n+  \n+  /** empties this Hashtable of all elements */\n+  public synchronized void clear()\n+  {\n+    size = 0;\n+    modCount++;\n+    buckets = new Bucket[capacity];\n+  }\n+  \n+  /** \n+   * returns a shallow clone of this Hashtable (i.e. the Hashtable\n+   * itself is cloned, but its contents are not) */\n+  public synchronized Object clone()\n+  {\n+    Map.Entry entry;\n+    Iterator it = entrySet().iterator();\n+    Hashtable clone = new Hashtable(capacity, loadFactor);\n+    while (it.hasNext())\n+      {\n+\tentry = (Map.Entry) it.next();\n+\tclone.internalPut(entry.getKey(), entry.getValue());\n+      }\n+    return clone;\n+  }\n+  \n+  /**\n+   * returns a String representation of this Hashtable\n+   *\n+   * the String representation of a Hashtable is defined by Sun and\n+   * looks like this:\n+   * <pre>\n+   * {name_1=value_1, name_2=value_2, name_3=value_3, ..., name_N=value_N}\n+   * </pre>\n+   * for N elements in this Hashtable */\n+  public synchronized String toString()\n+  {\n+    Map.Entry entry;\n+    Iterator it = entrySet().iterator();\n+    StringBuffer sb = new StringBuffer(\"{\");\n+    boolean isFirst = true;\n+    while (it.hasNext())\n+      {\n+\tentry = (Map.Entry) it.next();\n+\tif (isFirst)\n+\t  isFirst = false;\n+\telse\n+\t  sb.append(\", \");\n+\tsb.append(entry.getKey().toString()).append(\"=\").append(entry.getValue().toString());\n+      }\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+  \n+  /** returns a Set of Keys in this Hashtable */\n+  public synchronized Set keySet()\n+  {\n+    return new HashtableSet(KEYS);\n+  }\n+  \n+  /** \n+   * returns a Set of Map.Entry objects in this Hashtable;\n+   * note, this was called <pre>entries()</pre> prior to JDK-1.2b4 */\n+  public synchronized Set entrySet()\n+  {\n+    return new HashtableSet(ENTRIES);\n+  }\n+  \n+  // This is the pre JDK1.2b4 named method for the above\n+  //     public Set entries()\n+  //     {\n+  // \treturn entrySet();\n+  //     }\n+  \n+  /** returns a Collection of values in this Hashtable */\n+  public synchronized Collection values()\n+  {\n+    return new HashtableCollection();\n+  }\n+  \n+  /** returns true if this Hashtable equals the supplied Object <pre>o</pre>;\n+   * that is:\n+   * <pre>\n+   * if (o instanceof Map)\n+   * and\n+   * o.keySet().equals(keySet())\n+   * and\n+   * for each key in o.keySet(), o.get(key).equals(get(key))\n+   *</pre>\n+   */\n+  public synchronized boolean equals(Object o)\n+  {\n+    Map other;\n+    Set keys = keySet();\n+    Object currentKey;\n+    Iterator it;\n+    if (o instanceof Map)\n+      {\n+\tother = (Map) o;\n+\tif (other.keySet().equals(keys))\n+\t  {\n+\t    it = keys.iterator();\n+\t    while (it.hasNext())\n+\t      {\n+\t\tcurrentKey = it.next();\n+\t\tif (!get(currentKey).equals(other.get(currentKey)))\n+\t\t  return false;\n+\t      }\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+  \n+  /** a Map's hashCode is the sum of the hashCodes of all of its\n+      Map.Entry objects */\n+  public synchronized int hashCode()\n+  {\n+    Iterator it = entrySet().iterator();\n+    int result = 0;\n+    while (it.hasNext())\n+      result += it.next().hashCode();\n+    return result;\n+  }\n+  \n+  /** \n+   * a private method, called by all of the constructors to initialize a new Hashtable\n+   *\n+   * @param   initialCapacity     the initial capacity of this Hashtable (>=0)\n+   * @param   initialLoadFactor   the load factor of this Hashtable \n+   *                              (a misnomer, really, since the load factor of\n+   *                              a Hashtable does not change)\n+   */ \n+  private void init(int initialCapacity, float initialLoadFactor)\n+  {\n+    size = 0;\n+    modCount = 0;\n+    capacity = initialCapacity;\n+    loadFactor = initialLoadFactor;\n+    threshold = (int) ((float) capacity * loadFactor);\n+    buckets = new Bucket[capacity];\n+  }\n+  \n+  /** private -- simply hashes a non-null Object to its array index */\n+  private int hash(Object key)\n+  {\n+    return Math.abs(key.hashCode() % capacity);\n+  }\n+  \n+  /** Serialize this Object in a manner which is binary-compatible\n+      with the JDK */\n+  private void writeObject(ObjectOutputStream s) throws IOException\n+  {\n+    ObjectOutputStream.PutField oFields;\n+    Iterator it = entrySet().iterator();\n+    Map.Entry oEntry;\n+    oFields = s.putFields();\n+    oFields.put(\"loadFactor\", loadFactor);\n+    oFields.put(\"threshold\", threshold);\n+    s.writeFields();\n+    \n+    s.writeInt(capacity);\n+    s.writeInt(size);\n+    while (it.hasNext())\n+      {\n+\toEntry = (Map.Entry) it.next();\n+\ts.writeObject(oEntry.getKey());\n+\ts.writeObject(oEntry.getValue());\n+      }\n+  }\n+  \n+  /** Deserialize this Object in a manner which is binary-compatible\n+      with the JDK */\n+  private void readObject(ObjectInputStream s) \n+    throws IOException, ClassNotFoundException\n+  {\n+    int i;\n+    int iLen;\n+    Object oKey, oValue;\n+    ObjectInputStream.GetField oFields;\n+    oFields = s.readFields();\n+    loadFactor = oFields.get(\"loadFactor\", DEFAULT_LOAD_FACTOR);\n+    threshold = oFields.get(\"threshold\", \n+\t\t\t    (int) (DEFAULT_LOAD_FACTOR \n+\t\t\t\t   * (float) DEFAULT_CAPACITY));\n+    \n+    capacity = s.readInt();\n+    iLen = s.readInt();\n+    size = 0;\n+    modCount = 0;\n+    buckets = new Bucket[capacity];\n+    \n+    for (i = 0; i < iLen; i++)\n+      {\n+\toKey = s.readObject();\n+\toValue = s.readObject();\n+\tinternalPut(oKey, oValue);\n+      }\n+  }\n+  \n+  /**\n+   * a Hashtable version of Map.Entry -- one thing in this implementation is\n+   * Hashtable-specific:  a NullPointerException is thrown if someone calls\n+   * <pre>setValue(null)</pre>\n+   *\n+   * Simply, a key / value pair\n+   *\n+   * @author      Jon Zeppieri\n+   * @version     $Revision: 1.7 $\n+   * @modified    $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+   */\n+  private static class HashtableEntry extends Bucket.Node implements Map.Entry\n+  {\n+    /** construct a new HastableEntry with the given key and value */\n+    public HashtableEntry(Object key, Object value)\n+    {\n+      super(key, value);\n+    }\n+    \n+    /** sets the value of this Map.Entry; throws NullPointerException if \n+     * <pre>newValue</pre> is null \n+     *\n+     * @throws     NullPointerException   if <pre>newValue</pre> is null \n+     */\n+    public Object setValue(Object newValue)\n+      throws UnsupportedOperationException, ClassCastException, \n+      IllegalArgumentException, NullPointerException\n+    {\n+      if (newValue == null)\n+\tthrow new NullPointerException();\n+      else\n+\treturn super.setValue(newValue);\n+    }\n+  }\n+  \n+  \n+  /**\n+   * an inner class representing an Enumeration view of this\n+   * Hashtable, providing sequential access to its elements; this\n+   * implementation is parameterized to provide access either to the\n+   * keys or to the values in the Hashtable\n+   *\n+   * @author       Jon Zeppieri\n+   * @version      $Revision: 1.7 $\n+   * @modified $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $ */\n+  private class HashtableEnumeration implements Enumeration\n+  {\n+    /** the type of Enumeration:  KEYS or VALUES */\n+    private int myType;\n+    /** where are we in our iteration over the elements of this Hashtable */\n+    private int position;\n+    /** our current index into the BucketList array */\n+    private int bucketIndex;\n+    /** a reference to the specific Bucket at which our \"cursor\" is positioned */\n+    private Bucket.Node currentNode;\n+    \n+    /**\n+     * construct a new HashtableEnumeration with the given type of view\n+     *\n+     * @param      type        KEYS or VALUES:  the type of view this Enumeration is\n+     *                         providing\n+     */\n+    HashtableEnumeration(int type)\n+    {\n+      myType = type;\n+      position = 0;\n+      bucketIndex = -1;\n+      currentNode = null;\n+    }\n+    \n+    /**\n+     * returns true if not all elements have been retrived from the Enuemration\n+     *\n+     * <b>NOTE: modifications to the backing Hashtable while iterating\n+     * through an Enumeration can result in undefined behavior, as the\n+     * cursor may no longer be appropriately positioned</b> */\n+\tpublic boolean hasMoreElements()\n+    {\n+      return position < Hashtable.this.size();\n+    }\n+    \n+    /**\n+     * returns the next element from the Enuemration\n+     *\n+     * <b>NOTE: modifications to the backing Hashtable while iterating\n+     * through an Enumeration can result in undefined behavior, as the\n+     * cursor may no longer be appropriately positioned</b>\n+     *\n+     * @throws    NoSuchElementException     if there are no more elements left in\n+     *                                       the sequential view */\n+    public Object nextElement()\n+    {\n+      Bucket list = null;\n+      Object result;\n+      try\n \t{\n-\t  // Calling put(elem.key, elem.value); would seem like the easy way\n-\t  // but it is dangerous since put increases 'hsize' and calls rehash!\n-\t  // This could become infinite recursion under the right\n-\t  // circumstances.  Instead, we'll add the element directly; this is a\n-\t  // bit more efficient than put since the data is already verified.\n-    \t  final int index = Math.abs(elem.key.hashCode() % bucket.length);\n-\t  HashtableEntry newElem = new HashtableEntry(elem.key, elem.value);\n-\t  if (bucket[index] == null)\n-\t    bucket[index] = newElem;\n-\t  else\n+\t  while (currentNode == null)\n \t    {\n-\t      // Since this key can't already be in the table, just add this\n-\t      // in at the top of the bucket.\n-\t      newElem.nextEntry = bucket[index];\n-\t      bucket[index] = newElem;\n+\t      while (list == null)\n+\t\tlist = Hashtable.this.buckets[++bucketIndex];\n+\t      currentNode = list.first;\n \t    }\n+\t  result = (myType == KEYS) ? currentNode.getKey() : \n+\t    currentNode.getValue();\n+\t  currentNode = currentNode.next;\n \t}\n-  }\n-\n-  public synchronized Object remove(Object key)\n-  {\n-    // TBD: Hmm, none of the various docs say to throw an exception here.\n-    if (key == null)\n-      return null;\n-\n-    Object retval;\n-    HashtableEntry prevElem = null;\n-    final int index = Math.abs(key.hashCode() % bucket.length);\n-\n-    for (HashtableEntry elem = bucket[index]; elem != null;\n-\t prevElem = elem, elem = elem.nextEntry)\n-      if (elem.key.equals(key))\n+      catch(Exception e)\n \t{\n-\t  retval = elem.value;\n-\t  if (prevElem == null)\n-\t    bucket[index] = elem.nextEntry;\n-\t  else\n-\t    prevElem.nextEntry = elem.nextEntry;\n-\t  --hsize;\n-\t  return retval;\n+\t  throw new NoSuchElementException();\n \t}\n-\n-    return null;\n+      position++;\n+      return result;\n+    }\n   }\n-\n-  public int size()\n+  \n+  /**\n+   * an inner class providing a Set view of a Hashtable; this\n+   * implementation is parameterized to view either a Set of keys or a\n+   * Set of Map.Entry objects\n+   *\n+   * Note: a lot of these methods are implemented by AbstractSet, and\n+   * would work just fine without any meddling, but far greater\n+   * efficiency can be gained by overriding a number of them.  And so\n+   * I did.\n+   *\n+   * @author      Jon Zeppieri\n+   * @version     $Revision: 1.7 $\n+   * @modified $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $ */\n+  private class HashtableSet extends AbstractSet\n+  {\n+    /** the type of this Set view:  KEYS or ENTRIES */\n+    private int setType;\n+    \n+    /** construct a new HashtableSet with the supplied view type */\n+    HashtableSet(int type)\n+    {\n+      setType = type;\n+    }\n+    \n+    /**\n+     * adding an element is unsupported; this method simply throws an\n+     * exception\n+     *\n+     * @throws UnsupportedOperationException */\n+    public boolean add(Object o) throws UnsupportedOperationException\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * adding an element is unsupported; this method simply throws an\n+     * exception\n+     *\n+     * @throws UnsupportedOperationException */\n+    public boolean addAll(Collection c) throws UnsupportedOperationException\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * clears the backing Hashtable; this is a prime example of an\n+     * overridden implementation which is far more efficient than its\n+     * superclass implementation (which uses an iterator and is O(n)\n+     * -- this is an O(1) call) */\n+    public void clear()\n+    {\n+      Hashtable.this.clear();\n+    }\n+    \n+    /**\n+     * returns true if the supplied object is contained by this Set\n+     *\n+     * @param     o       an Object being testing to see if it is in this Set\n+     */\n+    public boolean contains(Object o)\n+    {\n+      if (setType == KEYS)\n+\treturn Hashtable.this.containsKey(o);\n+      else\n+\treturn (o instanceof Map.Entry) ? Hashtable.this.containsEntry((Map.Entry) o) : false;\n+    }\n+    \n+    /** \n+     * returns true if the backing Hashtable is empty (which is the\n+     * only case either a KEYS Set or an ENTRIES Set would be empty) */\n+    public boolean isEmpty()\n+    {\n+      return Hashtable.this.isEmpty();\n+    }\n+    \n+    /**\n+     * removes the supplied Object from the Set\n+     *\n+     * @param      o       the Object to be removed\n+     */\n+    public boolean remove(Object o)\n+    {\n+      if (setType == KEYS)\n+\treturn (Hashtable.this.remove(o) != null);\n+      else\n+\treturn (o instanceof Map.Entry) ? \n+\t  (Hashtable.this.remove(((Map.Entry) o).getKey()) != null) : false;\n+    }\n+    \n+    /** returns the size of this Set (always equal to the size of the\n+        backing Hashtable) */\n+    public int size()\n+    {\n+      return Hashtable.this.size();\n+    }\n+    \n+    /** returns an Iterator over the elements of this Set */\n+    public Iterator iterator()\n+    {\n+      return new HashtableIterator(setType);\n+    }\n+  }\n+  \n+  /**\n+   * Like the above Set view, except this one if for values, which are not\n+   * guaranteed to be unique in a Hashtable; this prvides a Bag of values\n+   * in the Hashtable\n+   *\n+   * @author       Jon Zeppieri\n+   * @version      $Revision: 1.7 $\n+   * @modified     $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+   */\n+  private class HashtableCollection extends AbstractCollection\n   {\n-    return this.hsize;\n+    /** a trivial contructor for HashtableCollection */\n+    HashtableCollection()\n+    {\n+    }\n+    \n+    /** \n+     * adding elements is not supported by this Collection;\n+     * this method merely throws an exception\n+     *\n+     * @throws     UnsupportedOperationException\n+     */\n+    public boolean add(Object o) throws UnsupportedOperationException\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    \n+    /** \n+     * adding elements is not supported by this Collection;\n+     * this method merely throws an exception\n+     *\n+     * @throws     UnsupportedOperationException\n+     */\n+    public boolean addAll(Collection c) throws UnsupportedOperationException\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+    \n+    /** removes all elements from this Set (and from the backing Hashtable) */\n+    public void clear()\n+    {\n+      Hashtable.this.clear();\n+    }\n+    \n+    /** \n+     * returns true if this Collection contains at least one Object which equals() the\n+     * supplied Object\n+     *\n+     * @param         o        the Object to compare against those in the Set\n+     */\n+    public boolean contains(Object o)\n+    {\n+      return Hashtable.this.containsValue(o);\n+    }\n+    \n+    /** returns true IFF the Collection has no elements */\n+    public boolean isEmpty()\n+    {\n+      return Hashtable.this.isEmpty();\n+    }\n+    \n+    /** returns the size of this Collection */\n+    public int size()\n+    {\n+      return Hashtable.this.size();\n+    }\n+    \n+    /** returns an Iterator over the elements in this Collection */\n+    public Iterator iterator()\n+    {\n+      return new HashtableIterator(VALUES);\n+    }\n   }\n-\n-  public synchronized String toString()\n+  \n+  /**\n+   * Hashtable's version of the JDK-1.2 counterpart to the Enumeration;\n+   * this implementation is parameterized to give a sequential view of\n+   * keys, values, or entries; it also allows the removal of elements, \n+   * as per the Javasoft spec.\n+   *\n+   * @author       Jon Zeppieri\n+   * @version      $Revision: 1.7 $\n+   * @modified     $Id: Hashtable.java,v 1.7 2000/03/15 21:59:13 rao Exp $\n+   */\n+  class HashtableIterator implements Iterator\n   {\n-    // Following the Java Lang Spec 21.5.4 (p. 636).\n-\n-    Enumeration keys = keys();\n-    Enumeration values = elements();\n-\n-    // Prepend first element with open bracket\n-    StringBuffer result = new StringBuffer(\"{\");\n-\n-    // add first element if one exists\n-    // TBD: Seems like it is more efficient to catch the exception than\n-    // to call hasMoreElements each time around.\n-    try\n+    /** the type of this Iterator: KEYS, VALUES, or ENTRIES */\n+    private int myType;\n+    /** \n+     * the number of modifications to the backing Hashtable for which\n+     * this Iterator can account (idea ripped off from Stuart Ballard)\n+     */\n+    private int knownMods;\n+    /** the location of our sequential \"cursor\" */\n+    private int position;\n+    /** the current index of the BucketList array */\n+    private int bucketIndex;\n+    /** a reference, originally null, to the specific Bucket our\n+        \"cursor\" is pointing to */\n+    private Bucket.Node currentNode;\n+    /** a reference to the current key -- used fro removing elements\n+        via the Iterator */\n+    private Object currentKey;\n+    \n+    /** construct a new HashtableIterator with the supllied type:\n+        KEYS, VALUES, or ENTRIES */\n+    HashtableIterator(int type)\n     {\n-      result.append(keys.nextElement().toString() + \"=\" +\n-\t\tvalues.nextElement().toString());\n+      myType = type;\n+      knownMods = Hashtable.this.modCount;\n+      position = 0;\n+      bucketIndex = -1;\n+      currentNode = null;\n+      currentKey = null;\n     }\n-    catch (NoSuchElementException ex)\n+    \n+    /** \n+     * Stuart Ballard's code: if the backing Hashtable has been\n+     * altered through anything but <i>this</i> Iterator's\n+     * <pre>remove()</pre> method, we will give up right here, rather\n+     * than risking undefined behavior\n+     *\n+     * @throws ConcurrentModificationException */\n+    private void checkMod() \n     {\n+      if (knownMods != Hashtable.this.modCount)\n+\tthrow new ConcurrentModificationException();\n     }\n-\n-    // Prepend subsequent elements with \", \"\n-    try\n+    \n+    /** returns true if the Iterator has more elements */\n+    public boolean hasNext()\n     {\n-      while (true)\n-        result.append(\", \" + keys.nextElement().toString() + \"=\" +\n-\t\tvalues.nextElement().toString());\n+      checkMod();\n+      return position < Hashtable.this.size();\n     }\n-    catch (NoSuchElementException ex)\n+    \n+    /** returns the next element in the Iterator's sequential view */\n+    public Object next()\n     {\n+      Bucket list = null;\n+      Object result;\n+      checkMod();\t    \n+      try\n+\t{\n+\t  while (currentNode == null)\n+\t    {\n+\t      while (list == null)\n+\t\tlist = Hashtable.this.buckets[++bucketIndex];\n+\t      currentNode = list.first;\n+\t    }\n+\t  currentKey = currentNode.getKey();\n+\t  result = (myType == KEYS) ? currentKey : \n+\t    ((myType == VALUES) ? currentNode.getValue() : currentNode);\n+\t  currentNode = currentNode.next;\n+\t}\n+      catch(Exception e)\n+\t{\n+\t  throw new NoSuchElementException();\n+\t}\n+      position++;\n+      return result;\n+    }\n+    \n+    /** \n+     * removes from the backing Hashtable the last element which was\n+     * fetched with the <pre>next()</pre> method */\n+    public void remove()\n+    {\n+      checkMod();\n+      if (currentKey == null)\n+\t{\n+\t  throw new IllegalStateException();\n+\t}\n+      else\n+\t{\n+\t  Hashtable.this.remove(currentKey);\n+\t  knownMods++;\n+\t  position--;\n+\t  currentKey = null;\n+\t}\n     }\n-\n-    // Append last element with closing bracket\n-    result.append(\"}\");\n-    return result.toString();\n   }\n+}\n+\n \n-  // TODO12:\n-  // public Set entrySet()\n-  // {\n-  // }\n \n-  // TODO12:\n-  // public Set keySet()\n-  // {\n-  // }\n \n-  // Since JDK 1.2:\n-  // This method is identical to contains but is part of the 1.2 Map interface.\n-  // TBD: Should contains return containsValue instead?  Depends on which\n-  // will be called more typically.\n-  public synchronized boolean containsValue(Object value)\n-  {\n-    return this.contains(value);\n-  }\n \n-  // TODO12:\n-  // public boolean equals(Object o)\n-  // {\n-  // }\n \n-  // TODO12:\n-  // public boolean hashCode()\n-  // {\n-  // }\n \n-  // TODO12:\n-  // public void putAll(Map t)\n-  // {\n-  // }\n \n-  // TODO12:\n-  // public Collection values()\n-  // {\n-  // }\n-}"}, {"sha": "c9d46dffb3e59576fdfb4ba4ac1b0a50bfca03d5", "filename": "libjava/java/util/Map.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FMap.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,57 @@\n+/* Map.java -- An object that maps keys to values\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Doc comments for everything.\n+\n+package java.util;\n+\n+public interface Map \n+{\n+    public void clear();\n+    public boolean containsKey(Object key);\n+    public boolean containsValue(Object value);\n+    public Set entrySet();\n+    public boolean equals(Object o);\n+    public Object get(Object key);\n+    public Object put(Object key, Object value);\n+    public int hashCode();\n+    public boolean isEmpty();\n+    public Set keySet();\n+    public void putAll(Map m);\n+    public Object remove(Object o);\n+    public int size();\n+    public Collection values();\n+    \n+    public static interface Entry {\n+\tpublic Object getKey();\n+\tpublic Object getValue();\n+\tpublic Object setValue(Object value);\n+\tpublic int hashCode();\n+\tpublic boolean equals(Object o);\n+    }\n+}"}, {"sha": "f1f836a0e8a603492d79cfbf0f49359c4c191251", "filename": "libjava/java/util/Set.java", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2FSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSet.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,48 @@\n+/* Set.java -- A collection that prohibits duplicates\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+// TO DO:\n+// ~ Doc comments for everything.\n+\n+package java.util;\n+\n+public interface Set extends Collection {\n+  boolean add(Object o);\n+  boolean addAll(Collection c);\n+  void clear();\n+  boolean contains(Object o);\n+  boolean containsAll(Collection c);\n+  boolean equals(Object o);\n+  int hashCode();\n+  boolean isEmpty();\n+  Iterator iterator();\n+  boolean remove(Object o);\n+  boolean removeAll(Collection c);\n+  boolean retainAll(Collection c);\n+  int size();\n+  Object[] toArray();\n+}"}, {"sha": "587f4a1d130efb5940fbdfe72f0913fcb95166e5", "filename": "libjava/java/util/jar/Attributes.java", "status": "added", "additions": 586, "deletions": 0, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FAttributes.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,586 @@\n+/* Attributes.java -- Represents attribute name/value pairs from a Manifest\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util.jar;\n+\n+import java.util.Collection;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Represents attribute name/value pairs from a Manifest as a Map.\n+ * The names of an attribute are represented by the\n+ * <code>Attributes.Name</code> class and should confirm to the restrictions\n+ * described in that class. Note that the Map interface that Attributes\n+ * implements allows you to put names and values into the attribute that don't\n+ * follow these restriction (and are not really Atrribute.Names, but if you do\n+ * that it might cause undefined behaviour later).\n+ * <p>\n+ * If you use the constants defined in the inner class Name then you can be\n+ * sure that you always access the right attribute names. This makes\n+ * manipulating the Attributes more or less type safe.\n+ * <p>\n+ * Most of the methods are wrappers to implement the Map interface. The really\n+ * usefull and often used methods are <code>getValue(Name)</code> and\n+ * <code>getValue(String)</code>. If you actually want to set attributes you\n+ * may want to use the <code>putValue(String, String)</code> method\n+ * (sorry there is no public type safe <code>putValue(Name, String)</code>\n+ * method).\n+ *\n+ * @see java.util.jar.Attributes.Name\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class Attributes implements Cloneable, Map {\n+\n+    // Fields\n+\n+    /**\n+     * The map that holds all the attribute name/value pairs. In this\n+     * implementation it is actually a Hashtable, but that can be different in\n+     * other implementations.\n+     */\n+    protected Map map;\n+\n+    // Inner class\n+\n+    /**\n+     * Represents a name of a Manifest Attribute. Defines a couple of well\n+     * know names for the general main attributes, stand alone application\n+     * attributes, applet attributes, extension identification attributes,\n+     * package versioning and sealing attributes, file contents attributes,\n+     * bean objects attribute and signing attributes. See the \n+     * <p>\n+     * The characters of a Name must obey the following restrictions:\n+     * <ul>\n+     * <li> Must contain at least one character\n+     * <li> The first character must be alphanumeric (a-z, A-Z, 0-9)\n+     * <li> All other characters must be alphanumeric, a '-' or a '_'\n+     * </ul>\n+     * <p>\n+     * When comparing Names (with <code>equals</code>) all characters are\n+     * converted to lowercase. But you can get the original case sensitive\n+     * string with the <code>toString()</code> method.\n+     *\n+     * @since 1.2\n+     * @author Mark Wielaard (mark@klomp.org)\n+     */\n+    public static class Name {\n+\n+        // Fields\n+\n+        // General Main Attributes\n+\n+        /**\n+         * General main attribute -\n+         * the version of this Manifest file.\n+         */\n+        public static final Name MANIFEST_VERSION\n+                                = new Name(\"Manifest-Version\");\n+        /**\n+         * General main attribute -\n+         * tool and version that created this Manifest file.\n+         */\n+        public static final Name CREATED_BY\n+                                = new Name(\"Created-By\");\n+        /**\n+         * General main attribute -\n+         * the version of the jar file signature.\n+         */\n+        public static final Name SIGNATURE_VERSION\n+                                = new Name(\"Signature-Version\");\n+        /**\n+         * General main attribute -\n+         * (relative) URLs of the libraries/classpaths that the Classes in\n+         * this jar file depend on.\n+         */\n+        public static final Name CLASS_PATH\n+                                = new Name(\"Class-Path\");\n+\n+        /**\n+         * Stand alone application attribute -\n+         * the entry (without the .class ending) that is the main\n+         * class of this jar file.\n+         */\n+        public static final Name MAIN_CLASS\n+                                = new Name(\"Main-Class\");\n+\n+        /**\n+         * Applet attribute -\n+         * a list of extension libraries that the applet in this\n+         * jar file depends on.\n+         * For every named extension there should be some Attributes in the\n+         * Manifest manifest file with the following Names:\n+         * <ul>\n+         * <li> &lt;extension&gt;-Extension-Name:\n+         * unique name of the extension\n+         * <li> &lt;extension&gt;-Specification-Version:\n+         * minimum specification version\n+         * <li> &lt;extension&gt;-Implementation-Version:\n+         * minimum implementation version\n+         * <li> &lt;extension&gt;-Implementation-Vendor-Id:\n+         * unique id of implementation vendor\n+         * <li> &lt;extension&gt;-Implementation-URL:\n+         * where the latest version of the extension library can be found\n+         * </ul>\n+         */\n+        public static final Name EXTENSION_LIST\n+                                = new Name(\"Extension-List\");\n+\n+        /**\n+         * Extension identification attribute -\n+         * the name if the extension library contained in the jar.\n+         */\n+        public static final Name EXTENSION_NAME\n+                                = new Name(\"Extension-Name\");\n+        /**\n+         * Extension identification attribute -\n+         * synonym for <code>EXTENSTION_NAME</code>.\n+         */\n+        public static final Name EXTENSION_INSTALLATION\n+                                = EXTENSION_NAME;\n+\n+        // Package versioning and sealing attributes\n+        /**\n+         * Package versioning -\n+         * name of extension library contained in this jar.\n+         */\n+        public static final Name IMPLEMENTATION_TITLE\n+                                = new Name(\"Implementation-Title\");\n+        /**\n+         * Package versioning -\n+         * version of the extension library contained in this jar.\n+         */\n+        public static final Name IMPLEMENTATION_VERSION\n+                                = new Name(\"Implementation-Version\");\n+        /**\n+         * Package versioning -\n+         * name of extension library creator contained in this jar.\n+         */\n+        public static final Name IMPLEMENTATION_VENDOR\n+                                = new Name(\"Implementation-Vendor\");\n+        /**\n+         * Package versioning -\n+         * unique id of extension library creator.\n+         */\n+        public static final Name IMPLEMENTATION_VENDOR_ID\n+                                = new Name(\"Implementation-Vendor-Id\");\n+        /**\n+         * Package versioning -\n+         * location where this implementation can be downloaded.\n+         */\n+        public static final Name IMPLEMENTATION_URL\n+                                = new Name(\"Implementation-URL\");\n+        /**\n+         * Package versioning -\n+         * title of the specification contained in this jar.\n+         */\n+        public static final Name SPECIFICATION_TITLE\n+                                = new Name(\"Specification-Title\");\n+        /**\n+         * Package versioning -\n+         * version of the specification contained in this jar.\n+         */\n+        public static final Name SPECIFICATION_VERSION\n+                                = new Name(\"Specification-Version\");\n+        /**\n+         * Package versioning -\n+         * organisation that maintains the specification contains in this\n+         * jar.\n+         */\n+        public static final Name SPECIFICATION_VENDOR\n+                                = new Name(\"Specification-Vendor\");\n+        /**\n+         * Package sealing -\n+         * whether (all) package(s) is(/are) sealed. Value is either \"true\"\n+         * or \"false\".\n+         */\n+        public static final Name SEALED\n+                                = new Name(\"Sealed\");\n+\n+        /**\n+         * File contents attribute -\n+         * Mime type and subtype for the jar entry.\n+         */\n+        public static final Name CONTENT_TYPE\n+                                = new Name(\"Content-Type\");\n+\n+        /**\n+         * Bean objects attribute -\n+         * whether the entry is a Java Bean. Value is either \"true\" or \"false\".\n+         */\n+        public static final Name JAVA_BEAN\n+                                = new Name(\"Java-Bean\");\n+\n+        /**\n+         * Signing attribute -\n+         * application specific signing attribute. Must be understood by\n+         * the manifest parser when present to validate the jar (entry).\n+         */\n+        public static final Name MAGIC\n+                                = new Name(\"Magic\");\n+\n+        /** The (lowercase) String representation of this Name */\n+        private final String name;\n+        /** The original String given to the constructor */\n+        private final String origName;\n+\n+        // Constructor\n+\n+        /**\n+         * Creates a new Name from the given String.\n+         * Throws an IllegalArgumentException if the given String is empty or\n+         * contains any illegal Name characters.\n+         * \n+         * @param name the name of the new Name\n+         * @exception IllegalArgumentException if name isn't a valid String\n+         * representation of a Name\n+         * @exception NullPointerException if name is null\n+         */\n+        public Name(String name) throws IllegalArgumentException,\n+                                        NullPointerException {\n+            // name must not be null\n+            // this will throw a NullPointerException if it is\n+            char chars[] = name.toCharArray();\n+                                             \n+            // there must be at least one character\n+            if (chars.length == 0)\n+                throw new IllegalArgumentException(\n+                            \"There must be at least one character in a name\");\n+\n+            // first character must be alphanum\n+            char c = chars[0];\n+            if (!((c >= 'a' && c <= 'z') ||\n+                  (c >= 'A' && c <= 'Z') ||\n+                  (c >= '0' && c <= '9')))\n+                throw new IllegalArgumentException(\n+                                        \"First character must be alphanum\");\n+\n+            // all other characters must be alphanums, '-' or '_'\n+            for (int i = 1; i < chars.length; i++) {\n+                if (!((c >= 'a' && c <= 'z') ||\n+                      (c >= 'A' && c <= 'Z') ||\n+                      (c >= '0' && c <= '9') ||\n+                      (c == '-') || (c == '_')))\n+                    throw new IllegalArgumentException(\n+                                \"Characters must be alphanums, '-' or '_'\");\n+            }\n+\n+            // Still here? Then convert to lower case and be done.\n+            // Store the original name for toString();\n+            this.origName = name;\n+            this.name = name.toLowerCase();\n+        }\n+\n+        /**\n+         * Returns the hash code of the (lowercase) String representation of\n+         * this Name.\n+         */\n+        public int hashCode() {\n+            return name.hashCode();\n+        }\n+\n+        /**\n+         * Checks if another object is equal to this Name object.\n+         * Another object is equal to this Name object if it is an instance of\n+         * Name and the (lowercase) string representation of the name is equal.\n+         */\n+        public boolean equals(Object o) {\n+            // Quick and dirty check\n+            if (name == o)\n+                return true;\n+\n+            try {\n+                // Note that the constructor already converts the strings to\n+                // lowercase.\n+                String otherName = ((Name)o).name;\n+                return name.equals(otherName);\n+            } catch (ClassCastException cce) {\n+                return false;\n+            } catch (NullPointerException npe) {\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Returns the string representation of this Name as given to the\n+         * constructor (not neccesarily the lower case representation).\n+         */\n+        public String toString() {\n+            return origName;\n+        }\n+    }\n+\n+    // Constructors\n+\n+    /**\n+     * Creates an empty Attributes map.\n+     */\n+    public Attributes() {\n+        map = new Hashtable();\n+    }\n+\n+    /**\n+     * Creates an empty Attributes map with the given initial size.\n+     * @param size the initial size of the underlying map\n+     */\n+    public Attributes(int size) {\n+        map = new Hashtable(size);\n+    }\n+\n+    /**\n+     * Creates an Attributes map with the initial values taken from another\n+     * Attributes map.\n+     * @param attr Attributes map to take the initial values from\n+     */\n+    public Attributes(Attributes attr) {\n+        map = new Hashtable(attr.map);\n+    }\n+\n+    // Methods\n+\n+    /**\n+     * Gets the value of an attribute name given as a String.\n+     *\n+     * @param name a String describing the Name to look for\n+     * @return the value gotten from the map of null when not found\n+     */\n+    public String getValue(String name) {\n+        return (String)get(new Name(name));\n+    }\n+\n+    /**\n+     * Gets the value of the given attribute name.\n+     *\n+     * @param name the Name to look for\n+     * @return the value gotten from the map of null when not found\n+     */\n+    public String getValue(Name name) {\n+        return (String)get(name);\n+    }\n+\n+    /**\n+     * Stores an attribute name (represented by a String) and value in this\n+     * Attributes map.\n+     * When the (case insensitive string) name already exists the value is\n+     * replaced and the old value is returned.\n+     *\n+     * @param name a (case insensitive) String representation of the attribite\n+     * name to add/replace\n+     * @param value the (new) value of the attribute name\n+     * @returns the old value of the attribute name or null if it didn't exist\n+     * yet\n+     */\n+    public String putValue(String name, String value)\n+    {\n+        return putValue(new Name(name), value);\n+    }\n+\n+    /**\n+     * Stores an attribute name (represented by a String) and value in this\n+     * Attributes map.\n+     * When the name already exists the value is replaced and the old value\n+     * is returned.\n+     * <p>\n+     * I don't know why there is no public method with this signature. I think\n+     * there should be one.\n+     *\n+     * @param name the attribite name to add/replace\n+     * @param value the (new) value of the attribute name\n+     * @returns the old value of the attribute name or null if it didn't exist\n+     * yet\n+     */\n+    private String putValue(Name name, String value)\n+    {\n+        return (String)put(name, value);\n+    }\n+\n+    // Methods from Cloneable interface\n+\n+    /**\n+     * Return a clone of this attribute map.\n+     */\n+    public Object clone() {\n+        return new Attributes(this);\n+    }\n+\n+    // Methods from Map interface\n+\n+    /**\n+     * Removes all attributes.\n+     */\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    /**\n+     * Checks to see if there is an attribute with the specified name.\n+     * XXX - what if the object is a String?\n+     *\n+     * @param attrName the name of the attribute to check\n+     * @return true if there is an attribute with the specified name, false\n+     * otherwise\n+     */\n+    public boolean containsKey(Object attrName) {\n+        return map.containsKey(attrName);\n+    }\n+\n+    /**\n+     * Checks to see if there is an attribute name with the specified value.\n+     *\n+     * @param attrValue the value of a attribute to check\n+     * @return true if there is an attribute name with the specified value,\n+     * false otherwise\n+     */\n+    public boolean containsValue(Object attrValue) {\n+        return map.containsValue(attrValue);\n+    }\n+\n+    /**\n+     * Gives a Set of atrribute name and values pairs as MapEntries.\n+     * @see java.util.Map.Entry\n+     * @see java.util.Map#entrySet()\n+     *\n+     * @return a set of attribute name value pairs\n+     */\n+    public Set entrySet() {\n+        return map.entrySet();\n+    }\n+\n+    /**\n+     * Checks to see if two Attributes are equal. The supplied object must be\n+     * a real instance of Attributes and contain the same attribute name/value\n+     * pairs.\n+     *\n+     * @param o another Attribute object which should be checked for equality\n+     * @return true if the object is an instance of Attributes and contains the\n+     * same name/value pairs, false otherwise\n+     */\n+    public boolean equals(Object o) {\n+        // quick and dirty check\n+        if (this == o)\n+            return true;\n+\n+        try {\n+            return map.equals(((Attributes)o).map);\n+        } catch (ClassCastException cce) {\n+            return false;\n+        } catch (NullPointerException npe) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Gets the value of a specified attribute name.\n+     * XXX - what if the object is a String?\n+     *\n+     * @param attrName the name of the attribute we want the value of\n+     * @return the value of the specified attribute name or null when there is\n+     * no such attribute name\n+     */\n+    public Object get(Object attrName) {\n+        return map.get(attrName);\n+    }\n+\n+    /**\n+     * Returns the hashcode of the attribute name/value map.\n+     */\n+    public int hashCode() {\n+        return map.hashCode();\n+    }\n+\n+    /**\n+     * Returns true if there are no attributes set, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    /**\n+     * Gives a Set of all the values of defined attribute names.\n+     */\n+    public Set keySet() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Adds or replaces a attribute name/value pair.\n+     * XXX - What if the name is a string? What if the name is neither a Name\n+     * nor a String? What if the value is not a string?\n+     *\n+     * @param name the name of the attribute\n+     * @param value the (new) value of the attribute\n+     * @return the old value of the attribute or null when there was no old\n+     * attribute with this name\n+     */\n+    public Object put(Object name, Object value) {\n+        return map.put(name, value);\n+    }\n+\n+    /**\n+     * Adds or replaces all attribute name/value pairs from another\n+     * Attributes object to this one. The supplied Map must be an instance of\n+     * Attributes.\n+     *\n+     * @param attr the Attributes object to merge with this one\n+     * @exception ClassCastException if the supplied map is not an instance of\n+     * Attributes\n+     */\n+    public void putAll(Map attr) {\n+        if (!(attr instanceof Attributes)) {\n+            throw new ClassCastException(\n+                        \"Supplied Map is not an instance of Attributes\");\n+        }\n+        map.putAll(attr);\n+    }\n+\n+    /**\n+     * Remove a attribute name/value pair.\n+     * XXX - What if the name is a String?\n+     *\n+     * @param name the name of the attribute name/value pair to remove\n+     * @return the old value of the attribute or null if the attribute didn't\n+     * exist\n+     */\n+    public Object remove(Object name) {\n+        return map.remove(name);\n+    }\n+\n+    /**\n+     * Returns the number of defined attribute name/value pairs.\n+     */\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    /**\n+     * Returns all the values of the defined attribute name/value pairs as a\n+     * Collection.\n+     */\n+    public Collection values() {\n+        return map.values();\n+    }\n+}"}, {"sha": "e15f1a4f3363e854e1d238ff70da16fe5160c9f4", "filename": "libjava/java/util/jar/JarEntry.java", "status": "modified", "additions": 124, "deletions": 24, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarEntry.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -1,39 +1,139 @@\n-/* Copyright (C) 1999  Free Software Foundation\n+/* JarEntry.java - Represents an entry in a jar file\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.util.jar;\n \n-import java.util.zip.*;\n+import java.io.IOException;\n+import java.security.cert.Certificate;\n+import java.util.zip.ZipEntry;\n \n /**\n- * Does not implement the security and manifest methods.\n+ * Extension to a ZipEntry that contains manifest attributes and certificates.\n+ * Both the Atrributes and the Certificates can be null when not set.\n+ * Note that the <code>getCertificates()</code> method only returns a\n+ * valid value after all of the data of the entry has been read.\n+ * <p>\n+ * There are no public methods to set the attributes or certificate of an\n+ * Entru. Only JarEntries created by the classes in <code>java.util.jar</code>\n+ * will have these properties set.\n  *\n- * @author Kresten Krab Thorup <krab@gnu.org>\n- * @date August 10, 1999.\n+ * @since 1.2\n+ * @author Mark Wielaard (mark@klomp.org)\n  */\n+ \n+public class JarEntry extends ZipEntry {\n+\n+    // (Packge local) fields\n+\n+    Attributes attr;\n+    Certificate certs[];\n+\n+    // Constructors\n+\n+    /**\n+     * Creates a new JarEntry with the specified name and no attributes or\n+     * or certificates. Calls <code>super(name)</code> so all other (zip)entry\n+     * fields are null or -1.\n+     *\n+     * @param name the name of the new jar entry\n+     * @exception NullPointerException when the supplied name is null\n+     * @exception IllegalArgumentException when the supplied name is longer\n+     * than 65535 bytes\n+     */\n+    public JarEntry(String name) throws NullPointerException,\n+                                 IllegalArgumentException {\n+        super(name);\n+        attr = null;\n+        certs = null;\n+    }\n \n-public class JarEntry extends ZipEntry\n-{\n-  ZipEntry zip;\n+    /**\n+     * Creates a new JarEntry with the specified ZipEntry as template for\n+     * all properties of the entry. Both attributes and certificates will be\n+     * null.\n+     *\n+     * @param entry the ZipEntry whose fields should be copied\n+     */\n+    public JarEntry(ZipEntry entry) {\n+        super(entry);\n+        attr = null;\n+        certs = null;\n+    }\n \n-  public JarEntry (ZipEntry ent)\n-  {\n-    super (ent);\n-  }\n+    /**\n+     * Creates a new JarEntry with the specified JarEntry as template for\n+     * all properties of the entry.\n+     *\n+     * @param entry the jarEntry whose fields should be copied\n+     */\n+    public JarEntry(JarEntry entry) {\n+        super(entry);\n+        try {\n+            attr = entry.getAttributes();\n+        } catch(IOException _) {}\n+        certs = entry.getCertificates();\n+    }\n \n-  public JarEntry (JarEntry ent)\n-  {\n-    super (ent);\n-  }\n+    // Methods\n \n-  public JarEntry (String name)\n-  {\n-    super (name);\n-  }\n+    /**\n+     * Returns a copy of the Attributes set for this entry.\n+     * When no Attributes are set in the manifest null is returned.\n+     *\n+     * @return a copy of the Attributes set for this entry\n+     * @exception IOException This will never be thrown. It is here for\n+     * binary compatibility.\n+     */\n+    public Attributes getAttributes() throws IOException {\n+        if (attr != null) {\n+            return (Attributes) attr.clone();\n+        } else {\n+            return null;\n+        }\n+    }\n \n+    /**\n+     * Returns a copy of the certificates set for this entry.\n+     * When no certificates are set or when not all data of this entry has\n+     * been read null is returned.\n+     * <p>\n+     * To make sure that this call returns a valid value you must read all\n+     * data from the JarInputStream for this entry.\n+     * When you don't need the data for an entry but want to know the\n+     * certificates that are set for the entry then you can skip all data by\n+     * calling <code>skip(entry.getSize())</code> on the JarInputStream for\n+     * the entry.\n+     *\n+     * @return a copy of the certificates set for this entry\n+     */\n+    public Certificate[] getCertificates() {\n+        if (certs != null) {\n+            return (Certificate []) certs.clone();\n+        } else {\n+            return null;\n+        }\n+    }\n }"}, {"sha": "827f9e2a904caa71eb1f75759214c093f7514db0", "filename": "libjava/java/util/jar/JarException.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarException.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,65 @@\n+/* Attributes.java -- exception thrown to indicate an problem with a jar file\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util.jar;\n+\n+import java.util.zip.ZipException;\n+\n+/**\n+ * This exception is thrown to indicate an problem with a jar file.\n+ * It can be constructed with or without a descriptive message of the problem.\n+ * <p>\n+ * Note that none of the methods in the java.util.jar package actually declare\n+ * to throw this exception, most just declare that they throw an IOException\n+ * which is super class of JarException.\n+ * \n+ * @since 1.2\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+ \n+public class JarException extends ZipException {\n+\n+    // Constructors\n+\n+    /**\n+     * Create a new JarException without a descriptive error message.\n+     */\n+    public JarException() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a new JarException with a descriptive error message indicating\n+     * what went wrong. This message can later be retrieved by calling the\n+     * <code>getMessage()</code> method.\n+     * @see java.lang.Throwable@getMessage()\n+     *\n+     * @param message The descriptive error message\n+     */\n+    public JarException(String message) {\n+        super(message);\n+    }\n+}"}, {"sha": "3f1823a00b4eff400f81b33e220fd3f6121bcb56", "filename": "libjava/java/util/jar/JarFile.java", "status": "modified", "additions": 265, "deletions": 44, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarFile.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -1,56 +1,277 @@\n-/* Copyright (C) 1999  Free Software Foundation\n+/* JarFile.java - Representation of a jar file\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.util.jar;\n \n-import java.util.zip.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.util.Enumeration;\n \n /**\n- * Does not implement any of the security.  Just a place holder, so\n- * that I can implement URLClassLoader.\n+ * Representation of a jar file.\n+ * <p>\n+ * Note that this class is not a subclass of java.io.File but a subclass of\n+ * java.util.zip.ZipFile and you can only read JarFiles with it (although\n+ * there are constructors that take a File object).\n+ * <p>\n+ * XXX - verification of Manifest signatures is not yet implemented.\n  *\n- * @author Kresten Krab Thorup <krab@gnu.org>\n- * @date August 10, 1999.\n+ * @since 1.2\n+ * @author Mark Wielaard (mark@klomp.org)\n  */\n+public class JarFile extends ZipFile {\n+\n+    // Fields\n+\n+    /** The name of the manifest entry: META-INF/MANIFEST.MF */\n+    public static final String MANIFEST_NAME = \"META-INF/MANIFEST.MF\";\n+\n+    /**\n+     * The manifest of this file, if any, otherwise null.\n+     * Read by the constructor.\n+     */\n+    private final Manifest manifest;\n+\n+    /** Wether to verify the manifest and all entries */\n+    private boolean verify;\n+\n+    // Constructors\n+\n+    /**\n+     * Creates a new JarFile, tries to read the manifest and if the manifest\n+     * exists verifies it.\n+     *\n+     * @param fileName the name of the file to open\n+     * @exception FileNotFoundException if the fileName cannot be found\n+     * @exception IOException if another IO exception occurs while reading\n+     */\n+    public JarFile(String fileName) throws FileNotFoundException,\n+                                           IOException {\n+        this (fileName, true);\n+    }\n+\n+    /**\n+     * Creates a new JarFile, tries to read the manifest and if the manifest\n+     * exists and verify is true verfies it.\n+     *\n+     * @param fileName the name of the file to open\n+     * @param verify checks manifest and entries when true and a manifest\n+     * exists, when false no checks are made\n+     * @exception FileNotFoundException if the fileName cannot be found\n+     * @exception IOException if another IO exception occurs while reading\n+     */\n+    public JarFile(String fileName, boolean verify) throws\n+                                                    FileNotFoundException,\n+                                                    IOException {\n+        super(fileName);\n+        manifest = readManifest();\n+        if (verify)\n+            verify();\n+    }\n+\n+    /**\n+     * Creates a new JarFile, tries to read the manifest and if the manifest\n+     * exists verifies it.\n+     *\n+     * @param file the file to open as a jar file\n+     * @exception FileNotFoundException if the file does not exits\n+     * @exception IOException if another IO exception occurs while reading\n+     */\n+    public JarFile(File file) throws FileNotFoundException,\n+                                     IOException {\n+        this (file, true);\n+    }\n+\n+    /**\n+     * Creates a new JarFile, tries to read the manifest and if the manifest\n+     * exists and verify is true verfies it.\n+     *\n+     * @param file the file to open to open as a jar file\n+     * @param verify checks manifest and entries when true and a manifest\n+     * exists, when false no checks are made\n+     * @exception FileNotFoundException if file does not exist\n+     * @exception IOException if another IO exception occurs while reading\n+     */\n+    public JarFile(File file, boolean verify) throws FileNotFoundException,\n+                                                     IOException {\n+        super(file);\n+        manifest = readManifest();\n+        if (verify)\n+            verify();\n+    }\n+\n+    /**\n+     * XXX - not yet implemented in java.util.zip.ZipFile\n+     *\n+     * @param file the file to open to open as a jar file\n+     * @param verify checks manifest and entries when true and a manifest\n+     * exists, when false no checks are made\n+     * @param mode XXX - see ZipFile\n+     * @exception FileNotFoundException XXX\n+     * @exception IOException XXX\n+     * @exception IllegalArgumentException XXX\n+     * \n+     * @since 1.3\n+     */\n+    public JarFile(File file, boolean verify, int mode) throws\n+                                                    FileNotFoundException,\n+                                                    IOException,\n+                                                    IllegalArgumentException {\n+        // XXX - For now don't use super(file, mode)\n+        this(file, verify);\n+        /* super(file, mode);\n+           manifest = readManifest();\n+           if (verify)\n+               verify(); */\n+    }\n+\n+    // Methods\n+\n+    /**\n+     * XXX - should verify the manifest file\n+     */\n+    private void verify() {\n+        // only check if manifest is not null\n+        if (manifest == null) {\n+            verify = false;\n+            return;\n+        }\n+\n+        verify = true;\n+        // XXX - verify manifest\n+    }\n+\n+    /**\n+     * Parses and returns the manifest if it exists, otherwise returns null.\n+     */\n+    private Manifest readManifest() {\n+        try {\n+            ZipEntry manEntry = super.getEntry(MANIFEST_NAME);\n+            if (manEntry != null) {\n+                InputStream in = super.getInputStream(manEntry);\n+                return new Manifest(in);\n+            } else {\n+                return null;\n+            }\n+        } catch (IOException ioe) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Returns a enumeration of all the entries in the JarFile.\n+     * Note that also the Jar META-INF entries are returned.\n+     *\n+     * @exception IllegalStateException when the JarFile is already closed\n+     */\n+    public Enumeration entries() throws IllegalStateException {\n+        return new JarEnumeration(super.entries());\n+    }\n+\n+    /**\n+     * Wraps a given Zip Entries Enumeration. For every zip entry a\n+     * JarEntry is created and the corresponding Attributes are looked up.\n+     * XXX - Should also look up the certificates.\n+     */\n+    private class JarEnumeration implements Enumeration {\n+\n+        private final Enumeration entries;\n+\n+        JarEnumeration(Enumeration e) {\n+            entries = e;\n+        }\n+\n+        public boolean hasMoreElements() {\n+            return entries.hasMoreElements();\n+        }\n+\n+        public Object nextElement() {\n+            ZipEntry zip = (ZipEntry) entries.nextElement();\n+            JarEntry jar = new JarEntry(zip);\n+            if (manifest != null) {\n+                jar.attr = manifest.getAttributes(jar.getName());\n+            }\n+            // XXX jar.certs\n+            return jar;\n+        }\n+    }\n+\n+    /**\n+     * XXX\n+     * It actually returns a JarEntry not a zipEntry\n+     * @param name XXX\n+     */\n+    public ZipEntry getEntry(String name) {\n+        ZipEntry entry = super.getEntry(name);\n+        if (entry != null) {\n+            JarEntry jarEntry = new JarEntry(getEntry(name));\n+            if (manifest != null) {\n+                jarEntry.attr = manifest.getAttributes(name);\n+                // XXX jarEntry.certs\n+            }\n+            return jarEntry;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * XXX should verify the inputstream\n+     * @param entry XXX\n+     * @exception ZipException XXX\n+     * @exception IOException XXX\n+     */\n+    public synchronized InputStream getInputStream(ZipEntry entry) throws\n+                                                                ZipException,\n+                                                                IOException {\n+        return super.getInputStream(entry); // XXX verify\n+    }\n+\n+    /**\n+     * Returns the JarEntry that belongs to the name if such an entry\n+     * exists in the JarFile. Returns null otherwise\n+     * Convenience method that just casts the result from <code>getEntry</code>\n+     * to a JarEntry.\n+     *\n+     * @param name the jar entry name to look up\n+     * @return the JarEntry if it exists, null otherwise\n+     */\n+    public JarEntry getJarEntry(String name) {\n+        return (JarEntry)getEntry(name);\n+    }\n \n-public class JarFile extends ZipFile\n-{\n-  private boolean verify;\n-\n-  public JarFile (String file) throws java.io.IOException\n-  {\n-    super (file);\n-  }\n-    \n-  public JarFile (File file) throws java.io.IOException\n-  {\n-    super (file);\n-  }\n-\n-  public JarFile (String file, boolean verify) throws java.io.IOException\n-  {\n-    super (file);\n-    this.verify = verify;\n-  }\n-    \n-  public JarFile (File file, boolean verify) throws java.io.IOException\n-  {\n-    super (file);\n-    this.verify = verify;\n-  }\n-\n-  public JarEntry getJarEntry (String name)\n-  {\n-    ZipEntry ent = getEntry(name);\n-    if (ent == null)\n-      return null;\n-    else\n-      return new JarEntry(ent);\n-  }\n+    /**\n+     * Returns the manifest for this JarFile or null when the JarFile does not\n+     * contain a manifest file.\n+     */\n+    public Manifest getManifest() {\n+        return manifest;\n+    }\n }"}, {"sha": "c8f5340637ba726712ed2af434d180301dc4239f", "filename": "libjava/java/util/jar/JarInputStream.java", "status": "modified", "additions": 162, "deletions": 19, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarInputStream.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -1,32 +1,175 @@\n-/* Copyright (C) 1999  Free Software Foundation\n+/* JarInputStream.java - InputStream for reading jar files\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.util.jar;\n \n-import java.util.zip.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n \n /**\n- * Does not implement any of the security.  Just a place holder, so\n- * that I can implement URLClassLoader.\n+ * InputStream for reading jar files.\n+ * XXX - verification of the signatures in the Manifest file is not yet\n+ * implemented.\n  *\n- * @author Kresten Krab Thorup <krab@gnu.org>\n- * @date August 10, 1999.\n+ * @since 1.2\n+ * @author Mark Wielaard (mark@klomp.org)\n  */\n+ \n+public class JarInputStream extends ZipInputStream {\n+\n+    // Fields\n+\n+    /** The manifest for this file or null when there was no manifest. */\n+    private Manifest manifest;\n+\n+    /** The first real JarEntry for this file. Used by readManifest() to store\n+        an entry that isn't the manifest but that should be returned by\n+        getNextEntry next time it is called. Null when no firstEntry was read\n+        while searching for the manifest entry, or when it has already been\n+        returned by getNextEntry(). */\n+    private JarEntry firstEntry;\n+\n+    // Constructors\n+\n+    /**\n+     * Creates a new JarInputStream and tries to read the manifest.\n+     * If such a manifest is present the JarInputStream tries to verify all\n+     * the entry signatures while reading.\n+     *\n+     * @param in InputStream to read the jar from\n+     * @exception IOException when an error occurs when opening or reading\n+     */\n+    public JarInputStream(InputStream in) throws IOException {\n+        this(in, true);\n+    }\n+\n+    /**\n+     * Creates a new JarInputStream and tries to read the manifest.\n+     * If such a manifest is present and verify is true, the JarInputStream\n+     * tries to verify all the entry signatures while reading.\n+     *\n+     * @param in InputStream to read the jar from\n+     * @param verify wheter or not to verify the manifest entries\n+     * @exception IOException when an error occurs when opening or reading\n+     */\n+    public JarInputStream(InputStream in, boolean verify) throws IOException {\n+        super(in);\n+        readManifest(verify);\n+    }\n \n-public class JarInputStream extends ZipInputStream\n-{\n-   public JarEntry getNextJarEntry () throws java.io.IOException\n-    {\n-       return new JarEntry (getNextEntry ());\n+    // Methods\n+\n+    /**\n+     * Set the manifest if found. Skips all entries that start with \"META-INF/\"\n+     *\n+     * @param verify when true (and a Manifest is found) checks the Manifest,\n+     * when false no check is performed\n+     * @exception IOException if an error occurs while reading\n+     */\n+    private void readManifest(boolean verify) throws IOException {\n+        firstEntry = (JarEntry) super.getNextEntry();\n+        while ((firstEntry != null) &&\n+               firstEntry.getName().startsWith(\"META-INF/\")) {\n+            if(firstEntry.getName().equals(JarFile.MANIFEST_NAME)) {\n+                manifest = new Manifest(this);\n+            }\n+            firstEntry = (JarEntry) super.getNextEntry();\n+        }\n+        closeEntry();\n+\n+        if (verify) {\n+            // XXX\n+        }\n+    }\n+\n+    /**\n+     * Creates a JarEntry for a particular name and consults the manifest\n+     * for the Attributes of the entry.\n+     * Used by <code>ZipEntry.getNextEntry()</code>\n+     *\n+     * @param name the name of the new entry\n+     */\n+    protected ZipEntry createZipEntry(String name) {\n+        ZipEntry zipEntry = super.createZipEntry(name);\n+        JarEntry jarEntry = new JarEntry(zipEntry);\n+        if (manifest != null) {\n+            jarEntry.attr = manifest.getAttributes(name);\n+        }\n+        return jarEntry;\n+    }\n+    \n+    /**\n+     * Returns the Manifest for the jar file or null if there was no Manifest.\n+     */\n+    public Manifest getManifest() {\n+        return manifest;\n     }\n \n-  public JarInputStream (java.io.InputStream is)\n-  {\n-    super(is);\n-  }\n+    /**\n+     * Returns the next entry or null when there are no more entries.\n+     * Does actually return a JarEntry, if you don't want to cast it yourself\n+     * use <code>getNextJarEntry()</code>. Does not return any entries found\n+     * at the beginning of the ZipFile that are special\n+     * (those that start with \"META-INF/\").\n+     *\n+     * @exception IOException if an IO error occurs when reading the entry\n+     */\n+    public ZipEntry getNextEntry() throws IOException {\n+        ZipEntry entry;\n+        if (firstEntry != null) {\n+            entry = firstEntry;\n+            firstEntry = null;\n+        } else {\n+            entry = super.getNextEntry();\n+        }\n+        return entry;\n+    }\n+\n+    /**\n+     * Returns the next jar entry or null when there are no more entries.\n+     *\n+     * @exception IOException if an IO error occurs when reading the entry\n+     */\n+    public JarEntry getNextJarEntry() throws IOException {\n+        return (JarEntry)getNextEntry();\n+    }\n+\n+    /**\n+     * XXX\n+     *\n+     * @param buf XXX\n+     * @param off XXX\n+     * @param len XXX\n+     * @return XXX\n+     * @exception IOException XXX\n+     */\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        // XXX if (verify) {}\n+        return super.read(buf, off, len);\n+    }\n }"}, {"sha": "78bb35979ea4491d3df4494e7fdb1c2a61580a74", "filename": "libjava/java/util/jar/JarOutputStream.java", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FJarOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FJarOutputStream.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,98 @@\n+/* JarOutputStream.java - OutputStream for writing jar files\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util.jar;\n+\n+import java.io.OutputStream;\n+import java.io.IOException;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+/**\n+ * OutputStream for writing jar files.\n+ * A special ZipOutputStream that can take JarEntries and can have a optional\n+ * Manifest as first entry.\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+ \n+public class JarOutputStream extends ZipOutputStream {\n+\n+    // Constructors\n+\n+    /**\n+     * Creates a new JarOutputStream without a manifest entry.\n+     *\n+     * @param out the stream to create the new jar on\n+     * @exception IOException if something unexpected happend\n+     */\n+    public JarOutputStream(OutputStream out) throws IOException {\n+        this(out, null);\n+    }\n+\n+    /**\n+     * Creates a new JarOutputStream with a manifest entry.\n+     * The manifest will be the first entry in the jar.\n+     *\n+     * @param out the stream to create the new jar on\n+     * @param man the manifest that should be put in the jar file or null\n+     * for no manifest entry\n+     * @exception IOException if something unexpected happend\n+     */\n+    public JarOutputStream(OutputStream out, Manifest man) throws IOException {\n+        super(out);\n+        if (man != null)\n+            writeManifest(man);\n+    }\n+\n+    // Methods\n+\n+    /**\n+     * Writes the manifest to a new JarEntry in this JarOutputStream with as\n+     * name JarFile.MANIFEST_NAME.\n+     *\n+     * @param manifest the non null manifest to be written\n+     * @exception IOException if something unexpected happend\n+     */\n+    private void writeManifest(Manifest manifest) throws IOException {\n+        // Create a new Jar Entry for the Manifest\n+        JarEntry entry = new JarEntry(JarFile.MANIFEST_NAME);\n+        putNextEntry(entry);\n+        manifest.write(this);\n+        closeEntry();\n+    }\n+\n+    /**\n+     * Prepares the JarOutputStream for writing the next entry. \n+     * This implementation just calls <code>super.putNextEntre()</code>.\n+     *\n+     * @param entry The information for the next entry\n+     * @exception IOException when some unexpected I/O exception occured\n+     */\n+    public void putNextEntry(ZipEntry entry) throws IOException {\n+        super.putNextEntry(entry); // XXX\n+    }\n+}"}, {"sha": "a4034e2c65cfc13f61049427fa3abe51b499fc2f", "filename": "libjava/java/util/jar/Manifest.java", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FManifest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fjar%2FManifest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fjar%2FManifest.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -0,0 +1,406 @@\n+/* Attributes.java -- Reads, writes and manipulaties jar manifest files\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util.jar;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Reads, writes and manipulaties jar manifest files.\n+ * XXX\n+ * \n+ * @since 1.2\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class Manifest implements Cloneable {\n+\n+    // Fields\n+\n+    /** The main attributes of the manifest (jar file). */\n+    private final Attributes mainAttr;\n+\n+    /** A map of atrributes for all entries described in this Manifest. */\n+    private final Map entries;\n+\n+    // Constructors\n+\n+    /**\n+     * Creates a new empty Manifest.\n+     */\n+    public Manifest() {\n+        mainAttr = new Attributes();\n+        entries = new Hashtable();\n+    }\n+\n+    /**\n+     * Creates a Manifest from the supplied input stream.\n+     *\n+     * @see read(Inputstream)\n+     * @see write(OutputStream)\n+     *\n+     * @param InputStream the input stream to read the manifest from\n+     * @exception IOException when an i/o exception occurs or the input stream\n+     * does not describe a valid manifest\n+     */\n+    public Manifest(InputStream in) throws IOException {\n+        this();\n+        read(in);\n+    }\n+\n+    /**\n+     * Creates a Manifest from another Manifest.\n+     * Makes a deep copy of the main attributes, but a shallow copy of\n+     * the other entries. This means that you can freely add, change or remove\n+     * the main attributes or the entries of the new manifest without effecting\n+     * the original manifest, but adding, changing or removing attributes from\n+     * a particular entry also changes the attributes of that entry in the\n+     * original manifest.\n+     *\n+     * @see clone()\n+     * @param man the Manifest to copy from\n+     */\n+    public Manifest (Manifest man) {\n+        mainAttr = new Attributes(man.getMainAttributes());\n+        entries = new Hashtable(man.getEntries());\n+    }\n+\n+    // Methods\n+\n+    /**\n+     * Gets the main attributes of this Manifest.\n+     */\n+    public Attributes getMainAttributes() {\n+        return mainAttr;\n+    }\n+\n+    /**\n+     * Gets a map of entry Strings to Attributes for all the entries described\n+     * in this manifest. Adding, changing or removing from this entries map\n+     * changes the entries of this manifest.\n+     */\n+    public Map getEntries() {\n+        return entries;\n+    }\n+\n+    /**\n+     * Returns the Attributes associated with the Entry.\n+     * <p>\n+     * Implemented as:\n+     * <code>return (Attributes)getEntries().get(entryName)</code>\n+     *\n+     * @param entryName the name of the entry to look up\n+     * @return the attributes associated with the entry or null when none\n+     */\n+    public Attributes getAttributes(String entryName) {\n+        return (Attributes)getEntries().get(entryName);\n+    }\n+\n+    /**\n+     * Clears the main attributes and removes all the entries from the\n+     * manifest.\n+     */\n+    public void clear() {\n+        mainAttr.clear();\n+        entries.clear();\n+    }\n+\n+    /**\n+     * XXX\n+     */\n+    public void read(InputStream in) throws IOException {\n+        BufferedReader br = new BufferedReader(\n+                                new InputStreamReader(in, \"8859_1\"));\n+        read_main_section(getMainAttributes(), br);\n+        read_individual_sections(getEntries(), br);\n+    }\n+\n+    // Private Static methods for reading the Manifest file from BufferedReader\n+\n+    private static void read_main_section(Attributes attr,\n+                                          BufferedReader br) throws\n+                                                             IOException {\n+        read_version_info(attr, br);\n+        read_attributes(attr, br);\n+    }\n+\n+    private static void read_version_info(Attributes attr,\n+                                          BufferedReader br) throws\n+                                                             IOException {\n+        String version_header = Attributes.Name.MANIFEST_VERSION.toString();\n+        try {\n+            String value = expect_header(version_header, br);\n+            attr.putValue(version_header, value);\n+        } catch (IOException ioe) {\n+            throw new JarException(\n+                            \"Manifest should start with a \" + version_header\n+                            + \": \" + ioe.getMessage());\n+        }\n+    }\n+\n+    private static String expect_header(String header, BufferedReader br)\n+        throws IOException {\n+\n+        String s = br.readLine();\n+        if (s == null) {\n+            throw new JarException(\"unexpected end of file\");\n+        }\n+        return expect_header(header, br, s);\n+    }\n+\n+    private static String expect_header(String header, BufferedReader br,\n+                                        String s) throws IOException {\n+        try {\n+            String name = s.substring(0, header.length() + 1);\n+            if (name.equalsIgnoreCase(header + \":\")) {\n+                String value_start = s.substring(header.length() + 2);\n+                return read_header_value(value_start, br);\n+            }\n+        } catch (IndexOutOfBoundsException iobe) {}\n+        // If we arrive here, something went wrong\n+        throw new JarException(\"unexpected '\" + s + \"'\");\n+    }\n+\n+    private static String read_header_value(String s, BufferedReader br)\n+                                                        throws IOException {\n+        boolean try_next = true;\n+        while (try_next) {\n+            // Lets see if there is something on the next line\n+            br.mark(1);\n+            if (br.read() == ' ') {\n+                s += br.readLine();\n+            } else {\n+                br.reset();\n+                try_next = false;\n+            }\n+        }\n+        return s;\n+    }\n+\n+    private static void read_attributes(Attributes attr,\n+                                        BufferedReader br) throws\n+                                                           IOException {\n+        String s = br.readLine();\n+        while (s != null && (!s.equals(\"\"))) {\n+            read_attribute(attr, s, br);\n+            s = br.readLine();\n+        }\n+    }\n+\n+    private static void read_attribute(Attributes attr, String s,\n+                                       BufferedReader br) throws IOException {\n+        try {\n+            int colon = s.indexOf(\": \");\n+            String name = s.substring(0, colon);\n+            String value_start = s.substring(colon+2);\n+            String value = read_header_value(value_start, br);\n+            attr.putValue(name, value);\n+        } catch (IndexOutOfBoundsException iobe) {\n+            throw new JarException(\n+                            \"Manifest contains a bad header: \" + s);\n+        }\n+    }\n+\n+    private static void read_individual_sections(Map entries,\n+                                                 BufferedReader br) throws\n+                                                                IOException {\n+        String s = br.readLine();\n+        while (s != null && (!s.equals(\"\"))) {\n+            Attributes attr = read_section_name(s, br, entries);\n+            read_attributes(attr, br);\n+            s = br.readLine();\n+        }\n+    }\n+\n+    private static Attributes read_section_name(String s, BufferedReader br,\n+                                                Map entries) throws\n+                                                                JarException {\n+        try {\n+            String name = expect_header(\"Name\", br, s);\n+            Attributes attr = new Attributes();\n+            entries.put(name, attr);\n+            return attr;\n+        } catch(IOException ioe) {\n+            throw new JarException\n+                (\"Section should start with a Name header: \"\n+                 + ioe.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * XXX\n+     */\n+    public void write(OutputStream out) throws IOException {\n+        PrintWriter pw = new PrintWriter(\n+                            new BufferedWriter(\n+                                new OutputStreamWriter(out, \"8859_1\")));\n+        write_main_section(getMainAttributes(), pw);\n+        pw.println();\n+        write_individual_sections(getEntries(), pw);\n+        if (pw.checkError()) {\n+            throw new JarException(\"Error while writing manifest\");\n+        }\n+    }\n+\n+    // Private Static functions for writing the Manifest file to a PrintWriter\n+\n+    private static void write_main_section(Attributes attr,\n+                                           PrintWriter pw)\n+        throws JarException {\n+\n+        write_version_info(attr, pw);\n+        write_main_attributes(attr, pw);\n+    }\n+\n+    private static void write_version_info(Attributes attr, PrintWriter pw) {\n+        // First check if there is already a version attribute set\n+        String version = attr.getValue(Attributes.Name.MANIFEST_VERSION);\n+        if (version == null) {\n+            version = \"1.0\";\n+        }\n+        write_header(Attributes.Name.MANIFEST_VERSION.toString(), version, pw);\n+    }\n+\n+    private static void write_header(String name, String value,\n+                                     PrintWriter pw) {\n+        pw.print(name + \": \");\n+\n+        int last = 68 - name.length();\n+        if (last > value.length()) {\n+            pw.println(value);\n+        } else {\n+            pw.println(value.substring(0, last));\n+        }\n+        while (last < value.length()) {\n+            pw.print(\" \");\n+            int end = (last + 69);\n+            if (end > value.length()) {\n+                pw.println(value.substring(last));\n+            } else {\n+                pw.println(value.substring(last, end));\n+            }\n+            last = end;\n+        }\n+    }\n+\n+    private static void write_main_attributes(Attributes attr,\n+                                              PrintWriter pw) throws\n+                                                              JarException {\n+        Iterator it = attr.entrySet().iterator();\n+        while(it.hasNext()) {\n+            Map.Entry entry = (Map.Entry)it.next();\n+            // Don't print the manifest version again\n+            if (!Attributes.Name.MANIFEST_VERSION.equals(entry.getKey())) {\n+                write_attribute_entry(entry, pw);\n+            }\n+        }\n+    }\n+\n+    private static void write_attribute_entry(Map.Entry entry,\n+                                              PrintWriter pw) throws\n+                                                              JarException {\n+        String name = entry.getKey().toString();\n+        String value = entry.getValue().toString();\n+\n+        if (name.equalsIgnoreCase(\"Name\")) {\n+            throw new JarException(\"Attributes cannot be called 'Name'\");\n+        }\n+        if (name.startsWith(\"From\")) {\n+            throw new JarException(\n+                        \"Header cannot start with the four letters 'From'\"\n+                        + name);\n+        }\n+        write_header(name, value, pw);\n+    }\n+\n+    private static void write_individual_sections(Map entries,\n+                                                  PrintWriter pw)\n+        throws JarException {\n+\n+        Iterator it = entries.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry entry = (Map.Entry)it.next();\n+            write_header(\"Name\", entry.getKey().toString(), pw);\n+            write_entry_attributes((Attributes)entry.getValue(), pw);\n+            pw.println();\n+        }\n+    }\n+\n+    private static void write_entry_attributes(Attributes attr,\n+                                               PrintWriter pw) throws\n+                                                               JarException {\n+        Iterator it = attr.entrySet().iterator();\n+        while(it.hasNext()) {\n+            Map.Entry entry = (Map.Entry)it.next();\n+            write_attribute_entry(entry, pw);\n+        }\n+    }\n+\n+    /**\n+     * Makes a deep copy of the main attributes, but a shallow copy of\n+     * the other entries. This means that you can freely add, change or remove\n+     * the main attributes or the entries of the new manifest without effecting\n+     * the original manifest, but adding, changing or removing attributes from\n+     * a particular entry also changes the attributes of that entry in the\n+     * original manifest. Calls <CODE>new Manifest(this)</CODE>.\n+     */\n+    public Object clone() {\n+        return new Manifest(this);\n+    }\n+\n+    /**\n+     * Checks if another object is equal to this Manifest object.\n+     * Another Object is equal to this Manifest object if it is an instance of\n+     * Manifest and the main attributes and the entries of the other manifest\n+     * are equal to this one.\n+     */\n+    public boolean equals(Object o) {\n+        return (o instanceof Manifest) &&\n+               (mainAttr.equals(((Manifest)o).mainAttr)) &&\n+               (entries.equals(((Manifest)o).entries));\n+    }\n+\n+    /**\n+     * Calculates the hash code of the manifest. Implemented by a xor of the\n+     * hash code of the main attributes with the hash code of the entries map.\n+     */\n+    public int hashCode() {\n+        return mainAttr.hashCode() ^ entries.hashCode();\n+    }\n+\n+}"}, {"sha": "3532096198291c27b4e8373fd4e1e615dd405901", "filename": "libjava/java/util/zip/ZipInputStream.java", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipInputStream.java?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -123,6 +123,12 @@ protected void fill () throws IOException\n       }\n   }\n \n+  protected ZipEntry createZipEntry (String name)\n+  {\n+    // FIXME - must figure out what this is supposed to do.\n+    return null;\n+  }\n+  \n   public int read (byte[] b, int off, int len)  throws IOException\n   {\n     if (len > avail)"}, {"sha": "da2b002c8234dd55e9c0f5348de5a8c05f0cda70", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a729a4e9aba7afb312ee0f15a70979ae75d1a9fe/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=a729a4e9aba7afb312ee0f15a70979ae75d1a9fe", "patch": "@@ -137,7 +137,7 @@ DIST_COMMON =  ChangeLog Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -165,7 +165,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}]}