{"sha": "27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdlYWM5ZWU2MTM3YTZiNWFlNjkzYjU0Y2FmYTIyYmRjMGNiY2Q1YQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-08-05T16:37:32Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-08-05T16:38:58Z"}, "message": "Static analysis for definition of DO index variables in contained procedures.\n\nWhen encountering a procedure call in a DO loop, this patch checks if\nthe call is to a contained procedure, and if it is, check for\nchanges in the index variable.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/96469\n\t* frontend-passes.c (doloop_contained_function_call): New\n\tfunction.\n\t(doloop_contained_procedure_code): New function.\n\t(CHECK_INQ): Macro for inquire checks.\n\t(doloop_code): Invoke doloop_contained_procedure_code and\n\tdoloop_contained_function_call if appropriate.\n\t(do_intent): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/96469\n\t* gfortran.dg/do_check_4.f90: Hide change in index variable\n\tfrom compile-time analysis.\n\t* gfortran.dg/do_check_13.f90: New test.", "tree": {"sha": "1391366f157fe03fe2f44d6dcdba23d28340fad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1391366f157fe03fe2f44d6dcdba23d28340fad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/comments", "author": null, "committer": null, "parents": [{"sha": "229752afe3156a3990dacaedb94c76846cebf132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229752afe3156a3990dacaedb94c76846cebf132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229752afe3156a3990dacaedb94c76846cebf132"}], "stats": {"total": 368, "additions": 357, "deletions": 11}, "files": [{"sha": "6bcb1f06b1c00ea5c7cdcf911424e4273d946094", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 256, "deletions": 2, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "patch": "@@ -2305,6 +2305,212 @@ optimize_minmaxloc (gfc_expr **e)\n   mpz_set_ui (a->expr->value.integer, 1);\n }\n \n+/* Data package to hand down for DO loop checks in a contained\n+   procedure.  */\n+typedef struct contained_info\n+{\n+  gfc_symbol *do_var;\n+  gfc_symbol *procedure;\n+  locus where_do;\n+} contained_info;\n+\n+static enum gfc_exec_op last_io_op;\n+\n+/* Callback function to check for INTENT(OUT) and INTENT(INOUT) in a\n+   contained function call.  */\n+\n+static int\n+doloop_contained_function_call (gfc_expr **e,\n+\t\t\t\tint *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n+{\n+  gfc_expr *expr = *e;\n+  gfc_formal_arglist *f;\n+  gfc_actual_arglist *a;\n+  gfc_symbol *sym, *do_var;\n+  contained_info *info;\n+\n+  if (expr->expr_type != EXPR_FUNCTION || expr->value.function.isym)\n+    return 0;\n+\n+  sym = expr->value.function.esym;\n+  f = gfc_sym_get_dummy_args (sym);\n+  if (f == NULL)\n+    return 0;\n+\n+  info = (contained_info *) data;\n+  do_var = info->do_var;\n+  a = expr->value.function.actual;\n+\n+  while (a && f)\n+    {\n+      if (a->expr && a->expr->symtree && a->expr->symtree->n.sym == do_var)\n+\t{\n+\t  if (f->sym->attr.intent == INTENT_OUT)\n+\t    {\n+\t      gfc_error_now (\"Index variable %qs set to undefined as \"\n+\t\t\t     \"INTENT(OUT) argument at %L in procedure %qs \"\n+\t\t\t     \"called from within DO loop at %L\", do_var->name,\n+\t\t\t     &a->expr->where, info->procedure->name,\n+\t\t\t     &info->where_do);\n+\t      return 1;\n+\t    }\n+\t  else if (f->sym->attr.intent == INTENT_INOUT)\n+\t    {\n+\t      gfc_error_now (\"Index variable %qs not definable as \"\n+\t\t\t     \"INTENT(INOUT) argument at %L in procedure %qs \"\n+\t\t\t     \"called from within DO loop at %L\", do_var->name,\n+\t\t\t     &a->expr->where, info->procedure->name,\n+\t\t\t     &info->where_do);\n+\t      return 1;\n+\t    }\n+\t}\n+      a = a->next;\n+      f = f->next;\n+    }\n+  return 0;\n+}\n+\n+/* Callback function that goes through the code in a contained\n+   procedure to make sure it does not change a variable in a DO\n+   loop.  */\n+\n+static int\n+doloop_contained_procedure_code (gfc_code **c,\n+\t\t\t\t int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t\t void *data)\n+{\n+  gfc_code *co = *c;\n+  contained_info *info = (contained_info *) data;\n+  gfc_symbol *do_var = info->do_var;\n+  const char *errmsg = _(\"Index variable %qs redefined at %L in procedure %qs \"\n+\t\t\t \"called from within DO loop at %L\");\n+  static enum gfc_exec_op saved_io_op;\n+\n+  switch (co->op)\n+    {\n+    case EXEC_ASSIGN:\n+      if (co->expr1->symtree->n.sym == do_var)\n+\tgfc_error_now (errmsg, do_var->name, &co->loc, info->procedure->name,\n+\t\t       &info->where_do);\n+      break;\n+\n+    case EXEC_DO:\n+      if (co->ext.iterator && co->ext.iterator->var\n+\t  && co->ext.iterator->var->symtree->n.sym == do_var)\n+\tgfc_error (errmsg, do_var->name, &co->loc, info->procedure->name,\n+\t\t   &info->where_do);\n+      break;\n+\n+    case EXEC_READ:\n+    case EXEC_WRITE:\n+    case EXEC_INQUIRE:\n+      saved_io_op = last_io_op;\n+      last_io_op = co->op;\n+      break;\n+\n+    case EXEC_OPEN:\n+      if (co->ext.open->iostat\n+\t  && co->ext.open->iostat->symtree->n.sym == do_var)\n+\tgfc_error_now (errmsg, do_var->name, &co->ext.open->iostat->where,\n+\t\t       info->procedure->name, &info->where_do);\n+      break;\n+\n+    case EXEC_CLOSE:\n+      if (co->ext.close->iostat\n+\t  && co->ext.close->iostat->symtree->n.sym == do_var)\n+\tgfc_error_now (errmsg, do_var->name, &co->ext.close->iostat->where,\n+\t\t       info->procedure->name, &info->where_do);\n+      break;\n+\n+    case EXEC_TRANSFER:\n+      switch (last_io_op)\n+\t{\n+\n+\tcase EXEC_INQUIRE:\n+#define CHECK_INQ(a) do { if (co->ext.inquire->a &&\t\t\t\\\n+\t\t\t      co->ext.inquire->a->symtree->n.sym == do_var) \\\n+\t      gfc_error_now (errmsg, do_var->name,\t\t\t\\\n+\t\t\t     &co->ext.inquire->a->where,\t\t\\\n+\t\t\t     info->procedure->name,\t\t\t\\\n+\t\t\t     &info->where_do);\t\t\t\t\\\n+\t  } while (0)\n+\n+\t  CHECK_INQ(iostat);\n+\t  CHECK_INQ(number);\n+\t  CHECK_INQ(position);\n+\t  CHECK_INQ(recl);\n+\t  CHECK_INQ(position);\n+\t  CHECK_INQ(iolength);\n+\t  CHECK_INQ(strm_pos);\n+\t  break;\n+#undef CHECK_INQ\n+\n+\tcase EXEC_READ:\n+\t  if (co->expr1 && co->expr1->symtree->n.sym == do_var)\n+\t    gfc_error_now (errmsg, do_var->name, &co->expr1->where,\n+\t\t\t   info->procedure->name, &info->where_do);\n+\n+\t  /* Fallthrough.  */\n+\n+\tcase EXEC_WRITE:\n+\t  if (co->ext.dt->iostat\n+\t      && co->ext.dt->iostat->symtree->n.sym == do_var)\n+\t    gfc_error_now (errmsg, do_var->name, &co->ext.dt->iostat->where,\n+\t\t\t   info->procedure->name, &info->where_do);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case EXEC_DT_END:\n+      last_io_op = saved_io_op;\n+      break;\n+\n+    case EXEC_CALL:\n+      gfc_formal_arglist *f;\n+      gfc_actual_arglist *a;\n+\n+      f = gfc_sym_get_dummy_args (co->resolved_sym);\n+      if (f == NULL)\n+\tbreak;\n+      a = co->ext.actual;\n+      /* Slightly different error message here. If there is an error,\n+\t return 1 to avoid an infinite loop.  */\n+      while (a && f)\n+\t{\n+\t  if (a->expr && a->expr->symtree && a->expr->symtree->n.sym == do_var)\n+\t    {\n+\t      if (f->sym->attr.intent == INTENT_OUT)\n+\t\t{\n+\t\t  gfc_error_now (\"Index variable %qs set to undefined as \"\n+\t\t\t\t \"INTENT(OUT) argument at %L in subroutine %qs \"\n+\t\t\t\t \"called from within DO loop at %L\",\n+\t\t\t\t do_var->name, &a->expr->where,\n+\t\t\t\t info->procedure->name, &info->where_do);\n+\t\t  return 1;\n+\t\t}\n+\t      else if (f->sym->attr.intent == INTENT_INOUT)\n+\t\t{\n+\t\t  gfc_error_now (\"Index variable %qs not definable as \"\n+\t\t\t\t \"INTENT(INOUT) argument at %L in subroutine %qs \"\n+\t\t\t\t \"called from within DO loop at %L\", do_var->name,\n+\t\t\t\t &a->expr->where, info->procedure->name,\n+\t\t\t\t &info->where_do);\n+\t\t  return 1;\n+\t\t}\n+\t    }\n+\t  a = a->next;\n+\t  f = f->next;\n+\t}\n+      break;\n+    default:\n+      break;\n+    }\n+  return 0;\n+}\n+\n /* Callback function for code checking that we do not pass a DO variable to an\n    INTENT(OUT) or INTENT(INOUT) dummy variable.  */\n \n@@ -2389,10 +2595,32 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n       break;\n \n     case EXEC_CALL:\n-\n       if (co->resolved_sym == NULL)\n \tbreak;\n \n+      /* Test if somebody stealthily changes the DO variable from\n+\t under us by changing it in a host-associated procedure.  */\n+      if (co->resolved_sym->attr.contained)\n+\t{\n+\t  FOR_EACH_VEC_ELT (doloop_list, i, lp)\n+\t    {\n+\t      gfc_symbol *sym = co->resolved_sym;\n+\t      contained_info info;\n+\t      gfc_namespace *ns;\n+\n+\t      cl = lp->c;\n+\t      info.do_var = cl->ext.iterator->var->symtree->n.sym;\n+\t      info.procedure = co->resolved_sym;  /* sym? */\n+\t      info.where_do = co->loc;\n+\t      /* Look contained procedures under the namespace of the\n+\t\t variable.  */\n+\t      for (ns = info.do_var->ns->contained; ns; ns = ns->sibling)\n+\t\tif (ns->proc_name && ns->proc_name == sym)\n+\t\t  gfc_code_walker (&ns->code, doloop_contained_procedure_code,\n+\t\t\t\t   doloop_contained_function_call, &info);\n+\t    }\n+\t}\n+\n       f = gfc_sym_get_dummy_args (co->resolved_sym);\n \n       /* Withot a formal arglist, there is only unknown INTENT,\n@@ -2436,6 +2664,7 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  a = a->next;\n \t  f = f->next;\n \t}\n+\n       break;\n \n     default:\n@@ -2737,6 +2966,7 @@ do_intent (gfc_expr **e)\n   gfc_code *dl;\n   do_t *lp;\n   int i;\n+  gfc_symbol *sym;\n \n   expr = *e;\n   if (expr->expr_type != EXPR_FUNCTION)\n@@ -2747,7 +2977,31 @@ do_intent (gfc_expr **e)\n   if (expr->value.function.isym)\n     return 0;\n \n-  f = gfc_sym_get_dummy_args (expr->symtree->n.sym);\n+  sym = expr->value.function.esym;\n+  if (sym == NULL)\n+    return 0;\n+\n+  if (sym->attr.contained)\n+    {\n+      FOR_EACH_VEC_ELT (doloop_list, i, lp)\n+\t{\n+\t  contained_info info;\n+\t  gfc_namespace *ns;\n+\n+\t  dl = lp->c;\n+\t  info.do_var = dl->ext.iterator->var->symtree->n.sym;\n+\t  info.procedure = sym;\n+\t  info.where_do = expr->where;\n+\t  /* Look contained procedures under the namespace of the\n+\t\t variable.  */\n+\t  for (ns = info.do_var->ns->contained; ns; ns = ns->sibling)\n+\t    if (ns->proc_name && ns->proc_name == sym)\n+\t      gfc_code_walker (&ns->code, doloop_contained_procedure_code,\n+\t\t\t       dummy_expr_callback, &info);\n+\t}\n+    }\n+\n+  f = gfc_sym_get_dummy_args (sym);\n \n   /* Without a formal arglist, there is only unknown INTENT,\n      which we don't check for.  */"}, {"sha": "5ff7cdb4bb4b9529e879f968a5ce113eff5c02c0", "filename": "gcc/testsuite/gfortran.dg/do_check_13.f90", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_13.f90?ref=27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "patch": "@@ -0,0 +1,86 @@\n+program main\n+  implicit none\n+  integer :: i1, i2, i3, i4, i5, i6, i7\n+  integer :: j\n+  do i1=1,10\n+     call sub1 ! { dg-error \"Index variable 'i1' redefined\" }\n+  end do\n+  do i2=1,10\n+     call sub2 ! { dg-error \"Index variable 'i2' redefined\" }\n+  end do\n+  do i3=1,10\n+     j = fcn3() ! { dg-error \"Index variable 'i3' redefined\" }\n+  end do\n+  do i4=1,10\n+     j = fcn4() ! { dg-error \"Index variable 'i4' redefined\" }\n+  end do\n+  do i5=1,10\n+     call sub5 ! { dg-error \"Index variable 'i5' set to undefined\" }\n+  end do\n+\n+  call sub6\n+\n+  do i7=1,10\n+     call sub7 ! { dg-error \"Index variable 'i7' not definable\" }\n+  end do\n+contains\n+  subroutine sub1\n+    i1 = 5 ! { dg-error \"Index variable 'i1' redefined\" }\n+  end subroutine sub1\n+\n+  subroutine sub2\n+    do i2=1,5 ! { dg-error \"Index variable 'i2' redefined\" }\n+    end do\n+  end subroutine sub2\n+  \n+  integer function fcn3()\n+    i3 = 1 ! { dg-error \"Index variable 'i3' redefined\" }\n+    fcn3 = i3\n+  end function fcn3\n+\n+  integer function fcn4()\n+    open (10,file=\"foo.dat\", iostat=i4) ! { dg-error \"Index variable 'i4' redefined\" }\n+    fcn4 = 12\n+  end function fcn4\n+\n+  subroutine sub5\n+    integer :: k\n+    k = intentout(i5) ! { dg-error \"Index variable 'i5' set to undefined\" }\n+  end subroutine sub5\n+\n+  subroutine sub6\n+    do i6=1,10\n+       call sub6a ! { dg-error \"Index variable 'i6' redefined\" }\n+    end do\n+  end subroutine sub6\n+\n+  subroutine sub6a\n+    i6 = 5   ! { dg-error \"Index variable 'i6' redefined\" }\n+  end subroutine sub6a\n+\n+  subroutine sub7\n+    integer :: k\n+    k = intentinout (i7)  ! { dg-error \"Index variable 'i7' not definable\" }\n+  end subroutine sub7\n+  \n+  integer function intentout(i)\n+    integer, intent(out) :: i\n+  end function intentout\n+\n+  integer function intentinout(i)\n+    integer, intent(inout) :: i\n+  end function intentinout\n+end program main\n+\n+module foo\n+  integer :: j1\n+contains\n+  subroutine mod_sub_1\n+    do j1=1,10\n+       call aux ! { dg-error \"Index variable 'j1' redefined\" }\n+    end do\n+  end subroutine mod_sub_1\n+  subroutine aux\n+    j1 = 3  ! { dg-error \"Index variable 'j1' redefined\" }\n+  end subroutine aux\n+end module foo"}, {"sha": "5b087e4dde33d955ae38f9a977170bb68f5e6fda", "filename": "gcc/testsuite/gfortran.dg/do_check_4.f90", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_4.f90?ref=27eac9ee6137a6b5ae693b54cafa22bdc0cbcd5a", "patch": "@@ -5,17 +5,23 @@\n ! PR fortran/34656\n ! Run-time check for modifing loop variables\n !\n+\n+module x\n+  integer :: i\n+contains\n+  SUBROUTINE do_something()\n+    IMPLICIT NONE\n+    DO i=1,10\n+    ENDDO\n+  END SUBROUTINE do_something\n+end module x\n+\n PROGRAM test\n+  use x\n   IMPLICIT NONE\n-  INTEGER :: i\n   DO i=1,100\n-    CALL do_something()\n+     CALL do_something()\n   ENDDO\n-CONTAINS\n- SUBROUTINE do_something()\n- IMPLICIT NONE\n-   DO i=1,10\n-   ENDDO\n- END SUBROUTINE do_something\n-END PROGRAM test\n+end PROGRAM test\n+\n ! { dg-output \"Fortran runtime error: Loop variable has been modified\" }"}]}