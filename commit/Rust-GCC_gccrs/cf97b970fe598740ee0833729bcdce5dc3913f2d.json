{"sha": "cf97b970fe598740ee0833729bcdce5dc3913f2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y5N2I5NzBmZTU5ODc0MGVlMDgzMzcyOWJjZGNlNWRjMzkxM2YyZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-09T12:52:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-09T12:56:47Z"}, "message": "c++: Decl module-specific semantic processing\n\nThis adds the module-specific logic to the various declaration\nprocessing routines in decl.c and semantic.c.  I also adjust the rtti\ntype creation, as those are all in the global module, so we need to\ntemporarily clear the module_kind, when they are being created.\nFinally, I added init and fini module processing with the initialier\ngiving a fatal error if you try and turn it on (so don't do that yet).\n\n\tgcc/cp/\n\t* decl.c (duplicate_decls): Add module-specific redeclaration\n\tlogic.\n\t(cxx_init_decl_processing): Export the global namespace, maybe\n\tinitialize modules.\n\t(start_decl): Reject local-extern in a module, adjust linkage of\n\ttemplate var.\n\t(xref_tag_1): Add module-specific redeclaration logic.\n\t(start_enum): Likewise.\n\t(finish_enum_value_list): Export unscoped members of an exported\n\tenum.\n\t(grokmethod): Implement p1779 linkage of in-class defined\n\tfunctions.\n\t* decl2.c (no_linkage_error): Imports are ok.\n\t(c_parse_final_cleanups): Call fini_modules.\n\t* lex.c (cxx_dup_lang_specific): Clear some module flags in the\n\tcopy.\n\t* module.cc (module_kind): Define.\n\t(module_may_redeclare, set_defining_module): Stubs.\n\t(init_modules): Error on modules.\n\t(fini_modules): Stub.\n\t* rtti.c (push_abi_namespace): Save and reset module_kind.\n\t(pop_abi_namespace): Restore module kind.\n\t(build_dynamic_cast_1, tinfo_base_init): Adjust.\n\t* semantics.c (begin_class_definition): Add module-specific logic.\n\t(expand_or_defer_fn_1): Keep bodies of more fns when modules_p.", "tree": {"sha": "4ab0ae5991d8bceef81fc69d7457c9b21fea2adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab0ae5991d8bceef81fc69d7457c9b21fea2adf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf97b970fe598740ee0833729bcdce5dc3913f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf97b970fe598740ee0833729bcdce5dc3913f2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf97b970fe598740ee0833729bcdce5dc3913f2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf97b970fe598740ee0833729bcdce5dc3913f2d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72217b5ddb2a15e2606f4b15b147dd59fe8e6216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72217b5ddb2a15e2606f4b15b147dd59fe8e6216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72217b5ddb2a15e2606f4b15b147dd59fe8e6216"}], "stats": {"total": 220, "additions": 205, "deletions": 15}, "files": [{"sha": "ae93fe1d7f0747c92da0559d630a66ce3f3d837a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 141, "deletions": 8, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cf97b970fe598740ee0833729bcdce5dc3913f2d", "patch": "@@ -2008,6 +2008,39 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n   if (!validate_constexpr_redeclaration (olddecl, newdecl))\n     return error_mark_node;\n \n+  if (modules_p ()\n+      && TREE_CODE (CP_DECL_CONTEXT (olddecl)) == NAMESPACE_DECL\n+      && TREE_CODE (olddecl) != NAMESPACE_DECL\n+      && !hiding)\n+    {\n+      if (DECL_ARTIFICIAL (olddecl))\n+\t{\n+\t  gcc_checking_assert (!(DECL_LANG_SPECIFIC (olddecl)\n+\t\t\t\t && DECL_MODULE_IMPORT_P (olddecl)));\n+\t  if (!(global_purview_p () || not_module_p ()))\n+\t    error (\"declaration %qD conflicts with builtin\", newdecl);\n+\t  else\n+\t    DECL_MODULE_EXPORT_P (olddecl) = DECL_MODULE_EXPORT_P (newdecl);\n+\t}\n+      else\n+\t{\n+\t  if (!module_may_redeclare (olddecl))\n+\t    {\n+\t      error (\"declaration %qD conflicts with import\", newdecl);\n+\t      inform (olddecl_loc, \"import declared %q#D here\", olddecl);\n+\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  if (DECL_MODULE_EXPORT_P (newdecl)\n+\t      && !DECL_MODULE_EXPORT_P (olddecl))\n+\t    {\n+\t      error (\"conflicting exporting declaration %qD\", newdecl);\n+\t      inform (olddecl_loc, \"previous declaration %q#D here\", olddecl);\n+\t    }\n+\t}\n+    }\n+\n   /* We have committed to returning OLDDECL at this point.  */\n \n   /* If new decl is `static' and an `extern' was seen previously,\n@@ -2218,6 +2251,10 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n \t    }\n \t}\n \n+      DECL_MODULE_IMPORT_P (olddecl)\n+\t= DECL_MODULE_IMPORT_P (old_result)\n+\t= DECL_MODULE_IMPORT_P (newdecl);\n+\n       return olddecl;\n     }\n \n@@ -2836,6 +2873,20 @@ duplicate_decls (tree newdecl, tree olddecl, bool hiding, bool was_hidden)\n       memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t      (char *) newdecl + sizeof (struct tree_common),\n \t      sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n+\n+      if (DECL_LANG_SPECIFIC (olddecl) && DECL_TEMPLATE_INFO (olddecl))\n+\t{\n+\t  /* Repropagate the module information to the template.  */\n+\t  tree tmpl = DECL_TI_TEMPLATE (olddecl);\n+\n+\t  if (DECL_TEMPLATE_RESULT (tmpl) == olddecl)\n+\t    {\n+\t      DECL_MODULE_PURVIEW_P (tmpl) = DECL_MODULE_PURVIEW_P (olddecl);\n+\t      gcc_checking_assert (!DECL_MODULE_IMPORT_P (olddecl));\n+\t      DECL_MODULE_IMPORT_P (tmpl) = false;\n+\t    }\n+\t}\n+\n       switch (TREE_CODE (newdecl))\n \t{\n \tcase LABEL_DECL:\n@@ -4330,7 +4381,8 @@ cxx_init_decl_processing (void)\n   gcc_assert (global_namespace == NULL_TREE);\n   global_namespace = build_lang_decl (NAMESPACE_DECL, global_identifier,\n \t\t\t\t      void_type_node);\n-  TREE_PUBLIC (global_namespace) = 1;\n+  TREE_PUBLIC (global_namespace) = true;\n+  DECL_MODULE_EXPORT_P (global_namespace) = true;\n   DECL_CONTEXT (global_namespace)\n     = build_translation_unit_decl (get_identifier (main_input_filename));\n   /* Remember whether we want the empty class passing ABI change warning\n@@ -4629,6 +4681,9 @@ cxx_init_decl_processing (void)\n   if (! supports_one_only ())\n     flag_weak = 0;\n \n+  if (modules_p ())\n+    init_modules (parse_in);\n+\n   make_fname_decl = cp_make_fname_decl;\n   start_fname_decls ();\n \n@@ -5453,8 +5508,14 @@ start_decl (const cp_declarator *declarator,\n \n   if ((DECL_EXTERNAL (decl) || TREE_CODE (decl) == FUNCTION_DECL)\n       && current_function_decl)\n-    /* A function-scope decl of some namespace-scope decl.  */\n-    DECL_LOCAL_DECL_P (decl) = true;\n+    {\n+      /* A function-scope decl of some namespace-scope decl.  */\n+      DECL_LOCAL_DECL_P (decl) = true;\n+      if (named_module_purview_p ())\n+\terror_at (declarator->id_loc,\n+\t\t  \"block-scope extern declaration %q#D not permitted\"\n+\t\t  \" in module purview\", decl);\n+    }\n \n   /* Enter this declaration into the symbol table.  Don't push the plain\n      VAR_DECL for a variable template.  */\n@@ -5470,7 +5531,9 @@ start_decl (const cp_declarator *declarator,\n \n   if (VAR_P (decl)\n       && DECL_NAMESPACE_SCOPE_P (decl) && !TREE_PUBLIC (decl) && !was_public\n-      && !DECL_THIS_STATIC (decl) && !DECL_ARTIFICIAL (decl))\n+      && !DECL_THIS_STATIC (decl) && !DECL_ARTIFICIAL (decl)\n+      /* But not templated variables.  */\n+      && !(DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)))\n     {\n       /* This is a const variable with implicit 'static'.  Set\n \t DECL_THIS_STATIC so we can tell it from variables that are\n@@ -15143,6 +15206,41 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n \t  inform (location_of (t), \"previous declaration %qD\", t);\n \t  return error_mark_node;\n \t}\n+\n+      if (modules_p ()\n+\t  && how == TAG_how::CURRENT_ONLY)\n+\t{\n+\t  tree decl = TYPE_NAME (t);\n+\t  if (!module_may_redeclare (decl))\n+\t    {\n+\t      error (\"cannot declare %qD in a different module\", decl);\n+\t      inform (DECL_SOURCE_LOCATION (decl), \"declared here\");\n+\t      return error_mark_node;\n+\t    }\n+\n+\t  tree maybe_tmpl = decl;\n+\t  if (CLASS_TYPE_P (t) && CLASSTYPE_IS_TEMPLATE (t))\n+\t    maybe_tmpl = CLASSTYPE_TI_TEMPLATE (t);\n+\n+\t  if (DECL_LANG_SPECIFIC (decl)\n+\t      && DECL_MODULE_IMPORT_P (decl)\n+\t      && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n+\t    {\n+\t      /* Push it into this TU's symbol slot.  */\n+\t      gcc_checking_assert (current_namespace == CP_DECL_CONTEXT (decl));\n+\t      if (maybe_tmpl != decl)\n+\t\t/* We're in the template parm binding level.\n+\t\t   Pushtag has logic to slide under that, but we're\n+\t\t   not pushing a *new* type.  */\n+\t\tpush_nested_namespace (CP_DECL_CONTEXT (decl));\n+\n+\t      pushdecl (maybe_tmpl);\n+\t      if (maybe_tmpl != decl)\n+\t\tpop_nested_namespace (CP_DECL_CONTEXT (decl));\n+\t    }\n+\n+\t  set_instantiating_module (maybe_tmpl);\n+\t}\n     }\n \n   return t;\n@@ -15487,6 +15585,19 @@ start_enum (tree name, tree enumtype, tree underlying_type,\n \t\t  \"previous definition here\");\n \t  underlying_type = NULL_TREE;\n \t}\n+\n+      if (modules_p ())\n+\t{\n+\t  if (!module_may_redeclare (TYPE_NAME (enumtype)))\n+\t    {\n+\t      error (\"cannot define %qD in different module\",\n+\t\t     TYPE_NAME (enumtype));\n+\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (enumtype)),\n+\t\t      \"declared here\");\n+\t      enumtype = error_mark_node;\n+\t    }\n+\t  set_instantiating_module (TYPE_NAME (enumtype));\n+\t}\n     }\n \n   if (!enumtype || TREE_CODE (enumtype) != ENUMERAL_TYPE\n@@ -15747,6 +15858,11 @@ finish_enum_value_list (tree enumtype)\n   else\n     underlying_type = ENUM_UNDERLYING_TYPE (enumtype);\n \n+  /* If the enum is exported, mark the consts too.  */\n+  bool export_p = (UNSCOPED_ENUM_P (enumtype)\n+\t\t   && DECL_MODULE_EXPORT_P (TYPE_STUB_DECL (enumtype))\n+\t\t   && at_namespace_scope_p ());\n+\n   /* Convert each of the enumerators to the type of the underlying\n      type of the enumeration.  */\n   for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))\n@@ -15769,6 +15885,8 @@ finish_enum_value_list (tree enumtype)\n \t  TREE_TYPE (value) = enumtype;\n \t}\n       DECL_INITIAL (decl) = value;\n+      if (export_p)\n+\tDECL_MODULE_EXPORT_P (decl) = true;\n     }\n \n   /* Fix up all variant types of this enum type.  */\n@@ -17366,10 +17484,25 @@ grokmethod (cp_decl_specifier_seq *declspecs,\n \n   check_template_shadow (fndecl);\n \n-  if (TREE_PUBLIC (fndecl))\n-    DECL_COMDAT (fndecl) = 1;\n-  DECL_DECLARED_INLINE_P (fndecl) = 1;\n-  DECL_NO_INLINE_WARNING_P (fndecl) = 1;\n+  /* p1779 ABI-Isolation makes inline not a default for in-class\n+     definitions in named module purview.  If the user explicitly\n+     made it inline, grokdeclarator will already have done the right\n+     things.  */\n+  if ((!named_module_purview_p ()\n+       || flag_module_implicit_inline\n+      /* Lambda's operator function remains inline.  */\n+       || LAMBDA_TYPE_P (DECL_CONTEXT (fndecl)))\n+      /* If the user explicitly asked for this to be inline, we don't\n+\t need to do more, but more importantly we want to warn if we\n+\t can't inline it.  */\n+      && !DECL_DECLARED_INLINE_P (fndecl))\n+    {\n+      if (TREE_PUBLIC (fndecl))\n+\tDECL_COMDAT (fndecl) = 1;\n+      DECL_DECLARED_INLINE_P (fndecl) = 1;\n+      /* It's ok if we can't inline this.  */\n+      DECL_NO_INLINE_WARNING_P (fndecl) = 1;\n+    }\n \n   /* We process method specializations in finish_struct_1.  */\n   if (processing_template_decl && !DECL_TEMPLATE_SPECIALIZATION (fndecl))"}, {"sha": "c122017c2faee8317c900762a13c20cdb6c0902d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cf97b970fe598740ee0833729bcdce5dc3913f2d", "patch": "@@ -4531,6 +4531,10 @@ no_linkage_error (tree decl)\n     /* In C++11 it's ok if the decl is defined.  */\n     return;\n \n+  if (DECL_LANG_SPECIFIC (decl) && DECL_MODULE_IMPORT_P (decl))\n+    /* An imported decl is ok.  */\n+    return;\n+\n   tree t = no_linkage_check (TREE_TYPE (decl), /*relaxed_p=*/false);\n   if (t == NULL_TREE)\n     /* The type that got us on no_linkage_decls must have gotten a name for\n@@ -5226,6 +5230,8 @@ c_parse_final_cleanups (void)\n   if (priority_info_map)\n     splay_tree_delete (priority_info_map);\n \n+  fini_modules ();\n+\n   /* Generate any missing aliases.  */\n   maybe_apply_pending_pragma_weaks ();\n "}, {"sha": "339ed479a9a37a1cf4989823f7fc7862d0aae81d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cf97b970fe598740ee0833729bcdce5dc3913f2d", "patch": "@@ -1006,6 +1006,12 @@ cxx_dup_lang_specific_decl (tree node)\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;\n \n+  /* Directly clear some flags that do not apply to the copy\n+     (module_purview_p still does).  */\n+  ld->u.base.module_entity_p = false;\n+  ld->u.base.module_import_p = false;\n+  ld->u.base.module_pending_p = false;\n+  \n   if (GATHER_STATISTICS)\n     {\n       tree_node_counts[(int)lang_decl] += 1;"}, {"sha": "a961e3bcc92ad6aad835887d1cbb8e4299d5cea1", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=cf97b970fe598740ee0833729bcdce5dc3913f2d", "patch": "@@ -65,6 +65,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"langhooks.h\"\n \n+/* What the current TU is.  */\n+unsigned module_kind;\n+\n module_state *\n get_module (tree, module_state *, bool)\n {\n@@ -99,11 +102,22 @@ get_originating_module (tree, bool)\n   return 0;\n }\n \n+bool\n+module_may_redeclare (tree)\n+{\n+  return true;\n+}\n+\n void\n set_instantiating_module (tree)\n {\n }\n \n+void\n+set_defining_module (tree)\n+{\n+}\n+\n void\n set_originating_module (tree, bool)\n {\n@@ -120,3 +134,16 @@ preprocessed_module (cpp_reader *)\n {\n }\n \n+void\n+init_modules (cpp_reader *)\n+{\n+  /* Do not turn on yet.  */\n+  if (modules_p ())\n+    fatal_error (input_location,\n+\t\t \"Shtopp! What are you doing? This is not ready yet.\");\n+}\n+\n+void\n+fini_modules ()\n+{\n+}"}, {"sha": "0be9eff54adbe57e16f038e5704e477943ca11c9", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=cf97b970fe598740ee0833729bcdce5dc3913f2d", "patch": "@@ -143,16 +143,20 @@ static bool typeinfo_in_lib_p (tree);\n \n static int doing_runtime = 0;\n \f\n-static void\n+static unsigned\n push_abi_namespace (void)\n {\n   push_nested_namespace (abi_node);\n   push_visibility (\"default\", 2);\n+  unsigned flags = module_kind;\n+  module_kind = 0;\n+  return flags;\n }\n \n static void\n-pop_abi_namespace (void)\n+pop_abi_namespace (unsigned flags)\n {\n+  module_kind = flags;\n   pop_visibility (2);\n   pop_nested_namespace (abi_node);\n }\n@@ -765,7 +769,7 @@ build_dynamic_cast_1 (location_t loc, tree type, tree expr,\n \t  dcast_fn = dynamic_cast_node;\n \t  if (!dcast_fn)\n \t    {\n-\t      push_abi_namespace ();\n+\t      unsigned flags = push_abi_namespace ();\n \t      tree tinfo_ptr = xref_tag (class_type,\n \t\t\t\t\t get_identifier (\"__class_type_info\"));\n \t      tinfo_ptr = cp_build_qualified_type (tinfo_ptr, TYPE_QUAL_CONST);\n@@ -780,7 +784,7 @@ build_dynamic_cast_1 (location_t loc, tree type, tree expr,\n \t\t\t       NULL_TREE));\n \t      dcast_fn = (build_library_fn_ptr\n \t\t\t  (fn_name, fn_type, ECF_LEAF | ECF_PURE | ECF_NOTHROW));\n-\t      pop_abi_namespace ();\n+\t      pop_abi_namespace (flags);\n \t      dynamic_cast_node = dcast_fn;\n \t    }\n \t  result = build_cxx_call (dcast_fn, 4, elems, complain);\n@@ -954,11 +958,11 @@ tinfo_base_init (tinfo_s *ti, tree target)\n   vtable_ptr = ti->vtable;\n   if (!vtable_ptr)\n     {\n-      push_abi_namespace ();\n+      int flags = push_abi_namespace ();\n       tree real_type = xref_tag (class_type, ti->name);\n       tree real_decl = TYPE_NAME (real_type);\n       DECL_SOURCE_LOCATION (real_decl) = BUILTINS_LOCATION;\n-      pop_abi_namespace ();\n+      pop_abi_namespace (flags);\n \n       if (!COMPLETE_TYPE_P (real_type))\n \t{"}, {"sha": "92e32c8e0ad8601e91a41cd3dbcdb187d32814be", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf97b970fe598740ee0833729bcdce5dc3913f2d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cf97b970fe598740ee0833729bcdce5dc3913f2d", "patch": "@@ -3220,6 +3220,19 @@ begin_class_definition (tree t)\n       t = make_class_type (TREE_CODE (t));\n       pushtag (TYPE_IDENTIFIER (t), t);\n     }\n+\n+  if (modules_p ())\n+    {\n+      if (!module_may_redeclare (TYPE_NAME (t)))\n+\t{\n+\t  error (\"cannot declare %qD in a different module\", TYPE_NAME (t));\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t)), \"declared here\");\n+\t  return error_mark_node;\n+\t}\n+      set_instantiating_module (TYPE_NAME (t));\n+      set_defining_module (TYPE_NAME (t));\n+    }\n+\n   maybe_process_partial_specialization (t);\n   pushclass (t);\n   TYPE_BEING_DEFINED (t) = 1;\n@@ -4506,7 +4519,8 @@ expand_or_defer_fn_1 (tree fn)\n \t it out, even though we haven't.  */\n       TREE_ASM_WRITTEN (fn) = 1;\n       /* If this is a constexpr function, keep DECL_SAVED_TREE.  */\n-      if (!DECL_DECLARED_CONSTEXPR_P (fn))\n+      if (!DECL_DECLARED_CONSTEXPR_P (fn)\n+\t  && !(modules_p () && DECL_DECLARED_INLINE_P (fn)))\n \tDECL_SAVED_TREE (fn) = NULL_TREE;\n       return false;\n     }"}]}