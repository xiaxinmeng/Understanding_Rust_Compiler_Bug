{"sha": "708cae97714cec1d3ec97cc9a07873493487614a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4Y2FlOTc3MTRjZWMxZDNlYzk3Y2M5YTA3ODczNDkzNDg3NjE0YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-07-02T03:00:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-07-02T03:00:03Z"}, "message": "init.c (init_init_processing): Go back to aligning like double_type_node for old ABI.\n\n        * init.c (init_init_processing): Go back to aligning like\n        double_type_node for old ABI.\n        (get_cookie_size): Make cookie larger if we get a type that needs\n        more alignment.\n        (build_vec_delete): Call it.\n\n        * typeck.c (qualify_type_recursive): New fn.\n        (composite_pointer_type): Use it.\n        (build_binary_op): Use composite_pointer_type.\n\n        * typeck.c (check_return_expr): Don't complain about returning\n        NULL from operator new if -fcheck-new.\n        * cp-tree.h: Declare flag_check_new here.\n        * init.c: Not here.\n\nFrom-SVN: r34824", "tree": {"sha": "10c70dd56e95e2971c8f48dcb3d995ac7024f3ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10c70dd56e95e2971c8f48dcb3d995ac7024f3ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/708cae97714cec1d3ec97cc9a07873493487614a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708cae97714cec1d3ec97cc9a07873493487614a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708cae97714cec1d3ec97cc9a07873493487614a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708cae97714cec1d3ec97cc9a07873493487614a/comments", "author": null, "committer": null, "parents": [{"sha": "792a328b3b91a03068709a0697fe1308af326592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792a328b3b91a03068709a0697fe1308af326592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792a328b3b91a03068709a0697fe1308af326592"}], "stats": {"total": 20886, "additions": 108, "deletions": 20778}, "files": [{"sha": "a1d99de36aecf55c06cea49ba61e46eed98ad2c7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 20675, "changes": 20695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=708cae97714cec1d3ec97cc9a07873493487614a"}, {"sha": "373114f3aca479845af5813e01995e392a51eee2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -1223,6 +1223,11 @@ extern int flag_enforce_eh_specs;\n \n extern int flag_access_control;\n \n+/* Nonzero if we want to check the return value of new and avoid calling\n+   constructors if it is a null pointer.  */\n+\n+extern int flag_check_new;\n+\n /* If this variable is defined to a non-NULL value, it will be called\n    after the file has been completely parsed.  The argument will be\n    the GLOBAL_NAMESPACE.  */"}, {"sha": "1f21f4ee490142dce8378e97b80ebb4948911bae", "filename": "gcc/cp/init.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -58,7 +58,7 @@ static tree build_vtbl_address PARAMS ((tree));\n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n \n-static tree BI_header_type, BI_header_size;\n+static tree BI_header_type;\n \n void init_init_processing ()\n {\n@@ -71,16 +71,10 @@ void init_init_processing ()\n   BI_header_type = make_aggr_type (RECORD_TYPE);\n   fields[0] = build_decl (FIELD_DECL, nelts_identifier, sizetype);\n \n-  /* Use the biggest alignment supported by the target to prevent operator\n-     new from returning misaligned pointers. */\n-  TYPE_ALIGN (BI_header_type) = BIGGEST_ALIGNMENT;\n-  TYPE_USER_ALIGN (BI_header_type) = 0;\n   finish_builtin_type (BI_header_type, \"__new_cookie\", fields,\n-\t\t       0, BI_header_type);\n-  BI_header_size = size_in_bytes (BI_header_type);\n+\t\t       0, double_type_node);\n \n   ggc_add_tree_root (&BI_header_type, 1);\n-  ggc_add_tree_root (&BI_header_size, 1);\n }\n \n /* We are about to generate some complex initialization code.\n@@ -1975,8 +1969,6 @@ build_builtin_delete_call (addr)\n \n    PLACEMENT is the `placement' list for user-defined operator new ().  */\n \n-extern int flag_check_new;\n-\n tree\n build_new (placement, decl, init, use_global_new)\n      tree placement;\n@@ -2205,7 +2197,12 @@ get_cookie_size (type)\n \tcookie_size = type_align;\n     }\n   else\n-    cookie_size = BI_header_size;\n+    {\n+      if (TYPE_ALIGN (type) > TYPE_ALIGN (BI_header_type))\n+\treturn size_int (TYPE_ALIGN_UNIT (type));\n+      else\n+\treturn size_in_bytes (BI_header_type);\n+    }\n \n   return cookie_size;\n }\n@@ -2385,8 +2382,8 @@ build_new_1 (exp)\n   else\n     alloc_expr = NULL_TREE;\n \n-  /* if rval is NULL_TREE I don't have to allocate it, but are we totally\n-     sure we have some extra bytes in that case for the BI_header_size\n+  /* if rval is NULL_TREE I don't have to allocate it, but are we\n+     totally sure we have some extra bytes in that case for the\n      cookies? And how does that interact with the code below? (mrs) */\n   /* Finish up some magic for new'ed arrays */\n   if (use_cookie && rval != NULL_TREE)\n@@ -2633,7 +2630,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n       goto no_destructor;\n     }\n \n-  /* The below is short by BI_header_size */\n+  /* The below is short by the cookie size.  */\n   virtual_size = size_binop (MULT_EXPR, size_exp,\n \t\t\t     convert (sizetype, maxindex));\n \n@@ -2676,7 +2673,7 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n     {\n       tree base_tbd;\n \n-      /* The below is short by BI_header_size */\n+      /* The below is short by the cookie size.  */\n       virtual_size = size_binop (MULT_EXPR, size_exp,\n \t\t\t\t convert (sizetype, maxindex));\n \n@@ -3378,6 +3375,7 @@ build_vec_delete (base, maxindex, auto_delete_vec, use_global_delete)\n       /* Step back one from start of vector, and read dimension.  */\n       tree cookie_addr;\n \n+      type = strip_array_types (TREE_TYPE (type));\n       if (flag_new_abi)\n \t{\n \t  cookie_addr = build (MINUS_EXPR,\n@@ -3391,13 +3389,11 @@ build_vec_delete (base, maxindex, auto_delete_vec, use_global_delete)\n \t  tree cookie;\n \n \t  cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n-\t\t\t       base, BI_header_size);\n+\t\t\t       base, get_cookie_size (type));\n \t  cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n \t  maxindex = build_component_ref (cookie, nelts_identifier, \n \t\t\t\t\t  NULL_TREE, 0);\n \t}\n-\n-      type = strip_array_types (TREE_TYPE (type));\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {"}, {"sha": "794b01af55f2321c9f5c9fa5c3a2a542f65c0f2c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 63, "deletions": 78, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -61,6 +61,7 @@ static tree lookup_anon_field PARAMS ((tree, tree));\n static tree pointer_diff PARAMS ((tree, tree, tree));\n static tree build_component_addr PARAMS ((tree, tree));\n static tree qualify_type PARAMS ((tree, tree));\n+static tree qualify_type_recursive PARAMS ((tree, tree));\n static tree get_delta_difference PARAMS ((tree, tree, int));\n static int comp_cv_target_types PARAMS ((tree, tree, int));\n static void casts_away_constness_r PARAMS ((tree *, tree *));\n@@ -209,6 +210,44 @@ qualify_type (type, like)\n   return cp_build_qualified_type (type, (CP_TYPE_QUALS (type) \n \t\t\t\t\t | CP_TYPE_QUALS (like)));\n }\n+\n+/* Return a pointer or pointer to member type similar to T1, with a\n+   cv-qualification signature that is the union of the cv-qualification\n+   signatures of T1 and T2: [expr.rel], [expr.eq].  */\n+\n+static tree\n+qualify_type_recursive (t1, t2)\n+     tree t1, t2;\n+{\n+  if ((TYPE_PTR_P (t1) && TYPE_PTR_P (t2))\n+      || (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2)))\n+    {\n+      tree tt1 = TREE_TYPE (t1);\n+      tree tt2 = TREE_TYPE (t2);\n+      tree b1;\n+      int type_quals;\n+      tree target;\n+      tree attributes = merge_machine_type_attributes (t1, t2);\n+\n+      if (TREE_CODE (tt1) == OFFSET_TYPE)\n+\t{\n+\t  b1 = TYPE_OFFSET_BASETYPE (tt1);\n+\t  tt1 = TREE_TYPE (tt1);\n+\t  tt2 = TREE_TYPE (tt2);\n+\t}\n+      else\n+\tb1 = NULL_TREE;\n+\n+      type_quals = (CP_TYPE_QUALS (tt1) | CP_TYPE_QUALS (tt2));\n+      target = qualify_type_recursive (tt1, tt2);\n+      target = cp_build_qualified_type (target, type_quals);\n+      if (b1)\n+\ttarget = build_offset_type (b1, target);\n+      t1 = build_pointer_type (target);\n+      t1 = build_type_attribute_variant (t1, attributes);\n+    }\n+  return t1;\n+}\n \f\n /* Return the common type of two parameter lists.\n    We assume that comptypes has already been done and returned 1;\n@@ -441,50 +480,36 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n   if (TYPE_PTRMEMFUNC_P (t2))\n     t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n   \n-  if (comp_target_types (t1, t2, 1))\n-    result_type = common_type (t1, t2);\n-  else if (VOID_TYPE_P (TREE_TYPE (t1)))\n+  if (VOID_TYPE_P (TREE_TYPE (t1)))\n     {\n-      if (pedantic && TREE_CODE (t2) == FUNCTION_TYPE)\n+      if (pedantic && TYPE_PTRFN_P (t2))\n \tpedwarn (\"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function\", location);\n       result_type = qualify_type (t1, t2);\n     }\n   else if (VOID_TYPE_P (TREE_TYPE (t2)))\n     {\n-      if (pedantic && TREE_CODE (t1) == FUNCTION_TYPE)\n+      if (pedantic && TYPE_PTRFN_P (t1))\n \tpedwarn (\"ISO C++ forbids %s between pointer of type `void *' and pointer-to-function\", location);\n       result_type = qualify_type (t2, t1);\n     }\n-  /* C++ */\n-  else if (same_or_base_type_p (t2, t1))\n-    result_type = t2;\n-  else if (IS_AGGR_TYPE (TREE_TYPE (t1))\n-\t   && IS_AGGR_TYPE (TREE_TYPE (t2))\n-\t   && (result_type = common_base_type (TREE_TYPE (t1),\n-\t\t\t\t\t       TREE_TYPE (t2))))\n+  else\n     {\n-      if (result_type == error_mark_node)\n-\t{\n-\t  cp_error (\"common base type of types `%T' and `%T' is ambiguous\",\n-\t\t    TREE_TYPE (t1), TREE_TYPE (t2));\n-\t  result_type = ptr_type_node;\n-\t}\n+      tree full1 = qualify_type_recursive (t1, t2);\n+      tree full2 = qualify_type_recursive (t2, t1);\n+\n+      int val = comp_target_types (full1, full2, 1);\n+\n+      if (val > 0)\n+\tresult_type = full1;\n+      else if (val < 0)\n+\tresult_type = full2;\n       else\n \t{\n-\t  if (pedantic\n-\t      && result_type != TREE_TYPE (t1)\n-\t      && result_type != TREE_TYPE (t2))\n-\t    cp_pedwarn (\"types `%T' and `%T' converted to `%T *' in %s\",\n-\t\t\tt1, t2, result_type, location);\n-\t  \n-\t  result_type = build_pointer_type (result_type);\n+\t  cp_pedwarn (\"%s between distinct pointer types `%T' and `%T' lacks a cast\",\n+\t\t      location, t1, t2);\n+\t  result_type = ptr_type_node;\n \t}\n     }\n-  else\n-    {\n-      cp_pedwarn (\"pointer type mismatch in %s\", location);\n-      result_type = ptr_type_node;\n-    }\n \n   return result_type;\n }\n@@ -3578,33 +3603,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n-\t{\n-\t  register tree tt0 = TYPE_MAIN_VARIANT (TREE_TYPE (type0));\n-\t  register tree tt1 = TYPE_MAIN_VARIANT (TREE_TYPE (type1));\n-\n-\t  if (comp_target_types (type0, type1, 1))\n-\t    result_type = common_type (type0, type1);\n-\t  else if (VOID_TYPE_P (tt0))\n-\t    {\n-\t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n-\t\t  && tree_int_cst_lt (TYPE_SIZE (type0), TYPE_SIZE (type1)))\n-\t\tpedwarn (\"ISO C++ forbids comparison of `void *' with function pointer\");\n-\t      else if (TREE_CODE (tt1) == OFFSET_TYPE)\n-\t\tpedwarn (\"ISO C++ forbids conversion of a pointer to member to `void *'\");\n-\t    }\n-\t  else if (VOID_TYPE_P (tt1))\n-\t    {\n-\t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE\n-\t\t  && tree_int_cst_lt (TYPE_SIZE (type1), TYPE_SIZE (type0)))\n-\t\tpedwarn (\"ISO C++ forbids comparison of `void *' with function pointer\");\n-\t    }\n-\t  else\n-\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n-\t\t\ttype0, type1);\n-\n-\t  if (result_type == NULL_TREE)\n-\t    result_type = ptr_type_node;\n-\t}\n+\tresult_type = composite_pointer_type (type0, type1, op0, op1,\n+\t\t\t\t\t      \"comparison\");\n       else if (code0 == POINTER_TYPE && null_ptr_cst_p (op1))\n \tresult_type = type0;\n       else if (code1 == POINTER_TYPE && null_ptr_cst_p (op0))\n@@ -3723,16 +3723,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \tshorten = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n-\t{\n-\t  if (comp_target_types (type0, type1, 1))\n-\t    result_type = common_type (type0, type1);\n-\t  else\n-\t    {\n-\t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n-\t\t\t  type0, type1);\n-\t      result_type = ptr_type_node;\n-\t    }\n-\t}\n+\tresult_type = composite_pointer_type (type0, type1, op0, op1,\n+\t\t\t\t\t      \"comparison\");\n       break;\n \n     case LE_EXPR:\n@@ -3744,16 +3736,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n-\t{\n-\t  if (comp_target_types (type0, type1, 1))\n-\t    result_type = common_type (type0, type1);\n-\t  else\n-\t    {\n-\t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n-\t\t\t  type0, type1);\n-\t      result_type = ptr_type_node;\n-\t    }\n-\t}\n+\tresult_type = composite_pointer_type (type0, type1, op0, op1,\n+\t\t\t\t\t      \"comparison\");\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n \tresult_type = type0;\n@@ -6844,8 +6828,9 @@ check_return_expr (retval)\n   if ((DECL_OVERLOADED_OPERATOR_P (current_function_decl) == NEW_EXPR\n        || DECL_OVERLOADED_OPERATOR_P (current_function_decl) == VEC_NEW_EXPR)\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n+      && ! flag_check_new\n       && null_ptr_cst_p (retval))\n-    cp_warning (\"`operator new' should throw an exception, not return NULL\");\n+    cp_warning (\"`operator new' must not return NULL unless it is declared `throw()' (or -fcheck-new is in effect)\");\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp"}, {"sha": "39aff256a4af1fa4bfeb0849cb2c37ea0d0f0680", "filename": "gcc/testsuite/g++.old-deja/g++.jason/new3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fnew3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fnew3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fnew3.C?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -11,7 +11,7 @@ struct A {\n   void * operator new (__SIZE_TYPE__ s)\n   {\n     if (ena)\n-      return 0; // WARNING - returning NULL\n+      return 0;\n     return malloc (s);\n   }\n };"}, {"sha": "f41830aebaf089c38aac79a7a807333d46e6a014", "filename": "gcc/testsuite/g++.old-deja/g++.jason/rfg20.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg20.C?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -6,5 +6,5 @@ void *vp;\n \n void example ()\n {\n-    vp != fp;\t\t\t// gets bogus error - nuttin' wrong wit dat\n+    vp != fp;\t\t\t// ERROR - no conversion from pfn to void*\n }"}, {"sha": "16a42d8c6bab746a727f2cd4dfab349571f314da", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/template7.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Ftemplate7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Ftemplate7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Ftemplate7.C?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -4,12 +4,11 @@\n \n // by Alexandre Oliva <oliva@lsd.ic.unicamp.br>\n // simplified from bug report by Paul Burchard <burchard@pobox.com>\n-// crash test - XFAIL *-*-*\n \n template<class> struct A {};\n template<template<class> class T> struct B {\n   B() {\n-    T<B>(); // gets bogus error - conversion from int to non-scalar - XFAIL *-*-*\n+    T<B>(); // gets bogus error - conversion from int to non-scalar\n   }\n };\n B<A> foo;"}, {"sha": "5abe1b1bfe1d099cb614d7049146ff350cdca74a", "filename": "gcc/testsuite/g++.old-deja/g++.other/conv6.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconv6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/708cae97714cec1d3ec97cc9a07873493487614a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconv6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconv6.C?ref=708cae97714cec1d3ec97cc9a07873493487614a", "patch": "@@ -11,18 +11,18 @@ int main ()\n   // The composite type is `A const *'\n         A* ap = &b;\n   const B* bp = &b;\n-  if (ap != bp)\t\t// gets bogus error - distinct types XFAIL *-*-*\n+  if (ap != bp)\t\t// gets bogus error - distinct types\n     return 1;\n \n   // The composite type is `B const *const *'\n   B       *const * p = 0;\n   B const *      * q = 0;\n-  if (p != q)\t\t// gets bogus error - distinct types XFAIL *-*-*\n+  if (p != q)\t\t// gets bogus error - distinct types\n     return 1;\n \n   // The common type is `int const B::*'\n   const int A::*apm = &A::i;\n         int B::*bpm = &A::i;\n-  if (apm != bpm)\t// gets bogus error - distinct types XFAIL *-*-*\n+  if (apm != bpm)\t// gets bogus error - distinct types\n     return 1;\n }"}]}