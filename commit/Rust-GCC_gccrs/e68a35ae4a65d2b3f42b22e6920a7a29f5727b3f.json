{"sha": "e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4YTM1YWU0YTY1ZDJiM2Y0MmIyMmU2OTIwYTdhMjlmNTcyN2IzZg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-08-24T21:12:45Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-08-24T21:12:45Z"}, "message": "re PR fortran/91390 (treatment of extra parameter in a subroutine call)\n\n2019-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/91390\n\tPR fortran/91519\n\t* frontend-passes.c (check_externals_procedure): New\n\tfunction. If a procedure is not in the translation unit, create\n\tan \"interface\" for it, including its formal arguments.\n\t(check_externals_code): Use check_externals_procedure for common\n\tcode with check_externals_expr.\n\t(check_externals_expr): Vice versa.\n\t* gfortran.h (gfc_get_formal_from_actual-arglist): New prototype.\n\t(gfc_compare_actual_formal): New prototype.\n\t* interface.c (compare_actual_formal): Rename to\n\t(gfc_compare_actual_formal): New function, make global.\n\t(gfc_get_formal_from_actual_arglist): Make global, and move here from\n\t* trans-types.c (get_formal_from_actual_arglist): Remove here.\n\t(gfc_get_function_type): Use gfc_get_formal_from_actual_arglist.\n\n2019-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/91390\n\tPR fortran/91519\n\t* gfortran.dg/bessel_3.f90: Add type mismatch errors.\n\t* gfortran.dg/coarray_7.f90: Rename subroutines to avoid\n\tadditional errors.\n\t* gfortran.dg/g77/20010519-1.f: Add -std=legacy. Remove\n\twarnings for ASSIGN. Add warnings for type mismatch.\n\t* gfortran.dg/goacc/acc_on_device-1.f95: Add -std=legacy.\n\tAdd catch-all warning.\n\t* gfortran.dg/internal_pack_9.f90: Rename subroutine to\n\tavoid type error.\n\t* gfortran.dg/internal_pack_9.f90: Add -std=legacy. Add\n\twarnings for type mismatch.\n\t* gfortran.dg/pr39937.f: Add -std=legacy and type warnings. Move\n\there from\n\t* gfortran.fortran-torture/compile/pr39937.f: Move to\n\tgfortran.dg.\n\nFrom-SVN: r274902", "tree": {"sha": "a8408061a41b4c771669bfe144ef8f5e658cf7f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8408061a41b4c771669bfe144ef8f5e658cf7f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/comments", "author": null, "committer": null, "parents": [{"sha": "c6ca0e3e69e2e3681c81d5a5ddd2dcd6f41b7522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6ca0e3e69e2e3681c81d5a5ddd2dcd6f41b7522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6ca0e3e69e2e3681c81d5a5ddd2dcd6f41b7522"}], "stats": {"total": 357, "additions": 217, "deletions": 140}, "files": [{"sha": "abdf9e6b24f0eeb491fdfbe4629555959c73b229", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -1,3 +1,21 @@\n+2019-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/91390\n+\tPR fortran/91519\n+\t* frontend-passes.c (check_externals_procedure): New\n+\tfunction. If a procedure is not in the translation unit, create\n+\tan \"interface\" for it, including its formal arguments.\n+\t(check_externals_code): Use check_externals_procedure for common\n+\tcode with check_externals_expr.\n+\t(check_externals_expr): Vice versa.\n+\t* gfortran.h (gfc_get_formal_from_actual-arglist): New prototype.\n+\t(gfc_compare_actual_formal): New prototype.\n+\t* interface.c (compare_actual_formal): Rename to\n+\t(gfc_compare_actual_formal): New function, make global.\n+\t(gfc_get_formal_from_actual_arglist): Make global, and move here from\n+\t* trans-types.c (get_formal_from_actual_arglist): Remove here.\n+\t(gfc_get_function_type): Use gfc_get_formal_from_actual_arglist.\n+\n 2019-08-23  Mark Eggleston  <mark.eggleston@codethink.com>\n \n \t* intrinsics.text: References in 'See also:' are now on\n@@ -14,7 +32,7 @@\n \n 2019-08-23  Mark Eggleston  <mark.eggleston@codethink.com>\n \n-\t* intrinsics.text: Removed empty sections. The order of \n+\t* intrinsics.text: Removed empty sections. The order of\n \tsections for each intrinsic is now consistent throughout.\n \tStray words removed. Text in the wrong section moved.\n \tMissing standard statement inserted."}, {"sha": "fa416671fc6a5ae6a1f51fde2309d257c55aa5da", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 60, "deletions": 28, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -5369,72 +5369,104 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n    We do this by looping over the code (and expressions). The first call\n    we happen to find is assumed to be canonical.  */\n \n-/* Callback for external functions.  */\n+\n+/* Common tests for argument checking for both functions and subroutines.  */\n \n static int\n-check_externals_expr (gfc_expr **ep, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t      void *data ATTRIBUTE_UNUSED)\n+check_externals_procedure (gfc_symbol *sym, locus *loc, gfc_actual_arglist *actual)\n {\n-  gfc_expr *e = *ep;\n-  gfc_symbol *sym, *def_sym;\n   gfc_gsymbol *gsym;\n+  gfc_symbol *def_sym = NULL;\n \n-  if (e->expr_type != EXPR_FUNCTION)\n+ if (sym == NULL || sym->attr.is_bind_c)\n     return 0;\n \n-  sym = e->value.function.esym;\n-\n-  if (sym == NULL || sym->attr.is_bind_c)\n+  if (sym->attr.proc != PROC_EXTERNAL && sym->attr.proc != PROC_UNKNOWN)\n     return 0;\n \n-  if (sym->attr.proc != PROC_EXTERNAL && sym->attr.proc != PROC_UNKNOWN)\n+  if (sym->attr.if_source == IFSRC_IFBODY || sym->attr.if_source == IFSRC_DECL)\n     return 0;\n \n   gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);\n   if (gsym == NULL)\n     return 0;\n \n-  gfc_find_symbol (sym->name, gsym->ns, 0, &def_sym);\n+  if (gsym->ns)\n+    gfc_find_symbol (sym->name, gsym->ns, 0, &def_sym);\n \n-  if (sym && def_sym)\n-    gfc_procedure_use (def_sym, &e->value.function.actual, &e->where);\n+  if (def_sym)\n+    {\n+      gfc_procedure_use (def_sym, &actual, loc);\n+      return 0;\n+    }\n+\n+  /* First time we have seen this procedure called. Let's create an\n+     \"interface\" from the call and put it into a new namespace.  */\n+  gfc_namespace *save_ns;\n+  gfc_symbol *new_sym;\n+\n+  gsym->where = *loc;\n+  save_ns = gfc_current_ns;\n+  gsym->ns = gfc_get_namespace (gfc_current_ns, 0);\n+  gsym->ns->proc_name = sym;\n+\n+  gfc_get_symbol (sym->name, gsym->ns, &new_sym);\n+  gcc_assert (new_sym);\n+  new_sym->attr = sym->attr;\n+  new_sym->attr.if_source = IFSRC_DECL;\n+  gfc_current_ns = gsym->ns;\n+\n+  gfc_get_formal_from_actual_arglist (new_sym, actual);\n+  gfc_current_ns = save_ns;\n \n   return 0;\n+\n }\n \n-/* Callback for external code.  */\n+/* Callback for calls of external routines.  */\n \n static int\n check_externals_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t      void *data ATTRIBUTE_UNUSED)\n {\n   gfc_code *co = *c;\n-  gfc_symbol *sym, *def_sym;\n-  gfc_gsymbol *gsym;\n+  gfc_symbol *sym;\n+  locus *loc;\n+  gfc_actual_arglist *actual;\n \n   if (co->op != EXEC_CALL)\n     return 0;\n \n   sym = co->resolved_sym;\n-  if (sym == NULL || sym->attr.is_bind_c)\n-    return 0;\n+  loc = &co->loc;\n+  actual = co->ext.actual;\n \n-  if (sym->attr.proc != PROC_EXTERNAL && sym->attr.proc != PROC_UNKNOWN)\n-    return 0;\n+  return check_externals_procedure (sym, loc, actual);\n \n-  if (sym->attr.if_source == IFSRC_IFBODY || sym->attr.if_source == IFSRC_DECL)\n-    return 0;\n+}\n \n-  gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);\n-  if (gsym == NULL)\n+/* Callback for external functions.  */\n+\n+static int\n+check_externals_expr (gfc_expr **ep, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t      void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_expr *e = *ep;\n+  gfc_symbol *sym;\n+  locus *loc;\n+  gfc_actual_arglist *actual;\n+\n+  if (e->expr_type != EXPR_FUNCTION)\n     return 0;\n \n-  gfc_find_symbol (sym->name, gsym->ns, 0, &def_sym);\n+  sym = e->value.function.esym;\n+  if (sym == NULL)\n+    return 0;\n \n-  if (sym && def_sym)\n-    gfc_procedure_use (def_sym, &co->ext.actual, &co->loc);\n+  loc = &e->where;\n+  actual = e->value.function.actual;\n \n-  return 0;\n+  return check_externals_procedure (sym, loc, actual);\n }\n \n /* Called routine.  */"}, {"sha": "7f54897361f749bebf4b275fbd8ae3f707f92c7b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -3421,6 +3421,9 @@ bool gfc_check_typebound_override (gfc_symtree*, gfc_symtree*);\n void gfc_check_dtio_interfaces (gfc_symbol*);\n gfc_symtree* gfc_find_typebound_dtio_proc (gfc_symbol *, bool, bool);\n gfc_symbol* gfc_find_specific_dtio_proc (gfc_symbol*, bool, bool);\n+void gfc_get_formal_from_actual_arglist (gfc_symbol *, gfc_actual_arglist *);\n+bool gfc_compare_actual_formal (gfc_actual_arglist **, gfc_formal_arglist *,\n+\t\t\t\tint, int, bool, locus *);\n \n \n /* io.c */"}, {"sha": "43d7cd5a29686b307c054127654fb4dfb5ae3267", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 70, "deletions": 8, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -2878,10 +2878,10 @@ lookup_arg_fuzzy (const char *arg, gfc_formal_arglist *arguments)\n    errors when things don't match instead of just returning the status\n    code.  */\n \n-static bool\n-compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n-\t \t       int ranks_must_agree, int is_elemental,\n-\t\t       bool in_statement_function, locus *where)\n+bool\n+gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n+\t\t\t   int ranks_must_agree, int is_elemental,\n+\t\t\t   bool in_statement_function, locus *where)\n {\n   gfc_actual_arglist **new_arg, *a, *actual;\n   gfc_formal_arglist *f;\n@@ -3805,8 +3805,8 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \n   /* For a statement function, check that types and type parameters of actual\n      arguments and dummy arguments match.  */\n-  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,\n-\t\t\t      sym->attr.proc == PROC_ST_FUNCTION, where))\n+  if (!gfc_compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,\n+\t\t\t\t  sym->attr.proc == PROC_ST_FUNCTION, where))\n     return false;\n  \n   if (!check_intents (dummy_args, *ap))\n@@ -3854,7 +3854,7 @@ gfc_ppc_use (gfc_component *comp, gfc_actual_arglist **ap, locus *where)\n       return;\n     }\n \n-  if (!compare_actual_formal (ap, comp->ts.interface->formal, 0,\n+  if (!gfc_compare_actual_formal (ap, comp->ts.interface->formal, 0,\n \t\t\t      comp->attr.elemental, false, where))\n     return;\n \n@@ -3880,7 +3880,7 @@ gfc_arglist_matches_symbol (gfc_actual_arglist** args, gfc_symbol* sym)\n   dummy_args = gfc_sym_get_dummy_args (sym);\n \n   r = !sym->attr.elemental;\n-  if (compare_actual_formal (args, dummy_args, r, !r, false, NULL))\n+  if (gfc_compare_actual_formal (args, dummy_args, r, !r, false, NULL))\n     {\n       check_intents (dummy_args, *args);\n       if (warn_aliasing)\n@@ -5131,3 +5131,65 @@ gfc_find_specific_dtio_proc (gfc_symbol *derived, bool write, bool formatted)\n \n   return dtio_sub;\n }\n+\n+/* Helper function - if we do not find an interface for a procedure,\n+   construct it from the actual arglist.  Luckily, this can only\n+   happen for call by reference, so the information we actually need\n+   to provide (and which would be impossible to guess from the call\n+   itself) is not actually needed.  */\n+\n+void\n+gfc_get_formal_from_actual_arglist (gfc_symbol *sym,\n+\t\t\t\t    gfc_actual_arglist *actual_args)\n+{\n+  gfc_actual_arglist *a;\n+  gfc_formal_arglist **f;\n+  gfc_symbol *s;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  static int var_num;\n+\n+  f = &sym->formal;\n+  for (a = actual_args; a != NULL; a = a->next)\n+    {\n+      (*f) = gfc_get_formal_arglist ();\n+      if (a->expr)\n+\t{\n+\t  snprintf (name, GFC_MAX_SYMBOL_LEN, \"_formal_%d\", var_num ++);\n+\t  gfc_get_symbol (name, gfc_current_ns, &s);\n+\t  if (a->expr->ts.type == BT_PROCEDURE)\n+\t    {\n+\t      s->attr.flavor = FL_PROCEDURE;\n+\t    }\n+\t  else\n+\t    {\n+\t      s->ts = a->expr->ts;\n+\n+\t      if (s->ts.type == BT_CHARACTER)\n+\t\ts->ts.u.cl = gfc_get_charlen ();\n+\n+\t      s->ts.deferred = 0;\n+\t      s->ts.is_iso_c = 0;\n+\t      s->ts.is_c_interop = 0;\n+\t      s->attr.flavor = FL_VARIABLE;\n+\t      s->attr.artificial = 1;\n+\t      if (a->expr->rank > 0)\n+\t\t{\n+\t\t  s->attr.dimension = 1;\n+\t\t  s->as = gfc_get_array_spec ();\n+\t\t  s->as->rank = 1;\n+\t\t  s->as->lower[0] = gfc_get_int_expr (gfc_index_integer_kind,\n+\t\t\t\t\t\t      &a->expr->where, 1);\n+\t\t  s->as->upper[0] = NULL;\n+\t\t  s->as->type = AS_ASSUMED_SIZE;\n+\t\t}\n+\t    }\n+\t  s->attr.dummy = 1;\n+\t  s->attr.intent = INTENT_UNKNOWN;\n+\t  (*f)->sym = s;\n+\t}\n+      else  /* If a->expr is NULL, this is an alternate rerturn.  */\n+\t(*f)->sym = NULL;\n+\n+      f = &((*f)->next);\n+    }\n+}"}, {"sha": "82666c48beccb15940a93452d1829bb205f7f77b", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -2975,66 +2975,6 @@ create_fn_spec (gfc_symbol *sym, tree fntype)\n   return build_type_attribute_variant (fntype, tmp);\n }\n \n-/* Helper function - if we do not find an interface for a procedure,\n-   construct it from the actual arglist.  Luckily, this can only\n-   happen for call by reference, so the information we actually need\n-   to provide (and which would be impossible to guess from the call\n-   itself) is not actually needed.  */\n-\n-static void\n-get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)\n-{\n-  gfc_actual_arglist *a;\n-  gfc_formal_arglist **f;\n-  gfc_symbol *s;\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  static int var_num;\n-\n-  f = &sym->formal;\n-  for (a = actual_args; a != NULL; a = a->next)\n-    {\n-      (*f) = gfc_get_formal_arglist ();\n-      if (a->expr)\n-\t{\n-\t  snprintf (name, GFC_MAX_SYMBOL_LEN, \"_formal_%d\", var_num ++);\n-\t  gfc_get_symbol (name, gfc_current_ns, &s);\n-\t  if (a->expr->ts.type == BT_PROCEDURE)\n-\t    {\n-\t      s->attr.flavor = FL_PROCEDURE;\n-\t    }\n-\t  else\n-\t    {\n-\t      s->ts = a->expr->ts;\n-\n-\t      if (s->ts.type == BT_CHARACTER)\n-\t\t  s->ts.u.cl = gfc_get_charlen ();\n-\n-\t      s->ts.deferred = 0;\n-\t      s->ts.is_iso_c = 0;\n-\t      s->ts.is_c_interop = 0;\n-\t      s->attr.flavor = FL_VARIABLE;\n-\t      if (a->expr->rank > 0)\n-\t\t{\n-\t\t  s->attr.dimension = 1;\n-\t\t  s->as = gfc_get_array_spec ();\n-\t\t  s->as->rank = 1;\n-\t\t  s->as->lower[0] = gfc_get_int_expr (gfc_index_integer_kind,\n-\t\t\t\t\t\t      &a->expr->where, 1);\n-\t\t  s->as->upper[0] = NULL;\n-\t\t  s->as->type = AS_ASSUMED_SIZE;\n-\t\t}\n-\t    }\n-\t  s->attr.dummy = 1;\n-\t  s->attr.intent = INTENT_UNKNOWN;\n-\t  (*f)->sym = s;\n-\t}\n-      else  /* If a->expr is NULL, this is an alternate rerturn.  */\n-\t(*f)->sym = NULL;\n-\n-      f = &((*f)->next);\n-    }\n-}\n-\n tree\n gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)\n {\n@@ -3097,7 +3037,7 @@ gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)\n   if (sym->backend_decl == error_mark_node && actual_args != NULL\n       && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL\n \t\t\t\t || sym->attr.proc == PROC_UNKNOWN))\n-    get_formal_from_actual_arglist (sym, actual_args);\n+    gfc_get_formal_from_actual_arglist (sym, actual_args);\n \n   /* Build the argument types for the function.  */\n   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)"}, {"sha": "efb0157bff196e8d59d8c9689542a753a79b82ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -1,3 +1,22 @@\n+2019-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/91390\n+\tPR fortran/91519\n+\t* gfortran.dg/bessel_3.f90: Add type mismatch errors.\n+\t* gfortran.dg/coarray_7.f90: Rename subroutines to avoid\n+\tadditional errors.\n+\t* gfortran.dg/g77/20010519-1.f: Add -std=legacy. Remove\n+\twarnings for ASSIGN. Add warnings for type mismatch.\n+\t* gfortran.dg/goacc/acc_on_device-1.f95: Add -std=legacy.\n+\tAdd catch-all warning.\n+\t* gfortran.dg/internal_pack_9.f90: Rename subroutine to\n+\tavoid type error.\n+\t* gfortran.dg/internal_pack_9.f90: Add -std=legacy. Add\n+\twarnings for type mismatch.\n+\t* gfortran.dg/pr39937.f: Add -std=legacy and type warnings. Move\n+\there from\n+\t* gfortran.fortran-torture/compile/pr39937.f: Move to gfortran.dg.\n+\n 2019-08-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/conversion/simd4.C: Test all the locations."}, {"sha": "05610ae0c389c3a9516c0dc2ec1fc2dbd96e2522", "filename": "gcc/testsuite/gfortran.dg/bessel_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbessel_3.f90?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -9,10 +9,10 @@\n print *, BESSEL_J0(1.0) ! { dg-error \"has no IMPLICIT type\" })\n print *, BESSEL_J1(1.0) ! { dg-error \"has no IMPLICIT type\" }\n print *, BESSEL_JN(1,1.0) ! { dg-error \"has no IMPLICIT type\" }\n-print *, BESSEL_JN(1,2,1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_JN(1,2,1.0) ! { dg-error \"has no IMPLICIT type|Type mismatch\" }\n \n print *, BESSEL_Y0(1.0) ! { dg-error \"has no IMPLICIT type\" }\n print *, BESSEL_Y1(1.0) ! { dg-error \"has no IMPLICIT type\" }\n print *, BESSEL_YN(1,1.0) ! { dg-error \"has no IMPLICIT type\" }\n-print *, BESSEL_YN(1,2,1.0) ! { dg-error \"has no IMPLICIT type\" }\n+print *, BESSEL_YN(1,2,1.0) ! { dg-error \"has no IMPLICIT type|Type mismatch\" }\n end"}, {"sha": "49482efdb6a18e735a5e64f4263cf2873746b078", "filename": "gcc/testsuite/gfortran.dg/coarray_7.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -50,9 +50,9 @@ program test\n   call coarray(caf2)\n   call coarray(caf2[1]) ! { dg-error \"must be a coarray\" }\n   call ups(i)\n-  call ups(i[1]) ! { dg-error \"with ultimate pointer component\" }\n-  call ups(i%ptr)\n-  call ups(i[1]%ptr) ! OK - passes target not pointer\n+  call ups1(i[1]) ! { dg-error \"with ultimate pointer component\" }\n+  call ups2(i%ptr)\n+  call ups3(i[1]%ptr) ! OK - passes target not pointer\n contains\n   subroutine asyn(a)\n     integer, intent(in), asynchronous :: a"}, {"sha": "4cefb958600c7279dc03fc2420561280ba5f1877", "filename": "gcc/testsuite/gfortran.dg/g77/20010519-1.f", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010519-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010519-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010519-1.f?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -1,4 +1,5 @@\n c { dg-do compile }\n+c { dg-options \"-std=legacy\" }\n CHARMM Element source/dimb/nmdimb.src 1.1\n C.##IF DIMB\n       SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n@@ -711,32 +712,32 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n      1     'NFREG IS LARGER THAN PARDIM*3')\n C\n C ALLOCATE-SPACE-FOR-TRANSROT-VECTORS\n-      ASSIGN 801 TO I800 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+      ASSIGN 801 TO I800\n       GOTO 800\n  801  CONTINUE\n C ALLOCATE-SPACE-FOR-DIAGONALIZATION\n-      ASSIGN 721 TO I720 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+      ASSIGN 721 TO I720\n       GOTO 720\n  721  CONTINUE\n C ALLOCATE-SPACE-FOR-REDUCED-BASIS\n-      ASSIGN 761 TO I760 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+      ASSIGN 761 TO I760\n       GOTO 760\n  761  CONTINUE\n C ALLOCATE-SPACE-FOR-OTHER-ARRAYS\n-      ASSIGN 921 TO I920 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+      ASSIGN 921 TO I920\n       GOTO 920\n  921  CONTINUE\n C\n C Space allocation for working arrays of EISPACK\n C diagonalization subroutines\n       IF(LSCI) THEN\n C ALLOCATE-SPACE-FOR-LSCI\n-         ASSIGN 841 TO I840 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+         ASSIGN 841 TO I840\n          GOTO 840\n  841     CONTINUE\n       ELSE\n C ALLOCATE-DUMMY-SPACE-FOR-LSCI\n-         ASSIGN 881 TO I880 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+         ASSIGN 881 TO I880\n          GOTO 880\n  881     CONTINUE\n       ENDIF\n@@ -846,7 +847,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n C\n          OLDPRN=PRNLEV\n          PRNLEV=1\n-         CALL ORTHNM(1,NFRET,NFRET,DDV,NAT3,LPURG,TOLER)\n+         CALL ORTHNM(1,NFRET,NFRET,DDV,NAT3,LPURG,TOLER) ! { dg-warning \"Type mismatch\" }\n          PRNLEV=OLDPRN\n C\n C Do reduced basis diagonalization using the DDV vectors\n@@ -878,11 +879,11 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n C\n C DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n C\n-         ASSIGN 621 TO I620 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+         ASSIGN 621 TO I620\n          GOTO 620\n  621     CONTINUE\n C SAVE-MODES\n-         ASSIGN 701 TO I700 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+         ASSIGN 701 TO I700\n          GOTO 700\n  701     CONTINUE\n          IF(ITER.EQ.ITMX) THEN\n@@ -1025,17 +1026,17 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n             CALL PARTDS(NAT3,NPARC,ATMPAR,NPARS,ATMPAS,INIDS,NPARMX,\n      1                  DDF,NFREG,CUTF1,PARDIM,NFCUT1)\n C DO-THE-DIAGONALISATIONS\n-            ASSIGN 641 to I640 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+            ASSIGN 641 to I640\n             GOTO 640\n  641        CONTINUE\n             QDIAG=.FALSE.\n C DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n-            ASSIGN 622 TO I620 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+            ASSIGN 622 TO I620\n             GOTO 620\n  622        CONTINUE\n             QDIAG=.TRUE.\n C SAVE-MODES\n-            ASSIGN 702 TO I700 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+            ASSIGN 702 TO I700\n             GOTO 700\n  702        CONTINUE\n C\n@@ -1048,21 +1049,21 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n                   ITER=ITER+1\n                   IF(PRNLEV.GE.2) WRITE(OUTU,553) ITER\n C DO-THE-DWIN-DIAGONALISATIONS\n-                  ASSIGN 661 TO I660 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+                  ASSIGN 661 TO I660\n                   GOTO 660\n  661              CONTINUE\n                ENDIF\n                IF((IRESF.EQ.SAVF).OR.(ITER.EQ.ITMX)) THEN\n                   IRESF=0\n                   QDIAG=.FALSE.\n C DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n-                  ASSIGN 623 TO I620 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+                  ASSIGN 623 TO I620\n                   GOTO 620\n  623              CONTINUE\n                   QDIAG=.TRUE.\n                   IF((CVGMX.LE.TOLDIM).OR.(ITER.EQ.ITMX)) GOTO 600\n C SAVE-MODES\n-                  ASSIGN 703 TO I700 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+                  ASSIGN 703 TO I700\n                   GOTO 700\n  703              CONTINUE\n                ENDIF\n@@ -1072,7 +1073,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n  600  CONTINUE\n C\n C SAVE-MODES\n-      ASSIGN 704 TO I700 ! { dg-warning \"Deleted feature: ASSIGN\" \"Deleted feature: ASSIGN\" }\n+      ASSIGN 704 TO I700\n       GOTO 700\n  704  CONTINUE\n       CALL CLEANHP(NAT3,NFREG,NPARD,NSUBP,PARDIM,DDV2,DDSS,DDVBAS,\n@@ -1125,7 +1126,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n          NFCUT=NFRET\n          OLDPRN=PRNLEV\n          PRNLEV=1\n-         CALL ORTHNM(1,NFRET,NFCUT,DDV,NAT3,LPURG,TOLER)\n+         CALL ORTHNM(1,NFRET,NFCUT,DDV,NAT3,LPURG,TOLER) ! { dg-warning \"Type mismatch\" }\n          PRNLEV=OLDPRN\n          NFRET=NFCUT\n          IF(PRNLEV.GE.2) WRITE(OUTU,568) NFRET\n@@ -1150,7 +1151,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n      6     HEAP(BDRATQ),HEAP(INRATQ),LSCI,LBIG,IUNMOD)\n          CALL SELNMD(DDF,NFRET,CUTF1,NFCUT1)\n       ENDIF\n-      GOTO I620 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I620 \n C\n C-----------------------------------------------------------------------\n C TO DO-THE-DIAGONALISATIONS\n@@ -1173,7 +1174,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n          NFSAV=NFCUT1\n          OLDPRN=PRNLEV\n          PRNLEV=1\n-         CALL ORTHNM(1,NFCUT1,NFCUT,DDV,NAT3,LPURG,TOLER)\n+         CALL ORTHNM(1,NFCUT1,NFCUT,DDV,NAT3,LPURG,TOLER) ! { dg-warning \"Type mismatch\" }\n          PRNLEV=OLDPRN\n          CALL CPARAY(HEAP(DDVBAS),DDV,NAT3,1,NFCUT,1)\n          NFRET=NDIM+NFCUT\n@@ -1190,7 +1191,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n          NFCUT1=NFCUT\n          NFRET=NFCUT\n       ENDDO\n-      GOTO I640 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I640 \n C\n C-----------------------------------------------------------------------\n C TO DO-THE-DWIN-DIAGONALISATIONS\n@@ -1223,7 +1224,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       CALL ADZERD(DDV,1,NFCUT1,NAT3,IS1,IS2,IS3,IS4)\n       OLDPRN=PRNLEV\n       PRNLEV=1\n-      CALL ORTHNM(1,NFCUT1,NFCUT,DDV,NAT3,LPURG,TOLER)\n+      CALL ORTHNM(1,NFCUT1,NFCUT,DDV,NAT3,LPURG,TOLER) ! { dg-warning \"Type mismatch\" }\n       PRNLEV=OLDPRN\n       CALL CPARAY(HEAP(DDVBAS),DDV,NAT3,1,NFCUT,1)\n C\n@@ -1241,7 +1242,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       IF(NFCUT.GT.NFRRES) NFCUT=NFRRES\n       NFCUT1=NFCUT\n       NFRET=NFCUT\n-      GOTO I660 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I660 \n C\n C-----------------------------------------------------------------------\n C TO SAVE-MODES\n@@ -1258,7 +1259,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       CALL WRTNMD(LCARD,ISTRT,ISTOP,NAT3,DDV,DDSCR,DDEV,IUNMOD,\n      1            AMASS)\n       CALL SAVEIT(IUNMOD)\n-      GOTO I700 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I700 \n C\n C-----------------------------------------------------------------------\n C TO ALLOCATE-SPACE-FOR-DIAGONALIZATION\n@@ -1269,7 +1270,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       JSPACE=JSPACE+JSP\n       DDSS=ALLHP(JSPACE)\n       DD5=DDSS+JSPACE-JSP\n-      GOTO I720 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I720 \n C\n C-----------------------------------------------------------------------\n C TO ALLOCATE-SPACE-FOR-REDUCED-BASIS\n@@ -1279,13 +1280,13 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       ELSE\n          DDVBAS=ALLHP(IREAL8(NFREG*NAT3))\n       ENDIF\n-      GOTO I760 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I760 \n C\n C-----------------------------------------------------------------------\n C TO ALLOCATE-SPACE-FOR-TRANSROT-VECTORS\n  800  CONTINUE\n       TRAROT=ALLHP(IREAL8(6*NAT3))\n-      GOTO I800 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I800 \n C\n C-----------------------------------------------------------------------\n C TO ALLOCATE-SPACE-FOR-LSCI\n@@ -1300,7 +1301,7 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       E2RATQ=ALLHP(IREAL8(PARDIM+3))\n       BDRATQ=ALLHP(IREAL8(PARDIM+3))\n       INRATQ=ALLHP(INTEG4(PARDIM+3))\n-      GOTO I840 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I840 \n C\n C-----------------------------------------------------------------------\n C TO ALLOCATE-DUMMY-SPACE-FOR-LSCI\n@@ -1315,13 +1316,13 @@ SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n       E2RATQ=ALLHP(IREAL8(2))\n       BDRATQ=ALLHP(IREAL8(2))\n       INRATQ=ALLHP(INTEG4(2))\n-      GOTO I880 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I880 \n C\n C-----------------------------------------------------------------------\n C TO ALLOCATE-SPACE-FOR-OTHER-ARRAYS\n  920  CONTINUE\n       IUPD=ALLHP(INTEG4(PARDIM+3))\n-      GOTO I920 ! { dg-warning \"Deleted feature: Assigned\" \"Assigned GO TO\" }\n+      GOTO I920 \n C.##ELSE\n C.##ENDIF\n       END"}, {"sha": "e204b539e6f9de6840e4108507639e4d2e068b3f", "filename": "gcc/testsuite/gfortran.dg/goacc/acc_on_device-1.f95", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-1.f95?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -1,5 +1,5 @@\n ! Have to enable optimizations, as otherwise builtins won't be expanded.\n-! { dg-additional-options \"-O -fdump-rtl-expand\" }\n+! { dg-additional-options \"-O -fdump-rtl-expand -std=legacy\" }\n \n logical function f ()\n   implicit none\n@@ -9,7 +9,7 @@ logical function f ()\n \n   f = .false.\n   f = f .or. acc_on_device ()\n-  f = f .or. acc_on_device (1, 2)\n+  f = f .or. acc_on_device (1, 2) ! { dg-warning \".*\" }\n   f = f .or. acc_on_device (3.14)\n   f = f .or. acc_on_device (\"hello\")\n "}, {"sha": "568b42cde67da72631ae80a69dc18aaf54184d4a", "filename": "gcc/testsuite/gfortran.dg/internal_pack_9.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_9.f90?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -10,9 +10,9 @@\n ! Case 1: Substring encompassing the whole string\n subroutine foo2\n   implicit none\n-  external foo\n+  external foo_char\n   character(len=20) :: str(2) = '1234567890'\n-  call foo(str(:)(1:20)) ! This is still not fixed.\n+  call foo_char (str(:)(1:20)) ! This is still not fixed.\n end\n \n ! Case 2: Contiguous array section"}, {"sha": "bb63c411b41d5d3c787def0bff8057d94d0ccd1b", "filename": "gcc/testsuite/gfortran.dg/pr24823.f", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr24823.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr24823.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr24823.f?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -1,5 +1,5 @@\n !     { dg-do compile }\n-!     { dg-options \"-O2\" }\n+!     { dg-options \"-O2 -std=legacy\" }\n !     PR24823 Flow didn't handle a PARALLEL as destination of a SET properly.\n       SUBROUTINE ZLATMR( M, N, DIST, ISEED, SYM, D, MODE, COND, DMAX,\n      $     RSIGN, GRADE, DL, MODEL, CONDL, DR, MODER,\n@@ -52,7 +52,7 @@ SUBROUTINE ZLATMR( M, N, DIST, ISEED, SYM, D, MODE, COND, DMAX,\n                   A( J-I+1, I ) = DCONJG( ZLATM2( M, N, I, J, KL,\n      $                 DR, IPVTNG, IWORK, SPARSE ) )\n                ELSE\n-                  A( J-I+1, I ) = ZLATM2( M, N, I, J, KL, KU,\n+                  A( J-I+1, I ) = ZLATM2( M, N, I, J, KL, KU, ! { dg-warning \"Type mismatch\" }\n      $                 IPVTNG, IWORK, SPARSE )\n                END IF\n             END IF\n@@ -61,7 +61,7 @@ SUBROUTINE ZLATMR( M, N, DIST, ISEED, SYM, D, MODE, COND, DMAX,\n                   IF( ISYM.EQ.0 ) THEN\n                   END IF\n                END IF\n-               A( I-J+KUU+1, J ) = ZLATM2( M, N, I, J, KL, KU,\n+               A( I-J+KUU+1, J ) = ZLATM2( M, N, I, J, KL, KU, ! { dg-warning \"Type mismatch\" }\n      $              DR, IPVTNG, IWORK, SPARSE )\n             END IF\n          END IF"}, {"sha": "1ab22ee439716c75a707b8f3f37d5aff6783753e", "filename": "gcc/testsuite/gfortran.dg/pr39937.f", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr39937.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr39937.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr39937.f?ref=e68a35ae4a65d2b3f42b22e6920a7a29f5727b3f", "patch": "@@ -1,3 +1,5 @@\n+C { dg-do compile }\n+C { dg-options \"-std=legacy\" }\n       SUBROUTINE DTREVC( SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR,\n      $                   LDVR, MM, M, WORK, INFO )\n       DOUBLE PRECISION   T( LDT, * ), VL( LDVL, * ), VR( LDVR, * ),\n@@ -18,7 +20,7 @@ SUBROUTINE DTREVC( SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR,\n           END IF\n           CALL DLALN2( .FALSE., 2, 2, SMIN, ONE,\n      $                            T( J-1, J-1 ), LDT, ONE, ONE,\n-     $                            XNORM, IERR )\n+     $                            XNORM, IERR ) ! { dg-warning \"Type mismatch\" }\n           CALL DAXPY( J-2, -X( 1, 1 ), T( 1, J-1 ), 1,\n      $                           WORK( 1+N ), 1 )\n           CALL DAXPY( J-2, -X( 2, 2 ), T( 1, J ), 1,", "previous_filename": "gcc/testsuite/gfortran.fortran-torture/compile/pr39937.f"}]}