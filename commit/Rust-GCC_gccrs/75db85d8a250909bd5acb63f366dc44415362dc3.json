{"sha": "75db85d8a250909bd5acb63f366dc44415362dc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkYjg1ZDhhMjUwOTA5YmQ1YWNiNjNmMzY2ZGM0NDQxNTM2MmRjMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-03-22T22:24:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-03-22T22:24:28Z"}, "message": "Remove alpha-unicosmk code from the backend.\n\nFrom-SVN: r171309", "tree": {"sha": "a32f365d2dbe1ddd0a8e9a305cfaa04c0982f637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a32f365d2dbe1ddd0a8e9a305cfaa04c0982f637"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75db85d8a250909bd5acb63f366dc44415362dc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75db85d8a250909bd5acb63f366dc44415362dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75db85d8a250909bd5acb63f366dc44415362dc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75db85d8a250909bd5acb63f366dc44415362dc3/comments", "author": null, "committer": null, "parents": [{"sha": "96e4542172ff9a57b56370cdd65f1b1dacbdcdf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e4542172ff9a57b56370cdd65f1b1dacbdcdf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e4542172ff9a57b56370cdd65f1b1dacbdcdf8"}], "stats": {"total": 1610, "additions": 146, "deletions": 1464}, "files": [{"sha": "f5456436d0b22749ba108752debb6f3b1907514e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -1,3 +1,46 @@\n+2011-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (NUM_ARGS): Don't test TARGET_ABI_UNICOSMK.\n+\t(alpha_option_override, direct_return): Likewise.\n+\t(alpha_arg_partial_bytes, alpha_setup_incoming_varargs): Likewise.\n+\t(alpha_va_start, alpha_gimplify_va_arg, alpha_sa_mask): Likewise.\n+\t(alpha_sa_size, compute_frame_size, alpha_expand_prologue): Likewise.\n+\t(alpha_start_function, alpha_output_function_end_prologue): Likewise.\n+\t(alpha_expand_epilogue, alpha_end_function): Likewise.\n+\t(alpha_init_libfuncs): Likewise.\n+\t(struct machine_function): Remove unicosmk members.\n+\t(print_operand) ['t']: Remove.\n+\t(unicosmk_must_pass_in_stack, unicosmk_initial_elimination_offset,\n+\tunicosmk_output_module_name, unicosmk_output_common,\n+\tcurrent_section_align, unicosmk_output_text_section_asm_op,\n+\tunicosmk_output_data_section_asm_op, unicosmk_init_sections,\n+\tunicosmk_section_type_flags, unicosmk_unique_section,\n+\tunicosmk_asm_named_section, unicosmk_insert_attributes,\n+\tunicosmk_output_align, unicosmk_defer_case_vector,\n+\tunicosmk_output_addr_vec, unicosmk_output_deferred_case_vectors,\n+\tSSIB_PREFIX, SSIB_PREFIX_LEN, unicosmk_ssib_name, unicosmk_gen_dsib,\n+\tunicosmk_output_ssib, unicosmk_add_call_info_word,\n+\tunicosmk_extern_head, unicosmk_output_default_externs,\n+\tunicosmk_output_externs, unicosmk_add_extern, unicosmk_dex_list,\n+\tunicosmk_dex_count, unicosmk_special_name, unicosmk_need_dex,\n+\tunicosmk_output_dex, unicosmk_file_start, unicosmk_file_end): Remove.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.h (TARGET_ABI_OSF): Don't test TARGET_ABI_UNICOSMK.\n+\t* config/alpha/alpha.md (UNSPEC_UMK_LAUM, UNSPEC_UMK_LALM): Remove.\n+\t(UNSPEC_UMK_LAL, UNSPEC_UMK_LOAD_CIW): Remove.\n+\t(mulsi3): Don't test TARGET_ABI_UNICOSMK.\n+\t(*mulsi_se, mulvsi3): Likewise.\n+\t(divsi3, udivsi3, modsi3, umodsi3, divdi3, udivdi3): Likewise.\n+\t(*divmodsi_internal, call, call_value, realign): Likewise.\n+\t(moddi3, umoddi3): Likewise; remove duplicate expander.\n+\t(moddi3_umk, umoddi3_umk, call_umk, call_value_umk): Remove.\n+\t(*call_umk_1, *movsi, umk_laum, umk_lalm, *umk_load_ciw): Remove.\n+\t(*movdi_nofix): Remove r/U alternative.\n+\t(umk_mismatch_args, arg_home_umk, *call_value_umk): Remove.\n+\t* config/alpha/constraints.md (\"U\"): Remove.\n+\t* config/alpha/predicates.md (call_operand\"): Don't test\n+\tTARGET_ABI_UNICOSMK.\n+\n 2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n \n \t* target.def (handle_option): Take gcc_options and"}, {"sha": "1db35757bd6197e119c7e8efac566de14037472c", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -118,14 +118,6 @@ extern HOST_WIDE_INT alpha_vms_initial_elimination_offset (unsigned int,\n \n extern rtx unicosmk_add_call_info_word (rtx);\n \n-#if TARGET_ABI_UNICOSMK\n-extern void unicosmk_defer_case_vector (rtx, rtx);\n-extern void unicosmk_add_extern (const char *);\n-extern void unicosmk_output_align (FILE *, int);\n-extern void unicosmk_output_common (FILE *, const char *, int, int);\n-extern int unicosmk_initial_elimination_offset (int, int);\n-#endif\n-\n extern int some_small_symbolic_operand_int (rtx *, void *);\n extern int tls_symbolic_operand_1 (rtx, int, int);\n extern rtx resolve_reload_operand (rtx);"}, {"sha": "48046c631c563e2ac7b2e1fb2a20a505a1c995ca", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 75, "deletions": 1132, "changes": 1207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -185,7 +185,7 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_size =\n };\n \n /* Get the number of args of a function in one of two ways.  */\n-#if TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK\n+#if TARGET_ABI_OPEN_VMS\n #define NUM_ARGS crtl->args.info.num_args\n #else\n #define NUM_ARGS crtl->args.info\n@@ -202,11 +202,6 @@ static rtx alpha_emit_xfloating_compare (enum rtx_code *, rtx, rtx);\n static void alpha_write_linkage (FILE *, const char *, tree);\n static bool vms_valid_pointer_mode (enum machine_mode);\n #endif\n-\n-static void unicosmk_output_deferred_case_vectors (FILE *);\n-static void unicosmk_gen_dsib (unsigned long *);\n-static void unicosmk_output_ssib (FILE *, const char *);\n-static int unicosmk_need_dex (rtx);\n \f\n /* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n static const struct default_options alpha_option_optimization_table[] =\n@@ -298,50 +293,19 @@ alpha_option_override (void)\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n \n-  /* Unicos/Mk doesn't have shared libraries.  */\n-  if (TARGET_ABI_UNICOSMK && flag_pic)\n-    {\n-      warning (0, \"-f%s ignored for Unicos/Mk (not supported)\",\n-\t       (flag_pic > 1) ? \"PIC\" : \"pic\");\n-      flag_pic = 0;\n-    }\n-\n-  /* On Unicos/Mk, the native compiler consistently generates /d suffices for\n-     floating-point instructions.  Make that the default for this target.  */\n-  if (TARGET_ABI_UNICOSMK)\n-    alpha_fprm = ALPHA_FPRM_DYN;\n-  else\n-    alpha_fprm = ALPHA_FPRM_NORM;\n-\n+  alpha_fprm = ALPHA_FPRM_NORM;\n   alpha_tp = ALPHA_TP_PROG;\n   alpha_fptm = ALPHA_FPTM_N;\n \n-  /* We cannot use su and sui qualifiers for conversion instructions on\n-     Unicos/Mk.  I'm not sure if this is due to assembler or hardware\n-     limitations.  Right now, we issue a warning if -mieee is specified\n-     and then ignore it; eventually, we should either get it right or\n-     disable the option altogether.  */\n-\n   if (TARGET_IEEE)\n     {\n-      if (TARGET_ABI_UNICOSMK)\n-\twarning (0, \"-mieee not supported on Unicos/Mk\");\n-      else\n-\t{\n-\t  alpha_tp = ALPHA_TP_INSN;\n-\t  alpha_fptm = ALPHA_FPTM_SU;\n-\t}\n+      alpha_tp = ALPHA_TP_INSN;\n+      alpha_fptm = ALPHA_FPTM_SU;\n     }\n-\n   if (TARGET_IEEE_WITH_INEXACT)\n     {\n-      if (TARGET_ABI_UNICOSMK)\n-\twarning (0, \"-mieee-with-inexact not supported on Unicos/Mk\");\n-      else\n-\t{\n-\t  alpha_tp = ALPHA_TP_INSN;\n-\t  alpha_fptm = ALPHA_FPTM_SUI;\n-\t}\n+      alpha_tp = ALPHA_TP_INSN;\n+      alpha_fptm = ALPHA_FPTM_SUI;\n     }\n \n   if (alpha_tp_string)\n@@ -413,12 +377,6 @@ alpha_option_override (void)\n \n   /* Do some sanity checks on the above options.  */\n \n-  if (TARGET_ABI_UNICOSMK && alpha_fptm != ALPHA_FPTM_N)\n-    {\n-      warning (0, \"trap mode not supported on Unicos/Mk\");\n-      alpha_fptm = ALPHA_FPTM_N;\n-    }\n-\n   if ((alpha_fptm == ALPHA_FPTM_SU || alpha_fptm == ALPHA_FPTM_SUI)\n       && alpha_tp != ALPHA_TP_INSN && alpha_cpu != PROCESSOR_EV6)\n     {\n@@ -540,11 +498,6 @@ alpha_option_override (void)\n   if (!(target_flags_explicit & MASK_LONG_DOUBLE_128))\n     target_flags |= MASK_LONG_DOUBLE_128;\n #endif\n-\n-  /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).  */\n-  if (TARGET_ABI_UNICOSMK)\n-    targetm.expand_builtin_va_start = NULL;\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -614,8 +567,7 @@ resolve_reload_operand (rtx op)\n \n /* The scalar modes supported differs from the default check-what-c-supports\n    version in that sometimes TFmode is available even when long double\n-   indicates only DFmode.  On unicosmk, we have the situation that HImode\n-   doesn't map to any C type, but of course we still support that.  */\n+   indicates only DFmode.  */\n \n static bool\n alpha_scalar_mode_supported_p (enum machine_mode mode)\n@@ -657,7 +609,7 @@ alpha_vector_mode_supported_p (enum machine_mode mode)\n int\n direct_return (void)\n {\n-  return (! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\n+  return (!TARGET_ABI_OPEN_VMS\n \t  && reload_completed\n \t  && alpha_sa_size () == 0\n \t  && get_frame_size () == 0\n@@ -4805,15 +4757,6 @@ alpha_multipass_dfa_lookahead (void)\n \n struct GTY(()) machine_function\n {\n-  /* For unicosmk.  */\n-  /* List of call information words for calls from this function.  */\n-  struct rtx_def *first_ciw;\n-  struct rtx_def *last_ciw;\n-  int ciw_count;\n-\n-  /* List of deferred case vectors.  */\n-  struct rtx_def *addr_list;\n-\n   /* For OSF.  */\n   const char *some_ld_name;\n \n@@ -5365,18 +5308,6 @@ print_operand (FILE *file, rtx x, int code)\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, (64 - INTVAL (x)) / 8);\n       break;\n \n-    case 't':\n-      {\n-        /* On Unicos/Mk systems: use a DEX expression if the symbol\n-\t   clashes with a register name.  */\n-\tint dex = unicosmk_need_dex (x);\n-\tif (dex)\n-\t  fprintf (file, \"DEX(%d)\", dex);\n-\telse\n-\t  output_addr_const (file, x);\n-      }\n-      break;\n-\n     case 'C': case 'D': case 'c': case 'd':\n       /* Write out comparison name.  */\n       {\n@@ -5739,8 +5670,6 @@ alpha_arg_partial_bytes (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n   if (cum->num_args < 6\n       && 6 < cum->num_args + ALPHA_ARG_SIZE (mode, type, named))\n     words = 6 - cum->num_args;\n-#elif TARGET_ABI_UNICOSMK\n-  /* Never any split arguments.  */\n #elif TARGET_ABI_OSF\n   if (*cum < 6 && 6 < *cum + ALPHA_ARG_SIZE (mode, type, named))\n     words = 6 - *cum;\n@@ -5897,7 +5826,7 @@ alpha_build_builtin_va_list (void)\n {\n   tree base, ofs, space, record, type_decl;\n \n-  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n+  if (TARGET_ABI_OPEN_VMS)\n     return ptr_type_node;\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -6156,21 +6085,7 @@ alpha_setup_incoming_varargs (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n   /* Skip the current argument.  */\n   targetm.calls.function_arg_advance (&cum, mode, type, true);\n \n-#if TARGET_ABI_UNICOSMK\n-  /* On Unicos/Mk, the standard subroutine __T3E_MISMATCH stores all register\n-     arguments on the stack. Unfortunately, it doesn't always store the first\n-     one (i.e. the one that arrives in $16 or $f16). This is not a problem\n-     with stdargs as we always have at least one named argument there.  */\n-  if (cum.num_reg_words < 6)\n-    {\n-      if (!no_rtl)\n-\t{\n-\t  emit_insn (gen_umk_mismatch_args (GEN_INT (cum.num_reg_words)));\n-\t  emit_insn (gen_arg_home_umk ());\n-\t}\n-      *pretend_size = 0;\n-    }\n-#elif TARGET_ABI_OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS\n   /* For VMS, we allocate space for all 6 arg registers plus a count.\n \n      However, if NO registers need to be saved, don't allocate any space.\n@@ -6251,9 +6166,6 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   if (TREE_CODE (TREE_TYPE (valist)) == ERROR_MARK)\n     return;\n \n-  if (TARGET_ABI_UNICOSMK)\n-    std_expand_builtin_va_start (valist, nextarg);\n-\n   /* For Unix, TARGET_SETUP_INCOMING_VARARGS moves the starting address base\n      up by 48, storing fp arg registers in the first 48 bytes, and the\n      integer arg registers in the next 48 bytes.  This is only done,\n@@ -6383,7 +6295,7 @@ alpha_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   tree offset_field, base_field, offset, base, t, r;\n   bool indirect;\n \n-  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n+  if (TARGET_ABI_OPEN_VMS)\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n   base_field = TYPE_FIELDS (va_list_type_node);\n@@ -7316,8 +7228,7 @@ alpha_sa_mask (unsigned long *imaskP, unsigned long *fmaskP)\n   /* One for every register we have to save.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (! fixed_regs[i] && ! call_used_regs[i]\n-\t&& df_regs_ever_live_p (i) && i != REG_RA\n-\t&& (!TARGET_ABI_UNICOSMK || i != HARD_FRAME_POINTER_REGNUM))\n+\t&& df_regs_ever_live_p (i) && i != REG_RA)\n       {\n \tif (i < 32)\n \t  imask |= (1UL << i);\n@@ -7356,40 +7267,12 @@ alpha_sa_size (void)\n \n   alpha_sa_mask (&mask[0], &mask[1]);\n \n-  if (TARGET_ABI_UNICOSMK)\n-    {\n-      if (mask[0] || mask[1])\n-\tsa_size = 14;\n-    }\n-  else\n-    {\n-      for (j = 0; j < 2; ++j)\n-\tfor (i = 0; i < 32; ++i)\n-\t  if ((mask[j] >> i) & 1)\n-\t    sa_size++;\n-    }\n-\n-  if (TARGET_ABI_UNICOSMK)\n-    {\n-      /* We might not need to generate a frame if we don't make any calls\n-\t (including calls to __T3E_MISMATCH if this is a vararg function),\n-\t don't have any local variables which require stack slots, don't\n-\t use alloca and have not determined that we need a frame for other\n-\t reasons.  */\n-\n-      alpha_procedure_type\n-\t= (sa_size || get_frame_size() != 0\n-\t   || crtl->outgoing_args_size\n-\t   || cfun->stdarg || cfun->calls_alloca\n-\t   || frame_pointer_needed)\n-\t  ? PT_STACK : PT_REGISTER;\n+  for (j = 0; j < 2; ++j)\n+    for (i = 0; i < 32; ++i)\n+      if ((mask[j] >> i) & 1)\n+\tsa_size++;\n \n-      /* Always reserve space for saving callee-saved registers if we\n-\t need a frame as required by the calling convention.  */\n-      if (alpha_procedure_type == PT_STACK)\n-        sa_size = 14;\n-    }\n-  else if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Start with a stack procedure if we make any calls (REG_RA used), or\n \t need a frame pointer, with a register procedure if we otherwise need\n@@ -7764,12 +7647,6 @@ compute_frame_size (HOST_WIDE_INT size, HOST_WIDE_INT sa_size)\n \t\t\t+ (alpha_procedure_type == PT_STACK ? 8 : 0)\n \t\t\t+ size\n \t\t\t+ crtl->args.pretend_args_size);\n-  else if (TARGET_ABI_UNICOSMK)\n-    /* We have to allocate space for the DSIB if we generate a frame.  */\n-    return ALPHA_ROUND (sa_size\n-\t\t\t+ (alpha_procedure_type == PT_STACK ? 48 : 0))\n-\t   + ALPHA_ROUND (size\n-\t\t\t  + crtl->outgoing_args_size);\n   else\n     return ALPHA_ROUND (crtl->outgoing_args_size)\n \t   + sa_size\n@@ -7801,7 +7678,7 @@ alpha_expand_prologue (void)\n   unsigned long imask = 0;\n   unsigned long fmask = 0;\n   /* Stack space needed for pushing registers clobbered by us.  */\n-  HOST_WIDE_INT sa_size;\n+  HOST_WIDE_INT sa_size, sa_bias;\n   /* Complete stack size needed.  */\n   HOST_WIDE_INT frame_size;\n   /* Probed stack size; it additionally includes the size of\n@@ -7840,9 +7717,6 @@ alpha_expand_prologue (void)\n   if (TARGET_PROFILING_NEEDS_GP && crtl->profile)\n     emit_insn (gen_prologue_mcount ());\n \n-  if (TARGET_ABI_UNICOSMK)\n-    unicosmk_gen_dsib (&imask);\n-\n   /* Adjust the stack by the frame size.  If the frame size is > 4096\n      bytes, we need to be sure we probe somewhere in the first and last\n      4096 bytes (we can probably get away without the latter test) and\n@@ -7863,9 +7737,7 @@ alpha_expand_prologue (void)\n \t  int probed;\n \n \t  for (probed = 4096; probed < probed_size; probed += 8192)\n-\t    emit_insn (gen_probe_stack (GEN_INT (TARGET_ABI_UNICOSMK\n-\t\t\t\t\t\t ? -probed + 64\n-\t\t\t\t\t\t : -probed)));\n+\t    emit_insn (gen_probe_stack (GEN_INT (-probed)));\n \n \t  /* We only have to do this probe if we aren't saving registers or\n \t     if we are probing beyond the frame because of -fstack-check.  */\n@@ -7876,9 +7748,7 @@ alpha_expand_prologue (void)\n \n       if (frame_size != 0)\n \tFRP (emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (TARGET_ABI_UNICOSMK\n-\t\t\t\t\t     ? -frame_size + 64\n-\t\t\t\t\t     : -frame_size))));\n+\t\t\t\t    GEN_INT (-frame_size))));\n     }\n   else\n     {\n@@ -7896,8 +7766,7 @@ alpha_expand_prologue (void)\n       rtx seq;\n \n       emit_move_insn (count, GEN_INT (blocks));\n-      emit_insn (gen_adddi3 (ptr, stack_pointer_rtx,\n-\t\t\t     GEN_INT (TARGET_ABI_UNICOSMK ? 4096 - 64 : 4096)));\n+      emit_insn (gen_adddi3 (ptr, stack_pointer_rtx, GEN_INT (4096)));\n \n       /* Because of the difficulty in emitting a new basic block this\n \t late in the compilation, generate the loop as a single insn.  */\n@@ -7944,88 +7813,62 @@ alpha_expand_prologue (void)\n       RTX_FRAME_RELATED_P (seq) = 1;\n       add_reg_note (seq, REG_FRAME_RELATED_EXPR,\n \t\t    gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t       GEN_INT (TARGET_ABI_UNICOSMK\n-\t\t\t\t\t\t\t? -frame_size + 64\n-\t\t\t\t\t\t\t: -frame_size))));\n+\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t-frame_size)));\n     }\n \n-  if (!TARGET_ABI_UNICOSMK)\n+  /* Cope with very large offsets to the register save area.  */\n+  sa_bias = 0;\n+  sa_reg = stack_pointer_rtx;\n+  if (reg_offset + sa_size > 0x8000)\n     {\n-      HOST_WIDE_INT sa_bias = 0;\n-\n-      /* Cope with very large offsets to the register save area.  */\n-      sa_reg = stack_pointer_rtx;\n-      if (reg_offset + sa_size > 0x8000)\n-\t{\n-\t  int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n-\t  rtx sa_bias_rtx;\n-\n-\t  if (low + sa_size <= 0x8000)\n-\t    sa_bias = reg_offset - low, reg_offset = low;\n-\t  else\n-\t    sa_bias = reg_offset, reg_offset = 0;\n+      int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n+      rtx sa_bias_rtx;\n \n-\t  sa_reg = gen_rtx_REG (DImode, 24);\n-\t  sa_bias_rtx = GEN_INT (sa_bias);\n-\n-\t  if (add_operand (sa_bias_rtx, DImode))\n-\t    emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, sa_bias_rtx));\n-\t  else\n-\t    {\n-\t      emit_move_insn (sa_reg, sa_bias_rtx);\n-\t      emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, sa_reg));\n-\t    }\n-\t}\n+      if (low + sa_size <= 0x8000)\n+\tsa_bias = reg_offset - low, reg_offset = low;\n+      else\n+\tsa_bias = reg_offset, reg_offset = 0;\n \n-      /* Save regs in stack order.  Beginning with VMS PV.  */\n-      if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n-\temit_frame_store (REG_PV, stack_pointer_rtx, 0, 0);\n+      sa_reg = gen_rtx_REG (DImode, 24);\n+      sa_bias_rtx = GEN_INT (sa_bias);\n \n-      /* Save register RA next.  */\n-      if (imask & (1UL << REG_RA))\n+      if (add_operand (sa_bias_rtx, DImode))\n+\temit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, sa_bias_rtx));\n+      else\n \t{\n-\t  emit_frame_store (REG_RA, sa_reg, sa_bias, reg_offset);\n-\t  imask &= ~(1UL << REG_RA);\n-\t  reg_offset += 8;\n+\t  emit_move_insn (sa_reg, sa_bias_rtx);\n+\t  emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, sa_reg));\n \t}\n+    }\n \n-      /* Now save any other registers required to be saved.  */\n-      for (i = 0; i < 31; i++)\n-\tif (imask & (1UL << i))\n-\t  {\n-\t    emit_frame_store (i, sa_reg, sa_bias, reg_offset);\n-\t    reg_offset += 8;\n-\t  }\n+  /* Save regs in stack order.  Beginning with VMS PV.  */\n+  if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n+    emit_frame_store (REG_PV, stack_pointer_rtx, 0, 0);\n \n-      for (i = 0; i < 31; i++)\n-\tif (fmask & (1UL << i))\n-\t  {\n-\t    emit_frame_store (i+32, sa_reg, sa_bias, reg_offset);\n-\t    reg_offset += 8;\n-\t  }\n-    }\n-  else if (TARGET_ABI_UNICOSMK && alpha_procedure_type == PT_STACK)\n+  /* Save register RA next.  */\n+  if (imask & (1UL << REG_RA))\n     {\n-      /* The standard frame on the T3E includes space for saving registers.\n-\t We just have to use it. We don't have to save the return address and\n-\t the old frame pointer here - they are saved in the DSIB.  */\n-\n-      reg_offset = -56;\n-      for (i = 9; i < 15; i++)\n-\tif (imask & (1UL << i))\n-\t  {\n-\t    emit_frame_store (i, hard_frame_pointer_rtx, 0, reg_offset);\n-\t    reg_offset -= 8;\n-\t  }\n-      for (i = 2; i < 10; i++)\n-\tif (fmask & (1UL << i))\n-\t  {\n-\t    emit_frame_store (i+32, hard_frame_pointer_rtx, 0, reg_offset);\n-\t    reg_offset -= 8;\n-\t  }\n+      emit_frame_store (REG_RA, sa_reg, sa_bias, reg_offset);\n+      imask &= ~(1UL << REG_RA);\n+      reg_offset += 8;\n     }\n \n+  /* Now save any other registers required to be saved.  */\n+  for (i = 0; i < 31; i++)\n+    if (imask & (1UL << i))\n+      {\n+\temit_frame_store (i, sa_reg, sa_bias, reg_offset);\n+\treg_offset += 8;\n+      }\n+\n+  for (i = 0; i < 31; i++)\n+    if (fmask & (1UL << i))\n+      {\n+\temit_frame_store (i+32, sa_reg, sa_bias, reg_offset);\n+\treg_offset += 8;\n+      }\n+\n   if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Register frame procedures save the fp.  */\n@@ -8073,7 +7916,7 @@ alpha_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (seq) = ! frame_pointer_needed;\n \t}\n     }\n-  else if (!TARGET_ABI_UNICOSMK)\n+  else\n     {\n       /* If we need a frame pointer, set it from the stack pointer.  */\n       if (frame_pointer_needed)\n@@ -8127,14 +7970,6 @@ alpha_start_function (FILE *file, const char *fnname,\n   char *tramp_label = (char *) alloca (strlen (fnname) + 6);\n   int i;\n \n-  /* Don't emit an extern directive for functions defined in the same file.  */\n-  if (TARGET_ABI_UNICOSMK)\n-    {\n-      tree name_tree;\n-      name_tree = get_identifier (fnname);\n-      TREE_ASM_WRITTEN (name_tree) = 1;\n-    }\n-\n #if TARGET_ABI_OPEN_VMS\n   if (vms_debug_main\n       && strncmp (vms_debug_main, fnname, strlen (vms_debug_main)) == 0)\n@@ -8179,8 +8014,7 @@ alpha_start_function (FILE *file, const char *fnname,\n     }\n \n   /* Issue function start and label.  */\n-  if (TARGET_ABI_OPEN_VMS\n-      || (!TARGET_ABI_UNICOSMK && !flag_inhibit_size_directive))\n+  if (TARGET_ABI_OPEN_VMS || !flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.ent \", file);\n       assemble_name (file, fnname);\n@@ -8216,18 +8050,13 @@ alpha_start_function (FILE *file, const char *fnname,\n   if (TARGET_ABI_OPEN_VMS)\n     strcat (entry_label, \"..en\");\n \n-  /* For public functions, the label must be globalized by appending an\n-     additional colon.  */\n-  if (TARGET_ABI_UNICOSMK && TREE_PUBLIC (decl))\n-    strcat (entry_label, \":\");\n-\n   ASM_OUTPUT_LABEL (file, entry_label);\n   inside_function = TRUE;\n \n   if (TARGET_ABI_OPEN_VMS)\n     fprintf (file, \"\\t.base $%d\\n\", vms_base_regno);\n \n-  if (!TARGET_ABI_OPEN_VMS && !TARGET_ABI_UNICOSMK && TARGET_IEEE_CONFORMANT\n+  if (!TARGET_ABI_OPEN_VMS && TARGET_IEEE_CONFORMANT\n       && !flag_inhibit_size_directive)\n     {\n       /* Set flags in procedure descriptor to request IEEE-conformant\n@@ -8243,9 +8072,7 @@ alpha_start_function (FILE *file, const char *fnname,\n   /* Describe our frame.  If the frame size is larger than an integer,\n      print it as zero to avoid an assembler error.  We won't be\n      properly describing such a frame, but that's the best we can do.  */\n-  if (TARGET_ABI_UNICOSMK)\n-    ;\n-  else if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     fprintf (file, \"\\t.frame $%d,\" HOST_WIDE_INT_PRINT_DEC \",$26,\"\n \t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t     vms_unwind_regno,\n@@ -8259,9 +8086,7 @@ alpha_start_function (FILE *file, const char *fnname,\n \t     crtl->args.pretend_args_size);\n \n   /* Describe which registers were spilled.  */\n-  if (TARGET_ABI_UNICOSMK)\n-    ;\n-  else if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       if (imask)\n         /* ??? Does VMS care if mask contains ra?  The old code didn't\n@@ -8317,9 +8142,7 @@ alpha_start_function (FILE *file, const char *fnname,\n static void\n alpha_output_function_end_prologue (FILE *file)\n {\n-  if (TARGET_ABI_UNICOSMK)\n-    ;\n-  else if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     fputs (\"\\t.prologue\\n\", file);\n   else if (TARGET_ABI_WINDOWS_NT)\n     fputs (\"\\t.prologue 0\\n\", file);\n@@ -8375,7 +8198,7 @@ alpha_expand_epilogue (void)\n   else\n     eh_ofs = NULL_RTX;\n \n-  if (!TARGET_ABI_UNICOSMK && sa_size)\n+  if (sa_size)\n     {\n       /* If we have a frame pointer, restore SP from it.  */\n       if ((TARGET_ABI_OPEN_VMS\n@@ -8440,43 +8263,6 @@ alpha_expand_epilogue (void)\n \t    reg_offset += 8;\n \t  }\n     }\n-  else if (TARGET_ABI_UNICOSMK && alpha_procedure_type == PT_STACK)\n-    {\n-      /* Restore callee-saved general-purpose registers.  */\n-\n-      reg_offset = -56;\n-\n-      for (i = 9; i < 15; i++)\n-\tif (imask & (1UL << i))\n-\t  {\n-\t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n-\t\t\t\t\t\t     reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    reg = gen_rtx_REG (DImode, i);\n-\t    emit_move_insn (reg, mem);\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n-\t    reg_offset -= 8;\n-\t  }\n-\n-      for (i = 2; i < 10; i++)\n-\tif (fmask & (1UL << i))\n-\t  {\n-\t    mem = gen_rtx_MEM (DFmode, plus_constant(hard_frame_pointer_rtx,\n-\t\t\t\t\t\t     reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    reg = gen_rtx_REG (DFmode, i+32);\n-\t    emit_move_insn (reg, mem);\n-\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n-\t    reg_offset -= 8;\n-\t  }\n-\n-      /* Restore the return address from the DSIB.  */\n-      mem = gen_rtx_MEM (DImode, plus_constant (hard_frame_pointer_rtx, -8));\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-      reg = gen_rtx_REG (DImode, REG_RA);\n-      emit_move_insn (reg, mem);\n-      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n-    }\n \n   if (frame_size || eh_ofs)\n     {\n@@ -8492,15 +8278,8 @@ alpha_expand_epilogue (void)\n       /* If the stack size is large, begin computation into a temporary\n \t register so as not to interfere with a potential fp restore,\n \t which must be consecutive with an SP restore.  */\n-      if (frame_size < 32768\n-\t  && ! (TARGET_ABI_UNICOSMK && cfun->calls_alloca))\n+      if (frame_size < 32768 && !cfun->calls_alloca)\n \tsp_adj2 = GEN_INT (frame_size);\n-      else if (TARGET_ABI_UNICOSMK)\n-\t{\n-\t  sp_adj1 = gen_rtx_REG (DImode, 23);\n-\t  emit_move_insn (sp_adj1, hard_frame_pointer_rtx);\n-\t  sp_adj2 = const0_rtx;\n-\t}\n       else if (frame_size < 0x40007fffL)\n \t{\n \t  int low = ((frame_size & 0xffff) ^ 0x8000) - 0x8000;\n@@ -8532,17 +8311,7 @@ alpha_expand_epilogue (void)\n       /* From now on, things must be in order.  So emit blockages.  */\n \n       /* Restore the frame pointer.  */\n-      if (TARGET_ABI_UNICOSMK)\n-\t{\n-\t  emit_insn (gen_blockage ());\n-\t  mem = gen_rtx_MEM (DImode,\n-\t\t\t     plus_constant (hard_frame_pointer_rtx, -16));\n-\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t  emit_move_insn (hard_frame_pointer_rtx, mem);\n-\t  cfa_restores = alloc_reg_note (REG_CFA_RESTORE,\n-\t\t\t\t\t hard_frame_pointer_rtx, cfa_restores);\n-\t}\n-      else if (fp_is_frame_pointer)\n+      if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n \t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, fp_offset));\n@@ -8583,14 +8352,6 @@ alpha_expand_epilogue (void)\n \t  add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n         }\n-      else if (TARGET_ABI_UNICOSMK && alpha_procedure_type != PT_STACK)\n-\t{\n-\t  /* Decrement the frame pointer if the function does not have a\n-\t     frame.  */\n-\t  emit_insn (gen_blockage ());\n-\t  emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-\t\t\t\t hard_frame_pointer_rtx, constm1_rtx));\n-        }\n     }\n }\n \f\n@@ -8615,20 +8376,13 @@ alpha_end_function (FILE *file, const char *fnname, tree decl ATTRIBUTE_UNUSED)\n #endif\n \n   /* End the function.  */\n-  if (!TARGET_ABI_UNICOSMK && !flag_inhibit_size_directive)\n+  if (!flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.end \", file);\n       assemble_name (file, fnname);\n       putc ('\\n', file);\n     }\n   inside_function = FALSE;\n-\n-  /* Output jump tables and the static subroutine information block.  */\n-  if (TARGET_ABI_UNICOSMK)\n-    {\n-      unicosmk_output_ssib (file, fnname);\n-      unicosmk_output_deferred_case_vectors (file);\n-    }\n }\n \n #if TARGET_ABI_OPEN_VMS\n@@ -9732,8 +9486,6 @@ alpha_reorg (void)\n     }\n }\n \f\n-#if !TARGET_ABI_UNICOSMK\n-\n #ifdef HAVE_STAMP_H\n #include <stamp.h>\n #endif\n@@ -9777,7 +9529,6 @@ alpha_file_start (void)\n       fprintf (asm_out_file, \"\\t.arch %s\\n\", arch);\n     }\n }\n-#endif\n \n #ifdef OBJECT_FORMAT_ELF\n /* Since we don't have a .dynbss section, we should not allow global\n@@ -10185,796 +9936,10 @@ alpha_use_linkage (rtx func ATTRIBUTE_UNUSED,\n \n #endif /* TARGET_ABI_OPEN_VMS */\n \f\n-#if TARGET_ABI_UNICOSMK\n-\n-/* This evaluates to true if we do not know how to pass TYPE solely in\n-   registers.  This is the case for all arguments that do not fit in two\n-   registers.  */\n-\n-static bool\n-unicosmk_must_pass_in_stack (enum machine_mode mode, const_tree type)\n-{\n-  if (type == NULL)\n-    return false;\n-\n-  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-    return true;\n-  if (TREE_ADDRESSABLE (type))\n-    return true;\n-\n-  return ALPHA_ARG_SIZE (mode, type, 0) > 2;\n-}\n-\n-/* Define the offset between two registers, one to be eliminated, and the\n-   other its replacement, at the start of a routine.  */\n-\n-int\n-unicosmk_initial_elimination_offset (int from, int to)\n-{\n-  int fixed_size;\n-\n-  fixed_size = alpha_sa_size();\n-  if (fixed_size != 0)\n-    fixed_size += 48;\n-\n-  if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n-    return -fixed_size;\n-  else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n-    return 0;\n-  else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return (ALPHA_ROUND (crtl->outgoing_args_size)\n-\t    + ALPHA_ROUND (get_frame_size()));\n-  else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return (ALPHA_ROUND (fixed_size)\n-\t    + ALPHA_ROUND (get_frame_size()\n-\t\t\t   + crtl->outgoing_args_size));\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Output the module name for .ident and .end directives. We have to strip\n-   directories and add make sure that the module name starts with a letter\n-   or '$'.  */\n-\n-static void\n-unicosmk_output_module_name (FILE *file)\n-{\n-  const char *name = lbasename (main_input_filename);\n-  unsigned len = strlen (name);\n-  char *clean_name = alloca (len + 2);\n-  char *ptr = clean_name;\n-\n-  /* CAM only accepts module names that start with a letter or '$'. We\n-     prefix the module name with a '$' if necessary.  */\n-\n-  if (!ISALPHA (*name))\n-    *ptr++ = '$';\n-  memcpy (ptr, name, len + 1);\n-  clean_symbol_name (clean_name);\n-  fputs (clean_name, file);\n-}\n-\n-/* Output the definition of a common variable.  */\n-\n-void\n-unicosmk_output_common (FILE *file, const char *name, int size, int align)\n-{\n-  tree name_tree;\n-  printf (\"T3E__: common %s\\n\", name);\n-\n-  in_section = NULL;\n-  fputs(\"\\t.endp\\n\\n\\t.psect \", file);\n-  assemble_name(file, name);\n-  fprintf(file, \",%d,common\\n\", floor_log2 (align / BITS_PER_UNIT));\n-  fprintf(file, \"\\t.byte\\t0:%d\\n\", size);\n-\n-  /* Mark the symbol as defined in this module.  */\n-  name_tree = get_identifier (name);\n-  TREE_ASM_WRITTEN (name_tree) = 1;\n-}\n-\n-#define SECTION_PUBLIC SECTION_MACH_DEP\n-#define SECTION_MAIN (SECTION_PUBLIC << 1)\n-static int current_section_align;\n-\n-/* A get_unnamed_section callback for switching to the text section.  */\n-\n-static void\n-unicosmk_output_text_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n-{\n-  static int count = 0;\n-  fprintf (asm_out_file, \"\\t.endp\\n\\n\\t.psect\\tgcc@text___%d,code\\n\", count++);\n-}\n-\n-/* A get_unnamed_section callback for switching to the data section.  */\n-\n-static void\n-unicosmk_output_data_section_asm_op (const void *data ATTRIBUTE_UNUSED)\n-{\n-  static int count = 1;\n-  fprintf (asm_out_file, \"\\t.endp\\n\\n\\t.psect\\tgcc@data___%d,data\\n\", count++);\n-}\n-\n-/* Implement TARGET_ASM_INIT_SECTIONS.\n-\n-   The Cray assembler is really weird with respect to sections. It has only\n-   named sections and you can't reopen a section once it has been closed.\n-   This means that we have to generate unique names whenever we want to\n-   reenter the text or the data section.  */\n-\n-static void\n-unicosmk_init_sections (void)\n-{\n-  text_section = get_unnamed_section (SECTION_CODE,\n-\t\t\t\t      unicosmk_output_text_section_asm_op,\n-\t\t\t\t      NULL);\n-  data_section = get_unnamed_section (SECTION_WRITE,\n-\t\t\t\t      unicosmk_output_data_section_asm_op,\n-\t\t\t\t      NULL);\n-  readonly_data_section = data_section;\n-}\n-\n-static unsigned int\n-unicosmk_section_type_flags (tree decl, const char *name,\n-\t\t\t     int reloc ATTRIBUTE_UNUSED)\n-{\n-  unsigned int flags = default_section_type_flags (decl, name, reloc);\n-\n-  if (!decl)\n-    return flags;\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      current_section_align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n-      if (align_functions_log > current_section_align)\n-\tcurrent_section_align = align_functions_log;\n-\n-      if (! strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), \"main\"))\n-\tflags |= SECTION_MAIN;\n-    }\n-  else\n-    current_section_align = floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT);\n-\n-  if (TREE_PUBLIC (decl))\n-    flags |= SECTION_PUBLIC;\n-\n-  return flags;\n-}\n-\n-/* Generate a section name for decl and associate it with the\n-   declaration.  */\n-\n-static void\n-unicosmk_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n-{\n-  const char *name;\n-  int len;\n-\n-  gcc_assert (decl);\n-\n-  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  name = default_strip_name_encoding (name);\n-  len = strlen (name);\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      char *string;\n-\n-      /* It is essential that we prefix the section name here because\n-\t otherwise the section names generated for constructors and\n-\t destructors confuse collect2.  */\n-\n-      string = alloca (len + 6);\n-      sprintf (string, \"code@%s\", name);\n-      DECL_SECTION_NAME (decl) = build_string (len + 5, string);\n-    }\n-  else if (TREE_PUBLIC (decl))\n-    DECL_SECTION_NAME (decl) = build_string (len, name);\n-  else\n-    {\n-      char *string;\n-\n-      string = alloca (len + 6);\n-      sprintf (string, \"data@%s\", name);\n-      DECL_SECTION_NAME (decl) = build_string (len + 5, string);\n-    }\n-}\n-\n-/* Switch to an arbitrary section NAME with attributes as specified\n-   by FLAGS.  ALIGN specifies any known alignment requirements for\n-   the section; 0 if the default should be used.  */\n-\n-static void\n-unicosmk_asm_named_section (const char *name, unsigned int flags, \n-\t\t\t    tree decl ATTRIBUTE_UNUSED)\n-{\n-  const char *kind;\n-\n-  /* Close the previous section.  */\n-\n-  fputs (\"\\t.endp\\n\\n\", asm_out_file);\n-\n-  /* Find out what kind of section we are opening.  */\n-\n-  if (flags & SECTION_MAIN)\n-    fputs (\"\\t.start\\tmain\\n\", asm_out_file);\n-\n-  if (flags & SECTION_CODE)\n-    kind = \"code\";\n-  else if (flags & SECTION_PUBLIC)\n-    kind = \"common\";\n-  else\n-    kind = \"data\";\n-\n-  if (current_section_align != 0)\n-    fprintf (asm_out_file, \"\\t.psect\\t%s,%d,%s\\n\", name,\n-\t     current_section_align, kind);\n-  else\n-    fprintf (asm_out_file, \"\\t.psect\\t%s,%s\\n\", name, kind);\n-}\n-\n-static void\n-unicosmk_insert_attributes (tree decl, tree *attr_ptr ATTRIBUTE_UNUSED)\n-{\n-  if (DECL_P (decl)\n-      && (TREE_PUBLIC (decl) || TREE_CODE (decl) == FUNCTION_DECL))\n-    unicosmk_unique_section (decl, 0);\n-}\n-\n-/* Output an alignment directive. We have to use the macro 'gcc@code@align'\n-   in code sections because .align fill unused space with zeroes.  */\n-\n-void\n-unicosmk_output_align (FILE *file, int align)\n-{\n-  if (inside_function)\n-    fprintf (file, \"\\tgcc@code@align\\t%d\\n\", align);\n-  else\n-    fprintf (file, \"\\t.align\\t%d\\n\", align);\n-}\n-\n-/* Add a case vector to the current function's list of deferred case\n-   vectors. Case vectors have to be put into a separate section because CAM\n-   does not allow data definitions in code sections.  */\n-\n-void\n-unicosmk_defer_case_vector (rtx lab, rtx vec)\n-{\n-  struct machine_function *machine = cfun->machine;\n-\n-  vec = gen_rtx_EXPR_LIST (VOIDmode, lab, vec);\n-  machine->addr_list = gen_rtx_EXPR_LIST (VOIDmode, vec,\n-\t\t\t\t\t  machine->addr_list);\n-}\n-\n-/* Output a case vector.  */\n-\n-static void\n-unicosmk_output_addr_vec (FILE *file, rtx vec)\n-{\n-  rtx lab  = XEXP (vec, 0);\n-  rtx body = XEXP (vec, 1);\n-  int vlen = XVECLEN (body, 0);\n-  int idx;\n-\n-  (*targetm.asm_out.internal_label) (file, \"L\", CODE_LABEL_NUMBER (lab));\n-\n-  for (idx = 0; idx < vlen; idx++)\n-    {\n-      ASM_OUTPUT_ADDR_VEC_ELT\n-        (file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));\n-    }\n-}\n-\n-/* Output current function's deferred case vectors.  */\n-\n-static void\n-unicosmk_output_deferred_case_vectors (FILE *file)\n-{\n-  struct machine_function *machine = cfun->machine;\n-  rtx t;\n-\n-  if (machine->addr_list == NULL_RTX)\n-    return;\n-\n-  switch_to_section (data_section);\n-  for (t = machine->addr_list; t; t = XEXP (t, 1))\n-    unicosmk_output_addr_vec (file, XEXP (t, 0));\n-}\n-\n-/* Generate the name of the SSIB section for the current function.  */\n-\n-#define SSIB_PREFIX \"__SSIB_\"\n-#define SSIB_PREFIX_LEN 7\n-\n-static const char *\n-unicosmk_ssib_name (void)\n-{\n-  /* This is ok since CAM won't be able to deal with names longer than that\n-     anyway.  */\n-\n-  static char name[256];\n-\n-  rtx x;\n-  const char *fnname;\n-  int len;\n-\n-  x = DECL_RTL (cfun->decl);\n-  gcc_assert (MEM_P (x));\n-  x = XEXP (x, 0);\n-  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-  fnname = XSTR (x, 0);\n-\n-  len = strlen (fnname);\n-  if (len + SSIB_PREFIX_LEN > 255)\n-    len = 255 - SSIB_PREFIX_LEN;\n-\n-  strcpy (name, SSIB_PREFIX);\n-  strncpy (name + SSIB_PREFIX_LEN, fnname, len);\n-  name[len + SSIB_PREFIX_LEN] = 0;\n-\n-  return name;\n-}\n-\n-/* Set up the dynamic subprogram information block (DSIB) and update the\n-   frame pointer register ($15) for subroutines which have a frame. If the\n-   subroutine doesn't have a frame, simply increment $15.  */\n-\n-static void\n-unicosmk_gen_dsib (unsigned long *imaskP)\n-{\n-  if (alpha_procedure_type == PT_STACK)\n-    {\n-      const char *ssib_name;\n-      rtx mem;\n-\n-      /* Allocate 64 bytes for the DSIB.  */\n-\n-      FRP (emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n-                                  GEN_INT (-64))));\n-      emit_insn (gen_blockage ());\n-\n-      /* Save the return address.  */\n-\n-      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 56));\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n-      (*imaskP) &= ~(1UL << REG_RA);\n-\n-      /* Save the old frame pointer.  */\n-\n-      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 48));\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (mem, hard_frame_pointer_rtx));\n-      (*imaskP) &= ~(1UL << HARD_FRAME_POINTER_REGNUM);\n-\n-      emit_insn (gen_blockage ());\n-\n-      /* Store the SSIB pointer.  */\n-\n-      ssib_name = ggc_strdup (unicosmk_ssib_name ());\n-      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 32));\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-\n-      FRP (emit_move_insn (gen_rtx_REG (DImode, 5),\n-                           gen_rtx_SYMBOL_REF (Pmode, ssib_name)));\n-      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, 5)));\n-\n-      /* Save the CIW index.  */\n-\n-      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 24));\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, 25)));\n-\n-      emit_insn (gen_blockage ());\n-\n-      /* Set the new frame pointer.  */\n-      FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-                                  stack_pointer_rtx, GEN_INT (64))));\n-    }\n-  else\n-    {\n-      /* Increment the frame pointer register to indicate that we do not\n-         have a frame.  */\n-      emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n-                             hard_frame_pointer_rtx, const1_rtx));\n-    }\n-}\n-\n-/* Output the static subroutine information block for the current\n-   function.  */\n-\n-static void\n-unicosmk_output_ssib (FILE *file, const char *fnname)\n-{\n-  int len;\n-  int i;\n-  rtx x;\n-  rtx ciw;\n-  struct machine_function *machine = cfun->machine;\n-\n-  in_section = NULL;\n-  fprintf (file, \"\\t.endp\\n\\n\\t.psect\\t%s%s,data\\n\", user_label_prefix,\n-\t   unicosmk_ssib_name ());\n-\n-  /* Some required stuff and the function name length.  */\n-\n-  len = strlen (fnname);\n-  fprintf (file, \"\\t.quad\\t^X20008%2.2X28\\n\", len);\n-\n-  /* Saved registers\n-     ??? We don't do that yet.  */\n-\n-  fputs (\"\\t.quad\\t0\\n\", file);\n-\n-  /* Function address.  */\n-\n-  fputs (\"\\t.quad\\t\", file);\n-  assemble_name (file, fnname);\n-  putc ('\\n', file);\n-\n-  fputs (\"\\t.quad\\t0\\n\", file);\n-  fputs (\"\\t.quad\\t0\\n\", file);\n-\n-  /* Function name.\n-     ??? We do it the same way Cray CC does it but this could be\n-     simplified.  */\n-\n-  for( i = 0; i < len; i++ )\n-    fprintf (file, \"\\t.byte\\t%d\\n\", (int)(fnname[i]));\n-  if( (len % 8) == 0 )\n-    fputs (\"\\t.quad\\t0\\n\", file);\n-  else\n-    fprintf (file, \"\\t.bits\\t%d : 0\\n\", (8 - (len % 8))*8);\n-\n-  /* All call information words used in the function.  */\n-\n-  for (x = machine->first_ciw; x; x = XEXP (x, 1))\n-    {\n-      ciw = XEXP (x, 0);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      fprintf (file, \"\\t.quad\\t\" HOST_WIDE_INT_PRINT_DOUBLE_HEX \"\\n\",\n-\t       CONST_DOUBLE_HIGH (ciw), CONST_DOUBLE_LOW (ciw));\n-#else\n-      fprintf (file, \"\\t.quad\\t\" HOST_WIDE_INT_PRINT_HEX \"\\n\", INTVAL (ciw));\n-#endif\n-    }\n-}\n-\n-/* Add a call information word (CIW) to the list of the current function's\n-   CIWs and return its index.\n-\n-   X is a CONST_INT or CONST_DOUBLE representing the CIW.  */\n-\n-rtx\n-unicosmk_add_call_info_word (rtx x)\n-{\n-  rtx node;\n-  struct machine_function *machine = cfun->machine;\n-\n-  node = gen_rtx_EXPR_LIST (VOIDmode, x, NULL_RTX);\n-  if (machine->first_ciw == NULL_RTX)\n-    machine->first_ciw = node;\n-  else\n-    XEXP (machine->last_ciw, 1) = node;\n-\n-  machine->last_ciw = node;\n-  ++machine->ciw_count;\n-\n-  return GEN_INT (machine->ciw_count\n-\t\t  + strlen (current_function_name ())/8 + 5);\n-}\n-\n-/* The Cray assembler doesn't accept extern declarations for symbols which\n-   are defined in the same file. We have to keep track of all global\n-   symbols which are referenced and/or defined in a source file and output\n-   extern declarations for those which are referenced but not defined at\n-   the end of file.  */\n-\n-/* List of identifiers for which an extern declaration might have to be\n-   emitted.  */\n-/* FIXME: needs to use GC, so it can be saved and restored for PCH.  */\n-\n-struct unicosmk_extern_list\n-{\n-  struct unicosmk_extern_list *next;\n-  const char *name;\n-};\n-\n-static struct unicosmk_extern_list *unicosmk_extern_head = 0;\n-\n-/* Output extern declarations which are required for every asm file.  */\n-\n-static void\n-unicosmk_output_default_externs (FILE *file)\n-{\n-  static const char *const externs[] =\n-    { \"__T3E_MISMATCH\" };\n-\n-  int i;\n-  int n;\n-\n-  n = ARRAY_SIZE (externs);\n-\n-  for (i = 0; i < n; i++)\n-    fprintf (file, \"\\t.extern\\t%s\\n\", externs[i]);\n-}\n-\n-/* Output extern declarations for global symbols which are have been\n-   referenced but not defined.  */\n-\n-static void\n-unicosmk_output_externs (FILE *file)\n-{\n-  struct unicosmk_extern_list *p;\n-  const char *real_name;\n-  int len;\n-  tree name_tree;\n-\n-  len = strlen (user_label_prefix);\n-  for (p = unicosmk_extern_head; p != 0; p = p->next)\n-    {\n-      /* We have to strip the encoding and possibly remove user_label_prefix\n-\t from the identifier in order to handle -fleading-underscore and\n-\t explicit asm names correctly (cf. gcc.dg/asm-names-1.c).  */\n-      real_name = default_strip_name_encoding (p->name);\n-      if (len && p->name[0] == '*'\n-\t  && !memcmp (real_name, user_label_prefix, len))\n-\treal_name += len;\n-\n-      name_tree = get_identifier (real_name);\n-      if (! TREE_ASM_WRITTEN (name_tree))\n-\t{\n-\t  TREE_ASM_WRITTEN (name_tree) = 1;\n-\t  fputs (\"\\t.extern\\t\", file);\n-\t  assemble_name (file, p->name);\n-\t  putc ('\\n', file);\n-\t}\n-    }\n-}\n-\n-/* Record an extern.  */\n-\n-void\n-unicosmk_add_extern (const char *name)\n-{\n-  struct unicosmk_extern_list *p;\n-\n-  p = (struct unicosmk_extern_list *)\n-       xmalloc (sizeof (struct unicosmk_extern_list));\n-  p->next = unicosmk_extern_head;\n-  p->name = name;\n-  unicosmk_extern_head = p;\n-}\n-\n-/* The Cray assembler generates incorrect code if identifiers which\n-   conflict with register names are used as instruction operands. We have\n-   to replace such identifiers with DEX expressions.  */\n-\n-/* Structure to collect identifiers which have been replaced by DEX\n-   expressions.  */\n-/* FIXME: needs to use GC, so it can be saved and restored for PCH.  */\n-\n-struct unicosmk_dex {\n-  struct unicosmk_dex *next;\n-  const char *name;\n-};\n-\n-/* List of identifiers which have been replaced by DEX expressions. The DEX\n-   number is determined by the position in the list.  */\n-\n-static struct unicosmk_dex *unicosmk_dex_list = NULL;\n-\n-/* The number of elements in the DEX list.  */\n-\n-static int unicosmk_dex_count = 0;\n-\n-/* Check if NAME must be replaced by a DEX expression.  */\n-\n-static int\n-unicosmk_special_name (const char *name)\n-{\n-  if (name[0] == '*')\n-    ++name;\n-\n-  if (name[0] == '$')\n-    ++name;\n-\n-  if (name[0] != 'r' && name[0] != 'f' && name[0] != 'R' && name[0] != 'F')\n-    return 0;\n-\n-  switch (name[1])\n-    {\n-    case '1':  case '2':\n-      return (name[2] == '\\0' || (ISDIGIT (name[2]) && name[3] == '\\0'));\n-\n-    case '3':\n-      return (name[2] == '\\0'\n-\t       || ((name[2] == '0' || name[2] == '1') && name[3] == '\\0'));\n-\n-    default:\n-      return (ISDIGIT (name[1]) && name[2] == '\\0');\n-    }\n-}\n-\n-/* Return the DEX number if X must be replaced by a DEX expression and 0\n-   otherwise.  */\n-\n-static int\n-unicosmk_need_dex (rtx x)\n-{\n-  struct unicosmk_dex *dex;\n-  const char *name;\n-  int i;\n-\n-  if (GET_CODE (x) != SYMBOL_REF)\n-    return 0;\n-\n-  name = XSTR (x,0);\n-  if (! unicosmk_special_name (name))\n-    return 0;\n-\n-  i = unicosmk_dex_count;\n-  for (dex = unicosmk_dex_list; dex; dex = dex->next)\n-    {\n-      if (! strcmp (name, dex->name))\n-        return i;\n-      --i;\n-    }\n-\n-  dex = (struct unicosmk_dex *) xmalloc (sizeof (struct unicosmk_dex));\n-  dex->name = name;\n-  dex->next = unicosmk_dex_list;\n-  unicosmk_dex_list = dex;\n-\n-  ++unicosmk_dex_count;\n-  return unicosmk_dex_count;\n-}\n-\n-/* Output the DEX definitions for this file.  */\n-\n-static void\n-unicosmk_output_dex (FILE *file)\n-{\n-  struct unicosmk_dex *dex;\n-  int i;\n-\n-  if (unicosmk_dex_list == NULL)\n-    return;\n-\n-  fprintf (file, \"\\t.dexstart\\n\");\n-\n-  i = unicosmk_dex_count;\n-  for (dex = unicosmk_dex_list; dex; dex = dex->next)\n-    {\n-      fprintf (file, \"\\tDEX (%d) = \", i);\n-      assemble_name (file, dex->name);\n-      putc ('\\n', file);\n-      --i;\n-    }\n-\n-  fprintf (file, \"\\t.dexend\\n\");\n-}\n-\n-/* Output text that to appear at the beginning of an assembler file.  */\n-\n-static void\n-unicosmk_file_start (void)\n-{\n-  int i;\n-\n-  fputs (\"\\t.ident\\t\", asm_out_file);\n-  unicosmk_output_module_name (asm_out_file);\n-  fputs (\"\\n\\n\", asm_out_file);\n-\n-  /* The Unicos/Mk assembler uses different register names. Instead of trying\n-     to support them, we simply use micro definitions.  */\n-\n-  /* CAM has different register names: rN for the integer register N and fN\n-     for the floating-point register N. Instead of trying to use these in\n-     alpha.md, we define the symbols $N and $fN to refer to the appropriate\n-     register.  */\n-\n-  for (i = 0; i < 32; ++i)\n-    fprintf (asm_out_file, \"$%d <- r%d\\n\", i, i);\n-\n-  for (i = 0; i < 32; ++i)\n-    fprintf (asm_out_file, \"$f%d <- f%d\\n\", i, i);\n-\n-  putc ('\\n', asm_out_file);\n-\n-  /* The .align directive fill unused space with zeroes which does not work\n-     in code sections. We define the macro 'gcc@code@align' which uses nops\n-     instead. Note that it assumes that code sections always have the\n-     biggest possible alignment since . refers to the current offset from\n-     the beginning of the section.  */\n-\n-  fputs (\"\\t.macro gcc@code@align n\\n\", asm_out_file);\n-  fputs (\"gcc@n@bytes = 1 << n\\n\", asm_out_file);\n-  fputs (\"gcc@here = . % gcc@n@bytes\\n\", asm_out_file);\n-  fputs (\"\\t.if ne, gcc@here, 0\\n\", asm_out_file);\n-  fputs (\"\\t.repeat (gcc@n@bytes - gcc@here) / 4\\n\", asm_out_file);\n-  fputs (\"\\tbis r31,r31,r31\\n\", asm_out_file);\n-  fputs (\"\\t.endr\\n\", asm_out_file);\n-  fputs (\"\\t.endif\\n\", asm_out_file);\n-  fputs (\"\\t.endm gcc@code@align\\n\\n\", asm_out_file);\n-\n-  /* Output extern declarations which should always be visible.  */\n-  unicosmk_output_default_externs (asm_out_file);\n-\n-  /* Open a dummy section. We always need to be inside a section for the\n-     section-switching code to work correctly.\n-     ??? This should be a module id or something like that. I still have to\n-     figure out what the rules for those are.  */\n-  fputs (\"\\n\\t.psect\\t$SG00000,data\\n\", asm_out_file);\n-}\n-\n-/* Output text to appear at the end of an assembler file. This includes all\n-   pending extern declarations and DEX expressions.  */\n-\n-static void\n-unicosmk_file_end (void)\n-{\n-  fputs (\"\\t.endp\\n\\n\", asm_out_file);\n-\n-  /* Output all pending externs.  */\n-\n-  unicosmk_output_externs (asm_out_file);\n-\n-  /* Output dex definitions used for functions whose names conflict with\n-     register names.  */\n-\n-  unicosmk_output_dex (asm_out_file);\n-\n-  fputs (\"\\t.end\\t\", asm_out_file);\n-  unicosmk_output_module_name (asm_out_file);\n-  putc ('\\n', asm_out_file);\n-}\n-\n-#else\n-\n-static void\n-unicosmk_output_deferred_case_vectors (FILE *file ATTRIBUTE_UNUSED)\n-{}\n-\n-static void\n-unicosmk_gen_dsib (unsigned long *imaskP ATTRIBUTE_UNUSED)\n-{}\n-\n-static void\n-unicosmk_output_ssib (FILE * file ATTRIBUTE_UNUSED,\n-\t\t      const char * fnname ATTRIBUTE_UNUSED)\n-{}\n-\n-rtx\n-unicosmk_add_call_info_word (rtx x ATTRIBUTE_UNUSED)\n-{\n-  return NULL_RTX;\n-}\n-\n-static int\n-unicosmk_need_dex (rtx x ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n-#endif /* TARGET_ABI_UNICOSMK */\n-\n static void\n alpha_init_libfuncs (void)\n {\n-  if (TARGET_ABI_UNICOSMK)\n-    {\n-      /* Prevent gcc from generating calls to __divsi3.  */\n-      set_optab_libfunc (sdiv_optab, SImode, 0);\n-      set_optab_libfunc (udiv_optab, SImode, 0);\n-\n-      /* Use the functions provided by the system library\n-\t for DImode integer division.  */\n-      set_optab_libfunc (sdiv_optab, DImode, \"$sldiv\");\n-      set_optab_libfunc (udiv_optab, DImode, \"$uldiv\");\n-    }\n-  else if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Use the VMS runtime library functions for division and\n \t remainder.  */\n@@ -11017,21 +9982,6 @@ alpha_conditional_register_usage (void)\n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p\n \n-#if TARGET_ABI_UNICOSMK\n-# undef TARGET_INSERT_ATTRIBUTES\n-# define TARGET_INSERT_ATTRIBUTES unicosmk_insert_attributes\n-# undef TARGET_SECTION_TYPE_FLAGS\n-# define TARGET_SECTION_TYPE_FLAGS unicosmk_section_type_flags\n-# undef TARGET_ASM_UNIQUE_SECTION\n-# define TARGET_ASM_UNIQUE_SECTION unicosmk_unique_section\n-#undef TARGET_ASM_FUNCTION_RODATA_SECTION\n-#define TARGET_ASM_FUNCTION_RODATA_SECTION default_no_function_rodata_section\n-# undef TARGET_ASM_GLOBALIZE_LABEL\n-# define TARGET_ASM_GLOBALIZE_LABEL hook_void_FILEptr_constcharptr\n-# undef TARGET_MUST_PASS_IN_STACK\n-# define TARGET_MUST_PASS_IN_STACK unicosmk_must_pass_in_stack\n-#endif\n-\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n #undef TARGET_ASM_ALIGNED_DI_OP\n@@ -11066,17 +10016,10 @@ alpha_conditional_register_usage (void)\n #undef TARGET_LEGITIMIZE_ADDRESS\n #define TARGET_LEGITIMIZE_ADDRESS alpha_legitimize_address\n \n-#if TARGET_ABI_UNICOSMK\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START unicosmk_file_start\n-#undef TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END unicosmk_file_end\n-#else\n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START alpha_file_start\n #undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-#endif\n \n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST alpha_adjust_cost"}, {"sha": "f116f1ff419f8c239ba7e607776e3e49efbc2b76", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -148,10 +148,7 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n /* These are for target os support and cannot be changed at runtime.  */\n #define TARGET_ABI_WINDOWS_NT 0\n #define TARGET_ABI_OPEN_VMS 0\n-#define TARGET_ABI_UNICOSMK 0\n-#define TARGET_ABI_OSF (!TARGET_ABI_WINDOWS_NT\t\\\n-\t\t\t&& !TARGET_ABI_OPEN_VMS\t\\\n-\t\t\t&& !TARGET_ABI_UNICOSMK)\n+#define TARGET_ABI_OSF (!TARGET_ABI_WINDOWS_NT && !TARGET_ABI_OPEN_VMS)\n \n #ifndef TARGET_AS_CAN_SUBTRACT_LABELS\n #define TARGET_AS_CAN_SUBTRACT_LABELS TARGET_GAS"}, {"sha": "80e8ea424247987c75841905c237aaa04a1595dd", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 22, "deletions": 309, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -31,10 +31,6 @@\n   UNSPEC_MSKXH\n   UNSPEC_CVTQL\n   UNSPEC_CVTLQ\n-  UNSPEC_UMK_LAUM\n-  UNSPEC_UMK_LALM\n-  UNSPEC_UMK_LAL\n-  UNSPEC_UMK_LOAD_CIW\n   UNSPEC_LDGP2\n   UNSPEC_LITERAL\n   UNSPEC_LITUSE\n@@ -689,13 +685,11 @@\n   \"\"\n   \"subqv %r1,%2,%0\")\n \n-;; The Unicos/Mk assembler doesn't support mull.\n-\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:SI 2 \"reg_or_8bit_operand\" \"rI\")))]\n-  \"!TARGET_ABI_UNICOSMK\"\n+  \"\"\n   \"mull %r1,%2,%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"si\")])\n@@ -705,7 +699,7 @@\n \t(sign_extend:DI\n \t  (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t   (match_operand:SI 2 \"reg_or_8bit_operand\" \"rI\"))))]\n-  \"!TARGET_ABI_UNICOSMK\"\n+  \"\"\n   \"mull %r1,%2,%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"si\")])\n@@ -719,7 +713,7 @@\n \t\t(sign_extend:DI (mult:SI (match_dup 1)\n \t\t\t\t\t (match_dup 2))))\n \t    (const_int 0))]\n-  \"!TARGET_ABI_UNICOSMK\"\n+  \"\"\n   \"mullv %r1,%2,%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"si\")])\n@@ -786,11 +780,8 @@\n    (set_attr \"opsize\" \"udi\")])\n \f\n ;; The divide and remainder operations take their inputs from r24 and\n-;; r25, put their output in r27, and clobber r23 and r28 on all\n-;; systems except Unicos/Mk. On Unicos, the standard library provides\n-;; subroutines which use the standard calling convention and work on\n-;; DImode operands.\n-\n+;; r25, put their output in r27, and clobber r23 and r28 on all systems.\n+;;\n ;; ??? Force sign-extension here because some versions of OSF/1 and\n ;; Interix/NT don't do the right thing if the inputs are not properly\n ;; sign-extended.  But Linux, for instance, does not have this\n@@ -808,7 +799,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (match_dup 5) 0))]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n {\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n@@ -826,7 +817,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (match_dup 5) 0))]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n {\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n@@ -844,7 +835,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (match_dup 5) 0))]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n {\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n@@ -862,7 +853,7 @@\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (match_dup 5) 0))]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n {\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n@@ -875,7 +866,7 @@\n \t\t\t   (match_operand:DI 2 \"register_operand\" \"\")))\n \t      (clobber (reg:DI 23))\n \t      (clobber (reg:DI 28))])]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"udivdi3\"\n@@ -884,88 +875,27 @@\n \t\t\t    (match_operand:DI 2 \"register_operand\" \"\")))\n \t      (clobber (reg:DI 23))\n \t      (clobber (reg:DI 28))])]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n (define_expand \"moddi3\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))\n-   (use (match_operand:DI 2 \"register_operand\" \"\"))]\n-  \"!TARGET_ABI_OPEN_VMS\"\n-{\n-  if (TARGET_ABI_UNICOSMK)\n-    emit_insn (gen_moddi3_umk (operands[0], operands[1], operands[2]));\n-  else\n-    emit_insn (gen_moddi3_dft (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-(define_expand \"moddi3_dft\"\n   [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (mod:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t\t   (match_operand:DI 2 \"register_operand\" \"\")))\n \t      (clobber (reg:DI 23))\n \t      (clobber (reg:DI 28))])]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n-;; On Unicos/Mk, we do as the system's C compiler does:\n-;; compute the quotient, multiply and subtract.\n-\n-(define_expand \"moddi3_umk\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))\n-   (use (match_operand:DI 2 \"register_operand\" \"\"))]\n-  \"TARGET_ABI_UNICOSMK\"\n-{\n-  rtx div, mul = gen_reg_rtx (DImode);\n-\n-  div = expand_binop (DImode, sdiv_optab, operands[1], operands[2],\n-\t\t      NULL_RTX, 0, OPTAB_LIB);\n-  div = force_reg (DImode, div);\n-  emit_insn (gen_muldi3 (mul, operands[2], div));\n-  emit_insn (gen_subdi3 (operands[0], operands[1], mul));\n-  DONE;\n-})\n-\n (define_expand \"umoddi3\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))\n-   (use (match_operand:DI 2 \"register_operand\" \"\"))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n-{\n-  if (TARGET_ABI_UNICOSMK)\n-    emit_insn (gen_umoddi3_umk (operands[0], operands[1], operands[2]));\n-  else\n-    emit_insn (gen_umoddi3_dft (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n-\n-(define_expand \"umoddi3_dft\"\n   [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t\t   (umod:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t\t    (match_operand:DI 2 \"register_operand\" \"\")))\n \t      (clobber (reg:DI 23))\n \t      (clobber (reg:DI 28))])]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n   \"\")\n \n-(define_expand \"umoddi3_umk\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))\n-   (use (match_operand:DI 2 \"register_operand\" \"\"))]\n-  \"TARGET_ABI_UNICOSMK\"\n-{\n-  rtx div, mul = gen_reg_rtx (DImode);\n-\n-  div = expand_binop (DImode, udiv_optab, operands[1], operands[2],\n-\t\t      NULL_RTX, 1, OPTAB_LIB);\n-  div = force_reg (DImode, div);\n-  emit_insn (gen_muldi3 (mul, operands[2], div));\n-  emit_insn (gen_subdi3 (operands[0], operands[1], mul));\n-  DONE;\n-})\n-\n ;; Lengths of 8 for ldq $t12,__divq($gp); jsr $t9,($t12),__divq as\n ;; expanded by the assembler.\n \n@@ -1021,7 +951,7 @@\n    (use (match_operand 5 \"const_int_operand\" \"\"))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"TARGET_EXPLICIT_RELOCS && ! TARGET_ABI_OPEN_VMS\"\n+  \"TARGET_EXPLICIT_RELOCS && !TARGET_ABI_OPEN_VMS\"\n   \"jsr $23,($27),__%E3%j5\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"4\")])\n@@ -1033,7 +963,7 @@\n \t\t\t (match_operand:DI 2 \"register_operand\" \"b\")])))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n   \"%E3 %1,%2,%0\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -1089,7 +1019,7 @@\n    (use (match_operand 5 \"const_int_operand\" \"\"))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"TARGET_EXPLICIT_RELOCS && ! TARGET_ABI_OPEN_VMS\"\n+  \"TARGET_EXPLICIT_RELOCS && !TARGET_ABI_OPEN_VMS\"\n   \"jsr $23,($27),__%E3%j5\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"4\")])\n@@ -1101,7 +1031,7 @@\n \t\t\t (match_operand:DI 2 \"register_operand\" \"b\")]))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n+  \"!TARGET_ABI_OPEN_VMS\"\n   \"%E3 %1,%2,%0\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -4315,16 +4245,6 @@\n ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF\n ;; work differently, so we have different patterns for each.\n \n-;; On Unicos/Mk a call information word (CIW) must be generated for each\n-;; call. The CIW contains information about arguments passed in registers\n-;; and is stored in the caller's SSIB. Its offset relative to the beginning\n-;; of the SSIB is passed in $25. Handling this properly is quite complicated\n-;; in the presence of inlining since the CIWs for calls performed by the\n-;; inlined function must be stored in the SSIB of the function it is inlined\n-;; into as well. We encode the CIW in an unspec and append it to the list\n-;; of the CIWs for the current function only when the instruction for loading\n-;; $25 is generated.\n-\n (define_expand \"call\"\n   [(use (match_operand:DI 0 \"\" \"\"))\n    (use (match_operand 1 \"\" \"\"))\n@@ -4336,8 +4256,6 @@\n     emit_call_insn (gen_call_nt (operands[0], operands[1]));\n   else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_vms (operands[0], operands[2]));\n-  else if (TARGET_ABI_UNICOSMK)\n-    emit_call_insn (gen_call_umk (operands[0], operands[2]));\n   else\n     emit_call_insn (gen_call_osf (operands[0], operands[1]));\n   DONE;\n@@ -4380,29 +4298,6 @@\n     operands[0] = force_reg (DImode, operands[0]);\n })\n \n-;; Calls on Unicos/Mk are always indirect.\n-;; op 0: symbol ref for called function\n-;; op 1: CIW for $25 represented by an unspec\n-\n-(define_expand \"call_umk\"\n-   [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n-\t\t     (match_operand 1 \"\" \"\"))\n-\t       (use (reg:DI 25))\n-\t       (clobber (reg:DI 26))])]\n-   \"\"\n-{\n-  gcc_assert (MEM_P (operands[0]));\n-\n-  /* Always load the address of the called function into a register;\n-     load the CIW in $25.  */\n-\n-  operands[0] = XEXP (operands[0], 0);\n-  if (!REG_P (operands[0]))\n-    operands[0] = force_reg (DImode, operands[0]);\n-\n-  emit_move_insn (gen_rtx_REG (DImode, 25), operands[1]);\n-})\n-\n ;;\n ;; call openvms/alpha\n ;; op 0: symbol ref for called function\n@@ -4454,9 +4349,6 @@\n   else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_value_vms (operands[0], operands[1],\n \t\t\t\t\toperands[3]));\n-  else if (TARGET_ABI_UNICOSMK)\n-    emit_call_insn (gen_call_value_umk (operands[0], operands[1],\n-\t\t\t\t\toperands[3]));\n   else\n     emit_call_insn (gen_call_value_osf (operands[0], operands[1],\n \t\t\t\t\toperands[2]));\n@@ -4536,23 +4428,6 @@\n     }\n })\n \n-(define_expand \"call_value_umk\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t      (use (reg:DI 25))\n-\t      (clobber (reg:DI 26))])]\n-  \"\"\n-{\n-  gcc_assert (MEM_P (operands[1]));\n-\n-  operands[1] = XEXP (operands[1], 0);\n-  if (!REG_P (operands[1]))\n-    operands[1] = force_reg (DImode, operands[1]);\n-\n-  emit_move_insn (gen_rtx_REG (DImode, 25), operands[2]);\n-})\n-\n (define_insn \"*call_osf_1_er_noreturn\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,s\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -4765,15 +4640,6 @@\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"12,16\")])\n \n-(define_insn \"*call_umk_1\"\n-  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (reg:DI 25))\n-   (clobber (reg:DI 26))]\n-  \"TARGET_ABI_UNICOSMK\"\n-  \"jsr $26,(%0)\"\n-  [(set_attr \"type\" \"jsr\")])\n-\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\"\n@@ -5091,7 +4957,7 @@\n (define_insn \"*movsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m\")\n \t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,n,m,rJ\"))]\n-  \"(TARGET_ABI_OSF || TARGET_ABI_UNICOSMK)\n+  \"TARGET_ABI_OSF\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n@@ -5194,84 +5060,6 @@\n     FAIL;\n })\n \n-;; Split the load of an address into a four-insn sequence on Unicos/Mk.\n-;; Always generate a REG_EQUAL note for the last instruction to facilitate\n-;; optimizations. If the symbolic operand is a label_ref, generate\n-;; REG_LABEL_OPERAND notes and update LABEL_NUSES because this is not done\n-;; automatically.  Labels may be incorrectly deleted if we don't do this.\n-;;\n-;; Describing what the individual instructions do correctly is too complicated\n-;; so use UNSPECs for each of the three parts of an address.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operand:DI 1 \"symbolic_operand\" \"\"))]\n-  \"TARGET_ABI_UNICOSMK && reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx insn1, insn2, insn3;\n-\n-  insn1 = emit_insn (gen_umk_laum (operands[0], operands[1]));\n-  emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n-  insn2 = emit_insn (gen_umk_lalm (operands[0], operands[0], operands[1]));\n-  insn3 = emit_insn (gen_umk_lal (operands[0], operands[0], operands[1]));\n-  set_unique_reg_note (insn3, REG_EQUAL, operands[1]);\n-\n-  if (GET_CODE (operands[1]) == LABEL_REF)\n-    {\n-      rtx label;\n-\n-      label = XEXP (operands[1], 0);\n-      add_reg_note (insn1, REG_LABEL_OPERAND, label);\n-      add_reg_note (insn2, REG_LABEL_OPERAND, label);\n-      add_reg_note (insn3, REG_LABEL_OPERAND, label);\n-      LABEL_NUSES (label) += 3;\n-    }\n-  DONE;\n-})\n-\n-;; Instructions for loading the three parts of an address on Unicos/Mk.\n-\n-(define_insn \"umk_laum\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n-\t\t   UNSPEC_UMK_LAUM))]\n-  \"TARGET_ABI_UNICOSMK\"\n-  \"laum %r0,%t1($31)\"\n-  [(set_attr \"type\" \"iadd\")])\n-\n-(define_insn \"umk_lalm\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_UMK_LALM)))] \n-  \"TARGET_ABI_UNICOSMK\"\n-  \"lalm %r0,%t2(%r1)\"\n-  [(set_attr \"type\" \"iadd\")])\n-\n-(define_insn \"umk_lal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n-\t\t\t    UNSPEC_UMK_LAL)))]\n-  \"TARGET_ABI_UNICOSMK\"\n-  \"lal %r0,%t2(%r1)\"\n-  [(set_attr \"type\" \"iadd\")])\n-\n-;; Add a new call information word to the current function's list of CIWs\n-;; and load its index into $25. Doing it here ensures that the CIW will be\n-;; associated with the correct function even in the presence of inlining.\n-\n-(define_insn \"*umk_load_ciw\"\n-  [(set (reg:DI 25)\n-\t(unspec:DI [(match_operand 0 \"\" \"\")] UNSPEC_UMK_LOAD_CIW))]\n-  \"TARGET_ABI_UNICOSMK\"\n-{\n-  operands[0] = unicosmk_add_call_info_word (operands[0]);\n-  return \"lda $25,%0\";\n-}\n-  [(set_attr \"type\" \"iadd\")])\n-\n (define_insn \"*movdi_er_low_l\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -5428,30 +5216,24 @@\n   [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,multi,ild,ist,fcpys,fld,fst\")\n    (set_attr \"usegp\" \"*,*,*,yes,*,*,*,*,*,*,*\")])\n \n-;; The 'U' constraint matches symbolic operands on Unicos/Mk. Those should\n-;; have been split up by the rules above but we shouldn't reject the\n-;; possibility of them getting through.\n-\n (define_insn \"*movdi_nofix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,r,m,*f,*f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,U,s,n,m,rJ,*fJ,Q,*f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,n,m,rJ,*fJ,Q,*f\"))]\n   \"! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n    bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n-   laum %0,%t1($31)\\;sll %0,32,%0\\;lalm %0,%t1(%0)\\;lal %0,%t1(%0)\n    lda %0,%1\n    #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ldsym,multi,ild,ist,fcpys,fld,fst\")\n-   (set_attr \"length\" \"*,*,*,16,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,multi,ild,ist,fcpys,fld,fst\")])\n \n (define_insn \"*movdi_er_fix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n@@ -6907,58 +6689,6 @@\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"multi\")])\n \n-;; Load the CIW into r2 for calling __T3E_MISMATCH\n-\n-(define_expand \"umk_mismatch_args\"\n-  [(set (match_dup 1) (mem:DI (plus:DI (reg:DI 15) (const_int -16))))\n-   (set (match_dup 2) (mem:DI (plus:DI (match_dup 1) (const_int -32))))\n-   (set (reg:DI 1) (match_operand:DI 0 \"const_int_operand\" \"\"))\n-   (set (match_dup 3) (plus:DI (mult:DI (reg:DI 25)\n-\t\t\t\t\t(const_int 8))\n-\t\t\t       (match_dup 2)))\n-   (set (reg:DI 2) (mem:DI (match_dup 3)))]\n-  \"TARGET_ABI_UNICOSMK\"\n-{\n-  operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_reg_rtx (DImode);\n-  operands[3] = gen_reg_rtx (DImode);\n-})\n-\n-(define_insn \"arg_home_umk\"\n-  [(unspec [(const_int 0)] UNSPEC_ARG_HOME)\n-   (use (reg:DI 1))\n-   (use (reg:DI 2))\n-   (use (reg:DI 16))\n-   (use (reg:DI 17))\n-   (use (reg:DI 18))\n-   (use (reg:DI 19))\n-   (use (reg:DI 20))\n-   (use (reg:DI 21))\n-   (use (reg:DI 48))\n-   (use (reg:DI 49))\n-   (use (reg:DI 50))\n-   (use (reg:DI 51))\n-   (use (reg:DI 52))\n-   (use (reg:DI 53))\n-   (clobber (mem:BLK (const_int 0)))\n-   (parallel [\n-   (clobber (reg:DI 22))\n-   (clobber (reg:DI 23))\n-   (clobber (reg:DI 24))\n-   (clobber (reg:DI 0))\n-   (clobber (reg:DI 1))\n-   (clobber (reg:DI 2))\n-   (clobber (reg:DI 3))\n-   (clobber (reg:DI 4))\n-   (clobber (reg:DI 5))\n-   (clobber (reg:DI 6))\n-   (clobber (reg:DI 7))\n-   (clobber (reg:DI 8))])]\n-  \"TARGET_ABI_UNICOSMK\"\n-  \"laum $4,__T3E_MISMATCH($31)\\;sll $4,32,$4\\;lalm $4,__T3E_MISMATCH($4)\\;lal $4,__T3E_MISMATCH($4)\\;jsr $3,($4)\"\n-  [(set_attr \"length\" \"16\")\n-   (set_attr \"type\" \"multi\")])\n-\n ;; Prefetch data.  \n ;;\n ;; On EV4, these instructions are nops -- no load occurs.\n@@ -7027,18 +6757,11 @@\n   \"\"\n   \"ldq_u $31,0($30)\")\n \n-;; On Unicos/Mk we use a macro for aligning code.\n-\n (define_insn \"realign\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")]\n \t\t    UNSPECV_REALIGN)]\n   \"\"\n-{\n-  if (TARGET_ABI_UNICOSMK)\n-    return \"gcc@code@align %0\";\n-  else\n-    return \".align %0 #realign\";\n-})\n+  \".align %0 #realign\")\n \f\n ;; Instructions to be emitted from __builtins.\n \n@@ -7987,13 +7710,3 @@\n }\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"12,16\")])\n-\n-(define_insn \"*call_value_umk\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (reg:DI 25))\n-   (clobber (reg:DI 26))]\n-  \"TARGET_ABI_UNICOSMK\"\n-  \"jsr $26,(%1)\"\n-  [(set_attr \"type\" \"jsr\")])"}, {"sha": "398ffbc5d13f8aa206746cd3d0cc6aa1ab8b3f51", "filename": "gcc/config/alpha/constraints.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fconstraints.md?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -110,11 +110,6 @@\n   \"@internal A high-part symbol\"\n   (match_code \"high\"))\n \n-(define_constraint \"U\"\n-  \"@internal A UNICOSMK symbol\"\n-  (and (match_test \"TARGET_ABI_UNICOSMK\")\n-       (match_operand 0 \"symbolic_operand\")))\n-\n (define_constraint \"W\"\n   \"A vector zero constant\"\n   (and (match_code \"const_vector\")"}, {"sha": "e41b07055db137fb2d3e404f62992622684fc68a", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75db85d8a250909bd5acb63f366dc44415362dc3/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=75db85d8a250909bd5acb63f366dc44415362dc3", "patch": "@@ -295,14 +295,13 @@\n ;; Return 1 if OP is a valid operand for the MEM of a CALL insn.\n ;;\n ;; For TARGET_ABI_OSF, we want to restrict to R27 or a pseudo.\n-;; For TARGET_ABI_UNICOSMK, we want to restrict to registers.\n \n (define_predicate \"call_operand\"\n-  (if_then_else (match_code \"reg\")\n-    (match_test \"!TARGET_ABI_OSF\n-\t\t || REGNO (op) == 27 || REGNO (op) > LAST_VIRTUAL_REGISTER\")\n-    (and (match_test \"!TARGET_ABI_UNICOSMK\")\n-\t (match_code \"symbol_ref\"))))\n+  (ior (match_code \"symbol_ref\")\n+       (and (match_code \"reg\")\n+\t    (ior (match_test \"!TARGET_ABI_OSF\")\n+\t\t (match_test \"!HARD_REGISTER_P (op)\")\n+\t\t (match_test \"REGNO (op) == R27_REG\")))))\n \n ;; Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n ;; a (non-tls) variable known to be defined in this file."}]}