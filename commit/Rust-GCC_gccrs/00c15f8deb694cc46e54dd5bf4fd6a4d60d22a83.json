{"sha": "00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBjMTVmOGRlYjY5NGNjNDZlNTRkZDViZjRmZDZhNGQ2MGQyMmE4Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-05-24T23:55:20Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-24T23:55:20Z"}, "message": "call.c (maybe_handle_implicit_object): Handle QUAL_CONVs.\n\n1998-05-24  Mark Mitchell  <mark@markmitchell.com>\n\t* call.c (maybe_handle_implicit_object): Handle QUAL_CONVs.  Make\n\tsure the type of the REF_BIND is a reference type.\n\t(maybe_handle_ref_bind, compare_ics): Rename reference_type* to\n\tref_to_type* for clarity.\n\nFrom-SVN: r20037", "tree": {"sha": "753e8900721afec2662f593a026b5f30821b97fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/753e8900721afec2662f593a026b5f30821b97fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/comments", "author": null, "committer": null, "parents": [{"sha": "1dcf683ec2188907189a0815e28c7a8377c52b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcf683ec2188907189a0815e28c7a8377c52b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dcf683ec2188907189a0815e28c7a8377c52b5c"}], "stats": {"total": 55, "additions": 41, "deletions": 14}, "files": [{"sha": "0bf7d8a12474565275ea508324148e110455ddd5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "patch": "@@ -1,5 +1,10 @@\n 1998-05-24  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* call.c (maybe_handle_implicit_object): Handle QUAL_CONVs.  Make\n+\tsure the type of the REF_BIND is a reference type.\n+\t(maybe_handle_ref_bind, compare_ics): Rename reference_type to\n+\ttarget_type for clarity.\n+\n \t* parse.y (xcond): Move call to condition_conversion ...\n \t* semantics.c (finish_for_cond): Here.\n \t* parse.c: Regenerated."}, {"sha": "01bb53fe089eab1671f44b33545d3cbdacd22c42", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "patch": "@@ -3739,23 +3739,27 @@ maybe_handle_implicit_object (ics)\n \t member and cv is the cv-qualification on the member\n \t function declaration.  */\n       tree t = *ics;\n+      if (TREE_CODE (t) == QUAL_CONV)\n+\tt = TREE_OPERAND (t, 0);\n       if (TREE_CODE (t) == PTR_CONV)\n \tt = TREE_OPERAND (t, 0);\n       t = build1 (IDENTITY_CONV, TREE_TYPE (TREE_TYPE (t)), NULL_TREE);\n-      t = build_conv (REF_BIND, TREE_TYPE (*ics), t);\n+      t = build_conv (REF_BIND, \n+\t\t      build_reference_type (TREE_TYPE (TREE_TYPE (*ics))), \n+\t\t      t);\n       ICS_STD_RANK (t) = ICS_STD_RANK (*ics);\n       *ics = t;\n     }\n }\n \n-/* If ICS is a REF_BIND, modify it appropriately, set ORIG_TO_TYPE\n+/* If ICS is a REF_BIND, modify it appropriately, set TARGET_TYPE\n    to the type the reference originally referred to, and return 1.\n    Otherwise, return 0.  */\n \n static int\n-maybe_handle_ref_bind (ics, reference_type)\n+maybe_handle_ref_bind (ics, target_type)\n      tree* ics;\n-     tree* reference_type;\n+     tree* target_type;\n {\n   if (TREE_CODE (*ics) == REF_BIND)\n     {\n@@ -3788,11 +3792,11 @@ maybe_handle_ref_bind (ics, reference_type)\n \n       tree old_ics = *ics;\n \n-      *reference_type = TREE_TYPE (TREE_TYPE (*ics));\n+      *target_type = TREE_TYPE (TREE_TYPE (*ics));\n       *ics = TREE_OPERAND (*ics, 0);\n       if (TREE_CODE (*ics) == IDENTITY_CONV\n-\t  && is_properly_derived_from (TREE_TYPE (*ics), *reference_type))\n-\t*ics = build_conv (BASE_CONV, *reference_type, *ics);\n+\t  && is_properly_derived_from (TREE_TYPE (*ics), *target_type))\n+\t*ics = build_conv (BASE_CONV, *target_type, *ics);\n       ICS_USER_FLAG (*ics) = ICS_USER_FLAG (old_ics);\n       ICS_BAD_FLAG (*ics) = ICS_BAD_FLAG (old_ics);\n       \n@@ -3823,20 +3827,20 @@ compare_ics (ics1, ics2)\n   tree deref_to_type2;\n \n   /* REF_BINDING is non-zero if the result of the conversion sequence\n-     is a reference type.   In that case REFERENCE_TYPE is the\n-     reference type.  */\n+     is a reference type.   In that case TARGET_TYPE is the\n+     type referred to by the reference.  */\n   int ref_binding1;\n   int ref_binding2;\n-  tree reference_type1;\n-  tree reference_type2;\n+  tree target_type1;\n+  tree target_type2;\n \n   /* Handle implicit object parameters.  */\n   maybe_handle_implicit_object (&ics1);\n   maybe_handle_implicit_object (&ics2);\n \n   /* Handle reference parameters.  */\n-  ref_binding1 = maybe_handle_ref_bind (&ics1, &reference_type1);\n-  ref_binding2 = maybe_handle_ref_bind (&ics2, &reference_type2);\n+  ref_binding1 = maybe_handle_ref_bind (&ics1, &target_type1);\n+  ref_binding2 = maybe_handle_ref_bind (&ics2, &target_type2);\n \n   /* [over.ics.rank]\n \n@@ -4132,7 +4136,7 @@ compare_ics (ics1, ics2)\n   if (ref_binding1 && ref_binding2\n       && comptypes (TYPE_MAIN_VARIANT (to_type1),\n \t\t    TYPE_MAIN_VARIANT (to_type2), 1))\n-    return comp_cv_qualification (reference_type2, reference_type1);\n+    return comp_cv_qualification (target_type2, target_type1);\n \n   /* Neither conversion sequence is better than the other.  */\n   return 0;"}, {"sha": "fae26c348246d0a34c1bf3bcc999146511a88951", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload6.C?ref=00c15f8deb694cc46e54dd5bf4fd6a4d60d22a83", "patch": "@@ -0,0 +1,18 @@\n+extern \"C\" void abort();\n+\n+struct S1\n+{\n+  int f() { return 0; }\n+  int f() const { return 1; }\n+};\n+\n+struct S2 : public S1\n+{\n+};\n+\n+int main()\n+{\n+  S2 s2;\n+  if (s2.f() != 0)\n+    abort ();\n+}"}]}