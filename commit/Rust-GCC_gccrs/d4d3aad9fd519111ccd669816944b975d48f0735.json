{"sha": "d4d3aad9fd519111ccd669816944b975d48f0735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRkM2FhZDlmZDUxOTExMWNjZDY2OTgxNjk0NGI5NzVkNDhmMDczNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-11-24T20:21:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-11-24T20:21:29Z"}, "message": "* tree-sra.c (sra_walk_modify_expr): Handle RHS first, then LHS.\n\nFrom-SVN: r91193", "tree": {"sha": "2ed31b45e8cf1b6752b390ad9a13f2a52ea6a55d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ed31b45e8cf1b6752b390ad9a13f2a52ea6a55d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4d3aad9fd519111ccd669816944b975d48f0735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d3aad9fd519111ccd669816944b975d48f0735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4d3aad9fd519111ccd669816944b975d48f0735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d3aad9fd519111ccd669816944b975d48f0735/comments", "author": null, "committer": null, "parents": [{"sha": "bb04998ab783bff53eb995de3e7d38a4eba2f06e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb04998ab783bff53eb995de3e7d38a4eba2f06e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb04998ab783bff53eb995de3e7d38a4eba2f06e"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "eb73d4f22b4fd5c11096e164dcf1c7950ed866b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d3aad9fd519111ccd669816944b975d48f0735/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d3aad9fd519111ccd669816944b975d48f0735/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4d3aad9fd519111ccd669816944b975d48f0735", "patch": "@@ -1,5 +1,7 @@\n 2004-11-24  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree-sra.c (sra_walk_modify_expr): Handle RHS first, then LHS.\n+\n \t* tree-inline.c (copy_body_r): Explicitly copy a constant if the\n \ttype will be remapped.\n "}, {"sha": "e904d6263cdd27793fe9f71186819e278be49ee0", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4d3aad9fd519111ccd669816944b975d48f0735/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4d3aad9fd519111ccd669816944b975d48f0735/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d4d3aad9fd519111ccd669816944b975d48f0735", "patch": "@@ -805,6 +805,31 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       return;\n     }\n \n+  /* If the RHS is scalarizable, handle it.  There are only two cases.  */\n+  if (rhs_elt)\n+    {\n+      if (!rhs_elt->is_scalar)\n+\tfns->ldst (rhs_elt, lhs, bsi, false);\n+      else\n+\tfns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false);\n+    }\n+\n+  /* If it isn't scalarizable, there may be scalarizable variables within, so\n+     check for a call or else walk the RHS to see if we need to do any\n+     copy-in operations.  We need to do it before the LHS is scalarized so\n+     that the statements get inserted in the proper place, before any\n+     copy-out operations.  */\n+  else\n+    {\n+      tree call = get_call_expr_in (rhs);\n+      if (call)\n+\tsra_walk_call_expr (call, bsi, fns);\n+      else\n+\tsra_walk_expr (&TREE_OPERAND (expr, 1), bsi, false, fns);\n+    }\n+\n+  /* Likewise, handle the LHS being scalarizable.  We have cases similar\n+     to those above, but also want to handle RHS being constant.  */\n   if (lhs_elt)\n     {\n       /* If this is an assignment from a constant, or constructor, then\n@@ -834,31 +859,12 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n       else\n \tfns->use (lhs_elt, &TREE_OPERAND (expr, 0), bsi, true);\n     }\n-  else\n-    {\n-      /* LHS_ELT being null only means that the LHS as a whole is not a\n-\t scalarizable reference.  There may be occurrences of scalarizable\n-\t variables within, which implies a USE.  */\n-      sra_walk_expr (&TREE_OPERAND (expr, 0), bsi, true, fns);\n-    }\n \n-  /* Likewise for the right-hand side.  The only difference here is that\n-     we don't have to handle constants, and the RHS may be a call.  */\n-  if (rhs_elt)\n-    {\n-      if (!rhs_elt->is_scalar)\n-\tfns->ldst (rhs_elt, lhs, bsi, false);\n-      else\n-\tfns->use (rhs_elt, &TREE_OPERAND (expr, 1), bsi, false);\n-    }\n+  /* Similarly to above, LHS_ELT being null only means that the LHS as a\n+     whole is not a scalarizable reference.  There may be occurrences of\n+     scalarizable variables within, which implies a USE.  */\n   else\n-    {\n-      tree call = get_call_expr_in (rhs);\n-      if (call)\n-\tsra_walk_call_expr (call, bsi, fns);\n-      else\n-\tsra_walk_expr (&TREE_OPERAND (expr, 1), bsi, false, fns);\n-    }\n+    sra_walk_expr (&TREE_OPERAND (expr, 0), bsi, true, fns);\n }\n \n /* Entry point to the walk functions.  Search the entire function,"}]}