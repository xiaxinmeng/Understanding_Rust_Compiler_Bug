{"sha": "fd1e93027047ca891e278fac96d38978aeb51d6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQxZTkzMDI3MDQ3Y2E4OTFlMjc4ZmFjOTZkMzg5NzhhZWI1MWQ2ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-25T02:58:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-25T02:58:54Z"}, "message": "ggc.h (ggc_grow): New function.\n\n\t* ggc.h (ggc_grow): New function.\n\t* ggc-none.c (ggc_grow): New function.\n\t* ggc-page.c (ggc_grow): Likewise.\n\t* lto.c (read_cgraph_and_symbols): Grow ggc memory after streaming.\n\nFrom-SVN: r210908", "tree": {"sha": "41a5b3a40274b4ea228e9edf919dd2dfac1e4e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41a5b3a40274b4ea228e9edf919dd2dfac1e4e80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd1e93027047ca891e278fac96d38978aeb51d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd1e93027047ca891e278fac96d38978aeb51d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd1e93027047ca891e278fac96d38978aeb51d6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd1e93027047ca891e278fac96d38978aeb51d6d/comments", "author": null, "committer": null, "parents": [{"sha": "7f7beb3f103ec602dc863ba9473bdff4337d5fff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7beb3f103ec602dc863ba9473bdff4337d5fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7beb3f103ec602dc863ba9473bdff4337d5fff"}], "stats": {"total": 39, "additions": 39, "deletions": 0}, "files": [{"sha": "46aa41ca500bbbe4dc000eeb6b6d0b6d2a3a95bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd1e93027047ca891e278fac96d38978aeb51d6d", "patch": "@@ -1,3 +1,9 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ggc.h (ggc_grow): New function.\n+\t* ggc-none.c (ggc_grow): New function.\n+\t* ggc-page.c (ggc_grow): Likewise.\n+\n 2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa.c (cgraph_non_local_node_p_1, cgraph_local_node_p, address_taken_from_non_vtable_p,"}, {"sha": "29a7b2f767ac481d7ff80c4b71e716938c5a20d2", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=fd1e93027047ca891e278fac96d38978aeb51d6d", "patch": "@@ -67,3 +67,8 @@ ggc_free (void *p)\n {\n   free (p);\n }\n+\n+void\n+ggc_grow (void)\n+{\n+}"}, {"sha": "e37ddc246feb21d11d4c57a607d88f92738e0b38", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=fd1e93027047ca891e278fac96d38978aeb51d6d", "patch": "@@ -2185,6 +2185,23 @@ ggc_collect (void)\n     fprintf (G.debug_file, \"END COLLECTING\\n\");\n }\n \n+/* Assume that all GGC memory is reachable and grow the limits for next collection.\n+   With checking, trigger GGC so -Q compilation outputs how much of memory really is\n+   reachable.  */\n+\n+void\n+ggc_grow (void)\n+{\n+#ifndef ENABLE_CHECKING\n+  G.allocated_last_gc = MAX (G.allocated_last_gc,\n+\t\t\t     G.allocated);\n+#else\n+  ggc_collect ();\n+#endif\n+  if (!quiet_flag)\n+    fprintf (stderr, \" {GC start %luk} \", (unsigned long) G.allocated / 1024);\n+}\n+\n /* Print allocation statistics.  */\n #define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n \t\t  ? (x) \\"}, {"sha": "1c0fd3d1ba5e8c00cc9960f3e2dd4be78f2d8599", "filename": "gcc/ggc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=fd1e93027047ca891e278fac96d38978aeb51d6d", "patch": "@@ -282,6 +282,9 @@ extern const char *ggc_alloc_string (const char *contents, int length\n    function is called, not during allocations.  */\n extern void ggc_collect\t(void);\n \n+/* Assume that all GGC memory is reachable and grow the limits for next collection. */\n+extern void ggc_grow (void);\n+\n /* Register an additional root table.  This can be useful for some\n    plugins.  Does nothing if the passed pointer is NULL. */\n extern void ggc_register_root_tab (const struct ggc_root_tab *);"}, {"sha": "8fd483e338dcec1bf71f5e8ae0d4bdac29b765fb", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=fd1e93027047ca891e278fac96d38978aeb51d6d", "patch": "@@ -1,3 +1,7 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (read_cgraph_and_symbols): Grow ggc memory after streaming.\n+\n 2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c (lto_symtab_merge_symbols): Update code setting"}, {"sha": "41d63f69d40a39d49e64769a0e3844246fa1426a", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd1e93027047ca891e278fac96d38978aeb51d6d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=fd1e93027047ca891e278fac96d38978aeb51d6d", "patch": "@@ -3001,6 +3001,10 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   gimple_canonical_types = NULL;\n   delete canonical_type_hash_cache;\n   canonical_type_hash_cache = NULL;\n+\n+  /* At this stage we know that majority of GGC memory is reachable.  \n+     Growing the limits prevents unnecesary invocation of GGC.  */\n+  ggc_grow ();\n   ggc_collect ();\n \n   /* Set the hooks so that all of the ipa passes can read in their data.  */"}]}