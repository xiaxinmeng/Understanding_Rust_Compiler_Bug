{"sha": "ac05926156c0997b191af1176122ee3d8663d19e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwNTkyNjE1NmMwOTk3YjE5MWFmMTE3NjEyMmVlM2Q4NjYzZDE5ZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-06-03T09:33:32Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-06-03T09:33:32Z"}, "message": "Port pool-allocator memory stats to a new infrastructure.\n\n\t* alloc-pool.c (allocate_pool_descriptor): Remove.\n\t(struct pool_output_info): Likewise.\n\t(print_alloc_pool_statistics): Likewise.\n\t(dump_alloc_pool_statistics): Likewise.\n\t* alloc-pool.h (struct pool_usage): New struct.\n\t(pool_allocator::initialize): Change usage of memory statistics\n\tto a new interface.\n\t(pool_allocator::release): Likewise.\n\t(pool_allocator::allocate): Likewise.\n\t(pool_allocator::remove): Likewise.\n\t* mem-stats-traits.h (enum mem_alloc_origin): Add new enum value\n\tfor a pool allocator.\n\t* mem-stats.h (struct mem_location): Add new ctor.\n\t(struct mem_usage): Add counter for number of\n\tinstances.\n\t(mem_alloc_description::register_descriptor): New overload of\n\t* mem-stats.h (mem_location::to_string): New function.\n\t* bitmap.h (struct bitmap_usage): Use this new function.\n\t* ggc-common.c (struct ggc_usage): Likewise.\n\tthe function.\n\nFrom-SVN: r224070", "tree": {"sha": "125beb54d6d03f07b223139332359997e5d92a29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/125beb54d6d03f07b223139332359997e5d92a29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac05926156c0997b191af1176122ee3d8663d19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac05926156c0997b191af1176122ee3d8663d19e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac05926156c0997b191af1176122ee3d8663d19e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac05926156c0997b191af1176122ee3d8663d19e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a810680ee212c8c01239699859a4dd395db6174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a810680ee212c8c01239699859a4dd395db6174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a810680ee212c8c01239699859a4dd395db6174"}], "stats": {"total": 307, "additions": 187, "deletions": 120}, "files": [{"sha": "0a18c89d5606def4f9f057d5f47335f32b1c4831", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -1,3 +1,26 @@\n+2015-06-03  Martin Liska  <mliska@suse.cz>\n+\n+\t* alloc-pool.c (allocate_pool_descriptor): Remove.\n+\t(struct pool_output_info): Likewise.\n+\t(print_alloc_pool_statistics): Likewise.\n+\t(dump_alloc_pool_statistics): Likewise.\n+\t* alloc-pool.h (struct pool_usage): New struct.\n+\t(pool_allocator::initialize): Change usage of memory statistics\n+\tto a new interface.\n+\t(pool_allocator::release): Likewise.\n+\t(pool_allocator::allocate): Likewise.\n+\t(pool_allocator::remove): Likewise.\n+\t* mem-stats-traits.h (enum mem_alloc_origin): Add new enum value\n+\tfor a pool allocator.\n+\t* mem-stats.h (struct mem_location): Add new ctor.\n+\t(struct mem_usage): Add counter for number of\n+\tinstances.\n+\t(mem_alloc_description::register_descriptor): New overload of\n+\t* mem-stats.h (mem_location::to_string): New function.\n+\t* bitmap.h (struct bitmap_usage): Use this new function.\n+\t* ggc-common.c (struct ggc_usage): Likewise.\n+\tthe function.\n+\n 2015-06-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* defaults.h (SWITCHABLE_TARGET, TARGET_SUPPORTS_WIDE_INT): Move out"}, {"sha": "601c2b73f817d54e5380c7f624a766550b6a5e84", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -26,70 +26,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hash-map.h\"\n \n ALLOC_POOL_ID_TYPE last_id;\n-\n-/* Hashtable mapping alloc_pool names to descriptors.  */\n-hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n-\n-struct alloc_pool_descriptor *\n-allocate_pool_descriptor (const char *name)\n-{\n-  if (!alloc_pool_hash)\n-    alloc_pool_hash = new hash_map<const char *, alloc_pool_descriptor> (10,\n-\t\t\t\t\t\t\t\t\t false,\n-\t\t\t\t\t\t\t\t\t false);\n-\n-  return &alloc_pool_hash->get_or_insert (name);\n-}\n-\n-/* Output per-alloc_pool statistics.  */\n-\n-/* Used to accumulate statistics about alloc_pool sizes.  */\n-struct pool_output_info\n-{\n-  unsigned long total_created;\n-  unsigned long total_allocated;\n-};\n-\n-/* Called via hash_map.traverse.  Output alloc_pool descriptor pointed out by\n-   SLOT and update statistics.  */\n-bool\n-print_alloc_pool_statistics (const char *const &name,\n-\t\t\t     const alloc_pool_descriptor &d,\n-\t\t\t     struct pool_output_info *i)\n-{\n-  if (d.allocated)\n-    {\n-      fprintf (stderr,\n-\t       \"%-22s %6d %10lu %10lu(%10lu) %10lu(%10lu) %10lu(%10lu)\\n\",\n-\t       name, d.elt_size, d.created, d.allocated,\n-\t       d.allocated / d.elt_size, d.peak, d.peak / d.elt_size,\n-\t       d.current, d.current / d.elt_size);\n-      i->total_allocated += d.allocated;\n-      i->total_created += d.created;\n-    }\n-  return 1;\n-}\n+mem_alloc_description<pool_usage> pool_allocator_usage;\n \n /* Output per-alloc_pool memory usage statistics.  */\n void\n dump_alloc_pool_statistics (void)\n {\n-  struct pool_output_info info;\n-\n   if (! GATHER_STATISTICS)\n     return;\n \n-  if (!alloc_pool_hash)\n-    return;\n-\n-  fprintf (stderr, \"\\nAlloc-pool Kind         Elt size  Pools  Allocated (elts)            Peak (elts)            Leak (elts)\\n\");\n-  fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n-  info.total_created = 0;\n-  info.total_allocated = 0;\n-  alloc_pool_hash->traverse <struct pool_output_info *,\n-\t\t\t     print_alloc_pool_statistics> (&info);\n-  fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n-  fprintf (stderr, \"%-22s           %7lu %10lu\\n\",\n-\t   \"Total\", info.total_created, info.total_allocated);\n-  fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n+  pool_allocator_usage.dump (ALLOC_POOL);\n }"}, {"sha": "b1bd386156ba6d812c661276dd470f27723d9109", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 80, "deletions": 21, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -26,6 +26,69 @@ extern void dump_alloc_pool_statistics (void);\n \n typedef unsigned long ALLOC_POOL_ID_TYPE;\n \n+/* Pool allocator memory usage.  */\n+struct pool_usage: public mem_usage\n+{\n+  /* Default contructor.  */\n+  pool_usage (): m_element_size (0), m_pool_name (\"\") {}\n+  /* Constructor.  */\n+  pool_usage (size_t allocated, size_t times, size_t peak,\n+\t      size_t instances, size_t element_size,\n+\t      const char *pool_name)\n+    : mem_usage (allocated, times, peak, instances),\n+      m_element_size (element_size),\n+      m_pool_name (pool_name) {}\n+\n+  /* Sum the usage with SECOND usage.  */\n+  pool_usage operator+ (const pool_usage &second)\n+  {\n+    return pool_usage (m_allocated + second.m_allocated,\n+\t\t\t     m_times + second.m_times,\n+\t\t\t     m_peak + second.m_peak,\n+\t\t\t     m_instances + second.m_instances,\n+\t\t\t     m_element_size, m_pool_name);\n+  }\n+\n+  /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n+  inline void dump (mem_location *loc, mem_usage &total) const\n+  {\n+    char *location_string = loc->to_string ();\n+\n+    fprintf (stderr, \"%-32s%-48s %6li%10li:%5.1f%%%10li%10li:%5.1f%%%12li\\n\",\n+\t     m_pool_name, location_string, (long)m_instances,\n+\t     (long)m_allocated, get_percent (m_allocated, total.m_allocated),\n+\t     (long)m_peak, (long)m_times,\n+\t     get_percent (m_times, total.m_times),\n+\t     (long)m_element_size);\n+\n+    free (location_string);\n+  }\n+\n+  /* Dump header with NAME.  */\n+  static inline void dump_header (const char *name)\n+  {\n+    fprintf (stderr, \"%-32s%-48s %6s%11s%16s%17s%12s\\n\", \"Pool name\", name,\n+\t     \"Pools\", \"Leak\", \"Peak\", \"Times\", \"Elt size\");\n+    print_dash_line ();\n+  }\n+\n+  /* Dump footer.  */\n+  inline void dump_footer ()\n+  {\n+    print_dash_line ();\n+    fprintf (stderr, \"%s%75li%10li\\n\", \"Total\", (long)m_instances,\n+\t     (long)m_allocated);\n+    print_dash_line ();\n+  }\n+\n+  /* Element size.  */\n+  size_t m_element_size;\n+  /* Pool name.  */\n+  const char *m_pool_name;\n+};\n+\n+extern mem_alloc_description<pool_usage> pool_allocator_usage;\n+\n /* Type based memory pool allocator.  */\n template <typename T>\n class pool_allocator\n@@ -35,7 +98,7 @@ class pool_allocator\n      has NUM elements.  The allocator support EXTRA_SIZE and can\n      potentially IGNORE_TYPE_SIZE.  */\n   pool_allocator (const char *name, size_t num, size_t extra_size = 0,\n-\t\t  bool ignore_type_size = false);\n+\t\t  bool ignore_type_size = false CXX_MEM_STAT_INFO);\n   ~pool_allocator ();\n   void release ();\n   void release_if_empty ();\n@@ -122,6 +185,8 @@ class pool_allocator\n   size_t m_extra_size;\n   /* Flag if a pool allocator is initialized.  */\n   bool m_initialized;\n+  /* Memory allocation location.  */\n+  mem_location m_location;\n };\n \n /* Last used ID.  */\n@@ -151,19 +216,17 @@ struct alloc_pool_descriptor\n /* Hashtable mapping alloc_pool names to descriptors.  */\n extern hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n \n-/* For given name, return descriptor, create new if needed.  */\n-alloc_pool_descriptor *\n-allocate_pool_descriptor (const char *name);\n-\n template <typename T>\n inline\n pool_allocator<T>::pool_allocator (const char *name, size_t num,\n-\t\t\t\t   size_t extra_size, bool ignore_type_size):\n+\t\t\t\t   size_t extra_size, bool ignore_type_size\n+\t\t\t\t   MEM_STAT_DECL):\n   m_name (name), m_id (0), m_elts_per_block (num), m_returned_free_list (NULL),\n   m_virgin_free_list (NULL), m_virgin_elts_remaining (0), m_elts_allocated (0),\n   m_elts_free (0), m_blocks_allocated (0), m_block_list (NULL),\n   m_block_size (0), m_ignore_type_size (ignore_type_size),\n-  m_extra_size (extra_size), m_initialized (false) {}\n+  m_extra_size (extra_size), m_initialized (false),\n+  m_location (ALLOC_POOL, false PASS_MEM_STAT) {}\n \n /* Initialize a pool allocator.  */\n \n@@ -196,9 +259,11 @@ pool_allocator<T>::initialize ()\n \n   if (GATHER_STATISTICS)\n     {\n-      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n-      desc->elt_size = size;\n-      desc->created++;\n+      pool_usage *u = pool_allocator_usage.register_descriptor\n+\t(this, new mem_location (m_location));\n+\n+      u->m_element_size = m_elt_size;\n+      u->m_pool_name = m_name;\n     }\n \n   /* List header size should be a multiple of 8.  */\n@@ -234,10 +299,10 @@ pool_allocator<T>::release ()\n       free (block);\n     }\n \n-  if (GATHER_STATISTICS && false)\n+  if (GATHER_STATISTICS)\n     {\n-      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n-      desc->current -= (m_elts_allocated - m_elts_free) * m_elt_size;\n+      pool_allocator_usage.release_instance_overhead\n+\t(this, (m_elts_allocated - m_elts_free) * m_elt_size);\n     }\n \n   m_returned_free_list = NULL;\n@@ -278,12 +343,7 @@ pool_allocator<T>::allocate ()\n \n   if (GATHER_STATISTICS)\n     {\n-      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n-\n-      desc->allocated += m_elt_size;\n-      desc->current += m_elt_size;\n-      if (desc->peak < desc->current)\n-\tdesc->peak = desc->current;\n+      pool_allocator_usage.register_instance_overhead (m_elt_size, this);\n     }\n \n #ifdef ENABLE_VALGRIND_ANNOTATIONS\n@@ -382,8 +442,7 @@ pool_allocator<T>::remove (T *object)\n \n   if (GATHER_STATISTICS)\n     {\n-      alloc_pool_descriptor *desc = allocate_pool_descriptor (m_name);\n-      desc->current -= m_elt_size;\n+      pool_allocator_usage.release_instance_overhead (this, m_elt_size);\n     }\n }\n "}, {"sha": "4309f6db182c42e9600bce2e5c93f52de11a5bec", "filename": "gcc/bitmap.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -156,18 +156,17 @@ struct bitmap_usage: public mem_usage\n   /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n   inline void dump (mem_location *loc, mem_usage &total) const\n   {\n-    char s[4096];\n-    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n-\t     loc->m_line, loc->m_function);\n+    char *location_string = loc->to_string ();\n \n-    s[48] = '\\0';\n-\n-    fprintf (stderr, \"%-48s %10li:%5.1f%%%10li%10li:%5.1f%%%12li%12li%10s\\n\", s,\n+    fprintf (stderr, \"%-48s %10li:%5.1f%%%10li%10li:%5.1f%%%12li%12li%10s\\n\",\n+\t     location_string,\n \t     (long)m_allocated, get_percent (m_allocated, total.m_allocated),\n \t     (long)m_peak, (long)m_times,\n \t     get_percent (m_times, total.m_times),\n \t     (long)m_nsearches, (long)m_search_iter,\n \t     loc->m_ggc ? \"ggc\" : \"heap\");\n+\n+    free (location_string);\n   }\n \n   /* Dump header with NAME.  */"}, {"sha": "43ccc0b740208bd3c037e906dd074bc8eecd95b5", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -894,12 +894,11 @@ struct ggc_usage: public mem_usage\n   /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n   inline void dump (mem_location *loc, ggc_usage &total) const\n   {\n-    char s[4096];\n-    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n-\t     loc->m_line, loc->m_function);\n-    s[48] = '\\0';\n+    char *location_string = loc->to_string ();\n \n-    dump (s, total);\n+    dump (location_string, total);\n+\n+    free (location_string);\n   }\n \n   /* Dump footer.  */"}, {"sha": "f7843f2165ff2becadc6234a015b6fde7b09ebbe", "filename": "gcc/mem-stats-traits.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fmem-stats-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fmem-stats-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats-traits.h?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -10,11 +10,12 @@ enum mem_alloc_origin\n   VEC,\n   BITMAP,\n   GGC,\n+  ALLOC_POOL,\n   MEM_ALLOC_ORIGIN_LENGTH\n };\n \n /* Verbose names of the memory allocation origin.  */\n static const char * mem_alloc_origin_names[] = { \"Hash tables\", \"Hash maps\",\n-  \"Hash sets\", \"Heap vectors\", \"Bitmaps\", \"GGC memory\" };\n+  \"Hash sets\", \"Heap vectors\", \"Bitmaps\", \"GGC memory\", \"Allocation pool\" };\n \n #endif // GCC_MEM_STATS_TRAITS_H"}, {"sha": "092bfd3610e1ecd546d7c4564a0c61e166819254", "filename": "gcc/mem-stats.h", "status": "modified", "additions": 71, "deletions": 29, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fmem-stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac05926156c0997b191af1176122ee3d8663d19e/gcc%2Fmem-stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats.h?ref=ac05926156c0997b191af1176122ee3d8663d19e", "patch": "@@ -11,18 +11,27 @@ template<typename Key, typename Value,\n \t typename Traits = default_hashmap_traits>\n class hash_map;\n \n+#define LOCATION_LINE_EXTRA_SPACE 30\n+#define LOCATION_LINE_WIDTH\t  48\n+\n /* Memory allocation location.  */\n struct mem_location\n {\n   /* Default constructor.  */\n   inline mem_location () {}\n \n   /* Constructor.  */\n-  inline mem_location (const char *filename, const char *function, int line,\n-\t\tmem_alloc_origin origin, bool ggc):\n+  inline mem_location (mem_alloc_origin origin, bool ggc,\n+\t\tconst char *filename = NULL, int line = 0,\n+\t\tconst char *function = NULL):\n     m_filename (filename), m_function (function), m_line (line), m_origin\n     (origin), m_ggc (ggc) {}\n \n+  /* Copy constructor.  */\n+  inline mem_location (mem_location &other): m_filename (other.m_filename),\n+    m_function (other.m_function), m_line (other.m_line),\n+    m_origin (other.m_origin), m_ggc (other.m_ggc) {}\n+\n   /* Compute hash value based on file name, function name and line in\n      source code. As there is just a single pointer registered for every\n      constant that points to e.g. the same file name, we can use hash\n@@ -57,6 +66,20 @@ struct mem_location\n     return s1;\n   }\n \n+  inline char *to_string ()\n+  {\n+    unsigned l = strlen (get_trimmed_filename ()) + strlen (m_function)\n+      + LOCATION_LINE_EXTRA_SPACE;\n+\n+    char *s = XNEWVEC (char, l);\n+    sprintf (s, \"%s:%i (%s)\", get_trimmed_filename (),\n+\t     m_line, m_function);\n+\n+    s[MIN (LOCATION_LINE_WIDTH, l - 1)] = '\\0';\n+\n+    return s;\n+  }\n+\n   /* Return display name associated to ORIGIN type.  */\n   static const char *get_origin_name (mem_alloc_origin origin)\n   {\n@@ -79,11 +102,12 @@ struct mem_location\n struct mem_usage\n {\n   /* Default constructor.  */\n-  mem_usage (): m_allocated (0), m_times (0), m_peak (0) {}\n+  mem_usage (): m_allocated (0), m_times (0), m_peak (0), m_instances (1) {}\n \n   /* Constructor.  */\n-  mem_usage (size_t allocated, size_t times, size_t peak):\n-    m_allocated (allocated), m_times (times), m_peak (peak) {}\n+  mem_usage (size_t allocated, size_t times, size_t peak, size_t instances = 0):\n+    m_allocated (allocated), m_times (times), m_peak (peak),\n+    m_instances (instances) {}\n \n   /* Register overhead of SIZE bytes.  */\n   inline void register_overhead (size_t size)\n@@ -108,7 +132,8 @@ struct mem_usage\n   {\n     return mem_usage (m_allocated + second.m_allocated,\n \t\t      m_times + second.m_times,\n-\t\t      m_peak + second.m_peak);\n+\t\t      m_peak + second.m_peak,\n+\t\t      m_instances + second.m_instances);\n   }\n \n   /* Comparison operator.  */\n@@ -133,20 +158,19 @@ struct mem_usage\n   /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n   inline void dump (mem_location *loc, mem_usage &total) const\n   {\n-    char s[4096];\n-    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n-\t     loc->m_line, loc->m_function);\n+    char *location_string = loc->to_string ();\n \n-    s[48] = '\\0';\n-\n-    fprintf (stderr, \"%-48s %10li:%5.1f%%%10li%10li:%5.1f%%%10s\\n\", s,\n+    fprintf (stderr, \"%-48s %10li:%5.1f%%%10li%10li:%5.1f%%%10s\\n\",\n+\t     location_string,\n \t     (long)m_allocated, get_percent (m_allocated, total.m_allocated),\n \t     (long)m_peak, (long)m_times,\n \t     get_percent (m_times, total.m_times), loc->m_ggc ? \"ggc\" : \"heap\");\n+\n+    free (location_string);\n   }\n \n   /* Dump footer.  */\n-  inline void dump_footer ()\n+  inline void dump_footer () const\n   {\n     print_dash_line ();\n     fprintf (stderr, \"%s%54li%27li\\n\", \"Total\", (long)m_allocated,\n@@ -163,7 +187,7 @@ struct mem_usage\n   /* Print line made of dashes.  */\n   static inline void print_dash_line ()\n   {\n-    fprintf (stderr, \"%s\\n\", std::string (128, '-').c_str ());\n+    fprintf (stderr, \"%s\\n\", std::string (140, '-').c_str ());\n   }\n \n   /* Dump header with NAME.  */\n@@ -180,6 +204,8 @@ struct mem_usage\n   size_t m_times;\n   /* Peak allocation in bytes.  */\n   size_t m_peak;\n+  /* Number of container instances.  */\n+  size_t m_instances;\n };\n \n /* Memory usage pair that connectes memory usage and number\n@@ -241,9 +267,13 @@ class mem_alloc_description\n   /* Return descriptor for instance PTR.  */\n   T *get_descriptor_for_instance (const void *ptr);\n \n-  /* Register memory allocation descriptor for container PTR. ORIGIN identifies\n+  /* Register memory allocation descriptor for container PTR which is\n+     described by a memory LOCATION.  */\n+  T *register_descriptor (const void *ptr, mem_location *location);\n+\n+  /* Register memory allocation descriptor for container PTR.  ORIGIN identifies\n      type of container and GGC identifes if the allocation is handled in GGC\n-     memory. Each location is identified by file NAME, LINE in source code and\n+     memory.  Each location is identified by file NAME, LINE in source code and\n      FUNCTION name.  */\n   T *register_descriptor (const void *ptr, mem_alloc_origin origin,\n \t\t\t  bool ggc, const char *name, int line,\n@@ -321,33 +351,27 @@ mem_alloc_description<T>::get_descriptor_for_instance (const void *ptr)\n   return m_reverse_map->get (ptr) ? (*m_reverse_map->get (ptr)).usage : NULL;\n }\n \n-/* Register memory allocation descriptor for container PTR. ORIGIN identifies\n-   type of container and GGC identifes if the allocation is handled in GGC\n-   memory. Each location is identified by file NAME, LINE in source code and\n-   FUNCTION name.  */\n \n+  /* Register memory allocation descriptor for container PTR which is\n+     described by a memory LOCATION.  */\n template <class T>\n inline T*\n mem_alloc_description<T>::register_descriptor (const void *ptr,\n-\t\t\t\t\t       mem_alloc_origin origin,\n-\t\t\t\t\t       bool ggc,\n-\t\t\t\t\t       const char *filename,\n-\t\t\t\t\t       int line,\n-\t\t\t\t\t       const char *function)\n+\t\t\t\t\t       mem_location *location)\n {\n-  mem_location *l = new mem_location (filename, function, line, origin, ggc);\n   T *usage = NULL;\n \n-  T **slot = m_map->get (l);\n+  T **slot = m_map->get (location);\n   if (slot)\n     {\n-      delete l;\n+      delete location;\n       usage = *slot;\n+      usage->m_instances++;\n     }\n   else\n     {\n       usage = new T ();\n-      m_map->put (l, usage);\n+      m_map->put (location, usage);\n     }\n \n   if (!m_reverse_map->get (ptr))\n@@ -356,6 +380,24 @@ mem_alloc_description<T>::register_descriptor (const void *ptr,\n   return usage;\n }\n \n+/* Register memory allocation descriptor for container PTR.  ORIGIN identifies\n+   type of container and GGC identifes if the allocation is handled in GGC\n+   memory.  Each location is identified by file NAME, LINE in source code and\n+   FUNCTION name.  */\n+\n+template <class T>\n+inline T*\n+mem_alloc_description<T>::register_descriptor (const void *ptr,\n+\t\t\t\t\t       mem_alloc_origin origin,\n+\t\t\t\t\t       bool ggc,\n+\t\t\t\t\t       const char *filename,\n+\t\t\t\t\t       int line,\n+\t\t\t\t\t       const char *function)\n+{\n+  mem_location *l = new mem_location (origin, ggc, filename, line, function);\n+  return register_descriptor (ptr, l);\n+}\n+\n /* Register instance overhead identified by PTR pointer. Allocation takes\n    SIZE bytes.  */\n "}]}