{"sha": "72e4bfd9e42fee1f39c24571caf8b82c0b457482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlNGJmZDllNDJmZWUxZjM5YzI0NTcxY2FmOGI4MmMwYjQ1NzQ4Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:28:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:28:51Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r22177,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r22178", "tree": {"sha": "bf58c7f6496e4a6ae9fd66ba7710d050163f1997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf58c7f6496e4a6ae9fd66ba7710d050163f1997"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72e4bfd9e42fee1f39c24571caf8b82c0b457482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e4bfd9e42fee1f39c24571caf8b82c0b457482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e4bfd9e42fee1f39c24571caf8b82c0b457482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e4bfd9e42fee1f39c24571caf8b82c0b457482/comments", "author": null, "committer": null, "parents": [{"sha": "38fcba265cae3cb9656a3d1a211194560836cf6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fcba265cae3cb9656a3d1a211194560836cf6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38fcba265cae3cb9656a3d1a211194560836cf6e"}], "stats": {"total": 233, "additions": 121, "deletions": 112}, "files": [{"sha": "0bdabbd111c8776d32eb1f8e2a9b19d544ef9602", "filename": "libstdc++/stl/limits", "status": "modified", "additions": 121, "deletions": 112, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e4bfd9e42fee1f39c24571caf8b82c0b457482/libstdc%2B%2B%2Fstl%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e4bfd9e42fee1f39c24571caf8b82c0b457482/libstdc%2B%2B%2Fstl%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Flimits?ref=72e4bfd9e42fee1f39c24571caf8b82c0b457482", "patch": "@@ -34,17 +34,22 @@ enum float_round_style {\n   round_toward_infinity     =  2,\n   round_toward_neg_infinity =  3\n };\n-  \n+\n+enum float_denorm_style {\n+  denorm_indeterminate = -1,\n+  denorm_absent        =  0,\n+  denorm_present       =  1\n+};\n \n // Base class for all specializations of numeric_limits.\n \n-template <class Number>\n-class __numeric_limits_base {\n+template <class __number>\n+class _Numeric_limits_base {\n public:\n   static const bool is_specialized = false;\n \n-  static Number min() __STL_NOTHROW { return Number(); }\n-  static Number max() __STL_NOTHROW { return Number(); }\n+  static __number min() __STL_NOTHROW { return __number(); }\n+  static __number max() __STL_NOTHROW { return __number(); }\n \n   static const int digits   = 0;\n   static const int digits10 = 0;\n@@ -55,8 +60,8 @@ public:\n \n   static const int radix = 0;\n \n-  static Number epsilon() __STL_NOTHROW     { return Number(); }\n-  static Number round_error() __STL_NOTHROW { return Number(); }\n+  static __number epsilon() __STL_NOTHROW     { return __number(); }\n+  static __number round_error() __STL_NOTHROW { return __number(); }\n \n   static const int min_exponent   = 0;\n   static const int min_exponent10 = 0;\n@@ -66,13 +71,13 @@ public:\n   static const bool has_infinity      = false;\n   static const bool has_quiet_NaN     = false;\n   static const bool has_signaling_NaN = false;\n-  static const bool has_denorm        = false;\n+  static const float_denorm_style has_denorm = denorm_absent;\n   static const bool has_denorm_loss   = false;\n \n-  static Number infinity() __STL_NOTHROW      { return Number(); }\n-  static Number quiet_NaN() __STL_NOTHROW     { return Number(); }\n-  static Number signaling_NaN() __STL_NOTHROW { return Number(); }\n-  static Number denorm_min() __STL_NOTHROW    { return Number(); }\n+  static __number infinity() __STL_NOTHROW      { return __number(); }\n+  static __number quiet_NaN() __STL_NOTHROW     { return __number(); }\n+  static __number signaling_NaN() __STL_NOTHROW { return __number(); }\n+  static __number denorm_min() __STL_NOTHROW    { return __number(); }\n \n   static const bool is_iec559  = false;\n   static const bool is_bounded = false;\n@@ -84,8 +89,8 @@ public:\n };\n \n #define __declare_numeric_base_member(__type, __mem) \\\n-template <class Number> \\\n-  const __type __numeric_limits_base<Number>:: __mem\n+template <class __number> \\\n+  const __type _Numeric_limits_base<__number>:: __mem\n \n __declare_numeric_base_member(bool, is_specialized);\n __declare_numeric_base_member(int, digits);\n@@ -101,7 +106,7 @@ __declare_numeric_base_member(int, max_exponent10);\n __declare_numeric_base_member(bool, has_infinity);\n __declare_numeric_base_member(bool, has_quiet_NaN);\n __declare_numeric_base_member(bool, has_signaling_NaN);\n-__declare_numeric_base_member(bool, has_denorm);\n+__declare_numeric_base_member(float_denorm_style, has_denorm);\n __declare_numeric_base_member(bool, has_denorm_loss);\n __declare_numeric_base_member(bool, is_iec559);\n __declare_numeric_base_member(bool, is_bounded);\n@@ -114,24 +119,25 @@ __declare_numeric_base_member(float_round_style, round_style);\n \n // Base class for integers.\n \n-template <class __Int,\n-          __Int IMin,\n-          __Int IMax,\n-          int IDigits = -1>\n-class __integer_limits : public __numeric_limits_base<__Int> \n+template <class _Int,\n+          _Int __imin,\n+          _Int __imax,\n+          int __idigits = -1>\n+class _Integer_limits : public _Numeric_limits_base<_Int> \n {\n public:\n   static const bool is_specialized = true;\n \n-  static __Int min() __STL_NOTHROW { return IMin; }\n-  static __Int max() __STL_NOTHROW { return IMax; }\n+  static _Int min() __STL_NOTHROW { return __imin; }\n+  static _Int max() __STL_NOTHROW { return __imax; }\n \n   static const int digits = \n-    (IDigits < 0) ? sizeof(__Int) * CHAR_BIT - (IMin == 0 ? 0 : 1) : IDigits;\n+    (__idigits < 0) ? sizeof(_Int) * CHAR_BIT - (__imin == 0 ? 0 : 1) \n+                    : __idigits;\n   static const int digits10 = (digits * 301) / 1000; \n                                 // log 2 = 0.301029995664...\n \n-  static const bool is_signed = IMin != 0;\n+  static const bool is_signed = __imin != 0;\n   static const bool is_integer = true;\n   static const bool is_exact = true;\n   static const int radix = 2;\n@@ -142,8 +148,8 @@ public:\n };\n \n #define __declare_integer_limits_member(__type, __mem) \\\n-template <class __Int, __Int IMin, __Int IMax, int IDigits> \\\n-  const __type __integer_limits<__Int, IMin, IMax, IDigits>:: __mem\n+template <class _Int, _Int __imin, _Int __imax, int __idigits> \\\n+  const __type _Integer_limits<_Int, __imin, __imax, __idigits>:: __mem\n \n __declare_integer_limits_member(bool, is_specialized);\n __declare_integer_limits_member(int, digits);\n@@ -158,66 +164,69 @@ __declare_integer_limits_member(bool, is_modulo);\n #undef __declare_integer_limits_member\n \n // Base class for floating-point numbers.\n-template <class Number,\n-         int FDigits, int FDigits10,\n-         int FMinExp, int FMaxExp,\n-         int FMinExp10, int FMaxExp10,\n-         unsigned int FInfinityWord,\n-         unsigned int FQNaNWord, unsigned int FSNaNWord,\n-         bool FIsIEC559,\n-         float_round_style FRoundStyle>\n-class __floating_limits : public __numeric_limits_base<Number>\n+template <class __number,\n+         int __Digits, int __Digits10,\n+         int __MinExp, int __MaxExp,\n+         int __MinExp10, int __MaxExp10,\n+         unsigned int __InfinityWord,\n+         unsigned int __QNaNWord, unsigned int __SNaNWord,\n+         bool __IsIEC559,\n+         float_round_style __RoundStyle>\n+class _Floating_limits : public _Numeric_limits_base<__number>\n {\n public:\n   static const bool is_specialized = true;\n \n-  static const int digits   = FDigits;\n-  static const int digits10 = FDigits10;\n+  static const int digits   = __Digits;\n+  static const int digits10 = __Digits10;\n \n   static const bool is_signed = true;\n \n   static const int radix = 2;\n \n-  static const int min_exponent   = FMinExp;\n-  static const int max_exponent   = FMaxExp;\n-  static const int min_exponent10 = FMinExp10;\n-  static const int max_exponent10 = FMaxExp10;\n+  static const int min_exponent   = __MinExp;\n+  static const int max_exponent   = __MaxExp;\n+  static const int min_exponent10 = __MinExp10;\n+  static const int max_exponent10 = __MaxExp10;\n \n   static const bool has_infinity      = true;\n   static const bool has_quiet_NaN     = true;\n   static const bool has_signaling_NaN = true;\n-  static const bool has_denorm        = false;\n+  static const float_denorm_style has_denorm = denorm_indeterminate;\n   static const bool has_denorm_loss   = false;\n \n-  static Number infinity() __STL_NOTHROW {\n-    static unsigned int inf[sizeof(Number) / sizeof(int)] = { FInfinityWord };\n-    return *reinterpret_cast<Number*>(&inf);\n+  static __number infinity() __STL_NOTHROW {\n+    static unsigned int _S_inf[sizeof(__number) / sizeof(int)] = \n+      { __InfinityWord };\n+    return *reinterpret_cast<__number*>(&_S_inf);\n   }\n-  static Number quiet_NaN() __STL_NOTHROW {\n-    static unsigned int nan[sizeof(Number) / sizeof(int)] = { FQNaNWord };\n-    return *reinterpret_cast<Number*>(&nan);\n+  static __number quiet_NaN() __STL_NOTHROW {\n+    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = \n+      { __QNaNWord };\n+    return *reinterpret_cast<__number*>(&_S_nan);\n   }\n-  static Number signaling_NaN() __STL_NOTHROW {\n-    static unsigned int nan[sizeof(Number) / sizeof(int)] = { FSNaNWord };\n-    return *reinterpret_cast<Number*>(&nan);\n+  static __number signaling_NaN() __STL_NOTHROW {\n+    static unsigned int _S_nan[sizeof(__number) / sizeof(int)] = \n+      { __SNaNWord };\n+    return *reinterpret_cast<__number*>(&_S_nan);\n   }\n \n-  static const bool is_iec559       = FIsIEC559;\n+  static const bool is_iec559       = __IsIEC559;\n   static const bool is_bounded      = true;\n   static const bool traps           = true;\n   static const bool tinyness_before = false;\n \n-  static const float_round_style round_style = FRoundStyle;\n+  static const float_round_style round_style = __RoundStyle;\n };\n \n #define __declare_float_limits_member(__type, __mem) \\\n template <class __Num, int __Dig, int __Dig10, \\\n           int __MnX, int __MxX, int __MnX10, int __MxX10, \\\n           unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, \\\n           bool __IsIEEE, float_round_style __Sty> \\\n-const __type __floating_limits<__Num, __Dig, __Dig10, \\\n-                               __MnX, __MxX, __MnX10, __MxX10, \\\n-                               __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>:: __mem\n+const __type _Floating_limits<__Num, __Dig, __Dig10, \\\n+                              __MnX, __MxX, __MnX10, __MxX10, \\\n+                              __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>:: __mem\n \n __declare_float_limits_member(bool, is_specialized);  \n __declare_float_limits_member(int, digits);  \n@@ -231,7 +240,7 @@ __declare_float_limits_member(int, max_exponent10);\n __declare_float_limits_member(bool, has_infinity);\n __declare_float_limits_member(bool, has_quiet_NaN);\n __declare_float_limits_member(bool, has_signaling_NaN);\n-__declare_float_limits_member(bool, has_denorm);\n+__declare_float_limits_member(float_denorm_style, has_denorm);\n __declare_float_limits_member(bool, has_denorm_loss);\n __declare_float_limits_member(bool, is_iec559);\n __declare_float_limits_member(bool, is_bounded);\n@@ -246,102 +255,102 @@ __declare_float_limits_member(float_round_style, round_style);\n // The unspecialized class.\n \n template<class T> \n-class numeric_limits : public __numeric_limits_base<T> {};\n+class numeric_limits : public _Numeric_limits_base<T> {};\n \n // Specializations for all built-in integral types.\n \n-#ifndef __STL_NEED_BOOL\n+#ifndef __STL_NO_BOOL\n \n template<>\n class numeric_limits<bool>\n-  : public __integer_limits<bool, false, true, 0>\n+  : public _Integer_limits<bool, false, true, 0>\n {};\n \n-#endif /* __STL_NEED_BOOL */\n+#endif /* __STL_NO_BOOL */\n \n template<>\n class numeric_limits<char>\n-  : public __integer_limits<char, CHAR_MIN, CHAR_MAX>\n+  : public _Integer_limits<char, CHAR_MIN, CHAR_MAX>\n {};\n \n template<>\n class numeric_limits<signed char>\n-  : public __integer_limits<signed char, SCHAR_MIN, SCHAR_MAX>\n+  : public _Integer_limits<signed char, SCHAR_MIN, SCHAR_MAX>\n {};\n \n template<>\n class numeric_limits<unsigned char>\n-  : public __integer_limits<unsigned char, 0, UCHAR_MAX>\n+  : public _Integer_limits<unsigned char, 0, UCHAR_MAX>\n {};\n \n-#ifdef _WCHAR_T_IS_KEYWORD\n+#ifdef __STL_HAS_WCHAR_T\n \n template<>\n class numeric_limits<wchar_t>\n-  : public __integer_limits<wchar_t, INT_MIN, INT_MAX>\n+  : public _Integer_limits<wchar_t, INT_MIN, INT_MAX>\n {};\n \n #endif\n \n template<>\n class numeric_limits<short>\n-  : public __integer_limits<short, SHRT_MIN, SHRT_MAX>\n+  : public _Integer_limits<short, SHRT_MIN, SHRT_MAX>\n {};\n \n template<>\n class numeric_limits<unsigned short>\n-  : public __integer_limits<unsigned short, 0, USHRT_MAX>\n+  : public _Integer_limits<unsigned short, 0, USHRT_MAX>\n {};\n \n template<>\n class numeric_limits<int>\n-  : public __integer_limits<int, INT_MIN, INT_MAX>\n+  : public _Integer_limits<int, INT_MIN, INT_MAX>\n {};\n \n template<>\n class numeric_limits<unsigned int>\n-  : public __integer_limits<unsigned int, 0, UINT_MAX>\n+  : public _Integer_limits<unsigned int, 0, UINT_MAX>\n {};\n \n template<>\n class numeric_limits<long>\n-  : public __integer_limits<long, LONG_MIN, LONG_MAX>\n+  : public _Integer_limits<long, LONG_MIN, LONG_MAX>\n {};\n \n template<>\n class numeric_limits<unsigned long>\n-  : public __integer_limits<unsigned long, 0, ULONG_MAX>\n+  : public _Integer_limits<unsigned long, 0, ULONG_MAX>\n {};\n \n-#if defined(_LONGLONG) && _SGIAPI\n+#ifdef __STL_LONG_LONG\n \n template<>\n class numeric_limits<long long>\n-  : public __integer_limits<long long, LONGLONG_MIN, LONGLONG_MAX>\n+  : public _Integer_limits<long long, LONGLONG_MIN, LONGLONG_MAX>\n {};\n \n template<>\n class numeric_limits<unsigned long long>\n-  : public __integer_limits<unsigned long long, 0, ULONGLONG_MAX>\n+  : public _Integer_limits<unsigned long long, 0, ULONGLONG_MAX>\n {};\n \n-#endif /* _LONGLONG && _SGIAPI */\n+#endif /* __STL_LONG_LONG */\n \n // Specializations for all built-in floating-point type.\n \n template<> class numeric_limits<float>\n-  : public __floating_limits<float, \n-                             FLT_MANT_DIG,   // Binary digits of precision\n-                             FLT_DIG,        // Decimal digits of precision\n-                             FLT_MIN_EXP,    // Minimum exponent\n-                             FLT_MAX_EXP,    // Maximum exponent\n-                             FLT_MIN_10_EXP, // Minimum base 10 exponent\n-                             FLT_MAX_10_EXP, // Maximum base 10 exponent\n-                             0x7f800000u,    // First word of +infinity\n-                             0x7f810000u,    // First word of quiet NaN\n-                             0x7fc10000u,    // First word of signaling NaN\n-                             true,           // conforms to iec559\n-                             round_to_nearest>\n+  : public _Floating_limits<float, \n+                            FLT_MANT_DIG,   // Binary digits of precision\n+                            FLT_DIG,        // Decimal digits of precision\n+                            FLT_MIN_EXP,    // Minimum exponent\n+                            FLT_MAX_EXP,    // Maximum exponent\n+                            FLT_MIN_10_EXP, // Minimum base 10 exponent\n+                            FLT_MAX_10_EXP, // Maximum base 10 exponent\n+                            0x7f800000u,    // First word of +infinity\n+                            0x7f810000u,    // First word of quiet NaN\n+                            0x7fc10000u,    // First word of signaling NaN\n+                            true,           // conforms to iec559\n+                            round_to_nearest>\n {\n public:\n   static float min() __STL_NOTHROW { return FLT_MIN; }\n@@ -352,18 +361,18 @@ public:\n };\n \n template<> class numeric_limits<double>\n-  : public __floating_limits<double, \n-                             DBL_MANT_DIG,   // Binary digits of precision\n-                             DBL_DIG,        // Decimal digits of precision\n-                             DBL_MIN_EXP,    // Minimum exponent\n-                             DBL_MAX_EXP,    // Maximum exponent\n-                             DBL_MIN_10_EXP, // Minimum base 10 exponent\n-                             DBL_MAX_10_EXP, // Maximum base 10 exponent\n-                             0x7ff00000u,    // First word of +infinity\n-                             0x7ff10000u,    // First word of quiet NaN\n-                             0x7ff90000u,    // First word of signaling NaN\n-                             true,           // conforms to iec559\n-                             round_to_nearest>\n+  : public _Floating_limits<double, \n+                            DBL_MANT_DIG,   // Binary digits of precision\n+                            DBL_DIG,        // Decimal digits of precision\n+                            DBL_MIN_EXP,    // Minimum exponent\n+                            DBL_MAX_EXP,    // Maximum exponent\n+                            DBL_MIN_10_EXP, // Minimum base 10 exponent\n+                            DBL_MAX_10_EXP, // Maximum base 10 exponent\n+                            0x7ff00000u,    // First word of +infinity\n+                            0x7ff10000u,    // First word of quiet NaN\n+                            0x7ff90000u,    // First word of signaling NaN\n+                            true,           // conforms to iec559\n+                            round_to_nearest>\n {\n public:\n   static double min() __STL_NOTHROW { return DBL_MIN; }\n@@ -374,18 +383,18 @@ public:\n };\n \n template<> class numeric_limits<long double>\n-  : public __floating_limits<long double, \n-                             LDBL_MANT_DIG,  // Binary digits of precision\n-                             LDBL_DIG,       // Decimal digits of precision\n-                             LDBL_MIN_EXP,   // Minimum exponent\n-                             LDBL_MAX_EXP,   // Maximum exponent\n-                             LDBL_MIN_10_EXP,// Minimum base 10 exponent\n-                             LDBL_MAX_10_EXP,// Maximum base 10 exponent\n-                             0x7ff00000u,    // First word of +infinity\n-                             0x7ff10000u,    // First word of quiet NaN\n-                             0x7ff90000u,    // First word of signaling NaN\n-                             false,          // Doesn't conform to iec559\n-                             round_to_nearest>\n+  : public _Floating_limits<long double, \n+                            LDBL_MANT_DIG,  // Binary digits of precision\n+                            LDBL_DIG,       // Decimal digits of precision\n+                            LDBL_MIN_EXP,   // Minimum exponent\n+                            LDBL_MAX_EXP,   // Maximum exponent\n+                            LDBL_MIN_10_EXP,// Minimum base 10 exponent\n+                            LDBL_MAX_10_EXP,// Maximum base 10 exponent\n+                            0x7ff00000u,    // First word of +infinity\n+                            0x7ff10000u,    // First word of quiet NaN\n+                            0x7ff90000u,    // First word of signaling NaN\n+                            false,          // Doesn't conform to iec559\n+                            round_to_nearest>\n {\n public:\n   static long double min() __STL_NOTHROW { return LDBL_MIN; }"}]}