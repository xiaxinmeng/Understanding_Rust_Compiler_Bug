{"sha": "46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZmYmIyOWMyZWUxYTkwNWY5Y2FkOGI1MDA0ZmY3OWZjZjgyYmZlYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-10-04T05:57:38Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-10-04T05:57:38Z"}, "message": "re PR tree-optimization/23049 (ICE with -O3 -ftree-vectorize on 4.1.x)\n\n2005-10-05  Steven Bosscher  <stevenb@suse.de>\ngcc/\n\tPR tree-optimization/23049\n\t* tree-ssa-dom.c (thread_across_edge): Make sure that the condition\n\tof a COND_EXPR is folded before calling fold on the whole rhs of a\n\tconditional assignment.\n\t* doc/tree-ssa.texi: Update the GIMPLE grammar for a valid rhs to\n\tdocument that a COND_EXPR may appear there.\n\ntestsuite/\n\t* gcc.dg/pr23049.c: New test.\n\n\t* gcc.dg/ucnid-4.c: Fix test.\n\nFrom-SVN: r104938", "tree": {"sha": "7151af0afa8919a5d3d55f199b5534c2e0dbb2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7151af0afa8919a5d3d55f199b5534c2e0dbb2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/comments", "author": null, "committer": null, "parents": [{"sha": "36dd6d31e4cfb026258d1885e788d7934521f694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36dd6d31e4cfb026258d1885e788d7934521f694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36dd6d31e4cfb026258d1885e788d7934521f694"}], "stats": {"total": 80, "additions": 72, "deletions": 8}, "files": [{"sha": "9003d0da7cc87b881f764ac0756e67093a943631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "patch": "@@ -1,3 +1,12 @@\n+2005-10-05  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR tree-optimization/23049\n+\t* tree-ssa-dom.c (thread_across_edge): Make sure that the condition\n+\tof a COND_EXPR is folded before calling fold on the whole rhs of a\n+\tconditional assignment.\n+\t* doc/tree-ssa.texi: Update the GIMPLE grammar for a valid rhs to\n+\tdocument that a COND_EXPR may appear there.\n+\n 2005-10-03  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 23445"}, {"sha": "77a2f0a01ab64cc2fdc0600ce05c975d89f67128", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "patch": "@@ -728,6 +728,10 @@ void f()\n                 | RELOP\n                         op0 -> val\n                         op1 -> val\n+\t\t| COND_EXPR\n+\t\t\top0 -> condition\n+\t\t\top1 -> val\n+\t\t\top2 -> val\n @end smallexample\n \n @node Annotations"}, {"sha": "34826bfec699e2cf96eac804ef49f1a7c18ffb02", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "patch": "@@ -1,3 +1,9 @@\n+2005-10-05  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* gcc.dg/pr23049.c: New test.\n+\n+\t* gcc.dg/ucnid-4.c: Fix test.\n+\n 2005-10-03  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR 23445"}, {"sha": "0a71cecb21795f8236f204125713b693bb0021aa", "filename": "gcc/testsuite/gcc.dg/pr23049.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23049.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23049.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23049.c?ref=46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "patch": "@@ -0,0 +1,26 @@\n+/* This was an ICE in fold where we tried to fold something like,\n+\n+     a = 0 == 0 ? 0 : 3988292384\n+\n+   after doing if-conversion for the vectorizer.  Folding \"0 == 0\"\n+   should have been done before calling fold on the whole rhs of\n+   the above expression.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ftree-vectorize\" } */\n+\n+static unsigned short int crc_table[256];\n+void AC3_encode_init(void)\n+{\n+  unsigned int c, n, k;\n+  for(n=0;  n<256; n++)\n+  {\n+    c = n << 8;\n+    for (k = 0; k < 8; k++)\n+    {\n+      if (c & (1 << 15))\n+       c = ((c << 1) & 0xffff) ^ (((1 << 0) | (1 << 2) | (1 << 15) | (1 << 16)) & 0xffff);\n+    }\n+    crc_table[n] = c;\n+  }\n+}"}, {"sha": "1fd492551b8bd1c96a4ff358f64ec35adc07265a", "filename": "gcc/testsuite/gcc.dg/ucnid-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fucnid-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftestsuite%2Fgcc.dg%2Fucnid-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fucnid-4.c?ref=46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do run */\n+/* { dg-do run } */\n /* { dg-xfail-if \"\" { \"powerpc-ibm-aix*\" } { \"*\" } { \"\" } } */\n /* { dg-options \"-std=c99 -fextended-identifiers\" } */\n void abort (void);"}, {"sha": "71dcd4ffc6d9f5888355572a5f267f64bc345dcf", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=46fbb29c2ee1a905f9cad8b5004ff79fcf82bfeb", "patch": "@@ -666,7 +666,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n      statements.  This does not prevent threading through E->dest.  */\n   for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n     {\n-      tree cached_lhs;\n+      tree cached_lhs = NULL;\n \n       stmt = bsi_stmt (bsi);\n \n@@ -705,7 +705,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       else\n \t{\n \t  /* Copy the operands.  */\n-\t  tree *copy;\n+\t  tree *copy, pre_fold_expr;\n \t  ssa_op_iter iter;\n \t  use_operand_p use_p;\n \t  unsigned int num, i = 0;\n@@ -729,12 +729,31 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \n \t  /* Try to fold/lookup the new expression.  Inserting the\n \t     expression into the hash table is unlikely to help\n-\t     simplify anything later, so just query the hashtable.  */\n-\t  cached_lhs = fold (TREE_OPERAND (stmt, 1));\n-\t  if (TREE_CODE (cached_lhs) != SSA_NAME\n-\t      && !is_gimple_min_invariant (cached_lhs))\n-\t    cached_lhs = lookup_avail_expr (stmt, false);\n+\t     Sadly, we have to handle conditional assignments specially\n+\t     here, because fold expects all the operands of an expression\n+\t     to be folded before the expression itself is folded, but we\n+\t     can't just substitute the folded condition here.  */\n+\t  if (TREE_CODE (TREE_OPERAND (stmt, 1)) == COND_EXPR)\n+\t    {\n+\t      tree cond = COND_EXPR_COND (TREE_OPERAND (stmt, 1));\n+\t      cond = fold (cond);\n+\t      if (cond == boolean_true_node)\n+\t\tpre_fold_expr = COND_EXPR_THEN (TREE_OPERAND (stmt, 1));\n+\t      else if (cond == boolean_false_node)\n+\t\tpre_fold_expr = COND_EXPR_ELSE (TREE_OPERAND (stmt, 1));\n+\t      else\n+\t\tpre_fold_expr = TREE_OPERAND (stmt, 1);\n+\t    }\n+\t  else\n+\t    pre_fold_expr = TREE_OPERAND (stmt, 1);\n \n+\t  if (pre_fold_expr)\n+\t    {\n+\t      cached_lhs = fold (pre_fold_expr);\n+\t      if (TREE_CODE (cached_lhs) != SSA_NAME\n+\t\t  && !is_gimple_min_invariant (cached_lhs))\n+\t        cached_lhs = lookup_avail_expr (stmt, false);\n+\t    }\n \n \t  /* Restore the statement's original uses/defs.  */\n \t  i = 0;"}]}