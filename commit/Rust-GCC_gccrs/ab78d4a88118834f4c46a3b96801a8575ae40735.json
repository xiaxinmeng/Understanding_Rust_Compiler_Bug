{"sha": "ab78d4a88118834f4c46a3b96801a8575ae40735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3OGQ0YTg4MTE4ODM0ZjRjNDZhM2I5NjgwMWE4NTc1YWU0MDczNQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-08-25T17:39:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-08-25T17:39:37Z"}, "message": "Change MIPS fp to be at top of stack, instead of bottom; Fix calling mips-tfile with wrong .o file\n\nFrom-SVN: r1941", "tree": {"sha": "409cd7da2445e9dfbd2aa86b4354e0e95fdd5080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/409cd7da2445e9dfbd2aa86b4354e0e95fdd5080"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab78d4a88118834f4c46a3b96801a8575ae40735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab78d4a88118834f4c46a3b96801a8575ae40735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab78d4a88118834f4c46a3b96801a8575ae40735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab78d4a88118834f4c46a3b96801a8575ae40735/comments", "author": null, "committer": null, "parents": [{"sha": "8436fe35328c0c173575ad517e746e4e3a57d781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8436fe35328c0c173575ad517e746e4e3a57d781", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8436fe35328c0c173575ad517e746e4e3a57d781"}], "stats": {"total": 221, "additions": 145, "deletions": 76}, "files": [{"sha": "5cae65b616faec3555d034693914250c16be1ece", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 48, "deletions": 61, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab78d4a88118834f4c46a3b96801a8575ae40735/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab78d4a88118834f4c46a3b96801a8575ae40735/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ab78d4a88118834f4c46a3b96801a8575ae40735", "patch": "@@ -107,10 +107,6 @@ int mips_section_threshold = -1;\n /* Count the number of .file directives, so that .loc is up to date.  */\n int num_source_filenames = 0;\n \n-/* Count of the number of functions created so far, in order to make\n-   unique labels for omitting the frame pointer.  */\n-int number_functions_processed = 0;\n-\n /* Count the number of sdb related labels are generated (to find block\n    start and end boundaries).  */\n int sdb_label_count = 0;\n@@ -3085,11 +3081,14 @@ override_options ()\n \n \f\n /*\n- * If the frame pointer has been eliminated, the offset for an auto\n- * or argument will be based on the stack pointer.  But this is not\n- * what the debugger expects--it needs to find an offset off of the\n- * frame pointer (whether it exists or not).  So here we turn all\n- * offsets into those based on the (possibly virtual) frame pointer.\n+ * The MIPS debug format wants all automatic variables and arguments\n+ * to be in terms of the virtual frame pointer (stack pointer before\n+ * any adjustment in the function), while the MIPS 3.0 linker wants\n+ * the frame pointer to be the stack pointer after the initial\n+ * adjustment.  So, we do the adjustment here.  The arg pointer (which\n+ * is eliminated) points to the virtual frame pointer, while the frame\n+ * pointer (which may be eliminated) points to the stack pointer after\n+ * the initial adjustments.\n  */\n \n int\n@@ -3103,21 +3102,16 @@ mips_debugger_offset (addr, offset)\n   if (!offset)\n     offset = INTVAL (offset2);\n \n-  if (reg == stack_pointer_rtx)\n+  if (reg == stack_pointer_rtx || reg == frame_pointer_rtx)\n     {\n       int frame_size = (!current_frame_info.initialized)\n \t\t\t\t? compute_frame_size (get_frame_size ())\n \t\t\t\t: current_frame_info.total_size;\n \n       offset = offset - frame_size;\n     }\n-\n-  /* Any other register is, we hope, either the frame pointer,\n-     or a pseudo equivalent to the frame pointer.  (Assign_parms\n-     copies the arg pointer to a pseudo if ARG_POINTER_REGNUM is\n-     equal to FRAME_POINTER_REGNUM, so references off of the\n-     arg pointer are all off a pseudo.)  Seems like all we can\n-     do is to just return OFFSET and hope for the best.  */\n+  else if (reg != arg_pointer_rtx)\n+    abort_with_insn (addr, \"mips_debugger_offset called with non stack/frame/arg pointer.\");\n \n   return offset;\n }\n@@ -3415,6 +3409,9 @@ print_operand_address (file, addr)\n \tbreak;\n \n       case REG:\n+\tif (REGNO (addr) == ARG_POINTER_REGNUM)\n+\t  abort_with_insn (addr, \"Arg pointer not eliminated.\");\n+\n \tfprintf (file, \"0(%s)\", reg_names [REGNO (addr)]);\n \tbreak;\n \n@@ -3448,6 +3445,9 @@ print_operand_address (file, addr)\n \t  if (!CONSTANT_P (offset))\n \t    abort_with_insn (addr, \"PRINT_OPERAND_ADDRESS, illegal insn #2\");\n \n+\tif (REGNO (reg) == ARG_POINTER_REGNUM)\n+\t  abort_with_insn (addr, \"Arg pointer not eliminated.\");\n+\n \t  output_addr_const (file, offset);\n \t  fprintf (file, \"(%s)\", reg_names [REGNO (reg)]);\n \t}\n@@ -3861,10 +3861,6 @@ mips_output_float (stream, value)\n \t\t\t\t\t|  GP save for V.4 abi\t|\n \t\t\t\t\t|\t\t\t|\n \t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t|  local variables\t|\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n \t\t\t\t\t|\t\t        |\n                                         |  fp register save     |\n \t\t\t\t\t|\t\t\t|\n@@ -3874,6 +3870,10 @@ mips_output_float (stream, value)\n                                         |       \t\t|\n \t\t\t\t\t+-----------------------+\n \t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t|  local variables\t|\n+\t\t\t\t\t|\t\t\t|\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|\t\t\t|\n                                         |  alloca allocations   |\n         \t\t\t\t|\t\t\t|\n \t\t\t\t\t+-----------------------+\n@@ -3906,16 +3906,23 @@ compute_frame_size (size)\n   int fp_inc;\t\t\t/* 1 or 2 depending on the size of fp regs */\n   int fp_bits;\t\t\t/* bitmask to use for each fp register */\n \n-  extra_size\t = MIPS_STACK_ALIGN (((TARGET_ABICALLS) ? UNITS_PER_WORD : 0)\n-\t\t\t\t     -STARTING_FRAME_OFFSET);\n-\n-  var_size\t = MIPS_STACK_ALIGN (size);\n-  args_size\t = MIPS_STACK_ALIGN (current_function_outgoing_args_size);\n-  total_size\t = var_size + args_size + extra_size;\n   gp_reg_size\t = 0;\n   fp_reg_size\t = 0;\n   mask\t\t = 0;\n   fmask\t\t = 0;\n+  extra_size\t = MIPS_STACK_ALIGN (((TARGET_ABICALLS) ? UNITS_PER_WORD : 0));\n+  var_size\t = MIPS_STACK_ALIGN (size);\n+  args_size\t = MIPS_STACK_ALIGN (current_function_outgoing_args_size);\n+\n+  /* The MIPS 3.0 linker does not like functions that dynamically\n+     allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n+     looks like we are trying to create a second frame pointer to the\n+     function, so allocate some stack space to make it happy.  */\n+\n+  if (args_size == 0 && current_function_calls_alloca)\n+\targs_size = 4*UNITS_PER_WORD;\n+\n+  total_size = var_size + args_size + extra_size;\n \n   /* Calculate space needed for gp registers.  */\n   for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n@@ -3969,14 +3976,14 @@ compute_frame_size (size)\n \n   if (mask)\n     {\n-      unsigned long offset = args_size + gp_reg_size - UNITS_PER_WORD;\n+      unsigned long offset = args_size + var_size + gp_reg_size - UNITS_PER_WORD;\n       current_frame_info.gp_sp_offset = offset;\n       current_frame_info.gp_save_offset = offset - total_size;\n     }\n \n   if (fmask)\n     {\n-      unsigned long offset = args_size + gp_reg_rounded + fp_reg_size - 2*UNITS_PER_WORD;\n+      unsigned long offset = args_size + var_size + gp_reg_rounded + fp_reg_size - 2*UNITS_PER_WORD;\n       current_frame_info.fp_sp_offset = offset;\n       current_frame_info.fp_save_offset = offset - total_size + UNITS_PER_WORD;\n     }\n@@ -4152,8 +4159,6 @@ function_prologue (file, size)\n      int size;\n {\n   int tsize = current_frame_info.total_size;\n-  int vframe;\n-  int vreg;\n \n   ASM_OUTPUT_SOURCE_FILENAME (file, DECL_SOURCE_FILE (current_function_decl));\n   ASM_OUTPUT_SOURCE_LINE (file, DECL_SOURCE_LINE (current_function_decl));\n@@ -4174,20 +4179,9 @@ function_prologue (file, size)\n   if (tsize > 0 && TARGET_ABICALLS)\n     fprintf (file, \"\\t.cprestore %d\\n\", tsize + STARTING_FRAME_OFFSET);\n \n-  if (frame_pointer_needed)\n-    {\n-      vframe = 0;\n-      vreg   = FRAME_POINTER_REGNUM;\n-    }\n-  else\n-    {\n-      vframe = tsize;\n-      vreg   = STACK_POINTER_REGNUM;\n-    }\n-\n   fprintf (file, \"\\t.frame\\t%s,%d,%s\\t\\t# vars= %d, regs= %d/%d, args = %d, extra= %d\\n\",\n-\t   reg_names[ vreg ],\n-\t   vframe,\n+\t   reg_names[ (frame_pointer_needed) ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM ],\n+\t   tsize,\n \t   reg_names[31 + GP_REG_FIRST],\n \t   current_frame_info.var_size,\n \t   current_frame_info.num_gp,\n@@ -4209,7 +4203,6 @@ void\n mips_expand_prologue ()\n {\n   int regno;\n-  int size;\n   int tsize;\n   tree fndecl = current_function_decl; /* current... is tooo long */\n   tree fntype = TREE_TYPE (fndecl);\n@@ -4291,9 +4284,7 @@ mips_expand_prologue ()\n \t}\n     }\n \n-  size  = MIPS_STACK_ALIGN (get_frame_size ());\n-  tsize = compute_frame_size (size);\n-\n+  tsize = compute_frame_size (get_frame_size ());\n   if (tsize > 0)\n     {\n       rtx tsize_rtx = GEN_INT (tsize);\n@@ -4310,7 +4301,7 @@ mips_expand_prologue ()\n       save_restore_insns (TRUE);\n \n       if (frame_pointer_needed)\n-\temit_insn (gen_addsi3 (frame_pointer_rtx, stack_pointer_rtx, tsize_rtx));\n+\temit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n     }\n }\n \n@@ -4413,15 +4404,8 @@ function_epilogue (file, size)\n \tfprintf (file, \"\\tli\\t%s,%d\\n\", t1_str, tsize);\n \n       if (frame_pointer_needed)\n-\t{\n-\t  char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n-\t  if (tsize > 32767)\n-\t    fprintf (file,\"\\tsubu\\t%s,%s,%s\\t\\t# sp not trusted  here\\n\",\n-\t\t     sp_str, fp_str, t1_str);\n-\t  else\n-\t    fprintf (file,\"\\tsubu\\t%s,%s,%d\\t\\t# sp not trusted  here\\n\",\n-\t\t     sp_str, fp_str, tsize);\n-\t}\n+\tfprintf (file, \"\\tmove\\t%s,%s\\t\\t\\t# sp not trusted here\\n\",\n+\t\t sp_str, reg_names[FRAME_POINTER_REGNUM]);\n \n       save_restore (file, \"lw\", \"ld\", \"l.d\");\n \n@@ -4489,6 +4473,10 @@ function_epilogue (file, size)\n       int num_gp_regs = current_frame_info.gp_reg_size / 4;\n       int num_fp_regs = current_frame_info.fp_reg_size / 8;\n       int num_regs    = num_gp_regs + num_fp_regs;\n+      char *name      = current_function_name;\n+\n+      if (name[0] == '*')\n+\tname++;\n \n       dslots_load_total += num_regs;\n \n@@ -4511,7 +4499,7 @@ function_epilogue (file, size)\n \n       fprintf (stderr,\n \t       \"%-20s fp=%c leaf=%c alloca=%c setjmp=%c stack=%4ld arg=%3ld reg=%2d/%d delay=%3d/%3dL %3d/%3dJ refs=%3d/%3d/%3d\",\n-\t       current_function_name,\n+\t       name,\n \t       (frame_pointer_needed) ? 'y' : 'n',\n \t       ((current_frame_info.mask & (1 << 31)) != 0) ? 'n' : 'y',\n \t       (current_function_calls_alloca) ? 'y' : 'n',\n@@ -4545,7 +4533,6 @@ function_epilogue (file, size)\n   mips_load_reg      = (rtx)0;\n   mips_load_reg2     = (rtx)0;\n   current_frame_info = zero_frame_info;\n-  number_functions_processed++;\n \n   /* Restore the output file if optimizing the GP (optimizing the GP causes\n      the text to be diverted to a tempfile, so that data decls come before\n@@ -4574,7 +4561,7 @@ mips_expand_epilogue ()\n   if (tsize > 0)\n     {\n       if (frame_pointer_needed)\n-\temit_insn (gen_subsi3 (stack_pointer_rtx, frame_pointer_rtx, tsize_rtx));\n+\temit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n \n       save_restore_insns (FALSE);\n "}, {"sha": "fd748b43552d6d4b3492fac13a728f8cce5d2426", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 96, "deletions": 14, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab78d4a88118834f4c46a3b96801a8575ae40735/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab78d4a88118834f4c46a3b96801a8575ae40735/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ab78d4a88118834f4c46a3b96801a8575ae40735", "patch": "@@ -402,7 +402,7 @@ while (0)\n \t\\n mips-tfile %{v*: -v} \\\n \t\t%{K: -I %b.o~} \\\n \t\t%{!K: %{save-temps: -I %b.o~}} \\\n-\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %u.o} \\\n+\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %U.o} \\\n \t\t%{.s:%i} %{!.s:%g.s}}}\"\n #endif\n \n@@ -473,7 +473,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 23]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 24]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -651,8 +651,12 @@ do {\t\t\t\t\t\t\t\\\n #define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n   sprintf ((BUFFER), \".%dfake\", (NUMBER));\n \n-/* Correct the offset of automatic variables and arguments\n-   if the frame pointer has been eliminated.  */\n+/* Correct the offset of automatic variables and arguments.  Note that\n+   the MIPS debug format wants all automatic variables and arguments\n+   to be in terms of the virtual frame pointer (stack pointer before\n+   any adjustment in the function), while the MIPS 3.0 linker wants\n+   the frame pointer to be the stack pointer after the initial\n+   adjustment.  */\n \n #define DEBUGGER_AUTO_OFFSET(X)\t\tmips_debugger_offset (X, 0)\n #define DEBUGGER_ARG_OFFSET(OFFSET, X)\tmips_debugger_offset (X, OFFSET)\n@@ -1196,7 +1200,7 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n #define FRAME_POINTER_REQUIRED (current_function_calls_alloca)\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n+#define ARG_POINTER_REGNUM GP_REG_FIRST\n \n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n@@ -1485,13 +1489,30 @@ extern enum reg_class mips_char_to_class[];\n    is at the high-address end of the local variables;\n    that is, each additional local variable allocated\n    goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n+/* #define FRAME_GROWS_DOWNWARD */\n \n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n    of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET (-8)\n+#define STARTING_FRAME_OFFSET current_function_outgoing_args_size\n+\n+/* Offset from the stack pointer register to an item dynamically\n+   allocated on the stack, e.g., by `alloca'.\n+\n+   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n+   length of the outgoing arguments.  The default is correct for most\n+   machines.  See `function.c' for details.\n+\n+   The MIPS 3.0 linker does not like functions that dynamically\n+   allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n+   looks like we are trying to create a second frame pointer to the\n+   function, so allocate some stack space to make it happy.  */\n+\n+#define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n+  ((current_function_outgoing_args_size == 0 && current_function_calls_alloca) \\\n+\t? 4*UNITS_PER_WORD\t\t\t\t\t\t\\\n+\t: current_function_outgoing_args_size)\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -1522,8 +1543,69 @@ extern struct mips_frame_info current_frame_info;\n    as of the start of the function body.  This depends on the layout\n    of the fixed parts of the stack frame and on how registers are saved.  */\n \n-#define INITIAL_FRAME_POINTER_OFFSET(VAR)\t\t\t\t\\\n- ((VAR) = compute_frame_size (get_frame_size ()))\n+/* #define INITIAL_FRAME_POINTER_OFFSET(VAR)\t\t\t\t\\\n+    ((VAR) = compute_frame_size (get_frame_size ())) */\n+\n+/* If defined, this macro specifies a table of register pairs used to\n+   eliminate unneeded registers that point into the stack frame.  If\n+   it is not defined, the only elimination attempted by the compiler\n+   is to replace references to the frame pointer with references to\n+   the stack pointer.\n+\n+   The definition of this macro is a list of structure\n+   initializations, each of which specifies an original and\n+   replacement register.\n+\n+   On some machines, the position of the argument pointer is not\n+   known until the compilation is completed.  In such a case, a\n+   separate hard register must be used for the argument pointer. \n+   This register can be eliminated by replacing it with either the\n+   frame pointer or the argument pointer, depending on whether or not\n+   the frame pointer has been eliminated.\n+\n+   In this case, you might specify:\n+        #define ELIMINABLE_REGS  \\\n+        {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n+         {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \\\n+         {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+   Note that the elimination of the argument pointer with the stack\n+   pointer is specified first since that is the preferred elimination.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},\t\t\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+\n+/* A C expression that returns non-zero if the compiler is allowed to\n+   try to replace register number FROM-REG with register number\n+   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n+   defined, and will usually be the constant 1, since most of the\n+   cases preventing register elimination are things that the compiler\n+   already knows about.  */\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n+  (!frame_pointer_needed\t\t\t\t\t\t\\\n+   || ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM))\n+\n+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n+   specifies the initial difference between the specified pair of\n+   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n+   defined.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n+{  compute_frame_size (get_frame_size ());\t\t\t\t \\\n+  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t \\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n+    (OFFSET) = current_frame_info.total_size;\t\t\t\t \\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n+    (OFFSET) = current_frame_info.total_size;\t\t\t\t \\\n+  else\t\t\t\t\t\t\t\t\t \\\n+    abort ();\t\t\t\t\t\t\t\t \\\n+}\n+\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -1780,18 +1862,19 @@ typedef struct mips_args {\n   (get_attr_dslot (INSN) == DSLOT_NO\t\t\t\t\t\\\n    && get_attr_length (INSN) == 1\t\t\t\t\t\\\n    && ! reg_mentioned_p (stack_pointer_rtx, PATTERN (INSN))\t\t\\\n-   && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (INSN)))\n+   && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (INSN))\t\t\\\n+   && ! reg_mentioned_p (arg_pointer_rtx, PATTERN (INSN)))\n \n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n #define MUST_SAVE_REGISTER(regno) \\\n  ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n   || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n-  || (regno == 31 && regs_ever_live[31]))\n+  || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n \n /* ALIGN FRAMES on double word boundaries */\n \n-#define MIPS_STACK_ALIGN(LOC) (((LOC)+7) & 0xfffffff8)\n+#define MIPS_STACK_ALIGN(LOC) (((LOC)+7) & ~7)\n \n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n@@ -2918,8 +3001,7 @@ while (0)\n \t$Lb[0-9]+\tBegin blocks for MIPS debug support\n \t$Lc[0-9]+\tLabel for use in s<xx> operation.\n \t$Le[0-9]+\tEnd blocks for MIPS debug support\n-\t$Lp\\..+\t\tHalf-pic labels.\n-\t$Ls[0-9]+\tFP-SP difference if -fomit-frame-pointer  */\n+\t$Lp\\..+\t\tHalf-pic labels. */\n \n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME."}, {"sha": "dd3f9f7ae242e79cae672e6008ed055d37b74f54", "filename": "gcc/config/mips/osfrose.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab78d4a88118834f4c46a3b96801a8575ae40735/gcc%2Fconfig%2Fmips%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab78d4a88118834f4c46a3b96801a8575ae40735/gcc%2Fconfig%2Fmips%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fosfrose.h?ref=ab78d4a88118834f4c46a3b96801a8575ae40735", "patch": "@@ -45,7 +45,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \t\\n mips-tfile %{v*: -v} %{d*} \\\n \t\t\t%{K: -I %b.o~} \\\n \t\t\t%{!K: %{save-temps: -I %b.o~}} \\\n-\t\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %u.o} \\\n+\t\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %U.o} \\\n \t\t\t%{.s:%i} %{!.s:%g.s}}}\"\n \n #define CPP_SPEC \"\\"}]}