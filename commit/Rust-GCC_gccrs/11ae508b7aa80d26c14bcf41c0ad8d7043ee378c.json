{"sha": "11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFhZTUwOGI3YWE4MGQyNmMxNGJjZjQxYzBhZDhkNzA0M2VlMzc4Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-30T10:37:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-30T10:37:57Z"}, "message": "flow.c (struct reg_cond_life_info): New.\n\n        * flow.c (struct reg_cond_life_info): New.\n        (struct propagate_block_info): Add reg_cond_dead and reg_cond_reg.\n        (init_propagate_block_info): Initialize them.\n        (free_propagate_block_info): Destruct them.\n        (mark_set_1): Consider conditional life before killing a register.\n        (mark_regno_cond_dead): New.\n        (free_reg_cond_life_info): New.\n        (flush_reg_cond_reg_1, flush_reg_cond_reg): New.\n        (ior_reg_cond, not_reg_cond, nand_reg_cond): New.\n        (mark_used_reg): Record conditional life.\n\n        * haifa-sched.c (schedule_insns): Disable death counting\n        sanity check for HAVE_conditional_execution.\n\nFrom-SVN: r33544", "tree": {"sha": "f5871199a09d8a91181fbb5304bf0a54b10242a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5871199a09d8a91181fbb5304bf0a54b10242a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/comments", "author": null, "committer": null, "parents": [{"sha": "614f6bc1640585bfc0add375a0064b90344f0966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/614f6bc1640585bfc0add375a0064b90344f0966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/614f6bc1640585bfc0add375a0064b90344f0966"}], "stats": {"total": 454, "additions": 453, "deletions": 1}, "files": [{"sha": "b960165c410834b43bf6180e74d4187be7081e23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "patch": "@@ -1,3 +1,19 @@\n+2000-04-30  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (struct reg_cond_life_info): New.\n+\t(struct propagate_block_info): Add reg_cond_dead and reg_cond_reg.\n+\t(init_propagate_block_info): Initialize them.\n+\t(free_propagate_block_info): Destruct them.\n+\t(mark_set_1): Consider conditional life before killing a register.\n+\t(mark_regno_cond_dead): New.\n+\t(free_reg_cond_life_info): New.\n+\t(flush_reg_cond_reg_1, flush_reg_cond_reg): New.\n+\t(ior_reg_cond, not_reg_cond, nand_reg_cond): New.\n+\t(mark_used_reg): Record conditional life.\n+\n+\t* haifa-sched.c (schedule_insns): Disable death counting\n+\tsanity check for HAVE_conditional_execution.\n+\n 2000-04-30  Richard Henderson  <rth@cygnus.com>\n \n \t* Makefile.in (TIMEVAR_H): New."}, {"sha": "16f008c8c3cdb44b2cd9532813791e3e4828472b", "filename": "gcc/flow.c", "status": "modified", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "patch": "@@ -138,6 +138,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n \n #include \"obstack.h\"\n+#include \"splay-tree.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -253,6 +254,16 @@ varray_type basic_block_for_insn;\n \n static rtx label_value_list;\n \n+/* Holds information for tracking conditional register life information.  */\n+struct reg_cond_life_info\n+{\n+  /* An EXPR_LIST of conditions under which a register is dead.  */\n+  rtx condition;\n+\n+  /* ??? Could store mask of bytes that are dead, so that we could finally\n+     track lifetimes of multi-word registers accessed via subregs.  */\n+};\n+\n /* For use in communicating between propagate_block and its subroutines.\n    Holds all information needed to compute life and def-use information.  */\n \n@@ -278,6 +289,15 @@ struct propagate_block_info\n   /* If non-null, record the set of registers set in the basic block.  */\n   regset local_set;\n \n+#ifdef HAVE_conditional_execution\n+  /* Indexed by register number, holds a reg_cond_life_info for each\n+     register that is not unconditionally live or dead.  */\n+  splay_tree reg_cond_dead;\n+\n+  /* Bit N is set if register N is in an expression in reg_cond_dead.  */\n+  regset reg_cond_reg;\n+#endif\n+\n   /* Non-zero if the value of CC0 is live.  */\n   int cc0_live;\n \n@@ -335,6 +355,17 @@ static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t enum rtx_code, rtx, rtx,\n \t\t\t\t\t\t rtx, int));\n+#ifdef HAVE_conditional_execution\n+static int mark_regno_cond_dead\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t int, rtx));\n+static void free_reg_cond_life_info\tPARAMS ((splay_tree_value));\n+static int flush_reg_cond_reg_1\t\tPARAMS ((splay_tree_node, void *));\n+static void flush_reg_cond_reg\t\tPARAMS ((struct propagate_block_info *,\n+\t\t\t\t\t\t int));\n+static rtx ior_reg_cond\t\t\tPARAMS ((rtx, rtx));\n+static rtx not_reg_cond\t\t\tPARAMS ((rtx));\n+static rtx nand_reg_cond\t\tPARAMS ((rtx, rtx));\n+#endif\n #ifdef AUTO_INC_DEC\n static void find_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx));\n@@ -3522,6 +3553,80 @@ init_propagate_block_info (bb, live, local_set, flags)\n \n   pbi->new_set = BITMAP_XMALLOC ();\n \n+#ifdef HAVE_conditional_execution\n+  pbi->reg_cond_dead = splay_tree_new (splay_tree_compare_ints, NULL,\n+\t\t\t\t       free_reg_cond_life_info);\n+  pbi->reg_cond_reg = BITMAP_XMALLOC ();\n+\n+  /* If this block ends in a conditional branch, for each register live\n+     from one side of the branch and not the other, record the register\n+     as conditionally dead.  */\n+  if (GET_CODE (bb->end) == JUMP_INSN\n+      && condjump_p (bb->end)\n+      && ! simplejump_p (bb->end))\n+    {\n+      regset_head diff_head;\n+      regset diff = INITIALIZE_REG_SET (diff_head);\n+      basic_block bb_true, bb_false;\n+      rtx cond_true, cond_false;\n+      int i;\n+\n+      /* Identify the successor blocks.  */\n+      bb_false = bb->succ->succ_next->dest;\n+      bb_true = bb->succ->dest;\n+      if (bb->succ->flags & EDGE_FALLTHRU)\n+\t{\n+\t  basic_block t = bb_false;\n+\t  bb_false = bb_true;\n+\t  bb_true = t;\n+\t}\n+      else if (! (bb->succ->succ_next->flags & EDGE_FALLTHRU))\n+\tabort ();\n+     \n+      /* Extract the condition from the branch.  */\n+      cond_true = XEXP (SET_SRC (PATTERN (bb->end)), 0);\n+      cond_false = gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond_true)),\n+\t\t\t\t   GET_MODE (cond_true), XEXP (cond_true, 0),\n+\t\t\t\t   XEXP (cond_true, 1));\n+      if (GET_CODE (XEXP (SET_SRC (PATTERN (bb->end)), 1)) == PC)\n+\t{\n+\t  rtx t = cond_false;\n+\t  cond_false = cond_true;\n+\t  cond_true = t;\n+\t}\n+\n+      /* Compute which register lead different lives in the successors.  */\n+      if (bitmap_operation (diff, bb_true->global_live_at_start,\n+\t\t\t    bb_false->global_live_at_start, BITMAP_XOR))\n+\t{\n+\t  if (GET_CODE (XEXP (cond_true, 0)) != REG)\n+\t    abort ();\n+\t  SET_REGNO_REG_SET (pbi.reg_cond_reg, REGNO (XEXP (cond_true, 0)));\n+\n+\t  /* For each such register, mark it conditionally dead.  */\n+\t  EXECUTE_IF_SET_IN_REG_SET\n+\t    (diff, 0, i,\n+\t     {\n+\t       struct reg_cond_life_info *rcli;\n+\t       rtx cond;\n+\n+\t       rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n+\n+\t       if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n+\t\t cond = cond_false;\n+\t       else\n+\t\t cond = cond_true;\n+\t       rcli->condition = alloc_EXPR_LIST (0, cond, NULL_RTX);\n+\n+\t       splay_tree_insert (pbi.reg_cond_dead, i,\n+\t\t\t\t  (splay_tree_value) rcli);\n+\t     });\n+\t}\n+\n+      FREE_REG_SET (diff);\n+    }\n+#endif\n+\n   return pbi;\n }\n \n@@ -3535,6 +3640,11 @@ free_propagate_block_info (pbi)\n \n   BITMAP_XFREE (pbi->new_set);\n \n+#ifdef HAVE_conditional_execution\n+  splay_tree_delete (pbi->reg_cond_dead);\n+  BITMAP_XFREE (pbi->reg_cond_reg);\n+#endif\n+\n   if (pbi->reg_next_use)\n     free (pbi->reg_next_use);\n \n@@ -4137,6 +4247,22 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t  some_was_dead |= ! needed_regno;\n \t}\n \n+#ifdef HAVE_conditional_execution\n+      /* Consider conditional death in deciding that the register needs\n+\t a death note.  */\n+      if (some_was_live\n+\t  /* The stack pointer is never dead.  Well, not strictly true,\n+\t     but it's very difficult to tell from here.  Hopefully\n+\t     combine_stack_adjustments will fix up the most egregious\n+\t     errors.  */\n+\t  && regno_first != STACK_POINTER_REGNUM)\n+\t{\n+\t  for (i = regno_first; i <= regno_last; ++i)\n+\t    if (! mark_regno_cond_dead (pbi, i, cond))\n+\t      not_dead = 1;\n+\t}\n+#endif\n+\n       /* Additional data to record if this is the final pass.  */\n       if (flags & (PROP_LOG_LINKS | PROP_REG_INFO\n \t\t   | PROP_DEATH_NOTES | PROP_AUTOINC))\n@@ -4272,6 +4398,263 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n     }\n }\n \f\n+#ifdef HAVE_conditional_execution\n+/* Mark REGNO conditionally dead.  Return true if the register is\n+   now unconditionally dead.  */\n+\n+static int\n+mark_regno_cond_dead (pbi, regno, cond)\n+     struct propagate_block_info *pbi;\n+     int regno;\n+     rtx cond;\n+{\n+  /* If this is a store to a predicate register, the value of the\n+     predicate is changing, we don't know that the predicate as seen\n+     before is the same as that seen after.  Flush all dependant\n+     conditions from reg_cond_dead.  This will make all such\n+     conditionally live registers unconditionally live.  */\n+  if (REGNO_REG_SET_P (pbi->reg_cond_reg, regno))\n+    flush_reg_cond_reg (pbi, regno);\n+\n+  /* If this is an unconditional store, remove any conditional\n+     life that may have existed.  */\n+  if (cond == NULL_RTX)\n+    splay_tree_remove (pbi->reg_cond_dead, regno);\n+  else\n+    {\n+      splay_tree_node node;\n+      struct reg_cond_life_info *rcli;\n+      rtx ncond;\n+\n+      /* Otherwise this is a conditional set.  Record that fact.\n+\t It may have been conditionally used, or there may be a\n+\t subsequent set with a complimentary condition.  */\n+\n+      node = splay_tree_lookup (pbi->reg_cond_dead, regno);\n+      if (node == NULL)\n+\t{\n+\t  /* The register was unconditionally live previously.\n+\t     Record the current condition as the condition under\n+\t     which it is dead.  */\n+\t  rcli = (struct reg_cond_life_info *)\n+\t    xmalloc (sizeof (*rcli));\n+\t  rcli->condition = alloc_EXPR_LIST (0, cond, NULL_RTX);\n+\t  splay_tree_insert (pbi->reg_cond_dead, regno,\n+\t\t\t     (splay_tree_value) rcli);\n+\n+\t  SET_REGNO_REG_SET (pbi->reg_cond_reg,\n+\t\t\t     REGNO (XEXP (cond, 0)));\n+\n+\t  /* Not unconditionaly dead.  */\n+\t  return 0;\n+\t}\n+      else\n+\t{\n+\t  /* The register was conditionally live previously. \n+\t     Add the new condition to the old.  */\n+\t  rcli = (struct reg_cond_life_info *) node->value;\n+\t  ncond = rcli->condition;\n+\t  ncond = ior_reg_cond (ncond, cond);\n+\n+\t  /* If the register is now unconditionally dead,\n+\t     remove the entry in the splay_tree.  */\n+\t  if (ncond == const1_rtx)\n+\t    splay_tree_remove (pbi->reg_cond_dead, regno);\n+\t  else\n+\t    {\n+\t      rcli->condition = ncond;\n+\n+\t      SET_REGNO_REG_SET (pbi->reg_cond_reg,\n+\t\t\t\t REGNO (XEXP (cond, 0)));\n+\n+\t      /* Not unconditionaly dead.  */\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+/* Called from splay_tree_delete for pbi->reg_cond_life.  */\n+\n+static void\n+free_reg_cond_life_info (value)\n+     splay_tree_value value;\n+{\n+  struct reg_cond_life_info *rcli = (struct reg_cond_life_info *) value;\n+  free_EXPR_LIST_list (&rcli->condition);\n+  free (rcli);\n+}\n+\n+/* Helper function for flush_reg_cond_reg.  */\n+\n+static int\n+flush_reg_cond_reg_1 (node, data)\n+     splay_tree_node node;\n+     void *data;\n+{\n+  struct reg_cond_life_info *rcli;\n+  int *xdata = (int *) data;\n+  unsigned int regno = xdata[0];\n+  rtx c, *prev;\n+\n+  /* Don't need to search if last flushed value was farther on in\n+     the in-order traversal.  */\n+  if (xdata[1] >= (int) node->key)\n+    return 0;\n+\n+  /* Splice out portions of the expression that refer to regno.  */\n+  rcli = (struct reg_cond_life_info *) node->value;\n+  c = *(prev = &rcli->condition);\n+  while (c)\n+    {\n+      if (regno == REGNO (XEXP (XEXP (c, 0), 0)))\n+\t{\n+\t  rtx next = XEXP (c, 1);\n+\t  free_EXPR_LIST_node (c);\n+\t  c = *prev = next;\n+\t}\n+      else\n+\tc = *(prev = &XEXP (c, 1));\n+    }\n+\n+  /* If the entire condition is now NULL, signal the node to be removed.  */\n+  if (! rcli->condition)\n+    {\n+      xdata[1] = node->key;\n+      return -1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Flush all (sub) expressions referring to REGNO from REG_COND_LIVE.  */\n+\n+static void\n+flush_reg_cond_reg (pbi, regno)\n+     struct propagate_block_info *pbi;\n+     int regno;\n+{\n+  int pair[2];\n+\n+  pair[0] = regno;\n+  pair[1] = -1;\n+  while (splay_tree_foreach (pbi->reg_cond_dead,\n+\t\t\t     flush_reg_cond_reg_1, pair) == -1)\n+    splay_tree_remove (pbi->reg_cond_dead, pair[1]);\n+\n+  CLEAR_REGNO_REG_SET (pbi->reg_cond_reg, regno);\n+}\n+\n+/* Logical arithmetic on predicate conditions.  IOR, NOT and NAND.\n+   We actually use EXPR_LIST to chain the sub-expressions together\n+   instead of IOR because it's easier to manipulate and we have \n+   the lists.c functions to reuse nodes.\n+   \n+   Return a new rtl expression as appropriate.  */\n+\n+static rtx\n+ior_reg_cond (old, x)\n+     rtx old, x;\n+{\n+  enum rtx_code x_code;\n+  rtx x_reg;\n+  rtx c;\n+\n+  /* We expect these conditions to be of the form (eq reg 0).  */\n+  x_code = GET_CODE (x);\n+  if (GET_RTX_CLASS (x_code) != '<'\n+      || GET_CODE (x_reg = XEXP (x, 0)) != REG\n+      || XEXP (x, 1) != const0_rtx)\n+    abort ();\n+\n+  /* Search the expression for an existing sub-expression of X_REG.  */\n+  for (c = old; c ; c = XEXP (c, 1))\n+    {\n+      rtx y = XEXP (c, 0);\n+      if (REGNO (XEXP (y, 0)) == REGNO (x_reg))\n+\t{\n+\t  /* If we find X already present in OLD, we need do nothing.  */\n+\t  if (GET_CODE (y) == x_code)\n+\t    return old;\n+\n+\t  /* If we find X being a compliment of a condition in OLD, \n+\t     then the entire condition is true.  */\n+\t  if (GET_CODE (y) == reverse_condition (x_code))\n+\t    return const1_rtx;\n+\t}\n+    }\n+\n+  /* Otherwise just add to the chain.  */\n+  return alloc_EXPR_LIST (0, x, old);\n+}\n+\n+static rtx\n+not_reg_cond (x)\n+     rtx x;\n+{\n+  enum rtx_code x_code;\n+  rtx x_reg;\n+\n+  /* We expect these conditions to be of the form (eq reg 0).  */\n+  x_code = GET_CODE (x);\n+  if (GET_RTX_CLASS (x_code) != '<'\n+      || GET_CODE (x_reg = XEXP (x, 0)) != REG\n+      || XEXP (x, 1) != const0_rtx)\n+    abort ();\n+\n+  return alloc_EXPR_LIST (0, gen_rtx_fmt_ee (reverse_condition (x_code),\n+\t\t\t\t\t     VOIDmode, x_reg, const0_rtx),\n+\t\t\t  NULL_RTX);\n+}\n+\n+static rtx\n+nand_reg_cond (old, x)\n+     rtx old, x;\n+{\n+  enum rtx_code x_code;\n+  rtx x_reg;\n+  rtx c, *prev;\n+\n+  /* We expect these conditions to be of the form (eq reg 0).  */\n+  x_code = GET_CODE (x);\n+  if (GET_RTX_CLASS (x_code) != '<'\n+      || GET_CODE (x_reg = XEXP (x, 0)) != REG\n+      || XEXP (x, 1) != const0_rtx)\n+    abort ();\n+\n+  /* Search the expression for an existing sub-expression of X_REG.  */\n+\n+  for (c = *(prev = &old); c ; c = *(prev = &XEXP (c, 1)))\n+    {\n+      rtx y = XEXP (c, 0);\n+      if (REGNO (XEXP (y, 0)) == REGNO (x_reg))\n+\t{\n+\t  /* If we find X already present in OLD, then we need to \n+\t     splice it out.  */\n+\t  if (GET_CODE (y) == x_code)\n+\t    {\n+\t      *prev = XEXP (c, 1);\n+\t      free_EXPR_LIST_node (c);\n+\t      return old ? old : const0_rtx;\n+\t    }\n+\n+\t  /* If we find X being a compliment of a condition in OLD, \n+\t     then we need do nothing.  */\n+\t  if (GET_CODE (y) == reverse_condition (x_code))\n+\t    return old;\n+\t}\n+    }\n+\n+  /* Otherwise, by implication, the register in question is now live for\n+     the inverse of the condition X.  */\n+  return alloc_EXPR_LIST (0, gen_rtx_fmt_ee (reverse_condition (x_code),\n+\t\t\t\t\t     VOIDmode, x_reg, const0_rtx),\n+\t\t\t  old);\n+}\n+#endif /* HAVE_conditional_execution */\n+\f\n #ifdef AUTO_INC_DEC\n \n /* X is a MEM found in INSN.  See if we can convert it into an auto-increment\n@@ -4594,6 +4977,54 @@ mark_used_reg (pbi, reg, cond, insn)\n       while (--n > 0)\n \tSET_REGNO_REG_SET (pbi->reg_live, regno + n);\n     }\n+\n+#ifdef HAVE_conditional_execution\n+  /* If this is a conditional use, record that fact.  If it is later\n+     conditionally set, we'll know to kill the register.  */\n+  if (cond != NULL_RTX)\n+    {\n+      splay_tree_node node;\n+      struct reg_cond_life_info *rcli;\n+      rtx ncond;\n+\n+      if (some_was_live)\n+\t{\n+\t  node = splay_tree_lookup (pbi->reg_cond_dead, regno);\n+\t  if (node == NULL)\n+\t    {\n+\t      /* The register was unconditionally live previously.\n+\t\t No need to do anything.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The register was conditionally live previously. \n+\t\t Subtract the new life cond from the old death cond.  */\n+\t      rcli = (struct reg_cond_life_info *) node->value;\n+\t      ncond = rcli->condition;\n+\t      ncond = nand_reg_cond (ncond, cond);\n+\n+\t      /* If the register is now unconditionally live, remove the\n+\t\t entry in the splay_tree.  */\n+\t      if (ncond == const0_rtx)\n+\t\t{\n+\t\t  rcli->condition = NULL_RTX;\n+\t\t  splay_tree_remove (pbi->reg_cond_dead, regno);\n+\t\t}\n+\t      else\n+\t\trcli->condition = ncond;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* The register was not previously live at all.  Record\n+\t     the condition under which it is still dead.  */\n+\t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n+\t  rcli->condition = not_reg_cond (cond);\n+\t  splay_tree_insert (pbi->reg_cond_dead, regno,\n+\t\t\t     (splay_tree_value) rcli);\n+\t}\n+    }\n+#endif\n }\n \n /* Scan expression X and store a 1-bit in NEW_LIVE for each reg it uses."}, {"sha": "83d85fdbe33e757e8d13a562f1e614ad95747ef0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11ae508b7aa80d26c14bcf41c0ad8d7043ee378c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=11ae508b7aa80d26c14bcf41c0ad8d7043ee378c", "patch": "@@ -7019,10 +7019,15 @@ schedule_insns (dump_file)\n \t\t\t  (reload_completed ? PROP_DEATH_NOTES\n \t\t\t   : PROP_DEATH_NOTES | PROP_REG_INFO));\n \n+#ifndef HAVE_conditional_execution\n+\t/* ??? REG_DEAD notes only exist for unconditional deaths.  We need\n+\t   a count of the conditional plus unconditional deaths for this to\n+\t   work out.  */\n \t/* In the single block case, the count of registers that died should\n \t   not have changed during the schedule.  */\n \tif (count_or_remove_death_notes (blocks, 0) != deaths_in_region[rgn])\n-          abort (); \n+          abort ();\n+#endif\n       }\n \n   if (any_large_regions)"}]}