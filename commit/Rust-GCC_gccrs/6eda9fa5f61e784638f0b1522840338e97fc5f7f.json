{"sha": "6eda9fa5f61e784638f0b1522840338e97fc5f7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVkYTlmYTVmNjFlNzg0NjM4ZjBiMTUyMjg0MDMzOGU5N2ZjNWY3Zg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-09-17T07:23:12Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-01T12:55:08Z"}, "message": "Initial implementation of value query class.\n\ngcc/ChangeLog:\n\n\t* Makefile.in: Add value-query.o.\n\t* value-query.cc: New file.\n\t* value-query.h: New file.", "tree": {"sha": "45945e8b3fbdd1cbbb1fe6c84b7f22530afd0b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45945e8b3fbdd1cbbb1fe6c84b7f22530afd0b04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eda9fa5f61e784638f0b1522840338e97fc5f7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eda9fa5f61e784638f0b1522840338e97fc5f7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eda9fa5f61e784638f0b1522840338e97fc5f7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eda9fa5f61e784638f0b1522840338e97fc5f7f/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bab2a0dc84e7c3e14cb44fcd6ac41df079baa0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bab2a0dc84e7c3e14cb44fcd6ac41df079baa0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bab2a0dc84e7c3e14cb44fcd6ac41df079baa0f"}], "stats": {"total": 270, "additions": 270, "deletions": 0}, "files": [{"sha": "50d6c83eb768de4d62c35c27b478aada4062e320", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eda9fa5f61e784638f0b1522840338e97fc5f7f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eda9fa5f61e784638f0b1522840338e97fc5f7f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6eda9fa5f61e784638f0b1522840338e97fc5f7f", "patch": "@@ -1646,6 +1646,7 @@ OBJS = \\\n \ttyped-splay-tree.o \\\n \tunique-ptr-tests.o \\\n \tvaltrack.o \\\n+\tvalue-query.o \\\n \tvalue-range.o \\\n \tvalue-range-equiv.o \\\n \tvalue-prof.o \\"}, {"sha": "5370a23fe18c2d90233ad899b14337b2f9963853", "filename": "gcc/value-query.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eda9fa5f61e784638f0b1522840338e97fc5f7f/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eda9fa5f61e784638f0b1522840338e97fc5f7f/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=6eda9fa5f61e784638f0b1522840338e97fc5f7f", "patch": "@@ -0,0 +1,162 @@\n+/* Support routines for value queries.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com> and\n+   Andrew MacLeod <amacleod@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"value-range-equiv.h\"\n+#include \"value-query.h\"\n+#include \"alloc-pool.h\"\n+\n+// value_query default methods.\n+\n+tree\n+value_query::value_on_edge (edge, tree name)\n+{\n+  return value_of_expr (name);\n+}\n+\n+tree\n+value_query::value_of_stmt (gimple *stmt, tree name)\n+{\n+  if (!name)\n+    name = gimple_get_lhs (stmt);\n+\n+  gcc_checking_assert (!name || name == gimple_get_lhs (stmt));\n+\n+  if (name)\n+    return value_of_expr (name);\n+  return NULL_TREE;\n+}\n+\n+// range_query default methods.\n+\n+bool\n+range_query::range_on_edge (irange &r, edge, tree name)\n+{\n+  return range_of_expr (r, name);\n+}\n+\n+bool\n+range_query::range_of_stmt (irange &r, gimple *stmt, tree name)\n+{\n+  if (!name)\n+    name = gimple_get_lhs (stmt);\n+\n+  gcc_checking_assert (!name || name == gimple_get_lhs (stmt));\n+\n+  if (name)\n+    return range_of_expr (r, name);\n+  return false;\n+}\n+\n+tree\n+range_query::value_of_expr (tree name, gimple *stmt)\n+{\n+  tree t;\n+  value_range r;\n+\n+  if (!irange::supports_type_p (TREE_TYPE (name)))\n+    return NULL_TREE;\n+  if (range_of_expr (r, name, stmt) && r.singleton_p (&t))\n+    return t;\n+  return NULL_TREE;\n+}\n+\n+tree\n+range_query::value_on_edge (edge e, tree name)\n+{\n+  tree t;\n+  value_range r;\n+\n+  if (!irange::supports_type_p (TREE_TYPE (name)))\n+    return NULL_TREE;\n+  if (range_on_edge (r, e, name) && r.singleton_p (&t))\n+    return t;\n+  return NULL_TREE;\n+\n+}\n+\n+tree\n+range_query::value_of_stmt (gimple *stmt, tree name)\n+{\n+  tree t;\n+  value_range r;\n+\n+  if (!name)\n+    name = gimple_get_lhs (stmt);\n+\n+  gcc_checking_assert (!name || name == gimple_get_lhs (stmt));\n+\n+  if (!name || !irange::supports_type_p (TREE_TYPE (name)))\n+    return NULL_TREE;\n+  if (range_of_stmt (r, stmt, name) && r.singleton_p (&t))\n+    return t;\n+  return NULL_TREE;\n+\n+}\n+\n+// valuation_query support routines for value_range_equiv's.\n+\n+class equiv_allocator : public object_allocator<value_range_equiv>\n+{\n+public:\n+  equiv_allocator ()\n+    : object_allocator<value_range_equiv> (\"equiv_allocator pool\") { }\n+};\n+\n+value_range_equiv *\n+range_query::allocate_value_range_equiv ()\n+{\n+  return new (equiv_alloc->allocate ()) value_range_equiv;\n+}\n+\n+void\n+range_query::free_value_range_equiv (value_range_equiv *v)\n+{\n+  equiv_alloc->remove (v);\n+}\n+\n+const class value_range_equiv *\n+range_query::get_value_range (const_tree expr, gimple *stmt)\n+{\n+  int_range_max r;\n+  if (range_of_expr (r, const_cast<tree> (expr), stmt))\n+    return new (equiv_alloc->allocate ()) value_range_equiv (r);\n+  return new (equiv_alloc->allocate ()) value_range_equiv (TREE_TYPE (expr));\n+}\n+\n+range_query::range_query ()\n+{\n+  equiv_alloc = new equiv_allocator;\n+}\n+\n+range_query::~range_query ()\n+{\n+  equiv_alloc->release ();\n+  delete equiv_alloc;\n+}"}, {"sha": "cf0b6ed5dc1314f061e030775a3527d904c9d001", "filename": "gcc/value-query.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eda9fa5f61e784638f0b1522840338e97fc5f7f/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eda9fa5f61e784638f0b1522840338e97fc5f7f/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=6eda9fa5f61e784638f0b1522840338e97fc5f7f", "patch": "@@ -0,0 +1,107 @@\n+/* Support routines for value queries.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com> and\n+   Andrew Macleod <amacleod@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_QUERY_H\n+#define GCC_QUERY_H\n+\n+// The value_query class is used by optimization passes that require\n+// valueizing SSA names in terms of a tree value, but have no neeed\n+// for ranges.\n+//\n+// value_of_expr must be provided.  The default for value_on_edge and\n+// value_of_stmt is to call value_of_expr.\n+//\n+// This implies the valuation is global in nature.  If a pass can make\n+// use of more specific information, it can override the other queries.\n+//\n+// Proper usage of the correct query in passes will enable other\n+// valuation mechanisms to produce more precise results.\n+\n+class value_query\n+{\n+public:\n+  value_query () { }\n+  // Return the singleton expression for NAME at a gimple statement,\n+  // or NULL if none found.\n+  virtual tree value_of_expr (tree name, gimple * = NULL) = 0;\n+  // Return the singleton expression for NAME at an edge, or NULL if\n+  // none found.\n+  virtual tree value_on_edge (edge, tree name);\n+  // Return the singleton expression for the LHS of a gimple\n+  // statement, assuming an (optional) initial value of NAME.  Returns\n+  // NULL if none found.\n+  //\n+  // Note that this method calculates the range the LHS would have\n+  // *after* the statement has executed.\n+  virtual tree value_of_stmt (gimple *, tree name = NULL);\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (value_query);\n+};\n+\n+// The range_query class is used by optimization passes which are\n+// range aware.\n+//\n+// range_of_expr must be provided.  The default for range_on_edge and\n+// range_of_stmt is to call range_of_expr.  If a pass can make use of\n+// more specific information, then it can override the other queries.\n+//\n+// The default for the value_* routines is to call the equivalent\n+// range_* routines, check if the range is a singleton, and return it\n+// if so.\n+//\n+// The get_value_range method is currently provided for compatibility\n+// with vr-values.  It will be deprecated when possible.\n+\n+class range_query : public value_query\n+{\n+public:\n+  range_query ();\n+  virtual ~range_query ();\n+\n+  virtual tree value_of_expr (tree name, gimple * = NULL) OVERRIDE;\n+  virtual tree value_on_edge (edge, tree name) OVERRIDE;\n+  virtual tree value_of_stmt (gimple *, tree name = NULL) OVERRIDE;\n+\n+  // These are the range equivalents of the value_* methods.  Instead\n+  // of returning a singleton, they calculate a range and return it in\n+  // R.  TRUE is returned on success or FALSE if no range was found.\n+  //\n+  // Note that range_of_expr must always return TRUE unless ranges are\n+  // unsupported for NAME's type (supports_type_p is false).\n+  virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) = 0;\n+  virtual bool range_on_edge (irange &r, edge, tree name);\n+  virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL);\n+\n+  // DEPRECATED: This method is used from vr-values.  The plan is to\n+  // rewrite all uses of it to the above API.\n+  virtual const class value_range_equiv *get_value_range (const_tree,\n+\t\t\t\t\t\t\t  gimple * = NULL);\n+\n+protected:\n+  class value_range_equiv *allocate_value_range_equiv ();\n+  void free_value_range_equiv (class value_range_equiv *);\n+\n+private:\n+  class equiv_allocator *equiv_alloc;\n+};\n+\n+#endif // GCC_QUERY_H"}]}