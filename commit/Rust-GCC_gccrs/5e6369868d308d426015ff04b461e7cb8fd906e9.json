{"sha": "5e6369868d308d426015ff04b461e7cb8fd906e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU2MzY5ODY4ZDMwOGQ0MjYwMTVmZjA0YjQ2MWU3Y2I4ZmQ5MDZlOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-08T15:35:57Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-08T15:35:57Z"}, "message": "(umulsidi3, mulsidi3): Don't generate an immediate\noperand that the matcher won't accept.\n\n(umulsidi3 expand + two matchers): Rewrite.\nOld patterns misused subreg and matched wrong immediate values.\n(mulsidi3 patterns): Likewise.\n\nFrom-SVN: r4384", "tree": {"sha": "c0c4ea9d9a9b721902c1736503beb19cb1f8c149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0c4ea9d9a9b721902c1736503beb19cb1f8c149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e6369868d308d426015ff04b461e7cb8fd906e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6369868d308d426015ff04b461e7cb8fd906e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6369868d308d426015ff04b461e7cb8fd906e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6369868d308d426015ff04b461e7cb8fd906e9/comments", "author": null, "committer": null, "parents": [{"sha": "d6924c84424964dbdab8ce058159de6118692df1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6924c84424964dbdab8ce058159de6118692df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6924c84424964dbdab8ce058159de6118692df1"}], "stats": {"total": 130, "additions": 52, "deletions": 78}, "files": [{"sha": "0a319fd34987d598aecbb6f0e7f8acd1c0d4ba02", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 52, "deletions": 78, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6369868d308d426015ff04b461e7cb8fd906e9/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6369868d308d426015ff04b461e7cb8fd906e9/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=5e6369868d308d426015ff04b461e7cb8fd906e9", "patch": "@@ -2403,7 +2403,7 @@\n \t(mult:SI (sign_extend:SI\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n+  \"INTVAL (operands[2]) >= -0x10000 && INTVAL (operands[2]) <= 0x7fff\"\n   \"*\n {\n #if defined(MOTOROLA) && !defined(CRDS)\n@@ -2441,7 +2441,7 @@\n \t(mult:SI (zero_extend:SI\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n+  \"INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) <= 0xffff\"\n   \"*\n {\n #if defined(MOTOROLA) && !defined(CRDS)\n@@ -2457,113 +2457,87 @@\n (define_expand \"umulsidi3\"\n   [(parallel\n     [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"\") 1)\n-\t  (subreg:SI\n-\t   (mult:DI (zero_extend:DI\n-\t\t     (match_operand:SI 1 \"register_operand\" \"\"))\n-\t\t    (zero_extend:DI\n-\t\t     (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n-\t   1))\n+\t  (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n      (set (subreg:SI (match_dup 0) 0)\n-\t  (subreg:SI\n-\t   (mult:DI (zero_extend:DI\n-\t\t     (match_dup 1))\n-\t\t    (zero_extend:DI\n-\t\t     (match_dup 2)))\n-\t   0))])]\n-  \"TARGET_68020\"\n+\t  (truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n+\t\t\t\t\t     (zero_extend:DI (match_dup 2)))\n+\t\t\t\t    (const_int 32))))])]\n+  ;; Prevent generating an insn that the immediate pattern below\n+  ;; would refuse to match.\n+  ;; Testing INTVAL in this way is a no-op, both there and here;\n+  ;; but in case on some host is not a no-op,\n+  ;; this test must go with the other.\n+  \"TARGET_68020\n+   && !(GET_CODE (operands[2]) == CONST_INT\n+\t&& INTVAL (operands[2]) > 0x7fffffff)\"\n   \"\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (zero_extend:DI\n-\t\t   (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t\t  (zero_extend:DI\n-\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"dm\")))\n-\t 1))\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"dm\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (zero_extend:DI\n-\t\t   (match_dup 1))\n-\t\t  (zero_extend:DI\n-\t\t   (match_dup 2)))\n-\t 0))]\n+\t(truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n+\t\t\t\t\t   (zero_extend:DI (match_dup 2)))\n+\t\t\t\t  (const_int 32))))]\n   \"TARGET_68020\"\n   \"mulu%.l %2,%3:%0\")\n \n+; Match immediate case.  For 2.4 only match things < 2^31. For 2.5 we\n+; can enhance this and the similar pattern below for signed multiply.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (zero_extend:DI\n-\t\t   (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t\t  (match_operand:SI 2 \"immediate_operand\" \"sK\"))\n-\t 1))\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"\" \"K\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (zero_extend:DI\n-\t\t   (match_dup 1))\n-\t\t  (zero_extend:DI\n-\t\t   (match_dup 2)))\n-\t 0))]\n+\t(truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n+\t\t\t\t\t   (match_dup 2))\n+\t\t\t\t  (const_int 32))))]\n   \"TARGET_68020\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))\"\n+   && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) <= 0x7fffffff\"\n   \"mulu%.l %2,%3:%0\")\n \n (define_expand \"mulsidi3\"\n   [(parallel\n     [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"\") 1)\n-\t  (subreg:SI\n-\t   (mult:DI (sign_extend:DI\n-\t\t     (match_operand:SI 1 \"register_operand\" \"\"))\n-\t\t    (sign_extend:DI\n-\t\t     (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n-\t   1))\n+\t  (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n      (set (subreg:SI (match_dup 0) 0)\n-\t  (subreg:SI\n-\t   (mult:DI (sign_extend:DI\n-\t\t     (match_dup 1))\n-\t\t    (sign_extend:DI\n-\t\t     (match_dup 2)))\n-\t   0))])]\n-  \"TARGET_68020\"\n+\t  (truncate:SI (ashift:DI (mult:DI (sign_extend:DI (match_dup 1))\n+\t\t\t\t\t   (sign_extend:DI (match_dup 2)))\n+\t\t\t\t  (const_int 32))))])]\n+  ;; Prevent generating an insn that the immediate pattern below\n+  ;; would refuse to match.\n+  ;; Testing INTVAL in this way is a no-op, both there and here;\n+  ;; but in case on some host is not a no-op,\n+  ;; this test must go with the other.\n+  \"TARGET_68020\n+   && !(GET_CODE (operands[2]) == CONST_INT\n+\t&& INTVAL (operands[2]) > 0x7fffffff)\"\n   \"\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (sign_extend:DI\n-\t\t   (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t\t  (sign_extend:DI\n-\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"dm\")))\n-\t 1))\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"nonimmediate_operand\" \"dm\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (sign_extend:DI\n-\t\t   (match_dup 1))\n-\t\t  (sign_extend:DI\n-\t\t   (match_dup 2)))\n-\t 0))]\n+\t(truncate:SI (ashift:DI (mult:DI (sign_extend:DI (match_dup 1))\n+\t\t\t\t\t (sign_extend:DI (match_dup 2)))\n+\t\t\t\t(const_int 32))))]\n   \"TARGET_68020\"\n   \"muls%.l %2,%3:%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (sign_extend:DI\n-\t\t   (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t\t  (match_operand:SI 2 \"immediate_operand\" \"sK\"))\n-\t 1))\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"\" \"K\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(subreg:SI\n-\t (mult:DI (sign_extend:DI\n-\t\t   (match_dup 1))\n-\t\t  (sign_extend:DI\n-\t\t   (match_dup 2)))\n-\t 0))]\n+\t(truncate:SI (ashift:DI (mult:DI (sign_extend:DI (match_dup 1))\n+\t\t\t\t\t (match_dup 2))\n+\t\t\t\t(const_int 32))))]\n   \"TARGET_68020\n-   && (GET_CODE (operands[2]) != CONST_INT\n-       || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))\"\n+   && GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) <= 0x7fffffff\"\n   \"muls%.l %2,%3:%0\")\n \n (define_expand \"muldf3\""}]}