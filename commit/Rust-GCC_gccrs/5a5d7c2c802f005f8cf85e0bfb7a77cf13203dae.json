{"sha": "5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae", "node_id": "C_kwDOANBUbNoAKDVhNWQ3YzJjODAyZjAwNWY4Y2Y4NWUwYmZiN2E3N2NmMTMyMDNkYWU", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-21T16:44:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-21T21:24:53Z"}, "message": "libstdc++: Add Doxygen comments to contents of <functional>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/mofunc_impl.h: Add doxygen comments.\n\t* include/std/functional: Likewise.", "tree": {"sha": "b0b8fbdd179938395e8b491306211dc0d33b376e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0b8fbdd179938395e8b491306211dc0d33b376e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6667d5feb9cbb14fc4e2a4f90d9dfa14e24d5bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6667d5feb9cbb14fc4e2a4f90d9dfa14e24d5bd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6667d5feb9cbb14fc4e2a4f90d9dfa14e24d5bd9"}], "stats": {"total": 131, "additions": 119, "deletions": 12}, "files": [{"sha": "6cc9711a42b753ad411f0baa28c1228338ddc644", "filename": "libstdc++-v3/include/bits/mofunc_impl.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmofunc_impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmofunc_impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmofunc_impl.h?ref=5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae", "patch": "@@ -44,6 +44,22 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  /**\n+   *  @brief Polymorphic function wrapper.\n+   *  @ingroup functors\n+   *  @since C++23\n+   *  @headername functional\n+   *\n+   *  The `std::move_only_function` class template is a call wrapper similar\n+   *  to *  `std::function`, but does not require the stored target function\n+   *  to be copyable.\n+   *\n+   *  It also supports const-qualification, ref-qualification, and\n+   *  no-throw guarantees. The qualifications and exception-specification\n+   *  of the `move_only_function::operator()` member function are respected\n+   *  when invoking the target function.\n+   *\n+   */\n   template<typename _Res, typename... _ArgTypes, bool _Noex>\n     class move_only_function<_Res(_ArgTypes...) _GLIBCXX_MOF_CV\n \t\t\t       _GLIBCXX_MOF_REF noexcept(_Noex)>\n@@ -64,15 +80,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     public:\n       using result_type = _Res;\n \n+      /// Creates an empty object.\n       move_only_function() noexcept { }\n \n+      /// Creates an empty object.\n       move_only_function(nullptr_t) noexcept { }\n \n+      /// Moves the target object, leaving the source empty.\n       move_only_function(move_only_function&& __x) noexcept\n       : _Mofunc_base(static_cast<_Mofunc_base&&>(__x)),\n \t_M_invoke(std::__exchange(__x._M_invoke, nullptr))\n       { }\n \n+      /// Stores a target object initialized from the argument.\n       template<typename _Fn, typename _Vt = decay_t<_Fn>>\n \trequires (!is_same_v<_Vt, move_only_function>)\n \t  && (!__is_in_place_type_v<_Vt>) && __is_callable_from<_Vt>\n@@ -89,6 +109,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_invoke = &_S_invoke<_Vt>;\n \t}\n \n+      /// Stores a target object initialized from the arguments.\n       template<typename _Tp, typename... _Args>\n \trequires is_constructible_v<_Tp, _Args...>\n \t  && __is_callable_from<_Tp>\n@@ -101,6 +122,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_init<_Tp>(std::forward<_Args>(__args)...);\n \t}\n \n+      /// Stores a target object initialized from the arguments.\n       template<typename _Tp, typename _Up, typename... _Args>\n \trequires is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>\n \t  && __is_callable_from<_Tp>\n@@ -114,6 +136,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_init<_Tp>(__il, std::forward<_Args>(__args)...);\n \t}\n \n+      /// Stores a new target object, leaving `x` empty.\n       move_only_function&\n       operator=(move_only_function&& __x) noexcept\n       {\n@@ -122,6 +145,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+      /// Destroys the target object (if any).\n       move_only_function&\n       operator=(nullptr_t) noexcept\n       {\n@@ -130,6 +154,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n+      /// Stores a new target object, initialized from the argument.\n       template<typename _Fn>\n \trequires is_constructible_v<move_only_function, _Fn>\n \tmove_only_function&\n@@ -142,26 +167,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       ~move_only_function() = default;\n \n+      /// True if a target object is present, false otherwise.\n       explicit operator bool() const noexcept { return _M_invoke != nullptr; }\n \n+      /** Invoke the target object.\n+       *\n+       * The target object will be invoked using the supplied arguments,\n+       * and as an lvalue or rvalue, and as const or non-const, as dictated\n+       * by the template arguments of the `move_only_function` specialization.\n+       *\n+       * @pre Must not be empty.\n+       */\n       _Res\n       operator()(_ArgTypes... __args) _GLIBCXX_MOF_CV_REF noexcept(_Noex)\n       {\n \t__glibcxx_assert(*this != nullptr);\n \treturn _M_invoke(this, std::forward<_ArgTypes>(__args)...);\n       }\n \n+      /// Exchange the target objects (if any).\n       void\n       swap(move_only_function& __x) noexcept\n       {\n \t_Mofunc_base::swap(__x);\n \tstd::swap(_M_invoke, __x._M_invoke);\n       }\n \n+      /// Exchange the target objects (if any).\n       friend void\n       swap(move_only_function& __x, move_only_function& __y) noexcept\n       { __x.swap(__y); }\n \n+      /// Check for emptiness by comparing with `nullptr`.\n       friend bool\n       operator==(const move_only_function& __x, nullptr_t) noexcept\n       { return __x._M_invoke == nullptr; }"}, {"sha": "5cf4417b963be4ef052825fd7ffd74eff2dc3985", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 82, "deletions": 12, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=5a5d7c2c802f005f8cf85e0bfb7a77cf13203dae", "patch": "@@ -79,6 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   /** @brief The type of placeholder objects defined by libstdc++.\n    *  @ingroup binders\n+   *  @since C++11\n    */\n   template<int _Num> struct _Placeholder { };\n \n@@ -90,7 +91,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #  define __cpp_lib_constexpr_functional 201907L\n # endif\n \n-  /// Invoke a callable object.\n+  /** Invoke a callable object.\n+   *\n+   * `std::invoke` takes a callable object as its first argument and calls it\n+   * with the remaining arguments. The callable object can be a pointer or\n+   * reference to a function, a lambda closure, a class with `operator()`,\n+   * or even a pointer-to-member.  For a pointer-to-member the first argument\n+   * must be a reference or pointer to the object that the pointer-to-member\n+   * will be applied to.\n+   *\n+   *  @since C++17\n+   */\n   template<typename _Callable, typename... _Args>\n     inline _GLIBCXX20_CONSTEXPR invoke_result_t<_Callable, _Args...>\n     invoke(_Callable&& __fn, _Args&&... __args)\n@@ -103,7 +114,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #if __cplusplus > 202002L\n # define __cpp_lib_invoke_r 202106L\n \n-  /// Invoke a callable object and convert the result to _Res.\n+  /** Invoke a callable object and convert the result to `_Res`.\n+   *\n+   * `std::invoke_r<R>(f, args...)` is equivalent to `std::invoke(f, args...)`\n+   * with the result implicitly converted to `R`.\n+   *\n+   *  @since C++23\n+   */\n   template<typename _Res, typename _Callable, typename... _Args>\n     requires is_invocable_r_v<_Res, _Callable, _Args...>\n     constexpr _Res\n@@ -116,6 +133,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif // C++23\n #endif // C++17\n \n+  /// @cond undocumented\n+\n   template<typename _MemFunPtr,\n \t   bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>\n     class _Mem_fn_base\n@@ -182,13 +201,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;\n     };\n+  /// @endcond\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 2048.  Unnecessary mem_fn overloads\n   /**\n-   *  @brief Returns a function object that forwards to the member\n-   *  pointer @a pm.\n-   *  @ingroup functors\n+   * @brief Returns a function object that forwards to the member pointer\n+   * pointer `pm`.\n+   *\n+   * This allows a pointer-to-member to be transformed into a function object\n+   * that can be called with an object expression as its first argument.\n+   *\n+   * For a pointer-to-data-member the result must be called with exactly one\n+   * argument, the object expression that would be used as the first operand\n+   * in a `obj.*memptr` or `objp->*memptr` expression.\n+   *\n+   * For a pointer-to-member-function the result must be called with an object\n+   * expression and any additional arguments to pass to the member function,\n+   * as in an expression like `(obj.*memfun)(args...)` or\n+   * `(objp->*memfun)(args...)`.\n+   *\n+   * The object expression can be a pointer, reference, `reference_wrapper`,\n+   * or smart pointer, and the call wrapper will dereference it as needed\n+   * to apply the pointer-to-member.\n+   *\n+   * @ingroup functors\n+   * @since C++11\n    */\n   template<typename _Tp, typename _Class>\n     _GLIBCXX20_CONSTEXPR\n@@ -199,12 +237,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   /**\n-   *  @brief Determines if the given type _Tp is a function object that\n-   *  should be treated as a subexpression when evaluating calls to\n-   *  function objects returned by bind().\n+   * @brief Trait that identifies a bind expression.\n+   * \n+   * Determines if the given type `_Tp` is a function object that\n+   * should be treated as a subexpression when evaluating calls to\n+   * function objects returned by `std::bind`.\n    *\n-   *  C++11 [func.bind.isbind].\n-   *  @ingroup binders\n+   * C++11 [func.bind.isbind].\n+   * @ingroup binders\n+   * @since C++11\n    */\n   template<typename _Tp>\n     struct is_bind_expression\n@@ -216,6 +257,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *\n    *  C++11 [func.bind.isplace].\n    *  @ingroup binders\n+   *  @since C++11\n    */\n   template<typename _Tp>\n     struct is_placeholder\n@@ -232,6 +274,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /** @namespace std::placeholders\n    *  @brief ISO C++ 2011 namespace for std::bind placeholders.\n    *  @ingroup binders\n+   *  @since C++11\n    */\n   namespace placeholders\n   {\n@@ -274,6 +317,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  Partial specialization of is_placeholder that provides the placeholder\n    *  number for the placeholder objects defined by libstdc++.\n    *  @ingroup binders\n+   *  @since C++11\n    */\n   template<int _Num>\n     struct is_placeholder<_Placeholder<_Num> >\n@@ -285,6 +329,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public integral_constant<int, _Num>\n     { };\n \n+  /// @cond undocumented\n \n   // Like tuple_element_t but SFINAE-friendly.\n   template<std::size_t __i, typename _Tuple>\n@@ -414,6 +459,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&\n     { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }\n \n+  /// @endcond\n+\n   /// Type of the function object returned from bind().\n   template<typename _Signature>\n     class _Bind;\n@@ -799,6 +846,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /**\n    *  @brief Function template for std::bind.\n    *  @ingroup binders\n+   *  @since C++11\n    */\n   template<typename _Func, typename... _BoundArgs>\n     inline _GLIBCXX20_CONSTEXPR typename\n@@ -823,6 +871,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /**\n    *  @brief Function template for std::bind<R>.\n    *  @ingroup binders\n+   *  @since C++11\n    */\n   template<typename _Result, typename _Func, typename... _BoundArgs>\n     inline _GLIBCXX20_CONSTEXPR\n@@ -923,6 +972,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using _Bind_front_t\n       = _Bind_front<decay_t<_Fn>, decay_t<_Args>...>;\n \n+  /** Create call wrapper by partial application of arguments to function.\n+   *\n+   * The result of `std::bind_front(f, args...)` is a function object that\n+   * stores `f` and the bound arguments, `args...`. When that function\n+   * object is invoked with `call_args...` it returns the result of calling\n+   * `f(args..., call_args...)`.\n+   *\n+   *  @since C++20\n+   */\n   template<typename _Fn, typename... _Args>\n     constexpr _Bind_front_t<_Fn, _Args...>\n     bind_front(_Fn&& __fn, _Args&&... __args)\n@@ -932,7 +990,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return _Bind_front_t<_Fn, _Args...>(0, std::forward<_Fn>(__fn),\n \t\t\t\t\t  std::forward<_Args>(__args)...);\n     }\n-#endif\n+#endif // C++20\n \n #if __cplusplus >= 201402L\n   /// Generalized negator.\n@@ -1003,8 +1061,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_byte_like<byte, equal_to<void>>\n     : true_type { };\n \n+  // [func.not_fn] Function template not_fn\n #define __cpp_lib_not_fn 201603\n-  /// [func.not_fn] Function template not_fn\n+  /** Wrap a function object to create one that negates its result.\n+   *\n+   * The function template `std::not_fn` creates a \"forwarding call wrapper\",\n+   * which is a function object that wraps another function object and\n+   * when called, forwards its arguments to the wrapped function object.\n+   *\n+   * The result of invoking the wrapper is the negation (using `!`) of\n+   * the wrapped function object.\n+   *\n+   *  @ingroup functors\n+   *  @since C++17\n+   */\n   template<typename _Fn>\n     _GLIBCXX20_CONSTEXPR\n     inline auto"}]}