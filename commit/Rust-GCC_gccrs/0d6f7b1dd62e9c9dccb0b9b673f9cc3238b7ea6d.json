{"sha": "0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "node_id": "C_kwDOANBUbNoAKDBkNmY3YjFkZDYyZTljOWRjY2IwYjliNjczZjljYzMyMzhiN2VhNmQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-01-19T18:51:16Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2023-01-19T18:51:16Z"}, "message": "analyzer: use dominator info in -Wanalyzer-deref-before-check [PR108455]\n\nMy integration testing [1] of -fanalyzer in GCC 13 is showing a lot of\ndiagnostics from the new -Wanalyzer-deref-before-check warning on\nreal-world C projects, and most of these seem to be false positives.\n\nThis patch updates the warning to make it much less likely to fire:\n- only intraprocedural cases are now reported\n- reject cases in which there are control flow paths to the check\n  that didn't come through the dereference, by looking at BB dominator\n  information.  This fixes a false positive seen in git-2.39.0's\n  pack-revindex.c: load_revindex_from_disk (PR analyzer/108455), in\n  which a shared \"cleanup:\" section checks \"data\" for NULL, and\n  depending on how much of the function is executed \"data\" might or\n  might not have already been dereferenced.\n\nThe counts of -Wanalyzer-deref-before-check diagnostics in [1]\nbefore/after this patch show this improvement:\n  Known false positives:    6 ->  0  (-6)\n  Known true positives:     1 ->  1\n  Unclassified positives: 123 -> 63 (-60)\n\n[1] https://github.com/davidmalcolm/gcc-analyzer-integration-tests\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/108455\n\t* analyzer.h (class checker_event): New forward decl.\n\t(class state_change_event): Indent.\n\t(class warning_event): New forward decl.\n\t* checker-event.cc (state_change_event::state_change_event): Add\n\t\"enode\" param.\n\t(warning_event::get_desc): Update for new param of\n\tevdesc::final_event ctor.\n\t* checker-event.h (state_change_event::state_change_event): Add\n\t\"enode\" param.\n\t(state_change_event::get_exploded_node): New accessor.\n\t(state_change_event::m_enode): New field.\n\t(warning_event::warning_event): New \"enode\" param.\n\t(warning_event::get_exploded_node): New accessor.\n\t(warning_event::m_enode): New field.\n\t* diagnostic-manager.cc\n\t(state_change_event_creator::on_global_state_change): Pass\n\tsrc_node to state_change_event ctor.\n\t(state_change_event_creator::on_state_change): Likewise.\n\t(null_assignment_sm_context::set_next_state): Pass NULL for\n\tnew param of state_change_event ctor.\n\t* infinite-recursion.cc\n\t(infinite_recursion_diagnostic::add_final_event): Update for new\n\tparam of warning_event ctor.\n\t* pending-diagnostic.cc (pending_diagnostic::add_final_event):\n\tPass enode to warning_event ctor.\n\t* pending-diagnostic.h (evdesc::final_event): Add reference to\n\twarning_event.\n\t* sm-malloc.cc: Include \"analyzer/checker-event.h\" and\n\t\"analyzer/exploded-graph.h\".\n\t(deref_before_check::deref_before_check): Initialize new fields.\n\t(deref_before_check::emit): Reject warnings in which we were\n\tunable to determine the enodes of the dereference and the check.\n\tReject warnings interprocedural warnings. Reject warnings in which\n\tthe dereference doesn't dominate the check.\n\t(deref_before_check::describe_state_change): Set m_deref_enode.\n\t(deref_before_check::describe_final_event): Set m_check_enode.\n\t(deref_before_check::m_deref_enode): New field.\n\t(deref_before_check::m_check_enode): New field.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/108455\n\t* gcc.dg/analyzer/deref-before-check-1.c: Add test coverage\n\tinvolving dominance.\n\t* gcc.dg/analyzer/deref-before-check-pr108455-1.c: New test.\n\t* gcc.dg/analyzer/deref-before-check-pr108455-git-pack-revindex.c:\n\tNew test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "20173f86c0439cfb9c869c5db42067828b28b32d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20173f86c0439cfb9c869c5db42067828b28b32d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "117848f425a3c0eda85517b4bdaf2ebe3bc705c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/117848f425a3c0eda85517b4bdaf2ebe3bc705c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/117848f425a3c0eda85517b4bdaf2ebe3bc705c2"}], "stats": {"total": 285, "additions": 272, "deletions": 13}, "files": [{"sha": "8f79e4b5df5133f2aa8e27a46f9b8267e8fed3e4", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -93,7 +93,9 @@ class bounded_ranges_manager;\n class pending_diagnostic;\n class pending_note;\n struct event_loc_info;\n-class state_change_event;\n+class checker_event;\n+  class state_change_event;\n+  class warning_event;\n class checker_path;\n class extrinsic_state;\n class sm_state_map;"}, {"sha": "3612df7bd1d36914cf5f00a0c0e3f87a503a5290", "filename": "gcc/analyzer/checker-event.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fchecker-event.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fchecker-event.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-event.cc?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -410,15 +410,17 @@ state_change_event::state_change_event (const supernode *node,\n \t\t\t\t\tstate_machine::state_t from,\n \t\t\t\t\tstate_machine::state_t to,\n \t\t\t\t\tconst svalue *origin,\n-\t\t\t\t\tconst program_state &dst_state)\n+\t\t\t\t\tconst program_state &dst_state,\n+\t\t\t\t\tconst exploded_node *enode)\n : checker_event (EK_STATE_CHANGE,\n \t\t event_loc_info (stmt->location,\n \t\t\t\t node->m_fun->decl,\n \t\t\t\t stack_depth)),\n   m_node (node), m_stmt (stmt), m_sm (sm),\n   m_sval (sval), m_from (from), m_to (to),\n   m_origin (origin),\n-  m_dst_state (dst_state)\n+  m_dst_state (dst_state),\n+  m_enode (enode)\n {\n }\n \n@@ -1159,7 +1161,7 @@ warning_event::get_desc (bool can_colorize) const\n       tree var = fixup_tree_for_diagnostic (m_var);\n       label_text ev_desc\n \t= m_pending_diagnostic->describe_final_event\n-\t    (evdesc::final_event (can_colorize, var, m_state));\n+\t    (evdesc::final_event (can_colorize, var, m_state, *this));\n       if (ev_desc.get ())\n \t{\n \t  if (m_sm && flag_analyzer_verbose_state_changes)"}, {"sha": "5dd25cb0775e62222d485cf5f573827b418ca72c", "filename": "gcc/analyzer/checker-event.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fchecker-event.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fchecker-event.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-event.h?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -357,7 +357,8 @@ class state_change_event : public checker_event\n \t\t      state_machine::state_t from,\n \t\t      state_machine::state_t to,\n \t\t      const svalue *origin,\n-\t\t      const program_state &dst_state);\n+\t\t      const program_state &dst_state,\n+\t\t      const exploded_node *enode);\n \n   label_text get_desc (bool can_colorize) const final override;\n   meaning get_meaning () const override;\n@@ -367,6 +368,8 @@ class state_change_event : public checker_event\n     return m_dst_state.get_current_function ();\n   }\n \n+  const exploded_node *get_exploded_node () const { return m_enode; }\n+\n   const supernode *m_node;\n   const gimple *m_stmt;\n   const state_machine &m_sm;\n@@ -375,6 +378,7 @@ class state_change_event : public checker_event\n   state_machine::state_t m_to;\n   const svalue *m_origin;\n   program_state m_dst_state;\n+  const exploded_node *m_enode;\n };\n \n /* Subclass of checker_event; parent class for subclasses that relate to\n@@ -668,17 +672,22 @@ class warning_event : public checker_event\n {\n public:\n   warning_event (const event_loc_info &loc_info,\n+\t\t const exploded_node *enode,\n \t\t const state_machine *sm,\n \t\t tree var, state_machine::state_t state)\n   : checker_event (EK_WARNING, loc_info),\n+    m_enode (enode),\n     m_sm (sm), m_var (var), m_state (state)\n   {\n   }\n \n   label_text get_desc (bool can_colorize) const final override;\n   meaning get_meaning () const override;\n \n+  const exploded_node *get_exploded_node () const { return m_enode; }\n+\n private:\n+  const exploded_node *m_enode;\n   const state_machine *m_sm;\n   tree m_var;\n   state_machine::state_t m_state;"}, {"sha": "1227d6c1151295d850ac41d8a2fbfc2f771d14fa", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -1572,7 +1572,8 @@ class state_change_event_creator : public state_change_visitor\n \t\t\t\t\tsrc_sm_val,\n \t\t\t\t\tdst_sm_val,\n \t\t\t\t\tNULL,\n-\t\t\t\t\tdst_state));\n+\t\t\t\t\tdst_state,\n+\t\t\t\t\tsrc_node));\n     return false;\n   }\n \n@@ -1616,7 +1617,8 @@ class state_change_event_creator : public state_change_visitor\n \t\t\t\t\tsrc_sm_val,\n \t\t\t\t\tdst_sm_val,\n \t\t\t\t\tdst_origin_sval,\n-\t\t\t\t\tdst_state));\n+\t\t\t\t\tdst_state,\n+\t\t\t\t\tsrc_node));\n     return false;\n   }\n \n@@ -1760,7 +1762,8 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\tvar_new_sval,\n \t\t\t\t\tfrom, to,\n \t\t\t\t\tNULL,\n-\t\t\t\t\t*m_new_state));\n+\t\t\t\t\t*m_new_state,\n+\t\t\t\t\tNULL));\n   }\n \n   void set_next_state (const gimple *stmt,\n@@ -1785,7 +1788,8 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\tsval,\n \t\t\t\t\tfrom, to,\n \t\t\t\t\tNULL,\n-\t\t\t\t\t*m_new_state));\n+\t\t\t\t\t*m_new_state,\n+\t\t\t\t\tNULL));\n   }\n \n   void warn (const supernode *, const gimple *,"}, {"sha": "c4e85bfac18312df1f1de6b459b6235adf4472df", "filename": "gcc/analyzer/infinite-recursion.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Finfinite-recursion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Finfinite-recursion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Finfinite-recursion.cc?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -182,7 +182,7 @@ class infinite_recursion_diagnostic\n   /* Customize the location where the warning_event appears, putting\n      it at the topmost entrypoint to the function.  */\n   void add_final_event (const state_machine *,\n-\t\t\tconst exploded_node *,\n+\t\t\tconst exploded_node *enode,\n \t\t\tconst gimple *,\n \t\t\ttree,\n \t\t\tstate_machine::state_t,\n@@ -195,6 +195,7 @@ class infinite_recursion_diagnostic\n \t\t\t  ()->get_start_location (),\n \t\t\tm_callee_fndecl,\n \t\t\tm_new_entry_enode->get_stack_depth ()),\n+\tenode,\n \tNULL, NULL, NULL));\n   }\n "}, {"sha": "79e6c5528ebcd8ba54db35bbad2bf701c294aced", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -232,6 +232,7 @@ pending_diagnostic::add_final_event (const state_machine *sm,\n      (event_loc_info (get_stmt_location (stmt, enode->get_function ()),\n \t\t      enode->get_function ()->decl,\n \t\t      enode->get_stack_depth ()),\n+      enode,\n       sm, var, state));\n }\n "}, {"sha": "de79890b0e07bcfa66900e76981954123935ddc9", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -131,13 +131,15 @@ struct return_of_state : public event_desc\n struct final_event : public event_desc\n {\n   final_event (bool colorize,\n-\t       tree expr, state_machine::state_t state)\n+\t       tree expr, state_machine::state_t state,\n+\t       const warning_event &event)\n   : event_desc (colorize),\n-    m_expr (expr), m_state (state)\n+    m_expr (expr), m_state (state), m_event (event)\n   {}\n \n   tree m_expr;\n   state_machine::state_t m_state;\n+  const warning_event &m_event;\n };\n \n } /* end of namespace evdesc */"}, {"sha": "9aee810f818b4c744bc97c0ec2abe6ae6ee32d13", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"analyzer/function-set.h\"\n #include \"analyzer/program-state.h\"\n+#include \"analyzer/checker-event.h\"\n+#include \"analyzer/exploded-graph.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -1490,7 +1492,9 @@ class deref_before_check : public malloc_diagnostic\n {\n public:\n   deref_before_check (const malloc_state_machine &sm, tree arg)\n-  : malloc_diagnostic (sm, arg)\n+  : malloc_diagnostic (sm, arg),\n+    m_deref_enode (NULL),\n+    m_check_enode (NULL)\n   {}\n \n   const char *get_kind () const final override { return \"deref_before_check\"; }\n@@ -1502,6 +1506,31 @@ class deref_before_check : public malloc_diagnostic\n \n   bool emit (rich_location *rich_loc) final override\n   {\n+    /* Don't emit the warning if we can't show where the deref\n+       and the check occur.  */\n+    if (!m_deref_enode)\n+      return false;\n+    if (!m_check_enode)\n+      return false;\n+    /* Only emit the warning for intraprocedural cases.  */\n+    if (m_deref_enode->get_function () != m_check_enode->get_function ())\n+      return false;\n+    if (&m_deref_enode->get_point ().get_call_string ()\n+\t!= &m_check_enode->get_point ().get_call_string ())\n+      return false;\n+\n+    /* Reject the warning if the deref's BB doesn't dominate that\n+       of the check, so that we don't warn e.g. for shared cleanup\n+       code that checks a pointer for NULL, when that code is sometimes\n+       used before a deref and sometimes after.\n+       Using the dominance code requires setting cfun.  */\n+    auto_cfun sentinel (m_deref_enode->get_function ());\n+    calculate_dominance_info (CDI_DOMINATORS);\n+    if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t m_check_enode->get_supernode ()->m_bb,\n+\t\t\t m_deref_enode->get_supernode ()->m_bb))\n+      return false;\n+\n     if (m_arg)\n       return warning_at (rich_loc, get_controlling_option (),\n \t\t\t \"check of %qE for NULL after already\"\n@@ -1520,6 +1549,7 @@ class deref_before_check : public malloc_diagnostic\n \t&& assumed_non_null_p (change.m_new_state))\n       {\n \tm_first_deref_event = change.m_event_id;\n+\tm_deref_enode = change.m_event.get_exploded_node ();\n \tif (m_arg)\n \t  return change.formatted_print (\"pointer %qE is dereferenced here\",\n \t\t\t\t\t m_arg);\n@@ -1531,6 +1561,7 @@ class deref_before_check : public malloc_diagnostic\n \n   label_text describe_final_event (const evdesc::final_event &ev) final override\n   {\n+    m_check_enode = ev.m_event.get_exploded_node ();\n     if (m_first_deref_event.known_p ())\n       {\n \tif (m_arg)\n@@ -1556,6 +1587,8 @@ class deref_before_check : public malloc_diagnostic\n \n private:\n   diagnostic_event_id_t m_first_deref_event;\n+  const exploded_node *m_deref_enode;\n+  const exploded_node *m_check_enode;\n };\n \n /* struct allocation_state : public state_machine::state.  */"}, {"sha": "1b11da5d8e15a59832c784daf8b45001bb4578ad", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-1.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-1.c?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -167,3 +167,39 @@ int test_checking_ptr_after_calling_deref (int *q)\n     return 0;\n   return v;\n }\n+\n+extern void foo ();\n+extern void bar ();\n+extern void baz ();\n+\n+int test_cfg_diamond_1 (int *p, int flag)\n+{\n+  int x;\n+  x = *p; /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+  if (flag)\n+    foo ();\n+  else\n+    bar ();\n+  if (p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    {\n+      baz ();\n+    }\n+  return x;\n+}\n+\n+int test_cfg_diamond_2 (int *p, int flag)\n+{\n+  int x = 0;\n+  if (flag)\n+    foo ();\n+  else\n+    {\n+      x = *p;\n+      bar ();\n+    }\n+  if (p) /* { dg-bogus \"check of 'p' for NULL after already dereferencing it\" } */\n+    {\n+      baz ();\n+    }\n+  return x;\n+}"}, {"sha": "d7d873edc51dbe9811a1c065126d9de1a8fc7c98", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-pr108455-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108455-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108455-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108455-1.c?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -0,0 +1,36 @@\n+extern int could_fail_1 (void);\n+extern void *could_fail_2 (int);\n+extern void cleanup (void *);\n+\n+struct header {\n+  int signature;\n+};\n+\n+int test_1 (void) {\n+  int fd, ret = 0;\n+  void *data = ((void *)0);\n+  struct header *hdr;\n+\n+  fd = could_fail_1 ();\n+\n+  if (fd < 0) {\n+    ret = -1;\n+    goto cleanup;\n+  }\n+\n+  data = could_fail_2 (fd);\n+  hdr = data;\n+\n+  if (hdr->signature != 42) {\n+    ret = -2;\n+    goto cleanup;\n+  }\n+\n+cleanup:\n+  if (ret) {\n+    if (data) /* { dg-bogus \"check of 'data' for NULL after already dereferencing it\" } */\n+      cleanup (data);\n+  }\n+\n+  return ret;\n+}"}, {"sha": "7553f86051d678d21f0ca382de245a8427085027", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-pr108455-git-pack-revindex.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108455-git-pack-revindex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108455-git-pack-revindex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr108455-git-pack-revindex.c?ref=0d6f7b1dd62e9c9dccb0b9b673f9cc3238b7ea6d", "patch": "@@ -0,0 +1,133 @@\n+/* Reduced from git-2.39.0's pack-revindex.c  */\n+\n+typedef unsigned int __uint32_t;\n+typedef unsigned long int __uintmax_t;\n+typedef long int __off_t;\n+typedef long int __off64_t;\n+typedef __SIZE_TYPE__ size_t;\n+typedef __off64_t off_t;\n+typedef __uint32_t uint32_t;\n+typedef __uintmax_t uintmax_t;\n+\n+struct stat {\n+  /* [...snip...] */\n+  __off_t st_size;\n+  /* [...snip...] */\n+};\n+\n+extern int close(int __fd);\n+extern int fstat(int __fd, struct stat *__buf)\n+  __attribute__((__nothrow__, __leaf__)) __attribute__((__nonnull__(2)));\n+extern uint32_t default_swab32(uint32_t val);\n+extern uint32_t git_bswap32(uint32_t x);\n+__attribute__((__noreturn__)) void die(const char *err, ...)\n+    __attribute__((format(printf, 1, 2)));\n+int error(const char *err, ...) __attribute__((format(printf, 1, 2)));\n+int error_errno(const char *err, ...) __attribute__((format(printf, 1, 2)));\n+static inline int const_error(void) { return -1; }\n+extern int munmap(void *__addr, size_t __len)\n+    __attribute__((__nothrow__, __leaf__));\n+extern size_t st_mult(size_t a, size_t b);\n+extern void *xmmap(void *start, size_t length, int prot, int flags, int fd,\n+\t\t   off_t offset);\n+extern size_t xsize_t(off_t len);\n+\n+extern char *gettext(const char *__msgid) __attribute__((__nothrow__, __leaf__))\n+__attribute__((__format_arg__(1)));\n+static inline __attribute__((format_arg(1))) const char *_(const char *msgid) {\n+  if (!*msgid)\n+    return \"\";\n+  return gettext(msgid);\n+}\n+\n+struct repository {\n+  /* [...snip...] */\n+  const struct git_hash_algo *hash_algo;\n+  /* [...snip...] */\n+};\n+extern struct repository *the_repository;\n+struct git_hash_algo {\n+  /* [...snip...] */\n+  size_t rawsz;\n+  /* [...snip...] */\n+};\n+\n+int git_open_cloexec(const char *name, int flags);\n+\n+struct revindex_header {\n+  uint32_t signature;\n+  uint32_t version;\n+  uint32_t hash_id;\n+};\n+\n+int load_revindex_from_disk(char *revindex_name, uint32_t num_objects,\n+                            const uint32_t **data_p, size_t *len_p) {\n+  int fd, ret = 0;\n+  struct stat st;\n+  void *data = ((void *)0);\n+  size_t revindex_size;\n+  struct revindex_header *hdr;\n+\n+  fd = git_open_cloexec(revindex_name, 00);\n+\n+  if (fd < 0) {\n+    ret = -1;\n+    goto cleanup;\n+  }\n+  if (fstat(fd, &st)) {\n+    ret = (error_errno(_(\"failed to read %s\"), revindex_name), const_error());\n+    goto cleanup;\n+  }\n+\n+  revindex_size = xsize_t(st.st_size);\n+\n+  if (revindex_size < ((12) + (2 * the_repository->hash_algo->rawsz))) {\n+    ret = (error(_(\"reverse-index file %s is too small\"), revindex_name),\n+           const_error());\n+    goto cleanup;\n+  }\n+\n+  if (revindex_size - ((12) + (2 * the_repository->hash_algo->rawsz)) !=\n+      st_mult(sizeof(uint32_t), num_objects)) {\n+    ret = (error(_(\"reverse-index file %s is corrupt\"), revindex_name),\n+           const_error());\n+    goto cleanup;\n+  }\n+\n+  data = xmmap(((void *)0), revindex_size, 0x1, 0x02, fd, 0);\n+  hdr = data;\n+\n+  if (git_bswap32(hdr->signature) != 0x52494458) {\n+    ret =\n+        (error(_(\"reverse-index file %s has unknown signature\"), revindex_name),\n+         const_error());\n+    goto cleanup;\n+  }\n+  if (git_bswap32(hdr->version) != 1) {\n+    ret = (error(_(\"reverse-index file %s has unsupported version %\"\n+                   \"u\"),\n+                 revindex_name, git_bswap32(hdr->version)),\n+           const_error());\n+    goto cleanup;\n+  }\n+  if (!(git_bswap32(hdr->hash_id) == 1 || git_bswap32(hdr->hash_id) == 2)) {\n+    ret = (error(_(\"reverse-index file %s has unsupported hash id %\"\n+                   \"u\"),\n+                 revindex_name, git_bswap32(hdr->hash_id)),\n+           const_error());\n+    goto cleanup;\n+  }\n+\n+cleanup:\n+  if (ret) {\n+    if (data) /* { dg-bogus \"check of 'data' for NULL after already dereferencing it\" } */\n+      munmap(data, revindex_size);\n+  } else {\n+    *len_p = revindex_size;\n+    *data_p = (const uint32_t *)data;\n+  }\n+\n+  if (fd >= 0)\n+    close(fd);\n+  return ret;\n+}"}]}