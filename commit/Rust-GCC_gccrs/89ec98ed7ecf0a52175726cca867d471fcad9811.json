{"sha": "89ec98ed7ecf0a52175726cca867d471fcad9811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllYzk4ZWQ3ZWNmMGE1MjE3NTcyNmNjYTg2N2Q0NzFmY2FkOTgxMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-09-09T12:29:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-09-09T12:29:08Z"}, "message": "decl.c (promote_object_alignment): New function taken from...\n\n\t* gcc-interface/decl.c (promote_object_alignment): New function taken\n\tfrom...\n\t(gnat_to_gnu_entity) <E_Variable>: ...here.  Invoke it.\n\t(gnat_to_gnu_field): If the field is Atomic or VFA, invoke it and\n\tcreate a padding type on success before doing the atomic check.\n\nFrom-SVN: r251931", "tree": {"sha": "69c068c8f67a967e86f534a73ae17a418845d075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69c068c8f67a967e86f534a73ae17a418845d075"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89ec98ed7ecf0a52175726cca867d471fcad9811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ec98ed7ecf0a52175726cca867d471fcad9811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ec98ed7ecf0a52175726cca867d471fcad9811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ec98ed7ecf0a52175726cca867d471fcad9811/comments", "author": null, "committer": null, "parents": [{"sha": "7f46ecf6dcc9047bf659932990e55759a00978c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f46ecf6dcc9047bf659932990e55759a00978c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f46ecf6dcc9047bf659932990e55759a00978c0"}], "stats": {"total": 143, "additions": 103, "deletions": 40}, "files": [{"sha": "d0d230c167a9946472e5483c3ccd8daa5090a27a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=89ec98ed7ecf0a52175726cca867d471fcad9811", "patch": "@@ -1,3 +1,11 @@\n+2017-09-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (promote_object_alignment): New function taken\n+\tfrom...\n+\t(gnat_to_gnu_entity) <E_Variable>: ...here.  Invoke it.\n+\t(gnat_to_gnu_field): If the field is Atomic or VFA, invoke it and\n+\tcreate a padding type on success before doing the atomic check.\n+\n 2017-09-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Apply the"}, {"sha": "2a31e8f917ea05a4a7726deab4b0586ceccd1380", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=89ec98ed7ecf0a52175726cca867d471fcad9811", "patch": "@@ -230,6 +230,7 @@ static vec<variant_desc> build_variant_list (tree, vec<subst_pair>,\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n+static unsigned int promote_object_alignment (tree, Entity_Id);\n static void check_ok_for_atomic_type (tree, Entity_Id, bool);\n static tree create_field_decl_from (tree, tree, tree, tree, tree,\n \t\t\t\t    vec<subst_pair>);\n@@ -856,45 +857,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    && No (Renamed_Object (gnat_entity))\n \t\t    && No (Address_Clause (gnat_entity))))\n \t    && TREE_CODE (TYPE_SIZE (gnu_type)) == INTEGER_CST)\n-\t  {\n-\t    unsigned int size_cap, align_cap;\n-\n-\t    /* No point in promoting the alignment if this doesn't prevent\n-\t       BLKmode access to the object, in particular block copy, as\n-\t       this will for example disable the NRV optimization for it.\n-\t       No point in jumping through all the hoops needed in order\n-\t       to support BIGGEST_ALIGNMENT if we don't really have to.\n-\t       So we cap to the smallest alignment that corresponds to\n-\t       a known efficient memory access pattern of the target.  */\n-\t    if (Is_Atomic_Or_VFA (gnat_entity))\n-\t      {\n-\t\tsize_cap = UINT_MAX;\n-\t\talign_cap = BIGGEST_ALIGNMENT;\n-\t      }\n-\t    else\n-\t      {\n-\t\tsize_cap = MAX_FIXED_MODE_SIZE;\n-\t\talign_cap = get_mode_alignment (ptr_mode);\n-\t      }\n-\n-\t    if (!tree_fits_uhwi_p (TYPE_SIZE (gnu_type))\n-\t\t|| compare_tree_int (TYPE_SIZE (gnu_type), size_cap) > 0)\n-\t      align = 0;\n-\t    else if (compare_tree_int (TYPE_SIZE (gnu_type), align_cap) > 0)\n-\t      align = align_cap;\n-\t    else\n-\t      align = ceil_pow2 (tree_to_uhwi (TYPE_SIZE (gnu_type)));\n-\n-\t    /* But make sure not to under-align the object.  */\n-\t    if (align <= TYPE_ALIGN (gnu_type))\n-\t      align = 0;\n-\n-\t    /* And honor the minimum valid atomic alignment, if any.  */\n-#ifdef MINIMUM_ATOMIC_ALIGNMENT\n-\t    else if (align < MINIMUM_ATOMIC_ALIGNMENT)\n-\t      align = MINIMUM_ATOMIC_ALIGNMENT;\n-#endif\n-\t  }\n+\t  align = promote_object_alignment (gnu_type, gnat_entity);\n \n \t/* If the object is set to have atomic components, find the component\n \t   type and validate it.\n@@ -6891,7 +6854,15 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     }\n \n   if (Is_Atomic_Or_VFA (gnat_field))\n-    check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n+    {\n+      const unsigned int align\n+\t= promote_object_alignment (gnu_field_type, gnat_field);\n+      if (align > 0)\n+\tgnu_field_type\n+\t  = maybe_pad_type (gnu_field_type, NULL_TREE, align, gnat_field,\n+\t\t\t    false, false, definition, true);\n+      check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n+    }\n \n   if (Present (Component_Clause (gnat_field)))\n     {\n@@ -8808,6 +8779,53 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n   return align;\n }\n \f\n+/* Promote the alignment of GNU_TYPE corresponding to GNAT_ENTITY.  Return\n+   a positive value on success or zero on failure.  */\n+\n+static unsigned int\n+promote_object_alignment (tree gnu_type, Entity_Id gnat_entity)\n+{\n+  unsigned int align, size_cap, align_cap;\n+\n+  /* No point in promoting the alignment if this doesn't prevent BLKmode access\n+     to the object, in particular block copy, as this will for example disable\n+     the NRV optimization for it.  No point in jumping through all the hoops\n+     needed in order to support BIGGEST_ALIGNMENT if we don't really have to.\n+     So we cap to the smallest alignment that corresponds to a known efficient\n+     memory access pattern, except for Atomic and Volatile_Full_Access.  */\n+  if (Is_Atomic_Or_VFA (gnat_entity))\n+    {\n+      size_cap = UINT_MAX;\n+      align_cap = BIGGEST_ALIGNMENT;\n+    }\n+  else\n+    {\n+      size_cap = MAX_FIXED_MODE_SIZE;\n+      align_cap = get_mode_alignment (ptr_mode);\n+    }\n+\n+  /* Do the promotion within the above limits.  */\n+  if (!tree_fits_uhwi_p (TYPE_SIZE (gnu_type))\n+      || compare_tree_int (TYPE_SIZE (gnu_type), size_cap) > 0)\n+    align = 0;\n+  else if (compare_tree_int (TYPE_SIZE (gnu_type), align_cap) > 0)\n+    align = align_cap;\n+  else\n+    align = ceil_pow2 (tree_to_uhwi (TYPE_SIZE (gnu_type)));\n+\n+  /* But make sure not to under-align the object.  */\n+  if (align <= TYPE_ALIGN (gnu_type))\n+    align = 0;\n+\n+   /* And honor the minimum valid atomic alignment, if any.  */\n+#ifdef MINIMUM_ATOMIC_ALIGNMENT\n+  else if (align < MINIMUM_ATOMIC_ALIGNMENT)\n+    align = MINIMUM_ATOMIC_ALIGNMENT;\n+#endif\n+\n+  return align;\n+}\n+\f\n /* Verify that TYPE is something we can implement atomically.  If not, issue\n    an error for GNAT_ENTITY.  COMPONENT_P is true if we are being called to\n    process a component type.  */"}, {"sha": "0f58fb777f3f3e972599249580bb8d0e5c1db160", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89ec98ed7ecf0a52175726cca867d471fcad9811", "patch": "@@ -1,3 +1,7 @@\n+2017-09-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/atomic3.ads: New test.\n+\n 2017-09-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/vfa.ads: Rename into..."}, {"sha": "875f2236274b15cae249b3caf95c6144f3cb18f2", "filename": "gcc/testsuite/gnat.dg/specs/atomic3.ads", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fatomic3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ec98ed7ecf0a52175726cca867d471fcad9811/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fatomic3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fatomic3.ads?ref=89ec98ed7ecf0a52175726cca867d471fcad9811", "patch": "@@ -0,0 +1,33 @@\n+-- { dg-do compile }\n+\n+package Atomic3 is\n+\n+   type Four_Bits is mod 2**4;\n+   type Fourteen_Bits is mod 2**14;\n+   type Twenty_Eight_Bits is mod 2**28;\n+\n+   type Rec1 (Mode : Boolean := True) is record\n+      Reserved : Four_Bits;\n+      case Mode is\n+         when True =>\n+           High_Part : Fourteen_Bits;\n+           Low_Part  : Fourteen_Bits;\n+         when False =>\n+           Data : Twenty_Eight_Bits;\n+      end case;\n+   end record;\n+   for Rec1 use record\n+      Reserved  at 0 range 28 .. 31;\n+      High_Part at 0 range 14 .. 27;\n+      Low_Part  at 0 range  0 .. 13;\n+      Data      at 0 range  0 .. 27;\n+   end record;\n+   for Rec1'Size use 32;\n+   pragma Unchecked_Union (Rec1);\n+\n+   type Rec2 is record\n+      A : Rec1;\n+      pragma Atomic (A);\n+   end record;\n+\n+end Atomic3;"}]}