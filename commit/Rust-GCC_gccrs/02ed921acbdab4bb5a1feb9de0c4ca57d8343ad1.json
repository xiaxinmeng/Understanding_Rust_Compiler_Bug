{"sha": "02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlZDkyMWFjYmRhYjRiYjVhMWZlYjlkZTBjNGNhNTdkODM0M2FkMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-25T20:42:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-25T20:42:20Z"}, "message": "Clean up handling of undefined types.\n\nFrom-SVN: r171528", "tree": {"sha": "9659a8b29744d26752c5e09c09987b1af5191897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9659a8b29744d26752c5e09c09987b1af5191897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/comments", "author": null, "committer": null, "parents": [{"sha": "cf3b3080558eb84d79b0dfe73683c7d2b65bb3ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3b3080558eb84d79b0dfe73683c7d2b65bb3ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf3b3080558eb84d79b0dfe73683c7d2b65bb3ac"}], "stats": {"total": 151, "additions": 60, "deletions": 91}, "files": [{"sha": "19ac03e9347e93dffdf2999d7df46b1c2da6da37", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 30, "deletions": 45, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "patch": "@@ -205,17 +205,9 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n   if (lhs_type == rhs_type)\n     return rhs_tree;\n \n-  if (lhs_type->is_error_type() || rhs_type->is_error_type())\n+  if (lhs_type->is_error() || rhs_type->is_error())\n     return error_mark_node;\n \n-  if (lhs_type->is_undefined() || rhs_type->is_undefined())\n-    {\n-      // Make sure we report the error.\n-      lhs_type->base();\n-      rhs_type->base();\n-      return error_mark_node;\n-    }\n-\n   if (rhs_tree == error_mark_node || TREE_TYPE(rhs_tree) == error_mark_node)\n     return error_mark_node;\n \n@@ -2628,7 +2620,7 @@ Const_expression::do_determine_type(const Type_context* context)\n void\n Const_expression::check_for_init_loop()\n {\n-  if (this->type_ != NULL && this->type_->is_error_type())\n+  if (this->type_ != NULL && this->type_->is_error())\n     return;\n \n   if (this->seen_)\n@@ -2647,7 +2639,7 @@ Const_expression::check_for_init_loop()\n \n   if (find_named_object.found())\n     {\n-      if (this->type_ == NULL || !this->type_->is_error_type())\n+      if (this->type_ == NULL || !this->type_->is_error())\n \t{\n \t  this->report_error(_(\"constant refers to itself\"));\n \t  this->type_ = Type::make_error_type();\n@@ -2661,7 +2653,7 @@ Const_expression::check_for_init_loop()\n void\n Const_expression::do_check_types(Gogo*)\n {\n-  if (this->type_ != NULL && this->type_->is_error_type())\n+  if (this->type_ != NULL && this->type_->is_error())\n     return;\n \n   this->check_for_init_loop();\n@@ -3311,14 +3303,8 @@ Type_conversion_expression::do_check_types(Gogo*)\n   Type* expr_type = this->expr_->type();\n   std::string reason;\n \n-  if (type->is_error_type()\n-      || type->is_undefined()\n-      || expr_type->is_error_type()\n-      || expr_type->is_undefined())\n+  if (type->is_error() || expr_type->is_error())\n     {\n-      // Make sure we emit an error for an undefined type.\n-      type->base();\n-      expr_type->base();\n       this->set_is_error();\n       return;\n     }\n@@ -4027,7 +4013,7 @@ void\n Unary_expression::do_check_types(Gogo*)\n {\n   Type* type = this->expr_->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     {\n       this->set_is_error();\n       return;\n@@ -5447,9 +5433,9 @@ Binary_expression::do_type()\n       {\n \tType* left_type = this->left_->type();\n \tType* right_type = this->right_->type();\n-\tif (left_type->is_error_type())\n+\tif (left_type->is_error())\n \t  return left_type;\n-\telse if (right_type->is_error_type())\n+\telse if (right_type->is_error())\n \t  return right_type;\n \telse if (!Type::are_compatible_for_binop(left_type, right_type))\n \t  {\n@@ -5688,7 +5674,7 @@ Binary_expression::do_check_types(Gogo*)\n \n   Type* left_type = this->left_->type();\n   Type* right_type = this->right_->type();\n-  if (left_type->is_error_type() || right_type->is_error_type())\n+  if (left_type->is_error() || right_type->is_error())\n     {\n       this->set_is_error();\n       return;\n@@ -7001,7 +6987,7 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n       if (arg == NULL)\n \treturn false;\n       Type* arg_type = arg->type();\n-      if (arg_type->is_error_type() || arg_type->is_undefined())\n+      if (arg_type->is_error())\n \treturn false;\n       if (arg_type->is_abstract())\n \treturn false;\n@@ -7354,8 +7340,7 @@ Builtin_call_expression::check_one_arg()\n       return false;\n     }\n   if (args->front()->is_error_expression()\n-      || args->front()->type()->is_error_type()\n-      || args->front()->type()->is_undefined())\n+      || args->front()->type()->is_error())\n     {\n       this->set_is_error();\n       return false;\n@@ -7389,15 +7374,15 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t      arg_type = arg_type->points_to();\n \t    if (this->code_ == BUILTIN_CAP)\n \t      {\n-\t\tif (!arg_type->is_error_type()\n+\t\tif (!arg_type->is_error()\n \t\t    && arg_type->array_type() == NULL\n \t\t    && arg_type->channel_type() == NULL)\n \t\t  this->report_error(_(\"argument must be array or slice \"\n \t\t\t\t       \"or channel\"));\n \t      }\n \t    else\n \t      {\n-\t\tif (!arg_type->is_error_type()\n+\t\tif (!arg_type->is_error()\n \t\t    && !arg_type->is_string_type()\n \t\t    && arg_type->array_type() == NULL\n \t\t    && arg_type->map_type() == NULL\n@@ -7429,7 +7414,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t\t ++p)\n \t      {\n \t\tType* type = (*p)->type();\n-\t\tif (type->is_error_type()\n+\t\tif (type->is_error()\n \t\t    || type->is_string_type()\n \t\t    || type->integer_type() != NULL\n \t\t    || type->float_type() != NULL\n@@ -7493,7 +7478,7 @@ Builtin_call_expression::do_check_types(Gogo*)\n \t  }\n \tType* arg1_type = args->front()->type();\n \tType* arg2_type = args->back()->type();\n-\tif (arg1_type->is_error_type() || arg2_type->is_error_type())\n+\tif (arg1_type->is_error() || arg2_type->is_error())\n \t  break;\n \n \tType* e1;\n@@ -7568,9 +7553,9 @@ Builtin_call_expression::do_check_types(Gogo*)\n \telse if (args->size() > 2)\n \t  this->report_error(_(\"too many arguments\"));\n \telse if (args->front()->is_error_expression()\n-\t\t || args->front()->type()->is_error_type()\n+\t\t || args->front()->type()->is_error()\n \t\t || args->back()->is_error_expression()\n-\t\t || args->back()->type()->is_error_type())\n+\t\t || args->back()->type()->is_error())\n \t  this->set_is_error();\n \telse if (!Type::are_identical(args->front()->type(),\n \t\t\t\t      args->back()->type(), true, NULL))\n@@ -8540,7 +8525,7 @@ Call_expression::do_check_types(Gogo*)\n   Function_type* fntype = this->get_function_type();\n   if (fntype == NULL)\n     {\n-      if (!this->fn_->type()->is_error_type())\n+      if (!this->fn_->type()->is_error())\n \tthis->report_error(_(\"expected function\"));\n       return;\n     }\n@@ -9060,7 +9045,7 @@ Index_expression::do_lower(Gogo*, Named_object*, int)\n   Expression* end = this->end_;\n \n   Type* type = left->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     return Expression::make_error(location);\n   else if (left->is_type_expression())\n     {\n@@ -9236,7 +9221,7 @@ Array_index_expression::do_check_types(Gogo*)\n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n     {\n-      gcc_assert(this->array_->type()->is_error_type());\n+      gcc_assert(this->array_->type()->is_error());\n       return;\n     }\n \n@@ -9318,7 +9303,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n     {\n-      gcc_assert(this->array_->type()->is_error_type());\n+      gcc_assert(this->array_->type()->is_error());\n       return error_mark_node;\n     }\n \n@@ -9979,7 +9964,7 @@ Type*\n Field_reference_expression::do_type()\n {\n   Type* type = this->expr_->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     return type;\n   Struct_type* struct_type = type->struct_type();\n   gcc_assert(struct_type != NULL);\n@@ -9992,7 +9977,7 @@ void\n Field_reference_expression::do_check_types(Gogo*)\n {\n   Type* type = this->expr_->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     return;\n   Struct_type* struct_type = type->struct_type();\n   gcc_assert(struct_type != NULL);\n@@ -11140,7 +11125,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n   Array_type* array_type = this->type()->array_type();\n   if (array_type == NULL)\n     {\n-      gcc_assert(this->type()->is_error_type());\n+      gcc_assert(this->type()->is_error());\n       return error_mark_node;\n     }\n \n@@ -11659,15 +11644,15 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function, int)\n \ttype = type->map_type()->val_type();\n       else\n \t{\n-\t  if (!type->is_error_type())\n+\t  if (!type->is_error())\n \t    error_at(this->location(),\n \t\t     (\"may only omit types within composite literals \"\n \t\t      \"of slice, array, or map type\"));\n \t  return Expression::make_error(this->location());\n \t}\n     }\n \n-  if (type->is_error_type())\n+  if (type->is_error())\n     return Expression::make_error(this->location());\n   else if (type->struct_type() != NULL)\n     return this->lower_struct(gogo, type);\n@@ -12132,7 +12117,7 @@ Type_guard_expression::do_check_types(Gogo*)\n     }\n   else if (expr_type->interface_type() == NULL)\n     {\n-      if (!expr_type->is_error_type() && !this->type_->is_error_type())\n+      if (!expr_type->is_error() && !this->type_->is_error())\n \tthis->report_error(_(\"type assertion only valid for interface types\"));\n       this->set_is_error();\n     }\n@@ -12142,7 +12127,7 @@ Type_guard_expression::do_check_types(Gogo*)\n       if (!expr_type->interface_type()->implements_interface(this->type_,\n \t\t\t\t\t\t\t     &reason))\n \t{\n-\t  if (!this->type_->is_error_type())\n+\t  if (!this->type_->is_error())\n \t    {\n \t      if (reason.empty())\n \t\tthis->report_error(_(\"impossible type assertion: \"\n@@ -12294,7 +12279,7 @@ void\n Receive_expression::do_check_types(Gogo*)\n {\n   Type* type = this->channel_->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     {\n       this->set_is_error();\n       return;\n@@ -12319,7 +12304,7 @@ Receive_expression::do_get_tree(Translate_context* context)\n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   if (channel_type == NULL)\n     {\n-      gcc_assert(this->channel_->type()->is_error_type());\n+      gcc_assert(this->channel_->type()->is_error());\n       return error_mark_node;\n     }\n   Type* element_type = channel_type->element_type();"}, {"sha": "2f52aa20b6ce0d97af8892d025a9ba0b87684514", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "patch": "@@ -914,14 +914,10 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \t    Type* type = named_constant->type();\n \t    if (type != NULL && !type->is_abstract())\n \t      {\n-\t\tif (!type->is_undefined())\n+\t\tif (!type->is_error())\n \t\t  expr_tree = fold_convert(type->get_tree(gogo), expr_tree);\n \t\telse\n-\t\t  {\n-\t\t    // Make sure we report the error.\n-\t\t    type->base();\n-\t\t    expr_tree = error_mark_node;\n-\t\t  }\n+\t\t  expr_tree = error_mark_node;\n \t      }\n \t    if (expr_tree == error_mark_node)\n \t      decl = error_mark_node;\n@@ -1047,12 +1043,8 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n       {\n \tResult_variable* result = this->u_.result_var_value;\n \tType* type = result->type();\n-\tif (type->is_error_type() || type->is_undefined())\n-\t  {\n-\t    // Force the error.\n-\t    type->base();\n-\t    decl = error_mark_node;\n-\t  }\n+\tif (type->is_error())\n+\t  decl = error_mark_node;\n \telse\n \t  {\n \t    gcc_assert(result->function() == function->func_value());"}, {"sha": "a09ffb3aaec95529a9574c598ef9d10fb69bbce9", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "patch": "@@ -1527,7 +1527,7 @@ Check_types_traverse::constant(Named_object* named_object, bool)\n       && !ctype->is_boolean_type()\n       && !ctype->is_string_type())\n     {\n-      if (!ctype->is_error_type())\n+      if (!ctype->is_error())\n \terror_at(constant->location(), \"invalid constant type\");\n       constant->set_error();\n     }"}, {"sha": "6843d6d8958653d65f1064cc1ad3440833f39bae", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "patch": "@@ -517,7 +517,7 @@ Assignment_statement::do_check_types(Gogo*)\n       && this->lhs_->map_index_expression() == NULL\n       && !this->lhs_->is_sink_expression())\n     {\n-      if (!this->lhs_->type()->is_error_type())\n+      if (!this->lhs_->type()->is_error())\n \tthis->report_error(_(\"invalid left hand side of assignment\"));\n       return;\n     }\n@@ -535,16 +535,8 @@ Assignment_statement::do_check_types(Gogo*)\n       this->set_is_error();\n     }\n \n-  if (lhs_type->is_error_type()\n-      || rhs_type->is_error_type()\n-      || lhs_type->is_undefined()\n-      || rhs_type->is_undefined())\n-    {\n-      // Make sure we get the error for an undefined type.\n-      lhs_type->base();\n-      rhs_type->base();\n-      this->set_is_error();\n-    }\n+  if (lhs_type->is_error() || rhs_type->is_error())\n+    this->set_is_error();\n }\n \n // Build a tree for an assignment statement.\n@@ -817,9 +809,9 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n       gcc_assert(prhs != this->rhs_->end());\n \n       if ((*plhs)->is_error_expression()\n-\t  || (*plhs)->type()->is_error_type()\n+\t  || (*plhs)->type()->is_error()\n \t  || (*prhs)->is_error_expression()\n-\t  || (*prhs)->type()->is_error_type())\n+\t  || (*prhs)->type()->is_error())\n \tcontinue;\n \n       if ((*plhs)->is_sink_expression())\n@@ -843,9 +835,9 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n        ++plhs, ++prhs)\n     {\n       if ((*plhs)->is_error_expression()\n-\t  || (*plhs)->type()->is_error_type()\n+\t  || (*plhs)->type()->is_error()\n \t  || (*prhs)->is_error_expression()\n-\t  || (*prhs)->type()->is_error_type())\n+\t  || (*prhs)->type()->is_error())\n \tcontinue;\n \n       if ((*plhs)->is_sink_expression())\n@@ -1363,7 +1355,7 @@ Tuple_type_guard_assignment_statement::do_lower(Gogo*, Named_object*,\n   Type* expr_type = this->expr_->type();\n   if (expr_type->interface_type() == NULL)\n     {\n-      if (!expr_type->is_error_type() && !this->type_->is_error_type())\n+      if (!expr_type->is_error() && !this->type_->is_error())\n \tthis->report_error(_(\"type assertion only valid for interface types\"));\n       return Statement::make_error_statement(loc);\n     }\n@@ -2624,16 +2616,8 @@ Return_statement::do_check_types(Gogo*)\n \t\t     i, reason.c_str());\n \t  this->set_is_error();\n \t}\n-      else if (pt->type()->is_error_type()\n-\t       || (*pe)->type()->is_error_type()\n-\t       || pt->type()->is_undefined()\n-\t       || (*pe)->type()->is_undefined())\n-\t{\n-\t  // Make sure we get the error for an undefined type.\n-\t  pt->type()->base();\n-\t  (*pe)->type()->base();\n-\t  this->set_is_error();\n-\t}\n+      else if (pt->type()->is_error() || (*pe)->type()->is_error())\n+\tthis->set_is_error();\n     }\n \n   if (pt != results->end())\n@@ -3001,7 +2985,7 @@ void\n If_statement::do_check_types(Gogo*)\n {\n   Type* type = this->cond_->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     this->set_is_error();\n   else if (!type->is_boolean_type())\n     this->report_error(_(\"expected boolean expression\"));\n@@ -3023,7 +3007,7 @@ tree\n If_statement::do_get_tree(Translate_context* context)\n {\n   gcc_assert(this->cond_->type()->is_boolean_type()\n-\t     || this->cond_->type()->is_error_type());\n+\t     || this->cond_->type()->is_error());\n   tree cond_tree = this->cond_->get_tree(context);\n   tree then_tree = this->then_block_->get_tree(context);\n   tree else_tree = (this->else_block_ == NULL\n@@ -3554,7 +3538,7 @@ Switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n \n   if (this->val_ != NULL\n       && (this->val_->is_error_expression()\n-\t  || this->val_->type()->is_error_type()))\n+\t  || this->val_->type()->is_error()))\n     return Statement::make_error_statement(loc);\n \n   if (this->val_ != NULL\n@@ -4023,7 +4007,7 @@ void\n Send_statement::do_check_types(Gogo*)\n {\n   Type* type = this->channel_->type();\n-  if (type->is_error_type())\n+  if (type->is_error())\n     {\n       this->set_is_error();\n       return;\n@@ -4739,7 +4723,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing)\n       index_type = range_type->channel_type()->element_type();\n       if (this->value_var_ != NULL)\n \t{\n-\t  if (!this->value_var_->type()->is_error_type())\n+\t  if (!this->value_var_->type()->is_error())\n \t    this->report_error(_(\"too many variables for range clause \"\n \t\t\t\t \"with channel\"));\n \t  return Statement::make_error_statement(this->location());"}, {"sha": "24f425bd8b99dba0cf4809dc33453cd6d4d273ed", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=02ed921acbdab4bb5a1feb9de0c4ca57d8343ad1", "patch": "@@ -587,11 +587,19 @@ class Type\n   has_pointer() const\n   { return this->do_has_pointer(); }\n \n-  // Return true if this is an error type.  An error type indicates a\n-  // parsing error.\n+  // Return true if this is the error type.  This returns false for a\n+  // type which is not defined, as it is called by the parser before\n+  // all types are defined.\n   bool\n   is_error_type() const;\n \n+  // Return true if this is the error type or if the type is\n+  // undefined.  If the type is undefined, this will give an error.\n+  // This should only be called after parsing is complete.\n+  bool\n+  is_error() const\n+  { return this->base()->is_error_type(); }\n+\n   // Return true if this is a void type.\n   bool\n   is_void_type() const"}]}