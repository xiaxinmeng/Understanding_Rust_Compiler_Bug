{"sha": "6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3YTlmMDE1NmE0MTI5NmJmOGJjY2Q0MjNjNWVjOGM1Y2QzMmUyYg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-07-28T18:30:18Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-07-28T18:30:18Z"}, "message": "x\n\nFrom-SVN: r14543", "tree": {"sha": "f0ea595e6b5c70b108104c4ae0c22f325f116b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0ea595e6b5c70b108104c4ae0c22f325f116b40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b/comments", "author": null, "committer": null, "parents": [{"sha": "429baef53a9d160e88ce202a09c8d735524893b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/429baef53a9d160e88ce202a09c8d735524893b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/429baef53a9d160e88ce202a09c8d735524893b4"}], "stats": {"total": 49, "additions": 21, "deletions": 28}, "files": [{"sha": "0c516a1a5975a6a2510c41d9138b46f110371a98", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b", "patch": "@@ -6260,38 +6260,21 @@ add_AT_location_description (die, attr_kind, rtl)\n      enum dwarf_attribute attr_kind;\n      register rtx rtl;\n {\n-  dw_loc_descr_ref loc_descr = NULL;\n-\n   /* Handle a special case.  If we are about to output a location descriptor\n      for a variable or parameter which has been optimized out of existence,\n-     don't do that.  Instead we output a null location descriptor value as\n-     part of the location attribute. A variable which has been optimized out\n+     don't do that.  A variable which has been optimized out\n      of existence will have a DECL_RTL value which denotes a pseudo-reg.\n      Currently, in some rare cases, variables can have DECL_RTL values which\n      look like (MEM (REG pseudo-reg#)).  These cases are due to bugs\n      elsewhere in the compiler.  We treat such cases as if the variable(s) in \n-     question had been optimized out of existence. Note that in all cases\n-     where we wish to express the fact that a variable has been optimized out \n-     of existence, we do not simply suppress the generation of the entire\n-     location attribute because the absence of a location attribute in\n-     certain kinds of DIEs is used to indicate something else entirely...\n-     i.e. that the DIE represents an object declaration, but not a\n-     definition.  So sayeth the PLSIG.  */\n-\n-  if (!is_pseudo_reg (rtl)\n-      && (GET_CODE (rtl) != MEM\n-\t  || !is_pseudo_reg (XEXP (rtl, 0))))\n-    loc_descr = loc_descriptor (eliminate_regs (rtl, 0, NULL_RTX, 0));\n+     question had been optimized out of existence.  */\n \n-#ifdef MIPS_DEBUGGING_INFO\n-  /* ??? SGI's dwarf reader is buggy, and will not accept a zero size\n-     location descriptor.  Lets just use r0 for now to represent a\n-     variable that has been optimized away.  */\n-  if (loc_descr == NULL)\n-    loc_descr = loc_descriptor (gen_rtx (REG, word_mode, 0));\n-#endif\n+  if (is_pseudo_reg (rtl)\n+      || (GET_CODE (rtl) == MEM\n+\t  && is_pseudo_reg (XEXP (rtl, 0))))\n+    return;\n \n-  add_AT_loc (die, attr_kind, loc_descr);\n+  add_AT_loc (die, attr_kind, loc_descriptor (rtl));\n }\n \n /* Attach the specialized form of location attribute used for data\n@@ -6428,9 +6411,7 @@ add_const_value_attribute (die, rtl)\n          of the (artificial) local variable either.  Rather, it represents the \n          *value* which the artificial local variable always has during its\n          lifetime.  We currently have no way to represent such quasi-constant \n-         values in Dwarf, so for now we just punt and generate an\n-         DW_AT_const_value attribute with null address.  */\n-      add_AT_addr (die, DW_AT_const_value, addr_to_string (const0_rtx));\n+         values in Dwarf, so for now we just punt and generate nothing.  */\n       break;\n \n     default:\n@@ -6566,6 +6547,12 @@ add_location_or_const_value_attribute (die, decl)\n   if (rtl == NULL_RTX)\n     return;\n \n+  rtl = eliminate_regs (rtl, 0, NULL_RTX, 0);\n+#ifdef LEAF_REG_REMAP\n+  if (leaf_function)\n+    leaf_renumber_regs_insn (DECL_RTL (decl));\n+#endif\n+\n   switch (GET_CODE (rtl))\n     {\n     case CONST_INT:"}, {"sha": "d03234ff8b0d5d95752329815dfd2a20abcd4f4a", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=6a7a9f0156a41296bf8bccd423c5ec8c5cd32e2b", "patch": "@@ -2141,7 +2141,7 @@ location_attribute (rtl)\n \n   if (! is_pseudo_reg (rtl)\n       && (GET_CODE (rtl) != MEM || ! is_pseudo_reg (XEXP (rtl, 0))))\n-    output_loc_descriptor (eliminate_regs (rtl, 0, NULL_RTX, 0));\n+    output_loc_descriptor (rtl);\n \n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n }\n@@ -2395,6 +2395,12 @@ location_or_const_value_attribute (decl)\n   if (rtl == NULL_RTX)\n     return;\n \n+  rtl = eliminate_regs (rtl, 0, NULL_RTX, 0);\n+#ifdef LEAF_REG_REMAP\n+  if (leaf_function)\n+    leaf_renumber_regs_insn (DECL_RTL (decl));\n+#endif\n+\n   switch (GET_CODE (rtl))\n     {\n     case CONST_INT:"}]}