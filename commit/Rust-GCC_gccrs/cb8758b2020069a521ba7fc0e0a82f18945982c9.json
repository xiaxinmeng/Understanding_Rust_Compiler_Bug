{"sha": "cb8758b2020069a521ba7fc0e0a82f18945982c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I4NzU4YjIwMjAwNjlhNTIxYmE3ZmMwZTBhODJmMTg5NDU5ODJjOQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-11-13T09:06:13Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-11-13T09:06:13Z"}, "message": "GCOV: remove typedef for function_t\n\n2017-11-13  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (struct function_info): Remove typedef for function_t.\n\t(struct source_info): Likewise.\n\t(source_info::get_functions_at_location): Likewise.\n\t(solve_flow_graph): Likewise.\n\t(find_exception_blocks): Likewise.\n\t(add_line_counts): Likewise.\n\t(output_intermediate_file): Likewise.\n\t(process_file): Likewise.\n\t(generate_results): Likewise.\n\t(release_structures): Likewise.\n\t(read_graph_file): Likewise.\n\t(read_count_file): Likewise.\n\t(accumulate_line_counts): Likewise.\n\t(output_lines): Likewise.\n\nFrom-SVN: r254675", "tree": {"sha": "c7fbda17b3e629bb7ce0da285702ecba69be7e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7fbda17b3e629bb7ce0da285702ecba69be7e10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb8758b2020069a521ba7fc0e0a82f18945982c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8758b2020069a521ba7fc0e0a82f18945982c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb8758b2020069a521ba7fc0e0a82f18945982c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8758b2020069a521ba7fc0e0a82f18945982c9/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4464b9772d6f2fe927a47f3a3e120ce5938fbfdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4464b9772d6f2fe927a47f3a3e120ce5938fbfdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4464b9772d6f2fe927a47f3a3e120ce5938fbfdf"}], "stats": {"total": 87, "additions": 52, "deletions": 35}, "files": [{"sha": "1e07a19c94e4ffc5e5ad71a7692cf422c601fdf3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb8758b2020069a521ba7fc0e0a82f18945982c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb8758b2020069a521ba7fc0e0a82f18945982c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb8758b2020069a521ba7fc0e0a82f18945982c9", "patch": "@@ -1,3 +1,20 @@\n+2017-11-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (struct function_info): Remove typedef for function_t.\n+\t(struct source_info): Likewise.\n+\t(source_info::get_functions_at_location): Likewise.\n+\t(solve_flow_graph): Likewise.\n+\t(find_exception_blocks): Likewise.\n+\t(add_line_counts): Likewise.\n+\t(output_intermediate_file): Likewise.\n+\t(process_file): Likewise.\n+\t(generate_results): Likewise.\n+\t(release_structures): Likewise.\n+\t(read_graph_file): Likewise.\n+\t(read_count_file): Likewise.\n+\t(accumulate_line_counts): Likewise.\n+\t(output_lines): Likewise.\n+\n 2017-11-13  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (function_info::function_info): Remove num_counts"}, {"sha": "3dac5c3122eef863aea7ccc46db48b6008f4aa91", "filename": "gcc/gcov.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb8758b2020069a521ba7fc0e0a82f18945982c9/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb8758b2020069a521ba7fc0e0a82f18945982c9/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=cb8758b2020069a521ba7fc0e0a82f18945982c9", "patch": "@@ -223,7 +223,7 @@ line_info::has_block (block_t *needle)\n \n /* Describes a single function. Contains an array of basic blocks.  */\n \n-typedef struct function_info\n+struct function_info\n {\n   function_info ();\n   ~function_info ();\n@@ -284,7 +284,7 @@ typedef struct function_info\n \n   /* Next function.  */\n   struct function_info *next;\n-} function_t;\n+};\n \n /* Function info comparer that will sort functions according to starting\n    line.  */\n@@ -325,7 +325,7 @@ struct source_info\n   /* Default constructor.  */\n   source_info ();\n \n-  vector<function_t *> get_functions_at_location (unsigned line_num) const;\n+  vector<function_info *> get_functions_at_location (unsigned line_num) const;\n \n   /* Index of the source_info in sources vector.  */\n   unsigned index;\n@@ -341,20 +341,20 @@ struct source_info\n \n   /* Functions in this source file.  These are in ascending line\n      number order.  */\n-  vector <function_t *> functions;\n+  vector <function_info *> functions;\n };\n \n source_info::source_info (): index (0), name (NULL), file_time (),\n   lines (), coverage (), functions ()\n {\n }\n \n-vector<function_t *>\n+vector<function_info *>\n source_info::get_functions_at_location (unsigned line_num) const\n {\n-  vector<function_t *> r;\n+  vector<function_info *> r;\n \n-  for (vector<function_t *>::const_iterator it = functions.begin ();\n+  for (vector<function_info *>::const_iterator it = functions.begin ();\n        it != functions.end (); it++)\n     {\n       if ((*it)->start_line == line_num && (*it)->src == index)\n@@ -400,7 +400,7 @@ class name_map\n };\n \n /* Vector of all functions.  */\n-static vector<function_t *> functions;\n+static vector<function_info *> functions;\n \n /* Vector of source files.  */\n static vector<source_info> sources;\n@@ -542,10 +542,10 @@ static char *canonicalize_name (const char *);\n static unsigned find_source (const char *);\n static void read_graph_file (void);\n static int read_count_file (void);\n-static void solve_flow_graph (function_t *);\n-static void find_exception_blocks (function_t *);\n+static void solve_flow_graph (function_info *);\n+static void find_exception_blocks (function_info *);\n static void add_branch_counts (coverage_t *, const arc_t *);\n-static void add_line_counts (coverage_t *, function_t *);\n+static void add_line_counts (coverage_t *, function_info *);\n static void executed_summary (unsigned, unsigned);\n static void function_summary (const coverage_t *, const char *);\n static const char *format_gcov (gcov_type, gcov_type, int);\n@@ -1039,7 +1039,7 @@ output_intermediate_file (FILE *gcov_file, source_info *src)\n \n   std::sort (src->functions.begin (), src->functions.end (),\n \t     function_line_start_cmp ());\n-  for (vector<function_t *>::iterator it = src->functions.begin ();\n+  for (vector<function_info *>::iterator it = src->functions.begin ();\n        it != src->functions.end (); it++)\n     {\n       /* function:<name>,<line_number>,<execution_count> */\n@@ -1050,10 +1050,10 @@ output_intermediate_file (FILE *gcov_file, source_info *src)\n \n   for (unsigned line_num = 1; line_num <= src->lines.size (); line_num++)\n     {\n-      vector<function_t *> fns = src->get_functions_at_location (line_num);\n+      vector<function_info *> fns = src->get_functions_at_location (line_num);\n \n       /* Print first group functions that begin on the line.  */\n-      for (vector<function_t *>::iterator it2 = fns.begin ();\n+      for (vector<function_info *>::iterator it2 = fns.begin ();\n \t   it2 != fns.end (); it2++)\n \t{\n \t  vector<line_info> &lines = (*it2)->lines;\n@@ -1136,18 +1136,18 @@ process_file (const char *file_name)\n \n   read_count_file ();\n \n-  hash_map<function_start_pair_hash, function_t *> fn_map;\n+  hash_map<function_start_pair_hash, function_info *> fn_map;\n \n   /* Identify group functions.  */\n-  for (vector<function_t *>::iterator it = functions.begin ();\n+  for (vector<function_info *>::iterator it = functions.begin ();\n        it != functions.end (); it++)\n     if (!(*it)->artificial)\n       {\n \tfunction_start needle;\n \tneedle.source_file_idx = (*it)->src;\n \tneedle.start_line = (*it)->start_line;\n \n-\tfunction_t **slot = fn_map.get (needle);\n+\tfunction_info **slot = fn_map.get (needle);\n \tif (slot)\n \t  {\n \t    gcc_assert ((*slot)->end_line == (*it)->end_line);\n@@ -1162,10 +1162,10 @@ process_file (const char *file_name)\n   functions.erase (remove_if (functions.begin (), functions.end (),\n \t\t\t      function_info::is_artificial), functions.end ());\n \n-  for (vector<function_t *>::iterator it = functions.begin ();\n+  for (vector<function_info *>::iterator it = functions.begin ();\n        it != functions.end (); it++)\n     {\n-      function_t *fn = *it;\n+      function_info *fn = *it;\n       unsigned src = fn->src;\n \n       if (!fn->counts.empty () || no_data_file)\n@@ -1260,10 +1260,10 @@ generate_results (const char *file_name)\n   FILE *gcov_intermediate_file = NULL;\n   char *gcov_intermediate_filename = NULL;\n \n-  for (vector<function_t *>::iterator it = functions.begin ();\n+  for (vector<function_info *>::iterator it = functions.begin ();\n        it != functions.end (); it++)\n     {\n-      function_t *fn = *it;\n+      function_info *fn = *it;\n       coverage_t coverage;\n \n       memset (&coverage, 0, sizeof (coverage));\n@@ -1352,7 +1352,7 @@ generate_results (const char *file_name)\n static void\n release_structures (void)\n {\n-  for (vector<function_t *>::iterator it = functions.begin ();\n+  for (vector<function_info *>::iterator it = functions.begin ();\n        it != functions.end (); it++)\n     delete (*it);\n \n@@ -1552,7 +1552,7 @@ read_graph_file (void)\n   bbg_stamp = gcov_read_unsigned ();\n   bbg_supports_has_unexecuted_blocks = gcov_read_unsigned ();\n \n-  function_t *fn = NULL;\n+  function_info *fn = NULL;\n   while ((tag = gcov_read_unsigned ()))\n     {\n       unsigned length = gcov_read_unsigned ();\n@@ -1574,7 +1574,7 @@ read_graph_file (void)\n \t  unsigned start_column = gcov_read_unsigned ();\n \t  unsigned end_line = gcov_read_unsigned ();\n \n-\t  fn = new function_t ();\n+\t  fn = new function_info ();\n \t  functions.push_back (fn);\n \t  fn->name = function_name;\n \t  if (flag_demangled_names)\n@@ -1730,7 +1730,7 @@ read_count_file (void)\n   unsigned ix;\n   unsigned version;\n   unsigned tag;\n-  function_t *fn = NULL;\n+  function_info *fn = NULL;\n   int error = 0;\n \n   if (!gcov_open (da_file_name, 1))\n@@ -1788,8 +1788,8 @@ read_count_file (void)\n \t  ident = gcov_read_unsigned ();\n \n \t  fn = NULL;\n-\t  for (vector<function_t *>::reverse_iterator it = functions.rbegin ();\n-\t       it != functions.rend (); it++)\n+\t  for (vector<function_info *>::reverse_iterator it\n+\t       = functions.rbegin (); it != functions.rend (); it++)\n \t    {\n \t      if ((*it)->ident == ident)\n \t\t{\n@@ -1837,7 +1837,7 @@ read_count_file (void)\n    to the blocks and the uninstrumented arcs.  */\n \n static void\n-solve_flow_graph (function_t *fn)\n+solve_flow_graph (function_info *fn)\n {\n   unsigned ix;\n   arc_t *arc;\n@@ -2100,7 +2100,7 @@ solve_flow_graph (function_t *fn)\n /* Mark all the blocks only reachable via an incoming catch.  */\n \n static void\n-find_exception_blocks (function_t *fn)\n+find_exception_blocks (function_info *fn)\n {\n   unsigned ix;\n   block_t **queue = XALLOCAVEC (block_t *, fn->blocks.size ());\n@@ -2479,7 +2479,7 @@ mangle_name (char const *base, char *ptr)\n    the appropriate basic block.  */\n \n static void\n-add_line_counts (coverage_t *coverage, function_t *fn)\n+add_line_counts (coverage_t *coverage, function_info *fn)\n {\n   bool has_any_line = false;\n   /* Scan each basic block.  */\n@@ -2611,7 +2611,7 @@ static void\n accumulate_line_counts (source_info *src)\n {\n   /* First work on group functions.  */\n-  for (vector<function_t *>::iterator it = src->functions.begin ();\n+  for (vector<function_info *>::iterator it = src->functions.begin ();\n        it != src->functions.end (); it++)\n     {\n       function_info *fn = *it;\n@@ -2635,7 +2635,7 @@ accumulate_line_counts (source_info *src)\n   /* If not using intermediate mode, sum lines of group functions and\n      add them to lines that live in a source file.  */\n   if (!flag_intermediate_format)\n-    for (vector<function_t *>::iterator it = src->functions.begin ();\n+    for (vector<function_info *>::iterator it = src->functions.begin ();\n \t it != src->functions.end (); it++)\n       {\n \tfunction_info *fn = *it;\n@@ -2939,7 +2939,7 @@ output_lines (FILE *gcov_file, const source_info *src)\n       source_lines.push_back (xstrdup (retval));\n \n   unsigned line_start_group = 0;\n-  vector<function_t *> fns;\n+  vector<function_info *> fns;\n \n   for (unsigned line_num = 1; line_num <= source_lines.size (); line_num++)\n     {\n@@ -2959,7 +2959,7 @@ output_lines (FILE *gcov_file, const source_info *src)\n \t    line_start_group = fns[0]->end_line;\n \t  else if (fns.size () == 1)\n \t    {\n-\t      function_t *fn = fns[0];\n+\t      function_info *fn = fns[0];\n \t      output_function_details (gcov_file, fn);\n \t    }\n \t}\n@@ -2979,7 +2979,7 @@ output_lines (FILE *gcov_file, const source_info *src)\n \n       if (line_start_group == line_num)\n \t{\n-\t  for (vector<function_t *>::iterator it = fns.begin ();\n+\t  for (vector<function_info *>::iterator it = fns.begin ();\n \t       it != fns.end (); it++)\n \t    {\n \t      function_info *fn = *it;"}]}