{"sha": "c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA3NDk5ZGM3NWNmODNhZTBiM2IyMGI2YzVjNmJlODYxNDJkZDI1Yg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-21T15:34:19Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-21T15:34:19Z"}, "message": "In libobjc/: 2010-12-21 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/16110\n\t* init.c (__objc_send_message_in_list): Renamed to\n\t__objc_send_load_using_method_list.  Do not take an 'op' argument.\n\tRegister the 'load' selector if needed.\n\t(__objc_send_load): Do not register the 'load' selector.  Updated\n\tcall to __objc_send_message_in_list.\n\t(__objc_create_classes_tree): Add the class of any claimed\n\tcategory that was loaded in the module to the list of classes for\n\twhich we try to execute +load.\n\t\nIn gcc/testsuite/:\n2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/16110\n\t* objc.dg/special/special.exp: Added new test.\n\t* objc.dg/special/load-category-1.m: New.\n\t* objc.dg/special/load-category-1a.m: New.\n\t* objc.dg/special/load-category-1.h: New.\n\nFrom-SVN: r168122", "tree": {"sha": "61fdf00a963f3916ab9cbcba2bb1052b6c017925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61fdf00a963f3916ab9cbcba2bb1052b6c017925"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8613835dd8af9e8f0e62b8ea0e76f9aadf60057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8613835dd8af9e8f0e62b8ea0e76f9aadf60057", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8613835dd8af9e8f0e62b8ea0e76f9aadf60057"}], "stats": {"total": 208, "additions": 184, "deletions": 24}, "files": [{"sha": "007baf400b90ee06412766dee195b60a53ecce73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -1,3 +1,11 @@\n+2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/16110\n+\t* objc.dg/special/special.exp: Added new test.\n+\t* objc.dg/special/load-category-1.m: New.\n+\t* objc.dg/special/load-category-1a.m: New.\n+\t* objc.dg/special/load-category-1.h: New.\t\n+\t\n 2010-12-21  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR middle-end/45310"}, {"sha": "7810487dfe4ab7bf610b65bbdc6ec7a4537d5843", "filename": "gcc/testsuite/objc.dg/special/load-category-1.h", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1.h?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -0,0 +1,20 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+\n+/* Test that +load works when a category is defined in a different\n+   module than the main class.  */\n+\n+/* This function should be called any time +load is invoked, so we can\n+   keep the count.  */\n+extern int increase_load_count (void);\n+\n+@interface TestClass1\n+{\n+  id isa;\n+}\n+@end\n+\n+@interface TestClass2\n+{\n+  id isa;\n+}\n+@end"}, {"sha": "bfd6373d2b8ec198ee07e9df357d2faa4169c840", "filename": "gcc/testsuite/objc.dg/special/load-category-1.m", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1.m?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -0,0 +1,40 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+#include \"load-category-1.h\"\n+\n+@implementation TestClass1\n++ initialize { return self; }\n++ load\n+{\n+  increase_load_count ();\n+}\n+@end\n+\n+@implementation TestClass2 (Category)\n++ load\n+{\n+  increase_load_count ();\n+}\n+@end\n+\n+\n+static int load_count = 0;\n+\n+int increase_load_count (void)\n+{\n+  load_count++;\n+}\n+\n+int main (void)\n+{\n+  if (load_count != 4)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "f516e7dfa3dd8e5e0d78dd3894125386ae346c36", "filename": "gcc/testsuite/objc.dg/special/load-category-1a.m", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1a.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1a.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fload-category-1a.m?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -0,0 +1,22 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, December 2010.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+#include \"load-category-1.h\"\n+\n+@implementation TestClass2\n++ initialize { return self; }\n++ load\n+{\n+  increase_load_count ();\n+}\n+@end\n+\n+@implementation TestClass1 (Category)\n++ load\n+{\n+  increase_load_count ();\n+}\n+@end"}, {"sha": "dd443808c050fc1072044cd886778e9eab44a9dd", "filename": "gcc/testsuite/objc.dg/special/special.exp", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fspecial.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fspecial.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fspecial%2Fspecial.exp?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -1,5 +1,5 @@\n # GCC Objective-C testsuite that uses the `dg.exp' driver.\n-#   Copyright (C) 1997, 2001, 2007 Free Software Foundation, Inc.\n+#   Copyright (C) 1997, 2001, 2007, 2010 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -56,6 +56,33 @@ if ![string match \"\" $lines] then {\n }\n }\n \n+#\n+# load-category-1 test\n+#\n+# This test is similar to the one above.  We compile load-category-1.m\n+# and load-category-1a.m, link them together, and execute the result.\n+set add_flags \"additional_flags=-I${srcdir}/../../libobjc\"\n+lappend add_flags \"additional_flags=-fgnu-runtime\"\n+set lines [objc_target_compile \"$srcdir/$subdir/load-category-1a.m\" \"load-category-1a.o\" object $add_flags ]\n+if ![string match \"\" $lines] then {\n+    fail \"load-category-1a.o\"\n+} else {\n+    dg-runtest \"$srcdir/$subdir/load-category-1.m\" \"load-category-1a.o\" \"-I${srcdir}/../../libobjc -fgnu-runtime\"\n+    file delete load-category-1a.o\n+}\n+\n+if [istarget \"*-*-darwin*\" ] {\n+set add_flags \"\"\n+lappend add_flags \"additional_flags=-fnext-runtime\"\n+set lines [objc_target_compile \"$srcdir/$subdir/load-category-1a.m\" \"load-category-1a.o\" object $add_flags ]\n+if ![string match \"\" $lines] then {\n+    fail \"load-category-1a.o\"\n+} else {\n+    dg-runtest \"$srcdir/$subdir/load-category-1.m\" \"load-category-1a.o\" \"-fnext-runtime\"\n+    file delete load-category-1a.o\n+}\n+}\n+\n # All done.\n dg-finish\n "}, {"sha": "3cebc7652027ed57149a10de675210ea0011d7fb", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -1,3 +1,15 @@\n+2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/16110\n+\t* init.c (__objc_send_message_in_list): Renamed to\n+\t__objc_send_load_using_method_list.  Do not take an 'op' argument.\n+\tRegister the 'load' selector if needed.\n+\t(__objc_send_load): Do not register the 'load' selector.  Updated\n+\tcall to __objc_send_message_in_list.\n+\t(__objc_create_classes_tree): Add the class of any claimed\n+\tcategory that was loaded in the module to the list of classes for\n+\twhich we try to execute +load.\n+\t\n 2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-private/common.h: When DEBUG is defined, include <stdio.h>."}, {"sha": "d4d7abb4f46cecbaedf12862d06a82c4e5be7454", "filename": "libobjc/init.c", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c07499dc75cf83ae0b3b20b6c5c6be86142dd25b/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=c07499dc75cf83ae0b3b20b6c5c6be86142dd25b", "patch": "@@ -44,8 +44,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define OBJC_VERSION 8\n #define PROTOCOL_VERSION 2\n \n-/* This list contains all modules currently loaded into the\n-   runtime.  */\n+/* This list contains modules currently loaded into the runtime and\n+   for which the +load method has not been called yet.  */\n static struct objc_list *__objc_module_list = 0; \t/* !T:MUTEX */\n \n /* This list contains all proto_list's not yet assigned class\n@@ -359,56 +359,66 @@ __objc_tree_print (objc_class_tree *tree, int level)\n #endif\n \n /* Walks on a linked list of methods in the reverse order and executes\n-   all the methods corresponding to `op' selector. Walking in the\n-   reverse order assures the +load of class is executed first and then\n-   +load of categories because of the way in which categories are\n-   added to the class methods.  */\n+   all the methods corresponding to the `+load' selector.  Walking in\n+   the reverse order assures the +load of class is executed first and\n+   then +load of categories because of the way in which categories are\n+   added to the class methods.  This function needs to be called with\n+   the objc_runtime_mutex locked.  */\n static void\n-__objc_send_message_in_list (struct objc_method_list *method_list, Class class, SEL op)\n+__objc_send_load_using_method_list (struct objc_method_list *method_list, Class class)\n {\n+  static SEL load_selector = 0;\n   int i;\n \n-  if (! method_list)\n+  if (!method_list)\n     return;\n \n-  /* First execute the `op' message in the following method lists.  */\n-  __objc_send_message_in_list (method_list->method_next, class, op);\n+  /* This needs no lock protection because we are called with the\n+     objc_runtime_mutex locked.  */\n+  if (!load_selector)\n+    load_selector = sel_registerName (\"load\");\n+\n+  /* method_list is a linked list of method lists; since we're\n+     executing in reverse order, we need to do the next list before we\n+     do this one.  */\n+  __objc_send_load_using_method_list (method_list->method_next, class);\n \n   /* Search the method list.  */\n   for (i = 0; i < method_list->method_count; i++)\n     {\n       struct objc_method *mth = &method_list->method_list[i];\n \n-      if (mth->method_name && sel_eq (mth->method_name, op)\n+      /* We are searching for +load methods that we haven't executed\n+\t yet.  */\n+      if (mth->method_name && sel_eq (mth->method_name, load_selector)\n \t  && ! objc_hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n \t{\n-\t  /* Add this method into the +load hash table.  */\n+\t  /* Add this method into the +load hash table, so we won't\n+\t     execute it again next time.  */\n \t  objc_hash_add (&__objc_load_methods,\n \t\t\t mth->method_imp,\n \t\t\t mth->method_imp);\n \t  \n \t  DEBUG_PRINTF (\"sending +load in class: %s\\n\", class->name);\n \t  \n-\t  /* The method was found and wasn't previously executed.  */\n+\t  /* Call +load.  */\n \t  (*mth->method_imp) ((id)class, mth->method_name);\n \n \t  break;\n \t}\n     }\n }\n \n+/* This function needs to be called with the objc_runtime_mutex\n+   locked.  */\n static void\n __objc_send_load (objc_class_tree *tree,\n \t\t  int level __attribute__ ((__unused__)))\n {\n-  static SEL load_sel = 0;\n   Class class = tree->class;\n   struct objc_method_list *method_list = class->class_pointer->methods;\n \n-  if (! load_sel)\n-    load_sel = sel_registerName (\"load\");\n-\n-  __objc_send_message_in_list (method_list, class, load_sel);\n+  __objc_send_load_using_method_list (method_list, class);\n }\n \n static void\n@@ -580,8 +590,8 @@ __objc_exec_class (struct objc_module *module)\n       previous_constructors = 1;\n     }\n \n-  /* Save the module pointer for later processing. (not currently\n-     used).  */\n+  /* Save the module pointer so that later we remember to call +load\n+     on all classes and categories on it.  */\n   objc_mutex_lock (__objc_runtime_mutex);\n   __objc_module_list = list_cons (module, __objc_module_list);\n \n@@ -717,14 +727,16 @@ __objc_exec_class (struct objc_module *module)\n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n+/* This function needs to be called with the objc_runtime_mutex\n+   locked.  */\n static void\n objc_send_load (void)\n {\n-  if (! __objc_module_list)\n+  if (!__objc_module_list)\n     return;\n  \n   /* Try to find out if all the classes loaded so far also have their\n-     superclasses known to the runtime. We suppose that the objects\n+     superclasses known to the runtime.  We suppose that the objects\n      that are allocated in the +load method are in general of a class\n      declared in the same module.  */\n   if (unresolved_classes)\n@@ -742,7 +754,7 @@ objc_send_load (void)\n \n       /* If we still have classes for whom we don't have yet their\n          super classes known to the runtime we don't send the +load\n-         messages.  */\n+         messages yet.  */\n       if (unresolved_classes)\n \treturn;\n     }\n@@ -791,6 +803,25 @@ __objc_create_classes_tree (struct objc_module *module)\n \n       objc_tree_insert_class (class);\n     }\n+\n+  /* Now iterate over \"claimed\" categories too (ie, categories that\n+     extend a class that has already been loaded by the runtime), and\n+     insert them in the classes tree hiearchy too.  Otherwise, if you\n+     add a category, its +load method would not be called if the class\n+     is already loaded in the runtime.  It the category is\n+     \"unclaimed\", ie, we haven't loaded the main class yet, postpone\n+     sending +load as we want to execute +load from the class before\n+     we execute the one from the category.  */\n+  for (i = 0; i < symtab->cat_def_cnt; ++i)\n+    {\n+      struct objc_category *category = symtab->defs[i + symtab->cls_def_cnt];\n+      Class class = objc_getClass (category->class_name);\n+      \n+      /* If the class for the category exists then append its\n+\t methods.  */\n+      if (class)\n+\tobjc_tree_insert_class (class);\n+    }\n }\n \n static void"}]}