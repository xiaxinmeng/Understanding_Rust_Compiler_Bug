{"sha": "76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZiNGYwZjcyNGFlMjZiZjlmN2E2ZWQzYjg4OGQ0MzYwZmQ2ZWE1ZA==", "commit": {"author": {"name": "Vladimir Yanovsky", "email": "yanov@il.ibm.com", "date": "2007-08-08T12:21:37Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-08-08T12:21:37Z"}, "message": "Remove profitability check\n\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r127293", "tree": {"sha": "34b0d824a7d6bbe2ee5d1a22423e53a0efaf2828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34b0d824a7d6bbe2ee5d1a22423e53a0efaf2828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/comments", "author": null, "committer": null, "parents": [{"sha": "473210a961853103e0155332b2df87559cc63f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473210a961853103e0155332b2df87559cc63f08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473210a961853103e0155332b2df87559cc63f08"}], "stats": {"total": 300, "additions": 98, "deletions": 202}, "files": [{"sha": "552961070094da5fcc68747f53a8f40703fce253", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "patch": "@@ -1,3 +1,17 @@\n+2007-08-08  Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres  <eres@il.ibm.com>\n+\n+\t* ddg.c (print_ddg): Add dump information.\n+\t* modulo-sched.c (print_node_sched_params): Add parameter and\n+\tverbosity.\n+\t(calculate_maxii): Remove function.\n+\t(undo_generate_reg_moves): Likewise.\n+\t(undo_permute_partial_schedule): Likewise.\n+\t(kernel_number_of_cycles): Likewise.\n+\t(MAXII_FACTOR): New definition to calculate the upper bound of II.\n+\t(sms_schedule): Use it.  Remove profitability checks.\n+\t(sms_schedule_by_order): Fix order of nodes within the cycle.\n+\n 2007-08-08  Samuel Thibault  <samuel.thibault@ens-lyon.org>\n \n \t* gcc/config/i386/gnu.h (STARTFILE_SPEC): Use gcrt0.o in profile mode, add"}, {"sha": "73e37225a255769fb26c14e5d2b2664140bb5205", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "patch": "@@ -568,6 +568,7 @@ print_ddg (FILE *file, ddg_ptr g)\n     {\n       ddg_edge_ptr e;\n \n+      fprintf (file, \"Node num: %d\\n\", g->nodes[i].cuid);\n       print_rtl_single (file, g->nodes[i].insn);\n       fprintf (file, \"OUT ARCS: \");\n       for (e = g->nodes[i].out; e; e = e->next_out)"}, {"sha": "73c4adc84b030e40c30a87e0fff69c9eb92bd5cc", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 55, "deletions": 201, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "patch": "@@ -159,7 +159,6 @@ static partial_schedule_ptr create_partial_schedule (int ii, ddg_ptr, int histor\n static void free_partial_schedule (partial_schedule_ptr);\n static void reset_partial_schedule (partial_schedule_ptr, int new_ii);\n void print_partial_schedule (partial_schedule_ptr, FILE *);\n-static int kernel_number_of_cycles (rtx first_insn, rtx last_insn);\n static ps_insn_ptr ps_add_node_check_conflicts (partial_schedule_ptr,\n \t\t\t\t\t\tddg_node_ptr node, int cycle,\n \t\t\t\t\t\tsbitmap must_precede,\n@@ -365,7 +364,7 @@ set_node_sched_params (ddg_ptr g)\n }\n \n static void\n-print_node_sched_params (FILE * file, int num_nodes)\n+print_node_sched_params (FILE *file, int num_nodes, ddg_ptr g)\n {\n   int i;\n \n@@ -377,7 +376,8 @@ print_node_sched_params (FILE * file, int num_nodes)\n       rtx reg_move = nsp->first_reg_move;\n       int j;\n \n-      fprintf (file, \"Node %d:\\n\", i);\n+      fprintf (file, \"Node = %d; INSN = %d\\n\", i,\n+\t       (INSN_UID (g->nodes[i].insn)));\n       fprintf (file, \" asap = %d:\\n\", nsp->asap);\n       fprintf (file, \" time = %d:\\n\", nsp->time);\n       fprintf (file, \" nreg_moves = %d:\\n\", nsp->nreg_moves);\n@@ -390,29 +390,6 @@ print_node_sched_params (FILE * file, int num_nodes)\n     }\n }\n \n-/* Calculate an upper bound for II.  SMS should not schedule the loop if it\n-   requires more cycles than this bound.  Currently set to the sum of the\n-   longest latency edge for each node.  Reset based on experiments.  */\n-static int\n-calculate_maxii (ddg_ptr g)\n-{\n-  int i;\n-  int maxii = 0;\n-\n-  for (i = 0; i < g->num_nodes; i++)\n-    {\n-      ddg_node_ptr u = &g->nodes[i];\n-      ddg_edge_ptr e;\n-      int max_edge_latency = 0;\n-\n-      for (e = u->out; e; e = e->next_out)\n-\tmax_edge_latency = MAX (max_edge_latency, e->latency);\n-\n-      maxii += max_edge_latency;\n-    }\n-  return maxii;\n-}\n-\n /*\n    Breaking intra-loop register anti-dependences:\n    Each intra-loop register anti-dependence implies a cross-iteration true\n@@ -533,40 +510,6 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n   return reg_move_replaces;\n }\n \n-/* We call this when we want to undo the SMS schedule for a given loop.\n-   One of the things that we do is to delete the register moves generated\n-   for the sake of SMS; this function deletes the register move instructions\n-   recorded in the undo buffer.  */\n-static void\n-undo_generate_reg_moves (partial_schedule_ptr ps,\n-\t\t\t struct undo_replace_buff_elem *reg_move_replaces)\n-{\n-  int i,j;\n-\n-  for (i = 0; i < ps->g->num_nodes; i++)\n-    {\n-      ddg_node_ptr u = &ps->g->nodes[i];\n-      rtx prev;\n-      rtx crr = SCHED_FIRST_REG_MOVE (u);\n-\n-      for (j = 0; j < SCHED_NREG_MOVES (u); j++)\n-\t{\n-\t  prev = PREV_INSN (crr);\n-\t  delete_insn (crr);\n-\t  crr = prev;\n-\t}\n-      SCHED_FIRST_REG_MOVE (u) = NULL_RTX;\n-    }\n-\n-  while (reg_move_replaces)\n-    {\n-      struct undo_replace_buff_elem *rep = reg_move_replaces;\n-\n-      reg_move_replaces = reg_move_replaces->next;\n-      replace_rtx (rep->insn, rep->new_reg, rep->orig_reg);\n-    }\n-}\n-\n /* Free memory allocated for the undo buffer.  */\n static void\n free_undo_replace_buff (struct undo_replace_buff_elem *reg_move_replaces)\n@@ -638,28 +581,6 @@ permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n \t\t\t    PREV_INSN (last));\n }\n \n-/* As part of undoing SMS we return to the original ordering of the\n-   instructions inside the loop kernel.  Given the partial schedule PS, this\n-   function returns the ordering of the instruction according to their CUID\n-   in the DDG (PS->G), which is the original order of the instruction before\n-   performing SMS.  */\n-static void\n-undo_permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n-{\n-  int i;\n-\n-  for (i = 0 ; i < ps->g->num_nodes; i++)\n-    if (last == ps->g->nodes[i].insn\n-\t|| last == ps->g->nodes[i].first_note)\n-      break;\n-    else if (PREV_INSN (last) != ps->g->nodes[i].insn)\n-      reorder_insns_nobb (ps->g->nodes[i].first_note, ps->g->nodes[i].insn,\n-\t\t\t  PREV_INSN (last));\n-}\n-\n-/* Used to generate the prologue & epilogue.  Duplicate the subset of\n-   nodes whose stages are between FROM_STAGE and TO_STAGE (inclusive\n-   of both), together with a prefix/suffix of their reg_moves.  */\n static void\n duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \t\t\t   int to_stage, int for_prolog)\n@@ -869,6 +790,9 @@ canon_loop (struct loop *loop)\n    version may be entered.  Just a guess.  */\n #define PROB_SMS_ENOUGH_ITERATIONS 80\n \n+/* Used to calculate the upper bound of ii.  */\n+#define MAXII_FACTOR 2\n+\n /* Main entry point, perform SMS scheduling on the loops of the function\n    that consist of single basic blocks.  */\n static void\n@@ -1097,7 +1021,7 @@ sms_schedule (void)\n       mii = 1; /* Need to pass some estimate of mii.  */\n       rec_mii = sms_order_nodes (g, mii, node_order);\n       mii = MAX (res_MII (g), rec_mii);\n-      maxii = (calculate_maxii (g) * SMS_MAX_II_FACTOR) / 100;\n+      maxii = MAXII_FACTOR * mii;\n \n       if (dump_file)\n \tfprintf (dump_file, \"SMS iis %d %d %d (rec_mii, mii, maxii)\\n\",\n@@ -1131,8 +1055,6 @@ sms_schedule (void)\n \t}\n       else\n \t{\n-\t  int orig_cycles = kernel_number_of_cycles (BB_HEAD (g->bb), BB_END (g->bb));\n-\t  int new_cycles;\n \t  struct undo_replace_buff_elem *reg_move_replaces;\n \n \t  if (dump_file)\n@@ -1154,68 +1076,46 @@ sms_schedule (void)\n \t  normalize_sched_times (ps);\n \t  rotate_partial_schedule (ps, PS_MIN_CYCLE (ps));\n \t  set_columns_for_ps (ps);\n-\n-\t  /* Generate the kernel just to be able to measure its cycles.  */\n+\t  \n+\t  canon_loop (loop);\n+\n+          /* case the BCT count is not known , Do loop-versioning */\n+\t  if (count_reg && ! count_init)\n+            {\n+\t      rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n+\t  \t\t\t\t     GEN_INT(stage_count));\n+\t      unsigned prob = (PROB_SMS_ENOUGH_ITERATIONS\n+\t\t\t       * REG_BR_PROB_BASE) / 100;\n+\n+\t      loop_version (loop, comp_rtx, &condition_bb,\n+\t  \t\t    prob, prob, REG_BR_PROB_BASE - prob,\n+\t\t\t    true);\n+\t     }\n+\n+\t  /* Set new iteration count of loop kernel.  */\n+          if (count_reg && count_init)\n+\t    SET_SRC (single_set (count_init)) = GEN_INT (loop_count\n+\t\t\t\t\t\t     - stage_count + 1);\n+\n+\t  /* Now apply the scheduled kernel to the RTL of the loop.  */\n \t  permute_partial_schedule (ps, g->closing_branch->first_note);\n-\t  reg_move_replaces = generate_reg_moves (ps, false);\n \n-\t  /* Get the number of cycles the new kernel expect to execute in.  */\n-\t  new_cycles = kernel_number_of_cycles (BB_HEAD (g->bb), BB_END (g->bb));\n+          /* Mark this loop as software pipelined so the later\n+\t     scheduling passes doesn't touch it.  */\n+\t  if (! flag_resched_modulo_sched)\n+\t    g->bb->flags |= BB_DISABLE_SCHEDULE;\n+\t  /* The life-info is not valid any more.  */\n+\t  df_set_bb_dirty (g->bb);\n \n-\t  /* Get back to the original loop so we can do loop versioning.  */\n-\t  undo_permute_partial_schedule (ps, g->closing_branch->first_note);\n-\t  if (reg_move_replaces)\n-\t    undo_generate_reg_moves (ps, reg_move_replaces);\n-\n-\t  if ( new_cycles >= orig_cycles)\n-\t    {\n-\t      /* SMS is not profitable so undo the permutation and reg move generation\n-\t         and return the kernel to its original state.  */\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Undoing SMS because it is not profitable.\\n\");\n-\n-\t    }\n+\t  reg_move_replaces = generate_reg_moves (ps, true);\n+\t  if (dump_file)\n+\t    print_node_sched_params (dump_file, g->num_nodes, g);\n+\t  /* Generate prolog and epilog.  */\n+\t  if (count_reg && !count_init)\n+\t    generate_prolog_epilog (ps, loop, count_reg);\n \t  else\n-\t    {\n-\t      canon_loop (loop);\n-\n-              /* case the BCT count is not known , Do loop-versioning */\n-\t      if (count_reg && ! count_init)\n-\t\t{\n-\t\t  rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n-\t\t\t\t\t\t GEN_INT(stage_count));\n-\t\t  unsigned prob = (PROB_SMS_ENOUGH_ITERATIONS\n-\t\t\t\t   * REG_BR_PROB_BASE) / 100;\n-\n-\t\t  loop_version (loop, comp_rtx, &condition_bb,\n-\t\t\t\tprob, prob, REG_BR_PROB_BASE - prob,\n-\t\t\t\ttrue);\n-\t\t}\n-\n-\t      /* Set new iteration count of loop kernel.  */\n-              if (count_reg && count_init)\n-\t\tSET_SRC (single_set (count_init)) = GEN_INT (loop_count\n-\t\t\t\t\t\t\t     - stage_count + 1);\n-\n-\t      /* Now apply the scheduled kernel to the RTL of the loop.  */\n-\t      permute_partial_schedule (ps, g->closing_branch->first_note);\n-\n-              /* Mark this loop as software pipelined so the later\n-\t      scheduling passes doesn't touch it.  */\n-\t      if (! flag_resched_modulo_sched)\n-\t\tg->bb->flags |= BB_DISABLE_SCHEDULE;\n-\t      /* The life-info is not valid any more.  */\n-\t      df_set_bb_dirty (g->bb);\n-\n-\t      reg_move_replaces = generate_reg_moves (ps, true);\n-\t      if (dump_file)\n-\t\tprint_node_sched_params (dump_file, g->num_nodes);\n-\t      /* Generate prolog and epilog.  */\n-\t      if (count_reg && !count_init)\n-\t\tgenerate_prolog_epilog (ps, loop, count_reg);\n-\t      else\n-\t \tgenerate_prolog_epilog (ps, loop, NULL_RTX);\n-\t    }\n+\t    generate_prolog_epilog (ps, loop, NULL_RTX);\n+\t    \n \t  free_undo_replace_buff (reg_move_replaces);\n \t}\n \n@@ -1529,17 +1429,21 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \t     of nodes within the cycle.  */\n           sbitmap_zero (must_precede);\n           sbitmap_zero (must_follow);\n-      \t  for (e = u_node->in; e != 0; e = e->next_in)\n+          /* TODO: We can add an insn to the must_precede or must_follow\n+             bitmaps only if it has tight dependence to U and they\n+             both scheduled in the same row.  The current check is less\n+             conservative and content with the fact that both U and the\n+             insn are scheduled in the same row.  */\n+          for (e = u_node->in; e != 0; e = e->next_in)\n             if (TEST_BIT (sched_nodes, e->src->cuid)\n-\t        && e->latency == (ii * e->distance)\n-\t\t&& start == SCHED_TIME (e->src))\n-             SET_BIT (must_precede, e->src->cuid);\n+                && (SMODULO (SCHED_TIME (e->src), ii) == SMODULO (start, ii)))\n+              SET_BIT (must_precede, e->src->cuid);\n \n-\t  for (e = u_node->out; e != 0; e = e->next_out)\n+          for (e = u_node->out; e != 0; e = e->next_out)\n             if (TEST_BIT (sched_nodes, e->dest->cuid)\n-\t        && e->latency == (ii * e->distance)\n-\t\t&& end == SCHED_TIME (e->dest))\n-             SET_BIT (must_follow, e->dest->cuid);\n+                && (SMODULO (SCHED_TIME (e->dest), ii) ==\n+                    SMODULO ((end - step), ii)))\n+              SET_BIT (must_follow, e->dest->cuid);\n \n \t  success = 0;\n \t  if ((step > 0 && start < end) ||  (step < 0 && start > end))\n@@ -2259,57 +2163,7 @@ advance_one_cycle (void)\n \t\t      targetm.sched.dfa_post_cycle_insn ());\n }\n \n-/* Given the kernel of a loop (from FIRST_INSN to LAST_INSN), finds\n-   the number of cycles according to DFA that the kernel fits in,\n-   we use this to check if we done well with SMS after we add\n-   register moves.  In some cases register moves overhead makes\n-   it even worse than the original loop.  We want SMS to be performed\n-   when it gives less cycles after register moves are added.  */\n-static int\n-kernel_number_of_cycles (rtx first_insn, rtx last_insn)\n-{\n-  int cycles = 0;\n-  rtx insn;\n-  int can_issue_more = issue_rate;\n-\n-  state_reset (curr_state);\n-\n-  for (insn = first_insn;\n-       insn != NULL_RTX && insn != last_insn;\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (! INSN_P (insn) || GET_CODE (PATTERN (insn)) == USE)\n-\tcontinue;\n \n-      /* Check if there is room for the current insn.  */\n-      if (!can_issue_more || state_dead_lock_p (curr_state))\n-\t{\n-\t  cycles ++;\n-\t  advance_one_cycle ();\n-\t  can_issue_more = issue_rate;\n-\t}\n-\n-\t/* Update the DFA state and return with failure if the DFA found\n-\t   recource conflicts.  */\n-      if (state_transition (curr_state, insn) >= 0)\n-\t{\n-\t  cycles ++;\n-\t  advance_one_cycle ();\n-\t  can_issue_more = issue_rate;\n-\t}\n-\n-      if (targetm.sched.variable_issue)\n-\tcan_issue_more =\n-\t  targetm.sched.variable_issue (sched_dump, sched_verbose,\n-\t\t\t\t\tinsn, can_issue_more);\n-      /* A naked CLOBBER or USE generates no instruction, so don't\n-\t let them consume issue slots.  */\n-      else if (GET_CODE (PATTERN (insn)) != USE\n-\t       && GET_CODE (PATTERN (insn)) != CLOBBER)\n-\tcan_issue_more--;\n-    }\n-  return cycles;\n-}\n \n /* Checks if PS has resource conflicts according to DFA, starting from\n    FROM cycle to TO cycle; returns true if there are conflicts and false"}, {"sha": "851229a6bcf4024dea89b8830bd9ac8f6edd14df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "patch": "@@ -1,3 +1,9 @@\n+2007-08-08  Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres  <eres@il.ibm.com>\n+ \n+\t* gfortran.dg/sms-1.f90: Add comment.\n+\t* gfortran.dg/sms-2.f90: New.\n+\n 2007-08-07  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/instrument-1.c: New test."}, {"sha": "754cb8caeb1480e5695696fb053821bd2ab8f9d6", "filename": "gcc/testsuite/gfortran.dg/sms-1.f90", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsms-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsms-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsms-1.f90?ref=76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "patch": "@@ -1,5 +1,7 @@\n ! { dg-do run }\n-! { dg-options \"-O2 -fmodulo-sched\" } \n+! { dg-options \"-O2 -fmodulo-sched\" }\n+! This testcase related to INC instruction which is\n+! currently not supported in SMS. \n program main\n   integer (kind = 8) :: i, l8, u8, step8\n   integer (kind = 4) :: l4, step4"}, {"sha": "80ab9bf49157269743b14f02885082a86cc0c404", "filename": "gcc/testsuite/gfortran.dg/sms-2.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsms-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d/gcc%2Ftestsuite%2Fgfortran.dg%2Fsms-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsms-2.f90?ref=76b4f0f724ae26bf9f7a6ed3b888d4360fd6ea5d", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! { dg-options \"-O2 -fmodulo-sched\" }\n+! This testcase related to wrong order within a cycle fix.\n+!\n+program foo \n+  real, dimension (5, 5, 5, 5) :: a\n+\n+  a (:, :, :,  :)  = 4\n+  a (:, 2, :, 4) = 10\n+  a (:, 2, :, 1) = 0\n+\n+  forall (i = 1:5, i == 3) \n+     a(i, i, i, i) = -5\n+   end forall\n+\n+  if (sum (a) .ne. 2541.0) call abort ()\n+end\n+\n+"}]}