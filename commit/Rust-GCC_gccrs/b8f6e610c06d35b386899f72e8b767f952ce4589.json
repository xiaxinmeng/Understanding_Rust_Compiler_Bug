{"sha": "b8f6e610c06d35b386899f72e8b767f952ce4589", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmNmU2MTBjMDZkMzViMzg2ODk5ZjcyZThiNzY3Zjk1MmNlNDU4OQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-08-27T21:41:15Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-08-27T21:41:15Z"}, "message": "ipa-prop.h (ipa_pass_through_data): New field type_preserved.\n\n2013-08-27  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_pass_through_data): New field type_preserved.\n\t(ipa_ancestor_jf_data): Likewise.\n\t(ipa_get_jf_pass_through_agg_preserved): Fix comment typo.\n\t(ipa_get_jf_pass_through_type_preserved): New function.\n\t(ipa_get_jf_ancestor_agg_preserved): Fix comment typo.\n\t(ipa_get_jf_ancestor_type_preserved): New function.\n\t* ipa-cp.c (ipa_get_jf_pass_through_result): Honor type_preserved\n\tflag.\n\t(ipa_get_jf_ancestor_result): Likewise.\n\t(propagate_vals_accross_pass_through): Use\n\tipa_get_jf_pass_through_result to do all the value mappings.\n\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Dump the\n\ttype_preserved flag.\n\t(ipa_set_jf_cst_copy): New function.\n\t(ipa_set_jf_simple_pass_through): Set the type_preserved flag.\n\t(ipa_set_jf_arith_pass_through): Likewise.\n\t(ipa_set_ancestor_jf): Likewise.\n\t(compute_complex_assign_jump_func): Set type_preserved instead of\n\tpunting.\n\t(ipa_compute_jump_functions_for_edge): Likewise.\n\t(combine_known_type_and_ancestor_jfs): Honor type_preserved.\n\t(update_jump_functions_after_inlining): Update type_preserved.\n\tExplicitely create jump functions when combining one with\n\tpass_through.\n\t(ipa_write_jump_function): Stream the type_preserved flags.\n\t(ipa_read_jump_function): Likewise.\n\nFrom-SVN: r202036", "tree": {"sha": "a2d5071d970254c4acebb2d4c7039bfa0e43d18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2d5071d970254c4acebb2d4c7039bfa0e43d18a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8f6e610c06d35b386899f72e8b767f952ce4589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f6e610c06d35b386899f72e8b767f952ce4589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8f6e610c06d35b386899f72e8b767f952ce4589", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f6e610c06d35b386899f72e8b767f952ce4589/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74bf76ed78a14069969e94233f05e7840806aed8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74bf76ed78a14069969e94233f05e7840806aed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74bf76ed78a14069969e94233f05e7840806aed8"}], "stats": {"total": 259, "additions": 203, "deletions": 56}, "files": [{"sha": "0903dc43ffdd987cd3bb810ac42abd7be32b27c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8f6e610c06d35b386899f72e8b767f952ce4589", "patch": "@@ -1,3 +1,32 @@\n+2013-08-27  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (ipa_pass_through_data): New field type_preserved.\n+\t(ipa_ancestor_jf_data): Likewise.\n+\t(ipa_get_jf_pass_through_agg_preserved): Fix comment typo.\n+\t(ipa_get_jf_pass_through_type_preserved): New function.\n+\t(ipa_get_jf_ancestor_agg_preserved): Fix comment typo.\n+\t(ipa_get_jf_ancestor_type_preserved): New function.\n+\t* ipa-cp.c (ipa_get_jf_pass_through_result): Honor type_preserved\n+\tflag.\n+\t(ipa_get_jf_ancestor_result): Likewise.\n+\t(propagate_vals_accross_pass_through): Use\n+\tipa_get_jf_pass_through_result to do all the value mappings.\n+\t* ipa-prop.c (ipa_print_node_jump_functions_for_edge): Dump the\n+\ttype_preserved flag.\n+\t(ipa_set_jf_cst_copy): New function.\n+\t(ipa_set_jf_simple_pass_through): Set the type_preserved flag.\n+\t(ipa_set_jf_arith_pass_through): Likewise.\n+\t(ipa_set_ancestor_jf): Likewise.\n+\t(compute_complex_assign_jump_func): Set type_preserved instead of\n+\tpunting.\n+\t(ipa_compute_jump_functions_for_edge): Likewise.\n+\t(combine_known_type_and_ancestor_jfs): Honor type_preserved.\n+\t(update_jump_functions_after_inlining): Update type_preserved.\n+\tExplicitely create jump functions when combining one with\n+\tpass_through.\n+\t(ipa_write_jump_function): Stream the type_preserved flags.\n+\t(ipa_read_jump_function): Likewise.\n+\n 2013-08-27  Jakub Jelinek  <jakub@redhat.com>\n \t    Aldy Hernandez  <aldyh@redhat.com>\n "}, {"sha": "78dee15aad8e1aefd9de6ff323d16e0ab57c324f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b8f6e610c06d35b386899f72e8b767f952ce4589", "patch": "@@ -745,17 +745,26 @@ initialize_node_lattices (struct cgraph_node *node)\n \n /* Return the result of a (possibly arithmetic) pass through jump function\n    JFUNC on the constant value INPUT.  Return NULL_TREE if that cannot be\n-   determined or itself is considered an interprocedural invariant.  */\n+   determined or be considered an interprocedural invariant.  */\n \n static tree\n ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n {\n   tree restype, res;\n \n+  if (TREE_CODE (input) == TREE_BINFO)\n+    {\n+      if (ipa_get_jf_pass_through_type_preserved (jfunc))\n+\t{\n+\t  gcc_checking_assert (ipa_get_jf_pass_through_operation (jfunc)\n+\t\t\t       == NOP_EXPR);\n+\t  return input;\n+\t}\n+      return NULL_TREE;\n+    }\n+\n   if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n     return input;\n-  else if (TREE_CODE (input) == TREE_BINFO)\n-    return NULL_TREE;\n \n   gcc_checking_assert (is_gimple_ip_invariant (input));\n   if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n@@ -779,9 +788,13 @@ static tree\n ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n {\n   if (TREE_CODE (input) == TREE_BINFO)\n-    return get_binfo_at_offset (input,\n-\t\t\t\tipa_get_jf_ancestor_offset (jfunc),\n-\t\t\t\tipa_get_jf_ancestor_type (jfunc));\n+    {\n+      if (!ipa_get_jf_ancestor_type_preserved (jfunc))\n+\treturn NULL;\n+      return get_binfo_at_offset (input,\n+\t\t\t\t  ipa_get_jf_ancestor_offset (jfunc),\n+\t\t\t\t  ipa_get_jf_ancestor_type (jfunc));\n+    }\n   else if (TREE_CODE (input) == ADDR_EXPR)\n     {\n       tree t = TREE_OPERAND (input, 0);\n@@ -1013,26 +1026,16 @@ propagate_vals_accross_pass_through (struct cgraph_edge *cs,\n   struct ipcp_value *src_val;\n   bool ret = false;\n \n-  if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n-    for (src_val = src_lat->values; src_val; src_val = src_val->next)\n-      ret |= add_scalar_value_to_lattice (dest_lat, src_val->value, cs,\n-\t\t\t\t\t  src_val, src_idx);\n   /* Do not create new values when propagating within an SCC because if there\n      are arithmetic functions with circular dependencies, there is infinite\n      number of them and we would just make lattices bottom.  */\n-  else if (edge_within_scc (cs))\n+  if ((ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n+      and edge_within_scc (cs))\n     ret = set_lattice_contains_variable (dest_lat);\n   else\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n       {\n-\ttree cstval = src_val->value;\n-\n-\tif (TREE_CODE (cstval) == TREE_BINFO)\n-\t  {\n-\t    ret |= set_lattice_contains_variable (dest_lat);\n-\t    continue;\n-\t  }\n-\tcstval = ipa_get_jf_pass_through_result (jfunc, cstval);\n+\ttree cstval = ipa_get_jf_pass_through_result (jfunc, src_val->value);\n \n \tif (cstval)\n \t  ret |= add_scalar_value_to_lattice (dest_lat, cstval, cs, src_val,"}, {"sha": "ca133134d509e7e00469b5aa05b58fbb0811fa9e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 121, "deletions": 33, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=b8f6e610c06d35b386899f72e8b767f952ce4589", "patch": "@@ -257,6 +257,8 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t    }\n \t  if (jump_func->value.pass_through.agg_preserved)\n \t    fprintf (f, \", agg_preserved\");\n+\t  if (jump_func->value.pass_through.type_preserved)\n+\t    fprintf (f, \", type_preserved\");\n \t  fprintf (f, \"\\n\");\n \t}\n       else if (type == IPA_JF_ANCESTOR)\n@@ -268,6 +270,8 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t  print_generic_expr (f, jump_func->value.ancestor.type, 0);\n \t  if (jump_func->value.ancestor.agg_preserved)\n \t    fprintf (f, \", agg_preserved\");\n+\t  if (jump_func->value.ancestor.type_preserved)\n+\t    fprintf (f, \", type_preserved\");\n \t  fprintf (f, \"\\n\");\n \t}\n \n@@ -373,6 +377,19 @@ ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n   jfunc->value.known_type.component_type = component_type;\n }\n \n+/* Set JFUNC to be a copy of another jmp (to be used by jump function\n+   combination code).  The two functions will share their rdesc.  */\n+\n+static void\n+ipa_set_jf_cst_copy (struct ipa_jump_func *dst,\n+\t\t     struct ipa_jump_func *src)\n+\n+{\n+  gcc_checking_assert (src->type == IPA_JF_CONST);\n+  dst->type = IPA_JF_CONST;\n+  dst->value.constant = src->value.constant;\n+}\n+\n /* Set JFUNC to be a constant jmp function.  */\n \n static void\n@@ -406,13 +423,14 @@ ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant,\n /* Set JFUNC to be a simple pass-through jump function.  */\n static void\n ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n-\t\t\t\tbool agg_preserved)\n+\t\t\t\tbool agg_preserved, bool type_preserved)\n {\n   jfunc->type = IPA_JF_PASS_THROUGH;\n   jfunc->value.pass_through.operand = NULL_TREE;\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = NOP_EXPR;\n   jfunc->value.pass_through.agg_preserved = agg_preserved;\n+  jfunc->value.pass_through.type_preserved = type_preserved;\n }\n \n /* Set JFUNC to be an arithmetic pass through jump function.  */\n@@ -426,19 +444,22 @@ ipa_set_jf_arith_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = operation;\n   jfunc->value.pass_through.agg_preserved = false;\n+  jfunc->value.pass_through.type_preserved = false;\n }\n \n /* Set JFUNC to be an ancestor jump function.  */\n \n static void\n ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n-\t\t     tree type, int formal_id, bool agg_preserved)\n+\t\t     tree type, int formal_id, bool agg_preserved,\n+\t\t     bool type_preserved)\n {\n   jfunc->type = IPA_JF_ANCESTOR;\n   jfunc->value.ancestor.formal_id = formal_id;\n   jfunc->value.ancestor.offset = offset;\n   jfunc->value.ancestor.type = type;\n   jfunc->value.ancestor.agg_preserved = agg_preserved;\n+  jfunc->value.ancestor.type_preserved = type_preserved;\n }\n \n /* Extract the acual BINFO being described by JFUNC which must be a known type\n@@ -1005,12 +1026,13 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t  ipa_set_jf_arith_pass_through (jfunc, index, op2,\n \t\t\t\t\t gimple_assign_rhs_code (stmt));\n \t}\n-      else if (gimple_assign_single_p (stmt)\n-\t       && !detect_type_change_ssa (tc_ssa, call, jfunc))\n+      else if (gimple_assign_single_p (stmt))\n \t{\n \t  bool agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n \t\t\t\t\t\t     call, tc_ssa);\n-\t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n+\t  bool type_p = !detect_type_change_ssa (tc_ssa, call, jfunc);\n+\t  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n+\t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p, type_p);\n \t}\n       return;\n     }\n@@ -1033,13 +1055,16 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n       || offset < 0)\n     return;\n \n-  /* Dynamic types are changed only in constructors and destructors and  */\n+  /* Dynamic types are changed in constructors and destructors.  */\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n-  if (index >= 0\n-      && !detect_type_change (op1, base, call, jfunc, offset))\n-    ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (op1), index,\n-\t\t\t parm_ref_data_pass_through_p (&parms_ainfo[index],\n-\t\t\t\t\t\t       call, ssa));\n+  if (index >= 0)\n+    {\n+      bool type_p = !detect_type_change (op1, base, call, jfunc, offset);\n+      if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n+\tipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (op1), index,\n+\t\t\t     parm_ref_data_pass_through_p (&parms_ainfo[index],\n+\t\t\t\t\t\t\t   call, ssa), type_p);\n+    }\n }\n \n /* Extract the base, offset and MEM_REF expression from a statement ASSIGN if\n@@ -1163,10 +1188,11 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \treturn;\n     }\n \n-  if (!detect_type_change (obj, expr, call, jfunc, offset))\n+  bool type_p = !detect_type_change (obj, expr, call, jfunc, offset);\n+  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n     ipa_set_ancestor_jf (jfunc, offset, TREE_TYPE (obj), index,\n \t\t\t parm_ref_data_pass_through_p (&parms_ainfo[index],\n-\t\t\t\t\t\t       call, parm));\n+\t\t\t\t\t\t       call, parm), type_p);\n }\n \n /* Given OP which is passed as an actual argument to a called function,\n@@ -1507,7 +1533,7 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t     for cycle.  */\n \t  if (parm_preserved_before_stmt_p (&parms_ainfo[index], call, arg))\n \t    {\n-\t      ipa_set_jf_simple_pass_through (jfunc, index, false);\n+\t      ipa_set_jf_simple_pass_through (jfunc, index, false, false);\n \t      continue;\n \t    }\n \t}\n@@ -1516,13 +1542,14 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n \t    {\n \t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n-\t      if (index >= 0\n-\t\t  && !detect_type_change_ssa (arg, call, jfunc))\n+\t      if (index >= 0)\n \t\t{\n-\t\t  bool agg_p;\n+\t\t  bool agg_p, type_p;\n \t\t  agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n \t\t\t\t\t\t\tcall, arg);\n-\t\t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n+\t\t  type_p = !detect_type_change_ssa (arg, call, jfunc);\n+\t\t  if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n+\t\t    ipa_set_jf_simple_pass_through (jfunc, index, agg_p,\t\t\t\t\t\t    type_p);\n \t\t}\n \t    }\n \t  else\n@@ -2130,6 +2157,12 @@ combine_known_type_and_ancestor_jfs (struct ipa_jump_func *src,\n   HOST_WIDE_INT combined_offset;\n   tree combined_type;\n \n+  if (!ipa_get_jf_ancestor_type_preserved (dst))\n+    {\n+      dst->type = IPA_JF_UNKNOWN;\n+      return;\n+    }\n+\n   combined_offset = ipa_get_jf_known_type_offset (src)\n     + ipa_get_jf_ancestor_offset (dst);\n   combined_type = ipa_get_jf_ancestor_type (dst);\n@@ -2196,13 +2229,17 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n \t      dst->value.ancestor.agg_preserved &=\n \t\tsrc->value.pass_through.agg_preserved;\n+\t      dst->value.ancestor.type_preserved &=\n+\t\tsrc->value.pass_through.type_preserved;\n \t    }\n \t  else if (src->type == IPA_JF_ANCESTOR)\n \t    {\n \t      dst->value.ancestor.formal_id = src->value.ancestor.formal_id;\n \t      dst->value.ancestor.offset += src->value.ancestor.offset;\n \t      dst->value.ancestor.agg_preserved &=\n \t\tsrc->value.ancestor.agg_preserved;\n+\t      dst->value.ancestor.type_preserved &=\n+\t\tsrc->value.ancestor.type_preserved;\n \t    }\n \t  else\n \t    dst->type = IPA_JF_UNKNOWN;\n@@ -2216,16 +2253,69 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      && (dst->value.pass_through.formal_id\n \t\t  < ipa_get_cs_argument_count (top)))\n \t    {\n-\t      bool agg_p;\n \t      int dst_fid = dst->value.pass_through.formal_id;\n \t      src = ipa_get_ith_jump_func (top, dst_fid);\n-\t      agg_p = dst->value.pass_through.agg_preserved;\n+\t      bool dst_agg_p = ipa_get_jf_pass_through_agg_preserved (dst);\n \n-\t      dst->type = src->type;\n-\t      dst->value = src->value;\n+\t      switch (src->type)\n+\t\t{\n+\t\tcase IPA_JF_UNKNOWN:\n+\t\t  dst->type = IPA_JF_UNKNOWN;\n+\t\t  break;\n+\t\tcase IPA_JF_KNOWN_TYPE:\n+\t\t  ipa_set_jf_known_type (dst,\n+\t\t\t\t\t ipa_get_jf_known_type_offset (src),\n+\t\t\t\t\t ipa_get_jf_known_type_base_type (src),\n+\t\t\t\t\t ipa_get_jf_known_type_base_type (src));\n+\t\t  break;\n+\t\tcase IPA_JF_CONST:\n+\t\t  ipa_set_jf_cst_copy (dst, src);\n+\t\t  break;\n+\n+\t\tcase IPA_JF_PASS_THROUGH:\n+\t\t  {\n+\t\t    int formal_id = ipa_get_jf_pass_through_formal_id (src);\n+\t\t    enum tree_code operation;\n+\t\t    operation = ipa_get_jf_pass_through_operation (src);\n+\n+\t\t    if (operation == NOP_EXPR)\n+\t\t      {\n+\t\t\tbool agg_p, type_p;\n+\t\t\tagg_p = dst_agg_p\n+\t\t\t  && ipa_get_jf_pass_through_agg_preserved (src);\n+\t\t\ttype_p = ipa_get_jf_pass_through_type_preserved (src)\n+\t\t\t  && ipa_get_jf_pass_through_type_preserved (dst);\n+\t\t\tipa_set_jf_simple_pass_through (dst, formal_id,\n+\t\t\t\t\t\t\tagg_p, type_p);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\ttree operand = ipa_get_jf_pass_through_operand (src);\n+\t\t\tipa_set_jf_arith_pass_through (dst, formal_id, operand,\n+\t\t\t\t\t\t       operation);\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\t\tcase IPA_JF_ANCESTOR:\n+\t\t  {\n+\t\t    bool agg_p, type_p;\n+\t\t    agg_p = dst_agg_p\n+\t\t      && ipa_get_jf_ancestor_agg_preserved (src);\n+\t\t    type_p = ipa_get_jf_ancestor_type_preserved (src)\n+\t\t      && ipa_get_jf_pass_through_type_preserved (dst);\n+\t\t    ipa_set_ancestor_jf (dst,\n+\t\t\t\t\t ipa_get_jf_ancestor_offset (src),\n+\t\t\t\t\t ipa_get_jf_ancestor_type (src),\n+\t\t\t\t\t ipa_get_jf_ancestor_formal_id (src),\n+\t\t\t\t\t agg_p, type_p);\n+\t\t    break;\n+\t\t  }\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \n \t      if (src->agg.items\n-\t\t  && (agg_p || !src->agg.by_ref))\n+\t\t  && (dst_agg_p || !src->agg.by_ref))\n \t\t{\n \t\t  /* Currently we do not produce clobber aggregate jump\n \t\t     functions, replace with merging when we do.  */\n@@ -2234,14 +2324,6 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t  dst->agg.by_ref = src->agg.by_ref;\n \t\t  dst->agg.items = vec_safe_copy (src->agg.items);\n \t\t}\n-\n-\t      if (!agg_p)\n-\t\t{\n-\t\t  if (dst->type == IPA_JF_PASS_THROUGH)\n-\t\t    dst->value.pass_through.agg_preserved = false;\n-\t\t  else if (dst->type == IPA_JF_ANCESTOR)\n-\t\t    dst->value.ancestor.agg_preserved = false;\n-\t\t}\n \t    }\n \t  else\n \t    dst->type = IPA_JF_UNKNOWN;\n@@ -3703,6 +3785,7 @@ ipa_write_jump_function (struct output_block *ob,\n \t  streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n+\t  bp_pack_value (&bp, jump_func->value.pass_through.type_preserved, 1);\n \t  streamer_write_bitpack (&bp);\n \t}\n       else\n@@ -3717,6 +3800,7 @@ ipa_write_jump_function (struct output_block *ob,\n       streamer_write_uhwi (ob, jump_func->value.ancestor.formal_id);\n       bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, jump_func->value.ancestor.agg_preserved, 1);\n+      bp_pack_value (&bp, jump_func->value.ancestor.type_preserved, 1);\n       streamer_write_bitpack (&bp);\n       break;\n     }\n@@ -3774,7 +3858,9 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t  int formal_id =  streamer_read_uhwi (ib);\n \t  struct bitpack_d bp = streamer_read_bitpack (ib);\n \t  bool agg_preserved = bp_unpack_value (&bp, 1);\n-\t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved);\n+\t  bool type_preserved = bp_unpack_value (&bp, 1);\n+\t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved,\n+\t\t\t\t\t  type_preserved);\n \t}\n       else\n \t{\n@@ -3791,8 +3877,10 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \tint formal_id = streamer_read_uhwi (ib);\n \tstruct bitpack_d bp = streamer_read_bitpack (ib);\n \tbool agg_preserved = bp_unpack_value (&bp, 1);\n+\tbool type_preserved = bp_unpack_value (&bp, 1);\n \n-\tipa_set_ancestor_jf (jump_func, offset, type, formal_id, agg_preserved);\n+\tipa_set_ancestor_jf (jump_func, offset, type, formal_id, agg_preserved,\n+\t\t\t     type_preserved);\n \tbreak;\n       }\n     }"}, {"sha": "48634d2e172a33f845e770270c4bd33b5a158782", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f6e610c06d35b386899f72e8b767f952ce4589/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=b8f6e610c06d35b386899f72e8b767f952ce4589", "patch": "@@ -117,7 +117,12 @@ struct GTY(()) ipa_pass_through_data\n      aggregate part of the jump function (see description of\n      ipa_agg_jump_function).  The flag is used only when the operation is\n      NOP_EXPR.  */\n-  bool agg_preserved;\n+  unsigned agg_preserved : 1;\n+\n+  /* When set to true, we guarantee that, if there is a C++ object pointed to\n+     by this object, it does not undergo dynamic type change in the course of\n+     functions decribed by this jump function.  */\n+  unsigned type_preserved : 1;\n };\n \n /* Structure holding data required to describe an ancestor pass-through\n@@ -132,7 +137,11 @@ struct GTY(()) ipa_ancestor_jf_data\n   /* Number of the caller's formal parameter being passed.  */\n   int formal_id;\n   /* Flag with the same meaning like agg_preserve in ipa_pass_through_data.  */\n-  bool agg_preserved;\n+  unsigned agg_preserved : 1;\n+  /* When set to true, we guarantee that, if there is a C++ object pointed to\n+     by this object, it does not undergo dynamic type change in the course of\n+     functions decribed by this jump function.  */\n+  unsigned type_preserved : 1;\n };\n \n /* An element in an aggegate part of a jump function describing a known value\n@@ -264,7 +273,7 @@ ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)\n   return jfunc->value.pass_through.operation;\n }\n \n-/* Return the agg_preserved flag of a pass through jump functin JFUNC.  */\n+/* Return the agg_preserved flag of a pass through jump function JFUNC.  */\n \n static inline bool\n ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n@@ -273,6 +282,15 @@ ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.pass_through.agg_preserved;\n }\n \n+/* Return the type_preserved flag of a pass through jump function JFUNC.  */\n+\n+static inline bool\n+ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  return jfunc->value.pass_through.type_preserved;\n+}\n+\n /* Return the offset of an ancestor jump function JFUNC.  */\n \n static inline HOST_WIDE_INT\n@@ -301,7 +319,7 @@ ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.formal_id;\n }\n \n-/* Return the agg_preserved flag of an ancestor jump functin JFUNC.  */\n+/* Return the agg_preserved flag of an ancestor jump function JFUNC.  */\n \n static inline bool\n ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n@@ -310,6 +328,15 @@ ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.agg_preserved;\n }\n \n+/* Return the type_preserved flag of an ancestor jump function JFUNC.  */\n+\n+static inline bool\n+ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n+  return jfunc->value.ancestor.type_preserved;\n+}\n+\n /* Summary describing a single formal parameter.  */\n \n struct ipa_param_descriptor"}]}