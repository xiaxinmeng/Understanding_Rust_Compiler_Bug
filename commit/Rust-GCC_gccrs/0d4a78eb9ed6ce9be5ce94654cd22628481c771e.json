{"sha": "0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ0YTc4ZWI5ZWQ2Y2U5YmU1Y2U5NDY1NGNkMjI2Mjg0ODFjNzcxZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-04-05T11:26:48Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-04-05T11:26:48Z"}, "message": "bfin-modes.def: New file.\n\n\t* config/bfin/bfin-modes.def: New file.\n\t* config/bfin/bfin-protos.h: New file.\n\t* config/bfin/bfin.c: New file.\n\t* config/bfin/bfin.h: New file.\n\t* config/bfin/bfin.md: New file.\n\t* config/bfin/bfin.opt: New file.\n\t* config/bfin/crti.s: New file.\n\t* config/bfin/crtn.s: New file.\n\t* config/bfin/elf.h: New file.\n\t* config/bfin/lib1funcs.asm: New file.\n\t* config/bfin/predicates.md: New file.\n\t* config/bfin/t-bfin: New file.\n\t* config/bfin/t-bfin-elf: New file.\n\t* doc/extend.texi (exception_handler, kspisusp, nesting, nmi_handler):\n\tDocument new attributes.\n\t(interrupt, interrupt_handler, saveall): Update documentation for\n\tthese attributes.\n\t* doc/install.texi (Specific): Add entry for the Blackfin.\n\t* doc/invoke.texi (Blackfin Options): New section.\n\t* doc/md.texi (Blackfin family): New section to document constraints.\n\t* config.gcc: Add bfin*-* and bfin*-elf configurations.\n\nFrom-SVN: r97622", "tree": {"sha": "0c1dfb753f5d1ba94f529adf00d67f3ba6f44cdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c1dfb753f5d1ba94f529adf00d67f3ba6f44cdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/comments", "author": null, "committer": null, "parents": [{"sha": "fcec20a7581be7e4a1aa34a4ce0f0316ba03d690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcec20a7581be7e4a1aa34a4ce0f0316ba03d690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcec20a7581be7e4a1aa34a4ce0f0316ba03d690"}], "stats": {"total": 6611, "additions": 6602, "deletions": 9}, "files": [{"sha": "3296cd4e404dbbf03d07a2948e169b408823fce2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -1,3 +1,27 @@\n+2005-04-05  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin-modes.def: New file.\n+\t* config/bfin/bfin-protos.h: New file.\n+\t* config/bfin/bfin.c: New file.\n+\t* config/bfin/bfin.h: New file.\n+\t* config/bfin/bfin.md: New file.\n+\t* config/bfin/bfin.opt: New file.\n+\t* config/bfin/crti.s: New file.\n+\t* config/bfin/crtn.s: New file.\n+\t* config/bfin/elf.h: New file.\n+\t* config/bfin/lib1funcs.asm: New file.\n+\t* config/bfin/predicates.md: New file.\n+\t* config/bfin/t-bfin: New file.\n+\t* config/bfin/t-bfin-elf: New file.\n+\t* doc/extend.texi (exception_handler, kspisusp, nesting, nmi_handler):\n+\tDocument new attributes.\n+\t(interrupt, interrupt_handler, saveall): Update documentation for\n+\tthese attributes.\n+\t* doc/install.texi (Specific): Add entry for the Blackfin.\n+\t* doc/invoke.texi (Blackfin Options): New section.\n+\t* doc/md.texi (Blackfin family): New section to document constraints.\n+\t* config.gcc: Add bfin*-* and bfin*-elf configurations.\n+\n 2005-04-05  Olivier Hainque  <hainque@adacore.com>\n \t\n \t* config/mips/iris6.h (DWARF_FRAME_RETURN_COLUMN): Redefine to"}, {"sha": "4468992146b6ecb7221d6a805fbe40cf633d3eaf", "filename": "gcc/config.gcc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -248,6 +248,9 @@ arm*-*-*)\n \tcpu_type=arm\n \textra_headers=\"mmintrin.h\"\n \t;;\n+bfin*-*)\n+\tcpu_type=bfin\n+\t;;\n ep9312*-*-*)\n \tcpu_type=arm\n \t;;\n@@ -727,6 +730,16 @@ avr-*-*)\n \ttm_file=\"avr/avr.h dbxelf.h\"\n \tuse_fixproto=yes\n \t;;\n+bfin*-elf*)\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h bfin/elf.h\"\n+        tmake_file=bfin/t-bfin-elf\n+        use_collect2=no\n+        ;;  \n+bfin*-*)\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h bfin/elf.h\"\n+        tmake_file=bfin/t-bfin\n+        use_collect2=no\n+        ;;  \n c4x-*-rtems* | tic4x-*-rtems*)\n \ttmake_file=\"c4x/t-c4x t-rtems c4x/t-rtems\"\n \ttm_file=\"c4x/c4x.h c4x/rtems.h rtems.h\""}, {"sha": "18ed3156941e66925a313892c801a6d2b66cb453", "filename": "gcc/config/bfin/bfin-modes.def", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-modes.def?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,25 @@\n+/* Definitions of target machine for GNU compiler, for Blackfin.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Analog Devices.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+/* PDImode for the 40 bit accumulators.  */\n+PARTIAL_INT_MODE (DI);\n+\n+VECTOR_MODE (INT, HI, 2); /* V2HI */"}, {"sha": "e75046aeb19e6cf7db02487e36ab820a7a65b73b", "filename": "gcc/config/bfin/bfin-protos.h", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,88 @@\n+/* Prototypes for Blackfin functions used in the md file & elsewhere.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* Function prototypes that cannot exist in bfin.h due to dependency\n+   complications.  */\n+#ifndef GCC_BFIN_PROTOS_H\n+#define GCC_BFIN_PROTOS_H\n+\n+#define Mmode enum machine_mode\n+\n+extern rtx function_arg (CUMULATIVE_ARGS *, Mmode, tree, int);\n+extern void function_arg_advance (CUMULATIVE_ARGS *, Mmode, tree, int);\n+extern bool function_arg_regno_p (int);\n+\n+extern const char *output_load_immediate (rtx *);\n+extern const char *output_casesi_internal (rtx *);\n+extern char *bfin_asm_long (void);\n+extern char *bfin_asm_short (void);\n+extern int log2constp (unsigned HOST_WIDE_INT);\n+\n+extern rtx legitimize_address (rtx, rtx, Mmode);\n+extern int hard_regno_mode_ok (int, Mmode);\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\t  \n+extern int bfin_frame_pointer_required (void);\n+extern HOST_WIDE_INT bfin_initial_elimination_offset (int, int);\n+\n+extern int effective_address_32bit_p (rtx, Mmode);\n+extern int symbolic_reference_mentioned_p (rtx);\n+extern rtx bfin_gen_compare (rtx, Mmode);\n+extern void expand_move (rtx *, Mmode);\n+extern void bfin_expand_call (rtx, rtx, rtx, int);\n+extern bool bfin_expand_strmov (rtx, rtx, rtx, rtx);\n+\n+extern void conditional_register_usage (void);\n+extern int bfin_register_move_cost (enum machine_mode, enum reg_class,\n+\t\t\t\t    enum reg_class);\n+extern int bfin_memory_move_cost (enum machine_mode, enum reg_class, int in);\n+extern enum reg_class secondary_input_reload_class (enum reg_class, Mmode,\n+\t\t\t\t\t\t    rtx);\n+extern enum reg_class secondary_output_reload_class (enum reg_class, Mmode,\n+\t\t\t\t\t\t     rtx);\n+extern char *section_asm_op_1 (SECT_ENUM_T);\n+extern char *section_asm_op (SECT_ENUM_T);\n+extern void override_options (void);\n+extern void print_operand (FILE *,  rtx, char);\n+extern void print_address_operand (FILE *, rtx);\n+extern void split_di (rtx [], int, rtx [], rtx []);\n+extern int split_load_immediate (rtx []);\n+extern rtx legitimize_pic_address (rtx, rtx);\n+extern void emit_pic_move (rtx *, Mmode);\n+extern void override_options (void);\n+extern void asm_conditional_branch (rtx, rtx *, int, int);\n+extern rtx bfin_gen_compare (rtx, Mmode);\n+\n+extern int bfin_return_in_memory (tree);\n+extern void initialize_trampoline (rtx, rtx, rtx);\n+extern bool bfin_legitimate_address_p (Mmode, rtx, int);\n+extern rtx bfin_va_arg (tree, tree);\n+\n+extern void bfin_expand_prologue (void);\n+extern void bfin_expand_epilogue (int, int);\n+extern int push_multiple_operation (rtx, Mmode);\n+extern int pop_multiple_operation (rtx, Mmode);\n+extern void output_push_multiple (rtx, rtx *);\n+extern void output_pop_multiple (rtx, rtx *);\n+extern int bfin_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern rtx bfin_return_addr_rtx (int);\n+#undef  Mmode \n+\n+#endif\n+"}, {"sha": "be3beb362f2f154cb601318326387fbeb7d0bf97", "filename": "gcc/config/bfin/bfin.c", "status": "added", "additions": 2728, "deletions": 0, "changes": 2728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,2728 @@\n+/* The Blackfin code generation auxilary output file.\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+   Contributed by Analog Devices.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"input.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"expr.h\"\n+#include \"toplev.h\"\n+#include \"recog.h\"\n+#include \"ggc.h\"\n+#include \"integrate.h\"\n+#include \"bfin-protos.h\"\n+#include \"tm-preds.h\"\n+#include \"gt-bfin.h\"\n+\n+/* Test and compare insns in bfin.md store the information needed to\n+   generate branch and scc insns here.  */\n+rtx bfin_compare_op0, bfin_compare_op1;\n+\n+/* RTX for condition code flag register and RETS register */\n+extern GTY(()) rtx bfin_cc_rtx;\n+extern GTY(()) rtx bfin_rets_rtx;\n+rtx bfin_cc_rtx, bfin_rets_rtx;\n+\n+int max_arg_registers = 0;\n+\n+/* Arrays used when emitting register names.  */\n+const char *short_reg_names[]  =  SHORT_REGISTER_NAMES;\n+const char *high_reg_names[]   =  HIGH_REGISTER_NAMES;\n+const char *dregs_pair_names[] =  DREGS_PAIR_NAMES;\n+const char *byte_reg_names[]   =  BYTE_REGISTER_NAMES;\n+\n+static int arg_regs[] = FUNCTION_ARG_REGISTERS;\n+\n+const char *bfin_library_id_string;\n+\n+static void\n+bfin_globalize_label (FILE *stream, const char *name)\n+{\n+  fputs (\".global \", stream);\n+  assemble_name (stream, name);\n+  fputc (';',stream);\n+  fputc ('\\n',stream);\n+}\n+\n+static void \n+output_file_start (void) \n+{\n+  FILE *file = asm_out_file;\n+  int i;\n+\n+  fprintf (file, \".file \\\"%s\\\";\\n\", input_filename);\n+  \n+  for (i = 0; arg_regs[i] >= 0; i++)\n+    ;\n+  max_arg_registers = i;\t/* how many arg reg used  */\n+}\n+\n+/* Called early in the compilation to conditionally modify\n+   fixed_regs/call_used_regs.  */\n+\n+void \n+conditional_register_usage (void)\n+{\n+  /* initialize condition code flag register rtx */\n+  bfin_cc_rtx = gen_rtx_REG (BImode, REG_CC);\n+  bfin_rets_rtx = gen_rtx_REG (Pmode, REG_RETS);\n+}\n+\n+/* Examine machine-dependent attributes of function type FUNTYPE and return its\n+   type.  See the definition of E_FUNKIND.  */\n+\n+static e_funkind funkind (tree funtype)\n+{\n+  tree attrs = TYPE_ATTRIBUTES (funtype);\n+  if (lookup_attribute (\"interrupt_handler\", attrs))\n+    return INTERRUPT_HANDLER;\n+  else if (lookup_attribute (\"exception_handler\", attrs))\n+    return EXCPT_HANDLER;\n+  else if (lookup_attribute (\"nmi_handler\", attrs))\n+    return NMI_HANDLER;\n+  else\n+    return SUBROUTINE;\n+}\n+\f\n+/* Stack frame layout. */\n+\n+/* Compute the number of DREGS to save with a push_multiple operation.\n+   This could include registers that aren't modified in the function,\n+   since push_multiple only takes a range of registers.  */\n+\n+static int\n+n_dregs_to_save (void)\n+{\n+  unsigned i;\n+\n+  for (i = REG_R0; i <= REG_R7; i++)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+\treturn REG_R7 - i + 1;\n+\n+      if (current_function_calls_eh_return)\n+\t{\n+\t  unsigned j;\n+\t  for (j = 0; ; j++)\n+\t    {\n+\t      unsigned test = EH_RETURN_DATA_REGNO (j);\n+\t      if (test == INVALID_REGNUM)\n+\t\tbreak;\n+\t      if (test == i)\n+\t\treturn REG_R7 - i + 1;\n+\t    }\n+\t}\n+\n+    }\n+  return 0;\n+}\n+\n+/* Like n_dregs_to_save, but compute number of PREGS to save.  */\n+\n+static int\n+n_pregs_to_save (void)\n+{\n+  unsigned i;\n+\n+  for (i = REG_P0; i <= REG_P5; i++)\n+    if ((regs_ever_live[i] && ! call_used_regs[i])\n+\t|| (i == PIC_OFFSET_TABLE_REGNUM\n+\t    && (current_function_uses_pic_offset_table\n+\t\t|| (TARGET_ID_SHARED_LIBRARY && ! current_function_is_leaf))))\n+      return REG_P5 - i + 1;\n+  return 0;\n+}\n+\n+/* Determine if we are going to save the frame pointer in the prologue.  */\n+\n+static bool\n+must_save_fp_p (void)\n+{\n+  return (frame_pointer_needed || regs_ever_live[REG_FP]);\n+}\n+\n+static bool\n+stack_frame_needed_p (void)\n+{\n+  /* EH return puts a new return address into the frame using an\n+     address relative to the frame pointer.  */\n+  if (current_function_calls_eh_return)\n+    return true;\n+  return frame_pointer_needed;\n+}\n+\n+/* Emit code to save registers in the prologue.  SAVEALL is nonzero if we\n+   must save all registers; this is used for interrupt handlers.\n+   SPREG contains (reg:SI REG_SP).  */\n+\n+static void\n+expand_prologue_reg_save (rtx spreg, int saveall)\n+{\n+  int ndregs = saveall ? 8 : n_dregs_to_save ();\n+  int npregs = saveall ? 6 : n_pregs_to_save ();\n+  int dregno = REG_R7 + 1 - ndregs;\n+  int pregno = REG_P5 + 1 - npregs;\n+  int total = ndregs + npregs;\n+  int i;\n+  rtx pat, insn, val;\n+\n+  if (total == 0)\n+    return;\n+\n+  val = GEN_INT (-total * 4);\n+  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total + 2));\n+  XVECEXP (pat, 0, 0) = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, val),\n+\t\t\t\t\tUNSPEC_PUSH_MULTIPLE);\n+  XVECEXP (pat, 0, total + 1) = gen_rtx_SET (VOIDmode, spreg,\n+\t\t\t\t\t     gen_rtx_PLUS (Pmode, spreg,\n+\t\t\t\t\t\t\t   val));\n+  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, total + 1)) = 1;\n+  for (i = 0; i < total; i++)\n+    {\n+      rtx memref = gen_rtx_MEM (word_mode,\n+\t\t\t\tgen_rtx_PLUS (Pmode, spreg,\n+\t\t\t\t\t      GEN_INT (- i * 4 - 4)));\n+      rtx subpat;\n+      if (ndregs > 0)\n+\t{\n+\t  subpat = gen_rtx_SET (VOIDmode, memref, gen_rtx_REG (word_mode,\n+\t\t\t\t\t\t\t       dregno++));\n+\t  ndregs--;\n+\t}\n+      else\n+\t{\n+\t  subpat = gen_rtx_SET (VOIDmode, memref, gen_rtx_REG (word_mode,\n+\t\t\t\t\t\t\t       pregno++));\n+\t  npregs++;\n+\t}\n+      XVECEXP (pat, 0, i + 1) = subpat;\n+      RTX_FRAME_RELATED_P (subpat) = 1;\n+    }\n+  insn = emit_insn (pat);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+/* Emit code to restore registers in the epilogue.  SAVEALL is nonzero if we\n+   must save all registers; this is used for interrupt handlers.\n+   SPREG contains (reg:SI REG_SP).  */\n+\n+static void\n+expand_epilogue_reg_restore (rtx spreg, int saveall)\n+{\n+  int ndregs = saveall ? 8 : n_dregs_to_save ();\n+  int npregs = saveall ? 6 : n_pregs_to_save ();\n+  int total = ndregs + npregs;\n+  int i, regno;\n+  rtx pat, insn;\n+\n+  if (total == 0)\n+    return;\n+\n+  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total + 1));\n+  XVECEXP (pat, 0, 0) = gen_rtx_SET (VOIDmode, spreg,\n+\t\t\t\t     gen_rtx_PLUS (Pmode, spreg,\n+\t\t\t\t\t\t   GEN_INT (total * 4)));\n+\n+  if (npregs > 0)\n+    regno = REG_P5 + 1;\n+  else\n+    regno = REG_R7 + 1;\n+\n+  for (i = 0; i < total; i++)\n+    {\n+      rtx addr = (i > 0\n+\t\t  ? gen_rtx_PLUS (Pmode, spreg, GEN_INT (i * 4))\n+\t\t  : spreg);\n+      rtx memref = gen_rtx_MEM (word_mode, addr);\n+\n+      regno--;\n+      XVECEXP (pat, 0, i + 1)\n+\t= gen_rtx_SET (VOIDmode, gen_rtx_REG (word_mode, regno), memref);\n+\n+      if (npregs > 0)\n+\t{\n+\t  if (--npregs == 0)\n+\t    regno = REG_R7 + 1;\n+\t}\n+    }\n+\n+  insn = emit_insn (pat);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments.\n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  \n+\n+   Blackfin specific :\n+   - VDSP C compiler manual (our ABI) says that a variable args function\n+     should save the R0, R1 and R2 registers in the stack.\n+   - The caller will always leave space on the stack for the\n+     arguments that are passed in registers, so we dont have\n+     to leave any extra space.\n+   - now, the vastart pointer can access all arguments from the stack.  */\n+\n+static void\n+setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\ttree type ATTRIBUTE_UNUSED, int *pretend_size,\n+\t\t\tint no_rtl)\n+{\n+  rtx mem;\n+  int i;\n+\n+  if (no_rtl)\n+    return;\n+\n+  /* The move for named arguments will be generated automatically by the\n+     compiler.  We need to generate the move rtx for the unnamed arguments\n+     if they are in the first 3 words.  We assume atleast 1 named argument\n+     exists, so we never generate [ARGP] = R0 here.  */\n+\n+  for (i = cum->words + 1; i < max_arg_registers; i++)\n+    {\n+      mem = gen_rtx_MEM (Pmode,\n+\t\t\t plus_constant (arg_pointer_rtx, (i * UNITS_PER_WORD)));\n+      emit_move_insn (mem, gen_rtx_REG (Pmode, i));\n+    }\n+\n+  *pretend_size = 0;\n+}\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may\n+   be accessed via the stack pointer) in functions that seem suitable.  */\n+\n+int\n+bfin_frame_pointer_required (void) \n+{\n+  e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n+\n+  if (fkind != SUBROUTINE)\n+    return 1;\n+\n+  /* We turn on on -fomit-frame-pointer if -momit-leaf-frame-pointer is used,\n+     so we have to override it for non-leaf functions.  */\n+  if (TARGET_OMIT_LEAF_FRAME_POINTER && ! current_function_is_leaf)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return the number of registers pushed during the prologue.  */\n+\n+static int\n+n_regs_saved_by_prologue (void)\n+{\n+  e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n+  int n = n_dregs_to_save () + n_pregs_to_save ();\n+\n+  if (stack_frame_needed_p ())\n+    /* We use a LINK instruction in this case.  */\n+    n += 2;\n+  else\n+    {\n+      if (must_save_fp_p ())\n+\tn++;\n+      if (! current_function_is_leaf)\n+\tn++;\n+    }\n+\n+  if (fkind != SUBROUTINE)\n+    {\n+      tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+      tree all = lookup_attribute (\"saveall\", attrs);\n+      int i;\n+\n+      /* Increment once for ASTAT.  */\n+      n++;\n+\n+      /* RETE/X/N.  */\n+      if (lookup_attribute (\"nesting\", attrs))\n+\tn++;\n+\n+      for (i = REG_P7 + 1; i < REG_CC; i++)\n+\tif (all \n+\t    || regs_ever_live[i]\n+\t    || (!leaf_function_p () && call_used_regs[i]))\n+\t  n += i == REG_A0 || i == REG_A1 ? 2 : 1;\n+    }\n+  return n;\n+}\n+\n+/* Return the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+HOST_WIDE_INT\n+bfin_initial_elimination_offset (int from, int to)\n+{\n+  HOST_WIDE_INT offset = 0;\n+\n+  if (from == ARG_POINTER_REGNUM)\n+    offset = n_regs_saved_by_prologue () * 4;\n+\n+  if (to == STACK_POINTER_REGNUM)\n+    {\n+      if (current_function_outgoing_args_size >= FIXED_STACK_AREA)\n+\toffset += current_function_outgoing_args_size;\n+      else if (current_function_outgoing_args_size)\n+\toffset += FIXED_STACK_AREA;\n+\n+      offset += get_frame_size ();\n+    }\n+\n+  return offset;\n+}\n+\n+/* Emit code to load a constant CONSTANT into register REG; setting\n+   RTX_FRAME_RELATED_P on all insns we generate.  Make sure that the insns\n+   we generate need not be split.  */\n+\n+static void\n+frame_related_constant_load (rtx reg, HOST_WIDE_INT constant)\n+{\n+  rtx insn;\n+  rtx cst = GEN_INT (constant);\n+\n+  if (constant >= -32768 && constant < 65536)\n+    insn = emit_move_insn (reg, cst);\n+  else\n+    {\n+      /* We don't call split_load_immediate here, since dwarf2out.c can get\n+\t confused about some of the more clever sequences it can generate.  */\n+      insn = emit_insn (gen_movsi_high (reg, cst));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_insn (gen_movsi_low (reg, reg, cst));\n+    }\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+/* Generate efficient code to add a value to the frame pointer.  We\n+   can use P1 as a scratch register.  Set RTX_FRAME_RELATED_P on the\n+   generated insns if FRAME is nonzero.  */\n+\n+static void\n+add_to_sp (rtx spreg, HOST_WIDE_INT value, int frame)\n+{\n+  if (value == 0)\n+    return;\n+\n+  /* Choose whether to use a sequence using a temporary register, or\n+     a sequence with multiple adds.  We can add a signed 7 bit value\n+     in one instruction.  */\n+  if (value > 120 || value < -120)\n+    {\n+      rtx tmpreg = gen_rtx_REG (SImode, REG_P1);\n+      rtx insn;\n+\n+      if (frame)\n+\tframe_related_constant_load (tmpreg, value);\n+      else\n+\t{\n+\t  insn = emit_move_insn (tmpreg, GEN_INT (value));\n+\t  if (frame)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      insn = emit_insn (gen_addsi3 (spreg, spreg, tmpreg));\n+      if (frame)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    do\n+      {\n+\tint size = value;\n+\trtx insn;\n+\n+\tif (size > 60)\n+\t  size = 60;\n+\telse if (size < -60)\n+\t  /* We could use -62, but that would leave the stack unaligned, so\n+\t     it's no good.  */\n+\t  size = -60;\n+\n+\tinsn = emit_insn (gen_addsi3 (spreg, spreg, GEN_INT (size)));\n+\tif (frame)\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\tvalue -= size;\n+      }\n+    while (value != 0);\n+}\n+\n+/* Generate a LINK insn for a frame sized FRAME_SIZE.  If this constant\n+   is too large, generate a sequence of insns that has the same effect.\n+   SPREG contains (reg:SI REG_SP).  */\n+\n+static void\n+emit_link_insn (rtx spreg, HOST_WIDE_INT frame_size)\n+{\n+  HOST_WIDE_INT link_size = frame_size;\n+  rtx insn;\n+  int i;\n+\n+  if (link_size > 262140)\n+    link_size = 262140;\n+\n+  /* Use a LINK insn with as big a constant as possible, then subtract\n+     any remaining size from the SP.  */\n+  insn = emit_insn (gen_link (GEN_INT (-8 - link_size)));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+    {\n+      rtx set = XVECEXP (PATTERN (insn), 0, i);\n+      if (GET_CODE (set) != SET)\n+\tabort ();\n+      RTX_FRAME_RELATED_P (set) = 1;\n+    }\n+\n+  frame_size -= link_size;\n+\n+  if (frame_size > 0)\n+    {\n+      /* Must use a call-clobbered PREG that isn't the static chain.  */\n+      rtx tmpreg = gen_rtx_REG (Pmode, REG_P1);\n+\n+      frame_related_constant_load (tmpreg, -frame_size);\n+      insn = emit_insn (gen_addsi3 (spreg, spreg, tmpreg));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+/* Return the number of bytes we must reserve for outgoing arguments\n+   in the current function's stack frame.  */\n+\n+static HOST_WIDE_INT\n+arg_area_size (void)\n+{\n+  if (current_function_outgoing_args_size)\n+    {\n+      if (current_function_outgoing_args_size >= FIXED_STACK_AREA)\n+\treturn current_function_outgoing_args_size;\n+      else\n+\treturn FIXED_STACK_AREA;\n+    }\n+  return 0;\n+}\n+\n+/* Save RETS and FP, and allocate a stack frame.  */\n+\n+static void\n+do_link (rtx spreg, HOST_WIDE_INT frame_size)\n+{\n+  frame_size += arg_area_size ();\n+\n+  if (stack_frame_needed_p ()\n+      || (must_save_fp_p () && ! current_function_is_leaf))\n+    emit_link_insn (spreg, frame_size);\n+  else\n+    {\n+      if (! current_function_is_leaf)\n+\t{\n+\t  rtx pat = gen_movsi (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t    gen_rtx_PRE_DEC (Pmode, spreg)),\n+\t\t\t       bfin_rets_rtx);\n+\t  rtx insn = emit_insn (pat);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      if (must_save_fp_p ())\n+\t{\n+\t  rtx pat = gen_movsi (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t    gen_rtx_PRE_DEC (Pmode, spreg)),\n+\t\t\t       gen_rtx_REG (Pmode, REG_FP));\n+\t  rtx insn = emit_insn (pat);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      add_to_sp (spreg, -frame_size, 1);\n+    }\n+}\n+\n+/* Like do_link, but used for epilogues to deallocate the stack frame.  */\n+\n+static void\n+do_unlink (rtx spreg, HOST_WIDE_INT frame_size)\n+{\n+  frame_size += arg_area_size ();\n+\n+  if (stack_frame_needed_p ())\n+    emit_insn (gen_unlink ());\n+  else \n+    {\n+      rtx postinc = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, spreg));\n+\n+      add_to_sp (spreg, frame_size, 0);\n+      if (must_save_fp_p ())\n+\t{\n+\t  rtx fpreg = gen_rtx_REG (Pmode, REG_FP);\n+\t  emit_move_insn (fpreg, postinc);\n+\t  emit_insn (gen_rtx_USE (VOIDmode, fpreg));\n+\t}\n+      if (! current_function_is_leaf)\n+\t{\n+\t  emit_move_insn (bfin_rets_rtx, postinc);\n+\t  emit_insn (gen_rtx_USE (VOIDmode, bfin_rets_rtx));\n+\t}\n+    }\n+}\n+\n+/* Generate a prologue suitable for a function of kind FKIND.  This is\n+   called for interrupt and exception handler prologues.\n+   SPREG contains (reg:SI REG_SP).  */\n+\n+static void\n+expand_interrupt_handler_prologue (rtx spreg, e_funkind fkind)\n+{\n+  int i;\n+  HOST_WIDE_INT frame_size = get_frame_size ();\n+  rtx predec1 = gen_rtx_PRE_DEC (SImode, spreg);\n+  rtx predec = gen_rtx_MEM (SImode, predec1);\n+  rtx insn;\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  tree all = lookup_attribute (\"saveall\", attrs);\n+  tree kspisusp = lookup_attribute (\"kspisusp\", attrs);\n+\n+  if (kspisusp)\n+    {\n+      insn = emit_move_insn (spreg, gen_rtx_REG (Pmode, REG_USP));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* We need space on the stack in case we need to save the argument\n+     registers.  */\n+  if (fkind == EXCPT_HANDLER)\n+    {\n+      insn = emit_insn (gen_addsi3 (spreg, spreg, GEN_INT (-12)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  expand_prologue_reg_save (spreg, all != NULL_TREE);\n+\n+  for (i = REG_P7 + 1; i < REG_CC; i++)\n+    if (all \n+\t|| regs_ever_live[i]\n+\t|| (!leaf_function_p () && call_used_regs[i]))\n+      {\n+\tif (i == REG_A0 || i == REG_A1)\n+\t  insn = emit_move_insn (gen_rtx_MEM (PDImode, predec1),\n+\t\t\t\t gen_rtx_REG (PDImode, i));\n+\telse\n+\t  insn = emit_move_insn (predec, gen_rtx_REG (SImode, i));\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+      }\n+\n+  if (lookup_attribute (\"nesting\", attrs))\n+    {\n+      rtx srcreg = gen_rtx_REG (Pmode, (fkind == EXCPT_HANDLER ? REG_RETX\n+\t\t\t\t\t: fkind == NMI_HANDLER ? REG_RETN\n+\t\t\t\t\t: REG_RETI));\n+      insn = emit_move_insn (predec, srcreg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  do_link (spreg, frame_size);\n+\n+  if (fkind == EXCPT_HANDLER)\n+    {\n+      rtx r0reg = gen_rtx_REG (SImode, REG_R0);\n+      rtx r1reg = gen_rtx_REG (SImode, REG_R1);\n+      rtx r2reg = gen_rtx_REG (SImode, REG_R2);\n+      rtx insn;\n+\n+      insn = emit_move_insn (r0reg, gen_rtx_REG (SImode, REG_SEQSTAT));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    NULL_RTX);\n+      insn = emit_insn (gen_ashrsi3 (r0reg, r0reg, GEN_INT (26)));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    NULL_RTX);\n+      insn = emit_insn (gen_ashlsi3 (r0reg, r0reg, GEN_INT (26)));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    NULL_RTX);\n+      insn = emit_move_insn (r1reg, spreg);\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    NULL_RTX);\n+      insn = emit_move_insn (r2reg, gen_rtx_REG (Pmode, REG_FP));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    NULL_RTX);\n+      insn = emit_insn (gen_addsi3 (r2reg, r2reg, GEN_INT (8)));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    NULL_RTX);\n+    }\n+}\n+\n+/* Generate an epilogue suitable for a function of kind FKIND.  This is\n+   called for interrupt and exception handler epilogues.\n+   SPREG contains (reg:SI REG_SP).  */\n+\n+static void\n+expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind) \n+{\n+  int i;\n+  rtx postinc1 = gen_rtx_POST_INC (SImode, spreg);\n+  rtx postinc = gen_rtx_MEM (SImode, postinc1);\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n+  tree all = lookup_attribute (\"saveall\", attrs);\n+\n+  /* A slightly crude technique to stop flow from trying to delete \"dead\"\n+     insns.  */\n+  MEM_VOLATILE_P (postinc) = 1;\n+\n+  do_unlink (spreg, get_frame_size ());\n+\n+  if (lookup_attribute (\"nesting\", attrs))\n+    {\n+      rtx srcreg = gen_rtx_REG (Pmode, (fkind == EXCPT_HANDLER ? REG_RETX\n+\t\t\t\t\t: fkind == NMI_HANDLER ? REG_RETN\n+\t\t\t\t\t: REG_RETI));\n+      emit_move_insn (srcreg, postinc);\n+    }\n+\n+  for (i = REG_CC - 1; i > REG_P7; i--)\n+    if (all\n+\t|| regs_ever_live[i] \n+\t|| (!leaf_function_p () && call_used_regs[i]))\n+      {\n+\tif (i == REG_A0 || i == REG_A1)\n+\t  {\n+\t    rtx mem = gen_rtx_MEM (PDImode, postinc1);\n+\t    MEM_VOLATILE_P (mem) = 1;\n+\t    emit_move_insn (gen_rtx_REG (PDImode, i), mem);\n+\t  }\n+\telse\n+\t  emit_move_insn (gen_rtx_REG (SImode, i), postinc);\n+      }\n+\n+  expand_epilogue_reg_restore (spreg, all != NULL_TREE);\n+\n+  emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n+\n+  /* Deallocate any space we left on the stack in case we needed to save the\n+     argument registers.  */\n+  if (fkind == EXCPT_HANDLER)\n+    emit_insn (gen_addsi3 (spreg, spreg, GEN_INT (12)));\n+\n+  emit_jump_insn (gen_return_internal (GEN_INT (fkind)));\n+}\n+\n+/* Generate RTL for the prologue of the current function.  */\n+\n+void\n+bfin_expand_prologue (void)\n+{\n+  rtx insn;\n+  HOST_WIDE_INT frame_size = get_frame_size ();\n+  rtx spreg = gen_rtx_REG (Pmode, REG_SP);\n+  e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n+\n+  if (fkind != SUBROUTINE)\n+    {\n+      expand_interrupt_handler_prologue (spreg, fkind);\n+      return;\n+    }\n+\n+  expand_prologue_reg_save (spreg, 0);\n+\n+  do_link (spreg, frame_size);\n+\n+  if (TARGET_ID_SHARED_LIBRARY\n+      && (current_function_uses_pic_offset_table\n+\t  || !current_function_is_leaf))\n+    {\n+      rtx addr;\n+      \n+      if (bfin_library_id_string)\n+\taddr = plus_constant (pic_offset_table_rtx, atoi (bfin_library_id_string));\n+      else\n+\taddr = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t     gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t\t     UNSPEC_LIBRARY_OFFSET));\n+      insn = emit_insn (gen_movsi (pic_offset_table_rtx,\n+\t\t\t\t   gen_rtx_MEM (Pmode, addr)));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n+    }\n+}\n+\n+/* Generate RTL for the epilogue of the current function.  NEED_RETURN is zero\n+   if this is for a sibcall.  EH_RETURN is nonzero if we're expanding an\n+   eh_return pattern.  */\n+\n+void\n+bfin_expand_epilogue (int need_return, int eh_return)\n+{\n+  rtx spreg = gen_rtx_REG (Pmode, REG_SP);\n+  e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n+\n+  if (fkind != SUBROUTINE)\n+    {\n+      expand_interrupt_handler_epilogue (spreg, fkind);\n+      return;\n+    }\n+\n+  do_unlink (spreg, get_frame_size ());\n+\n+  expand_epilogue_reg_restore (spreg, 0);\n+\n+  /* Omit the return insn if this is for a sibcall.  */\n+  if (! need_return)\n+    return;\n+\n+  if (eh_return)\n+    emit_insn (gen_addsi3 (spreg, spreg, gen_rtx_REG (Pmode, REG_P2)));\n+\n+  emit_jump_insn (gen_return_internal (GEN_INT (SUBROUTINE)));\n+}\n+\f\n+/* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */\n+\n+int\n+bfin_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n+\t\t\t   unsigned int new_reg)\n+{\n+  /* Interrupt functions can only use registers that have already been\n+     saved by the prologue, even if they would normally be\n+     call-clobbered.  */\n+\n+  if (funkind (TREE_TYPE (current_function_decl)) != SUBROUTINE\n+      && !regs_ever_live[new_reg])\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Return the value of the return address for the frame COUNT steps up\n+   from the current frame, after the prologue.\n+   We punt for everything but the current frame by returning const0_rtx.  */\n+\n+rtx\n+bfin_return_addr_rtx (int count)\n+{\n+  if (count != 0)\n+    return const0_rtx;\n+\n+  return get_hard_reg_initial_val (Pmode, REG_RETS);\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address X\n+   to be legitimate.  If we find one, return the new, valid address,\n+   otherwise return NULL_RTX.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE is the mode of the memory reference.  */\n+\n+rtx\n+legitimize_address (rtx x ATTRIBUTE_UNUSED, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return NULL_RTX;\n+}\n+\n+/* This predicate is used to compute the length of a load/store insn.\n+   OP is a MEM rtx, we return nonzero if its addressing mode requires a\n+   32 bit instruction.  */\n+\n+int\n+effective_address_32bit_p (rtx op, enum machine_mode mode) \n+{\n+  HOST_WIDE_INT offset;\n+\n+  mode = GET_MODE (op);\n+  op = XEXP (op, 0);\n+\n+  if (REG_P (op) || GET_CODE (op) == POST_INC\n+      || GET_CODE (op) == PRE_DEC || GET_CODE (op) == POST_DEC)\n+    return 0;\n+  if (GET_CODE (op) != PLUS)\n+    abort ();\n+\n+  offset = INTVAL (XEXP (op, 1));\n+\n+  /* All byte loads use a 16 bit offset.  */\n+  if (GET_MODE_SIZE (mode) == 1)\n+    return 1;\n+\n+  if (GET_MODE_SIZE (mode) == 4)\n+    {\n+      /* Frame pointer relative loads can use a negative offset, all others\n+\t are restricted to a small positive one.  */\n+      if (XEXP (op, 0) == frame_pointer_rtx)\n+\treturn offset < -128 || offset > 60;\n+      return offset < 0 || offset > 60;\n+    }\n+\n+  /* Must be HImode now.  */\n+  return offset < 0 || offset > 30;\n+}\n+\n+/* Return cost of the memory address ADDR.\n+   All addressing modes are equally cheap on the Blackfin.  */\n+\n+static int\n+bfin_address_cost (rtx addr ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+/* Subroutine of print_operand; used to print a memory reference X to FILE.  */\n+\n+void\n+print_address_operand (FILE *file, rtx x)\n+{\n+  if (GET_CODE (x) == MEM) \n+    abort ();\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+      output_address (XEXP (x, 0));\n+      fprintf (file, \"+\");\n+      output_address (XEXP (x, 1));\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"--\");\n+      output_address (XEXP (x, 0));    \n+      break;\n+    case POST_INC:\n+      output_address (XEXP (x, 0));\n+      fprintf (file, \"++\");\n+      break;\n+    case POST_DEC:\n+      output_address (XEXP (x, 0));\n+      fprintf (file, \"--\");\n+      break;\n+\n+    default:\n+      print_operand (file, x, 0);\n+    }\n+}\n+\n+/* Adding intp DImode support by Tony\n+ * -- Q: (low  word)\n+ * -- R: (high word)\n+ */\n+\n+void\n+print_operand (FILE *file, rtx x, char code)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case 'j':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:\n+\t  fprintf (file, \"e\");\n+\t  break;\n+\tcase NE:\n+\t  fprintf (file, \"ne\");\n+\t  break;\n+\tcase GT:\n+\t  fprintf (file, \"g\");\n+\t  break;\n+\tcase LT:\n+\t  fprintf (file, \"l\");\n+\t  break;\n+\tcase GE:\n+\t  fprintf (file, \"ge\");\n+\t  break;\n+\tcase LE:\n+\t  fprintf (file, \"le\");\n+\t  break;\n+\tcase GTU:\n+\t  fprintf (file, \"g\");\n+\t  break;\n+\tcase LTU:\n+\t  fprintf (file, \"l\");\n+\t  break;\n+\tcase GEU:\n+\t  fprintf (file, \"ge\");\n+\t  break;\n+\tcase LEU:\n+\t  fprintf (file, \"le\");\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%j value\");\n+\t}\n+      break;\n+    \n+    case 'J':\t\t\t\t\t /* reverse logic */\n+      switch (GET_CODE(x))\n+\t{\n+\tcase EQ:\n+\t  fprintf (file, \"ne\");\n+\t  break;\n+\tcase NE:\n+\t  fprintf (file, \"e\");\n+\t  break;\n+\tcase GT:\n+\t  fprintf (file, \"le\");\n+\t  break;\n+\tcase LT:\n+\t  fprintf (file, \"ge\");\n+\t  break;\n+\tcase GE:\n+\t  fprintf (file, \"l\");\n+\t  break;\n+\tcase LE:\n+\t  fprintf (file, \"g\");\n+\t  break;\n+\tcase GTU:\n+\t  fprintf (file, \"le\");\n+\t  break;\n+\tcase LTU:\n+\t  fprintf (file, \"ge\");\n+\t  break;\n+\tcase GEU:\n+\t  fprintf (file, \"l\");\n+\t  break;\n+\tcase LEU:\n+\t  fprintf (file, \"g\");\n+\t  break;\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%J value\");\n+\t}\n+      break;\n+\n+    default:\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  if (code == 'h')\n+\t    {\n+\t      gcc_assert (REGNO (x) < 32);\n+\t      fprintf (file, \"%s\", short_reg_names[REGNO (x)]);\n+\t      /*fprintf (file, \"\\n%d\\n \", REGNO (x));*/\n+\t      break;\n+\t    }\n+\t  else if (code == 'd')\n+\t    {\n+\t      gcc_assert (REGNO (x) < 32);\n+\t      fprintf (file, \"%s\", high_reg_names[REGNO (x)]);\n+\t      break;\n+\t    }\n+\t  else if (code == 'w')\n+\t    {\n+\t      gcc_assert (REGNO (x) == REG_A0 || REGNO (x) == REG_A1);\n+\t      fprintf (file, \"%s.w\", reg_names[REGNO (x)]);\n+\t    }\n+\t  else if (code == 'x')\n+\t    {\n+\t      gcc_assert (REGNO (x) == REG_A0 || REGNO (x) == REG_A1);\n+\t      fprintf (file, \"%s.x\", reg_names[REGNO (x)]);\n+\t    }\n+\t  else if (code == 'D')\n+\t    {\n+\t      fprintf (file, \"%s\", dregs_pair_names[REGNO (x)]);\n+\t    }\n+\t  else if (code == 'H')\n+\t    {\n+\t      gcc_assert (mode == DImode || mode == DFmode);\n+\t      gcc_assert (REG_P (x));\n+\t      fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+\t    }\n+\t  else if (code == 'T')\n+\t    {\n+\t      if (REGNO (x) > 7)\n+\t\tabort ();\n+\t      fprintf (file, \"%s\", byte_reg_names[REGNO (x)]);\n+\t    }\n+\t  else \n+\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  break;\n+\n+\tcase MEM:\n+\t  fputc ('[', file);\n+\t  x = XEXP (x,0);\n+\t  print_address_operand (file, x);\n+\t  fputc (']', file);\n+\t  break;\n+\n+\tcase CONST_INT:\n+\t  /* Moves to half registers with d or h modifiers always use unsigned\n+\t     constants.  */\n+\t  if (code == 'd')\n+\t    x = GEN_INT ((INTVAL (x) >> 16) & 0xffff);\n+\t  else if (code == 'h')\n+\t    x = GEN_INT (INTVAL (x) & 0xffff);\n+\t  else if (code == 'X')\n+\t    x = GEN_INT (exact_log2 (0xffffffff & INTVAL (x)));\n+\t  else if (code == 'Y')\n+\t    x = GEN_INT (exact_log2 (0xffffffff & ~INTVAL (x)));\n+\t  else if (code == 'Z')\n+\t    /* Used for LINK insns.  */\n+\t    x = GEN_INT (-8 - INTVAL (x));\n+\n+\t  /* fall through */\n+\n+\tcase SYMBOL_REF:\n+\t  output_addr_const (file, x);\n+\t  if (code == 'G' && flag_pic)\n+\t    fprintf (file, \"@GOT\");\n+\t  break;\n+\n+\tcase CONST_DOUBLE:\n+\t  output_operand_lossage (\"invalid const_double operand\");\n+\t  break;\n+\n+\tcase UNSPEC:\n+\t  if (XINT (x, 1) == UNSPEC_MOVE_PIC)\n+\t    {\n+\t      output_addr_const (file, XVECEXP (x, 0, 0));\n+\t      fprintf (file, \"@GOT\");\n+\t    }\n+\t  else if (XINT (x, 1) == UNSPEC_LIBRARY_OFFSET)\n+\t    fprintf (file, \"_current_shared_library_p5_offset_\");\n+\t  else\n+\t    abort ();\n+\t  break;\n+\n+\tdefault:\n+\t  output_addr_const (file, x);\n+\t}\n+    }\n+}\n+\f\n+/* Argument support functions.  */\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  \n+   VDSP C Compiler manual, our ABI says that\n+   first 3 words of arguments will use R0, R1 and R2.\n+*/\n+\n+void\n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype ATTRIBUTE_UNUSED,\n+\t\t      rtx libname ATTRIBUTE_UNUSED)\n+{\n+  static CUMULATIVE_ARGS zero_cum;\n+\n+  *cum = zero_cum;\n+\n+  /* Set up the number of registers to use for passing arguments.  */\n+\n+  cum->nregs = max_arg_registers;\n+  cum->arg_regs = arg_regs;\n+\n+  return;\n+}\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+void\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t\t      int named ATTRIBUTE_UNUSED)\n+{\n+  int count, bytes, words;\n+\n+  bytes = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  cum->words += words;\n+  cum->nregs -= words;\n+\n+  if (cum->nregs <= 0)\n+    {\n+      cum->nregs = 0;\n+      cum->arg_regs = NULL;\n+    }\n+  else\n+    {\n+      for (count = 1; count <= words; count++)\n+        cum->arg_regs++;\n+    }\n+\n+  return;\n+}\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+struct rtx_def *\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n+\t      int named ATTRIBUTE_UNUSED)\n+{\n+  int bytes\n+    = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+\n+  if (bytes == -1)\n+    return NULL_RTX;\n+\n+  if (cum->nregs)\n+    return gen_rtx_REG (mode, *(cum->arg_regs));\n+\n+  return NULL_RTX;\n+}\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of bytes passed in registers.\n+   For args passed entirely in registers or entirely in memory, zero.\n+\n+   Refer VDSP C Compiler manual, our ABI.\n+   First 3 words are in registers. So, if a an argument is larger\n+   than the registers available, it will span the register and\n+   stack.   */\n+\n+static int\n+bfin_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\ttree type ATTRIBUTE_UNUSED,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n+{\n+  int bytes\n+    = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  int bytes_left = cum->nregs * UNITS_PER_WORD;\n+  \n+  if (bytes == -1)\n+    return 0;\n+\n+  if (bytes_left == 0)\n+    return 0;\n+  if (bytes > bytes_left)\n+    return bytes_left;\n+  return 0;\n+}\n+\n+/* Variable sized types are passed by reference.  */\n+\n+static bool\n+bfin_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n+}\n+\n+/* Decide whether a type should be returned in memory (true)\n+   or in a register (false).  This is called by the macro\n+   RETURN_IN_MEMORY.  */\n+\n+int\n+bfin_return_in_memory (tree type)\n+{\n+  int size;\n+  enum machine_mode mode = TYPE_MODE (type);\n+\n+  if (mode == BLKmode)\n+    return 1;\n+  size = int_size_in_bytes (type);\t\n+  if (VECTOR_MODE_P (mode) || mode == TImode)\n+    {\n+      /* User-created vectors small enough to fit in REG.  */\n+      if (size < 8)\n+        return 0;\n+      if (size == 8 || size == 16)\n+\treturn 1;\n+    }\n+\n+  if (size > 12)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+static rtx\n+bfin_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n+\t\t      int incoming ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (Pmode, REG_P0);\n+}\n+\n+/* Return true when register may be used to pass function parameters.  */\n+\n+bool \n+function_arg_regno_p (int n)\n+{\n+  int i;\n+  for (i = 0; arg_regs[i] != -1; i++)\n+    if (n == arg_regs[i])\n+      return true;\n+  return false;\n+}\n+\n+/* Returns 1 if OP contains a symbol reference */\n+\n+int\n+symbolic_reference_mentioned_p (rtx op)\n+{\n+  register const char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (op));\n+  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n+\t    if (symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t      return 1;\n+\t}\n+\n+      else if (fmt[i] == 'e' && symbolic_reference_mentioned_p (XEXP (op, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Decide whether we can make a sibling call to a function.  DECL is the\n+   declaration of the function being targeted by the call and EXP is the\n+   CALL_EXPR representing the call.  */\n+\n+static bool\n+bfin_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n+\t\t\t      tree exp ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\f\n+/* Emit RTL insns to initialize the variable parts of a trampoline at\n+   TRAMP. FNADDR is an RTX for the address of the function's pure\n+   code.  CXT is an RTX for the static chain value for the function.  */\n+\n+void\n+initialize_trampoline (tramp, fnaddr, cxt)\n+     rtx tramp, fnaddr, cxt;\n+{\n+  rtx t1 = copy_to_reg (fnaddr);\n+  rtx t2 = copy_to_reg (cxt);\n+  rtx addr;\n+\n+  addr = memory_address (Pmode, plus_constant (tramp, 2));\n+  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, t1));\n+  emit_insn (gen_ashrsi3 (t1, t1, GEN_INT (16)));\n+  addr = memory_address (Pmode, plus_constant (tramp, 6));\n+  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, t1));\n+\n+  addr = memory_address (Pmode, plus_constant (tramp, 10));\n+  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, t2));\n+  emit_insn (gen_ashrsi3 (t2, t2, GEN_INT (16)));\n+  addr = memory_address (Pmode, plus_constant (tramp, 14));\n+  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, t2));\n+}\n+\n+/* Legitimize PIC addresses.  If the address is already position-independent,\n+   we return ORIG.  Newly generated position-independent addresses go into a\n+   reg.  This is REG if nonzero, otherwise we allocate register(s) as\n+   necessary.  */\n+\n+rtx\n+legitimize_pic_address (rtx orig, rtx reg)\n+{\n+  rtx addr = orig;\n+  rtx new = orig;\n+\n+  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n+    {\n+      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n+\treg = new = orig;\n+      else\n+\t{\n+\t  if (reg == 0)\n+\t    {\n+\t      if (no_new_pseudos)\n+\t\tabort ();\n+\t      reg = gen_reg_rtx (Pmode);\n+\t    }\n+\n+\t  if (flag_pic == 2)\n+\t    {\n+\t      emit_insn (gen_movsi_high_pic (reg, addr));\n+\t      emit_insn (gen_movsi_low_pic (reg, reg, addr));\n+\t      emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));\n+\t      new = gen_rtx_MEM (Pmode, reg);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n+\t\t\t\t\tUNSPEC_MOVE_PIC);\n+\t      new = gen_rtx_MEM (Pmode,\n+\t\t\t\t gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t\t       tmp));\n+\t    }\n+\t  emit_move_insn (reg, new);\n+\t}\n+      current_function_uses_pic_offset_table = 1;\n+      return reg;\n+    }\n+\n+  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n+    {\n+      rtx base;\n+\n+      if (GET_CODE (addr) == CONST)\n+\t{\n+\t  addr = XEXP (addr, 0);\n+\t  if (GET_CODE (addr) != PLUS)\n+\t    abort ();\n+\t}\n+\n+      if (XEXP (addr, 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (no_new_pseudos)\n+\t    abort ();\n+\t  reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      base = legitimize_pic_address (XEXP (addr, 0), reg);\n+      addr = legitimize_pic_address (XEXP (addr, 1),\n+\t\t\t\t     base == reg ? NULL_RTX : reg);\n+\n+      if (GET_CODE (addr) == CONST_INT)\n+\t{\n+\t  if (! reload_in_progress && ! reload_completed)\n+\t    addr = force_reg (Pmode, addr);\n+\t  else\n+\t    /* If we reach here, then something is seriously wrong.  */\n+\t    abort ();\n+\t}\n+\n+      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n+\t{\n+\t  base = gen_rtx_PLUS (Pmode, base, XEXP (addr, 0));\n+\t  addr = XEXP (addr, 1);\n+\t}\n+\n+      return gen_rtx_PLUS (Pmode, base, addr);\n+    }\n+\n+  return new;\n+}\n+\n+/* Emit insns to move operands[1] into operands[0].  */\n+\n+void\n+emit_pic_move (rtx *operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n+\n+  if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+  else\n+    operands[1] = legitimize_pic_address (operands[1], temp);\n+}\n+\n+/* Expand a move operation in mode MODE.  The operands are in OPERANDS.  */\n+\n+void\n+expand_move (rtx *operands, enum machine_mode mode)\n+{\n+  if (flag_pic && SYMBOLIC_CONST (operands[1]))\n+    emit_pic_move (operands, mode);\n+\n+  /* Don't generate memory->memory or constant->memory moves, go through a\n+     register */\n+  else if ((reload_in_progress | reload_completed) == 0\n+\t   && GET_CODE (operands[0]) == MEM\n+    \t   && GET_CODE (operands[1]) != REG)\n+    operands[1] = force_reg (mode, operands[1]);\n+}\n+\f\n+/* Split one or more DImode RTL references into pairs of SImode\n+   references.  The RTL can be REG, offsettable MEM, integer constant, or\n+   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n+   split and \"num\" is its length.  lo_half and hi_half are output arrays\n+   that parallel \"operands\".  */\n+\n+void\n+split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n+{\n+  while (num--)\n+    {\n+      rtx op = operands[num];\n+\n+      /* simplify_subreg refuse to split volatile memory addresses,\n+         but we still have to handle it.  */\n+      if (GET_CODE (op) == MEM)\n+\t{\n+\t  lo_half[num] = adjust_address (op, SImode, 0);\n+\t  hi_half[num] = adjust_address (op, SImode, 4);\n+\t}\n+      else\n+\t{\n+\t  lo_half[num] = simplify_gen_subreg (SImode, op,\n+\t\t\t\t\t      GET_MODE (op) == VOIDmode\n+\t\t\t\t\t      ? DImode : GET_MODE (op), 0);\n+\t  hi_half[num] = simplify_gen_subreg (SImode, op,\n+\t\t\t\t\t      GET_MODE (op) == VOIDmode\n+\t\t\t\t\t      ? DImode : GET_MODE (op), 4);\n+\t}\n+    }\n+}\n+\f\n+/* Expand a call instruction.  FNADDR is the call target, RETVAL the return value.\n+   SIBCALL is nonzero if this is a sibling call.  */\n+\n+void\n+bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, int sibcall)\n+{\n+  rtx use = NULL, call;\n+\n+  /* Static functions and indirect calls don't need the pic register.  */\n+  if (flag_pic\n+      && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n+      && ! SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n+    use_reg (&use, pic_offset_table_rtx);\n+\n+  if (! call_insn_operand (XEXP (fnaddr, 0), Pmode))\n+    {\n+      fnaddr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n+      fnaddr = gen_rtx_MEM (Pmode, fnaddr);\n+    }\n+  call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n+\n+  if (retval)\n+    call = gen_rtx_SET (VOIDmode, retval, call);\n+  if (sibcall)\n+    {\n+      rtx pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+      XVECEXP (pat, 0, 0) = call;\n+      XVECEXP (pat, 0, 1) = gen_rtx_RETURN (VOIDmode);\n+      call = pat;\n+    }\n+  call = emit_call_insn (call);\n+  if (use)\n+    CALL_INSN_FUNCTION_USAGE (call) = use;\n+}\n+\f\n+/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+\n+int\n+hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  /* Allow only dregs to store value of mode HI or QI */\n+  enum reg_class class = REGNO_REG_CLASS (regno);\n+\n+  if (mode == CCmode)\n+    return 0;\n+\n+  if (mode == V2HImode)\n+    return D_REGNO_P (regno);\n+  if (class == CCREGS)\n+    return mode == BImode;\n+  if (mode == PDImode)\n+    return regno == REG_A0 || regno == REG_A1;\n+  if (mode == SImode\n+      && TEST_HARD_REG_BIT (reg_class_contents[PROLOGUE_REGS], regno))\n+    return 1;\n+      \n+  return TEST_HARD_REG_BIT (reg_class_contents[MOST_REGS], regno);\n+}\n+\n+/* Implements target hook vector_mode_supported_p.  */\n+\n+static bool\n+bfin_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  return mode == V2HImode;\n+}\n+\n+/* Return the cost of moving data from a register in class CLASS1 to\n+   one in class CLASS2.  A cost of 2 is the default.  */\n+\n+int\n+bfin_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t enum reg_class class1, enum reg_class class2)\n+{\n+  /* If optimizing for size, always prefer reg-reg over reg-memory moves.  */\n+  if (optimize_size)\n+    return 2;\n+\n+  /* There are some stalls involved when moving from a DREG to a different\n+     class reg, and using the value in one of the following instructions.\n+     Attempt to model this by slightly discouraging such moves.  */\n+  if (class1 == DREGS && class2 != DREGS)\n+    return 2 * 2;\n+\n+  return 2;\n+}\n+\n+/* Return the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   ??? In theory L1 memory has single-cycle latency.  We should add a switch\n+   that tells the compiler whether we expect to use only L1 memory for the\n+   program; it'll make the costs more accurate.  */\n+\n+int\n+bfin_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       enum reg_class class,\n+\t\t       int in ATTRIBUTE_UNUSED)\n+{\n+  /* Make memory accesses slightly more expensive than any register-register\n+     move.  Also, penalize non-DP registers, since they need secondary\n+     reloads to load and store.  */\n+  if (! reg_class_subset_p (class, DPREGS))\n+    return 10;\n+\n+  return 8;\n+}\n+\n+/* Inform reload about cases where moving X with a mode MODE to a register in\n+   CLASS requires an extra scratch register.  Return the class needed for the\n+   scratch register.  */\n+\n+enum reg_class\n+secondary_input_reload_class (enum reg_class class, enum machine_mode mode,\n+\t\t\t      rtx x)\n+{\n+  /* If we have HImode or QImode, we can only use DREGS as secondary registers;\n+     in most other cases we can also use PREGS.  */\n+  enum reg_class default_class = GET_MODE_SIZE (mode) >= 4 ? DPREGS : DREGS;\n+  enum reg_class x_class = NO_REGS;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  if (code == SUBREG)\n+    x = SUBREG_REG (x), code = GET_CODE (x);\n+  if (REG_P (x))\n+    {\n+      int regno = REGNO (x);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tregno = reg_renumber[regno];\n+\n+      if (regno == -1)\n+\tcode = MEM;\n+      else\n+\tx_class = REGNO_REG_CLASS (regno);\n+    }\n+\n+  /* We can be asked to reload (plus (FP) (large_constant)) into a DREG.\n+     This happens as a side effect of register elimination, and we need\n+     a scratch register to do it.  */\n+  if (fp_plus_const_operand (x, mode))\n+    {\n+      rtx op2 = XEXP (x, 1);\n+      int large_constant_p = ! CONST_7BIT_IMM_P (INTVAL (op2));\n+\n+      if (class == PREGS || class == PREGS_CLOBBERED)\n+\treturn NO_REGS;\n+      /* If destination is a DREG, we can do this without a scratch register\n+\t if the constant is valid for an add instruction.  */\n+      if (class == DREGS || class == DPREGS)\n+\treturn large_constant_p ? PREGS : NO_REGS;\n+      /* Reloading to anything other than a DREG?  Use a PREG scratch\n+\t register.  */\n+      return PREGS;\n+    }\n+\n+  /* Data can usually be moved freely between registers of most classes.\n+     AREGS are an exception; they can only move to or from another register\n+     in AREGS or one in DREGS.  They can also be assigned the constant 0.  */\n+  if (x_class == AREGS)\n+    return class == DREGS || class == AREGS ? NO_REGS : DREGS;\n+\n+  if (class == AREGS)\n+    {\n+      if (x != const0_rtx && x_class != DREGS)\n+\treturn DREGS;\n+      else\n+\treturn NO_REGS;\n+    }\n+\n+  /* CCREGS can only be moved from/to DREGS.  */\n+  if (class == CCREGS && x_class != DREGS)\n+    return DREGS;\n+  if (x_class == CCREGS && class != DREGS)\n+    return DREGS;\n+  /* All registers other than AREGS can load arbitrary constants.  The only\n+     case that remains is MEM.  */\n+  if (code == MEM)\n+    if (! reg_class_subset_p (class, default_class))\n+      return default_class;\n+  return NO_REGS;\n+}\n+\n+/* Like secondary_input_reload_class; and all we do is call that function.  */\n+\n+enum reg_class\n+secondary_output_reload_class (enum reg_class class, enum machine_mode mode,\n+\t\t\t       rtx x)\n+{\n+  return secondary_input_reload_class (class, mode, x);\n+}\n+\f\n+/* Implement the macro OVERRIDE_OPTIONS.  */\n+\n+void\n+override_options (void)\n+{\n+  if (TARGET_OMIT_LEAF_FRAME_POINTER)\n+    flag_omit_frame_pointer = 1;\n+\n+  /* Library identification */\n+  if (bfin_library_id_string)\n+    {\n+      int id;\n+\n+      if (! TARGET_ID_SHARED_LIBRARY)\n+\terror (\"-mshared-library-id= specified without -mid-shared-library\");\n+      id = atoi (bfin_library_id_string);\n+      if (id < 0 || id > MAX_LIBRARY_ID)\n+\terror (\"-mshared-library-id=%d is not between 0 and %d\", id, MAX_LIBRARY_ID);\n+\n+      /* From now on, bfin_library_id_string will contain the library offset.  */\n+      asprintf ((char **)&bfin_library_id_string, \"%d\", (id * -4) - 4);\n+    }\n+\n+  if (TARGET_ID_SHARED_LIBRARY)\n+    /* ??? Provide a way to use a bigger GOT.  */\n+    flag_pic = 1;\n+\n+  flag_schedule_insns = 0;\n+}\n+\n+/* Return the destination address of BRANCH.  */\n+\n+static int\n+branch_dest (rtx branch)\n+{\n+  rtx dest;\n+  int dest_uid;\n+  rtx pat = PATTERN (branch);\n+  if (GET_CODE (pat) == PARALLEL)\n+    pat = XVECEXP (pat, 0, 0);\n+  dest = SET_SRC (pat);\n+  if (GET_CODE (dest) == IF_THEN_ELSE)\n+    dest = XEXP (dest, 1);\n+  dest = XEXP (dest, 0);\n+  dest_uid = INSN_UID (dest);\n+  return INSN_ADDRESSES (dest_uid);\n+}\n+\n+/* Return nonzero if INSN is annotated with a REG_BR_PROB note that indicates\n+   it's a branch that's predicted taken.  */\n+\n+static int\n+cbranch_predicted_taken_p (rtx insn)\n+{\n+  rtx x = find_reg_note (insn, REG_BR_PROB, 0);\n+\n+  if (x)\n+    {\n+      int pred_val = INTVAL (XEXP (x, 0));\n+\n+      return pred_val >= REG_BR_PROB_BASE / 2;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Templates for use by asm_conditional_branch.  */\n+\n+static const char *ccbranch_templates[][3] = {\n+  { \"if !cc jump %3;\",  \"if cc jump 4 (bp); jump.s %3;\",  \"if cc jump 6 (bp); jump.l %3;\" },\n+  { \"if cc jump %3;\",   \"if !cc jump 4 (bp); jump.s %3;\", \"if !cc jump 6 (bp); jump.l %3;\" },\n+  { \"if !cc jump %3 (bp);\",  \"if cc jump 4; jump.s %3;\",  \"if cc jump 6; jump.l %3;\" },\n+  { \"if cc jump %3 (bp);\",  \"if !cc jump 4; jump.s %3;\",  \"if !cc jump 6; jump.l %3;\" },\n+};\n+\n+/* Output INSN, which is a conditional branch instruction with operands\n+   OPERANDS.\n+\n+   We deal with the various forms of conditional branches that can be generated\n+   by bfin_reorg to prevent the hardware from doing speculative loads, by\n+   - emitting a sufficient number of nops, if N_NOPS is nonzero, or\n+   - always emitting the branch as predicted taken, if PREDICT_TAKEN is true.\n+   Either of these is only necessary if the branch is short, otherwise the\n+   template we use ends in an unconditional jump which flushes the pipeline\n+   anyway.  */\n+\n+void\n+asm_conditional_branch (rtx insn, rtx *operands, int n_nops, int predict_taken)\n+{\n+  int offset = branch_dest (insn) - INSN_ADDRESSES (INSN_UID (insn));\n+  /* Note : offset for instructions like if cc jmp; jump.[sl] offset\n+            is to be taken from start of if cc rather than jump.\n+            Range for jump.s is (-4094, 4096) instead of (-4096, 4094)\n+  */\n+  int len = (offset >= -1024 && offset <= 1022 ? 0\n+\t     : offset >= -4094 && offset <= 4096 ? 1\n+\t     : 2);\n+  int bp = predict_taken && len == 0 ? 1 : cbranch_predicted_taken_p (insn);\n+  int idx = (bp << 1) | (GET_CODE (operands[0]) == EQ ? BRF : BRT);\n+  output_asm_insn (ccbranch_templates[idx][len], operands);\n+  if (n_nops > 0 && bp)\n+    abort ();\n+  if (len == 0)\n+    while (n_nops-- > 0)\n+      output_asm_insn (\"nop;\", NULL);\n+}\n+\n+/* Emit rtl for a comparison operation CMP in mode MODE.  Operands have been\n+   stored in bfin_compare_op0 and bfin_compare_op1 already.  */\n+\n+rtx\n+bfin_gen_compare (rtx cmp, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  enum rtx_code code1, code2;\n+  rtx op0 = bfin_compare_op0, op1 = bfin_compare_op1;\n+  rtx tem = bfin_cc_rtx;\n+  enum rtx_code code = GET_CODE (cmp);\n+\n+  /* If we have a BImode input, then we already have a compare result, and\n+     do not need to emit another comparison.  */\n+  if (GET_MODE (op0) == BImode)\n+    {\n+      if ((code == NE || code == EQ) && op1 == const0_rtx)\n+\ttem = op0, code2 = code;\n+      else\n+\tabort ();\n+    }\n+  else\n+    {\n+      switch (code) {\n+\t/* bfin has these conditions */\n+      case EQ:\n+      case LT:\n+      case LE:\n+      case LEU:\n+      case LTU:\n+\tcode1 = code;\n+\tcode2 = NE;\n+\tbreak;\n+      default:\n+\tcode1 = reverse_condition (code);\n+\tcode2 = EQ;\n+\tbreak;\n+      }\n+      emit_insn (gen_rtx_SET (BImode, tem,\n+\t\t\t      gen_rtx_fmt_ee (code1, BImode, op0, op1)));\n+    }\n+\n+  return gen_rtx_fmt_ee (code2, BImode, tem, CONST0_RTX (BImode));\n+}\n+\f\n+/* Return nonzero iff C has exactly one bit set if it is interpreted\n+   as a 32 bit constant.  */\n+\n+int\n+log2constp (unsigned HOST_WIDE_INT c)\n+{\n+  c &= 0xFFFFFFFF;\n+  return c != 0 && (c & (c-1)) == 0;\n+}\n+\n+/* Returns the number of consecutive least significant zeros in the binary\n+   representation of *V.\n+   We modify *V to contain the original value arithmetically shifted right by\n+   the number of zeroes.  */\n+\n+static int\n+shiftr_zero (HOST_WIDE_INT *v)\n+{\n+  unsigned HOST_WIDE_INT tmp = *v;\n+  unsigned HOST_WIDE_INT sgn;\n+  int n = 0;\n+\n+  if (tmp == 0)\n+    return 0;\n+\n+  sgn = tmp & ((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1));\n+  while ((tmp & 0x1) == 0 && n <= 32)\n+    {\n+      tmp = (tmp >> 1) | sgn;\n+      n++;\n+    }\n+  *v = tmp;\n+  return n;\n+}\n+\n+/* After reload, split the load of an immediate constant.  OPERANDS are the\n+   operands of the movsi_insn pattern which we are splitting.  We return\n+   nonzero if we emitted a sequence to load the constant, zero if we emitted\n+   nothing because we want to use the splitter's default sequence.  */\n+\n+int\n+split_load_immediate (rtx operands[])\n+{\n+  HOST_WIDE_INT val = INTVAL (operands[1]);\n+  HOST_WIDE_INT tmp;\n+  HOST_WIDE_INT shifted = val;\n+  HOST_WIDE_INT shifted_compl = ~val;\n+  int num_zero = shiftr_zero (&shifted);\n+  int num_compl_zero = shiftr_zero (&shifted_compl);\n+  unsigned int regno = REGNO (operands[0]);\n+  enum reg_class class1 = REGNO_REG_CLASS (regno);\n+\n+  /* This case takes care of single-bit set/clear constants, which we could\n+     also implement with BITSET/BITCLR.  */\n+  if (num_zero\n+      && shifted >= -32768 && shifted < 65536\n+      && (D_REGNO_P (regno)\n+\t  || (regno >= REG_P0 && regno <= REG_P7 && num_zero <= 2)))\n+    {\n+      emit_insn (gen_movsi (operands[0], GEN_INT (shifted)));\n+      emit_insn (gen_ashlsi3 (operands[0], operands[0], GEN_INT (num_zero)));\n+      return 1;\n+    }\n+\n+  tmp = val & 0xFFFF;\n+  tmp |= -(tmp & 0x8000);\n+\n+  /* If high word has one bit set or clear, try to use a bit operation.  */\n+  if (D_REGNO_P (regno))\n+    {\n+      if (log2constp (val & 0xFFFF0000))\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], GEN_INT (val & 0xFFFF)));\n+\t  emit_insn (gen_iorsi3 (operands[0], operands[0], GEN_INT (val & 0xFFFF0000)));\n+\t  return 1;\n+\t}\n+      else if (log2constp (val | 0xFFFF) && (val & 0x8000) != 0)\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], GEN_INT (tmp)));\n+\t  emit_insn (gen_andsi3 (operands[0], operands[0], GEN_INT (val | 0xFFFF)));\n+\t}\n+    }\n+\n+  if (D_REGNO_P (regno))\n+    {\n+      if (CONST_7BIT_IMM_P (tmp))\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], GEN_INT (tmp)));\n+\t  emit_insn (gen_movstricthi_high (operands[0], GEN_INT (val & -65536)));\n+\t  return 1;\n+\t}\n+\n+      if ((val & 0xFFFF0000) == 0)\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], const0_rtx));\n+\t  emit_insn (gen_movsi_low (operands[0], operands[0], operands[1]));\n+\t  return 1;\n+\t}\n+\n+      if ((val & 0xFFFF0000) == 0xFFFF0000)\n+\t{\n+\t  emit_insn (gen_movsi (operands[0], constm1_rtx));\n+\t  emit_insn (gen_movsi_low (operands[0], operands[0], operands[1]));\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* Need DREGs for the remaining case.  */\n+  if (regno > REG_R7)\n+    return 0;\n+\n+  if (optimize_size\n+      && num_compl_zero && CONST_7BIT_IMM_P (shifted_compl))\n+    {\n+      /* If optimizing for size, generate a sequence that has more instructions\n+\t but is shorter.  */\n+      emit_insn (gen_movsi (operands[0], GEN_INT (shifted_compl)));\n+      emit_insn (gen_ashlsi3 (operands[0], operands[0],\n+\t\t\t      GEN_INT (num_compl_zero)));\n+      emit_insn (gen_one_cmplsi2 (operands[0], operands[0]));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\f\n+/* Return true if the legitimate memory address for a memory operand of mode\n+   MODE.  Return false if not.  */\n+\n+static bool\n+bfin_valid_add (enum machine_mode mode, HOST_WIDE_INT value)\n+{\n+  unsigned HOST_WIDE_INT v = value > 0 ? value : -value;\n+  int sz = GET_MODE_SIZE (mode);\n+  int shift = sz == 1 ? 0 : sz == 2 ? 1 : 2;\n+  /* The usual offsettable_memref machinery doesn't work so well for this\n+     port, so we deal with the problem here.  */\n+  unsigned HOST_WIDE_INT mask = sz == 8 ? 0x7ffe : 0x7fff;\n+  return (v & ~(mask << shift)) == 0;\n+}\n+\n+static bool\n+bfin_valid_reg_p (unsigned int regno, int strict)\n+{\n+  return ((strict && REGNO_OK_FOR_BASE_STRICT_P (regno))\n+\t  || (!strict && REGNO_OK_FOR_BASE_NONSTRICT_P (regno)));\n+}\n+\n+bool\n+bfin_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+{\n+  switch (GET_CODE (x)) {\n+  case REG:\n+    if (bfin_valid_reg_p (REGNO (x), strict))\n+      return true;\n+    break;\n+  case PLUS:\n+    if (REG_P (XEXP (x, 0))\n+\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict)\n+\t&& (GET_CODE (XEXP (x, 1)) == UNSPEC\n+\t    || (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t&& bfin_valid_add (mode, INTVAL (XEXP (x, 1))))))\n+      return true;\n+    break;\n+  case POST_INC:\n+  case POST_DEC:\n+    if (LEGITIMATE_MODE_FOR_AUTOINC_P (mode)\n+\t&& REG_P (XEXP (x, 0))\n+\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict))\n+      return true;\n+  case PRE_DEC:\n+    if (LEGITIMATE_MODE_FOR_AUTOINC_P (mode)\n+\t&& XEXP (x, 0) == stack_pointer_rtx\n+\t&& REG_P (XEXP (x, 0))\n+\t&& bfin_valid_reg_p (REGNO (XEXP (x, 0)), strict))\n+      return true;\n+    break;\n+  default:\n+    break;\n+  }\n+  return false;\n+}\n+\n+static bool\n+bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  int cost2 = COSTS_N_INSNS (1);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (outer_code == SET || outer_code == PLUS)\n+        *total = CONST_7BIT_IMM_P (INTVAL (x)) ? 0 : cost2;\n+      else if (outer_code == AND)\n+        *total = log2constp (~INTVAL (x)) ? 0 : cost2;\n+      else if (outer_code == LE || outer_code == LT || outer_code == EQ)\n+        *total = (INTVAL (x) >= -4 && INTVAL (x) <= 3) ? 0 : cost2;\n+      else if (outer_code == LEU || outer_code == LTU)\n+        *total = (INTVAL (x) >= 0 && INTVAL (x) <= 7) ? 0 : cost2;\n+      else if (outer_code == MULT)\n+        *total = (INTVAL (x) == 2 || INTVAL (x) == 4) ? 0 : cost2;\n+      else if (outer_code == ASHIFT && (INTVAL (x) == 1 || INTVAL (x) == 2))\n+        *total = 0;\n+      else if (outer_code == ASHIFT || outer_code == ASHIFTRT\n+\t       || outer_code == LSHIFTRT)\n+        *total = (INTVAL (x) >= 0 && INTVAL (x) <= 31) ? 0 : cost2;\n+      else if (outer_code == IOR || outer_code == XOR)\n+        *total = (INTVAL (x) & (INTVAL (x) - 1)) == 0 ? 0 : cost2;\n+      else\n+\t*total = cost2;\n+      return true;\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case PLUS:\n+      if (GET_MODE (x) == Pmode)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == MULT\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\t    {\n+\t      HOST_WIDE_INT val = INTVAL (XEXP (XEXP (x, 0), 1));\n+\t      if (val == 2 || val == 4)\n+\t\t{\n+\t\t  *total = cost2;\n+\t\t  *total += rtx_cost (XEXP (XEXP (x, 0), 0), outer_code);\n+\t\t  *total += rtx_cost (XEXP (x, 1), outer_code);\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* fall through */\n+\n+    case MINUS:\n+    case ASHIFT: \n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (GET_MODE (x) == DImode)\n+\t*total = 6 * cost2;\n+      return false;\n+\t  \n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (GET_MODE (x) == DImode)\n+\t*total = 2 * cost2;\n+      return false;\n+\n+    case MULT:\n+      if (GET_MODE_SIZE (GET_MODE (x)) <= UNITS_PER_WORD)\n+\t*total = COSTS_N_INSNS (3);\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+static void\n+bfin_internal_label (FILE *stream, const char *prefix, unsigned long num)\n+{\n+  fprintf (stream, \"%s%s$%ld:\\n\", LOCAL_LABEL_PREFIX, prefix, num);\n+}\n+\f\n+/* Used for communication between {push,pop}_multiple_operation (which\n+   we use not only as a predicate) and the corresponding output functions.  */\n+static int first_preg_to_save, first_dreg_to_save;\n+\n+int\n+push_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int lastdreg = 8, lastpreg = 6;\n+  int i, group;\n+\n+  first_preg_to_save = lastpreg;\n+  first_dreg_to_save = lastdreg;\n+  for (i = 1, group = 0; i < XVECLEN (op, 0) - 1; i++)\n+    {\n+      rtx t = XVECEXP (op, 0, i);\n+      rtx src, dest;\n+      int regno;\n+\n+      if (GET_CODE (t) != SET)\n+\treturn 0;\n+\n+      src = SET_SRC (t);\n+      dest = SET_DEST (t);\n+      if (GET_CODE (dest) != MEM || ! REG_P (src))\n+\treturn 0;\n+      dest = XEXP (dest, 0);\n+      if (GET_CODE (dest) != PLUS\n+\t  || ! REG_P (XEXP (dest, 0))\n+\t  || REGNO (XEXP (dest, 0)) != REG_SP\n+\t  || GET_CODE (XEXP (dest, 1)) != CONST_INT\n+\t  || INTVAL (XEXP (dest, 1)) != -i * 4)\n+\treturn 0;\n+\n+      regno = REGNO (src);\n+      if (group == 0)\n+\t{\n+\t  if (D_REGNO_P (regno))\n+\t    {\n+\t      group = 1;\n+\t      first_dreg_to_save = lastdreg = regno - REG_R0;\n+\t    }\n+\t  else if (regno >= REG_P0 && regno <= REG_P7)\n+\t    {\n+\t      group = 2;\n+\t      first_preg_to_save = lastpreg = regno - REG_P0;\n+\t    }\n+\t  else\n+\t    return 0;\n+\n+\t  continue;\n+\t}\n+\n+      if (group == 1)\n+\t{\n+\t  if (regno >= REG_P0 && regno <= REG_P7)\n+\t    {\n+\t      group = 2;\n+\t      first_preg_to_save = lastpreg = regno - REG_P0;\n+\t    }\n+\t  else if (regno != REG_R0 + lastdreg + 1)\n+\t    return 0;\n+\t  else\n+\t    lastdreg++;\n+\t}\n+      else if (group == 2)\n+\t{\n+\t  if (regno != REG_P0 + lastpreg + 1)\n+\t    return 0;\n+\t  lastpreg++;\n+\t}\n+    }\n+  return 1;\n+}\n+\n+int\n+pop_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  int lastdreg = 8, lastpreg = 6;\n+  int i, group;\n+\n+  for (i = 1, group = 0; i < XVECLEN (op, 0); i++)\n+    {\n+      rtx t = XVECEXP (op, 0, i);\n+      rtx src, dest;\n+      int regno;\n+\n+      if (GET_CODE (t) != SET)\n+\treturn 0;\n+\n+      src = SET_SRC (t);\n+      dest = SET_DEST (t);\n+      if (GET_CODE (src) != MEM || ! REG_P (dest))\n+\treturn 0;\n+      src = XEXP (src, 0);\n+\n+      if (i == 1)\n+\t{\n+\t  if (! REG_P (src) || REGNO (src) != REG_SP)\n+\t    return 0;\n+\t}\n+      else if (GET_CODE (src) != PLUS\n+\t       || ! REG_P (XEXP (src, 0))\n+\t       || REGNO (XEXP (src, 0)) != REG_SP\n+\t       || GET_CODE (XEXP (src, 1)) != CONST_INT\n+\t       || INTVAL (XEXP (src, 1)) != (i - 1) * 4)\n+\treturn 0;\n+\n+      regno = REGNO (dest);\n+      if (group == 0)\n+\t{\n+\t  if (regno == REG_R7)\n+\t    {\n+\t      group = 1;\n+\t      lastdreg = 7;\n+\t    }\n+\t  else if (regno != REG_P0 + lastpreg - 1)\n+\t    return 0;\n+\t  else\n+\t    lastpreg--;\n+\t}\n+      else if (group == 1)\n+\t{\n+\t  if (regno != REG_R0 + lastdreg - 1)\n+\t    return 0;\n+\t  else\n+\t    lastdreg--;\n+\t}\n+    }\n+  first_dreg_to_save = lastdreg;\n+  first_preg_to_save = lastpreg;\n+  return 1;\n+}\n+\n+/* Emit assembly code for one multi-register push described by INSN, with\n+   operands in OPERANDS.  */\n+\n+void\n+output_push_multiple (rtx insn, rtx *operands)\n+{\n+  char buf[80];\n+  /* Validate the insn again, and compute first_[dp]reg_to_save. */\n+  if (! push_multiple_operation (PATTERN (insn), VOIDmode))\n+    abort ();\n+  if (first_dreg_to_save == 8)\n+    sprintf (buf, \"[--sp] = ( p5:%d );\\n\", first_preg_to_save);\n+  else if (first_preg_to_save == 6)\n+    sprintf (buf, \"[--sp] = ( r7:%d );\\n\", first_dreg_to_save);\n+  else\n+    sprintf (buf, \"[--sp] = ( r7:%d, p5:%d );\\n\", first_dreg_to_save, first_preg_to_save);\n+\n+  output_asm_insn (buf, operands);\n+}\n+\n+/* Emit assembly code for one multi-register pop described by INSN, with\n+   operands in OPERANDS.  */\n+\n+void\n+output_pop_multiple (rtx insn, rtx *operands)\n+{\n+  char buf[80];\n+  /* Validate the insn again, and compute first_[dp]reg_to_save. */\n+  if (! pop_multiple_operation (PATTERN (insn), VOIDmode))\n+    abort ();\n+\n+  if (first_dreg_to_save == 8)\n+    sprintf (buf, \"( p5:%d ) = [sp++];\\n\", first_preg_to_save);\n+  else if (first_preg_to_save == 6)\n+    sprintf (buf, \"( r7:%d ) = [sp++];\\n\", first_dreg_to_save);\n+  else\n+    sprintf (buf, \"( r7:%d, p5:%d ) = [sp++];\\n\", first_dreg_to_save, first_preg_to_save);\n+\n+  output_asm_insn (buf, operands);\n+}\n+\n+/* Adjust DST and SRC by OFFSET bytes, and generate one move in mode MODE.  */\n+\n+static void\n+single_move_for_strmov (rtx dst, rtx src, enum machine_mode mode, HOST_WIDE_INT offset)\n+{\n+  rtx scratch = gen_reg_rtx (mode);\n+  rtx srcmem, dstmem;\n+\n+  srcmem = adjust_address_nv (src, mode, offset);\n+  dstmem = adjust_address_nv (dst, mode, offset);\n+  emit_move_insn (scratch, srcmem);\n+  emit_move_insn (dstmem, scratch);\n+}\n+\n+/* Expand a string move operation of COUNT_EXP bytes from SRC to DST, with\n+   alignment ALIGN_EXP.  Return true if successful, false if we should fall\n+   back on a different method.  */\n+\n+bool\n+bfin_expand_strmov (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n+{\n+  rtx srcreg, destreg, countreg;\n+  HOST_WIDE_INT align = 0;\n+  unsigned HOST_WIDE_INT count = 0;\n+\n+  if (GET_CODE (align_exp) == CONST_INT)\n+    align = INTVAL (align_exp);\n+  if (GET_CODE (count_exp) == CONST_INT)\n+    {\n+      count = INTVAL (count_exp);\n+#if 0\n+      if (!TARGET_INLINE_ALL_STRINGOPS && count > 64)\n+\treturn false;\n+#endif\n+    }\n+\n+  /* If optimizing for size, only do single copies inline.  */\n+  if (optimize_size)\n+    {\n+      if (count == 2 && align < 2)\n+\treturn false;\n+      if (count == 4 && align < 4)\n+\treturn false;\n+      if (count != 1 && count != 2 && count != 4)\n+\treturn false;\n+    }\n+  if (align < 2 && count != 1)\n+    return false;\n+\n+  destreg = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n+  if (destreg != XEXP (dst, 0))\n+    dst = replace_equiv_address_nv (dst, destreg);\n+  srcreg = copy_to_mode_reg (Pmode, XEXP (src, 0));\n+  if (srcreg != XEXP (src, 0))\n+    src = replace_equiv_address_nv (src, srcreg);\n+\n+  if (count != 0 && align >= 2)\n+    {\n+      unsigned HOST_WIDE_INT offset = 0;\n+\n+      if (align >= 4)\n+\t{\n+\t  if ((count & ~3) == 4)\n+\t    {\n+\t      single_move_for_strmov (dst, src, SImode, offset);\n+\t      offset = 4;\n+\t    }\n+\t  else if (count & ~3)\n+\t    {\n+\t      HOST_WIDE_INT new_count = ((count >> 2) & 0x3fffffff) - 1;\n+\t      countreg = copy_to_mode_reg (Pmode, GEN_INT (new_count));\n+\n+\t      emit_insn (gen_rep_movsi (destreg, srcreg, countreg, destreg, srcreg));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if ((count & ~1) == 2)\n+\t    {\n+\t      single_move_for_strmov (dst, src, HImode, offset);\n+\t      offset = 2;\n+\t    }\n+\t  else if (count & ~1)\n+\t    {\n+\t      HOST_WIDE_INT new_count = ((count >> 1) & 0x7fffffff) - 1;\n+\t      countreg = copy_to_mode_reg (Pmode, GEN_INT (new_count));\n+\n+\t      emit_insn (gen_rep_movhi (destreg, srcreg, countreg, destreg, srcreg));\n+\t    }\n+\t}\n+      if (count & 2)\n+\t{\n+\t  single_move_for_strmov (dst, src, HImode, offset);\n+\t  offset += 2;\n+\t}\n+      if (count & 1)\n+\t{\n+\t  single_move_for_strmov (dst, src, QImode, offset);\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\f\n+static int\n+bfin_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n+{\n+  enum attr_type insn_type, dep_insn_type;\n+  int dep_insn_code_number;\n+\n+  /* Anti and output dependencies have zero cost.  */\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;\n+\n+  dep_insn_code_number = recog_memoized (dep_insn);\n+\n+  /* If we can't recognize the insns, we can't really do anything.  */\n+  if (dep_insn_code_number < 0 || recog_memoized (insn) < 0)\n+    return cost;\n+\n+  insn_type = get_attr_type (insn);\n+  dep_insn_type = get_attr_type (dep_insn);\n+\n+  if (dep_insn_type == TYPE_MOVE || dep_insn_type == TYPE_MCLD)\n+    {\n+      rtx pat = PATTERN (dep_insn);\n+      rtx dest = SET_DEST (pat);\n+      rtx src = SET_SRC (pat);\n+      if (! ADDRESS_REGNO_P (REGNO (dest)) || ! D_REGNO_P (REGNO (src)))\n+\treturn cost;\n+      return cost + (dep_insn_type == TYPE_MOVE ? 4 : 3);\n+    }\n+\n+  return cost;\n+}\n+\f\n+/* We use the machine specific reorg pass for emitting CSYNC instructions\n+   after conditional branches as needed.\n+\n+   The Blackfin is unusual in that a code sequence like\n+     if cc jump label\n+     r0 = (p0)\n+   may speculatively perform the load even if the condition isn't true.  This\n+   happens for a branch that is predicted not taken, because the pipeline\n+   isn't flushed or stalled, so the early stages of the following instructions,\n+   which perform the memory reference, are allowed to execute before the\n+   jump condition is evaluated.\n+   Therefore, we must insert additional instructions in all places where this\n+   could lead to incorrect behaviour.  The manual recommends CSYNC, while\n+   VDSP seems to use NOPs (even though its corresponding compiler option is\n+   named CSYNC).\n+\n+   When optimizing for speed, we emit NOPs, which seems faster than a CSYNC.\n+   When optimizing for size, we turn the branch into a predicted taken one.\n+   This may be slower due to mispredicts, but saves code size.  */\n+\n+static void\n+bfin_reorg (void)\n+{\n+  rtx insn, last_condjump = NULL_RTX;\n+  int cycles_since_jump = INT_MAX;\n+\n+  if (! TARGET_CSYNC)\n+    return;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      if (NOTE_P (insn) || BARRIER_P (insn) || LABEL_P (insn))\n+\tcontinue;\n+\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t  || GET_CODE (pat) == ASM_INPUT || GET_CODE (pat) == ADDR_VEC\n+\t  || GET_CODE (pat) == ADDR_DIFF_VEC || asm_noperands (pat) >= 0)\n+\tcontinue;\n+\n+      if (JUMP_P (insn))\n+\t{\n+\t  if (any_condjump_p (insn)\n+\t      && ! cbranch_predicted_taken_p (insn))\n+\t    {\n+\t      last_condjump = insn;\n+\t      cycles_since_jump = 0;\n+\t    }\n+\t  else\n+\t    cycles_since_jump = INT_MAX;\n+\t}\n+      else if (INSN_P (insn))\n+\t{\n+\t  enum attr_type type = get_attr_type (insn);\n+\t  if (cycles_since_jump < INT_MAX)\n+\t    cycles_since_jump++;\n+\n+\t  if (type == TYPE_MCLD && cycles_since_jump < 3)\n+\t    {\n+\t      rtx pat;\n+\n+\t      pat = single_set (insn);\n+\t      if (may_trap_p (SET_SRC (pat)))\n+\t\t{\n+\t\t  int num_clobbers;\n+\t\t  rtx *op = recog_data.operand;\n+\n+\t\t  extract_insn (last_condjump);\n+\t\t  if (optimize_size)\n+\t\t    pat = gen_cbranch_predicted_taken (op[0], op[1], op[2],\n+\t\t\t\t\t\t       op[3]);\n+\t\t  else\n+\t\t    pat = gen_cbranch_with_nops (op[0], op[1], op[2], op[3],\n+\t\t\t\t\t\t GEN_INT (3 - cycles_since_jump));\n+\t\t  PATTERN (last_condjump) = pat;\n+\t\t  INSN_CODE (last_condjump) = recog (pat, insn, &num_clobbers);\n+\t\t  cycles_since_jump = INT_MAX;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\f\n+/* Handle interrupt_handler, exception_handler and nmi_handler function\n+   attributes; arguments as in struct attribute_spec.handler.  */\n+\n+static tree\n+handle_int_attribute (tree *node, tree name,\n+\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t      bool *no_add_attrs)\n+{\n+  tree x = *node;\n+  if (TREE_CODE (x) == FUNCTION_DECL)\n+    x = TREE_TYPE (x);\n+\n+  if (TREE_CODE (x) != FUNCTION_TYPE)\n+    {\n+      warning (\"%qs attribute only applies to functions\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (funkind (x) != SUBROUTINE)\n+    error (\"multiple function type attributes specified\");\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return 0 if the attributes for two types are incompatible, 1 if they\n+   are compatible, and 2 if they are nearly compatible (which causes a\n+   warning to be generated).  */\n+\n+static int\n+bfin_comp_type_attributes (tree type1, tree type2)\n+{\n+  e_funkind kind1, kind2;\n+\n+  if (TREE_CODE (type1) != FUNCTION_TYPE)\n+    return 1;\n+\n+  kind1 = funkind (type1);\n+  kind2 = funkind (type2);\n+\n+  if (kind1 != kind2)\n+    return 0;\n+  \n+  /*  Check for mismatched modifiers */\n+  if (!lookup_attribute (\"nesting\", TYPE_ATTRIBUTES (type1))\n+      != !lookup_attribute (\"nesting\", TYPE_ATTRIBUTES (type2)))\n+    return 0;\n+\n+  if (!lookup_attribute (\"saveall\", TYPE_ATTRIBUTES (type1))\n+      != !lookup_attribute (\"saveall\", TYPE_ATTRIBUTES (type2)))\n+    return 0;\n+\n+  if (!lookup_attribute (\"kspisusp\", TYPE_ATTRIBUTES (type1))\n+      != !lookup_attribute (\"kspisusp\", TYPE_ATTRIBUTES (type2)))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Table of valid machine attributes.  */\n+const struct attribute_spec bfin_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, false, true,  true, handle_int_attribute },\n+  { \"exception_handler\", 0, 0, false, true,  true, handle_int_attribute },\n+  { \"nmi_handler\", 0, 0, false, true,  true, handle_int_attribute },\n+  { \"nesting\", 0, 0, false, true,  true, NULL },\n+  { \"kspisusp\", 0, 0, false, true,  true, NULL },\n+  { \"saveall\", 0, 0, false, true,  true, NULL },\n+  { NULL, 0, 0, false, false, false, NULL }\n+};\n+\f\n+/* Output the assembler code for a thunk function.  THUNK_DECL is the\n+   declaration for the thunk function itself, FUNCTION is the decl for\n+   the target function.  DELTA is an immediate constant offset to be\n+   added to THIS.  If VCALL_OFFSET is nonzero, the word at\n+   *(*this + vcall_offset) should be added to THIS.  */\n+\n+static void\n+bfin_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n+\t\t      tree thunk ATTRIBUTE_UNUSED, HOST_WIDE_INT delta,\n+\t\t      HOST_WIDE_INT vcall_offset, tree function)\n+{\n+  rtx xops[3];\n+  /* The this parameter is passed as the first argument.  */\n+  rtx this = gen_rtx_REG (Pmode, REG_R0);\n+\n+  /* Adjust the this parameter by a fixed constant.  */\n+  if (delta)\n+    {\n+      xops[1] = this;\n+      if (delta >= -64 && delta <= 63)\n+\t{\n+\t  xops[0] = GEN_INT (delta);\n+\t  output_asm_insn (\"%1 += %0;\", xops);\n+\t}\n+      else if (delta >= -128 && delta < -64)\n+\t{\n+\t  xops[0] = GEN_INT (delta + 64);\n+\t  output_asm_insn (\"%1 += -64; %1 += %0;\", xops);\n+\t}\n+      else if (delta > 63 && delta <= 126)\n+\t{\n+\t  xops[0] = GEN_INT (delta - 63);\n+\t  output_asm_insn (\"%1 += 63; %1 += %0;\", xops);\n+\t}\n+      else\n+\t{\n+\t  xops[0] = GEN_INT (delta);\n+\t  output_asm_insn (\"r3.l = %h0; r3.h = %d0; %1 = %1 + r3;\", xops);\n+\t}\n+    }\n+\n+  /* Adjust the this parameter by a value stored in the vtable.  */\n+  if (vcall_offset)\n+    {\n+      rtx p2tmp = gen_rtx_REG (Pmode, REG_P2);\n+      rtx tmp = gen_rtx_REG (Pmode, REG_R2);\n+\n+      xops[1] = tmp;\n+      xops[2] = p2tmp;\n+      output_asm_insn (\"%2 = r0; %2 = [%2];\", xops);\n+\n+      /* Adjust the this parameter.  */\n+      xops[0] = gen_rtx_MEM (Pmode, plus_constant (p2tmp, vcall_offset));\n+      if (!memory_operand (xops[0], Pmode))\n+\t{\n+\t  rtx tmp2 = gen_rtx_REG (Pmode, REG_P1);\n+\t  xops[0] = GEN_INT (vcall_offset);\n+\t  xops[1] = tmp2;\n+\t  output_asm_insn (\"%h1 = %h0; %d1 = %d0; %2 = %2 + %1\", xops);\n+\t  xops[0] = gen_rtx_MEM (Pmode, p2tmp);\n+\t}\n+      xops[2] = this;\n+      output_asm_insn (\"%1 = %0; %2 = %2 + %1;\", xops);\n+    }\n+\n+  xops[0] = XEXP (DECL_RTL (function), 0);\n+  if (1 || !flag_pic || (*targetm.binds_local_p) (function))\n+    output_asm_insn (\"jump.l\\t%P0\", xops);\n+}\n+\f\n+#undef TARGET_ASM_GLOBALIZE_LABEL\n+#define TARGET_ASM_GLOBALIZE_LABEL bfin_globalize_label \n+\n+#undef TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START output_file_start\n+\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE bfin_attribute_table\n+\n+#undef TARGET_COMP_TYPE_ATTRIBUTES\n+#define TARGET_COMP_TYPE_ATTRIBUTES bfin_comp_type_attributes\n+\n+#undef TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS bfin_rtx_costs\n+\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST bfin_address_cost\n+\n+#undef TARGET_ASM_INTERNAL_LABEL\n+#define TARGET_ASM_INTERNAL_LABEL bfin_internal_label\n+\n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG bfin_reorg\n+\n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL bfin_function_ok_for_sibcall\n+\n+#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#define TARGET_ASM_OUTPUT_MI_THUNK bfin_output_mi_thunk\n+#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_true\n+\n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST bfin_adjust_cost\n+\n+#undef TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n+#undef TARGET_PROMOTE_FUNCTION_ARGS\n+#define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_true\n+#undef TARGET_PROMOTE_FUNCTION_RETURN\n+#define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true\n+\n+#undef TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES bfin_arg_partial_bytes\n+\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE bfin_pass_by_reference\n+\n+#undef TARGET_SETUP_INCOMING_VARARGS\n+#define TARGET_SETUP_INCOMING_VARARGS setup_incoming_varargs\n+\n+#undef TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX bfin_struct_value_rtx\n+\n+#undef TARGET_VECTOR_MODE_SUPPORTED_P\n+#define TARGET_VECTOR_MODE_SUPPORTED_P bfin_vector_mode_supported_p\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "d52d407726508527c700fc186cfac1e22d80a455", "filename": "gcc/config/bfin/bfin.h", "status": "added", "additions": 1168, "deletions": 0, "changes": 1168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,1168 @@\n+/* Definitions for the Blackfin port.\n+   Copyright (C) 2005  Free Software Foundation, Inc.\n+   Contributed by Analog Devices.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _BFIN_CONFIG\n+#define _BFIN_CONFIG\n+\n+#define OBJECT_FORMAT_ELF\n+\n+#define BRT 1\n+#define BRF 0\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (BlackFin bfin)\")\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Predefinition in the preprocessor for this target machine */\n+#ifndef TARGET_CPU_CPP_BUILTINS\n+#define TARGET_CPU_CPP_BUILTINS()               \\\n+  do                                            \\\n+    {                                           \\\n+      builtin_define (\"bfin\");                  \\\n+      builtin_define (\"BFIN\");                  \\\n+    }                                           \\\n+  while (0)\n+#endif\n+\n+/* Generate DSP instructions, like DSP halfword loads */\n+#define TARGET_DSP\t\t\t(1)\n+\n+#define TARGET_DEFAULT MASK_CSYNC\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable.  The\n+   variable, type `char *', is set to the variable part of the given\n+   option if the fixed part matches.  The actual option name is made\n+   by appending `-m' to the specified name.  */\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{ { \"shared-library-id=\",\t&bfin_library_id_string,\t\t\\\n+    \"ID of shared library to build\", 0}\t\t\t\t\t\\\n+}\n+\n+/* Maximum number of library ids we permit */\n+#define MAX_LIBRARY_ID 255\n+\n+extern const char *bfin_library_id_string;\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+ \n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+ \n+#define OVERRIDE_OPTIONS override_options ()\n+\n+#define FUNCTION_MODE    SImode\n+#define Pmode            SImode\n+\n+/* store-condition-codes instructions store 0 for false\n+   This is the value stored for true.  */\n+#define STORE_FLAG_VALUE 1\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+#define STACK_PUSH_CODE PRE_DEC\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* We define a dummy ARGP register; the parameters start at offset 0 from\n+   it. */\n+#define FIRST_PARM_OFFSET(DECL) 0\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM REG_P6\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM REG_P7\n+\n+/* A dummy register that will be eliminated to either FP or SP.  */\n+#define ARG_POINTER_REGNUM REG_ARGP\n+\n+/* `PIC_OFFSET_TABLE_REGNUM'\n+     The register number of the register used to address a table of\n+     static data addresses in memory.  In some cases this register is\n+     defined by a processor's \"application binary interface\" (ABI).\n+     When this macro is defined, RTL is generated for this register\n+     once, as with the stack pointer and frame pointer registers.  If\n+     this macro is not defined, it is up to the machine-dependent files\n+     to allocate such a register (if necessary). */\n+#define PIC_OFFSET_TABLE_REGNUM (REG_P5)\n+\n+/* A static chain register for nested functions.  We need to use a\n+   call-clobbered register for this.  */\n+#define STATIC_CHAIN_REGNUM REG_P2\n+\n+/* Define this if functions should assume that stack space has been\n+   allocated for arguments even when their values are passed in\n+   registers.\n+\n+   The value of this macro is the size, in bytes, of the area reserved for\n+   arguments passed in registers.\n+\n+   This space can either be allocated by the caller or be a part of the\n+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'\n+   says which.  */\n+#define FIXED_STACK_AREA 12\n+#define REG_PARM_STACK_SPACE(FNDECL) FIXED_STACK_AREA\n+\n+/* Define this if the above stack space is to be considered part of the\n+ * space allocated by the caller.  */\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\t  \n+/* Define this if the maximum size of all the outgoing args is to be\n+   accumulated and pushed during the prologue.  The amount can be\n+   found in the variable current_function_outgoing_args_size. */ \n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  \n+*/\n+#define FRAME_POINTER_REQUIRED (bfin_frame_pointer_required ())\n+\n+#define PARM_BOUNDRY            32\n+\n+#define STACK_BOUNDRY           32\n+\n+/*#define DATA_ALIGNMENT(TYPE, BASIC-ALIGN) for arrays.. */\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST        \\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))    \n+\n+#define TRAMPOLINE_SIZE 18\n+#define TRAMPOLINE_TEMPLATE(FILE)                                       \\\n+  fprintf(FILE, \"\\t.dd\\t0x0000e109\\n\"); /* p1.l = fn low */\t\t\\\n+  fprintf(FILE, \"\\t.dd\\t0x0000e149\\n\"); /* p1.h = fn high */;\t\t\\\n+  fprintf(FILE, \"\\t.dd\\t0x0000e10a\\n\"); /* p2.l = sc low */;\t\t\\\n+  fprintf(FILE, \"\\t.dd\\t0x0000e14a\\n\"); /* p2.h = sc high */;\t\t\\\n+  fprintf(FILE, \"\\t.dw\\t0x0051\\n\"); /* jump (p1)*/\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+  initialize_trampoline (TRAMP, FNADDR, CXT)\n+\f\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   There are two registers that can always be eliminated on the i386.\n+   The frame pointer and the arg pointer can be replaced by either the\n+   hard frame pointer or to the stack pointer, depending upon the\n+   circumstances.  The hard frame pointer is not used before reload and\n+   so it is not eligible for elimination.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\t\\\n+\n+/* Given FROM and TO register numbers, say whether this elimination is\n+   allowed.  Frame pointer elimination is automatically handled.\n+\n+   All other eliminations are valid.  */\n+\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  ((TO) == STACK_POINTER_REGNUM ? ! frame_pointer_needed : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = bfin_initial_elimination_offset ((FROM), (TO)))\n+\f\n+/* This processor has\n+   8 data register for doing arithmetic\n+   8  pointer register for doing addressing, including\n+      1  stack pointer P6\n+      1  frame pointer P7\n+   4 sets of indexing registers (I0-3, B0-3, L0-3, M0-3)\n+   1  condition code flag register CC\n+   5  return address registers RETS/I/X/N/E\n+   1  arithmetic status register (ASTAT).  */\n+\n+#define FIRST_PSEUDO_REGISTER 44\n+\n+#define PREG_P(X) (REG_P (X) && REGNO (X) >= REG_P0 && REGNO (X) <= REG_P7)\n+#define ADDRESS_REGNO_P(X) ((X) >= REG_P0 && (X) <= REG_M3)\n+#define D_REGNO_P(X) ((X) <= REG_R7)\n+\n+#define REGISTER_NAMES { \\\n+  \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \\\n+  \"P0\", \"P1\", \"P2\", \"P3\", \"P4\", \"P5\", \"SP\", \"FP\", \\\n+  \"I0\", \"B0\", \"L0\", \"I1\", \"B1\", \"L1\", \"I2\", \"B2\", \\\n+  \"L2\", \"I3\", \"B3\", \"L3\", \"M0\", \"M1\", \"M2\", \"M3\", \\\n+  \"A0\", \"A1\", \\\n+  \"CC\", \\\n+  \"RETS\", \"RETI\", \"RETX\", \"RETN\", \"RETE\", \"ASTAT\", \"SEQSTAT\", \"USP\", \\\n+  \"ARGP\" \\\n+}\n+\n+#define SHORT_REGISTER_NAMES { \\\n+\t\"R0.L\",\t\"R1.L\",\t\"R2.L\",\t\"R3.L\", \"R4.L\", \"R5.L\", \"R6.L\", \"R7.L\", \\\n+\t\"P0.L\",\t\"P1.L\",\t\"P2.L\",\t\"P3.L\", \"P4.L\", \"P5.L\", \"SP.L\", \"FP.L\", \\\n+\t\"I0.L\",\t\"B0.L\", \"L0.L\",\t\"I1.L\",\t\"B1.L\",\t\"L1.L\",\t\"I2.L\",\t\"B2.L\", \\\n+\t\"L2.L\",\t\"I3.L\",\t\"B3.L\",\t\"L3.L\",\t\"M0.L\",\t\"M1.L\",\t\"M2.L\",\t\"M3.L\", }\n+\n+#define HIGH_REGISTER_NAMES { \\\n+\t\"R0.H\",\t\"R1.H\",\t\"R2.H\",\t\"R3.H\", \"R4.H\", \"R5.H\", \"R6.H\", \"R7.H\", \\\n+\t\"P0.H\",\t\"P1.H\",\t\"P2.H\",\t\"P3.H\", \"P4.H\", \"P5.H\", \"SP.H\", \"FP.H\", \\\n+\t\"I0.H\",\t\"B0.H\",\t\"L0.H\",\t\"I1.H\",\t\"B1.H\",\t\"L1.H\",\t\"I2.H\",\t\"B2.H\", \\\n+\t\"L2.H\",\t\"I3.H\",\t\"B3.H\",\t\"L3.H\",\t\"M0.H\",\t\"M1.H\",\t\"M2.H\",\t\"M3.H\", }\n+\n+#define DREGS_PAIR_NAMES { \\\n+  \"R1:0.p\", 0, \"R3:2.p\", 0, \"R5:4.p\", 0, \"R7:6.p\", 0,  }\n+\n+#define BYTE_REGISTER_NAMES { \\\n+  \"R0.B\", \"R1.B\", \"R2.B\", \"R3.B\", \"R4.B\", \"R5.B\", \"R6.B\", \"R7.B\",  }\n+\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+\n+#define FIXED_REGISTERS \\\n+/*r0 r1 r2 r3 r4 r5 r6 r7   p0 p1 p2 p3 p4 p5 p6 p7 */ \\\n+{ 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 1, 0,    \\\n+/*i0 b0 l0 i1 b1 l1 i2 b2   l2 i3 b3 l3 m0 m1 m2 m3 */ \\\n+  0, 0, 1, 0, 0, 1, 0, 0,   1, 0, 0, 1, 0, 0, 0, 0,    \\\n+/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp */ \\\n+  0, 0, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1\t \\\n+}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+/*r0 r1 r2 r3 r4 r5 r6 r7   p0 p1 p2 p3 p4 p5 p6 p7 */ \\\n+{ 1, 1, 1, 1, 0, 0, 0, 0,   1, 1, 1, 0, 0, 0, 1, 0, \\\n+/*i0 b0 l0 i1 b1 l1 i2 b2   l2 i3 b3 l3 m0 m1 m2 m3 */ \\\n+  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \\\n+/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp */ \\\n+  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1\t \\\n+}\n+\n+/* Order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.  List frame pointer\n+   late and fixed registers last.  Note that, in general, we prefer\n+   registers listed in CALL_USED_REGISTERS, keeping the others\n+   available for storage of persistent values. */\n+\n+#define REG_ALLOC_ORDER \\\n+{ REG_R0, REG_R1, REG_R2, REG_R3, REG_R7, REG_R6, REG_R5, REG_R4, \\\n+  REG_P2, REG_P1, REG_P0, REG_P5, REG_P4, REG_P3, REG_P6, REG_P7, \\\n+  REG_A0, REG_A1, \\\n+  REG_I0, REG_B0, REG_L0, REG_I1, REG_B1, REG_L1, REG_I2, REG_B2, \\\n+  REG_L2, REG_I3, REG_B3, REG_L3, REG_M0, REG_M1, REG_M2, REG_M3, \\\n+  REG_RETS, REG_RETI, REG_RETX, REG_RETN, REG_RETE,\t\t  \\\n+  REG_ASTAT, REG_SEQSTAT, REG_USP, \t\t\t\t  \\\n+  REG_CC, REG_ARGP\t\t\t\t\t\t  \\\n+}\n+\n+/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    conditional_register_usage();                       \\\n+    if (flag_pic)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union. */\n+\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  IREGS,\n+  BREGS,\n+  LREGS,\n+  MREGS,\n+  CIRCREGS, /* Circular buffering registers, Ix, Bx, Lx together form. See Automatic Circlur Buffering */\n+  DAGREGS,\n+  EVEN_AREGS,\n+  ODD_AREGS,\n+  AREGS,\n+  CCREGS,\n+  EVEN_DREGS,\n+  ODD_DREGS,\n+  DREGS,\n+  PREGS_CLOBBERED,\n+  PREGS,\n+  DPREGS,\n+  MOST_REGS,\n+  PROLOGUE_REGS,\n+  NON_A_CC_REGS,\n+  ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES ((int)LIM_REG_CLASSES)\n+\n+#define GENERAL_REGS DPREGS\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+{  \"NO_REGS\",\t\t\\\n+   \"IREGS\",\t\t\\\n+   \"BREGS\",\t\t\\\n+   \"LREGS\",\t\t\\\n+   \"MREGS\",\t\t\\\n+   \"CIRCREGS\",\t\t\\\n+   \"DAGREGS\",\t\t\\\n+   \"EVEN_AREGS\",\t\\\n+   \"ODD_AREGS\",\t\t\\\n+   \"AREGS\",\t\t\\\n+   \"CCREGS\",\t\t\\\n+   \"EVEN_DREGS\",\t\\\n+   \"ODD_DREGS\",\t\t\\\n+   \"DREGS\",\t\t\\\n+   \"PREGS_CLOBBERED\",\t\\\n+   \"PREGS\",\t\t\\\n+   \"DPREGS\",\t\t\\\n+   \"MOST_REGS\",\t\t\\\n+   \"PROLOGUE_REGS\",\t\\\n+   \"NON_A_CC_REGS\",\t\\\n+   \"ALL_REGS\" }\n+\n+/* An initializer containing the contents of the register classes, as integers\n+   which are bit masks.  The Nth integer specifies the contents of class N.\n+   The way the integer MASK is interpreted is that register R is in the class\n+   if `MASK & (1 << R)' is 1.\n+\n+   When the machine has more than 32 registers, an integer does not suffice.\n+   Then the integers are replaced by sub-initializers, braced groupings\n+   containing several integers.  Each sub-initializer must be suitable as an\n+   initializer for the type `HARD_REG_SET' which is defined in\n+   `hard-reg-set.h'.  */\n+\n+/* NOTE: DSP registers, IREGS - AREGS, are not GENERAL_REGS.  We use\n+   MOST_REGS as the union of DPREGS and DAGREGS.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+    /* 31 - 0       63-32   */ \\\n+{   { 0x00000000,    0 },\t\t/* NO_REGS */\t\\\n+    { 0x02490000,    0 },\t\t/* IREGS */\t\\\n+    { 0x04920000,    0 },\t\t/* BREGS */\t\t\\\n+    { 0x09240000,    0 },\t\t/* LREGS */\t\\\n+    { 0xf0000000,    0 },\t\t/* MREGS */   \\\n+    { 0x0fff0000,    0 },\t\t/* CIRCREGS */   \\\n+    { 0xffff0000,    0 },\t\t/* DAGREGS */   \\\n+    { 0x00000000,    0x1 },\t\t/* EVEN_AREGS */   \\\n+    { 0x00000000,    0x2 },\t\t/* ODD_AREGS */   \\\n+    { 0x00000000,    0x3 },\t\t/* AREGS */   \\\n+    { 0x00000000,    0x4 },\t\t/* CCREGS */  \\\n+    { 0x00000055,    0 },\t\t/* EVEN_DREGS */   \\\n+    { 0x000000aa,    0 },\t\t/* ODD_DREGS */   \\\n+    { 0x000000ff,    0 },\t\t/* DREGS */   \\\n+    { 0x00004700,    0x800 },\t\t/* PREGS_CLOBBERED */   \\\n+    { 0x0000ff00,    0x800 },\t\t/* PREGS */   \\\n+    { 0x0000ffff,    0x800 },\t\t/* DPREGS */   \\\n+    { 0xffffffff,    0x800 },\t\t/* MOST_REGS */\\\n+    { 0x00000000,    0x7f8 },\t\t/* PROLOGUE_REGS */\\\n+    { 0xffffffff,    0xff8 },\t\t/* NON_A_CC_REGS */\\\n+    { 0xffffffff,    0xfff }}\t\t/* ALL_REGS */\n+\n+#define BASE_REG_CLASS          PREGS\n+#define INDEX_REG_CLASS         PREGS\n+\n+#define REGNO_OK_FOR_BASE_STRICT_P(X) (REGNO_REG_CLASS (X) == BASE_REG_CLASS)\n+#define REGNO_OK_FOR_BASE_NONSTRICT_P(X)  \\\n+ (((X) >= FIRST_PSEUDO_REGISTER) || REGNO_REG_CLASS (X) == BASE_REG_CLASS)\n+\n+#ifdef REG_OK_STRICT\n+#define REGNO_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_STRICT_P (X)\n+#else\n+#define REGNO_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_NONSTRICT_P (X)\n+#endif\n+\n+#define REG_OK_FOR_BASE_P(X)    (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n+#define REG_OK_FOR_INDEX_P(X)   0\n+#define REGNO_OK_FOR_INDEX_P(X)   0\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(LETTER)\t\\\n+  ((LETTER) == 'a' ? PREGS :            \\\n+   (LETTER) == 'd' ? DREGS : \t\t\\\n+   (LETTER) == 'z' ? PREGS_CLOBBERED :\t\\\n+   (LETTER) == 'D' ? EVEN_DREGS : \t\\\n+   (LETTER) == 'W' ? ODD_DREGS : \t\\\n+   (LETTER) == 'e' ? AREGS : \t\t\\\n+   (LETTER) == 'A' ? EVEN_AREGS : \t\\\n+   (LETTER) == 'B' ? ODD_AREGS : \t\\\n+   (LETTER) == 'b' ? IREGS :            \\\n+   (LETTER) == 'B' ? BREGS :            \\\n+   (LETTER) == 'f' ? MREGS : \t\t\\\n+   (LETTER) == 'c' ? CIRCREGS :         \\\n+   (LETTER) == 'C' ? CCREGS : \t\t\\\n+   (LETTER) == 'x' ? MOST_REGS :\t\\\n+   (LETTER) == 'y' ? PROLOGUE_REGS :\t\\\n+   (LETTER) == 'w' ? NON_A_CC_REGS :\t\\\n+   NO_REGS)\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+ ((REGNO) < REG_P0 ? DREGS\t\t\t\t\\\n+ : (REGNO) < REG_I0 ? PREGS\t\t\t\t\\\n+ : (REGNO) == REG_ARGP ? BASE_REG_CLASS\t\t\t\\\n+ : (REGNO) >= REG_I0 && (REGNO) <= REG_I3 ? IREGS\t\\\n+ : (REGNO) >= REG_L0 && (REGNO) <= REG_L3 ? LREGS\t\\\n+ : (REGNO) >= REG_B0 && (REGNO) <= REG_B3 ? BREGS\t\\\n+ : (REGNO) >= REG_M0 && (REGNO) <= REG_M3 ? MREGS\t\\\n+ : (REGNO) == REG_A0 || (REGNO) == REG_A1 ? AREGS\t\\\n+ : (REGNO) == REG_CC ? CCREGS\t\t\t\t\\\n+ : (REGNO) >= REG_RETS ? PROLOGUE_REGS\t\t\t\\\n+ : NO_REGS)\n+\n+/* When defined, the compiler allows registers explicitly used in the\n+   rtl to be used as spill registers but prevents the compiler from\n+   extending the lifetime of these registers. */\n+#define SMALL_REGISTER_CLASSES 1\n+\n+#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n+    ((CLASS) == PREGS_CLOBBERED \\\n+     || (CLASS) == PROLOGUE_REGS \\\n+     || (CLASS) == CCREGS)\n+\n+/* Do not allow to store a value in REG_CC for any mode */\n+/* Do not allow to store value in pregs if mode is not SI*/\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok((REGNO), (MODE))\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+((MODE) == PDImode && ((REGNO) == REG_A0 || (REGNO) == REG_A1) \\\n+ ? 1 : CLASS_MAX_NREGS (GENERAL_REGS, MODE))\n+\n+/* A C expression that is nonzero if hard register TO can be\n+   considered for use as a rename register for FROM register */\n+#define HARD_REGNO_RENAME_OK(FROM, TO) bfin_hard_regno_rename_ok (FROM, TO)\n+\n+/* A C expression that is nonzero if it is desirable to choose\n+   register allocation so as to avoid move instructions between a\n+   value of mode MODE1 and a value of mode MODE2.\n+\n+   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n+   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n+   MODE2)' must be zero. */\n+#define MODES_TIEABLE_P(MODE1, MODE2) ((MODE1) == (MODE2))\n+\n+/* `PREFERRED_RELOAD_CLASS (X, CLASS)'\n+   A C expression that places additional restrictions on the register\n+   class to use when it is necessary to copy value X into a register\n+   in class CLASS.  The value is a register class; perhaps CLASS, or\n+   perhaps another, smaller class.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n+\n+#define  SECONDARY_OUTPUT_RELOAD_CLASS(class,mode,x) \\\n+    secondary_output_reload_class(class,mode,x)\n+#define  SECONDARY_INPUT_RELOAD_CLASS(class,mode,x)  \\\n+    secondary_input_reload_class(class,mode,x)\n+\n+/* Function Calling Conventions. */\n+\n+/* The type of the current function; normal functions are of type\n+   SUBROUTINE.  */\n+typedef enum {\n+  SUBROUTINE, INTERRUPT_HANDLER, EXCPT_HANDLER, NMI_HANDLER\n+} e_funkind;\n+\n+#define FUNCTION_ARG_REGISTERS { REG_R0, REG_R1, REG_R2, -1 }\n+\n+typedef struct {\n+  int words;\t\t\t/* # words passed so far */\n+  int nregs;\t\t\t/* # registers available for passing */\n+  int *arg_regs;\t\t/* array of register -1 terminated */\n+} CUMULATIVE_ARGS;\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  (function_arg (&CUM, MODE, TYPE, NAMED))\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO) function_arg_regno_p (REGNO)\n+\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT, N_NAMED_ARGS)\t\\\n+  (init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (function_arg_advance (&CUM, MODE, TYPE, NAMED))\n+\n+#define RETURN_POPS_ARGS(FDECL, FUNTYPE, STKSIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.\n+*/\n+\n+#define VALUE_REGNO(MODE) (REG_R0)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\\\n+  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\\\n+\t       VALUE_REGNO(TYPE_MODE(VALTYPE)))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, VALUE_REGNO(MODE))\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_R0)\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+#define RETURN_IN_MEMORY(TYPE) bfin_return_in_memory(TYPE)\n+\n+/* Before the prologue, the return address is in the RETS register.  */\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, REG_RETS)\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAME) bfin_return_addr_rtx (COUNT)\n+\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (REG_RETS)\n+\n+/* Call instructions don't modify the stack pointer on the Blackfin.  */\n+#define INCOMING_FRAME_SP_OFFSET 0\n+\n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N)\t((N) < 2 ? (N) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, REG_P2)\n+#define EH_RETURN_HANDLER_RTX \\\n+    gen_rtx_MEM (Pmode, plus_constant (frame_pointer_rtx, UNITS_PER_WORD))\n+\n+/* Addressing Modes */\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X)\t(CONSTANT_P (X))\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   symbol_ref are not legitimate and will be put into constant pool.\n+   See force_const_mem().\n+   If -mno-pool, all constants are legitimate.\n+ */\n+#define LEGITIMATE_CONSTANT_P(x) 1\n+\n+/*   A number, the maximum number of registers that can appear in a\n+     valid memory address.  Note that it is up to you to specify a\n+     value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'\n+     would ever accept. */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address. \n+\n+   Blackfin addressing modes are as follows:\n+\n+      [preg]\n+      [preg + imm16]\n+\n+      B [ Preg + uimm15 ]\n+      W [ Preg + uimm16m2 ]\n+      [ Preg + uimm17m4 ] \n+\n+      [preg++]\n+      [preg--]\n+      [--sp]\n+*/\n+\n+#define LEGITIMATE_MODE_FOR_AUTOINC_P(MODE) \\\n+      (GET_MODE_SIZE (MODE) <= 4 || (MODE) == PDImode)\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (bfin_legitimate_address_p (MODE, X, 1))\t\t\\\n+      goto WIN;\t\t\t\t\t\t\\\n+  } while (0);\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (bfin_legitimate_address_p (MODE, X, 0))\t\t\\\n+      goto WIN;\t\t\t\t\t\t\\\n+  } while (0);\n+#endif\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+ */\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)    \\\n+do {\t\t\t\t\t       \\\n+   rtx _q = legitimize_address(X, OLDX, MODE); \\\n+   if (_q) { X = _q; goto WIN; }\t       \\\n+} while (0)\n+\n+#define HAVE_POST_INCREMENT 1\n+#define HAVE_POST_DECREMENT 1\n+#define HAVE_PRE_DECREMENT  1\n+\n+/* `LEGITIMATE_PIC_OPERAND_P (X)'\n+     A C expression that is nonzero if X is a legitimate immediate\n+     operand on the target machine when generating position independent\n+     code.  You can assume that X satisfies `CONSTANT_P', so you need\n+     not check this.  You can also assume FLAG_PIC is true, so you need\n+     not check it either.  You need not define this macro if all\n+     constants (including `SYMBOL_REF') can be immediate operands when\n+     generating position independent code. */\n+#define LEGITIMATE_PIC_OPERAND_P(X) ! SYMBOLIC_CONST (X)\n+\n+#define SYMBOLIC_CONST(X)\t\\\n+(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+ || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+ || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+\n+/*\n+     A C statement or compound statement with a conditional `goto\n+     LABEL;' executed if memory address X (an RTX) can have different\n+     meanings depending on the machine mode of the memory reference it\n+     is used for or if the address is valid for some modes but not\n+     others.\n+\n+     Autoincrement and autodecrement addresses typically have\n+     mode-dependent effects because the amount of the increment or\n+     decrement is the size of the operand being addressed.  Some\n+     machines have other mode-dependent addresses.  Many RISC machines\n+     have no mode-dependent addresses.\n+\n+     You may assume that ADDR is a valid address for the machine.\n+*/\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+do {                                              \\\n+ if (GET_CODE (ADDR) == POST_INC                  \\\n+     || GET_CODE (ADDR) == POST_DEC               \\\n+     || GET_CODE (ADDR) == PRE_DEC)               \\\n+   goto LABEL;\t\t\t\t\t  \\\n+} while (0)\n+\n+#define NOTICE_UPDATE_CC(EXPR, INSN) 0\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX UNITS_PER_WORD\n+\n+\n+/* STORAGE LAYOUT: target machine storage layout\n+   Define this macro as a C expression which is nonzero if accessing\n+   less than a word of memory (i.e. a `char' or a `short') is no\n+   faster than accessing a word of memory, i.e., if such access\n+   require more than one instruction or if there is no difference in\n+   cost between byte and (aligned) word loads.\n+\n+   When this macro is not defined, the compiler will access a field by\n+   finding the smallest containing object; when it is defined, a\n+   fullword load will be used if alignment permits.  Unless bytes\n+   accesses are faster than word accesses, using word accesses is\n+   preferable since it may eliminate subsequent memory access if\n+   subsequent accesses occur to other fields in the same word of the\n+   structure, but to different bytes.  */\n+#define SLOW_BYTE_ACCESS  0\n+#define SLOW_SHORT_ACCESS 0\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+#define BITS_BIG_ENDIAN  0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.\n+   We can't access bytes but if we could we would in the Big Endian order. */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is numbered. */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Size of a vector for autovectorization.  */\n+#define UNITS_PER_SIMD_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode1' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY BITS_PER_WORD\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* (shell-command \"rm c-decl.o stor-layout.o\")\n+ *  never define PCC_BITFIELD_TYPE_MATTERS\n+ *  really cause some alignment problem\n+ */\n+\n+#define UNITS_PER_FLOAT  ((FLOAT_TYPE_SIZE  + BITS_PER_UNIT - 1) / \\\n+\t\t\t   BITS_PER_UNIT)\n+\n+#define UNITS_PER_DOUBLE ((DOUBLE_TYPE_SIZE + BITS_PER_UNIT - 1) / \\\n+ \t\t\t   BITS_PER_UNIT)\n+\n+\n+/* what is the 'type' of size_t */\n+#define SIZE_TYPE \"long unsigned int\"\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+#define FLOAT_TYPE_SIZE BITS_PER_WORD\n+#define SHORT_TYPE_SIZE 16 \n+#define CHAR_TYPE_SIZE\t8\n+#define INT_TYPE_SIZE\t32\n+#define LONG_TYPE_SIZE\t32\n+#define LONG_LONG_TYPE_SIZE 64 \n+\n+/* Note: Fix this to depend on target switch. -- lev */\n+\n+/* Note: Try to implement double and force long double. -- tonyko\n+ * #define __DOUBLES_ARE_FLOATS__\n+ * #define DOUBLE_TYPE_SIZE FLOAT_TYPE_SIZE\n+ * #define LONG_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE\n+ * #define DOUBLES_ARE_FLOATS 1\n+ */\n+\n+#define DOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* `PROMOTE_MODE (M, UNSIGNEDP, TYPE)'\n+     A macro to update M and UNSIGNEDP when an object whose type is\n+     TYPE and which has the specified mode and signedness is to be\n+     stored in a register.  This macro is only called when TYPE is a\n+     scalar type.\n+\n+     On most RISC machines, which only have operations that operate on\n+     a full register, define this macro to set M to `word_mode' if M is\n+     an integer mode narrower than `BITS_PER_WORD'.  In most cases,\n+     only integer modes should be widened because wider-precision\n+     floating-point operations are usually more expensive than their\n+     narrower counterparts.\n+\n+     For most machines, the macro definition does not change UNSIGNEDP.\n+     However, some machines, have instructions that preferentially\n+     handle either signed or unsigned quantities of certain modes.  For\n+     example, on the DEC Alpha, 32-bit loads from memory and 32-bit add\n+     instructions sign-extend the result to 64 bits.  On such machines,\n+     set UNSIGNEDP according to which kind of extension is more\n+     efficient.\n+\n+     Do not define this macro if it would never modify M.*/\n+\n+#define BFIN_PROMOTE_MODE_P(MODE) \\\n+    (!TARGET_DSP && GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \\\n+  if (BFIN_PROMOTE_MODE_P(MODE))\t\t\\\n+    {                                           \\\n+      if (MODE == QImode)                       \\\n+        UNSIGNEDP = 1;                          \\\n+      else if (MODE == HImode)                  \\\n+        UNSIGNEDP = 0;      \t\t\t\\\n+      (MODE) = SImode;                          \\\n+    }\n+\n+/* Describing Relative Costs of Operations */\n+\n+/* Do not put function addr into constant pool */\n+#define NO_FUNCTION_CSE 1\n+\n+/* A C expression for the cost of moving data from a register in class FROM to\n+   one in class TO.  The classes are expressed using the enumeration values\n+   such as `GENERAL_REGS'.  A value of 2 is the default; other values are\n+   interpreted relative to that.\n+\n+   It is not required that the cost always equal 2 when FROM is the same as TO;\n+   on some machines it is expensive to move between registers if they are not\n+   general registers.  */\n+\n+#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n+   bfin_register_move_cost ((MODE), (CLASS1), (CLASS2))\n+\n+/* A C expression for the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   If moving between registers and memory is more expensive than\n+   between two registers, you should define this macro to express the\n+   relative cost.  */\n+\n+#define MEMORY_MOVE_COST(MODE, CLASS, IN)\t\\\n+  bfin_memory_move_cost ((MODE), (CLASS), (IN))\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION flag_pic\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified. \n+#define WORD_REGISTER_OPERATIONS\n+*/\n+\n+#define CONST_18UBIT_IMM_P(VALUE) ((VALUE) >= 0 && (VALUE) <= 262140)\n+#define CONST_16BIT_IMM_P(VALUE) ((VALUE) >= -32768 && (VALUE) <= 32767)\n+#define CONST_16UBIT_IMM_P(VALUE) ((VALUE) >= 0 && (VALUE) <= 65535)\n+#define CONST_7BIT_IMM_P(VALUE) ((VALUE) >= -64 && (VALUE) <= 63)\n+#define CONST_7NBIT_IMM_P(VALUE) ((VALUE) >= -64 && (VALUE) <= 0)\n+#define CONST_5UBIT_IMM_P(VALUE) ((VALUE) >= 0 && (VALUE) <= 31)\n+#define CONST_4BIT_IMM_P(VALUE) ((VALUE) >= -8 && (VALUE) <= 7)\n+#define CONST_4UBIT_IMM_P(VALUE) ((VALUE) >= 0 && (VALUE) <= 15)\n+#define CONST_3BIT_IMM_P(VALUE) ((VALUE) >= -4 && (VALUE) <= 3)\n+#define CONST_3UBIT_IMM_P(VALUE) ((VALUE) >= 0 && (VALUE) <= 7)\n+\n+#define CONSTRAINT_LEN(C, STR)\t\t\t\\\n+    ((C) == 'P' || (C) == 'M' || (C) == 'N' ? 2\t\\\n+     : (C) == 'K' ? 3\t\t\t\t\\\n+     : DEFAULT_CONSTRAINT_LEN ((C), (STR)))\n+\n+#define CONST_OK_FOR_P(VALUE, STR)    \\\n+    ((STR)[1] == '0' ? (VALUE) == 0   \\\n+     : (STR)[1] == '1' ? (VALUE) == 1 \\\n+     : (STR)[1] == '2' ? (VALUE) == 2 \\\n+     : (STR)[1] == '3' ? (VALUE) == 3 \\\n+     : (STR)[1] == '4' ? (VALUE) == 4 \\\n+     : 0)\n+\n+#define CONST_OK_FOR_K(VALUE, STR)\t\t\t\\\n+    ((STR)[1] == 'u'\t\t\t\t\t\\\n+     ? ((STR)[2] == '3' ? CONST_3UBIT_IMM_P (VALUE)\t\\\n+\t: (STR)[2] == '4' ? CONST_4UBIT_IMM_P (VALUE)\t\\\n+\t: (STR)[2] == '5' ? CONST_5UBIT_IMM_P (VALUE)\t\\\n+\t: (STR)[2] == 'h' ? CONST_16UBIT_IMM_P (VALUE)\t\\\n+\t: 0)\t\t\t\t\t\t\\\n+     : (STR)[1] == 's'\t\t\t\t\t\\\n+     ? ((STR)[2] == '3' ? CONST_3BIT_IMM_P (VALUE)\t\\\n+\t: (STR)[2] == '4' ? CONST_4BIT_IMM_P (VALUE)\t\\\n+\t: (STR)[2] == '7' ? CONST_7BIT_IMM_P (VALUE)\t\\\n+\t: (STR)[2] == 'h' ? CONST_16BIT_IMM_P (VALUE)\t\\\n+\t: 0)\t\t\t\t\t\t\\\n+     : (STR)[1] == 'n'\t\t\t\t\t\\\n+     ? ((STR)[2] == '7' ? CONST_7NBIT_IMM_P (VALUE)\t\\\n+\t: 0)\t\t\t\t\t\t\\\n+     : 0)\n+\n+#define CONST_OK_FOR_M(VALUE, STR)\t\t\t\\\n+    ((STR)[1] == '1' ? (VALUE) == 255\t\t\t\\\n+     : (STR)[1] == '2' ? (VALUE) == 65535\t\t\\\n+     : 0)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C. \n+   \n+   bfin constant operands are as follows\n+   \n+     J   2**N       5bit imm scaled\n+     Ks7 -64 .. 63  signed 7bit imm\n+     Ku5 0..31      unsigned 5bit imm\n+     Ks4 -8 .. 7    signed 4bit imm\n+     Ks3 -4 .. 3    signed 3bit imm\n+     Ku3 0 .. 7     unsigned 3bit imm\n+     Pn  0, 1, 2    constants 0, 1 or 2, corresponding to n\n+*/\n+#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)\t\t\\\n+  ((C) == 'J' ? (log2constp (VALUE))\t\t\t\t\\\n+   : (C) == 'K' ? CONST_OK_FOR_K (VALUE, STR)\t\t\t\\\n+   : (C) == 'L' ? log2constp (~(VALUE))\t\t\t\t\\\n+   : (C) == 'M' ? CONST_OK_FOR_M (VALUE, STR)\t\t\t\\\n+   : (C) == 'P' ? CONST_OK_FOR_P (VALUE, STR)\t\t\t\\\n+   : 0)\n+\n+     /*Constant Output Formats */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n+  ((C) == 'H' ? 1 : 0)\n+\n+#define EXTRA_CONSTRAINT(VALUE, D) \\\n+    ((D) == 'Q' ? GET_CODE (VALUE) == SYMBOL_REF : 0)\n+\n+/* `FINALIZE_PIC'\n+     By generating position-independent code, when two different\n+     programs (A and B) share a common library (libC.a), the text of\n+     the library can be shared whether or not the library is linked at\n+     the same address for both programs.  In some of these\n+     environments, position-independent code requires not only the use\n+     of different addressing modes, but also special code to enable the\n+     use of these addressing modes.\n+\n+     The `FINALIZE_PIC' macro serves as a hook to emit these special\n+     codes once the function is being compiled into assembly code, but\n+     not before.  (It is not done before, because in the case of\n+     compiling an inline function, it would lead to multiple PIC\n+     prologues being included in functions which used inline functions\n+     and were compiled to assembly language.) */\n+#define FINALIZE_PIC  do {} while (0)\n+\n+/* Switch into a generic section.  */\n+#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n+\n+#define PRINT_OPERAND(FILE, RTX, CODE)\t print_operand (FILE, RTX, CODE)\n+#define PRINT_OPERAND_ADDRESS(FILE, RTX) print_address_operand (FILE, RTX)\n+\n+typedef enum sections {\n+    CODE_DIR,\n+    DATA_DIR,\n+    LAST_SECT_NM\n+} SECT_ENUM_T;\n+\n+typedef enum directives {\n+    LONG_CONST_DIR,\n+    SHORT_CONST_DIR,\n+    BYTE_CONST_DIR,\n+    SPACE_DIR,\n+    INIT_DIR,\n+    LAST_DIR_NM\n+} DIR_ENUM_T;\n+\n+#define TEXT_SECTION_ASM_OP \".text;\"\n+#define DATA_SECTION_ASM_OP \".data;\"\n+\n+#define ASM_APP_ON  \"\"\n+#define ASM_APP_OFF \"\"\n+\n+#define ASM_GLOBALIZE_LABEL1(FILE, NAME) \\\n+  do {  fputs (\".global \", FILE);\t\t\\\n+        assemble_name (FILE, NAME);\t        \\\n+        fputc (';',FILE);\t\t\t\\\n+        fputc ('\\n',FILE);\t\t\t\\\n+      } while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL) \\\n+  do {\t\t\t\t\t\\\n+    fputs (\".type \", FILE);           \t\\\n+    assemble_name (FILE, NAME);         \\\n+    fputs (\", STT_FUNC\", FILE);         \\\n+    fputc (';',FILE);                   \\\n+    fputc ('\\n',FILE);\t\t\t\\\n+    ASM_OUTPUT_LABEL(FILE, NAME);\t\\\n+  } while (0)\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)    \\\n+  do {  assemble_name (FILE, NAME);\t\t\\\n+        fputs (\":\\n\",FILE);\t\t\t\\\n+      } while (0)\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) \t\\\n+    do {  fprintf (FILE, \"_%s\", NAME); \\\n+        } while (0)\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int len = strlen (NAME);\t\t\t\t\t\t\\\n+    char *temp = (char *) alloca (len + 4);\t\t\t\t\\\n+    temp[0] = 'L';\t\t\t\t\t\t\t\\\n+    temp[1] = '_';\t\t\t\t\t\t\t\\\n+    strcpy (&temp[2], (NAME));\t\t\t\t\t\t\\\n+    temp[len + 2] = '_';\t\t\t\t\t\t\\\n+    temp[len + 3] = 0;\t\t\t\t\t\t\t\\\n+    (OUTPUT) = (char *) alloca (strlen (NAME) + 13);\t\t\t\\\n+    sprintf (OUTPUT, \"_%s$%d\", temp, LABELNO);\t\t\t\t\\\n+  } while (0)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)    \t\\\n+do { char __buf[256];\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.dd\\t\");\t\t\t\t\\\n+     ASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", VALUE);\t\\\n+     assemble_name (FILE, __buf);\t\t\t\\\n+     fputc (';', FILE);\t\t\t\t\t\\\n+     fputc ('\\n', FILE);\t\t\t\t\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+    MY_ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\n+\n+#define MY_ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\t\\\n+    do {\t\t\t\t\t\t\t\\\n+\tchar __buf[256];\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.dd\\t\");\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", VALUE);\t\\\n+\tassemble_name (FILE, __buf);\t\t\t\t\\\n+\tfputs (\" - \", FILE);\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", REL);\t\t\\\n+\tassemble_name (FILE, __buf);\t\t\t\t\\\n+\tfputc (';', FILE);\t\t\t\t\t\\\n+\tfputc ('\\n', FILE);\t\t\t\t\t\\\n+    } while (0)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \t\t\t\t\\\n+    do {\t\t \t\t\t\t\t\\\n+\tfprintf (FILE, \".align %d\\n\", LOG);\t\t\t\\\n+    } while (0)\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)\t\t\\\n+    do {\t\t\t\t\t\\\n+\tasm_output_skip (FILE, SIZE);\t\t\\\n+    } while (0)\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\\\n+do { \t\t\t\t\t\t\\\n+    data_section();\t\t\t\t\\\n+    if ((SIZE) >= (unsigned int) 4 ) ASM_OUTPUT_ALIGN(FILE,2);\t\\\n+    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);\t\t\\\n+    ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n+    fprintf (FILE, \"%s %ld;\\n\", ASM_SPACE,\t\t\t\\\n+\t     (ROUNDED) > (unsigned int) 1 ? (ROUNDED) : 1);\t\\\n+} while (0)\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+     do {\t\t\t\t\t\t\\\n+\tASM_GLOBALIZE_LABEL1(FILE,NAME); \t\t\\\n+        ASM_OUTPUT_LOCAL (FILE, NAME, SIZE, ROUNDED); } while(0)\n+\n+#define ASM_COMMENT_START \"//\"\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \\\n+  do {\\\n+    fprintf (FILE, \"\\tP1.l =LP$%d; P1.h =LP$%d; call mcount;\\n\", \\\n+       LABELNO, LABELNO);\\\n+  } while(0)\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) fprintf (FILE, \"[SP--] = %s;\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)  fprintf (FILE, \"%s = [SP++];\\n\", reg_names[REGNO])\n+\n+extern struct rtx_def *bfin_compare_op0, *bfin_compare_op1;\n+extern struct rtx_def *bfin_cc_rtx, *bfin_rets_rtx;\n+\n+/* This works for GAS and some other assemblers.  */\n+#define SET_ASM_OP              \".set \"\n+\n+/* Don't know how to order these.  UNALIGNED_WORD_ASM_OP is in\n+   dwarf2.out. */\n+#define UNALIGNED_WORD_ASM_OP \".4byte\"\n+\n+/* DBX register number for a given compiler register number */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO) \n+\n+#define SIZE_ASM_OP     \"\\t.size\\t\"\n+\n+#endif /*  _BFIN_CONFIG */"}, {"sha": "348bce906021d24472e87550abd12b695fceed2c", "filename": "gcc/config/bfin/bfin.md", "status": "added", "additions": 1902, "deletions": 0, "changes": 1902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,1902 @@\n+;;- Machine description for Blackfin for GNU compiler\n+;;  Copyright 2005  Free Software Foundation, Inc.\n+;;  Contributed by Analog Devices.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+; operand punctuation marks:\n+;\n+;     X -- integer value printed as log2\n+;     Y -- integer value printed as log2(~value) - for bitclear\n+;     h -- print half word register, low part\n+;     d -- print half word register, high part\n+;     D -- print operand as dregs pairs\n+;     w -- print operand as accumulator register word (a0w, a1w)\n+;     H -- high part of double mode operand\n+;     T -- byte register representation Oct. 02 2001\n+\n+; constant operand classes\n+;\n+;     J   2**N       5bit imm scaled\n+;     Ks7 -64 .. 63  signed 7bit imm\n+;     Ku5 0..31      unsigned 5bit imm\n+;     Ks4 -8 .. 7    signed 4bit imm\n+;     Ks3 -4 .. 3    signed 3bit imm\n+;     Ku3 0 .. 7     unsigned 3bit imm\n+;     Pn  0, 1, 2    constants 0, 1 or 2, corresponding to n\n+;\n+; register operands\n+;     d  (r0..r7)\n+;     a  (p0..p5,fp,sp)\n+;     e  (a0, a1)\n+;     b  (i0..i3)\n+;     f  (m0..m3)\n+;     B\n+;     c (i0..i3,m0..m3) CIRCREGS\n+;     C (CC)            CCREGS\n+;\n+\n+;; Define constants for hard registers.\n+\n+(define_constants\n+  [(REG_R0 0)\n+   (REG_R1 1)\n+   (REG_R2 2)\n+   (REG_R3 3)\n+   (REG_R4 4)\n+   (REG_R5 5)\n+   (REG_R6 6)\n+   (REG_R7 7)\n+\n+   (REG_P0 8)\n+   (REG_P1 9)\n+   (REG_P2 10)\n+   (REG_P3 11)\n+   (REG_P4 12)\n+   (REG_P5 13)\n+   (REG_P6 14)\n+   (REG_P7 15)\n+\n+   (REG_SP 14)\n+   (REG_FP 15)\n+\n+   (REG_I0 16)\n+   (REG_B0 17)\n+   (REG_L0 18)\n+   (REG_I1 19)\n+   (REG_B1 20)\n+   (REG_L1 21)\n+   (REG_I2 22)\n+   (REG_B2 23)\n+   (REG_L2 24)\n+   (REG_I3 25)\n+   (REG_B3 26)\n+   (REG_L3 27)\n+\n+   (REG_M0 28)\n+   (REG_M1 29)\n+   (REG_M2 30)\n+   (REG_M3 31)\n+\n+   (REG_A0 32)\n+   (REG_A1 33)\n+\n+   (REG_CC 34)\n+   (REG_RETS 35)\n+   (REG_RETI 36)\n+   (REG_RETX 37)\n+   (REG_RETN 38)\n+   (REG_RETE 39)\n+\n+   (REG_ASTAT 40)\n+   (REG_SEQSTAT 41)\n+   (REG_USP 42)\n+\n+   (REG_ARGP 43)])\n+\n+;; Constants used in UNSPECs and UNSPEC_VOLATILEs.\n+\n+(define_constants\n+  [(UNSPEC_CBRANCH_TAKEN 0)\n+   (UNSPEC_CBRANCH_NOPS 1)\n+   (UNSPEC_RETURN 2)\n+   (UNSPEC_MOVE_PIC 3)\n+   (UNSPEC_LIBRARY_OFFSET 4)\n+   (UNSPEC_PUSH_MULTIPLE 5)])\n+\n+(define_constants\n+  [(UNSPEC_VOLATILE_EH_RETURN 0)])\n+\n+(define_attr \"type\"\n+  \"move,mvi,mcld,mcst,dsp32,mult,alu0,shft,brcc,br,call,misc,compare,dummy\"\n+  (const_string \"misc\"))\n+\n+;; Scheduling definitions\n+\n+(define_automaton \"bfin\")\n+\n+(define_cpu_unit \"core\" \"bfin\")\n+\n+(define_insn_reservation \"alu\" 1\n+  (eq_attr \"type\" \"move,mvi,mcst,dsp32,alu0,shft,brcc,br,call,misc,compare\")\n+  \"core\")\n+\n+(define_insn_reservation \"imul\" 3\n+  (eq_attr \"type\" \"mult\")\n+  \"core*3\")\n+\n+(define_insn_reservation \"load\" 1\n+  (eq_attr \"type\" \"mcld\")\n+  \"core\")\n+\n+;; Make sure genautomata knows about the maximum latency that can be produced\n+;; by the adjust_cost function.\n+(define_insn_reservation \"dummy\" 5\n+  (eq_attr \"type\" \"mcld\")\n+  \"core\")\n+\f\n+;; Operand and operator predicates\n+\n+(include \"predicates.md\")\n+\n+\f\n+;;; FRIO branches have been optimized for code density\n+;;; this comes at a slight cost of complexity when\n+;;; a compiler needs to generate branches in the general\n+;;; case.  In order to generate the correct branching\n+;;; mechanisms the compiler needs keep track of instruction\n+;;; lengths.  The follow table describes how to count instructions\n+;;; for the FRIO architecture.\n+;;;\n+;;; unconditional br are 12-bit imm pcrelative branches *2\n+;;; conditional   br are 10-bit imm pcrelative branches *2\n+;;; brcc 10-bit:\n+;;;   1024 10-bit imm *2 is 2048 (-1024..1022)\n+;;; br 12-bit  :\n+;;;   4096 12-bit imm *2 is 8192 (-4096..4094)\n+;;; NOTE : For brcc we generate instructions such as\n+;;;   if cc jmp; jump.[sl] offset\n+;;;   offset of jump.[sl] is from the jump instruction but\n+;;;     gcc calculates length from the if cc jmp instruction\n+;;;     hence our range is (-4094, 4096) instead of (-4096, 4094) for a br\n+;;;\n+;;; The way the (pc) rtx works in these calculations is somewhat odd;\n+;;; for backward branches it's the address of the current instruction,\n+;;; for forward branches it's the previously known address of the following\n+;;; instruction - we have to take this into account by reducing the range\n+;;; for a forward branch.\n+\n+;; Lengths for type \"mvi\" insns are always defined by the instructions\n+;; themselves.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"mcld\")\n+         (if_then_else (match_operand 1 \"effective_address_32bit_p\" \"\")\n+                       (const_int 4) (const_int 2))\n+\n+\t (eq_attr \"type\" \"mcst\")\n+\t (if_then_else (match_operand 0 \"effective_address_32bit_p\" \"\")\n+\t\t       (const_int 4) (const_int 2))\n+\n+\t (eq_attr \"type\" \"move\") (const_int 2)\n+\n+\t (eq_attr \"type\" \"dsp32\") (const_int 4)\n+\t (eq_attr \"type\" \"call\")  (const_int 4)\n+\n+         (eq_attr \"type\" \"br\")\n+  \t (if_then_else (and\n+\t                  (le (minus (match_dup 0) (pc)) (const_int 4092))\n+\t                  (ge (minus (match_dup 0) (pc)) (const_int -4096)))\n+        \t  (const_int 2)\n+                  (const_int 4))\n+\n+         (eq_attr \"type\" \"brcc\")\n+\t (cond [(and\n+\t            (le (minus (match_dup 3) (pc)) (const_int 1020))\n+\t            (ge (minus (match_dup 3) (pc)) (const_int -1024)))\n+\t\t  (const_int 2)\n+\t\t(and\n+\t            (le (minus (match_dup 3) (pc)) (const_int 4096))\n+\t            (ge (minus (match_dup 3) (pc)) (const_int -4094)))\n+\t\t  (const_int 4)]\n+\t       (const_int 6))\n+        ]\n+\n+\t(const_int 2)))\n+\n+;; Conditional moves\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n+                         (match_operand:SI 2 \"register_operand\" \"\")\n+                         (match_operand:SI 3 \"register_operand\" \"\")))]\n+  \"\"\n+{\n+  operands[1] = bfin_gen_compare (operands[1], SImode);\n+})\n+\n+(define_insn \"*movsicc_insn1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da,da,da\")\n+        (if_then_else:SI\n+\t    (eq:BI (match_operand:BI 3 \"cc_operand\" \"C,C,C\")\n+\t\t(const_int 0))\n+\t    (match_operand:SI 1 \"register_operand\" \"da,0,da\")\n+\t    (match_operand:SI 2 \"register_operand\" \"0,da,da\")))]\n+  \"\"\n+  \"@\n+    if !cc %0 =%1; /* movsicc-1a */\n+    if cc %0 =%2; /* movsicc-1b */\n+    if !cc %0 =%1; if cc %0=%2; /* movsicc-1 */\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"type\" \"move\")])\n+\n+(define_insn \"*movsicc_insn2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da,da,da\")\n+        (if_then_else:SI\n+\t    (ne:BI (match_operand:BI 3 \"cc_operand\" \"C,C,C\")\n+\t\t(const_int 0))\n+\t    (match_operand:SI 1 \"register_operand\" \"0,da,da\")\n+\t    (match_operand:SI 2 \"register_operand\" \"da,0,da\")))]\n+  \"\"\n+  \"@\n+   if !cc %0 =%2; /* movsicc-2b */\n+   if cc %0 =%1; /* movsicc-2a */\n+   if cc %0 =%1; if !cc %0=%2; /* movsicc-1 */\"\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"type\" \"move\")])\n+\n+;; Insns to load HIGH and LO_SUM\n+\n+(define_insn \"movsi_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=x\")\n+\t(high:SI (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"reload_completed\"\n+  \"%d0 = %d1;\"\n+  [(set_attr \"type\" \"mvi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"movstricthi_high\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+x\")\n+\t(ior:SI (and:SI (match_dup 0) (const_int 65535))\n+\t\t(match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"reload_completed\"\n+  \"%d0 = %d1;\"\n+  [(set_attr \"type\" \"mvi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsi_low\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=x\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"reload_completed\"\n+  \"%h0 = %h2;\"\n+  [(set_attr \"type\" \"mvi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsi_high_pic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=x\")\n+\t(high:SI (unspec:SI [(match_operand:SI 1 \"\" \"\")]\n+\t\t\t    UNSPEC_MOVE_PIC)))]\n+  \"\"\n+  \"%d0 = %1@GOT_LOW;\"\n+  [(set_attr \"type\" \"mvi\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsi_low_pic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=x\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (unspec:SI [(match_operand:SI 2 \"\" \"\")]\n+\t\t\t      UNSPEC_MOVE_PIC)))]\n+  \"\"\n+  \"%h0 = %h2@GOT_HIGH;\"\n+  [(set_attr \"type\" \"mvi\")\n+   (set_attr \"length\" \"4\")])\n+\n+;;; Move instructions\n+\n+(define_insn_and_split \"movdi_insn\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=x,mx,r\")\n+\t(match_operand:DI 1 \"general_operand\" \"iFx,r,mx\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  rtx lo_half[2], hi_half[2];\n+  split_di (operands, 2, lo_half, hi_half);\n+\n+  if (reg_overlap_mentioned_p (lo_half[0], hi_half[1]))\n+    {\n+      operands[2] = hi_half[0];\n+      operands[3] = hi_half[1];\n+      operands[4] = lo_half[0];\n+      operands[5] = lo_half[1];\n+    }\n+  else\n+    {\n+      operands[2] = lo_half[0];\n+      operands[3] = lo_half[1];\n+      operands[4] = hi_half[0];\n+      operands[5] = hi_half[1];\n+    }\n+})\n+\n+(define_insn \"movbi\"\n+  [(set (match_operand:BI 0 \"nonimmediate_operand\" \"=x,x,d,mr,C,d\")\n+        (match_operand:BI 1 \"general_operand\" \"x,xKs3,mr,d,d,C\"))]\n+\n+  \"\"\n+  \"@\n+   %0 = %1;\n+   %0 = %1 (X);\n+   %0 = %1;\n+   %0 = %1;\n+   CC = %1;\n+   %0 = CC;\"\n+  [(set_attr \"type\" \"move,mvi,mcld,mcst,compare,compare\")\n+   (set_attr \"length\" \"2,2,*,*,2,2\")])\n+\n+(define_insn \"movpdi\"\n+  [(set (match_operand:PDI 0 \"nonimmediate_operand\" \"=e,<,e\")\n+        (match_operand:PDI 1 \"general_operand\" \" e,e,>\"))]\n+  \"\"\n+  \"@\n+   %0 = %1;\n+   %0 = %x1; %0 = %w1;\n+   %w0 = %1; %x0 = %1;\"\n+  [(set_attr \"type\" \"move,mcst,mcld\")])\n+\n+(define_insn \"*pushsi_insn\"\n+  [(set (mem:SI (pre_dec:SI (reg:SI REG_SP)))\n+        (match_operand:SI 0 \"register_operand\" \"xy\"))]\n+  \"\"\n+  \"[--SP] = %0;\"\n+  [(set_attr \"type\" \"mcst\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*popsi_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=xy\")\n+        (mem:SI (post_inc:SI (reg:SI REG_SP))))]\n+  \"\"\n+  \"%0 = [SP++];\"\n+  [(set_attr \"type\" \"mcld\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; The first alternative is used to make reload choose a limited register\n+;; class when faced with a movsi_insn that had its input operand replaced\n+;; with a PLUS.  We generally require fewer secondary reloads this way.\n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=da,x*y,da,x,x,x,da,mr\")\n+        (match_operand:SI 1 \"general_operand\" \"da,x*y,xKs7,xKsh,xKuh,ix,mr,da\"))]\n+\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"@\n+   %0 = %1;\n+   %0 = %1;\n+   %0 = %1 (X);\n+   %0 = %1 (X);\n+   %0 = %1 (Z);\n+   #\n+   %0 = %1;\n+   %0 = %1;\"\n+  [(set_attr \"type\" \"move,move,mvi,mvi,mvi,*,mcld,mcst\")\n+   (set_attr \"length\" \"2,2,2,4,4,*,*,*\")])\n+\n+(define_insn \"*movv2hi_insn\"\n+  [(set (match_operand:V2HI 0 \"nonimmediate_operand\" \"=da,d,m\")\n+        (match_operand:V2HI 1 \"general_operand\" \"d,m,d\"))]\n+\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"%0 = %1;\"\n+  [(set_attr \"type\" \"move,mcld,mcst\")\n+   (set_attr \"length\" \"2,*,*\")])\n+\n+(define_insn \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=x,da,x,d,mr\")\n+        (match_operand:HI 1 \"general_operand\" \"x,xKs7,xKsh,mr,d\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"@\n+   %0 = %1;\n+   %0 = %1 (X);\n+   %0 = %1 (X);\n+   %0 = W %1 (X);\n+   W %0 = %1;\"\n+  [(set_attr \"type\" \"move,mvi,mvi,mcld,mcst\")\n+   (set_attr \"length\" \"2,2,4,*,*\")])\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=x,da,x,d,mr\")\n+        (match_operand:QI 1 \"general_operand\" \"x,xKs7,xKsh,mr,d\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"@\n+   %0 = %1;\n+   %0 = %1 (X);\n+   %0 = %1 (X);\n+   %0 = B %1 (X);\n+   B %0 = %1;\"\n+  [(set_attr \"type\" \"move,mvi,mvi,mcld,mcst\")\n+   (set_attr \"length\" \"2,2,4,*,*\")])\n+\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x,x,da,mr\")\n+        (match_operand:SF 1 \"general_operand\" \"x,Fx,mr,da\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"@\n+   %0 = %1;\n+   #\n+   %0 = %1;\n+   %0 = %1;\"\n+  [(set_attr \"type\" \"move,*,mcld,mcst\")])\n+\n+(define_insn_and_split \"movdf_insn\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=x,mx,r\")\n+\t(match_operand:DF 1 \"general_operand\" \"iFx,r,mx\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  rtx lo_half[2], hi_half[2];\n+  split_di (operands, 2, lo_half, hi_half);\n+\n+  if (reg_overlap_mentioned_p (lo_half[0], hi_half[1]))\n+    {\n+      operands[2] = hi_half[0];\n+      operands[3] = hi_half[1];\n+      operands[4] = lo_half[0];\n+      operands[5] = lo_half[1];\n+    }\n+  else\n+    {\n+      operands[2] = lo_half[0];\n+      operands[3] = lo_half[1];\n+      operands[4] = hi_half[0];\n+      operands[5] = hi_half[1];\n+    }\n+})\n+\n+;; This is the main \"hook\" for PIC code.  When generating\n+;; PIC, movsi is responsible for determining when the source address\n+;; needs PIC relocation and appropriately calling legitimize_pic_address\n+;; to perform the actual relocation.\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"expand_move (operands, SImode);\")\n+\n+(define_expand \"movv2hi\"\n+  [(set (match_operand:V2HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V2HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"expand_move (operands, V2HImode);\")\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"expand_move (operands, DImode);\")\n+\n+(define_expand \"movsf\"\n+ [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+       (match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"expand_move (operands, SFmode);\")\n+\n+(define_expand \"movdf\"\n+ [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+       (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"expand_move (operands, DFmode);\")\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"expand_move (operands, HImode);\")\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \" expand_move (operands, QImode); \")\n+\n+;; Some define_splits to break up SI/SFmode loads of immediate constants.\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"symbolic_or_const_operand\" \"\"))]\n+  \"reload_completed\n+   /* Always split symbolic operands; split integer constants that are\n+      too large for a single instruction.  */\n+   && (GET_CODE (operands[1]) != CONST_INT\n+       || (INTVAL (operands[1]) < -32768\n+ \t   || INTVAL (operands[1]) >= 65536\n+\t   || (INTVAL (operands[1]) >= 32768 && PREG_P (operands[0]))))\"\n+  [(set (match_dup 0) (high:SI (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:SI (match_dup 0) (match_dup 1)))]\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && split_load_immediate (operands))\n+    DONE;\n+  /* ??? Do something about TARGET_LOW_64K.  */\n+})\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operand:SF 1 \"immediate_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (high:SI (match_dup 3)))\n+   (set (match_dup 2) (lo_sum:SI (match_dup 2) (match_dup 3)))]\n+{\n+  long values;\n+  REAL_VALUE_TYPE value;\n+\n+  if (GET_CODE (operands[1]) != CONST_DOUBLE)\n+    abort ();\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (value, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (value, values);\n+\n+  operands[2] = gen_rtx_REG (SImode, true_regnum (operands[0]));\n+  operands[3] = GEN_INT (trunc_int_for_mode (values, SImode));\n+  if (values >= -32768 && values < 65536)\n+    {\n+      emit_move_insn (operands[2], operands[3]);\n+      DONE;\n+    }\n+  if (split_load_immediate (operands + 2))\n+    DONE;\n+})\n+\n+;; Sadly, this can't be a proper named movstrict pattern, since the compiler\n+;; expects to be able to use registers for operand 1.\n+;; Note that the asm instruction is defined by the manual to take an unsigned\n+;; constant, but it doesn't matter to the assembler, and the compiler only\n+;; deals with sign-extended constants.  Hence \"Ksh\".\n+(define_insn \"*movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+x\"))\n+\t(match_operand:HI 1 \"immediate_operand\" \"Ksh\"))]\n+  \"\"\n+  \"%h0 = %1;\"\n+  [(set_attr \"type\" \"mvi\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Sign and zero extensions\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d, d\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d, m\")))]\n+  \"\"\n+  \"@\n+   %0 = %h1 (X);\n+   %0 = W %h1 (X);\"\n+  [(set_attr \"type\" \"alu0,mcld\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d, d\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d, m\")))]\n+  \"\"\n+  \"@\n+   %0 = %h1 (Z);\n+   %0 = W%h1 (Z);\"\n+  [(set_attr \"type\" \"alu0,mcld\")])\n+\n+(define_insn \"zero_extendbisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:BI 1 \"nonimmediate_operand\" \"C\")))]\n+  \"\"\n+  \"%0 = %1;\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d, d\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"m, d\")))]\n+  \"\"\n+  \"@\n+   %0 = B %1 (X);\n+   %0 = %T1 (X);\"\n+  [(set_attr \"type\" \"mcld,alu0\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d, d\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m, d\")))]\n+  \"\"\n+  \"@\n+   %0 = B %1 (X);\n+   %0 = %T1 (X);\"\n+  [(set_attr \"type\" \"mcld,alu0\")])\n+\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d, d\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"m, d\")))]\n+  \"\"\n+  \"@\n+   %0 = B %1 (Z);\n+   %0 = %T1 (Z);\"\n+  [(set_attr \"type\" \"mcld,alu0\")])\n+\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d, d\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m, d\")))]\n+  \"\"\n+  \"@\n+   %0 = B %1 (Z);\n+   %0 = %T1 (Z);\"\n+  [(set_attr \"type\" \"mcld,alu0\")])\n+\n+;; DImode logical operations\n+\n+(define_code_macro any_logical [and ior xor])\n+(define_code_attr optab [(and \"and\")\n+\t\t\t (ior \"ior\")\n+\t\t\t (xor \"xor\")])\n+(define_code_attr op [(and \"&\")\n+\t\t      (ior \"|\")\n+\t\t      (xor \"^\")])\n+(define_code_attr high_result [(and \"0\")\n+\t\t\t       (ior \"%H1\")\n+\t\t\t       (xor \"%H1\")])\n+\n+(define_insn \"<optab>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (any_logical:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 <op> %2;\\\\n\\\\t%H0 = %H1 <op> %H2;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*<optab>di_zesidi_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (any_logical:DI (zero_extend:DI\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\"))\n+\t\t\t(match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 <op>  %2;\\\\n\\\\t%H0 = <high_result>;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*<optab>di_sesdi_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (any_logical:DI (sign_extend:DI\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\"))\n+\t\t\t(match_operand:DI 1 \"register_operand\" \"0\")))\n+   (clobber (match_scratch:SI 3 \"=&d\"))]\n+  \"\"\n+  \"%0 = %1 <op> %2;\\\\n\\\\t%3 = %2;\\\\n\\\\t%3 >>>= 31;\\\\n\\\\t%H0 = %H1 <op> %3;\"\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 2 \"=&d\"))\n+   (clobber (reg:CC REG_CC))]\n+  \"\"\n+  \"%2 = 0; %2 = %2 - %1; cc = ac0; cc = !cc; %2 = cc;\\\\n\\\\t%0 = -%1; %H0 = -%H1; %H0 = %H0 - %2;\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (not:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = ~%1;\\\\n\\\\t%H0 = ~%H1;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; DImode zero and sign extend patterns\n+\n+(define_insn_and_split \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 3) (const_int 0))]\n+{\n+  split_di (operands, 1, operands + 2, operands + 3);\n+  if (REGNO (operands[0]) != REGNO (operands[1]))\n+    emit_move_insn (operands[2], operands[1]);\n+})\n+\n+(define_insn \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %T1 (Z);\\\\n\\\\t%H0 = 0;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %h1 (Z);\\\\n\\\\t%H0 = 0;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 3) (ashiftrt:SI (match_dup 3) (const_int 31)))]\n+{\n+  split_di (operands, 1, operands + 2, operands + 3);\n+  if (REGNO (operands[0]) != REGNO (operands[1]))\n+    emit_move_insn (operands[2], operands[1]);\n+})\n+\n+(define_insn_and_split \"extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (sign_extend:DI (match_operand:QI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (sign_extend:SI (match_dup 1)))\n+   (set (match_dup 3) (sign_extend:SI (match_dup 1)))\n+   (set (match_dup 3) (ashiftrt:SI (match_dup 3) (const_int 31)))]\n+{\n+  split_di (operands, 1, operands + 2, operands + 3);\n+})\n+\n+(define_insn_and_split \"extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (sign_extend:DI (match_operand:HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (sign_extend:SI (match_dup 1)))\n+   (set (match_dup 3) (sign_extend:SI (match_dup 1)))\n+   (set (match_dup 3) (ashiftrt:SI (match_dup 3) (const_int 31)))]\n+{\n+  split_di (operands, 1, operands + 2, operands + 3);\n+})\n+\n+;; DImode arithmetic operations\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d,&d,&d\")\n+        (plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0\")\n+                 (match_operand:DI 2 \"nonmemory_operand\" \"Kn7,Ks7,d\")))\n+   (clobber (match_scratch:SI 3 \"=&d,&d,&d\"))\n+   (clobber (reg:CC 34))]\n+  \"\"\n+  \"@\n+   %0 += %2; cc = ac0; %3 = cc; %H0 += -1; %H0 = %H0 + %3;\n+   %0 += %2; cc = ac0; %3 = cc; %H0 = %H0 + %3;\n+   %0 = %0 + %2; cc = ac0; %3 = cc; %H0 = %H0 + %H2; %H0 = %H0 + %3;\"\n+  [(set_attr \"type\" \"alu0\")\n+   (set_attr \"length\" \"10,8,10\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+                  (match_operand:DI 2 \"register_operand\" \"d\")))\n+   (clobber (reg:CC 34))]\n+  \"\"\n+  \"%0 = %1-%2;\\\\n\\\\tcc = ac0;\\\\n\\\\t%H0 = %H1-%H2;\\\\n\\\\tif cc jump 1f;\\\\n\\\\t%H0 += -1;\\\\n\\\\t1:\"\n+  [(set_attr \"length\" \"10\")])\n+\n+(define_insn \"*subdi_di_zesidi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+                  (zero_extend:DI\n+                  (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:SI 3 \"=&d\"))\n+   (clobber (reg:CC 34))]\n+  \"\"\n+  \"%0 = %1 - %2;\\\\n\\\\tcc = ac0;\\\\n\\\\tcc = ! cc;\\\\n\\\\t%3 = cc;\\\\n\\\\t%H0 = %H1 - %3;\"\n+  [(set_attr \"length\" \"10\")])\n+\n+(define_insn \"*subdi_zesidi_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (minus:DI (zero_extend:DI\n+                  (match_operand:SI 2 \"register_operand\" \"d\"))\n+                  (match_operand:DI 1 \"register_operand\" \"0\")))\n+   (clobber (match_scratch:SI 3 \"=&d\"))\n+   (clobber (reg:CC 34))]\n+  \"\"\n+  \"%0 = %2 - %1;\\\\n\\\\tcc = ac0;\\\\n\\\\tcc = ! cc;\\\\n\\\\t%3 = cc;\\\\n\\\\t%3 = -%3;\\\\n\\\\t%H0 = %3 - %H1\"\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_insn \"*subdi_di_sesidi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+                  (sign_extend:DI\n+                  (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:SI 3 \"=&d\"))\n+   (clobber (reg:CC 34))]\n+  \"\"\n+  \"%0 = %1 - %2;\\\\n\\\\tcc = ac0;\\\\n\\\\t%3 = %2;\\\\n\\\\t%3 >>>= 31;\\\\n\\\\t%H0 = %H1 - %3;\\\\n\\\\tif cc jump 1f;\\\\n\\\\t%H0 += -1;\\\\n\\\\t1:\"\n+  [(set_attr \"length\" \"14\")])\n+\n+(define_insn \"*subdi_sesidi_di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (minus:DI (sign_extend:DI\n+                  (match_operand:SI 2 \"register_operand\" \"d\"))\n+                  (match_operand:DI 1 \"register_operand\" \"0\")))\n+   (clobber (match_scratch:SI 3 \"=&d\"))\n+   (clobber (reg:CC 34))]\n+  \"\"\n+  \"%0 = %2 - %1;\\\\n\\\\tcc = ac0;\\\\n\\\\t%3 = %2;\\\\n\\\\t%3 >>>= 31;\\\\n\\\\t%H0 = %3 - %H1;\\\\n\\\\tif cc jump 1f;\\\\n\\\\t%H0 += -1;\\\\n\\\\t1:\"\n+  [(set_attr \"length\" \"14\")])\n+\n+;; Combined shift/add instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,d\")\n+\t(ashift:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t            (match_operand:SI 2 \"register_operand\" \"a,d\"))\n+\t\t   (match_operand:SI 3 \"pos_scale_operand\" \"P1P2,P1P2\")))]\n+  \"\"\n+  \"%0 = (%0 + %2) << %3;\" /* \"shadd %0,%2,%3;\" */\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"a\")\n+\t\t (mult:SI (match_operand:SI 2 \"register_operand\" \"a\")\n+\t\t\t  (match_operand:SI 3 \"scale_by_operand\" \"i\"))))]\n+  \"\"\n+  \"%0 = %1 + (%2 << %X3);\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"a\")\n+\t\t (ashift:SI (match_operand:SI 2 \"register_operand\" \"a\")\n+\t\t\t    (match_operand:SI 3 \"pos_scale_operand\" \"i\"))))]\n+  \"\"\n+  \"%0 = %1 + (%2 << %3);\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"a\")\n+\t\t\t  (match_operand:SI 2 \"scale_by_operand\" \"i\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"a\")))]\n+  \"\"\n+  \"%0 = %3 + (%1 << %X2);\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"a\")\n+\t\t\t    (match_operand:SI 2 \"pos_scale_operand\" \"i\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"a\")))]\n+  \"\"\n+  \"%0 = %3 + (%1 << %2);\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%d\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"%0 = %h1 * %h2 (IS);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%d\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"%0 = %h1 * %h2 (FU);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+;; The processor also supports ireg += mreg or ireg -= mreg, but these\n+;; are unusable if we don't ensure that the corresponding lreg is zero.\n+;; The same applies to the add/subtract constant versions involving\n+;; iregs\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=ad,a,d\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0, a,d\")\n+\t\t (match_operand:SI 2 \"reg_or_7bit_operand\" \"Ks7, a,d\")))]\n+  \"\"\n+  \"@\n+   %0 += %2;\n+   %0 = %1 + %2;\n+   %0 = %1 + %2;\"\n+  [(set_attr \"type\" \"alu0\")\n+   (set_attr \"length\" \"2,2,2\")])\n+\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"reg_or_7bit_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da,d,a\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,d,0\")\n+\t\t  (match_operand:SI 2 \"reg_or_7bit_operand\" \"Ks7,d,a\")))]\n+  \"GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != -64\"\n+{\n+  static const char *const strings_subsi3[] = {\n+    \"%0 += -%2;\",\n+    \"%0 = %1 - %2;\",\n+    \"%0 -= %2;\",\n+  };\n+\n+  if (CONSTANT_P (operands[2]) && INTVAL (operands[2]) < 0) {\n+     rtx tmp_op = operands[2];\n+     operands[2] = GEN_INT (-INTVAL (operands[2]));\n+     output_asm_insn (\"%0 += %2;\", operands);\n+     operands[2] = tmp_op;\n+     return \"\";\n+  }\n+\n+  return strings_subsi3[which_alternative];\n+}\n+  [(set_attr \"type\" \"alu0\")])\n+\n+;; Bit test instructions\n+\n+(define_insn \"*not_bittst\"\n+ [(set (match_operand:BI 0 \"cc_operand\" \"=C\")\n+       (eq:BI (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (match_operand:SI 2 \"immediate_operand\" \"Ku5\"))\n+\t      (const_int 0)))]\n+ \"\"\n+ \"cc = !BITTST (%1,%2);\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"*bittst\"\n+ [(set (match_operand:BI 0 \"cc_operand\" \"=C\")\n+       (ne:BI (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t       (const_int 1)\n+\t\t\t       (match_operand:SI 2 \"immediate_operand\" \"Ku5\"))\n+\t\t(const_int 0)))]\n+ \"\"\n+ \"cc = BITTST (%1,%2);\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn_and_split \"*bit_extract\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"Ku5\")))\n+   (clobber (reg:BI REG_CC))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:BI REG_CC)\n+\t(ne:BI (zero_extract:SI (match_dup 1) (const_int 1) (match_dup 2))\n+\t       (const_int 0)))\n+   (set (match_dup 0)\n+\t(ne:SI (reg:BI REG_CC) (const_int 0)))])\n+\n+(define_insn_and_split \"*not_bit_extract\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extract:SI (not:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"Ku5\")))\n+   (clobber (reg:BI REG_CC))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (reg:BI REG_CC)\n+\t(eq:BI (zero_extract:SI (match_dup 1) (const_int 1) (match_dup 2))\n+\t       (const_int 0)))\n+   (set (match_dup 0)\n+\t(ne:SI (reg:BI REG_CC) (const_int 0)))])\n+\n+(define_insn \"*andsi_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,d,d,d\")\n+\t\t(match_operand:SI 2 \"rhs_andsi3_operand\" \"L,M1,M2,d\")))]\n+  \"\"\n+  \"@\n+   BITCLR (%0,%Y2);\n+   %0 = %T1 (Z);\n+   %0 = %h1 (Z);\n+   %0 = %1 & %2;\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  if (highbits_operand (operands[2], SImode))\n+    {\n+      operands[2] = GEN_INT (exact_log2 (-INTVAL (operands[2])));\n+      emit_insn (gen_ashrsi3 (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_ashlsi3 (operands[0], operands[0], operands[2]));\n+      DONE;\n+    }\n+  if (! rhs_andsi3_operand (operands[2], SImode))\n+    operands[2] = force_reg (SImode, operands[2]);\n+})\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,d\")\n+\t\t(match_operand:SI 2 \"regorlog2_operand\" \"J,d\")))]\n+  \"\"\n+  \"@\n+   BITSET (%0, %X2);\n+   %0 = %1 | %2;\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,d\")\n+\t\t  (match_operand:SI 2 \"regorlog2_operand\" \"J,d\")))]\n+  \"\"\n+  \"@\n+   BITTGL (%0, %X2);\n+   %0 = %1 ^ %2;\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"smaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(smax:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 =max(%1,%2);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(smin:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 =min(%1,%2);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"abssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(abs:SI (match_operand:SI 1 \"register_operand\" \" d\")))]\n+  \"\"\n+  \"%0 =abs %1;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \" d\")))]\n+  \"\"\n+  \"%0 =-%1;\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \" d\")))]\n+  \"\"\n+  \"%0 =~%1;\"\n+  [(set_attr \"type\" \"alu0\")])\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 *=%2;\"\n+  [(set_attr \"type\" \"mult\")])\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+                   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+{\n+ if (GET_CODE (operands[2]) == CONST_INT\n+     && ((unsigned HOST_WIDE_INT) INTVAL (operands[2])) > 31)\n+   {\n+     emit_insn (gen_movsi (operands[0], const0_rtx));\n+     DONE;\n+   }\n+})\n+\n+(define_insn_and_split \"*ashlsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a,a\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,a,a,a\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"dKu5,P1,P2,?P3P4\")))]\n+  \"\"\n+  \"@\n+   %0 <<= %2;\n+   %0 = %1 + %1;\n+   %0 = %1 << %2;\n+   #\"\n+  \"PREG_P (operands[0]) && INTVAL (operands[2]) > 2\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 1) (const_int 2)))\n+   (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 3)))]\n+  \"operands[3] = GEN_INT (INTVAL (operands[2]) - 2);\"\n+  [(set_attr \"type\" \"shft\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"dKu5\")))]\n+  \"\"\n+  \"%0 >>>= %2;\"\n+  [(set_attr \"type\" \"shft\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \" 0,a\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"dKu5,P1P2\")))]\n+  \"\"\n+  \"@\n+   %0 >>= %2;\n+   %0 = %1 >> %2;\"\n+  [(set_attr \"type\" \"shft\")])\n+\n+;; A pattern to reload the equivalent of\n+;;   (set (Dreg) (plus (FP) (large_constant)))\n+;; or\n+;;   (set (dagreg) (plus (FP) (arbitrary_constant))) \n+;; using a scratch register\n+(define_expand \"reload_insi\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=w\")\n+                   (match_operand:SI 1 \"fp_plus_const_operand\" \"\"))\n+              (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))])]\n+  \"\"\n+{\n+  rtx fp_op = XEXP (operands[1], 0);\n+  rtx const_op = XEXP (operands[1], 1);\n+  rtx primary = operands[0];\n+  rtx scratch = operands[2];\n+\n+  emit_move_insn (scratch, const_op);\n+  emit_insn (gen_addsi3 (scratch, scratch, fp_op));\n+  emit_move_insn (primary, scratch);\n+  DONE;\n+})\n+\n+;; Jump instructions\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \"jump.s %0;\";\n+  else\n+    return \"jump.l %0;\";\n+}\n+  [(set_attr \"type\" \"br\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"jump (%0);\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n+              (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+{\n+  /* In PIC mode, the table entries are stored PC relative.\n+     Convert the relative address to an absolute address.  */\n+  if (flag_pic)\n+    {\n+      rtx op1 = gen_rtx_LABEL_REF (Pmode, operands[1]);\n+\n+      operands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n+\t\t\t\t\t op1, NULL_RTX, 0, OPTAB_DIRECT);\n+    }\n+})\n+\n+(define_insn \"*tablejump_internal\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jump (%0);\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+;;  Call instructions..\n+\n+(define_expand \"call\"\n+  [(call (match_operand:SI 0 \"\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"bfin_expand_call (NULL_RTX, operands[0], operands[1], 0); DONE;\")\n+\n+(define_expand \"sibcall\"\n+  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (return)])]\n+  \"\"\n+  \"bfin_expand_call (NULL_RTX, operands[0], operands[1], 1); DONE;\")\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+         (call (match_operand:SI 1 \"\" \"\")\n+\t       (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"bfin_expand_call (operands[0], operands[1], operands[2], 0); DONE;\")\n+\n+(define_expand \"sibcall_value\"\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n+\t\t   (call (match_operand:SI 1 \"\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (return)])]\n+  \"\"\n+  \"bfin_expand_call (operands[0], operands[1], operands[2], 1); DONE;\")\n+\n+(define_insn \"*call_insn\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"a,Q\"))\n+\t (match_operand 1 \"general_operand\" \"g,g\"))]\n+  \"! SIBLING_CALL_P (insn)\n+   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n+  \"@\n+  call (%0);\n+  call %G0;\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"*sibcall_insn\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_insn_operand\" \"z,Q\"))\n+\t (match_operand 1 \"general_operand\" \"g,g\"))\n+   (return)]\n+  \"SIBLING_CALL_P (insn)\n+   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n+  \"@\n+  jump (%0);\n+  jump.l %G0;\"\n+  [(set_attr \"type\" \"br\")\n+   (set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"*call_value_insn\"\n+  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n+        (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"a,Q\"))\n+\t      (match_operand 2 \"general_operand\" \"g,g\")))]\n+  \"! SIBLING_CALL_P (insn)\n+   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n+  \"@\n+  call (%1);\n+  call %G1;\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"*sibcall_value_insn\"\n+  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n+         (call (mem:SI (match_operand:SI 1 \"call_insn_operand\" \"z,Q\"))\n+\t       (match_operand 2 \"general_operand\" \"g,g\")))\n+   (return)]\n+  \"SIBLING_CALL_P (insn)\n+   && (GET_CODE (operands[0]) == SYMBOL_REF || GET_CODE (operands[0]) == REG)\"\n+  \"@\n+  jump (%1);\n+  jump.l %G1;\"\n+  [(set_attr \"type\" \"br\")\n+   (set_attr \"length\" \"2,4\")])\n+\n+;; Block move patterns\n+\n+;; We cheat.  This copies one more word than operand 2 indicates.\n+\n+(define_insn \"rep_movsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&a\")\n+        (plus:SI (plus:SI (match_operand:SI 3 \"register_operand\" \"0\")\n+\t\t\t  (ashift:SI (match_operand:SI 2 \"register_operand\" \"a\")\n+\t\t\t\t     (const_int 2)))\n+\t\t (const_int 4)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&b\")\n+        (plus:SI (plus:SI (match_operand:SI 4 \"register_operand\" \"1\")\n+\t\t\t  (ashift:SI (match_dup 2) (const_int 2)))\n+\t\t (const_int 4)))\n+   (set (mem:BLK (match_dup 3))\n+\t(mem:BLK (match_dup 4)))\n+   (use (match_dup 2))\n+   (clobber (match_scratch:HI 5 \"=&d\"))]\n+  \"\"\n+  \"lsetup (1f, 1f) LC1 = %2; %5 = [%4++]; 1: MNOP || [%3++] = %5 || %5 = [%4++]; [%3++] = %5;\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_insn \"rep_movhi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&a\")\n+        (plus:SI (plus:SI (match_operand:SI 3 \"register_operand\" \"0\")\n+\t\t\t  (ashift:SI (match_operand:SI 2 \"register_operand\" \"a\")\n+\t\t\t\t     (const_int 1)))\n+\t\t (const_int 2)))\n+   (set (match_operand:SI 1 \"register_operand\" \"=&b\")\n+        (plus:SI (plus:SI (match_operand:SI 4 \"register_operand\" \"1\")\n+\t\t\t  (ashift:SI (match_dup 2) (const_int 1)))\n+\t\t (const_int 2)))\n+   (set (mem:BLK (match_dup 3))\n+\t(mem:BLK (match_dup 4)))\n+   (use (match_dup 2))\n+   (clobber (match_scratch:HI 5 \"=&d\"))]\n+  \"\"\n+  \"lsetup (1f, 1f) LC1 = %2; %h5 = W[%4++]; 1: MNOP || W [%3++] = %5 || %h5 = W [%4++]; W [%3++] = %5;\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_expand \"movstrsi\"\n+  [(match_operand:BLK 0 \"general_operand\" \"\")\n+   (match_operand:BLK 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\" \"\")\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+  \"\"\n+{\n+  if (bfin_expand_strmov (operands[0], operands[1], operands[2], operands[3]))\n+    DONE;\n+  FAIL;\n+})\n+\n+;; Conditional branch patterns\n+;; The Blackfin has only few condition codes: eq, lt, lte, ltu, leu\n+\n+;; The only outcome of this pattern is that global variables\n+;; bfin_compare_op[01] are set for use in bcond patterns.\n+\n+(define_expand \"cmpbi\"\n+ [(set (cc0) (compare (match_operand:BI 0 \"register_operand\" \"\")\n+                      (match_operand:BI 1 \"immediate_operand\" \"\")))]\n+ \"\"\n+{\n+  bfin_compare_op0 = operands[0];\n+  bfin_compare_op1 = operands[1];\n+  DONE;\n+})\n+\n+(define_expand \"cmpsi\"\n+ [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+                      (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+ \"\"\n+{\n+  bfin_compare_op0 = operands[0];\n+  bfin_compare_op1 = operands[1];\n+  DONE;\n+})\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C,C\")\n+        (eq:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n+               (match_operand:SI 2 \"nonmemory_operand\" \"dKs3,aKs3\")))]\n+  \"\"\n+  \"cc =%1==%2;\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C,C\")\n+        (ne:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n+               (match_operand:SI 2 \"nonmemory_operand\" \"dKs3,aKs3\")))]\n+  \"0\"\n+  \"cc =%1!=%2;\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C,C\")\n+        (lt:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n+               (match_operand:SI 2 \"nonmemory_operand\" \"dKs3,aKs3\")))]\n+  \"\"\n+  \"cc =%1<%2;\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C,C\")\n+        (le:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n+               (match_operand:SI 2 \"nonmemory_operand\" \"dKs3,aKs3\")))]\n+  \"\"\n+  \"cc =%1<=%2;\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C,C\")\n+        (leu:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"dKu3,aKu3\")))]\n+  \"\"\n+  \"cc =%1<=%2 (iu);\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C,C\")\n+        (ltu:BI (match_operand:SI 1 \"register_operand\" \"d,a\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"dKu3,aKu3\")))]\n+  \"\"\n+  \"cc =%1<%2 (iu);\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_expand \"beq\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t   (pc)))]\n+  \"\"\n+{\n+  rtx op0 = bfin_compare_op0, op1 = bfin_compare_op1;\n+  operands[1] = bfin_cc_rtx;\t/* hard register: CC */\n+  operands[2] = gen_rtx_EQ (BImode, op0, op1);\n+  /* If we have a BImode input, then we already have a compare result, and\n+     do not need to emit another comparison.  */\n+  if (GET_MODE (bfin_compare_op0) == BImode)\n+    {\n+      if (bfin_compare_op1 == const0_rtx)\n+\t{\n+\t  emit_insn (gen_cbranchbi4 (operands[2], op0, op1,\n+\t\t\t\t     operands[0]));\n+\t  DONE;\n+\t}\n+      else\n+\tabort ();\n+    }\n+\n+  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"bne\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t    (pc)))]\n+  \"\"\n+{\n+  rtx op0 = bfin_compare_op0, op1 = bfin_compare_op1;\n+  /* If we have a BImode input, then we already have a compare result, and\n+     do not need to emit another comparison.  */\n+  if (GET_MODE (bfin_compare_op0) == BImode)\n+    {\n+      if (bfin_compare_op1 == const0_rtx)\n+\t{\n+\t  rtx cmp = gen_rtx_NE (BImode, op0, op1);\n+\t  emit_insn (gen_cbranchbi4 (cmp, op0, op1, operands[0]));\n+\t  DONE;\n+\t}\n+      else\n+\tabort ();\n+    }\n+\n+  operands[1] = bfin_cc_rtx;\t/* hard register: CC */\n+  operands[2] = gen_rtx_EQ (BImode, op0, op1);\n+  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"bgt\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t    (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LE (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"bgtu\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t    (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LEU (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"blt\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t    (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LT (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"bltu\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LTU (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n+})\n+\n+\n+(define_expand \"bge\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LT (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"bgeu\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LTU (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_EQ (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"ble\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LE (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_expand \"bleu\"\n+  [(set (match_dup 1) (match_dup 2))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))\n+  ]\n+  \"\"\n+{\n+  operands[1] = bfin_cc_rtx;\n+  operands[2] = gen_rtx_LEU (BImode, bfin_compare_op0, bfin_compare_op1);\n+  operands[3] = gen_rtx_NE (BImode, operands[1], const0_rtx);\n+})\n+\n+(define_insn \"cbranchbi4\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"bfin_cbranch_operator\"\n+\t\t\t [(match_operand:BI 1 \"cc_operand\" \"C\")\n+\t\t\t  (match_operand:BI 2 \"immediate_operand\" \"P0\")])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+{\n+  asm_conditional_branch (insn, operands, 0, 0);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"brcc\")])\n+\n+;; Special cbranch patterns to deal with the speculative load problem - see\n+;; bfin_reorg for details.\n+\n+(define_insn \"cbranch_predicted_taken\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"bfin_cbranch_operator\"\n+\t\t\t [(match_operand:BI 1 \"cc_operand\" \"C\")\n+\t\t\t  (match_operand:BI 2 \"immediate_operand\" \"P0\")])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (unspec [(const_int 0)] UNSPEC_CBRANCH_TAKEN)]\n+  \"\"\n+{\n+  asm_conditional_branch (insn, operands, 0, 1);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"brcc\")])\n+\n+(define_insn \"cbranch_with_nops\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"bfin_cbranch_operator\"\n+\t\t\t [(match_operand:BI 1 \"cc_operand\" \"C\")\n+\t\t\t  (match_operand:BI 2 \"immediate_operand\" \"P0\")])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))\n+   (unspec [(match_operand 4 \"immediate_operand\" \"\")] UNSPEC_CBRANCH_NOPS)]\n+  \"reload_completed\"\n+{\n+  asm_conditional_branch (insn, operands, INTVAL (operands[4]), 0);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"brcc\")\n+   (set_attr \"length\" \"6\")])\n+\n+;; setcc insns.  */\n+(define_expand \"seq\"\n+  [(set (match_dup 1) (eq:BI (match_dup 2) (match_dup 3)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+{\n+  operands[2] = bfin_compare_op0;\n+  operands[3] = bfin_compare_op1;\n+  operands[1] = bfin_cc_rtx;\n+})\n+\n+(define_expand \"slt\"\n+  [(set (match_dup 1) (lt:BI (match_dup 2) (match_dup 3)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+{\n+   operands[2] = bfin_compare_op0;\n+   operands[3] = bfin_compare_op1;\n+   operands[1] = bfin_cc_rtx;\n+})\n+\n+(define_expand \"sle\"\n+  [(set (match_dup 1) (le:BI (match_dup 2) (match_dup 3)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+{\n+   operands[2] = bfin_compare_op0;\n+   operands[3] = bfin_compare_op1;\n+   operands[1] = bfin_cc_rtx;\n+})\n+\n+(define_expand \"sltu\"\n+  [(set (match_dup 1) (ltu:BI (match_dup 2) (match_dup 3)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+{\n+   operands[2] = bfin_compare_op0;\n+   operands[3] = bfin_compare_op1;\n+   operands[1] = bfin_cc_rtx;\n+})\n+\n+(define_expand \"sleu\"\n+  [(set (match_dup 1) (leu:BI (match_dup 2) (match_dup 3)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+{\n+   operands[2] = bfin_compare_op0;\n+   operands[3] = bfin_compare_op1;\n+   operands[1] = bfin_cc_rtx;\n+})\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop;\")\n+\n+;;;;;;;;;;;;;;;;;;;;   CC2dreg   ;;;;;;;;;;;;;;;;;;;;;;;;;\n+(define_insn \"movsibi\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C\")\n+\t(ne:BI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"CC = %1;\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"movbisi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ne:SI (match_operand:BI 1 \"cc_operand\" \"C\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"%0 = CC;\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:BI 0 \"cc_operand\" \"=C\")\n+\t(eq:BI (match_operand:BI 1 \"cc_operand\" \" 0\")\n+\t       (const_int 0)))]\n+  \"\"\n+  \"%0 = ! %0;\"    /*  NOT CC;\"  */\n+  [(set_attr \"type\" \"compare\")])\n+\n+;; Vector and DSP insns\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t   (const_int 24))\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (const_int 8))))]\n+  \"\"\n+  \"%0 = ALIGN8(%1, %2);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t   (const_int 16))\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (const_int 16))))]\n+  \"\"\n+  \"%0 = ALIGN16(%1, %2);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t   (const_int 8))\n+\t\t(lshiftrt:SI (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (const_int 24))))]\n+  \"\"\n+  \"%0 = ALIGN24(%1, %2);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+;; Prologue and epilogue.\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"bfin_expand_prologue (); DONE;\")\n+\n+(define_expand \"epilogue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"bfin_expand_epilogue (1, 0); DONE;\")\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"bfin_expand_epilogue (0, 0); DONE;\")\n+\n+(define_expand \"eh_return\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"\")]\n+\t\t    UNSPEC_VOLATILE_EH_RETURN)]\n+  \"\"\n+{\n+  emit_move_insn (EH_RETURN_HANDLER_RTX, operands[0]);\n+  emit_insn (gen_eh_return_internal ());\n+  emit_barrier ();\n+})\n+\n+(define_insn_and_split \"eh_return_internal\"\n+  [(unspec_volatile [(reg:SI REG_P2)] UNSPEC_VOLATILE_EH_RETURN)]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 1)]\n+  \"bfin_expand_epilogue (1, 1); DONE;\")\n+\n+(define_insn \"link\"\n+  [(set (mem:SI (plus:SI (reg:SI REG_SP) (const_int -4))) (reg:SI REG_RETS))\n+   (set (mem:SI (plus:SI (reg:SI REG_SP) (const_int -8))) (reg:SI REG_FP))\n+   (set (reg:SI REG_FP)\n+\t(plus:SI (reg:SI REG_SP) (const_int -8)))\n+   (set (reg:SI REG_SP)\n+\t(plus:SI (reg:SI REG_SP) (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"LINK %Z0;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"unlink\"\n+  [(set (reg:SI REG_FP) (mem:SI (reg:SI REG_FP)))\n+   (set (reg:SI REG_RETS) (mem:SI (plus:SI (reg:SI REG_FP) (const_int 4))))\n+   (set (reg:SI REG_SP) (plus:SI (reg:SI REG_FP) (const_int 8)))]\n+  \"\"\n+  \"UNLINK;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; This pattern is slightly clumsy.  The stack adjust must be the final SET in\n+;; the pattern, otherwise dwarf2out becomes very confused about which reg goes\n+;; where on the stack, since it goes through all elements of the parallel in\n+;; sequence.\n+(define_insn \"push_multiple\"\n+  [(match_parallel 0 \"push_multiple_operation\"\n+    [(unspec [(match_operand:SI 1 \"immediate_operand\" \"i\")] UNSPEC_PUSH_MULTIPLE)])]\n+  \"\"\n+{\n+  output_push_multiple (insn, operands);\n+  return \"\";\n+})\n+\n+(define_insn \"pop_multiple\"\n+  [(match_parallel 0 \"pop_multiple_operation\"\n+    [(set (reg:SI REG_SP)\n+\t  (plus:SI (reg:SI REG_SP) (match_operand:SI 1 \"immediate_operand\" \"i\")))])]\n+  \"\"\n+{\n+  output_pop_multiple (insn, operands);\n+  return \"\";\n+})\n+\n+(define_insn \"return_internal\"\n+  [(return)\n+   (unspec [(match_operand 0 \"immediate_operand\" \"i\")] UNSPEC_RETURN)]\n+  \"reload_completed\"\n+{\n+  switch (INTVAL (operands[0]))\n+    {\n+    case EXCPT_HANDLER:\n+      return \"rtx;\";\n+    case NMI_HANDLER:\n+      return \"rtn;\";\n+    case INTERRUPT_HANDLER:\n+      return \"rti;\";\n+    case SUBROUTINE:\n+      return \"rts;\";\n+    }\n+  gcc_unreachable ();\n+})\n+\n+;;; Vector instructions\n+\n+(define_insn \"addv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(plus:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 +|+ %2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"subv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(minus:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = %1 -|- %2;\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"sminv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(smin:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = MIN (%1, %2) (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"smaxv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(smax:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = MAX (%1, %2) (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"mulv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(mult:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:V2HI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%h0 = %h1 * %h2, %d0 = %d1 * %d2 (IS);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"negv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(neg:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = - %1 (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+\n+(define_insn \"absv2hi\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(abs:V2HI (match_operand:V2HI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"%0 = ABS %1 (V);\"\n+  [(set_attr \"type\" \"dsp32\")])\n+"}, {"sha": "b09d4ddf177781de4e1d980b59e2933946b65a2d", "filename": "gcc/config/bfin/bfin.opt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fbfin.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.opt?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,36 @@\n+; Options for the Blackfin port of the compiler\n+;\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+; 02111-1307, USA.\n+\n+momit-leaf-frame-pointer\n+Target Report Mask(OMIT_LEAF_FRAME_POINTER)\n+Omit frame pointer for leaf functions\n+\n+mlow64k\n+Target Report Mask(LOW_64K)\n+Program is entirely located in low 64k of memory.\n+\n+mcsync\n+Target Report Mask(CSYNC)\n+Avoid speculative loads by inserting CSYNC or equivalent\n+\n+mid-shared-library\n+Target Report Mask(ID_SHARED_LIBRARY)\n+Enabled ID based shared library"}, {"sha": "69e670070912e966732d0c04d331b763bf8e14a3", "filename": "gcc/config/bfin/crti.s", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fcrti.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fcrti.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fcrti.s?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,47 @@\n+/* Specialized code needed to support construction and destruction of\n+   file-scope objects in C++ and Java code, and to support exception handling.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Analog Devices.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/*\n+ * This file just supplies function prologues for the .init and .fini\n+ * sections.  It is linked in before crtbegin.o.\n+ */\n+\n+\t.file   \"crti.o\"\n+\t.ident  \"GNU C crti.o\"\n+\n+\t.section .init\n+\t.globl  _init\n+\t.type   _init,@function\n+_init:\n+\tLINK 0;\n+\n+\t.section .fini\n+\t.globl  _fini\n+\t.type   _fini,@function\n+_fini:\n+\tLINK 0; "}, {"sha": "fb25b77c5f9645235f77fc377a2d5c9a18d237ad", "filename": "gcc/config/bfin/crtn.s", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fcrtn.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fcrtn.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fcrtn.s?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,43 @@\n+/* Specialized code needed to support construction and destruction of\n+   file-scope objects in C++ and Java code, and to support exception handling.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Analog Devices.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/*\n+ * This file supplies function epilogues for the .init and .fini sections.\n+ * It is linked in after all other files.\n+ */\n+\n+\t.file   \"crtn.o\"\n+\t.ident  \"GNU C crtn.o\"\n+\n+\t.section .init\n+\tunlink; \n+\trts;\n+\n+\t.section .fini\n+\tunlink;\n+\trts;"}, {"sha": "643d5197a677615abbd7d97a4131e6305bb4a94b", "filename": "gcc/config/bfin/elf.h", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Felf.h?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,16 @@\n+#define OBJECT_FORMAT_ELF\n+\n+#define LOCAL_LABEL_PREFIX \"L$\"\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\\\n+     sprintf (LABEL, \"*%s%s$%d\", LOCAL_LABEL_PREFIX, PREFIX, (int) NUM)\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC\t\"crt0%O%s crti%O%s crtbegin%O%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC\t\"crtend%O%s crtn%O%s\"\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\""}, {"sha": "778d056fbf42576a38832dd74afa0b17bc0159a8", "filename": "gcc/config/bfin/lib1funcs.asm", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Flib1funcs.asm?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,120 @@\n+/* libgcc functions for Blackfin.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Analog Devices.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\n+#ifdef L_divsi3\n+.text\n+.align 2\n+.global ___divsi3;\n+.type ___divsi3, STT_FUNC;\n+\n+___divsi3:\n+        [--SP]= RETS;\n+\t[--SP] = R7;\n+\n+\tR2 = -R0;\n+        CC = R0 < 0;\n+\tIF CC R0 = R2;\n+\tR7 = CC;\n+\n+\tR2 = -R1;\n+        CC = R1 < 0;\n+\tIF CC R1 = R2;\n+\tR2 = CC;\n+\tR7 = R7 ^ R2;\n+\n+        CALL ___udivsi3;\n+\n+\tCC = R7;\n+\tR1 = -R0;\n+\tIF CC R0 = R1;\n+\n+\tR7 = [SP++];\n+        RETS = [SP++];\n+        RTS;\n+#endif\n+\n+#ifdef L_modsi3\t\n+.align 2\n+.global ___modsi3;\n+.type ___modsi3, STT_FUNC;\n+\n+___modsi3:\n+        [--SP] = RETS;\n+\t/* P1 and P2 are preserved by divsi3 and udivsi3.  */\n+\tP1 = R0;\n+\tP2 = R1;\n+        CALL ___divsi3;\n+\tR1 = P1;\n+\tR2 = P2;\n+\tR2 *= R0;\n+\tR0 = R1 - R2;\n+\tRETS = [SP++];\n+        RTS; \n+#endif\n+\n+#ifdef L_udivsi3\n+.align 2\n+.global ___udivsi3;\n+.type ___udivsi3, STT_FUNC;\n+\n+___udivsi3:\n+        P0 = 32;\n+        LSETUP (0f, 1f) LC0 = P0;\n+\t/* upper half of dividend */\n+        R3 = 0;\n+0:\n+\t/* The first time round in the loop we shift in garbage, but since we\n+\t   perform 33 shifts, it doesn't matter.  */\n+\tR0 = ROT R0 BY 1;\n+\tR3 = ROT R3 BY 1;\n+\tR2 = R3 - R1;\n+        CC = R3 < R1 (IU);\n+1:\n+\t/* Last instruction of the loop.  */\n+\tIF ! CC R3 = R2;\n+\n+\t/* Shift in the last bit.  */\n+\tR0 = ROT R0 BY 1;\n+\t/* R0 is the result, R3 contains the remainder.  */\n+\tR0 = ~ R0;\n+        RTS;\n+#endif\n+\n+#ifdef L_umodsi3\n+.align 2\n+.global ___umodsi3;\n+.type ___umodsi3, STT_FUNC;\n+\n+___umodsi3:\n+        P1 = RETS;\n+        CALL ___udivsi3;\n+\tR0 = R3;\n+\tRETS = P1; \n+        RTS;\n+#endif\n+"}, {"sha": "53448844dda4d829e47d377e81eb20bcda647212", "filename": "gcc/config/bfin/predicates.md", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,127 @@\n+;; Predicate definitions for the Blackfin.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Return nonzero iff OP is one of the integer constants 1 or 2.\n+(define_predicate \"pos_scale_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 1 || INTVAL (op) == 2\")))\n+\n+;; Return nonzero iff OP is one of the integer constants 2 or 4.\n+(define_predicate \"scale_by_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4\")))\n+\n+;; Return nonzero if OP is a constant that consists of two parts; lower\n+;; bits all zero and upper bits all ones.  In this case, we can perform\n+;; an AND operation with a sequence of two shifts.  Don't return nonzero\n+;; if the constant would be cheap to load.\n+(define_predicate \"highbits_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"log2constp (-INTVAL (op)) && !CONST_7BIT_IMM_P (INTVAL (op))\")))\n+\n+;; Return nonzero if OP is suitable as a right-hand side operand for an\n+;; andsi3 operation.\n+(define_predicate \"rhs_andsi3_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"log2constp (~INTVAL (op)) || INTVAL (op) == 255 || INTVAL (op) == 65535\"))))\n+\n+;; Return nonzero if OP is a register or a constant with exactly one bit\n+;; set.\n+(define_predicate \"regorlog2_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"log2constp (INTVAL (op))\"))))\n+\n+;; Like register_operand, but make sure that hard regs have a valid mode.\n+(define_predicate \"valid_reg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (REGNO (op) < FIRST_PSEUDO_REGISTER)\n+    return HARD_REGNO_MODE_OK (REGNO (op), mode);\n+  return 1;\n+})\n+\n+;; Return nonzero if OP is the CC register.\n+(define_predicate \"cc_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == REG_CC && GET_MODE (op) == BImode\")))\n+\n+;; Return nonzero if OP is a register or a 7 bit signed constant.\n+(define_predicate \"reg_or_7bit_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_7BIT_IMM_P (INTVAL (op))\"))))\n+\n+;; Used for secondary reloads, this function returns 1 if OP is of the\n+;; form (plus (fp) (const_int)).\n+(define_predicate \"fp_plus_const_operand\"\n+  (match_code \"plus\")\n+{\n+  rtx op1, op2;\n+\n+  op1 = XEXP (op, 0);\n+  op2 = XEXP (op, 1);\n+  return (REG_P (op1)\n+\t  && (REGNO (op1) == FRAME_POINTER_REGNUM\n+\t      || REGNO (op1) == STACK_POINTER_REGNUM)\n+\t  && GET_CODE (op2) == CONST_INT);\n+})\n+\n+;; Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n+;; possibly with an offset.\n+(define_predicate \"symbolic_operand\"\n+  (ior (match_code \"symbol_ref,label_ref\")\n+       (and (match_code \"const\")\n+\t    (match_test \"GET_CODE (XEXP (op,0)) == PLUS\n+\t\t\t && (GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t\t\t     || GET_CODE (XEXP (XEXP (op, 0), 0)) == LABEL_REF)\n+\t\t\t && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\"))))\n+\n+;; Returns 1 if OP is a plain constant or matched by symbolic_operand.\n+(define_predicate \"symbolic_or_const_operand\"\n+  (ior (match_code \"const_int,const_double\")\n+       (match_operand 0 \"symbolic_operand\")))\n+\n+;; True for any non-virtual or eliminable register.  Used in places where\n+;; instantiation of such a register may cause the pattern to not be recognized.\n+(define_predicate \"register_no_elim_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return !(op == arg_pointer_rtx\n+\t   || op == frame_pointer_rtx\n+\t   || (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t       && REGNO (op) <= LAST_VIRTUAL_REGISTER));\n+})\n+\n+;; Test for a valid operand for a call instruction.  Don't allow the\n+;; arg pointer register or virtual regs since they may decay into\n+;; reg + const, which the patterns can't handle.\n+;; We only allow SYMBOL_REF if !flag_pic.\n+(define_predicate \"call_insn_operand\"\n+  (ior (and (match_test \"!flag_pic\") (match_code \"symbol_ref\"))\n+       (match_operand 0 \"register_no_elim_operand\")))\n+\n+;; Test for an operator valid in a conditional branch\n+(define_predicate \"bfin_cbranch_operator\"\n+  (match_code \"eq,ne\"))"}, {"sha": "662dc4c3e607c34f2f1c3846454d6b92ceccf72a", "filename": "gcc/config/bfin/t-bfin", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Ft-bfin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Ft-bfin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Ft-bfin?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,29 @@\n+## Target part of the Makefile\n+\n+LIB1ASMSRC = bfin/lib1funcs.asm\n+LIB1ASMFUNCS = _divsi3 _udivsi3 _umodsi3 _modsi3\n+\n+EXTRA_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+# This shouldn't be needed here.  I added it to the specs file for now, until\n+# it is fixed in binutils (if it is necessary).\n+GCC_CFLAGS += -N\n+\n+# Assemble startup files.\n+$(T)crti.o: $(srcdir)/config/bfin/crti.s $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/bfin/crti.s\n+\n+$(T)crtn.o: $(srcdir)/config/bfin/crtn.s $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/bfin/crtn.s"}, {"sha": "662dc4c3e607c34f2f1c3846454d6b92ceccf72a", "filename": "gcc/config/bfin/t-bfin-elf", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Ft-bfin-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fconfig%2Fbfin%2Ft-bfin-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Ft-bfin-elf?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -0,0 +1,29 @@\n+## Target part of the Makefile\n+\n+LIB1ASMSRC = bfin/lib1funcs.asm\n+LIB1ASMFUNCS = _divsi3 _udivsi3 _umodsi3 _modsi3\n+\n+EXTRA_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+# This shouldn't be needed here.  I added it to the specs file for now, until\n+# it is fixed in binutils (if it is necessary).\n+GCC_CFLAGS += -N\n+\n+# Assemble startup files.\n+$(T)crti.o: $(srcdir)/config/bfin/crti.s $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/bfin/crti.s\n+\n+$(T)crtn.o: $(srcdir)/config/bfin/crtn.s $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/bfin/crtn.s"}, {"sha": "23b046d1bd1f562ca5a6f1e13f149cc5379d8e62", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -1724,6 +1724,13 @@ on data in the eight bit data area.  Note the eight bit data area is limited to\n You must use GAS and GLD from GNU binutils version 2.7 or later for\n this attribute to work correctly.\n \n+@item exception_handler\n+@cindex exception handler functions on the Blackfin processor\n+Use this attribute on the Blackfin to indicate that the specified function\n+is an exception handler.  The compiler will generate function entry and\n+exit sequences suitable for use in an exception handler when this\n+attribute is present.\n+\n @item far\n @cindex functions which handle memory bank switching\n On 68HC11 and 68HC12 the @code{far} attribute causes the compiler to\n@@ -1872,8 +1879,8 @@ that the specified function is an interrupt handler.  The compiler will\n generate function entry and exit sequences suitable for use in an\n interrupt handler when this attribute is present.\n \n-Note, interrupt handlers for the m68k, H8/300, H8/300H, H8S, and SH processors\n-can be specified via the @code{interrupt_handler} attribute.\n+Note, interrupt handlers for the Blackfin, m68k, H8/300, H8/300H, H8S, and\n+SH processors can be specified via the @code{interrupt_handler} attribute.\n \n Note, on the AVR, interrupts will be enabled inside the function.\n \n@@ -1887,11 +1894,17 @@ void f () __attribute__ ((interrupt (\"IRQ\")));\n Permissible values for this parameter are: IRQ, FIQ, SWI, ABORT and UNDEF@.\n \n @item interrupt_handler\n-@cindex interrupt handler functions on the m68k, H8/300 and SH processors\n-Use this attribute on the m68k, H8/300, H8/300H, H8S, and SH to indicate that\n-the specified function is an interrupt handler.  The compiler will generate\n-function entry and exit sequences suitable for use in an interrupt\n-handler when this attribute is present.\n+@cindex interrupt handler functions on the Blackfin, m68k, H8/300 and SH processors\n+Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S, and SH to\n+indicate that the specified function is an interrupt handler.  The compiler\n+will generate function entry and exit sequences suitable for use in an\n+interrupt handler when this attribute is present.\n+\n+@item kspisusp\n+@cindex User stack pointer in interrupts on the Blackfin\n+When used together with @code{interrupt_handler}, @code{exception_handler}\n+or @code{nmi_handler}, code will be generated to load the stack pointer\n+from the USP register in the function prologue.\n \n @item long_call/short_call\n @cindex indirect calls on ARM\n@@ -1971,6 +1984,19 @@ use the normal calling convention based on @code{jsr} and @code{rts}.\n This attribute can be used to cancel the effect of the @option{-mlong-calls}\n option.\n \n+@item nesting\n+@cindex Allow nesting in an interrupt handler on the Blackfin processor.\n+Use this attribute together with @code{interrupt_handler},\n+@code{exception_handler} or @code{nmi_handler} to indicate that the function\n+entry code should enable nested interrupts or exceptions.\n+\n+@item nmi_handler\n+@cindex NMI handler functions on the Blackfin processor\n+Use this attribute on the Blackfin to indicate that the specified function\n+is an NMI handler.  The compiler will generate function entry and\n+exit sequences suitable for use in an NMI handler when this\n+attribute is present.\n+\n @item no_instrument_function\n @cindex @code{no_instrument_function} function attribute\n @opindex finstrument-functions\n@@ -2125,8 +2151,8 @@ The @code{longjmp}-like counterpart of such function, if any, might need\n to be marked with the @code{noreturn} attribute.\n \n @item saveall\n-@cindex save all registers on the H8/300, H8/300H, and H8S\n-Use this attribute on the H8/300, H8/300H, and H8S to indicate that\n+@cindex save all registers on the Blackfin, H8/300, H8/300H, and H8S\n+Use this attribute on the Blackfin, H8/300, H8/300H, and H8S to indicate that\n all registers except the stack pointer should be saved in the prologue\n regardless of whether they are used or not.\n "}, {"sha": "09bc9fc2fcf3f5958e88f3987208d8eb02c83ec1", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -2176,6 +2176,8 @@ GNU Compiler Collection on your machine.\n @item\n @uref{#avr,,avr}\n @item\n+@uref{#bfin,,Blackfin}\n+@item\n @uref{#c4x,,c4x}\n @item\n @uref{#dos,,DOS}\n@@ -2487,6 +2489,23 @@ The following error:\n \n indicates that you should upgrade to a newer version of the binutils.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{bfin}Blackfin\n+\n+The Blackfin processor, an Analog Devices DSP.\n+@ifnothtml\n+@xref{Blackfin Options,, Blackfin Options, gcc, Using and Porting the GNU\n+Compiler Collection (GCC)},\n+@end ifnothtml\n+@ifhtml\n+See ``Blackfin Options'' in the main manual\n+@end ifhtml\n+\n+More information, and a version of binutils with support for this processor,\n+is available at @uref{http://blackfin.uclinux.org}\n+\n @html\n <hr />\n @end html"}, {"sha": "2fe6bd945714be664c8bc7fea8093fe5e136b2e4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -401,6 +401,11 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-mmcu=@var{mcu}  -msize  -minit-stack=@var{n}  -mno-interrupts @gol\n -mcall-prologues  -mno-tablejump  -mtiny-stack  -mint8}\n \n+@emph{Blackfin Options}\n+@gccoptlist{-momit-leaf-frame-pointer -mno-omit-leaf-frame-pointer -mcsync @gol\n+-mno-csync -mlow-64k -mno-low64k -mid-shared-library @gol\n+-mno-id-shared-library -mshared-library-id=@var{n} @gol}\n+\n @emph{CRIS Options}\n @gccoptlist{-mcpu=@var{cpu}  -march=@var{cpu}  -mtune=@var{cpu} @gol\n -mmax-stack-frame=@var{n}  -melinux-stacksize=@var{n} @gol\n@@ -6730,6 +6735,7 @@ that macro, which enables you to change the defaults.\n * ARC Options::\n * ARM Options::\n * AVR Options::\n+* Blackfin Options::\n * CRIS Options::\n * Darwin Options::\n * DEC Alpha Options::\n@@ -7181,6 +7187,57 @@ comply to the C standards, but it will provide you with smaller code\n size.\n @end table\n \n+@node Blackfin Options\n+@subsection Blackfin Options\n+@cindex Blackfin Options\n+\n+@table @gcctabopt\n+@item -momit-leaf-frame-pointer\n+@opindex momit-leaf-frame-pointer\n+Don't keep the frame pointer in a register for leaf functions.  This\n+avoids the instructions to save, set up and restore frame pointers and\n+makes an extra register available in leaf functions.  The option\n+@option{-fomit-frame-pointer} removes the frame pointer for all functions\n+which might make debugging harder.\n+\n+@item -mcsync\n+@opindex mcsync\n+When enabled, the compiler will ensure that the generated code does not\n+contain speculative loads after jump instructions.  This option is enabled\n+by default.\n+\n+@item -mno-csync\n+@opindex mno-csync\n+Don't generate extra code to prevent speculative loads from occurring.\n+\n+@item -mlow-64k\n+@opindex\n+When enabled, the compiler is free to take advantage of the knowledge that\n+the entire program fits into the low 64k of memory.\n+\n+@item -mno-low-64k\n+@opindex mno-low-64k\n+Assume that the program is arbitrarily large.  This is the default.\n+\n+@item -mid-shared-library\n+@opindex mid-shared-library\n+Generate code that supports shared libraries via the library ID method.\n+This allows for execute in place and shared libraries in an environment\n+without virtual memory management.  This option implies @option{-fPIC}.\n+\n+@item -mno-id-shared-library\n+@opindex mno-id-shared-library\n+Generate code that doesn't assume ID based shared libraries are being used.\n+This is the default.\n+\n+@item -mshared-library-id=n\n+@opindex mshared-library-id\n+Specified the identification number of the ID based shared library being\n+compiled.  Specifying a value of 0 will generate more compact code, specifying\n+other values will force the allocation of that number to the current\n+library but is no more space or time efficient than omitting this option.\n+@end table\n+\n @node CRIS Options\n @subsection CRIS Options\n @cindex CRIS Options"}, {"sha": "460023091f4e71f270e95cf91e594d7a836eb26b", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4a78eb9ed6ce9be5ce94654cd22628481c771e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0d4a78eb9ed6ce9be5ce94654cd22628481c771e", "patch": "@@ -2069,6 +2069,102 @@ range of 1 to 2047.\n \n @end table\n \n+@item Blackfin family---@file{bfin.h}\n+@table @code\n+@item a\n+P register\n+\n+@item d\n+D register\n+\n+@item z\n+A call clobbered P register.\n+\n+@item D\n+Even-numbered D register\n+\n+@item W\n+Odd-numbered D register\n+\n+@item e\n+Accumulator register.\n+\n+@item A\n+Even-numbered accumulator register.\n+\n+@item B\n+Odd-numbered accumulator register.\n+\n+@item b\n+I register\n+\n+@item B\n+B register\n+\n+@item f\n+M register\n+\n+@item c\n+Registers used for circular buffering, i.e. I, B, or L registers.\n+\n+@item C\n+The CC register.\n+\n+@item x\n+Any D, P, B, M, I or L register.\n+\n+@item y\n+Additional registers typically used only in prologues and epilogues: RETS,\n+RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.\n+\n+@item w\n+Any register except accumulators or CC.\n+\n+@item Ksh\n+Signed 16 bit integer (in the range -32768 to 32767)\n+\n+@item Kuh\n+Unsigned 16 bit integer (in the range 0 to 65535)\n+\n+@item Ks7\n+Signed 7 bit integer (in the range -64 to 63)\n+\n+@item Ku7\n+Unsigned 7 bit integer (in the range 0 to 127)\n+\n+@item Ku5\n+Unsigned 5 bit integer (in the range 0 to 31)\n+\n+@item Ks4\n+Signed 4 bit integer (in the range -8 to 7)\n+\n+@item Ks3\n+Signed 3 bit integer (in the range -3 to 4)\n+\n+@item Ku3\n+Unsigned 3 bit integer (in the range 0 to 7)\n+\n+@item P@var{n}\n+Constant @var{n}, where @var{n} is a single-digit constant in the range 0 to 4.\n+\n+@item M1\n+Constant 255.\n+\n+@item M2\n+Constant 65535.\n+\n+@item J\n+An integer constant with exactly a single bit set.\n+\n+@item L\n+An integer constant with all bits set except exactly one.\n+\n+@item H\n+\n+@item Q\n+Any SYMBOL_REF.\n+@end table\n+\n @item IP2K---@file{ip2k.h}\n @table @code\n @item a"}]}