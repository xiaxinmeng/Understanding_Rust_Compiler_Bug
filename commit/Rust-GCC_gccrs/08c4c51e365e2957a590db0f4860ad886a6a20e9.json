{"sha": "08c4c51e365e2957a590db0f4860ad886a6a20e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjNGM1MWUzNjVlMjk1N2E1OTBkYjBmNDg2MGFkODg2YTZhMjBlOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-08-07T23:51:27Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-08-07T23:51:27Z"}, "message": "re PR target/81593 (Optimize PowerPC vector set from vector extract)\n\n[gcc]\n2017-08-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/81593\n\t* config/rs6000/vsx.md (vsx_concat_<mode>, VSX_D): Cleanup\n\tconstraints since the -mupper-regs-* switches have been\n\teliminated.\n\t(vsx_concat_<mode>_1): New combiner insns to recognize inserting\n\tinto a vector from a double word element that was extracted from\n\tanother vector, and eliminate extra XXPERMDI instructions.\n\t(vsx_concat_<mode>_2): Likewise.\n\t(vsx_concat_<mode>_3): Likewise.\n\t(vsx_set_<mode>, VSX_D): Rewrite vector set in terms of vector\n\tconcat to allow optimizing inserts from previous extracts.\n\n[gcc/testsuite]\n2017-08-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/81593\n\t* gcc.target/powerpc/vec-setup.h: New tests to test various\n\tcombinations of setting up vectors of 2 double word elements.\n\t* gcc.target/powerpc/vec-setup-long.c: Likewise.\n\t* gcc.target/powerpc/vec-setup-double.c: Likewise.\n\t* gcc.target/powerpc/vec-setup-be-long.c: Likewise.\n\t* gcc.target/powerpc/vec-setup-be-double.c: Likewise.\n\t* gcc.target/powerpc/vsx-extract-6.c: New tests for optimzing\n\tvector inserts from vector extracts.\n\t* gcc.target/powerpc/vsx-extract-7.c: Likewise.\n\nFrom-SVN: r250936", "tree": {"sha": "c99cbe4963984941b131f2ad8788c4096940ff47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c99cbe4963984941b131f2ad8788c4096940ff47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c4c51e365e2957a590db0f4860ad886a6a20e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c4c51e365e2957a590db0f4860ad886a6a20e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c4c51e365e2957a590db0f4860ad886a6a20e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c4c51e365e2957a590db0f4860ad886a6a20e9/comments", "author": null, "committer": null, "parents": [{"sha": "1abeb09f83033e0dce2aee908a4021ed9e1d3300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1abeb09f83033e0dce2aee908a4021ed9e1d3300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1abeb09f83033e0dce2aee908a4021ed9e1d3300"}], "stats": {"total": 606, "additions": 588, "deletions": 18}, "files": [{"sha": "823da542a693ea589cfd62346f9933e59859a4a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -1,3 +1,17 @@\n+2017-08-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/81593\n+\t* config/rs6000/vsx.md (vsx_concat_<mode>, VSX_D): Cleanup\n+\tconstraints since the -mupper-regs-* switches have been\n+\teliminated.\n+\t(vsx_concat_<mode>_1): New combiner insns to recognize inserting\n+\tinto a vector from a double word element that was extracted from\n+\tanother vector, and eliminate extra XXPERMDI instructions.\n+\t(vsx_concat_<mode>_2): Likewise.\n+\t(vsx_concat_<mode>_3): Likewise.\n+\t(vsx_set_<mode>, VSX_D): Rewrite vector set in terms of vector\n+\tconcat to allow optimizing inserts from previous extracts.\n+\n 2017-08-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_stack_protect_guard): Generate"}, {"sha": "510294d97eb395f4587a4e662dc6c9bd52ba22e7", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 102, "deletions": 18, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -2364,10 +2364,10 @@\n \n ;; Build a V2DF/V2DI vector from two scalars\n (define_insn \"vsx_concat_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"gpc_reg_operand\" \"=<VSa>,we\")\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa,we\")\n \t(vec_concat:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"<VS_64reg>,b\")\n-\t (match_operand:<VS_scalar> 2 \"gpc_reg_operand\" \"<VS_64reg>,b\")))]\n+\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"wa,b\")\n+\t (match_operand:<VS_scalar> 2 \"gpc_reg_operand\" \"wa,b\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   if (which_alternative == 0)\n@@ -2385,6 +2385,80 @@\n }\n   [(set_attr \"type\" \"vecperm\")])\n \n+;; Combiner patterns to allow creating XXPERMDI's to access either double\n+;; word element in a vector register.\n+(define_insn \"*vsx_concat_<mode>_1\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n+\t(vec_concat:VSX_D\n+\t (vec_select:<VS_scalar>\n+\t  (match_operand:VSX_D 1 \"gpc_reg_operand\" \"wa\")\n+\t  (parallel [(match_operand:QI 2 \"const_0_to_1_operand\" \"n\")]))\n+\t (match_operand:<VS_scalar> 3 \"gpc_reg_operand\" \"wa\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+{\n+  HOST_WIDE_INT dword = INTVAL (operands[2]);\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      operands[4] = GEN_INT (2*dword);\n+      return \"xxpermdi %x0,%x1,%x3,%4\";\n+    }\n+  else\n+    {\n+      operands[4] = GEN_INT (!dword);\n+      return \"xxpermdi %x0,%x3,%x1,%4\";\n+    }\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*vsx_concat_<mode>_2\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n+\t(vec_concat:VSX_D\n+\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"wa\")\n+\t (vec_select:<VS_scalar>\n+\t  (match_operand:VSX_D 2 \"gpc_reg_operand\" \"wa\")\n+\t  (parallel [(match_operand:QI 3 \"const_0_to_1_operand\" \"n\")]))))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+{\n+  HOST_WIDE_INT dword = INTVAL (operands[3]);\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      operands[4] = GEN_INT (dword);\n+      return \"xxpermdi %x0,%x1,%x2,%4\";\n+    }\n+  else\n+    {\n+      operands[4] = GEN_INT (2 * !dword);\n+      return \"xxpermdi %x0,%x2,%x1,%4\";\n+    }\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*vsx_concat_<mode>_3\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n+\t(vec_concat:VSX_D\n+\t (vec_select:<VS_scalar>\n+\t  (match_operand:VSX_D 1 \"gpc_reg_operand\" \"wa\")\n+\t  (parallel [(match_operand:QI 2 \"const_0_to_1_operand\" \"n\")]))\n+\t (vec_select:<VS_scalar>\n+\t  (match_operand:VSX_D 3 \"gpc_reg_operand\" \"wa\")\n+\t  (parallel [(match_operand:QI 4 \"const_0_to_1_operand\" \"n\")]))))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+{\n+  HOST_WIDE_INT dword1 = INTVAL (operands[2]);\n+  HOST_WIDE_INT dword2 = INTVAL (operands[4]);\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      operands[5] = GEN_INT ((2 * dword1) + dword2);\n+      return \"xxpermdi %x0,%x1,%x3,%5\";\n+    }\n+  else\n+    {\n+      operands[5] = GEN_INT ((2 * !dword2) + !dword1);\n+      return \"xxpermdi %x0,%x3,%x1,%5\";\n+    }\n+}\n+  [(set_attr \"type\" \"vecperm\")])\n+\n ;; Special purpose concat using xxpermdi to glue two single precision values\n ;; together, relying on the fact that internally scalar floats are represented\n ;; as doubles.  This is used to initialize a V4SF vector with 4 floats\n@@ -2585,25 +2659,35 @@\n   DONE;\n })\n \n-;; Set the element of a V2DI/VD2F mode\n-(define_insn \"vsx_set_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,?<VSa>\")\n-\t(unspec:VSX_D\n-\t [(match_operand:VSX_D 1 \"vsx_register_operand\" \"wd,<VSa>\")\n-\t  (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"<VS_64reg>,<VSa>\")\n-\t  (match_operand:QI 3 \"u5bit_cint_operand\" \"i,i\")]\n-\t UNSPEC_VSX_SET))]\n+;; Rewrite V2DF/V2DI set in terms of VEC_CONCAT\n+(define_expand \"vsx_set_<mode>\"\n+  [(use (match_operand:VSX_D 0 \"vsx_register_operand\"))\n+   (use (match_operand:VSX_D 1 \"vsx_register_operand\"))\n+   (use (match_operand:<VS_scalar> 2 \"gpc_reg_operand\"))\n+   (use (match_operand:QI 3 \"const_0_to_1_operand\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n-  int idx_first = BYTES_BIG_ENDIAN ? 0 : 1;\n-  if (INTVAL (operands[3]) == idx_first)\n-    return \\\"xxpermdi %x0,%x2,%x1,1\\\";\n-  else if (INTVAL (operands[3]) == 1 - idx_first)\n-    return \\\"xxpermdi %x0,%x1,%x2,0\\\";\n+  rtx dest = operands[0];\n+  rtx vec_reg = operands[1];\n+  rtx value = operands[2];\n+  rtx ele = operands[3];\n+  rtx tmp = gen_reg_rtx (<VS_scalar>mode);\n+\n+  if (ele == const0_rtx)\n+    {\n+      emit_insn (gen_vsx_extract_<mode> (tmp, vec_reg, const1_rtx));\n+      emit_insn (gen_vsx_concat_<mode> (dest, value, tmp));\n+      DONE;\n+    }\n+  else if (ele == const1_rtx)\n+    {\n+      emit_insn (gen_vsx_extract_<mode> (tmp, vec_reg, const0_rtx));\n+      emit_insn (gen_vsx_concat_<mode> (dest, tmp, value));\n+      DONE;\n+    }\n   else\n     gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"vecperm\")])\n+})\n \n ;; Extract a DF/DI element from V2DF/V2DI\n ;; Optimize cases were we can do a simple or direct move."}, {"sha": "c2119f478bab1a293159a2385cc8facdf09c04d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -1,3 +1,16 @@\n+2017-08-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/81593\n+\t* gcc.target/powerpc/vec-setup.h: New tests to test various\n+\tcombinations of setting up vectors of 2 double word elements.\n+\t* gcc.target/powerpc/vec-setup-long.c: Likewise.\n+\t* gcc.target/powerpc/vec-setup-double.c: Likewise.\n+\t* gcc.target/powerpc/vec-setup-be-long.c: Likewise.\n+\t* gcc.target/powerpc/vec-setup-be-double.c: Likewise.\n+\t* gcc.target/powerpc/vsx-extract-6.c: New tests for optimzing\n+\tvector inserts from vector extracts.\n+\t* gcc.target/powerpc/vsx-extract-7.c: Likewise.\n+\n 2017-08-07  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/68829"}, {"sha": "acf429acaa90940c0bf7d1b4959e88ad25a090a7", "filename": "gcc/testsuite/gcc.target/powerpc/vec-setup-be-double.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-be-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-be-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-be-double.c?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+/* Test various ways of creating vectors with 2 double words and accessing the\n+   elements.  This test uses the double datatype.\n+\n+   This test explicitly tests -maltivec=be to make sure things are correct.  */\n+\n+#define DO_DOUBLE\n+\n+#include \"vec-setup.h\""}, {"sha": "492cd2d76a24d3d1cfb746d72d1155aa089a56d1", "filename": "gcc/testsuite/gcc.target/powerpc/vec-setup-be-long.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-be-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-be-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-be-long.c?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run { target { powerpc64le*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx -maltivec=be\" } */\n+\n+/* Test various ways of creating vectors with 2 double words and accessing the\n+   elements.  This test uses the long (on 64-bit systems) or long long datatype\n+   (on 32-bit systems).\n+\n+   This test explicitly tests -maltivec=be to make sure things are correct.  */\n+\n+#include \"vec-setup.h\""}, {"sha": "36c6405caf79b3cd7ffcec899bdb185299b99824", "filename": "gcc/testsuite/gcc.target/powerpc/vec-setup-double.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-double.c?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+/* Test various ways of creating vectors with 2 double words and accessing the\n+   elements.  This test uses the double datatype and the default endian\n+   order.  */\n+\n+#define DO_DOUBLE\n+\n+#include \"vec-setup.h\""}, {"sha": "5588e1586f3c07b1230552c2e05ee8d692eadc65", "filename": "gcc/testsuite/gcc.target/powerpc/vec-setup-long.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-long.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-long.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup-long.c?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+/* Test various ways of creating vectors with 2 double words and accessing the\n+   elements.  This test uses the long (on 64-bit systems) or long long datatype\n+   (on 32-bit systems).  The default endian order is used.  */\n+\n+#include \"vec-setup.h\""}, {"sha": "9e251646d2d5a62385b4d3961b78cd85297326e5", "filename": "gcc/testsuite/gcc.target/powerpc/vec-setup.h", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-setup.h?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,366 @@\n+#include <altivec.h>\n+\n+/* Test various ways of creating vectors with 2 double words and accessing the\n+   elements.  This include files supports:\n+\n+\t testing double\n+\t testing long on 64-bit systems\n+\t testing long long on 32-bit systems.\n+\n+   The endian support is:\n+\n+\tbig endian\n+\tlittle endian with little endian element ordering\n+\tlittle endian with big endian element ordering.  */\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#define DEBUG0(STR)\t\tfputs (STR, stdout)\n+#define DEBUG2(STR,A,B)\t\tprintf (STR, A, B)\n+\n+static int errors = 0;\n+\n+#else\n+#include <stdlib.h>\n+#define DEBUG0(STR)\n+#define DEBUG2(STR,A,B)\n+#endif\n+\n+#if defined(DO_DOUBLE)\n+#define TYPE\tdouble\n+#define STYPE\t\"double\"\n+#define ZERO\t0.0\n+#define ONE\t1.0\n+#define TWO\t2.0\n+#define THREE\t3.0\n+#define FOUR\t4.0\n+#define FIVE\t5.0\n+#define SIX\t6.0\n+#define FMT\t\"g\"\n+\n+#elif defined(_ARCH_PPC64)\n+#define TYPE\tlong\n+#define STYPE\t\"long\"\n+#define ZERO\t0L\n+#define ONE\t1L\n+#define TWO\t2L\n+#define THREE\t3L\n+#define FOUR\t4L\n+#define FIVE\t5L\n+#define SIX\t6L\n+#define FMT\t\"ld\"\n+\n+#else\n+#define TYPE\tlong long\n+#define STYPE\t\"long long\"\n+#define ZERO\t0LL\n+#define ONE\t1LL\n+#define TWO\t2LL\n+#define THREE\t3LL\n+#define FOUR\t4LL\n+#define FIVE\t5LL\n+#define SIX\t6LL\n+#define FMT\t\"lld\"\n+#endif\n+\n+/* Macros to order the left/right values correctly.  Note, -maltivec=be does\n+   not change the order for static initializations, so we have to handle it\n+   specially.  */\n+\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+#define INIT_ORDER(A, B)\t(TYPE) A, (TYPE) B\n+#define ELEMENT_ORDER(A, B)\t(TYPE) A, (TYPE) B\n+#define ENDIAN\t\t\t\"-mbig\"\n+\n+#elif __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__\n+#define NO_ARRAY\n+#define INIT_ORDER(A, B)\t(TYPE) B, (TYPE) A\n+#define ELEMENT_ORDER(A, B)\t(TYPE) A, (TYPE) B\n+#define ENDIAN\t\t\t\"-mlittle -maltivec=be\"\n+\n+#else\n+#define INIT_ORDER(A, B)\t(TYPE) B, (TYPE) A\n+#define ELEMENT_ORDER(A, B)\t(TYPE) B, (TYPE) A\n+#define ENDIAN\t\t\t\"-mlittle\"\n+#endif\n+\n+static volatile TYPE\t\tfive\t= FIVE;\n+static volatile TYPE\t\tsix\t= SIX;\n+static volatile vector TYPE\ts_v12 = { ONE,   TWO };\n+static volatile vector TYPE\tg_v34 = { THREE, FOUR };\n+\n+\n+__attribute__((__noinline__))\n+static void\n+vector_check (vector TYPE v, TYPE expect_hi, TYPE expect_lo)\n+{\n+  TYPE actual_hi, actual_lo;\n+#ifdef DEBUG\n+  const char *pass_fail;\n+#endif\n+\n+  __asm__ (\"xxlor %x0,%x1,%x1\"\t\t: \"=&wa\" (actual_hi) : \"wa\" (v));\n+  __asm__ (\"xxpermdi %x0,%x1,%x1,3\"\t: \"=&wa\" (actual_lo) : \"wa\" (v));\n+\n+#ifdef DEBUG\n+  if ((actual_hi == expect_hi) && (actual_lo == expect_lo))\n+    pass_fail = \", pass\";\n+  else\n+    {\n+      pass_fail = \", fail\";\n+      errors++;\n+    }\n+\n+  printf (\"Expected %\" FMT \", %\" FMT \", got %\" FMT \", %\" FMT \"%s\\n\",\n+\t  expect_hi, expect_lo,\n+\t  actual_hi, actual_lo,\n+\t  pass_fail);\n+#else\n+  if ((actual_hi != expect_hi) || (actual_lo != expect_lo))\n+    abort ();\n+#endif\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+combine (TYPE op0, TYPE op1)\n+{\n+  return (vector TYPE) { op0, op1 };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+combine_insert (TYPE op0, TYPE op1)\n+{\n+  vector TYPE ret = (vector TYPE) { ZERO, ZERO };\n+  ret = vec_insert (op0, ret, 0);\n+  ret = vec_insert (op1, ret, 1);\n+  return ret;\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract_00 (vector TYPE a, vector TYPE b)\n+{\n+  return (vector TYPE) { vec_extract (a, 0), vec_extract (b, 0) };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract_01 (vector TYPE a, vector TYPE b)\n+{\n+  return (vector TYPE) { vec_extract (a, 0), vec_extract (b, 1) };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract_10 (vector TYPE a, vector TYPE b)\n+{\n+  return (vector TYPE) { vec_extract (a, 1), vec_extract (b, 0) };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract_11 (vector TYPE a, vector TYPE b)\n+{\n+  return (vector TYPE) { vec_extract (a, 1), vec_extract (b, 1) };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract2_0s (vector TYPE a, TYPE b)\n+{\n+  return (vector TYPE) { vec_extract (a, 0), b };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract2_1s (vector TYPE a, TYPE b)\n+{\n+  return (vector TYPE) { vec_extract (a, 1), b };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract2_s0 (TYPE a, vector TYPE b)\n+{\n+  return (vector TYPE) { a, vec_extract (b, 0) };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract2_s1 (TYPE a, vector TYPE b)\n+{\n+  return (vector TYPE) { a, vec_extract (b, 1) };\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+concat_extract_nn (vector TYPE a, vector TYPE b, size_t i, size_t j)\n+{\n+  return (vector TYPE) { vec_extract (a, i), vec_extract (b, j) };\n+}\n+\n+#ifndef NO_ARRAY\n+__attribute__((__noinline__))\n+static vector TYPE\n+array_0 (vector TYPE v, TYPE a)\n+{\n+  v[0] = a;\n+  return v;\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+array_1 (vector TYPE v, TYPE a)\n+{\n+  v[1] = a;\n+  return v;\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+array_01 (vector TYPE v, TYPE a, TYPE b)\n+{\n+  v[0] = a;\n+  v[1] = b;\n+  return v;\n+}\n+\n+__attribute__((__noinline__))\n+static vector TYPE\n+array_01b (TYPE a, TYPE b)\n+{\n+  vector TYPE v = (vector TYPE) { 0, 0 };\n+  v[0] = a;\n+  v[1] = b;\n+  return v;\n+}\n+#endif\n+\n+int\n+main (void)\n+{\n+  vector TYPE a = (vector TYPE) { ONE,   TWO  };\n+  vector TYPE b = (vector TYPE) { THREE, FOUR };\n+  size_t i, j;\n+\n+#ifndef NO_ARRAY\n+  vector TYPE z = (vector TYPE) { ZERO,  ZERO };\n+#endif\n+\n+  DEBUG2 (\"Endian: %s, type: %s\\n\", ENDIAN, STYPE);\n+  DEBUG0 (\"\\nStatic/global initialization\\n\");\n+  vector_check (s_v12, INIT_ORDER (1, 2));\n+  vector_check (g_v34, INIT_ORDER (3, 4));\n+\n+  DEBUG0 (\"\\nVector via constant runtime intiialization\\n\");\n+  vector_check (a, INIT_ORDER (1, 2));\n+  vector_check (b, INIT_ORDER (3, 4));\n+\n+  DEBUG0 (\"\\nCombine scalars using vector initialization\\n\");\n+  vector_check (combine (1, 2), INIT_ORDER (1, 2));\n+  vector_check (combine (3, 4), INIT_ORDER (3, 4));\n+\n+  DEBUG0 (\"\\nSetup with vec_insert\\n\");\n+  a = combine_insert (1, 2);\n+  b = combine_insert (3, 4);\n+  vector_check (a, ELEMENT_ORDER (1, 2));\n+  vector_check (b, ELEMENT_ORDER (3, 4));\n+\n+#ifndef NO_ARRAY\n+  DEBUG0 (\"\\nTesting array syntax\\n\");\n+  vector_check (array_0   (a, FIVE),      ELEMENT_ORDER (5, 2));\n+  vector_check (array_1   (b, SIX),       ELEMENT_ORDER (3, 6));\n+  vector_check (array_01  (z, FIVE, SIX), ELEMENT_ORDER (5, 6));\n+  vector_check (array_01b (FIVE, SIX),    ELEMENT_ORDER (5, 6));\n+\n+  vector_check (array_0   (a, five),      ELEMENT_ORDER (5, 2));\n+  vector_check (array_1   (b, six),       ELEMENT_ORDER (3, 6));\n+  vector_check (array_01  (z, five, six), ELEMENT_ORDER (5, 6));\n+  vector_check (array_01b (five, six),    ELEMENT_ORDER (5, 6));\n+#else\n+  DEBUG0 (\"\\nSkipping array syntax on -maltivec=be\\n\");\n+#endif\n+\n+  DEBUG0 (\"\\nTesting concat and extract\\n\");\n+  vector_check (concat_extract_00 (a, b), INIT_ORDER (1, 3));\n+  vector_check (concat_extract_01 (a, b), INIT_ORDER (1, 4));\n+  vector_check (concat_extract_10 (a, b), INIT_ORDER (2, 3));\n+  vector_check (concat_extract_11 (a, b), INIT_ORDER (2, 4));\n+\n+  DEBUG0 (\"\\nTesting concat and extract #2\\n\");\n+  vector_check (concat_extract2_0s (a, FIVE), INIT_ORDER (1, 5));\n+  vector_check (concat_extract2_1s (a, FIVE), INIT_ORDER (2, 5));\n+  vector_check (concat_extract2_s0 (SIX, a),  INIT_ORDER (6, 1));\n+  vector_check (concat_extract2_s1 (SIX, a),  INIT_ORDER (6, 2));\n+\n+  DEBUG0 (\"\\nTesting variable concat and extract\\n\");\n+  for (i = 0; i < 2; i++)\n+    {\n+      for (j = 0; j < 2; j++)\n+\t{\n+\t  static struct {\n+\t    TYPE hi;\n+\t    TYPE lo;\n+\t  } hilo[2][2] =\n+\t      { { { ONE, THREE }, { ONE, FOUR } },\n+\t\t{ { TWO, THREE }, { TWO, FOUR } } };\n+\n+\t  vector_check (concat_extract_nn (a, b, i, j),\n+\t\t\tINIT_ORDER (hilo[i][j].hi, hilo[i][j].lo));\n+\t}\n+    }\n+\n+  DEBUG0 (\"\\nTesting separate function\\n\");\n+  vector_check (combine (vec_extract (a, 0), vec_extract (b, 0)),\n+\t\tINIT_ORDER (1, 3));\n+\n+  vector_check (combine (vec_extract (a, 0), vec_extract (b, 1)),\n+\t\tINIT_ORDER (1, 4));\n+\n+  vector_check (combine (vec_extract (a, 1), vec_extract (b, 0)),\n+\t\tINIT_ORDER (2, 3));\n+\n+  vector_check (combine (vec_extract (a, 1), vec_extract (b, 1)),\n+\t\tINIT_ORDER (2, 4));\n+\n+  vector_check (combine_insert (vec_extract (a, 0), vec_extract (b, 0)),\n+\t\tELEMENT_ORDER (1, 3));\n+\n+  vector_check (combine_insert (vec_extract (a, 0), vec_extract (b, 1)),\n+\t\tELEMENT_ORDER (1, 4));\n+\n+  vector_check (combine_insert (vec_extract (a, 1), vec_extract (b, 0)),\n+\t\tELEMENT_ORDER (2, 3));\n+\n+  vector_check (combine_insert (vec_extract (a, 1), vec_extract (b, 1)),\n+\t\tELEMENT_ORDER (2, 4));\n+\n+\n+#if defined(DO_DOUBLE)\n+  DEBUG0 (\"\\nTesting explicit 2df concat\\n\");\n+  vector_check (__builtin_vsx_concat_2df (FIVE, SIX), INIT_ORDER (5, 6));\n+  vector_check (__builtin_vsx_concat_2df (five, six), INIT_ORDER (5, 6));\n+\n+#elif defined(_ARCH_PPC64)\n+  DEBUG0 (\"\\nTesting explicit 2di concat\\n\");\n+  vector_check (__builtin_vsx_concat_2di (FIVE, SIX), INIT_ORDER (5, 6));\n+  vector_check (__builtin_vsx_concat_2di (five, six), INIT_ORDER (5, 6));\n+\n+#else\n+  DEBUG0 (\"\\nSkip explicit 2di concat on 32-bit\\n\");\n+#endif\n+\n+#ifdef DEBUG\n+  if (errors)\n+    printf (\"\\n%d error%s were found\", errors, (errors == 1) ? \"\" : \"s\");\n+  else\n+    printf (\"\\nNo errors were found.\\n\");\n+\n+  return errors;\n+\n+#else\n+  return 0;\n+#endif\n+}"}, {"sha": "8a5eb573f7915e9b89f77bba0f7eb43651af080f", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-6.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-6.c?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+vector unsigned long\n+test_vpasted (vector unsigned long high, vector unsigned long low)\n+{\n+  vector unsigned long res;\n+  res[1] = high[1];\n+  res[0] = low[0];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 1    } } */\n+/* { dg-final { scan-assembler-not   {\\mvspltisw\\M}      } } */\n+/* { dg-final { scan-assembler-not   {\\mxxlor\\M}         } } */\n+/* { dg-final { scan-assembler-not   {\\mxxlxor\\M}        } } */\n+/* { dg-final { scan-assembler-not   {\\mxxspltib\\M}      } } */\n+/* { dg-final { scan-assembler-not   {\\mlxvx?\\M}         } } */\n+/* { dg-final { scan-assembler-not   {\\mlxv[dw][24]x\\M}  } } */\n+/* { dg-final { scan-assembler-not   {\\mlvx\\M}           } } */\n+/* { dg-final { scan-assembler-not   {\\mstxvx?\\M}        } } */\n+/* { dg-final { scan-assembler-not   {\\mstxv[dw][24]x\\M} } } */\n+/* { dg-final { scan-assembler-not   {\\mstvx\\M}          } } */"}, {"sha": "961a980794ebf375c6f84165bdbf7e79a06541f3", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-7.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c4c51e365e2957a590db0f4860ad886a6a20e9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-7.c?ref=08c4c51e365e2957a590db0f4860ad886a6a20e9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx\" } */\n+\n+vector double\n+test_vpasted (vector double high, vector double low)\n+{\n+  vector double res;\n+  res[1] = high[1];\n+  res[0] = low[0];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 1    } } */\n+/* { dg-final { scan-assembler-not   {\\mvspltisw\\M}      } } */\n+/* { dg-final { scan-assembler-not   {\\mxxlor\\M}         } } */\n+/* { dg-final { scan-assembler-not   {\\mxxlxor\\M}        } } */\n+/* { dg-final { scan-assembler-not   {\\mxxspltib\\M}      } } */\n+/* { dg-final { scan-assembler-not   {\\mlxvx?\\M}         } } */\n+/* { dg-final { scan-assembler-not   {\\mlxv[dw][24]x\\M}  } } */\n+/* { dg-final { scan-assembler-not   {\\mlvx\\M}           } } */\n+/* { dg-final { scan-assembler-not   {\\mstxvx?\\M}        } } */\n+/* { dg-final { scan-assembler-not   {\\mstxv[dw][24]x\\M} } } */\n+/* { dg-final { scan-assembler-not   {\\mstvx\\M}          } } */"}]}