{"sha": "5cb1f2fa910c2132a95e9198c2966a1295937875", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNiMWYyZmE5MTBjMjEzMmE5NWU5MTk4YzI5NjZhMTI5NTkzNzg3NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:15:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:15:48Z"}, "message": "(integer_pow2): Mask value to width of type.\n\n(tree_log2): New function.\n\nFrom-SVN: r13374", "tree": {"sha": "5c08e08d93d0b67e716da3cf3a8dcb791ba8ec0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c08e08d93d0b67e716da3cf3a8dcb791ba8ec0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cb1f2fa910c2132a95e9198c2966a1295937875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb1f2fa910c2132a95e9198c2966a1295937875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cb1f2fa910c2132a95e9198c2966a1295937875", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cb1f2fa910c2132a95e9198c2966a1295937875/comments", "author": null, "committer": null, "parents": [{"sha": "86b5812c1817f234a0f3e283e587f14c70fa90ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b5812c1817f234a0f3e283e587f14c70fa90ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b5812c1817f234a0f3e283e587f14c70fa90ba"}], "stats": {"total": 58, "additions": 57, "deletions": 1}, "files": [{"sha": "c54cf6ec6f312cca76a1d18f22613e25597a57ec", "filename": "gcc/tree.c", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cb1f2fa910c2132a95e9198c2966a1295937875/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cb1f2fa910c2132a95e9198c2966a1295937875/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5cb1f2fa910c2132a95e9198c2966a1295937875", "patch": "@@ -1,5 +1,5 @@\n /* Language-independent node constructors for parse phase of GNU compiler.\n-   Copyright (C) 1987, 88, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1625,6 +1625,7 @@ int\n integer_pow2p (expr)\n      tree expr;\n {\n+  int prec;\n   HOST_WIDE_INT high, low;\n \n   STRIP_NOPS (expr);\n@@ -1637,16 +1638,71 @@ integer_pow2p (expr)\n   if (TREE_CODE (expr) != INTEGER_CST || TREE_CONSTANT_OVERFLOW (expr))\n     return 0;\n \n+  prec = (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+\t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n   high = TREE_INT_CST_HIGH (expr);\n   low = TREE_INT_CST_LOW (expr);\n \n+  /* First clear all bits that are beyond the type's precision in case\n+     we've been sign extended.  */\n+\n+  if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+    ;\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n+    high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n+  else\n+    {\n+      high = 0;\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tlow &= ~((HOST_WIDE_INT) (-1) << prec);\n+    }\n+\n   if (high == 0 && low == 0)\n     return 0;\n \n   return ((high == 0 && (low & (low - 1)) == 0)\n \t  || (low == 0 && (high & (high - 1)) == 0));\n }\n \n+/* Return the power of two represented by a tree node known to be a\n+   power of two.  */\n+\n+int\n+tree_log2 (expr)\n+     tree expr;\n+{\n+  int prec;\n+  HOST_WIDE_INT high, low;\n+\n+  STRIP_NOPS (expr);\n+\n+  if (TREE_CODE (expr) == COMPLEX_CST)\n+    return tree_log2 (TREE_REALPART (expr));\n+\n+  prec = (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+\t  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));\n+\n+  high = TREE_INT_CST_HIGH (expr);\n+  low = TREE_INT_CST_LOW (expr);\n+\n+  /* First clear all bits that are beyond the type's precision in case\n+     we've been sign extended.  */\n+\n+  if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+    ;\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n+    high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n+  else\n+    {\n+      high = 0;\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tlow &= ~((HOST_WIDE_INT) (-1) << prec);\n+    }\n+\n+  return (high != 0 ? HOST_BITS_PER_WIDE_INT + exact_log2 (high)\n+\t  :  exact_log2 (low));\n+}\n+\n /* Return 1 if EXPR is the real constant zero.  */\n \n int"}]}