{"sha": "f1ea1f5c047c3e94c8b2c604bb1af7608cc27724", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlYTFmNWMwNDdjM2U5NGM4YjJjNjA0YmIxYWY3NjA4Y2MyNzcyNA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-05-21T19:32:55Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-05-21T19:32:55Z"}, "message": "i386.c (put_condition_code): Change \"reverse\" and \"fp\" arguments to bool.\n\n\t* config/i386/i386.c (put_condition_code): Change \"reverse\" and \"fp\"\n\targuments to bool.\n\t(ix86_print_operand) <case 'O'>: Look at mode size of the operand.\n\tDo not print '.' here.  Output operand lossage error for unhandled\n\tsizes.  Move.\n\t<case '*'>: Move.\n\t<case '&'>: Ditto.\n\t<case 'Y'>: Ditto.\n\t<case 'z'>: Hardcode \"code\" argument into error strings.\n\t<case 'Z'>: Ditto.\n\t<case 'D'>: Merge AVX and non-AVX codes.\n\t<case 'C', case 'c', case 'F', case 'f'>: Merge.  Fix error string.\n\tUpdate call to put_condition_code.\n\nFrom-SVN: r187734", "tree": {"sha": "0aafeb428b7faccc815854d69c16af7df79ccad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aafeb428b7faccc815854d69c16af7df79ccad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724/comments", "author": null, "committer": null, "parents": [{"sha": "07ba94b91a868dc164f1a2a1e20894e11244c8b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ba94b91a868dc164f1a2a1e20894e11244c8b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ba94b91a868dc164f1a2a1e20894e11244c8b1"}], "stats": {"total": 397, "additions": 182, "deletions": 215}, "files": [{"sha": "8b24de1427c5ca51670a29dcdbb44498f6cfdfbe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1ea1f5c047c3e94c8b2c604bb1af7608cc27724", "patch": "@@ -1,11 +1,26 @@\n+2012-05-21  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (put_condition_code): Change \"reverse\" and \"fp\"\n+\targuments to bool.\n+\t(ix86_print_operand) <case 'O'>: Look at mode size of the operand.\n+\tDo not print '.' here.  Output operand lossage error for unhandled\n+\tsizes.  Move.\n+\t<case '*'>: Move.\n+\t<case '&'>: Ditto.\n+\t<case 'Y'>: Ditto.\n+\t<case 'z'>: Hardcode \"code\" argument into error strings.\n+\t<case 'Z'>: Ditto.\n+\t<case 'D'>: Merge AVX and non-AVX codes.\n+\t<case 'C', case 'c', case 'F', case 'f'>: Merge.  Fix error string.\n+\tUpdate call to put_condition_code.\n+\n 2012-05-21  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* config/m68k/m68k.md (*clzsi2_cf): Renamed from clzsi2.  Call\n \tCC_STATUS_INIT.\n \t(clzsi2): New expander.\n \t(*clzsi2_68k): New insn.\n-\t* config/m68k/m68k.h: Update comment about\n-\tCLZ_DEFINED_VALUE_AT_ZERO.\n+\t* config/m68k/m68k.h: Update comment about CLZ_DEFINED_VALUE_AT_ZERO.\n \n 2012-05-21  Aldy Hernandez  <aldyh@redhat.com>\n "}, {"sha": "12719e2b9a6ed4f4b861a1848a4cfcaa7d50b2c8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 165, "deletions": 213, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ea1f5c047c3e94c8b2c604bb1af7608cc27724/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f1ea1f5c047c3e94c8b2c604bb1af7608cc27724", "patch": "@@ -13610,8 +13610,8 @@ ix86_find_base_term (rtx x)\n }\n \f\n static void\n-put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n-\t\t    int fp, FILE *file)\n+put_condition_code (enum rtx_code code, enum machine_mode mode, bool reverse,\n+\t\t    bool fp, FILE *file)\n {\n   const char *suffix;\n \n@@ -13932,8 +13932,8 @@ get_some_local_dynamic_name (void)\n    C -- print opcode suffix for set/cmov insn.\n    c -- like C, but print reversed condition\n    F,f -- likewise, but for floating-point.\n-   O -- if HAVE_AS_IX86_CMOV_SUN_SYNTAX, expand to \"w.\", \"l.\" or \"q.\",\n-        otherwise nothing\n+   O -- if HAVE_AS_IX86_CMOV_SUN_SYNTAX, print the opcode suffix for\n+\tthe size of the current operand, otherwise nothing.\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n    Z -- likewise, with special suffixes for x87 instructions.\n@@ -13974,22 +13974,6 @@ ix86_print_operand (FILE *file, rtx x, int code)\n     {\n       switch (code)\n \t{\n-\tcase '*':\n-\t  if (ASSEMBLER_DIALECT == ASM_ATT)\n-\t    putc ('*', file);\n-\t  return;\n-\n-\tcase '&':\n-\t  {\n-\t    const char *name = get_some_local_dynamic_name ();\n-\t    if (name == NULL)\n-\t      output_operand_lossage (\"'%%&' used without any \"\n-\t\t\t\t      \"local dynamic TLS references\");\n-\t    else\n-\t      assemble_name (file, name);\n-\t    return;\n-\t  }\n-\n \tcase 'A':\n \t  switch (ASSEMBLER_DIALECT)\n \t    {\n@@ -14054,6 +14038,33 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    putc ('t', file);\n \t  return;\n \n+\tcase 'O':\n+#ifdef HAVE_AS_IX86_CMOV_SUN_SYNTAX\n+\t  if (ASSEMBLER_DIALECT != ASM_ATT)\n+\t    return;\n+\n+\t  switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t    {\n+\t    case 2:\n+\t      putc ('w', file);\n+\t      break;\n+  \n+\t    case 4:\n+\t      putc ('l', file);\n+\t      break;\n+\n+\t    case 8:\n+\t      putc ('q', file);\n+\t      break;\n+\n+\t    default:\n+\t      output_operand_lossage\n+\t\t(\"invalid operand size for operand code 'O'\");\n+\t      return;\n+\t    }\n+#endif\n+\t  return;\n+\n \tcase 'z':\n \t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n \t    {\n@@ -14081,14 +14092,14 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \n \t\tdefault:\n \t\t  output_operand_lossage\n-\t\t    (\"invalid operand size for operand code '%c'\", code);\n+\t\t    (\"invalid operand size for operand code 'z'\");\n \t\t  return;\n \t\t}\n \t    }\n \n \t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n \t    warning\n-\t      (0, \"non-integer operand used with operand code '%c'\", code);\n+\t      (0, \"non-integer operand used with operand code 'z'\");\n \t  /* FALLTHRU */\n \n \tcase 'Z':\n@@ -14151,12 +14162,12 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t  else\n \t    {\n \t      output_operand_lossage\n-\t\t(\"invalid operand type used with operand code '%c'\", code);\n+\t\t(\"invalid operand type used with operand code 'Z'\");\n \t      return;\n \t    }\n \n \t  output_operand_lossage\n-\t    (\"invalid operand size for operand code '%c'\", code);\n+\t    (\"invalid operand size for operand code 'Z'\");\n \t  return;\n \n \tcase 'd':\n@@ -14181,179 +14192,160 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    }\n \t  return;\n \n+\tcase 'Y':\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case NE:\n+\t      fputs (\"neq\", file);\n+\t      break;\n+\t    case EQ:\n+\t      fputs (\"eq\", file);\n+\t      break;\n+\t    case GE:\n+\t    case GEU:\n+\t      fputs (INTEGRAL_MODE_P (GET_MODE (x)) ? \"ge\" : \"unlt\", file);\n+\t      break;\n+\t    case GT:\n+\t    case GTU:\n+\t      fputs (INTEGRAL_MODE_P (GET_MODE (x)) ? \"gt\" : \"unle\", file);\n+\t      break;\n+\t    case LE:\n+\t    case LEU:\n+\t      fputs (\"le\", file);\n+\t      break;\n+\t    case LT:\n+\t    case LTU:\n+\t      fputs (\"lt\", file);\n+\t      break;\n+\t    case UNORDERED:\n+\t      fputs (\"unord\", file);\n+\t      break;\n+\t    case ORDERED:\n+\t      fputs (\"ord\", file);\n+\t      break;\n+\t    case UNEQ:\n+\t      fputs (\"ueq\", file);\n+\t      break;\n+\t    case UNGE:\n+\t      fputs (\"nlt\", file);\n+\t      break;\n+\t    case UNGT:\n+\t      fputs (\"nle\", file);\n+\t      break;\n+\t    case UNLE:\n+\t      fputs (\"ule\", file);\n+\t      break;\n+\t    case UNLT:\n+\t      fputs (\"ult\", file);\n+\t      break;\n+\t    case LTGT:\n+\t      fputs (\"une\", file);\n+\t      break;\n+\t    default:\n+\t      output_operand_lossage (\"operand is not a condition code, \"\n+\t\t\t\t      \"invalid operand code 'Y'\");\n+\t      return;\n+\t    }\n+\t  return;\n+\n \tcase 'D':\n \t  /* Little bit of braindamage here.  The SSE compare instructions\n \t     does use completely different names for the comparisons that the\n \t     fp conditional moves.  */\n-\t  if (TARGET_AVX)\n+\t  switch (GET_CODE (x))\n \t    {\n-\t      switch (GET_CODE (x))\n+\t    case UNEQ:\n+\t      if (TARGET_AVX)\n \t\t{\n-\t\tcase EQ:\n-\t\t  fputs (\"eq\", file);\n-\t\t  break;\n-\t\tcase UNEQ:\n \t\t  fputs (\"eq_us\", file);\n \t\t  break;\n-\t\tcase LT:\n-\t\t  fputs (\"lt\", file);\n-\t\t  break;\n-\t\tcase UNLT:\n+\t\t}\n+\t    case EQ:\n+\t      fputs (\"eq\", file);\n+\t      break;\n+\t    case UNLT:\n+\t      if (TARGET_AVX)\n+\t\t{\n \t\t  fputs (\"nge\", file);\n \t\t  break;\n-\t\tcase LE:\n-\t\t  fputs (\"le\", file);\n-\t\t  break;\n-\t\tcase UNLE:\n+\t\t}\n+\t    case LT:\n+\t      fputs (\"lt\", file);\n+\t      break;\n+\t    case UNLE:\n+\t      if (TARGET_AVX)\n+\t\t{\n \t\t  fputs (\"ngt\", file);\n \t\t  break;\n-\t\tcase UNORDERED:\n-\t\t  fputs (\"unord\", file);\n-\t\t  break;\n-\t\tcase NE:\n-\t\t  fputs (\"neq\", file);\n-\t\t  break;\n-\t\tcase LTGT:\n+\t\t}\n+\t    case LE:\n+\t      fputs (\"le\", file);\n+\t      break;\n+\t    case UNORDERED:\n+\t      fputs (\"unord\", file);\n+\t      break;\n+\t    case LTGT:\n+\t      if (TARGET_AVX)\n+\t\t{\n \t\t  fputs (\"neq_oq\", file);\n \t\t  break;\n-\t\tcase GE:\n-\t\t  fputs (\"ge\", file);\n-\t\t  break;\n-\t\tcase UNGE:\n-\t\t  fputs (\"nlt\", file);\n-\t\t  break;\n-\t\tcase GT:\n-\t\t  fputs (\"gt\", file);\n-\t\t  break;\n-\t\tcase UNGT:\n-\t\t  fputs (\"nle\", file);\n-\t\t  break;\n-\t\tcase ORDERED:\n-\t\t  fputs (\"ord\", file);\n-\t\t  break;\n-\t\tdefault:\n-\t\t  output_operand_lossage (\"operand is not a condition code, \"\n-\t\t\t\t\t  \"invalid operand code 'D'\");\n-\t\t  return;\n \t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      switch (GET_CODE (x))\n+\t    case NE:\n+\t      fputs (\"neq\", file);\n+\t      break;\n+\t    case GE:\n+\t      if (TARGET_AVX)\n \t\t{\n-\t\tcase EQ:\n-\t\tcase UNEQ:\n-\t\t  fputs (\"eq\", file);\n-\t\t  break;\n-\t\tcase LT:\n-\t\tcase UNLT:\n-\t\t  fputs (\"lt\", file);\n-\t\t  break;\n-\t\tcase LE:\n-\t\tcase UNLE:\n-\t\t  fputs (\"le\", file);\n-\t\t  break;\n-\t\tcase UNORDERED:\n-\t\t  fputs (\"unord\", file);\n-\t\t  break;\n-\t\tcase NE:\n-\t\tcase LTGT:\n-\t\t  fputs (\"neq\", file);\n-\t\t  break;\n-\t\tcase UNGE:\n-\t\tcase GE:\n-\t\t  fputs (\"nlt\", file);\n-\t\t  break;\n-\t\tcase UNGT:\n-\t\tcase GT:\n-\t\t  fputs (\"nle\", file);\n-\t\t  break;\n-\t\tcase ORDERED:\n-\t\t  fputs (\"ord\", file);\n+\t\t  fputs (\"ge\", file);\n \t\t  break;\n-\t\tdefault:\n-\t\t  output_operand_lossage (\"operand is not a condition code, \"\n-\t\t\t\t\t  \"invalid operand code 'D'\");\n-\t\t  return;\n \t\t}\n-\t    }\n-\t  return;\n-\tcase 'O':\n-#ifdef HAVE_AS_IX86_CMOV_SUN_SYNTAX\n-\t  if (ASSEMBLER_DIALECT == ASM_ATT)\n-\t    {\n-\t      switch (GET_MODE (x))\n+\t    case UNGE:\n+\t      fputs (\"nlt\", file);\n+\t      break;\n+\t    case GT:\n+\t      if (TARGET_AVX)\n \t\t{\n-\t\tcase HImode: putc ('w', file); break;\n-\t\tcase SImode:\n-\t\tcase SFmode: putc ('l', file); break;\n-\t\tcase DImode:\n-\t\tcase DFmode: putc ('q', file); break;\n-\t\tdefault: gcc_unreachable ();\n+\t\t  fputs (\"gt\", file);\n+\t\t  break;\n \t\t}\n-\t      putc ('.', file);\n-\t    }\n-#endif\n-\t  return;\n-\tcase 'C':\n-\t  if (!COMPARISON_P (x))\n-\t    {\n-\t      output_operand_lossage (\"operand is neither a constant nor a \"\n-\t\t\t\t      \"condition code, invalid operand code \"\n-\t\t\t\t      \"'C'\");\n+\t    case UNGT:\n+\t      fputs (\"nle\", file);\n+\t      break;\n+\t    case ORDERED:\n+\t      fputs (\"ord\", file);\n+\t      break;\n+\t    default:\n+\t      output_operand_lossage (\"operand is not a condition code, \"\n+\t\t\t\t      \"invalid operand code 'D'\");\n \t      return;\n \t    }\n-\t  put_condition_code (GET_CODE (x), GET_MODE (XEXP (x, 0)), 0, 0, file);\n-\t  return;\n-\tcase 'F':\n-\t  if (!COMPARISON_P (x))\n-\t    {\n-\t      output_operand_lossage (\"operand is neither a constant nor a \"\n-\t\t\t\t      \"condition code, invalid operand code \"\n-\t\t\t\t      \"'F'\");\n-\t      return;\n-\t    }\n-#ifdef HAVE_AS_IX86_CMOV_SUN_SYNTAX\n-\t  if (ASSEMBLER_DIALECT == ASM_ATT)\n-\t    putc ('.', file);\n-#endif\n-\t  put_condition_code (GET_CODE (x), GET_MODE (XEXP (x, 0)), 0, 1, file);\n \t  return;\n \n-\t  /* Like above, but reverse condition */\n+\tcase 'C':\n \tcase 'c':\n-\t  /* Check to see if argument to %c is really a constant\n-\t     and not a condition code which needs to be reversed.  */\n-\t  if (!COMPARISON_P (x))\n-\t    {\n-\t      output_operand_lossage (\"operand is neither a constant nor a \"\n-\t\t\t\t      \"condition code, invalid operand \"\n-\t\t\t\t      \"code 'c'\");\n-\t      return;\n-\t    }\n-\t  put_condition_code (GET_CODE (x), GET_MODE (XEXP (x, 0)), 1, 0, file);\n-\t  return;\n+\tcase 'F':\n \tcase 'f':\n \t  if (!COMPARISON_P (x))\n \t    {\n-\t      output_operand_lossage (\"operand is neither a constant nor a \"\n-\t\t\t\t      \"condition code, invalid operand \"\n-\t\t\t\t      \"code 'f'\");\n+\t      output_operand_lossage (\"operand is not a condition code, \"\n+\t\t\t\t      \"invalid operand code '%c'\", code);\n \t      return;\n \t    }\n #ifdef HAVE_AS_IX86_CMOV_SUN_SYNTAX\n \t  if (ASSEMBLER_DIALECT == ASM_ATT)\n \t    putc ('.', file);\n #endif\n-\t  put_condition_code (GET_CODE (x), GET_MODE (XEXP (x, 0)), 1, 1, file);\n+\t  put_condition_code (GET_CODE (x), GET_MODE (XEXP (x, 0)),\n+\t\t\t      code == 'c' || code == 'f',\n+\t\t\t      code == 'F' || code == 'f',\n+\t\t\t      file);\n \t  return;\n \n \tcase 'H':\n \t  if (!offsettable_memref_p (x))\n \t    {\n \t      output_operand_lossage (\"operand is not an offsettable memory \"\n-\t\t\t\t      \"reference, invalid operand \"\n-\t\t\t\t      \"code 'H'\");\n+\t\t\t\t      \"reference, invalid operand code 'H'\");\n \t      return;\n \t    }\n \t  /* It doesn't actually matter what mode we use here, as we're\n@@ -14379,6 +14371,22 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t  /* We do not want to print value of the operand.  */\n \t  return;\n \n+\tcase '*':\n+\t  if (ASSEMBLER_DIALECT == ASM_ATT)\n+\t    putc ('*', file);\n+\t  return;\n+\n+\tcase '&':\n+\t  {\n+\t    const char *name = get_some_local_dynamic_name ();\n+\t    if (name == NULL)\n+\t      output_operand_lossage (\"'%%&' used without any \"\n+\t\t\t\t      \"local dynamic TLS references\");\n+\t    else\n+\t      assemble_name (file, name);\n+\t    return;\n+\t  }\n+\n \tcase '+':\n \t  {\n \t    rtx x;\n@@ -14416,62 +14424,6 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    return;\n \t  }\n \n-\tcase 'Y':\n-\t  switch (GET_CODE (x))\n-\t    {\n-\t    case NE:\n-\t      fputs (\"neq\", file);\n-\t      break;\n-\t    case EQ:\n-\t      fputs (\"eq\", file);\n-\t      break;\n-\t    case GE:\n-\t    case GEU:\n-\t      fputs (INTEGRAL_MODE_P (GET_MODE (x)) ? \"ge\" : \"unlt\", file);\n-\t      break;\n-\t    case GT:\n-\t    case GTU:\n-\t      fputs (INTEGRAL_MODE_P (GET_MODE (x)) ? \"gt\" : \"unle\", file);\n-\t      break;\n-\t    case LE:\n-\t    case LEU:\n-\t      fputs (\"le\", file);\n-\t      break;\n-\t    case LT:\n-\t    case LTU:\n-\t      fputs (\"lt\", file);\n-\t      break;\n-\t    case UNORDERED:\n-\t      fputs (\"unord\", file);\n-\t      break;\n-\t    case ORDERED:\n-\t      fputs (\"ord\", file);\n-\t      break;\n-\t    case UNEQ:\n-\t      fputs (\"ueq\", file);\n-\t      break;\n-\t    case UNGE:\n-\t      fputs (\"nlt\", file);\n-\t      break;\n-\t    case UNGT:\n-\t      fputs (\"nle\", file);\n-\t      break;\n-\t    case UNLE:\n-\t      fputs (\"ule\", file);\n-\t      break;\n-\t    case UNLT:\n-\t      fputs (\"ult\", file);\n-\t      break;\n-\t    case LTGT:\n-\t      fputs (\"une\", file);\n-\t      break;\n-\t    default:\n-\t      output_operand_lossage (\"operand is not a condition code, \"\n-\t\t\t\t      \"invalid operand code 'Y'\");\n-\t      return;\n-\t    }\n-\t  return;\n-\n \tcase ';':\n #ifndef HAVE_AS_IX86_REP_LOCK_PREFIX\n \t  putc (';', file);"}]}