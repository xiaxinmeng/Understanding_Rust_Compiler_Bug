{"sha": "c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "node_id": "C_kwDOANBUbNoAKGM2NzU2YjNiYzFkMmFmMWM4ZTg2ZjBhZDE3MTFlOWI5MTM0NTIwYmE", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T05:56:25Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T05:56:25Z"}, "message": "Add new constant data structure.\n\nThis patch provides the data structure and function to convert a\nCONST_INT, CONST_DOUBLE, CONST_VECTOR, or VEC_DUPLICATE of a constant) to\nan array of bytes, half-words, words, and  double words that can be loaded\ninto a 128-bit vector register.\n\nThe next patches will use this data structure to generate code that\ngenerates load of the vector/floating point registers using the XXSPLTIDP,\nXXSPLTIW, and LXVKQ instructions that were added in power10.\n\n2021-12-15  Michael Meissner  <meissner@the-meissners.org>\n\ngcc/\n\n\t* config/rs6000/rs6000-protos.h (VECTOR_128BIT_BITS): New macro.\n\t(VECTOR_128BIT_BYTES): Likewise.\n\t(VECTOR_128BIT_HALF_WORDS): Likewise.\n\t(VECTOR_128BIT_WORDS): Likewise.\n\t(VECTOR_128BIT_DOUBLE_WORDS): Likewise.\n\t(vec_const_128bit_type): New structure type.\n\t(vec_const_128bit_to_bytes): New declaration.\n\t* config/rs6000/rs6000.c (constant_int_to_128bit_vector): New\n\thelper function.\n\t(constant_fp_to_128bit_vector): New helper function.\n\t(vec_const_128bit_to_bytes): New function.", "tree": {"sha": "b8ea0e611150caaa7b359d07bc2b8b0c1d5af9ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8ea0e611150caaa7b359d07bc2b8b0c1d5af9ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba/comments", "author": null, "committer": null, "parents": [{"sha": "71cc9b8c39148d19a8043b74ca8b6b4e8b8072ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71cc9b8c39148d19a8043b74ca8b6b4e8b8072ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71cc9b8c39148d19a8043b74ca8b6b4e8b8072ca"}], "stats": {"total": 281, "additions": 281, "deletions": 0}, "files": [{"sha": "81345d80952885aedd9ef8e86d33a36e969ec5eb", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "patch": "@@ -222,6 +222,34 @@ address_is_prefixed (rtx addr,\n   return (iform == INSN_FORM_PREFIXED_NUMERIC\n \t  || iform == INSN_FORM_PCREL_LOCAL);\n }\n+\n+/* Functions and data structures relating to 128-bit constants that are\n+   converted to byte, half-word, word, and double-word values.  All fields are\n+   kept in big endian order.  We also convert scalar values to 128-bits if they\n+   are going to be loaded into vector registers.  */\n+#define VECTOR_128BIT_BITS\t\t128\n+#define VECTOR_128BIT_BYTES\t\t(128 / 8)\n+#define VECTOR_128BIT_HALF_WORDS\t(128 / 16)\n+#define VECTOR_128BIT_WORDS\t\t(128 / 32)\n+#define VECTOR_128BIT_DOUBLE_WORDS\t(128 / 64)\n+\n+typedef struct {\n+  /* Constant as various sized items.  */\n+  unsigned HOST_WIDE_INT double_words[VECTOR_128BIT_DOUBLE_WORDS];\n+  unsigned int words[VECTOR_128BIT_WORDS];\n+  unsigned short half_words[VECTOR_128BIT_HALF_WORDS];\n+  unsigned char bytes[VECTOR_128BIT_BYTES];\n+\n+  unsigned original_size;\t\t/* Constant size before splat.  */\n+  bool fp_constant_p;\t\t\t/* Is the constant floating point?  */\n+  bool all_double_words_same;\t\t/* Are the double words all equal?  */\n+  bool all_words_same;\t\t\t/* Are the words all equal?  */\n+  bool all_half_words_same;\t\t/* Are the half words all equal?  */\n+  bool all_bytes_same;\t\t\t/* Are the bytes all equal?  */\n+} vec_const_128bit_type;\n+\n+extern bool vec_const_128bit_to_bytes (rtx, machine_mode,\n+\t\t\t\t       vec_const_128bit_type *);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "819314d9fe95801ee38207f44a1fe5827f2f8c03", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c6756b3bc1d2af1c8e86f0ad1711e9b9134520ba", "patch": "@@ -28334,6 +28334,259 @@ rs6000_output_addr_vec_elt (FILE *file, int value)\n   fprintf (file, \"\\n\");\n }\n \n+\f\n+/* Copy an integer constant to the vector constant structure.  */\n+\n+static void\n+constant_int_to_128bit_vector (rtx op,\n+\t\t\t       machine_mode mode,\n+\t\t\t       size_t byte_num,\n+\t\t\t       vec_const_128bit_type *info)\n+{\n+  unsigned HOST_WIDE_INT uvalue = UINTVAL (op);\n+  unsigned bitsize = GET_MODE_BITSIZE (mode);\n+\n+  for (int shift = bitsize - 8; shift >= 0; shift -= 8)\n+    info->bytes[byte_num++] = (uvalue >> shift) & 0xff;\n+}\n+\n+/* Copy a floating point constant to the vector constant structure.  */\n+\n+static void\n+constant_fp_to_128bit_vector (rtx op,\n+\t\t\t      machine_mode mode,\n+\t\t\t      size_t byte_num,\n+\t\t\t      vec_const_128bit_type *info)\n+{\n+  unsigned bitsize = GET_MODE_BITSIZE (mode);\n+  unsigned num_words = bitsize / 32;\n+  const REAL_VALUE_TYPE *rtype = CONST_DOUBLE_REAL_VALUE (op);\n+  long real_words[VECTOR_128BIT_WORDS];\n+\n+  /* Make sure we don't overflow the real_words array and that it is\n+     filled completely.  */\n+  gcc_assert (num_words <= VECTOR_128BIT_WORDS && (bitsize % 32) == 0);\n+\n+  real_to_target (real_words, rtype, mode);\n+\n+  /* Iterate over each 32-bit word in the floating point constant.  The\n+     real_to_target function puts out words in target endian fashion.  We need\n+     to arrange the order so that the bytes are written in big endian order.  */\n+  for (unsigned num = 0; num < num_words; num++)\n+    {\n+      unsigned endian_num = (BYTES_BIG_ENDIAN\n+\t\t\t     ? num\n+\t\t\t     : num_words - 1 - num);\n+\n+      unsigned uvalue = real_words[endian_num];\n+      for (int shift = 32 - 8; shift >= 0; shift -= 8)\n+\tinfo->bytes[byte_num++] = (uvalue >> shift) & 0xff;\n+    }\n+\n+  /* Mark that this constant involves floating point.  */\n+  info->fp_constant_p = true;\n+}\n+\n+/* Convert a vector constant OP with mode MODE to a vector 128-bit constant\n+   structure INFO.\n+\n+   Break out the constant out to bytes, half words, words, and double words.\n+   Return true if we have successfully converted the constant.\n+\n+   We handle CONST_INT, CONST_DOUBLE, CONST_VECTOR, and VEC_DUPLICATE of\n+   constants.  Integer and floating point scalar constants are splatted to fill\n+   out the vector.  */\n+\n+bool\n+vec_const_128bit_to_bytes (rtx op,\n+\t\t\t   machine_mode mode,\n+\t\t\t   vec_const_128bit_type *info)\n+{\n+  /* Initialize the constant structure.  */\n+  memset ((void *)info, 0, sizeof (vec_const_128bit_type));\n+\n+  /* Assume CONST_INTs are DImode.  */\n+  if (mode == VOIDmode)\n+    mode = CONST_INT_P (op) ? DImode : GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    return false;\n+\n+  unsigned size = GET_MODE_SIZE (mode);\n+  bool splat_p = false;\n+\n+  if (size > VECTOR_128BIT_BYTES)\n+    return false;\n+\n+  /* Set up the bits.  */\n+  switch (GET_CODE (op))\n+    {\n+      /* Integer constants, default to double word.  */\n+    case CONST_INT:\n+      {\n+\tconstant_int_to_128bit_vector (op, mode, 0, info);\n+\tsplat_p = true;\n+\tbreak;\n+      }\n+\n+      /* Floating point constants.  */\n+    case CONST_DOUBLE:\n+      {\n+\t/* Fail if the floating point constant is the wrong mode.  */\n+\tif (GET_MODE (op) != mode)\n+\t  return false;\n+\n+\t/* SFmode stored as scalars are stored in DFmode format.  */\n+\tif (mode == SFmode)\n+\t  {\n+\t    mode = DFmode;\n+\t    size = GET_MODE_SIZE (DFmode);\n+\t  }\n+\n+\tconstant_fp_to_128bit_vector (op, mode, 0, info);\n+\tsplat_p = true;\n+\tbreak;\n+      }\n+\n+      /* Vector constants, iterate over each element.  On little endian\n+\t systems, we have to reverse the element numbers.  */\n+    case CONST_VECTOR:\n+      {\n+\t/* Fail if the vector constant is the wrong mode or size.  */\n+\tif (GET_MODE (op) != mode\n+\t    || GET_MODE_SIZE (mode) != VECTOR_128BIT_BYTES)\n+\t  return false;\n+\n+\tmachine_mode ele_mode = GET_MODE_INNER (mode);\n+\tsize_t ele_size = GET_MODE_SIZE (ele_mode);\n+\tsize_t nunits = GET_MODE_NUNITS (mode);\n+\n+\tfor (size_t num = 0; num < nunits; num++)\n+\t  {\n+\t    rtx ele = CONST_VECTOR_ELT (op, num);\n+\t    size_t byte_num = (BYTES_BIG_ENDIAN\n+\t\t\t       ? num\n+\t\t\t       : nunits - 1 - num) * ele_size;\n+\n+\t    if (CONST_INT_P (ele))\n+\t      constant_int_to_128bit_vector (ele, ele_mode, byte_num, info);\n+\t    else if (CONST_DOUBLE_P (ele))\n+\t      constant_fp_to_128bit_vector (ele, ele_mode, byte_num, info);\n+\t    else\n+\t      return false;\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+\t/* Treat VEC_DUPLICATE of a constant just like a vector constant.\n+\t   Since we are duplicating the element, we don't have to worry about\n+\t   endian issues.  */\n+    case VEC_DUPLICATE:\n+      {\n+\t/* Fail if the vector duplicate is the wrong mode or size.  */\n+\tif (GET_MODE (op) != mode\n+\t    || GET_MODE_SIZE (mode) != VECTOR_128BIT_BYTES)\n+\t  return false;\n+\n+\tmachine_mode ele_mode = GET_MODE_INNER (mode);\n+\tsize_t ele_size = GET_MODE_SIZE (ele_mode);\n+\trtx ele = XEXP (op, 0);\n+\tsize_t nunits = GET_MODE_NUNITS (mode);\n+\n+\tif (!CONST_INT_P (ele) && !CONST_DOUBLE_P (ele))\n+\t  return false;\n+\n+\tfor (size_t num = 0; num < nunits; num++)\n+\t  {\n+\t    size_t byte_num = num * ele_size;\n+\n+\t    if (CONST_INT_P (ele))\n+\t      constant_int_to_128bit_vector (ele, ele_mode, byte_num, info);\n+\t    else\n+\t      constant_fp_to_128bit_vector (ele, ele_mode, byte_num, info);\n+\t  }\n+\n+\tbreak;\n+      }\n+\n+      /* Any thing else, just return failure.  */\n+    default:\n+      return false;\n+    }\n+\n+  /* Splat the constant to fill 128 bits if desired.  */\n+  if (splat_p && size < VECTOR_128BIT_BYTES)\n+    {\n+      if ((VECTOR_128BIT_BYTES % size) != 0)\n+\treturn false;\n+\n+      for (size_t offset = size;\n+\t   offset < VECTOR_128BIT_BYTES;\n+\t   offset += size)\n+\tmemcpy ((void *) &info->bytes[offset],\n+\t\t(void *) &info->bytes[0],\n+\t\tsize);\n+    }\n+\n+  /* Remember original size.  */\n+  info->original_size = size;\n+\n+  /* Determine if the bytes are all the same.  */\n+  unsigned char first_byte = info->bytes[0];\n+  info->all_bytes_same = true;\n+  for (size_t i = 1; i < VECTOR_128BIT_BYTES; i++)\n+    if (first_byte != info->bytes[i])\n+      {\n+\tinfo->all_bytes_same = false;\n+\tbreak;\n+      }\n+\n+  /* Pack half words together & determine if all of the half words are the\n+     same.  */\n+  for (size_t i = 0; i < VECTOR_128BIT_HALF_WORDS; i++)\n+    info->half_words[i] = ((info->bytes[i * 2] << 8)\n+\t\t\t   | info->bytes[(i * 2) + 1]);\n+\n+  unsigned short first_hword = info->half_words[0];\n+  info->all_half_words_same = true;\n+  for (size_t i = 1; i < VECTOR_128BIT_HALF_WORDS; i++)\n+    if (first_hword != info->half_words[i])\n+      {\n+\tinfo->all_half_words_same = false;\n+\tbreak;\n+      }\n+\n+  /* Pack words together & determine if all of the words are the same.  */\n+  for (size_t i = 0; i < VECTOR_128BIT_WORDS; i++)\n+    info->words[i] = ((info->bytes[i * 4] << 24)\n+\t\t      | (info->bytes[(i * 4) + 1] << 16)\n+\t\t      | (info->bytes[(i * 4) + 2] << 8)\n+\t\t      | info->bytes[(i * 4) + 3]);\n+\n+  info->all_words_same\n+    = (info->words[0] == info->words[1]\n+       && info->words[0] == info->words[1]\n+       && info->words[0] == info->words[2]\n+       && info->words[0] == info->words[3]);\n+\n+  /* Pack double words together & determine if all of the double words are the\n+     same.  */\n+  for (size_t i = 0; i < VECTOR_128BIT_DOUBLE_WORDS; i++)\n+    {\n+      unsigned HOST_WIDE_INT d_word = 0;\n+      for (size_t j = 0; j < 8; j++)\n+\td_word = (d_word << 8) | info->bytes[(i * 8) + j];\n+\n+      info->double_words[i] = d_word;\n+    }\n+\n+  info->all_double_words_same\n+    = (info->double_words[0] == info->double_words[1]);\n+\n+  return true;\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rs6000.h\""}]}