{"sha": "3136f75db4864765316286f60ffd72ba5383b594", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEzNmY3NWRiNDg2NDc2NTMxNjI4NmY2MGZmZDcyYmE1MzgzYjU5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:51:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:51:58Z"}, "message": "(objc_condition_{,de}allocate): New functions.\n\n(objc_condition_{wait,broadcast,signal}): New functions.\n(__objc_runtime_mutex): Eliminate leading underscore from name of objc\nmutex and thread structures.\n\nFrom-SVN: r13594", "tree": {"sha": "5f75b56d750dbd2910192307a20199f9fb50b5e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f75b56d750dbd2910192307a20199f9fb50b5e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3136f75db4864765316286f60ffd72ba5383b594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3136f75db4864765316286f60ffd72ba5383b594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3136f75db4864765316286f60ffd72ba5383b594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3136f75db4864765316286f60ffd72ba5383b594/comments", "author": null, "committer": null, "parents": [{"sha": "3cec07d501b9e0b836c8a7e9d709e7764aacf4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cec07d501b9e0b836c8a7e9d709e7764aacf4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cec07d501b9e0b836c8a7e9d709e7764aacf4e6"}], "stats": {"total": 147, "additions": 125, "deletions": 22}, "files": [{"sha": "1f43fc56f2407e8ada5c1c95fe0f4a2f39a9a697", "filename": "gcc/objc/thr-mach.c", "status": "modified", "additions": 125, "deletions": 22, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3136f75db4864765316286f60ffd72ba5383b594/gcc%2Fobjc%2Fthr-mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3136f75db4864765316286f60ffd72ba5383b594/gcc%2Fobjc%2Fthr-mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-mach.c?ref=3136f75db4864765316286f60ffd72ba5383b594", "patch": "@@ -1,7 +1,8 @@\n /* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n    Modified for Mach threads by Bill Bumgarner <bbum@friday.com>\n+   Condition functions added by Mircea Oancea <mircea@first.elcom.pub.ro>\n \n This file is part of GNU CC.\n \n@@ -36,13 +37,17 @@ Boston, MA 02111-1307, USA.  */\n  *  provided by the system.  We augment it with depth and current owner id\n  *  fields to implement and re-entrant lock.\n  */\n-struct _objc_mutex \n+struct objc_mutex \n {\n-    volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+    volatile objc_thread_t     owner;          /* Id of thread that owns.  */\n     volatile int                depth;          /* # of acquires.           */\n     struct mutex                lock;           /* cthread mutex            */\n };\n \n+struct objc_condition \n+{\n+    struct condition            condition;      /* cthread condition        */\n+};\n \n /********\n  * obtain the maximum thread priority that can set for t.  Under the\n@@ -95,10 +100,10 @@ __objc_fini_thread_system(void)\n  *  Create a new thread of execution and return its id.  Return NULL if fails.\n  *  The new thread starts in \"func\" with the given argument.\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_create(void (*func)(void *arg), void *arg)\n {\n-    _objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n+    objc_thread_t      thread_id = NULL;       /* Detached thread id.      */\n     cthread_t           new_thread_handle;      /* cthread handle.          */\n \n     objc_mutex_lock(__objc_runtime_mutex);\n@@ -108,7 +113,7 @@ objc_thread_create(void (*func)(void *arg), void *arg)\n \n     if(new_thread_handle) {\n       /* this is not terribly portable */\n-        thread_id = *(_objc_thread_t *)&new_thread_handle; \n+        thread_id = *(objc_thread_t *)&new_thread_handle; \n         cthread_detach(new_thread_handle);      /* fully detach thread */\n         __objc_runtime_threads_alive++;         /* increment thread count */\n     }\n@@ -123,7 +128,7 @@ objc_thread_create(void (*func)(void *arg), void *arg)\n int\n objc_thread_set_priority(int priority)\n {\n-    _objc_thread_t   *t\t     = objc_thread_id();\n+    objc_thread_t   *t\t     = objc_thread_id();\n     cthread_t        cT\t     = (cthread_t) t; \n     int \t     maxPriority  = __mach_get_max_thread_priority(cT, NULL);\n     int              sys_priority = 0;\n@@ -160,7 +165,7 @@ objc_thread_set_priority(int priority)\n int\n objc_thread_get_priority(void)\n {\n-    _objc_thread_t *t\t        = objc_thread_id();\n+    objc_thread_t *t\t        = objc_thread_id();\n     cthread_t      cT\t        = (cthread_t) t; /* see objc_thread_id() */\n     int \t   basePriority;\n     int \t   maxPriority;\n@@ -212,11 +217,11 @@ objc_thread_exit(void)\n  *  Returns an integer value which uniquely describes a thread.  Must not be\n  *  NULL which is reserved as a marker for \"no thread\".\n  */\n-_objc_thread_t\n+objc_thread_t\n objc_thread_id(void)\n {\n   cthread_t self = cthread_self();\n-  return (_objc_thread_t)self;\n+  return (objc_thread_t)self;\n }\n \n /********\n@@ -244,13 +249,13 @@ objc_thread_get_data(void)\n  *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n  *  allocation failed for any reason.\n  */\n-_objc_mutex_t\n+objc_mutex_t\n objc_mutex_allocate(void)\n {\n-    _objc_mutex_t mutex;\n+    objc_mutex_t mutex;\n     int         err = 0;\n     \n-    if (!(mutex = (_objc_mutex_t) objc_malloc(sizeof(struct _objc_mutex))))\n+    if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n         return NULL;                            /* Abort if malloc failed.  */\n \n     err = mutex_init(&(mutex->lock));\n@@ -259,7 +264,7 @@ objc_mutex_allocate(void)\n         objc_free(mutex);                       /* Yes, free local memory.  */\n         return NULL;                            /* Abort.                   */\n     }\n-    mutex->owner = (_objc_thread_t) -1;         /* No owner.                */\n+    mutex->owner = (objc_thread_t) -1;         /* No owner.                */\n     mutex->depth = 0;                           /* No locks.                */\n     return mutex;                               /* Return mutex handle.     */\n }\n@@ -272,7 +277,7 @@ objc_mutex_allocate(void)\n  *  Returns the number of locks on the thread.  (1 for deallocate).\n  */\n int\n-objc_mutex_deallocate(_objc_mutex_t mutex)\n+objc_mutex_deallocate(objc_mutex_t mutex)\n {\n     int         depth;                          /* # of locks on mutex.     */\n \n@@ -294,9 +299,9 @@ objc_mutex_deallocate(_objc_mutex_t mutex)\n  *  Returns the lock count on the mutex held by this thread.\n  */\n int\n-objc_mutex_lock(_objc_mutex_t mutex)\n+objc_mutex_lock(objc_mutex_t mutex)\n {\n-    _objc_thread_t thread_id;                  /* Cache our thread id.     */\n+    objc_thread_t thread_id;                  /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -316,9 +321,9 @@ objc_mutex_lock(_objc_mutex_t mutex)\n  *  thread has a lock on the mutex returns -1.\n  */\n int\n-objc_mutex_trylock(_objc_mutex_t mutex)\n+objc_mutex_trylock(objc_mutex_t mutex)\n {\n-    _objc_thread_t         thread_id;           /* Cache our thread id.     */\n+    objc_thread_t         thread_id;           /* Cache our thread id.     */\n \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -341,9 +346,9 @@ objc_mutex_trylock(_objc_mutex_t mutex)\n  *  Will also return -1 if the mutex free fails.\n  */\n int\n-objc_mutex_unlock(_objc_mutex_t mutex)\n+objc_mutex_unlock(objc_mutex_t mutex)\n {\n-    _objc_thread_t    thread_id;                /* Cache our thread id.     */\n+    objc_thread_t    thread_id;                /* Cache our thread id.     */\n     \n     if (!mutex)                                 /* Is argument bad?         */\n         return -1;                              /* Yes, abort.              */\n@@ -353,9 +358,107 @@ objc_mutex_unlock(_objc_mutex_t mutex)\n     if (mutex->depth > 1)                       /* Released last lock?      */\n         return --mutex->depth;                  /* No, Decrement depth, end.*/\n     mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n-    mutex->owner = (_objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n+    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n     \n     mutex_unlock(&(mutex->lock));               /* unlock cthread mutex.    */\n     \n     return 0;                                   /* No, return success.      */\n }\n+\n+/********\n+ *  Allocate a condition.  Return the condition pointer if successful or NULL\n+ * if the allocation failed for any reason.\n+ */\n+objc_condition_t \n+objc_condition_allocate(void)\n+{\n+    objc_condition_t condition;\n+    \n+    if (!(condition = (objc_condition_t)objc_malloc(\n+                        sizeof(struct objc_condition))))\n+        return NULL;                            /* Abort if malloc failed.  */\n+\n+    condition_init(&(condition->condition));\n+    \n+    return condition;                           /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a condition. Note that this includes an implicit \n+ *  condition_broadcast to insure that waiting threads have the opportunity\n+ *  to wake.  It is legal to dealloc a condition only if no other\n+ *  thread is/will be using it. Here we do NOT check for other threads\n+ *  waiting but just wake them up.\n+ */\n+int\n+objc_condition_deallocate(objc_condition_t condition)\n+{\n+\tcondition_broadcast(&(condition->condition));\n+\tcondition_clear(&(condition->condition));\n+\tobjc_free(condition);\n+\treturn 0;\n+}\n+\n+/********\n+ *  Wait on the condition unlocking the mutex until objc_condition_signal()\n+ *  or objc_condition_broadcast() are called for the same condition. The\n+ *  given mutex *must* have the depth set to 1 so that it can be unlocked\n+ *  here, so that someone else can lock it and signal/broadcast the condition.\n+ *  The mutex is used to lock access to the shared data that make up the\n+ *  \"condition\" predicate.\n+ */\n+int\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+    objc_thread_t    thread_id;                /* Cache our thread id.     */\n+    \n+    if (!mutex || !condition)                   /* Is argument bad?         */\n+        return -1;                              /* Yes, abort.              */\n+\n+    thread_id = objc_thread_id();               /* Get this thread's id.    */\n+    if (mutex->owner != thread_id)              /* Does some else own lock? */\n+        return -1;                              /* Yes, abort.              */\n+    if (mutex->depth > 1)                       /* Locked more than once ?  */\n+        return -1;                              /* YES, return error        */\n+                                                /* mutex will be unlocked   */\n+    mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+    mutex->owner = (objc_thread_t) -1;         /* Set owner to \"no thread\".*/\n+    \n+    condition_wait(&(condition->condition),\n+\t\t&(mutex->lock));                        /* unlock, wait ..., lock   */\n+    \n+    mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+    mutex->depth = 1;                           /* Increment depth to end.  */\n+    return 0;                                   /* Return success.          */\n+}\n+\n+/********\n+ *  Wake up all threads waiting on this condition. It is recommended that \n+ *  the called would lock the same mutex as the threads in objc_condition_wait\n+ *  before changing the \"condition predicate\" and make this call and unlock it\n+ *  right away after this call.\n+ */\n+int\n+objc_condition_broadcast(objc_condition_t condition)\n+{\n+    if (!condition)\n+\t\treturn -1;\n+\tcondition_broadcast(&(condition->condition));\n+\treturn 0;\n+}\n+\n+/********\n+ *  Wake up one thread waiting on this condition. It is recommended that \n+ *  the called would lock the same mutex as the threads in objc_condition_wait\n+ *  before changing the \"condition predicate\" and make this call and unlock it\n+ *  right away after this call.\n+ */\n+int\n+objc_condition_signal(objc_condition_t condition)\n+{\n+    if (!condition)\n+\t\treturn -1;\n+\tcondition_signal(&(condition->condition));\n+\treturn 0;\n+}\n+"}]}