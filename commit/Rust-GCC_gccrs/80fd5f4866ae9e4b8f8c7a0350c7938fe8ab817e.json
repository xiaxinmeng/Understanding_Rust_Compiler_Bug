{"sha": "80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBmZDVmNDg2NmFlOWU0YjhmOGM3YTAzNTBjNzkzOGZlOGFiODE3ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-02T19:41:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-02T19:41:09Z"}, "message": "cp-tree.h (dfs_mark_primary_bases_queue_p): New function.\n\n\t* cp-tree.h (dfs_mark_primary_bases_queue_p): New function.\n\t(layout_basetypes): Remove.\n\t* class.c (propagate_binfo_offsets): Moved here from tree.c.\n\tUpdate to handle primary virtual bases.\n\t(remove_base_fields): New function, split out from\n\tlayout_basetypes.\n\t(dfs_mark_primary_bases_and_set_vbase_offsets): New function.\n\t(layout_virtual_bases): New function, split out from\n\tlayout_basetypes.  Update to handle primary virtual bases.\n\t(layout_basetypes): Moved here from tree.c.  Use\n\tremove_base_fields and layout_virtual_bases.\n\t* search.c (dfs_mark_primary_bases_queue_p): New function.\n\t(mark_primary_bases): Use it.\n\t* tree.c (CEIL): Remove.\n\t(propagate_binfo_offsets): Remove.\n\t(layout_basetypes): Remove.\n\nFrom-SVN: r31168", "tree": {"sha": "3fa1f12ab897f718878ac55b7d173dcf94ba10c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fa1f12ab897f718878ac55b7d173dcf94ba10c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/comments", "author": null, "committer": null, "parents": [{"sha": "13799af323ca20c344c7b62ccc766b4bf5fc589f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13799af323ca20c344c7b62ccc766b4bf5fc589f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13799af323ca20c344c7b62ccc766b4bf5fc589f"}], "stats": {"total": 614, "additions": 366, "deletions": 248}, "files": [{"sha": "c023f90f754331f217e4ca122e6913b3a7870ed6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "patch": "@@ -1,3 +1,22 @@\n+2000-01-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (dfs_mark_primary_bases_queue_p): New function.\n+\t(layout_basetypes): Remove.\n+\t* class.c (propagate_binfo_offsets): Moved here from tree.c.\n+\tUpdate to handle primary virtual bases.\n+\t(remove_base_fields): New function, split out from\n+\tlayout_basetypes.\n+\t(dfs_mark_primary_bases_and_set_vbase_offsets): New function.\n+\t(layout_virtual_bases): New function, split out from\n+\tlayout_basetypes.  Update to handle primary virtual bases.\n+\t(layout_basetypes): Moved here from tree.c.  Use\n+\tremove_base_fields and layout_virtual_bases.\n+\t* search.c (dfs_mark_primary_bases_queue_p): New function.\n+\t(mark_primary_bases): Use it.\n+\t* tree.c (CEIL): Remove.\n+\t(propagate_binfo_offsets): Remove.\n+\t(layout_basetypes): Remove.\n+\t\n 2000-01-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (skip_rtti_stuff): Adjust prototype."}, {"sha": "7d22db8f463714c36af306d33620b874e5cc5a20", "filename": "gcc/cp/class.c", "status": "modified", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "patch": "@@ -138,6 +138,11 @@ static void layout_class_type PROTO((tree, int *, int *, int *, tree *, tree *))\n static void fixup_pending_inline PROTO((struct pending_inline *));\n static void fixup_inline_methods PROTO((tree));\n static void set_primary_base PROTO((tree, int, int *));\n+static void propagate_binfo_offsets PROTO((tree, tree));\n+static int layout_basetypes PROTO((tree, int));\n+static tree dfs_mark_primary_bases_and_set_vbase_offsets PROTO((tree, void *));\n+static int layout_virtual_bases PROTO((tree, int));\n+static void remove_base_fields PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -4143,6 +4148,320 @@ fixup_inline_methods (type)\n   CLASSTYPE_INLINE_FRIENDS (type) = NULL_TREE;\n }\n \n+/* Add OFFSET to all base types of T.\n+\n+   OFFSET, which is a type offset, is number of bytes.\n+\n+   Note that we don't have to worry about having two paths to the\n+   same base type, since this type owns its association list.  */\n+\n+static void\n+propagate_binfo_offsets (binfo, offset)\n+     tree binfo;\n+     tree offset;\n+{\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  if (flag_new_abi)\n+    {\n+      for (i = 0; i < n_baselinks; ++i)\n+\t{\n+\t  tree base_binfo;\n+\n+\t  /* Figure out which base we're looking at.  */\n+\t  base_binfo = TREE_VEC_ELT (binfos, i);\n+\n+\t  /* Skip non-primary virtual bases.  Their BINFO_OFFSET\n+\t     doesn't matter since they are always reached by using\n+\t     offsets looked up at run-time.  */\n+\t  if (TREE_VIA_VIRTUAL (base_binfo) \n+\t      && i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo)))\n+\t    continue;\n+\n+\t  /* Whatever offset this class used to have in its immediate\n+\t     derived class, it is now at OFFSET more bytes in its\n+\t     final derived class, since the immediate derived class is\n+\t     already at the indicated OFFSET.  */\n+\t  BINFO_OFFSET (base_binfo)\n+\t    = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);\n+\n+\t  propagate_binfo_offsets (base_binfo, offset);\n+\t}\n+    }\n+  else\n+    {\n+      /* This algorithm, used for the old ABI, is neither simple, nor\n+\t general.  For example, it mishandles the case of:\n+       \n+           struct A;\n+\t   struct B : public A;\n+\t   struct C : public B;\n+\t   \n+\t if B is at offset zero in C, but A is not in offset zero in\n+\t B.  In that case, it sets the BINFO_OFFSET for A to zero.\n+\t (This sitution arises in the new ABI if B has virtual\n+\t functions, but A does not.)  Rather than change this\n+\t algorithm, and risking breaking the old ABI, it is preserved\n+\t here.  */\n+      for (i = 0; i < n_baselinks; /* note increment is done in the\n+\t\t\t\t      loop.  */)\n+\t{\n+\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\n+\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t    i += 1;\n+\t  else\n+\t    {\n+\t      int j;\n+\t      tree delta = NULL_TREE;\n+\n+\t      for (j = i+1; j < n_baselinks; j++)\n+\t\tif (! TREE_VIA_VIRTUAL (TREE_VEC_ELT (binfos, j)))\n+\t\t  {\n+\t\t    /* The next basetype offset must take into account\n+\t\t       the space between the classes, not just the\n+\t\t       size of each class.  */\n+\t\t    delta = size_binop (MINUS_EXPR,\n+\t\t\t\t\tBINFO_OFFSET (TREE_VEC_ELT (binfos, \n+\t\t\t\t\t\t\t\t    j)),\n+\t\t\t\t\tBINFO_OFFSET (base_binfo));\n+\t\t    break;\n+\t\t  }\n+\n+\t      BINFO_OFFSET (base_binfo) = offset;\n+\n+\t      propagate_binfo_offsets (base_binfo, offset);\n+\n+\t      /* Go to our next class that counts for offset\n+                 propagation.  */\n+\t      i = j;\n+\t      if (i < n_baselinks)\n+\t\toffset = size_binop (PLUS_EXPR, offset, delta);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Remove the FIELD_DECLs created for T's base classes in\n+   build_base_fields.  Simultaneously, update BINFO_OFFSET for all the\n+   bases, except for non-primary virtual baseclasses.  */\n+\n+static void\n+remove_base_fields (t)\n+     tree t;\n+{\n+  int i;\n+  tree *field;\n+\n+  /* Now propagate offset information throughout the lattice.\n+     Simultaneously, remove the temporary FIELD_DECLS we created in\n+     build_base_fields to refer to base types.  */\n+  field = &TYPE_FIELDS (t);\n+  if (TYPE_VFIELD (t) == *field)\n+    {\n+      /* If this class did not have a primary base, we create a\n+\t virtual function table pointer.  It will be the first thing\n+\t in the class, under the new ABI.  Skip it; the base fields\n+\t will follow it.  */\n+      my_friendly_assert (flag_new_abi \n+\t\t\t  && !CLASSTYPE_HAS_PRIMARY_BASE_P (t),\n+\t\t\t  19991218);\n+      field = &TREE_CHAIN (*field);\n+    }\n+    \n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n+    {\n+      register tree base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+      register tree basetype = BINFO_TYPE (base_binfo);\n+\n+      /* We treat a primary virtual base class just like an ordinary\n+\t base class.  But, non-primary virtual bases are laid out\n+\t later.  */\n+      if (TREE_VIA_VIRTUAL (base_binfo) && i != CLASSTYPE_VFIELD_PARENT (t))\n+\tcontinue;\n+\n+      my_friendly_assert (TREE_TYPE (*field) == basetype, 23897);\n+\n+      if (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n+\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t    basetype, t);\n+\n+      BINFO_OFFSET (base_binfo)\n+\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n+\t\t\t  BITS_PER_UNIT));\n+      propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n+\n+      /* Remove this field.  */\n+      *field = TREE_CHAIN (*field);\n+    }\n+}\n+\n+/* Called via dfs_walk from layout_virtual_bases.  */\n+\n+static tree\n+dfs_mark_primary_bases_and_set_vbase_offsets (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+    {\n+      int i;\n+      tree base_binfo;\n+\n+      i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      base_binfo = BINFO_BASETYPE (binfo, i);\n+      \n+      /* If this is a virtual base class, and we've just now\n+\t discovered it to be a primary base, then reuse this copy as\n+\t the virtual base class for the complete object. */\n+      if (TREE_VIA_VIRTUAL (base_binfo)\n+\t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n+\t{\n+\t  tree vbase;\n+\n+\t  vbase = BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), (tree) data);\n+\t  BINFO_OFFSET (vbase) = BINFO_OFFSET (base_binfo);\n+\t}\n+\n+      SET_BINFO_PRIMARY_MARKED_P (BINFO_BASETYPE (binfo, i));\n+    }\n+\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Set BINFO_OFFSET for all of the virtual bases for T.  Update\n+   TYPE_ALIGN and TYPE_SIZE for T.  Return the maximum of MAX and the\n+   largest CLASSTYPE_VSIZE for any of the virtual bases.  */\n+\n+static int\n+layout_virtual_bases (t, max)\n+     tree t;\n+     int max;\n+{\n+  tree vbase;\n+  int dsize;\n+\n+  /* Mark the primary base classes.  Only virtual bases that are not\n+     also primary base classes need to be laid out (since otherwise we\n+     can just reuse one of the places in the hierarchy where the\n+     virtual base already occurs.)  */\n+  dfs_walk (TYPE_BINFO (t), \n+\t    dfs_mark_primary_bases_and_set_vbase_offsets,\n+\t    dfs_mark_primary_bases_queue_p, \n+\t    t);\n+\n+  /* DSIZE is the size of the class without the virtual bases.  */\n+  dsize = TREE_INT_CST_LOW (TYPE_SIZE (t));\n+  /* Make every class have alignment of at least one.  */\n+  TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), BITS_PER_UNIT);\n+\n+  for (vbase = CLASSTYPE_VBASECLASSES (t); \n+       vbase; \n+       vbase = TREE_CHAIN (vbase))\n+    if (!BINFO_PRIMARY_MARKED_P (vbase))\n+      {\n+\t/* This virtual base is not a primary base of any class in the\n+\t   hierarchy, so we have to add space for it.  */\n+\ttree basetype;\n+\tunsigned int desired_align;\n+\n+\tbasetype = BINFO_TYPE (vbase);\n+\tdesired_align = TYPE_ALIGN (basetype);\n+\tTYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n+\n+\t/* Add padding so that we can put the virtual base class at an\n+\t   appropriately aligned offset.  */\n+\tdsize = CEIL (dsize, desired_align) * desired_align;\n+\t/* And compute the offset of the virtual base.  */\n+\tBINFO_OFFSET (vbase) = size_int (CEIL (dsize, BITS_PER_UNIT));\n+\t/* Every virtual baseclass takes a least a UNIT, so that we can\n+\t   take it's address and get something different for each base.  */\n+\tdsize += MAX (BITS_PER_UNIT,\n+\t\t      TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n+\n+\t/* Now that we've laid out this virtual base class, some of\n+\t   the remaining virtual bases might have been implicitly laid\n+\t   out as well -- they could be primary base classes of\n+\t   classes in BASETYPE.  */\n+\tdfs_walk (vbase,\n+\t\t  dfs_mark_primary_bases_and_set_vbase_offsets,\n+\t\t  dfs_mark_primary_bases_queue_p, \n+\t\t  t);\n+\n+\t/* While we're here, see if this new virtual base class has\n+\t   more virtual functions than we expected.  */\n+\tmax = MAX (CLASSTYPE_VSIZE (basetype), max);\n+      }\n+\n+  /* We're done with the various marks, now, so clear them.  */\n+  unmark_primary_bases (t);\n+  dfs_walk (TYPE_BINFO (t), dfs_unmark, markedp, 0);\n+\n+  /* Now, make sure that the total size of the type is a multiple of\n+     its alignment.  */\n+  dsize = CEIL (dsize, TYPE_ALIGN (t)) * TYPE_ALIGN (t);\n+  TYPE_SIZE (t) = size_int (dsize);\n+  TYPE_SIZE_UNIT (t) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (t),\n+\t\t\t\t   size_int (BITS_PER_UNIT));\n+\n+  return max;\n+}\n+\n+/* Finish the work of layout_record, now taking virtual bases into account.\n+   Also compute the actual offsets that our base classes will have.\n+   This must be performed after the fields are laid out, since virtual\n+   baseclasses must lay down at the end of the record.\n+\n+   Returns the maximum number of virtual functions any of the\n+   baseclasses provide.  */\n+\n+static int\n+layout_basetypes (rec, max)\n+     tree rec;\n+     int max;\n+{\n+  tree vbase_types;\n+\n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  /* Packed structures don't need to have minimum size.  */\n+  if (! TYPE_PACKED (rec))\n+    TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), STRUCTURE_SIZE_BOUNDARY);\n+#endif\n+\n+  /* Remove the FIELD_DECLs we created for baseclasses in\n+     build_base_fields.  Simultaneously, update the BINFO_OFFSETs for\n+     everything in the hierarcy except non-primary virtual bases.  */\n+  remove_base_fields (rec);\n+\n+  /* Allocate the virtual base classes.  */\n+  max = layout_virtual_bases (rec, max);\n+\n+  /* Get all the virtual base types that this type uses.  The\n+     TREE_VALUE slot holds the virtual baseclass type.  Note that\n+     get_vbase_types makes copies of the virtual base BINFOs, so that\n+     the vbase_types are unshared.  */\n+  for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n+       vbase_types = TREE_CHAIN (vbase_types))\n+    {\n+      BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n+      unshare_base_binfos (vbase_types);\n+      propagate_binfo_offsets (vbase_types, BINFO_OFFSET (vbase_types));\n+\n+      if (extra_warnings)\n+\t{\n+\t  tree basetype = BINFO_TYPE (vbase_types);\n+\t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n+\t    cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t\tbasetype, rec);\n+\t}\n+    }\n+\n+  return max;\n+}\n+\n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n    BINFO_OFFSETs for all of the base-classes.  Position the vtable\n    pointer.  */"}, {"sha": "a83dc15a2c0d59a2edbd070c7c3beec8d9d1f59e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "patch": "@@ -3909,6 +3909,7 @@ extern tree dfs_walk                            PROTO((tree,\n \t\t\t\t\t\t       void *));\n extern tree dfs_unmark                          PROTO((tree, void *));\n extern tree markedp                             PROTO((tree, void *));\n+extern tree dfs_mark_primary_bases_queue_p      PROTO((tree, void *));\n extern void mark_primary_bases                  PROTO((tree));\n extern void unmark_primary_bases                PROTO((tree));\n \n@@ -4028,7 +4029,6 @@ extern tree break_out_calls\t\t\tPROTO((tree));\n extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_staticfn_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n-extern int layout_basetypes\t\t\tPROTO((tree, int));\n extern tree hash_tree_cons\t\t\tPROTO((tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n extern tree hash_chainon\t\t\tPROTO((tree, tree));"}, {"sha": "079a653130a8ad06505fb7191ea19e894bfcac02", "filename": "gcc/cp/search.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "patch": "@@ -2104,7 +2104,7 @@ get_matching_virtual (binfo, fndecl, dtorp)\n     }\n }\n \n-/* Called via dfs_walk from mark_nonprimary_bases.  */\n+/* Called via dfs_walk from mark_primary_bases.  */\n \n static tree\n dfs_mark_primary_bases (binfo, data)\n@@ -2124,6 +2124,31 @@ dfs_mark_primary_bases (binfo, data)\n   return NULL_TREE;\n }\n \n+/* Called via dfs_walk from mark_primary_bases.  */\n+\n+tree\n+dfs_mark_primary_bases_queue_p (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  /* Don't walk into virtual baseclasses that are not primary \n+     bases.  */\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      tree derived_class;\n+      tree primary_base;\n+      \n+      derived_class = BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo));\n+      primary_base = CLASSTYPE_PRIMARY_BINFO (derived_class);\n+      if (!primary_base || !same_type_p (BINFO_TYPE (primary_base),\n+\t\t\t\t\t BINFO_TYPE (binfo)))\n+\treturn NULL_TREE;\n+    }\n+\n+  /* But do walk into everything else.  */\n+  return binfo;\n+}\n+\n /* Set BINFO_PRIMARY_MARKED_P for all binfos in the hierarchy\n    dominated by TYPE that are primary bases.  (In addition,\n    BINFO_MARKED is set for all classes in the hierarchy; callers\n@@ -2135,7 +2160,7 @@ mark_primary_bases (type)\n {\n   dfs_walk (TYPE_BINFO (type), \n \t    dfs_mark_primary_bases,\n-\t    unmarkedp,\n+\t    dfs_mark_primary_bases_queue_p,\n \t    NULL);\n }\n "}, {"sha": "a951b5f719731a5f9d39aa78f26681222828a0c7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 245, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=80fd5f4866ae9e4b8f8c7a0350c7938fe8ab817e", "patch": "@@ -37,7 +37,6 @@ static tree build_cplus_array_type_1 PROTO((tree, tree));\n static void list_hash_add PROTO((int, tree));\n static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, tree, tree, tree));\n-static void propagate_binfo_offsets PROTO((tree, tree));\n static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n static tree no_linkage_helper PROTO((tree *, int *, void *));\n static tree build_srcloc PROTO((char *, int));\n@@ -48,8 +47,6 @@ static tree cp_unsave_r PROTO ((tree *, int *, void *));\n static void cp_unsave PROTO((tree *));\n static tree build_target_expr PROTO((tree, tree));\n \n-#define CEIL(x,y) (((x) + (y) - 1) / (y))\n-\n /* If REF is an lvalue, returns the kind of lvalue that REF is.\n    Otherwise, returns clk_none.  If TREAT_CLASS_RVALUES_AS_LVALUES is\n    non-zero, rvalues of class type are considered lvalues.  */\n@@ -656,100 +653,6 @@ canonical_type_variant (t)\n   return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), CP_TYPE_QUALS (t));\n }\n \f\n-/* Add OFFSET to all base types of T.\n-\n-   OFFSET, which is a type offset, is number of bytes.\n-\n-   Note that we don't have to worry about having two paths to the\n-   same base type, since this type owns its association list.  */\n-\n-static void\n-propagate_binfo_offsets (binfo, offset)\n-     tree binfo;\n-     tree offset;\n-{\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  if (flag_new_abi)\n-    {\n-      for (i = 0; i < n_baselinks; ++i)\n-\t{\n-\t  tree base_binfo;\n-\n-\t  /* Figure out which base we're looking at.  */\n-\t  base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-\t  /* Skip virtual bases.  Their BINFO_OFFSET doesn't matter\n-\t     since they are always reached by using offsets looked up\n-\t     at run-time.  */\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n-\t    continue;\n-\n-\t  /* Whatever offset this class used to have in its immediate\n-\t     derived class, it is now at OFFSET more bytes in its\n-\t     final derived class, since the immediate derived class is\n-\t     already at the indicated OFFSET.  */\n-\t  BINFO_OFFSET (base_binfo)\n-\t    = size_binop (PLUS_EXPR, BINFO_OFFSET (base_binfo), offset);\n-\n-\t  propagate_binfo_offsets (base_binfo, offset);\n-\t}\n-    }\n-  else\n-    {\n-      /* This algorithm, used for the old ABI, is neither simple, nor\n-\t general.  For example, it mishandles the case of:\n-       \n-           struct A;\n-\t   struct B : public A;\n-\t   struct C : public B;\n-\t   \n-\t if B is at offset zero in C, but A is not in offset zero in\n-\t B.  In that case, it sets the BINFO_OFFSET for A to zero.\n-\t (This sitution arises in the new ABI if B has virtual\n-\t functions, but A does not.)  Rather than change this\n-\t algorithm, and risking breaking the old ABI, it is preserved\n-\t here.  */\n-      for (i = 0; i < n_baselinks; /* note increment is done in the\n-\t\t\t\t      loop.  */)\n-\t{\n-\t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n-\t    i += 1;\n-\t  else\n-\t    {\n-\t      int j;\n-\t      tree delta = NULL_TREE;\n-\n-\t      for (j = i+1; j < n_baselinks; j++)\n-\t\tif (! TREE_VIA_VIRTUAL (TREE_VEC_ELT (binfos, j)))\n-\t\t  {\n-\t\t    /* The next basetype offset must take into account\n-\t\t       the space between the classes, not just the\n-\t\t       size of each class.  */\n-\t\t    delta = size_binop (MINUS_EXPR,\n-\t\t\t\t\tBINFO_OFFSET (TREE_VEC_ELT (binfos, \n-\t\t\t\t\t\t\t\t    j)),\n-\t\t\t\t\tBINFO_OFFSET (base_binfo));\n-\t\t    break;\n-\t\t  }\n-\n-\t      BINFO_OFFSET (base_binfo) = offset;\n-\n-\t      propagate_binfo_offsets (base_binfo, offset);\n-\n-\t      /* Go to our next class that counts for offset\n-                 propagation.  */\n-\t      i = j;\n-\t      if (i < n_baselinks)\n-\t\toffset = size_binop (PLUS_EXPR, offset, delta);\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Makes new binfos for the indirect bases under BINFO, and updates\n    BINFO_OFFSET for them and their bases.  */\n \n@@ -782,154 +685,6 @@ unshare_base_binfos (binfo)\n     }\n }\n \n-/* Finish the work of layout_record, now taking virtual bases into account.\n-   Also compute the actual offsets that our base classes will have.\n-   This must be performed after the fields are laid out, since virtual\n-   baseclasses must lay down at the end of the record.\n-\n-   Returns the maximum number of virtual functions any of the\n-   baseclasses provide.  */\n-\n-int\n-layout_basetypes (rec, max)\n-     tree rec;\n-     int max;\n-{\n-  tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n-  tree vbase_types;\n-  tree *field;\n-\n-  unsigned int record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n-  unsigned int desired_align;\n-\n-  /* Record size so far is CONST_SIZE bits, where CONST_SIZE is an integer.  */\n-  register unsigned int const_size = 0;\n-  unsigned int nonvirtual_const_size;\n-\n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-  /* Packed structures don't need to have minimum size.  */\n-  if (! TYPE_PACKED (rec))\n-    record_align = MAX (record_align, STRUCTURE_SIZE_BOUNDARY);\n-#endif\n-\n-  /* Get all the virtual base types that this type uses.  The\n-     TREE_VALUE slot holds the virtual baseclass type.  Note that\n-     get_vbase_types makes copies of the virtual base BINFOs, so that\n-     the vbase_types are unshared.  */\n-  vbase_types = CLASSTYPE_VBASECLASSES (rec);\n-\n-  my_friendly_assert (TREE_CODE (TYPE_SIZE (rec)) == INTEGER_CST, 19970302);\n-  const_size = TREE_INT_CST_LOW (TYPE_SIZE (rec));\n-\n-  nonvirtual_const_size = const_size;\n-\n-  while (vbase_types)\n-    {\n-      tree basetype = BINFO_TYPE (vbase_types);\n-      tree offset;\n-\n-      desired_align = TYPE_ALIGN (basetype);\n-      record_align = MAX (record_align, desired_align);\n-\n-      if (const_size == 0)\n-\toffset = integer_zero_node;\n-      else\n-\t{\n-\t  /* Give each virtual base type the alignment it wants.  */\n-\t  const_size = CEIL (const_size, desired_align) * desired_align;\n-\t  offset = size_int (CEIL (const_size, BITS_PER_UNIT));\n-\t}\n-\n-      if (CLASSTYPE_VSIZE (basetype) > max)\n-\tmax = CLASSTYPE_VSIZE (basetype);\n-      BINFO_OFFSET (vbase_types) = offset;\n-\n-      /* Every virtual baseclass takes a least a UNIT, so that we can\n-\t take it's address and get something different for each base.  */\n-      const_size += MAX (BITS_PER_UNIT,\n-\t\t\t TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n-\n-      vbase_types = TREE_CHAIN (vbase_types);\n-    }\n-\n-  if (const_size)\n-    {\n-      /* Because a virtual base might take a single byte above,\n-\t we have to re-adjust the total size to make sure it is\n-\t a multiple of the alignment.  */\n-      /* Give the whole object the alignment it wants.  */\n-      const_size = CEIL (const_size, record_align) * record_align;\n-    }\n-\n-  /* Set the alignment in the complete type.  We don't set CLASSTYPE_ALIGN\n-   here, as that is for this class, without any virtual base classes.  */\n-  TYPE_ALIGN (rec) = record_align;\n-  if (const_size != nonvirtual_const_size)\n-    {\n-      TYPE_SIZE (rec) = size_int (const_size);\n-      TYPE_SIZE_UNIT (rec) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (rec),\n-                                         size_int (BITS_PER_UNIT));\n-    }\n-\n-  /* Now propagate offset information throughout the lattice.\n-     Simultaneously, remove the temporary FIELD_DECLS we created in\n-     build_base_fields to refer to base types.  */\n-  field = &TYPE_FIELDS (rec);\n-  if (TYPE_VFIELD (rec) == *field)\n-    {\n-      /* If this class did not have a primary base, we create a\n-\t virtual function table pointer.  It will be the first thing\n-\t in the class, under the new ABI.  Skip it; the base fields\n-\t will follow it.  */\n-      my_friendly_assert (flag_new_abi \n-\t\t\t  && !CLASSTYPE_HAS_PRIMARY_BASE_P (rec),\n-\t\t\t  19991218);\n-      field = &TREE_CHAIN (*field);\n-    }\n-    \n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tcontinue;\n-\n-      my_friendly_assert (TREE_TYPE (*field) == basetype, 23897);\n-\n-      if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t    basetype, rec);\n-\n-      BINFO_OFFSET (base_binfo)\n-\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n-\t\t\t  BITS_PER_UNIT));\n-      propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n-\n-      /* Remove this field.  */\n-      *field = TREE_CHAIN (*field);\n-    }\n-\n-  for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n-       vbase_types = TREE_CHAIN (vbase_types))\n-    {\n-      BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n-      unshare_base_binfos (vbase_types);\n-      propagate_binfo_offsets (vbase_types, BINFO_OFFSET (vbase_types));\n-\n-      if (extra_warnings)\n-\t{\n-\t  tree basetype = BINFO_TYPE (vbase_types);\n-\t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\t    cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t\tbasetype, rec);\n-\t}\n-    }\n-\n-  return max;\n-}\n-\n \f\n /* Hashing of lists so that we don't make duplicates.\n    The entry point is `list_hash_canon'.  */"}]}