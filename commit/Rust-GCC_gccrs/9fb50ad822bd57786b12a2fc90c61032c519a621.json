{"sha": "9fb50ad822bd57786b12a2fc90c61032c519a621", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiNTBhZDgyMmJkNTc3ODZiMTJhMmZjOTBjNjEwMzJjNTE5YTYyMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:31:09Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:31:09Z"}, "message": "Port edge_growth_cache to call_summary.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-inline-analysis.c (inline_edge_removal_hook): Remove.\n\t(initialize_growth_caches): Remove.\n\t(free_growth_caches): Likewise.\n\t(do_estimate_edge_time): Use edge_growth_cache.\n\t(do_estimate_edge_size): Likewise.\n\t(do_estimate_edge_hints): Likewise.\n\t* ipa-inline.c (reset_edge_caches): Likewise.\n\t(recursive_inlining): Likewise.\n\t(inline_small_functions): Likewise.\n\t* ipa-inline.h (initialize_growth_caches): Remove.\n\t(estimate_edge_size): Likewise.\n\t(estimate_edge_time): Likewise.\n\t(estimate_edge_hints): Likewise.\n\t(reset_edge_growth_cache): Likewise.\n\t* symbol-summary.h (call_summary::remove): New method.\n\nFrom-SVN: r261318", "tree": {"sha": "167105a5677e1cdfe7a5f9f9b37b02b13340a447", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/167105a5677e1cdfe7a5f9f9b37b02b13340a447"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb50ad822bd57786b12a2fc90c61032c519a621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb50ad822bd57786b12a2fc90c61032c519a621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb50ad822bd57786b12a2fc90c61032c519a621", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb50ad822bd57786b12a2fc90c61032c519a621/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac2bdb45faaa455afcb3b77eb824dde429c27fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ac2bdb45faaa455afcb3b77eb824dde429c27fb"}], "stats": {"total": 162, "additions": 80, "deletions": 82}, "files": [{"sha": "7c231a0fc1703161424b9647a76cb25bfc11f347", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fb50ad822bd57786b12a2fc90c61032c519a621", "patch": "@@ -1,3 +1,21 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-inline-analysis.c (inline_edge_removal_hook): Remove.\n+\t(initialize_growth_caches): Remove.\n+\t(free_growth_caches): Likewise.\n+\t(do_estimate_edge_time): Use edge_growth_cache.\n+\t(do_estimate_edge_size): Likewise.\n+\t(do_estimate_edge_hints): Likewise.\n+\t* ipa-inline.c (reset_edge_caches): Likewise.\n+\t(recursive_inlining): Likewise.\n+\t(inline_small_functions): Likewise.\n+\t* ipa-inline.h (initialize_growth_caches): Remove.\n+\t(estimate_edge_size): Likewise.\n+\t(estimate_edge_time): Likewise.\n+\t(estimate_edge_hints): Likewise.\n+\t(reset_edge_growth_cache): Likewise.\n+\t* symbol-summary.h (call_summary::remove): New method.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-cp.c (class edge_clone_summary): New summary."}, {"sha": "9a7267395ea78c3e5fe349557ff76e0511590eb5", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9fb50ad822bd57786b12a2fc90c61032c519a621", "patch": "@@ -51,9 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n \n /* Cached node/edge growths.  */\n-vec<edge_growth_cache_entry> edge_growth_cache;\n-static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-\n+call_summary<edge_growth_cache_entry *> *edge_growth_cache = NULL;\n \n /* Give initial reasons why inlining would fail on EDGE.  This gets either\n    nullified or usually overwritten by more precise reasons later.  */\n@@ -80,40 +78,13 @@ initialize_inline_failed (struct cgraph_edge *e)\n }\n \n \n-/* Keep edge cache consistent across edge removal.  */\n-\n-static void\n-inline_edge_removal_hook (struct cgraph_edge *edge,\n-\t\t\t  void *data ATTRIBUTE_UNUSED)\n-{\n-  reset_edge_growth_cache (edge);\n-}\n-\n-\n-/* Initialize growth caches.  */\n-\n-void\n-initialize_growth_caches (void)\n-{\n-  if (!edge_removal_hook_holder)\n-    edge_removal_hook_holder =\n-      symtab->add_edge_removal_hook (&inline_edge_removal_hook, NULL);\n-  if (symtab->edges_max_uid)\n-    edge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n-}\n-\n-\n /* Free growth caches.  */\n \n void\n free_growth_caches (void)\n {\n-  if (edge_removal_hook_holder)\n-    {\n-      symtab->remove_edge_removal_hook (edge_removal_hook_holder);\n-      edge_removal_hook_holder = NULL;\n-    }\n-  edge_growth_cache.release ();\n+  delete edge_growth_cache;\n+  edge_growth_cache = NULL;\n }\n \n /* Return hints derrived from EDGE.   */\n@@ -188,17 +159,17 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   gcc_checking_assert (time >= 0);\n \n   /* When caching, update the cache entry.  */\n-  if (edge_growth_cache.exists ())\n+  if (edge_growth_cache != NULL)\n     {\n       ipa_fn_summaries->get_create (edge->callee)->min_size = min_size;\n-      if ((int) edge_growth_cache.length () <= edge->uid)\n-\tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n-      edge_growth_cache[edge->uid].time = time;\n-      edge_growth_cache[edge->uid].nonspec_time = nonspec_time;\n+      edge_growth_cache_entry *entry\n+\t= edge_growth_cache->get_create (edge);\n+      entry->time = time;\n+      entry->nonspec_time = nonspec_time;\n \n-      edge_growth_cache[edge->uid].size = size + (size >= 0);\n+      entry->size = size + (size >= 0);\n       hints |= simple_edge_hints (edge);\n-      edge_growth_cache[edge->uid].hints = hints + 1;\n+      entry->hints = hints + 1;\n     }\n   return time;\n }\n@@ -219,10 +190,10 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n-  if (edge_growth_cache.exists ())\n+  if (edge_growth_cache != NULL)\n     {\n       do_estimate_edge_time (edge);\n-      size = edge_growth_cache[edge->uid].size;\n+      size = edge_growth_cache->get (edge)->size;\n       gcc_checking_assert (size);\n       return size - (size > 0);\n     }\n@@ -260,10 +231,10 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n-  if (edge_growth_cache.exists ())\n+  if (edge_growth_cache != NULL)\n     {\n       do_estimate_edge_time (edge);\n-      hints = edge_growth_cache[edge->uid].hints;\n+      hints = edge_growth_cache->get (edge)->hints;\n       gcc_checking_assert (hints);\n       return hints - 1;\n     }"}, {"sha": "0d8c6f0af20216752fbb3c4f55eb33837cc1c150", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=9fb50ad822bd57786b12a2fc90c61032c519a621", "patch": "@@ -1287,9 +1287,10 @@ reset_edge_caches (struct cgraph_node *node)\n   if (where->global.inlined_to)\n     where = where->global.inlined_to;\n \n-  for (edge = where->callers; edge; edge = edge->next_caller)\n-    if (edge->inline_failed)\n-      reset_edge_growth_cache (edge);\n+  if (edge_growth_cache != NULL)\n+    for (edge = where->callers; edge; edge = edge->next_caller)\n+      if (edge->inline_failed)\n+\tedge_growth_cache->remove (edge);\n \n   FOR_EACH_ALIAS (where, ref)\n     reset_edge_caches (dyn_cast <cgraph_node *> (ref->referring));\n@@ -1302,8 +1303,8 @@ reset_edge_caches (struct cgraph_node *node)\n       e = e->callee->callees;\n     else\n       {\n-\tif (e->inline_failed)\n-\t  reset_edge_growth_cache (e);\n+\tif (edge_growth_cache != NULL && e->inline_failed)\n+\t  edge_growth_cache->remove (e);\n \tif (e->next_callee)\n \t  e = e->next_callee;\n \telse\n@@ -1496,13 +1497,15 @@ recursive_inlining (struct cgraph_edge *edge,\n       if (master_clone)\n \t{\n \t  curr->redirect_callee (master_clone);\n-\t  reset_edge_growth_cache (curr);\n+\t  if (edge_growth_cache != NULL)\n+\t    edge_growth_cache->remove (curr);\n \t}\n \n       if (estimate_size_after_inlining (node, curr) > limit)\n \t{\n \t  curr->redirect_callee (dest);\n-\t  reset_edge_growth_cache (curr);\n+\t  if (edge_growth_cache != NULL)\n+\t    edge_growth_cache->remove (curr);\n \t  break;\n \t}\n \n@@ -1516,7 +1519,8 @@ recursive_inlining (struct cgraph_edge *edge,\n       if (!want_inline_self_recursive_call_p (curr, node, false, depth))\n \t{\n \t  curr->redirect_callee (dest);\n-\t  reset_edge_growth_cache (curr);\n+\t  if (edge_growth_cache != NULL)\n+\t    edge_growth_cache->remove (curr);\n \t  continue;\n \t}\n \n@@ -1541,7 +1545,8 @@ recursive_inlining (struct cgraph_edge *edge,\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL);\n \t  curr->redirect_callee (master_clone);\n-          reset_edge_growth_cache (curr);\n+\t  if (edge_growth_cache != NULL)\n+\t    edge_growth_cache->remove (curr);\n \t}\n \n       inline_call (curr, false, new_edges, &overall_size, true);\n@@ -1798,7 +1803,8 @@ inline_small_functions (void)\n \t  max_count = max_count.max (edge->count.ipa ());\n       }\n   ipa_free_postorder_info ();\n-  initialize_growth_caches ();\n+  edge_growth_cache\n+    = new call_summary<edge_growth_cache_entry *> (symtab, false);\n \n   if (dump_file)\n     fprintf (dump_file,\n@@ -1892,7 +1898,8 @@ inline_small_functions (void)\n \t  sreal old_time_est = estimate_edge_time (edge);\n \t  int old_hints_est = estimate_edge_hints (edge);\n \n-\t  reset_edge_growth_cache (edge);\n+\t  if (edge_growth_cache != NULL)\n+\t    edge_growth_cache->remove (edge);\n \t  gcc_assert (old_size_est == estimate_edge_size (edge));\n \t  gcc_assert (old_time_est == estimate_edge_time (edge));\n \t  /* FIXME:\n@@ -1906,7 +1913,7 @@ inline_small_functions (void)\n \t     for given invocation but that will be better done once whole\n \t     code is converted to sreals.  Disable for now and revert to \"wrong\"\n \t     value so enable/disable checking paths agree.  */\n-\t  edge_growth_cache[edge->uid].hints = old_hints_est + 1;\n+\t  edge_growth_cache->get (edge)->hints = old_hints_est + 1;\n \n \t  /* When updating the edge costs, we only decrease badness in the keys.\n \t     Increases of badness are handled lazilly; when we see key with out"}, {"sha": "15825bca820f39273d2190f4f45a9286bb3a959f", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=9fb50ad822bd57786b12a2fc90c61032c519a621", "patch": "@@ -38,7 +38,7 @@ struct edge_growth_cache_entry\n       hints (hints) {}\n };\n \n-extern vec<edge_growth_cache_entry> edge_growth_cache;\n+extern call_summary<edge_growth_cache_entry *> *edge_growth_cache;\n \n /* In ipa-inline-analysis.c  */\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n@@ -47,7 +47,6 @@ bool growth_likely_positive (struct cgraph_node *, int);\n int do_estimate_edge_size (struct cgraph_edge *edge);\n sreal do_estimate_edge_time (struct cgraph_edge *edge);\n ipa_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n-void initialize_growth_caches (void);\n void free_growth_caches (void);\n \n /* In ipa-inline.c  */\n@@ -69,11 +68,12 @@ extern int nfunctions_inlined;\n static inline int\n estimate_edge_size (struct cgraph_edge *edge)\n {\n-  int ret;\n-  if ((int)edge_growth_cache.length () <= edge->uid\n-      || !(ret = edge_growth_cache[edge->uid].size))\n+  edge_growth_cache_entry *entry;\n+  if (edge_growth_cache == NULL\n+      || (entry = edge_growth_cache->get (edge)) == NULL\n+      || entry->size == 0)\n     return do_estimate_edge_size (edge);\n-  return ret - (ret > 0);\n+  return entry->size - (entry->size > 0);\n }\n \n /* Return estimated callee growth after inlining EDGE.  */\n@@ -92,13 +92,14 @@ estimate_edge_growth (struct cgraph_edge *edge)\n static inline sreal\n estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n {\n-  sreal ret;\n-  if ((int)edge_growth_cache.length () <= edge->uid\n-      || !edge_growth_cache[edge->uid].size)\n+  edge_growth_cache_entry *entry;\n+  if (edge_growth_cache == NULL\n+      || (entry = edge_growth_cache->get (edge)) == NULL\n+      || entry->time == 0)\n     return do_estimate_edge_time (edge);\n   if (nonspec_time)\n-    *nonspec_time = edge_growth_cache[edge->uid].nonspec_time;\n-  return edge_growth_cache[edge->uid].time;\n+    *nonspec_time = edge_growth_cache->get (edge)->nonspec_time;\n+  return entry->time;\n }\n \n \n@@ -108,23 +109,12 @@ estimate_edge_time (struct cgraph_edge *edge, sreal *nonspec_time = NULL)\n static inline ipa_hints\n estimate_edge_hints (struct cgraph_edge *edge)\n {\n-  ipa_hints ret;\n-  if ((int)edge_growth_cache.length () <= edge->uid\n-      || !(ret = edge_growth_cache[edge->uid].hints))\n+  edge_growth_cache_entry *entry;\n+  if (edge_growth_cache == NULL\n+      || (entry = edge_growth_cache->get (edge)) == NULL\n+      || entry->hints == 0)\n     return do_estimate_edge_hints (edge);\n-  return ret - 1;\n-}\n-\n-/* Reset cached value for EDGE.  */\n-\n-static inline void\n-reset_edge_growth_cache (struct cgraph_edge *edge)\n-{\n-  if ((int)edge_growth_cache.length () > edge->uid)\n-    {\n-      struct edge_growth_cache_entry zero (0, 0, 0, 0);\n-      edge_growth_cache[edge->uid] = zero;\n-    }\n+  return entry->hints - 1;\n }\n \n #endif /* GCC_IPA_INLINE_H */"}, {"sha": "12e50201125386b4c0bbd72bffa36416fe8f0659", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb50ad822bd57786b12a2fc90c61032c519a621/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=9fb50ad822bd57786b12a2fc90c61032c519a621", "patch": "@@ -384,6 +384,18 @@ class GTY((user)) call_summary <T *>\n     return get (hashable_uid (edge), false);\n   }\n \n+  /* Remove edge from summary.  */\n+  void remove (cgraph_edge *edge)\n+  {\n+    int uid = hashable_uid (edge);\n+    T **v = m_map.get (uid);\n+    if (v)\n+      {\n+\tm_map.remove (uid);\n+\trelease (*v);\n+      }\n+  }\n+\n   /* Return number of elements handled by data structure.  */\n   size_t elements ()\n   {"}]}