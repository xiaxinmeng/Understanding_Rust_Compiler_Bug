{"sha": "b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQzMjllM2RkNmZiN2M3ODk0OGZjZjlkMmY1YjlkODczZGVlYzI4NA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-26T12:35:31Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-05-26T12:35:31Z"}, "message": "c++: Fix reference NTTP binding to noexcept fn [PR97420]\n\nHere, in C++17 mode, convert_nontype_argument_function is rejecting\nbinding a non-noexcept function reference template parameter to a\nnoexcept function (encoded as the template argument '*(int (&) (int)) &f').\n\nThe first roadblock to making this work is that the argument is wrapped\nan an implicit INDIRECT_REF, so we need to unwrap it before calling\nstrip_fnptr_conv.\n\nThe second roadblock is that the NOP_EXPR cast converts from a function\npointer type to a reference type while simultaneously removing the\nnoexcept qualification, and fnptr_conv_p doesn't consider this cast to\nbe a function pointer conversion.  This patch fixes this by making\nfnptr_conv_p treat REFERENCE_TYPEs and POINTER_TYPEs interchangeably.\n\nFinally, in passing, this patch also simplifies noexcept_conv_p by\nremoving a bunch of redundant checks already performed by its only\ncaller fnptr_conv_p.\n\n\tPR c++/97420\n\ngcc/cp/ChangeLog:\n\n\t* cvt.c (noexcept_conv_p): Remove redundant checks and simplify.\n\t(fnptr_conv_p): Don't call non_reference.  Use INDIRECT_TYPE_P\n\tinstead of TYPE_PTR_P.\n\t* pt.c (convert_nontype_argument_function): Look through\n\timplicit INDIRECT_REFs before calling strip_fnptr_conv.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/noexcept68.C: New test.", "tree": {"sha": "d00562e26db85a44f3d94e1eee696e92b47d3c63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d00562e26db85a44f3d94e1eee696e92b47d3c63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/comments", "author": null, "committer": null, "parents": [{"sha": "95d67762171f83277a5700b270c0d1e2756f83f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95d67762171f83277a5700b270c0d1e2756f83f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95d67762171f83277a5700b270c0d1e2756f83f4"}], "stats": {"total": 49, "additions": 23, "deletions": 26}, "files": [{"sha": "330d65854b4289547546d8d34c289d4bb93c9dae", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "patch": "@@ -2081,55 +2081,41 @@ can_convert_tx_safety (tree to, tree from)\n \t  && same_type_p (to, tx_unsafe_fn_variant (from)));\n }\n \n-/* Return true iff FROM can convert to TO by dropping noexcept.  */\n+/* Return true iff FROM can convert to TO by dropping noexcept.\n+   This is just a subroutine of of fnptr_conv_p.  */\n \n static bool\n noexcept_conv_p (tree to, tree from)\n {\n   if (!flag_noexcept_type)\n     return false;\n \n-  tree t = non_reference (to);\n-  tree f = from;\n-  if (TYPE_PTRMEMFUNC_P (t)\n-      && TYPE_PTRMEMFUNC_P (f))\n-    {\n-      t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n-      f = TYPE_PTRMEMFUNC_FN_TYPE (f);\n-    }\n-  if (TYPE_PTR_P (t)\n-      && TYPE_PTR_P (f))\n-    {\n-      t = TREE_TYPE (t);\n-      f = TREE_TYPE (f);\n-    }\n-  tree_code code = TREE_CODE (f);\n-  if (TREE_CODE (t) != code)\n+  if (TREE_CODE (to) != TREE_CODE (from))\n     return false;\n-  if (code != FUNCTION_TYPE && code != METHOD_TYPE)\n+  if (!FUNC_OR_METHOD_TYPE_P (from))\n     return false;\n-  if (!type_throw_all_p (t)\n-      || type_throw_all_p (f))\n+  if (!type_throw_all_p (to)\n+      || type_throw_all_p (from))\n     return false;\n-  tree v = build_exception_variant (f, NULL_TREE);\n-  return same_type_p (t, v);\n+  tree v = build_exception_variant (from, NULL_TREE);\n+  return same_type_p (to, v);\n }\n \n /* Return true iff FROM can convert to TO by a function pointer conversion.  */\n \n bool\n fnptr_conv_p (tree to, tree from)\n {\n-  tree t = non_reference (to);\n+  tree t = to;\n   tree f = from;\n   if (TYPE_PTRMEMFUNC_P (t)\n       && TYPE_PTRMEMFUNC_P (f))\n     {\n       t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n       f = TYPE_PTRMEMFUNC_FN_TYPE (f);\n     }\n-  if (TYPE_PTR_P (t)\n-      && TYPE_PTR_P (f))\n+  if (INDIRECT_TYPE_P (t)\n+      && INDIRECT_TYPE_P (f))\n     {\n       t = TREE_TYPE (t);\n       f = TREE_TYPE (f);"}, {"sha": "f3fa9c192ad56153a9c6409f4925b6064af60fba", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "patch": "@@ -6622,7 +6622,10 @@ convert_nontype_argument_function (tree type, tree expr,\n   if (value_dependent_expression_p (fn))\n     goto accept;\n \n-  fn_no_ptr = strip_fnptr_conv (fn);\n+  fn_no_ptr = fn;\n+  if (REFERENCE_REF_P (fn_no_ptr))\n+    fn_no_ptr = TREE_OPERAND (fn_no_ptr, 0);\n+  fn_no_ptr = strip_fnptr_conv (fn_no_ptr);\n   if (TREE_CODE (fn_no_ptr) == ADDR_EXPR)\n     fn_no_ptr = TREE_OPERAND (fn_no_ptr, 0);\n   if (BASELINK_P (fn_no_ptr))"}, {"sha": "086899a4a19fd216c8872b67817eefb7e1f315a2", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept68.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept68.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4329e3dd6fb7c78948fcf9d2f5b9d873deec284/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept68.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept68.C?ref=b4329e3dd6fb7c78948fcf9d2f5b9d873deec284", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/97420\n+// { dg-do compile { target c++11 } }\n+\n+int f(int) noexcept;\n+template<int (&)(int)> void A();\n+int main() {\n+  A<f>();\n+}"}]}