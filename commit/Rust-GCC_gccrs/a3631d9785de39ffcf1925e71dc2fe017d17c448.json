{"sha": "a3631d9785de39ffcf1925e71dc2fe017d17c448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM2MzFkOTc4NWRlMzlmZmNmMTkyNWU3MWRjMmZlMDE3ZDE3YzQ0OA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-08-23T08:17:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-08-23T08:17:20Z"}, "message": "tree-ssa-loop-im.c (fem_single_reachable_address, [...]): New functions.\n\n\t* tree-ssa-loop-im.c (fem_single_reachable_address, for_each_memref):\n\tNew functions.\n\t(single_reachable_address): Use them.\n\t(schedule_sm): Add dump.\n\t(is_call_clobbered_ref): New function.\n\t(determine_lsm_reg): Check whether the reference is call clobbered.\n\tOnly work for gimple_reg_type values.\n\nFrom-SVN: r86418", "tree": {"sha": "2beddeafd901f493531bb38780ea9185b51b567c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2beddeafd901f493531bb38780ea9185b51b567c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3631d9785de39ffcf1925e71dc2fe017d17c448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3631d9785de39ffcf1925e71dc2fe017d17c448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3631d9785de39ffcf1925e71dc2fe017d17c448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3631d9785de39ffcf1925e71dc2fe017d17c448/comments", "author": null, "committer": null, "parents": [{"sha": "b1f58428618b90ec7e79df0e113e592b3a68e9f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1f58428618b90ec7e79df0e113e592b3a68e9f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1f58428618b90ec7e79df0e113e592b3a68e9f2"}], "stats": {"total": 189, "additions": 167, "deletions": 22}, "files": [{"sha": "c68a2ed73e55b84641bd22bbbfda0403c4ee09a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3631d9785de39ffcf1925e71dc2fe017d17c448/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3631d9785de39ffcf1925e71dc2fe017d17c448/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3631d9785de39ffcf1925e71dc2fe017d17c448", "patch": "@@ -1,3 +1,13 @@\n+2004-08-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-ssa-loop-im.c (fem_single_reachable_address, for_each_memref):\n+\tNew functions.\n+\t(single_reachable_address): Use them.\n+\t(schedule_sm): Add dump.\n+\t(is_call_clobbered_ref): New function.\n+\t(determine_lsm_reg): Check whether the reference is call clobbered.\n+\tOnly work for gimple_reg_type values.\n+\n 2004-08-23  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (*mov<mode>_ra): Name previously unnamed MIPS16"}, {"sha": "de2540aa4f2c28f622a0418e04bad8d0a493af16", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 157, "deletions": 22, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3631d9785de39ffcf1925e71dc2fe017d17c448/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3631d9785de39ffcf1925e71dc2fe017d17c448/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=a3631d9785de39ffcf1925e71dc2fe017d17c448", "patch": "@@ -833,34 +833,118 @@ maybe_queue_var (tree var, struct loop *loop,\n   queue[(*in_queue)++] = stmt;\n }\n \n+/* If COMMON_REF is NULL, set COMMON_REF to *OP and return true.\n+   Otherwise return true if the memory reference *OP is equal to COMMON_REF.\n+   Record the reference OP to list MEM_REFS.  STMT is the statement in that\n+   the reference occurs.  */\n+\n+struct sra_data\n+{\n+  struct mem_ref **mem_refs;\n+  tree common_ref;\n+  tree stmt;\n+};\n+\n+static bool\n+fem_single_reachable_address (tree *op, void *data)\n+{\n+  struct sra_data *sra_data = data;\n+\n+  if (sra_data->common_ref\n+      && !operand_equal_p (*op, sra_data->common_ref, 0))\n+    return false;\n+  sra_data->common_ref = *op;\n+\n+  record_mem_ref (sra_data->mem_refs, sra_data->stmt, op);\n+  return true;\n+}\n+\n+/* Runs CALLBACK for each operand of STMT that is a memory reference.  DATA\n+   is passed to the CALLBACK as well.  The traversal stops if CALLBACK\n+   returns false, for_each_memref then returns false as well.  Otherwise\n+   for_each_memref returns true.  */\n+\n+static bool\n+for_each_memref (tree stmt, bool (*callback)(tree *, void *), void *data)\n+{\n+  tree *op;\n+\n+  if (TREE_CODE (stmt) == RETURN_EXPR)\n+    stmt = TREE_OPERAND (stmt, 1);\n+\n+  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+    {\n+      op = &TREE_OPERAND (stmt, 0);\n+      if (TREE_CODE (*op) != SSA_NAME\n+\t  && !callback (op, data))\n+\treturn false;\n+\n+      op = &TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (*op) != SSA_NAME\n+\t  && is_gimple_lvalue (*op)\n+\t  && !callback (op, data))\n+\treturn false;\n+\n+      stmt = TREE_OPERAND (stmt, 1);\n+    }\n+\n+  if (TREE_CODE (stmt) == WITH_SIZE_EXPR)\n+    stmt = TREE_OPERAND (stmt, 0);\n+\n+  if (TREE_CODE (stmt) == CALL_EXPR)\n+    {\n+      tree args;\n+\n+      for (args = TREE_OPERAND (stmt, 1); args; args = TREE_CHAIN (args))\n+\t{\n+\t  op = &TREE_VALUE (args);\n+\n+\t  if (TREE_CODE (*op) != SSA_NAME\n+\t      && is_gimple_lvalue (*op)\n+\t      && !callback (op, data))\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Determine whether all memory references inside the LOOP that correspond\n    to virtual ssa names defined in statement STMT are equal.\n    If so, store the list of the references to MEM_REFS, and return one\n-   of them.  Otherwise store NULL to MEM_REFS and return NULL_TREE.  */\n+   of them.  Otherwise store NULL to MEM_REFS and return NULL_TREE.\n+   *SEEN_CALL_STMT is set to true if the virtual operands suggest\n+   that the reference might be clobbered by a call inside the LOOP.  */\n \n static tree\n single_reachable_address (struct loop *loop, tree stmt,\n-\t\t\t  struct mem_ref **mem_refs)\n+\t\t\t  struct mem_ref **mem_refs,\n+\t\t\t  bool *seen_call_stmt)\n {\n   tree *queue = xmalloc (sizeof (tree) * max_uid);\n   sbitmap seen = sbitmap_alloc (max_uid);\n-  tree common_ref = NULL, *aref;\n   unsigned in_queue = 1;\n   dataflow_t df;\n   unsigned i, n;\n   v_may_def_optype v_may_defs;\n   vuse_optype vuses;\n+  struct sra_data sra_data;\n+  tree call;\n \n   sbitmap_zero (seen);\n \n   *mem_refs = NULL;\n+  sra_data.mem_refs = mem_refs;\n+  sra_data.common_ref = NULL_TREE;\n \n   queue[0] = stmt;\n   SET_BIT (seen, stmt_ann (stmt)->uid);\n+  *seen_call_stmt = false;\n \n   while (in_queue)\n     {\n       stmt = queue[--in_queue];\n+      sra_data.stmt = stmt;\n \n       if (LIM_DATA (stmt)\n \t  && LIM_DATA (stmt)->sm_done)\n@@ -869,17 +953,20 @@ single_reachable_address (struct loop *loop, tree stmt,\n       switch (TREE_CODE (stmt))\n \t{\n \tcase MODIFY_EXPR:\n-\t  aref = &TREE_OPERAND (stmt, 0);\n-\t  if (is_gimple_reg (*aref)\n-\t      || !is_gimple_lvalue (*aref))\n-\t    aref = &TREE_OPERAND (stmt, 1);\n-\t  if (is_gimple_reg (*aref)\n-\t      || !is_gimple_lvalue (*aref)\n-\t      || (common_ref && !operand_equal_p (*aref, common_ref, 0)))\n+\tcase CALL_EXPR:\n+\tcase RETURN_EXPR:\n+\t  if (!for_each_memref (stmt, fem_single_reachable_address,\n+\t\t\t\t&sra_data))\n \t    goto fail;\n-\t  common_ref = *aref;\n \n-\t  record_mem_ref (mem_refs, stmt, aref);\n+\t  /* If this is a function that may depend on the memory location,\n+\t     record the fact.  We cannot directly refuse call clobbered\n+\t     operands here, since sra_data.common_ref did not have\n+\t     to be set yet.  */\n+\t  call = get_call_expr_in (stmt);\n+\t  if (call\n+\t      && !(call_expr_flags (call) & ECF_CONST))\n+\t    *seen_call_stmt = true;\n \n \t  /* Traverse also definitions of the VUSES (there may be other\n \t     distinct from the one we used to get to this statement).  */\n@@ -926,7 +1013,7 @@ single_reachable_address (struct loop *loop, tree stmt,\n   free (queue);\n   sbitmap_free (seen);\n \n-  return common_ref;\n+  return sra_data.common_ref;\n \n fail:\n   free_mem_refs (*mem_refs);\n@@ -994,6 +1081,13 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n   tree load, store;\n   struct fmt_data fmt_data;\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Executing store motion of \");\n+      print_generic_expr (dump_file, ref, 0);\n+      fprintf (dump_file, \" from loop %d\\n\", loop->num);\n+    }\n+\n   tmp_var = make_rename_temp (TREE_TYPE (ref), \"lsm_tmp\");\n \n   fmt_data.loop = loop;\n@@ -1023,6 +1117,39 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n     }\n }\n \n+/* Returns true if REF may be clobbered by calls.  */\n+\n+static bool\n+is_call_clobbered_ref (tree ref)\n+{\n+  tree base;\n+\n+  base = get_base_address (ref);\n+  if (!base)\n+    return true;\n+\n+  if (DECL_P (base))\n+    return is_call_clobbered (base);\n+\n+  if (TREE_CODE (base) == INDIRECT_REF)\n+    {\n+      /* Check whether the alias tags associated with the pointer\n+\t are call clobbered.  */\n+      tree ptr = TREE_OPERAND (base, 0);\n+      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+      tree nmt = (pi) ? pi->name_mem_tag : NULL_TREE;\n+      tree tmt = var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+\n+      if ((nmt && is_call_clobbered (nmt))\n+\t  || (tmt && is_call_clobbered (tmt)))\n+\treturn true;\n+\n+      return false;\n+    }\n+\n+  abort ();\n+}\n+\n /* Determine whether all memory references inside LOOP corresponding to the\n    virtual ssa name REG are equal to each other, and whether the address of\n    this common reference can be hoisted outside of the loop.  If this is true,\n@@ -1037,19 +1164,28 @@ determine_lsm_reg (struct loop *loop, edge *exits, unsigned n_exits, tree reg)\n   tree ref;\n   struct mem_ref *mem_refs, *aref;\n   struct loop *must_exec;\n+  bool sees_call;\n   \n   if (is_gimple_reg (reg))\n     return;\n   \n-  ref = single_reachable_address (loop, SSA_NAME_DEF_STMT (reg), &mem_refs);\n+  ref = single_reachable_address (loop, SSA_NAME_DEF_STMT (reg), &mem_refs,\n+\t\t\t\t  &sees_call);\n   if (!ref)\n     return;\n \n+  /* If we cannot create a ssa name for the result, give up.  */\n+  if (!is_gimple_reg_type (TREE_TYPE (ref))\n+      || TREE_THIS_VOLATILE (ref))\n+    goto fail;\n+\n+  /* If there is a call that may use the location, give up as well.  */\n+  if (sees_call\n+      && is_call_clobbered_ref (ref))\n+    goto fail;\n+\n   if (!for_each_index (&ref, may_move_till, loop))\n-    {\n-      free_mem_refs (mem_refs);\n-      return;\n-    }\n+    goto fail;\n \n   if (tree_could_trap_p (ref))\n     {\n@@ -1079,13 +1215,12 @@ determine_lsm_reg (struct loop *loop, edge *exits, unsigned n_exits, tree reg)\n \t}\n \n       if (!aref)\n-\t{\n-\t  free_mem_refs (mem_refs);\n-\t  return;\n-\t}\n+\tgoto fail;\n     }\n \n   schedule_sm (loop, exits, n_exits, ref, mem_refs);\n+\n+fail: ;\n   free_mem_refs (mem_refs);\n }\n "}]}