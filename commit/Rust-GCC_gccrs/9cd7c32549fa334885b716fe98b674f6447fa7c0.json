{"sha": "9cd7c32549fa334885b716fe98b674f6447fa7c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNkN2MzMjU0OWZhMzM0ODg1YjcxNmZlOThiNjc0ZjY0NDdmYTdjMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-27T05:51:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-27T20:08:05Z"}, "message": "c++: Dependent using enum [PR97874]\n\nThe handling of dependent scopes and unsuitable scopes in lookup_using_decl\nwas a bit convoluted; I tweaked it for a while and then eventually\nreorganized much of the function to hopefully be clearer.  Along the way I\nnoticed a couple of ways we were mishandling inherited constructors.\n\nThe local binding for a dependent using is the USING_DECL.\n\nImplement instantiation of a dependent USING_DECL at function scope.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97874\n\t* name-lookup.c (lookup_using_decl): Clean up handling\n\tof dependency and inherited constructors.\n\t(finish_nonmember_using_decl): Handle DECL_DEPENDENT_P.\n\t* pt.c (tsubst_expr): Handle DECL_DEPENDENT_P.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97874\n\t* g++.dg/lookup/using4.C: No error in C++20.\n\t* g++.dg/cpp0x/decltype37.C: Adjust message.\n\t* g++.dg/template/crash75.C: Adjust message.\n\t* g++.dg/template/crash76.C: Adjust message.\n\t* g++.dg/cpp0x/inh-ctor36.C: New test.\n\t* g++.dg/cpp1z/inh-ctor39.C: New test.\n\t* g++.dg/cpp2a/using-enum-7.C: New test.", "tree": {"sha": "a75a9c54c180f5e49cceec4f6ec3e25cb248cb10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a75a9c54c180f5e49cceec4f6ec3e25cb248cb10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cd7c32549fa334885b716fe98b674f6447fa7c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd7c32549fa334885b716fe98b674f6447fa7c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cd7c32549fa334885b716fe98b674f6447fa7c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd7c32549fa334885b716fe98b674f6447fa7c0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55163419211c6f17e3e22c68304384eba35782a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55163419211c6f17e3e22c68304384eba35782a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55163419211c6f17e3e22c68304384eba35782a3"}], "stats": {"total": 244, "additions": 154, "deletions": 90}, "files": [{"sha": "52e4a630e25df584242a883f9173deeec93b49a7", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -5729,6 +5729,16 @@ lookup_using_decl (tree scope, name_lookup &lookup)\n       /* Naming a class member.  This is awkward in C++20, because we\n \t might be naming an enumerator of an unrelated class.  */\n \n+      tree npscope = scope;\n+      if (PACK_EXPANSION_P (scope))\n+\tnpscope = PACK_EXPANSION_PATTERN (scope);\n+\n+      if (!MAYBE_CLASS_TYPE_P (npscope))\n+\t{\n+\t  error (\"%qT is not a class, namespace, or enumeration\", npscope);\n+\t  return NULL_TREE;\n+\t}\n+\n       /* You cannot using-decl a destructor.  */\n       if (TREE_CODE (lookup.name) == BIT_NOT_EXPR)\n \t{\n@@ -5737,103 +5747,93 @@ lookup_using_decl (tree scope, name_lookup &lookup)\n \t}\n \n       /* Using T::T declares inheriting ctors, even if T is a typedef.  */\n-      if (MAYBE_CLASS_TYPE_P (scope)\n-\t  && (lookup.name == TYPE_IDENTIFIER (scope)\n-\t      || constructor_name_p (lookup.name, scope)))\n+      if (lookup.name == TYPE_IDENTIFIER (npscope)\n+\t  || constructor_name_p (lookup.name, npscope))\n \t{\n \t  if (!TYPE_P (current))\n \t    {\n \t      error (\"non-member using-declaration names constructor of %qT\",\n-\t\t     scope);\n+\t\t     npscope);\n \t      return NULL_TREE;\n \t    }\n \t  maybe_warn_cpp0x (CPP0X_INHERITING_CTORS);\n \t  lookup.name = ctor_identifier;\n \t  CLASSTYPE_NON_AGGREGATE (current) = true;\n     \t}\n \n-      if (!MAYBE_CLASS_TYPE_P (scope))\n-\t;\n+      if (!TYPE_P (current) && cxx_dialect < cxx20)\n+\t{\n+\t  error (\"using-declaration for member at non-class scope\");\n+\t  return NULL_TREE;\n+\t}\n+\n+      bool depscope = dependent_scope_p (scope);\n+\n+      if (depscope)\n+\t/* Leave binfo null.  */;\n       else if (TYPE_P (current))\n \t{\n-\t  dependent_p = dependent_scope_p (scope);\n-\t  if (!dependent_p)\n+\t  binfo = lookup_base (current, scope, ba_any, &b_kind, tf_none);\n+\t  gcc_checking_assert (b_kind >= bk_not_base);\n+\n+\t  if (b_kind == bk_not_base && any_dependent_bases_p ())\n+\t    /* Treat as-if dependent.  */\n+\t    depscope = true;\n+\t  else if (lookup.name == ctor_identifier\n+\t\t   && (b_kind < bk_proper_base || !binfo_direct_p (binfo)))\n \t    {\n-\t      binfo = lookup_base (current, scope, ba_any, &b_kind, tf_none);\n-\t      gcc_checking_assert (b_kind >= bk_not_base);\n-\n-\t      if (lookup.name == ctor_identifier)\n+\t      if (any_dependent_bases_p ())\n+\t\tdepscope = true;\n+\t      else\n \t\t{\n-\t\t  /* Even if there are dependent bases, SCOPE will not\n-\t\t     be direct base, no matter.  */\n-\t\t  if (b_kind < bk_proper_base || !binfo_direct_p (binfo))\n-\t\t    {\n-\t\t      error (\"%qT is not a direct base of %qT\", scope, current);\n-\t\t      return NULL_TREE;\n-\t\t    }\n+\t\t  error (\"%qT is not a direct base of %qT\", scope, current);\n+\t\t  return NULL_TREE;\n \t\t}\n-\t      else if (b_kind < bk_proper_base)\n-\t\tbinfo = TYPE_BINFO (scope);\n-\t      else if (IDENTIFIER_CONV_OP_P (lookup.name)\n-\t\t       && dependent_type_p (TREE_TYPE (lookup.name)))\n-\t\tdependent_p = true;\n \t    }\n+\n+\t  if (b_kind < bk_proper_base)\n+\t    binfo = TYPE_BINFO (scope);\n \t}\n       else\n \tbinfo = TYPE_BINFO (scope);\n \n+      dependent_p = (depscope\n+\t\t     || (IDENTIFIER_CONV_OP_P (lookup.name)\n+\t\t\t && dependent_type_p (TREE_TYPE (lookup.name))));\n+\n       if (!dependent_p)\n-\t{\n-\t  if (binfo)\n-\t    lookup.value = lookup_member (binfo, lookup.name, /*protect=*/2,\n-\t\t\t\t\t  /*want_type=*/false, tf_none);\n+\tlookup.value = lookup_member (binfo, lookup.name, /*protect=*/2,\n+\t\t\t\t      /*want_type=*/false, tf_none);\n \n-\t  tree saved_value = lookup.value;\n-\t  if (lookup.value\n-\t      && b_kind < bk_proper_base)\n+      if (!depscope && b_kind < bk_proper_base)\n+\t{\n+\t  if (cxx_dialect >= cxx20 && lookup.value\n+\t      && TREE_CODE (lookup.value) == CONST_DECL)\n \t    {\n-\t      if (cxx_dialect >= cxx20\n-\t\t  && TREE_CODE (lookup.value) == CONST_DECL)\n-\t\t{\n-\t\t  /* Using an unrelated enum; check access here rather\n-\t\t     than separately for class and non-class using.  */\n-\t\t  perform_or_defer_access_check\n-\t\t    (binfo, lookup.value, lookup.value, tf_warning_or_error);\n-\t\t  /* And then if this is a copy from handle_using_decl, look\n-\t\t     through to the original enumerator.  */\n-\t\t  if (CONST_DECL_USING_P (lookup.value))\n-\t\t    lookup.value = DECL_ABSTRACT_ORIGIN (lookup.value);\n-\t\t}\n-\t      else\n-\t\tlookup.value = NULL_TREE;\n+\t      /* Using an unrelated enum; check access here rather\n+\t\t than separately for class and non-class using.  */\n+\t      perform_or_defer_access_check\n+\t\t(binfo, lookup.value, lookup.value, tf_warning_or_error);\n+\t      /* And then if this is a copy from handle_using_decl, look\n+\t\t through to the original enumerator.  */\n+\t      if (CONST_DECL_USING_P (lookup.value))\n+\t\tlookup.value = DECL_ABSTRACT_ORIGIN (lookup.value);\n \t    }\n-\n-\t  if (!lookup.value)\n+\t  else if (!TYPE_P (current))\n \t    {\n-\t      if (!TYPE_P (current))\n-\t\t{\n-\t\t  error (\"using-declaration for member at non-class scope\");\n-\t\t  return NULL_TREE;\n-\t\t}\n-\n-\t      if (b_kind < bk_proper_base)\n-\t\t{\n-\t\t  if (b_kind == bk_not_base && any_dependent_bases_p ())\n-\t\t    /* Treat as-if dependent.  */\n-\t\t    dependent_p = true;\n-\t\t  else\n-\t\t    {\n-\t\t      auto_diagnostic_group g;\n-\t\t      error_not_base_type (scope, current);\n-\t\t      if (saved_value && DECL_IMPLICIT_TYPEDEF_P (saved_value)\n-\t\t\t  && (TREE_CODE (TREE_TYPE (saved_value))\n-\t\t\t      == ENUMERAL_TYPE))\n-\t\t\tinform (input_location,\n-\t\t\t\t\"did you mean %<using enum %T::%D%>?\",\n-\t\t\t\tscope, lookup.name);\n-\t\t      return NULL_TREE;\n-\t\t    }\n-\t\t}\n+\t      error (\"using-declaration for member at non-class scope\");\n+\t      return NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      auto_diagnostic_group g;\n+\t      error_not_base_type (scope, current);\n+\t      if (lookup.value && DECL_IMPLICIT_TYPEDEF_P (lookup.value)\n+\t\t  && TREE_CODE (TREE_TYPE (lookup.value)) == ENUMERAL_TYPE)\n+\t\tinform (input_location,\n+\t\t\t\"did you mean %<using enum %T::%D%>?\",\n+\t\t\tscope, lookup.name);\n+\t      return NULL_TREE;\n \t    }\n \t}\n     }\n@@ -6455,6 +6455,8 @@ finish_nonmember_using_decl (tree scope, tree name)\n   else\n     {\n       add_decl_expr (using_decl);\n+      if (DECL_DEPENDENT_P (using_decl))\n+\tlookup.value = using_decl;\n       push_using_decl_bindings (&lookup, name, NULL_TREE);\n     }\n }"}, {"sha": "8f05ce28899e46dde03226a8c5b61dfd8d6d3ca1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -18130,22 +18130,33 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t  finish_label_decl (DECL_NAME (decl));\n \telse if (TREE_CODE (decl) == USING_DECL)\n \t  {\n-\t    /* We cannot have a member-using decl here (until 'using\n-\t       enum T' is a thing).  */\n-\t    gcc_checking_assert (!DECL_DEPENDENT_P (decl));\n-\n-\t    /* This must be a non-dependent using-decl, and we'll have\n-\t       used the names it found during template parsing.  We do\n-\t       not want to do the lookup again, because we might not\n-\t       find the things we found then.  (Again, using enum T\n-\t       might mean we have to do things here.)  */\n \t    tree scope = USING_DECL_SCOPE (decl);\n-\t    gcc_checking_assert (scope\n-\t\t\t\t == tsubst (scope, args, complain, in_decl));\n-\t    /* We still need to push the bindings so that we can look up\n-\t       this name later.  */\n-\t    push_using_decl_bindings (DECL_NAME (decl),\n-\t\t\t\t      USING_DECL_DECLS (decl));\n+\t    if (DECL_DEPENDENT_P (decl))\n+\t      {\n+\t\tscope = tsubst (scope, args, complain, in_decl);\n+\t\tif (!MAYBE_CLASS_TYPE_P (scope)\n+\t\t    && TREE_CODE (scope) != ENUMERAL_TYPE)\n+\t\t  {\n+\t\t    if (complain & tf_error)\n+\t\t      error_at (DECL_SOURCE_LOCATION (decl), \"%qT is not a \"\n+\t\t\t\t\"class, namespace, or enumeration\", scope);\n+\t\t    return error_mark_node;\n+\t\t  }\n+\t\tfinish_nonmember_using_decl (scope, DECL_NAME (decl));\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* This is a non-dependent using-decl, and we'll have\n+\t\t   used the names it found during template parsing.  We do\n+\t\t   not want to do the lookup again, because we might not\n+\t\t   find the things we found then.  */\n+\t\tgcc_checking_assert (scope == tsubst (scope, args,\n+\t\t\t\t\t\t      complain, in_decl));\n+\t\t/* We still need to push the bindings so that we can look up\n+\t\t   this name later.  */\n+\t\tpush_using_decl_bindings (DECL_NAME (decl),\n+\t\t\t\t\t  USING_DECL_DECLS (decl));\n+\t      }\n \t  }\n \telse if (is_capture_proxy (decl)\n \t\t && !DECL_TEMPLATE_INSTANTIATION (current_function_decl))"}, {"sha": "5d0f085f433ba43432f50659982b5094203a11ba", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype37.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype37.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -8,7 +8,7 @@ template<typename T> auto foo(T* t) -> wrap<T>* { return 0; }\n template<typename T>\n struct holder : decltype(*foo((T*)0)) // { dg-error \"class type\" }\n {\n-    using decltype(*foo((T*)0))::bar; // { dg-error \"is not a base\" }\n+    using decltype(*foo((T*)0))::bar; // { dg-error \"is not a class\" }\n };\n \n holder<int> h;"}, {"sha": "c531af9bd27bc0438e1119117ba4b4cb212e4118", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor36.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor36.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A { A(); A(int); };\n+\n+template <class... T> struct C: T...\n+{\n+  using A::A;\n+};\n+\n+C<A> c1(42);"}, {"sha": "3e6356c9935f366cea9ce38d1c4d2d34655598b2", "filename": "gcc/testsuite/g++.dg/cpp1z/inh-ctor39.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Finh-ctor39.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++17 } }\n+\n+struct A { A(); A(int); };\n+struct B { B(); B(void*); };\n+\n+template <class... T> struct C: T...\n+{\n+  using T::T...;\n+};\n+\n+C<A,B> c1(42);\n+C<A,B> c2(nullptr);"}, {"sha": "4ba3b9ea89365353b750db99f527a1c69c1d1bac", "filename": "gcc/testsuite/g++.dg/cpp2a/using-enum-7.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fusing-enum-7.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/97874\n+// { dg-do compile { target c++20 } }\n+\n+struct A { enum E { kl }; };\n+\n+template <typename UQ>\n+int\n+v4 ()\n+{\n+  using UQ::kl;\n+  return kl;\n+}\n+\n+template <typename UQ>\n+int\n+v5 ()\n+{\n+  using UQ::kl;\t\t\t// { dg-error \"not a class\" }\n+  return kl;\t\t\t// { dg-error \"not declared\" }\n+}\n+\n+int main()\n+{\n+  v4<A>();\n+  v4<A::E>();\n+  v5<int>();\n+}"}, {"sha": "a9a8ec21c4dd9644c078c7697561a68a21551532", "filename": "gcc/testsuite/g++.dg/lookup/using4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing4.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -10,6 +10,6 @@ template <class T>\n struct Bar : public Foo<T> {\n         void foo()\n         {\n-                using Foo<T>::i;\t// { dg-error \"member at non-class scope\" }\n+                using Foo<T>::i;\t// { dg-error \"member at non-class scope\" \"\" { target c++17_down } }\n         }\n };"}, {"sha": "2bdc3950f541d6b7fee9f859f3a3bca73859c3b8", "filename": "gcc/testsuite/g++.dg/template/crash75.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash75.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash75.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash75.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -2,7 +2,9 @@\n \n template<typename T> struct A\n {\n-  T::X<0> x; // { dg-error \"non-template|T::template|base type\" }\n+  T::X<0> x; // { dg-error \"non-template\" }\n+  // { dg-message \"T::template\" \"\" { target *-*-* } .-1 }\n+  // { dg-prune-output \"is not a class\" }\n };\n \n A<int*> a;"}, {"sha": "2711749eca97b97898ddb5e15504b01477ee1eeb", "filename": "gcc/testsuite/g++.dg/template/crash76.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash76.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd7c32549fa334885b716fe98b674f6447fa7c0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash76.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash76.C?ref=9cd7c32549fa334885b716fe98b674f6447fa7c0", "patch": "@@ -7,7 +7,7 @@ template<typename> struct A\n \n template<typename T> struct B\n {\n-  using A<T>::X::Y; // { dg-error \"not a base type\" }\n+  using A<T>::X::Y; // { dg-error \"not a class\" }\n };\n \n B<int> b;"}]}