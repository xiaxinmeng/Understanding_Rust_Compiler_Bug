{"sha": "874a0341c8306d74db689405040a4bc4f550085a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc0YTAzNDFjODMwNmQ3NGRiNjg5NDA1MDQwYTRiYzRmNTUwMDg1YQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-04-06T09:25:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:25:05Z"}, "message": "par-prag.adb (Prag): Add dummy entry for pragma Compile_Time_Error\n\n2007-04-06  Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Vincent Celier  <celier@adacore.com>\n\n\t* par-prag.adb (Prag): Add dummy entry for pragma Compile_Time_Error\n\t(Extensions_Allowed): No longer sets Ada_Version\n\tEntry for pragma Unreferenced_Objects\n\n\t* sem_prag.adb (Analyze_Pragma, case Priority): Force with of\n\tsystem.tasking if pragma priority used in a procedure\n\t(Analyze_Pragma, case Warning): Handle dot warning switches\n\t(Process_Compile_Time_Warning_Or_Error): New procedure\n\t(Analyze_Pragma): Add processing for Compile_Time_Error\n\tAdd support for extra arguments External_Name and Link_Name.\n\tRemove code associated with pragmas CPP_Virtual and CPP_Vtable.\n\t(Process_Import_Or_Interface): Add support for the use of pragma Import\n\twith tagged types.\n\t(Extensions_Allowed): No longer affects Ada_Version\n\t(Analyze_Pragma): Split Is_Abstract flag into Is_Abstract_Subprogram and\n\tIs_Abstract_Type. Make sure these are called only when appropriate.\n\tAdd processing for pragma Unreferenced_Objects\n\n\t* snames.h, snames.ads, snames.adb: Add entry for pragma\n\tCompile_Time_Error\n\tAdd new standard name Minimum_Binder_Options for new gprmake\n\tAdd new standard names for gprmake: Archive_Suffix,\n\tLibrary_Auto_Init_Supported, Library_Major_Minor_Id_Supported,\n\tLibrary_Support, Library_Version_Options,\n\tShared_Library_Minimum_Options,\n\tShared_Library_Prefix, Shared_Library_Suffix, Symbolic_Link_Supported.\n\tChange Name_Call to Name_uCall so that it cannot clash with a legal\n\tsubprogram name.\n\tAdd new standard names Mapping_Spec_Suffix and Mapping_Body_Suffix\n\tAppend C_Plus_Plus to convention identifiers as synonym for CPP\n\tAdd new standard names Stack and Builder_Switches\n\tAdd new standard names: Compiler_Minimum_Options, Global_Config_File,\n\tLibrary_Builder, Local_Config_File, Objects_Path, Objects_Path_File,\n\tRun_Path_Option, Toolchain_Version.\n\tEntry for pragma Unreferenced_Objects\n\n\t* switch-c.adb (Scan_Front_End_Switches): Store correct -gnateD\n\tswitches, without repetition of \"eD\". Make sure that last character of\n\t-gnatep= switch is not taken as -gnat switch character.\n\tComplete rewrite of circuit for handling saving compilation options\n\tOccasioned by need to support dot switchs for -gnatw, but cleans up\n\tthings in general.\n\t-gnatX does not affect Ada_Version\n\tInclude -gnatyA in -gnatg style switches\n\n\t* sem_warn.ads, sem_warn.adb (Output_Unreferenced_Messages): Exclude\n\twarnings on return objects.\n\t(Warn_On_Useless_Assignment): Exclude warnings on return objects\n\t(Set_Dot_Warning_Switch): New procedure\n\t(Check_References): Add missing case of test for\n\tHas_Pragma_Unreferenced_Objects\n\t(Output_Unreferenced_Messages): Implement effect of new pragma\n\tUnreferenced_Objects, remove special casing of limited controlled\n\tvariables.\n\nFrom-SVN: r123588", "tree": {"sha": "3b517a2f19b064dd50f9f6fd05484c058f948fc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b517a2f19b064dd50f9f6fd05484c058f948fc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/874a0341c8306d74db689405040a4bc4f550085a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874a0341c8306d74db689405040a4bc4f550085a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874a0341c8306d74db689405040a4bc4f550085a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874a0341c8306d74db689405040a4bc4f550085a/comments", "author": null, "committer": null, "parents": [{"sha": "6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c929a2ea0eacad1c3c59c46bcded2fa72b2c7cd"}], "stats": {"total": 2540, "additions": 1220, "deletions": 1320}, "files": [{"sha": "c9afda4999b71e255167a78bc0f422508cd14344", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -376,14 +376,10 @@ begin\n \n          if Chars (Expression (Arg1)) = Name_On then\n             Extensions_Allowed := True;\n-            Ada_Version := Ada_Version_Type'Last;\n          else\n             Extensions_Allowed := False;\n-            Ada_Version := Ada_Version_Type'Min (Ada_Version, Ada_95);\n          end if;\n \n-         Ada_Version_Explicit := Ada_Version;\n-\n       ----------------\n       -- List (2.8) --\n       ----------------\n@@ -1058,6 +1054,7 @@ begin\n            Pragma_Atomic                        |\n            Pragma_Atomic_Components             |\n            Pragma_Attach_Handler                |\n+           Pragma_Compile_Time_Error            |\n            Pragma_Compile_Time_Warning          |\n            Pragma_Convention_Identifier         |\n            Pragma_CPP_Class                     |\n@@ -1179,6 +1176,7 @@ begin\n            Pragma_Unimplemented_Unit            |\n            Pragma_Universal_Data                |\n            Pragma_Unreferenced                  |\n+           Pragma_Unreferenced_Objects          |\n            Pragma_Unreserve_All_Interrupts      |\n            Pragma_Unsuppress                    |\n            Pragma_Use_VADS_Size                 |"}, {"sha": "9ad244c810704a50bec1c1c8daa2e560ef9f456a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 214, "deletions": 371, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -35,7 +35,6 @@ with Casing;   use Casing;\n with Csets;    use Csets;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n-with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Dist; use Exp_Dist;\n with Hostparm; use Hostparm;\n@@ -54,7 +53,6 @@ with Sem;      use Sem;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n-with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n@@ -513,6 +511,9 @@ package body Sem_Prag is\n       --  Shared is an obsolete Ada 83 pragma, treated as being identical\n       --  in effect to pragma Atomic.\n \n+      procedure Process_Compile_Time_Warning_Or_Error;\n+      --  Common processing for Compile_Time_Error and Compile_Time_Warning\n+\n       procedure Process_Convention (C : out Convention_Id; E : out Entity_Id);\n       --  Common procesing for Convention, Interface, Import and Export.\n       --  Checks first two arguments of pragma, and sets the appropriate\n@@ -1985,6 +1986,78 @@ package body Sem_Prag is\n          end if;\n       end Process_Atomic_Shared_Volatile;\n \n+      -------------------------------------------\n+      -- Process_Compile_Time_Warning_Or_Error --\n+      -------------------------------------------\n+\n+      procedure Process_Compile_Time_Warning_Or_Error is\n+         Arg1x : constant Node_Id := Get_Pragma_Arg (Arg1);\n+\n+      begin\n+         GNAT_Pragma;\n+         Check_Arg_Count (2);\n+         Check_No_Identifiers;\n+         Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n+         Analyze_And_Resolve (Arg1x, Standard_Boolean);\n+\n+         if Compile_Time_Known_Value (Arg1x) then\n+            if Is_True (Expr_Value (Get_Pragma_Arg (Arg1))) then\n+               declare\n+                  Str   : constant String_Id :=\n+                            Strval (Get_Pragma_Arg (Arg2));\n+                  Len   : constant Int := String_Length (Str);\n+                  Cont  : Boolean;\n+                  Ptr   : Nat;\n+                  CC    : Char_Code;\n+                  C     : Character;\n+\n+               begin\n+                  Cont := False;\n+                  Ptr := 1;\n+\n+                  --  Loop through segments of message separated by line\n+                  --  feeds. We output these segments as separate messages\n+                  --  with continuation marks for all but the first.\n+\n+                  loop\n+                     Error_Msg_Strlen := 0;\n+\n+                     --  Loop to copy characters from argument to error\n+                     --  message string buffer.\n+\n+                     loop\n+                        exit when Ptr > Len;\n+                        CC := Get_String_Char (Str, Ptr);\n+                        Ptr := Ptr + 1;\n+\n+                        --  Ignore wide chars ??? else store character\n+\n+                        if In_Character_Range (CC) then\n+                           C := Get_Character (CC);\n+                           exit when C = ASCII.LF;\n+                           Error_Msg_Strlen := Error_Msg_Strlen + 1;\n+                           Error_Msg_String (Error_Msg_Strlen) := C;\n+                        end if;\n+                     end loop;\n+\n+                     --  Here with one line ready to go\n+\n+                     Error_Msg_Warn := Prag_Id = Pragma_Compile_Time_Warning;\n+\n+                     if Cont = False then\n+                        Error_Msg_N (\"<~\", Arg1);\n+                        Cont := True;\n+                     else\n+                        Error_Msg_N (\"\\<~\", Arg1);\n+                     end if;\n+\n+                     exit when Ptr > Len;\n+                  end loop;\n+               end;\n+            end if;\n+         end if;\n+      end Process_Compile_Time_Warning_Or_Error;\n+\n       ------------------------\n       -- Process_Convention --\n       ------------------------\n@@ -2247,7 +2320,7 @@ package body Sem_Prag is\n             --  Treat a pragma Import as an implicit body, for GPS use\n \n             if Prag_Id = Pragma_Import then\n-                  Generate_Reference (E, Id, 'b');\n+               Generate_Reference (E, Id, 'b');\n             end if;\n \n             E1 := E;\n@@ -3175,6 +3248,19 @@ package body Sem_Prag is\n             Set_Is_Public (Def_Id);\n             Process_Interface_Name (Def_Id, Arg3, Arg4);\n \n+         --  Import a CPP class\n+\n+         elsif Is_Record_Type (Def_Id)\n+           and then C = Convention_CPP\n+         then\n+            if not Is_Tagged_Type (Def_Id) then\n+               Error_Msg_Sloc := Sloc (Def_Id);\n+               Error_Pragma_Arg (\"imported 'C'P'P type must be tagged\", Arg2);\n+            else\n+               Set_Is_CPP_Class (Def_Id);\n+               Set_Is_Limited_Record (Def_Id);\n+            end if;\n+\n          else\n             Error_Pragma_Arg\n               (\"second argument of pragma% must be object or subprogram\",\n@@ -5035,78 +5121,25 @@ package body Sem_Prag is\n \n          --  Processing for this pragma is shared with Psect_Object\n \n+         ------------------------\n+         -- Compile_Time_Error --\n+         ------------------------\n+\n+         --  pragma Compile_Time_Error\n+         --    (boolean_EXPRESSION, static_string_EXPRESSION);\n+\n+         when Pragma_Compile_Time_Error =>\n+            Process_Compile_Time_Warning_Or_Error;\n+\n          --------------------------\n          -- Compile_Time_Warning --\n          --------------------------\n \n          --  pragma Compile_Time_Warning\n          --    (boolean_EXPRESSION, static_string_EXPRESSION);\n \n-         when Pragma_Compile_Time_Warning => Compile_Time_Warning : declare\n-            Arg1x : constant Node_Id := Get_Pragma_Arg (Arg1);\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_Arg_Count (2);\n-            Check_No_Identifiers;\n-            Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n-            Analyze_And_Resolve (Arg1x, Standard_Boolean);\n-\n-            if Compile_Time_Known_Value (Arg1x) then\n-               if Is_True (Expr_Value (Get_Pragma_Arg (Arg1))) then\n-                  declare\n-                     Str   : constant String_Id :=\n-                               Strval (Get_Pragma_Arg (Arg2));\n-                     Len   : constant Int := String_Length (Str);\n-                     Cont  : Boolean;\n-                     Ptr   : Nat;\n-                     CC    : Char_Code;\n-                     C     : Character;\n-\n-                  begin\n-                     Cont := False;\n-                     Ptr := 1;\n-\n-                     --  Loop through segments of message separated by line\n-                     --  feeds. We output these segments as separate messages\n-                     --  with continuation marks for all but the first.\n-\n-                     loop\n-                        Error_Msg_Strlen := 0;\n-\n-                        --  Loop to copy characters from argument to error\n-                        --  message string buffer.\n-\n-                        loop\n-                           exit when Ptr > Len;\n-                           CC := Get_String_Char (Str, Ptr);\n-                           Ptr := Ptr + 1;\n-\n-                           --  Ignore wide chars ??? else store character\n-\n-                           if In_Character_Range (CC) then\n-                              C := Get_Character (CC);\n-                              exit when C = ASCII.LF;\n-                              Error_Msg_Strlen := Error_Msg_Strlen + 1;\n-                              Error_Msg_String (Error_Msg_Strlen) := C;\n-                           end if;\n-                        end loop;\n-\n-                        --  Here with one line ready to go\n-\n-                        if Cont = False then\n-                           Error_Msg_N (\"?~\", Arg1);\n-                           Cont := True;\n-                        else\n-                           Error_Msg_N (\"\\?~\", Arg1);\n-                        end if;\n-\n-                        exit when Ptr > Len;\n-                     end loop;\n-                  end;\n-               end if;\n-            end if;\n-         end Compile_Time_Warning;\n+         when Pragma_Compile_Time_Warning =>\n+            Process_Compile_Time_Warning_Or_Error;\n \n          -----------------------------\n          -- Complete_Representation --\n@@ -5346,14 +5379,16 @@ package body Sem_Prag is\n          --  pragma CPP_Class ([Entity =>] local_NAME)\n \n          when Pragma_CPP_Class => CPP_Class : declare\n-            Arg         : Node_Id;\n-            Typ         : Entity_Id;\n-            Default_DTC : Entity_Id := Empty;\n-            VTP_Type    : constant Entity_Id  := RTE (RE_Vtable_Ptr);\n-            C           : Entity_Id;\n-            Tag_C       : Entity_Id;\n+            Arg : Node_Id;\n+            Typ : Entity_Id;\n \n          begin\n+            if Warn_On_Obsolescent_Feature then\n+               Error_Msg_N\n+                 (\"'G'N'A'T pragma cpp'_class is now obsolete; replace it\" &\n+                  \" by pragma import?\", N);\n+            end if;\n+\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n@@ -5374,87 +5409,31 @@ package body Sem_Prag is\n \n             Typ := Entity (Arg);\n \n-            if not Is_Record_Type (Typ) then\n-               Error_Pragma_Arg (\"pragma% applicable to a record, \"\n-                 & \"tagged record or record extension\", Arg1);\n-            end if;\n-\n-            Default_DTC := First_Component (Typ);\n-            while Present (Default_DTC)\n-              and then Etype (Default_DTC) /= VTP_Type\n-            loop\n-               Next_Component (Default_DTC);\n-            end loop;\n-\n-            --  Case of non tagged type\n-\n             if not Is_Tagged_Type (Typ) then\n-               Set_Is_CPP_Class (Typ);\n-\n-               if Present (Default_DTC) then\n-                  Error_Pragma_Arg\n-                    (\"only tagged records can contain vtable pointers\", Arg1);\n-               end if;\n-\n-            --  Case of tagged type with no user-defined vtable ptr. In this\n-            --  case, because of our C++ ABI compatibility, the programmer\n-            --  does not need to specify the tag component.\n-\n-            elsif Is_Tagged_Type (Typ)\n-              and then No (Default_DTC)\n-            then\n-               Set_Is_CPP_Class (Typ);\n-               Set_Is_Limited_Record (Typ);\n-\n-            --  Tagged type that has a vtable ptr\n-\n-            elsif Present (Default_DTC) then\n-               Set_Is_CPP_Class (Typ);\n-               Set_Is_Limited_Record (Typ);\n-               Set_Is_Tag (Default_DTC);\n-               Set_DT_Entry_Count (Default_DTC, No_Uint);\n-\n-               --  Since a CPP type has no direct link to its associated tag\n-               --  most tags checks cannot be performed\n-\n-               Set_Kill_Tag_Checks (Typ);\n-               Set_Kill_Tag_Checks (Class_Wide_Type (Typ));\n-\n-               --  Get rid of the _tag component when there was one.\n-               --  It is only useful for regular tagged types\n-\n-               if Expander_Active and then Typ = Root_Type (Typ) then\n-\n-                  Tag_C := First_Tag_Component (Typ);\n-                  C := First_Entity (Typ);\n-\n-                  if C = Tag_C then\n-                     Set_First_Entity (Typ, Next_Entity (Tag_C));\n-\n-                  else\n-                     while Next_Entity (C) /= Tag_C loop\n-                        Next_Entity (C);\n-                     end loop;\n-\n-                     Set_Next_Entity (C, Next_Entity (Tag_C));\n-                  end if;\n-               end if;\n+               Error_Pragma_Arg (\"pragma% applicable to tagged types \", Arg1);\n             end if;\n+\n+            Set_Is_CPP_Class      (Typ);\n+            Set_Is_Limited_Record (Typ);\n+            Set_Convention        (Typ, Convention_CPP);\n          end CPP_Class;\n \n          ---------------------\n          -- CPP_Constructor --\n          ---------------------\n \n-         --  pragma CPP_Constructor ([Entity =>] LOCAL_NAME);\n+         --  pragma CPP_Constructor ([Entity =>] LOCAL_NAME\n+         --    [, [External_Name =>] static_string_EXPRESSION ]\n+         --    [, [Link_Name     =>] static_string_EXPRESSION ]);\n \n          when Pragma_CPP_Constructor => CPP_Constructor : declare\n             Id     : Entity_Id;\n             Def_Id : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n-            Check_Arg_Count (1);\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments (3);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n \n@@ -5473,10 +5452,9 @@ package body Sem_Prag is\n               and then Is_Class_Wide_Type (Etype (Def_Id))\n               and then Is_CPP_Class (Etype (Etype (Def_Id)))\n             then\n-               --  What the heck is this??? this pragma allows only 1 arg\n-\n                if Arg_Count >= 2 then\n-                  Check_At_Most_N_Arguments (3);\n+                  Set_Imported (Def_Id);\n+                  Set_Is_Public (Def_Id);\n                   Process_Interface_Name (Def_Id, Arg2, Arg3);\n                end if;\n \n@@ -5499,230 +5477,25 @@ package body Sem_Prag is\n          -- CPP_Virtual --\n          -----------------\n \n-         --  pragma CPP_Virtual\n-         --      [Entity =>]       LOCAL_NAME\n-         --    [ [Vtable_Ptr =>]   LOCAL_NAME,\n-         --      [Position =>]     static_integer_EXPRESSION]);\n-\n          when Pragma_CPP_Virtual => CPP_Virtual : declare\n-            Arg      : Node_Id;\n-            Typ      : Entity_Id;\n-            Subp     : Entity_Id;\n-            VTP_Type : constant Entity_Id  := RTE (RE_Vtable_Ptr);\n-            DTC      : Entity_Id;\n-            V        : Uint;\n-\n          begin\n-            GNAT_Pragma;\n-            Check_Arg_Order ((Name_Entity, Name_Vtable_Ptr, Name_Position));\n-\n-            if Arg_Count = 3 then\n-               Check_Optional_Identifier (Arg2, Name_Vtable_Ptr);\n-\n-               --  We allow Entry_Count as well as Position for the third\n-               --  parameter for back compatibility with versions of GNAT\n-               --  before version 3.12. The documentation has always said\n-               --  Position, but the code up to 3.12 said Entry_Count.\n-\n-               if Chars (Arg3) /= Name_Entry_Count then\n-                  Check_Optional_Identifier (Arg3, Name_Position);\n-               end if;\n-\n-            else\n-               Check_Arg_Count (1);\n-            end if;\n-\n-            Check_Optional_Identifier (Arg1, Name_Entity);\n-            Check_Arg_Is_Local_Name (Arg1);\n-\n-            --  First argument must be a subprogram name\n-\n-            Arg := Expression (Arg1);\n-            Find_Program_Unit_Name (Arg);\n-\n-            if Etype (Arg) = Any_Type then\n-               return;\n-            else\n-               Subp := Entity (Arg);\n-            end if;\n-\n-            if not (Is_Subprogram (Subp)\n-                     and then Is_Dispatching_Operation (Subp))\n-            then\n-               Error_Pragma_Arg\n-                 (\"pragma% must reference a primitive operation\", Arg1);\n-            end if;\n-\n-            Typ := Find_Dispatching_Type (Subp);\n-\n-            --  If only one Argument defaults are :\n-            --    . DTC_Entity is the default Vtable pointer\n-            --    . DT_Position will be set at the freezing point\n-\n-            if Arg_Count = 1 then\n-               Set_DTC_Entity (Subp, First_Tag_Component (Typ));\n-               return;\n-            end if;\n-\n-            --  Second argument is a component name of type Vtable_Ptr\n-\n-            Arg := Expression (Arg2);\n-\n-            if Nkind (Arg) /= N_Identifier then\n-               Error_Msg_NE (\"must be a& component name\", Arg, Typ);\n-               raise Pragma_Exit;\n-            end if;\n-\n-            DTC := First_Component (Typ);\n-            while Present (DTC) and then Chars (DTC) /= Chars (Arg) loop\n-               Next_Component (DTC);\n-            end loop;\n-\n-            --  Case of tagged type with no user-defined vtable ptr\n-\n-            if No (DTC) then\n-               Error_Msg_NE (\"must be a& component name\", Arg, Typ);\n-               raise Pragma_Exit;\n-\n-            elsif Etype (DTC) /= VTP_Type then\n-               Wrong_Type (Arg, VTP_Type);\n-               return;\n-            end if;\n-\n-            --  Third argument is an integer (DT_Position)\n-\n-            Arg := Expression (Arg3);\n-            Analyze_And_Resolve (Arg, Any_Integer);\n-\n-            if not Is_Static_Expression (Arg) then\n-               Flag_Non_Static_Expr\n-                 (\"third argument of pragma CPP_Virtual must be static!\",\n-                  Arg3);\n-               raise Pragma_Exit;\n-\n-            else\n-               V := Expr_Value (Expression (Arg3));\n-\n-               if V <= 0 then\n-                  Error_Pragma_Arg\n-                    (\"third argument of pragma% must be positive\",\n-                     Arg3);\n-\n-               else\n-                  Set_DTC_Entity (Subp, DTC);\n-                  Set_DT_Position (Subp, V);\n-               end if;\n+            if Warn_On_Obsolescent_Feature then\n+               Error_Msg_N\n+                 (\"'G'N'A'T pragma cpp'_virtual is now obsolete and has \" &\n+                  \"no effect?\", N);\n             end if;\n          end CPP_Virtual;\n \n          ----------------\n          -- CPP_Vtable --\n          ----------------\n \n-         --  pragma CPP_Vtable (\n-         --    [Entity =>]       LOCAL_NAME\n-         --    [Vtable_Ptr =>]   LOCAL_NAME,\n-         --    [Entry_Count =>]  static_integer_EXPRESSION);\n-\n          when Pragma_CPP_Vtable => CPP_Vtable : declare\n-            Arg      : Node_Id;\n-            Typ      : Entity_Id;\n-            VTP_Type : constant Entity_Id  := RTE (RE_Vtable_Ptr);\n-            DTC      : Entity_Id;\n-            V        : Uint;\n-            Elmt     : Elmt_Id;\n-\n          begin\n-            GNAT_Pragma;\n-            Check_Arg_Order ((Name_Entity, Name_Vtable_Ptr, Name_Entry_Count));\n-            Check_Arg_Count (3);\n-            Check_Optional_Identifier (Arg1, Name_Entity);\n-            Check_Optional_Identifier (Arg2, Name_Vtable_Ptr);\n-            Check_Optional_Identifier (Arg3, Name_Entry_Count);\n-            Check_Arg_Is_Local_Name (Arg1);\n-\n-            --  First argument is a record type name\n-\n-            Arg := Expression (Arg1);\n-            Analyze (Arg);\n-\n-            if Etype (Arg) = Any_Type then\n-               return;\n-            else\n-               Typ := Entity (Arg);\n-            end if;\n-\n-            if not (Is_Tagged_Type (Typ) and then Is_CPP_Class (Typ)) then\n-               Error_Pragma_Arg (\"'C'P'P_Class tagged type expected\", Arg1);\n-            end if;\n-\n-            --  Second argument is a component name of type Vtable_Ptr\n-\n-            Arg := Expression (Arg2);\n-\n-            if Nkind (Arg) /= N_Identifier then\n-               Error_Msg_NE (\"must be a& component name\", Arg, Typ);\n-               raise Pragma_Exit;\n-            end if;\n-\n-            DTC := First_Component (Typ);\n-            while Present (DTC) and then Chars (DTC) /= Chars (Arg) loop\n-               Next_Component (DTC);\n-            end loop;\n-\n-            if No (DTC) then\n-               Error_Msg_NE (\"must be a& component name\", Arg, Typ);\n-               raise Pragma_Exit;\n-\n-            elsif Etype (DTC) /= VTP_Type then\n-               Wrong_Type (DTC, VTP_Type);\n-               return;\n-\n-            --  If it is the first pragma Vtable, This becomes the default tag\n-\n-            elsif (not Is_Tag (DTC))\n-              and then DT_Entry_Count (First_Tag_Component (Typ)) = No_Uint\n-            then\n-               Set_Is_Tag (First_Tag_Component (Typ), False);\n-               Set_Is_Tag (DTC, True);\n-               Set_DT_Entry_Count (DTC, No_Uint);\n-            end if;\n-\n-            --  Those pragmas must appear before any primitive operation\n-            --  definition (except inherited ones) otherwise the default\n-            --  may be wrong\n-\n-            Elmt := First_Elmt (Primitive_Operations (Typ));\n-            while Present (Elmt) loop\n-               if No (Alias (Node (Elmt))) then\n-                  Error_Msg_Sloc := Sloc (Node (Elmt));\n-                  Error_Pragma\n-                    (\"pragma% must appear before this primitive operation\");\n-               end if;\n-\n-               Next_Elmt (Elmt);\n-            end loop;\n-\n-            --  Third argument is an integer (DT_Entry_Count)\n-\n-            Arg := Expression (Arg3);\n-            Analyze_And_Resolve (Arg, Any_Integer);\n-\n-            if not Is_Static_Expression (Arg) then\n-               Flag_Non_Static_Expr\n-                 (\"entry count for pragma CPP_Vtable must be a static \" &\n-                  \"expression!\", Arg3);\n-               raise Pragma_Exit;\n-\n-            else\n-               V := Expr_Value (Expression (Arg3));\n-\n-               if V <= 0 then\n-                  Error_Pragma_Arg\n-                    (\"entry count for pragma% must be positive\", Arg3);\n-               else\n-                  Set_DT_Entry_Count (DTC, V);\n-               end if;\n+            if Warn_On_Obsolescent_Feature then\n+               Error_Msg_N\n+                 (\"'G'N'A'T pragma cpp'_vtable is now obsolete and has \" &\n+                  \"no effect?\", N);\n             end if;\n          end CPP_Vtable;\n \n@@ -6560,14 +6333,10 @@ package body Sem_Prag is\n \n             if Chars (Expression (Arg1)) = Name_On then\n                Extensions_Allowed := True;\n-               Ada_Version := Ada_Version_Type'Last;\n             else\n                Extensions_Allowed := False;\n-               Ada_Version := Ada_Version_Type'Min (Ada_Version, Ada_95);\n             end if;\n \n-            Ada_Version_Explicit := Ada_Version;\n-\n          --------------\n          -- External --\n          --------------\n@@ -7674,7 +7443,7 @@ package body Sem_Prag is\n             --  java.lang.Object.Typ and that all primitives of the type\n             --  should be declared abstract. ???\n \n-            if not Is_Tagged_Type (Typ) or else not Is_Abstract (Typ) then\n+            if not Is_Tagged_Type (Typ) or else not Is_Abstract_Type (Typ) then\n                Error_Pragma_Arg (\"pragma% requires an abstract \"\n                  & \"tagged type\", Arg1);\n \n@@ -8927,7 +8696,19 @@ package body Sem_Prag is\n                end if;\n \n                Set_Main_Priority\n-                 (Current_Sem_Unit, UI_To_Int (Expr_Value (Arg)));\n+                    (Current_Sem_Unit, UI_To_Int (Expr_Value (Arg)));\n+\n+               --  Load an arbitrary entity from System.Tasking to make sure\n+               --  this package is implicitly with'ed, since we need to have\n+               --  the tasking run-time active for the pragma Priority to have\n+               --  any effect.\n+\n+               declare\n+                  Discard : Entity_Id;\n+                  pragma Warnings (Off, Discard);\n+               begin\n+                  Discard := RTE (RE_Task_List);\n+               end;\n \n             --  Task or Protected, must be of type Integer\n \n@@ -10586,7 +10367,7 @@ package body Sem_Prag is\n                Get_Name_String (Chars (Cunitent));\n                Set_Casing (Mixed_Case);\n                Write_Str (Name_Buffer (1 .. Name_Len));\n-               Write_Str (\" is not implemented\");\n+               Write_Str (\" is not supported in this configuration\");\n                Write_Eol;\n                raise Unrecoverable_Error;\n             end if;\n@@ -10709,6 +10490,38 @@ package body Sem_Prag is\n             end if;\n          end Unreferenced;\n \n+         --------------------------\n+         -- Unreferenced_Objects --\n+         --------------------------\n+\n+         --  pragma Unreferenced_Objects (local_Name {, local_Name});\n+\n+         when Pragma_Unreferenced_Objects => Unreferenced_Objects : declare\n+            Arg_Node : Node_Id;\n+            Arg_Expr : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+\n+            Arg_Node := Arg1;\n+            while Present (Arg_Node) loop\n+               Check_No_Identifier (Arg_Node);\n+               Check_Arg_Is_Local_Name (Arg_Node);\n+               Arg_Expr := Get_Pragma_Arg (Arg_Node);\n+\n+               if not Is_Entity_Name (Arg_Expr)\n+                 or else not Is_Type (Entity (Arg_Expr))\n+               then\n+                  Error_Pragma_Arg\n+                    (\"argument for pragma% must be type or subtype\", Arg_Node);\n+               end if;\n+\n+               Set_Has_Pragma_Unreferenced_Objects (Entity (Arg_Expr));\n+               Next (Arg_Node);\n+            end loop;\n+         end Unreferenced_Objects;\n+\n          ------------------------------\n          -- Unreserve_All_Interrupts --\n          ------------------------------\n@@ -10862,20 +10675,48 @@ package body Sem_Prag is\n                      declare\n                         Lit : constant Node_Id   := Expr_Value_S (Argx);\n                         Str : constant String_Id := Strval (Lit);\n+                        Len : constant Nat       := String_Length (Str);\n                         C   : Char_Code;\n+                        J   : Nat;\n+                        OK  : Boolean;\n+                        Chr : Character;\n \n                      begin\n-                        for J in 1 .. String_Length (Str) loop\n+                        J := 1;\n+                        while J <= Len loop\n                            C := Get_String_Char (Str, J);\n+                           OK := In_Character_Range (C);\n \n-                           if In_Character_Range (C)\n-                             and then Set_Warning_Switch (Get_Character (C))\n-                           then\n-                              null;\n-                           else\n+                           if OK then\n+                              Chr := Get_Character (C);\n+\n+                              --  Dot case\n+\n+                              if J < Len and then Chr = '.' then\n+                                 J := J + 1;\n+                                 C := Get_String_Char (Str, J);\n+                                 Chr := Get_Character (C);\n+\n+                                 if not Set_Dot_Warning_Switch (Chr) then\n+                                    Error_Pragma_Arg\n+                                      (\"invalid warning switch character \" &\n+                                       '.' & Chr, Arg1);\n+                                 end if;\n+\n+                              --  Non-Dot case\n+\n+                              else\n+                                 OK := Set_Warning_Switch (Chr);\n+                              end if;\n+                           end if;\n+\n+                           if not OK then\n                               Error_Pragma_Arg\n-                                (\"invalid warning switch character\", Arg1);\n+                                (\"invalid warning switch character \" & Chr,\n+                                 Arg1);\n                            end if;\n+\n+                           J := J + 1;\n                         end loop;\n                      end;\n                   end if;\n@@ -10953,7 +10794,7 @@ package body Sem_Prag is\n                         if Is_Configuration_Pragma then\n                            if Chars (Argx) = Name_On then\n                               Error_Pragma\n-                                (\"pragma Warnings (Off, string) cannot be \" &\n+                                (\"pragma Warnings (On, string) cannot be \" &\n                                  \"used as configuration pragma\");\n \n                            else\n@@ -11178,6 +11019,7 @@ package body Sem_Prag is\n       Pragma_C_Pass_By_Copy                =>  0,\n       Pragma_Comment                       =>  0,\n       Pragma_Common_Object                 => -1,\n+      Pragma_Compile_Time_Error            => -1,\n       Pragma_Compile_Time_Warning          => -1,\n       Pragma_Complete_Representation       =>  0,\n       Pragma_Complex_Representation        =>  0,\n@@ -11302,6 +11144,7 @@ package body Sem_Prag is\n       Pragma_Unimplemented_Unit            => -1,\n       Pragma_Universal_Data                => -1,\n       Pragma_Unreferenced                  => -1,\n+      Pragma_Unreferenced_Objects          => -1,\n       Pragma_Unreserve_All_Interrupts      => -1,\n       Pragma_Unsuppress                    =>  0,\n       Pragma_Use_VADS_Size                 => -1,"}, {"sha": "af50d9cae4d09df0a783940a3a3da8e264e4b802", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -392,6 +392,7 @@ package body Sem_Warn is\n                      --  or if it is a parameter, to the corresponding spec.\n \n                      if Has_Pragma_Unreferenced (E1)\n+                       or else Has_Pragma_Unreferenced_Objects (Etype (E1))\n                        or else (Is_Formal (E1)\n                                   and then Present (Spec_Entity (E1))\n                                   and then\n@@ -1641,6 +1642,7 @@ package body Sem_Warn is\n                   then\n                      if Warn_On_Modified_Unread\n                        and then not Is_Imported (E)\n+                       and then not Is_Return_Object (E)\n \n                         --  Suppress message for aliased or renamed variables,\n                         --  since there may be other entities that read the\n@@ -1658,20 +1660,12 @@ package body Sem_Warn is\n                   --  Normal case of neither assigned nor read\n \n                   else\n-                     --  We suppress the message for limited controlled types,\n-                     --  to catch the common design pattern (known as RAII, or\n-                     --  Resource Acquisition Is Initialization) which uses\n-                     --  such types solely for their initialization and\n-                     --  finalization semantics.\n-\n-                     if Is_Controlled (Etype (E))\n-                       and then Is_Limited_Type (Etype (E))\n-                     then\n-                        null;\n+                     --  We suppress the message for types for which a valid\n+                     --  pragma Unreferenced_Objects has been given, otherwise\n+                     --  we go ahead and give the message.\n \n-                     --  Normal case where we want to give message\n+                     if not Has_Pragma_Unreferenced_Objects (Etype (E)) then\n \n-                     else\n                         --  Distinguish renamed case in message\n \n                         if Present (Renamed_Object (E))\n@@ -1740,6 +1734,26 @@ package body Sem_Warn is\n       end loop;\n    end Output_Unreferenced_Messages;\n \n+   ----------------------------\n+   -- Set_Dot_Warning_Switch --\n+   ----------------------------\n+\n+   function Set_Dot_Warning_Switch (C : Character) return Boolean is\n+   begin\n+      case C is\n+         when 'x' =>\n+            Warn_On_Non_Local_Exception         := True;\n+\n+         when 'X' =>\n+            Warn_On_Non_Local_Exception         := False;\n+\n+         when others =>\n+            return False;\n+      end case;\n+\n+      return True;\n+   end Set_Dot_Warning_Switch;\n+\n    ------------------------\n    -- Set_Warning_Switch --\n    ------------------------\n@@ -1761,6 +1775,7 @@ package body Sem_Warn is\n             Warn_On_Export_Import               := True;\n             Warn_On_Modified_Unread             := True;\n             Warn_On_No_Value_Assigned           := True;\n+            Warn_On_Non_Local_Exception         := True;\n             Warn_On_Obsolescent_Feature         := True;\n             Warn_On_Questionable_Missing_Parens := True;\n             Warn_On_Redundant_Constructs        := True;\n@@ -1784,8 +1799,9 @@ package body Sem_Warn is\n             Warn_On_Hiding                      := False;\n             Warn_On_Modified_Unread             := False;\n             Warn_On_No_Value_Assigned           := False;\n+            Warn_On_Non_Local_Exception         := False;\n             Warn_On_Obsolescent_Feature         := False;\n-            Warn_On_Questionable_Missing_Parens := True;\n+            Warn_On_Questionable_Missing_Parens := False;\n             Warn_On_Redundant_Constructs        := False;\n             Warn_On_Unchecked_Conversion        := False;\n             Warn_On_Unrecognized_Pragma         := False;\n@@ -2409,11 +2425,12 @@ package body Sem_Warn is\n    --  Start of processing for Warn_On_Useless_Assignment\n \n    begin\n-      --  Check if this is a case we want to warn on, a variable with\n-      --  the last assignment field set, with warnings enabled, and\n-      --  which is not imported or exported.\n+      --  Check if this is a case we want to warn on, a variable with the\n+      --  last assignment field set, with warnings enabled, and which is\n+      --  not imported or exported.\n \n       if Ekind (Ent) = E_Variable\n+        and then not Is_Return_Object (Ent)\n         and then Present (Last_Assignment (Ent))\n         and then not Warnings_Off (Ent)\n         and then not Has_Pragma_Unreferenced (Ent)"}, {"sha": "efc747cf9c3a089ab5cd0a704a3214d0d05400ac", "filename": "gcc/ada/sem_warn.ads", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsem_warn.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsem_warn.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.ads?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -37,9 +37,16 @@ package Sem_Warn is\n    --------------------\n \n    function Set_Warning_Switch (C : Character) return Boolean;\n-   --  This function sets the warning switch or switches corresponding to\n-   --  the given character. It is used for processing a -gnatw switch on the\n-   --  command line, or a string literal in pragma Warnings.\n+   --  This function sets the warning switch or switches corresponding to the\n+   --  given character. It is used to process a -gnatw switch on the command\n+   --  line, or a character in a string literal in pragma Warnings. Returns\n+   --  True for valid warning character C, False for invalid character.\n+\n+   function Set_Dot_Warning_Switch (C : Character) return Boolean;\n+   --  This function sets the warning switch or switches corresponding to the\n+   --  given character preceded by a dot. Used to process a -gnatw. switch on\n+   --  the command line or .C in a string literal in pragma Warnings. Returns\n+   --  True for valid warning character C, False for invalid character.\n \n    ------------------------------------------\n    -- Routines to Handle Unused References --"}, {"sha": "998172548df308438fe6b52f2177c8debe7d6585", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -139,7 +139,7 @@ package body Snames is\n      \"partition#\" &\n      \"partition_interface#\" &\n      \"ras#\" &\n-     \"call#\" &\n+     \"_call#\" &\n      \"rci_name#\" &\n      \"receiver#\" &\n      \"result#\" &\n@@ -178,6 +178,7 @@ package body Snames is\n      \"ada_2005#\" &\n      \"assertion_policy#\" &\n      \"c_pass_by_copy#\" &\n+     \"compile_time_error#\" &\n      \"compile_time_warning#\" &\n      \"component_alignment#\" &\n      \"convention_identifier#\" &\n@@ -317,6 +318,7 @@ package body Snames is\n      \"unchecked_union#\" &\n      \"unimplemented_unit#\" &\n      \"unreferenced#\" &\n+     \"unreferenced_objects#\" &\n      \"unreserve_all_interrupts#\" &\n      \"volatile#\" &\n      \"volatile_components#\" &\n@@ -333,6 +335,7 @@ package body Snames is\n      \"asm#\" &\n      \"assembly#\" &\n      \"default#\" &\n+     \"c_plus_plus#\" &\n      \"dll#\" &\n      \"win32#\" &\n      \"as_is#\" &\n@@ -664,13 +667,16 @@ package body Snames is\n      \"ada_roots#\" &\n      \"archive_builder#\" &\n      \"archive_indexer#\" &\n+     \"archive_suffix#\" &\n      \"binder#\" &\n      \"binder_driver#\" &\n      \"body_suffix#\" &\n      \"builder#\" &\n+     \"builder_switches#\" &\n      \"compiler#\" &\n      \"compiler_driver#\" &\n      \"compiler_kind#\" &\n+     \"compiler_minimum_options#\" &\n      \"compiler_pic_option#\" &\n      \"compute_dependency#\" &\n      \"config_body_file_name#\" &\n@@ -695,6 +701,7 @@ package body Snames is\n      \"finder#\" &\n      \"global_compiler_switches#\" &\n      \"global_configuration_pragmas#\" &\n+     \"global_config_file#\" &\n      \"gnatls#\" &\n      \"gnatstub#\" &\n      \"implementation#\" &\n@@ -707,32 +714,47 @@ package body Snames is\n      \"language_processing#\" &\n      \"languages#\" &\n      \"library_ali_dir#\" &\n-     \"library_dir#\" &\n      \"library_auto_init#\" &\n+     \"library_auto_init_supported#\" &\n+     \"library_builder#\" &\n+     \"library_dir#\" &\n      \"library_gcc#\" &\n      \"library_interface#\" &\n      \"library_kind#\" &\n      \"library_name#\" &\n+     \"library_major_minor_id_supported#\" &\n      \"library_options#\" &\n      \"library_reference_symbol_file#\" &\n      \"library_src_dir#\" &\n+     \"library_support#\" &\n      \"library_symbol_file#\" &\n      \"library_symbol_policy#\" &\n      \"library_version#\" &\n+     \"library_version_options#\" &\n      \"linker#\" &\n      \"linker_executable_option#\" &\n      \"linker_lib_dir_option#\" &\n      \"linker_lib_name_option#\" &\n+     \"local_config_file#\" &\n      \"local_configuration_pragmas#\" &\n      \"locally_removed_files#\" &\n      \"mapping_file_switches#\" &\n+     \"mapping_spec_suffix#\" &\n+     \"mapping_body_suffix#\" &\n      \"metrics#\" &\n+     \"minimum_binder_options#\" &\n      \"naming#\" &\n+     \"objects_path#\" &\n+     \"objects_path_file#\" &\n      \"object_dir#\" &\n      \"pretty_printer#\" &\n      \"project#\" &\n      \"roots#\" &\n+     \"run_path_option#\" &\n      \"runtime_project#\" &\n+     \"shared_library_minimum_options#\" &\n+     \"shared_library_prefix#\" &\n+     \"shared_library_suffix#\" &\n      \"separate_suffix#\" &\n      \"source_dirs#\" &\n      \"source_files#\" &\n@@ -742,7 +764,10 @@ package body Snames is\n      \"specification#\" &\n      \"specification_exceptions#\" &\n      \"specification_suffix#\" &\n+     \"stack#\" &\n      \"switches#\" &\n+     \"symbolic_link_supported#\" &\n+     \"toolchain_version#\" &\n      \"unaligned_valid#\" &\n      \"interface#\" &\n      \"overriding#\" &\n@@ -976,14 +1001,16 @@ package body Snames is\n \n       Convention_Identifiers.Init;\n \n-      Convention_Identifiers.Append ((Name_Asm,      Convention_Assembler));\n-      Convention_Identifiers.Append ((Name_Assembly, Convention_Assembler));\n+      Convention_Identifiers.Append ((Name_Asm,         Convention_Assembler));\n+      Convention_Identifiers.Append ((Name_Assembly,    Convention_Assembler));\n+\n+      Convention_Identifiers.Append ((Name_Default,     Convention_C));\n+      Convention_Identifiers.Append ((Name_External,    Convention_C));\n \n-      Convention_Identifiers.Append ((Name_Default,  Convention_C));\n-      Convention_Identifiers.Append ((Name_External, Convention_C));\n+      Convention_Identifiers.Append ((Name_C_Plus_Plus, Convention_CPP));\n \n-      Convention_Identifiers.Append ((Name_DLL,      Convention_Stdcall));\n-      Convention_Identifiers.Append ((Name_Win32,    Convention_Stdcall));\n+      Convention_Identifiers.Append ((Name_DLL,         Convention_Stdcall));\n+      Convention_Identifiers.Append ((Name_Win32,       Convention_Stdcall));\n    end Initialize;\n \n    -----------------------"}, {"sha": "3ff606e759fef22e46d7cb356f474fd18337f349", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 629, "deletions": 599, "changes": 1228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -267,7 +267,7 @@ package Snames is\n    Name_Partition                      : constant Name_Id := N + 078;\n    Name_Partition_Interface            : constant Name_Id := N + 079;\n    Name_Ras                            : constant Name_Id := N + 080;\n-   Name_Call                           : constant Name_Id := N + 081;\n+   Name_uCall                          : constant Name_Id := N + 081;\n    Name_RCI_Name                       : constant Name_Id := N + 082;\n    Name_Receiver                       : constant Name_Id := N + 083;\n    Name_Result                         : constant Name_Id := N + 084;\n@@ -339,147 +339,148 @@ package Snames is\n    Name_Ada_2005                       : constant Name_Id := N + 117; -- GNAT\n    Name_Assertion_Policy               : constant Name_Id := N + 118; -- Ada 05\n    Name_C_Pass_By_Copy                 : constant Name_Id := N + 119; -- GNAT\n-   Name_Compile_Time_Warning           : constant Name_Id := N + 120; -- GNAT\n-   Name_Component_Alignment            : constant Name_Id := N + 121; -- GNAT\n-   Name_Convention_Identifier          : constant Name_Id := N + 122; -- GNAT\n-   Name_Debug_Policy                   : constant Name_Id := N + 123; -- GNAT\n-   Name_Detect_Blocking                : constant Name_Id := N + 124; -- Ada 05\n-   Name_Discard_Names                  : constant Name_Id := N + 125;\n-   Name_Elaboration_Checks             : constant Name_Id := N + 126; -- GNAT\n-   Name_Eliminate                      : constant Name_Id := N + 127; -- GNAT\n-   Name_Explicit_Overriding            : constant Name_Id := N + 128; -- Ada 05\n-   Name_Extend_System                  : constant Name_Id := N + 129; -- GNAT\n-   Name_Extensions_Allowed             : constant Name_Id := N + 130; -- GNAT\n-   Name_External_Name_Casing           : constant Name_Id := N + 131; -- GNAT\n-   Name_Float_Representation           : constant Name_Id := N + 132; -- GNAT\n-   Name_Initialize_Scalars             : constant Name_Id := N + 133; -- GNAT\n-   Name_Interrupt_State                : constant Name_Id := N + 134; -- GNAT\n-   Name_License                        : constant Name_Id := N + 135; -- GNAT\n-   Name_Locking_Policy                 : constant Name_Id := N + 136;\n-   Name_Long_Float                     : constant Name_Id := N + 137; -- VMS\n-   Name_No_Run_Time                    : constant Name_Id := N + 138; -- GNAT\n-   Name_No_Strict_Aliasing             : constant Name_Id := N + 139; -- GNAT\n-   Name_Normalize_Scalars              : constant Name_Id := N + 140;\n-   Name_Polling                        : constant Name_Id := N + 141; -- GNAT\n-   Name_Persistent_BSS                 : constant Name_Id := N + 142; -- GNAT\n-   Name_Priority_Specific_Dispatching  : constant Name_Id := N + 143; -- Ada 05\n-   Name_Profile                        : constant Name_Id := N + 144; -- Ada 05\n-   Name_Profile_Warnings               : constant Name_Id := N + 145; -- GNAT\n-   Name_Propagate_Exceptions           : constant Name_Id := N + 146; -- GNAT\n-   Name_Queuing_Policy                 : constant Name_Id := N + 147;\n-   Name_Ravenscar                      : constant Name_Id := N + 148; -- Ada 05\n-   Name_Restricted_Run_Time            : constant Name_Id := N + 149; -- GNAT\n-   Name_Restrictions                   : constant Name_Id := N + 150;\n-   Name_Restriction_Warnings           : constant Name_Id := N + 151; -- GNAT\n-   Name_Reviewable                     : constant Name_Id := N + 152;\n-   Name_Source_File_Name               : constant Name_Id := N + 153; -- GNAT\n-   Name_Source_File_Name_Project       : constant Name_Id := N + 154; -- GNAT\n-   Name_Style_Checks                   : constant Name_Id := N + 155; -- GNAT\n-   Name_Suppress                       : constant Name_Id := N + 156;\n-   Name_Suppress_Exception_Locations   : constant Name_Id := N + 157; -- GNAT\n-   Name_Task_Dispatching_Policy        : constant Name_Id := N + 158;\n-   Name_Universal_Data                 : constant Name_Id := N + 159; -- AAMP\n-   Name_Unsuppress                     : constant Name_Id := N + 160; -- GNAT\n-   Name_Use_VADS_Size                  : constant Name_Id := N + 161; -- GNAT\n-   Name_Validity_Checks                : constant Name_Id := N + 162; -- GNAT\n-   Name_Warnings                       : constant Name_Id := N + 163; -- GNAT\n-   Name_Wide_Character_Encoding        : constant Name_Id := N + 164; -- GNAT\n-   Last_Configuration_Pragma_Name      : constant Name_Id := N + 164;\n+   Name_Compile_Time_Error             : constant Name_Id := N + 120; -- GNAT\n+   Name_Compile_Time_Warning           : constant Name_Id := N + 121; -- GNAT\n+   Name_Component_Alignment            : constant Name_Id := N + 122; -- GNAT\n+   Name_Convention_Identifier          : constant Name_Id := N + 123; -- GNAT\n+   Name_Debug_Policy                   : constant Name_Id := N + 124; -- GNAT\n+   Name_Detect_Blocking                : constant Name_Id := N + 125; -- Ada 05\n+   Name_Discard_Names                  : constant Name_Id := N + 126;\n+   Name_Elaboration_Checks             : constant Name_Id := N + 127; -- GNAT\n+   Name_Eliminate                      : constant Name_Id := N + 128; -- GNAT\n+   Name_Explicit_Overriding            : constant Name_Id := N + 129; -- Ada 05\n+   Name_Extend_System                  : constant Name_Id := N + 130; -- GNAT\n+   Name_Extensions_Allowed             : constant Name_Id := N + 131; -- GNAT\n+   Name_External_Name_Casing           : constant Name_Id := N + 132; -- GNAT\n+   Name_Float_Representation           : constant Name_Id := N + 133; -- GNAT\n+   Name_Initialize_Scalars             : constant Name_Id := N + 134; -- GNAT\n+   Name_Interrupt_State                : constant Name_Id := N + 135; -- GNAT\n+   Name_License                        : constant Name_Id := N + 136; -- GNAT\n+   Name_Locking_Policy                 : constant Name_Id := N + 137;\n+   Name_Long_Float                     : constant Name_Id := N + 138; -- VMS\n+   Name_No_Run_Time                    : constant Name_Id := N + 139; -- GNAT\n+   Name_No_Strict_Aliasing             : constant Name_Id := N + 140; -- GNAT\n+   Name_Normalize_Scalars              : constant Name_Id := N + 141;\n+   Name_Polling                        : constant Name_Id := N + 142; -- GNAT\n+   Name_Persistent_BSS                 : constant Name_Id := N + 143; -- GNAT\n+   Name_Priority_Specific_Dispatching  : constant Name_Id := N + 144; -- Ada 05\n+   Name_Profile                        : constant Name_Id := N + 145; -- Ada 05\n+   Name_Profile_Warnings               : constant Name_Id := N + 146; -- GNAT\n+   Name_Propagate_Exceptions           : constant Name_Id := N + 147; -- GNAT\n+   Name_Queuing_Policy                 : constant Name_Id := N + 148;\n+   Name_Ravenscar                      : constant Name_Id := N + 149; -- Ada 05\n+   Name_Restricted_Run_Time            : constant Name_Id := N + 150; -- GNAT\n+   Name_Restrictions                   : constant Name_Id := N + 151;\n+   Name_Restriction_Warnings           : constant Name_Id := N + 152; -- GNAT\n+   Name_Reviewable                     : constant Name_Id := N + 153;\n+   Name_Source_File_Name               : constant Name_Id := N + 154; -- GNAT\n+   Name_Source_File_Name_Project       : constant Name_Id := N + 155; -- GNAT\n+   Name_Style_Checks                   : constant Name_Id := N + 156; -- GNAT\n+   Name_Suppress                       : constant Name_Id := N + 157;\n+   Name_Suppress_Exception_Locations   : constant Name_Id := N + 158; -- GNAT\n+   Name_Task_Dispatching_Policy        : constant Name_Id := N + 159;\n+   Name_Universal_Data                 : constant Name_Id := N + 160; -- AAMP\n+   Name_Unsuppress                     : constant Name_Id := N + 161; -- GNAT\n+   Name_Use_VADS_Size                  : constant Name_Id := N + 162; -- GNAT\n+   Name_Validity_Checks                : constant Name_Id := N + 163; -- GNAT\n+   Name_Warnings                       : constant Name_Id := N + 164; -- GNAT\n+   Name_Wide_Character_Encoding        : constant Name_Id := N + 165; -- GNAT\n+   Last_Configuration_Pragma_Name      : constant Name_Id := N + 165;\n \n    --  Remaining pragma names\n \n-   Name_Abort_Defer                    : constant Name_Id := N + 165; -- GNAT\n-   Name_All_Calls_Remote               : constant Name_Id := N + 166;\n-   Name_Annotate                       : constant Name_Id := N + 167; -- GNAT\n+   Name_Abort_Defer                    : constant Name_Id := N + 166; -- GNAT\n+   Name_All_Calls_Remote               : constant Name_Id := N + 167;\n+   Name_Annotate                       : constant Name_Id := N + 168; -- GNAT\n \n    --  Note: AST_Entry is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Pragma_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Name_AST_Entry.\n    --  AST_Entry is a VMS specific pragma.\n \n-   Name_Assert                         : constant Name_Id := N + 168; -- Ada 05\n-   Name_Asynchronous                   : constant Name_Id := N + 169;\n-   Name_Atomic                         : constant Name_Id := N + 170;\n-   Name_Atomic_Components              : constant Name_Id := N + 171;\n-   Name_Attach_Handler                 : constant Name_Id := N + 172;\n-   Name_Comment                        : constant Name_Id := N + 173; -- GNAT\n-   Name_Common_Object                  : constant Name_Id := N + 174; -- GNAT\n-   Name_Complete_Representation        : constant Name_Id := N + 175; -- GNAT\n-   Name_Complex_Representation         : constant Name_Id := N + 176; -- GNAT\n-   Name_Controlled                     : constant Name_Id := N + 177;\n-   Name_Convention                     : constant Name_Id := N + 178;\n-   Name_CPP_Class                      : constant Name_Id := N + 179; -- GNAT\n-   Name_CPP_Constructor                : constant Name_Id := N + 180; -- GNAT\n-   Name_CPP_Virtual                    : constant Name_Id := N + 181; -- GNAT\n-   Name_CPP_Vtable                     : constant Name_Id := N + 182; -- GNAT\n-   Name_Debug                          : constant Name_Id := N + 183; -- GNAT\n-   Name_Elaborate                      : constant Name_Id := N + 184; -- Ada 83\n-   Name_Elaborate_All                  : constant Name_Id := N + 185;\n-   Name_Elaborate_Body                 : constant Name_Id := N + 186;\n-   Name_Export                         : constant Name_Id := N + 187;\n-   Name_Export_Exception               : constant Name_Id := N + 188; -- VMS\n-   Name_Export_Function                : constant Name_Id := N + 189; -- GNAT\n-   Name_Export_Object                  : constant Name_Id := N + 190; -- GNAT\n-   Name_Export_Procedure               : constant Name_Id := N + 191; -- GNAT\n-   Name_Export_Value                   : constant Name_Id := N + 192; -- GNAT\n-   Name_Export_Valued_Procedure        : constant Name_Id := N + 193; -- GNAT\n-   Name_External                       : constant Name_Id := N + 194; -- GNAT\n-   Name_Finalize_Storage_Only          : constant Name_Id := N + 195; -- GNAT\n-   Name_Ident                          : constant Name_Id := N + 196; -- VMS\n-   Name_Import                         : constant Name_Id := N + 197;\n-   Name_Import_Exception               : constant Name_Id := N + 198; -- VMS\n-   Name_Import_Function                : constant Name_Id := N + 199; -- GNAT\n-   Name_Import_Object                  : constant Name_Id := N + 200; -- GNAT\n-   Name_Import_Procedure               : constant Name_Id := N + 201; -- GNAT\n-   Name_Import_Valued_Procedure        : constant Name_Id := N + 202; -- GNAT\n-   Name_Inline                         : constant Name_Id := N + 203;\n-   Name_Inline_Always                  : constant Name_Id := N + 204; -- GNAT\n-   Name_Inline_Generic                 : constant Name_Id := N + 205; -- GNAT\n-   Name_Inspection_Point               : constant Name_Id := N + 206;\n-   Name_Interface_Name                 : constant Name_Id := N + 207; -- GNAT\n-   Name_Interrupt_Handler              : constant Name_Id := N + 208;\n-   Name_Interrupt_Priority             : constant Name_Id := N + 209;\n-   Name_Java_Constructor               : constant Name_Id := N + 210; -- GNAT\n-   Name_Java_Interface                 : constant Name_Id := N + 211; -- GNAT\n-   Name_Keep_Names                     : constant Name_Id := N + 212; -- GNAT\n-   Name_Link_With                      : constant Name_Id := N + 213; -- GNAT\n-   Name_Linker_Alias                   : constant Name_Id := N + 214; -- GNAT\n-   Name_Linker_Constructor             : constant Name_Id := N + 215; -- GNAT\n-   Name_Linker_Destructor              : constant Name_Id := N + 216; -- GNAT\n-   Name_Linker_Options                 : constant Name_Id := N + 217;\n-   Name_Linker_Section                 : constant Name_Id := N + 218; -- GNAT\n-   Name_List                           : constant Name_Id := N + 219;\n-   Name_Machine_Attribute              : constant Name_Id := N + 220; -- GNAT\n-   Name_Main                           : constant Name_Id := N + 221; -- GNAT\n-   Name_Main_Storage                   : constant Name_Id := N + 222; -- GNAT\n-   Name_Memory_Size                    : constant Name_Id := N + 223; -- Ada 83\n-   Name_No_Return                      : constant Name_Id := N + 224; -- GNAT\n-   Name_Obsolescent                    : constant Name_Id := N + 225; -- GNAT\n-   Name_Optimize                       : constant Name_Id := N + 226;\n-   Name_Optional_Overriding            : constant Name_Id := N + 227; -- Ada 05\n-   Name_Pack                           : constant Name_Id := N + 228;\n-   Name_Page                           : constant Name_Id := N + 229;\n-   Name_Passive                        : constant Name_Id := N + 230; -- GNAT\n-   Name_Preelaborable_Initialization   : constant Name_Id := N + 231; -- Ada 05\n-   Name_Preelaborate                   : constant Name_Id := N + 232;\n-   Name_Preelaborate_05                : constant Name_Id := N + 233; -- GNAT\n+   Name_Assert                         : constant Name_Id := N + 169; -- Ada 05\n+   Name_Asynchronous                   : constant Name_Id := N + 170;\n+   Name_Atomic                         : constant Name_Id := N + 171;\n+   Name_Atomic_Components              : constant Name_Id := N + 172;\n+   Name_Attach_Handler                 : constant Name_Id := N + 173;\n+   Name_Comment                        : constant Name_Id := N + 174; -- GNAT\n+   Name_Common_Object                  : constant Name_Id := N + 175; -- GNAT\n+   Name_Complete_Representation        : constant Name_Id := N + 176; -- GNAT\n+   Name_Complex_Representation         : constant Name_Id := N + 177; -- GNAT\n+   Name_Controlled                     : constant Name_Id := N + 178;\n+   Name_Convention                     : constant Name_Id := N + 179;\n+   Name_CPP_Class                      : constant Name_Id := N + 180; -- GNAT\n+   Name_CPP_Constructor                : constant Name_Id := N + 181; -- GNAT\n+   Name_CPP_Virtual                    : constant Name_Id := N + 182; -- GNAT\n+   Name_CPP_Vtable                     : constant Name_Id := N + 183; -- GNAT\n+   Name_Debug                          : constant Name_Id := N + 184; -- GNAT\n+   Name_Elaborate                      : constant Name_Id := N + 185; -- Ada 83\n+   Name_Elaborate_All                  : constant Name_Id := N + 186;\n+   Name_Elaborate_Body                 : constant Name_Id := N + 187;\n+   Name_Export                         : constant Name_Id := N + 188;\n+   Name_Export_Exception               : constant Name_Id := N + 189; -- VMS\n+   Name_Export_Function                : constant Name_Id := N + 190; -- GNAT\n+   Name_Export_Object                  : constant Name_Id := N + 191; -- GNAT\n+   Name_Export_Procedure               : constant Name_Id := N + 192; -- GNAT\n+   Name_Export_Value                   : constant Name_Id := N + 193; -- GNAT\n+   Name_Export_Valued_Procedure        : constant Name_Id := N + 194; -- GNAT\n+   Name_External                       : constant Name_Id := N + 195; -- GNAT\n+   Name_Finalize_Storage_Only          : constant Name_Id := N + 196; -- GNAT\n+   Name_Ident                          : constant Name_Id := N + 197; -- VMS\n+   Name_Import                         : constant Name_Id := N + 198;\n+   Name_Import_Exception               : constant Name_Id := N + 199; -- VMS\n+   Name_Import_Function                : constant Name_Id := N + 200; -- GNAT\n+   Name_Import_Object                  : constant Name_Id := N + 201; -- GNAT\n+   Name_Import_Procedure               : constant Name_Id := N + 202; -- GNAT\n+   Name_Import_Valued_Procedure        : constant Name_Id := N + 203; -- GNAT\n+   Name_Inline                         : constant Name_Id := N + 204;\n+   Name_Inline_Always                  : constant Name_Id := N + 205; -- GNAT\n+   Name_Inline_Generic                 : constant Name_Id := N + 206; -- GNAT\n+   Name_Inspection_Point               : constant Name_Id := N + 207;\n+   Name_Interface_Name                 : constant Name_Id := N + 208; -- GNAT\n+   Name_Interrupt_Handler              : constant Name_Id := N + 209;\n+   Name_Interrupt_Priority             : constant Name_Id := N + 210;\n+   Name_Java_Constructor               : constant Name_Id := N + 211; -- GNAT\n+   Name_Java_Interface                 : constant Name_Id := N + 212; -- GNAT\n+   Name_Keep_Names                     : constant Name_Id := N + 213; -- GNAT\n+   Name_Link_With                      : constant Name_Id := N + 214; -- GNAT\n+   Name_Linker_Alias                   : constant Name_Id := N + 215; -- GNAT\n+   Name_Linker_Constructor             : constant Name_Id := N + 216; -- GNAT\n+   Name_Linker_Destructor              : constant Name_Id := N + 217; -- GNAT\n+   Name_Linker_Options                 : constant Name_Id := N + 218;\n+   Name_Linker_Section                 : constant Name_Id := N + 219; -- GNAT\n+   Name_List                           : constant Name_Id := N + 220;\n+   Name_Machine_Attribute              : constant Name_Id := N + 221; -- GNAT\n+   Name_Main                           : constant Name_Id := N + 222; -- GNAT\n+   Name_Main_Storage                   : constant Name_Id := N + 223; -- GNAT\n+   Name_Memory_Size                    : constant Name_Id := N + 224; -- Ada 83\n+   Name_No_Return                      : constant Name_Id := N + 225; -- GNAT\n+   Name_Obsolescent                    : constant Name_Id := N + 226; -- GNAT\n+   Name_Optimize                       : constant Name_Id := N + 227;\n+   Name_Optional_Overriding            : constant Name_Id := N + 228; -- Ada 05\n+   Name_Pack                           : constant Name_Id := N + 229;\n+   Name_Page                           : constant Name_Id := N + 230;\n+   Name_Passive                        : constant Name_Id := N + 231; -- GNAT\n+   Name_Preelaborable_Initialization   : constant Name_Id := N + 232; -- Ada 05\n+   Name_Preelaborate                   : constant Name_Id := N + 233;\n+   Name_Preelaborate_05                : constant Name_Id := N + 234; -- GNAT\n \n    --  Note: Priority is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n    --  definition of the type Pragma_Id, and the functions Get_Pragma_Id\n    --  and Check_Pragma_Id correctly recognize and process Priority.\n    --  Priority is a standard Ada 95 pragma.\n \n-   Name_Psect_Object                   : constant Name_Id := N + 234; -- VMS\n-   Name_Pure                           : constant Name_Id := N + 235;\n-   Name_Pure_05                        : constant Name_Id := N + 236; -- GNAT\n-   Name_Pure_Function                  : constant Name_Id := N + 237; -- GNAT\n-   Name_Remote_Call_Interface          : constant Name_Id := N + 238;\n-   Name_Remote_Types                   : constant Name_Id := N + 239;\n-   Name_Share_Generic                  : constant Name_Id := N + 240; -- GNAT\n-   Name_Shared                         : constant Name_Id := N + 241; -- Ada 83\n-   Name_Shared_Passive                 : constant Name_Id := N + 242;\n+   Name_Psect_Object                   : constant Name_Id := N + 235; -- VMS\n+   Name_Pure                           : constant Name_Id := N + 236;\n+   Name_Pure_05                        : constant Name_Id := N + 237; -- GNAT\n+   Name_Pure_Function                  : constant Name_Id := N + 238; -- GNAT\n+   Name_Remote_Call_Interface          : constant Name_Id := N + 239;\n+   Name_Remote_Types                   : constant Name_Id := N + 240;\n+   Name_Share_Generic                  : constant Name_Id := N + 241; -- GNAT\n+   Name_Shared                         : constant Name_Id := N + 242; -- Ada 83\n+   Name_Shared_Passive                 : constant Name_Id := N + 243;\n \n    --  Note: Storage_Size is not in this list because its name matches the\n    --  name of the corresponding attribute. However, it is included in the\n@@ -489,27 +490,28 @@ package Snames is\n    --  Note: Storage_Unit is also omitted from the list because of a clash\n    --  with an attribute name, and is treated similarly.\n \n-   Name_Source_Reference               : constant Name_Id := N + 243; -- GNAT\n-   Name_Stream_Convert                 : constant Name_Id := N + 244; -- GNAT\n-   Name_Subtitle                       : constant Name_Id := N + 245; -- GNAT\n-   Name_Suppress_All                   : constant Name_Id := N + 246; -- GNAT\n-   Name_Suppress_Debug_Info            : constant Name_Id := N + 247; -- GNAT\n-   Name_Suppress_Initialization        : constant Name_Id := N + 248; -- GNAT\n-   Name_System_Name                    : constant Name_Id := N + 249; -- Ada 83\n-   Name_Task_Info                      : constant Name_Id := N + 250; -- GNAT\n-   Name_Task_Name                      : constant Name_Id := N + 251; -- GNAT\n-   Name_Task_Storage                   : constant Name_Id := N + 252; -- VMS\n-   Name_Thread_Body                    : constant Name_Id := N + 253; -- GNAT\n-   Name_Time_Slice                     : constant Name_Id := N + 254; -- GNAT\n-   Name_Title                          : constant Name_Id := N + 255; -- GNAT\n-   Name_Unchecked_Union                : constant Name_Id := N + 256; -- GNAT\n-   Name_Unimplemented_Unit             : constant Name_Id := N + 257; -- GNAT\n-   Name_Unreferenced                   : constant Name_Id := N + 258; -- GNAT\n-   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 259; -- GNAT\n-   Name_Volatile                       : constant Name_Id := N + 260;\n-   Name_Volatile_Components            : constant Name_Id := N + 261;\n-   Name_Weak_External                  : constant Name_Id := N + 262; -- GNAT\n-   Last_Pragma_Name                    : constant Name_Id := N + 262;\n+   Name_Source_Reference               : constant Name_Id := N + 244; -- GNAT\n+   Name_Stream_Convert                 : constant Name_Id := N + 245; -- GNAT\n+   Name_Subtitle                       : constant Name_Id := N + 246; -- GNAT\n+   Name_Suppress_All                   : constant Name_Id := N + 247; -- GNAT\n+   Name_Suppress_Debug_Info            : constant Name_Id := N + 248; -- GNAT\n+   Name_Suppress_Initialization        : constant Name_Id := N + 249; -- GNAT\n+   Name_System_Name                    : constant Name_Id := N + 250; -- Ada 83\n+   Name_Task_Info                      : constant Name_Id := N + 251; -- GNAT\n+   Name_Task_Name                      : constant Name_Id := N + 252; -- GNAT\n+   Name_Task_Storage                   : constant Name_Id := N + 253; -- VMS\n+   Name_Thread_Body                    : constant Name_Id := N + 254; -- GNAT\n+   Name_Time_Slice                     : constant Name_Id := N + 255; -- GNAT\n+   Name_Title                          : constant Name_Id := N + 256; -- GNAT\n+   Name_Unchecked_Union                : constant Name_Id := N + 257; -- GNAT\n+   Name_Unimplemented_Unit             : constant Name_Id := N + 258; -- GNAT\n+   Name_Unreferenced                   : constant Name_Id := N + 259; -- GNAT\n+   Name_Unreferenced_Objects           : constant Name_Id := N + 260; -- GNAT\n+   Name_Unreserve_All_Interrupts       : constant Name_Id := N + 261; -- GNAT\n+   Name_Volatile                       : constant Name_Id := N + 262;\n+   Name_Volatile_Components            : constant Name_Id := N + 263;\n+   Name_Weak_External                  : constant Name_Id := N + 264; -- GNAT\n+   Last_Pragma_Name                    : constant Name_Id := N + 264;\n \n    --  Language convention names for pragma Convention/Export/Import/Interface\n    --  Note that Name_C is not included in this list, since it was already\n@@ -520,114 +522,118 @@ package Snames is\n    --  Entry and Protected, this is because these conventions cannot be\n    --  specified by a pragma.\n \n-   First_Convention_Name               : constant Name_Id := N + 263;\n-   Name_Ada                            : constant Name_Id := N + 263;\n-   Name_Assembler                      : constant Name_Id := N + 264;\n-   Name_COBOL                          : constant Name_Id := N + 265;\n-   Name_CPP                            : constant Name_Id := N + 266;\n-   Name_Fortran                        : constant Name_Id := N + 267;\n-   Name_Intrinsic                      : constant Name_Id := N + 268;\n-   Name_Java                           : constant Name_Id := N + 269;\n-   Name_Stdcall                        : constant Name_Id := N + 270;\n-   Name_Stubbed                        : constant Name_Id := N + 271;\n-   Last_Convention_Name                : constant Name_Id := N + 271;\n+   First_Convention_Name               : constant Name_Id := N + 265;\n+   Name_Ada                            : constant Name_Id := N + 265;\n+   Name_Assembler                      : constant Name_Id := N + 266;\n+   Name_COBOL                          : constant Name_Id := N + 267;\n+   Name_CPP                            : constant Name_Id := N + 268;\n+   Name_Fortran                        : constant Name_Id := N + 269;\n+   Name_Intrinsic                      : constant Name_Id := N + 270;\n+   Name_Java                           : constant Name_Id := N + 271;\n+   Name_Stdcall                        : constant Name_Id := N + 272;\n+   Name_Stubbed                        : constant Name_Id := N + 273;\n+   Last_Convention_Name                : constant Name_Id := N + 273;\n \n    --  The following names are preset as synonyms for Assembler\n \n-   Name_Asm                            : constant Name_Id := N + 272;\n-   Name_Assembly                       : constant Name_Id := N + 273;\n+   Name_Asm                            : constant Name_Id := N + 274;\n+   Name_Assembly                       : constant Name_Id := N + 275;\n \n    --  The following names are preset as synonyms for C\n \n-   Name_Default                        : constant Name_Id := N + 274;\n+   Name_Default                        : constant Name_Id := N + 276;\n    --  Name_Exernal (previously defined as pragma)\n \n+   --  The following names are preset as synonyms for CPP\n+\n+   Name_C_Plus_Plus                    : constant Name_Id := N + 277;\n+\n    --  The following names are present as synonyms for Stdcall\n \n-   Name_DLL                            : constant Name_Id := N + 275;\n-   Name_Win32                          : constant Name_Id := N + 276;\n+   Name_DLL                            : constant Name_Id := N + 278;\n+   Name_Win32                          : constant Name_Id := N + 279;\n \n    --  Other special names used in processing pragmas\n \n-   Name_As_Is                          : constant Name_Id := N + 277;\n-   Name_Attribute_Name                 : constant Name_Id := N + 278;\n-   Name_Body_File_Name                 : constant Name_Id := N + 279;\n-   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 280;\n-   Name_Check                          : constant Name_Id := N + 281;\n-   Name_Casing                         : constant Name_Id := N + 282;\n-   Name_Code                           : constant Name_Id := N + 283;\n-   Name_Component                      : constant Name_Id := N + 284;\n-   Name_Component_Size_4               : constant Name_Id := N + 285;\n-   Name_Copy                           : constant Name_Id := N + 286;\n-   Name_D_Float                        : constant Name_Id := N + 287;\n-   Name_Descriptor                     : constant Name_Id := N + 288;\n-   Name_Dot_Replacement                : constant Name_Id := N + 289;\n-   Name_Dynamic                        : constant Name_Id := N + 290;\n-   Name_Entity                         : constant Name_Id := N + 291;\n-   Name_Entry_Count                    : constant Name_Id := N + 292;\n-   Name_External_Name                  : constant Name_Id := N + 293;\n-   Name_First_Optional_Parameter       : constant Name_Id := N + 294;\n-   Name_Form                           : constant Name_Id := N + 295;\n-   Name_G_Float                        : constant Name_Id := N + 296;\n-   Name_Gcc                            : constant Name_Id := N + 297;\n-   Name_Gnat                           : constant Name_Id := N + 298;\n-   Name_GPL                            : constant Name_Id := N + 299;\n-   Name_IEEE_Float                     : constant Name_Id := N + 300;\n-   Name_Ignore                         : constant Name_Id := N + 301;\n-   Name_Info                           : constant Name_Id := N + 302;\n-   Name_Internal                       : constant Name_Id := N + 303;\n-   Name_Link_Name                      : constant Name_Id := N + 304;\n-   Name_Lowercase                      : constant Name_Id := N + 305;\n-   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 306;\n-   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 307;\n-   Name_Max_Size                       : constant Name_Id := N + 308;\n-   Name_Mechanism                      : constant Name_Id := N + 309;\n-   Name_Message                        : constant Name_Id := N + 310;\n-   Name_Mixedcase                      : constant Name_Id := N + 311;\n-   Name_Modified_GPL                   : constant Name_Id := N + 312;\n-   Name_Name                           : constant Name_Id := N + 313;\n-   Name_NCA                            : constant Name_Id := N + 314;\n-   Name_No                             : constant Name_Id := N + 315;\n-   Name_No_Dependence                  : constant Name_Id := N + 316;\n-   Name_No_Dynamic_Attachment          : constant Name_Id := N + 317;\n-   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 318;\n-   Name_No_Requeue                     : constant Name_Id := N + 319;\n-   Name_No_Requeue_Statements          : constant Name_Id := N + 320;\n-   Name_No_Task_Attributes             : constant Name_Id := N + 321;\n-   Name_No_Task_Attributes_Package     : constant Name_Id := N + 322;\n-   Name_On                             : constant Name_Id := N + 323;\n-   Name_Parameter_Types                : constant Name_Id := N + 324;\n-   Name_Reference                      : constant Name_Id := N + 325;\n-   Name_Restricted                     : constant Name_Id := N + 326;\n-   Name_Result_Mechanism               : constant Name_Id := N + 327;\n-   Name_Result_Type                    : constant Name_Id := N + 328;\n-   Name_Runtime                        : constant Name_Id := N + 329;\n-   Name_SB                             : constant Name_Id := N + 330;\n-   Name_Secondary_Stack_Size           : constant Name_Id := N + 331;\n-   Name_Section                        : constant Name_Id := N + 332;\n-   Name_Semaphore                      : constant Name_Id := N + 333;\n-   Name_Simple_Barriers                : constant Name_Id := N + 334;\n-   Name_Spec_File_Name                 : constant Name_Id := N + 335;\n-   Name_State                          : constant Name_Id := N + 336;\n-   Name_Static                         : constant Name_Id := N + 337;\n-   Name_Stack_Size                     : constant Name_Id := N + 338;\n-   Name_Subunit_File_Name              : constant Name_Id := N + 339;\n-   Name_Task_Stack_Size_Default        : constant Name_Id := N + 340;\n-   Name_Task_Type                      : constant Name_Id := N + 341;\n-   Name_Time_Slicing_Enabled           : constant Name_Id := N + 342;\n-   Name_Top_Guard                      : constant Name_Id := N + 343;\n-   Name_UBA                            : constant Name_Id := N + 344;\n-   Name_UBS                            : constant Name_Id := N + 345;\n-   Name_UBSB                           : constant Name_Id := N + 346;\n-   Name_Unit_Name                      : constant Name_Id := N + 347;\n-   Name_Unknown                        : constant Name_Id := N + 348;\n-   Name_Unrestricted                   : constant Name_Id := N + 349;\n-   Name_Uppercase                      : constant Name_Id := N + 350;\n-   Name_User                           : constant Name_Id := N + 351;\n-   Name_VAX_Float                      : constant Name_Id := N + 352;\n-   Name_VMS                            : constant Name_Id := N + 353;\n-   Name_Vtable_Ptr                     : constant Name_Id := N + 354;\n-   Name_Working_Storage                : constant Name_Id := N + 355;\n+   Name_As_Is                          : constant Name_Id := N + 280;\n+   Name_Attribute_Name                 : constant Name_Id := N + 281;\n+   Name_Body_File_Name                 : constant Name_Id := N + 282;\n+   Name_Boolean_Entry_Barriers         : constant Name_Id := N + 283;\n+   Name_Check                          : constant Name_Id := N + 284;\n+   Name_Casing                         : constant Name_Id := N + 285;\n+   Name_Code                           : constant Name_Id := N + 286;\n+   Name_Component                      : constant Name_Id := N + 287;\n+   Name_Component_Size_4               : constant Name_Id := N + 288;\n+   Name_Copy                           : constant Name_Id := N + 289;\n+   Name_D_Float                        : constant Name_Id := N + 290;\n+   Name_Descriptor                     : constant Name_Id := N + 291;\n+   Name_Dot_Replacement                : constant Name_Id := N + 292;\n+   Name_Dynamic                        : constant Name_Id := N + 293;\n+   Name_Entity                         : constant Name_Id := N + 294;\n+   Name_Entry_Count                    : constant Name_Id := N + 295;\n+   Name_External_Name                  : constant Name_Id := N + 296;\n+   Name_First_Optional_Parameter       : constant Name_Id := N + 297;\n+   Name_Form                           : constant Name_Id := N + 298;\n+   Name_G_Float                        : constant Name_Id := N + 299;\n+   Name_Gcc                            : constant Name_Id := N + 300;\n+   Name_Gnat                           : constant Name_Id := N + 301;\n+   Name_GPL                            : constant Name_Id := N + 302;\n+   Name_IEEE_Float                     : constant Name_Id := N + 303;\n+   Name_Ignore                         : constant Name_Id := N + 304;\n+   Name_Info                           : constant Name_Id := N + 305;\n+   Name_Internal                       : constant Name_Id := N + 306;\n+   Name_Link_Name                      : constant Name_Id := N + 307;\n+   Name_Lowercase                      : constant Name_Id := N + 308;\n+   Name_Max_Entry_Queue_Depth          : constant Name_Id := N + 309;\n+   Name_Max_Entry_Queue_Length         : constant Name_Id := N + 310;\n+   Name_Max_Size                       : constant Name_Id := N + 311;\n+   Name_Mechanism                      : constant Name_Id := N + 312;\n+   Name_Message                        : constant Name_Id := N + 313;\n+   Name_Mixedcase                      : constant Name_Id := N + 314;\n+   Name_Modified_GPL                   : constant Name_Id := N + 315;\n+   Name_Name                           : constant Name_Id := N + 316;\n+   Name_NCA                            : constant Name_Id := N + 317;\n+   Name_No                             : constant Name_Id := N + 318;\n+   Name_No_Dependence                  : constant Name_Id := N + 319;\n+   Name_No_Dynamic_Attachment          : constant Name_Id := N + 320;\n+   Name_No_Dynamic_Interrupts          : constant Name_Id := N + 321;\n+   Name_No_Requeue                     : constant Name_Id := N + 322;\n+   Name_No_Requeue_Statements          : constant Name_Id := N + 323;\n+   Name_No_Task_Attributes             : constant Name_Id := N + 324;\n+   Name_No_Task_Attributes_Package     : constant Name_Id := N + 325;\n+   Name_On                             : constant Name_Id := N + 326;\n+   Name_Parameter_Types                : constant Name_Id := N + 327;\n+   Name_Reference                      : constant Name_Id := N + 328;\n+   Name_Restricted                     : constant Name_Id := N + 329;\n+   Name_Result_Mechanism               : constant Name_Id := N + 330;\n+   Name_Result_Type                    : constant Name_Id := N + 331;\n+   Name_Runtime                        : constant Name_Id := N + 332;\n+   Name_SB                             : constant Name_Id := N + 333;\n+   Name_Secondary_Stack_Size           : constant Name_Id := N + 334;\n+   Name_Section                        : constant Name_Id := N + 335;\n+   Name_Semaphore                      : constant Name_Id := N + 336;\n+   Name_Simple_Barriers                : constant Name_Id := N + 337;\n+   Name_Spec_File_Name                 : constant Name_Id := N + 338;\n+   Name_State                          : constant Name_Id := N + 339;\n+   Name_Static                         : constant Name_Id := N + 340;\n+   Name_Stack_Size                     : constant Name_Id := N + 341;\n+   Name_Subunit_File_Name              : constant Name_Id := N + 342;\n+   Name_Task_Stack_Size_Default        : constant Name_Id := N + 343;\n+   Name_Task_Type                      : constant Name_Id := N + 344;\n+   Name_Time_Slicing_Enabled           : constant Name_Id := N + 345;\n+   Name_Top_Guard                      : constant Name_Id := N + 346;\n+   Name_UBA                            : constant Name_Id := N + 347;\n+   Name_UBS                            : constant Name_Id := N + 348;\n+   Name_UBSB                           : constant Name_Id := N + 349;\n+   Name_Unit_Name                      : constant Name_Id := N + 350;\n+   Name_Unknown                        : constant Name_Id := N + 351;\n+   Name_Unrestricted                   : constant Name_Id := N + 352;\n+   Name_Uppercase                      : constant Name_Id := N + 353;\n+   Name_User                           : constant Name_Id := N + 354;\n+   Name_VAX_Float                      : constant Name_Id := N + 355;\n+   Name_VMS                            : constant Name_Id := N + 356;\n+   Name_Vtable_Ptr                     : constant Name_Id := N + 357;\n+   Name_Working_Storage                : constant Name_Id := N + 358;\n \n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n@@ -641,440 +647,462 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n-   First_Attribute_Name                : constant Name_Id := N + 356;\n-   Name_Abort_Signal                   : constant Name_Id := N + 356; -- GNAT\n-   Name_Access                         : constant Name_Id := N + 357;\n-   Name_Address                        : constant Name_Id := N + 358;\n-   Name_Address_Size                   : constant Name_Id := N + 359; -- GNAT\n-   Name_Aft                            : constant Name_Id := N + 360;\n-   Name_Alignment                      : constant Name_Id := N + 361;\n-   Name_Asm_Input                      : constant Name_Id := N + 362; -- GNAT\n-   Name_Asm_Output                     : constant Name_Id := N + 363; -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + 364; -- VMS\n-   Name_Bit                            : constant Name_Id := N + 365; -- GNAT\n-   Name_Bit_Order                      : constant Name_Id := N + 366;\n-   Name_Bit_Position                   : constant Name_Id := N + 367; -- GNAT\n-   Name_Body_Version                   : constant Name_Id := N + 368;\n-   Name_Callable                       : constant Name_Id := N + 369;\n-   Name_Caller                         : constant Name_Id := N + 370;\n-   Name_Code_Address                   : constant Name_Id := N + 371; -- GNAT\n-   Name_Component_Size                 : constant Name_Id := N + 372;\n-   Name_Compose                        : constant Name_Id := N + 373;\n-   Name_Constrained                    : constant Name_Id := N + 374;\n-   Name_Count                          : constant Name_Id := N + 375;\n-   Name_Default_Bit_Order              : constant Name_Id := N + 376; -- GNAT\n-   Name_Definite                       : constant Name_Id := N + 377;\n-   Name_Delta                          : constant Name_Id := N + 378;\n-   Name_Denorm                         : constant Name_Id := N + 379;\n-   Name_Digits                         : constant Name_Id := N + 380;\n-   Name_Elaborated                     : constant Name_Id := N + 381; -- GNAT\n-   Name_Emax                           : constant Name_Id := N + 382; -- Ada 83\n-   Name_Enum_Rep                       : constant Name_Id := N + 383; -- GNAT\n-   Name_Epsilon                        : constant Name_Id := N + 384; -- Ada 83\n-   Name_Exponent                       : constant Name_Id := N + 385;\n-   Name_External_Tag                   : constant Name_Id := N + 386;\n-   Name_First                          : constant Name_Id := N + 387;\n-   Name_First_Bit                      : constant Name_Id := N + 388;\n-   Name_Fixed_Value                    : constant Name_Id := N + 389; -- GNAT\n-   Name_Fore                           : constant Name_Id := N + 390;\n-   Name_Has_Access_Values              : constant Name_Id := N + 391; -- GNAT\n-   Name_Has_Discriminants              : constant Name_Id := N + 392; -- GNAT\n-   Name_Identity                       : constant Name_Id := N + 393;\n-   Name_Img                            : constant Name_Id := N + 394; -- GNAT\n-   Name_Integer_Value                  : constant Name_Id := N + 395; -- GNAT\n-   Name_Large                          : constant Name_Id := N + 396; -- Ada 83\n-   Name_Last                           : constant Name_Id := N + 397;\n-   Name_Last_Bit                       : constant Name_Id := N + 398;\n-   Name_Leading_Part                   : constant Name_Id := N + 399;\n-   Name_Length                         : constant Name_Id := N + 400;\n-   Name_Machine_Emax                   : constant Name_Id := N + 401;\n-   Name_Machine_Emin                   : constant Name_Id := N + 402;\n-   Name_Machine_Mantissa               : constant Name_Id := N + 403;\n-   Name_Machine_Overflows              : constant Name_Id := N + 404;\n-   Name_Machine_Radix                  : constant Name_Id := N + 405;\n-   Name_Machine_Rounding               : constant Name_Id := N + 406; -- Ada 05\n-   Name_Machine_Rounds                 : constant Name_Id := N + 407;\n-   Name_Machine_Size                   : constant Name_Id := N + 408; -- GNAT\n-   Name_Mantissa                       : constant Name_Id := N + 409; -- Ada 83\n-   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 410;\n-   Name_Maximum_Alignment              : constant Name_Id := N + 411; -- GNAT\n-   Name_Mechanism_Code                 : constant Name_Id := N + 412; -- GNAT\n-   Name_Mod                            : constant Name_Id := N + 413;\n-   Name_Model_Emin                     : constant Name_Id := N + 414;\n-   Name_Model_Epsilon                  : constant Name_Id := N + 415;\n-   Name_Model_Mantissa                 : constant Name_Id := N + 416;\n-   Name_Model_Small                    : constant Name_Id := N + 417;\n-   Name_Modulus                        : constant Name_Id := N + 418;\n-   Name_Null_Parameter                 : constant Name_Id := N + 419; -- GNAT\n-   Name_Object_Size                    : constant Name_Id := N + 420; -- GNAT\n-   Name_Partition_ID                   : constant Name_Id := N + 421;\n-   Name_Passed_By_Reference            : constant Name_Id := N + 422; -- GNAT\n-   Name_Pool_Address                   : constant Name_Id := N + 423;\n-   Name_Pos                            : constant Name_Id := N + 424;\n-   Name_Position                       : constant Name_Id := N + 425;\n-   Name_Priority                       : constant Name_Id := N + 426; -- Ada 05\n-   Name_Range                          : constant Name_Id := N + 427;\n-   Name_Range_Length                   : constant Name_Id := N + 428; -- GNAT\n-   Name_Round                          : constant Name_Id := N + 429;\n-   Name_Safe_Emax                      : constant Name_Id := N + 430; -- Ada 83\n-   Name_Safe_First                     : constant Name_Id := N + 431;\n-   Name_Safe_Large                     : constant Name_Id := N + 432; -- Ada 83\n-   Name_Safe_Last                      : constant Name_Id := N + 433;\n-   Name_Safe_Small                     : constant Name_Id := N + 434; -- Ada 83\n-   Name_Scale                          : constant Name_Id := N + 435;\n-   Name_Scaling                        : constant Name_Id := N + 436;\n-   Name_Signed_Zeros                   : constant Name_Id := N + 437;\n-   Name_Size                           : constant Name_Id := N + 438;\n-   Name_Small                          : constant Name_Id := N + 439;\n-   Name_Storage_Size                   : constant Name_Id := N + 440;\n-   Name_Storage_Unit                   : constant Name_Id := N + 441; -- GNAT\n-   Name_Stream_Size                    : constant Name_Id := N + 442; -- Ada 05\n-   Name_Tag                            : constant Name_Id := N + 443;\n-   Name_Target_Name                    : constant Name_Id := N + 444; -- GNAT\n-   Name_Terminated                     : constant Name_Id := N + 445;\n-   Name_To_Address                     : constant Name_Id := N + 446; -- GNAT\n-   Name_Type_Class                     : constant Name_Id := N + 447; -- GNAT\n-   Name_UET_Address                    : constant Name_Id := N + 448; -- GNAT\n-   Name_Unbiased_Rounding              : constant Name_Id := N + 449;\n-   Name_Unchecked_Access               : constant Name_Id := N + 450;\n-   Name_Unconstrained_Array            : constant Name_Id := N + 451;\n-   Name_Universal_Literal_String       : constant Name_Id := N + 452; -- GNAT\n-   Name_Unrestricted_Access            : constant Name_Id := N + 453; -- GNAT\n-   Name_VADS_Size                      : constant Name_Id := N + 454; -- GNAT\n-   Name_Val                            : constant Name_Id := N + 455;\n-   Name_Valid                          : constant Name_Id := N + 456;\n-   Name_Value_Size                     : constant Name_Id := N + 457; -- GNAT\n-   Name_Version                        : constant Name_Id := N + 458;\n-   Name_Wchar_T_Size                   : constant Name_Id := N + 459; -- GNAT\n-   Name_Wide_Wide_Width                : constant Name_Id := N + 460; -- Ada 05\n-   Name_Wide_Width                     : constant Name_Id := N + 461;\n-   Name_Width                          : constant Name_Id := N + 462;\n-   Name_Word_Size                      : constant Name_Id := N + 463; -- GNAT\n+   First_Attribute_Name                : constant Name_Id := N + 359;\n+   Name_Abort_Signal                   : constant Name_Id := N + 359; -- GNAT\n+   Name_Access                         : constant Name_Id := N + 360;\n+   Name_Address                        : constant Name_Id := N + 361;\n+   Name_Address_Size                   : constant Name_Id := N + 362; -- GNAT\n+   Name_Aft                            : constant Name_Id := N + 363;\n+   Name_Alignment                      : constant Name_Id := N + 364;\n+   Name_Asm_Input                      : constant Name_Id := N + 365; -- GNAT\n+   Name_Asm_Output                     : constant Name_Id := N + 366; -- GNAT\n+   Name_AST_Entry                      : constant Name_Id := N + 367; -- VMS\n+   Name_Bit                            : constant Name_Id := N + 368; -- GNAT\n+   Name_Bit_Order                      : constant Name_Id := N + 369;\n+   Name_Bit_Position                   : constant Name_Id := N + 370; -- GNAT\n+   Name_Body_Version                   : constant Name_Id := N + 371;\n+   Name_Callable                       : constant Name_Id := N + 372;\n+   Name_Caller                         : constant Name_Id := N + 373;\n+   Name_Code_Address                   : constant Name_Id := N + 374; -- GNAT\n+   Name_Component_Size                 : constant Name_Id := N + 375;\n+   Name_Compose                        : constant Name_Id := N + 376;\n+   Name_Constrained                    : constant Name_Id := N + 377;\n+   Name_Count                          : constant Name_Id := N + 378;\n+   Name_Default_Bit_Order              : constant Name_Id := N + 379; -- GNAT\n+   Name_Definite                       : constant Name_Id := N + 380;\n+   Name_Delta                          : constant Name_Id := N + 381;\n+   Name_Denorm                         : constant Name_Id := N + 382;\n+   Name_Digits                         : constant Name_Id := N + 383;\n+   Name_Elaborated                     : constant Name_Id := N + 384; -- GNAT\n+   Name_Emax                           : constant Name_Id := N + 385; -- Ada 83\n+   Name_Enum_Rep                       : constant Name_Id := N + 386; -- GNAT\n+   Name_Epsilon                        : constant Name_Id := N + 387; -- Ada 83\n+   Name_Exponent                       : constant Name_Id := N + 388;\n+   Name_External_Tag                   : constant Name_Id := N + 389;\n+   Name_First                          : constant Name_Id := N + 390;\n+   Name_First_Bit                      : constant Name_Id := N + 391;\n+   Name_Fixed_Value                    : constant Name_Id := N + 392; -- GNAT\n+   Name_Fore                           : constant Name_Id := N + 393;\n+   Name_Has_Access_Values              : constant Name_Id := N + 394; -- GNAT\n+   Name_Has_Discriminants              : constant Name_Id := N + 395; -- GNAT\n+   Name_Identity                       : constant Name_Id := N + 396;\n+   Name_Img                            : constant Name_Id := N + 397; -- GNAT\n+   Name_Integer_Value                  : constant Name_Id := N + 398; -- GNAT\n+   Name_Large                          : constant Name_Id := N + 399; -- Ada 83\n+   Name_Last                           : constant Name_Id := N + 400;\n+   Name_Last_Bit                       : constant Name_Id := N + 401;\n+   Name_Leading_Part                   : constant Name_Id := N + 402;\n+   Name_Length                         : constant Name_Id := N + 403;\n+   Name_Machine_Emax                   : constant Name_Id := N + 404;\n+   Name_Machine_Emin                   : constant Name_Id := N + 405;\n+   Name_Machine_Mantissa               : constant Name_Id := N + 406;\n+   Name_Machine_Overflows              : constant Name_Id := N + 407;\n+   Name_Machine_Radix                  : constant Name_Id := N + 408;\n+   Name_Machine_Rounding               : constant Name_Id := N + 409; -- Ada 05\n+   Name_Machine_Rounds                 : constant Name_Id := N + 410;\n+   Name_Machine_Size                   : constant Name_Id := N + 411; -- GNAT\n+   Name_Mantissa                       : constant Name_Id := N + 412; -- Ada 83\n+   Name_Max_Size_In_Storage_Elements   : constant Name_Id := N + 413;\n+   Name_Maximum_Alignment              : constant Name_Id := N + 414; -- GNAT\n+   Name_Mechanism_Code                 : constant Name_Id := N + 415; -- GNAT\n+   Name_Mod                            : constant Name_Id := N + 416;\n+   Name_Model_Emin                     : constant Name_Id := N + 417;\n+   Name_Model_Epsilon                  : constant Name_Id := N + 418;\n+   Name_Model_Mantissa                 : constant Name_Id := N + 419;\n+   Name_Model_Small                    : constant Name_Id := N + 420;\n+   Name_Modulus                        : constant Name_Id := N + 421;\n+   Name_Null_Parameter                 : constant Name_Id := N + 422; -- GNAT\n+   Name_Object_Size                    : constant Name_Id := N + 423; -- GNAT\n+   Name_Partition_ID                   : constant Name_Id := N + 424;\n+   Name_Passed_By_Reference            : constant Name_Id := N + 425; -- GNAT\n+   Name_Pool_Address                   : constant Name_Id := N + 426;\n+   Name_Pos                            : constant Name_Id := N + 427;\n+   Name_Position                       : constant Name_Id := N + 428;\n+   Name_Priority                       : constant Name_Id := N + 429; -- Ada 05\n+   Name_Range                          : constant Name_Id := N + 430;\n+   Name_Range_Length                   : constant Name_Id := N + 431; -- GNAT\n+   Name_Round                          : constant Name_Id := N + 432;\n+   Name_Safe_Emax                      : constant Name_Id := N + 433; -- Ada 83\n+   Name_Safe_First                     : constant Name_Id := N + 434;\n+   Name_Safe_Large                     : constant Name_Id := N + 435; -- Ada 83\n+   Name_Safe_Last                      : constant Name_Id := N + 436;\n+   Name_Safe_Small                     : constant Name_Id := N + 437; -- Ada 83\n+   Name_Scale                          : constant Name_Id := N + 438;\n+   Name_Scaling                        : constant Name_Id := N + 439;\n+   Name_Signed_Zeros                   : constant Name_Id := N + 440;\n+   Name_Size                           : constant Name_Id := N + 441;\n+   Name_Small                          : constant Name_Id := N + 442;\n+   Name_Storage_Size                   : constant Name_Id := N + 443;\n+   Name_Storage_Unit                   : constant Name_Id := N + 444; -- GNAT\n+   Name_Stream_Size                    : constant Name_Id := N + 445; -- Ada 05\n+   Name_Tag                            : constant Name_Id := N + 446;\n+   Name_Target_Name                    : constant Name_Id := N + 447; -- GNAT\n+   Name_Terminated                     : constant Name_Id := N + 448;\n+   Name_To_Address                     : constant Name_Id := N + 449; -- GNAT\n+   Name_Type_Class                     : constant Name_Id := N + 450; -- GNAT\n+   Name_UET_Address                    : constant Name_Id := N + 451; -- GNAT\n+   Name_Unbiased_Rounding              : constant Name_Id := N + 452;\n+   Name_Unchecked_Access               : constant Name_Id := N + 453;\n+   Name_Unconstrained_Array            : constant Name_Id := N + 454;\n+   Name_Universal_Literal_String       : constant Name_Id := N + 455; -- GNAT\n+   Name_Unrestricted_Access            : constant Name_Id := N + 456; -- GNAT\n+   Name_VADS_Size                      : constant Name_Id := N + 457; -- GNAT\n+   Name_Val                            : constant Name_Id := N + 458;\n+   Name_Valid                          : constant Name_Id := N + 459;\n+   Name_Value_Size                     : constant Name_Id := N + 460; -- GNAT\n+   Name_Version                        : constant Name_Id := N + 461;\n+   Name_Wchar_T_Size                   : constant Name_Id := N + 462; -- GNAT\n+   Name_Wide_Wide_Width                : constant Name_Id := N + 463; -- Ada 05\n+   Name_Wide_Width                     : constant Name_Id := N + 464;\n+   Name_Width                          : constant Name_Id := N + 465;\n+   Name_Word_Size                      : constant Name_Id := N + 466; -- GNAT\n \n    --  Attributes that designate attributes returning renamable functions,\n    --  i.e. functions that return other than a universal value and that\n    --  have non-universal arguments.\n \n-   First_Renamable_Function_Attribute  : constant Name_Id := N + 464;\n-   Name_Adjacent                       : constant Name_Id := N + 464;\n-   Name_Ceiling                        : constant Name_Id := N + 465;\n-   Name_Copy_Sign                      : constant Name_Id := N + 466;\n-   Name_Floor                          : constant Name_Id := N + 467;\n-   Name_Fraction                       : constant Name_Id := N + 468;\n-   Name_Image                          : constant Name_Id := N + 469;\n-   Name_Input                          : constant Name_Id := N + 470;\n-   Name_Machine                        : constant Name_Id := N + 471;\n-   Name_Max                            : constant Name_Id := N + 472;\n-   Name_Min                            : constant Name_Id := N + 473;\n-   Name_Model                          : constant Name_Id := N + 474;\n-   Name_Pred                           : constant Name_Id := N + 475;\n-   Name_Remainder                      : constant Name_Id := N + 476;\n-   Name_Rounding                       : constant Name_Id := N + 477;\n-   Name_Succ                           : constant Name_Id := N + 478;\n-   Name_Truncation                     : constant Name_Id := N + 479;\n-   Name_Value                          : constant Name_Id := N + 480;\n-   Name_Wide_Image                     : constant Name_Id := N + 481;\n-   Name_Wide_Wide_Image                : constant Name_Id := N + 482;\n-   Name_Wide_Value                     : constant Name_Id := N + 483;\n-   Name_Wide_Wide_Value                : constant Name_Id := N + 484;\n-   Last_Renamable_Function_Attribute   : constant Name_Id := N + 484;\n+   First_Renamable_Function_Attribute  : constant Name_Id := N + 467;\n+   Name_Adjacent                       : constant Name_Id := N + 467;\n+   Name_Ceiling                        : constant Name_Id := N + 468;\n+   Name_Copy_Sign                      : constant Name_Id := N + 469;\n+   Name_Floor                          : constant Name_Id := N + 470;\n+   Name_Fraction                       : constant Name_Id := N + 471;\n+   Name_Image                          : constant Name_Id := N + 472;\n+   Name_Input                          : constant Name_Id := N + 473;\n+   Name_Machine                        : constant Name_Id := N + 474;\n+   Name_Max                            : constant Name_Id := N + 475;\n+   Name_Min                            : constant Name_Id := N + 476;\n+   Name_Model                          : constant Name_Id := N + 477;\n+   Name_Pred                           : constant Name_Id := N + 478;\n+   Name_Remainder                      : constant Name_Id := N + 479;\n+   Name_Rounding                       : constant Name_Id := N + 480;\n+   Name_Succ                           : constant Name_Id := N + 481;\n+   Name_Truncation                     : constant Name_Id := N + 482;\n+   Name_Value                          : constant Name_Id := N + 483;\n+   Name_Wide_Image                     : constant Name_Id := N + 484;\n+   Name_Wide_Wide_Image                : constant Name_Id := N + 485;\n+   Name_Wide_Value                     : constant Name_Id := N + 486;\n+   Name_Wide_Wide_Value                : constant Name_Id := N + 487;\n+   Last_Renamable_Function_Attribute   : constant Name_Id := N + 487;\n \n    --  Attributes that designate procedures\n \n-   First_Procedure_Attribute           : constant Name_Id := N + 485;\n-   Name_Output                         : constant Name_Id := N + 485;\n-   Name_Read                           : constant Name_Id := N + 486;\n-   Name_Write                          : constant Name_Id := N + 487;\n-   Last_Procedure_Attribute            : constant Name_Id := N + 487;\n+   First_Procedure_Attribute           : constant Name_Id := N + 488;\n+   Name_Output                         : constant Name_Id := N + 488;\n+   Name_Read                           : constant Name_Id := N + 489;\n+   Name_Write                          : constant Name_Id := N + 490;\n+   Last_Procedure_Attribute            : constant Name_Id := N + 490;\n \n    --  Remaining attributes are ones that return entities\n \n-   First_Entity_Attribute_Name         : constant Name_Id := N + 488;\n-   Name_Elab_Body                      : constant Name_Id := N + 488; -- GNAT\n-   Name_Elab_Spec                      : constant Name_Id := N + 489; -- GNAT\n-   Name_Storage_Pool                   : constant Name_Id := N + 490;\n+   First_Entity_Attribute_Name         : constant Name_Id := N + 491;\n+   Name_Elab_Body                      : constant Name_Id := N + 491; -- GNAT\n+   Name_Elab_Spec                      : constant Name_Id := N + 492; -- GNAT\n+   Name_Storage_Pool                   : constant Name_Id := N + 493;\n \n    --  These attributes are the ones that return types\n \n-   First_Type_Attribute_Name           : constant Name_Id := N + 491;\n-   Name_Base                           : constant Name_Id := N + 491;\n-   Name_Class                          : constant Name_Id := N + 492;\n-   Name_Stub_Type                      : constant Name_Id := N + 493;\n-   Last_Type_Attribute_Name            : constant Name_Id := N + 493;\n-   Last_Entity_Attribute_Name          : constant Name_Id := N + 493;\n-   Last_Attribute_Name                 : constant Name_Id := N + 493;\n+   First_Type_Attribute_Name           : constant Name_Id := N + 494;\n+   Name_Base                           : constant Name_Id := N + 494;\n+   Name_Class                          : constant Name_Id := N + 495;\n+   Name_Stub_Type                      : constant Name_Id := N + 496;\n+   Last_Type_Attribute_Name            : constant Name_Id := N + 496;\n+   Last_Entity_Attribute_Name          : constant Name_Id := N + 496;\n+   Last_Attribute_Name                 : constant Name_Id := N + 496;\n \n    --  Names of recognized locking policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. C for Ceiling_Locking). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Locking_Policy_Name           : constant Name_Id := N + 494;\n-   Name_Ceiling_Locking                : constant Name_Id := N + 494;\n-   Name_Inheritance_Locking            : constant Name_Id := N + 495;\n-   Last_Locking_Policy_Name            : constant Name_Id := N + 495;\n+   First_Locking_Policy_Name           : constant Name_Id := N + 497;\n+   Name_Ceiling_Locking                : constant Name_Id := N + 497;\n+   Name_Inheritance_Locking            : constant Name_Id := N + 498;\n+   Last_Locking_Policy_Name            : constant Name_Id := N + 498;\n \n    --  Names of recognized queuing policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Queuing). If new policy names are added,\n    --  the first character must be distinct.\n \n-   First_Queuing_Policy_Name           : constant Name_Id := N + 496;\n-   Name_FIFO_Queuing                   : constant Name_Id := N + 496;\n-   Name_Priority_Queuing               : constant Name_Id := N + 497;\n-   Last_Queuing_Policy_Name            : constant Name_Id := N + 497;\n+   First_Queuing_Policy_Name           : constant Name_Id := N + 499;\n+   Name_FIFO_Queuing                   : constant Name_Id := N + 499;\n+   Name_Priority_Queuing               : constant Name_Id := N + 500;\n+   Last_Queuing_Policy_Name            : constant Name_Id := N + 500;\n \n    --  Names of recognized task dispatching policy identifiers\n \n    --  Note: policies are identified by the first character of the\n    --  name (e.g. F for FIFO_Within_Priorities). If new policy names\n    --  are added, the first character must be distinct.\n \n-   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 498;\n-   Name_EDF_Across_Priorities          : constant Name_Id := N + 498;\n-   Name_FIFO_Within_Priorities         : constant Name_Id := N + 499;\n-   Name_Non_Preemptive_Within_Priorities : constant Name_Id := N + 500;\n-   Name_Round_Robin_Within_Priorities  : constant Name_Id := N + 501;\n-   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 501;\n+   First_Task_Dispatching_Policy_Name  : constant Name_Id := N + 501;\n+   Name_EDF_Across_Priorities          : constant Name_Id := N + 501;\n+   Name_FIFO_Within_Priorities         : constant Name_Id := N + 502;\n+   Name_Non_Preemptive_Within_Priorities : constant Name_Id := N + 503;\n+   Name_Round_Robin_Within_Priorities  : constant Name_Id := N + 504;\n+   Last_Task_Dispatching_Policy_Name   : constant Name_Id := N + 504;\n \n    --  Names of recognized checks for pragma Suppress\n \n-   First_Check_Name                    : constant Name_Id := N + 502;\n-   Name_Access_Check                   : constant Name_Id := N + 502;\n-   Name_Accessibility_Check            : constant Name_Id := N + 503;\n-   Name_Alignment_Check                : constant Name_Id := N + 504;\n-   Name_Discriminant_Check             : constant Name_Id := N + 505;\n-   Name_Division_Check                 : constant Name_Id := N + 506;\n-   Name_Elaboration_Check              : constant Name_Id := N + 507;\n-   Name_Index_Check                    : constant Name_Id := N + 508;\n-   Name_Length_Check                   : constant Name_Id := N + 509;\n-   Name_Overflow_Check                 : constant Name_Id := N + 510;\n-   Name_Range_Check                    : constant Name_Id := N + 511;\n-   Name_Storage_Check                  : constant Name_Id := N + 512;\n-   Name_Tag_Check                      : constant Name_Id := N + 513;\n-   Name_Validity_Check                 : constant Name_Id := N + 514;\n-   Name_All_Checks                     : constant Name_Id := N + 515;\n-   Last_Check_Name                     : constant Name_Id := N + 515;\n+   First_Check_Name                    : constant Name_Id := N + 505;\n+   Name_Access_Check                   : constant Name_Id := N + 505;\n+   Name_Accessibility_Check            : constant Name_Id := N + 506;\n+   Name_Alignment_Check                : constant Name_Id := N + 507;\n+   Name_Discriminant_Check             : constant Name_Id := N + 508;\n+   Name_Division_Check                 : constant Name_Id := N + 509;\n+   Name_Elaboration_Check              : constant Name_Id := N + 510;\n+   Name_Index_Check                    : constant Name_Id := N + 511;\n+   Name_Length_Check                   : constant Name_Id := N + 512;\n+   Name_Overflow_Check                 : constant Name_Id := N + 513;\n+   Name_Range_Check                    : constant Name_Id := N + 514;\n+   Name_Storage_Check                  : constant Name_Id := N + 515;\n+   Name_Tag_Check                      : constant Name_Id := N + 516;\n+   Name_Validity_Check                 : constant Name_Id := N + 517;\n+   Name_All_Checks                     : constant Name_Id := N + 518;\n+   Last_Check_Name                     : constant Name_Id := N + 518;\n \n    --  Names corresponding to reserved keywords, excluding those already\n    --  declared in the attribute list (Access, Delta, Digits, Mod, Range).\n \n-   Name_Abort                          : constant Name_Id := N + 516;\n-   Name_Abs                            : constant Name_Id := N + 517;\n-   Name_Accept                         : constant Name_Id := N + 518;\n-   Name_And                            : constant Name_Id := N + 519;\n-   Name_All                            : constant Name_Id := N + 520;\n-   Name_Array                          : constant Name_Id := N + 521;\n-   Name_At                             : constant Name_Id := N + 522;\n-   Name_Begin                          : constant Name_Id := N + 523;\n-   Name_Body                           : constant Name_Id := N + 524;\n-   Name_Case                           : constant Name_Id := N + 525;\n-   Name_Constant                       : constant Name_Id := N + 526;\n-   Name_Declare                        : constant Name_Id := N + 527;\n-   Name_Delay                          : constant Name_Id := N + 528;\n-   Name_Do                             : constant Name_Id := N + 529;\n-   Name_Else                           : constant Name_Id := N + 530;\n-   Name_Elsif                          : constant Name_Id := N + 531;\n-   Name_End                            : constant Name_Id := N + 532;\n-   Name_Entry                          : constant Name_Id := N + 533;\n-   Name_Exception                      : constant Name_Id := N + 534;\n-   Name_Exit                           : constant Name_Id := N + 535;\n-   Name_For                            : constant Name_Id := N + 536;\n-   Name_Function                       : constant Name_Id := N + 537;\n-   Name_Generic                        : constant Name_Id := N + 538;\n-   Name_Goto                           : constant Name_Id := N + 539;\n-   Name_If                             : constant Name_Id := N + 540;\n-   Name_In                             : constant Name_Id := N + 541;\n-   Name_Is                             : constant Name_Id := N + 542;\n-   Name_Limited                        : constant Name_Id := N + 543;\n-   Name_Loop                           : constant Name_Id := N + 544;\n-   Name_New                            : constant Name_Id := N + 545;\n-   Name_Not                            : constant Name_Id := N + 546;\n-   Name_Null                           : constant Name_Id := N + 547;\n-   Name_Of                             : constant Name_Id := N + 548;\n-   Name_Or                             : constant Name_Id := N + 549;\n-   Name_Others                         : constant Name_Id := N + 550;\n-   Name_Out                            : constant Name_Id := N + 551;\n-   Name_Package                        : constant Name_Id := N + 552;\n-   Name_Pragma                         : constant Name_Id := N + 553;\n-   Name_Private                        : constant Name_Id := N + 554;\n-   Name_Procedure                      : constant Name_Id := N + 555;\n-   Name_Raise                          : constant Name_Id := N + 556;\n-   Name_Record                         : constant Name_Id := N + 557;\n-   Name_Rem                            : constant Name_Id := N + 558;\n-   Name_Renames                        : constant Name_Id := N + 559;\n-   Name_Return                         : constant Name_Id := N + 560;\n-   Name_Reverse                        : constant Name_Id := N + 561;\n-   Name_Select                         : constant Name_Id := N + 562;\n-   Name_Separate                       : constant Name_Id := N + 563;\n-   Name_Subtype                        : constant Name_Id := N + 564;\n-   Name_Task                           : constant Name_Id := N + 565;\n-   Name_Terminate                      : constant Name_Id := N + 566;\n-   Name_Then                           : constant Name_Id := N + 567;\n-   Name_Type                           : constant Name_Id := N + 568;\n-   Name_Use                            : constant Name_Id := N + 569;\n-   Name_When                           : constant Name_Id := N + 570;\n-   Name_While                          : constant Name_Id := N + 571;\n-   Name_With                           : constant Name_Id := N + 572;\n-   Name_Xor                            : constant Name_Id := N + 573;\n+   Name_Abort                          : constant Name_Id := N + 519;\n+   Name_Abs                            : constant Name_Id := N + 520;\n+   Name_Accept                         : constant Name_Id := N + 521;\n+   Name_And                            : constant Name_Id := N + 522;\n+   Name_All                            : constant Name_Id := N + 523;\n+   Name_Array                          : constant Name_Id := N + 524;\n+   Name_At                             : constant Name_Id := N + 525;\n+   Name_Begin                          : constant Name_Id := N + 526;\n+   Name_Body                           : constant Name_Id := N + 527;\n+   Name_Case                           : constant Name_Id := N + 528;\n+   Name_Constant                       : constant Name_Id := N + 529;\n+   Name_Declare                        : constant Name_Id := N + 530;\n+   Name_Delay                          : constant Name_Id := N + 531;\n+   Name_Do                             : constant Name_Id := N + 532;\n+   Name_Else                           : constant Name_Id := N + 533;\n+   Name_Elsif                          : constant Name_Id := N + 534;\n+   Name_End                            : constant Name_Id := N + 535;\n+   Name_Entry                          : constant Name_Id := N + 536;\n+   Name_Exception                      : constant Name_Id := N + 537;\n+   Name_Exit                           : constant Name_Id := N + 538;\n+   Name_For                            : constant Name_Id := N + 539;\n+   Name_Function                       : constant Name_Id := N + 540;\n+   Name_Generic                        : constant Name_Id := N + 541;\n+   Name_Goto                           : constant Name_Id := N + 542;\n+   Name_If                             : constant Name_Id := N + 543;\n+   Name_In                             : constant Name_Id := N + 544;\n+   Name_Is                             : constant Name_Id := N + 545;\n+   Name_Limited                        : constant Name_Id := N + 546;\n+   Name_Loop                           : constant Name_Id := N + 547;\n+   Name_New                            : constant Name_Id := N + 548;\n+   Name_Not                            : constant Name_Id := N + 549;\n+   Name_Null                           : constant Name_Id := N + 550;\n+   Name_Of                             : constant Name_Id := N + 551;\n+   Name_Or                             : constant Name_Id := N + 552;\n+   Name_Others                         : constant Name_Id := N + 553;\n+   Name_Out                            : constant Name_Id := N + 554;\n+   Name_Package                        : constant Name_Id := N + 555;\n+   Name_Pragma                         : constant Name_Id := N + 556;\n+   Name_Private                        : constant Name_Id := N + 557;\n+   Name_Procedure                      : constant Name_Id := N + 558;\n+   Name_Raise                          : constant Name_Id := N + 559;\n+   Name_Record                         : constant Name_Id := N + 560;\n+   Name_Rem                            : constant Name_Id := N + 561;\n+   Name_Renames                        : constant Name_Id := N + 562;\n+   Name_Return                         : constant Name_Id := N + 563;\n+   Name_Reverse                        : constant Name_Id := N + 564;\n+   Name_Select                         : constant Name_Id := N + 565;\n+   Name_Separate                       : constant Name_Id := N + 566;\n+   Name_Subtype                        : constant Name_Id := N + 567;\n+   Name_Task                           : constant Name_Id := N + 568;\n+   Name_Terminate                      : constant Name_Id := N + 569;\n+   Name_Then                           : constant Name_Id := N + 570;\n+   Name_Type                           : constant Name_Id := N + 571;\n+   Name_Use                            : constant Name_Id := N + 572;\n+   Name_When                           : constant Name_Id := N + 573;\n+   Name_While                          : constant Name_Id := N + 574;\n+   Name_With                           : constant Name_Id := N + 575;\n+   Name_Xor                            : constant Name_Id := N + 576;\n \n    --  Names of intrinsic subprograms\n \n    --  Note: Asm is missing from this list, since Asm is a legitimate\n    --  convention name. So is To_Adress, which is a GNAT attribute.\n \n-   First_Intrinsic_Name                 : constant Name_Id := N + 574;\n-   Name_Divide                          : constant Name_Id := N + 574;\n-   Name_Enclosing_Entity                : constant Name_Id := N + 575;\n-   Name_Exception_Information           : constant Name_Id := N + 576;\n-   Name_Exception_Message               : constant Name_Id := N + 577;\n-   Name_Exception_Name                  : constant Name_Id := N + 578;\n-   Name_File                            : constant Name_Id := N + 579;\n-   Name_Generic_Dispatching_Constructor : constant Name_Id := N + 580;\n-   Name_Import_Address                  : constant Name_Id := N + 581;\n-   Name_Import_Largest_Value            : constant Name_Id := N + 582;\n-   Name_Import_Value                    : constant Name_Id := N + 583;\n-   Name_Is_Negative                     : constant Name_Id := N + 584;\n-   Name_Line                            : constant Name_Id := N + 585;\n-   Name_Rotate_Left                     : constant Name_Id := N + 586;\n-   Name_Rotate_Right                    : constant Name_Id := N + 587;\n-   Name_Shift_Left                      : constant Name_Id := N + 588;\n-   Name_Shift_Right                     : constant Name_Id := N + 589;\n-   Name_Shift_Right_Arithmetic          : constant Name_Id := N + 590;\n-   Name_Source_Location                 : constant Name_Id := N + 591;\n-   Name_Unchecked_Conversion            : constant Name_Id := N + 592;\n-   Name_Unchecked_Deallocation          : constant Name_Id := N + 593;\n-   Name_To_Pointer                      : constant Name_Id := N + 594;\n-   Last_Intrinsic_Name                  : constant Name_Id := N + 594;\n+   First_Intrinsic_Name                 : constant Name_Id := N + 577;\n+   Name_Divide                          : constant Name_Id := N + 577;\n+   Name_Enclosing_Entity                : constant Name_Id := N + 578;\n+   Name_Exception_Information           : constant Name_Id := N + 579;\n+   Name_Exception_Message               : constant Name_Id := N + 580;\n+   Name_Exception_Name                  : constant Name_Id := N + 581;\n+   Name_File                            : constant Name_Id := N + 582;\n+   Name_Generic_Dispatching_Constructor : constant Name_Id := N + 583;\n+   Name_Import_Address                  : constant Name_Id := N + 584;\n+   Name_Import_Largest_Value            : constant Name_Id := N + 585;\n+   Name_Import_Value                    : constant Name_Id := N + 586;\n+   Name_Is_Negative                     : constant Name_Id := N + 587;\n+   Name_Line                            : constant Name_Id := N + 588;\n+   Name_Rotate_Left                     : constant Name_Id := N + 589;\n+   Name_Rotate_Right                    : constant Name_Id := N + 590;\n+   Name_Shift_Left                      : constant Name_Id := N + 591;\n+   Name_Shift_Right                     : constant Name_Id := N + 592;\n+   Name_Shift_Right_Arithmetic          : constant Name_Id := N + 593;\n+   Name_Source_Location                 : constant Name_Id := N + 594;\n+   Name_Unchecked_Conversion            : constant Name_Id := N + 595;\n+   Name_Unchecked_Deallocation          : constant Name_Id := N + 596;\n+   Name_To_Pointer                      : constant Name_Id := N + 597;\n+   Last_Intrinsic_Name                  : constant Name_Id := N + 597;\n \n    --  Names used in processing intrinsic calls\n \n-   Name_Free                           : constant Name_Id := N + 595;\n+   Name_Free                           : constant Name_Id := N + 598;\n \n    --  Reserved words used only in Ada 95\n \n-   First_95_Reserved_Word              : constant Name_Id := N + 596;\n-   Name_Abstract                       : constant Name_Id := N + 596;\n-   Name_Aliased                        : constant Name_Id := N + 597;\n-   Name_Protected                      : constant Name_Id := N + 598;\n-   Name_Until                          : constant Name_Id := N + 599;\n-   Name_Requeue                        : constant Name_Id := N + 600;\n-   Name_Tagged                         : constant Name_Id := N + 601;\n-   Last_95_Reserved_Word               : constant Name_Id := N + 601;\n+   First_95_Reserved_Word              : constant Name_Id := N + 599;\n+   Name_Abstract                       : constant Name_Id := N + 599;\n+   Name_Aliased                        : constant Name_Id := N + 600;\n+   Name_Protected                      : constant Name_Id := N + 601;\n+   Name_Until                          : constant Name_Id := N + 602;\n+   Name_Requeue                        : constant Name_Id := N + 603;\n+   Name_Tagged                         : constant Name_Id := N + 604;\n+   Last_95_Reserved_Word               : constant Name_Id := N + 604;\n \n    subtype Ada_95_Reserved_Words is\n      Name_Id range First_95_Reserved_Word .. Last_95_Reserved_Word;\n \n    --  Miscellaneous names used in semantic checking\n \n-   Name_Raise_Exception                : constant Name_Id := N + 602;\n+   Name_Raise_Exception                : constant Name_Id := N + 605;\n \n    --  Additional reserved words and identifiers used in GNAT Project Files\n    --  Note that Name_External is already previously declared\n \n-   Name_Ada_Roots                      : constant Name_Id := N + 603;\n-   Name_Archive_Builder                : constant Name_Id := N + 604;\n-   Name_Archive_Indexer                : constant Name_Id := N + 605;\n-   Name_Binder                         : constant Name_Id := N + 606;\n-   Name_Binder_Driver                  : constant Name_Id := N + 607;\n-   Name_Body_Suffix                    : constant Name_Id := N + 608;\n-   Name_Builder                        : constant Name_Id := N + 609;\n-   Name_Compiler                       : constant Name_Id := N + 610;\n-   Name_Compiler_Driver                : constant Name_Id := N + 611;\n-   Name_Compiler_Kind                  : constant Name_Id := N + 612;\n-   Name_Compiler_Pic_Option            : constant Name_Id := N + 613;\n-   Name_Compute_Dependency             : constant Name_Id := N + 614;\n-   Name_Config_Body_File_Name          : constant Name_Id := N + 615;\n-   Name_Config_Body_File_Name_Pattern  : constant Name_Id := N + 616;\n-   Name_Config_File_Switches           : constant Name_Id := N + 617;\n-   Name_Config_File_Unique             : constant Name_Id := N + 618;\n-   Name_Config_Spec_File_Name          : constant Name_Id := N + 619;\n-   Name_Config_Spec_File_Name_Pattern  : constant Name_Id := N + 620;\n-   Name_Cross_Reference                : constant Name_Id := N + 621;\n-   Name_Default_Builder_Switches       : constant Name_Id := N + 622;\n-   Name_Default_Global_Compiler_Switches : constant Name_Id := N + 623;\n-   Name_Default_Language               : constant Name_Id := N + 624;\n-   Name_Default_Linker                 : constant Name_Id := N + 625;\n-   Name_Default_Switches               : constant Name_Id := N + 626;\n-   Name_Dependency_File_Kind           : constant Name_Id := N + 627;\n-   Name_Dependency_Option              : constant Name_Id := N + 628;\n-   Name_Exec_Dir                       : constant Name_Id := N + 629;\n-   Name_Executable                     : constant Name_Id := N + 630;\n-   Name_Executable_Suffix              : constant Name_Id := N + 631;\n-   Name_Extends                        : constant Name_Id := N + 632;\n-   Name_Externally_Built               : constant Name_Id := N + 633;\n-   Name_Finder                         : constant Name_Id := N + 634;\n-   Name_Global_Compiler_Switches       : constant Name_Id := N + 635;\n-   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 636;\n-   Name_Gnatls                         : constant Name_Id := N + 637;\n-   Name_Gnatstub                       : constant Name_Id := N + 638;\n-   Name_Implementation                 : constant Name_Id := N + 639;\n-   Name_Implementation_Exceptions      : constant Name_Id := N + 640;\n-   Name_Implementation_Suffix          : constant Name_Id := N + 641;\n-   Name_Include_Option                 : constant Name_Id := N + 642;\n-   Name_Include_Path                   : constant Name_Id := N + 643;\n-   Name_Include_Path_File              : constant Name_Id := N + 644;\n-   Name_Language_Kind                  : constant Name_Id := N + 645;\n-   Name_Language_Processing            : constant Name_Id := N + 646;\n-   Name_Languages                      : constant Name_Id := N + 647;\n-   Name_Library_Ali_Dir                : constant Name_Id := N + 648;\n-   Name_Library_Dir                    : constant Name_Id := N + 649;\n-   Name_Library_Auto_Init              : constant Name_Id := N + 650;\n-   Name_Library_GCC                    : constant Name_Id := N + 651;\n-   Name_Library_Interface              : constant Name_Id := N + 652;\n-   Name_Library_Kind                   : constant Name_Id := N + 653;\n-   Name_Library_Name                   : constant Name_Id := N + 654;\n-   Name_Library_Options                : constant Name_Id := N + 655;\n-   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 656;\n-   Name_Library_Src_Dir                : constant Name_Id := N + 657;\n-   Name_Library_Symbol_File            : constant Name_Id := N + 658;\n-   Name_Library_Symbol_Policy          : constant Name_Id := N + 659;\n-   Name_Library_Version                : constant Name_Id := N + 660;\n-   Name_Linker                         : constant Name_Id := N + 661;\n-   Name_Linker_Executable_Option       : constant Name_Id := N + 662;\n-   Name_Linker_Lib_Dir_Option          : constant Name_Id := N + 663;\n-   Name_Linker_Lib_Name_Option         : constant Name_Id := N + 664;\n-   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 665;\n-   Name_Locally_Removed_Files          : constant Name_Id := N + 666;\n-   Name_Mapping_File_Switches          : constant Name_Id := N + 667;\n-   Name_Metrics                        : constant Name_Id := N + 668;\n-   Name_Naming                         : constant Name_Id := N + 669;\n-   Name_Object_Dir                     : constant Name_Id := N + 670;\n-   Name_Pretty_Printer                 : constant Name_Id := N + 671;\n-   Name_Project                        : constant Name_Id := N + 672;\n-   Name_Roots                          : constant Name_Id := N + 673;\n-   Name_Runtime_Project                : constant Name_Id := N + 674;\n-   Name_Separate_Suffix                : constant Name_Id := N + 675;\n-   Name_Source_Dirs                    : constant Name_Id := N + 676;\n-   Name_Source_Files                   : constant Name_Id := N + 677;\n-   Name_Source_List_File               : constant Name_Id := N + 678;\n-   Name_Spec                           : constant Name_Id := N + 679;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 680;\n-   Name_Specification                  : constant Name_Id := N + 681;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 682;\n-   Name_Specification_Suffix           : constant Name_Id := N + 683;\n-   Name_Switches                       : constant Name_Id := N + 684;\n+   Name_Ada_Roots                      : constant Name_Id := N + 606;\n+   Name_Archive_Builder                : constant Name_Id := N + 607;\n+   Name_Archive_Indexer                : constant Name_Id := N + 608;\n+   Name_Archive_Suffix                 : constant Name_Id := N + 609;\n+   Name_Binder                         : constant Name_Id := N + 610;\n+   Name_Binder_Driver                  : constant Name_Id := N + 611;\n+   Name_Body_Suffix                    : constant Name_Id := N + 612;\n+   Name_Builder                        : constant Name_Id := N + 613;\n+   Name_Builder_Switches               : constant Name_Id := N + 614;\n+   Name_Compiler                       : constant Name_Id := N + 615;\n+   Name_Compiler_Driver                : constant Name_Id := N + 616;\n+   Name_Compiler_Kind                  : constant Name_Id := N + 617;\n+   Name_Compiler_Minimum_Options       : constant Name_Id := N + 618;\n+   Name_Compiler_Pic_Option            : constant Name_Id := N + 619;\n+   Name_Compute_Dependency             : constant Name_Id := N + 620;\n+   Name_Config_Body_File_Name          : constant Name_Id := N + 621;\n+   Name_Config_Body_File_Name_Pattern  : constant Name_Id := N + 622;\n+   Name_Config_File_Switches           : constant Name_Id := N + 623;\n+   Name_Config_File_Unique             : constant Name_Id := N + 624;\n+   Name_Config_Spec_File_Name          : constant Name_Id := N + 625;\n+   Name_Config_Spec_File_Name_Pattern  : constant Name_Id := N + 626;\n+   Name_Cross_Reference                : constant Name_Id := N + 627;\n+   Name_Default_Builder_Switches       : constant Name_Id := N + 628;\n+   Name_Default_Global_Compiler_Switches : constant Name_Id := N + 629;\n+   Name_Default_Language               : constant Name_Id := N + 630;\n+   Name_Default_Linker                 : constant Name_Id := N + 631;\n+   Name_Default_Switches               : constant Name_Id := N + 632;\n+   Name_Dependency_File_Kind           : constant Name_Id := N + 633;\n+   Name_Dependency_Option              : constant Name_Id := N + 634;\n+   Name_Exec_Dir                       : constant Name_Id := N + 635;\n+   Name_Executable                     : constant Name_Id := N + 636;\n+   Name_Executable_Suffix              : constant Name_Id := N + 637;\n+   Name_Extends                        : constant Name_Id := N + 638;\n+   Name_Externally_Built               : constant Name_Id := N + 639;\n+   Name_Finder                         : constant Name_Id := N + 640;\n+   Name_Global_Compiler_Switches       : constant Name_Id := N + 641;\n+   Name_Global_Configuration_Pragmas   : constant Name_Id := N + 642;\n+   Name_Global_Config_File             : constant Name_Id := N + 643;\n+   Name_Gnatls                         : constant Name_Id := N + 644;\n+   Name_Gnatstub                       : constant Name_Id := N + 645;\n+   Name_Implementation                 : constant Name_Id := N + 646;\n+   Name_Implementation_Exceptions      : constant Name_Id := N + 647;\n+   Name_Implementation_Suffix          : constant Name_Id := N + 648;\n+   Name_Include_Option                 : constant Name_Id := N + 649;\n+   Name_Include_Path                   : constant Name_Id := N + 650;\n+   Name_Include_Path_File              : constant Name_Id := N + 651;\n+   Name_Language_Kind                  : constant Name_Id := N + 652;\n+   Name_Language_Processing            : constant Name_Id := N + 653;\n+   Name_Languages                      : constant Name_Id := N + 654;\n+   Name_Library_Ali_Dir                : constant Name_Id := N + 655;\n+   Name_Library_Auto_Init              : constant Name_Id := N + 656;\n+   Name_Library_Auto_Init_Supported    : constant Name_Id := N + 657;\n+   Name_Library_Builder                : constant Name_Id := N + 658;\n+   Name_Library_Dir                    : constant Name_Id := N + 659;\n+   Name_Library_GCC                    : constant Name_Id := N + 660;\n+   Name_Library_Interface              : constant Name_Id := N + 661;\n+   Name_Library_Kind                   : constant Name_Id := N + 662;\n+   Name_Library_Name                   : constant Name_Id := N + 663;\n+   Name_Library_Major_Minor_Id_Supported : constant Name_Id := N + 664;\n+   Name_Library_Options                : constant Name_Id := N + 665;\n+   Name_Library_Reference_Symbol_File  : constant Name_Id := N + 666;\n+   Name_Library_Src_Dir                : constant Name_Id := N + 667;\n+   Name_Library_Support                : constant Name_Id := N + 668;\n+   Name_Library_Symbol_File            : constant Name_Id := N + 669;\n+   Name_Library_Symbol_Policy          : constant Name_Id := N + 670;\n+   Name_Library_Version                : constant Name_Id := N + 671;\n+   Name_Library_Version_Options        : constant Name_Id := N + 672;\n+   Name_Linker                         : constant Name_Id := N + 673;\n+   Name_Linker_Executable_Option       : constant Name_Id := N + 674;\n+   Name_Linker_Lib_Dir_Option          : constant Name_Id := N + 675;\n+   Name_Linker_Lib_Name_Option         : constant Name_Id := N + 676;\n+   Name_Local_Config_File              : constant Name_Id := N + 677;\n+   Name_Local_Configuration_Pragmas    : constant Name_Id := N + 678;\n+   Name_Locally_Removed_Files          : constant Name_Id := N + 679;\n+   Name_Mapping_File_Switches          : constant Name_Id := N + 680;\n+   Name_Mapping_Spec_Suffix            : constant Name_Id := N + 681;\n+   Name_Mapping_Body_Suffix            : constant Name_Id := N + 682;\n+   Name_Metrics                        : constant Name_Id := N + 683;\n+   Name_Minimum_Binder_Options         : constant Name_Id := N + 684;\n+   Name_Naming                         : constant Name_Id := N + 685;\n+   Name_Objects_Path                   : constant Name_Id := N + 686;\n+   Name_Objects_Path_File              : constant Name_Id := N + 687;\n+   Name_Object_Dir                     : constant Name_Id := N + 688;\n+   Name_Pretty_Printer                 : constant Name_Id := N + 689;\n+   Name_Project                        : constant Name_Id := N + 690;\n+   Name_Roots                          : constant Name_Id := N + 691;\n+   Name_Run_Path_Option                : constant Name_Id := N + 692;\n+   Name_Runtime_Project                : constant Name_Id := N + 693;\n+   Name_Shared_Library_Minimum_Options : constant Name_Id := N + 694;\n+   Name_Shared_Library_Prefix          : constant Name_Id := N + 695;\n+   Name_Shared_Library_Suffix          : constant Name_Id := N + 696;\n+   Name_Separate_Suffix                : constant Name_Id := N + 697;\n+   Name_Source_Dirs                    : constant Name_Id := N + 698;\n+   Name_Source_Files                   : constant Name_Id := N + 699;\n+   Name_Source_List_File               : constant Name_Id := N + 700;\n+   Name_Spec                           : constant Name_Id := N + 701;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 702;\n+   Name_Specification                  : constant Name_Id := N + 703;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 704;\n+   Name_Specification_Suffix           : constant Name_Id := N + 705;\n+   Name_Stack                          : constant Name_Id := N + 706;\n+   Name_Switches                       : constant Name_Id := N + 707;\n+   Name_Symbolic_Link_Supported        : constant Name_Id := N + 708;\n+   Name_Toolchain_Version              : constant Name_Id := N + 709;\n \n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 685;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 710;\n \n    --  Ada 2005 reserved words\n \n-   First_2005_Reserved_Word            : constant Name_Id := N + 686;\n-   Name_Interface                      : constant Name_Id := N + 686;\n-   Name_Overriding                     : constant Name_Id := N + 687;\n-   Name_Synchronized                   : constant Name_Id := N + 688;\n-   Last_2005_Reserved_Word             : constant Name_Id := N + 688;\n+   First_2005_Reserved_Word            : constant Name_Id := N + 711;\n+   Name_Interface                      : constant Name_Id := N + 711;\n+   Name_Overriding                     : constant Name_Id := N + 712;\n+   Name_Synchronized                   : constant Name_Id := N + 713;\n+   Last_2005_Reserved_Word             : constant Name_Id := N + 713;\n \n    subtype Ada_2005_Reserved_Words is\n      Name_Id range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 688;\n+   Last_Predefined_Name                : constant Name_Id := N + 713;\n \n    ---------------------------------------\n    -- Subtypes Defining Name Categories --\n@@ -1299,6 +1327,7 @@ package Snames is\n       Pragma_Ada_2005,\n       Pragma_Assertion_Policy,\n       Pragma_C_Pass_By_Copy,\n+      Pragma_Compile_Time_Error,\n       Pragma_Compile_Time_Warning,\n       Pragma_Component_Alignment,\n       Pragma_Convention_Identifier,\n@@ -1441,6 +1470,7 @@ package Snames is\n       Pragma_Unchecked_Union,\n       Pragma_Unimplemented_Unit,\n       Pragma_Unreferenced,\n+      Pragma_Unreferenced_Objects,\n       Pragma_Unreserve_All_Interrupts,\n       Pragma_Volatile,\n       Pragma_Volatile_Components,"}, {"sha": "98f079ea9a0f0d125c27c8950151dfd662202d60", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 150, "deletions": 148, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -220,153 +220,155 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Ada_2005                      3\n #define  Pragma_Assertion_Policy              4\n #define  Pragma_C_Pass_By_Copy                5\n-#define  Pragma_Compile_Time_Warning          6\n-#define  Pragma_Component_Alignment           7\n-#define  Pragma_Convention_Identifier         8\n-#define  Pragma_Debug_Policy                  9\n-#define  Pragma_Detect_Blocking               10\n-#define  Pragma_Discard_Names                 11\n-#define  Pragma_Elaboration_Checks            12\n-#define  Pragma_Eliminate                     13\n-#define  Pragma_Explicit_Overriding           14\n-#define  Pragma_Extend_System                 15\n-#define  Pragma_Extensions_Allowed            16\n-#define  Pragma_External_Name_Casing          17\n-#define  Pragma_Float_Representation          18\n-#define  Pragma_Initialize_Scalars            19\n-#define  Pragma_Interrupt_State               20\n-#define  Pragma_License                       21\n-#define  Pragma_Locking_Policy                22\n-#define  Pragma_Long_Float                    23\n-#define  Pragma_No_Run_Time                   24\n-#define  Pragma_No_Strict_Aliasing            25\n-#define  Pragma_Normalize_Scalars             26\n-#define  Pragma_Polling                       27\n-#define  Pragma_Persistent_BSS                28\n-#define  Pragma_Priority_Specific_Dispatching 29\n-#define  Pragma_Profile                       30\n-#define  Pragma_Profile_Warnings              31\n-#define  Pragma_Propagate_Exceptions          32\n-#define  Pragma_Queuing_Policy                33\n-#define  Pragma_Ravenscar                     34\n-#define  Pragma_Restricted_Run_Time           35\n-#define  Pragma_Restrictions                  36\n-#define  Pragma_Restriction_Warnings          37\n-#define  Pragma_Reviewable                    38\n-#define  Pragma_Source_File_Name              39\n-#define  Pragma_Source_File_Name_Project      40\n-#define  Pragma_Style_Checks                  41\n-#define  Pragma_Suppress                      42\n-#define  Pragma_Suppress_Exception_Locations  43\n-#define  Pragma_Task_Dispatching_Policy       44\n-#define  Pragma_Universal_Data                45\n-#define  Pragma_Unsuppress                    46\n-#define  Pragma_Use_VADS_Size                 47\n-#define  Pragma_Validity_Checks               48\n-#define  Pragma_Warnings                      49\n-#define  Pragma_Wide_Character_Encoding       50\n-#define  Pragma_Abort_Defer                   51\n-#define  Pragma_All_Calls_Remote              52\n-#define  Pragma_Annotate                      53\n-#define  Pragma_Assert                        54\n-#define  Pragma_Asynchronous                  55\n-#define  Pragma_Atomic                        56\n-#define  Pragma_Atomic_Components             57\n-#define  Pragma_Attach_Handler                58\n-#define  Pragma_Comment                       59\n-#define  Pragma_Common_Object                 60\n-#define  Pragma_Complete_Representation       61\n-#define  Pragma_Complex_Representation        62\n-#define  Pragma_Controlled                    63\n-#define  Pragma_Convention                    64\n-#define  Pragma_CPP_Class                     65\n-#define  Pragma_CPP_Constructor               66\n-#define  Pragma_CPP_Virtual                   67\n-#define  Pragma_CPP_Vtable                    68\n-#define  Pragma_Debug                         69\n-#define  Pragma_Elaborate                     70\n-#define  Pragma_Elaborate_All                 71\n-#define  Pragma_Elaborate_Body                72\n-#define  Pragma_Export                        73\n-#define  Pragma_Export_Exception              74\n-#define  Pragma_Export_Function               75\n-#define  Pragma_Export_Object                 76\n-#define  Pragma_Export_Procedure              77\n-#define  Pragma_Export_Value                  78\n-#define  Pragma_Export_Valued_Procedure       79\n-#define  Pragma_External                      80\n-#define  Pragma_Finalize_Storage_Only         81\n-#define  Pragma_Ident                         82\n-#define  Pragma_Import                        83\n-#define  Pragma_Import_Exception              84\n-#define  Pragma_Import_Function               85\n-#define  Pragma_Import_Object                 86\n-#define  Pragma_Import_Procedure              87\n-#define  Pragma_Import_Valued_Procedure       88\n-#define  Pragma_Inline                        89\n-#define  Pragma_Inline_Always                 90\n-#define  Pragma_Inline_Generic                91\n-#define  Pragma_Inspection_Point              92\n-#define  Pragma_Interface_Name                93\n-#define  Pragma_Interrupt_Handler             94\n-#define  Pragma_Interrupt_Priority            95\n-#define  Pragma_Java_Constructor              96\n-#define  Pragma_Java_Interface                97\n-#define  Pragma_Keep_Names                    98\n-#define  Pragma_Link_With                     99\n-#define  Pragma_Linker_Alias                  100\n-#define  Pragma_Linker_Constructor            101\n-#define  Pragma_Linker_Destructor             102\n-#define  Pragma_Linker_Options                103\n-#define  Pragma_Linker_Section                104\n-#define  Pragma_List                          105\n-#define  Pragma_Machine_Attribute             106\n-#define  Pragma_Main                          107\n-#define  Pragma_Main_Storage                  108\n-#define  Pragma_Memory_Size                   109\n-#define  Pragma_No_Return                     110\n-#define  Pragma_Obsolescent                   111\n-#define  Pragma_Optimize                      112\n-#define  Pragma_Optional_Overriding           113\n-#define  Pragma_Pack                          114\n-#define  Pragma_Page                          115\n-#define  Pragma_Passive                       116\n-#define  Pragma_Preelaborable_Initialization  117\n-#define  Pragma_Preelaborate                  118\n-#define  Pragma_Preelaborate_05               119\n-#define  Pragma_Psect_Object                  120\n-#define  Pragma_Pure                          121\n-#define  Pragma_Pure_05                       122\n-#define  Pragma_Pure_Function                 123\n-#define  Pragma_Remote_Call_Interface         124\n-#define  Pragma_Remote_Types                  125\n-#define  Pragma_Share_Generic                 126\n-#define  Pragma_Shared                        127\n-#define  Pragma_Shared_Passive                128\n-#define  Pragma_Source_Reference              129\n-#define  Pragma_Stream_Convert                130\n-#define  Pragma_Subtitle                      131\n-#define  Pragma_Suppress_All                  132\n-#define  Pragma_Suppress_Debug_Info           133\n-#define  Pragma_Suppress_Initialization       134\n-#define  Pragma_System_Name                   135\n-#define  Pragma_Task_Info                     136\n-#define  Pragma_Task_Name                     137\n-#define  Pragma_Task_Storage                  138\n-#define  Pragma_Thread_Body                   139\n-#define  Pragma_Time_Slice                    140\n-#define  Pragma_Title                         141\n-#define  Pragma_Unchecked_Union               142\n-#define  Pragma_Unimplemented_Unit            143\n-#define  Pragma_Unreferenced                  144\n-#define  Pragma_Unreserve_All_Interrupts      145\n-#define  Pragma_Volatile                      146\n-#define  Pragma_Volatile_Components           147\n-#define  Pragma_Weak_External                 148\n-#define  Pragma_AST_Entry                     149\n-#define  Pragma_Interface                     150\n-#define  Pragma_Priority                      151\n-#define  Pragma_Storage_Size                  152\n-#define  Pragma_Storage_Unit                  153\n+#define  Pragma_Compile_Time_Error            6\n+#define  Pragma_Compile_Time_Warning          7\n+#define  Pragma_Component_Alignment           8\n+#define  Pragma_Convention_Identifier         9\n+#define  Pragma_Debug_Policy                  10\n+#define  Pragma_Detect_Blocking               11\n+#define  Pragma_Discard_Names                 12\n+#define  Pragma_Elaboration_Checks            13\n+#define  Pragma_Eliminate                     14\n+#define  Pragma_Explicit_Overriding           15\n+#define  Pragma_Extend_System                 16\n+#define  Pragma_Extensions_Allowed            17\n+#define  Pragma_External_Name_Casing          18\n+#define  Pragma_Float_Representation          19\n+#define  Pragma_Initialize_Scalars            20\n+#define  Pragma_Interrupt_State               21\n+#define  Pragma_License                       22\n+#define  Pragma_Locking_Policy                23\n+#define  Pragma_Long_Float                    24\n+#define  Pragma_No_Run_Time                   25\n+#define  Pragma_No_Strict_Aliasing            26\n+#define  Pragma_Normalize_Scalars             27\n+#define  Pragma_Polling                       28\n+#define  Pragma_Persistent_BSS                29\n+#define  Pragma_Priority_Specific_Dispatching 30\n+#define  Pragma_Profile                       31\n+#define  Pragma_Profile_Warnings              32\n+#define  Pragma_Propagate_Exceptions          33\n+#define  Pragma_Queuing_Policy                34\n+#define  Pragma_Ravenscar                     35\n+#define  Pragma_Restricted_Run_Time           36\n+#define  Pragma_Restrictions                  37\n+#define  Pragma_Restriction_Warnings          38\n+#define  Pragma_Reviewable                    39\n+#define  Pragma_Source_File_Name              40\n+#define  Pragma_Source_File_Name_Project      41\n+#define  Pragma_Style_Checks                  42\n+#define  Pragma_Suppress                      43\n+#define  Pragma_Suppress_Exception_Locations  44\n+#define  Pragma_Task_Dispatching_Policy       45\n+#define  Pragma_Universal_Data                46\n+#define  Pragma_Unsuppress                    47\n+#define  Pragma_Use_VADS_Size                 48\n+#define  Pragma_Validity_Checks               49\n+#define  Pragma_Warnings                      50\n+#define  Pragma_Wide_Character_Encoding       51\n+#define  Pragma_Abort_Defer                   52\n+#define  Pragma_All_Calls_Remote              53\n+#define  Pragma_Annotate                      54\n+#define  Pragma_Assert                        55\n+#define  Pragma_Asynchronous                  56\n+#define  Pragma_Atomic                        57\n+#define  Pragma_Atomic_Components             58\n+#define  Pragma_Attach_Handler                59\n+#define  Pragma_Comment                       60\n+#define  Pragma_Common_Object                 61\n+#define  Pragma_Complete_Representation       62\n+#define  Pragma_Complex_Representation        63\n+#define  Pragma_Controlled                    64\n+#define  Pragma_Convention                    65\n+#define  Pragma_CPP_Class                     66\n+#define  Pragma_CPP_Constructor               67\n+#define  Pragma_CPP_Virtual                   68\n+#define  Pragma_CPP_Vtable                    69\n+#define  Pragma_Debug                         70\n+#define  Pragma_Elaborate                     71\n+#define  Pragma_Elaborate_All                 72\n+#define  Pragma_Elaborate_Body                73\n+#define  Pragma_Export                        74\n+#define  Pragma_Export_Exception              75\n+#define  Pragma_Export_Function               76\n+#define  Pragma_Export_Object                 77\n+#define  Pragma_Export_Procedure              78\n+#define  Pragma_Export_Value                  79\n+#define  Pragma_Export_Valued_Procedure       80\n+#define  Pragma_External                      81\n+#define  Pragma_Finalize_Storage_Only         82\n+#define  Pragma_Ident                         83\n+#define  Pragma_Import                        84\n+#define  Pragma_Import_Exception              85\n+#define  Pragma_Import_Function               86\n+#define  Pragma_Import_Object                 87\n+#define  Pragma_Import_Procedure              88\n+#define  Pragma_Import_Valued_Procedure       89\n+#define  Pragma_Inline                        90\n+#define  Pragma_Inline_Always                 91\n+#define  Pragma_Inline_Generic                92\n+#define  Pragma_Inspection_Point              93\n+#define  Pragma_Interface_Name                94\n+#define  Pragma_Interrupt_Handler             95\n+#define  Pragma_Interrupt_Priority            96\n+#define  Pragma_Java_Constructor              97\n+#define  Pragma_Java_Interface                98\n+#define  Pragma_Keep_Names                    99\n+#define  Pragma_Link_With                     100\n+#define  Pragma_Linker_Alias                  101\n+#define  Pragma_Linker_Constructor            102\n+#define  Pragma_Linker_Destructor             103\n+#define  Pragma_Linker_Options                104\n+#define  Pragma_Linker_Section                105\n+#define  Pragma_List                          106\n+#define  Pragma_Machine_Attribute             107\n+#define  Pragma_Main                          108\n+#define  Pragma_Main_Storage                  109\n+#define  Pragma_Memory_Size                   110\n+#define  Pragma_No_Return                     111\n+#define  Pragma_Obsolescent                   112\n+#define  Pragma_Optimize                      113\n+#define  Pragma_Optional_Overriding           114\n+#define  Pragma_Pack                          115\n+#define  Pragma_Page                          116\n+#define  Pragma_Passive                       117\n+#define  Pragma_Preelaborable_Initialization  118\n+#define  Pragma_Preelaborate                  119\n+#define  Pragma_Preelaborate_05               120\n+#define  Pragma_Psect_Object                  121\n+#define  Pragma_Pure                          122\n+#define  Pragma_Pure_05                       123\n+#define  Pragma_Pure_Function                 124\n+#define  Pragma_Remote_Call_Interface         125\n+#define  Pragma_Remote_Types                  126\n+#define  Pragma_Share_Generic                 127\n+#define  Pragma_Shared                        128\n+#define  Pragma_Shared_Passive                129\n+#define  Pragma_Source_Reference              130\n+#define  Pragma_Stream_Convert                131\n+#define  Pragma_Subtitle                      132\n+#define  Pragma_Suppress_All                  133\n+#define  Pragma_Suppress_Debug_Info           134\n+#define  Pragma_Suppress_Initialization       135\n+#define  Pragma_System_Name                   136\n+#define  Pragma_Task_Info                     137\n+#define  Pragma_Task_Name                     138\n+#define  Pragma_Task_Storage                  139\n+#define  Pragma_Thread_Body                   140\n+#define  Pragma_Time_Slice                    141\n+#define  Pragma_Title                         142\n+#define  Pragma_Unchecked_Union               143\n+#define  Pragma_Unimplemented_Unit            144\n+#define  Pragma_Unreferenced                  145\n+#define  Pragma_Unreferenced_Objects          146\n+#define  Pragma_Unreserve_All_Interrupts      147\n+#define  Pragma_Volatile                      148\n+#define  Pragma_Volatile_Components           149\n+#define  Pragma_Weak_External                 150\n+#define  Pragma_AST_Entry                     151\n+#define  Pragma_Interface                     152\n+#define  Pragma_Priority                      153\n+#define  Pragma_Storage_Size                  154\n+#define  Pragma_Storage_Unit                  155\n \n /* End of snames.h (C version of Snames package spec) */"}, {"sha": "fbc0e8f44df86442acfbd60fffdb8fada0c00a91", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 147, "deletions": 171, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/874a0341c8306d74db689405040a4bc4f550085a/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=874a0341c8306d74db689405040a4bc4f550085a", "patch": "@@ -24,8 +24,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-\n with Debug;    use Debug;\n with Lib;      use Lib;\n with Osint;    use Osint;\n@@ -35,6 +33,8 @@ with Validsw;  use Validsw;\n with Sem_Warn; use Sem_Warn;\n with Stylesw;  use Stylesw;\n \n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n with System.WCh_Con; use System.WCh_Con;\n \n package body Switch.C is\n@@ -47,24 +47,29 @@ package body Switch.C is\n    -----------------------------\n \n    procedure Scan_Front_End_Switches (Switch_Chars : String) is\n-      Switch_Starts_With_Gnat : Boolean;\n-      --  True if first four switch characters are \"gnat\"\n-\n       First_Switch : Boolean := True;\n       --  False for all but first switch\n \n-      Ptr : Integer := Switch_Chars'First;\n-      Max : constant Integer := Switch_Chars'Last;\n+      Max : constant Natural := Switch_Chars'Last;\n+      Ptr : Natural;\n       C   : Character := ' ';\n       Dot : Boolean;\n \n-      Store_Switch : Boolean  := True;\n-      First_Char   : Integer  := Ptr;\n-      Storing      : String   := Switch_Chars;\n-      First_Stored : Positive := Ptr + 1;\n-      --  The above need comments ???\n+      Store_Switch : Boolean;\n+      --  For -gnatxx switches, the normal processing, signalled by this flag\n+      --  being set to True, is to store the switch on exit from the case\n+      --  statement, the switch stored is -gnat followed by the characters\n+      --  from First_Char to Ptr-1. For cases like -gnaty, where the switch\n+      --  is stored in separate pieces, this flag is set to False, and the\n+      --  appropriate calls to Store_Compilation_Switch are made from within\n+      --  the case branch.\n+\n+      First_Char : Positive;\n+      --  Marks start of switch to be stored\n \n    begin\n+      Ptr := Switch_Chars'First;\n+\n       --  Skip past the initial character (must be the switch character)\n \n       if Ptr = Max then\n@@ -73,123 +78,120 @@ package body Switch.C is\n          Ptr := Ptr + 1;\n       end if;\n \n-      --  Remove \"gnat\" from the switch, if present\n+      --  Handle switches that do not start with -gnat\n \n-      Switch_Starts_With_Gnat :=\n-        Ptr + 3 <= Max and then Switch_Chars (Ptr .. Ptr + 3) = \"gnat\";\n+      if Ptr + 3 > Max\n+        or else Switch_Chars (Ptr .. Ptr + 3) /= \"gnat\"\n+      then\n+         --  There are two front-end switches that do not start with -gnat:\n+         --  -I, --RTS\n \n-      if Switch_Starts_With_Gnat then\n-         Ptr := Ptr + 4;\n-         First_Stored := Ptr;\n-      end if;\n+         if Switch_Chars (Ptr) = 'I' then\n \n-      --  Loop to scan through switches given in switch string\n+            --  Set flag Search_Directory_Present if switch is \"-I\" only:\n+            --  the directory will be the next argument.\n \n-      while Ptr <= Max loop\n-         Store_Switch := True;\n-         First_Char := Ptr;\n-         C := Switch_Chars (Ptr);\n+            if Ptr = Max then\n+               Search_Directory_Present := True;\n+               return;\n+            end if;\n \n-         --  Processing for a switch\n+            Ptr := Ptr + 1;\n \n-         case Switch_Starts_With_Gnat is\n+            --  Find out whether this is a -I- or regular -Ixxx switch\n \n-            when False =>\n+            --  Note: -I switches are not recorded in the ALI file, since the\n+            --  meaning of the program depends on the source files compiled,\n+            --  not where they came from.\n \n-            --  There are few front-end switches that\n-            --  do not start with -gnat: -I, --RTS\n+            if Ptr = Max and then Switch_Chars (Ptr) = '-' then\n+               Look_In_Primary_Dir := False;\n+            else\n+               Add_Src_Search_Dir (Switch_Chars (Ptr .. Max));\n+            end if;\n \n-               if Switch_Chars (Ptr) = 'I' then\n-                  Store_Switch := False;\n+         --  Processing of the --RTS switch. --RTS has been modified by\n+         --  gcc and is now of the form -fRTS.\n \n-                  --  Set flag Search_Directory_Present if switch is \"-I\" only:\n-                  --  the directory will be the next argument.\n+         elsif Ptr + 3 <= Max\n+           and then Switch_Chars (Ptr .. Ptr + 3) = \"fRTS\"\n+         then\n+            Ptr := Ptr + 1;\n \n-                  if Ptr = Max then\n-                     Search_Directory_Present := True;\n-                     return;\n-                  end if;\n+            if Ptr + 4 > Max\n+              or else Switch_Chars (Ptr + 3) /= '='\n+            then\n+               Osint.Fail (\"missing path for --RTS\");\n+            else\n+               --  Check that this is the first time --RTS is specified or if\n+               --  it is not the first time, the same path has been specified.\n \n-                  Ptr := Ptr + 1;\n+               if RTS_Specified = null then\n+                  RTS_Specified :=\n+                    new String'(Switch_Chars (Ptr + 4 .. Max));\n \n-                  --  Find out whether this is a -I- or regular -Ixxx switch\n+               elsif\n+                 RTS_Specified.all /= Switch_Chars (Ptr + 4 .. Max)\n+               then\n+                  Osint.Fail\n+                    (\"--RTS cannot be specified multiple times\");\n+               end if;\n \n-                  if Ptr = Max and then Switch_Chars (Ptr) = '-' then\n-                     Look_In_Primary_Dir := False;\n+               --  Valid --RTS switch\n \n-                  else\n-                     Add_Src_Search_Dir (Switch_Chars (Ptr .. Max));\n-                  end if;\n+               Opt.No_Stdinc := True;\n+               Opt.RTS_Switch := True;\n \n-                  Ptr := Max + 1;\n+               RTS_Src_Path_Name :=\n+                 Get_RTS_Search_Dir\n+                   (Switch_Chars (Ptr + 4 .. Max), Include);\n \n-               --  Processing of the --RTS switch. --RTS has been modified by\n-               --  gcc and is now of the form -fRTS\n+               RTS_Lib_Path_Name :=\n+                 Get_RTS_Search_Dir\n+                   (Switch_Chars (Ptr + 4 .. Max), Objects);\n \n-               elsif Ptr + 3 <= Max\n-                 and then Switch_Chars (Ptr .. Ptr + 3) = \"fRTS\"\n+               if RTS_Src_Path_Name /= null\n+                 and then RTS_Lib_Path_Name /= null\n                then\n-                  Ptr := Ptr + 1;\n-\n-                  if Ptr + 4 > Max\n-                    or else Switch_Chars (Ptr + 3) /= '='\n-                  then\n-                     Osint.Fail (\"missing path for --RTS\");\n-                  else\n-                     --  Check that this is the first time --RTS is specified\n-                     --  or if it is not the first time, the same path has\n-                     --  been specified.\n+                  --  Store the -fRTS switch (Note: Store_Compilation_Switch\n+                  --  changes -fRTS back into --RTS for the actual output).\n \n-                     if RTS_Specified = null then\n-                        RTS_Specified :=\n-                          new String'(Switch_Chars (Ptr + 4 .. Max));\n+                  Store_Compilation_Switch (Switch_Chars);\n \n-                     elsif\n-                       RTS_Specified.all /= Switch_Chars (Ptr + 4 .. Max)\n-                     then\n-                        Osint.Fail\n-                          (\"--RTS cannot be specified multiple times\");\n-                     end if;\n+               elsif RTS_Src_Path_Name = null\n+                 and then RTS_Lib_Path_Name = null\n+               then\n+                  Osint.Fail (\"RTS path not valid: missing \" &\n+                              \"adainclude and adalib directories\");\n \n-                     --  Valid --RTS switch\n+               elsif RTS_Src_Path_Name = null then\n+                  Osint.Fail (\"RTS path not valid: missing \" &\n+                              \"adainclude directory\");\n \n-                     Opt.No_Stdinc := True;\n-                     Opt.RTS_Switch := True;\n+               elsif RTS_Lib_Path_Name = null then\n+                  Osint.Fail (\"RTS path not valid: missing \" &\n+                              \"adalib directory\");\n+               end if;\n+            end if;\n \n-                     RTS_Src_Path_Name := Get_RTS_Search_Dir\n-                                            (Switch_Chars (Ptr + 4 .. Max),\n-                                             Include);\n-                     RTS_Lib_Path_Name := Get_RTS_Search_Dir\n-                                            (Switch_Chars (Ptr + 4 .. Max),\n-                                             Objects);\n+            --  There are no other switches not starting with -gnat\n \n-                     if RTS_Src_Path_Name /= null and then\n-                        RTS_Lib_Path_Name /= null\n-                     then\n-                        Ptr := Max + 1;\n+         else\n+            Bad_Switch (C);\n+         end if;\n \n-                     elsif RTS_Src_Path_Name = null and then\n-                           RTS_Lib_Path_Name = null\n-                     then\n-                        Osint.Fail (\"RTS path not valid: missing \" &\n-                                    \"adainclude and adalib directories\");\n+      --  Case of switch starting with -gnat\n \n-                     elsif RTS_Src_Path_Name = null then\n-                        Osint.Fail (\"RTS path not valid: missing \" &\n-                                    \"adainclude directory\");\n+      else\n+         Ptr := Ptr + 4;\n \n-                     elsif RTS_Lib_Path_Name = null then\n-                        Osint.Fail (\"RTS path not valid: missing \" &\n-                                    \"adalib directory\");\n-                     end if;\n-                  end if;\n-               else\n-                  Bad_Switch (C);\n-               end if;\n+         --  Loop to scan through switches given in switch string\n \n-         when True =>\n+         while Ptr <= Max loop\n+            First_Char := Ptr;\n+            Store_Switch := True;\n \n-            --  Process -gnat* options\n+            C := Switch_Chars (Ptr);\n \n             case C is\n \n@@ -229,7 +231,6 @@ package body Switch.C is\n \n             when 'd' =>\n                Store_Switch := False;\n-               Storing (First_Stored) := 'd';\n                Dot := False;\n \n                --  Note: for the debug switch, the remaining characters in this\n@@ -249,17 +250,10 @@ package body Switch.C is\n                   then\n                      if Dot then\n                         Set_Dotted_Debug_Flag (C);\n-                        Storing (First_Stored + 1) := '.';\n-                        Storing (First_Stored + 2) := C;\n-                        Store_Compilation_Switch\n-                          (Storing (Storing'First .. First_Stored + 2));\n-                        Dot := False;\n-\n+                        Store_Compilation_Switch (\"-gnatd.\" & C);\n                      else\n                         Set_Debug_Flag (C);\n-                        Storing (First_Stored + 1) := C;\n-                        Store_Compilation_Switch\n-                          (Storing (Storing'First .. First_Stored + 1));\n+                        Store_Compilation_Switch (\"-gnatd\" & C);\n                      end if;\n \n                   elsif C = '.' then\n@@ -349,7 +343,7 @@ package body Switch.C is\n \n                      return;\n \n-                  --  -gnateD switch (symbol definition)\n+                  --  -gnateD switch (preprocessing symbol definition)\n \n                   when 'D' =>\n                      Store_Switch := False;\n@@ -363,13 +357,9 @@ package body Switch.C is\n \n                      --  Store the switch\n \n-                     Storing (First_Stored .. First_Stored + 1) := \"eD\";\n-                     Storing\n-                       (First_Stored + 2 .. First_Stored + Max - Ptr + 2) :=\n-                       Switch_Chars (Ptr .. Max);\n-                     Store_Compilation_Switch (Storing\n-                              (Storing'First .. First_Stored + Max - Ptr + 2));\n-                     return;\n+                     Store_Compilation_Switch\n+                       (\"-gnateD\" & Switch_Chars (Ptr .. Max));\n+                     Ptr := Max + 1;\n \n                   --  -gnatef (full source path for brief error messages)\n \n@@ -383,8 +373,7 @@ package body Switch.C is\n \n                   when 'I' =>\n                      Ptr := Ptr + 1;\n-                     Scan_Pos\n-                       (Switch_Chars, Max, Ptr, Multiple_Unit_Index, C);\n+                     Scan_Pos (Switch_Chars, Max, Ptr, Multiple_Unit_Index, C);\n \n                   --  -gnatem (mapping file)\n \n@@ -427,22 +416,12 @@ package body Switch.C is\n                      Preprocessing_Data_File :=\n                        new String'(Switch_Chars (Ptr .. Max));\n \n-                     --  Store the switch.\n-                     --  Because we may store a longer switch (we normalize\n-                     --  to -gnatep=), use a local variable.\n+                     --  Store the switch, normalizing to -gnatep=\n \n-                     declare\n-                        To_Store : String\n-                          (1 .. Preprocessing_Data_File'Length + 8);\n-\n-                     begin\n-                        To_Store (1 .. 8) := \"-gnatep=\";\n-                        To_Store (9 .. Preprocessing_Data_File'Length + 8) :=\n-                          Preprocessing_Data_File.all;\n-                        Store_Compilation_Switch (To_Store);\n-                     end;\n+                     Store_Compilation_Switch\n+                       (\"-gnatep=\" & Preprocessing_Data_File.all);\n \n-                  return;\n+                     Ptr := Max + 1;\n \n                   when 'z' =>\n                      Store_Switch := False;\n@@ -509,7 +488,7 @@ package body Switch.C is\n                Warn_On_Unchecked_Conversion := True;\n                Warn_On_Unrecognized_Pragma  := True;\n \n-               Set_Style_Check_Options (\"3abcdefhiklmnprstux\");\n+               Set_Style_Check_Options (\"3aAbcdefhiklmnprstux\");\n \n             --  Processing for G switch\n \n@@ -680,10 +659,10 @@ package body Switch.C is\n             --  Processing for R switch\n \n             when 'R' =>\n-               Ptr := Ptr + 1;\n                Back_Annotate_Rep_Info := True;\n                List_Representation_Info := 1;\n \n+               Ptr := Ptr + 1;\n                while Ptr <= Max loop\n                   C := Switch_Chars (Ptr);\n \n@@ -761,7 +740,6 @@ package body Switch.C is\n \n             when 'V' =>\n                Store_Switch := False;\n-               Storing (First_Stored) := 'V';\n                Ptr := Ptr + 1;\n \n                if Ptr > Max then\n@@ -780,10 +758,8 @@ package body Switch.C is\n                      end if;\n \n                      for Index in First_Char + 1 .. Max loop\n-                        Storing (First_Stored + 1) :=\n-                          Switch_Chars (Index);\n                         Store_Compilation_Switch\n-                          (Storing (Storing'First .. First_Stored + 1));\n+                          (\"-gnatV\" & Switch_Chars (Index));\n                      end loop;\n                   end;\n                end if;\n@@ -794,7 +770,6 @@ package body Switch.C is\n \n             when 'w' =>\n                Store_Switch := False;\n-               Storing (First_Stored) := 'w';\n                Ptr := Ptr + 1;\n \n                if Ptr > Max then\n@@ -804,16 +779,26 @@ package body Switch.C is\n                while Ptr <= Max loop\n                   C := Switch_Chars (Ptr);\n \n-                  if Set_Warning_Switch (C) then\n-                     null;\n-                  else\n-                     Bad_Switch (C);\n-                  end if;\n+                  --  Case of dot switch\n \n-                  if C /= 'w' then\n-                     Storing (First_Stored + 1) := C;\n-                     Store_Compilation_Switch\n-                       (Storing (Storing'First .. First_Stored + 1));\n+                  if C = '.' and then Ptr < Max then\n+                     Ptr := Ptr + 1;\n+                     C := Switch_Chars (Ptr);\n+\n+                     if Set_Dot_Warning_Switch (C) then\n+                        Store_Compilation_Switch (\"-gnatw.\" & C);\n+                     else\n+                        Bad_Switch (C);\n+                     end if;\n+\n+                     --  Normal case, no dot\n+\n+                  else\n+                     if Set_Warning_Switch (C) then\n+                        Store_Compilation_Switch (\"-gnatw\" & C);\n+                     else\n+                        Bad_Switch (C);\n+                     end if;\n                   end if;\n \n                   Ptr := Ptr + 1;\n@@ -855,8 +840,6 @@ package body Switch.C is\n             when 'X' =>\n                Ptr := Ptr + 1;\n                Extensions_Allowed := True;\n-               Ada_Version := Ada_Version_Type'Last;\n-               Ada_Version_Explicit := Ada_Version;\n \n             --  Processing for y switch\n \n@@ -868,11 +851,9 @@ package body Switch.C is\n \n                else\n                   Store_Switch := False;\n-                  Storing (First_Stored) := 'y';\n \n                   declare\n                      OK  : Boolean;\n-                     Last_Stored : Integer;\n \n                   begin\n                      Set_Style_Check_Options\n@@ -886,24 +867,22 @@ package body Switch.C is\n \n                      Ptr := First_Char + 1;\n                      while Ptr <= Max loop\n-                        Last_Stored := First_Stored + 1;\n-                        Storing (Last_Stored) := Switch_Chars (Ptr);\n-\n                         if Switch_Chars (Ptr) = 'M' then\n+                           First_Char := Ptr;\n                            loop\n                               Ptr := Ptr + 1;\n                               exit when Ptr > Max\n                                 or else Switch_Chars (Ptr) not in '0' .. '9';\n-                              Last_Stored := Last_Stored + 1;\n-                              Storing (Last_Stored) := Switch_Chars (Ptr);\n                            end loop;\n \n+                           Store_Compilation_Switch\n+                             (\"-gnaty\" & Switch_Chars (First_Char .. Ptr - 1));\n+\n                         else\n+                           Store_Compilation_Switch\n+                             (\"-gnaty\" & Switch_Chars (Ptr));\n                            Ptr := Ptr + 1;\n                         end if;\n-\n-                        Store_Compilation_Switch\n-                          (Storing (Storing'First .. Last_Stored));\n                      end loop;\n                   end;\n                end if;\n@@ -929,7 +908,6 @@ package body Switch.C is\n                   end case;\n \n                   Ptr := Ptr + 1;\n-\n                end if;\n \n             --  Processing for Z switch\n@@ -1000,17 +978,15 @@ package body Switch.C is\n             when others =>\n                Bad_Switch (C);\n             end case;\n-         end case;\n \n-         if Store_Switch then\n-            Storing (First_Stored .. First_Stored + Ptr - First_Char - 1) :=\n-              Switch_Chars (First_Char .. Ptr - 1);\n-            Store_Compilation_Switch\n-              (Storing (Storing'First .. First_Stored + Ptr - First_Char - 1));\n-         end if;\n+            if Store_Switch then\n+               Store_Compilation_Switch\n+                 (\"-gnat\" & Switch_Chars (First_Char .. Ptr - 1));\n+            end if;\n \n-         First_Switch := False;\n-      end loop;\n+            First_Switch := False;\n+         end loop;\n+      end if;\n    end Scan_Front_End_Switches;\n \n end Switch.C;"}]}