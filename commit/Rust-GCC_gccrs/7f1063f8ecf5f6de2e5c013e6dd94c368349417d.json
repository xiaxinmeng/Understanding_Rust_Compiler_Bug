{"sha": "7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YxMDYzZjhlY2Y1ZjZkZTJlNWMwMTNlNmRkOTRjMzY4MzQ5NDE3ZA==", "commit": {"author": {"name": "Russell Davidson", "email": "russell@ehess.cnrs-mrs.fr", "date": "2000-06-20T01:24:46Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-06-20T01:24:46Z"}, "message": "istream_extractor_arith.cc: Patch.\n\n\n2000-06-19  Russell Davidson  <russell@ehess.cnrs-mrs.fr>\n\n\t* testsuite/27_io/istream_extractor_arith.cc: Patch.\n\t* bits/locale_factets.tcc: Tweak.\n\nFrom-SVN: r34612", "tree": {"sha": "923d0d216602c4f24001dd8776c12ad9cc2b198c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/923d0d216602c4f24001dd8776c12ad9cc2b198c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/comments", "author": null, "committer": null, "parents": [{"sha": "aec5061ba2487186e07012b1b9d2684c04dd027f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aec5061ba2487186e07012b1b9d2684c04dd027f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aec5061ba2487186e07012b1b9d2684c04dd027f"}], "stats": {"total": 1520, "additions": 882, "deletions": 638}, "files": [{"sha": "04e21fbb55a6db616f0f5f7639d8da532ff98360", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "patch": "@@ -1,3 +1,8 @@\n+2000-06-19  Russell Davidson  <russell@ehess.cnrs-mrs.fr>\n+\n+\t* testsuite/27_io/istream_extractor_arith.cc: Patch.\n+\t* bits/locale_factets.tcc: Tweak.\n+\t\n 2000-06-19  Raja R Harinath  <harinath@cs.umn.edu>\n \t\n \t* src/Makefile.am: change @WERROR@ to $(WERROR) so that this can"}, {"sha": "a8ddb378437c85c92cc7f2d359407e5a9126c5dd", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "patch": "@@ -905,9 +905,9 @@ AC_DEFUN(GLIBCPP_CHECK_MATH_SUPPORT, [\n   dnl in libstdc++, which we are building right now.\n   dnl Yet, we need to use the c++ compiler so that __cplusplus is defined.\n   dnl So, use this.\n-  ac_test_CFLAGS=\"${CFLAGS+set}\"\n-  ac_save_CFLAGS=\"$CFLAGS\"\n-  CFLAGS='-x c++'\n+#  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+#  ac_save_CFLAGS=\"$CFLAGS\"\n+#  CFLAGS='-x c++'\n \n   dnl Check libm\n   AC_CHECK_LIB(m, sin, libm=\"-lm\")\n@@ -937,7 +937,7 @@ AC_DEFUN(GLIBCPP_CHECK_MATH_SUPPORT, [\n   _sincosl _finite _finitef _finitel _fqfinite _fpclass _qfpclass)\n \n   LIBS=\"$save_LIBS\"\n-  CFLAGS=\"$ac_save_CFLAGS\"\n+#  CFLAGS=\"$ac_save_CFLAGS\"\n ])\n \n "}, {"sha": "097c4b9e67e9ccfa40802ec669d448f09f017c8b", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "patch": "@@ -913,13 +913,13 @@ dnl\n dnl GLIBCPP_CHECK_MATH_SUPPORT\n AC_DEFUN(GLIBCPP_CHECK_MATH_SUPPORT, [\n \n-  dnl NB: can't use AC_LANG_CPLUSPLUS here, because g++ tries to link\n+  dnl NB: Can't use AC_LANG_CPLUSPLUS here, because g++ tries to link\n   dnl in libstdc++, which we are building right now.\n   dnl Yet, we need to use the c++ compiler so that __cplusplus is defined.\n   dnl So, use this.\n-  ac_test_CFLAGS=\"${CFLAGS+set}\"\n-  ac_save_CFLAGS=\"$CFLAGS\"\n-  CFLAGS='-x c++'\n+#  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+#  ac_save_CFLAGS=\"$CFLAGS\"\n+#  CFLAGS='-x c++'\n \n   dnl Check libm\n   AC_CHECK_LIB(m, sin, libm=\"-lm\")\n@@ -949,7 +949,7 @@ AC_DEFUN(GLIBCPP_CHECK_MATH_SUPPORT, [\n   _sincosl _finite _finitef _finitel _fqfinite _fpclass _qfpclass)\n \n   LIBS=\"$save_LIBS\"\n-  CFLAGS=\"$ac_save_CFLAGS\"\n+#  CFLAGS=\"$ac_save_CFLAGS\"\n ])\n \n "}, {"sha": "dce6e25af9caf39649b54c659e637658c1c7e40c", "filename": "libstdc++-v3/bits/locale_facets.tcc", "status": "modified", "additions": 759, "deletions": 625, "changes": 1384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc?ref=7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "patch": "@@ -33,16 +33,17 @@\n #define _CPP_BITS_LOCFACETS_TCC 1\n \n #include <bits/std_cerrno.h>\n-#include <bits/std_cstdlib.h> \t// For strof, strtold\n-#include <bits/std_limits.h>\t// For numeric_limits\n+#include <bits/std_cstdlib.h>   // For strof, strtold\n+#include <bits/std_limits.h>    // For numeric_limits\n #include <bits/std_vector.h>\n-#include <bits/std_memory.h>\t// For auto_ptr\n-#include <bits/sbuf_iter.h>\t// For streambuf_iterators\n+#include <bits/std_memory.h>    // For auto_ptr\n+#include <bits/sbuf_iter.h>     // For streambuf_iterators\n+#include <bits/std_cctype.h>    // For isspace\n \n namespace std\n {\n   template<typename _Facet>\n-    locale \n+    locale\n     locale::combine(const locale& __other)\n     {\n       locale __copy(*this);\n@@ -54,14 +55,14 @@ namespace std\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     bool\n     locale::operator()(const basic_string<_CharT,_Traits,_Alloc>& __s1,\n-\t\t       const basic_string<_CharT,_Traits,_Alloc>& __s2) const\n+                       const basic_string<_CharT,_Traits,_Alloc>& __s2) const\n     {\n       // XXX should not need to qualify here.\n       // typedef collate<_CharT> __collate_type;\n       typedef std::collate<_CharT> __collate_type;\n       const __collate_type* __fcoll = &use_facet<__collate_type>(*this);\n       return (__fcoll->compare(__s1.data(), __s1.data() + __s1.length(),\n-\t\t\t       __s2.data(), __s2.data() + __s2.length()) < 0);\n+                               __s2.data(), __s2.data() + __s2.length()) < 0);\n     }\n \n   template<typename _Facet>\n@@ -72,17 +73,17 @@ namespace std\n       locale::id& __id = _Facet::id;         // check member id\n       size_t __i = __id._M_index;\n       const locale::_Impl* __tmp = __loc._M_impl;\n-      if (__id._M_index >= __loc._M_impl->_M_facets->size() \n-\t  || (__fp = (*(__tmp->_M_facets))[__i]) == 0)\n-\treturn _Use_facet_failure_handler<_Facet>(__loc);\n+      if (__id._M_index >= __loc._M_impl->_M_facets->size()\n+          || (__fp = (*(__tmp->_M_facets))[__i]) == 0)\n+        return _Use_facet_failure_handler<_Facet>(__loc);\n       return static_cast<const _Facet&>(*__fp);\n     }\n \n   template<typename _Facet>\n     bool\n     has_facet(const locale& __loc) throw()\n     {\n-      typedef locale::_Impl::__vec_facet\t__vec_facet;\n+      typedef locale::_Impl::__vec_facet        __vec_facet;\n       locale::id& __id = _Facet::id;         // check member id\n       size_t __i = __id._M_index;\n       __vec_facet* __tmpv = __loc._M_impl->_M_facets;\n@@ -96,66 +97,66 @@ namespace std\n   // end of sequence before it minimizes the set, sets __eof.\n   // Empty strings are never matched.\n   template<typename _InIter, typename _CharT>\n-    _InIter \n-    __match_parallel(_InIter __s, _InIter __end, int __ntargs, \n-\t\t     const basic_string<_CharT>* __targets,\n-\t\t     int* __matches, int& __remain, bool& __eof)\n+    _InIter\n+    __match_parallel(_InIter __s, _InIter __end, int __ntargs,\n+                     const basic_string<_CharT>* __targets,\n+                     int* __matches, int& __remain, bool& __eof)\n     {\n       typedef basic_string<_CharT> __string_type;\n       __eof = false;\n-      for (int __ti = 0; __ti < __ntargs; ++__ti) \n-\t__matches[__ti] = __ti;\n+      for (int __ti = 0; __ti < __ntargs; ++__ti)\n+        __matches[__ti] = __ti;\n       __remain = __ntargs;\n       size_t __pos = 0;\n-      do \n-\t{\n-\t  {\n-\t    int __ti = 0;\n-\t    for (;__ti < __remain &&\n-\t\t   __pos == __targets[__matches[__ti]].size(); ++__ti)\n-\t      { }\n-\t    if (__ti == __remain) \n-\t      {\n-\t\tif (__pos == 0) __remain = 0;\n-\t\treturn __s;\n-\t      }\n-\t  }\n-\t  if (__s == __end) \n-\t    __eof = true;\n-\t  bool __matched = false;\n-\t  for (int __ti = 0; __ti < __remain; ) \n-\t    {\n-\t      const __string_type& __target = __targets[__matches[__ti]];\n-\t      if (__pos < __target.size()) \n-\t\t{\n-\t\t  if (__eof || __target[__pos] != *__s)\n-\t\t    { \n-\t\t      __matches[__ti] = __matches[--__remain]; \n-\t\t      continue; \n-\t\t    }\n-\t\t  __matched = true;\n-\t\t}\n-\t      ++__ti;\n-\t    }\n-\t  if (__matched) \n-\t    { \n-\t      ++__s; \n-\t      ++__pos; \n-\t    }\n-\t  for (int __ti = 0; __ti < __remain;) \n-\t    {\n-\t      if (__pos > __targets[__matches[__ti]].size())\n-\t\t{ \n-\t\t  __matches[__ti] = __matches[--__remain]; \n-\t\t  continue; \n-\t\t}\n-\t      ++__ti;\n-\t    }\n-\t} \n+      do\n+        {\n+          {\n+            int __ti = 0;\n+            for (;__ti < __remain &&\n+                   __pos == __targets[__matches[__ti]].size(); ++__ti)\n+              { }\n+            if (__ti == __remain)\n+              {\n+                if (__pos == 0) __remain = 0;\n+                return __s;\n+              }\n+          }\n+          if (__s == __end)\n+            __eof = true;\n+          bool __matched = false;\n+          for (int __ti = 0; __ti < __remain; )\n+            {\n+              const __string_type& __target = __targets[__matches[__ti]];\n+              if (__pos < __target.size())\n+                {\n+                  if (__eof || __target[__pos] != *__s)\n+                    {\n+                      __matches[__ti] = __matches[--__remain];\n+                      continue;\n+                    }\n+                  __matched = true;\n+                }\n+              ++__ti;\n+            }\n+          if (__matched)\n+            {\n+              ++__s;\n+              ++__pos;\n+            }\n+          for (int __ti = 0; __ti < __remain;)\n+            {\n+              if (__pos > __targets[__matches[__ti]].size())\n+                {\n+                  __matches[__ti] = __matches[--__remain];\n+                  continue;\n+                }\n+              ++__ti;\n+            }\n+        }\n       while (__remain);\n       return __s;\n     }\n-  \n+\n   template<typename _CharT>\n     locale::id ctype<_CharT>::id;\n \n@@ -176,16 +177,16 @@ namespace std\n \n   template<>\n     _Format_cache<char>::_Format_cache()\n-    : _M_valid(true), \n-    _M_decimal_point('.'), _M_thousands_sep(','), \n+    : _M_valid(true),\n+    _M_decimal_point('.'), _M_thousands_sep(','),\n     _M_truename(\"true\"), _M_falsename(\"false\"), _M_use_grouping(false)\n     { }\n- \n+\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<>\n     _Format_cache<wchar_t>::_Format_cache()\n-    : _M_valid(true), \n-    _M_decimal_point(L'.'), _M_thousands_sep(L','), \n+    : _M_valid(true),\n+    _M_decimal_point(L'.'), _M_thousands_sep(L','),\n     _M_truename(L\"true\"), _M_falsename(L\"false\"), _M_use_grouping(false)\n     { }\n #endif\n@@ -214,44 +215,44 @@ namespace std\n     {\n       void*& __p = __ios.pword(__ix);\n       switch (__ev)\n-\t{\n-\tcase ios_base::erase_event:\n-\t  delete static_cast<_Format_cache<_CharT>*> (__p); __p = 0;   \n-\t  break;\n-\tcase ios_base::copyfmt_event:\n-\t  // If just stored zero, the callback would get registered again.\n-\t  try { \n-\t    __p = new _Format_cache<_CharT>; \n-\t  } \n-\t  catch(...) { \n-\t  }      \n-\t  break;\n-\tcase ios_base::imbue_event:\n-\t  static_cast<_Format_cache<_CharT>*>(__p)->_M_valid = false; \n-\t  break;\n-\t}\n+        {\n+        case ios_base::erase_event:\n+          delete static_cast<_Format_cache<_CharT>*> (__p); __p = 0;\n+          break;\n+        case ios_base::copyfmt_event:\n+          // If just stored zero, the callback would get registered again.\n+          try {\n+            __p = new _Format_cache<_CharT>;\n+          }\n+          catch(...) {\n+          }\n+          break;\n+        case ios_base::imbue_event:\n+          static_cast<_Format_cache<_CharT>*>(__p)->_M_valid = false;\n+          break;\n+        }\n     }\n-  \n+\n   template<typename _CharT>\n     _Format_cache<_CharT>*\n     _Format_cache<_CharT>::_S_get(ios_base& __ios)\n     {\n-      if (!_S_pword_ix) \n-\t_S_pword_ix = ios_base::xalloc();  // XXX MT\n+      if (!_S_pword_ix)\n+        _S_pword_ix = ios_base::xalloc();  // XXX MT\n       void*& __p = __ios.pword(_S_pword_ix);\n-      \n+\n       // XXX What if pword fails? must check failbit, throw.\n       if (__p == 0)  // XXX MT?  maybe sentry takes care of it\n-\t{\n-\t  auto_ptr<_Format_cache<_CharT> > __ap(new _Format_cache<_CharT>);\n-\t  __ios.register_callback(&_Format_cache<_CharT>::_S_callback,\n-\t\t\t\t  _S_pword_ix);\n-\t  __p = __ap.release();\n-\t}\n+        {\n+          auto_ptr<_Format_cache<_CharT> > __ap(new _Format_cache<_CharT>);\n+          __ios.register_callback(&_Format_cache<_CharT>::_S_callback,\n+                                  _S_pword_ix);\n+          __p = __ap.release();\n+        }\n       _Format_cache<_CharT>* __ncp = static_cast<_Format_cache<_CharT>*>(__p);\n-      if (!__ncp->_M_valid) \n-\t__ncp->_M_populate(__ios);\n-      \n+      if (!__ncp->_M_valid)\n+        __ncp->_M_populate(__ios);\n+\n       return __ncp;\n     }\n \n@@ -271,487 +272,625 @@ namespace std\n   // types, etc etc. The current approach seems to be smack dab in\n   // the middle between an unoptimized approach using sscanf, and\n   // some kind of hyper-optimized approach alluded to above.\n-  \n+\n   // XXX\n   // Need to do partial specialization to account for differences\n   // between character sets. For char, this is pretty\n   // straightforward, but for wchar_t, the conversion to a plain-jane\n   // char type is a bit more involved.\n   template<typename _CharT, typename _InIter>\n     void\n-    num_get<_CharT, _InIter>::    \n-    _M_extract(iter_type /*__beg*/, iter_type /*__end*/, ios_base& /*__io*/, \n-\t       ios_base::iostate& /*__err*/, char* /*__xtrc*/,\n+    num_get<_CharT, _InIter>::\n+    _M_extract(iter_type /*__beg*/, iter_type /*__end*/, ios_base& /*__io*/,\n+               ios_base::iostate& /*__err*/, char* /*__xtrc*/,\n                int& /*__base*/, bool /*__fp*/) const\n     {\n       // XXX Not currently done: need to expand upon char version below.\n     }\n \n   template<>\n     void\n-    num_get<char, istreambuf_iterator<char> >::    \n-    _M_extract(istreambuf_iterator<char> __beg, \n-\t       istreambuf_iterator<char> __end, ios_base& __io, \n-\t       ios_base::iostate& __err, char* __xtrc, \n-\t       int& __base, bool __fp) const\n+    num_get<char, istreambuf_iterator<char> >::\n+    _M_extract(istreambuf_iterator<char> __beg,\n+               istreambuf_iterator<char> __end, ios_base& __io,\n+               ios_base::iostate& __err, char* __xtrc,\n+               int& __base, bool __fp) const\n     {\n-      typedef _Format_cache<char> __cache_type;\n+      typedef _Format_cache<char> __cache_type;\t\n+\n+      // Prepare for possible failure\n+      __xtrc[0] = '\\0';\n \n       // Stage 1: determine a conversion specifier.\n       ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n-      if (__basefield == ios_base::oct)\n-\t__base = 8;\n+      if (__basefield == ios_base::dec)\n+        __base = 10;\n+      else if (__basefield == ios_base::oct)\n+        __base = 8;\n       else if (__basefield == ios_base::hex)\n-\t__base = 16;\n+        __base = 16;\n       else\n-\t__base = 10;\n-      \n+        __base = 0;\n+      // As far as I can tell, bases other than 10 are not available for\n+      // floating point types\n+      if (__fp)\n+        __base = 10;\n+\n       // Stage 2: extract characters.\n       __cache_type const* __fmt = __cache_type::_S_get(__io);\n       bool __valid = __beg != __end;\n+      // Fail quickly if !__valid\n+      if (!__valid)\n+        {\n+          __err |= (ios_base::eofbit | ios_base::failbit);\n+          return;\n+        }\n+\n+      // Acceptable formats for numbers here are based on 22.2.3.1\n       string __grp;\n       int __sep_pos = 0;\n       int __pos = 0;\n-      bool __testdec = false;\n-      bool __testEE = false;\n-      bool __testsign = false;\n-      bool __testEEsign = false;\n       const char* __lits = __fmt->_S_literals;\n+      char __c = *__beg;\n \n+      // Check first for sign\n+      bool __testsign = false;\n+      if ((__c == __lits[__cache_type::_S_minus])\n+          || (__c == __lits[__cache_type::_S_plus]))\n+        {\n+          __xtrc[__pos++] = __c;\n+          ++__beg;\n+          __testsign = true;\n+          // whitespace may follow a sign\n+          while ((__beg != __end) && (isspace(*__beg)))\n+            ++__beg;\n+\n+          // There had better be more to come...\n+          if (__beg == __end)\n+            {\n+              __xtrc[__pos] = '\\0';\n+              __err |= (ios_base::eofbit | ios_base::failbit);\n+              return;\n+            }\n+        }\n+\n+      bool __testzero = false;    // Has there been a leading zero?\n+\n+      // Now check if first character is a zero\n+      __c = *__beg;\n+      if (__c == __lits[__cache_type::_S_digits])\n+        {\n+           __testzero = true;\n+           ++__beg;\n+\n+           // We have to check for __beg == __end here. If so,\n+           // a plain '0' (possibly with a sign) can be got rid of now\n+           if (__beg == __end)\n+             {\n+               __xtrc[__pos++] = __c;\n+               __xtrc[__pos] = '\\0';\n+               __err |= ios_base::eofbit;\n+               return;\n+             }\n+\n+          // Figure out base for integer types only\n+          // Based on Table 55 of 22.2.2.1.2\n+          if (!__fp && __base != 10 && __base != 8)\n+            {\n+              // Here, __base == 0 or 16\n+              __c = *__beg;\n+              if ((__c == __lits[__cache_type::_S_x])\n+                 || (__c == __lits[__cache_type::_S_X]))\n+                {\n+                  ++__beg;\n+                  __base = 16;\n+                  __testzero = false; // \"0x\" is not a leading zero\n+                }\n+              else\n+                __base = 8;\n+            }\n+\n+          // Remove any more leading zeros\n+          while (__beg != __end)\n+            {\n+              if (*__beg == __lits[__cache_type::_S_digits])\n+                {\n+                  ++__beg;\n+                  __testzero = true;\n+                }\n+              else\n+                break;\n+            }\n+        }\n+      else if (__base == 0) // 1st character is not zero\n+        __base = 10;\n+\n+      // We now seek \"units\", i.e. digits and thousands separators.\n+      // We may need to know if anything is found here. A leading zero\n+      // (removed by now) would count.\n+\n+      bool __testunits = __testzero;\n       while (__valid && __beg != __end)\n         {\n           __valid = false;\n-          char __c = *__beg;\n-\t  const char* __p = strchr(__fmt->_S_literals, __c);\n-\t  \n-\t  // NB: strchr returns true for __c == 0x0\n+          __c = *__beg;\n+          const char* __p = strchr(__fmt->_S_literals, __c);\n+\n+          // NB: strchr returns true for __c == 0x0\n           if (__p && __c)\n             {\n-\t      // Check for sign and accept if appropriate.\n-\t      if ((__p == &__lits[__cache_type::_S_minus]) \n-\t\t  || (__p == &__lits[__cache_type::_S_plus]))\n-\t\t{\n-\t\t  if (__testEE)\n-\t\t    {\n-\t\t      if (__testEEsign) \n-\t\t\tbreak;\n-\t\t      __testEEsign = true;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (__testsign) \n-\t\t\tbreak;\n-\t\t      __testsign = true;\n-\t\t    }\n-\t\t}\n-\t      // Check for exponential part and accept if appropriate.\n- \t      else if ((__p == &__lits[__cache_type::_S_ee])\n-  \t\t       || (__p == &__lits[__cache_type::_S_Ee]))\n-  \t\t{\n- \t\t  if (!__fp || __testEE || !__testsign) \n-\t\t    break;\n- \t\t  __testEE = true;\n-  \t\t}\n-\t      // Check for hexadecimal base parts.\n-\t      else if ((__p == &__lits[__cache_type::_S_x])\n-\t\t       || (__p == &__lits[__cache_type::_S_X]))\n-\t\t{\n-\t\t  if (__base != 16 \n-\t\t      && __xtrc[__pos - 1] != __lits[__cache_type::_S_digits]) \n-\t\t    break;\n-\t\t}\n-\t      // Check for appropriate digits. If found, too late for a sign\n-\t      else if ((__p >= &__lits[__cache_type::_S_digits]\n-\t\t\t&& __p < &__lits[__cache_type::_S_digits + __base]) \n-\t\t       || (__p >= &__lits[__cache_type::_S_udigits]\n-\t\t\t   && __p < &__lits[__cache_type::_S_udigits + __base]))\n+              // Try first for acceptable digit; record it if found\n+              if ((__p >= &__lits[__cache_type::_S_digits]\n+                    && __p < &__lits[__cache_type::_S_digits + __base])\n+                   || (__p >= &__lits[__cache_type::_S_udigits]\n+                       && __p < &__lits[__cache_type::_S_udigits + __base]))\n                 {\n-\t\t  __testsign = true;\n-\t\t  if (__testEE) \n-\t\t    __testEEsign = true;\n+                  __xtrc[__pos++] = __c;\n+                  ++__sep_pos;\n+                  __valid = true;\n+                  __testunits = true;\n                 }\n-\t      // Nothing else will do\n-\t      else break;\n-\t      \n-\t      __xtrc[__pos] = __c;\n-\t      ++__pos;\n-\t      ++__sep_pos;\n-\t      __valid = true;\n-\t    }\n-          else if (__c == __fmt->_M_thousands_sep \n-\t\t   && __fmt->_M_use_grouping && !__testdec)\n-\t    {\n-\t      // NB: Thousands separator at the beginning of a string\n-\t      // is a no-no, as is two consecutive thousands\n-\t      // separators, as is thousands separator to the right of\n-\t      // a decimal point.\n-\t      if (__sep_pos && !__testdec)\n-\t\t{\n-\t\t  __grp += static_cast<char>(__sep_pos);\n-\t\t  __sep_pos = 0;\n-\t\t  __valid = true;\n-\t\t}\n-\t      else\n-\t\t__err |= ios_base::failbit;\t\t\n-\t    }\n-\t  else if (__c == __fmt->_M_decimal_point \n-\t\t   && __fp && !__testdec)\n-\t    {\n-\t      __xtrc[__pos] = '.';\n-\t      ++__pos;\n-\t      if (__fmt->_M_use_grouping && !__grp.empty())\n-\t\t{\n-\t\t  __grp += static_cast<char>(__sep_pos);\n-\t\t  __sep_pos = 0;\n-\t\t}\n-\t      __testdec = true;\n-\t      __valid = true;\n-\t    }\n-\t  if (__valid) \n-\t    ++__beg;\n-\t}\n-      __xtrc[__pos] = '\\0';\n-      if (__beg == __end)\n-\t__err |= ios_base::eofbit;\n-      \n+            }\n+          else if (__c == __fmt->_M_thousands_sep\n+                   && __fmt->_M_use_grouping)\n+            {\n+              // NB: Thousands separator at the beginning of a string\n+              // is a no-no, as is two consecutive thousands\n+              // separators\n+              if (__sep_pos)\n+                {\n+                  __grp += static_cast<char>(__sep_pos);\n+                  __sep_pos = 0;\n+                  __valid = true;\n+                }\n+              else\n+                __err |= ios_base::failbit;\n+            }\n+          if (__valid)\n+            ++__beg;\n+        }\n+\n       // Digit grouping is checked. If _M_groupings() doesn't\n       // match, then get very very upset, and set failbit.\n       if (__fmt->_M_use_grouping && !__grp.empty())\n-\t{\n-\t  // Add the ending grouping if the decimal point hasn't\n-\t  // already delineated the end of the sequence that grouping\n-\t  // cares about.\n-\t  if (!__testdec)\n-\t    __grp += static_cast<char>(__sep_pos);\n-\n-\t  // __grp is parsed L to R\n-\t  // 1,222,444 == __grp of \"/1/3/3\"\n-\t  // __fmt->_M_grouping is parsed R to L\n-\t  // 1,222,444 == __fmt->_M_grouping of \"/3\" == \"/3/3/3\"\n-\t  int __i = 0;\n-\t  int __j = 0;\n-\t  const int __len = __fmt->_M_grouping.size();\n-\t  int __n = __grp.size();\n-\t  bool __test = true;\n-\n-\t  // Parsed number groupings have to match the\n-\t  // numpunct::grouping string exactly, starting at the\n-\t  // right-most point of the parsed sequence of elements ...\n-\t  while (__test && __i < __n - 1)\n-\t    for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j, ++__i)\n-\t      __test &= __fmt->_M_grouping[__j] == __grp[__n - __i - 1];\n-\t  // ... but the last parsed grouping can be <= numpunct\n-\t  // grouping.\n-\t  __j == __len ? __j = 0 : __j;\n-\t  __test &= __fmt->_M_grouping[__j] >= __grp[__n - __i - 1];\n-\n-\t  if (!__test)\n-\t    __err |= ios_base::failbit;\n-\t}\n+        {\n+          // Add the ending grouping\n+          __grp += static_cast<char>(__sep_pos);\n+\n+          // __grp is parsed L to R\n+          // 1,222,444 == __grp of \"/1/3/3\"\n+          // __fmt->_M_grouping is parsed R to L\n+          // 1,222,444 == __fmt->_M_grouping of \"/3\" == \"/3/3/3\"\n+          int __i = 0;\n+          int __j = 0;\n+          const int __len = __fmt->_M_grouping.size();\n+          int __n = __grp.size();\n+          bool __test = true;\n+\n+          // Parsed number groupings have to match the\n+          // numpunct::grouping string exactly, starting at the\n+          // right-most point of the parsed sequence of elements ...\n+          while (__test && __i < __n - 1)\n+            for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)\n+              __test &= __fmt->_M_grouping[__j] == __grp[__n - __i - 1];\n+          // ... but the last parsed grouping can be <= numpunct\n+          // grouping.\n+          __j == __len ? __j = 0 : __j;\n+          __test &= __fmt->_M_grouping[__j] >= __grp[__n - __i - 1];\n+\n+          if (!__test)\n+            {\n+              __err |= ios_base::failbit;\n+              __xtrc[__pos] = '\\0';\n+              if (__beg == __end)\n+                __err |= ios_base::eofbit;\n+              return;\n+            }\n+        }\n+\n+      // If there was nothing but zeros, put one in the output string\n+      if (__testzero && (__pos == 0 || (__pos == 1 && __testsign)))\n+        __xtrc[__pos++] = __lits[__cache_type::_S_digits];\n+\n+      // That's it for integer types. Remaining code is for floating point\n+      if (__fp && __beg != __end)\n+        {\n+          __c = *__beg;\n+          // Check first for decimal point. There MUST be one if\n+          // __testunits is false.\n+          bool __testdec = false;    // Is there a decimal point\n+                                     // with digits following it?\n+          if (__c == __fmt->_M_decimal_point)\n+            {\n+              __xtrc[__pos++] = '.';\n+              ++__beg;\n+              // Now we get any digits after the decimal point\n+              // There MUST be some if __testunits is false.\n+              while (__beg != __end)\n+                {\n+                  __c = *__beg;\n+                  const char* __p = strchr(__fmt->_S_literals, __c);\n+                  if ((__p >= &__lits[__cache_type::_S_digits]\n+                        && __p < &__lits[__cache_type::_S_digits + __base])\n+                       || (__p >= &__lits[__cache_type::_S_udigits]\n+                           && __p < &__lits[__cache_type::_S_udigits + __base]))\n+                    {\n+                      __xtrc[__pos++] = __c;\n+                      ++__beg;\n+                      __testdec = true;\n+                    }\n+                  else\n+                    break;\n+                }\n+            }\n+          if (!__testunits && !__testdec) // Ill formed\n+            {\n+              __err |= ios_base::failbit;\n+              __xtrc[__pos] = '\\0';\n+              if (__beg == __end)\n+                __err |= ios_base::eofbit;\n+              return;\n+            }\n+\n+          // Now we may find an exponent\n+          if (__beg != __end)\n+            {\n+              __c = *__beg;\n+              if ((__c == __lits[__cache_type::_S_ee])\n+                   || (__c == __lits[__cache_type::_S_Ee]))\n+                {\n+                  __xtrc[__pos++] = __c;\n+                  ++__beg;\n+                  // Now there may be a sign\n+                  if (__beg != __end)\n+                    {\n+                      __c = *__beg;\n+                      if ((__c == __lits[__cache_type::_S_minus])\n+                          || (__c == __lits[__cache_type::_S_plus]))\n+                        {\n+                          __xtrc[__pos++] = __c;\n+                          ++__beg;\n+                          // whitespace may follow a sign\n+                          while ((__beg != __end) && (isspace(*__beg)))\n+                            ++__beg;\n+\n+                        }\n+                    }\n+                  // And now there must be some digits\n+                  if (__beg == __end)\n+                    {\n+                      __xtrc[__pos] = '\\0';\n+                      __err |= (ios_base::eofbit | ios_base::failbit);\n+                      return;\n+                    }\n+                  while (__beg != __end)\n+                    {\n+                      __c = *__beg;\n+                      const char* __p = strchr(__fmt->_S_literals, __c);\n+                      if ((__p >= &__lits[__cache_type::_S_digits]\n+                            && __p < &__lits[__cache_type::_S_digits + __base])\n+                           || (__p >= &__lits[__cache_type::_S_udigits]\n+                               && __p < &__lits[__cache_type::_S_udigits + __base]))\n+                        {\n+                          __xtrc[__pos++] = __c;\n+                          ++__beg;\n+                        }\n+                      else\n+                        break;\n+                    }\n+                }\n+            }\n+          // Finally, that's it for floating point\n+        }\n+\n+      // Finish up\n+      __xtrc[__pos] = '\\0';\n+      if (__beg == __end)\n+        __err |= ios_base::eofbit;\n     }\n-  \n+\n   // NB: This is an unresolved library defect #17\n   // _GLIBCPP_RESOLVE_LIB_DEFECTS\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, bool& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, bool& __v) const\n     {\n       // Parse bool values as long\n       if (!(__io.flags() & ios_base::boolalpha))\n-\t{\n-\t  // NB: We can't just call do_get(long) here, as it might\n-\t  // refer to a derived class.\n-\n-\t  // Stage 1: extract and determine the conversion specifier.\n-\t  // Assuming leading zeros eliminated, thus the size of 32 for\n-\t  // integral types.\n-\t  char __xtrc[32]= {'\\0'};\n-\t  int __base;\n-\t  _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-\t  \n-\t  // Stage 2: convert and store results.\n-\t  char* __sanity;\n-\t  errno = 0;\n-\t  long __l = strtol(__xtrc, &__sanity, __base);\n-\t  if (!(__err & ios_base::failbit)\n-\t      && __l <= 1\n-\t      && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t    __v = __l;\n-\t  else\n-\t    __err |= ios_base::failbit;\n-\t}\n-      \n+        {\n+          // NB: We can't just call do_get(long) here, as it might\n+          // refer to a derived class.\n+\n+          // Stage 1: extract and determine the conversion specifier.\n+          // Assuming leading zeros eliminated, thus the size of 32 for\n+          // integral types.\n+          char __xtrc[32]= {'\\0'};\n+          int __base;\n+          _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+          // Stage 2: convert and store results.\n+          char* __sanity;\n+          errno = 0;\n+          long __l = strtol(__xtrc, &__sanity, __base);\n+          if (!(__err & ios_base::failbit)\n+              && __l <= 1\n+              && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+            __v = __l;\n+          else\n+            __err |= ios_base::failbit;\n+        }\n+\n       // Parse bool values as alphanumeric\n       else\n-\t{\n-\t  typedef _Format_cache<char_type> __fcache_type;\n-\t  __fcache_type* __fmt = __fcache_type::_S_get(__io);\n-\t  const char_type* __true = __fmt->_M_truename.c_str();\n-\t  const char_type* __false = __fmt->_M_falsename.c_str();\n-\t  const size_t __truelen =  __traits_type::length(__true) - 1;\n-\t  const size_t __falselen =  __traits_type::length(__false) - 1;\n-\n-\t  for (size_t __pos = 0; __beg != __end; ++__pos)\n-\t    {\n-\t      char_type __c = *__beg++;\n-\t      bool __testf = __c == __false[__pos];\n-\t      bool __testt = __c == __true[__pos];\n-\t      if (!(__testf || __testt))\n-\t\t{\n-\t\t  __err |= ios_base::failbit;\n-\t\t  break;\n-\t\t}\n-\t      else if (__testf && __pos == __falselen)\n-\t\t{\n-\t\t  __v = 0;\n-\t\t  break;\n-\t\t}\n-\t      else if (__testt && __pos == __truelen)\n-\t\t{\n-\t\t  __v = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (__beg == __end)\n-\t    __err |= ios_base::eofbit;\n-\t}\n-      \n+        {\n+          typedef _Format_cache<char_type> __fcache_type;\n+          __fcache_type* __fmt = __fcache_type::_S_get(__io);\n+          const char_type* __true = __fmt->_M_truename.c_str();\n+          const char_type* __false = __fmt->_M_falsename.c_str();\n+          const size_t __truelen =  __traits_type::length(__true) - 1;\n+          const size_t __falselen =  __traits_type::length(__false) - 1;\n+\n+          for (size_t __pos = 0; __beg != __end; ++__pos)\n+            {\n+              char_type __c = *__beg++;\n+              bool __testf = __c == __false[__pos];\n+              bool __testt = __c == __true[__pos];\n+              if (!(__testf || __testt))\n+                {\n+                  __err |= ios_base::failbit;\n+                  break;\n+                }\n+              else if (__testf && __pos == __falselen)\n+                {\n+                  __v = 0;\n+                  break;\n+                }\n+              else if (__testt && __pos == __truelen)\n+                {\n+                  __v = 1;\n+                  break;\n+                }\n+            }\n+          if (__beg == __end)\n+            __err |= ios_base::eofbit;\n+        }\n+\n       return __beg;\n     }\n-  \n+\n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, short& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, short& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       long __l = strtol(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-\t  && __l >= SHRT_MIN && __l <= SHRT_MAX) \n-\t__v = static_cast<short>(__l);\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __l >= SHRT_MIN && __l <= SHRT_MAX)\n+        __v = static_cast<short>(__l);\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, int& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, int& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32] = {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       long __l = strtol(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-\t  && __l >= INT_MIN && __l <= INT_MAX) \n-\t__v = static_cast<int>(__l);\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __l >= INT_MIN && __l <= INT_MAX)\n+        __v = static_cast<int>(__l);\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n #endif\n-   \n+\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, long& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       long __l = strtol(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __l;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __l;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n-   \n+\n #ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, long long& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long long& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       long long __ll = strtoll(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __ll;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ll;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n #endif\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, unsigned short& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned short& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-\t  && __ul <= USHRT_MAX) \n-\t__v = static_cast<unsigned short>(__ul);\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __ul <= USHRT_MAX)\n+        __v = static_cast<unsigned short>(__ul);\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, unsigned int& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned int& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n-\t  && __ul <= UINT_MAX) \n-\t__v = static_cast<unsigned int>(__ul);\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __ul <= UINT_MAX)\n+        __v = static_cast<unsigned int>(__ul);\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, unsigned long& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned long& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32] = {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __ul;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ul;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, unsigned long long& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned long long& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 32 for\n       // integral types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       unsigned long long __ull = strtoull(__xtrc, &__sanity, __base);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __ull;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ull;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n #endif\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, float& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, float& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 256 for\n       // floating-point types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n@@ -761,72 +900,72 @@ namespace std\n       float __f = static_cast<float>(strtod(__xtrc, &__sanity));\n #endif\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __f;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __f;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, double& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, double& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 256 for\n       // floating-point types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       double __d = strtod(__xtrc, &__sanity);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __d;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __d;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n \n #if defined(_GLIBCPP_HAVE_STRTOLD) && !defined(__hpux)\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, long double& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long double& __v) const\n     {\n       // Stage 1: extract and determine the conversion specifier.\n       // Assuming leading zeros eliminated, thus the size of 256 for\n       // floating-point types.\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       long double __ld = strtold(__xtrc, &__sanity);\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __ld;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ld;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n #else\n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, long double& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long double& __v) const\n     {\n       // Stage 1: extract\n       char __xtrc[32]= {'\\0'};\n@@ -837,38 +976,38 @@ namespace std\n       ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n       const char* __conv;\n       if (__basefield == ios_base::oct)\n-\t__conv = \"%Lo\";\n+        __conv = \"%Lo\";\n       else if (__basefield == ios_base::hex)\n-\t__conv = \"%LX\";\n+        __conv = \"%LX\";\n       else if (__basefield == 0)\n-\t__conv = \"%Li\";\n+        __conv = \"%Li\";\n       else\n-\t__conv = \"%Lg\";\n+        __conv = \"%Lg\";\n \n       // Stage 3: store results.\n       long double __ld;\n       int __p = sscanf(__xtrc, __conv, &__ld);\n-      if (__p \n-\t  && static_cast<__traits_type::int_type>(__p) != __traits_type::eof())\n-\t__v = __ld;\n+      if (__p\n+          && static_cast<__traits_type::int_type>(__p) != __traits_type::eof())\n+        __v = __ld;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       return __beg;\n     }\n #endif\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     num_get<_CharT, _InIter>::\n-    do_get(iter_type __beg, iter_type __end, ios_base& __io, \n-\t   ios_base::iostate& __err, void*& __v) const\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, void*& __v) const\n     {\n       // Prepare for hex formatted input\n-      typedef ios_base::fmtflags \tfmtflags;\n+      typedef ios_base::fmtflags        fmtflags;\n       fmtflags __fmt = __io.flags();\n-      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield \n-\t\t\t     | ios_base::uppercase | ios_base::internal);\n+      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield\n+                             | ios_base::uppercase | ios_base::internal);\n       __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n \n       // Stage 1: extract and determine the conversion specifier.\n@@ -877,17 +1016,17 @@ namespace std\n       char __xtrc[32]= {'\\0'};\n       int __base;\n       _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n-      \n+\n       // Stage 2: convert and store results.\n       char* __sanity;\n       errno = 0;\n       void* __vp = reinterpret_cast<void*>(strtoul(__xtrc, &__sanity, __base));\n       if (!(__err & ios_base::failbit)\n-\t  && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n-\t__v = __vp;\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __vp;\n       else\n-\t__err |= ios_base::failbit;\n-      \n+        __err |= ios_base::failbit;\n+\n       // Reset from hex formatted input\n       __io.flags(__fmt);\n       return __beg;\n@@ -923,7 +1062,7 @@ namespace std\n     _S_fill(_OutIter __s, _CharT __fill, int __padding)\n     {\n       return _S_fill(__s, __fill, __padding,\n-\t\t     iterator_traits<_OutIter>::iterator_category());\n+                     iterator_traits<_OutIter>::iterator_category());\n     }\n \n   template <typename _CharT, typename _OutIter>\n@@ -933,97 +1072,97 @@ namespace std\n                    _CharT const* __middle, _CharT const* __last)\n     {\n       int __padding = __width - (__last - __first);\n-      if (__padding < 0) \n-\t__padding = 0;\n+      if (__padding < 0)\n+        __padding = 0;\n       ios_base::fmtflags __aflags = __flags & ios_base::adjustfield;\n-      bool __testfield = __padding == 0 || __aflags == ios_base::left \n-\t\t\t || __aflags == ios_base::internal;\n+      bool __testfield = __padding == 0 || __aflags == ios_base::left\n+                         || __aflags == ios_base::internal;\n \n       // This was needlessly complicated.\n       if (__first != __middle)\n-\t{\n-\t  if (!__testfield)\n-\t    {\n-\t      _S_fill(__s, __fill, __padding);\n-\t      __padding = 0;\n-\t    }\n-\t  copy(__first, __middle, __s);\n-\t}\n+        {\n+          if (!__testfield)\n+            {\n+              _S_fill(__s, __fill, __padding);\n+              __padding = 0;\n+            }\n+          copy(__first, __middle, __s);\n+        }\n       _OutIter __s2 = __s;\n \n-      if (__padding && __aflags != ios_base::left) \n-\t{\n-\t  _S_fill(__s2, __fill, __padding);\n-\t  __padding = 0;\n-\t}\n+      if (__padding && __aflags != ios_base::left)\n+        {\n+          _S_fill(__s2, __fill, __padding);\n+          __padding = 0;\n+        }\n       _OutIter __s3 = copy(__middle, __last, __s2);\n       if (__padding)\n-\t_S_fill(__s3, __fill, __padding);\n+        _S_fill(__s3, __fill, __padding);\n       return __s3;\n     }\n \n   template <typename _CharT, typename _OutIter>\n-    _OutIter \n+    _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n     {\n       const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n       ios_base::fmtflags __flags = __io.flags();\n \n       if ((__flags & ios_base::boolalpha) == 0)\n-\t{\n-\t  unsigned long __uv = __v;\n-\t  return _S_format(__s, __io, __fill, false, __uv);\n-\t}\n+        {\n+          unsigned long __uv = __v;\n+          return _S_format(__s, __io, __fill, false, __uv);\n+        }\n       else\n-\t{\n-\t  const char_type* __first;\n-\t  const char_type* __last;\n-\t  if (__v)\n-\t    {\n-\t      __first = __fmt->_M_truename.data();\n-\t      __last = __first + __fmt->_M_truename.size();\n-\t    }\n-\t  else\n-\t    {\n-\t      __first = __fmt->_M_falsename.data();\n-\t      __last = __first + __fmt->_M_falsename.size();\n-\t    }\n-\t  copy(__first, __last, __s);\n-\t}\n+        {\n+          const char_type* __first;\n+          const char_type* __last;\n+          if (__v)\n+            {\n+              __first = __fmt->_M_truename.data();\n+              __last = __first + __fmt->_M_truename.size();\n+            }\n+          else\n+            {\n+              __first = __fmt->_M_falsename.data();\n+              __last = __first + __fmt->_M_falsename.size();\n+            }\n+          copy(__first, __last, __s);\n+        }\n       return __s;\n     }\n \n-  // _S_group_digits inserts \"group separator\" characters into an array \n+  // _S_group_digits inserts \"group separator\" characters into an array\n   // of characters.  It's recursive, one iteration per group.  It moves\n   // the characters in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".\n   // Call this only with __grouping != __grend.\n   template <typename _CharT>\n     _CharT*\n-    _S_group_digits(_CharT* __s, _CharT __grsep,  char const* __grouping, \n-\t\t    char const* __grend, _CharT const* __first, \n-\t\t    _CharT const* __last)\n+    _S_group_digits(_CharT* __s, _CharT __grsep,  char const* __grouping,\n+                    char const* __grend, _CharT const* __first,\n+                    _CharT const* __last)\n     {\n-      if (__last - __first > *__grouping) \n-\t{\n-\t  __s = _S_group_digits(__s,  __grsep, \n+      if (__last - __first > *__grouping)\n+        {\n+          __s = _S_group_digits(__s,  __grsep,\n               (__grouping + 1 == __grend ? __grouping : __grouping + 1),\n-\t      __grend, __first, __last - *__grouping);\n-\t  __first = __last - *__grouping;\n-\t  *__s++ = __grsep;\n-\t}\n-      do \n-\t{\n-\t  *__s++ = *__first++;\n-\t} \n+              __grend, __first, __last - *__grouping);\n+          __first = __last - *__grouping;\n+          *__s++ = __grsep;\n+        }\n+      do\n+        {\n+          *__s++ = *__first++;\n+        }\n       while (__first != __last);\n       return __s;\n     }\n \n   template <typename _CharT, typename _OutIter, typename _ValueT>\n     _OutIter\n     _S_format(_OutIter __s, ios_base& __io, _CharT __fill, bool __neg,\n-\t      _ValueT __v)\n+              _ValueT __v)\n     {\n       // Leave room for \"+/-,\" \"0x,\" and commas.\n       const long _M_room = numeric_limits<_ValueT>::digits10 * 2 + 4;\n@@ -1035,104 +1174,104 @@ namespace std\n \n       ios_base::fmtflags __basefield = (__flags & __io.basefield);\n       _CharT* __sign_end = __front;\n-      if (__basefield == ios_base::hex) \n-\t{\n-\t  if (__flags & ios_base::uppercase) \n-\t    __table += 16;  // use ABCDEF\n-\t  do \n-\t    *--__front = __table[__v & 15];\n-\t  while ((__v >>= 4) != 0);\n-\t  __sign_end = __front;\n-\t  if (__flags & ios_base::showbase) \n-\t    {\n-\t      *--__front = __fmt->_S_literals[__fmt->_S_x +\n+      if (__basefield == ios_base::hex)\n+        {\n+          if (__flags & ios_base::uppercase)\n+            __table += 16;  // use ABCDEF\n+          do\n+            *--__front = __table[__v & 15];\n+          while ((__v >>= 4) != 0);\n+          __sign_end = __front;\n+          if (__flags & ios_base::showbase)\n+            {\n+              *--__front = __fmt->_S_literals[__fmt->_S_x +\n                        ((__flags & ios_base::uppercase) ? 1 : 0)];\n-\t      *--__front = __table[0];\n-\t    }\n-\t} \n-      else if (__basefield == ios_base::oct) \n-\t{\n-\t  do \n-\t    *--__front = __table[__v & 7];\n-\t  while ((__v >>= 3) != 0);\n-\t  if (__flags & ios_base::showbase \n-\t      && static_cast<char>(*__front) != __table[0])\n-\t    *--__front = __table[0];\n-\t  __sign_end = __front;\n-\t} \n-      else \n-\t{\n-\t  // NB: This is _lots_ faster than using ldiv.\n-\t  do \n-\t    *--__front = __table[__v % 10];\n-\t  while ((__v /= 10) != 0);\n-\t  __sign_end = __front;\n-\t  // NB: ios_base:hex || ios_base::oct assumed to be unsigned.\n-\t  if (__neg || (__flags & ios_base::showpos))\n-\t    *--__front = __fmt->_S_literals[__fmt->_S_plus - __neg];\n-\t}\n+              *--__front = __table[0];\n+            }\n+        }\n+      else if (__basefield == ios_base::oct)\n+        {\n+          do\n+            *--__front = __table[__v & 7];\n+          while ((__v >>= 3) != 0);\n+          if (__flags & ios_base::showbase\n+              && static_cast<char>(*__front) != __table[0])\n+            *--__front = __table[0];\n+          __sign_end = __front;\n+        }\n+      else\n+        {\n+          // NB: This is _lots_ faster than using ldiv.\n+          do\n+            *--__front = __table[__v % 10];\n+          while ((__v /= 10) != 0);\n+          __sign_end = __front;\n+          // NB: ios_base:hex || ios_base::oct assumed to be unsigned.\n+          if (__neg || (__flags & ios_base::showpos))\n+            *--__front = __fmt->_S_literals[__fmt->_S_plus - __neg];\n+        }\n \n       // XXX should specialize!\n       if (!__fmt->_M_use_grouping && !__io.width())\n-\treturn copy(__front, __digits + _M_room, __s);  \n+        return copy(__front, __digits + _M_room, __s);\n \n       if (!__fmt->_M_use_grouping)\n-\treturn _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n-\t\t\t      __front, __sign_end, __digits + _M_room);\n+        return _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n+                              __front, __sign_end, __digits + _M_room);\n \n       _CharT* __p = __digits;\n       while (__front < __sign_end)\n-\t*__p++ = *__front++;\n+        *__p++ = *__front++;\n       const char* __gr = __fmt->_M_grouping.data();\n-      __front = _S_group_digits(__p, __fmt->_M_thousands_sep, __gr, \n+      __front = _S_group_digits(__p, __fmt->_M_thousands_sep, __gr,\n         __gr + __fmt->_M_grouping.size(), __sign_end, __digits + _M_room);\n       return _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n-\t\t\t    __digits, __p, __front);\n+                            __digits, __p, __front);\n     }\n \n   template <typename _CharT, typename _OutIter>\n-    _OutIter \n+    _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n     {\n       unsigned long __uv = __v;\n       bool __neg = false;\n-      if (__v < 0) \n-\t{ \n-\t  __neg = true; \n-\t  __uv = -__uv; \n-\t}\n+      if (__v < 0)\n+        {\n+          __neg = true;\n+          __uv = -__uv;\n+        }\n       return _S_format(__s, __io, __fill, __neg, __uv);\n     }\n \n   template <typename _CharT, typename _OutIter>\n-    _OutIter \n+    _OutIter\n     num_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, ios_base& __io, char_type __fill, \n-\t   unsigned long __v) const\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+           unsigned long __v) const\n     { return _S_format(__s, __io, __fill, false, __v); }\n \n-#ifdef _GLIBCPP_USE_LONG_LONG \n+#ifdef _GLIBCPP_USE_LONG_LONG\n   template <typename _CharT, typename _OutIter>\n-    _OutIter \n+    _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n     {\n       unsigned long long __uv = __v;\n       bool __neg = false;\n-      if (__v < 0) \n-\t{ \n-\t  __neg = true; \n-\t  __uv = -__uv; \n-\t}\n+      if (__v < 0)\n+        {\n+          __neg = true;\n+          __uv = -__uv;\n+        }\n       return _S_format(__s, __b, __fill, __neg, __uv);\n     }\n \n   template <typename _CharT, typename _OutIter>\n-    _OutIter \n+    _OutIter\n     num_put<_CharT, _OutIter>::\n-    do_put(iter_type __s, ios_base& __io, char_type __fill, \n-\t   unsigned long long __v) const\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+           unsigned long long __v) const\n     { return _S_format(__s, __io, __fill, false, __v); }\n #endif\n \n@@ -1149,29 +1288,29 @@ namespace std\n   // implementation follows the C++ standard fairly directly as\n   // outlined in 22.2.2.2 [lib.locale.num.put]\n   bool\n-  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier, \n-\t\t\tstreamsize __prec)\n+  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier,\n+                        streamsize __prec)\n   {\n     bool __incl_prec = false;\n     ios_base::fmtflags __flags = __io.flags();\n     *__fptr++ = '%';\n-    // [22.2.2.2.2] Table 60 \n-    if (__flags & ios_base::showpos)  \n+    // [22.2.2.2.2] Table 60\n+    if (__flags & ios_base::showpos)\n       *__fptr++ = '+';\n     if (__flags & ios_base::showpoint)\n       *__fptr++ = '#';\n-    // As per [22.2.2.2.2.11] \n-    if (__flags & ios_base::fixed || __prec > 0) \n+    // As per [22.2.2.2.2.11]\n+    if (__flags & ios_base::fixed || __prec > 0)\n       {\n-\t*__fptr++ = '.';\n-\t*__fptr++ = '*';\n-\t__incl_prec = true;\n+        *__fptr++ = '.';\n+        *__fptr++ = '*';\n+        __incl_prec = true;\n       }\n     if (__modifier)\n       *__fptr++ = __modifier;\n     ios_base::fmtflags __fltfield = __flags & ios_base::floatfield;\n     // [22.2.2.2.2] Table 58\n-    if (__fltfield == ios_base::fixed)  \n+    if (__fltfield == ios_base::fixed)\n       *__fptr++ = 'f';\n     else if (__fltfield == ios_base::scientific)\n       *__fptr++ = (__flags & ios_base::uppercase) ? 'E' : 'e';\n@@ -1183,48 +1322,48 @@ namespace std\n \n   template<typename _CharT,typename _OutIter>\n     _OutIter\n-    _S_output_float(_OutIter __s, ios_base& __io,_CharT __fill, \n+    _S_output_float(_OutIter __s, ios_base& __io,_CharT __fill,\n                     const char* __sptr, size_t __slen)\n     {\n       size_t __padding = __io.width() > streamsize(__slen) ?\n-\t\t\t __io.width() -__slen : 0;\n+                         __io.width() -__slen : 0;\n       locale __loc = __io.getloc();\n       ctype<_CharT> const& __ct = use_facet<ctype<_CharT> >(__loc);\n       ios_base::fmtflags __adjfield = __io.flags() & ios_base::adjustfield;\n       const char* const __eptr = __sptr + __slen;\n       // [22.2.2.2.2.19] Table 61\n-      if (__adjfield == ios_base::internal)  \n+      if (__adjfield == ios_base::internal)\n        {\n-\t // [22.2.2.2.2.14]; widen()\n+         // [22.2.2.2.2.14]; widen()\n          if (__sptr < __eptr && (*__sptr == '+' || *__sptr == '-'))\n-\t   {\n-\t     __s = __ct.widen(*__sptr);\n-\t     ++__s;\n-\t     ++__sptr; \n-\t   }\n+           {\n+             __s = __ct.widen(*__sptr);\n+             ++__s;\n+             ++__sptr;\n+           }\n          __s = _S_fill(__s, __fill, __padding);\n-\t __padding = 0;\n+         __padding = 0;\n        }\n       else if (__adjfield != ios_base::left)\n-\t{\n-\t  __s = _S_fill(__s, __fill, __padding);\n-\t  __padding = 0;\n-\t}\n+        {\n+          __s = _S_fill(__s, __fill, __padding);\n+          __padding = 0;\n+        }\n       // the \"C\" locale decimal character\n-      char __decimal_point = *(localeconv()->decimal_point);  \n+      char __decimal_point = *(localeconv()->decimal_point);\n       const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n       for (; __sptr != __eptr; ++__s, ++__sptr)\n        {\n-         // [22.2.2.2.2.17]; decimal point conversion \n-         if (*__sptr == __decimal_point) \n-\t   __s = __fmt->_M_decimal_point;\n-\t // [22.2.2.2.2.14]; widen()\n+         // [22.2.2.2.2.17]; decimal point conversion\n+         if (*__sptr == __decimal_point)\n+           __s = __fmt->_M_decimal_point;\n+         // [22.2.2.2.2.14]; widen()\n          else\n-           __s = __ct.widen(*__sptr); \n+           __s = __ct.widen(*__sptr);\n        }\n       // [22.2.2.2.2.19] Table 61\n       if (__padding)\n-\t_S_fill(__s, __fill, __padding); \n+        _S_fill(__s, __fill, __padding);\n       __io.width(0);\n       return __s;\n     }\n@@ -1237,17 +1376,17 @@ namespace std\n       const streamsize __max_prec = numeric_limits<double>::digits10 + 3;\n       streamsize __prec = __io.precision();\n       // Protect against sprintf() buffer overflows.\n-      if (__prec > __max_prec) \n-\t__prec = __max_prec;\n+      if (__prec > __max_prec)\n+        __prec = __max_prec;\n       // The *2 provides for signs, exp, 'E', and pad.\n-      char __sbuf[__max_prec*2]; \n+      char __sbuf[__max_prec*2];\n       size_t __slen;\n-      // Long enough for the max format spec. \n-      char __fbuf[16];  \n+      // Long enough for the max format spec.\n+      char __fbuf[16];\n       if (_S_build_float_format(__io, __fbuf, 0, __prec))\n-\t__slen = sprintf(__sbuf, __fbuf, __prec, __v);\n+        __slen = sprintf(__sbuf, __fbuf, __prec, __v);\n       else\n-\t__slen = sprintf(__sbuf, __fbuf, __v);\n+        __slen = sprintf(__sbuf, __fbuf, __v);\n       // [22.2.2.2.2] Stages 2-4.\n       return _S_output_float(__s, __io, __fill, __sbuf, __slen);\n     }\n@@ -1256,47 +1395,47 @@ namespace std\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n-\t   long double __v) const\n+           long double __v) const\n     {\n       const streamsize __max_prec = numeric_limits<long double>::digits10 + 3;\n       streamsize __prec = __io.precision();\n       // Protect against sprintf() buffer overflows.\n-      if (__prec > __max_prec) \n-\t__prec = __max_prec;\n+      if (__prec > __max_prec)\n+        __prec = __max_prec;\n       // The *2 provides for signs, exp, 'E', and pad.\n-      char __sbuf[__max_prec*2]; \n+      char __sbuf[__max_prec*2];\n       size_t __slen;\n       // Long enough for the max format spec.\n-      char __fbuf[16];  \n+      char __fbuf[16];\n       // 'L' as per [22.2.2.2.2] Table 59\n-      if ( _S_build_float_format(__io, __fbuf, 'L', __prec)) \n-\t__slen = sprintf(__sbuf, __fbuf, __prec, __v);\n+      if ( _S_build_float_format(__io, __fbuf, 'L', __prec))\n+        __slen = sprintf(__sbuf, __fbuf, __prec, __v);\n       else\n-\t__slen = sprintf(__sbuf, __fbuf, __v);\n+        __slen = sprintf(__sbuf, __fbuf, __v);\n       // [22.2.2.2.2] Stages 2-4\n       return _S_output_float(__s, __io, __fill, __sbuf, __slen);\n     }\n \n   template <typename _CharT, typename _OutIter>\n-    _OutIter \n+    _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n-\t   const void* __v) const\n+           const void* __v) const\n     {\n-      typedef ios_base::fmtflags \tfmtflags;\n+      typedef ios_base::fmtflags        fmtflags;\n       fmtflags __fmt = __io.flags();\n-      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield \n-\t\t\t     | ios_base::uppercase | ios_base::internal);\n+      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield\n+                             | ios_base::uppercase | ios_base::internal);\n       __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n       try {\n-\t_OutIter __s2 = _S_format(__s, __io, __fill, false, \n-\t\t\t\t  reinterpret_cast<unsigned long>(__v));\n-\t__io.flags(__fmt);\n-\treturn __s2;\n-      } \n+        _OutIter __s2 = _S_format(__s, __io, __fill, false,\n+                                  reinterpret_cast<unsigned long>(__v));\n+        __io.flags(__fmt);\n+        return __s2;\n+      }\n       catch (...) {\n-\t__io.flags(__fmt); \n-\tthrow;\n+        __io.flags(__fmt);\n+        throw;\n       }\n     }\n \n@@ -1319,8 +1458,8 @@ namespace std\n \n   template<typename _Dummy>\n     const char* const\n-    _Weekdaynames<char,_Dummy>::_S_names[14] = \n-    { \n+    _Weekdaynames<char,_Dummy>::_S_names[14] =\n+    {\n       \"Sun\", \"Sunday\",\n       \"Mon\", \"Monday\",   \"Tue\", \"Tuesday\", \"Wed\", \"Wednesday\",\n       \"Thu\", \"Thursday\", \"Fri\", \"Friday\",  \"Sat\", \"Saturday\"\n@@ -1333,8 +1472,8 @@ namespace std\n \n   template<typename _Dummy>\n     const wchar_t* const\n-    _Weekdaynames<wchar_t,_Dummy>::_S_names[14] = \n-    { \n+    _Weekdaynames<wchar_t,_Dummy>::_S_names[14] =\n+    {\n       L\"Sun\", L\"Sunday\",\n       L\"Mon\", L\"Monday\",   L\"Tue\", L\"Tuesday\", L\"Wed\", L\"Wednesday\",\n       L\"Thu\", L\"Thursday\", L\"Fri\", L\"Friday\",  L\"Sat\", L\"Saturday\"\n@@ -1350,7 +1489,7 @@ namespace std\n \n   template<typename _Dummy>\n     const char* const\n-    _Monthnames<char,_Dummy>::_S_names[24] = \n+    _Monthnames<char,_Dummy>::_S_names[24] =\n     {\n       \"Jan\", \"January\", \"Feb\", \"February\", \"Mar\", \"March\",\n       \"Apr\", \"April\",   \"May\", \"May\",      \"Jun\", \"June\",\n@@ -1365,7 +1504,7 @@ namespace std\n \n   template<typename _Dummy>\n     const wchar_t* const\n-    _Monthnames<wchar_t,_Dummy>::_S_names[24] = \n+    _Monthnames<wchar_t,_Dummy>::_S_names[24] =\n     {\n       L\"Jan\", L\"January\", L\"Feb\", L\"February\", L\"Mar\", L\"March\",\n       L\"Apr\", L\"April\",   L\"May\", L\"May\",      L\"Jun\", L\"June\",\n@@ -1378,59 +1517,59 @@ namespace std\n     locale::id time_get<_CharT, _InIter>::id;\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     time_get<_CharT, _InIter>::\n     do_get_weekday(iter_type __s, iter_type __end,\n-\t\t   ios_base& __io, ios_base::iostate& __err, tm* __t) const\n+                   ios_base& __io, ios_base::iostate& __err, tm* __t) const\n     {\n-      if (!_M_daynames) \n-\t{\n-\t  _M_daynames = new basic_string<_CharT>[14];\n-\t  for (int __i = 0; __i < 14; ++__i)\n-\t    _M_daynames[__i] = _Weekdaynames<_CharT>::_S_names[__i];\n-\t}\n+      if (!_M_daynames)\n+        {\n+          _M_daynames = new basic_string<_CharT>[14];\n+          for (int __i = 0; __i < 14; ++__i)\n+            _M_daynames[__i] = _Weekdaynames<_CharT>::_S_names[__i];\n+        }\n       bool __at_eof = false;\n       int __remain = 0;\n       int __matches[14];\n-      iter_type __out = __match_parallel(__s, __end, 14, _M_daynames, \n-\t\t\t\t\t __matches, __remain, __at_eof);\n+      iter_type __out = __match_parallel(__s, __end, 14, _M_daynames,\n+                                         __matches, __remain, __at_eof);\n       __err = ios_base::iostate(0);\n       if (__at_eof) __err |= __io.eofbit;\n       if (__remain == 1 ||\n-\t  __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n-\t__t->tm_wday = (__matches[0]>>1);\n+          __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n+        __t->tm_wday = (__matches[0]>>1);\n       else\n-\t__err |= __io.failbit;\n+        __err |= __io.failbit;\n       return __out;\n     }\n \n   template<typename _CharT, typename _InIter>\n-    _InIter \n+    _InIter\n     time_get<_CharT, _InIter>::\n     do_get_monthname(iter_type __s, iter_type __end,\n-\t\t     ios_base& __io, ios_base::iostate& __err, tm* __t) const\n+                     ios_base& __io, ios_base::iostate& __err, tm* __t) const\n     {\n-      if (!_M_monthnames) \n-\t{\n-\t  _M_monthnames = new basic_string<_CharT>[24];\n-\t  for (int __i = 0; __i < 24; ++__i)\n-\t    _M_monthnames[__i] = _Monthnames<_CharT>::_S_names[__i];\n-\t}\n+      if (!_M_monthnames)\n+        {\n+          _M_monthnames = new basic_string<_CharT>[24];\n+          for (int __i = 0; __i < 24; ++__i)\n+            _M_monthnames[__i] = _Monthnames<_CharT>::_S_names[__i];\n+        }\n       bool __at_eof = false;\n       int __remain = 0;\n       int __matches[24];\n-      iter_type __out = __match_parallel( __s, __end, 24, _M_monthnames, \n-\t\t\t\t\t  __matches, __remain, __at_eof);\n+      iter_type __out = __match_parallel( __s, __end, 24, _M_monthnames,\n+                                          __matches, __remain, __at_eof);\n       __err = ios_base::iostate(0);\n       if (__at_eof) __err |= __io.eofbit;\n       if (__remain == 1 ||\n-\t  __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n-\t__t->tm_mon = (__matches[0]>>1);\n+          __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n+        __t->tm_mon = (__matches[0]>>1);\n       else\n-\t__err |= __io.failbit;\n+        __err |= __io.failbit;\n       return __out;\n     }\n-  \n+\n   template<typename _CharT, typename _OutIter>\n     locale::id time_put<_CharT, _OutIter>::id;\n \n@@ -1473,8 +1612,3 @@ namespace std\n // Local Variables:\n // mode:c++\n // End:\n-\n-\n-\n-\n-"}, {"sha": "df252ae508a082d4894367b474b4ab9866adcda0", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "patch": "@@ -4757,9 +4757,9 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n   \n \n-          ac_test_CFLAGS=\"${CFLAGS+set}\"\n-  ac_save_CFLAGS=\"$CFLAGS\"\n-  CFLAGS='-x c++'\n+        #  ac_test_CFLAGS=\"${CFLAGS+set}\"\n+#  ac_save_CFLAGS=\"$CFLAGS\"\n+#  CFLAGS='-x c++'\n \n     echo $ac_n \"checking for sin in -lm\"\"... $ac_c\" 1>&6\n echo \"configure:4766: checking for sin in -lm\" >&5\n@@ -4990,7 +4990,7 @@ done\n \n \n   LIBS=\"$save_LIBS\"\n-  CFLAGS=\"$ac_save_CFLAGS\"\n+#  CFLAGS=\"$ac_save_CFLAGS\"\n \n   \n     for ac_hdr in complex.h"}, {"sha": "fc754dc59126bbe5d963730c934e8721d5696dac", "filename": "libstdc++-v3/testsuite/27_io/istream_extractor_arith.cc", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f1063f8ecf5f6de2e5c013e6dd94c368349417d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream_extractor_arith.cc?ref=7f1063f8ecf5f6de2e5c013e6dd94c368349417d", "patch": "@@ -378,6 +378,110 @@ bool test09()\n   return test;\n }\n \n+bool test10() {\n+  std::string str_01(\"0 00 000 +0 +  0 -   0\");\n+  std::stringbuf isbuf_01(str_01);\n+  std::istream is_01(&isbuf_01);\n+\n+  bool test = true;\n+\n+  int n = 365;\n+  is_01 >> n;\n+  test &= n == 0;\n+  n = 364;\n+  is_01 >> n;\n+  test &= n == 0;\n+  n = 363;\n+  is_01 >> n;\n+  test &= n == 0;\n+  n = 362;\n+  is_01 >> n;\n+  test &= n == 0;\n+  n = 361;\n+  is_01 >> n;\n+  test &= n == 0;\n+  n = 360;\n+  is_01 >> n;\n+  test &= n == 0;\n+  test &= is_01.rdstate() == std::ios_base::eofbit;\n+\n+  std::string str_02(\"0x32 0X33 033 33\");\n+  std::stringbuf isbuf_02(str_02);\n+  std::istream is_02(&isbuf_02);\n+  is_02.unsetf(std::ios_base::basefield);\n+  is_02 >> n;\n+  test &= n == 50;\n+  is_02 >> n;\n+  test &= n == 51;\n+  is_02 >> n;\n+  test &= n == 27;\n+  is_02 >> n;\n+  test &= n == 33;\n+  test &= is_02.rdstate() == std::ios_base::eofbit;\n+\n+  std::stringbuf isbuf_03(str_02);\n+  std::istream is_03(&isbuf_03);\n+  char c;\n+  int m;\n+\n+  is_03 >> std::dec >> n >> c >> m;\n+  test &= n == 0;\n+  test &= c == 'x';\n+  test &= m == 32;\n+\n+  is_03 >> std::oct >> m >> c >> n;\n+  test &= m == 0;\n+  test &= c == 'X';\n+  test &= n == 27;\n+\n+  is_03 >> std::dec >> m >> n;\n+  test &= m == 33;\n+  test &= n == 33;\n+  test &= is_03.rdstate() == std::ios_base::eofbit;\n+\n+  std::string str_04(\"3. 4.5E+  2a5E-3 .6E1\");\n+  std::stringbuf isbuf_04(str_04);\n+  std::istream is_04(&isbuf_04);\n+\n+  double f;\n+  is_04 >> f;\n+  test &= f == 3.0;\n+  is_04 >> f;\n+  test &= f == 450.0;\n+  is_04.ignore();\n+  is_04 >> f;\n+  test &= f == 0.005;\n+  is_04 >> f;\n+  test &= f == 6;\n+  test &= is_03.rdstate() == std::ios_base::eofbit;\n+\n+  std::string str_05(\"0E20 5Ea E16\");\n+  std::stringbuf isbuf_05(str_05);\n+  std::istream is_05(&isbuf_05);\n+\n+  is_05 >> f;\n+  test &= f == 0;\n+  is_05 >> f;\n+  test &= f == 0;\n+  test &= is_05.rdstate() == std::ios_base::failbit;\n+  is_05.clear();\n+  is_05 >> c;\n+  test &= c == 'a';\n+  is_05 >> f;\n+  test &= f == 0;\n+  test &= is_05.rdstate() == std::ios_base::failbit;\n+  is_05.clear();\n+  is_05.ignore();\n+  is_05 >> n;\n+  test &= n == 16;\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n int main()\n {\n   test01();\n@@ -388,6 +492,7 @@ int main()\n   test07();\n   test08();\n   test09();\n+  test10();\n   return 0;\n }\n "}]}