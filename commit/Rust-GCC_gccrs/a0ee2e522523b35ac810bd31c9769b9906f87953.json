{"sha": "a0ee2e522523b35ac810bd31c9769b9906f87953", "node_id": "C_kwDOANBUbNoAKGEwZWUyZTUyMjUyM2IzNWFjODEwYmQzMWM5NzY5Yjk5MDZmODc5NTM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-06T09:26:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-12-06T09:26:09Z"}, "message": "range-op-float: Improve binary reverse operations\n\nOn Mon, Dec 05, 2022 at 02:29:36PM +0100, Aldy Hernandez wrote:\n> > So like this for multiplication op1/2_range if it passes bootstrap/regtest?\n> > For division I'll need to go to a drawing board...\n>\n> Sure, looks good to me.\n\nUlrich just filed PR107972, so in the light of that PR the following patch\nattempts to do that differently.\n\nAs for testcase, I've tried both attached testcases, but unfortunately it\nseems that in neither of the cases we actually figure out that res range\nis finite (or for last function non-zero ordered).  So there is further\nwork needed on that.\n\n2022-12-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/107972\n\t* range-op-float.cc (frange_drop_infs): New function.\n\t(float_binary_op_range_finish): Add DIV_OP2 argument.  If DIV_OP2 is\n\tfalse and lhs is finite or if DIV_OP2 is true and lhs is non-zero and\n\tnot NAN, r must be finite too.\n\t(foperator_div::op2_range): Pass true to DIV_OP2 of\n\tfloat_binary_op_range_finish.", "tree": {"sha": "6fda7268de978ba8c5c6de5b5993fcfc03584253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fda7268de978ba8c5c6de5b5993fcfc03584253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0ee2e522523b35ac810bd31c9769b9906f87953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ee2e522523b35ac810bd31c9769b9906f87953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ee2e522523b35ac810bd31c9769b9906f87953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ee2e522523b35ac810bd31c9769b9906f87953/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0525a7fad2a5b1d933a9662c11aa074b38cfa3d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0525a7fad2a5b1d933a9662c11aa074b38cfa3d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0525a7fad2a5b1d933a9662c11aa074b38cfa3d5"}], "stats": {"total": 33, "additions": 29, "deletions": 4}, "files": [{"sha": "c6c1137bafd1fd48c385dff3ff22203562031391", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0ee2e522523b35ac810bd31c9769b9906f87953/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0ee2e522523b35ac810bd31c9769b9906f87953/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=a0ee2e522523b35ac810bd31c9769b9906f87953", "patch": "@@ -330,6 +330,18 @@ frange_drop_ninf (frange &r, tree type)\n   r.intersect (tmp);\n }\n \n+// Crop R to [MIN, MAX] where MAX is the maximum representable number\n+// for TYPE and MIN the minimum representable number for TYPE.\n+\n+static inline void\n+frange_drop_infs (frange &r, tree type)\n+{\n+  REAL_VALUE_TYPE max = real_max_representable (type);\n+  REAL_VALUE_TYPE min = real_min_representable (type);\n+  frange tmp (type, min, max);\n+  r.intersect (tmp);\n+}\n+\n // If zero is in R, make sure both -0.0 and +0.0 are in the range.\n \n static inline void\n@@ -1883,7 +1895,7 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n \n static bool\n float_binary_op_range_finish (bool ret, frange &r, tree type,\n-\t\t\t      const frange &lhs)\n+\t\t\t      const frange &lhs, bool div_op2 = false)\n {\n   if (!ret)\n     return false;\n@@ -1904,7 +1916,20 @@ float_binary_op_range_finish (bool ret, frange &r, tree type,\n   // If lhs isn't NAN, then neither operand could be NAN,\n   // even if the reverse operation does introduce a maybe_nan.\n   if (!lhs.maybe_isnan ())\n-    r.clear_nan ();\n+    {\n+      r.clear_nan ();\n+      if (div_op2\n+\t  ? !(real_compare (LE_EXPR, &lhs.lower_bound (), &dconst0)\n+\t      && real_compare (GE_EXPR, &lhs.upper_bound (), &dconst0))\n+\t  : !(real_isinf (&lhs.lower_bound ())\n+\t      || real_isinf (&lhs.upper_bound ())))\n+\t// For reverse + or - or * or op1 of /, if result is finite, then\n+\t// r must be finite too, as X + INF or X - INF or X * INF or\n+\t// INF / X is always +-INF or NAN.  For op2 of /, if result is\n+\t// non-zero and not NAN, r must be finite, as X / INF is always\n+\t// 0 or NAN.\n+\tfrange_drop_infs (r, type);\n+    }\n   // If lhs is a maybe or known NAN, the operand could be\n   // NAN.\n   else\n@@ -2330,7 +2355,7 @@ class foperator_div : public foperator_mult_div_base\n     if (!ret)\n       return ret;\n     if (lhs.known_isnan () || op1.known_isnan () || op1.undefined_p ())\n-      return float_binary_op_range_finish (ret, r, type, lhs);\n+      return float_binary_op_range_finish (ret, r, type, lhs, true);\n     const REAL_VALUE_TYPE &lhs_lb = lhs.lower_bound ();\n     const REAL_VALUE_TYPE &lhs_ub = lhs.upper_bound ();\n     const REAL_VALUE_TYPE &op1_lb = op1.lower_bound ();\n@@ -2347,7 +2372,7 @@ class foperator_div : public foperator_mult_div_base\n \tzero_to_inf_range (lb, ub, signbit_known);\n \tr.set (type, lb, ub);\n       }\n-    return float_binary_op_range_finish (ret, r, type, lhs);\n+    return float_binary_op_range_finish (ret, r, type, lhs, true);\n   }\n private:\n   void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,"}]}