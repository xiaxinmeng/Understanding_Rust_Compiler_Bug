{"sha": "e1b7793c8ebdc72bd3d7283d70a29444da614c13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiNzc5M2M4ZWJkYzcyYmQzZDcyODNkNzBhMjk0NDRkYTYxNGMxMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-06-16T05:12:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-06-16T05:12:15Z"}, "message": "df-problems.c (df_simulate_one_insn_forwards): Fix braces in switch.\n\n./:\t* df-problems.c (df_simulate_one_insn_forwards): Fix braces in\n\tswitch.\n\t* gcov.c (read_count_file): Add braces around variables declared\n\tbefore label.\n\n\t* c.opt (Wjump-misses-init): New warning.\n\t* c-opts.c (c_common_handle_option): Set warn_jump_misses_init for\n\t-Wall and -Wc++-compat if not already set.\n\t(c_common_post_options): Clear warn_jump_misses_init if it was not\n\tset.\n\t* c-decl.c (struct c_binding): Change type field to a union with\n\tnew label field.  Make it the first field in the struct.  Update\n\treferences to type to use u.type instead.\n\t(struct c_spot_bindings): Define.\n\t(struct c_goto_bindings): Define.\n\t(c_goto_bindings_p): Define, along with VECs.\n\t(struct c_label_vars): Define.\n\t(struct c_scope): Add has_label_bindings field.\n\t(bind_label, set_spot_bindings): New static functions.\n\t(decl_jump_unsafe, update_spot_bindings): New static functions.\n\t(update_label_decls): New static function.\n\t(pop_scope): Call update_label_decls.  Don't call c_end_vm_scope.\n\tUpdate binding u.label field to shadowed field.\n\t(c_binding_start_stmt_expr): New function.\n\t(c_binding_end_stmt_expr): New function.\n\t(pushdecl): Don't call c_begin_vm_scope.\n\t(make_label): Add defining and p_label_vars parameters.  Change\n\tall callers.\n\t(lookup_label): Correct test for whether a label has not yet been\n\tdefined.  Call bind_label rather than bind.\n\t(warn_about_goto): New static function.\n\t(lookup_label_for_goto): New function.\n\t(declare_label): Call bind_label rather than bind.\n\t(check_earlier_gotos): New static function.\n\t(define_label): Don't give errors about jumping into statement\n\texpressions or scopes of variably modified types.  Call\n\tset_spot_bindings and check_earlier_gotos.  Call bind_label\n\tinstead of bind.  Don't set label_context_stack_se or\n\tlabel_context_stack_vm.\n\t(c_get_switch_bindings): New function.\n\t(c_release_switch_bindings): New function.\n\t(c_check_switch_jump_warnings): New function.\n\t(start_function): Don't set label_context_stack_se or\n\tlabel_context_stack_vm.\n\t(finish_function): Likewise.\n\t* c-typeck.c (label_context_stack_se): Don't define.\n\t(label_context_stack_vm): Don't define.\n\t(c_finish_goto_label): Call lookup_label_for_goto rather than\n\tlookup_label.  Don't give errors about jumping into a statement\n\texpression or the scope of a variably modified type.  Don't set\n\tlabel_context_stack_se or label_context_stack_vm.\n\t(struct c_switch): Remove blocked_stmt_expr and blocked_vm\n\tfields.  Add bindings field.\n\t(c_start_case): Don't set deleted fields.  Set bindings field.\n\t(do_case): Rework order of tests.  Don't check blocked_stmt_expr\n\tor blocked_vm.  Call c_check_switch_jump_warnings.\n\t(c_finish_case): Don't test blocked_stmt_expr field.  Call\n\tc_release_switch_bindings.\n\t(c_begin_stmt_expr): Don't increment blocked_stmt_expr in\n\tc_switch_stack.  Don't walk label_context_stack_se labels.  Don't\n\tset label_context_stack_se.  Call c_bindings_start_stmt_expr.\n\t(c_finish_stmt_expr): Don't decrement blocked_stmt_expr in\n\tc_switch_stack.  Don't walk label_context_stack_se labels.  Don't\n\tset label_context_stack_se.  Call c_bindings_end_stmt_expr.\n\t(c_begin_vm_scope, c_end_vm_scope): Don't define.\n\t* c-tree.h (C_DECL_UNJUMPABLE_STMT_EXPR): Don't define.\n\t(C_DECL_UNDEFINABLE_STMT_EXPR): Don't define.\n\t(C_DECL_UNJUMPABLE_VM): Don't define.\n\t(C_DECL_UNDEFINABLE_VM): Don't define.\n\t(struct c_label_list): Don't define.\n\t(struct c_label_context_se): Don't define.\n\t(struct c_label_context_vm): Don't define.\n\t(struct c_spot_bindings): Declare.\n\t(c_bindings_start_stmt_expr): Declare.\n\t(c_bindings_end_stmt_expr): Declare.\n\t(lookup_label_for_goto): Declare.\n\t(c_get_switch_bindings, c_release_switch_bindings): Declare.\n\t(c_check_switch_jump_warnings): Declare.\n\t(label_context_stack_se, label_context_stack_vm): Don't declare.\n\t(c_finish_goto_label): Update declaration.\n\t(c_begin_vm_scope, c_end_vm_scope): Don't declare.\n\t* doc/invoke.texi (Option Summary): Mention -Wjump-misses-init.\n\t(Warning Options): Document -Wjump-misses-init.\ncp/:\n\t* parser.c (cp_parser_direct_declarator): Add braces around\n\tvariables declared before label.\nobjc/:\n\t* objc-act.c (objc_start_function): Don't set\n\tlabel_context_stack_se or label_context_stack_vm.\ntestsuite/:\n\t* gcc.dg/Wjump-misses-init-1.c: New testcase.\n\t* gcc.dg/Wjump-misses-init-2.c: New testcase.\n\t* gcc.dg/c99-vla-jump-5.c: Adjust expected error messages.\n\tRecognize new notes.\n\t* gcc.dg/stmt-expr-label-2.c: Likewise.\n\t* gcc.dg/c99-vla-jump-1.c: Recognize new notes.  Fix column\n\tnumbers.\n\t* gcc.dg/c99-vla-jump-2.c: Recognize new notes.\n\t* gcc.dg/c99-vla-jump-3.c: Recognize new notes.\n\t* gcc.dg/c99-vla-jump-4.c: Likewise.\n\t* gcc.dg/stmt-expr-label-1.c: Likewise.\n\t* gcc.dg/stmt-expr-label-3.c: Likewise.\n\t* gcc.dg/vla-8.c: Likewise.  Move error message to different\n\tline.\n\nFrom-SVN: r148512", "tree": {"sha": "8497f69348fcfb23ffa019c746e037539cb42cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8497f69348fcfb23ffa019c746e037539cb42cc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1b7793c8ebdc72bd3d7283d70a29444da614c13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b7793c8ebdc72bd3d7283d70a29444da614c13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b7793c8ebdc72bd3d7283d70a29444da614c13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b7793c8ebdc72bd3d7283d70a29444da614c13/comments", "author": null, "committer": null, "parents": [{"sha": "dee6f5752949e9c53e1706925ad934760bcab775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee6f5752949e9c53e1706925ad934760bcab775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee6f5752949e9c53e1706925ad934760bcab775"}], "stats": {"total": 1760, "additions": 1190, "deletions": 570}, "files": [{"sha": "fd13b180a2b66aef44bbf65f0f8f3785a742d1c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -1,3 +1,89 @@\n+2009-06-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* df-problems.c (df_simulate_one_insn_forwards): Fix braces in\n+\tswitch.\n+\t* gcov.c (read_count_file): Add braces around variables declared\n+\tbefore label.\n+\n+\t* c.opt (Wjump-misses-init): New warning.\n+\t* c-opts.c (c_common_handle_option): Set warn_jump_misses_init for\n+\t-Wall and -Wc++-compat if not already set.\n+\t(c_common_post_options): Clear warn_jump_misses_init if it was not\n+\tset.\n+\t* c-decl.c (struct c_binding): Change type field to a union with\n+\tnew label field.  Make it the first field in the struct.  Update\n+\treferences to type to use u.type instead.\n+\t(struct c_spot_bindings): Define.\n+\t(struct c_goto_bindings): Define.\n+\t(c_goto_bindings_p): Define, along with VECs.\n+\t(struct c_label_vars): Define.\n+\t(struct c_scope): Add has_label_bindings field.\n+\t(bind_label, set_spot_bindings): New static functions.\n+\t(decl_jump_unsafe, update_spot_bindings): New static functions.\n+\t(update_label_decls): New static function.\n+\t(pop_scope): Call update_label_decls.  Don't call c_end_vm_scope.\n+\tUpdate binding u.label field to shadowed field.\n+\t(c_binding_start_stmt_expr): New function.\n+\t(c_binding_end_stmt_expr): New function.\n+\t(pushdecl): Don't call c_begin_vm_scope.\n+\t(make_label): Add defining and p_label_vars parameters.  Change\n+\tall callers.\n+\t(lookup_label): Correct test for whether a label has not yet been\n+\tdefined.  Call bind_label rather than bind.\n+\t(warn_about_goto): New static function.\n+\t(lookup_label_for_goto): New function.\n+\t(declare_label): Call bind_label rather than bind.\n+\t(check_earlier_gotos): New static function.\n+\t(define_label): Don't give errors about jumping into statement\n+\texpressions or scopes of variably modified types.  Call\n+\tset_spot_bindings and check_earlier_gotos.  Call bind_label\n+\tinstead of bind.  Don't set label_context_stack_se or\n+\tlabel_context_stack_vm.\n+\t(c_get_switch_bindings): New function.\n+\t(c_release_switch_bindings): New function.\n+\t(c_check_switch_jump_warnings): New function.\n+\t(start_function): Don't set label_context_stack_se or\n+\tlabel_context_stack_vm.\n+\t(finish_function): Likewise.\n+\t* c-typeck.c (label_context_stack_se): Don't define.\n+\t(label_context_stack_vm): Don't define.\n+\t(c_finish_goto_label): Call lookup_label_for_goto rather than\n+\tlookup_label.  Don't give errors about jumping into a statement\n+\texpression or the scope of a variably modified type.  Don't set\n+\tlabel_context_stack_se or label_context_stack_vm.\n+\t(struct c_switch): Remove blocked_stmt_expr and blocked_vm\n+\tfields.  Add bindings field.\n+\t(c_start_case): Don't set deleted fields.  Set bindings field.\n+\t(do_case): Rework order of tests.  Don't check blocked_stmt_expr\n+\tor blocked_vm.  Call c_check_switch_jump_warnings.\n+\t(c_finish_case): Don't test blocked_stmt_expr field.  Call\n+\tc_release_switch_bindings.\n+\t(c_begin_stmt_expr): Don't increment blocked_stmt_expr in\n+\tc_switch_stack.  Don't walk label_context_stack_se labels.  Don't\n+\tset label_context_stack_se.  Call c_bindings_start_stmt_expr.\n+\t(c_finish_stmt_expr): Don't decrement blocked_stmt_expr in\n+\tc_switch_stack.  Don't walk label_context_stack_se labels.  Don't\n+\tset label_context_stack_se.  Call c_bindings_end_stmt_expr.\n+\t(c_begin_vm_scope, c_end_vm_scope): Don't define.\n+\t* c-tree.h (C_DECL_UNJUMPABLE_STMT_EXPR): Don't define.\n+\t(C_DECL_UNDEFINABLE_STMT_EXPR): Don't define.\n+\t(C_DECL_UNJUMPABLE_VM): Don't define.\n+\t(C_DECL_UNDEFINABLE_VM): Don't define.\n+\t(struct c_label_list): Don't define.\n+\t(struct c_label_context_se): Don't define.\n+\t(struct c_label_context_vm): Don't define.\n+\t(struct c_spot_bindings): Declare.\n+\t(c_bindings_start_stmt_expr): Declare.\n+\t(c_bindings_end_stmt_expr): Declare.\n+\t(lookup_label_for_goto): Declare.\n+\t(c_get_switch_bindings, c_release_switch_bindings): Declare.\n+\t(c_check_switch_jump_warnings): Declare.\n+\t(label_context_stack_se, label_context_stack_vm): Don't declare.\n+\t(c_finish_goto_label): Update declaration.\n+\t(c_begin_vm_scope, c_end_vm_scope): Don't declare.\n+\t* doc/invoke.texi (Option Summary): Mention -Wjump-misses-init.\n+\t(Warning Options): Document -Wjump-misses-init.\n+\n 2009-06-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-object-size.c (addr_object_size): Fix a pasto in the last"}, {"sha": "c2c2a890c9d83c58aabff2f162a354fb4ffec8ce", "filename": "gcc/c-decl.c", "status": "modified", "additions": 565, "deletions": 79, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -188,7 +188,7 @@ bool c_override_global_bindings_to_false;\n    suppress further errors about that identifier in the current\n    function.\n \n-   The ->type field stores the type of the declaration in this scope;\n+   The ->u.type field stores the type of the declaration in this scope;\n    if NULL, the type is the type of the ->decl field.  This is only of\n    relevance for objects with external or internal linkage which may\n    be redeclared in inner scopes, forming composite types that only\n@@ -198,6 +198,9 @@ bool c_override_global_bindings_to_false;\n    scope) stores whether an incomplete array type at file scope was\n    completed at an inner scope to an array size other than 1.\n \n+   The ->u.label field is used for labels.  It points to a structure\n+   which stores additional information used for warnings.\n+\n    The depth field is copied from the scope structure that holds this\n    decl.  It is used to preserve the proper ordering of the ->shadowed\n    field (see bind()) and also for a handful of special-case checks.\n@@ -208,8 +211,11 @@ bool c_override_global_bindings_to_false;\n    invisible bit true.  */\n \n struct GTY((chain_next (\"%h.prev\"))) c_binding {\n+  union GTY(()) {\t\t/* first so GTY desc can use decl */\n+    tree GTY((tag (\"0\"))) type; /* the type in this scope */\n+    struct c_label_vars * GTY((tag (\"1\"))) label; /* for warnings */\n+  } GTY((desc (\"TREE_CODE (%0.decl) == LABEL_DECL\"))) u;\n   tree decl;\t\t\t/* the decl bound */\n-  tree type;\t\t\t/* the type in this scope */\n   tree id;\t\t\t/* the identifier it's bound to */\n   struct c_binding *prev;\t/* the previous decl in this scope */\n   struct c_binding *shadowed;\t/* the innermost decl shadowed by this one */\n@@ -266,6 +272,67 @@ union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n   struct lang_identifier GTY ((tag (\"1\"))) identifier;\n };\n \n+/* Track bindings and other things that matter for goto warnings.  For\n+   efficiency, we do not gather all the decls at the point of\n+   definition.  Instead, we point into the bindings structure.  As\n+   scopes are popped, we update these structures and gather the decls\n+   that matter at that time.  */\n+\n+struct GTY(()) c_spot_bindings {\n+  /* The currently open scope which holds bindings defined when the\n+     label was defined or the goto statement was found.  */\n+  struct c_scope *scope;\n+  /* The bindings in the scope field which were defined at the point\n+     of the label or goto.  This lets us look at older or newer\n+     bindings in the scope, as appropriate.  */\n+  struct c_binding *bindings_in_scope;\n+  /* The number of statement expressions that have started since this\n+     label or goto statement was defined.  This is zero if we are at\n+     the same statement expression level.  It is positive if we are in\n+     a statement expression started since this spot.  It is negative\n+     if this spot was in a statement expression and we have left\n+     it.  */\n+  int stmt_exprs;\n+  /* Whether we started in a statement expression but are no longer in\n+     it.  This is set to true if stmt_exprs ever goes negative.  */\n+  bool left_stmt_expr;\n+};\n+\n+/* This structure is used to keep track of bindings seen when a goto\n+   statement is defined.  This is only used if we see the goto\n+   statement before we see the label.  */\n+\n+struct GTY(()) c_goto_bindings {\n+  /* The location of the goto statement.  */\n+  location_t loc;\n+  /* The bindings of the goto statement.  */\n+  struct c_spot_bindings goto_bindings;\n+};\n+\n+typedef struct c_goto_bindings *c_goto_bindings_p;\n+DEF_VEC_P(c_goto_bindings_p);\n+DEF_VEC_ALLOC_P(c_goto_bindings_p,gc);\n+\n+/* The additional information we keep track of for a label binding.\n+   These fields are updated as scopes are popped.  */\n+\n+struct GTY(()) c_label_vars {\n+  /* The shadowed c_label_vars, when one label shadows another (which\n+     can only happen using a __label__ declaration).  */\n+  struct c_label_vars *shadowed;\n+  /* The bindings when the label was defined.  */\n+  struct c_spot_bindings label_bindings;\n+  /* A list of decls that we care about: decls about which we should\n+     warn if a goto branches to this label from later in the function.\n+     Decls are added to this list as scopes are popped.  We only add\n+     the decls that matter.  */\n+  VEC(tree,gc) *decls_in_scope;\n+  /* A list of goto statements to this label.  This is only used for\n+     goto statements seen before the label was defined, so that we can\n+     issue appropriate warnings for them.  */\n+  VEC(c_goto_bindings_p,gc) *gotos;\n+};\n+\n /* Each c_scope structure describes the complete contents of one\n    scope.  Four scopes are distinguished specially: the innermost or\n    current scope, the innermost function scope, the file scope (always\n@@ -354,6 +421,11 @@ struct GTY((chain_next (\"%h.outer\"))) c_scope {\n \n   /* True means that an unsuffixed float constant is _Decimal64.  */\n   BOOL_BITFIELD float_const_decimal64 : 1;\n+\n+  /* True if this scope has any label bindings.  This is used to speed\n+     up searching for labels when popping scopes, particularly since\n+     labels are normally only found at function scope.  */\n+  BOOL_BITFIELD has_label_bindings : 1;\n };\n \n /* The scope currently in effect.  */\n@@ -518,7 +590,7 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible,\n   b->inner_comp = 0;\n   b->locus = locus;\n \n-  b->type = 0;\n+  b->u.type = NULL;\n \n   b->prev = scope->bindings;\n   scope->bindings = b;\n@@ -569,6 +641,24 @@ free_binding_and_advance (struct c_binding *b)\n   return prev;\n }\n \n+/* Bind a label.  Like bind, but skip fields which aren't used for\n+   labels, and add the LABEL_VARS value.  */\n+static void\n+bind_label (tree name, tree label, struct c_scope *scope,\n+\t    struct c_label_vars *label_vars)\n+{\n+  struct c_binding *b;\n+\n+  bind (name, label, scope, /*invisible=*/false, /*nested=*/false,\n+\tUNKNOWN_LOCATION);\n+\n+  scope->has_label_bindings = true;\n+\n+  b = scope->bindings;\n+  gcc_assert (b->decl == label);\n+  label_vars->shadowed = b->u.label;\n+  b->u.label = label_vars;\n+}\n \f\n /* Hook called at end of compilation to assume 1 elt\n    for a file-scope tentative array defn that wasn't complete before.  */\n@@ -641,6 +731,73 @@ check_inline_statics (void)\n   c_inline_statics = NULL;\n }\n \f\n+/* Fill in a c_spot_bindings structure.  If DEFINING is true, set it\n+   for the current state, otherwise set it to uninitialized.  */\n+\n+static void\n+set_spot_bindings (struct c_spot_bindings *p, bool defining)\n+{\n+  if (defining)\n+    {\n+      p->scope = current_scope;\n+      p->bindings_in_scope = current_scope->bindings;\n+    }\n+  else\n+    {\n+      p->scope = NULL;\n+      p->bindings_in_scope = NULL;\n+    }\n+  p->stmt_exprs = 0;\n+  p->left_stmt_expr = false;\n+}\n+\n+/* Return true if we will want to say something if a goto statement\n+   crosses DECL.  */\n+\n+static bool\n+decl_jump_unsafe (tree decl)\n+{\n+  if (decl == error_mark_node || TREE_TYPE (decl) == error_mark_node)\n+    return false;\n+\n+  /* Always warn about crossing variably modified types.  */\n+  if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == TYPE_DECL)\n+      && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+    return true;\n+\n+  /* Otherwise, only warn if -Wgoto-misses-init and this is an\n+     initialized automatic decl.  */\n+  if (warn_jump_misses_init\n+      && TREE_CODE (decl) == VAR_DECL\n+      && !TREE_STATIC (decl)\n+      && DECL_INITIAL (decl) != NULL_TREE)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Update spot bindings P as we pop out of SCOPE.  Return true if we\n+   should push decls for a label.  */\n+\n+static bool\n+update_spot_bindings (struct c_scope *scope, struct c_spot_bindings *p)\n+{\n+  if (p->scope != scope)\n+    {\n+      /* This label or goto is defined in some other scope, or it is a\n+\t label which is not yet defined.  There is nothing to\n+\t update.  */\n+      return false;\n+    }\n+\n+  /* Adjust the spot bindings to refer to the bindings already defined\n+     in the enclosing scope.  */\n+  p->scope = scope->outer;\n+  p->bindings_in_scope = p->scope->bindings;\n+\n+  return true;\n+}\n+\f\n /* The Objective-C front-end often needs to determine the current scope.  */\n \n void *\n@@ -784,6 +941,67 @@ push_scope (void)\n     }\n }\n \n+/* This is called when we are leaving SCOPE.  For each label defined\n+   in SCOPE, add any appropriate decls to its decls_in_scope fields.\n+   These are the decls whose initialization will be skipped by a goto\n+   later in the function.  */\n+\n+static void\n+update_label_decls (struct c_scope *scope)\n+{\n+  struct c_scope *s;\n+\n+  s = scope;\n+  while (s != NULL)\n+    {\n+      if (s->has_label_bindings)\n+\t{\n+\t  struct c_binding *b;\n+\n+\t  for (b = s->bindings; b != NULL; b = b->prev)\n+\t    {\n+\t      struct c_label_vars *label_vars;\n+\t      struct c_binding *b1;\n+\t      unsigned int ix;\n+\t      struct c_goto_bindings *g;\n+\n+\t      if (TREE_CODE (b->decl) != LABEL_DECL)\n+\t\tcontinue;\n+\t      label_vars = b->u.label;\n+\n+\t      b1 = label_vars->label_bindings.bindings_in_scope;\n+\t      if (update_spot_bindings (scope, &label_vars->label_bindings))\n+\t\t{\n+\t\t  /* This label is defined in this scope.  */\n+\t\t  for (; b1 != NULL;  b1 = b1->prev)\n+\t\t    {\n+\t\t      /* A goto from later in the function to this\n+\t\t\t label will never see the initialization of\n+\t\t\t B1, if any.  Save it to issue a warning if\n+\t\t\t needed.  */\n+\t\t      if (decl_jump_unsafe (b1->decl))\n+\t\t\tVEC_safe_push (tree, gc, label_vars->decls_in_scope,\n+\t\t\t\t       b1->decl);\n+\t\t    }\n+\t\t}\n+\n+\t      /* Update the bindings of any goto statements associated\n+\t\t with this label.  */\n+\t      for (ix = 0;\n+\t\t   VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n+\t\t   ++ix)\n+\t\tupdate_spot_bindings (scope, &g->goto_bindings);\n+\t    }\n+\t}\n+\n+      /* Don't search beyond the current function.  */\n+      if (s == current_function_scope)\n+\tbreak;\n+\n+      s = s->outer;\n+    }\n+}\n+\n /* Set the TYPE_CONTEXT of all of TYPE's variants to CONTEXT.  */\n \n static void\n@@ -809,7 +1027,7 @@ pop_scope (void)\n   bool functionbody = scope->function_body;\n   bool keep = functionbody || scope->keep || scope->bindings;\n \n-  c_end_vm_scope (scope->depth);\n+  update_label_decls (scope);\n \n   /* If appropriate, create a BLOCK to record the decls for the life\n      of this function.  */\n@@ -874,6 +1092,10 @@ pop_scope (void)\n \t  BLOCK_VARS (block) = p;\n \t  gcc_assert (I_LABEL_BINDING (b->id) == b);\n \t  I_LABEL_BINDING (b->id) = b->shadowed;\n+\n+\t  /* Also pop back to the shadowed label_vars.  */\n+\t  release_tree_vector (b->u.label->decls_in_scope);\n+\t  b->u.label = b->u.label->shadowed;\n \t  break;\n \n \tcase ENUMERAL_TYPE:\n@@ -999,8 +1221,8 @@ pop_scope (void)\n \t    {\n \t      gcc_assert (I_SYMBOL_BINDING (b->id) == b);\n \t      I_SYMBOL_BINDING (b->id) = b->shadowed;\n-\t      if (b->shadowed && b->shadowed->type)\n-\t\tTREE_TYPE (b->shadowed->decl) = b->shadowed->type;\n+\t      if (b->shadowed && b->shadowed->u.type)\n+\t\tTREE_TYPE (b->shadowed->decl) = b->shadowed->u.type;\n \t    }\n \t  break;\n \n@@ -1087,7 +1309,91 @@ pop_file_scope (void)\n   maybe_apply_pending_pragma_weaks ();\n   cgraph_finalize_compilation_unit ();\n }\n+\f\n+/* Adjust the bindings for the start of a statement expression.  */\n+\n+void\n+c_bindings_start_stmt_expr (struct c_spot_bindings* switch_bindings)\n+{\n+  struct c_scope *scope;\n+\n+  for (scope = current_scope; scope != NULL; scope = scope->outer)\n+    {\n+      struct c_binding *b;\n+\n+      if (!scope->has_label_bindings)\n+\tcontinue;\n+\n+      for (b = scope->bindings; b != NULL; b = b->prev)\n+\t{\n+\t  struct c_label_vars *label_vars;\n+\t  unsigned int ix;\n+\t  struct c_goto_bindings *g;\n+\n+\t  if (TREE_CODE (b->decl) != LABEL_DECL)\n+\t    continue;\n+\t  label_vars = b->u.label;\n+\t  ++label_vars->label_bindings.stmt_exprs;\n+\t  for (ix = 0;\n+\t       VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n+\t       ++ix)\n+\t    ++g->goto_bindings.stmt_exprs;\n+\t}\n+    }\n+\n+  if (switch_bindings != NULL)\n+    ++switch_bindings->stmt_exprs;\n+}\n+\n+/* Adjust the bindings for the end of a statement expression.  */\n+\n+void\n+c_bindings_end_stmt_expr (struct c_spot_bindings *switch_bindings)\n+{\n+  struct c_scope *scope;\n+\n+  for (scope = current_scope; scope != NULL; scope = scope->outer)\n+    {\n+      struct c_binding *b;\n+\n+      if (!scope->has_label_bindings)\n+\tcontinue;\n+\n+      for (b = scope->bindings; b != NULL; b = b->prev)\n+\t{\n+\t  struct c_label_vars *label_vars;\n+\t  unsigned int ix;\n+\t  struct c_goto_bindings *g;\n+\n+\t  if (TREE_CODE (b->decl) != LABEL_DECL)\n+\t    continue;\n+\t  label_vars = b->u.label;\n+\t  --label_vars->label_bindings.stmt_exprs;\n+\t  if (label_vars->label_bindings.stmt_exprs < 0)\n+\t    {\n+\t      label_vars->label_bindings.left_stmt_expr = true;\n+\t      label_vars->label_bindings.stmt_exprs = 0;\n+\t    }\n+\t  for (ix = 0;\n+\t       VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n+\t       ++ix)\n+\t    {\n+\t      --g->goto_bindings.stmt_exprs;\n+\t      if (g->goto_bindings.stmt_exprs < 0)\n+\t\t{\n+\t\t  g->goto_bindings.left_stmt_expr = true;\n+\t\t  g->goto_bindings.stmt_exprs = 0;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n+  if (switch_bindings != NULL)\n+    {\n+      --switch_bindings->stmt_exprs;\n+      gcc_assert (switch_bindings->stmt_exprs >= 0);\n+    }\n+}\n \f\n /* Push a definition or a declaration of struct, union or enum tag \"name\".\n    \"type\" should be the type node.\n@@ -2182,12 +2488,6 @@ pushdecl (tree x)\n \t  || DECL_INITIAL (x) || !DECL_EXTERNAL (x)))\n     DECL_CONTEXT (x) = current_function_decl;\n \n-  /* If this is of variably modified type, prevent jumping into its\n-     scope.  */\n-  if ((TREE_CODE (x) == VAR_DECL || TREE_CODE (x) == TYPE_DECL)\n-      && variably_modified_type_p (TREE_TYPE (x), NULL_TREE))\n-    c_begin_vm_scope (scope->depth);\n-\n   /* Anonymous decls are just inserted in the scope.  */\n   if (!name)\n     {\n@@ -2226,8 +2526,8 @@ pushdecl (tree x)\n \t  if (b_ext)\n \t    {\n \t      b_use = b_ext;\n-\t      if (b_use->type)\n-\t\tTREE_TYPE (b_use->decl) = b_use->type;\n+\t      if (b_use->u.type)\n+\t\tTREE_TYPE (b_use->decl) = b_use->u.type;\n \t    }\n \t}\n       if (duplicate_decls (x, b_use->decl))\n@@ -2241,13 +2541,13 @@ pushdecl (tree x)\n \t\tthistype = composite_type (vistype, type);\n \t      else\n \t\tthistype = TREE_TYPE (b_use->decl);\n-\t      b_use->type = TREE_TYPE (b_use->decl);\n+\t      b_use->u.type = TREE_TYPE (b_use->decl);\n \t      if (TREE_CODE (b_use->decl) == FUNCTION_DECL\n \t\t  && DECL_BUILT_IN (b_use->decl))\n \t\tthistype\n \t\t  = build_type_attribute_variant (thistype,\n \t\t\t\t\t\t  TYPE_ATTRIBUTES\n-\t\t\t\t\t\t  (b_use->type));\n+\t\t\t\t\t\t  (b_use->u.type));\n \t      TREE_TYPE (b_use->decl) = thistype;\n \t    }\n \t  return b_use->decl;\n@@ -2298,7 +2598,7 @@ pushdecl (tree x)\n \t     their scopes will not have been re-entered.  */\n \t  if (DECL_P (b->decl) && DECL_FILE_SCOPE_P (b->decl) && !type_saved)\n \t    {\n-\t      b->type = TREE_TYPE (b->decl);\n+\t      b->u.type = TREE_TYPE (b->decl);\n \t      type_saved = true;\n \t    }\n \t  if (B_IN_FILE_SCOPE (b)\n@@ -2324,8 +2624,8 @@ pushdecl (tree x)\n \t After the consistency checks, it will be reset to the\n \t composite of the visible types only.  */\n       if (b && (TREE_PUBLIC (x) || same_translation_unit_p (x, b->decl))\n-\t  && b->type)\n-\tTREE_TYPE (b->decl) = b->type;\n+\t  && b->u.type)\n+\tTREE_TYPE (b->decl) = b->u.type;\n \n       /* The point of the same_translation_unit_p check here is,\n \t we want to detect a duplicate decl for a construct like\n@@ -2346,11 +2646,11 @@ pushdecl (tree x)\n \t    }\n \t  else\n \t    thistype = type;\n-\t  b->type = TREE_TYPE (b->decl);\n+\t  b->u.type = TREE_TYPE (b->decl);\n \t  if (TREE_CODE (b->decl) == FUNCTION_DECL && DECL_BUILT_IN (b->decl))\n \t    thistype\n \t      = build_type_attribute_variant (thistype,\n-\t\t\t\t\t      TYPE_ATTRIBUTES (b->type));\n+\t\t\t\t\t      TYPE_ATTRIBUTES (b->u.type));\n \t  TREE_TYPE (b->decl) = thistype;\n \t  bind (name, b->decl, scope, /*invisible=*/false, /*nested=*/true,\n \t\tlocus);\n@@ -2500,8 +2800,8 @@ implicitly_declare (location_t loc, tree functionid)\n       else\n \t{\n \t  tree newtype = default_function_type;\n-\t  if (b->type)\n-\t    TREE_TYPE (decl) = b->type;\n+\t  if (b->u.type)\n+\t    TREE_TYPE (decl) = b->u.type;\n \t  /* Implicit declaration of a function already declared\n \t     (somehow) in a different scope, or as a built-in.\n \t     If this is the first time this has happened, warn;\n@@ -2531,7 +2831,7 @@ implicitly_declare (location_t loc, tree functionid)\n \t\t  locate_old_decl (decl);\n \t\t}\n \t    }\n-\t  b->type = TREE_TYPE (decl);\n+\t  b->u.type = TREE_TYPE (decl);\n \t  TREE_TYPE (decl) = newtype;\n \t  bind (functionid, decl, current_scope,\n \t\t/*invisible=*/false, /*nested=*/true,\n@@ -2603,16 +2903,26 @@ undeclared_variable (location_t loc, tree id)\n }\n \f\n /* Subroutine of lookup_label, declare_label, define_label: construct a\n-   LABEL_DECL with all the proper frills.  */\n+   LABEL_DECL with all the proper frills.  Also create a struct\n+   c_label_vars initialized for the current scope.  */\n \n static tree\n-make_label (location_t location, tree name)\n+make_label (location_t location, tree name, bool defining,\n+\t    struct c_label_vars **p_label_vars)\n {\n   tree label = build_decl (location, LABEL_DECL, name, void_type_node);\n+  struct c_label_vars *label_vars;\n \n   DECL_CONTEXT (label) = current_function_decl;\n   DECL_MODE (label) = VOIDmode;\n \n+  label_vars = GGC_NEW (struct c_label_vars);\n+  label_vars->shadowed = NULL;\n+  set_spot_bindings (&label_vars->label_bindings, defining);\n+  label_vars->decls_in_scope = make_tree_vector ();\n+  label_vars->gotos = VEC_alloc (c_goto_bindings_p, gc, 0);\n+  *p_label_vars = label_vars;\n+\n   return label;\n }\n \n@@ -2625,6 +2935,7 @@ tree\n lookup_label (tree name)\n {\n   tree label;\n+  struct c_label_vars *label_vars;\n \n   if (current_function_decl == 0)\n     {\n@@ -2642,17 +2953,91 @@ lookup_label (tree name)\n       /* If the label has only been declared, update its apparent\n \t location to point here, for better diagnostics if it\n \t turns out not to have been defined.  */\n-      if (!TREE_USED (label))\n+      if (DECL_INITIAL (label) == NULL_TREE)\n \tDECL_SOURCE_LOCATION (label) = input_location;\n       return label;\n     }\n \n   /* No label binding for that identifier; make one.  */\n-  label = make_label (input_location, name);\n+  label = make_label (input_location, name, false, &label_vars);\n \n   /* Ordinary labels go in the current function scope.  */\n-  bind (name, label, current_function_scope,\n-\t/*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n+  bind_label (name, label, current_function_scope, label_vars);\n+\n+  return label;\n+}\n+\n+/* Issue a warning about DECL for a goto statement at GOTO_LOC going\n+   to LABEL.  */\n+\n+static void\n+warn_about_goto (location_t goto_loc, tree label, tree decl)\n+{\n+  if (variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+    error_at (goto_loc,\n+\t      \"jump into scope of identifier with variably modified type\");\n+  else\n+    warning_at (goto_loc, OPT_Wjump_misses_init,\n+\t\t\"jump skips variable initialization\");\n+  inform (DECL_SOURCE_LOCATION (label), \"label %qD defined here\", label);\n+  inform (DECL_SOURCE_LOCATION (decl), \"%qD declared here\", decl);\n+}\n+\n+/* Look up a label because of a goto statement.  This is like\n+   lookup_label, but also issues any appropriate warnings.  */\n+\n+tree\n+lookup_label_for_goto (location_t loc, tree name)\n+{\n+  tree label;\n+  struct c_label_vars *label_vars;\n+  unsigned int ix;\n+  tree decl;\n+\n+  label = lookup_label (name);\n+  if (label == NULL_TREE)\n+    return NULL_TREE;\n+\n+  /* If we are jumping to a different function, we can't issue any\n+     useful warnings.  */\n+  if (DECL_CONTEXT (label) != current_function_decl)\n+    {\n+      gcc_assert (C_DECLARED_LABEL_FLAG (label));\n+      return label;\n+    }\n+\n+  label_vars = I_LABEL_BINDING (name)->u.label;\n+\n+  /* If the label has not yet been defined, then push this goto on a\n+     list for possible later warnings.  */\n+  if (label_vars->label_bindings.scope == NULL)\n+    {\n+      struct c_goto_bindings *g;\n+\n+      g = GGC_NEW (struct c_goto_bindings);\n+      g->loc = loc;\n+      set_spot_bindings (&g->goto_bindings, true);\n+      VEC_safe_push (c_goto_bindings_p, gc, label_vars->gotos, g);\n+      return label;\n+    }\n+\n+  /* If there are any decls in label_vars->decls_in_scope, then this\n+     goto has missed the declaration of the decl.  This happens for a\n+     case like\n+       int i = 1;\n+      lab:\n+       ...\n+       goto lab;\n+     Issue a warning or error.  */\n+  for (ix = 0; VEC_iterate (tree, label_vars->decls_in_scope, ix, decl); ++ix)\n+    warn_about_goto (loc, label, decl);\n+\n+  if (label_vars->label_bindings.left_stmt_expr)\n+    {\n+      error_at (loc, \"jump into statement expression\");\n+      inform (DECL_SOURCE_LOCATION (label), \"label %qD defined here\", label);\n+    }\n+\n   return label;\n }\n \n@@ -2665,6 +3050,7 @@ declare_label (tree name)\n {\n   struct c_binding *b = I_LABEL_BINDING (name);\n   tree label;\n+  struct c_label_vars *label_vars;\n \n   /* Check to make sure that the label hasn't already been declared\n      at this scope */\n@@ -2677,15 +3063,74 @@ declare_label (tree name)\n       return b->decl;\n     }\n \n-  label = make_label (input_location, name);\n+  label = make_label (input_location, name, false, &label_vars);\n   C_DECLARED_LABEL_FLAG (label) = 1;\n \n   /* Declared labels go in the current scope.  */\n-  bind (name, label, current_scope,\n-\t/*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n+  bind_label (name, label, current_scope, label_vars);\n+\n   return label;\n }\n \n+/* When we define a label, issue any appropriate warnings if there are\n+   any gotos earlier in the function which jump to this label.  */\n+\n+static void\n+check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n+{\n+  unsigned int ix;\n+  struct c_goto_bindings *g;\n+\n+  for (ix = 0;\n+       VEC_iterate (c_goto_bindings_p, label_vars->gotos, ix, g);\n+       ++ix)\n+    {\n+      struct c_binding *b;\n+      struct c_scope *scope;\n+\n+      /* We have a goto to this label.  The goto is going forward.  In\n+\t g->scope, the goto is going to skip any binding which was\n+\t defined after g->bindings_in_scope.  */\n+      for (b = g->goto_bindings.scope->bindings;\n+\t   b != g->goto_bindings.bindings_in_scope;\n+\t   b = b->prev)\n+\t{\n+\t  if (decl_jump_unsafe (b->decl))\n+\t    warn_about_goto (g->loc, label, b->decl);\n+\t}\n+\n+      /* We also need to warn about decls defined in any scopes\n+\t between the scope of the label and the scope of the goto.  */\n+      for (scope = label_vars->label_bindings.scope;\n+\t   scope != g->goto_bindings.scope;\n+\t   scope = scope->outer)\n+\t{\n+\t  gcc_assert (scope != NULL);\n+\t  if (scope == label_vars->label_bindings.scope)\n+\t    b = label_vars->label_bindings.bindings_in_scope;\n+\t  else\n+\t    b = scope->bindings;\n+\t  for (; b != NULL; b = b->prev)\n+\t    {\n+\t      if (decl_jump_unsafe (b->decl))\n+\t\twarn_about_goto (g->loc, label, b->decl);\n+\t    }\n+\t}\n+\n+      if (g->goto_bindings.stmt_exprs > 0)\n+\t{\n+\t  error_at (g->loc, \"jump into statement expression\");\n+\t  inform (DECL_SOURCE_LOCATION (label), \"label %qD defined here\",\n+\t\t  label);\n+\t}\n+    }\n+\n+  /* Now that the label is defined, we will issue warnings about\n+     subsequent gotos to this label when we see them.  */\n+  VEC_truncate (c_goto_bindings_p, label_vars->gotos, 0);\n+  label_vars->gotos = NULL;\n+}\n+\n /* Define a label, specifying the location in the source file.\n    Return the LABEL_DECL node for the label, if the definition is valid.\n    Otherwise return 0.  */\n@@ -2698,7 +3143,6 @@ define_label (location_t location, tree name)\n      if there is a containing function with a declared label with\n      the same name.  */\n   tree label = I_LABEL_DECL (name);\n-  struct c_label_list *nlist_se, *nlist_vm;\n \n   if (label\n       && ((DECL_CONTEXT (label) == current_function_decl\n@@ -2712,46 +3156,110 @@ define_label (location_t location, tree name)\n     }\n   else if (label && DECL_CONTEXT (label) == current_function_decl)\n     {\n+      struct c_label_vars *label_vars = I_LABEL_BINDING (name)->u.label;\n+\n       /* The label has been used or declared already in this function,\n \t but not defined.  Update its location to point to this\n \t definition.  */\n-      if (C_DECL_UNDEFINABLE_STMT_EXPR (label))\n-\terror_at (location, \"jump into statement expression\");\n-      if (C_DECL_UNDEFINABLE_VM (label))\n-\terror_at (location,\n-\t\t  \"jump into scope of identifier with variably modified type\");\n       DECL_SOURCE_LOCATION (label) = location;\n+      set_spot_bindings (&label_vars->label_bindings, true);\n+\n+      /* Issue warnings as required about any goto statements from\n+\t earlier in the function.  */\n+      check_earlier_gotos (label, label_vars);\n     }\n   else\n     {\n+      struct c_label_vars *label_vars;\n+\n       /* No label binding for that identifier; make one.  */\n-      label = make_label (location, name);\n+      label = make_label (location, name, true, &label_vars);\n \n       /* Ordinary labels go in the current function scope.  */\n-      bind (name, label, current_function_scope,\n-\t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n+      bind_label (name, label, current_function_scope, label_vars);\n     }\n \n   if (!in_system_header && lookup_name (name))\n     warning_at (location, OPT_Wtraditional,\n \t\t\"traditional C lacks a separate namespace \"\n \t\t\"for labels, identifier %qE conflicts\", name);\n \n-  nlist_se = XOBNEW (&parser_obstack, struct c_label_list);\n-  nlist_se->next = label_context_stack_se->labels_def;\n-  nlist_se->label = label;\n-  label_context_stack_se->labels_def = nlist_se;\n-\n-  nlist_vm = XOBNEW (&parser_obstack, struct c_label_list);\n-  nlist_vm->next = label_context_stack_vm->labels_def;\n-  nlist_vm->label = label;\n-  label_context_stack_vm->labels_def = nlist_vm;\n-\n   /* Mark label as having been defined.  */\n   DECL_INITIAL (label) = error_mark_node;\n   return label;\n }\n \f\n+/* Get the bindings for a new switch statement.  This is used to issue\n+   warnings as appropriate for jumps from the switch to case or\n+   default labels.  */\n+\n+struct c_spot_bindings *\n+c_get_switch_bindings (void)\n+{\n+  struct c_spot_bindings *switch_bindings;\n+\n+  switch_bindings = XNEW (struct c_spot_bindings);\n+  set_spot_bindings (switch_bindings, true);\n+  return switch_bindings;\n+}\n+\n+void\n+c_release_switch_bindings (struct c_spot_bindings *bindings)\n+{\n+  gcc_assert (bindings->stmt_exprs == 0 && !bindings->left_stmt_expr);\n+  XDELETE (bindings);\n+}\n+\n+/* This is called at the point of a case or default label to issue\n+   warnings about decls as needed.  It returns true if it found an\n+   error, not just a warning.  */\n+\n+bool\n+c_check_switch_jump_warnings (struct c_spot_bindings *switch_bindings,\n+\t\t\t      location_t switch_loc, location_t case_loc)\n+{\n+  bool saw_error;\n+  struct c_scope *scope;\n+\n+  saw_error = false;\n+  for (scope = current_scope;\n+       scope != switch_bindings->scope;\n+       scope = scope->outer)\n+    {\n+      struct c_binding *b;\n+\n+      gcc_assert (scope != NULL);\n+      for (b = scope->bindings; b != NULL; b = b->prev)\n+\t{\n+\t  if (decl_jump_unsafe (b->decl))\n+\t    {\n+\t      if (variably_modified_type_p (TREE_TYPE (b->decl), NULL_TREE))\n+\t\t{\n+\t\t  saw_error = true;\n+\t\t  error_at (case_loc,\n+\t\t\t    (\"switch jumps into scope of identifier with \"\n+\t\t\t     \"variably modified type\"));\n+\t\t}\n+\t      else\n+\t\twarning_at (case_loc, OPT_Wjump_misses_init,\n+\t\t\t    \"switch jumps over variable initialization\");\n+\t      inform (switch_loc, \"switch starts here\");\n+\t      inform (DECL_SOURCE_LOCATION (b->decl), \"%qD declared here\",\n+\t\t      b->decl);\n+\t    }\n+\t}\n+    }\n+\n+  if (switch_bindings->stmt_exprs > 0)\n+    {\n+      saw_error = true;\n+      error_at (case_loc, \"switch jumps into statement expression\");\n+      inform (switch_loc, \"switch starts here\");\n+    }\n+\n+  return saw_error;\n+}\n+\f\n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n    If THISLEVEL_ONLY is nonzero, searches only the current_scope.\n@@ -3610,10 +4118,10 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t\tb_ext = b_ext->shadowed;\n \t      if (b_ext)\n \t\t{\n-\t\t  if (b_ext->type)\n-\t\t    b_ext->type = composite_type (b_ext->type, type);\n+\t\t  if (b_ext->u.type)\n+\t\t    b_ext->u.type = composite_type (b_ext->u.type, type);\n \t\t  else\n-\t\t    b_ext->type = type;\n+\t\t    b_ext->u.type = type;\n \t\t}\n \t    }\n \t  break;\n@@ -6610,8 +7118,6 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n {\n   tree decl1, old_decl;\n   tree restype, resdecl;\n-  struct c_label_context_se *nstack_se;\n-  struct c_label_context_vm *nstack_vm;\n   location_t loc;\n \n   current_function_returns_value = 0;  /* Assume, until we see it does.  */\n@@ -6620,19 +7126,6 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   warn_about_return_type = 0;\n   c_switch_stack = NULL;\n \n-  nstack_se = XOBNEW (&parser_obstack, struct c_label_context_se);\n-  nstack_se->labels_def = NULL;\n-  nstack_se->labels_used = NULL;\n-  nstack_se->next = label_context_stack_se;\n-  label_context_stack_se = nstack_se;\n-\n-  nstack_vm = XOBNEW (&parser_obstack, struct c_label_context_vm);\n-  nstack_vm->labels_def = NULL;\n-  nstack_vm->labels_used = NULL;\n-  nstack_vm->scope = 0;\n-  nstack_vm->next = label_context_stack_vm;\n-  label_context_stack_vm = nstack_vm;\n-\n   /* Indicate no valid break/continue context by setting these variables\n      to some non-null, non-label value.  We'll notice and emit the proper\n      error message in c_finish_bc_stmt.  */\n@@ -6644,11 +7137,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   /* If the declarator is not suitable for a function definition,\n      cause a syntax error.  */\n   if (decl1 == 0)\n-    {\n-      label_context_stack_se = label_context_stack_se->next;\n-      label_context_stack_vm = label_context_stack_vm->next;\n-      return 0;\n-    }\n+    return 0;\n \n   loc = DECL_SOURCE_LOCATION (decl1);\n \n@@ -6730,7 +7219,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t    {\n \t      tree ext_decl, ext_type;\n \t      ext_decl = b->decl;\n-\t      ext_type = b->type ? b->type : TREE_TYPE (ext_decl);\n+\t      ext_type = b->u.type ? b->u.type : TREE_TYPE (ext_decl);\n \t      if (TREE_CODE (ext_type) == FUNCTION_TYPE\n \t\t  && comptypes (TREE_TYPE (TREE_TYPE (decl1)),\n \t\t\t\tTREE_TYPE (ext_type)))\n@@ -7282,9 +7771,6 @@ finish_function (void)\n {\n   tree fndecl = current_function_decl;\n \n-  label_context_stack_se = label_context_stack_se->next;\n-  label_context_stack_vm = label_context_stack_vm->next;\n-\n   if (TREE_CODE (fndecl) == FUNCTION_DECL\n       && targetm.calls.promote_prototypes (TREE_TYPE (fndecl)))\n     {"}, {"sha": "4574bb2e92080bd7ec2e88712ad0bba124ac82d3", "filename": "gcc/c-opts.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -395,6 +395,8 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \twarn_strict_overflow = value;\n       warn_array_bounds = value;\n       warn_volatile_register_var = value;\n+      if (warn_jump_misses_init == -1)\n+\twarn_jump_misses_init = value;\n \n       /* Only warn about unknown pragmas that are not in system\n \t headers.  */\n@@ -445,6 +447,10 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \t implies -Wenum-compare.  */\n       if (warn_enum_compare == -1 && value)\n \twarn_enum_compare = value;\n+      /* Because C++ always warns about a goto which misses an\n+\t initialization, -Wc++-compat turns on -Wgoto-misses-init.  */\n+      if (warn_jump_misses_init == -1 && value)\n+\twarn_jump_misses_init = value;\n       cpp_opts->warn_cxx_operator_names = value;\n       break;\n \n@@ -1084,6 +1090,8 @@ c_common_post_options (const char **pfilename)\n     warn_strict_aliasing = 0;\n   if (warn_strict_overflow == -1)\n     warn_strict_overflow = 0;\n+  if (warn_jump_misses_init == -1)\n+    warn_jump_misses_init = 0;\n \n   /* -Woverlength-strings is off by default, but is enabled by -pedantic.\n      It is never enabled in C++, as the minimum limit is not normative"}, {"sha": "f565df58f315212f2b0adab9daeb733b543c5e5b", "filename": "gcc/c-tree.h", "status": "modified", "additions": 8, "deletions": 66, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -108,29 +108,6 @@ struct GTY(()) lang_type {\n    sizeof and typeof it is set for other function decls as well.  */\n #define C_DECL_USED(EXP) DECL_LANG_FLAG_5 (FUNCTION_DECL_CHECK (EXP))\n \n-/* Record whether a label was defined in a statement expression which\n-   has finished and so can no longer be jumped to.  */\n-#define C_DECL_UNJUMPABLE_STMT_EXPR(EXP)\t\\\n-  DECL_LANG_FLAG_6 (LABEL_DECL_CHECK (EXP))\n-\n-/* Record whether a label was the subject of a goto from outside the\n-   current level of statement expression nesting and so cannot be\n-   defined right now.  */\n-#define C_DECL_UNDEFINABLE_STMT_EXPR(EXP)\t\\\n-  DECL_LANG_FLAG_7 (LABEL_DECL_CHECK (EXP))\n-\n-/* Record whether a label was defined in the scope of an identifier\n-   with variably modified type which has finished and so can no longer\n-   be jumped to.  */\n-#define C_DECL_UNJUMPABLE_VM(EXP)\t\\\n-  DECL_LANG_FLAG_3 (LABEL_DECL_CHECK (EXP))\n-\n-/* Record whether a label was the subject of a goto from outside the\n-   current level of scopes of identifiers with variably modified type\n-   and so cannot be defined right now.  */\n-#define C_DECL_UNDEFINABLE_VM(EXP)\t\\\n-  DECL_LANG_FLAG_5 (LABEL_DECL_CHECK (EXP))\n-\n /* Record whether a variable has been declared threadprivate by\n    #pragma omp threadprivate.  */\n #define C_DECL_THREADPRIVATE_P(DECL) DECL_LANG_FLAG_3 (VAR_DECL_CHECK (DECL))\n@@ -421,45 +398,6 @@ struct GTY(()) language_function {\n   int warn_about_return_type;\n };\n \n-/* Save lists of labels used or defined in particular contexts.\n-   Allocated on the parser obstack.  */\n-\n-struct c_label_list\n-{\n-  /* The label at the head of the list.  */\n-  tree label;\n-  /* The rest of the list.  */\n-  struct c_label_list *next;\n-};\n-\n-/* Statement expression context.  */\n-\n-struct c_label_context_se\n-{\n-  /* The labels defined at this level of nesting.  */\n-  struct c_label_list *labels_def;\n-  /* The labels used at this level of nesting.  */\n-  struct c_label_list *labels_used;\n-  /* The next outermost context.  */\n-  struct c_label_context_se *next;\n-};\n-\n-/* Context of variably modified declarations.  */\n-\n-struct c_label_context_vm\n-{\n-  /* The labels defined at this level of nesting.  */\n-  struct c_label_list *labels_def;\n-  /* The labels used at this level of nesting.  */\n-  struct c_label_list *labels_used;\n-  /* The scope of this context.  Multiple contexts may be at the same\n-     numbered scope, since each variably modified declaration starts a\n-     new context.  */\n-  unsigned scope;\n-  /* The next outermost context.  */\n-  struct c_label_context_vm *next;\n-};\n-\n /* Used when parsing an enum.  Initialized by start_enum.  */\n struct c_enum_contents\n {\n@@ -491,13 +429,16 @@ extern void c_parse_init (void);\n extern void gen_aux_info_record (tree, int, int, int);\n \n /* in c-decl.c */\n+struct c_spot_bindings;\n extern struct obstack parser_obstack;\n extern tree c_break_label;\n extern tree c_cont_label;\n \n extern int global_bindings_p (void);\n extern void push_scope (void);\n extern tree pop_scope (void);\n+extern void c_bindings_start_stmt_expr (struct c_spot_bindings *);\n+extern void c_bindings_end_stmt_expr (struct c_spot_bindings *);\n \n extern void record_inline_static (location_t, tree, tree,\n \t\t\t\t  enum c_inline_static_type);\n@@ -513,8 +454,13 @@ extern tree check_for_loop_decls (location_t);\n extern void mark_forward_parm_decls (void);\n extern void declare_parm_level (void);\n extern void undeclared_variable (location_t, tree);\n+extern tree lookup_label_for_goto (location_t, tree);\n extern tree declare_label (tree);\n extern tree define_label (location_t, tree);\n+extern struct c_spot_bindings *c_get_switch_bindings (void);\n+extern void c_release_switch_bindings (struct c_spot_bindings *);\n+extern bool c_check_switch_jump_warnings (struct c_spot_bindings *,\n+\t\t\t\t\t  location_t, location_t);\n extern void c_maybe_initialize_eh (void);\n extern void finish_decl (tree, location_t, tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n@@ -583,8 +529,6 @@ extern int in_sizeof;\n extern int in_typeof;\n \n extern struct c_switch *c_switch_stack;\n-extern struct c_label_context_se *label_context_stack_se;\n-extern struct c_label_context_vm *label_context_stack_vm;\n \n extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (tree);\n@@ -643,8 +587,6 @@ extern tree c_finish_return (location_t, tree, tree);\n extern tree c_finish_bc_stmt (location_t, tree *, bool);\n extern tree c_finish_goto_label (location_t, tree);\n extern tree c_finish_goto_ptr (location_t, tree);\n-extern void c_begin_vm_scope (unsigned int);\n-extern void c_end_vm_scope (unsigned int);\n extern tree c_expr_to_decl (tree, bool *, bool *);\n extern tree c_begin_omp_parallel (void);\n extern tree c_finish_omp_parallel (location_t, tree, tree);"}, {"sha": "0dd97d31983a5fb2e2b07cfd05ffe9dfd12c7e7e", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 29, "deletions": 207, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -70,9 +70,6 @@ int in_sizeof;\n /* The level of nesting inside \"typeof\".  */\n int in_typeof;\n \n-struct c_label_context_se *label_context_stack_se;\n-struct c_label_context_vm *label_context_stack_vm;\n-\n /* Nonzero if we've already printed a \"missing braces around initializer\"\n    message within this initializer.  */\n static int missing_braces_mentioned;\n@@ -7979,46 +7976,9 @@ build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n tree\n c_finish_goto_label (location_t loc, tree label)\n {\n-  tree decl = lookup_label (label);\n+  tree decl = lookup_label_for_goto (loc, label);\n   if (!decl)\n     return NULL_TREE;\n-\n-  if (C_DECL_UNJUMPABLE_STMT_EXPR (decl))\n-    {\n-      error_at (loc, \"jump into statement expression\");\n-      return NULL_TREE;\n-    }\n-\n-  if (C_DECL_UNJUMPABLE_VM (decl))\n-    {\n-      error_at (loc,\n-\t\t\"jump into scope of identifier with variably modified type\");\n-      return NULL_TREE;\n-    }\n-\n-  if (!C_DECL_UNDEFINABLE_STMT_EXPR (decl))\n-    {\n-      /* No jump from outside this statement expression context, so\n-\t record that there is a jump from within this context.  */\n-      struct c_label_list *nlist;\n-      nlist = XOBNEW (&parser_obstack, struct c_label_list);\n-      nlist->next = label_context_stack_se->labels_used;\n-      nlist->label = decl;\n-      label_context_stack_se->labels_used = nlist;\n-    }\n-\n-  if (!C_DECL_UNDEFINABLE_VM (decl))\n-    {\n-      /* No jump from outside this context context of identifiers with\n-\t variably modified type, so record that there is a jump from\n-\t within this context.  */\n-      struct c_label_list *nlist;\n-      nlist = XOBNEW (&parser_obstack, struct c_label_list);\n-      nlist->next = label_context_stack_vm->labels_used;\n-      nlist->label = decl;\n-      label_context_stack_vm->labels_used = nlist;\n-    }\n-\n   TREE_USED (decl) = 1;\n   {\n     tree t = build1 (GOTO_EXPR, void_type_node, decl);\n@@ -8189,15 +8149,9 @@ struct c_switch {\n      of the GNU case range extension.  */\n   splay_tree cases;\n \n-  /* Number of nested statement expressions within this switch\n-     statement; if nonzero, case and default labels may not\n-     appear.  */\n-  unsigned int blocked_stmt_expr;\n-\n-  /* Scope of outermost declarations of identifiers with variably\n-     modified type within this switch statement; if nonzero, case and\n-     default labels may not appear.  */\n-  unsigned int blocked_vm;\n+  /* The bindings at the point of the switch.  This is used for\n+     warnings crossing decls when branching to a case label.  */\n+  struct c_spot_bindings *bindings;\n \n   /* The next node on the stack.  */\n   struct c_switch *next;\n@@ -8261,8 +8215,7 @@ c_start_case (location_t switch_loc,\n   SET_EXPR_LOCATION (cs->switch_expr, switch_loc);\n   cs->orig_type = orig_type;\n   cs->cases = splay_tree_new (case_compare, NULL, NULL);\n-  cs->blocked_stmt_expr = 0;\n-  cs->blocked_vm = 0;\n+  cs->bindings = c_get_switch_bindings ();\n   cs->next = c_switch_stack;\n   c_switch_stack = cs;\n \n@@ -8292,40 +8245,26 @@ do_case (location_t loc, tree low_value, tree high_value)\n \t\t \"case label is not an integer constant expression\");\n     }\n \n-  if (c_switch_stack && !c_switch_stack->blocked_stmt_expr\n-      && !c_switch_stack->blocked_vm)\n-    {\n-      label = c_add_case_label (loc, c_switch_stack->cases,\n-\t\t\t\tSWITCH_COND (c_switch_stack->switch_expr),\n-\t\t\t\tc_switch_stack->orig_type,\n-\t\t\t\tlow_value, high_value);\n-      if (label == error_mark_node)\n-\tlabel = NULL_TREE;\n-    }\n-  else if (c_switch_stack && c_switch_stack->blocked_stmt_expr)\n-    {\n-      if (low_value)\n-\terror_at (loc, \"case label in statement expression not containing \"\n-\t\t  \"enclosing switch statement\");\n-      else\n-\terror_at (loc, \"%<default%> label in statement expression not containing \"\n-\t\t  \"enclosing switch statement\");\n-    }\n-  else if (c_switch_stack && c_switch_stack->blocked_vm)\n+  if (c_switch_stack == NULL)\n     {\n       if (low_value)\n-\terror_at (loc, \"case label in scope of identifier with variably \"\n-\t\t  \"modified type not containing enclosing switch statement\");\n+\terror_at (loc, \"case label not within a switch statement\");\n       else\n-\terror_at (loc, \"%<default%> label in scope of identifier with \"\n-\t\t  \"variably modified type not containing enclosing switch \"\n-\t\t  \"statement\");\n+\terror_at (loc, \"%<default%> label not within a switch statement\");\n+      return NULL_TREE;\n     }\n-  else if (low_value)\n-    error_at (loc, \"case label not within a switch statement\");\n-  else\n-    error_at (loc, \"%<default%> label not within a switch statement\");\n \n+  if (c_check_switch_jump_warnings (c_switch_stack->bindings,\n+\t\t\t\t    EXPR_LOCATION (c_switch_stack->switch_expr),\n+\t\t\t\t    loc))\n+    return NULL_TREE;\n+\n+  label = c_add_case_label (loc, c_switch_stack->cases,\n+\t\t\t    SWITCH_COND (c_switch_stack->switch_expr),\n+\t\t\t    c_switch_stack->orig_type,\n+\t\t\t    low_value, high_value);\n+  if (label == error_mark_node)\n+    label = NULL_TREE;\n   return label;\n }\n \n@@ -8339,11 +8278,6 @@ c_finish_case (tree body)\n \n   SWITCH_BODY (cs->switch_expr) = body;\n \n-  /* We must not be within a statement expression nested in the switch\n-     at this point; we might, however, be within the scope of an\n-     identifier with variably modified type nested in the switch.  */\n-  gcc_assert (!cs->blocked_stmt_expr);\n-\n   /* Emit warnings as needed.  */\n   switch_location = EXPR_LOCATION (cs->switch_expr);\n   c_do_switch_warnings (cs->cases, switch_location,\n@@ -8353,6 +8287,7 @@ c_finish_case (tree body)\n   /* Pop the stack.  */\n   c_switch_stack = cs->next;\n   splay_tree_delete (cs->cases);\n+  c_release_switch_bindings (cs->bindings);\n   XDELETE (cs);\n }\n \f\n@@ -8603,30 +8538,16 @@ tree\n c_begin_stmt_expr (void)\n {\n   tree ret;\n-  struct c_label_context_se *nstack;\n-  struct c_label_list *glist;\n \n   /* We must force a BLOCK for this level so that, if it is not expanded\n      later, there is a way to turn off the entire subtree of blocks that\n      are contained in it.  */\n   keep_next_level ();\n   ret = c_begin_compound_stmt (true);\n-  if (c_switch_stack)\n-    {\n-      c_switch_stack->blocked_stmt_expr++;\n-      gcc_assert (c_switch_stack->blocked_stmt_expr != 0);\n-    }\n-  for (glist = label_context_stack_se->labels_used;\n-       glist != NULL;\n-       glist = glist->next)\n-    {\n-      C_DECL_UNDEFINABLE_STMT_EXPR (glist->label) = 1;\n-    }\n-  nstack = XOBNEW (&parser_obstack, struct c_label_context_se);\n-  nstack->labels_def = NULL;\n-  nstack->labels_used = NULL;\n-  nstack->next = label_context_stack_se;\n-  label_context_stack_se = nstack;\n+\n+  c_bindings_start_stmt_expr (c_switch_stack == NULL\n+\t\t\t      ? NULL\n+\t\t\t      : c_switch_stack->bindings);\n \n   /* Mark the current statement list as belonging to a statement list.  */\n   STATEMENT_LIST_STMT_EXPR (ret) = 1;\n@@ -8642,37 +8563,12 @@ c_finish_stmt_expr (location_t loc, tree body)\n {\n   tree last, type, tmp, val;\n   tree *last_p;\n-  struct c_label_list *dlist, *glist, *glist_prev = NULL;\n \n   body = c_end_compound_stmt (loc, body, true);\n-  if (c_switch_stack)\n-    {\n-      gcc_assert (c_switch_stack->blocked_stmt_expr != 0);\n-      c_switch_stack->blocked_stmt_expr--;\n-    }\n-  /* It is no longer possible to jump to labels defined within this\n-     statement expression.  */\n-  for (dlist = label_context_stack_se->labels_def;\n-       dlist != NULL;\n-       dlist = dlist->next)\n-    {\n-      C_DECL_UNJUMPABLE_STMT_EXPR (dlist->label) = 1;\n-    }\n-  /* It is again possible to define labels with a goto just outside\n-     this statement expression.  */\n-  for (glist = label_context_stack_se->next->labels_used;\n-       glist != NULL;\n-       glist = glist->next)\n-    {\n-      C_DECL_UNDEFINABLE_STMT_EXPR (glist->label) = 0;\n-      glist_prev = glist;\n-    }\n-  if (glist_prev != NULL)\n-    glist_prev->next = label_context_stack_se->labels_used;\n-  else\n-    label_context_stack_se->next->labels_used\n-      = label_context_stack_se->labels_used;\n-  label_context_stack_se = label_context_stack_se->next;\n+\n+  c_bindings_end_stmt_expr (c_switch_stack == NULL\n+\t\t\t    ? NULL\n+\t\t\t    : c_switch_stack->bindings);\n \n   /* Locate the last statement in BODY.  See c_end_compound_stmt\n      about always returning a BIND_EXPR.  */\n@@ -8762,80 +8658,6 @@ c_finish_stmt_expr (location_t loc, tree body)\n     return t;\n   }\n }\n-\n-/* Begin the scope of an identifier of variably modified type, scope\n-   number SCOPE.  Jumping from outside this scope to inside it is not\n-   permitted.  */\n-\n-void\n-c_begin_vm_scope (unsigned int scope)\n-{\n-  struct c_label_context_vm *nstack;\n-  struct c_label_list *glist;\n-\n-  gcc_assert (scope > 0);\n-\n-  /* At file_scope, we don't have to do any processing.  */\n-  if (label_context_stack_vm == NULL)\n-    return;\n-\n-  if (c_switch_stack && !c_switch_stack->blocked_vm)\n-    c_switch_stack->blocked_vm = scope;\n-  for (glist = label_context_stack_vm->labels_used;\n-       glist != NULL;\n-       glist = glist->next)\n-    {\n-      C_DECL_UNDEFINABLE_VM (glist->label) = 1;\n-    }\n-  nstack = XOBNEW (&parser_obstack, struct c_label_context_vm);\n-  nstack->labels_def = NULL;\n-  nstack->labels_used = NULL;\n-  nstack->scope = scope;\n-  nstack->next = label_context_stack_vm;\n-  label_context_stack_vm = nstack;\n-}\n-\n-/* End a scope which may contain identifiers of variably modified\n-   type, scope number SCOPE.  */\n-\n-void\n-c_end_vm_scope (unsigned int scope)\n-{\n-  if (label_context_stack_vm == NULL)\n-    return;\n-  if (c_switch_stack && c_switch_stack->blocked_vm == scope)\n-    c_switch_stack->blocked_vm = 0;\n-  /* We may have a number of nested scopes of identifiers with\n-     variably modified type, all at this depth.  Pop each in turn.  */\n-  while (label_context_stack_vm->scope == scope)\n-    {\n-      struct c_label_list *dlist, *glist, *glist_prev = NULL;\n-\n-      /* It is no longer possible to jump to labels defined within this\n-\t scope.  */\n-      for (dlist = label_context_stack_vm->labels_def;\n-\t   dlist != NULL;\n-\t   dlist = dlist->next)\n-\t{\n-\t  C_DECL_UNJUMPABLE_VM (dlist->label) = 1;\n-\t}\n-      /* It is again possible to define labels with a goto just outside\n-\t this scope.  */\n-      for (glist = label_context_stack_vm->next->labels_used;\n-\t   glist != NULL;\n-\t   glist = glist->next)\n-\t{\n-\t  C_DECL_UNDEFINABLE_VM (glist->label) = 0;\n-\t  glist_prev = glist;\n-\t}\n-      if (glist_prev != NULL)\n-\tglist_prev->next = label_context_stack_vm->labels_used;\n-      else\n-\tlabel_context_stack_vm->next->labels_used\n-\t  = label_context_stack_vm->labels_used;\n-      label_context_stack_vm = label_context_stack_vm->next;\n-    }\n-}\n \f\n /* Begin and end compound statements.  This is as simple as pushing\n    and popping new statement lists from the tree.  */"}, {"sha": "e8a9a31a382a45a01a28bf195c66da4823a29939", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -284,6 +284,10 @@ Winvalid-pch\n C ObjC C++ ObjC++ Warning\n Warn about PCH files that are found but not used\n \n+Wjump-misses-init\n+C Objc Var(warn_jump_misses_init) Init(-1) Warning\n+Warn when a jump misses a variable initialization\n+\n Wlogical-op\n C ObjC C++ ObjC++ Var(warn_logical_op) Init(0) Warning \n Warn when a logical operator is suspiciously always evaluating to true or false"}, {"sha": "911081ae5acb23ecba95d61a231ec89fbecccd1d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -1,3 +1,8 @@\n+2009-06-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* parser.c (cp_parser_direct_declarator): Add braces around\n+\tvariables declared before label.\n+\n 2009-06-15  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* cp-objcp-common.h (LANG_HOOKS_COMDAT_GROUP): Remove."}, {"sha": "0314bb32ea24f776d9ef54aaf6648226c158aac0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 164, "deletions": 162, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -13371,181 +13371,183 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t}\n       else if (first && dcl_kind != CP_PARSER_DECLARATOR_ABSTRACT)\n \t{\n-\t  tree qualifying_scope;\n-\t  tree unqualified_name;\n-\t  special_function_kind sfk;\n-\t  bool abstract_ok;\n-          bool pack_expansion_p = false;\n-\t  cp_token *declarator_id_start_token;\n-\n-\t  /* Parse a declarator-id */\n-\t  abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);\n-\t  if (abstract_ok)\n-            {\n-              cp_parser_parse_tentatively (parser);\n+\t  {\n+\t    tree qualifying_scope;\n+\t    tree unqualified_name;\n+\t    special_function_kind sfk;\n+\t    bool abstract_ok;\n+\t    bool pack_expansion_p = false;\n+\t    cp_token *declarator_id_start_token;\n+\n+\t    /* Parse a declarator-id */\n+\t    abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);\n+\t    if (abstract_ok)\n+\t      {\n+\t\tcp_parser_parse_tentatively (parser);\n \n-              /* If we see an ellipsis, we should be looking at a\n-                 parameter pack. */\n-              if (token->type == CPP_ELLIPSIS)\n-                {\n-                  /* Consume the `...' */\n-                  cp_lexer_consume_token (parser->lexer);\n+\t\t/* If we see an ellipsis, we should be looking at a\n+\t\t   parameter pack. */\n+\t\tif (token->type == CPP_ELLIPSIS)\n+\t\t  {\n+\t\t    /* Consume the `...' */\n+\t\t    cp_lexer_consume_token (parser->lexer);\n \n-                  pack_expansion_p = true;\n-                }\n-            }\n+\t\t    pack_expansion_p = true;\n+\t\t  }\n+\t      }\n \n-\t  declarator_id_start_token = cp_lexer_peek_token (parser->lexer);\n-\t  unqualified_name\n-\t    = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);\n-\t  qualifying_scope = parser->scope;\n-\t  if (abstract_ok)\n-\t    {\n-              bool okay = false;\n-\n-              if (!unqualified_name && pack_expansion_p)\n-                {\n-                  /* Check whether an error occurred. */\n-                  okay = !cp_parser_error_occurred (parser);\n-\n-                  /* We already consumed the ellipsis to mark a\n-                     parameter pack, but we have no way to report it,\n-                     so abort the tentative parse. We will be exiting\n-                     immediately anyway. */\n-                  cp_parser_abort_tentative_parse (parser);\n-                }\n-              else\n-                okay = cp_parser_parse_definitely (parser);\n-\n-\t      if (!okay)\n-\t\tunqualified_name = error_mark_node;\n-\t      else if (unqualified_name\n-\t\t       && (qualifying_scope\n-\t\t\t   || (TREE_CODE (unqualified_name)\n-\t\t\t       != IDENTIFIER_NODE)))\n-\t\t{\n-\t\t  cp_parser_error (parser, \"expected unqualified-id\");\n-\t\t  unqualified_name = error_mark_node;\n-\t\t}\n-\t    }\n+\t    declarator_id_start_token = cp_lexer_peek_token (parser->lexer);\n+\t    unqualified_name\n+\t      = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);\n+\t    qualifying_scope = parser->scope;\n+\t    if (abstract_ok)\n+\t      {\n+\t\tbool okay = false;\n \n-\t  if (!unqualified_name)\n-\t    return NULL;\n-\t  if (unqualified_name == error_mark_node)\n-\t    {\n-\t      declarator = cp_error_declarator;\n-              pack_expansion_p = false;\n-              declarator->parameter_pack_p = false;\n-\t      break;\n-\t    }\n+\t\tif (!unqualified_name && pack_expansion_p)\n+\t\t  {\n+\t\t    /* Check whether an error occurred. */\n+\t\t    okay = !cp_parser_error_occurred (parser);\n+\n+\t\t    /* We already consumed the ellipsis to mark a\n+\t\t       parameter pack, but we have no way to report it,\n+\t\t       so abort the tentative parse. We will be exiting\n+\t\t       immediately anyway. */\n+\t\t    cp_parser_abort_tentative_parse (parser);\n+\t\t  }\n+\t\telse\n+\t\t  okay = cp_parser_parse_definitely (parser);\n \n-\t  if (qualifying_scope && at_namespace_scope_p ()\n-\t      && TREE_CODE (qualifying_scope) == TYPENAME_TYPE)\n-\t    {\n-\t      /* In the declaration of a member of a template class\n-\t\t outside of the class itself, the SCOPE will sometimes\n-\t\t be a TYPENAME_TYPE.  For example, given:\n-\n-\t\t template <typename T>\n-\t\t int S<T>::R::i = 3;\n-\n-\t\t the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In\n-\t\t this context, we must resolve S<T>::R to an ordinary\n-\t\t type, rather than a typename type.\n-\n-\t\t The reason we normally avoid resolving TYPENAME_TYPEs\n-\t\t is that a specialization of `S' might render\n-\t\t `S<T>::R' not a type.  However, if `S' is\n-\t\t specialized, then this `i' will not be used, so there\n-\t\t is no harm in resolving the types here.  */\n-\t      tree type;\n+\t\tif (!okay)\n+\t\t  unqualified_name = error_mark_node;\n+\t\telse if (unqualified_name\n+\t\t\t && (qualifying_scope\n+\t\t\t     || (TREE_CODE (unqualified_name)\n+\t\t\t\t != IDENTIFIER_NODE)))\n+\t\t  {\n+\t\t    cp_parser_error (parser, \"expected unqualified-id\");\n+\t\t    unqualified_name = error_mark_node;\n+\t\t  }\n+\t      }\n \n-\t      /* Resolve the TYPENAME_TYPE.  */\n-\t      type = resolve_typename_type (qualifying_scope,\n-\t\t\t\t\t    /*only_current_p=*/false);\n-\t      /* If that failed, the declarator is invalid.  */\n-\t      if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t\terror (\"%H%<%T::%E%> is not a type\",\n-\t\t       &declarator_id_start_token->location,\n-\t\t       TYPE_CONTEXT (qualifying_scope),\n-\t\t       TYPE_IDENTIFIER (qualifying_scope));\n-\t      qualifying_scope = type;\n-\t    }\n+\t    if (!unqualified_name)\n+\t      return NULL;\n+\t    if (unqualified_name == error_mark_node)\n+\t      {\n+\t\tdeclarator = cp_error_declarator;\n+\t\tpack_expansion_p = false;\n+\t\tdeclarator->parameter_pack_p = false;\n+\t\tbreak;\n+\t      }\n \n-\t  sfk = sfk_none;\n+\t    if (qualifying_scope && at_namespace_scope_p ()\n+\t\t&& TREE_CODE (qualifying_scope) == TYPENAME_TYPE)\n+\t      {\n+\t\t/* In the declaration of a member of a template class\n+\t\t   outside of the class itself, the SCOPE will sometimes\n+\t\t   be a TYPENAME_TYPE.  For example, given:\n+\n+\t\t   template <typename T>\n+\t\t   int S<T>::R::i = 3;\n+\n+\t\t   the SCOPE will be a TYPENAME_TYPE for `S<T>::R'.  In\n+\t\t   this context, we must resolve S<T>::R to an ordinary\n+\t\t   type, rather than a typename type.\n+\n+\t\t   The reason we normally avoid resolving TYPENAME_TYPEs\n+\t\t   is that a specialization of `S' might render\n+\t\t   `S<T>::R' not a type.  However, if `S' is\n+\t\t   specialized, then this `i' will not be used, so there\n+\t\t   is no harm in resolving the types here.  */\n+\t\ttree type;\n+\n+\t\t/* Resolve the TYPENAME_TYPE.  */\n+\t\ttype = resolve_typename_type (qualifying_scope,\n+\t\t\t\t\t      /*only_current_p=*/false);\n+\t\t/* If that failed, the declarator is invalid.  */\n+\t\tif (TREE_CODE (type) == TYPENAME_TYPE)\n+\t\t  error (\"%H%<%T::%E%> is not a type\",\n+\t\t\t &declarator_id_start_token->location,\n+\t\t\t TYPE_CONTEXT (qualifying_scope),\n+\t\t\t TYPE_IDENTIFIER (qualifying_scope));\n+\t\tqualifying_scope = type;\n+\t      }\n \n-\t  if (unqualified_name)\n-\t    {\n-\t      tree class_type;\n+\t    sfk = sfk_none;\n \n-\t      if (qualifying_scope\n-\t\t  && CLASS_TYPE_P (qualifying_scope))\n-\t\tclass_type = qualifying_scope;\n-\t      else\n-\t\tclass_type = current_class_type;\n+\t    if (unqualified_name)\n+\t      {\n+\t\ttree class_type;\n \n-\t      if (TREE_CODE (unqualified_name) == TYPE_DECL)\n-\t\t{\n-\t\t  tree name_type = TREE_TYPE (unqualified_name);\n-\t\t  if (class_type && same_type_p (name_type, class_type))\n-\t\t    {\n-\t\t      if (qualifying_scope\n-\t\t\t  && CLASSTYPE_USE_TEMPLATE (name_type))\n-\t\t\t{\n-\t\t\t  error (\"%Hinvalid use of constructor as a template\",\n-\t\t\t\t &declarator_id_start_token->location);\n-\t\t\t  inform (input_location, \"use %<%T::%D%> instead of %<%T::%D%> to \"\n-\t\t\t\t  \"name the constructor in a qualified name\",\n-\t\t\t\t  class_type,\n-\t\t\t\t  DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n-\t\t\t\t  class_type, name_type);\n-\t\t\t  declarator = cp_error_declarator;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      else\n-\t\t\tunqualified_name = constructor_name (class_type);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* We do not attempt to print the declarator\n-\t\t\t here because we do not have enough\n-\t\t\t information about its original syntactic\n-\t\t\t form.  */\n-\t\t      cp_parser_error (parser, \"invalid declarator\");\n-\t\t      declarator = cp_error_declarator;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n+\t\tif (qualifying_scope\n+\t\t    && CLASS_TYPE_P (qualifying_scope))\n+\t\t  class_type = qualifying_scope;\n+\t\telse\n+\t\t  class_type = current_class_type;\n \n-\t      if (class_type)\n-\t\t{\n-\t\t  if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)\n-\t\t    sfk = sfk_destructor;\n-\t\t  else if (IDENTIFIER_TYPENAME_P (unqualified_name))\n-\t\t    sfk = sfk_conversion;\n-\t\t  else if (/* There's no way to declare a constructor\n-\t\t\t      for an anonymous type, even if the type\n-\t\t\t      got a name for linkage purposes.  */\n-\t\t\t   !TYPE_WAS_ANONYMOUS (class_type)\n-\t\t\t   && constructor_name_p (unqualified_name,\n-\t\t\t\t\t\t  class_type))\n-\t\t    {\n-\t\t      unqualified_name = constructor_name (class_type);\n-\t\t      sfk = sfk_constructor;\n-\t\t    }\n+\t\tif (TREE_CODE (unqualified_name) == TYPE_DECL)\n+\t\t  {\n+\t\t    tree name_type = TREE_TYPE (unqualified_name);\n+\t\t    if (class_type && same_type_p (name_type, class_type))\n+\t\t      {\n+\t\t\tif (qualifying_scope\n+\t\t\t    && CLASSTYPE_USE_TEMPLATE (name_type))\n+\t\t\t  {\n+\t\t\t    error (\"%Hinvalid use of constructor as a template\",\n+\t\t\t\t   &declarator_id_start_token->location);\n+\t\t\t    inform (input_location, \"use %<%T::%D%> instead of %<%T::%D%> to \"\n+\t\t\t\t    \"name the constructor in a qualified name\",\n+\t\t\t\t    class_type,\n+\t\t\t\t    DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n+\t\t\t\t    class_type, name_type);\n+\t\t\t    declarator = cp_error_declarator;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  unqualified_name = constructor_name (class_type);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t/* We do not attempt to print the declarator\n+\t\t\t   here because we do not have enough\n+\t\t\t   information about its original syntactic\n+\t\t\t   form.  */\n+\t\t\tcp_parser_error (parser, \"invalid declarator\");\n+\t\t\tdeclarator = cp_error_declarator;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n \n-\t\t  if (ctor_dtor_or_conv_p && sfk != sfk_none)\n-\t\t    *ctor_dtor_or_conv_p = -1;\n-\t\t}\n-\t    }\n-\t  declarator = make_id_declarator (qualifying_scope,\n-\t\t\t\t\t   unqualified_name,\n-\t\t\t\t\t   sfk);\n-\t  declarator->id_loc = token->location;\n-          declarator->parameter_pack_p = pack_expansion_p;\n+\t\tif (class_type)\n+\t\t  {\n+\t\t    if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR)\n+\t\t      sfk = sfk_destructor;\n+\t\t    else if (IDENTIFIER_TYPENAME_P (unqualified_name))\n+\t\t      sfk = sfk_conversion;\n+\t\t    else if (/* There's no way to declare a constructor\n+\t\t\t\tfor an anonymous type, even if the type\n+\t\t\t\tgot a name for linkage purposes.  */\n+\t\t\t     !TYPE_WAS_ANONYMOUS (class_type)\n+\t\t\t     && constructor_name_p (unqualified_name,\n+\t\t\t\t\t\t    class_type))\n+\t\t      {\n+\t\t\tunqualified_name = constructor_name (class_type);\n+\t\t\tsfk = sfk_constructor;\n+\t\t      }\n \n-          if (pack_expansion_p)\n-            maybe_warn_variadic_templates ();\n+\t\t    if (ctor_dtor_or_conv_p && sfk != sfk_none)\n+\t\t      *ctor_dtor_or_conv_p = -1;\n+\t\t  }\n+\t      }\n+\t    declarator = make_id_declarator (qualifying_scope,\n+\t\t\t\t\t     unqualified_name,\n+\t\t\t\t\t     sfk);\n+\t    declarator->id_loc = token->location;\n+\t    declarator->parameter_pack_p = pack_expansion_p;\n+\n+\t    if (pack_expansion_p)\n+\t      maybe_warn_variadic_templates ();\n+\t  }\n \n \thandle_declarator:;\n \t  scope = get_scope_of_declarator (declarator);"}, {"sha": "1d1dc9c9621e29066103cdecf60ff3b35c77a4a9", "filename": "gcc/df-problems.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -3912,19 +3912,21 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     {\n       switch (REG_NOTE_KIND (link))\n+\t{\n \tcase REG_DEAD:\n \tcase REG_UNUSED:\n-\t{\n-\t  rtx reg = XEXP (link, 0);\n-\t  int regno = REGNO (reg);\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      int n = hard_regno_nregs[regno][GET_MODE (reg)];\n-\t      while (--n >= 0)\n-\t\tbitmap_clear_bit (live, regno + n);\n-\t    }\n-\t  else \n-\t    bitmap_clear_bit (live, regno);\n+\t  {\n+\t    rtx reg = XEXP (link, 0);\n+\t    int regno = REGNO (reg);\n+\t    if (regno < FIRST_PSEUDO_REGISTER)\n+\t      {\n+\t\tint n = hard_regno_nregs[regno][GET_MODE (reg)];\n+\t\twhile (--n >= 0)\n+\t\t  bitmap_clear_bit (live, regno + n);\n+\t      }\n+\t    else \n+\t      bitmap_clear_bit (live, regno);\n+\t  }\n \t  break;\n \tdefault:\n \t  break;"}, {"sha": "f75a6a8a021bd84aa1bade83b6c616b8d1873075", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -238,7 +238,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol\n -Wno-format-contains-nul -Wno-format-extra-args -Wformat-nonliteral @gol\n -Wformat-security  -Wformat-y2k @gol\n--Wframe-larger-than=@var{len} -Wignored-qualifiers @gol\n+-Wframe-larger-than=@var{len} -Wjump-misses-init -Wignored-qualifiers @gol\n -Wimplicit  -Wimplicit-function-declaration  -Wimplicit-int @gol\n -Winit-self  -Winline @gol\n -Wno-int-to-pointer-cast -Wno-invalid-offsetof @gol\n@@ -2973,6 +2973,20 @@ requiring a non-null value by the @code{nonnull} function attribute.\n @option{-Wnonnull} is included in @option{-Wall} and @option{-Wformat}.  It\n can be disabled with the @option{-Wno-nonnull} option.\n \n+@item -Wjump-misses-init @r{(C, Objective-C only)}\n+@opindex Wjump-misses-init\n+@opindex Wno-jump-misses-init\n+Warn if a @code{goto} statement or a @code{switch} statement jumps\n+forward across the initialization of a variable, or jumps backward to a\n+label after the variable has been initialized.  This only warns about\n+variables which are initialized when they are declared.  This warning is\n+only supported for C and Objective C; in C++ this sort of branch is an\n+error in any case.\n+\n+@option{-Wjump-misses-init} is included in @option{-Wall} and\n+@option{-Wc++-compat}.  It can be disabled with the\n+@option{-Wno-jump-misses-init} option.\n+\n @item -Winit-self @r{(C, C++, Objective-C and Objective-C++ only)}\n @opindex Winit-self\n @opindex Wno-init-self"}, {"sha": "4f5c3d4ebba37f12a7fe2a8f14606e86c4064757", "filename": "gcc/gcov.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -1065,27 +1065,29 @@ read_count_file (void)\n \tprogram_count++;\n       else if (tag == GCOV_TAG_FUNCTION)\n \t{\n-\t  unsigned ident = gcov_read_unsigned ();\n-\t  struct function_info *fn_n = functions;\n+\t  {\n+\t    unsigned ident = gcov_read_unsigned ();\n+\t    struct function_info *fn_n = functions;\n \n-\t  /* Try to find the function in the list.\n-\t     To speed up the search, first start from the last function\n-\t     found.   */\n-\t  for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n-\t    {\n-\t      if (fn)\n-\t\t;\n-\t      else if ((fn = fn_n))\n-\t\tfn_n = NULL;\n-\t      else\n-\t\t{\n-\t\t  fnotice (stderr, \"%s:unknown function '%u'\\n\",\n-\t\t\t   da_file_name, ident);\n+\t    /* Try to find the function in the list.\n+\t       To speed up the search, first start from the last function\n+\t       found.   */\n+\t    for (fn = fn ? fn->next : NULL; ; fn = fn->next)\n+\t      {\n+\t\tif (fn)\n+\t\t  ;\n+\t\telse if ((fn = fn_n))\n+\t\t  fn_n = NULL;\n+\t\telse\n+\t\t  {\n+\t\t    fnotice (stderr, \"%s:unknown function '%u'\\n\",\n+\t\t\t     da_file_name, ident);\n+\t\t    break;\n+\t\t  }\n+\t\tif (fn->ident == ident)\n \t\t  break;\n-\t\t}\n-\t      if (fn->ident == ident)\n-\t\tbreak;\n-\t    }\n+\t      }\n+\t  }\n \n \t  if (!fn)\n \t    ;"}, {"sha": "2fe4b25be8cd3fd9d86ca9bdd61c5ff0298ea14e", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -1,3 +1,8 @@\n+2009-06-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* objc-act.c (objc_start_function): Don't set\n+\tlabel_context_stack_se or label_context_stack_vm.\n+\n 2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n \t\n \t* objc-act.c (finish_var_decl): Pass location to finish_decl."}, {"sha": "f114b65ef4a932266a1d29f8adf1e45097e70929", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -8632,19 +8632,6 @@ objc_start_function (tree name, tree type, tree attrs,\n   cplus_decl_attributes (&fndecl, attrs, 0);\n   start_preparsed_function (fndecl, attrs, /*flags=*/SF_DEFAULT);\n #else\n-  struct c_label_context_se *nstack_se;\n-  struct c_label_context_vm *nstack_vm;\n-  nstack_se = XOBNEW (&parser_obstack, struct c_label_context_se);\n-  nstack_se->labels_def = NULL;\n-  nstack_se->labels_used = NULL;\n-  nstack_se->next = label_context_stack_se;\n-  label_context_stack_se = nstack_se;\n-  nstack_vm = XOBNEW (&parser_obstack, struct c_label_context_vm);\n-  nstack_vm->labels_def = NULL;\n-  nstack_vm->labels_used = NULL;\n-  nstack_vm->scope = 0;\n-  nstack_vm->next = label_context_stack_vm;\n-  label_context_stack_vm = nstack_vm;\n   current_function_returns_value = 0;  /* Assume, until we see it does.  */\n   current_function_returns_null = 0;\n "}, {"sha": "c961525e9d79318c42adcd3b7ea2cbfa4d0e0b5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -1,3 +1,20 @@\n+2009-06-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wjump-misses-init-1.c: New testcase.\n+\t* gcc.dg/Wjump-misses-init-2.c: New testcase.\n+\t* gcc.dg/c99-vla-jump-5.c: Adjust expected error messages.\n+\tRecognize new notes.\n+\t* gcc.dg/stmt-expr-label-2.c: Likewise.\n+\t* gcc.dg/c99-vla-jump-1.c: Recognize new notes.  Fix column\n+\tnumbers.\n+\t* gcc.dg/c99-vla-jump-2.c: Recognize new notes.\n+\t* gcc.dg/c99-vla-jump-3.c: Recognize new notes.\n+\t* gcc.dg/c99-vla-jump-4.c: Likewise.\n+\t* gcc.dg/stmt-expr-label-1.c: Likewise.\n+\t* gcc.dg/stmt-expr-label-3.c: Likewise.\n+\t* gcc.dg/vla-8.c: Likewise.  Move error message to different\n+\tline.\n+\n 2009-06-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-math-6.c: Robustify and fix clog cases."}, {"sha": "86117f1f2f0d666ceac7723234615fbfad2ccecf", "filename": "gcc/testsuite/gcc.dg/Wjump-misses-init-1.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2FWjump-misses-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2FWjump-misses-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWjump-misses-init-1.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -0,0 +1,156 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wjump-misses-init\" } */\n+int\n+f1 (int a)\n+{\n+  if (a > 0)\n+    {\n+      int i = 7;\t/* { dg-message \"here\" } */\n+    lab:\t\t/* { dg-message \"here\" } */\n+      return a;\n+    }\n+  else\n+    {\n+      if (a < 0)\n+\tgoto lab;\t/* { dg-warning \"jump\" } */\n+      return 1;\n+    }\n+}\n+\n+int\n+f2 (int a)\n+{\n+  if (a > 0)\n+    {\n+      if (a < 0)\n+\tgoto lab;\t/* { dg-warning \"jump\" } */\n+      return 1;\n+    }\n+  else\n+    {\n+      int i = 7;\t/* { dg-message \"here\" } */\n+    lab:\t\t/* { dg-message \"here\" } */\n+      return a;\n+    }\n+}\n+\n+int\n+f3 (int a)\n+{\n+  if (a > 0)\n+    {\n+      static int i = 7;\n+    lab:\n+      return a;\n+    }\n+  else\n+    {\n+      if (a < 0)\n+\tgoto lab;\n+      return 1;\n+    }\n+}\n+\n+int\n+f4 (int a)\n+{\n+  if (a > 0)\n+    {\n+      if (a < 0)\n+\tgoto lab;\n+      return 1;\n+    }\n+  else\n+    {\n+      static int i = 7;\n+    lab:\n+      return a;\n+    }\n+}\n+\n+int\n+f5 (int a)\n+{\n+  if (a > 0)\n+    {\n+      int b = 1;\n+      if (a < 0)\n+\tgoto lab;\n+    }\n+ lab:\n+  return a;\n+}\n+\n+int\n+f6 (int a)\n+{\n+  if (a > 0)\n+    {\n+    lab:\n+      return a;\n+    }\n+  else\n+    {\n+      int b = 1;\n+      goto lab;\n+    }\n+}\n+\n+int\n+f7 (int a)\n+{\n+  switch (a)\t\t/* { dg-message \"switch\" } */\n+    {\n+      int b = 1;\t/* { dg-message \"here\" } */\n+\n+    case 1:\t\t/* { dg-warning \"jump\" } */\n+      return a;\n+    }\n+}\n+\n+int\n+f8 (int a)\n+{\n+  switch (a)\t\t/* { dg-message \"switch\" } */\n+    {\n+      int b = 1;\t/* { dg-message \"here\" } */\n+\n+    case 1:\t\t/* { dg-warning \"jump\" } */\n+      goto lab;\n+    }\n+ lab:\n+  return a;\n+}\n+\n+int\n+f9 (int a)\n+{\n+  switch (a)\n+    {\n+    case 0:\n+      {\n+\tint b = 1;\n+\treturn b;\n+      }\n+    case 1:\n+      return a;\n+    }\n+}\n+\n+int\n+f10 (int a)\n+{\n+  switch (a)\n+    {\n+    case 0:\n+      {\n+\tint b = 1;\n+\tgoto lab;\n+      }\n+\n+    case 1:\n+      goto lab;\n+    }\n+ lab:\n+  return a;\n+}"}, {"sha": "042c02aa7bdeb5c29a8e4b953631a25aa1b656ab", "filename": "gcc/testsuite/gcc.dg/Wjump-misses-init-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2FWjump-misses-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2FWjump-misses-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWjump-misses-init-2.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wjump-misses-init -std=c99\" } */\n+extern void f1 ();\n+int\n+f2 (int a)\n+{\n+  switch (a)\t\t/* { dg-message \"switch\" } */\n+    {\n+    case 1:\n+      f1 ();\n+      int v2 = 3;\t/* { dg-message \"here\" } */\n+    case 2:\t\t/* { dg-warning \"jump\" } */\n+      if (v2 == 7)\n+\tf1 ();\n+    }\n+  return 0;\n+}\n+\n+int\n+f3 (int i)\n+{\n+  if (i)\n+    goto bad;\t\t/* { dg-warning \"jump\" } */\n+  int a = f2 (i); \t/* { dg-message \"here\" } */\n+ bad:\t\t\t/* { dg-message \"here\" } */\n+  return a;\n+}\n+\n+int\n+f4 (int a)\n+{\n+  switch (a)\n+    {\n+    case 1:\n+      f1 ();\n+      static int v2 = 3;\n+    case 2:\n+      if (v2 == 7)\n+\tf1 ();\n+    }\n+  return 0;\n+}\n+\n+int\n+f5 (int i)\n+{\n+  if (i)\n+    goto bad;\n+  static int a = 6;\n+ bad:\n+  return a;\n+}"}, {"sha": "8e34b1001313e76387314266b8cd0b6092ab9f14", "filename": "gcc/testsuite/gcc.dg/c99-vla-jump-1.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-1.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -15,11 +15,11 @@\n /* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n \n void fa0 (int n) {  goto a; a:{ int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; }\n-void fa1 (int n) {  goto a; { int b[n]; a:{ int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"41:jump into scope of identifier with variably modified type\" } */\n-void fa2 (int n) {  goto a; { int b[n]; { int c[n]; a:0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"53:jump into scope of identifier with variably modified type\" } */\n-void fa3 (int n) {  goto a; { int b[n]; { int c[n]; 0;} a:{ int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"57:jump into scope of identifier with variably modified type\" } */\n-void fa4 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; a:0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"69:jump into scope of identifier with variably modified type\" } */\n-void fa5 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} a:; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"73:jump into scope of identifier with variably modified type\" } */\n+void fa1 (int n) {  goto a; { int b[n]; a:{ int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"21:jump into scope of identifier with variably modified type\" } */\n+void fa2 (int n) {  goto a; { int b[n]; { int c[n]; a:0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"21:jump into scope of identifier with variably modified type\" } */\n+void fa3 (int n) {  goto a; { int b[n]; { int c[n]; 0;} a:{ int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"21:jump into scope of identifier with variably modified type\" } */\n+void fa4 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; a:0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"21:jump into scope of identifier with variably modified type\" } */\n+void fa5 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} a:; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"21:jump into scope of identifier with variably modified type\" } */\n void fa6 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; a:0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n void fa7 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; a:{ int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; }\n void fa8 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; a:{ int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n@@ -303,3 +303,7 @@ void fa285 (int n) { { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}\n void fa286 (int n) { { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; a:; int j[n]; 0; goto a;  }\n void fa287 (int n) { { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; a:0; goto a;  }\n void fa288 (int n) { { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0;a: goto a;  }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '\\[^\\n'\\]*' declared here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "2b4d4d56a5d4c0b635eb9666ece835b43e68670c", "filename": "gcc/testsuite/gcc.dg/c99-vla-jump-2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-2.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -303,3 +303,7 @@ void fb285 (int n) { P0A:goto P0A;{ int b[n]; P01A:goto P01A;{ int c[n]; P012A:g\n void fb286 (int n) { P0A:goto P0A;{ int b[n]; P01A:goto P01A;{ int c[n]; P012A:goto P012A;0;} P01B:goto P01B;{ int d[n]; P013A:goto P013A;0;} P01C:goto P01C;; int e[n]; P014A:goto P014A;0;}; P0B:goto P0B;{ int f[n]; P02A:goto P02A;{ int g[n]; P024A:goto P024A;0;}; P02B:goto P02B;{ int h[n]; P025A:goto P025A;0;}; P02C:goto P02C;; int i[n]; P026A:goto P026A;0;}; a:; int j[n]; P03A:goto P03A;0;p03B:goto p03B; goto a; P03B:goto P03B; }\n void fb287 (int n) { P0A:goto P0A;{ int b[n]; P01A:goto P01A;{ int c[n]; P012A:goto P012A;0;} P01B:goto P01B;{ int d[n]; P013A:goto P013A;0;} P01C:goto P01C;; int e[n]; P014A:goto P014A;0;}; P0B:goto P0B;{ int f[n]; P02A:goto P02A;{ int g[n]; P024A:goto P024A;0;}; P02B:goto P02B;{ int h[n]; P025A:goto P025A;0;}; P02C:goto P02C;; int i[n]; P026A:goto P026A;0;}; P0C:goto P0C;; int j[n]; a:0;p03B:goto p03B; goto a; P03B:goto P03B; }\n void fb288 (int n) { P0A:goto P0A;{ int b[n]; P01A:goto P01A;{ int c[n]; P012A:goto P012A;0;} P01B:goto P01B;{ int d[n]; P013A:goto P013A;0;} P01C:goto P01C;; int e[n]; P014A:goto P014A;0;}; P0B:goto P0B;{ int f[n]; P02A:goto P02A;{ int g[n]; P024A:goto P024A;0;}; P02B:goto P02B;{ int h[n]; P025A:goto P025A;0;}; P02C:goto P02C;; int i[n]; P026A:goto P026A;0;}; P0C:goto P0C;; int j[n]; P03A:goto P03A;0;a: goto a; P03B:goto P03B; }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '\\[^\\n'\\]*' declared here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "ac1ae96c2c9f5ea7e5230d968ceab432cf1b276e", "filename": "gcc/testsuite/gcc.dg/c99-vla-jump-3.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-3.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -303,3 +303,7 @@ void fc285 (int n) { { typedef int (*b)[n]; { typedef int (*c)[n]; 0;} { typedef\n void fc286 (int n) { { typedef int (*b)[n]; { typedef int (*c)[n]; 0;} { typedef int (*d)[n]; 0;} ; typedef int (*e)[n]; 0;}; { typedef int (*f)[n]; { typedef int (*g)[n]; 0;}; { typedef int (*h)[n]; 0;}; ; typedef int (*i)[n]; 0;}; a:; typedef int (*j)[n]; 0; goto a;  }\n void fc287 (int n) { { typedef int (*b)[n]; { typedef int (*c)[n]; 0;} { typedef int (*d)[n]; 0;} ; typedef int (*e)[n]; 0;}; { typedef int (*f)[n]; { typedef int (*g)[n]; 0;}; { typedef int (*h)[n]; 0;}; ; typedef int (*i)[n]; 0;}; ; typedef int (*j)[n]; a:0; goto a;  }\n void fc288 (int n) { { typedef int (*b)[n]; { typedef int (*c)[n]; 0;} { typedef int (*d)[n]; 0;} ; typedef int (*e)[n]; 0;}; { typedef int (*f)[n]; { typedef int (*g)[n]; 0;}; { typedef int (*h)[n]; 0;}; ; typedef int (*i)[n]; 0;}; ; typedef int (*j)[n]; 0;a: goto a;  }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '\\[^\\n'\\]*' declared here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "848dfba945cd0a220d19c21e944ba544853988dd", "filename": "gcc/testsuite/gcc.dg/c99-vla-jump-4.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-4.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -303,3 +303,7 @@ void fd285 (int n) { P0A:goto P0A;{ typedef int (*b)[n]; P01A:goto P01A;{ typede\n void fd286 (int n) { P0A:goto P0A;{ typedef int (*b)[n]; P01A:goto P01A;{ typedef int (*c)[n]; P012A:goto P012A;0;} P01B:goto P01B;{ typedef int (*d)[n]; P013A:goto P013A;0;} P01C:goto P01C;; typedef int (*e)[n]; P014A:goto P014A;0;}; P0B:goto P0B;{ typedef int (*f)[n]; P02A:goto P02A;{ typedef int (*g)[n]; P024A:goto P024A;0;}; P02B:goto P02B;{ typedef int (*h)[n]; P025A:goto P025A;0;}; P02C:goto P02C;; typedef int (*i)[n]; P026A:goto P026A;0;}; a:; typedef int (*j)[n]; P03A:goto P03A;0;p03B:goto p03B; goto a; P03B:goto P03B; }\n void fd287 (int n) { P0A:goto P0A;{ typedef int (*b)[n]; P01A:goto P01A;{ typedef int (*c)[n]; P012A:goto P012A;0;} P01B:goto P01B;{ typedef int (*d)[n]; P013A:goto P013A;0;} P01C:goto P01C;; typedef int (*e)[n]; P014A:goto P014A;0;}; P0B:goto P0B;{ typedef int (*f)[n]; P02A:goto P02A;{ typedef int (*g)[n]; P024A:goto P024A;0;}; P02B:goto P02B;{ typedef int (*h)[n]; P025A:goto P025A;0;}; P02C:goto P02C;; typedef int (*i)[n]; P026A:goto P026A;0;}; P0C:goto P0C;; typedef int (*j)[n]; a:0;p03B:goto p03B; goto a; P03B:goto P03B; }\n void fd288 (int n) { P0A:goto P0A;{ typedef int (*b)[n]; P01A:goto P01A;{ typedef int (*c)[n]; P012A:goto P012A;0;} P01B:goto P01B;{ typedef int (*d)[n]; P013A:goto P013A;0;} P01C:goto P01C;; typedef int (*e)[n]; P014A:goto P014A;0;}; P0B:goto P0B;{ typedef int (*f)[n]; P02A:goto P02A;{ typedef int (*g)[n]; P024A:goto P024A;0;}; P02B:goto P02B;{ typedef int (*h)[n]; P025A:goto P025A;0;}; P02C:goto P02C;; typedef int (*i)[n]; P026A:goto P026A;0;}; P0C:goto P0C;; typedef int (*j)[n]; P03A:goto P03A;0;a: goto a; P03B:goto P03B; }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '\\[^\\n'\\]*' declared here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "683bcf21eb39d8f6ae8dfb659c7ac63414b6d863", "filename": "gcc/testsuite/gcc.dg/c99-vla-jump-5.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-5.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -16,8 +16,8 @@ f (int a, int b)\n {\n   switch (a) {\n     int v[b];\n-  case 2: /* { dg-error \"case label in scope of identifier with variably modified type not containing enclosing switch statement\" } */\n-  default: /* { dg-error \"'default' label in scope of identifier with variably modified type not containing enclosing switch statement\" } */\n+  case 2: /* { dg-error \"switch jumps into scope of identifier with variably modified type\" } */\n+  default: /* { dg-error \"switch jumps into scope of identifier with variably modified type\" } */\n   switch (a)\n     {\n     case 4:\n@@ -28,3 +28,7 @@ f (int a, int b)\n     }\n   }\n }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: switch starts here\" \"note: expected\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '\\[^\\n'\\]*' declared here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "a9dd46623f3afeaabc34590fd0c4a1b9c063ce59", "filename": "gcc/testsuite/gcc.dg/stmt-expr-label-1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-1.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -402,3 +402,6 @@ void f194 (void) { ({ ({0;}); ({0;}); 0;}); ({ ({0;}); ({0;}); 0;}); a:0; goto a\n void fa194 (void) { P0A:goto P0A;({ P01A:goto P01A;({P012A:goto P012A;0;}); P01B:goto P01B;({P013A:goto P013A;0;}); P01C:goto P01C;0;}); P0B:goto P0B;({ P02A:goto P02A;({P024A:goto P024A;0;}); P02B:goto P02B;({P025A:goto P025A;0;}); P02C:goto P02C;0;}); a:0;p0D:goto p0D; goto a; P0D:goto P0D; }\n void f195 (void) { ({ ({0;}); ({0;}); 0;}); ({ ({0;}); ({0;}); 0;}); 0;a: goto a;  }\n void fa195 (void) { P0A:goto P0A;({ P01A:goto P01A;({P012A:goto P012A;0;}); P01B:goto P01B;({P013A:goto P013A;0;}); P01C:goto P01C;0;}); P0B:goto P0B;({ P02A:goto P02A;({P024A:goto P024A;0;}); P02B:goto P02B;({P025A:goto P025A;0;}); P02C:goto P02C;0;}); P0C:goto P0C;0;a: goto a; P0D:goto P0D; }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "be7aa521000d993491255617efbba946eaaf6ecc", "filename": "gcc/testsuite/gcc.dg/stmt-expr-label-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-2.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -8,13 +8,13 @@\n void\n f (int a)\n {\n-  switch (a)\n+  switch (a) /* { dg-message \"here\" } */\n     {\n     case 0:\n     case 1:\n       ({\n-      case 2: /* { dg-error \"case label in statement expression not containing enclosing switch statement\" } */\n-      default: /* { dg-error \"'default' label in statement expression not containing enclosing switch statement\" } */\n+      case 2: /* { dg-error \"switch jumps into statement expression\" } */\n+      default: /* { dg-error \"switch jumps into statement expression\" } */\n \tswitch (a)\n \t  {\n \t  case 3:"}, {"sha": "0a6722283f4c4f86cd6caf4330c55bdd3e1bcfcb", "filename": "gcc/testsuite/gcc.dg/stmt-expr-label-3.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstmt-expr-label-3.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -6,3 +6,6 @@\n /* { dg-options \"-O2\" } */\n \n void f(void) { 1 ? 1 : ({ a : 1; 1; }); goto a; } /* { dg-error \"jump into statement expression\" } */\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */"}, {"sha": "6e14a06875ee3480106ce8a7dc136be7b82595c0", "filename": "gcc/testsuite/gcc.dg/vla-8.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7793c8ebdc72bd3d7283d70a29444da614c13/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-8.c?ref=e1b7793c8ebdc72bd3d7283d70a29444da614c13", "patch": "@@ -23,8 +23,12 @@ void foo1(int n) {\n }\n \n void foo2(int n) {\n-  goto A;\n+  goto A;\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n   int (*(*bar2)(void))[n];\n- A:\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+ A:\n   ;\n }\n+\n+/* Match extra informative notes.  */\n+/* { dg-message \"note: label '\\[^\\n'\\]*' defined here\" \"note: expected\" { target *-*-* } 0 } */\n+/* { dg-message \"note: '\\[^\\n'\\]*' declared here\" \"note: expected\" { target *-*-* } 0 } */"}]}