{"sha": "38df970effee179b44b5701603fa9c39f6af3688", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhkZjk3MGVmZmVlMTc5YjQ0YjU3MDE2MDNmYTljMzlmNmFmMzY4OA==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2003-01-24T16:08:41Z"}, "committer": {"name": "Gerald Pfeifer", "email": "gerald@gcc.gnu.org", "date": "2003-01-24T16:08:41Z"}, "message": "invoke.texi (Optimization Options): List -O levels for each optimization flag.\n\n\t* gcc/doc/invoke.texi (Optimization Options): List -O levels\n\tfor each optimization flag.\n\nFrom-SVN: r61704", "tree": {"sha": "9b3955165c3f2d74c04f8ed00a4d4c5c25e692cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b3955165c3f2d74c04f8ed00a4d4c5c25e692cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38df970effee179b44b5701603fa9c39f6af3688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38df970effee179b44b5701603fa9c39f6af3688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38df970effee179b44b5701603fa9c39f6af3688", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38df970effee179b44b5701603fa9c39f6af3688/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dff23a65f632e475aa005066cb5c79d6a2bda1ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff23a65f632e475aa005066cb5c79d6a2bda1ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff23a65f632e475aa005066cb5c79d6a2bda1ac"}], "stats": {"total": 95, "additions": 88, "deletions": 7}, "files": [{"sha": "be871990e87bbc120374adaaebad76f162d88642", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38df970effee179b44b5701603fa9c39f6af3688/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38df970effee179b44b5701603fa9c39f6af3688/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38df970effee179b44b5701603fa9c39f6af3688", "patch": "@@ -1,3 +1,8 @@\n+2003-01-24  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* gcc/doc/invoke.texi (Optimization Options): List -O levels\n+\tfor each optimization flag.\n+\n 2003-01-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (*andsi3_ashift_n_lower): New."}, {"sha": "1826df2d2d05ba21a2738071d8bce693b198503d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 83, "deletions": 7, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38df970effee179b44b5701603fa9c39f6af3688/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38df970effee179b44b5701603fa9c39f6af3688/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=38df970effee179b44b5701603fa9c39f6af3688", "patch": "@@ -3557,13 +3557,17 @@ returns.  For machines which must pop arguments after a function call,\n the compiler normally lets arguments accumulate on the stack for several\n function calls and pops them all at once.\n \n+Disabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fforce-mem\n @opindex fforce-mem\n Force memory operands to be copied into registers before doing\n arithmetic on them.  This produces better code by making all memory\n references potential common subexpressions.  When they are not common\n subexpressions, instruction combination should eliminate the separate\n-register-load.  The @option{-O2} option turns on this option.\n+register-load.\n+\n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n @item -fforce-addr\n @opindex fforce-addr\n@@ -3586,10 +3590,14 @@ machine-description macro @code{FRAME_POINTER_REQUIRED} controls\n whether a target machine supports this flag.  @xref{Registers,,Register\n Usage, gccint, GNU Compiler Collection (GCC) Internals}.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -foptimize-sibling-calls\n @opindex foptimize-sibling-calls\n Optimize sibling and tail recursive calls.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -ftrapv\n @opindex ftrapv\n This option generates traps for signed overflow on addition, subtraction,\n@@ -3611,6 +3619,8 @@ If all calls to a given function are integrated, and the function is\n declared @code{static}, then the function is normally not output as\n assembler code in its own right.\n \n+Enabled at level @option{-O3}.\n+\n @item -finline-limit=@var{n}\n @opindex finline-limit\n By default, gcc limits the size of functions that can be inlined.  This flag\n@@ -3654,6 +3664,8 @@ This option is the default for optimized compilation if the assembler and\n linker support it.  Use @option{-fno-merge-constants} to inhibit this\n behavior.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fmerge-all-constants\n Attempt to merge identical constants and identical variables.\n \n@@ -3678,6 +3690,9 @@ register, compare it against zero, then branch based upon the result.\n This option is only meaningful on architectures that support such\n instructions, which include x86, PowerPC, IA-64 and S/390.\n \n+The default is @option{-fbranch-count-reg}, enabled when\n+@option{-fstrength-reduce} is enabled.\n+\n @item -fno-function-cse\n @opindex fno-function-cse\n Do not put function addresses in registers; make each instruction that\n@@ -3687,6 +3702,8 @@ This option results in less efficient code, but some strange hacks\n that alter the assembler output may be confused by the optimizations\n performed when this option is not used.\n \n+The default is @option{-ffunction-cse}\n+\n @item -ffast-math\n @opindex ffast-math\n Sets @option{-fno-math-errno}, @option{-funsafe-math-optimizations}, @*\n@@ -3795,6 +3812,8 @@ this option defaults to true and false respectively.\n Perform the optimizations of loop strength reduction and\n elimination of iteration variables.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fthread-jumps\n @opindex fthread-jumps\n Perform optimizations where we check to see if a jump branches to a\n@@ -3803,6 +3822,8 @@ so, the first branch is redirected to either the destination of the\n second branch or a point immediately following it, depending on whether\n the condition is known to be true or false.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fcse-follow-jumps\n @opindex fcse-follow-jumps\n In common subexpression elimination, scan through jump instructions\n@@ -3811,6 +3832,8 @@ example, when CSE encounters an @code{if} statement with an\n @code{else} clause, CSE will follow the jump when the condition\n tested is false.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fcse-skip-blocks\n @opindex fcse-skip-blocks\n This is similar to @option{-fcse-follow-jumps}, but causes CSE to\n@@ -3819,15 +3842,21 @@ encounters a simple @code{if} statement with no else clause,\n @option{-fcse-skip-blocks} causes CSE to follow the jump around the\n body of the @code{if}.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -frerun-cse-after-loop\n @opindex frerun-cse-after-loop\n Re-run common subexpression elimination after loop optimizations has been\n performed.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -frerun-loop-opt\n @opindex frerun-loop-opt\n Run the loop optimizer twice.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fgcse\n @opindex fgcse\n Perform a global common subexpression elimination pass.\n@@ -3838,43 +3867,57 @@ extension, you may get better runtime performance if you disable\n the global common subexpression elimination pass by adding\n @option{-fno-gcse} to the command line.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fgcse-lm\n @opindex fgcse-lm\n When @option{-fgcse-lm} is enabled, global common subexpression elimination will\n attempt to move loads which are only killed by stores into themselves.  This\n allows a loop containing a load/store sequence to be changed to a load outside\n the loop, and a copy/store within the loop.\n \n+Enabled by default when gcse is enabled.\n+\n @item -fgcse-sm\n @opindex fgcse-sm\n When @option{-fgcse-sm} is enabled, A store motion pass is run after global common\n subexpression elimination.  This pass will attempt to move stores out of loops.\n When used in conjunction with @option{-fgcse-lm}, loops containing a load/store sequence\n can be changed to a load before the loop and a store after the loop.\n \n+Enabled by default when gcse is enabled.\n+\n @item -floop-optimize\n @opindex floop-optimize\n Perform loop optimizations: move constant expressions out of loops, simplify\n exit test conditions and optionally do strength-reduction and loop unrolling as\n well.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fcrossjumping\n @opindex crossjumping\n Perform cross-jumping transformation. This transformation unifies equivalent code and save code size. The\n resulting code may or may not perform better than without cross-jumping.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fif-conversion\n @opindex if-conversion\n Attempt to transform conditional jumps into branch-less equivalents.  This\n include use of conditional moves, min, max, set flags and abs instructions, and\n some tricks doable by standard arithmetics.  The use of conditional execution\n on chips where it is available is controlled by @code{if-conversion2}.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fif-conversion2\n @opindex if-conversion2\n Use conditional execution (where available) to transform conditional jumps into\n branch-less equivalents.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fdelete-null-pointer-checks\n @opindex fdelete-null-pointer-checks\n Use global dataflow analysis to identify and eliminate useless checks\n@@ -3887,29 +3930,36 @@ safely dereference null pointers.  Use\n @option{-fno-delete-null-pointer-checks} to disable this optimization\n for programs which depend on that behavior.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fexpensive-optimizations\n @opindex fexpensive-optimizations\n Perform a number of minor optimizations that are relatively expensive.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -foptimize-register-move\n @itemx -fregmove\n @opindex foptimize-register-move\n @opindex fregmove\n Attempt to reassign register numbers in move instructions and as\n operands of other simple instructions in order to maximize the amount of\n register tying.  This is especially helpful on machines with two-operand\n-instructions.  GCC enables this optimization by default with @option{-O2}\n-or higher.\n+instructions.\n \n Note @option{-fregmove} and @option{-foptimize-register-move} are the same\n optimization.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fdelayed-branch\n @opindex fdelayed-branch\n If supported for the target machine, attempt to reorder instructions\n to exploit instruction slots available after delayed branch\n instructions.\n \n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fschedule-insns\n @opindex fschedule-insns\n If supported for the target machine, attempt to reorder instructions to\n@@ -3918,13 +3968,17 @@ helps machines that have slow floating point or memory load instructions\n by allowing other instructions to be issued until the result of the load\n or floating point instruction is required.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fschedule-insns2\n @opindex fschedule-insns2\n Similar to @option{-fschedule-insns}, but requests an additional pass of\n instruction scheduling after register allocation has been done.  This is\n especially useful on machines with a relatively small number of\n registers and where memory load instructions take more than one cycle.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fno-sched-interblock\n @opindex fno-sched-interblock\n Don't schedule instructions across basic blocks.  This is normally\n@@ -3981,8 +4035,7 @@ seems to result in better code than would otherwise be produced.\n This option is always enabled by default on certain machines, usually\n those which have no call-preserved registers to use instead.\n \n-For all machines, optimization level 2 and higher enables this flag by\n-default.\n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n @item -ftracer\n @opindex ftracer\n@@ -4009,6 +4062,8 @@ the loop is entered.  This usually makes programs run more slowly.\n If supported by the target machine, generate instructions to prefetch\n memory to improve the performance of loops that access large arrays.\n \n+Disabled at level @option{-Os}.\n+\n @item -fmove-all-movables\n @opindex fmove-all-movables\n Forces all invariant computations in loops to be moved\n@@ -4045,6 +4100,9 @@ between @option{-fno-peephole} and @option{-fno-peephole2} is in how they\n are implemented in the compiler; some targets use one, some use the\n other, a few use both.\n \n+@option{-fpeephole} is enabled by default.\n+@option{-fpeephole2} enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fbranch-probabilities\n @opindex fbranch-probabilities\n After running a program compiled with @option{-fprofile-arcs}\n@@ -4082,11 +4140,16 @@ non-determinism is of paramount import.  This switch allows users to\n reduce non-determinism, possibly at the expense of inferior\n optimization.\n \n+The default is @option{-fguess-branch-probability} at levels\n+@option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -freorder-blocks\n @opindex freorder-blocks\n Reorder basic blocks in the compiled function in order to reduce number of\n taken branches and improve code locality.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -freorder-functions\n @opindex freorder-functions\n Reorder basic blocks in the compiled function in order to reduce number of\n@@ -4099,6 +4162,8 @@ place them in a reasonable way.\n Also profile feedback must be available in to make this option effective.  See\n @option{-fprofile-arcs} for details.\n \n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fstrict-aliasing\n @opindex fstrict-aliasing\n Allows the compiler to assume the strictest aliasing rules applicable to\n@@ -4144,8 +4209,7 @@ node, an alias set for the node.  Nodes in different alias sets are not\n allowed to alias.  For an example, see the C front-end function\n @code{c_get_alias_set}.\n \n-For all machines, optimization level 2 and higher enables this flag by\n-default.\n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n @item -falign-functions\n @itemx -falign-functions=@var{n}\n@@ -4164,6 +4228,8 @@ in that case, it is rounded up.\n \n If @var{n} is not specified, use a machine-dependent default.\n \n+Enabled at levels @option{-O2}, @option{-O3}.\n+\n @item -falign-labels\n @itemx -falign-labels=@var{n}\n @opindex falign-labels\n@@ -4178,6 +4244,8 @@ are greater than this value, then their values are used instead.\n If @var{n} is not specified, use a machine-dependent default which is\n very likely to be @samp{1}, meaning no alignment.\n \n+Enabled at levels @option{-O2}, @option{-O3}.\n+\n @item -falign-loops\n @itemx -falign-loops=@var{n}\n @opindex falign-loops\n@@ -4188,6 +4256,8 @@ operations.\n \n If @var{n} is not specified, use a machine-dependent default.\n \n+Enabled at levels @option{-O2}, @option{-O3}.\n+\n @item -falign-jumps\n @itemx -falign-jumps=@var{n}\n @opindex falign-jumps\n@@ -4198,6 +4268,8 @@ need be executed.\n \n If @var{n} is not specified, use a machine-dependent default.\n \n+Enabled at levels @option{-O2}, @option{-O3}.\n+\n @item -fssa\n @opindex fssa\n Perform optimizations in static single assignment form.  Each function's\n@@ -4228,12 +4300,16 @@ will most benefit processors with lots of registers.  It can, however,\n make debugging impossible, since variables will no longer stay in\n a ``home register''.\n \n+Enabled at levels @option{-O3}.\n+\n @item -fno-cprop-registers\n @opindex fno-cprop-registers\n After register allocation and post-register allocation instruction splitting,\n we perform a copy-propagation pass to try to reduce scheduling dependencies\n and occasionally eliminate the copy.\n \n+Disabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item --param @var{name}=@var{value}\n @opindex param\n In some places, GCC uses various constants to control the amount of"}]}