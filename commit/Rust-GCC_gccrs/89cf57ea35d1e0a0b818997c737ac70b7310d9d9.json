{"sha": "89cf57ea35d1e0a0b818997c737ac70b7310d9d9", "node_id": "C_kwDOANBUbNoAKDg5Y2Y1N2VhMzVkMWUwYTBiODE4OTk3YzczN2FjNzBiNzMxMGQ5ZDk", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-19T19:42:14Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-12-19T19:42:14Z"}, "message": "c++: nested lambda capturing a capture proxy, cont [PR94376]\n\nThe r12-5403 fix apparently doesn't handle the case where the inner\nlambda explicitly rather than implicitly captures the capture proxy from\nthe outer lambda, which causes us to reject the first example in the\ntestcase below.\n\nThis is because compared to an implicit capture, the effective initializer\nfor an explicit capture is wrapped in a location wrapper (pointing to within\nthe capture list), and this wrapper foils the is_capture_proxy check added\nin r12-5403.\n\nThe simplest fix appears to be to strip location wrappers accordingly\nbefore checking is_capture_proxy.  And to help prevent against this kind\nof bug, this patch also makes is_capture_proxy assert it doesn't see a\nlocation wrapper.\n\n\tPR c++/94376\n\ngcc/cp/ChangeLog:\n\n\t* lambda.c (lambda_capture_field_type): Strip location wrappers\n\tbefore checking for a capture proxy.\n\t(is_capture_proxy): Assert that we don't see a location wrapper.\n\t(mark_const_cap_r): Don't call is_constant_capture_proxy on a\n\tlocation wrapper.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/lambda/lambda-nested9a.C: New test.", "tree": {"sha": "f01d76e72c3225144859ee2ab1ddf2e65aa989db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f01d76e72c3225144859ee2ab1ddf2e65aa989db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89cf57ea35d1e0a0b818997c737ac70b7310d9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cf57ea35d1e0a0b818997c737ac70b7310d9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89cf57ea35d1e0a0b818997c737ac70b7310d9d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89cf57ea35d1e0a0b818997c737ac70b7310d9d9/comments", "author": null, "committer": null, "parents": [{"sha": "eac42299bfdf7de445b1bbed2ccb736a611f3863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac42299bfdf7de445b1bbed2ccb736a611f3863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eac42299bfdf7de445b1bbed2ccb736a611f3863"}], "stats": {"total": 51, "additions": 50, "deletions": 1}, "files": [{"sha": "b1cbe271c817b1fc27c80d949252c6bce555b116", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89cf57ea35d1e0a0b818997c737ac70b7310d9d9/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89cf57ea35d1e0a0b818997c737ac70b7310d9d9/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=89cf57ea35d1e0a0b818997c737ac70b7310d9d9", "patch": "@@ -221,6 +221,8 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n     }\n   else\n     {\n+      STRIP_ANY_LOCATION_WRAPPER (expr);\n+\n       if (!by_reference_p && is_capture_proxy (expr))\n \t{\n \t  /* When capturing by-value another capture proxy from an enclosing\n@@ -246,6 +248,10 @@ lambda_capture_field_type (tree expr, bool explicit_init_p,\n bool\n is_capture_proxy (tree decl)\n {\n+  /* Location wrappers should be stripped or otherwise handled by the\n+     caller before using this predicate.  */\n+  gcc_checking_assert (!location_wrapper_p (decl));\n+\n   return (VAR_P (decl)\n \t  && DECL_HAS_VALUE_EXPR_P (decl)\n \t  && !DECL_ANON_UNION_VAR_P (decl)\n@@ -1496,7 +1502,8 @@ mark_const_cap_r (tree *t, int *walk_subtrees, void *data)\n \t  *walk_subtrees = 0;\n \t}\n     }\n-  else if (is_constant_capture_proxy (*t))\n+  else if (!location_wrapper_p (*t) /* is_capture_proxy dislikes them.  */\n+\t   && is_constant_capture_proxy (*t))\n     var = DECL_CAPTURED_VARIABLE (*t);\n \n   if (var)"}, {"sha": "d62f8f0c9520baf570618b852e06962206892141", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-nested9a.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89cf57ea35d1e0a0b818997c737ac70b7310d9d9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested9a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89cf57ea35d1e0a0b818997c737ac70b7310d9d9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested9a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-nested9a.C?ref=89cf57ea35d1e0a0b818997c737ac70b7310d9d9", "patch": "@@ -0,0 +1,42 @@\n+// PR c++/94376\n+// Like lambda-nested9.C but using explicit captures in the inner lambda.\n+// { dg-do compile { target c++11 } }\n+\n+int main() {\n+  // We used to incorrectly reject the first two cases.\n+  int i = 0;\n+  [=] () {\n+    [i] () mutable {\n+      ++i;\n+    };\n+  };\n+\n+#if __cpp_init_captures\n+  [j=0] () {\n+    [j] () mutable {\n+      ++j;\n+    };\n+  };\n+#endif\n+\n+  [=] () {\n+    [&i] () mutable {\n+      ++i; // { dg-error \"read-only\" }\n+    };\n+  };\n+\n+  const int j = 0;\n+  [=] () {\n+    [j] () mutable {\n+      ++j; // { dg-error \"read-only\" }\n+    };\n+  };\n+\n+#if __cpp_init_captures\n+  [j=0] () {\n+    [&j] () mutable {\n+      ++j; // { dg-error \"read-only\" \"\" { target c++14 } }\n+    };\n+  };\n+#endif\n+}"}]}