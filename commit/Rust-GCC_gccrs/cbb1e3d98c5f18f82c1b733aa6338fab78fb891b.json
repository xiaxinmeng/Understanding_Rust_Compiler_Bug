{"sha": "cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiMWUzZDk4YzVmMThmODJjMWI3MzNhYTYzMzhmYWI3OGZiODkxYg==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2014-07-02T13:03:14Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2014-07-02T13:03:14Z"}, "message": "Support mode toggle.\n\n* mode-switching.c (struct bb_info): Add mode_out, mode_in caches.\n(make_preds_opaque): Delete.\n(clear_mode_bit, mode_bit_p, set_mode_bit): New macros.\n(commit_mode_sets): New function.\n(optimize_mode_switching): Handle current_mode to mode_switching_emit.\nProcess all modes at once.\n* basic-block.h (pre_edge_lcm_avs): Declare.\n* lcm.c (pre_edge_lcm_avs): Renamed from pre_edge_lcm.\nCall clear_aux_for_edges. Fix comments.\n(pre_edge_lcm): New wrapper function to call pre_edge_lcm_avs.\n(pre_edge_rev_lcm): Idem.\n* config/epiphany/epiphany.c (emit_set_fp_mode): Add prev_mode parameter.\n* config/epiphany/epiphany-protos.h (emit_set_fp_mode): Idem.\n* config/epiphany/resolve-sw-modes.c (pass_resolve_sw_modes::execute): Idem.\n* config/i386/i386.c (x96_emit_mode_set): Idem.\n* config/sh/sh.c (sh_emit_mode_set): Likewise. Handle PR toggle.\n* config/sh/sh.md (toggle_pr): \tDefined if TARGET_FPU_SINGLE.\n(fpscr_toggle) Disallow from delay slot.\n* target.def (emit_mode_set): Add prev_mode parameter.\n* doc/tm.texi: Regenerate.\n\nFrom-SVN: r212230", "tree": {"sha": "d5f4efb38c4b5345b26af85c0f13b1a9412dd461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5f4efb38c4b5345b26af85c0f13b1a9412dd461"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/comments", "author": null, "committer": null, "parents": [{"sha": "b18f1efce09e8cab57d6141754db3456fab938f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b18f1efce09e8cab57d6141754db3456fab938f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b18f1efce09e8cab57d6141754db3456fab938f7"}], "stats": {"total": 445, "additions": 281, "deletions": 164}, "files": [{"sha": "e60890bd2708dc33b5899b81feda605b05bf56e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -1,3 +1,26 @@\n+2014-07-02  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* mode-switching.c (struct bb_info): Add mode_out, mode_in caches.\n+\t(make_preds_opaque): Delete.\n+\t(clear_mode_bit, mode_bit_p, set_mode_bit): New macros.\n+\t(commit_mode_sets): New function.\n+\t(optimize_mode_switching): Handle current_mode to mode_switching_emit.\n+\tProcess all modes at once.\n+\t* basic-block.h (pre_edge_lcm_avs): Declare.\n+\t* lcm.c (pre_edge_lcm_avs): Renamed from pre_edge_lcm.\n+\tCall clear_aux_for_edges. Fix comments.\n+\t(pre_edge_lcm): New wrapper function to call pre_edge_lcm_avs.\n+\t(pre_edge_rev_lcm): Idem.\n+\t* config/epiphany/epiphany.c (emit_set_fp_mode): Add prev_mode parameter.\n+\t* config/epiphany/epiphany-protos.h (emit_set_fp_mode): Idem.\n+\t* config/epiphany/resolve-sw-modes.c (pass_resolve_sw_modes::execute): Idem.\n+\t* config/i386/i386.c (x96_emit_mode_set): Idem.\n+\t* config/sh/sh.c (sh_emit_mode_set): Likewise. Handle PR toggle.\n+\t* config/sh/sh.md (toggle_pr): \tDefined if TARGET_FPU_SINGLE.\n+\t(fpscr_toggle) Disallow from delay slot.\n+\t* target.def (emit_mode_set): Add prev_mode parameter.\n+\t* doc/tm.texi: Regenerate.\n+\n 2014-07-02  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_expand_vec_perm): Delete unused"}, {"sha": "f417b34a873704adce16392604ef88421a4f97ad", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -711,6 +711,9 @@ extern void bitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n \t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n \t\t\t\t       sbitmap **);\n+extern struct edge_list *pre_edge_lcm_avs (int, sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t\t   sbitmap *, sbitmap **, sbitmap **);\n extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap **,"}, {"sha": "98342a8d4998eba404f724c79d379d021846a98d", "filename": "gcc/config/epiphany/epiphany-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -40,7 +40,8 @@ extern int epiphany_initial_elimination_offset (int, int);\n extern void epiphany_init_expanders (void);\n extern int hard_regno_mode_ok (int regno, enum machine_mode mode);\n #ifdef HARD_CONST\n-extern void emit_set_fp_mode (int entity, int mode, HARD_REG_SET regs_live);\n+extern void emit_set_fp_mode (int entity, int mode, int prev_mode,\n+\t\t\t      HARD_REG_SET regs_live);\n #endif\n extern void epiphany_insert_mode_switch_use (rtx insn, int, int);\n extern void epiphany_expand_set_fp_mode (rtx *operands);"}, {"sha": "a9a3711509698a1efc7ab3f893bbb48343eb0454", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -2543,7 +2543,8 @@ epiphany_mode_exit (int entity)\n }\n \n void\n-emit_set_fp_mode (int entity, int mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)\n+emit_set_fp_mode (int entity, int mode, int prev_mode ATTRIBUTE_UNUSED,\n+\t\t  HARD_REG_SET regs_live ATTRIBUTE_UNUSED)\n {\n   rtx save_cc, cc_reg, mask, src, src2;\n   enum attr_fp_mode fp_mode;"}, {"sha": "a0c4fa44a41395fb81a0a1807a85c6ca626fd99f", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -170,7 +170,7 @@ pass_resolve_sw_modes::execute (function *fun)\n \t    }\n \t  start_sequence ();\n \t  emit_set_fp_mode (EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN,\n-\t\t\t    jilted_mode, NULL);\n+\t\t\t    jilted_mode, FP_MODE_NONE, NULL);\n \t  seq = get_insns ();\n \t  end_sequence ();\n \t  need_commit = true;"}, {"sha": "d29a25b13cbd8b5632d7dea0c3809087f2598aa5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -16447,7 +16447,8 @@ ix86_avx_emit_vzeroupper (HARD_REG_SET regs_live)\n    are to be inserted.  */\n \n static void\n-ix86_emit_mode_set (int entity, int mode, HARD_REG_SET regs_live)\n+ix86_emit_mode_set (int entity, int mode, int prev_mode ATTRIBUTE_UNUSED,\n+\t\t    HARD_REG_SET regs_live)\n {\n   switch (entity)\n     {"}, {"sha": "02468dadcddbaa6e7d705ba74c1a972864235912", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -203,7 +203,7 @@ static void push_regs (HARD_REG_SET *, int);\n static int calc_live_regs (HARD_REG_SET *);\n static HOST_WIDE_INT rounded_frame_size (int);\n static bool sh_frame_pointer_required (void);\n-static void sh_emit_mode_set (int, int, HARD_REG_SET);\n+static void sh_emit_mode_set (int, int, int, HARD_REG_SET);\n static int sh_mode_needed (int, rtx);\n static int sh_mode_after (int, int, rtx);\n static int sh_mode_entry (int);\n@@ -13583,9 +13583,17 @@ sh_try_omit_signzero_extend (rtx extended_op, rtx insn)\n \n static void\n sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,\n-\t\t  HARD_REG_SET regs_live)\n+\t\t  int prev_mode, HARD_REG_SET regs_live)\n {\n-  fpscr_set_from_mem (mode, regs_live);\n+  if ((TARGET_SH4A_FP || TARGET_SH4_300)\n+      && prev_mode != FP_MODE_NONE && prev_mode != mode)\n+    {\n+      emit_insn (gen_toggle_pr ());\n+      if (TARGET_FMOVD)\n+\temit_insn (gen_toggle_sz ());\n+    }\n+  else\n+    fpscr_set_from_mem (mode, regs_live);\n }\n \n static int"}, {"sha": "b5d05f4c7de00c4b5d1ce1807750b6ecb2fb0f4f", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -504,6 +504,7 @@\n (define_attr \"in_delay_slot\" \"yes,no\"\n   (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n \t (eq_attr \"type\" \"pcload,pcload_si\") (const_string \"no\")\n+\t (eq_attr \"type\" \"fpscr_toggle\") (const_string \"no\")\n \t (eq_attr \"needs_delay_slot\" \"yes\") (const_string \"no\")\n \t (eq_attr \"length\" \"2\") (const_string \"yes\")\n \t ] (const_string \"no\")))\n@@ -12239,15 +12240,12 @@ label:\n   \"fschg\"\n   [(set_attr \"type\" \"fpscr_toggle\") (set_attr \"fp_set\" \"unknown\")])\n \n-;; There's no way we can use it today, since optimize mode switching\n-;; doesn't enable us to know from which mode we're switching to the\n-;; mode it requests, to tell whether we can use a relative mode switch\n-;; (like toggle_pr) or an absolute switch (like loading fpscr from\n-;; memory).\n+;; Toggle FPU precision PR mode.\n+\n (define_insn \"toggle_pr\"\n   [(set (reg:PSI FPSCR_REG)\n \t(xor:PSI (reg:PSI FPSCR_REG) (const_int 524288)))]\n-  \"TARGET_SH4A_FP && ! TARGET_FPU_SINGLE\"\n+  \"TARGET_SH4A_FP\"\n   \"fpchg\"\n   [(set_attr \"type\" \"fpscr_toggle\")])\n "}, {"sha": "9dd8d68ddb9d762607a7aef6f17d49c0b7bc8266", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -9595,12 +9595,12 @@ represented as numbers 0 @dots{} N @minus{} 1.  N is used to specify that no mod\n switch is needed / supplied.\n @end defmac\n \n-@deftypefn {Target Hook} void TARGET_MODE_EMIT (int @var{entity}, int @var{mode}, HARD_REG_SET @var{regs_live})\n-Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.\n+@deftypefn {Target Hook} void TARGET_MODE_EMIT (int @var{entity}, int @var{mode}, int @var{prev_mode}, HARD_REG_SET @var{regs_live})\n+Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. @var{prev_moxde} indicates the mode to switch from. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_MODE_NEEDED (int @var{entity}, rtx @var{insn})\n-@var{entity} is an integer specifying a mode-switched entity. If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.\n+@var{entity} is an integer specifying a mode-switched entity.  If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_MODE_AFTER (int @var{entity}, int @var{mode}, rtx @var{insn})"}, {"sha": "cf69428a51c4736228c6d7b8191969f4f3428629", "filename": "gcc/lcm.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -377,17 +377,17 @@ compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n     }\n }\n \n-/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the insert and\n-   delete vectors for edge based LCM.  Returns an edgelist which is used to\n+/* Given local properties TRANSP, ANTLOC, AVLOC, KILL return the insert and\n+   delete vectors for edge based LCM  and return the AVIN, AVOUT bitmap.\n    map the insert vector to what edge an expression should be inserted on.  */\n \n struct edge_list *\n-pre_edge_lcm (int n_exprs, sbitmap *transp,\n+pre_edge_lcm_avs (int n_exprs, sbitmap *transp,\n \t      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,\n+\t      sbitmap *avin, sbitmap *avout,\n \t      sbitmap **insert, sbitmap **del)\n {\n   sbitmap *antin, *antout, *earliest;\n-  sbitmap *avin, *avout;\n   sbitmap *later, *laterin;\n   struct edge_list *edge_list;\n   int num_edges;\n@@ -413,10 +413,7 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n #endif\n \n   /* Compute global availability.  */\n-  avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n-  avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n   compute_available (avloc, kill, avout, avin);\n-  sbitmap_vector_free (avin);\n \n   /* Compute global anticipatability.  */\n   antin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n@@ -444,7 +441,6 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n \n   sbitmap_vector_free (antout);\n   sbitmap_vector_free (antin);\n-  sbitmap_vector_free (avout);\n \n   later = sbitmap_vector_alloc (num_edges, n_exprs);\n \n@@ -485,6 +481,28 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n   return edge_list;\n }\n \n+/* Wrapper to allocate avin/avout and call pre_edge_lcm_avs.  */\n+\n+struct edge_list *\n+pre_edge_lcm (int n_exprs, sbitmap *transp,\n+\t      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,\n+\t      sbitmap **insert, sbitmap **del)\n+{\n+  struct edge_list *edge_list;\n+  sbitmap *avin, *avout;\n+\n+  avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+  avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);\n+\n+  edge_list = pre_edge_lcm_avs (n_exprs, transp, avloc, antloc, kill,\n+\t\t\t\t avin, avout, insert, del);\n+\n+  sbitmap_vector_free (avout);\n+  sbitmap_vector_free (avin);\n+\n+  return edge_list;\n+}\n+\n /* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.\n    Return the number of passes we performed to iterate to a solution.  */\n "}, {"sha": "488f2a36489b034a277c722292dfcd2f71259f81", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 197, "deletions": 137, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -80,23 +80,75 @@ struct bb_info\n {\n   struct seginfo *seginfo;\n   int computing;\n+  int mode_out;\n+  int mode_in;\n };\n \n-/* These bitmaps are used for the LCM algorithm.  */\n-\n-static sbitmap *antic;\n-static sbitmap *transp;\n-static sbitmap *comp;\n-\n static struct seginfo * new_seginfo (int, rtx, int, HARD_REG_SET);\n static void add_seginfo (struct bb_info *, struct seginfo *);\n static void reg_dies (rtx, HARD_REG_SET *);\n static void reg_becomes_live (rtx, const_rtx, void *);\n-static void make_preds_opaque (basic_block, int);\n-\f\n \n-/* This function will allocate a new BBINFO structure, initialized\n-   with the MODE, INSN, and basic block BB parameters.\n+/* Clear ode I from entity J in bitmap B.  */\n+#define clear_mode_bit(b, j, i) \\\n+       bitmap_clear_bit (b, (j * max_num_modes) + i)\n+\n+/* Test mode I from entity J in bitmap B.  */\n+#define mode_bit_p(b, j, i) \\\n+       bitmap_bit_p (b, (j * max_num_modes) + i)\n+\n+/* Set mode I from entity J in bitmal B.  */\n+#define set_mode_bit(b, j, i) \\\n+       bitmap_set_bit (b, (j * max_num_modes) + i)\n+\n+/* Emit modes segments from EDGE_LIST associated with entity E.\n+   INFO gives mode availability for each mode.  */\n+\n+static bool\n+commit_mode_sets (struct edge_list *edge_list, int e, struct bb_info *info)\n+{\n+  bool need_commit = false;\n+\n+  for (int ed = NUM_EDGES (edge_list) - 1; ed >= 0; ed--)\n+    {\n+      edge eg = INDEX_EDGE (edge_list, ed);\n+      int mode;\n+\n+      if ((mode = (int)(intptr_t)(eg->aux)) != -1)\n+\t{\n+\t  HARD_REG_SET live_at_edge;\n+\t  basic_block src_bb = eg->src;\n+\t  int cur_mode = info[src_bb->index].mode_out;\n+\t  rtx mode_set;\n+\n+\t  REG_SET_TO_HARD_REG_SET (live_at_edge, df_get_live_out (src_bb));\n+\n+\t  rtl_profile_for_edge (eg);\n+\t  start_sequence ();\n+\n+\t  targetm.mode_switching.emit (e, mode, cur_mode, live_at_edge);\n+\n+\t  mode_set = get_insns ();\n+\t  end_sequence ();\n+\t  default_rtl_profile ();\n+\n+\t  /* Do not bother to insert empty sequence.  */\n+\t  if (mode_set == NULL_RTX)\n+\t    continue;\n+\n+\t  /* We should not get an abnormal edge here.  */\n+\t  gcc_assert (! (eg->flags & EDGE_ABNORMAL));\n+\n+\t  need_commit = true;\n+\t  insert_insn_on_edge (mode_set, eg);\n+\t}\n+    }\n+\n+  return need_commit;\n+}\n+\n+/* Allocate a new BBINFO structure, initialized with the MODE, INSN,\n+   and basic block BB parameters.\n    INSN may not be a NOTE_INSN_BASIC_BLOCK, unless it is an empty\n    basic block; that allows us later to insert instructions in a FIFO-like\n    manner.  */\n@@ -137,30 +189,6 @@ add_seginfo (struct bb_info *head, struct seginfo *info)\n     }\n }\n \n-/* Make all predecessors of basic block B opaque, recursively, till we hit\n-   some that are already non-transparent, or an edge where aux is set; that\n-   denotes that a mode set is to be done on that edge.\n-   J is the bit number in the bitmaps that corresponds to the entity that\n-   we are currently handling mode-switching for.  */\n-\n-static void\n-make_preds_opaque (basic_block b, int j)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, b->preds)\n-    {\n-      basic_block pb = e->src;\n-\n-      if (e->aux || ! bitmap_bit_p (transp[pb->index], j))\n-\tcontinue;\n-\n-      bitmap_clear_bit (transp[pb->index], j);\n-      make_preds_opaque (pb, j);\n-    }\n-}\n-\n /* Record in LIVE that register REG died.  */\n \n static void\n@@ -452,24 +480,26 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n static int\n optimize_mode_switching (void)\n {\n-  rtx insn;\n   int e;\n   basic_block bb;\n-  int need_commit = 0;\n-  sbitmap *kill;\n-  struct edge_list *edge_list;\n+  bool need_commit = false;\n   static const int num_modes[] = NUM_MODES_FOR_MODE_SWITCHING;\n #define N_ENTITIES ARRAY_SIZE (num_modes)\n   int entity_map[N_ENTITIES];\n   struct bb_info *bb_info[N_ENTITIES];\n   int i, j;\n-  int n_entities;\n+  int n_entities = 0;\n   int max_num_modes = 0;\n   bool emitted ATTRIBUTE_UNUSED = false;\n   basic_block post_entry = 0;\n   basic_block pre_exit = 0;\n+  struct edge_list *edge_list = 0;\n+\n+  /* These bitmaps are used for the LCM algorithm.  */\n+  sbitmap *kill, *del, *insert, *antic, *transp, *comp;\n+  sbitmap *avin, *avout;\n \n-  for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n+  for (e = N_ENTITIES - 1; e >= 0; e--)\n     if (OPTIMIZE_MODE_SWITCHING (e))\n       {\n \tint entry_exit_extra = 0;\n@@ -491,9 +521,10 @@ optimize_mode_switching (void)\n   if (! n_entities)\n     return 0;\n \n-  /* Make sure if MODE_ENTRY is defined the MODE_EXIT is defined and vice versa.  */\n+  /* Make sure if MODE_ENTRY is defined MODE_EXIT is defined.  */\n   gcc_assert ((targetm.mode_switching.entry && targetm.mode_switching.exit)\n-\t      || (!targetm.mode_switching.entry && !targetm.mode_switching.exit));\n+\t      || (!targetm.mode_switching.entry\n+\t\t  && !targetm.mode_switching.exit));\n \n   if (targetm.mode_switching.entry && targetm.mode_switching.exit)\n     {\n@@ -506,18 +537,29 @@ optimize_mode_switching (void)\n   df_analyze ();\n \n   /* Create the bitmap vectors.  */\n-\n-  antic = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n-  transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n-  comp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n+  antic = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\tn_entities * max_num_modes);\n+  transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t n_entities * max_num_modes);\n+  comp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t       n_entities * max_num_modes);\n+  avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t       n_entities * max_num_modes);\n+  avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\tn_entities * max_num_modes);\n+  kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t       n_entities * max_num_modes);\n \n   bitmap_vector_ones (transp, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (antic, last_basic_block_for_fn (cfun));\n+  bitmap_vector_clear (comp, last_basic_block_for_fn (cfun));\n \n   for (j = n_entities - 1; j >= 0; j--)\n     {\n       int e = entity_map[j];\n       int no_mode = num_modes[e];\n       struct bb_info *info = bb_info[j];\n+      rtx insn;\n \n       /* Determine what the first use (if any) need for a mode of entity E is.\n \t This will be the mode that is anticipatable for this block.\n@@ -529,16 +571,18 @@ optimize_mode_switching (void)\n \t  bool any_set_required = false;\n \t  HARD_REG_SET live_now;\n \n+\t  info[bb->index].mode_out = info[bb->index].mode_in = no_mode;\n+\n \t  REG_SET_TO_HARD_REG_SET (live_now, df_get_live_in (bb));\n \n \t  /* Pretend the mode is clobbered across abnormal edges.  */\n \t  {\n \t    edge_iterator ei;\n-\t    edge e;\n-\t    FOR_EACH_EDGE (e, ei, bb->preds)\n-\t      if (e->flags & EDGE_COMPLEX)\n+\t    edge eg;\n+\t    FOR_EACH_EDGE (eg, ei, bb->preds)\n+\t      if (eg->flags & EDGE_COMPLEX)\n \t\tbreak;\n-\t    if (e)\n+\t    if (eg)\n \t      {\n \t\trtx ins_pos = BB_HEAD (bb);\n \t\tif (LABEL_P (ins_pos))\n@@ -548,7 +592,8 @@ optimize_mode_switching (void)\n \t\t  ins_pos = NEXT_INSN (ins_pos);\n \t\tptr = new_seginfo (no_mode, ins_pos, bb->index, live_now);\n \t\tadd_seginfo (info + bb->index, ptr);\n-\t\tbitmap_clear_bit (transp[bb->index], j);\n+\t\tfor (i = 0; i < no_mode; i++)\n+\t\t  clear_mode_bit (transp[bb->index], j, i);\n \t      }\n \t  }\n \n@@ -565,11 +610,13 @@ optimize_mode_switching (void)\n \t\t      last_mode = mode;\n \t\t      ptr = new_seginfo (mode, insn, bb->index, live_now);\n \t\t      add_seginfo (info + bb->index, ptr);\n-\t\t      bitmap_clear_bit (transp[bb->index], j);\n+\t\t      for (i = 0; i < no_mode; i++)\n+\t\t\tclear_mode_bit (transp[bb->index], j, i);\n \t\t    }\n \n \t\t  if (targetm.mode_switching.after)\n-\t\t    last_mode = targetm.mode_switching.after (e, last_mode, insn);\n+\t\t    last_mode = targetm.mode_switching.after (e, last_mode,\n+\t\t\t\t\t\t\t      insn);\n \n \t\t  /* Update LIVE_NOW.  */\n \t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n@@ -593,13 +640,22 @@ optimize_mode_switching (void)\n \t      ptr = new_seginfo (no_mode, BB_END (bb), bb->index, live_now);\n \t      add_seginfo (info + bb->index, ptr);\n \t      if (last_mode != no_mode)\n-\t\tbitmap_clear_bit (transp[bb->index], j);\n+\t\tfor (i = 0; i < no_mode; i++)\n+\t\t  clear_mode_bit (transp[bb->index], j, i);\n \t    }\n \t}\n       if (targetm.mode_switching.entry && targetm.mode_switching.exit)\n \t{\n \t  int mode = targetm.mode_switching.entry (e);\n \n+\t  info[post_entry->index].mode_out =\n+\t    info[post_entry->index].mode_in = no_mode;\n+\t  if (pre_exit)\n+\t    {\n+\t      info[pre_exit->index].mode_out =\n+\t\tinfo[pre_exit->index].mode_in = no_mode;\n+\t    }\n+\n \t  if (mode != no_mode)\n \t    {\n \t      bb = post_entry;\n@@ -608,7 +664,8 @@ optimize_mode_switching (void)\n \t\t an extra check in make_preds_opaque.  We also\n \t\t need this to avoid confusing pre_edge_lcm when\n \t\t antic is cleared but transp and comp are set.  */\n-\t      bitmap_clear_bit (transp[bb->index], j);\n+\t      for (i = 0; i < no_mode; i++)\n+\t\tclear_mode_bit (transp[bb->index], j, i);\n \n \t      /* Insert a fake computing definition of MODE into entry\n \t\t blocks which compute no mode. This represents the mode on\n@@ -620,115 +677,109 @@ optimize_mode_switching (void)\n \t\t  targetm.mode_switching.exit (e);\n \t    }\n \t}\n-    }\n-\n-  kill = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_entities);\n-  for (i = 0; i < max_num_modes; i++)\n-    {\n-      int current_mode[N_ENTITIES];\n-      sbitmap *del;\n-      sbitmap *insert;\n \n       /* Set the anticipatable and computing arrays.  */\n-      bitmap_vector_clear (antic, last_basic_block_for_fn (cfun));\n-      bitmap_vector_clear (comp, last_basic_block_for_fn (cfun));\n-      for (j = n_entities - 1; j >= 0; j--)\n+      for (i = 0; i < no_mode; i++)\n \t{\n-\t  int m = current_mode[j] =\n-\t    targetm.mode_switching.priority (entity_map[j], i);\n-\t  struct bb_info *info = bb_info[j];\n+\t  int m = targetm.mode_switching.priority (entity_map[j], i);\n \n \t  FOR_EACH_BB_FN (bb, cfun)\n \t    {\n \t      if (info[bb->index].seginfo->mode == m)\n-\t\tbitmap_set_bit (antic[bb->index], j);\n+\t\tset_mode_bit (antic[bb->index], j, m);\n \n \t      if (info[bb->index].computing == m)\n-\t\tbitmap_set_bit (comp[bb->index], j);\n+\t\tset_mode_bit (comp[bb->index], j, m);\n \t    }\n \t}\n+    }\n \n-      /* Calculate the optimal locations for the\n-\t placement mode switches to modes with priority I.  */\n+  /* Calculate the optimal locations for the\n+     placement mode switches to modes with priority I.  */\n \n-      FOR_EACH_BB_FN (bb, cfun)\n-\tbitmap_not (kill[bb->index], transp[bb->index]);\n-      edge_list = pre_edge_lcm (n_entities, transp, comp, antic,\n-\t\t\t\tkill, &insert, &del);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    bitmap_not (kill[bb->index], transp[bb->index]);\n \n-      for (j = n_entities - 1; j >= 0; j--)\n-\t{\n-\t  /* Insert all mode sets that have been inserted by lcm.  */\n-\t  int no_mode = num_modes[entity_map[j]];\n-\n-\t  /* Wherever we have moved a mode setting upwards in the flow graph,\n-\t     the blocks between the new setting site and the now redundant\n-\t     computation ceases to be transparent for any lower-priority\n-\t     mode of the same entity.  First set the aux field of each\n-\t     insertion site edge non-transparent, then propagate the new\n-\t     non-transparency from the redundant computation upwards till\n-\t     we hit an insertion site or an already non-transparent block.  */\n-\t  for (e = NUM_EDGES (edge_list) - 1; e >= 0; e--)\n-\t    {\n-\t      edge eg = INDEX_EDGE (edge_list, e);\n-\t      int mode;\n-\t      basic_block src_bb;\n-\t      HARD_REG_SET live_at_edge;\n-\t      rtx mode_set;\n+  edge_list = pre_edge_lcm_avs (n_entities * max_num_modes, transp, comp, antic,\n+\t\t\t\tkill, avin, avout, &insert, &del);\n \n-\t      eg->aux = 0;\n-\n-\t      if (! bitmap_bit_p (insert[e], j))\n-\t\tcontinue;\n-\n-\t      eg->aux = (void *)1;\n+  for (j = n_entities - 1; j >= 0; j--)\n+    {\n+      int no_mode = num_modes[entity_map[j]];\n \n-\t      mode = current_mode[j];\n-\t      src_bb = eg->src;\n+      /* Insert all mode sets that have been inserted by lcm.  */\n \n-\t      REG_SET_TO_HARD_REG_SET (live_at_edge, df_get_live_out (src_bb));\n+      for (int ed = NUM_EDGES (edge_list) - 1; ed >= 0; ed--)\n+\t{\n+\t  edge eg = INDEX_EDGE (edge_list, ed);\n \n-\t      rtl_profile_for_edge (eg);\n-\t      start_sequence ();\n-\t      targetm.mode_switching.emit (entity_map[j], mode, live_at_edge);\n-\t      mode_set = get_insns ();\n-\t      end_sequence ();\n-\t      default_rtl_profile ();\n+\t  eg->aux = (void *)(intptr_t)-1;\n \n-\t      /* Do not bother to insert empty sequence.  */\n-\t      if (mode_set == NULL_RTX)\n-\t\tcontinue;\n+\t  for (i = 0; i < no_mode; i++)\n+\t    {\n+\t      int m = targetm.mode_switching.priority (entity_map[j], i);\n+\t      if (mode_bit_p (insert[ed], j, m))\n+\t\t{\n+\t\t  eg->aux = (void *)(intptr_t)m;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n \n-\t      /* We should not get an abnormal edge here.  */\n-\t      gcc_assert (! (eg->flags & EDGE_ABNORMAL));\n+      FOR_EACH_BB_FN (bb, cfun)\n+\t{\n+\t  struct bb_info *info = bb_info[j];\n+\t  int last_mode = no_mode;\n \n-\t      need_commit = 1;\n-\t      insert_insn_on_edge (mode_set, eg);\n-\t    }\n+\t  /* intialize mode in availability for bb.  */\n+\t  for (i = 0; i < no_mode; i++)\n+\t    if (mode_bit_p (avout[bb->index], j, i))\n+\t      {\n+\t\tif (last_mode == no_mode)\n+\t\t  last_mode = i;\n+\t\tif (last_mode != i)\n+\t\t  {\n+\t\t    last_mode = no_mode;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  info[bb->index].mode_out = last_mode;\n \n-\t  FOR_EACH_BB_REVERSE_FN (bb, cfun)\n-\t    if (bitmap_bit_p (del[bb->index], j))\n+\t  /* intialize mode out availability for bb.  */\n+\t  last_mode = no_mode;\n+\t  for (i = 0; i < no_mode; i++)\n+\t    if (mode_bit_p (avin[bb->index], j, i))\n \t      {\n-\t\tmake_preds_opaque (bb, j);\n-\t\t/* Cancel the 'deleted' mode set.  */\n-\t\tbb_info[j][bb->index].seginfo->mode = no_mode;\n+\t\tif (last_mode == no_mode)\n+\t\t  last_mode = i;\n+\t\tif (last_mode != i)\n+\t\t  {\n+\t\t    last_mode = no_mode;\n+\t\t    break;\n+\t\t  }\n \t      }\n+\t  info[bb->index].mode_in = last_mode;\n+\n+\t  for (i = 0; i < no_mode; i++)\n+\t    if (mode_bit_p (del[bb->index], j, i))\n+\t      info[bb->index].seginfo->mode = no_mode;\n \t}\n \n-      sbitmap_vector_free (del);\n-      sbitmap_vector_free (insert);\n-      clear_aux_for_edges ();\n-      free_edge_list (edge_list);\n-    }\n+      /* Now output the remaining mode sets in all the segments.  */\n \n-  /* Now output the remaining mode sets in all the segments.  */\n-  for (j = n_entities - 1; j >= 0; j--)\n-    {\n-      int no_mode = num_modes[entity_map[j]];\n+      /* In case there was no mode inserted. the mode information on the edge\n+\t might not be complete.\n+\t Update mode info on edges and commit pending mode sets.  */\n+      need_commit |= commit_mode_sets (edge_list, entity_map[j], bb_info[j]);\n+\n+      /* Reset modes for next entity.  */\n+      clear_aux_for_edges ();\n \n-      FOR_EACH_BB_REVERSE_FN (bb, cfun)\n+      FOR_EACH_BB_FN (bb, cfun)\n \t{\n \t  struct seginfo *ptr, *next;\n+\t  int cur_mode = bb_info[j][bb->index].mode_in;\n+\n \t  for (ptr = bb_info[j][bb->index].seginfo; ptr; ptr = next)\n \t    {\n \t      next = ptr->next;\n@@ -738,12 +789,15 @@ optimize_mode_switching (void)\n \n \t\t  rtl_profile_for_bb (bb);\n \t\t  start_sequence ();\n-\t\t  targetm.mode_switching.emit (entity_map[j],\n-\t\t\t\t\t       ptr->mode,\n-\t\t\t\t\t       ptr->regs_live);\n+\n+\t\t  targetm.mode_switching.emit (entity_map[j], ptr->mode,\n+\t\t\t\t\t       cur_mode, ptr->regs_live);\n \t\t  mode_set = get_insns ();\n \t\t  end_sequence ();\n \n+\t\t  /* modes kill each other inside a basic block.  */\n+\t\t  cur_mode = ptr->mode;\n+\n \t\t  /* Insert MODE_SET only if it is nonempty.  */\n \t\t  if (mode_set != NULL_RTX)\n \t\t    {\n@@ -772,11 +826,17 @@ optimize_mode_switching (void)\n       free (bb_info[j]);\n     }\n \n+  free_edge_list (edge_list);\n+\n   /* Finished. Free up all the things we've allocated.  */\n+  sbitmap_vector_free (del);\n+  sbitmap_vector_free (insert);\n   sbitmap_vector_free (kill);\n   sbitmap_vector_free (antic);\n   sbitmap_vector_free (transp);\n   sbitmap_vector_free (comp);\n+  sbitmap_vector_free (avin);\n+  sbitmap_vector_free (avout);\n \n   if (need_commit)\n     commit_edge_insertions ();"}, {"sha": "3a41db1a6df2bee0e3c918e640a7c05d525d25cb", "filename": "gcc/target.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -5365,12 +5365,12 @@ HOOK_VECTOR (TARGET_TOGGLE_, mode_switching)\n \n DEFHOOK\n (emit,\n- \"Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.\",\n- void, (int entity, int mode, HARD_REG_SET regs_live), NULL)\n+ \"Generate one or more insns to set @var{entity} to @var{mode}. @var{hard_reg_live} is the set of hard registers live at the point where the insn(s) are to be inserted. @var{prev_moxde} indicates the mode to switch from. Sets of a lower numbered entity will be emitted before sets of a higher numbered entity to a mode of the same or lower priority.\",\n+ void, (int entity, int mode, int prev_mode, HARD_REG_SET regs_live), NULL)\n \n DEFHOOK\n (needed,\n- \"@var{entity} is an integer specifying a mode-switched entity. If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.\",\n+ \"@var{entity} is an integer specifying a mode-switched entity.  If @code{OPTIMIZE_MODE_SWITCHING} is defined, you must define this macro to return an integer value not larger than the corresponding element in @code{NUM_MODES_FOR_MODE_SWITCHING}, to denote the mode that @var{entity} must be switched into prior to the execution of @var{insn}.\",\n  int, (int entity, rtx insn), NULL)\n \n DEFHOOK"}, {"sha": "9bea01cd91f2d41f906e16d669e8e4ab871620f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb1e3d98c5f18f82c1b733aa6338fab78fb891b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbb1e3d98c5f18f82c1b733aa6338fab78fb891b", "patch": "@@ -1,3 +1,7 @@\n+2014-07-02  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc.target/sh/fpchg.c: New test.\n+\n 2014-07-02  Jakub Jelinek  <jakub@redhat.com>\n \t    Fritz Reese  <Reese-Fritz@zai.com>\n "}]}