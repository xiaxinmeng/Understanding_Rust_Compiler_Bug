{"sha": "af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2NmY0ZjFiMDZmNWUwYzA5OWRmY2VkMmZjZjdiMWIyM2ZhNTNlNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-01-28T12:48:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-01-28T12:55:02Z"}, "message": "c++: header unit template alias merging [PR 98770]\n\nTypedefs are streamed by streaming the underlying type, and then\nrecreating the typedef.  But this breaks checking a duplicate is the\nsame as the original when it is a template alias -- we end up checking\na template alias (eg __void_t) against the underlying type (void).\nAnd those are not the same template alias.  This stops pretendig that\nthe underlying type is the typedef for that checking and tells\nis_matching_decl 'you have a typedef', so it knows what to do.  (We do\nnot want to recreate the typedef of the duplicate, because that whole\nset of nodes is going to go away.)\n\n\tPR c++/98770\n\tgcc/cp/\n\t* module.cc (trees_out::decl_value): Swap is_typedef & TYPE_NAME\n\tcheck order.\n\t(trees_in::decl_value): Do typedef frobbing only when installing\n\ta new typedef, adjust is_matching_decl call.  Swap is_typedef\n\t& TYPE_NAME check.\n\t(trees_in::is_matching_decl): Add is_typedef parm. Adjust variable\n\tnames and deal with typedef checking.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr98770_a.C: New.\n\t* g++.dg/modules/pr98770_b.C: New.", "tree": {"sha": "438fe5908263fa1ee477d4a322a3e74118bb6364", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438fe5908263fa1ee477d4a322a3e74118bb6364"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d61ca09ec9342ec5683a67a50b9bdd3dbdcd3624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d61ca09ec9342ec5683a67a50b9bdd3dbdcd3624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d61ca09ec9342ec5683a67a50b9bdd3dbdcd3624"}], "stats": {"total": 89, "additions": 58, "deletions": 31}, "files": [{"sha": "daf75b1600726adbf899c6afded65d4c90889e9b", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "patch": "@@ -3029,7 +3029,7 @@ class trees_in : public bytes_in {\n   bool read_definition (tree decl);\n   \n private:\n-  bool is_matching_decl (tree existing, tree decl);\n+  bool is_matching_decl (tree existing, tree decl, bool is_typedef);\n   static bool install_implicit_member (tree decl);\n   bool read_function_def (tree decl, tree maybe_template);\n   bool read_var_def (tree decl, tree maybe_template);\n@@ -7864,8 +7864,8 @@ trees_out::decl_value (tree decl, depset *dep)\n \t\t\t || !dep == (VAR_OR_FUNCTION_DECL_P (inner)\n \t\t\t\t     && DECL_LOCAL_DECL_P (inner)));\n   else if ((TREE_CODE (inner) == TYPE_DECL\n-\t    && TYPE_NAME (TREE_TYPE (inner)) == inner\n-\t    && !is_typedef)\n+\t    && !is_typedef\n+\t    && TYPE_NAME (TREE_TYPE (inner)) == inner)\n \t   || TREE_CODE (inner) == FUNCTION_DECL)\n     {\n       bool write_defn = !dep && has_definition (decl);\n@@ -8088,12 +8088,6 @@ trees_in::decl_value ()\n \t\t     && TREE_CODE (inner) == TYPE_DECL\n \t\t     && DECL_ORIGINAL_TYPE (inner)\n \t\t     && !TREE_TYPE (inner));\n-  if (is_typedef)\n-    {\n-      /* Frob it to be ready for cloning.  */\n-      TREE_TYPE (inner) = DECL_ORIGINAL_TYPE (inner);\n-      DECL_ORIGINAL_TYPE (inner) = NULL_TREE;\n-    }\n \n   existing = back_refs[~tag];\n   bool installed = install_entity (existing);\n@@ -8156,7 +8150,12 @@ trees_in::decl_value ()\n \t}\n \n       if (is_typedef)\n-\tset_underlying_type (inner);\n+\t{\n+\t  /* Frob it to be ready for cloning.  */\n+\t  TREE_TYPE (inner) = DECL_ORIGINAL_TYPE (inner);\n+\t  DECL_ORIGINAL_TYPE (inner) = NULL_TREE;\n+\t  set_underlying_type (inner);\n+\t}\n \n       if (inner_tag)\n \t/* Set the TEMPLATE_DECL's type.  */\n@@ -8218,7 +8217,7 @@ trees_in::decl_value ()\n \t/* Set the TEMPLATE_DECL's type.  */\n \tTREE_TYPE (decl) = TREE_TYPE (inner);\n \n-      if (!is_matching_decl (existing, decl))\n+      if (!is_matching_decl (existing, decl, is_typedef))\n \tunmatched_duplicate (existing);\n \n       /* And our result is the existing node.  */\n@@ -8257,8 +8256,8 @@ trees_in::decl_value ()\n   if (inner\n       && !NAMESPACE_SCOPE_P (inner)\n       && ((TREE_CODE (inner) == TYPE_DECL\n-\t   && TYPE_NAME (TREE_TYPE (inner)) == inner\n-\t   && !is_typedef)\n+\t   && !is_typedef\n+\t   && TYPE_NAME (TREE_TYPE (inner)) == inner)\n \t  || TREE_CODE (inner) == FUNCTION_DECL)\n       && u ())\n     read_definition (decl);\n@@ -11088,7 +11087,7 @@ trees_in::binfo_mergeable (tree *type)\n    decls_match because it can cause instantiations of constraints.  */\n \n bool\n-trees_in::is_matching_decl (tree existing, tree decl)\n+trees_in::is_matching_decl (tree existing, tree decl, bool is_typedef)\n {\n   // FIXME: We should probably do some duplicate decl-like stuff here\n   // (beware, default parms should be the same?)  Can we just call\n@@ -11099,35 +11098,36 @@ trees_in::is_matching_decl (tree existing, tree decl)\n   // can elide some of the checking\n   gcc_checking_assert (TREE_CODE (existing) == TREE_CODE (decl));\n \n-  tree inner = decl;\n+  tree d_inner = decl;\n+  tree e_inner = existing;\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     {\n-      inner = DECL_TEMPLATE_RESULT (decl);\n-      gcc_checking_assert (TREE_CODE (DECL_TEMPLATE_RESULT (existing))\n-\t\t\t   == TREE_CODE (inner));\n+      d_inner = DECL_TEMPLATE_RESULT (d_inner);\n+      e_inner = DECL_TEMPLATE_RESULT (e_inner);\n+      gcc_checking_assert (TREE_CODE (e_inner) == TREE_CODE (d_inner));\n     }\n \n   gcc_checking_assert (!map_context_from);\n   /* This mapping requres the new decl on the lhs and the existing\n      entity on the rhs of the comparitors below.  */\n-  map_context_from = inner;\n-  map_context_to = STRIP_TEMPLATE (existing);\n+  map_context_from = d_inner;\n+  map_context_to = e_inner;\n \n-  if (TREE_CODE (inner) == FUNCTION_DECL)\n+  if (TREE_CODE (d_inner) == FUNCTION_DECL)\n     {\n       tree e_ret = fndecl_declared_return_type (existing);\n       tree d_ret = fndecl_declared_return_type (decl);\n \n-      if (decl != inner && DECL_NAME (inner) == fun_identifier\n-\t  && LAMBDA_TYPE_P (DECL_CONTEXT (inner)))\n+      if (decl != d_inner && DECL_NAME (d_inner) == fun_identifier\n+\t  && LAMBDA_TYPE_P (DECL_CONTEXT (d_inner)))\n \t/* This has a recursive type that will compare different.  */;\n       else if (!same_type_p (d_ret, e_ret))\n \tgoto mismatch;\n \n-      tree e_type = TREE_TYPE (existing);\n-      tree d_type = TREE_TYPE (decl);\n+      tree e_type = TREE_TYPE (e_inner);\n+      tree d_type = TREE_TYPE (d_inner);\n \n-      if (DECL_EXTERN_C_P (decl) != DECL_EXTERN_C_P (existing))\n+      if (DECL_EXTERN_C_P (d_inner) != DECL_EXTERN_C_P (e_inner))\n \tgoto mismatch;\n \n       for (tree e_args = TYPE_ARG_TYPES (e_type),\n@@ -11176,6 +11176,13 @@ trees_in::is_matching_decl (tree existing, tree decl)\n \t       && !comp_except_specs (d_spec, e_spec, ce_type))\n \tgoto mismatch;\n     }\n+  else if (is_typedef)\n+    {\n+      if (!DECL_ORIGINAL_TYPE (e_inner)\n+\t  || !same_type_p (DECL_ORIGINAL_TYPE (d_inner),\n+\t\t\t   DECL_ORIGINAL_TYPE (e_inner)))\n+\tgoto mismatch;\n+    }\n   /* Using cp_tree_equal because we can meet TYPE_ARGUMENT_PACKs\n      here. I suspect the entities that directly do that are things\n      that shouldn't go to duplicate_decls (FIELD_DECLs etc).   */\n@@ -11255,12 +11262,10 @@ trees_in::is_matching_decl (tree existing, tree decl)\n     /* Don't instantiate again!  */\n     DECL_TEMPLATE_INSTANTIATED (existing) = true;\n \n-  tree e_inner = inner == decl ? existing : DECL_TEMPLATE_RESULT (existing);\n-\n-  if (TREE_CODE (inner) == FUNCTION_DECL\n-      && DECL_DECLARED_INLINE_P (inner))\n+  if (TREE_CODE (d_inner) == FUNCTION_DECL\n+      && DECL_DECLARED_INLINE_P (d_inner))\n     DECL_DECLARED_INLINE_P (e_inner) = true;\n-  if (!DECL_EXTERNAL (inner))\n+  if (!DECL_EXTERNAL (d_inner))\n     DECL_EXTERNAL (e_inner) = false;\n \n   // FIXME: Check default tmpl and fn parms here"}, {"sha": "668ff2891ca416d3597488532097b0eb41551204", "filename": "gcc/testsuite/g++.dg/modules/pr98770_a.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98770_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98770_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98770_a.C?ref=af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "patch": "@@ -0,0 +1,10 @@\n+// PR 98770 confused about duplicate template type aliases\n+// { dg-additional-options \"-fmodules-ts -Wno-pedantic\" }\n+\n+module ;\n+# 6 __FILE__ 1\n+template<typename> using __void_t = void;\n+# 8 \"\" 2\n+export module Foo;\n+\n+export using B = __void_t<int>;"}, {"sha": "a4ab2376815d025db28b1579b455bc5090d11e39", "filename": "gcc/testsuite/g++.dg/modules/pr98770_b.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98770_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98770_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98770_b.C?ref=af66f4f1b06f5e0c099dfced2fcf7b1b23fa53e7", "patch": "@@ -0,0 +1,12 @@\n+// PR 98770 confused about duplicate template type aliases\n+// { dg-additional-options \"-fmodules-ts -Wno-pedantic\" }\n+\n+module ;\n+# 6 __FILE__ 1\n+template<typename> using __void_t = void;\n+# 8 \"\" 2\n+export module Bar;\n+\n+import Foo;\n+\n+export B *b;"}]}