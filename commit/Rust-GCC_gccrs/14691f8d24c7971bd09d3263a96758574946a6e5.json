{"sha": "14691f8d24c7971bd09d3263a96758574946a6e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ2OTFmOGQyNGM3OTcxYmQwOWQzMjYzYTk2NzU4NTc0OTQ2YTZlNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-04T17:44:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-04T17:44:26Z"}, "message": "alpha.c (current_function_is_thunk): Don't check current_function_is_thunk.\n\n        * config/alpha/alpha.c (current_function_is_thunk): Don't check\n        current_function_is_thunk.\n        (alpha_sa_mask): Distinguish between current_function_is_thunk\n        called from ASM_OUTPUT_MI_THUNK and not.\n        (alpha_does_function_need_gp): Thunks always need gp.\n        (alpha_start_function, alpha_output_function_end_prologue): Likewise.\n        (alpha_output_mi_thunk_osf): New.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/alpha.h (ASM_OUTPUT_MI_THUNK): New.\n\ncp/\n        * method.c (use_thunk): Always initialize the block tree.  Reindent.\n        * semantics.c (expand_body): Emit thunks after function, not before.\n\nFrom-SVN: r49484", "tree": {"sha": "00e69406554780de155cc3cfc05ce57cf2a19f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00e69406554780de155cc3cfc05ce57cf2a19f1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14691f8d24c7971bd09d3263a96758574946a6e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14691f8d24c7971bd09d3263a96758574946a6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14691f8d24c7971bd09d3263a96758574946a6e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14691f8d24c7971bd09d3263a96758574946a6e5/comments", "author": null, "committer": null, "parents": [{"sha": "8d9d2e1df75bbf81c68ea846d27dbfb53a309488", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9d2e1df75bbf81c68ea846d27dbfb53a309488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9d2e1df75bbf81c68ea846d27dbfb53a309488"}], "stats": {"total": 342, "additions": 220, "deletions": 122}, "files": [{"sha": "919a4081be80d5af355977f881fad046ebdc43bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -1,3 +1,15 @@\n+2002-02-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (current_function_is_thunk): Don't check\n+\tcurrent_function_is_thunk.\n+\t(alpha_sa_mask): Distinguish between current_function_is_thunk\n+\tcalled from ASM_OUTPUT_MI_THUNK and not.\n+\t(alpha_does_function_need_gp): Thunks always need gp.\n+\t(alpha_start_function, alpha_output_function_end_prologue): Likewise.\n+\t(alpha_output_mi_thunk_osf): New.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.h (ASM_OUTPUT_MI_THUNK): New.\n+\n 2002-02-04  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* c-typeck.c (build_c_cast): Warn when qualifiers are added to"}, {"sha": "957e5d9c7730d15435ec3fdefe86c05606438559", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -163,6 +163,8 @@ extern rtx function_arg PARAMS ((CUMULATIVE_ARGS, enum machine_mode,\n #endif\n extern void alpha_start_function PARAMS ((FILE *, const char *, tree));\n extern void alpha_end_function PARAMS ((FILE *, const char *, tree));\n+extern void alpha_output_mi_thunk_osf PARAMS ((FILE *, tree,\n+\t\t\t\t\t       HOST_WIDE_INT, tree));\n extern void alpha_encode_section_info PARAMS ((tree));\n #endif /* TREE CODE */\n "}, {"sha": "9897077664fd025e7ebd5d335ad89c5e65da885f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 114, "deletions": 41, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"debug.h\"\n \n /* External data.  */\n extern int rtx_equal_function_value_matters;\n@@ -4993,10 +4994,6 @@ alpha_ra_ever_killed ()\n {\n   rtx top;\n \n-#ifdef ASM_OUTPUT_MI_THUNK\n-  if (current_function_is_thunk)\n-    return 0;\n-#endif\n   if (!has_hard_reg_initial_val (Pmode, REG_RA))\n     return regs_ever_live[REG_RA];\n \n@@ -5859,43 +5856,48 @@ alpha_sa_mask (imaskP, fmaskP)\n   unsigned long fmask = 0;\n   unsigned int i;\n \n-#ifdef ASM_OUTPUT_MI_THUNK\n-  if (!current_function_is_thunk)\n-#endif\n+  /* Irritatingly, there are two kinds of thunks -- those created with\n+     ASM_OUTPUT_MI_THUNK and those with DECL_THUNK_P that go through\n+     the regular part of the compiler.  In the ASM_OUTPUT_MI_THUNK case\n+     we don't have valid register life info, but assemble_start_function\n+     wants to output .frame and .mask directives.  */\n+  if (current_function_is_thunk && rtx_equal_function_value_matters)\n     {\n-      if (TARGET_ABI_OPEN_VMS && alpha_is_stack_procedure)\n-\timask |= (1L << HARD_FRAME_POINTER_REGNUM);\n+      *imaskP = 0;\n+      *fmaskP = 0;\n+      return;\n+    }\n \n-      /* One for every register we have to save.  */\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (! fixed_regs[i] && ! call_used_regs[i]\n-\t    && regs_ever_live[i] && i != REG_RA\n-\t    && (!TARGET_ABI_UNICOSMK || i != HARD_FRAME_POINTER_REGNUM))\n-\t  {\n-\t    if (i < 32)\n-\t      imask |= (1L << i);\n-\t    else\n-\t      fmask |= (1L << (i - 32));\n-\t  }\n+  if (TARGET_ABI_OPEN_VMS && alpha_is_stack_procedure)\n+    imask |= (1L << HARD_FRAME_POINTER_REGNUM);\n \n-      /* We need to restore these for the handler.  */\n-      if (current_function_calls_eh_return)\n-\t{\n-\t  for (i = 0; ; ++i)\n-\t    {\n-\t      unsigned regno = EH_RETURN_DATA_REGNO (i);\n-\t      if (regno == INVALID_REGNUM)\n-\t\tbreak;\n-\t      imask |= 1L << regno;\n-\t    }\n-\t}\n+  /* One for every register we have to save.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t&& regs_ever_live[i] && i != REG_RA\n+\t&& (!TARGET_ABI_UNICOSMK || i != HARD_FRAME_POINTER_REGNUM))\n+      {\n+\tif (i < 32)\n+\t  imask |= (1L << i);\n+\telse\n+\t  fmask |= (1L << (i - 32));\n+      }\n+\n+  /* We need to restore these for the handler.  */\n+  if (current_function_calls_eh_return)\n+    for (i = 0; ; ++i)\n+      {\n+\tunsigned regno = EH_RETURN_DATA_REGNO (i);\n+\tif (regno == INVALID_REGNUM)\n+\t  break;\n+\timask |= 1L << regno;\n+      }\n      \n-      /* If any register spilled, then spill the return address also.  */\n-      /* ??? This is required by the Digital stack unwind specification\n-\t and isn't needed if we're doing Dwarf2 unwinding.  */\n-      if (imask || fmask || alpha_ra_ever_killed ())\n-\timask |= (1L << REG_RA);\n-    }\n+  /* If any register spilled, then spill the return address also.  */\n+  /* ??? This is required by the Digital stack unwind specification\n+     and isn't needed if we're doing Dwarf2 unwinding.  */\n+  if (imask || fmask || alpha_ra_ever_killed ())\n+    imask |= (1L << REG_RA);\n \n   *imaskP = imask;\n   *fmaskP = fmask;\n@@ -6043,10 +6045,8 @@ alpha_does_function_need_gp ()\n   if (TARGET_PROFILING_NEEDS_GP && current_function_profile)\n     return 1;\n \n-#ifdef ASM_OUTPUT_MI_THUNK\n   if (current_function_is_thunk)\n     return 1;\n-#endif\n \n   /* If we need a GP (we have a LDSYM insn or a CALL_INSN), load it first. \n      Even if we are a static function, we still need to do this in case\n@@ -6512,7 +6512,9 @@ alpha_start_function (file, fnname, decl)\n \n       /* If the function needs GP, we'll write the \"..ng\" label there.\n \t Otherwise, do it here.  */\n-      if (TARGET_ABI_OSF && ! alpha_function_needs_gp)\n+      if (TARGET_ABI_OSF\n+          && ! alpha_function_needs_gp\n+\t  && ! current_function_is_thunk)\n \t{\n \t  putc ('$', file);\n \t  assemble_name (file, fnname);\n@@ -6646,7 +6648,8 @@ alpha_output_function_end_prologue (file)\n   else if (TARGET_ABI_WINDOWS_NT)\n     fputs (\"\\t.prologue 0\\n\", file);\n   else if (!flag_inhibit_size_directive)\n-    fprintf (file, \"\\t.prologue %d\\n\", alpha_function_needs_gp);\n+    fprintf (file, \"\\t.prologue %d\\n\",\n+\t     alpha_function_needs_gp || current_function_is_thunk);\n }\n \n /* Write function epilogue.  */\n@@ -6946,6 +6949,76 @@ alpha_end_function (file, fnname, decl)\n       unicosmk_output_deferred_case_vectors (file);\n     }\n }\n+\n+/* Emit a tail call to FUNCTION after adjusting THIS by DELTA. \n+\n+   In order to avoid the hordes of differences between generated code\n+   with and without TARGET_EXPLICIT_RELOCS, and to avoid duplicating\n+   lots of code loading up large constants, generate rtl and emit it\n+   instead of going straight to text.\n+\n+   Not sure why this idea hasn't been explored before...  */\n+\n+void\n+alpha_output_mi_thunk_osf (file, thunk_fndecl, delta, function)\n+     FILE *file;\n+     tree thunk_fndecl ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT delta;\n+     tree function;\n+{\n+  HOST_WIDE_INT hi, lo;\n+  rtx this, insn, funexp;\n+\n+  /* We always require a valid GP.  */\n+  emit_insn (gen_prologue_ldgp ());\n+  emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n+\n+  /* Find the \"this\" pointer.  If the function returns a structure,\n+     the structure return pointer is in $16.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+    this = gen_rtx_REG (Pmode, 17);\n+  else\n+    this = gen_rtx_REG (Pmode, 16);\n+\n+  /* Add DELTA.  When possible we use ldah+lda.  Otherwise load the\n+     entire constant for the add.  */\n+  lo = ((delta & 0xffff) ^ 0x8000) - 0x8000;\n+  hi = (((delta - lo) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+  if (hi + lo == delta)\n+    {\n+      if (hi)\n+\temit_insn (gen_adddi3 (this, this, GEN_INT (hi)));\n+      if (lo)\n+\temit_insn (gen_adddi3 (this, this, GEN_INT (lo)));\n+    }\n+  else\n+    {\n+      rtx tmp = alpha_emit_set_long_const (gen_rtx_REG (Pmode, 0),\n+\t\t\t\t\t   delta, -(delta < 0));\n+      emit_insn (gen_adddi3 (this, this, tmp));\n+    }\n+\n+  /* Generate a tail call to the target function.  */\n+  if (! TREE_USED (function))\n+    {\n+      assemble_external (function);\n+      TREE_USED (function) = 1;\n+    }\n+  funexp = XEXP (DECL_RTL (function), 0);\n+  funexp = gen_rtx_MEM (FUNCTION_MODE, funexp);\n+  insn = emit_call_insn (gen_sibcall (funexp, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Run just enough of rest_of_compilation to get the insns emitted.\n+     There's not really enough bulk here to make other passes such as\n+     instruction scheduling worth while.  Note that use_thunk calls\n+     assemble_start_function and assemble_end_function.  */\n+  insn = get_insns ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1, 0);\n+  final_end_function ();\n+}\n \f\n /* Debugging support.  */\n "}, {"sha": "99ef24ea9769681aeba3b846883bab533ac7d1c3", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -2236,3 +2236,8 @@ do {\t\t\t\t\t\t\t\\\n \n /* Generate calls to memcpy, etc., not bcopy, etc.  */\n #define TARGET_MEM_FUNCTIONS 1\n+\n+/* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n+   Used for C++ multiple inheritance.  */\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION) \\\n+  alpha_output_mi_thunk_osf (FILE, THUNK_FNDECL, DELTA, FUNCTION)"}, {"sha": "dfb3d4bdda296864004f4e390c0ebc88ea64e5ce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -1,3 +1,8 @@\n+2002-02-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* method.c (use_thunk): Always initialize the block tree.  Reindent.\n+\t* semantics.c (expand_body): Emit thunks after function, not before.\n+\n 2002-02-04  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (start_function): Call cplus_decl_attributes immediately"}, {"sha": "52a6a8cf59d1b618e3cfd0ee3393eb3d5edc1b39", "filename": "gcc/cp/method.c", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -392,6 +392,12 @@ use_thunk (thunk_fndecl, emit_p)\n \n   push_to_top_level ();\n \n+  /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n+     create one.  */\n+  DECL_INITIAL (thunk_fndecl) = make_node (BLOCK);\n+  BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) \n+    = DECL_ARGUMENTS (thunk_fndecl);\n+\n #ifdef ASM_OUTPUT_MI_THUNK\n   if (!vcall_offset)\n     {\n@@ -411,88 +417,83 @@ use_thunk (thunk_fndecl, emit_p)\n     }\n   else\n #endif /* ASM_OUTPUT_MI_THUNK */\n-  {\n-  /* If we don't have the necessary macro for efficient thunks, generate a\n-     thunk function that just makes a call to the real function.\n-     Unfortunately, this doesn't work for varargs.  */\n-\n-    tree a, t;\n-\n-    if (varargs_function_p (function))\n-      error (\"generic thunk code fails for method `%#D' which uses `...'\",\n-\t\tfunction);\n-\n-    /* Set up clone argument trees for the thunk.  */\n-    t = NULL_TREE;\n-    for (a = DECL_ARGUMENTS (function); a; a = TREE_CHAIN (a))\n-      {\n-\ttree x = copy_node (a);\n-\tTREE_CHAIN (x) = t;\n-\tDECL_CONTEXT (x) = thunk_fndecl;\n-\tt = x;\n-      }\n-    a = nreverse (t);\n-    DECL_ARGUMENTS (thunk_fndecl) = a;\n-    DECL_RESULT (thunk_fndecl) = NULL_TREE;\n-\n-    start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n-    /* We don't bother with a body block for thunks.  */\n-\n-    /* Adjust the this pointer by the constant.  */\n-    t = ssize_int (delta);\n-    t = fold (build (PLUS_EXPR, TREE_TYPE (a), a, t));\n-    /* If there's a vcall offset, look up that value in the vtable and\n-       adjust the `this' pointer again.  */\n-    if (vcall_offset && !integer_zerop (vcall_offset))\n-      {\n-\ttree orig_this;\n-\n-\tt = save_expr (t);\n-\torig_this = t;\n-\t/* The vptr is always at offset zero in the object.  */\n-\tt = build1 (NOP_EXPR,\n-\t\t    build_pointer_type (build_pointer_type \n-\t\t\t\t\t(vtable_entry_type)),\n-\t\t    t);\n-\t/* Form the vtable address.  */\n-\tt = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n-\t/* Find the entry with the vcall offset.  */\n-\tt = build (PLUS_EXPR, TREE_TYPE (t), t, vcall_offset);\n-\t/* Calculate the offset itself.  */\n-\tt = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n-\t/* Adjust the `this' pointer.  */\n-\tt = fold (build (PLUS_EXPR,\n-\t\t\t TREE_TYPE (orig_this),\n-\t\t\t orig_this,\n-\t\t\t t));\n-      }\n-\n-    /* Build up the call to the real function.  */\n-    t = tree_cons (NULL_TREE, t, NULL_TREE);\n-    for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n-      t = tree_cons (NULL_TREE, a, t);\n-    t = nreverse (t);\n-    t = build_call (function, t);\n-    if (VOID_TYPE_P (TREE_TYPE (t)))\n-      finish_expr_stmt (t);\n-    else\n-      finish_return_stmt (t);\n+    {\n+      /* If we don't have the necessary macro for efficient thunks, generate\n+\t a thunk function that just makes a call to the real function.\n+\t Unfortunately, this doesn't work for varargs.  */\n \n-    /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n-       create one.  */\n-    DECL_INITIAL (thunk_fndecl) = make_node (BLOCK);\n-    BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) \n-      = DECL_ARGUMENTS (thunk_fndecl);\n+      tree a, t;\n \n-    /* Since we want to emit the thunk, we explicitly mark its name as\n-       referenced.  */\n-    TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (thunk_fndecl)) = 1;\n+      if (varargs_function_p (function))\n+\terror (\"generic thunk code fails for method `%#D' which uses `...'\",\n+\t       function);\n \n-    /* But we don't want debugging information about it.  */\n-    DECL_IGNORED_P (thunk_fndecl) = 1;\n+      /* Set up clone argument trees for the thunk.  */\n+      t = NULL_TREE;\n+      for (a = DECL_ARGUMENTS (function); a; a = TREE_CHAIN (a))\n+\t{\n+\t  tree x = copy_node (a);\n+\t  TREE_CHAIN (x) = t;\n+\t  DECL_CONTEXT (x) = thunk_fndecl;\n+\t  t = x;\n+\t}\n+      a = nreverse (t);\n+      DECL_ARGUMENTS (thunk_fndecl) = a;\n+      DECL_RESULT (thunk_fndecl) = NULL_TREE;\n \n-    expand_body (finish_function (0));\n-  }\n+      start_function (NULL_TREE, thunk_fndecl, NULL_TREE, SF_PRE_PARSED);\n+      /* We don't bother with a body block for thunks.  */\n+\n+      /* Adjust the this pointer by the constant.  */\n+      t = ssize_int (delta);\n+      t = fold (build (PLUS_EXPR, TREE_TYPE (a), a, t));\n+\n+      /* If there's a vcall offset, look up that value in the vtable and\n+\t adjust the `this' pointer again.  */\n+      if (vcall_offset && !integer_zerop (vcall_offset))\n+\t{\n+\t  tree orig_this;\n+\n+\t  t = save_expr (t);\n+\t  orig_this = t;\n+\t  /* The vptr is always at offset zero in the object.  */\n+\t  t = build1 (NOP_EXPR,\n+\t\t      build_pointer_type (build_pointer_type \n+\t\t\t\t\t  (vtable_entry_type)),\n+\t\t      t);\n+\t  /* Form the vtable address.  */\n+\t  t = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n+\t  /* Find the entry with the vcall offset.  */\n+\t  t = build (PLUS_EXPR, TREE_TYPE (t), t, vcall_offset);\n+\t  /* Calculate the offset itself.  */\n+\t  t = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n+\t  /* Adjust the `this' pointer.  */\n+\t  t = fold (build (PLUS_EXPR,\n+\t\t\t   TREE_TYPE (orig_this),\n+\t\t\t   orig_this,\n+\t\t\t   t));\n+\t}\n+\n+      /* Build up the call to the real function.  */\n+      t = tree_cons (NULL_TREE, t, NULL_TREE);\n+      for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n+\tt = tree_cons (NULL_TREE, a, t);\n+      t = nreverse (t);\n+      t = build_call (function, t);\n+      if (VOID_TYPE_P (TREE_TYPE (t)))\n+\tfinish_expr_stmt (t);\n+      else\n+\tfinish_return_stmt (t);\n+\n+      /* Since we want to emit the thunk, we explicitly mark its name as\n+\t referenced.  */\n+      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (thunk_fndecl)) = 1;\n+\n+      /* But we don't want debugging information about it.  */\n+      DECL_IGNORED_P (thunk_fndecl) = 1;\n+\n+      expand_body (finish_function (0));\n+    }\n \n   pop_from_top_level ();\n }"}, {"sha": "cdc1178f338c40dd70d7feab2c8a6c306942b317", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14691f8d24c7971bd09d3263a96758574946a6e5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=14691f8d24c7971bd09d3263a96758574946a6e5", "patch": "@@ -2397,9 +2397,6 @@ expand_body (fn)\n   if (DECL_EXTERNAL (fn))\n     return;\n \n-  /* Emit any thunks that should be emitted at the same time as FN.  */\n-  emit_associated_thunks (fn);\n-\n   timevar_push (TV_INTEGRATION);\n \n   /* Optimize the body of the function before expanding it.  */\n@@ -2452,6 +2449,9 @@ expand_body (fn)\n   extract_interface_info ();\n \n   timevar_pop (TV_EXPAND);\n+\n+  /* Emit any thunks that should be emitted at the same time as FN.  */\n+  emit_associated_thunks (fn);\n }\n \n /* Helper function for walk_tree, used by finish_function to override all"}]}