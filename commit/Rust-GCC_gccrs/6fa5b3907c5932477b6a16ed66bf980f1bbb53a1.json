{"sha": "6fa5b3907c5932477b6a16ed66bf980f1bbb53a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhNWIzOTA3YzU5MzI0NzdiNmExNmVkNjZiZjk4MGYxYmJiNTNhMQ==", "commit": {"author": {"name": "Mark Dettinger", "email": "dettinge@de.ibm.com", "date": "2005-01-22T21:57:56Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-01-22T21:57:56Z"}, "message": "s390.c (struct processor_costs): New fields dlgr, dlr, dr, dsgfr, dsgr.\n\n2005-01-21  Mark Dettinger  <dettinge@de.ibm.com>\n\n\t* config/s390/s390.c (struct processor_costs): New fields\n\tdlgr, dlr, dr, dsgfr, dsgr.\n\t(z900_cost, z990_cost): Values for new fields.\n\t(s390_rtx_costs): New cases MEM und COMPARE in switch\n\tstatement. Modified handling of SIGN_EXTEND, ZERO_EXTEND,\n\tDIV, MOD, UDIV, UMOD.\n\nFrom-SVN: r94079", "tree": {"sha": "ff0a2d2402dd36ff35a9519af4c4d960890dc3da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff0a2d2402dd36ff35a9519af4c4d960890dc3da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1/comments", "author": null, "committer": null, "parents": [{"sha": "eb862a88ba7046dbeea77ce41f6cc90f1b436412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb862a88ba7046dbeea77ce41f6cc90f1b436412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb862a88ba7046dbeea77ce41f6cc90f1b436412"}], "stats": {"total": 88, "additions": 78, "deletions": 10}, "files": [{"sha": "3206c938f61d2bf3a63c5461d52fd56d3d8c2a92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fa5b3907c5932477b6a16ed66bf980f1bbb53a1", "patch": "@@ -1,3 +1,12 @@\n+2005-01-21  Mark Dettinger  <dettinge@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct processor_costs): New fields \n+\tdlgr, dlr, dr, dsgfr, dsgr.\n+\t(z900_cost, z990_cost): Values for new fields.\n+\t(s390_rtx_costs): New cases MEM und COMPARE in switch\n+\tstatement. Modified handling of SIGN_EXTEND, ZERO_EXTEND,\n+\tDIV, MOD, UDIV, UMOD.\n+\n 2005-01-21  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.md (\"doloop_si64\"): Reload input value directly"}, {"sha": "41faff324a76d4e2e6849b4bf65bf662fb5fe401", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa5b3907c5932477b6a16ed66bf980f1bbb53a1/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6fa5b3907c5932477b6a16ed66bf980f1bbb53a1", "patch": "@@ -115,6 +115,11 @@ struct processor_costs\n   const int ddr;\n   const int debr;\n   const int der;\n+  const int dlgr;\n+  const int dlr;\n+  const int dr;\n+  const int dsgfr;\n+  const int dsgr;\n };\n \n const struct processor_costs *s390_cost;\n@@ -143,6 +148,11 @@ struct processor_costs z900_cost =\n   COSTS_N_INSNS (30),    /* DDR  */\n   COSTS_N_INSNS (27),    /* DEBR */\n   COSTS_N_INSNS (26),    /* DER  */\n+  COSTS_N_INSNS (220),   /* DLGR */\n+  COSTS_N_INSNS (34),    /* DLR */\n+  COSTS_N_INSNS (34),    /* DR */\n+  COSTS_N_INSNS (32),    /* DSGFR */\n+  COSTS_N_INSNS (32),    /* DSGR */\n };\n \n static const\n@@ -169,6 +179,11 @@ struct processor_costs z990_cost =\n   COSTS_N_INSNS (44),    /* DDR  */\n   COSTS_N_INSNS (26),    /* DDBR */\n   COSTS_N_INSNS (28),    /* DER  */\n+  COSTS_N_INSNS (176),   /* DLGR */\n+  COSTS_N_INSNS (31),    /* DLR */\n+  COSTS_N_INSNS (31),    /* DR */\n+  COSTS_N_INSNS (31),    /* DSGFR */\n+  COSTS_N_INSNS (31),    /* DSGR */\n };\n \n \n@@ -1906,6 +1921,7 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST_DOUBLE:\n+    case MEM:\n       *total = 0;\n       return true;\n \n@@ -1998,8 +2014,38 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t}\n       return false;\n \n+    case UDIV:\n+    case UMOD:\n+      if (GET_MODE (x) == TImode) \t       /* 128 bit division */\n+\t*total = s390_cost->dlgr;\n+      else if (GET_MODE (x) == DImode)\n+\t{\n+\t  rtx right = XEXP (x, 1);\n+\t  if (GET_CODE (right) == ZERO_EXTEND) /* 64 by 32 bit division */\n+\t    *total = s390_cost->dlr;\n+\t  else \t                               /* 64 by 64 bit division */\n+\t    *total = s390_cost->dlgr;\n+\t}\n+      else if (GET_MODE (x) == SImode)         /* 32 bit division */\n+\t*total = s390_cost->dlr;\n+      return false;\n+\n     case DIV:\n-      if (GET_MODE (x) == SFmode)\n+    case MOD:\n+      if (GET_MODE (x) == DImode)\n+\t{\n+\t  rtx right = XEXP (x, 1);\n+\t  if (GET_CODE (right) == ZERO_EXTEND) /* 64 by 32 bit division */\n+\t    if (TARGET_64BIT)\n+\t      *total = s390_cost->dsgfr;\n+\t    else\n+\t      *total = s390_cost->dr;\n+\t  else \t                               /* 64 by 64 bit division */\n+\t    *total = s390_cost->dsgr;\n+\t}\n+      else if (GET_MODE (x) == SImode)         /* 32 bit division */\n+\t*total = s390_cost->dlr;\n+      else if (GET_MODE (x) == SFmode)\n \t{\n \t  if (TARGET_IEEE_FLOAT)\n \t    *total = s390_cost->debr;\n@@ -2013,14 +2059,6 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  else /* TARGET_IBM_FLOAT */\n \t    *total = s390_cost->ddr;\n \t}\n-      else\n-\t*total = COSTS_N_INSNS (33);\n-      return false;\n-\n-    case UDIV:\n-    case MOD:\n-    case UMOD:\n-      *total = COSTS_N_INSNS (33);\n       return false;\n \n     case SQRT:\n@@ -2032,10 +2070,31 @@ s390_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      if (outer_code == MULT)\n+      if (outer_code == MULT || outer_code == DIV || outer_code == MOD\n+\t  || outer_code == PLUS || outer_code == MINUS\n+\t  || outer_code == COMPARE)\n \t*total = 0;\n       return false;\n \n+    case COMPARE:\n+      *total = COSTS_N_INSNS (1);\n+      if (GET_CODE (XEXP (x, 0)) == AND\n+\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\t{\n+\t  rtx op0 = XEXP (XEXP (x, 0), 0);\n+\t  rtx op1 = XEXP (XEXP (x, 0), 1);\n+\t  rtx op2 = XEXP (x, 1);\n+\n+\t  if (memory_operand (op0, GET_MODE (op0))\n+\t      && s390_tm_ccmode (op1, op2, 0) != VOIDmode)\n+\t    return true;\n+\t  if (register_operand (op0, GET_MODE (op0))\n+\t      && s390_tm_ccmode (op1, op2, 1) != VOIDmode)\n+\t    return true;\n+\t}\n+      return false;\n+\n     default:\n       return false;\n     }"}]}