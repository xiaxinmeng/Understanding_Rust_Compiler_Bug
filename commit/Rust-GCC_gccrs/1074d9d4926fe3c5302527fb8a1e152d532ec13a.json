{"sha": "1074d9d4926fe3c5302527fb8a1e152d532ec13a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA3NGQ5ZDQ5MjZmZTNjNTMwMjUyN2ZiOGExZTE1MmQ1MzJlYzEzYQ==", "commit": {"author": {"name": "Nicola Pero", "email": "n.pero@mi.flashnet.it", "date": "2002-09-17T13:59:30Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2002-09-17T13:59:30Z"}, "message": "Fixed ObjC typechecking, particularly case with protocols\n\nFrom-SVN: r57250", "tree": {"sha": "23ab0a5793dddd08ab57f35855174dd146bea0f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23ab0a5793dddd08ab57f35855174dd146bea0f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1074d9d4926fe3c5302527fb8a1e152d532ec13a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1074d9d4926fe3c5302527fb8a1e152d532ec13a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1074d9d4926fe3c5302527fb8a1e152d532ec13a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1074d9d4926fe3c5302527fb8a1e152d532ec13a/comments", "author": null, "committer": null, "parents": [{"sha": "256e9fd21abe2cbebfb52396a47ecfd06412d144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/256e9fd21abe2cbebfb52396a47ecfd06412d144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/256e9fd21abe2cbebfb52396a47ecfd06412d144"}], "stats": {"total": 269, "additions": 221, "deletions": 48}, "files": [{"sha": "da1aed19f3405c7bafcea8a686a8fd622a885e3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1074d9d4926fe3c5302527fb8a1e152d532ec13a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1074d9d4926fe3c5302527fb8a1e152d532ec13a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1074d9d4926fe3c5302527fb8a1e152d532ec13a", "patch": "@@ -1,3 +1,13 @@\n+Tue Sep 17 13:58:04 2002  Nicola Pero  <n.pero@mi.flashnet.it>\n+\n+\tFix PR/7014 and related objc bugs:\n+\t* c-typeck.c (comp_target_types): Added a reflexive argument.\n+\tPass it to ObjC when/if calling objc_comptypes().  Updated all\n+\tcallers to provide the appropriate reflexive argument.\n+\t* objc/objc-act.c (objc_comptypes): Carefully checked and fixed\n+\ttypechecking for all cases of comparisons and assignments,\n+\tparticularly the obscure and less common ones involving protocols.\n+\n 2002-09-17  Nick Clifton  <nickc@redhat.com>\n \n \t* machmode.def (V1DImode): New mode.  A single element vector."}, {"sha": "3595cff496c132419df4315ca2a121b43f1797de", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1074d9d4926fe3c5302527fb8a1e152d532ec13a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1074d9d4926fe3c5302527fb8a1e152d532ec13a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=1074d9d4926fe3c5302527fb8a1e152d532ec13a", "patch": "@@ -51,7 +51,7 @@ static int missing_braces_mentioned;\n static int undeclared_variable_notice;\n \n static tree qualify_type\t\tPARAMS ((tree, tree));\n-static int comp_target_types\t\tPARAMS ((tree, tree));\n+static int comp_target_types\t\tPARAMS ((tree, tree, int));\n static int function_types_compatible_p\tPARAMS ((tree, tree));\n static int type_lists_compatible_p\tPARAMS ((tree, tree));\n static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n@@ -579,16 +579,21 @@ comptypes (type1, type2)\n }\n \n /* Return 1 if TTL and TTR are pointers to types that are equivalent,\n-   ignoring their qualifiers.  */\n+   ignoring their qualifiers.  REFLEXIVE is only used by ObjC - set it\n+   to 1 or 0 depending if the check of the pointer types is meant to\n+   be reflexive or not (typically, assignments are not reflexive,\n+   while comparisons are reflexive).\n+*/\n \n static int\n-comp_target_types (ttl, ttr)\n+comp_target_types (ttl, ttr, reflexive)\n      tree ttl, ttr;\n+     int reflexive;\n {\n   int val;\n \n   /* Give objc_comptypes a crack at letting these types through.  */\n-  if ((val = objc_comptypes (ttl, ttr, 1)) >= 0)\n+  if ((val = objc_comptypes (ttl, ttr, reflexive)) >= 0)\n     return val;\n \n   val = comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (ttl)),\n@@ -1958,7 +1963,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       /* Subtraction of two similar pointers.\n \t We must subtract them as integers, then divide by object size.  */\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n-\t  && comp_target_types (type0, type1))\n+\t  && comp_target_types (type0, type1, 1))\n \treturn pointer_diff (op0, op1);\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n@@ -2148,7 +2153,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  /* Anything compares with void *.  void * compares with anything.\n \t     Otherwise, the targets must be compatible\n \t     and both must be object or both incomplete.  */\n-\t  if (comp_target_types (type0, type1))\n+\t  if (comp_target_types (type0, type1, 1))\n \t    result_type = common_type (type0, type1);\n \t  else if (VOID_TYPE_P (tt0))\n \t    {\n@@ -2195,7 +2200,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \tshorten = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  if (comp_target_types (type0, type1))\n+\t  if (comp_target_types (type0, type1, 1))\n \t    {\n \t      result_type = common_type (type0, type1);\n \t      if (pedantic \n@@ -2220,7 +2225,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  if (comp_target_types (type0, type1))\n+\t  if (comp_target_types (type0, type1, 1))\n \t    {\n \t      result_type = common_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n@@ -3443,7 +3448,7 @@ build_conditional_expr (ifexp, op1, op2)\n     }\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n     {\n-      if (comp_target_types (type1, type2))\n+      if (comp_target_types (type1, type2, 1))\n \tresult_type = common_type (type1, type2);\n       else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node\n \t       && TREE_CODE (orig_op1) != NOP_EXPR)\n@@ -4010,8 +4015,9 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n     {\n       overflow_warning (rhs);\n-      /* Check for Objective-C protocols.  This will issue a warning if\n-\t there are protocol violations.  No need to use the return value.  */\n+      /* Check for Objective-C protocols.  This will automatically\n+\t issue a warning if there are protocol violations.  No need to\n+\t use the return value.  */\n       if (flag_objc)\n \tobjc_comptypes (type, rhstype, 0);\n       return rhs;\n@@ -4086,7 +4092,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t Meanwhile, the lhs target must have all the qualifiers of\n \t\t the rhs.  */\n \t      if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t\t  || comp_target_types (memb_type, rhstype))\n+\t\t  || comp_target_types (memb_type, rhstype, 0))\n \t\t{\n \t\t  /* If this type won't generate any warnings, use it.  */\n \t\t  if (TYPE_QUALS (ttl) == TYPE_QUALS (ttr)\n@@ -4161,7 +4167,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t and vice versa; otherwise, targets must be the same.\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n       if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t  || comp_target_types (type, rhstype)\n+\t  || comp_target_types (type, rhstype, 0)\n \t  || (c_common_unsigned_type (TYPE_MAIN_VARIANT (ttl))\n \t      == c_common_unsigned_type (TYPE_MAIN_VARIANT (ttr))))\n \t{\n@@ -4186,7 +4192,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n \t      else if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t\t       || comp_target_types (type, rhstype))\n+\t\t       || comp_target_types (type, rhstype, 0))\n \t\t;\n \t      /* If there is a mismatch, do warn.  */\n \t      else if (pedantic)"}, {"sha": "3b5b75c7e7af0c900d9b2290600d89c8f1bd592d", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 191, "deletions": 34, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1074d9d4926fe3c5302527fb8a1e152d532ec13a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1074d9d4926fe3c5302527fb8a1e152d532ec13a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=1074d9d4926fe3c5302527fb8a1e152d532ec13a", "patch": "@@ -587,10 +587,24 @@ lookup_protocol_in_reflist (rproto_list, lproto)\n   return 0;\n }\n \n-/* Return 1 if LHS and RHS are compatible types for assignment\n-   or various other operations.  Return 0 if they are incompatible,\n-   and return -1 if we choose to not decide.  When the operation\n-   is REFLEXIVE, check for compatibility in either direction.  */\n+/* Return 1 if LHS and RHS are compatible types for assignment or\n+   various other operations.  Return 0 if they are incompatible, and\n+   return -1 if we choose to not decide (because the types are really\n+   just C types, not ObjC specific ones).  When the operation is\n+   REFLEXIVE (typically comparisons), check for compatibility in\n+   either direction; when it's not (typically assignments), don't.\n+\n+   This function is called in two cases: when both lhs and rhs are\n+   pointers to records (in which case we check protocols too), and\n+   when both lhs and rhs are records (in which case we check class\n+   inheritance only).\n+\n+   Warnings about classes/protocols not implementing a protocol are\n+   emitted here (multiple of those warnings might be emitted for a\n+   single line!); generic warnings about incompatible assignments and\n+   lacks of casts in comparisons are/must be emitted by the caller if\n+   we return 0.\n+*/\n \n int\n objc_comptypes (lhs, rhs, reflexive)\n@@ -600,6 +614,8 @@ objc_comptypes (lhs, rhs, reflexive)\n {\n   /* New clause for protocols.  */\n \n+  /* Here we manage the case of a POINTER_TYPE = POINTER_TYPE.  We only\n+     manage the ObjC ones, and leave the rest to the C code.  */\n   if (TREE_CODE (lhs) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (lhs)) == RECORD_TYPE\n       && TREE_CODE (rhs) == POINTER_TYPE\n@@ -614,29 +630,75 @@ objc_comptypes (lhs, rhs, reflexive)\n \t  tree rproto, rproto_list;\n \t  tree p;\n \n+\t  /* <Protocol> = <Protocol>  */\n \t  if (rhs_is_proto)\n \t    {\n \t      rproto_list = TYPE_PROTOCOL_LIST (rhs);\n-\n-\t      /* Make sure the protocol is supported by the object\n-\t\t on the rhs.  */\n-\t      for (lproto = lproto_list; lproto; lproto = TREE_CHAIN (lproto))\n+\t      \n+\t      if (!reflexive)\n \t\t{\n-\t\t  p = TREE_VALUE (lproto);\n-\t\t  rproto = lookup_protocol_in_reflist (rproto_list, p);\n+\t\t  /* An assignment between objects of type 'id\n+\t\t     <Protocol>'; make sure the protocol on the lhs is\n+\t\t     supported by the object on the rhs.  */\n+\t\t  for (lproto = lproto_list; lproto; \n+\t\t       lproto = TREE_CHAIN (lproto))\n+\t\t    {\n+\t\t      p = TREE_VALUE (lproto);\n+\t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n \n-\t\t  if (!rproto)\n-\t\t    warning (\"object does not conform to the `%s' protocol\",\n-\t\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+\t\t      if (!rproto)\n+\t\t\twarning \n+\t\t\t  (\"object does not conform to the `%s' protocol\",\n+\t\t\t   IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+\t\t    }\n+\t\t  return 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Obscure case - a comparison between two objects\n+\t\t     of type 'id <Protocol>'.  Check that either the\n+\t\t     protocol on the lhs is supported by the object on\n+\t\t     the rhs, or viceversa.  */\n+\t\t  \n+\t\t  /* Check if the protocol on the lhs is supported by the\n+\t\t     object on the rhs.  */\n+\t\t  for (lproto = lproto_list; lproto; \n+\t\t       lproto = TREE_CHAIN (lproto))\n+\t\t    {\n+\t\t      p = TREE_VALUE (lproto);\n+\t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n+\t\t      \n+\t\t      if (!rproto)\n+\t\t\t{\n+\t\t\t  /* Check failed - check if the protocol on the rhs\n+\t\t\t     is supported by the object on the lhs.  */\n+\t\t\t  for (rproto = rproto_list; rproto; \n+\t\t\t       rproto = TREE_CHAIN (rproto))\n+\t\t\t    {\n+\t\t\t      p = TREE_VALUE (rproto);\n+\t\t\t      lproto = lookup_protocol_in_reflist (lproto_list,\n+\t\t\t\t\t\t\t\t   p);\n+\n+\t\t\t      if (!lproto)\n+\t\t\t\t{\n+\t\t\t\t  /* This check failed too: incompatible  */\n+\t\t\t\t  return 0;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  return 1;\n+\t\t\t}\n+\t\t    }\n+\t\t  return 1;\n \t\t}\n \t    }\n+\t  /* <Protocol> = <class> *  */\n \t  else if (TYPED_OBJECT (TREE_TYPE (rhs)))\n \t    {\n \t      tree rname = TYPE_NAME (TREE_TYPE (rhs));\n \t      tree rinter;\n \n-\t      /* Make sure the protocol is supported by the object\n-\t\t on the rhs.  */\n+\t      /* Make sure the protocol is supported by the object on\n+\t\t the rhs.  */\n \t      for (lproto = lproto_list; lproto; lproto = TREE_CHAIN (lproto))\n \t\t{\n \t\t  p = TREE_VALUE (lproto);\n@@ -651,7 +713,7 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t      rproto = lookup_protocol_in_reflist (rproto_list, p);\n \t\t      /* If the underlying ObjC class does not have\n \t\t\t the protocol we're looking for, check for \"one-off\"\n-\t\t\t protocols (e.g., `NSObject<MyProt> foo;') attached\n+\t\t\t protocols (e.g., `NSObject<MyProt> *foo;') attached\n \t\t\t to the rhs.  */\n \t\t      if (!rproto)\n \t\t\t{\n@@ -665,7 +727,6 @@ objc_comptypes (lhs, rhs, reflexive)\n \t\t\t{\n \t\t\t  rproto_list = CLASS_PROTOCOL_LIST (cat);\n \t\t\t  rproto = lookup_protocol_in_reflist (rproto_list, p);\n-\n \t\t\t  cat = CLASS_CATEGORY_LIST (cat);\n \t\t\t}\n \n@@ -674,31 +735,127 @@ objc_comptypes (lhs, rhs, reflexive)\n \n \t\t  if (!rproto)\n \t\t    warning (\"class `%s' does not implement the `%s' protocol\",\n-\t                     IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (rhs))),\n-\t\t             IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+\t\t\t     IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (rhs))),\n+\t\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n \t\t}\n+\t      return 1;\n \t    }\n-\n-\t  /* May change...based on whether there was any mismatch */\n-          return 1;\n+\t  /* <Protocol> = id */\n+\t  else if (TYPE_NAME (TREE_TYPE (rhs)) == objc_object_id)\n+\t    {\n+\t      return 1;\n+\t    }\n+\t  /* <Protocol> = Class */\n+\t  else if (TYPE_NAME (TREE_TYPE (rhs)) == objc_class_id)\n+\t    {\n+\t      return 0;\n+\t    }\n+\t  /* <Protocol> = ?? : let comptypes decide.  */\n+          return -1;\n         }\n       else if (rhs_is_proto)\n-\t/* Lhs is not a protocol...warn if it is statically typed */\n-\treturn (TYPED_OBJECT (TREE_TYPE (lhs)) != 0);\n+\t{\n+\t  /* <class> * = <Protocol> */\n+\t  if (TYPED_OBJECT (TREE_TYPE (lhs)))\n+\t    {\n+\t      if (reflexive)\n+\t\t{\n+\t\t  tree rname = TYPE_NAME (TREE_TYPE (lhs));\n+\t\t  tree rinter;\n+\t\t  tree rproto, rproto_list = TYPE_PROTOCOL_LIST (rhs);\n+\t\t  \n+\t\t  /* Make sure the protocol is supported by the object on\n+\t\t     the lhs.  */\n+\t\t  for (rproto = rproto_list; rproto; \n+\t\t       rproto = TREE_CHAIN (rproto))\n+\t\t    {\n+\t\t      tree p = TREE_VALUE (rproto);\n+\t\t      tree lproto = 0;\n+\t\t      rinter = lookup_interface (rname);\n \n+\t\t      while (rinter && !lproto)\n+\t\t\t{\n+\t\t\t  tree cat;\n+\n+\t\t\t  tree lproto_list = CLASS_PROTOCOL_LIST (rinter);\n+\t\t\t  lproto = lookup_protocol_in_reflist (lproto_list, p);\n+\t\t\t  /* If the underlying ObjC class does not\n+\t\t\t     have the protocol we're looking for,\n+\t\t\t     check for \"one-off\" protocols (e.g.,\n+\t\t\t     `NSObject<MyProt> *foo;') attached to the\n+\t\t\t     lhs.  */\n+\t\t\t  if (!lproto)\n+\t\t\t    {\n+\t\t\t      lproto_list = TYPE_PROTOCOL_LIST \n+\t\t\t\t(TREE_TYPE (lhs));\n+\t\t\t      lproto = lookup_protocol_in_reflist \n+\t\t\t\t(lproto_list, p);\n+\t\t\t    }\n+\n+\t\t\t  /* Check for protocols adopted by categories.  */\n+\t\t\t  cat = CLASS_CATEGORY_LIST (rinter);\n+\t\t\t  while (cat && !lproto)\n+\t\t\t    {\n+\t\t\t      lproto_list = CLASS_PROTOCOL_LIST (cat);\n+\t\t\t      lproto = lookup_protocol_in_reflist (lproto_list,\n+\t\t\t\t\t\t\t\t   p);\n+\t\t\t      cat = CLASS_CATEGORY_LIST (cat);\n+\t\t\t    }\n+\t\t\t  \n+\t\t\t  rinter = lookup_interface (CLASS_SUPER_NAME \n+\t\t\t\t\t\t     (rinter));\n+\t\t\t}\n+\t\t      \n+\t\t      if (!lproto)\n+\t\t\twarning (\"class `%s' does not implement the `%s' protocol\",\n+\t\t\t\t IDENTIFIER_POINTER (TYPE_NAME \n+\t\t\t\t\t\t     (TREE_TYPE (lhs))),\n+\t\t\t\t IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+\t\t    }\n+\t\t  return 1;\n+\t\t}\n+\t      else\n+\t\treturn 0;\n+\t    }\n+\t  /* id = <Protocol> */\n+\t  else if (TYPE_NAME (TREE_TYPE (lhs)) == objc_object_id)\n+\t    {\n+\t      return 1;\n+\t    }\n+\t  /* Class = <Protocol> */\n+\t  else if (TYPE_NAME (TREE_TYPE (lhs)) == objc_class_id)\n+\t    {\n+\t      return 0;\n+\t    }\n+\t  /* ??? = <Protocol> : let comptypes decide */\n+\t  else\n+\t    {\n+\t      return -1;\n+\t    }\n+\t}\n       else\n-\t/* Defer to comptypes.  */\n-\treturn -1;\n+\t{\n+\t  /* Attention: we shouldn't defer to comptypes here.  One bad\n+\t     side effect would be that we might loose the REFLEXIVE\n+\t     information.\n+\t  */\n+\t  lhs = TREE_TYPE (lhs);\n+\t  rhs = TREE_TYPE (rhs);\n+\t}\n     }\n \n-  else if (TREE_CODE (lhs) == RECORD_TYPE && TREE_CODE (rhs) == RECORD_TYPE)\n-    ; /* Fall thru.  This is the case we have been handling all along */\n-  else\n-    /* Defer to comptypes.  */\n-    return -1;\n-\n-  /* `id' = `<class> *', `<class> *' = `id' */\n+  if (TREE_CODE (lhs) != RECORD_TYPE || TREE_CODE (rhs) != RECORD_TYPE)\n+    {\n+      /* Nothing to do with ObjC - let immediately comptypes take\n+\t responsibility for checking.  */\n+      return -1;\n+    }\n \n+  /* `id' = `<class> *' `<class> *' = `id': always allow it.\n+     Please note that \n+     'Object *o = [[Object alloc] init]; falls\n+     in the case <class> * = `id'.\n+  */\n   if ((TYPE_NAME (lhs) == objc_object_id && TYPED_OBJECT (rhs))\n       || (TYPE_NAME (rhs) == objc_object_id && TYPED_OBJECT (lhs)))\n     return 1;\n@@ -739,7 +896,7 @@ objc_comptypes (lhs, rhs, reflexive)\n       return 0;\n     }\n   else\n-    /* Defer to comptypes.  */\n+    /* Not an ObjC type - let comptypes do the check.  */\n     return -1;\n }\n "}]}