{"sha": "3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E1YjkyODRkYTZhY2MzMDkxMThhMDRkY2JhM2ExY2JjYTJlY2RkNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-21T09:15:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-21T09:15:29Z"}, "message": "c-common.c (verify_sequence_points): Export.\n\n        * c-common.c (verify_sequence_points): Export.\n        (c_expand_expr_stmt): Move to c-typeck.c.\n        * c-common.h (c_expand_expr_stmt): Remove.\n        (verify_sequence_points): Declare.\n        * c-mudflap.c (mflang_flush_calls): Use c_finish_expr_stmt.\n        * c-parse.in (for_init_stmt, stmt): Likewise.\n        * c-tree.h (c_finish_expr_stmt): Declare.\n        (c_tree_expr_nonnegative_p): Remove.\n        * c-typeck.c (c_tree_expr_nonnegative_p): Remove.\n        (build_conditional_expr, build_binary_op): Use tree_expr_nonnegative_p.\n        (emit_side_effect_warnings): New.\n        (c_finish_expr_stmt): Rename from c_expand_expr_stmt.  Use it.\n        (c_finish_stmt_expr): Work without EXPR_STMT.  Handle eh regions.\n        Use emit_side_effect_warnings.\n        (push_cleanup): Copy STATEMENT_LIST_STMT_EXPR.\n        * fold-const.c (tree_expr_nonnegative_p): Handle TARGET_EXPR.\n        * gimplify.c (gimplify_modify_expr): Don't discard TARGET_EXPR\n        with void initializer.\n        (gimplify_target_expr): Handle void BIND_EXPR initializer.\n        * tree-inline.c (estimate_num_insns_1): Fix type lookup for\n        INIT_EXPR and MODIFY_EXPR.\n        * objc/objc-act.c (build_module_descriptor): Use add_stmt\n        instead of c_expand_expr_stmt.\ncp/\n        * semantics.c (finish_expr_stmt): Call verify_sequence_points.\ntestsuite/\n        * gcc.dg/tree-ssa/20030714-1.c: Rename variables to avoid\n        merging && to BIT_FIELD_REF.\n\nFrom-SVN: r83429", "tree": {"sha": "2f19dd655a5b6d52dc032012f1972b9a63e632e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f19dd655a5b6d52dc032012f1972b9a63e632e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/comments", "author": null, "committer": null, "parents": [{"sha": "2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c486ea78cfcbd4b05c7845db23647fe2bf61d6d"}], "stats": {"total": 354, "additions": 239, "deletions": 115}, "files": [{"sha": "77f8f98e00c188a3bee92f418ae354a246eee91e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -1,3 +1,29 @@\n+2004-06-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.c (verify_sequence_points): Export.\n+\t(c_expand_expr_stmt): Move to c-typeck.c.\n+\t* c-common.h (c_expand_expr_stmt): Remove.\n+\t(verify_sequence_points): Declare.\n+\t* c-mudflap.c (mflang_flush_calls): Use c_finish_expr_stmt.\n+\t* c-parse.in (for_init_stmt, stmt): Likewise.\n+\t* c-tree.h (c_finish_expr_stmt): Declare.\n+\t(c_tree_expr_nonnegative_p): Remove.\n+\t* c-typeck.c (c_tree_expr_nonnegative_p): Remove.\n+\t(build_conditional_expr, build_binary_op): Use tree_expr_nonnegative_p.\n+\t(emit_side_effect_warnings): New.\n+\t(c_finish_expr_stmt): Rename from c_expand_expr_stmt.  Use it.\n+\t(c_finish_stmt_expr): Work without EXPR_STMT.  Handle eh regions.\n+\tUse emit_side_effect_warnings.\n+\t(push_cleanup): Copy STATEMENT_LIST_STMT_EXPR.\n+\t* fold-const.c (tree_expr_nonnegative_p): Handle TARGET_EXPR.\n+\t* gimplify.c (gimplify_modify_expr): Don't discard TARGET_EXPR\n+\twith void initializer.\n+\t(gimplify_target_expr): Handle void BIND_EXPR initializer.\n+\t* tree-inline.c (estimate_num_insns_1): Fix type lookup for\n+\tINIT_EXPR and MODIFY_EXPR.\n+\t* objc/objc-act.c (build_module_descriptor): Use add_stmt\n+\tinstead of c_expand_expr_stmt.\n+\n 2004-06-21  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* fold-const.c (fold_cond_expr_with_comparison):"}, {"sha": "79d9d9ac85970e9e68c60471fec9aa950d0b3aac", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -1247,7 +1247,6 @@ static int warning_candidate_p (tree);\n static void warn_for_collisions (struct tlist *);\n static void warn_for_collisions_1 (tree, tree, struct tlist *, int);\n static struct tlist *new_tlist (struct tlist *, tree, tree);\n-static void verify_sequence_points (tree);\n \n /* Create a new struct tlist and fill in its fields.  */\n static struct tlist *\n@@ -1586,7 +1585,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n /* Try to warn for undefined behavior in EXPR due to missing sequence\n    points.  */\n \n-static void\n+void\n verify_sequence_points (tree expr)\n {\n   struct tlist *before_sp = 0, *after_sp = 0;\n@@ -1603,32 +1602,6 @@ verify_sequence_points (tree expr)\n   warn_for_collisions (after_sp);\n   obstack_free (&tlist_obstack, tlist_firstobj);\n }\n-\n-tree\n-c_expand_expr_stmt (tree expr)\n-{\n-  /* Do default conversion if safe and possibly important,\n-     in case within ({...}).  */\n-  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n-       && (flag_isoc99 || lvalue_p (expr)))\n-      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n-    expr = default_conversion (expr);\n-\n-  if (warn_sequence_point)\n-    verify_sequence_points (expr);\n-\n-  if (TREE_TYPE (expr) != error_mark_node\n-      && !COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (expr))\n-      && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n-    error (\"expression statement has incomplete type\");\n-\n-  /* As tempting as it might be, we can't diagnose statement with no\n-     effect yet.  We have to wait until after statement expressions\n-     have been parsed, and that process modifies the trees we are\n-     creating here.  */\n-\n-  return add_stmt (build_stmt (EXPR_STMT, expr));\n-}\n \f\n /* Validate the expression after `case' and apply default promotions.  */\n "}, {"sha": "27733aa7c5c3bba40c812cbe73b0b8287acb4dfc", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -859,7 +859,6 @@ extern void binary_op_error (enum tree_code);\n #define my_friendly_assert(EXP, N) (void) \\\n  (((EXP) == 0) ? (fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0) : 0)\n \n-extern tree c_expand_expr_stmt (tree);\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value (tree);\n extern tree fix_string_type (tree);\n@@ -1097,6 +1096,8 @@ extern tree c_walk_subtrees (tree*, int*, walk_tree_fn, void*, void*);\n \n extern void c_warn_unused_result (tree *);\n \n+extern void verify_sequence_points (tree);\n+\n /* In c-gimplify.c  */\n extern void c_genericize (tree);\n extern int c_gimplify_expr (tree *, tree *, tree *);"}, {"sha": "af1ade9b2dea4b427cc427d2e915186bc57ccafd", "filename": "gcc/c-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-mudflap.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -85,7 +85,7 @@ mflang_flush_calls (tree enqueued_call_stmt_chain)\n   mf_mark (current_function_decl);\n \n   cs = c_begin_compound_stmt (true);\n-  c_expand_expr_stmt (enqueued_call_stmt_chain);\n+  c_finish_expr_stmt (enqueued_call_stmt_chain);\n   add_stmt (c_end_compound_stmt (cs, true));\n \n   finish_function ();"}, {"sha": "ce8829a0321d85a17220778eadf254c3e63996ae", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -2210,7 +2210,7 @@ select_or_iter_stmt:\n \n for_init_stmt:\n \t  xexpr ';'\n-\t\t{ add_stmt (build_stmt (EXPR_STMT, $1)); }\n+\t\t{ c_finish_expr_stmt ($1); }\n \t| decl\n \t\t{ check_for_loop_decls (); }\n \t;\n@@ -2226,7 +2226,7 @@ stmt:\n \t  compstmt\n \t\t{ stmt_count++; add_stmt ($1); }\n \t| expr ';'\n-\t\t{ stmt_count++; c_expand_expr_stmt ($1); }\n+\t\t{ stmt_count++; c_finish_expr_stmt ($1); }\n \t| c99_block_start select_or_iter_stmt\n                 { add_stmt (c_end_compound_stmt ($1, flag_isoc99)); }\n \t| BREAK ';'"}, {"sha": "03d84dd6672c4356b13bbf49659ca9c020642148", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -227,7 +227,6 @@ extern tree build_indirect_ref (tree, const char *);\n extern tree build_array_ref (tree, tree);\n extern tree build_external_ref (tree, int);\n extern tree parser_build_binary_op (enum tree_code, tree, tree);\n-extern int c_tree_expr_nonnegative_p (tree);\n extern void readonly_error (tree, const char *);\n extern tree build_conditional_expr (tree, tree, tree);\n extern tree build_compound_expr (tree);\n@@ -272,6 +271,7 @@ extern void c_finish_for_stmt_incr (tree, tree);\n extern void c_finish_for_stmt (tree, tree);\n extern tree c_begin_stmt_expr (void);\n extern tree c_finish_stmt_expr (tree);\n+extern void c_finish_expr_stmt (tree);\n extern tree build_offsetof (tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if"}, {"sha": "91423dda0c778687384c3e8a59128dab8f5aba56", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 125, "deletions": 60, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -46,6 +46,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"tree-iterator.h\"\n+#include \"tree-gimple.h\"\n \n \n /* Nonzero if we've already printed a \"missing braces around initializer\"\n@@ -2201,17 +2202,6 @@ parser_build_binary_op (enum tree_code code, tree arg1, tree arg2)\n   return result;\n }\n \f\n-\n-/* Return true if `t' is known to be non-negative.  */\n-\n-int\n-c_tree_expr_nonnegative_p (tree t)\n-{\n-  if (TREE_CODE (t) == STMT_EXPR)\n-    t = expr_last (STMT_EXPR_STMT (t));\n-  return tree_expr_nonnegative_p (t);\n-}\n-\n /* Return a tree for the difference of pointers OP0 and OP1.\n    The resulting tree has type int.  */\n \n@@ -2810,8 +2800,8 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \t      /* Do not warn if the signed quantity is an unsuffixed\n \t\t integer literal (or some static constant expression\n \t\t involving such literals) and it is non-negative.  */\n-\t      else if ((unsigned_op2 && c_tree_expr_nonnegative_p (op1))\n-\t\t       || (unsigned_op1 && c_tree_expr_nonnegative_p (op2)))\n+\t      else if ((unsigned_op2 && tree_expr_nonnegative_p (op1))\n+\t\t       || (unsigned_op1 && tree_expr_nonnegative_p (op2)))\n \t\t/* OK */;\n \t      else\n \t\twarning (\"signed and unsigned type in conditional expression\");\n@@ -6657,7 +6647,61 @@ c_finish_for_stmt (tree body, tree for_stmt)\n   FOR_BODY (for_stmt) = body;\n }\n \f\n-/* Create a statement expression.  */\n+/* A helper routine for c_finish_expr_stmt and c_finish_stmt_expr.  */\n+\n+static void\n+emit_side_effect_warnings (tree expr)\n+{\n+  if (!TREE_SIDE_EFFECTS (expr))\n+    {\n+      if (!VOID_TYPE_P (TREE_TYPE (expr)) && !TREE_NO_WARNING (expr))\n+\twarning (\"%Hstatement with no effect\",\n+\t\t EXPR_LOCUS (expr) ? EXPR_LOCUS (expr) : &input_location);\n+    }\n+  else if (warn_unused_value)\n+    warn_if_unused_value (expr, input_location);\n+}\n+\n+/* Emit an expression as a statement.  */\n+\n+void\n+c_finish_expr_stmt (tree expr)\n+{\n+  if (!expr)\n+    return;\n+\n+  /* Do default conversion if safe and possibly important,\n+     in case within ({...}).  */\n+  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+       && (flag_isoc99 || lvalue_p (expr)))\n+      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n+    expr = default_conversion (expr);\n+\n+  if (warn_sequence_point)\n+    verify_sequence_points (expr);\n+\n+  if (TREE_TYPE (expr) != error_mark_node\n+      && !COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (expr))\n+      && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n+    error (\"expression statement has incomplete type\");\n+\n+  /* If we're not processing a statement expression, warn about unused values.\n+     Warnings for statement expressions will be emitted later, once we figure\n+     out which is the result.  */\n+  if (!STATEMENT_LIST_STMT_EXPR (cur_stmt_list)\n+      && (extra_warnings || warn_unused_value))\n+    emit_side_effect_warnings (expr);\n+\n+  /* If the expression is not of a type to which we cannot assign a line\n+     number, wrap the thing in a no-op NOP_EXPR.  */\n+  if (DECL_P (expr) || TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n+    expr = build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n+\n+  add_stmt (expr);\n+}\n+\n+/* Do the opposite and emit a statement as an expression.  To begin,\n+   create a new binding level and return it.  */\n \n tree\n c_begin_stmt_expr (void)\n@@ -6679,63 +6723,77 @@ c_begin_stmt_expr (void)\n tree\n c_finish_stmt_expr (tree body)\n {\n-  tree ret, last, type;\n+  tree last, type, tmp, val;\n   tree *last_p;\n \n   body = c_end_compound_stmt (body, true);\n \n-  /* Locate the last statement in BODY.  */\n-  last = body, last_p = &body;\n-  if (TREE_CODE (last) == BIND_EXPR)\n-    {\n-      last_p = &BIND_EXPR_BODY (last);\n-      last = BIND_EXPR_BODY (last);\n-    }\n+  /* Locate the last statement in BODY.  See c_end_compound_stmt\n+     about always returning a BIND_EXPR.  */\n+  last_p = &BIND_EXPR_BODY (body);\n+  last = BIND_EXPR_BODY (body);\n+\n+ continue_searching:\n   if (TREE_CODE (last) == STATEMENT_LIST)\n     {\n-      tree_stmt_iterator i = tsi_last (last);\n-      if (tsi_end_p (i))\n+      tree_stmt_iterator i;\n+\n+      /* This can happen with degenerate cases like ({ }).  No value.  */\n+      if (!TREE_SIDE_EFFECTS (last))\n+\treturn body;\n+\n+      /* If we're supposed to generate side effects warnings, process\n+\t all of the statements except the last.  */\n+      if (extra_warnings || warn_unused_value)\n \t{\n-\t  type = void_type_node;\n-\t  /* ??? Warn */\n-\t  goto no_expr;\n+\t  for (i = tsi_start (last); !tsi_one_before_end_p (i); tsi_next (&i))\n+\t    emit_side_effect_warnings (tsi_stmt (i));\n \t}\n       else\n-\t{\n-\t  last_p = tsi_stmt_ptr (i);\n-\t  last = *last_p;\n-\t}\n+\ti = tsi_last (last);\n+      last_p = tsi_stmt_ptr (i);\n+      last = *last_p;\n     }\n \n-  /* If the last statement is an EXPR_STMT, then unwrap it.  Otherwise\n-     voidify_wrapper_expr will stuff it inside a MODIFY_EXPR and we'll\n-     fail gimplification.  */\n-  /* ??? Should we go ahead and perform voidify_wrapper_expr here?\n-     We've got about all the information we need here.  All we'd have\n-     to do even for proper type safety is to create, in effect,\n-\t( ({ ...; tmp = last; }), tmp )\n-     I.e. a COMPOUND_EXPR with the rhs being the compiler temporary.\n-     Not going to try this now, since it's not clear what should\n-     happen (wrt bindings) with new temporaries at this stage.  It's\n-     easier once we begin gimplification.  */\n-  if (TREE_CODE (last) == EXPR_STMT)\n-    *last_p = last = EXPR_STMT_EXPR (last);\n+  /* If the end of the list is exception related, then the list was split\n+     by a call to push_cleanup.  Continue searching.  */\n+  if (TREE_CODE (last) == TRY_FINALLY_EXPR\n+      || TREE_CODE (last) == TRY_CATCH_EXPR)\n+    {\n+      last_p = &TREE_OPERAND (last, 0);\n+      last = *last_p;\n+      goto continue_searching;\n+    }\n+\n+  /* In the case that the BIND_EXPR is not necessary, return the\n+     expression out from inside it.  */\n+  if (last == BIND_EXPR_BODY (body) && BIND_EXPR_VARS (body) == NULL)\n+    return last;\n \n   /* Extract the type of said expression.  */\n   type = TREE_TYPE (last);\n-  if (!type)\n-    type = void_type_node;\n-\n- no_expr:\n-  /* If what's left is compound, make sure we've got a BIND_EXPR, and\n-     that it has the proper type.  */\n-  ret = body;\n-  if (TREE_CODE (ret) == STATEMENT_LIST)\n-    ret = build (BIND_EXPR, type, NULL, ret, NULL);\n-  else if (TREE_CODE (ret) == BIND_EXPR)\n-    TREE_TYPE (ret) = type;\n \n-  return ret;\n+  /* If we're not returning a value at all, then the BIND_EXPR that\n+     we already have is a fine expression to return.  */\n+  if (!type || VOID_TYPE_P (type))\n+    return body;\n+\n+  /* Now that we've located the expression containing the value, it seems\n+     silly to make voidify_wrapper_expr repeat the process.  Create a\n+     temporary of the appropriate type and stick it in a TARGET_EXPR.  */\n+  tmp = create_tmp_var_raw (type, NULL);\n+\n+  /* Unwrap a no-op NOP_EXPR as added by c_finish_expr_stmt.  This avoids\n+     tree_expr_nonnegative_p giving up immediately.  */\n+  val = last;\n+  if (TREE_CODE (val) == NOP_EXPR\n+      && TREE_TYPE (val) == TREE_TYPE (TREE_OPERAND (val, 0)))\n+    val = TREE_OPERAND (val, 0);\n+\n+  *last_p = build (MODIFY_EXPR, void_type_node, tmp, val);\n+  SET_EXPR_LOCUS (*last_p, EXPR_LOCUS (last));\n+\n+  return build (TARGET_EXPR, type, tmp, body, NULL_TREE, NULL_TREE);\n }\n \f\n /* Begin and end compound statements.  This is as simple as pushing\n@@ -6791,10 +6849,17 @@ c_end_compound_stmt (tree stmt, bool do_scope)\n void\n push_cleanup (tree decl ATTRIBUTE_UNUSED, tree cleanup, bool eh_only)\n {\n-  enum tree_code code = eh_only ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR;\n-  tree stmt = build_stmt (code, NULL, cleanup);\n+  enum tree_code code;\n+  tree stmt, list;\n+  bool stmt_expr;\n+\n+  code = eh_only ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR;\n+  stmt = build_stmt (code, NULL, cleanup);\n   add_stmt (stmt);\n-  TREE_OPERAND (stmt, 0) = push_stmt_list ();\n+  stmt_expr = STATEMENT_LIST_STMT_EXPR (cur_stmt_list);\n+  list = push_stmt_list ();\n+  TREE_OPERAND (stmt, 0) = list;\n+  STATEMENT_LIST_STMT_EXPR (list) = stmt_expr;\n }\n \f\n /* Build a binary-operation expression without default conversions.\n@@ -7412,7 +7477,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t     constant expression involving such literals or a\n \t\t     conditional expression involving such literals)\n \t\t     and it is non-negative.  */\n-\t\t  if (c_tree_expr_nonnegative_p (sop))\n+\t\t  if (tree_expr_nonnegative_p (sop))\n \t\t    /* OK */;\n \t\t  /* Do not warn if the comparison is an equality operation,\n \t\t     the unsigned quantity is an integral constant, and it"}, {"sha": "679289af87375e21be650d7d01dae53b1ff9adc1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -1,3 +1,7 @@\n+2004-06-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* semantics.c (finish_expr_stmt): Call verify_sequence_points.\n+\n 2004-06-20  Richard Henderson  <rth@redhat.com>\n \n \t* cp-tree.h (add_decl_stmt): Declare."}, {"sha": "826ac688a761715173c08817aea6c01a52830222", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -493,7 +493,11 @@ finish_expr_stmt (tree expr)\n   if (expr != NULL_TREE)\n     {\n       if (!processing_template_decl)\n-\texpr = convert_to_void (expr, \"statement\");\n+\t{\n+\t  if (warn_sequence_point)\n+\t    verify_sequence_points (expr);\n+\t  expr = convert_to_void (expr, \"statement\");\n+\t}\n       else if (!type_dependent_expression_p (expr))\n \tconvert_to_void (build_non_dependent_expr (expr), \"statement\");\n "}, {"sha": "517d5508b954007b0624786bf88a65ba2a4d2805", "filename": "gcc/fold-const.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -9267,6 +9267,37 @@ tree_expr_nonnegative_p (tree t)\n     case RTL_EXPR:\n       return rtl_expr_nonnegative_p (RTL_EXPR_RTL (t));\n \n+    case TARGET_EXPR:\n+      {\n+\ttree temp = TARGET_EXPR_SLOT (t);\n+\tt = TARGET_EXPR_INITIAL (t);\n+\n+\t/* If the initializer is non-void, then it's a normal expression\n+\t   that will be assigned to the slot.  */\n+\tif (!VOID_TYPE_P (t))\n+\t  return tree_expr_nonnegative_p (t);\n+\n+\t/* Otherwise, the initializer sets the slot in some way.  One common\n+\t   way is an assignment statement at the end of the initializer.  */\n+\twhile (1)\n+\t  {\n+\t    if (TREE_CODE (t) == BIND_EXPR)\n+\t      t = expr_last (BIND_EXPR_BODY (t));\n+\t    else if (TREE_CODE (t) == TRY_FINALLY_EXPR\n+\t\t     || TREE_CODE (t) == TRY_CATCH_EXPR)\n+\t      t = expr_last (TREE_OPERAND (t, 0));\n+\t    else if (TREE_CODE (t) == STATEMENT_LIST)\n+\t      t = expr_last (t);\n+\t    else\n+\t      break;\n+\t  }\n+\tif (TREE_CODE (t) == MODIFY_EXPR\n+\t    && TREE_OPERAND (t, 0) == temp)\n+\t  return tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\n+\treturn 0;\n+      }\n+\n     case CALL_EXPR:\n       {\n \ttree fndecl = get_callee_fndecl (t);"}, {"sha": "f6e4a04bf9bfe67bc6ef1481b47c0c2627ec475e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -2472,13 +2472,19 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n     return ret;\n \n   /* If we are initializing something from a TARGET_EXPR, strip the\n-     TARGET_EXPR and initialize it directly.  */\n+     TARGET_EXPR and initialize it directly, if possible.  This can't\n+     be done if the initializer is void, since that implies that the\n+     temporary is set in some non-trivial way.  */\n   /* What about code that pulls out the temp and uses it elsewhere?  I\n      think that such code never uses the TARGET_EXPR as an initializer.  If\n      I'm wrong, we'll abort because the temp won't have any RTL.  In that\n      case, I guess we'll need to replace references somehow.  */\n   if (TREE_CODE (*from_p) == TARGET_EXPR)\n-    *from_p = TARGET_EXPR_INITIAL (*from_p);\n+    {\n+      tree init = TARGET_EXPR_INITIAL (*from_p);\n+      if (!VOID_TYPE_P (TREE_TYPE (init)))\n+        *from_p = init;\n+    }\n \n   /* If we're assigning from a ?: expression with ADDRESSABLE type, push\n      the assignment down into the branches, since we can't generate a\n@@ -3021,22 +3027,29 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n   if (init)\n     {\n-      /* TARGET_EXPR temps aren't part of the enclosing block, so add it to the\n-\t temps list.  */\n+      /* TARGET_EXPR temps aren't part of the enclosing block, so add it\n+\t to the temps list.  */\n       gimple_add_tmp_var (temp);\n \n-      /* Build up the initialization and add it to pre_p.  Special handling\n-\t for BIND_EXPR can result in fewer temporaries created.  */\n-      if (TREE_CODE (init) == BIND_EXPR)\n-\tgimplify_bind_expr (&init, temp, pre_p);\n-      if (init != temp)\n+      /* If TARGET_EXPR_INITIAL is void, then the mere evaluation of the\n+\t expression is supposed to initialize the slot.  */\n+      if (VOID_TYPE_P (TREE_TYPE (init)))\n+\tret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n+      else\n \t{\n-\t  if (! VOID_TYPE_P (TREE_TYPE (init)))\n-\t    init = build (MODIFY_EXPR, void_type_node, temp, init);\n-\t  ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n-\t  if (ret == GS_ERROR)\n-\t    return GS_ERROR;\n+          /* Special handling for BIND_EXPR can result in fewer temps.  */\n+\t  ret = GS_OK;\n+          if (TREE_CODE (init) == BIND_EXPR)\n+\t    gimplify_bind_expr (&init, temp, pre_p);\n+          if (init != temp)\n+\t    {\n+\t      init = build (MODIFY_EXPR, void_type_node, temp, init);\n+\t      ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt,\n+\t\t\t\t   fb_none);\n+\t    }\n \t}\n+      if (ret == GS_ERROR)\n+\treturn GS_ERROR;\n       append_to_statement_list (init, pre_p);\n \n       /* If needed, push the cleanup for the temp.  */"}, {"sha": "4414309ca7d51cf72c5ba3c0ac181b81c0355d58", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -1918,7 +1918,7 @@ build_module_descriptor (void)\n \t\t\t build_unary_op (ADDR_EXPR, UOBJC_MODULES_decl, 0));\n     decelerator = build_function_call (execclass_decl, parms);\n \n-    c_expand_expr_stmt (decelerator);\n+    add_stmt (decelerator);\n     add_stmt (c_end_compound_stmt (compound, true));\n \n     finish_function ();"}, {"sha": "d9f579e2968d3ba3f79e27de5f89b541b2d06d95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -1,3 +1,8 @@\n+2004-06-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20030714-1.c: Rename variables to avoid\n+\tmerging && to BIT_FIELD_REF.\n+\n 2004-06-21  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* g++.dg/opt/placeholder1.C: New test."}, {"sha": "1caa22ab53586c593c703886bb940c1bdb82e98d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030714-1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030714-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030714-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030714-1.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -19,12 +19,12 @@ find_base_value (src)\n      rtx src;\n {\n   rtx temp;\n-  rtx src_0;\n-  rtx src_1;\n+  rtx src_0, src_2;\n+  rtx src_1, src_3;\n \n-  if ((src_0->code == REG) && (({src_0;})->frame_related))\n+  if ((src_0->code == REG) && (({src_2;})->frame_related))\n     return find_base_value (src_0);\n-  if ((src_1->code == REG) && (({ src_1;})->frame_related))\n+  if ((src_1->code == REG) && (({ src_3;})->frame_related))\n     return find_base_value (src_1);\n   if (src_0->code == REG)\n     find_base_value (src_0);\n@@ -41,4 +41,3 @@ find_base_value (src)\n \n /* There should be three loads of ->code.  */\n /* { dg-final { scan-tree-dump-times \"->code\" 3 \"dom3\"} } */\n-                                                                                "}, {"sha": "24bf3d1b2ff3e82cdd0b938d31effb239d5daea5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a5b9284da6acc309118a04dcba3a1cbca2ecdd4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3a5b9284da6acc309118a04dcba3a1cbca2ecdd4", "patch": "@@ -1251,11 +1251,14 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case STRING_CST:\n       *walk_subtrees = 0;\n       return NULL;\n+\n     /* Recognize assignments of large structures and constructors of\n        big arrays.  */\n     case INIT_EXPR:\n-    case TARGET_EXPR:\n     case MODIFY_EXPR:\n+      x = TREE_OPERAND (x, 0);\n+      /* FALLTHRU */\n+    case TARGET_EXPR:\n     case CONSTRUCTOR:\n       {\n \tHOST_WIDE_INT size;"}]}