{"sha": "98d429466bf783ff1a7ac59bf800061d3e67061a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThkNDI5NDY2YmY3ODNmZjFhN2FjNTliZjgwMDA2MWQzZTY3MDYxYQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-10-25T09:04:55Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:16Z"}, "message": "Added strip-marking to statements, items and expressions (to allow them to be stripped from their parents)\n\nFixed compile errors and added more stripping behaviour for extern blocks", "tree": {"sha": "dfd9923f42bc77371b7e379a70978d0618a4e0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfd9923f42bc77371b7e379a70978d0618a4e0ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98d429466bf783ff1a7ac59bf800061d3e67061a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d429466bf783ff1a7ac59bf800061d3e67061a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d429466bf783ff1a7ac59bf800061d3e67061a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d429466bf783ff1a7ac59bf800061d3e67061a/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb644945a4f1bcac234a099f904812dcbbafcc93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb644945a4f1bcac234a099f904812dcbbafcc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb644945a4f1bcac234a099f904812dcbbafcc93"}], "stats": {"total": 2005, "additions": 1153, "deletions": 852}, "files": [{"sha": "cbeb7d4ddd231a1dc2cb702f10593e8bda0ea9d2", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -192,6 +192,8 @@ Attribute &Attribute::operator= (Attribute const &other)\n   // guard to protect from null pointer dereference\n   if (other.attr_input != nullptr)\n     attr_input = other.attr_input->clone_attr_input ();\n+  else\n+    attr_input = nullptr;\n \n   return *this;\n }\n@@ -323,7 +325,13 @@ std::string\n VisItem::as_string () const\n {\n   // FIXME: can't do formatting on string to make identation occur.\n-  std::string str = Item::as_string ();\n+  std::string str;\n+\n+  if (!outer_attrs.empty ())\n+    {\n+      for (const auto &attr : outer_attrs)\n+\t  str += attr.as_string () + \"\\n\";\n+    }\n \n   if (has_visibility ())\n     {\n@@ -334,7 +342,7 @@ VisItem::as_string () const\n }\n \n // Creates a string that reflects the outer attributes stored.\n-std::string\n+/*std::string\n Item::as_string () const\n {\n   std::string str;\n@@ -348,7 +356,7 @@ Item::as_string () const\n     }\n \n   return str;\n-}\n+}*/\n \n std::string\n Module::as_string () const\n@@ -1400,8 +1408,14 @@ TypeAlias::as_string () const\n std::string\n MacroInvocationSemi::as_string () const\n {\n+  std::string str;\n+\n   // get outer attrs\n-  std::string str = MacroItem::as_string ();\n+  if (!outer_attrs.empty ())\n+    {\n+      for (const auto &attr : outer_attrs)\n+\t  str += attr.as_string () + \"\\n\";\n+    }\n \n   str += \"\\n\" + path.as_string () + \"!\";\n \n@@ -1498,7 +1512,16 @@ MacroRule::as_string () const\n std::string\n MacroRulesDefinition::as_string () const\n {\n-  std::string str (\"macro_rules!\");\n+  std::string str;\n+\n+  // get outer attrs\n+  if (!outer_attrs.empty ())\n+    {\n+      for (const auto &attr : outer_attrs)\n+\t  str += attr.as_string () + \"\\n\";\n+    }\n+\n+  str += \"macro_rules!\";\n \n   str += rule_name;\n \n@@ -1510,9 +1533,7 @@ MacroRulesDefinition::as_string () const\n   else\n     {\n       for (const auto &rule : rules)\n-\t{\n \t  str += \"\\n  \" + rule.as_string ();\n-\t}\n     }\n \n   str += \"\\n Delim type: \";\n@@ -5403,9 +5424,9 @@ std::vector<Attribute> Attribute::separate_cfg_attrs () {\n     if (!has_attr_input () || path.as_string () != \"cfg_attr\")\n       return {};\n \n-      // TODO: maybe replace with storing a \"has been parsed\" variable?\n-      parse_attr_to_meta_item ();\n-      // can't be const because of this anyway\n+    // TODO: maybe replace with storing a \"has been parsed\" variable?\n+    parse_attr_to_meta_item ();\n+    // can't be const because of this anyway\n \n     return attr_input->separate_cfg_attrs ();\n   }"}, {"sha": "31c547a7d39290a0ed7cc56c5243dede5b887eb6", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -591,7 +591,7 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   void accept_vis (ASTVisitor &vis) override;\n \n   bool\n-  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n+  check_cfg_predicate (const Session&) const override\n   {\n     // this should never be called - should be converted first\n     return false;\n@@ -764,6 +764,9 @@ class Stmt\n    * methods. */\n   virtual Location get_locus_slow () const { return Location (); }\n \n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual Stmt *clone_stmt_impl () const = 0;\n@@ -772,40 +775,29 @@ class Stmt\n // Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n class Item : public Stmt\n {\n-  std::vector<Attribute> outer_attrs;\n-\n-  // TODO: should outer attrs be defined here or in each derived class?\n-\n public:\n   // Unique pointer custom clone function\n   std::unique_ptr<Item> clone_item () const\n   {\n     return std::unique_ptr<Item> (clone_item_impl ());\n   }\n \n-  std::string as_string () const;\n+  std::string as_string () const = 0;\n \n   /* Adds crate names to the vector passed by reference, if it can\n-   * (polymorphism). */\n+   * (polymorphism). TODO: remove, unused. */\n   virtual void\n   add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n   {}\n \n-  virtual void accept_vis (ASTVisitor &vis ATTRIBUTE_UNUSED) {}\n-\n protected:\n-  // Constructor\n-  Item (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : outer_attrs (std::move (outer_attribs))\n-  {}\n-\n   // Clone function implementation as pure virtual method\n   virtual Item *clone_item_impl () const = 0;\n \n   /* Save having to specify two clone methods in derived classes by making\n    * statement clone return item clone. Hopefully won't affect performance too\n    * much. */\n-  Item *clone_stmt_impl () const override { return clone_item_impl (); }\n+  Item *clone_stmt_impl () const final override { return clone_item_impl (); }\n };\n \n // forward decl of ExprWithoutBlock\n@@ -849,6 +841,9 @@ class Expr\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+\n protected:\n   // Constructor\n   Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n@@ -882,7 +877,7 @@ class ExprWithoutBlock : public Expr\n   /* Save having to specify two clone methods in derived classes by making expr\n    * clone return exprwithoutblock clone. Hopefully won't affect performance too\n    * much. */\n-  ExprWithoutBlock *clone_expr_impl () const override\n+  ExprWithoutBlock *clone_expr_impl () const final override\n   {\n     return clone_expr_without_block_impl ();\n   }\n@@ -935,6 +930,10 @@ class IdentifierExpr : public ExprWithoutBlock\n     return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n   }\n \n+  // \"Error state\" if ident is empty, so base stripping on this.\n+  void mark_for_strip () override { ident = {}; }\n+  bool is_marked_for_strip () const override { return ident.empty (); }\n+\n protected:\n   // Clone method implementation\n   IdentifierExpr *clone_expr_without_block_impl () const override\n@@ -946,9 +945,6 @@ class IdentifierExpr : public ExprWithoutBlock\n   {\n     return new IdentifierExpr (*this);\n   }\n-\n-  IdentifierExpr (IdentifierExpr const &other) = default;\n-  IdentifierExpr &operator= (IdentifierExpr const &other) = default;\n };\n \n // Pattern base AST node\n@@ -994,7 +990,7 @@ class Type\n \n   /* HACK: convert to trait bound. Virtual method overriden by classes that\n    * enable this. */\n-  virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n+  virtual TraitBound *to_trait_bound (bool) const\n   {\n     return nullptr;\n   }\n@@ -1025,7 +1021,7 @@ class TypeNoBounds : public Type\n   /* Save having to specify two clone methods in derived classes by making type\n    * clone return typenobounds clone. Hopefully won't affect performance too\n    * much. */\n-  TypeNoBounds *clone_type_impl () const override\n+  TypeNoBounds *clone_type_impl () const final override\n   {\n     return clone_type_no_bounds_impl ();\n   }\n@@ -1207,10 +1203,12 @@ class MacroItem : public Item\n {\n   /*public:\n   std::string as_string() const;*/\n+  //std::vector<Attribute> outer_attrs;\n+\n protected:\n-  MacroItem (std::vector<Attribute> outer_attribs)\n-    : Item (std::move (outer_attribs))\n-  {}\n+  /*MacroItem (std::vector<Attribute> outer_attribs)\n+    : outer_attrs (std::move (outer_attribs))\n+  {}*/\n };\n \n // Item used in trait declarations - abstract base class\n@@ -1298,6 +1296,7 @@ class MacroInvocationSemi : public MacroItem,\n \t\t\t    public InherentImplItem,\n \t\t\t    public TraitImplItem\n {\n+  std::vector<Attribute> outer_attrs;\n   SimplePath path;\n   // all delim types except curly must have invocation end with a semicolon\n   DelimType delim_type;\n@@ -1310,36 +1309,15 @@ class MacroInvocationSemi : public MacroItem,\n   MacroInvocationSemi (SimplePath macro_path, DelimType delim_type,\n \t\t       std::vector<std::unique_ptr<TokenTree>> token_trees,\n \t\t       std::vector<Attribute> outer_attribs, Location locus)\n-    : MacroItem (std::move (outer_attribs)), path (std::move (macro_path)),\n+    : outer_attrs (std::move (outer_attribs)), path (std::move (macro_path)),\n       delim_type (delim_type), token_trees (std::move (token_trees)),\n       locus (locus)\n   {}\n-  /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n-   * attributes\n-   * - storage inefficiency at least.\n-   * Best current idea is to make Item preferred and have TraitItem get virtual\n-   * functions for attributes or something. Or just redo the \"composition\"\n-   * approach, but then this prevents polymorphism and would entail redoing\n-   * quite a bit of the parser. */\n-\n-  // Move constructors\n-  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n-  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  // Clones this macro invocation semi.\n-  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n-  {\n-    return std::unique_ptr<MacroInvocationSemi> (\n-      clone_macro_invocation_semi_impl ());\n-  }\n \n-protected:\n   // Copy constructor with vector clone\n   MacroInvocationSemi (MacroInvocationSemi const &other)\n     : MacroItem (other), TraitItem (other), InherentImplItem (other),\n-      TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n+      TraitImplItem (other), outer_attrs(other.outer_attrs), path (other.path), delim_type (other.delim_type),\n       locus (other.locus)\n   {\n     token_trees.reserve (other.token_trees.size ());\n@@ -1354,6 +1332,7 @@ class MacroInvocationSemi : public MacroItem,\n     TraitItem::operator= (other);\n     InherentImplItem::operator= (other);\n     TraitImplItem::operator= (other);\n+    outer_attrs = other.outer_attrs;\n     path = other.path;\n     delim_type = other.delim_type;\n     locus = other.locus;\n@@ -1365,6 +1344,24 @@ class MacroInvocationSemi : public MacroItem,\n     return *this;\n   }\n \n+  // Move constructors\n+  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n+  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Clones this macro invocation semi.\n+  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n+  {\n+    return std::unique_ptr<MacroInvocationSemi> (\n+      clone_macro_invocation_semi_impl ());\n+  }\n+\n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () override { path = SimplePath::create_empty (); }\n+  bool is_marked_for_strip () const override { return path.is_empty (); }\n+\n+protected:\n   MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n   {\n     return new MacroInvocationSemi (*this);\n@@ -1391,13 +1388,6 @@ class MacroInvocationSemi : public MacroItem,\n     return clone_macro_invocation_semi_impl ();\n   }\n \n-  // FIXME: remove if item impl virtual override works properly\n-  // Use covariance to implement clone function as returning this object rather\n-  // than base\n-  /*MacroInvocationSemi* clone_statement_impl() const override {\n-      return clone_macro_invocation_semi_impl ();\n-  }*/\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocationSemi *clone_trait_item_impl () const override"}, {"sha": "46478291509f0a085ed0766d5e46e95bead2fc58", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 493, "deletions": 507, "changes": 1000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -23,7 +23,7 @@ class ExprWithBlock : public Expr\n   virtual ExprWithBlock *clone_expr_with_block_impl () const = 0;\n \n   // prevent having to define multiple clone expressions\n-  ExprWithBlock *clone_expr_impl () const override\n+  ExprWithBlock *clone_expr_impl () const final override\n   {\n     return clone_expr_with_block_impl ();\n   }\n@@ -73,19 +73,16 @@ class LiteralExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  LiteralExpr *clone_expr_impl () const override\n-  {\n-    return new LiteralExpr (*this);\n-  }\n+  // Invalid if literal is in error state, so base stripping on that.\n+  void mark_for_strip () override { literal = Literal::create_error (); }\n+  bool is_marked_for_strip () const override { return literal.is_error (); }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   LiteralExpr *clone_expr_without_block_impl () const override\n   {\n-    return new LiteralExpr (*this);\n+    return clone_literal_expr_impl ();\n   }\n \n   /* not virtual as currently no subclasses of LiteralExpr, but could be in\n@@ -121,7 +118,7 @@ class AttrInputLiteral : public AttrInput\n   /* this can never be a cfg predicate - cfg and cfg_attr require a token-tree\n    * cfg */\n   bool\n-  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n+  check_cfg_predicate (const Session&) const override\n   {\n     return false;\n   }\n@@ -212,18 +209,26 @@ class OperatorExpr : public ExprWithoutBlock\n \n   // Copy constructor (only for initialisation of expr purposes)\n   OperatorExpr (OperatorExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus),\n-      main_or_left_expr (other.main_or_left_expr->clone_expr ())\n-  {}\n+    : ExprWithoutBlock (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.main_or_left_expr != nullptr)\n+      main_or_left_expr = other.main_or_left_expr->clone_expr ();\n+  }\n \n   // Overload assignment operator to deep copy expr\n   OperatorExpr &operator= (OperatorExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    main_or_left_expr = other.main_or_left_expr->clone_expr ();\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.main_or_left_expr != nullptr)\n+      main_or_left_expr = other.main_or_left_expr->clone_expr ();\n+    else\n+      main_or_left_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -234,6 +239,10 @@ class OperatorExpr : public ExprWithoutBlock\n public:\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n+\n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { main_or_left_expr = nullptr; }\n+  bool is_marked_for_strip () const override { return main_or_left_expr == nullptr; }\n };\n \n /* Unary prefix & or &mut (or && and &&mut) borrow operator. Cannot be\n@@ -249,21 +258,13 @@ class BorrowExpr : public OperatorExpr\n   BorrowExpr (std::unique_ptr<Expr> borrow_lvalue, bool is_mut_borrow,\n \t      bool is_double_borrow, std::vector<Attribute> outer_attribs,\n \t      Location locus)\n-    : OperatorExpr (std::move (borrow_lvalue), std::move (outer_attribs),\n-\t\t    locus),\n-      is_mut (is_mut_borrow), double_borrow (is_double_borrow)\n+    : OperatorExpr (std::move (borrow_lvalue), std::move (outer_attribs), \n+      locus), is_mut (is_mut_borrow), double_borrow (is_double_borrow)\n   {}\n \n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  BorrowExpr *clone_expr_impl () const override\n-  {\n-    return new BorrowExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   BorrowExpr *clone_expr_without_block_impl () const override\n@@ -287,13 +288,6 @@ class DereferenceExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  DereferenceExpr *clone_expr_impl () const override\n-  {\n-    return new DereferenceExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   DereferenceExpr *clone_expr_without_block_impl () const override\n@@ -318,13 +312,6 @@ class ErrorPropagationExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ErrorPropagationExpr *clone_expr_impl () const override\n-  {\n-    return new ErrorPropagationExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ErrorPropagationExpr *clone_expr_without_block_impl () const override\n@@ -366,13 +353,6 @@ class NegationExpr : public OperatorExpr\n   Expr *get_expr () { return main_or_left_expr.get (); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  NegationExpr *clone_expr_impl () const override\n-  {\n-    return new NegationExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   NegationExpr *clone_expr_without_block_impl () const override\n@@ -448,13 +428,6 @@ class ArithmeticOrLogicalExpr : public OperatorExpr\n   void visit_rhs (ASTVisitor &vis) { right_expr->accept_vis (vis); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ArithmeticOrLogicalExpr *clone_expr_impl () const override\n-  {\n-    return new ArithmeticOrLogicalExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ArithmeticOrLogicalExpr *clone_expr_without_block_impl () const override\n@@ -525,13 +498,6 @@ class ComparisonExpr : public OperatorExpr\n   /* TODO: implement via a function call to std::cmp::PartialEq::eq(&op1, &op2)\n    * maybe? */\n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ComparisonExpr *clone_expr_impl () const override\n-  {\n-    return new ComparisonExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ComparisonExpr *clone_expr_without_block_impl () const override\n@@ -595,13 +561,6 @@ class LazyBooleanExpr : public OperatorExpr\n   Expr *get_lhs () { return main_or_left_expr.get (); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  LazyBooleanExpr *clone_expr_impl () const override\n-  {\n-    return new LazyBooleanExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   LazyBooleanExpr *clone_expr_without_block_impl () const override\n@@ -650,13 +609,6 @@ class TypeCastExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TypeCastExpr *clone_expr_impl () const override\n-  {\n-    return new TypeCastExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TypeCastExpr *clone_expr_without_block_impl () const override\n@@ -710,13 +662,6 @@ class AssignmentExpr : public OperatorExpr\n   Expr *get_lhs () { return main_or_left_expr.get (); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  AssignmentExpr *clone_expr_impl () const override\n-  {\n-    return new AssignmentExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   AssignmentExpr *clone_expr_without_block_impl () const override\n@@ -789,13 +734,6 @@ class CompoundAssignmentExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  CompoundAssignmentExpr *clone_expr_impl () const override\n-  {\n-    return new CompoundAssignmentExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   CompoundAssignmentExpr *clone_expr_without_block_impl () const override\n@@ -828,18 +766,27 @@ class GroupedExpr : public ExprWithoutBlock\n   // Copy constructor includes clone for expr_in_parens\n   GroupedExpr (GroupedExpr const &other)\n     : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n-      expr_in_parens (other.expr_in_parens->clone_expr ()), locus (other.locus)\n-  {}\n+      locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr_in_parens != nullptr)\n+      expr_in_parens = other.expr_in_parens->clone_expr ();\n+  }\n \n   // Overloaded assignment operator to clone expr_in_parens\n   GroupedExpr &operator= (GroupedExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n-    expr_in_parens = other.expr_in_parens->clone_expr ();\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr_in_parens != nullptr)\n+      expr_in_parens = other.expr_in_parens->clone_expr ();\n+    else\n+      expr_in_parens = nullptr;\n+\n     return *this;\n   }\n \n@@ -852,14 +799,11 @@ class GroupedExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  GroupedExpr *clone_expr_impl () const override\n-  {\n-    return new GroupedExpr (*this);\n-  }\n+  // Invalid if inner expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr_in_parens = nullptr; }\n+  bool is_marked_for_strip () const override { return expr_in_parens == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   GroupedExpr *clone_expr_without_block_impl () const override\n@@ -988,6 +932,9 @@ class ArrayExpr : public ExprWithoutBlock\n   std::unique_ptr<ArrayElems> internal_elements;\n \n   Location locus;\n+  \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n \n public:\n   std::string as_string () const override;\n@@ -1009,7 +956,7 @@ class ArrayExpr : public ExprWithoutBlock\n   // Copy constructor requires cloning ArrayElems for polymorphism to hold\n   ArrayExpr (ArrayExpr const &other)\n     : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+      locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     if (other.has_array_elems ())\n       internal_elements = other.internal_elements->clone_array_elems ();\n@@ -1020,11 +967,15 @@ class ArrayExpr : public ExprWithoutBlock\n   {\n     ExprWithoutBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n-    if (other.has_array_elems ())\n-      internal_elements = other.internal_elements->clone_array_elems ();\n     locus = other.locus;\n+    marked_for_strip = other.marked_for_strip;\n     // outer_attrs = other.outer_attrs;\n \n+    if (other.has_array_elems ())\n+      internal_elements = other.internal_elements->clone_array_elems ();\n+    else\n+      internal_elements = nullptr;\n+\n     return *this;\n   }\n \n@@ -1037,11 +988,11 @@ class ArrayExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ArrayExpr *clone_expr_impl () const override { return new ArrayExpr (*this); }\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ArrayExpr *clone_expr_without_block_impl () const override\n@@ -1075,19 +1026,32 @@ class ArrayIndexExpr : public ExprWithoutBlock\n \n   // Copy constructor requires special cloning due to unique_ptr\n   ArrayIndexExpr (ArrayIndexExpr const &other)\n-    : ExprWithoutBlock (other), array_expr (other.array_expr->clone_expr ()),\n-      index_expr (other.index_expr->clone_expr ()), locus (other.locus)\n-  {}\n+    : ExprWithoutBlock (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.array_expr != nullptr)\n+      array_expr = other.array_expr->clone_expr ();\n+    if (other.index_expr != nullptr)\n+      index_expr = other.index_expr->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone unique_ptrs\n   ArrayIndexExpr &operator= (ArrayIndexExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    array_expr = other.array_expr->clone_expr ();\n-    index_expr = other.index_expr->clone_expr ();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.array_expr != nullptr)\n+      array_expr = other.array_expr->clone_expr ();\n+    else \n+      array_expr = nullptr;\n+    if (other.index_expr != nullptr)\n+      index_expr = other.index_expr->clone_expr ();\n+    else\n+      index_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -1100,14 +1064,11 @@ class ArrayIndexExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ArrayIndexExpr *clone_expr_impl () const override\n-  {\n-    return new ArrayIndexExpr (*this);\n-  }\n+  // Invalid if either expr is null, so base stripping on that.\n+  void mark_for_strip () override { array_expr = nullptr; index_expr = nullptr; }\n+  bool is_marked_for_strip () const override { return array_expr == nullptr && index_expr == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ArrayIndexExpr *clone_expr_without_block_impl () const override\n@@ -1126,6 +1087,9 @@ class TupleExpr : public ExprWithoutBlock\n \n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override;\n \n@@ -1142,7 +1106,7 @@ class TupleExpr : public ExprWithoutBlock\n   // copy constructor with vector clone\n   TupleExpr (TupleExpr const &other)\n     : ExprWithoutBlock (other), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+      locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     tuple_elems.reserve (other.tuple_elems.size ());\n     for (const auto &e : other.tuple_elems)\n@@ -1155,6 +1119,7 @@ class TupleExpr : public ExprWithoutBlock\n     ExprWithoutBlock::operator= (other);\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n+    marked_for_strip = other.marked_for_strip;\n \n     tuple_elems.reserve (other.tuple_elems.size ());\n     for (const auto &e : other.tuple_elems)\n@@ -1175,11 +1140,11 @@ class TupleExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TupleExpr *clone_expr_impl () const override { return new TupleExpr (*this); }\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TupleExpr *clone_expr_without_block_impl () const override\n@@ -1213,19 +1178,27 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   // Copy constructor requires a clone for tuple_expr\n   TupleIndexExpr (TupleIndexExpr const &other)\n-    : ExprWithoutBlock (other), tuple_expr (other.tuple_expr->clone_expr ()),\n-      tuple_index (other.tuple_index), locus (other.locus)\n-  {}\n+    : ExprWithoutBlock (other), tuple_index (other.tuple_index), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_expr != nullptr)\n+      tuple_expr = other.tuple_expr->clone_expr ();\n+  }\n \n   // Overload assignment operator in order to clone\n   TupleIndexExpr &operator= (TupleIndexExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    tuple_expr = other.tuple_expr->clone_expr ();\n     tuple_index = other.tuple_index;\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_expr != nullptr)\n+      tuple_expr = other.tuple_expr->clone_expr ();\n+    else\n+      tuple_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -1238,14 +1211,11 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TupleIndexExpr *clone_expr_impl () const override\n-  {\n-    return new TupleIndexExpr (*this);\n-  }\n+  // Invalid if tuple expr is null, so base stripping on that.\n+  void mark_for_strip () override { tuple_expr = nullptr; }\n+  bool is_marked_for_strip () const override { return tuple_expr == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TupleIndexExpr *clone_expr_without_block_impl () const override\n@@ -1271,6 +1241,10 @@ class StructExpr : public ExprWithoutBlock\n   const PathInExpression &get_struct_name () const { return struct_name; }\n \n   std::string as_string () const override;\n+\n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () override { struct_name = PathInExpression::create_error (); }\n+  bool is_marked_for_strip () const override { return struct_name.is_error (); }\n };\n \n // Actual AST node of the struct creator (with no fields). Not abstract!\n@@ -1299,13 +1273,6 @@ class StructExprStruct : public StructExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  StructExprStruct *clone_expr_impl () const override\n-  {\n-    return new StructExprStruct (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   StructExprStruct *clone_expr_without_block_impl () const override\n@@ -1332,7 +1299,7 @@ struct StructBase\n     /* HACK: gets around base_struct pointer being null (e.g. if no struct base\n      * exists) */\n     if (other.base_struct != nullptr)\n-      other.base_struct->clone_expr ();\n+      base_struct = other.base_struct->clone_expr ();\n   }\n \n   // Destructor\n@@ -1341,7 +1308,11 @@ struct StructBase\n   // Overload assignment operator to clone base_struct\n   StructBase &operator= (StructBase const &other)\n   {\n-    base_struct = other.base_struct->clone_expr ();\n+    // prevent null pointer dereference\n+    if (other.base_struct != nullptr)\n+      base_struct = other.base_struct->clone_expr ();\n+    else\n+      base_struct = nullptr;\n \n     return *this;\n   }\n@@ -1555,13 +1526,6 @@ class StructExprStructFields : public StructExprStruct\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  StructExprStructFields *clone_expr_impl () const override\n-  {\n-    return new StructExprStructFields (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   StructExprStructFields *clone_expr_without_block_impl () const override\n@@ -1593,13 +1557,6 @@ class StructExprStructBase : public StructExprStruct\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  StructExprStructBase *clone_expr_impl () const override\n-  {\n-    return new StructExprStructBase (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   StructExprStructBase *clone_expr_without_block_impl () const override\n@@ -1667,13 +1624,6 @@ class StructExprTuple : public StructExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  StructExprTuple *clone_expr_impl () const override\n-  {\n-    return new StructExprTuple (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   StructExprTuple *clone_expr_without_block_impl () const override\n@@ -1706,13 +1656,6 @@ class StructExprUnit : public StructExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  StructExprUnit *clone_expr_impl () const override\n-  {\n-    return new StructExprUnit (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   StructExprUnit *clone_expr_without_block_impl () const override\n@@ -1738,6 +1681,10 @@ class EnumVariantExpr : public ExprWithoutBlock\n public:\n   // TODO: maybe remove and have string version gotten here directly\n   PathInExpression get_enum_variant_path () const { return enum_variant_path; }\n+\n+  // Invalid if path is in error state, so base stripping on that.\n+  void mark_for_strip () override { enum_variant_path = PathInExpression::create_error (); }\n+  bool is_marked_for_strip () const override { return enum_variant_path.is_error (); }\n };\n \n /* Base AST node for a single enum expression field (in enum instance creation)\n@@ -1828,9 +1775,6 @@ class EnumExprFieldIdentifierValue : public EnumExprFieldWithVal\n       field_name (std::move (field_name))\n   {}\n \n-  // copy constructor, destructor, and assignment operator should not need\n-  // defining\n-\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n@@ -1922,13 +1866,6 @@ class EnumExprStruct : public EnumVariantExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  EnumExprStruct *clone_expr_impl () const override\n-  {\n-    return new EnumExprStruct (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   EnumExprStruct *clone_expr_without_block_impl () const override\n@@ -1991,13 +1928,6 @@ class EnumExprTuple : public EnumVariantExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  EnumExprTuple *clone_expr_impl () const override\n-  {\n-    return new EnumExprTuple (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   EnumExprTuple *clone_expr_without_block_impl () const override\n@@ -2031,13 +1961,6 @@ class EnumExprFieldless : public EnumVariantExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  EnumExprFieldless *clone_expr_impl () const override\n-  {\n-    return new EnumExprFieldless (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   EnumExprFieldless *clone_expr_without_block_impl () const override\n@@ -2077,9 +2000,11 @@ class CallExpr : public ExprWithoutBlock\n \n   // copy constructor requires clone\n   CallExpr (CallExpr const &other)\n-    : ExprWithoutBlock (other), function (other.function->clone_expr ()),\n-      locus (other.locus)\n-  /*, params(other.params),*/ {\n+    : ExprWithoutBlock (other), locus (other.locus) {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function != nullptr)\n+      function = other.function->clone_expr ();\n+\n     params.reserve (other.params.size ());\n     for (const auto &e : other.params)\n       params.push_back (e->clone_expr ());\n@@ -2089,11 +2014,15 @@ class CallExpr : public ExprWithoutBlock\n   CallExpr &operator= (CallExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    function = other.function->clone_expr ();\n     locus = other.locus;\n-    // params = other.params;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function != nullptr)\n+      function = other.function->clone_expr ();\n+    else\n+      function = nullptr;\n+\n     params.reserve (other.params.size ());\n     for (const auto &e : other.params)\n       params.push_back (e->clone_expr ());\n@@ -2113,11 +2042,11 @@ class CallExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  CallExpr *clone_expr_impl () const override { return new CallExpr (*this); }\n+  // Invalid if function expr is null, so base stripping on that.\n+  void mark_for_strip () override { function = nullptr; }\n+  bool is_marked_for_strip () const override { return function == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   CallExpr *clone_expr_without_block_impl () const override\n@@ -2155,9 +2084,11 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   // copy constructor required due to cloning\n   MethodCallExpr (MethodCallExpr const &other)\n-    : ExprWithoutBlock (other), receiver (other.receiver->clone_expr ()),\n-      method_name (other.method_name), locus (other.locus)\n-  /*, params(other.params),*/ {\n+    : ExprWithoutBlock (other), method_name (other.method_name), locus (other.locus) {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.receiver != nullptr)\n+      receiver = other.receiver->clone_expr ();\n+\n     params.reserve (other.params.size ());\n     for (const auto &e : other.params)\n       params.push_back (e->clone_expr ());\n@@ -2167,12 +2098,16 @@ class MethodCallExpr : public ExprWithoutBlock\n   MethodCallExpr &operator= (MethodCallExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    receiver = other.receiver->clone_expr ();\n     method_name = other.method_name;\n     locus = other.locus;\n-    // params = other.params;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.receiver != nullptr)\n+      receiver = other.receiver->clone_expr ();\n+    else\n+      receiver = nullptr;\n+\n     params.reserve (other.params.size ());\n     for (const auto &e : other.params)\n       params.push_back (e->clone_expr ());\n@@ -2189,14 +2124,11 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MethodCallExpr *clone_expr_impl () const override\n-  {\n-    return new MethodCallExpr (*this);\n-  }\n+  // Invalid if receiver expr is null, so base stripping on that.\n+  void mark_for_strip () override { receiver = nullptr; }\n+  bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MethodCallExpr *clone_expr_without_block_impl () const override\n@@ -2227,19 +2159,27 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   // Copy constructor required due to unique_ptr cloning\n   FieldAccessExpr (FieldAccessExpr const &other)\n-    : ExprWithoutBlock (other), receiver (other.receiver->clone_expr ()),\n-      field (other.field), locus (other.locus)\n-  {}\n+    : ExprWithoutBlock (other), field (other.field), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.receiver != nullptr)\n+      receiver = other.receiver->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone unique_ptr\n   FieldAccessExpr &operator= (FieldAccessExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    receiver = other.receiver->clone_expr ();\n     field = other.field;\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.receiver != nullptr)\n+      receiver = other.receiver->clone_expr ();\n+    else\n+      receiver = nullptr;\n+\n     return *this;\n   }\n \n@@ -2252,14 +2192,11 @@ class FieldAccessExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  FieldAccessExpr *clone_expr_impl () const override\n-  {\n-    return new FieldAccessExpr (*this);\n-  }\n+  // Invalid if receiver expr is null, so base stripping on that.\n+  void mark_for_strip () override { receiver = nullptr; }\n+  bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   FieldAccessExpr *clone_expr_without_block_impl () const override\n@@ -2294,6 +2231,8 @@ struct ClosureParam\n     : pattern (other.pattern->clone_pattern ())\n   {\n     // guard to protect from null pointer dereference\n+    if (other.pattern != nullptr)\n+      pattern = other.pattern->clone_pattern ();\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n   }\n@@ -2303,8 +2242,15 @@ struct ClosureParam\n   // Assignment operator must be overloaded to clone as well\n   ClosureParam &operator= (ClosureParam const &other)\n   {\n-    pattern = other.pattern->clone_pattern ();\n-    type = other.type->clone_type ();\n+    // guard to protect from null pointer dereference\n+    if (other.pattern != nullptr)\n+      pattern = other.pattern->clone_pattern ();\n+    else\n+      pattern = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n \n     return *this;\n   }\n@@ -2367,18 +2313,27 @@ class ClosureExprInner : public ClosureExpr\n \n   // Copy constructor must be defined to allow copying via cloning of unique_ptr\n   ClosureExprInner (ClosureExprInner const &other)\n-    : ClosureExpr (other), closure_inner (other.closure_inner->clone_expr ())\n-  {}\n+    : ClosureExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.closure_inner != nullptr)\n+      closure_inner = other.closure_inner->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone closure_inner\n   ClosureExprInner &operator= (ClosureExprInner const &other)\n   {\n     ClosureExpr::operator= (other);\n-    closure_inner = other.closure_inner->clone_expr ();\n     // params = other.params;\n     // has_move = other.has_move;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.closure_inner != nullptr)\n+      closure_inner = other.closure_inner->clone_expr ();\n+    else\n+      closure_inner = nullptr;\n+\n     return *this;\n   }\n \n@@ -2388,14 +2343,11 @@ class ClosureExprInner : public ClosureExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ClosureExprInner *clone_expr_impl () const override\n-  {\n-    return new ClosureExprInner (*this);\n-  }\n+  // Invalid if inner expr is null, so base stripping on that.\n+  void mark_for_strip () override { closure_inner = nullptr; }\n+  bool is_marked_for_strip () const override { return closure_inner == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ClosureExprInner *clone_expr_without_block_impl () const override\n@@ -2437,8 +2389,7 @@ class BlockExpr : public ExprWithBlock\n \n   // Copy constructor with clone\n   BlockExpr (BlockExpr const &other)\n-    : ExprWithBlock (other), /*statements(other.statements),*/\n-      inner_attrs (other.inner_attrs), locus (other.locus)\n+    : ExprWithBlock (other), inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n     // guard to protect from null pointer dereference\n     if (other.expr != nullptr)\n@@ -2453,12 +2404,16 @@ class BlockExpr : public ExprWithBlock\n   BlockExpr &operator= (BlockExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n-    // statements = other.statements;\n-    expr = other.expr->clone_expr_without_block ();\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to protect from null pointer dereference\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+    else\n+      expr = nullptr;\n+\n     statements.reserve (other.statements.size ());\n     for (const auto &e : other.statements)\n       statements.push_back (e->clone_stmt ());\n@@ -2481,14 +2436,16 @@ class BlockExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  BlockExpr *clone_expr_impl () const override\n-  {\n-    return clone_block_expr_impl ();\n+  // Invalid if has no statements or final expr, so base stripping on that.\n+  void mark_for_strip () override \n+  { \n+    expr = nullptr; \n+    statements.clear (); \n+    statements.shrink_to_fit (); \n   }\n+  bool is_marked_for_strip () const override { return expr == nullptr && statements.empty (); }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   BlockExpr *clone_expr_with_block_impl () const override\n@@ -2507,6 +2464,7 @@ class BlockExpr : public ExprWithBlock\n // Represents a type-specified closure expression AST node\n class ClosureExprInnerTyped : public ClosureExpr\n {\n+  // TODO: spec says typenobounds\n   std::unique_ptr<Type> return_type;\n   std::unique_ptr<BlockExpr>\n     expr; // only used because may be polymorphic in future\n@@ -2529,20 +2487,33 @@ class ClosureExprInnerTyped : public ClosureExpr\n \n   // Copy constructor requires cloning\n   ClosureExprInnerTyped (ClosureExprInnerTyped const &other)\n-    : ClosureExpr (other), return_type (other.return_type->clone_type ()),\n-      expr (other.expr->clone_block_expr ())\n-  {}\n+    : ClosureExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_block_expr ();\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+  }\n \n   // Overload assignment operator to clone unique_ptrs\n   ClosureExprInnerTyped &operator= (ClosureExprInnerTyped const &other)\n   {\n     ClosureExpr::operator= (other);\n-    return_type = other.return_type->clone_type ();\n-    expr = other.expr->clone_block_expr ();\n     // params = other.params;\n     // has_move = other.has_move;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_block_expr ();\n+    else\n+      expr = nullptr;\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -2552,14 +2523,11 @@ class ClosureExprInnerTyped : public ClosureExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ClosureExprInnerTyped *clone_expr_impl () const override\n-  {\n-    return new ClosureExprInnerTyped (*this);\n-  }\n+  /* Invalid if inner expr is null, so base stripping on that. Technically, type should also not be null. */\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ClosureExprInnerTyped *clone_expr_without_block_impl () const override\n@@ -2575,6 +2543,9 @@ class ContinueExpr : public ExprWithoutBlock\n   Lifetime label;\n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override;\n \n@@ -2594,14 +2565,11 @@ class ContinueExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ContinueExpr *clone_expr_impl () const override\n-  {\n-    return new ContinueExpr (*this);\n-  }\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ContinueExpr *clone_expr_without_block_impl () const override\n@@ -2622,6 +2590,9 @@ class BreakExpr : public ExprWithoutBlock\n \n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override;\n \n@@ -2643,7 +2614,7 @@ class BreakExpr : public ExprWithoutBlock\n \n   // Copy constructor defined to use clone for unique pointer\n   BreakExpr (BreakExpr const &other)\n-    : ExprWithoutBlock (other), label (other.label), locus (other.locus)\n+    : ExprWithoutBlock (other), label (other.label), locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n     if (other.break_expr != nullptr)\n@@ -2655,10 +2626,16 @@ class BreakExpr : public ExprWithoutBlock\n   {\n     ExprWithoutBlock::operator= (other);\n     label = other.label;\n-    break_expr = other.break_expr->clone_expr ();\n     locus = other.locus;\n+    marked_for_strip = other.marked_for_strip;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to protect from null pointer dereference\n+    if (other.break_expr != nullptr)\n+      break_expr = other.break_expr->clone_expr ();\n+    else\n+      break_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2671,11 +2648,11 @@ class BreakExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  BreakExpr *clone_expr_impl () const override { return new BreakExpr (*this); }\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   BreakExpr *clone_expr_without_block_impl () const override\n@@ -2718,16 +2695,29 @@ class RangeFromToExpr : public RangeExpr\n \n   // Copy constructor with cloning\n   RangeFromToExpr (RangeFromToExpr const &other)\n-    : RangeExpr (other), from (other.from->clone_expr ()),\n-      to (other.to->clone_expr ())\n-  {}\n+    : RangeExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.from != nullptr)\n+      from = other.from->clone_expr ();\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone unique pointers\n   RangeFromToExpr &operator= (RangeFromToExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    from = other.from->clone_expr ();\n-    to = other.to->clone_expr ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.from != nullptr)\n+      from = other.from->clone_expr ();\n+    else\n+      from = nullptr;\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+    else\n+      to = nullptr;\n \n     return *this;\n   }\n@@ -2738,14 +2728,11 @@ class RangeFromToExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RangeFromToExpr *clone_expr_impl () const override\n-  {\n-    return new RangeFromToExpr (*this);\n-  }\n+  // Invalid if either expr is null, so base stripping on that. \n+  void mark_for_strip () override { from = nullptr; to = nullptr; }\n+  bool is_marked_for_strip () const override { return from == nullptr && to == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RangeFromToExpr *clone_expr_without_block_impl () const override\n@@ -2769,14 +2756,23 @@ class RangeFromExpr : public RangeExpr\n \n   // Copy constructor with clone\n   RangeFromExpr (RangeFromExpr const &other)\n-    : RangeExpr (other), from (other.from->clone_expr ())\n-  {}\n+    : RangeExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.from != nullptr)\n+      from = other.from->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone unique_ptr\n   RangeFromExpr &operator= (RangeFromExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    from = other.from->clone_expr ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.from != nullptr)\n+      from = other.from->clone_expr ();\n+    else\n+      from = nullptr;\n \n     return *this;\n   }\n@@ -2787,14 +2783,11 @@ class RangeFromExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RangeFromExpr *clone_expr_impl () const override\n-  {\n-    return new RangeFromExpr (*this);\n-  }\n+  // Invalid if expr is null, so base stripping on that. \n+  void mark_for_strip () override { from = nullptr; }\n+  bool is_marked_for_strip () const override { return from == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RangeFromExpr *clone_expr_without_block_impl () const override\n@@ -2819,14 +2812,23 @@ class RangeToExpr : public RangeExpr\n \n   // Copy constructor with clone\n   RangeToExpr (RangeToExpr const &other)\n-    : RangeExpr (other), to (other.to->clone_expr ())\n-  {}\n+    : RangeExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone unique_ptr\n   RangeToExpr &operator= (RangeToExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    to = other.to->clone_expr ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+    else\n+      to = nullptr;\n \n     return *this;\n   }\n@@ -2837,14 +2839,11 @@ class RangeToExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RangeToExpr *clone_expr_impl () const override\n-  {\n-    return new RangeToExpr (*this);\n-  }\n+  // Invalid if expr is null, so base stripping on that. \n+  void mark_for_strip () override { to = nullptr; }\n+  bool is_marked_for_strip () const override { return to == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RangeToExpr *clone_expr_without_block_impl () const override\n@@ -2857,6 +2856,9 @@ class RangeToExpr : public RangeExpr\n // constructs a std::ops::RangeFull object\n class RangeFullExpr : public RangeExpr\n {\n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override;\n \n@@ -2865,14 +2867,11 @@ class RangeFullExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RangeFullExpr *clone_expr_impl () const override\n-  {\n-    return new RangeFullExpr (*this);\n-  }\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RangeFullExpr *clone_expr_without_block_impl () const override\n@@ -2900,16 +2899,29 @@ class RangeFromToInclExpr : public RangeExpr\n \n   // Copy constructor with clone\n   RangeFromToInclExpr (RangeFromToInclExpr const &other)\n-    : RangeExpr (other), from (other.from->clone_expr ()),\n-      to (other.to->clone_expr ())\n-  {}\n+    : RangeExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.from != nullptr)\n+      from = other.from->clone_expr ();\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+  }\n \n   // Overload assignment operator to use clone\n   RangeFromToInclExpr &operator= (RangeFromToInclExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    from = other.from->clone_expr ();\n-    to = other.to->clone_expr ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.from != nullptr)\n+      from = other.from->clone_expr ();\n+    else\n+      from = nullptr;\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+    else\n+      to = nullptr;\n \n     return *this;\n   }\n@@ -2920,14 +2932,11 @@ class RangeFromToInclExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RangeFromToInclExpr *clone_expr_impl () const override\n-  {\n-    return new RangeFromToInclExpr (*this);\n-  }\n+  // Invalid if either expr is null, so base stripping on that. \n+  void mark_for_strip () override { from = nullptr; to = nullptr; }\n+  bool is_marked_for_strip () const override { return from == nullptr && to == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RangeFromToInclExpr *clone_expr_without_block_impl () const override\n@@ -2952,14 +2961,23 @@ class RangeToInclExpr : public RangeExpr\n \n   // Copy constructor with clone\n   RangeToInclExpr (RangeToInclExpr const &other)\n-    : RangeExpr (other), to (other.to->clone_expr ())\n-  {}\n+    : RangeExpr (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone pointer\n   RangeToInclExpr &operator= (RangeToInclExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    to = other.to->clone_expr ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.to != nullptr)\n+      to = other.to->clone_expr ();\n+    else\n+      to = nullptr;\n \n     return *this;\n   }\n@@ -2970,14 +2988,11 @@ class RangeToInclExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RangeToInclExpr *clone_expr_impl () const override\n-  {\n-    return new RangeToInclExpr (*this);\n-  }\n+  // Invalid if expr is null, so base stripping on that. \n+  void mark_for_strip () override { to = nullptr; }\n+  bool is_marked_for_strip () const override { return to == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RangeToInclExpr *clone_expr_without_block_impl () const override\n@@ -2994,6 +3009,9 @@ class ReturnExpr : public ExprWithoutBlock\n \n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n   std::string as_string () const override;\n \n   /* Returns whether the object has an expression returned (i.e. not void return\n@@ -3009,7 +3027,7 @@ class ReturnExpr : public ExprWithoutBlock\n \n   // Copy constructor with clone\n   ReturnExpr (ReturnExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus)\n+    : ExprWithoutBlock (other), locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n     if (other.return_expr != nullptr)\n@@ -3020,10 +3038,16 @@ class ReturnExpr : public ExprWithoutBlock\n   ReturnExpr &operator= (ReturnExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    return_expr = other.return_expr->clone_expr ();\n     locus = other.locus;\n+    marked_for_strip = other.marked_for_strip;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to protect from null pointer dereference\n+    if (other.return_expr != nullptr)\n+      return_expr = other.return_expr->clone_expr ();\n+    else\n+      return_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -3036,14 +3060,11 @@ class ReturnExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ReturnExpr *clone_expr_impl () const override\n-  {\n-    return new ReturnExpr (*this);\n-  }\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ReturnExpr *clone_expr_without_block_impl () const override\n@@ -3074,18 +3095,26 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   // Copy constructor with clone\n   UnsafeBlockExpr (UnsafeBlockExpr const &other)\n-    : ExprWithBlock (other), expr (other.expr->clone_block_expr ()),\n-      locus (other.locus)\n-  {}\n+    : ExprWithBlock (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_block_expr ();\n+  }\n \n   // Overloaded assignment operator to clone\n   UnsafeBlockExpr &operator= (UnsafeBlockExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n-    expr = other.expr->clone_block_expr ();\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_block_expr ();\n+    else\n+      expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -3098,14 +3127,11 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  UnsafeBlockExpr *clone_expr_impl () const override\n-  {\n-    return new UnsafeBlockExpr (*this);\n-  }\n+  // Invalid if block is null, so base stripping on that. \n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   UnsafeBlockExpr *clone_expr_with_block_impl () const override\n@@ -3164,19 +3190,27 @@ class BaseLoopExpr : public ExprWithBlock\n \n   // Copy constructor for BaseLoopExpr with clone\n   BaseLoopExpr (BaseLoopExpr const &other)\n-    : ExprWithBlock (other), loop_label (other.loop_label),\n-      loop_block (other.loop_block->clone_block_expr ()), locus (other.locus)\n-  {}\n+    : ExprWithBlock (other), loop_label (other.loop_label), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.loop_block != nullptr)\n+      loop_block = other.loop_block->clone_block_expr ();\n+  }\n \n   // Overloaded assignment operator to clone\n   BaseLoopExpr &operator= (BaseLoopExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n-    loop_block = other.loop_block->clone_block_expr ();\n     loop_label = other.loop_label;\n     locus = other.locus;\n     // outer_attrs = other.outer_attrs;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.loop_block != nullptr)\n+      loop_block = other.loop_block->clone_block_expr ();\n+    else\n+      loop_block = nullptr;\n+\n     return *this;\n   }\n \n@@ -3189,6 +3223,10 @@ class BaseLoopExpr : public ExprWithBlock\n \n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n+\n+  // Invalid if loop block is null, so base stripping on that. \n+  void mark_for_strip () override { loop_block = nullptr; }\n+  bool is_marked_for_strip () const override { return loop_block == nullptr; }\n };\n \n // 'Loop' expression (i.e. the infinite loop) AST node\n@@ -3208,10 +3246,6 @@ class LoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  LoopExpr *clone_expr_impl () const override { return new LoopExpr (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   LoopExpr *clone_expr_with_block_impl () const override\n@@ -3263,13 +3297,6 @@ class WhileLoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  WhileLoopExpr *clone_expr_impl () const override\n-  {\n-    return new WhileLoopExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   WhileLoopExpr *clone_expr_with_block_impl () const override\n@@ -3336,13 +3363,6 @@ class WhileLetLoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  WhileLetLoopExpr *clone_expr_impl () const override\n-  {\n-    return new WhileLetLoopExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   WhileLetLoopExpr *clone_expr_with_block_impl () const override\n@@ -3398,13 +3418,6 @@ class ForLoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ForLoopExpr *clone_expr_impl () const override\n-  {\n-    return new ForLoopExpr (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ForLoopExpr *clone_expr_with_block_impl () const override\n@@ -3437,18 +3450,31 @@ class IfExpr : public ExprWithBlock\n \n   // Copy constructor with clone\n   IfExpr (IfExpr const &other)\n-    : ExprWithBlock (other), condition (other.condition->clone_expr ()),\n-      if_block (other.if_block->clone_block_expr ()), locus (other.locus)\n-  {}\n+    : ExprWithBlock (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.condition != nullptr)\n+      condition = other.condition->clone_expr ();\n+    if (other.if_block != nullptr)\n+      if_block = other.if_block->clone_block_expr ();\n+  }\n \n   // Overloaded assignment operator to clone expressions\n   IfExpr &operator= (IfExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n-    condition = other.condition->clone_expr ();\n-    if_block = other.if_block->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.condition != nullptr)\n+      condition = other.condition->clone_expr ();\n+    else\n+      condition = nullptr;\n+    if (other.if_block != nullptr)\n+      if_block = other.if_block->clone_block_expr ();\n+    else\n+      if_block = nullptr;\n+\n     return *this;\n   }\n \n@@ -3477,19 +3503,19 @@ class IfExpr : public ExprWithBlock\n   Expr *get_if_condition () { return condition.get (); }\n   BlockExpr *get_if_block () { return if_block.get (); }\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExpr *clone_expr_impl () const override { return new IfExpr (*this); }\n+  // Invalid if if block or condition is null, so base stripping on that. \n+  void mark_for_strip () override { if_block = nullptr; condition = nullptr; }\n+  bool is_marked_for_strip () const override { return if_block == nullptr && condition == nullptr; }\n \n+protected:\n   // Base clone function but still concrete as concrete base class\n   virtual IfExpr *clone_if_expr_impl () const { return new IfExpr (*this); }\n \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n-  IfExpr *clone_expr_with_block_impl () const override\n+  IfExpr *clone_expr_with_block_impl () const final override\n   {\n-    return new IfExpr (*this);\n+    return clone_if_expr_impl ();\n   }\n };\n \n@@ -3534,20 +3560,6 @@ class IfExprConseqElse : public IfExpr\n   void vis_else_block (ASTVisitor &vis) { else_block->accept_vis (vis); }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExprConseqElse *clone_expr_impl () const override\n-  {\n-    return new IfExprConseqElse (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExprConseqElse *clone_expr_with_block_impl () const override\n-  {\n-    return new IfExprConseqElse (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   IfExprConseqElse *clone_if_expr_impl () const override\n@@ -3600,20 +3612,6 @@ class IfExprConseqIf : public IfExpr\n   }\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExprConseqIf *clone_expr_impl () const override\n-  {\n-    return new IfExprConseqIf (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExprConseqIf *clone_expr_with_block_impl () const override\n-  {\n-    return new IfExprConseqIf (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   IfExprConseqIf *clone_if_expr_impl () const override\n@@ -3646,11 +3644,14 @@ class IfLetExpr : public ExprWithBlock\n \n   // copy constructor with clone\n   IfLetExpr (IfLetExpr const &other)\n-    : ExprWithBlock (other),\n-      /*match_arm_patterns(other.match_arm_patterns),*/ value (\n-\tother.value->clone_expr ()),\n-      if_block (other.if_block->clone_block_expr ()), locus (other.locus)\n+    : ExprWithBlock (other), locus (other.locus)\n   {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.value != nullptr)\n+      value = other.value->clone_expr ();\n+    if (other.if_block != nullptr)\n+      if_block = other.if_block->clone_block_expr ();\n+\n     match_arm_patterns.reserve (other.match_arm_patterns.size ());\n     for (const auto &e : other.match_arm_patterns)\n       match_arm_patterns.push_back (e->clone_pattern ());\n@@ -3660,11 +3661,18 @@ class IfLetExpr : public ExprWithBlock\n   IfLetExpr &operator= (IfLetExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n-    // match_arm_patterns = other.match_arm_patterns;\n-    value = other.value->clone_expr ();\n-    if_block = other.if_block->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.value != nullptr)\n+      value = other.value->clone_expr ();\n+    else\n+      value = nullptr;\n+    if (other.if_block != nullptr)\n+      if_block = other.if_block->clone_block_expr ();\n+    else\n+      if_block = nullptr;\n+\n     match_arm_patterns.reserve (other.match_arm_patterns.size ());\n     for (const auto &e : other.match_arm_patterns)\n       match_arm_patterns.push_back (e->clone_pattern ());\n@@ -3687,16 +3695,16 @@ class IfLetExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExpr *clone_expr_impl () const override { return new IfLetExpr (*this); }\n+  // Invalid if block or value is null, so base stripping on that. \n+  void mark_for_strip () override { if_block = nullptr; value = nullptr; }\n+  bool is_marked_for_strip () const override { return if_block == nullptr && value == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExpr *clone_expr_with_block_impl () const override\n+   * than base (or rather this or any derived object) */\n+  IfLetExpr *clone_expr_with_block_impl () const final override\n   {\n-    return new IfLetExpr (*this);\n+    return clone_if_let_expr_impl ();\n   }\n \n   // Base clone function but still concrete as concrete base class\n@@ -3746,20 +3754,6 @@ class IfExprConseqIfLet : public IfExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExprConseqIfLet *clone_expr_impl () const override\n-  {\n-    return new IfExprConseqIfLet (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfExprConseqIfLet *clone_expr_with_block_impl () const override\n-  {\n-    return new IfExprConseqIfLet (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   IfExprConseqIfLet *clone_if_expr_impl () const override\n@@ -3812,20 +3806,6 @@ class IfLetExprConseqElse : public IfLetExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExprConseqElse *clone_expr_impl () const override\n-  {\n-    return new IfLetExprConseqElse (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExprConseqElse *clone_expr_with_block_impl () const override\n-  {\n-    return new IfLetExprConseqElse (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   IfLetExprConseqElse *clone_if_let_expr_impl () const override\n@@ -3877,20 +3857,6 @@ class IfLetExprConseqIf : public IfLetExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExprConseqIf *clone_expr_impl () const override\n-  {\n-    return new IfLetExprConseqIf (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExprConseqIf *clone_expr_with_block_impl () const override\n-  {\n-    return new IfLetExprConseqIf (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   IfLetExprConseqIf *clone_if_let_expr_impl () const override\n@@ -3942,20 +3908,6 @@ class IfLetExprConseqIfLet : public IfLetExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExprConseqIfLet *clone_expr_impl () const override\n-  {\n-    return new IfLetExprConseqIfLet (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  IfLetExprConseqIfLet *clone_expr_with_block_impl () const override\n-  {\n-    return new IfLetExprConseqIfLet (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   IfLetExprConseqIfLet *clone_if_let_expr_impl () const override\n@@ -4012,6 +3964,8 @@ struct MatchArm\n \n     if (other.guard_expr != nullptr)\n       guard_expr = other.guard_expr->clone_expr ();\n+    else\n+      guard_expr = nullptr;\n \n     match_arm_patterns.reserve (other.match_arm_patterns.size ());\n     for (const auto &e : other.match_arm_patterns)\n@@ -4224,10 +4178,13 @@ class MatchExpr : public ExprWithBlock\n \n   // Copy constructor requires clone due to unique_ptr\n   MatchExpr (MatchExpr const &other)\n-    : ExprWithBlock (other), branch_value (other.branch_value->clone_expr ()),\n-      inner_attrs (other.inner_attrs), match_arms (other.match_arms),\n-      locus (other.locus)\n+    : ExprWithBlock (other), inner_attrs (other.inner_attrs), \n+      match_arms (other.match_arms), locus (other.locus)\n   {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.branch_value != nullptr)\n+      branch_value = other.branch_value->clone_expr ();\n+\n     /*match_arms.reserve (other.match_arms.size ());\n     for (const auto &e : other.match_arms)\n       match_arms.push_back (e->clone_match_case ());*/\n@@ -4237,12 +4194,17 @@ class MatchExpr : public ExprWithBlock\n   MatchExpr &operator= (MatchExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n-    branch_value = other.branch_value->clone_expr ();\n     inner_attrs = other.inner_attrs;\n     match_arms = other.match_arms;\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.branch_value != nullptr)\n+      branch_value = other.branch_value->clone_expr ();\n+    else\n+      branch_value = nullptr;\n+\n     /*match_arms.reserve (other.match_arms.size ());\n     for (const auto &e : other.match_arms)\n       match_arms.push_back (e->clone_match_case ());*/\n@@ -4259,11 +4221,11 @@ class MatchExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MatchExpr *clone_expr_impl () const override { return new MatchExpr (*this); }\n+  // Invalid if branch value is null, so base stripping on that. \n+  void mark_for_strip () override { branch_value = nullptr; }\n+  bool is_marked_for_strip () const override { return branch_value == nullptr; }\n \n+protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MatchExpr *clone_expr_with_block_impl () const override\n@@ -4289,17 +4251,25 @@ class AwaitExpr : public ExprWithoutBlock\n \n   // copy constructor with clone\n   AwaitExpr (AwaitExpr const &other)\n-    : ExprWithoutBlock (other),\n-      awaited_expr (other.awaited_expr->clone_expr ()), locus (other.locus)\n-  {}\n+    : ExprWithoutBlock (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.awaited_expr != nullptr)\n+      awaited_expr = other.awaited_expr->clone_expr ();\n+  }\n \n   // overloaded assignment operator with clone\n   AwaitExpr &operator= (AwaitExpr const &other)\n   {\n     ExprWithoutBlock::operator= (other);\n-    awaited_expr = other.awaited_expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.awaited_expr != nullptr)\n+      awaited_expr = other.awaited_expr->clone_expr ();\n+    else\n+      awaited_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -4314,6 +4284,10 @@ class AwaitExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if awaited expr is null, so base stripping on that. \n+  void mark_for_strip () override { awaited_expr = nullptr; }\n+  bool is_marked_for_strip () const override { return awaited_expr == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -4341,18 +4315,26 @@ class AsyncBlockExpr : public ExprWithBlock\n \n   // copy constructor with clone\n   AsyncBlockExpr (AsyncBlockExpr const &other)\n-    : ExprWithBlock (other), has_move (other.has_move),\n-      block_expr (other.block_expr->clone_block_expr ()), locus (other.locus)\n-  {}\n+    : ExprWithBlock (other), has_move (other.has_move), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.block_expr != nullptr)\n+      block_expr = other.block_expr->clone_block_expr ();\n+  }\n \n   // overloaded assignment operator to clone\n   AsyncBlockExpr &operator= (AsyncBlockExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n     has_move = other.has_move;\n-    block_expr = other.block_expr->clone_block_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.block_expr != nullptr)\n+      block_expr = other.block_expr->clone_block_expr ();\n+    else\n+      block_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -4367,6 +4349,10 @@ class AsyncBlockExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if block is null, so base stripping on that. \n+  void mark_for_strip () override { block_expr = nullptr; }\n+  bool is_marked_for_strip () const override { return block_expr == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "c35e65fdcbe9e060bafe4d6520e4b9ebf6a6fcb9", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 183, "deletions": 136, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -715,24 +715,24 @@ class Method : public InherentImplItem, public TraitImplItem\n class VisItem : public Item\n {\n   Visibility visibility;\n+  std::vector<Attribute> outer_attrs;\n \n protected:\n   // Visibility constructor\n   VisItem (Visibility visibility,\n \t   std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : Item (std::move (outer_attrs)), visibility (std::move (visibility))\n+    : visibility (std::move (visibility)), outer_attrs(std::move (outer_attrs))\n   {}\n \n   // Visibility copy constructor\n-  VisItem (VisItem const &other) : Item (other), visibility (other.visibility)\n+  VisItem (VisItem const &other) : visibility (other.visibility), outer_attrs(other.outer_attrs)\n   {}\n \n   // Overload assignment operator to clone\n   VisItem &operator= (VisItem const &other)\n   {\n-    Item::operator= (other);\n     visibility = other.visibility;\n-    // outer_attrs = other.outer_attrs;\n+    outer_attrs = other.outer_attrs;\n \n     return *this;\n   }\n@@ -747,6 +747,13 @@ class VisItem : public Item\n   bool has_visibility () const { return !visibility.is_error (); }\n \n   std::string as_string () const override;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  Visibility &get_vis () { return visibility; }\n+  const Visibility &get_vis () const { return visibility; }\n+\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n };\n \n // Rust module item - abstract base class\n@@ -767,6 +774,10 @@ class Module : public VisItem\n   std::string as_string () const override;\n \n   Location get_locus () const { return locus; }\n+\n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { module_name = \"\"; }\n+  bool is_marked_for_strip () const override { return module_name.empty (); }\n };\n \n // Module with a body, defined in file\n@@ -837,17 +848,14 @@ class ModuleBodied : public Module\n   {\n     return new ModuleBodied (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ModuleBodied* clone_statement_impl() const override {\n-      return new ModuleBodied(*this);\n-  }*/\n };\n \n // Module without a body, loaded from external file\n class ModuleNoBody : public Module\n {\n+  /* TODO: are modules loaded from file unique? As in, can you load the same file into two different\n+   * other files? Because this may make the difference between simply replacing this with the module\n+   * \"definition\" (as loaded from another file) vs this having to \"reference\" a module with body. */\n public:\n   std::string as_string () const override;\n \n@@ -867,12 +875,6 @@ class ModuleNoBody : public Module\n   {\n     return new ModuleNoBody (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ModuleNoBody* clone_statement_impl() const override {\n-      return new ModuleNoBody(*this);\n-  }*/\n };\n \n // Rust extern crate declaration AST node\n@@ -920,19 +922,17 @@ class ExternCrate : public VisItem\n     names.push_back (referenced_crate);\n   }\n \n+  // Invalid if crate name is empty, so base stripping on that.\n+  void mark_for_strip () override { referenced_crate = \"\"; }\n+  bool is_marked_for_strip () const override { return referenced_crate.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   ExternCrate *clone_item_impl () const override\n   {\n     return new ExternCrate (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ExternCrate* clone_statement_impl() const override {\n-      return new ExternCrate(*this);\n-  }*/\n };\n \n // The path-ish thing referred to in a use declaration - abstract base class\n@@ -1153,19 +1153,27 @@ class UseDeclaration : public VisItem\n \n   // Copy constructor with clone\n   UseDeclaration (UseDeclaration const &other)\n-    : VisItem (other), use_tree (other.use_tree->clone_use_tree ()),\n-      locus (other.locus)\n-  {}\n+    : VisItem (other), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.use_tree != nullptr)\n+      use_tree = other.use_tree->clone_use_tree ();\n+  }\n \n   // Overloaded assignment operator to clone\n   UseDeclaration &operator= (UseDeclaration const &other)\n   {\n     VisItem::operator= (other);\n-    use_tree = other.use_tree->clone_use_tree ();\n     // visibility = other.visibility->clone_visibility();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.use_tree != nullptr)\n+      use_tree = other.use_tree->clone_use_tree ();\n+    else\n+      use_tree = nullptr;\n+\n     return *this;\n   }\n \n@@ -1177,19 +1185,17 @@ class UseDeclaration : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if use tree is null, so base stripping on that.\n+  void mark_for_strip () override { use_tree = nullptr; }\n+  bool is_marked_for_strip () const override { return use_tree == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   UseDeclaration *clone_item_impl () const override\n   {\n     return new UseDeclaration (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual UseDeclaration* clone_statement_impl() const override {\n-      return new UseDeclaration(*this);\n-  }*/\n };\n \n // Parameters used in a function - TODO inline?\n@@ -1264,11 +1270,16 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     : VisItem (other), qualifiers (other.qualifiers),\n       function_name (other.function_name),\n       function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause),\n-      function_body (other.function_body->clone_block_expr ()),\n-      locus (other.locus)\n+      where_clause (other.where_clause), locus (other.locus)\n   {\n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1280,15 +1291,24 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     VisItem::operator= (other);\n     function_name = other.function_name;\n     qualifiers = other.qualifiers;\n-    // generic_params = other.generic_params;\n     function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n-    function_body = other.function_body->clone_block_expr ();\n     // visibility = other.visibility->clone_visibility();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (always required)\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.function_body != nullptr)\n+      function_body = other.function_body->clone_block_expr ();\n+    else\n+      function_body = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1304,6 +1324,10 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if block is null, so base stripping on that.\n+  void mark_for_strip () override { function_body = nullptr; }\n+  bool is_marked_for_strip () const override { return function_body == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1322,12 +1346,6 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   {\n     return new Function (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Function* clone_statement_impl() const override {\n-      return new Function(*this);\n-  }*/\n };\n \n // Rust type alias (i.e. typedef) AST node\n@@ -1370,9 +1388,12 @@ class TypeAlias : public VisItem, public TraitImplItem\n   // Copy constructor\n   TypeAlias (TypeAlias const &other)\n     : VisItem (other), new_type_name (other.new_type_name),\n-      where_clause (other.where_clause),\n-      existing_type (other.existing_type->clone_type ()), locus (other.locus)\n+      where_clause (other.where_clause), locus (other.locus)\n   {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.existing_type != nullptr)\n+      existing_type = other.existing_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1383,13 +1404,17 @@ class TypeAlias : public VisItem, public TraitImplItem\n   {\n     VisItem::operator= (other);\n     new_type_name = other.new_type_name;\n-    // generic_params = other.generic_params;\n     where_clause = other.where_clause;\n-    existing_type = other.existing_type->clone_type ();\n     // visibility = other.visibility->clone_visibility();\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.existing_type != nullptr)\n+      existing_type = other.existing_type->clone_type ();\n+    else\n+      existing_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -1405,6 +1430,10 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if existing type is null, so base stripping on that.\n+  void mark_for_strip () override { existing_type = nullptr; }\n+  bool is_marked_for_strip () const override { return existing_type == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1416,12 +1445,6 @@ class TypeAlias : public VisItem, public TraitImplItem\n   {\n     return new TypeAlias (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TypeAlias* clone_statement_impl() const override {\n-      return new TypeAlias(*this);\n-  }*/\n };\n \n // Rust base struct declaration AST node - abstract base class\n@@ -1448,6 +1471,10 @@ class Struct : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { struct_name = \"\"; }\n+  bool is_marked_for_strip () const override { return struct_name.empty (); }\n+\n protected:\n   Struct (Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -1584,8 +1611,7 @@ class StructStruct : public Struct\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n \t      std::move (where_clause), std::move (vis), locus,\n-\t      std::move (outer_attrs)),\n-      is_unit (true)\n+\t      std::move (outer_attrs)), is_unit (true)\n   {}\n   // TODO: can a unit struct have generic fields? assuming yes for now.\n \n@@ -1603,12 +1629,6 @@ class StructStruct : public Struct\n   {\n     return new StructStruct (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual StructStruct* clone_statement_impl() const override {\n-      return new StructStruct(*this);\n-  }*/\n };\n \n // A single field in a tuple\n@@ -1702,12 +1722,6 @@ class TupleStruct : public Struct\n   {\n     return new TupleStruct (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TupleStruct* clone_statement_impl() const override {\n-      return new TupleStruct(*this);\n-  }*/\n };\n \n /* An item used in an \"enum\" tagged union - not abstract: base represents a\n@@ -1937,16 +1951,14 @@ class Enum : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { enum_name = \"\"; }\n+  bool is_marked_for_strip () const override { return enum_name.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Enum *clone_item_impl () const override { return new Enum (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Enum* clone_statement_impl() const override {\n-      return new Enum(*this);\n-  }*/\n };\n \n // Rust untagged union used for C compat AST node\n@@ -2020,16 +2032,14 @@ class Union : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { union_name = \"\"; }\n+  bool is_marked_for_strip () const override { return union_name.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Union *clone_item_impl () const override { return new Union (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Union* clone_statement_impl() const override {\n-      return new Union(*this);\n-  }*/\n };\n \n /* \"Constant item\" AST node - used for constant, compile-time expressions\n@@ -2041,7 +2051,7 @@ class ConstantItem : public VisItem,\n   // either has an identifier or \"_\" - maybe handle in identifier?\n   // bool identifier_is_underscore;\n   // if no identifier declared, identifier will be \"_\"\n-  Identifier identifier;\n+  std::string identifier;\n \n   std::unique_ptr<Type> type;\n   std::unique_ptr<Expr> const_expr;\n@@ -2051,7 +2061,7 @@ class ConstantItem : public VisItem,\n public:\n   std::string as_string () const override;\n \n-  ConstantItem (Identifier ident, Visibility vis, std::unique_ptr<Type> type,\n+  ConstantItem (std::string ident, Visibility vis, std::unique_ptr<Type> type,\n \t\tstd::unique_ptr<Expr> const_expr,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -2060,20 +2070,32 @@ class ConstantItem : public VisItem,\n   {}\n \n   ConstantItem (ConstantItem const &other)\n-    : VisItem (other), identifier (other.identifier),\n-      type (other.type->clone_type ()),\n-      const_expr (other.const_expr->clone_expr ()), locus (other.locus)\n-  {}\n+    : VisItem (other), identifier (other.identifier), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    if (other.const_expr != nullptr)\n+      const_expr = other.const_expr->clone_expr ();\n+  }\n \n   // Overload assignment operator to clone\n   ConstantItem &operator= (ConstantItem const &other)\n   {\n     VisItem::operator= (other);\n     identifier = other.identifier;\n-    type = other.type->clone_type ();\n-    const_expr = other.const_expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+    if (other.const_expr != nullptr)\n+      const_expr = other.const_expr->clone_expr ();\n+    else\n+      const_expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2083,12 +2105,16 @@ class ConstantItem : public VisItem,\n \n   /* Returns whether constant item is an \"unnamed\" (wildcard underscore used\n    * as identifier) constant. */\n-  bool is_unnamed () const { return identifier == std::string (\"_\"); }\n+  bool is_unnamed () const { return identifier == \"_\"; }\n \n   Location get_locus () const { return locus; }\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if type or expression are null, so base stripping on that.\n+  void mark_for_strip () override { type = nullptr; const_expr = nullptr; }\n+  bool is_marked_for_strip () const override { return type == nullptr && const_expr == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2110,12 +2136,6 @@ class ConstantItem : public VisItem,\n   {\n     return new ConstantItem (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ConstantItem* clone_statement_impl() const override {\n-      return new ConstantItem(*this);\n-  }*/\n };\n \n /* Static item AST node - items within module scope with fixed storage\n@@ -2142,20 +2162,33 @@ class StaticItem : public VisItem\n   // Copy constructor with clone\n   StaticItem (StaticItem const &other)\n     : VisItem (other), has_mut (other.has_mut), name (other.name),\n-      type (other.type->clone_type ()), expr (other.expr->clone_expr ()),\n       locus (other.locus)\n-  {}\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+  }\n \n   // Overloaded assignment operator to clone\n   StaticItem &operator= (StaticItem const &other)\n   {\n     VisItem::operator= (other);\n     name = other.name;\n     has_mut = other.has_mut;\n-    type = other.type->clone_type ();\n-    expr = other.expr->clone_expr ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr ();\n+    else\n+      expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -2167,19 +2200,17 @@ class StaticItem : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if type or expression are null, so base stripping on that.\n+  void mark_for_strip () override { type = nullptr; expr = nullptr; }\n+  bool is_marked_for_strip () const override { return type == nullptr && expr == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   StaticItem *clone_item_impl () const override\n   {\n     return new StaticItem (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual StaticItem* clone_statement_impl() const override {\n-      return new StaticItem(*this);\n-  }*/\n };\n \n // Function declaration in traits\n@@ -2606,7 +2637,6 @@ class TraitItemType : public TraitItem\n class Trait : public VisItem\n {\n   bool has_unsafe;\n-\n   Identifier name;\n \n   // bool has_generics;\n@@ -2706,16 +2736,14 @@ class Trait : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if trait name is empty, so base stripping on that.\n+  void mark_for_strip () override { name = \"\"; }\n+  bool is_marked_for_strip () const override { return name.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   Trait *clone_item_impl () const override { return new Trait (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual Trait* clone_statement_impl() const override {\n-      return new Trait(*this);\n-  }*/\n };\n \n // Implementation item declaration AST node - abstract base class\n@@ -2751,6 +2779,10 @@ class Impl : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  // Invalid if trait type is null, so base stripping on that.\n+  void mark_for_strip () override { trait_type = nullptr; }\n+  bool is_marked_for_strip () const override { return trait_type == nullptr; }\n+\n protected:\n   // Mega-constructor\n   Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -2766,10 +2798,13 @@ class Impl : public VisItem\n \n   // Copy constructor\n   Impl (Impl const &other)\n-    : VisItem (other), trait_type (other.trait_type->clone_type ()),\n-      where_clause (other.where_clause), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+    : VisItem (other), where_clause (other.where_clause), \n+      inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.trait_type != nullptr)\n+      trait_type = other.trait_type->clone_type ();\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2779,11 +2814,16 @@ class Impl : public VisItem\n   Impl &operator= (Impl const &other)\n   {\n     VisItem::operator= (other);\n-    trait_type = other.trait_type->clone_type ();\n     where_clause = other.where_clause;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.trait_type != nullptr)\n+      trait_type = other.trait_type->clone_type ();\n+    else\n+      trait_type = nullptr;\n+\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n       generic_params.push_back (e->clone_generic_param ());\n@@ -2853,12 +2893,6 @@ class InherentImpl : public Impl\n   {\n     return new InherentImpl (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual InherentImpl* clone_statement_impl() const override {\n-      return new InherentImpl(*this);\n-  }*/\n };\n \n // The \"impl footrait for foo\" impl block declaration AST node\n@@ -2928,12 +2962,6 @@ class TraitImpl : public Impl\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   TraitImpl *clone_item_impl () const override { return new TraitImpl (*this); }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual TraitImpl* clone_statement_impl() const override {\n-      return new TraitImpl(*this);\n-  }*/\n };\n \n // Abstract base class for an item used inside an extern block\n@@ -2951,6 +2979,10 @@ class ExternalItem\n public:\n   virtual ~ExternalItem () {}\n \n+  /* TODO: spec syntax rules state that \"MacroInvocationSemi\" can be used as \n+   * ExternalItem, but text body isn't so clear. Adding MacroInvocationSemi \n+   * support would require a lot of refactoring. */\n+\n   // Returns whether item has outer attributes.\n   bool has_outer_attrs () const { return !outer_attrs.empty (); }\n \n@@ -2969,6 +3001,11 @@ class ExternalItem\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  // TODO: make virtual? Would be more flexible.\n+  // Based on idea that name should never be empty.\n+  void mark_for_strip () { item_name = \"\"; };\n+  bool is_marked_for_strip () const { return item_name.empty (); };\n+\n protected:\n   ExternalItem (Identifier item_name, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3209,6 +3246,9 @@ class ExternBlock : public VisItem\n   std::vector<std::unique_ptr<ExternalItem>> extern_items;\n \n   Location locus;\n+  \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n \n public:\n   std::string as_string () const override;\n@@ -3234,7 +3274,7 @@ class ExternBlock : public VisItem\n   // Copy constructor with vector clone\n   ExternBlock (ExternBlock const &other)\n     : VisItem (other), abi (other.abi), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+      locus (other.locus), marked_for_strip (other.marked_for_strip)\n   {\n     extern_items.reserve (other.extern_items.size ());\n     for (const auto &e : other.extern_items)\n@@ -3248,6 +3288,7 @@ class ExternBlock : public VisItem\n     abi = other.abi;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;\n+    marked_for_strip = other.marked_for_strip;\n \n     extern_items.reserve (other.extern_items.size ());\n     for (const auto &e : other.extern_items)\n@@ -3264,19 +3305,25 @@ class ExternBlock : public VisItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n+  // TODO: think of better way to do this\n+  const std::vector<std::unique_ptr<ExternalItem>>& get_extern_items () const { return extern_items; }\n+  std::vector<std::unique_ptr<ExternalItem>>& get_extern_items () { return extern_items; }\n+\n+  // TODO: think of better way to do this\n+  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n   ExternBlock *clone_item_impl () const override\n   {\n     return new ExternBlock (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  /*virtual ExternBlock* clone_statement_impl() const override {\n-      return new ExternBlock(*this);\n-  }*/\n };\n \n // Replaced with forward decls - defined in \"rust-macro.h\""}, {"sha": "8d50b8897c8359bf610099a86bf507a202b7c26d", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -124,7 +124,7 @@ class MacroMatchRepetition : public MacroMatch\n \n public:\n   // Returns whether macro match repetition has separator token.\n-  bool has_sep () const { return sep != NULL; }\n+  bool has_sep () const { return sep != nullptr; }\n \n   MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n \t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n@@ -133,8 +133,12 @@ class MacroMatchRepetition : public MacroMatch\n \n   // Copy constructor with clone\n   MacroMatchRepetition (MacroMatchRepetition const &other)\n-    : op (other.op), sep (other.sep->clone_token ())\n+    : op (other.op)\n   {\n+    // guard to protect from null pointer dereference\n+    if (other.sep != nullptr)\n+      sep = other.sep->clone_token ();\n+\n     matches.reserve (other.matches.size ());\n     for (const auto &e : other.matches)\n       matches.push_back (e->clone_macro_match ());\n@@ -144,7 +148,12 @@ class MacroMatchRepetition : public MacroMatch\n   MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n   {\n     op = other.op;\n-    sep = other.sep->clone_token ();\n+\n+    // guard to protect from null pointer dereference\n+    if (other.sep != nullptr)\n+      sep = other.sep->clone_token ();\n+    else\n+      sep = nullptr;\n \n     matches.reserve (other.matches.size ());\n     for (const auto &e : other.matches)\n@@ -280,8 +289,9 @@ struct MacroRule\n // A macro rules definition item AST node\n class MacroRulesDefinition : public MacroItem\n {\n+  std::vector<Attribute> outer_attrs;\n   Identifier rule_name;\n-  // MacroRulesDef rules_def; // TODO: inline\n+  // MacroRulesDef rules_def; \n   // only curly without required semicolon at end\n   DelimType delim_type;\n   // MacroRules rules;\n@@ -295,12 +305,16 @@ class MacroRulesDefinition : public MacroItem\n   MacroRulesDefinition (Identifier rule_name, DelimType delim_type,\n \t\t\tstd::vector<MacroRule> rules,\n \t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n-    : MacroItem (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n+    : outer_attrs (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n       delim_type (delim_type), rules (std::move (rules)), locus (locus)\n   {}\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if rule name is empty, so base stripping on that.\n+  void mark_for_strip () override { rule_name = \"\"; }\n+  bool is_marked_for_strip () const override { return rule_name.empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -334,35 +348,25 @@ class MacroInvocation : public TypeNoBounds,\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () override { path = SimplePath::create_empty (); }\n+  bool is_marked_for_strip () const override { return path.is_empty (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocation *clone_pattern_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_expr_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n+  \n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocation *clone_expr_without_block_impl () const override\n   {\n     return new MacroInvocation (*this);\n   }\n \n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  MacroInvocation *clone_type_impl () const override\n-  {\n-    return new MacroInvocation (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocation *clone_type_no_bounds_impl () const override"}, {"sha": "32147d3673aabbf86d976099b82890ea9bc8f659", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -70,9 +70,12 @@ struct GenericArgsBinding\n \n   // Copy constructor has to deep copy the type as it is a unique pointer\n   GenericArgsBinding (GenericArgsBinding const &other)\n-    : identifier (other.identifier), type (other.type->clone_type ()),\n-      locus (other.locus)\n-  {}\n+    : identifier (other.identifier), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // default destructor\n   ~GenericArgsBinding () = default;\n@@ -81,8 +84,14 @@ struct GenericArgsBinding\n   GenericArgsBinding &operator= (GenericArgsBinding const &other)\n   {\n     identifier = other.identifier;\n-    type = other.type->clone_type ();\n     locus = other.locus;\n+\n+    // guard to protect from null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -231,6 +240,9 @@ class PathPattern : public Pattern\n    * and creates a SimplePath from them. */\n   SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n \n+  // Removes all segments of the path.\n+  void remove_all_segments () { segments.clear (); segments.shrink_to_fit (); }\n+\n public:\n   /* Returns whether the path is a single segment (excluding qualified path\n    * initial as segment). */\n@@ -286,6 +298,10 @@ class PathInExpression : public PathPattern, public PathExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if path is empty (error state), so base stripping on that.\n+  void mark_for_strip () override { remove_all_segments (); }\n+  bool is_marked_for_strip () const override { return is_error (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -444,13 +460,6 @@ struct TypePathFunction\n   // Creates an error state function.\n   static TypePathFunction create_error () { return TypePathFunction (true); }\n \n-  // Constructor\n-  TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n-\t\t    Type *type = nullptr)\n-    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n-  {}\n-  // FIXME: deprecated\n-\n   // Constructor\n   TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n \t\t    std::unique_ptr<Type> type = nullptr)\n@@ -460,9 +469,12 @@ struct TypePathFunction\n \n   // Copy constructor with clone\n   TypePathFunction (TypePathFunction const &other)\n-    : return_type (other.return_type->clone_type ()),\n-      is_invalid (other.is_invalid)\n+    : is_invalid (other.is_invalid)\n   {\n+    // guard to protect from null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n       inputs.push_back (e->clone_type ());\n@@ -473,9 +485,14 @@ struct TypePathFunction\n   // Overloaded assignment operator to clone type\n   TypePathFunction &operator= (TypePathFunction const &other)\n   {\n-    return_type = other.return_type->clone_type ();\n     is_invalid = other.is_invalid;\n \n+    // guard to protect from null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n     inputs.reserve (other.inputs.size ());\n     for (const auto &e : other.inputs)\n       inputs.push_back (e->clone_type ());\n@@ -537,10 +554,6 @@ class TypePath : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TypePath *clone_type_impl () const override { return new TypePath (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TypePath *clone_type_no_bounds_impl () const override\n@@ -635,19 +648,28 @@ struct QualifiedPathType\n \n   // Copy constructor uses custom deep copy for Type to preserve polymorphism\n   QualifiedPathType (QualifiedPathType const &other)\n-    : type_to_invoke_on (other.type_to_invoke_on->clone_type ()),\n-      trait_path (other.trait_path), locus (other.locus)\n-  {}\n+    : trait_path (other.trait_path), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.type_to_invoke_on != nullptr)\n+      type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+  }\n \n   // default destructor\n   ~QualifiedPathType () = default;\n \n   // overload assignment operator to use custom clone method\n   QualifiedPathType &operator= (QualifiedPathType const &other)\n   {\n-    type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n     trait_path = other.trait_path;\n     locus = other.locus;\n+\n+    // guard to prevent null dereference\n+    if (other.type_to_invoke_on != nullptr)\n+      type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+    else\n+      type_to_invoke_on = nullptr;\n+\n     return *this;\n   }\n \n@@ -710,6 +732,10 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if path_type is error, so base stripping on that.\n+  void mark_for_strip () override { path_type = QualifiedPathType::create_error (); }\n+  bool is_marked_for_strip () const override { return is_error (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -735,13 +761,6 @@ class QualifiedPathInType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  QualifiedPathInType *clone_type_impl () const override\n-  {\n-    return new QualifiedPathInType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   QualifiedPathInType *clone_type_no_bounds_impl () const override"}, {"sha": "63abe7a44d54f152ba6200030e4076443dc707d7", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -77,7 +77,7 @@ class IdentifierPattern : public Pattern\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),\n       is_mut (other.is_mut), locus (other.locus)\n   {\n-    // fix to get prevent null pointer dereference\n+    // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n   }\n@@ -90,9 +90,11 @@ class IdentifierPattern : public Pattern\n     is_mut = other.is_mut;\n     locus = other.locus;\n \n-    // fix to get prevent null pointer dereference\n+    // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n+    else \n+      to_bind = nullptr;\n \n     return *this;\n   }\n@@ -1006,15 +1008,24 @@ class TuplePattern : public Pattern\n \n   // Copy constructor requires clone\n   TuplePattern (TuplePattern const &other)\n-    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n-  {}\n+    : locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_pattern_items ();\n+  }\n \n   // Overload assignment operator to clone\n   TuplePattern &operator= (TuplePattern const &other)\n   {\n-    items = other.items->clone_tuple_pattern_items ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_pattern_items ();\n+    else\n+      items = nullptr;\n+\n     return *this;\n   }\n "}, {"sha": "127ea2148f36a8b99d121571dee7be351fbddb49", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 71, "deletions": 14, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -12,6 +12,9 @@ class EmptyStmt : public Stmt\n {\n   Location locus;\n \n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n public:\n   std::string as_string () const override { return std::string (1, ';'); }\n \n@@ -21,6 +24,10 @@ class EmptyStmt : public Stmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -68,21 +75,41 @@ class LetStmt : public Stmt\n \n   // Copy constructor with clone\n   LetStmt (LetStmt const &other)\n-    : outer_attrs (other.outer_attrs),\n-      variables_pattern (other.variables_pattern->clone_pattern ()),\n-      type (other.type->clone_type ()),\n-      init_expr (other.init_expr->clone_expr ()), locus (other.locus)\n-  {}\n+    : outer_attrs (other.outer_attrs), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+    \n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n \n   // Overloaded assignment operator to clone\n   LetStmt &operator= (LetStmt const &other)\n   {\n-    variables_pattern = other.variables_pattern->clone_pattern ();\n-    init_expr = other.init_expr->clone_expr ();\n-    type = other.type->clone_type ();\n     outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+    else\n+      variables_pattern = nullptr;\n+    \n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    else\n+      init_expr = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     return *this;\n   }\n \n@@ -94,6 +121,10 @@ class LetStmt : public Stmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if pattern is null, so base stripping on that.\n+  void mark_for_strip () override { variables_pattern = nullptr; }\n+  bool is_marked_for_strip () const override { return variables_pattern == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -138,8 +169,12 @@ class ExprStmtWithoutBlock : public ExprStmt\n \n   // Copy constructor with clone\n   ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n-    : ExprStmt (other), expr (other.expr->clone_expr_without_block ())\n-  {}\n+    : ExprStmt (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+  }\n   /*ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n     : ExprStmt (other), expr (other.expr->clone_expr ())\n   {}*/\n@@ -148,9 +183,14 @@ class ExprStmtWithoutBlock : public ExprStmt\n   ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    expr = other.expr->clone_expr_without_block ();\n     //expr = other.expr->clone_expr ();\n \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+    else\n+      expr = nullptr;\n+\n     return *this;\n   }\n \n@@ -160,6 +200,10 @@ class ExprStmtWithoutBlock : public ExprStmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -185,14 +229,23 @@ class ExprStmtWithBlock : public ExprStmt\n \n   // Copy constructor with clone\n   ExprStmtWithBlock (ExprStmtWithBlock const &other)\n-    : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n-  {}\n+    : ExprStmt (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_with_block ();\n+  }\n \n   // Overloaded assignment operator to clone\n   ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    expr = other.expr->clone_expr_with_block ();\n+    \n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_with_block ();\n+    else\n+      expr = nullptr;\n \n     return *this;\n   }\n@@ -203,6 +256,10 @@ class ExprStmtWithBlock : public ExprStmt\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "78b57ebd204077f7f87778be0ebafdedb0932e04", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 24, "deletions": 74, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -175,13 +175,6 @@ class ParenthesisedType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ParenthesisedType *clone_type_impl () const override\n-  {\n-    return new ParenthesisedType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ParenthesisedType *clone_type_no_bounds_impl () const override\n@@ -240,13 +233,6 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ImplTraitTypeOneBound *clone_type_impl () const override\n-  {\n-    return new ImplTraitTypeOneBound (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n@@ -276,13 +262,6 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TraitObjectTypeOneBound *clone_type_impl () const override\n-  {\n-    return new TraitObjectTypeOneBound (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n@@ -360,10 +339,6 @@ class TupleType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TupleType *clone_type_impl () const override { return new TupleType (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   TupleType *clone_type_no_bounds_impl () const override\n@@ -380,10 +355,6 @@ class NeverType : public TypeNoBounds\n   Location locus;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  NeverType *clone_type_impl () const override { return new NeverType (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   NeverType *clone_type_no_bounds_impl () const override\n@@ -453,13 +424,6 @@ class RawPointerType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  RawPointerType *clone_type_impl () const override\n-  {\n-    return new RawPointerType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   RawPointerType *clone_type_no_bounds_impl () const override\n@@ -520,13 +484,6 @@ class ReferenceType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ReferenceType *clone_type_impl () const override\n-  {\n-    return new ReferenceType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ReferenceType *clone_type_no_bounds_impl () const override\n@@ -575,10 +532,6 @@ class ArrayType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  ArrayType *clone_type_impl () const override { return new ArrayType (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   ArrayType *clone_type_no_bounds_impl () const override\n@@ -625,10 +578,6 @@ class SliceType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  SliceType *clone_type_impl () const override { return new SliceType (*this); }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   SliceType *clone_type_no_bounds_impl () const override\n@@ -645,13 +594,6 @@ class InferredType : public TypeNoBounds\n \n   // e.g. Vec<_> = whatever\n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  InferredType *clone_type_impl () const override\n-  {\n-    return new InferredType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   InferredType *clone_type_no_bounds_impl () const override\n@@ -699,9 +641,12 @@ struct MaybeNamedParam\n \n   // Copy constructor with clone\n   MaybeNamedParam (MaybeNamedParam const &other)\n-    : param_type (other.param_type->clone_type ()),\n-      param_kind (other.param_kind), name (other.name), locus (other.locus)\n-  {}\n+    : param_kind (other.param_kind), name (other.name), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+  }\n \n   ~MaybeNamedParam () = default;\n \n@@ -710,9 +655,14 @@ struct MaybeNamedParam\n   {\n     name = other.name;\n     param_kind = other.param_kind;\n-    param_type = other.param_type->clone_type ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+    else\n+      param_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -773,10 +723,12 @@ class BareFunctionType : public TypeNoBounds\n   BareFunctionType (BareFunctionType const &other)\n     : for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n-      is_variadic (other.is_variadic),\n-      return_type (other.return_type->clone_type_no_bounds ()),\n-      locus (other.locus)\n-  {}\n+      is_variadic (other.is_variadic), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type_no_bounds ();\n+  }\n \n   // Overload assignment operator to deep copy\n   BareFunctionType &operator= (BareFunctionType const &other)\n@@ -785,9 +737,14 @@ class BareFunctionType : public TypeNoBounds\n     function_qualifiers = other.function_qualifiers;\n     params = other.params;\n     is_variadic = other.is_variadic;\n-    return_type = other.return_type->clone_type_no_bounds ();\n     locus = other.locus;\n \n+    // guard to prevent null dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type_no_bounds ();\n+    else\n+      return_type = nullptr;\n+\n     return *this;\n   }\n \n@@ -802,13 +759,6 @@ class BareFunctionType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  BareFunctionType *clone_type_impl () const override\n-  {\n-    return new BareFunctionType (*this);\n-  }\n-\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   BareFunctionType *clone_type_no_bounds_impl () const override"}, {"sha": "a7d2a1a93d8f7036eeeea7a2459e37dc8e30a684", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 218, "deletions": 1, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -1,8 +1,217 @@\n #include \"rust-macro-expand.h\"\n #include \"rust-ast-full.h\"\n // is full really required?\n+#include \"rust-ast-visitor.h\"\n \n namespace Rust {\n+    // Visitor used to expand attributes.\n+    class AttrVisitor : public AST::ASTVisitor {\n+      private:\n+        MacroExpander& expander;\n+\n+      public:\n+        AttrVisitor(MacroExpander& expander) : expander(expander) {}\n+\n+        void visit(AST::Token& tok) override {}\n+        void visit(AST::DelimTokenTree& delim_tok_tree) override {}\n+        void visit(AST::AttrInputMetaItemContainer& input) override {}\n+        void visit(AST::IdentifierExpr& ident_expr) override {}\n+        void visit(AST::Lifetime& lifetime) override {}\n+        void visit(AST::LifetimeParam& lifetime_param) override {}\n+        void visit(AST::MacroInvocationSemi& macro) override {}\n+\n+        void visit(AST::PathInExpression& path) override {}\n+        void visit(AST::TypePathSegment& segment) override {}\n+        void visit(AST::TypePathSegmentGeneric& segment) override {}\n+        void visit(AST::TypePathSegmentFunction& segment) override {}\n+        void visit(AST::TypePath& path) override {}\n+        void visit(AST::QualifiedPathInExpression& path) override {}\n+        void visit(AST::QualifiedPathInType& path) override {}\n+\n+        void visit(AST::LiteralExpr& expr) override {}\n+        void visit(AST::AttrInputLiteral& attr_input) override {}\n+        void visit(AST::MetaItemLitExpr& meta_item) override {}\n+        void visit(AST::MetaItemPathLit& meta_item) override {}\n+        void visit(AST::BorrowExpr& expr) override {}\n+        void visit(AST::DereferenceExpr& expr) override {}\n+        void visit(AST::ErrorPropagationExpr& expr) override {}\n+        void visit(AST::NegationExpr& expr) override {}\n+        void visit(AST::ArithmeticOrLogicalExpr& expr) override {}\n+        void visit(AST::ComparisonExpr& expr) override {}\n+        void visit(AST::LazyBooleanExpr& expr) override {}\n+        void visit(AST::TypeCastExpr& expr) override {}\n+        void visit(AST::AssignmentExpr& expr) override {}\n+        void visit(AST::CompoundAssignmentExpr& expr) override {}\n+        void visit(AST::GroupedExpr& expr) override {}\n+        void visit(AST::ArrayElemsValues& elems) override {}\n+        void visit(AST::ArrayElemsCopied& elems) override {}\n+        void visit(AST::ArrayExpr& expr) override {}\n+        void visit(AST::ArrayIndexExpr& expr) override {}\n+        void visit(AST::TupleExpr& expr) override {}\n+        void visit(AST::TupleIndexExpr& expr) override {}\n+        void visit(AST::StructExprStruct& expr) override {}\n+        void visit(AST::StructExprFieldIdentifier& field) override {}\n+        void visit(AST::StructExprFieldIdentifierValue& field) override {}\n+        void visit(AST::StructExprFieldIndexValue& field) override {}\n+        void visit(AST::StructExprStructFields& expr) override {}\n+        void visit(AST::StructExprStructBase& expr) override {}\n+        void visit(AST::StructExprTuple& expr) override {}\n+        void visit(AST::StructExprUnit& expr) override {}\n+        void visit(AST::EnumExprFieldIdentifier& field) override {}\n+        void visit(AST::EnumExprFieldIdentifierValue& field) override {}\n+        void visit(AST::EnumExprFieldIndexValue& field) override {}\n+        void visit(AST::EnumExprStruct& expr) override {}\n+        void visit(AST::EnumExprTuple& expr) override {}\n+        void visit(AST::EnumExprFieldless& expr) override {}\n+        void visit(AST::CallExpr& expr) override {}\n+        void visit(AST::MethodCallExpr& expr) override {}\n+        void visit(AST::FieldAccessExpr& expr) override {}\n+        void visit(AST::ClosureExprInner& expr) override {}\n+        void visit(AST::BlockExpr& expr) override {}\n+        void visit(AST::ClosureExprInnerTyped& expr) override {}\n+        void visit(AST::ContinueExpr& expr) override {}\n+        void visit(AST::BreakExpr& expr) override {}\n+        void visit(AST::RangeFromToExpr& expr) override {}\n+        void visit(AST::RangeFromExpr& expr) override {}\n+        void visit(AST::RangeToExpr& expr) override {}\n+        void visit(AST::RangeFullExpr& expr) override {}\n+        void visit(AST::RangeFromToInclExpr& expr) override {}\n+        void visit(AST::RangeToInclExpr& expr) override {}\n+        void visit(AST::ReturnExpr& expr) override {}\n+        void visit(AST::UnsafeBlockExpr& expr) override {}\n+        void visit(AST::LoopExpr& expr) override {}\n+        void visit(AST::WhileLoopExpr& expr) override {}\n+        void visit(AST::WhileLetLoopExpr& expr) override {}\n+        void visit(AST::ForLoopExpr& expr) override {}\n+        void visit(AST::IfExpr& expr) override {}\n+        void visit(AST::IfExprConseqElse& expr) override {}\n+        void visit(AST::IfExprConseqIf& expr) override {}\n+        void visit(AST::IfExprConseqIfLet& expr) override {}\n+        void visit(AST::IfLetExpr& expr) override {}\n+        void visit(AST::IfLetExprConseqElse& expr) override {}\n+        void visit(AST::IfLetExprConseqIf& expr) override {}\n+        void visit(AST::IfLetExprConseqIfLet& expr) override {}\n+        void visit(AST::MatchExpr& expr) override {}\n+        void visit(AST::AwaitExpr& expr) override {}\n+        void visit(AST::AsyncBlockExpr& expr) override {}\n+\n+        void visit(AST::TypeParam& param) override {}\n+        void visit(AST::LifetimeWhereClauseItem& item) override {}\n+        void visit(AST::TypeBoundWhereClauseItem& item) override {}\n+        void visit(AST::Method& method) override {}\n+        void visit(AST::ModuleBodied& module) override {}\n+        void visit(AST::ModuleNoBody& module) override {}\n+        void visit(AST::ExternCrate& crate) override {}\n+        void visit(AST::UseTreeGlob& use_tree) override {}\n+        void visit(AST::UseTreeList& use_tree) override {}\n+        void visit(AST::UseTreeRebind& use_tree) override {}\n+        void visit(AST::UseDeclaration& use_decl) override {}\n+        void visit(AST::Function& function) override {}\n+        void visit(AST::TypeAlias& type_alias) override {}\n+        void visit(AST::StructStruct& struct_item) override {}\n+        void visit(AST::TupleStruct& tuple_struct) override {}\n+        void visit(AST::EnumItem& item) override {}\n+        void visit(AST::EnumItemTuple& item) override {}\n+        void visit(AST::EnumItemStruct& item) override {}\n+        void visit(AST::EnumItemDiscriminant& item) override {}\n+        void visit(AST::Enum& enum_item) override {}\n+        void visit(AST::Union& union_item) override {}\n+        void visit(AST::ConstantItem& const_item) override {}\n+        void visit(AST::StaticItem& static_item) override {}\n+        void visit(AST::TraitItemFunc& item) override {}\n+        void visit(AST::TraitItemMethod& item) override {}\n+        void visit(AST::TraitItemConst& item) override {}\n+        void visit(AST::TraitItemType& item) override {}\n+        void visit(AST::Trait& trait) override {}\n+        void visit(AST::InherentImpl& impl) override {}\n+        void visit(AST::TraitImpl& impl) override {}\n+        void visit(AST::ExternalStaticItem& item) override {}\n+        void visit(AST::ExternalFunctionItem& item) override {}\n+        void visit(AST::ExternBlock& block) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(block.get_outer_attrs());\n+            if (expander.fails_cfg(block.get_outer_attrs())) {\n+                block.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip test based on inner attrs\n+            expander.expand_cfg_attrs(block.get_inner_attrs());\n+            if (expander.fails_cfg(block.get_inner_attrs())) {\n+                block.mark_for_strip();\n+                return;\n+            }\n+\n+            // strip external items if required\n+            auto& extern_items = block.get_extern_items();\n+            for (auto i = 0; i < extern_items.size(); ) {\n+                auto& item = extern_items[i];\n+\n+                // mark for stripping if required\n+                item->accept_vis(*this);\n+\n+                if (item->is_marked_for_strip ())\n+                    extern_items.erase (extern_items.begin() + i);\n+                else\n+                    i++;\n+                \n+            }\n+        }\n+\n+        void visit(AST::MacroMatchFragment& match) override {}\n+        void visit(AST::MacroMatchRepetition& match) override {}\n+        void visit(AST::MacroMatcher& matcher) override {}\n+        void visit(AST::MacroRulesDefinition& rules_def) override {}\n+        void visit(AST::MacroInvocation& macro_invoc) override {}\n+        void visit(AST::MetaItemPath& meta_item) override {}\n+        void visit(AST::MetaItemSeq& meta_item) override {}\n+        void visit(AST::MetaWord& meta_item) override {}\n+        void visit(AST::MetaNameValueStr& meta_item) override {}\n+        void visit(AST::MetaListPaths& meta_item) override {}\n+        void visit(AST::MetaListNameValueStr& meta_item) override {}\n+\n+        void visit(AST::LiteralPattern& pattern) override {}\n+        void visit(AST::IdentifierPattern& pattern) override {}\n+        void visit(AST::WildcardPattern& pattern) override {}\n+        void visit(AST::RangePatternBoundLiteral& bound) override {}\n+        void visit(AST::RangePatternBoundPath& bound) override {}\n+        void visit(AST::RangePatternBoundQualPath& bound) override {}\n+        void visit(AST::RangePattern& pattern) override {}\n+        void visit(AST::ReferencePattern& pattern) override {}\n+        void visit(AST::StructPatternFieldTuplePat& field) override {}\n+        void visit(AST::StructPatternFieldIdentPat& field) override {}\n+        void visit(AST::StructPatternFieldIdent& field) override {}\n+        void visit(AST::StructPattern& pattern) override {}\n+        void visit(AST::TupleStructItemsNoRange& tuple_items) override {}\n+        void visit(AST::TupleStructItemsRange& tuple_items) override {}\n+        void visit(AST::TupleStructPattern& pattern) override {}\n+        void visit(AST::TuplePatternItemsMultiple& tuple_items) override {}\n+        void visit(AST::TuplePatternItemsRanged& tuple_items) override {}\n+        void visit(AST::TuplePattern& pattern) override {}\n+        void visit(AST::GroupedPattern& pattern) override {}\n+        void visit(AST::SlicePattern& pattern) override {}\n+\n+        void visit(AST::EmptyStmt& stmt) override {}\n+        void visit(AST::LetStmt& stmt) override {}\n+        void visit(AST::ExprStmtWithoutBlock& stmt) override {}\n+        void visit(AST::ExprStmtWithBlock& stmt) override {}\n+\n+        void visit(AST::TraitBound& bound) override {}\n+        void visit(AST::ImplTraitType& type) override {}\n+        void visit(AST::TraitObjectType& type) override {}\n+        void visit(AST::ParenthesisedType& type) override {}\n+        void visit(AST::ImplTraitTypeOneBound& type) override {}\n+        void visit(AST::TraitObjectTypeOneBound& type) override {}\n+        void visit(AST::TupleType& type) override {}\n+        void visit(AST::NeverType& type) override {}\n+        void visit(AST::RawPointerType& type) override {}\n+        void visit(AST::ReferenceType& type) override {}\n+        void visit(AST::ArrayType& type) override {}\n+        void visit(AST::SliceType& type) override {}\n+        void visit(AST::InferredType& type) override {}\n+        void visit(AST::BareFunctionType& type) override {}\n+    };\n+\n     void MacroExpander::expand_invoc(std::unique_ptr<AST::MacroInvocation>& invoc) {\n         /* if current expansion depth > recursion limit, create an error (maybe fatal\n          * error) and return */\n@@ -24,7 +233,7 @@ namespace Rust {\n             - derive container macro - unreachable*/\n     }\n \n-    /* Determines whether any cfg predicate is false and hence item with attributes should \n+    /* Determines whether any cfg predicate is false and hence item with attributes should\n      * be stripped.  */\n     bool MacroExpander::fails_cfg(std::vector<AST::Attribute>& attrs) {\n         for (auto& attr : attrs) {\n@@ -81,6 +290,14 @@ namespace Rust {\n         }\n         // expand module attributes?\n \n+        // expand attributes recursively\n+        AttrVisitor attr_visitor(*this);\n+        for (auto& i : crate.items) {\n+            i->accept_vis(attr_visitor);\n+        }\n+        // TODO: should recursive attribute and macro expansion be done in the same transversal? Or in\n+        // separate ones like currently?\n+\n         // expand module tree recursively\n \n         // post-process"}, {"sha": "fd50bf1247c276b7035064373a89b3ebdf410f27", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d429466bf783ff1a7ac59bf800061d3e67061a/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=98d429466bf783ff1a7ac59bf800061d3e67061a", "patch": "@@ -626,8 +626,7 @@ Session::injection (AST::Crate &crate)\n    * rustc also has a \"quote\" macro that is defined differently and is\n    * supposedly not stable so eh. */\n   /* TODO: actually implement injection of these macros. In particular, derive\n-   * macros, cfg, and\n-   * test should be prioritised since they seem to be used the most. */\n+   * macros, cfg, and test should be prioritised since they seem to be used the most. */\n \n   // crate injection\n   std::vector<std::string> names;"}]}