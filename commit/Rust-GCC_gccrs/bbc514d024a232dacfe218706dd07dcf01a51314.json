{"sha": "bbc514d024a232dacfe218706dd07dcf01a51314", "node_id": "C_kwDOANBUbNoAKGJiYzUxNGQwMjRhMjMyZGFjZmUyMTg3MDZkZDA3ZGNmMDFhNTEzMTQ", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-08-06T11:55:47Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:26Z"}, "message": "rust-constexpr.cc: port over cxx_eval_bare_aggregate. Comments out build_ctor_subob_ref\ninside init_subob_ctx.", "tree": {"sha": "89e307830bf69d99a6085370098a33f6f76b496a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89e307830bf69d99a6085370098a33f6f76b496a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbc514d024a232dacfe218706dd07dcf01a51314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc514d024a232dacfe218706dd07dcf01a51314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbc514d024a232dacfe218706dd07dcf01a51314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc514d024a232dacfe218706dd07dcf01a51314/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c628a66a92f72add62608c2c24cf0ec4c5ae45af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c628a66a92f72add62608c2c24cf0ec4c5ae45af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c628a66a92f72add62608c2c24cf0ec4c5ae45af"}], "stats": {"total": 727, "additions": 503, "deletions": 224}, "files": [{"sha": "c26b1afcf6614c43f714ef6061b8222fdf9fcf59", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 470, "deletions": 224, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc514d024a232dacfe218706dd07dcf01a51314/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc514d024a232dacfe218706dd07dcf01a51314/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=bbc514d024a232dacfe218706dd07dcf01a51314", "patch": "@@ -990,6 +990,463 @@ inline_asm_in_constexpr_error (location_t loc)\n \t       \"%<constexpr%> function in C++20\");\n }\n \n+// forked from gcc/cp/constexpr.cc verify_ctor_sanity\n+\n+/* We're about to process an initializer for a class or array TYPE.  Make\n+   sure that CTX is set up appropriately.  */\n+\n+static void\n+verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n+{\n+  /* We don't bother building a ctor for an empty base subobject.  */\n+  if (is_empty_class (type))\n+    return;\n+\n+  /* We're in the middle of an initializer that might involve placeholders;\n+     our caller should have created a CONSTRUCTOR for us to put the\n+     initializer into.  We will either return that constructor or T.  */\n+  gcc_assert (ctx->ctor);\n+  gcc_assert (\n+    same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (ctx->ctor)));\n+  /* We used to check that ctx->ctor was empty, but that isn't the case when\n+     the object is zero-initialized before calling the constructor.  */\n+  if (ctx->object)\n+    {\n+      tree otype = TREE_TYPE (ctx->object);\n+      gcc_assert (same_type_ignoring_top_level_qualifiers_p (type, otype)\n+\t\t  /* Handle flexible array members.  */\n+\t\t  || (TREE_CODE (otype) == ARRAY_TYPE\n+\t\t      && TYPE_DOMAIN (otype) == NULL_TREE\n+\t\t      && TREE_CODE (type) == ARRAY_TYPE\n+\t\t      && (same_type_ignoring_top_level_qualifiers_p (\n+\t\t\tTREE_TYPE (type), TREE_TYPE (otype)))));\n+    }\n+  gcc_assert (!ctx->object || !DECL_P (ctx->object)\n+\t      || *(ctx->global->values.get (ctx->object)) == ctx->ctor);\n+}\n+\n+// forked from gcc/cp/constexpr.cc array_index_cmp\n+\n+/* Some of the expressions fed to the constexpr mechanism are calls to\n+   constructors, which have type void.  In that case, return the type being\n+   initialized by the constructor.  */\n+\n+static tree\n+initialized_type (tree t)\n+{\n+  if (TYPE_P (t))\n+    return t;\n+  tree type = TREE_TYPE (t);\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    {\n+      /* A constructor call has void type, so we need to look deeper.  */\n+      tree fn = get_function_named_in_call (t);\n+      if (fn && TREE_CODE (fn) == FUNCTION_DECL && DECL_CXX_CONSTRUCTOR_P (fn))\n+\ttype = DECL_CONTEXT (fn);\n+    }\n+  else if (TREE_CODE (t) == COMPOUND_EXPR)\n+    return initialized_type (TREE_OPERAND (t, 1));\n+\n+  return cv_unqualified (type);\n+}\n+\n+// forked from gcc/cp/constexpr.cc init_subob_ctx\n+\n+/* We're about to initialize element INDEX of an array or class from VALUE.\n+   Set up NEW_CTX appropriately by adjusting .object to refer to the\n+   subobject and creating a new CONSTRUCTOR if the element is itself\n+   a class or array.  */\n+\n+static void\n+init_subob_ctx (const constexpr_ctx *ctx, constexpr_ctx &new_ctx, tree index,\n+\t\ttree &value)\n+{\n+  new_ctx = *ctx;\n+\n+  if (index && TREE_CODE (index) != INTEGER_CST\n+      && TREE_CODE (index) != FIELD_DECL && TREE_CODE (index) != RANGE_EXPR)\n+    /* This won't have an element in the new CONSTRUCTOR.  */\n+    return;\n+\n+  tree type = initialized_type (value);\n+  if (!AGGREGATE_TYPE_P (type) && !VECTOR_TYPE_P (type))\n+    /* A non-aggregate member doesn't get its own CONSTRUCTOR.  */\n+    return;\n+\n+  /* The sub-aggregate initializer might contain a placeholder;\n+     update object to refer to the subobject and ctor to refer to\n+     the (newly created) sub-initializer.  */\n+  if (ctx->object)\n+    {\n+      if (index == NULL_TREE || TREE_CODE (index) == RANGE_EXPR)\n+\t/* There's no well-defined subobject for this index.  */\n+\tnew_ctx.object = NULL_TREE;\n+      else\n+\t// new_ctx.object = build_ctor_subob_ref (index, type, ctx->object);\n+\t;\n+    }\n+  tree elt = build_constructor (type, NULL);\n+  CONSTRUCTOR_NO_CLEARING (elt) = true;\n+  new_ctx.ctor = elt;\n+\n+  if (TREE_CODE (value) == TARGET_EXPR)\n+    /* Avoid creating another CONSTRUCTOR when we expand the TARGET_EXPR.  */\n+    value = TARGET_EXPR_INITIAL (value);\n+}\n+\n+// forked from gcc/cp/constexpr.cc base_field_constructor_elt\n+\n+/* REF is a COMPONENT_REF designating a particular field.  V is a vector of\n+   CONSTRUCTOR elements to initialize (part of) an object containing that\n+   field.  Return a pointer to the constructor_elt corresponding to the\n+   initialization of the field.  */\n+\n+static constructor_elt *\n+base_field_constructor_elt (vec<constructor_elt, va_gc> *v, tree ref)\n+{\n+  tree aggr = TREE_OPERAND (ref, 0);\n+  tree field = TREE_OPERAND (ref, 1);\n+  HOST_WIDE_INT i;\n+  constructor_elt *ce;\n+\n+  gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n+\n+  if (TREE_CODE (aggr) == COMPONENT_REF)\n+    {\n+      constructor_elt *base_ce = base_field_constructor_elt (v, aggr);\n+      v = CONSTRUCTOR_ELTS (base_ce->value);\n+    }\n+\n+  for (i = 0; vec_safe_iterate (v, i, &ce); ++i)\n+    if (ce->index == field)\n+      return ce;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Return a pointer to the constructor_elt of CTOR which matches INDEX.  If no\n+   matching constructor_elt exists, then add one to CTOR.\n+\n+   As an optimization, if POS_HINT is non-negative then it is used as a guess\n+   for the (integer) index of the matching constructor_elt within CTOR.  */\n+\n+static constructor_elt *\n+get_or_insert_ctor_field (tree ctor, tree index, int pos_hint = -1)\n+{\n+  /* Check the hint first.  */\n+  if (pos_hint >= 0 && (unsigned) pos_hint < CONSTRUCTOR_NELTS (ctor)\n+      && CONSTRUCTOR_ELT (ctor, pos_hint)->index == index)\n+    return CONSTRUCTOR_ELT (ctor, pos_hint);\n+\n+  tree type = TREE_TYPE (ctor);\n+  if (TREE_CODE (type) == VECTOR_TYPE && index == NULL_TREE)\n+    {\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (ctor), index, NULL_TREE);\n+      return &CONSTRUCTOR_ELTS (ctor)->last ();\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      if (TREE_CODE (index) == RANGE_EXPR)\n+\t{\n+\t  /* Support for RANGE_EXPR index lookups is currently limited to\n+\t     accessing an existing element via POS_HINT, or appending a new\n+\t     element to the end of CTOR.  ??? Support for other access\n+\t     patterns may also be needed.  */\n+\t  vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ctor);\n+\t  if (vec_safe_length (elts))\n+\t    {\n+\t      tree lo = TREE_OPERAND (index, 0);\n+\t      gcc_assert (array_index_cmp (elts->last ().index, lo) < 0);\n+\t    }\n+\t  CONSTRUCTOR_APPEND_ELT (elts, index, NULL_TREE);\n+\t  return &elts->last ();\n+\t}\n+\n+      HOST_WIDE_INT i = find_array_ctor_elt (ctor, index, /*insert*/ true);\n+      gcc_assert (i >= 0);\n+      constructor_elt *cep = CONSTRUCTOR_ELT (ctor, i);\n+      gcc_assert (cep->index == NULL_TREE\n+\t\t  || TREE_CODE (cep->index) != RANGE_EXPR);\n+      return cep;\n+    }\n+  else\n+    {\n+      gcc_assert (\n+\tTREE_CODE (index) == FIELD_DECL\n+\t&& (same_type_ignoring_top_level_qualifiers_p (DECL_CONTEXT (index),\n+\t\t\t\t\t\t       TREE_TYPE (ctor))));\n+\n+      /* We must keep the CONSTRUCTOR's ELTS in FIELD order.\n+\t Usually we meet initializers in that order, but it is\n+\t possible for base types to be placed not in program\n+\t order.  */\n+      tree fields = TYPE_FIELDS (DECL_CONTEXT (index));\n+      unsigned HOST_WIDE_INT idx = 0;\n+      constructor_elt *cep = NULL;\n+\n+      /* Check if we're changing the active member of a union.  */\n+      if (TREE_CODE (type) == UNION_TYPE && CONSTRUCTOR_NELTS (ctor)\n+\t  && CONSTRUCTOR_ELT (ctor, 0)->index != index)\n+\tvec_safe_truncate (CONSTRUCTOR_ELTS (ctor), 0);\n+      /* If the bit offset of INDEX is larger than that of the last\n+\t constructor_elt, then we can just immediately append a new\n+\t constructor_elt to the end of CTOR.  */\n+      else if (CONSTRUCTOR_NELTS (ctor)\n+\t       && tree_int_cst_compare (\n+\t\t    bit_position (index),\n+\t\t    bit_position (CONSTRUCTOR_ELTS (ctor)->last ().index))\n+\t\t    > 0)\n+\t{\n+\t  idx = CONSTRUCTOR_NELTS (ctor);\n+\t  goto insert;\n+\t}\n+\n+      /* Otherwise, we need to iterate over CTOR to find or insert INDEX\n+\t appropriately.  */\n+\n+      for (; vec_safe_iterate (CONSTRUCTOR_ELTS (ctor), idx, &cep);\n+\t   idx++, fields = DECL_CHAIN (fields))\n+\t{\n+\t  if (index == cep->index)\n+\t    goto found;\n+\n+\t  /* The field we're initializing must be on the field\n+\t     list.  Look to see if it is present before the\n+\t     field the current ELT initializes.  */\n+\t  for (; fields != cep->index; fields = DECL_CHAIN (fields))\n+\t    if (index == fields)\n+\t      goto insert;\n+\t}\n+      /* We fell off the end of the CONSTRUCTOR, so insert a new\n+\t entry at the end.  */\n+\n+      insert : {\n+\tconstructor_elt ce = {index, NULL_TREE};\n+\n+\tvec_safe_insert (CONSTRUCTOR_ELTS (ctor), idx, ce);\n+\tcep = CONSTRUCTOR_ELT (ctor, idx);\n+      }\n+    found:;\n+\n+      return cep;\n+    }\n+}\n+\n+// forked from gcc/cp/constexpr.cc cxx_eval_bare_aggregate\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   The expression tree T denotes a C-style array or a C-style\n+   aggregate.  Reduce it to a constant expression.  */\n+\n+static tree\n+eval_bare_aggregate (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t     bool *non_constant_p, bool *overflow_p)\n+{\n+  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n+  bool changed = false;\n+  gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (t));\n+  tree type = TREE_TYPE (t);\n+\n+  constexpr_ctx new_ctx;\n+  if (TYPE_PTRMEMFUNC_P (type) || VECTOR_TYPE_P (type))\n+    {\n+      /* We don't really need the ctx->ctor business for a PMF or\n+\t vector, but it's simpler to use the same code.  */\n+      new_ctx = *ctx;\n+      new_ctx.ctor = build_constructor (type, NULL);\n+      new_ctx.object = NULL_TREE;\n+      ctx = &new_ctx;\n+    };\n+  verify_ctor_sanity (ctx, type);\n+  vec<constructor_elt, va_gc> **p = &CONSTRUCTOR_ELTS (ctx->ctor);\n+  vec_alloc (*p, vec_safe_length (v));\n+\n+  if (CONSTRUCTOR_PLACEHOLDER_BOUNDARY (t))\n+    CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ctx->ctor) = 1;\n+\n+  unsigned i;\n+  tree index, value;\n+  bool constant_p = true;\n+  bool side_effects_p = false;\n+  FOR_EACH_CONSTRUCTOR_ELT (v, i, index, value)\n+    {\n+      tree orig_value = value;\n+      /* Like in cxx_eval_store_expression, omit entries for empty fields.  */\n+      bool no_slot = TREE_CODE (type) == RECORD_TYPE && is_empty_field (index);\n+      if (no_slot)\n+\tnew_ctx = *ctx;\n+      else\n+\tinit_subob_ctx (ctx, new_ctx, index, value);\n+      int pos_hint = -1;\n+      if (new_ctx.ctor != ctx->ctor)\n+\t{\n+\t  /* If we built a new CONSTRUCTOR, attach it now so that other\n+\t     initializers can refer to it.  */\n+\t  constructor_elt *cep = get_or_insert_ctor_field (ctx->ctor, index);\n+\t  cep->value = new_ctx.ctor;\n+\t  pos_hint = cep - (*p)->begin ();\n+\t}\n+      else if (TREE_CODE (type) == UNION_TYPE)\n+\t/* Otherwise if we're constructing a non-aggregate union member, set\n+\t   the active union member now so that we can later detect and diagnose\n+\t   if its initializer attempts to activate another member.  */\n+\tget_or_insert_ctor_field (ctx->ctor, index);\n+      tree elt = eval_constant_expression (&new_ctx, value, lval,\n+\t\t\t\t\t   non_constant_p, overflow_p);\n+      /* Don't VERIFY_CONSTANT here.  */\n+      if (ctx->quiet && *non_constant_p)\n+\tbreak;\n+      if (elt != orig_value)\n+\tchanged = true;\n+\n+      if (!TREE_CONSTANT (elt))\n+\tconstant_p = false;\n+      if (TREE_SIDE_EFFECTS (elt))\n+\tside_effects_p = true;\n+      if (index && TREE_CODE (index) == COMPONENT_REF)\n+\t{\n+\t  /* This is an initialization of a vfield inside a base\n+\t     subaggregate that we already initialized; push this\n+\t     initialization into the previous initialization.  */\n+\t  constructor_elt *inner = base_field_constructor_elt (*p, index);\n+\t  inner->value = elt;\n+\t  changed = true;\n+\t}\n+      else if (index\n+\t       && (TREE_CODE (index) == NOP_EXPR\n+\t\t   || TREE_CODE (index) == POINTER_PLUS_EXPR))\n+\t{\n+\t  /* This is an initializer for an empty base; now that we've\n+\t     checked that it's constant, we can ignore it.  */\n+\t  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (index))));\n+\t  changed = true;\n+\t}\n+      else if (no_slot)\n+\tchanged = true;\n+      else\n+\t{\n+\t  if (TREE_CODE (type) == UNION_TYPE && (*p)->last ().index != index)\n+\t    /* The initializer erroneously changed the active union member that\n+\t       we're initializing.  */\n+\t    gcc_assert (*non_constant_p);\n+\t  else\n+\t    {\n+\t      /* The initializer might have mutated the underlying CONSTRUCTOR,\n+\t\t so recompute the location of the target constructer_elt.  */\n+\t      constructor_elt *cep\n+\t\t= get_or_insert_ctor_field (ctx->ctor, index, pos_hint);\n+\t      cep->value = elt;\n+\t    }\n+\n+\t  /* Adding or replacing an element might change the ctor's flags.  */\n+\t  TREE_CONSTANT (ctx->ctor) = constant_p;\n+\t  TREE_SIDE_EFFECTS (ctx->ctor) = side_effects_p;\n+\t}\n+    }\n+  if (*non_constant_p || !changed)\n+    return t;\n+  t = ctx->ctor;\n+  /* We're done building this CONSTRUCTOR, so now we can interpret an\n+     element without an explicit initializer as value-initialized.  */\n+  CONSTRUCTOR_NO_CLEARING (t) = false;\n+  TREE_CONSTANT (t) = constant_p;\n+  TREE_SIDE_EFFECTS (t) = side_effects_p;\n+  if (VECTOR_TYPE_P (type))\n+    t = fold (t);\n+  return t;\n+}\n+\n+/* Return true if T is a valid constant initializer.  If a CONSTRUCTOR\n+   initializes all the members, the CONSTRUCTOR_NO_CLEARING flag will be\n+   cleared.\n+   FIXME speed this up, it's taking 16% of compile time on sieve testcase.  */\n+\n+bool\n+reduced_constant_expression_p (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case PTRMEM_CST:\n+      /* Even if we can't lower this yet, it's constant.  */\n+      return true;\n+\n+    case CONSTRUCTOR:\n+      /* And we need to handle PTRMEM_CST wrapped in a CONSTRUCTOR.  */\n+      tree field;\n+      if (CONSTRUCTOR_NO_CLEARING (t))\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+\t    /* An initialized vector would have a VECTOR_CST.  */\n+\t    return false;\n+\t  else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n+\t    {\n+\t      /* There must be a valid constant initializer at every array\n+\t\t index.  */\n+\t      tree min = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (t)));\n+\t      tree max = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (t)));\n+\t      tree cursor = min;\n+\t      for (auto &e : CONSTRUCTOR_ELTS (t))\n+\t\t{\n+\t\t  if (!reduced_constant_expression_p (e.value))\n+\t\t    return false;\n+\t\t  if (array_index_cmp (cursor, e.index) != 0)\n+\t\t    return false;\n+\t\t  if (TREE_CODE (e.index) == RANGE_EXPR)\n+\t\t    cursor = TREE_OPERAND (e.index, 1);\n+\t\t  cursor = int_const_binop (PLUS_EXPR, cursor, size_one_node);\n+\t\t}\n+\t      if (find_array_ctor_elt (t, max) == -1)\n+\t\treturn false;\n+\t      goto ok;\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n+\t    {\n+\t      if (CONSTRUCTOR_NELTS (t) == 0)\n+\t\t/* An initialized union has a constructor element.  */\n+\t\treturn false;\n+\t      /* And it only initializes one member.  */\n+\t      field = NULL_TREE;\n+\t    }\n+\t  else\n+\t    field = next_initializable_field (TYPE_FIELDS (TREE_TYPE (t)));\n+\t}\n+      else\n+\tfield = NULL_TREE;\n+      for (auto &e : CONSTRUCTOR_ELTS (t))\n+\t{\n+\t  /* If VAL is null, we're in the middle of initializing this\n+\t     element.  */\n+\t  if (!reduced_constant_expression_p (e.value))\n+\t    return false;\n+\t  /* Empty class field may or may not have an initializer.  */\n+\t  for (; field && e.index != field;\n+\t       field = next_initializable_field (DECL_CHAIN (field)))\n+\t    if (!is_really_empty_class (TREE_TYPE (field),\n+\t\t\t\t\t/*ignore_vptr*/ false))\n+\t      return false;\n+\t  if (field)\n+\t    field = next_initializable_field (DECL_CHAIN (field));\n+\t}\n+      /* There could be a non-empty field at the end.  */\n+      for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n+\tif (!is_really_empty_class (TREE_TYPE (field), /*ignore_vptr*/ false))\n+\t  return false;\n+    ok:\n+      if (CONSTRUCTOR_NO_CLEARING (t))\n+\t/* All the fields are initialized.  */\n+\tCONSTRUCTOR_NO_CLEARING (t) = false;\n+      return true;\n+\n+    default:\n+      /* FIXME are we calling this too much?  */\n+      return initializer_constant_valid_p (t, TREE_TYPE (t)) != NULL_TREE;\n+    }\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n@@ -1276,7 +1733,7 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       break;\n \n     case COND_EXPR:\n-    case IF_STMT:\n+    case IF_STMT: // comes from cp-tree.def\n       if (jump_target && *jump_target)\n \t{\n \t  tree orig_jump = *jump_target;\n@@ -1315,6 +1772,18 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t\t       jump_target);\n       break;\n \n+    case CONSTRUCTOR:\n+      if (TREE_CONSTANT (t) && reduced_constant_expression_p (t))\n+\t{\n+\t  /* Don't re-process a constant CONSTRUCTOR, but do fold it to\n+\t     VECTOR_CST if applicable.  */\n+\t  verify_constructor_flags (t);\n+\t  if (TREE_CONSTANT (t))\n+\t    return fold (t);\n+\t}\n+      r = eval_bare_aggregate (ctx, t, lval, non_constant_p, overflow_p);\n+      break;\n+\n       /* FALLTHROUGH.  */\n     case CONVERT_EXPR:\n       case VIEW_CONVERT_EXPR: {\n@@ -1479,114 +1948,6 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   return r;\n }\n \n-/* Return a pointer to the constructor_elt of CTOR which matches INDEX.  If no\n-   matching constructor_elt exists, then add one to CTOR.\n-\n-   As an optimization, if POS_HINT is non-negative then it is used as a guess\n-   for the (integer) index of the matching constructor_elt within CTOR.  */\n-\n-static constructor_elt *\n-get_or_insert_ctor_field (tree ctor, tree index, int pos_hint = -1)\n-{\n-  /* Check the hint first.  */\n-  if (pos_hint >= 0 && (unsigned) pos_hint < CONSTRUCTOR_NELTS (ctor)\n-      && CONSTRUCTOR_ELT (ctor, pos_hint)->index == index)\n-    return CONSTRUCTOR_ELT (ctor, pos_hint);\n-\n-  tree type = TREE_TYPE (ctor);\n-  if (TREE_CODE (type) == VECTOR_TYPE && index == NULL_TREE)\n-    {\n-      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (ctor), index, NULL_TREE);\n-      return &CONSTRUCTOR_ELTS (ctor)->last ();\n-    }\n-  else if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n-    {\n-      if (TREE_CODE (index) == RANGE_EXPR)\n-\t{\n-\t  /* Support for RANGE_EXPR index lookups is currently limited to\n-\t     accessing an existing element via POS_HINT, or appending a new\n-\t     element to the end of CTOR.  ??? Support for other access\n-\t     patterns may also be needed.  */\n-\t  vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ctor);\n-\t  if (vec_safe_length (elts))\n-\t    {\n-\t      tree lo = TREE_OPERAND (index, 0);\n-\t      gcc_assert (array_index_cmp (elts->last ().index, lo) < 0);\n-\t    }\n-\t  CONSTRUCTOR_APPEND_ELT (elts, index, NULL_TREE);\n-\t  return &elts->last ();\n-\t}\n-\n-      HOST_WIDE_INT i = find_array_ctor_elt (ctor, index, /*insert*/ true);\n-      gcc_assert (i >= 0);\n-      constructor_elt *cep = CONSTRUCTOR_ELT (ctor, i);\n-      gcc_assert (cep->index == NULL_TREE\n-\t\t  || TREE_CODE (cep->index) != RANGE_EXPR);\n-      return cep;\n-    }\n-  else\n-    {\n-      gcc_assert (\n-\tTREE_CODE (index) == FIELD_DECL\n-\t&& (same_type_ignoring_top_level_qualifiers_p (DECL_CONTEXT (index),\n-\t\t\t\t\t\t       TREE_TYPE (ctor))));\n-\n-      /* We must keep the CONSTRUCTOR's ELTS in FIELD order.\n-\t Usually we meet initializers in that order, but it is\n-\t possible for base types to be placed not in program\n-\t order.  */\n-      tree fields = TYPE_FIELDS (DECL_CONTEXT (index));\n-      unsigned HOST_WIDE_INT idx = 0;\n-      constructor_elt *cep = NULL;\n-\n-      /* Check if we're changing the active member of a union.  */\n-      if (TREE_CODE (type) == UNION_TYPE && CONSTRUCTOR_NELTS (ctor)\n-\t  && CONSTRUCTOR_ELT (ctor, 0)->index != index)\n-\tvec_safe_truncate (CONSTRUCTOR_ELTS (ctor), 0);\n-      /* If the bit offset of INDEX is larger than that of the last\n-\t constructor_elt, then we can just immediately append a new\n-\t constructor_elt to the end of CTOR.  */\n-      else if (CONSTRUCTOR_NELTS (ctor)\n-\t       && tree_int_cst_compare (\n-\t\t    bit_position (index),\n-\t\t    bit_position (CONSTRUCTOR_ELTS (ctor)->last ().index))\n-\t\t    > 0)\n-\t{\n-\t  idx = CONSTRUCTOR_NELTS (ctor);\n-\t  goto insert;\n-\t}\n-\n-      /* Otherwise, we need to iterate over CTOR to find or insert INDEX\n-\t appropriately.  */\n-\n-      for (; vec_safe_iterate (CONSTRUCTOR_ELTS (ctor), idx, &cep);\n-\t   idx++, fields = DECL_CHAIN (fields))\n-\t{\n-\t  if (index == cep->index)\n-\t    goto found;\n-\n-\t  /* The field we're initializing must be on the field\n-\t     list.  Look to see if it is present before the\n-\t     field the current ELT initializes.  */\n-\t  for (; fields != cep->index; fields = DECL_CHAIN (fields))\n-\t    if (index == fields)\n-\t      goto insert;\n-\t}\n-      /* We fell off the end of the CONSTRUCTOR, so insert a new\n-\t entry at the end.  */\n-\n-      insert : {\n-\tconstructor_elt ce = {index, NULL_TREE};\n-\n-\tvec_safe_insert (CONSTRUCTOR_ELTS (ctor), idx, ce);\n-\tcep = CONSTRUCTOR_ELT (ctor, idx);\n-      }\n-    found:;\n-\n-      return cep;\n-    }\n-}\n-\n /* Complain about a const object OBJ being modified in a constant expression.\n    EXPR is the MODIFY_EXPR expression performing the modification.  */\n \n@@ -2617,31 +2978,6 @@ var_in_maybe_constexpr_fn (tree t)\n   return (DECL_FUNCTION_SCOPE_P (t) && maybe_constexpr_fn (DECL_CONTEXT (t)));\n }\n \n-// forked from gcc/cp/constexpr.cc array_index_cmp\n-\n-/* Some of the expressions fed to the constexpr mechanism are calls to\n-   constructors, which have type void.  In that case, return the type being\n-   initialized by the constructor.  */\n-\n-static tree\n-initialized_type (tree t)\n-{\n-  if (TYPE_P (t))\n-    return t;\n-  tree type = TREE_TYPE (t);\n-  if (TREE_CODE (t) == CALL_EXPR)\n-    {\n-      /* A constructor call has void type, so we need to look deeper.  */\n-      tree fn = get_function_named_in_call (t);\n-      if (fn && TREE_CODE (fn) == FUNCTION_DECL && DECL_CXX_CONSTRUCTOR_P (fn))\n-\ttype = DECL_CONTEXT (fn);\n-    }\n-  else if (TREE_CODE (t) == COMPOUND_EXPR)\n-    return initialized_type (TREE_OPERAND (t, 1));\n-\n-  return cv_unqualified (type);\n-}\n-\n /* P0859: A function is needed for constant evaluation if it is a constexpr\n    function that is named by an expression ([basic.def.odr]) that is\n    potentially constant evaluated.\n@@ -2854,96 +3190,6 @@ find_array_ctor_elt (tree ary, tree dindex, bool insert)\n   return -1;\n }\n \n-/* Return true if T is a valid constant initializer.  If a CONSTRUCTOR\n-   initializes all the members, the CONSTRUCTOR_NO_CLEARING flag will be\n-   cleared.\n-   FIXME speed this up, it's taking 16% of compile time on sieve testcase.  */\n-\n-bool\n-reduced_constant_expression_p (tree t)\n-{\n-  if (t == NULL_TREE)\n-    return false;\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case PTRMEM_CST:\n-      /* Even if we can't lower this yet, it's constant.  */\n-      return true;\n-\n-    case CONSTRUCTOR:\n-      /* And we need to handle PTRMEM_CST wrapped in a CONSTRUCTOR.  */\n-      tree field;\n-      if (CONSTRUCTOR_NO_CLEARING (t))\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n-\t    /* An initialized vector would have a VECTOR_CST.  */\n-\t    return false;\n-\t  else if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-\t    {\n-\t      /* There must be a valid constant initializer at every array\n-\t\t index.  */\n-\t      tree min = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (t)));\n-\t      tree max = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (t)));\n-\t      tree cursor = min;\n-\t      for (auto &e : CONSTRUCTOR_ELTS (t))\n-\t\t{\n-\t\t  if (!reduced_constant_expression_p (e.value))\n-\t\t    return false;\n-\t\t  if (array_index_cmp (cursor, e.index) != 0)\n-\t\t    return false;\n-\t\t  if (TREE_CODE (e.index) == RANGE_EXPR)\n-\t\t    cursor = TREE_OPERAND (e.index, 1);\n-\t\t  cursor = int_const_binop (PLUS_EXPR, cursor, size_one_node);\n-\t\t}\n-\t      if (find_array_ctor_elt (t, max) == -1)\n-\t\treturn false;\n-\t      goto ok;\n-\t    }\n-\t  else if (TREE_CODE (TREE_TYPE (t)) == UNION_TYPE)\n-\t    {\n-\t      if (CONSTRUCTOR_NELTS (t) == 0)\n-\t\t/* An initialized union has a constructor element.  */\n-\t\treturn false;\n-\t      /* And it only initializes one member.  */\n-\t      field = NULL_TREE;\n-\t    }\n-\t  else\n-\t    field = next_initializable_field (TYPE_FIELDS (TREE_TYPE (t)));\n-\t}\n-      else\n-\tfield = NULL_TREE;\n-      for (auto &e : CONSTRUCTOR_ELTS (t))\n-\t{\n-\t  /* If VAL is null, we're in the middle of initializing this\n-\t     element.  */\n-\t  if (!reduced_constant_expression_p (e.value))\n-\t    return false;\n-\t  /* Empty class field may or may not have an initializer.  */\n-\t  for (; field && e.index != field;\n-\t       field = next_initializable_field (DECL_CHAIN (field)))\n-\t    if (!is_really_empty_class (TREE_TYPE (field),\n-\t\t\t\t\t/*ignore_vptr*/ false))\n-\t      return false;\n-\t  if (field)\n-\t    field = next_initializable_field (DECL_CHAIN (field));\n-\t}\n-      /* There could be a non-empty field at the end.  */\n-      for (; field; field = next_initializable_field (DECL_CHAIN (field)))\n-\tif (!is_really_empty_class (TREE_TYPE (field), /*ignore_vptr*/ false))\n-\t  return false;\n-    ok:\n-      if (CONSTRUCTOR_NO_CLEARING (t))\n-\t/* All the fields are initialized.  */\n-\tCONSTRUCTOR_NO_CLEARING (t) = false;\n-      return true;\n-\n-    default:\n-      /* FIXME are we calling this too much?  */\n-      return initializer_constant_valid_p (t, TREE_TYPE (t)) != NULL_TREE;\n-    }\n-}\n-\n /* Some expressions may have constant operands but are not constant\n    themselves, such as 1/0.  Call this function to check for that\n    condition."}, {"sha": "289b4b95801a114cd2297e304495b60aa642e388", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc514d024a232dacfe218706dd07dcf01a51314/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc514d024a232dacfe218706dd07dcf01a51314/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=bbc514d024a232dacfe218706dd07dcf01a51314", "patch": "@@ -4079,4 +4079,33 @@ build_new_constexpr_heap_type (tree elt_type, tree cookie_size, tree full_size)\n   return rtype;\n }\n \n+// forked from gcc/cp/class.cc field_poverlapping_p\n+\n+/* Return true iff FIELD_DECL DECL is potentially overlapping.  */\n+\n+static bool\n+field_poverlapping_p (tree decl)\n+{\n+  return lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (decl));\n+}\n+\n+// forked from gcc/cp/class.cc is_empty_field\n+\n+/* Return true iff DECL is an empty field, either for an empty base or a\n+   [[no_unique_address]] data member.  */\n+\n+bool\n+is_empty_field (tree decl)\n+{\n+  if (!decl || TREE_CODE (decl) != FIELD_DECL)\n+    return false;\n+\n+  bool r = (is_empty_class (TREE_TYPE (decl)) && (field_poverlapping_p (decl)));\n+\n+  /* Empty fields should have size zero.  */\n+  gcc_checking_assert (!r || integer_zerop (DECL_SIZE (decl)));\n+\n+  return r;\n+}\n+\n } // namespace Rust"}, {"sha": "f466a81962e3499b55e7e65473a4c7ca9914a80a", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc514d024a232dacfe218706dd07dcf01a51314/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc514d024a232dacfe218706dd07dcf01a51314/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=bbc514d024a232dacfe218706dd07dcf01a51314", "patch": "@@ -1269,6 +1269,8 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n #define CONSTRUCTOR_PLACEHOLDER_BOUNDARY(NODE)                                 \\\n   (TREE_LANG_FLAG_5 (CONSTRUCTOR_CHECK (NODE)))\n \n+#define AGGR_INIT_EXPR_SLOT(NODE) TREE_OPERAND (AGGR_INIT_EXPR_CHECK (NODE), 2)\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\\n@@ -2605,6 +2607,8 @@ extern bool decl_constant_var_p (tree);\n \n extern tree build_new_constexpr_heap_type (tree, tree, tree);\n \n+extern bool is_empty_field (tree);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum"}]}