{"sha": "cc2902df52a39b343d5094a39d3e6efb868015de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MyOTAyZGY1MmEzOWIzNDNkNTA5NGEzOWQzZTZlZmI4NjgwMTVkZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-22T14:09:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-22T14:09:34Z"}, "message": "dbxout.c: Follow spelling conventions.\n\n\t* dbxout.c: Follow spelling conventions.\n\t* defaults.h: Likewise.\n\t* df.c: Likewise.\n\t* diagnostic.h: Likewise.\n\t* doloop.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* dwarfout.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* except.c: Likewise.\n\t* explow.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* expr.h: Likewise.\n\t* flags.h: Likewise.\n\t* flow.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\t* function.h: Likewise.\n\t* gcc.c: Likewise.\n\t* gcov-io.h: Likewise.\n\t* gcov.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattrtab.c: Likewise.\n\t* genconfig.c: Likewise.\n\t* genrecog.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* ggc.h: Likewise.\n\t* global.c: Likewise.\n\t* gthr-win32.h: Likewise.\n\t* integrate.c: Likewise.\n\t* jump.c: Likewise.\n\t* langhooks.c: Likewise.\n\t* langhooks.h: Likewise.\n\t* line-map.h: Likewise.\n\t* local-alloc.c: Likewise.\n\t* longlong.h: Likewise.\n\t* loop.c: Likewise.\n\t* loop.h: Likewise.\n\nFrom-SVN: r57406", "tree": {"sha": "d2db7ebbe3f404f7fa5e30b7ecf4ac4675f5b518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2db7ebbe3f404f7fa5e30b7ecf4ac4675f5b518"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc2902df52a39b343d5094a39d3e6efb868015de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2902df52a39b343d5094a39d3e6efb868015de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2902df52a39b343d5094a39d3e6efb868015de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2902df52a39b343d5094a39d3e6efb868015de/comments", "author": null, "committer": null, "parents": [{"sha": "4bc38b68640a996a5a1a9e870a707836ca32bfa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc38b68640a996a5a1a9e870a707836ca32bfa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc38b68640a996a5a1a9e870a707836ca32bfa9"}], "stats": {"total": 353, "additions": 197, "deletions": 156}, "files": [{"sha": "7c0a807dc13f02bc458ea4da2959f6228ab0fb8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -1,3 +1,44 @@\n+2002-09-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* dbxout.c: Follow spelling conventions.\n+\t* defaults.h: Likewise.\n+\t* df.c: Likewise.\n+\t* diagnostic.h: Likewise.\n+\t* doloop.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* dwarfout.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* except.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* expr.h: Likewise.\n+\t* flags.h: Likewise.\n+\t* flow.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\t* function.h: Likewise.\n+\t* gcc.c: Likewise.\n+\t* gcov-io.h: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattrtab.c: Likewise.\n+\t* genconfig.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* ggc.h: Likewise.\n+\t* global.c: Likewise.\n+\t* gthr-win32.h: Likewise.\n+\t* integrate.c: Likewise.\n+\t* jump.c: Likewise.\n+\t* langhooks.c: Likewise.\n+\t* langhooks.h: Likewise.\n+\t* line-map.h: Likewise.\n+\t* local-alloc.c: Likewise.\n+\t* longlong.h: Likewise.\n+\t* loop.c: Likewise.\n+\t* loop.h: Likewise.\n+\n Tue Aug 27 22:26:35 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (BIGGEST_FIELD_ALIGNMENT): Set proper default for x86_64."}, {"sha": "2ce0fb8ff23de4d03b0722b3163fe6aeea2a884c", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -2460,7 +2460,7 @@ dbxout_finish_symbol (sym)\n #endif\n }\n \n-/* Output definitions of all the decls in a chain. Return non-zero if\n+/* Output definitions of all the decls in a chain. Return nonzero if\n    anything was output */\n \n int"}, {"sha": "a3b5f7e8e29595d91e8d3c43b899ca6ec43731d7", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -430,7 +430,7 @@ do { fputs (integer_asm_op (POINTER_SIZE / UNITS_PER_WORD, TRUE), FILE); \\\n #endif\n \n /* By default, the C++ compiler will use function addresses in the\n-   vtable entries.  Setting this non-zero tells the compiler to use\n+   vtable entries.  Setting this nonzero tells the compiler to use\n    function descriptors instead.  The value of this macro says how\n    many words wide the descriptor is (normally 2).  It is assumed \n    that the address of a function descriptor may be treated as a"}, {"sha": "6a08e4725db134532ab1e9be660094014cccc55f", "filename": "gcc/df.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -2289,7 +2289,7 @@ df_refs_update (df)\n }\n \n \n-/* Return non-zero if any of the requested blocks in the bitmap\n+/* Return nonzero if any of the requested blocks in the bitmap\n    BLOCKS have been modified.  */\n static int\n df_modified_p (df, blocks)\n@@ -2951,7 +2951,7 @@ df_insn_dominates_all_uses_p (df, bb, insn)\n }\n \n \n-/* Return non-zero if all DF dominates all the uses within the bitmap\n+/* Return nonzero if all DF dominates all the uses within the bitmap\n    BLOCKS.  */\n static int\n df_def_dominates_uses_p (df, def, blocks)\n@@ -2982,7 +2982,7 @@ df_def_dominates_uses_p (df, def, blocks)\n }\n \n \n-/* Return non-zero if all the defs of INSN within BB dominates\n+/* Return nonzero if all the defs of INSN within BB dominates\n    all the corresponding uses.  */\n int\n df_insn_dominates_uses_p (df, bb, insn, blocks)\n@@ -3029,7 +3029,7 @@ df_regno_bb (df, regno)\n }\n \n \n-/* Return non-zero if REG used in multiple basic blocks.  */\n+/* Return nonzero if REG used in multiple basic blocks.  */\n int\n df_reg_global_p (df, reg)\n      struct df *df;\n@@ -3049,7 +3049,7 @@ df_reg_lifetime (df, reg)\n }\n \n \n-/* Return non-zero if REG live at start of BB.  */\n+/* Return nonzero if REG live at start of BB.  */\n int\n df_bb_reg_live_start_p (df, bb, reg)\n      struct df *df ATTRIBUTE_UNUSED;\n@@ -3067,7 +3067,7 @@ df_bb_reg_live_start_p (df, bb, reg)\n }\n \n \n-/* Return non-zero if REG live at end of BB.  */\n+/* Return nonzero if REG live at end of BB.  */\n int\n df_bb_reg_live_end_p (df, bb, reg)\n      struct df *df ATTRIBUTE_UNUSED;"}, {"sha": "aad9a58cbedff2a11cd852e339a06dfcc609de8d", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -275,7 +275,7 @@ extern diagnostic_context *global_dc;\n /* Similarly, but for sorrys.  */\n #define sorrycount diagnostic_kind_count (global_dc, DK_SORRY)\n \n-/* Returns non-zero if warnings should be emitted.  */\n+/* Returns nonzero if warnings should be emitted.  */\n #define diagnostic_report_warnings_p()\t\t\t\\\n   (!inhibit_warnings\t\t\t\t\t\\\n    && !(in_system_header && !warn_system_headers))"}, {"sha": "f79fbad15246ab5d5b67df844c58b72fe642c5ae", "filename": "gcc/doloop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -140,7 +140,7 @@ doloop_condition_get (pattern)\n \n /* Return an estimate of the maximum number of loop iterations for the\n    loop specified by LOOP or zero if the loop is not normal.\n-   MODE is the mode of the iteration count and NONNEG is non-zero if\n+   MODE is the mode of the iteration count and NONNEG is nonzero if\n    the iteration count has been proved to be non-negative.  */\n static unsigned HOST_WIDE_INT\n doloop_iterations_max (loop_info, mode, nonneg)\n@@ -249,7 +249,7 @@ doloop_iterations_max (loop_info, mode, nonneg)\n }\n \n \n-/* Return non-zero if the loop specified by LOOP is suitable for\n+/* Return nonzero if the loop specified by LOOP is suitable for\n    the use of special low-overhead looping instructions.  */\n static int\n doloop_valid_p (loop, jump_insn)\n@@ -399,7 +399,7 @@ doloop_valid_p (loop, jump_insn)\n    number of loop iterations, ITERATIONS_MAX is a CONST_INT specifying\n    the maximum number of loop iterations, and DOLOOP_INSN is the\n    low-overhead looping insn to emit at the end of the loop.  This\n-   returns non-zero if it was successful.  */\n+   returns nonzero if it was successful.  */\n static int\n doloop_modify (loop, iterations, iterations_max,\n \t       doloop_seq, start_label, condition)\n@@ -539,7 +539,7 @@ doloop_modify (loop, iterations, iterations_max,\n    not present, we emit one.  The loop to modify is described by LOOP.\n    ITERATIONS_MAX is a CONST_INT specifying the estimated maximum\n    number of loop iterations.  DOLOOP_INSN is the low-overhead looping\n-   insn to insert.  Returns non-zero if loop successfully modified.  */\n+   insn to insert.  Returns nonzero if loop successfully modified.  */\n static int\n doloop_modify_runtime (loop, iterations_max,\n \t\t       doloop_seq, start_label, mode, condition)\n@@ -749,7 +749,7 @@ doloop_modify_runtime (loop, iterations_max,\n    suitable.  We distinguish between loops with compile-time bounds\n    and those with run-time bounds.  Information from LOOP is used to\n    compute the number of iterations and to determine whether the loop\n-   is a candidate for this optimization.  Returns non-zero if loop\n+   is a candidate for this optimization.  Returns nonzero if loop\n    successfully modified.  */\n int\n doloop_optimize (loop)"}, {"sha": "a312332efd5c7f19dc13a6fdcd6266e08a8c64a0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -1160,7 +1160,7 @@ static dw_cfa_location cfa_temp;\n   had better be the one we think we're using for this purpose.\n \n   Except: If the register being saved is the CFA register, and the\n-  offset is non-zero, we are saving the CFA, so we assume we have to\n+  offset is nonzero, we are saving the CFA, so we assume we have to\n   use DW_CFA_def_cfa_expression.  If the offset is 0, we assume that\n   the intent is to save the value of SP from the previous frame.\n \n@@ -3260,7 +3260,7 @@ limbo_die_node;\n #define ASM_COMMENT_START \";#\"\n #endif\n \n-/* Define a macro which returns non-zero for a TYPE_DECL which was\n+/* Define a macro which returns nonzero for a TYPE_DECL which was\n    implicitly generated for a tagged type.\n \n    Note that unlike the gcc front end (which generates a NULL named\n@@ -3846,7 +3846,7 @@ type_main_variant (type)\n   return type;\n }\n \n-/* Return non-zero if the given type node represents a tagged type.  */\n+/* Return nonzero if the given type node represents a tagged type.  */\n \n static inline int\n is_tagged_type (type)\n@@ -7439,7 +7439,7 @@ root_type (type)\n     }\n }\n \n-/* Given a pointer to an arbitrary ..._TYPE tree node, return non-zero if the\n+/* Given a pointer to an arbitrary ..._TYPE tree node, return nonzero if the\n    given input type is a Dwarf \"fundamental\" type.  Otherwise return null.  */\n \n static inline int"}, {"sha": "9c720dbb85712cb90615b6a54f81fb0517fd512e", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -600,7 +600,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   fprintf ((FILE), \"%s\", reg_names[REGNO (RTX)])\n #endif\n \n-/* Define a macro which returns non-zero for any tagged type which is\n+/* Define a macro which returns nonzero for any tagged type which is\n    used (directly or indirectly) in the specification of either some\n    function's return type or some formal parameter of some function.\n    We use this macro when we are operating in \"terse\" mode to help us\n@@ -612,12 +612,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    for these nodes.  For now, we have to just fake it.  It it safe for\n    us to simply return zero for all complete tagged types (which will\n    get forced out anyway if they were used in the specification of some\n-   formal or return type) and non-zero for all incomplete tagged types.\n+   formal or return type) and nonzero for all incomplete tagged types.\n */\n \n #define TYPE_USED_FOR_FUNCTION(tagged_type) (TYPE_SIZE (tagged_type) == 0)\n \n-/* Define a macro which returns non-zero for a TYPE_DECL which was\n+/* Define a macro which returns nonzero for a TYPE_DECL which was\n    implicitly generated for a tagged type.\n \n    Note that unlike the gcc front end (which generates a NULL named\n@@ -707,7 +707,7 @@ static unsigned pending_siblings_allocated;\n \n #define PENDING_SIBLINGS_INCREMENT 64\n \n-/* Non-zero if we are performing our file-scope finalization pass and if\n+/* Nonzero if we are performing our file-scope finalization pass and if\n    we should force out Dwarf descriptions of any and all file-scope\n    tagged types which are still incomplete types.  */\n \n@@ -1325,7 +1325,7 @@ type_main_variant (type)\n   return type;\n }\n \n-/* Return non-zero if the given type node represents a tagged type.  */\n+/* Return nonzero if the given type node represents a tagged type.  */\n \n static inline int\n is_tagged_type (type)\n@@ -1950,7 +1950,7 @@ write_modifier_bytes (type, decl_const, decl_volatile)\n   write_modifier_bytes_1 (type, decl_const, decl_volatile, 0);\n }\n \f\n-/* Given a pointer to an arbitrary ..._TYPE tree node, return non-zero if the\n+/* Given a pointer to an arbitrary ..._TYPE tree node, return nonzero if the\n    given input type is a Dwarf \"fundamental\" type.  Otherwise return zero.  */\n \n static inline int\n@@ -4533,7 +4533,7 @@ pend_type (type)\n   TREE_ASM_WRITTEN (type) = 1;\n }\n \n-/* Return non-zero if it is legitimate to output DIEs to represent a\n+/* Return nonzero if it is legitimate to output DIEs to represent a\n    given type while we are generating the list of child DIEs for some\n    DIE (e.g. a function or lexical block DIE) associated with a given scope.\n "}, {"sha": "eded8158d53a0e2ddab884a1f04353fcea31a607", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -204,7 +204,7 @@ const_int_htab_hash (x)\n   return (hashval_t) INTVAL ((struct rtx_def *) x);\n }\n \n-/* Returns non-zero if the value represented by X (which is really a\n+/* Returns nonzero if the value represented by X (which is really a\n    CONST_INT) is the same as that given by Y (which is really a\n    HOST_WIDE_INT *).  */\n \n@@ -231,7 +231,7 @@ const_double_htab_hash (x)\n   return h;\n }\n \n-/* Returns non-zero if the value represented by X (really a ...)\n+/* Returns nonzero if the value represented by X (really a ...)\n    is the same as that represented by Y (really a ...) */\n static int\n const_double_htab_eq (x, y)\n@@ -264,7 +264,7 @@ mem_attrs_htab_hash (x)\n \t  ^ (size_t) p->expr);\n }\n \n-/* Returns non-zero if the value represented by X (which is really a\n+/* Returns nonzero if the value represented by X (which is really a\n    mem_attrs *) is the same as that given by Y (which is also really a\n    mem_attrs *).  */\n \n@@ -2067,7 +2067,7 @@ adjust_address_1 (memref, mode, offset, validate, adjust)\n   unsigned int memalign = MEM_ALIGN (memref);\n \n   /* ??? Prefer to create garbage instead of creating shared rtl.\n-     This may happen even if offset is non-zero -- consider\n+     This may happen even if offset is nonzero -- consider\n      (plus (plus reg reg) const_int) -- so do this always.  */\n   addr = copy_rtx (addr);\n \n@@ -3187,7 +3187,7 @@ mark_label_nuses (x)\n /* Try splitting insns that can be split for better scheduling.\n    PAT is the pattern which might split.\n    TRIAL is the insn providing PAT.\n-   LAST is non-zero if we should return the last insn of the sequence produced.\n+   LAST is nonzero if we should return the last insn of the sequence produced.\n \n    If this routine succeeds in splitting, it returns the first or last\n    replacement insn depending on the value of LAST.  Otherwise, it"}, {"sha": "26a231b87dbfd9dd61e62135a45f72547f6d57bb", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -353,7 +353,7 @@ static void sjlj_output_call_site_table\t\tPARAMS ((void));\n \n \f\n /* Routine to see if exception handling is turned on.\n-   DO_WARN is non-zero if we want to inform the user that exception\n+   DO_WARN is nonzero if we want to inform the user that exception\n    handling is turned off.\n \n    This is used to ensure that -fexceptions has been specified if the"}, {"sha": "8d5114397c979706054bcdcd50e9d067451a1f57", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -823,7 +823,7 @@ copy_to_suggested_reg (x, target, mode)\n    PUNSIGNEDP points to the signedness of the type and may be adjusted\n    to show what signedness to use on extension operations.\n \n-   FOR_CALL is non-zero if this call is promoting args for a call.  */\n+   FOR_CALL is nonzero if this call is promoting args for a call.  */\n \n enum machine_mode\n promote_mode (type, mode, punsignedp, for_call)\n@@ -1233,7 +1233,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n      always know its final value at this point in the compilation (it\n      might depend on the size of the outgoing parameter lists, for\n      example), so we must align the value to be returned in that case.\n-     (Note that STACK_DYNAMIC_OFFSET will have a default non-zero value if\n+     (Note that STACK_DYNAMIC_OFFSET will have a default nonzero value if\n      STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).\n      We must also do an alignment operation on the returned value if\n      the stack pointer alignment is less strict that BIGGEST_ALIGNMENT."}, {"sha": "37622f5ddd07784e77a9b1c3a7584356dd340be6", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -54,7 +54,7 @@ static rtx extract_split_bit_field\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n static void do_cmp_and_jump\t\tPARAMS ((rtx, rtx, enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx));\n \n-/* Non-zero means divides or modulus operations are relatively cheap for\n+/* Nonzero means divides or modulus operations are relatively cheap for\n    powers of two, so don't use branches; emit the operation instead.\n    Usually, this will mean that the MD file will emit non-branch\n    sequences.  */\n@@ -4170,7 +4170,7 @@ make_tree (type, x)\n    MODE is the machine mode for the computation.\n    X and MULT must have mode MODE.  ADD may have a different mode.\n    So can X (defaults to same as MODE).\n-   UNSIGNEDP is non-zero to do unsigned multiplication.  */\n+   UNSIGNEDP is nonzero to do unsigned multiplication.  */\n \n bool\n const_mult_add_overflow_p (x, mult, add, mode, unsignedp)\n@@ -4208,7 +4208,7 @@ const_mult_add_overflow_p (x, mult, add, mode, unsignedp)\n    MODE is the machine mode for the computation.\n    X and MULT must have mode MODE.  ADD may have a different mode.\n    So can X (defaults to same as MODE).\n-   UNSIGNEDP is non-zero to do unsigned multiplication.\n+   UNSIGNEDP is nonzero to do unsigned multiplication.\n    This may emit insns.  */\n \n rtx\n@@ -4622,7 +4622,7 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n   if (code == EQ || code == NE)\n     {\n       /* For EQ or NE, one way to do the comparison is to apply an operation\n-\t that converts the operand into a positive number if it is non-zero\n+\t that converts the operand into a positive number if it is nonzero\n \t or zero if it was originally zero.  Then, for EQ, we subtract 1 and\n \t for NE we negate.  This puts the result in the sign bit.  Then we\n \t normalize with a shift, if needed."}, {"sha": "6190866377c9135b5a400704cd667edb7429f629", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -231,7 +231,7 @@ enum insn_code movstr_optab[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block clears.  */\n enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n \n-/* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow.  */\n+/* SLOW_UNALIGNED_ACCESS is nonzero if unaligned accesses are very slow.  */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n@@ -4653,7 +4653,7 @@ store_constructor_field (target, bitsize, bitpos, mode, exp, type, cleared,\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR\n       && bitpos % BITS_PER_UNIT == 0\n-      /* If we have a non-zero bitpos for a register target, then we just\n+      /* If we have a nonzero bitpos for a register target, then we just\n \t let store_field do the bitfield handling.  This is unlikely to\n \t generate unnecessary clear instructions anyways.  */\n       && (bitpos == 0 || GET_CODE (target) == MEM))\n@@ -9288,7 +9288,7 @@ is_aligning_offset (offset, exp)\n }\n \f\n /* Return the tree node if an ARG corresponds to a string constant or zero\n-   if it doesn't.  If we return non-zero, set *PTR_OFFSET to the offset\n+   if it doesn't.  If we return nonzero, set *PTR_OFFSET to the offset\n    in bytes within the string that ARG is accessing.  The type of the\n    offset will be `sizetype'.  */\n \n@@ -9674,7 +9674,7 @@ do_jump (exp, if_false_label, if_true_label)\n     case NEGATE_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n-      /* These cannot change zero->non-zero or vice versa.  */\n+      /* These cannot change zero->nonzero or vice versa.  */\n       do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n       break;\n \n@@ -9700,7 +9700,7 @@ do_jump (exp, if_false_label, if_true_label)\n #endif\n \n     case MINUS_EXPR:\n-      /* Non-zero iff operands of minus differ.  */\n+      /* Nonzero iff operands of minus differ.  */\n       do_compare_and_jump (build (NE_EXPR, TREE_TYPE (exp),\n \t\t\t\t  TREE_OPERAND (exp, 0),\n \t\t\t\t  TREE_OPERAND (exp, 1)),\n@@ -10515,7 +10515,7 @@ do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n \n    If TARGET is nonzero, store the result there if convenient.\n \n-   If ONLY_CHEAP is non-zero, only do this if it is likely to be very\n+   If ONLY_CHEAP is nonzero, only do this if it is likely to be very\n    cheap.\n \n    Return zero if there is no suitable set-flag instruction"}, {"sha": "e8b2c1760646592c9740dcfa80301690fd55b7f5", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -303,7 +303,7 @@ rtx emit_conditional_move PARAMS ((rtx, enum rtx_code, rtx, rtx,\n \t\t\t\t   enum machine_mode, rtx, rtx,\n \t\t\t\t   enum machine_mode, int));\n \n-/* Return non-zero if the conditional move is supported.  */\n+/* Return nonzero if the conditional move is supported.  */\n int can_conditionally_move_p PARAMS ((enum machine_mode mode));\n \n #endif\n@@ -439,7 +439,7 @@ extern void use_group_regs PARAMS ((rtx *, rtx));\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n extern rtx clear_storage PARAMS ((rtx, rtx));\n \n-/* Return non-zero if it is desirable to store LEN bytes generated by\n+/* Return nonzero if it is desirable to store LEN bytes generated by\n    CONSTFUN with several move instructions by store_by_pieces\n    function.  CONSTFUNDATA is a pointer which will be passed as argument\n    in every CONSTFUN call."}, {"sha": "f033887e02c1e2852d14e4edf8bfb71f87fa6ff2", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -657,7 +657,7 @@ extern int flag_gcse_sm;\n \n extern int flag_eliminate_dwarf2_dups;\n \n-/* Non-zero means to collect statistics which might be expensive\n+/* Nonzero means to collect statistics which might be expensive\n    and to print them when we are done.  */\n extern int flag_detailed_statistics;\n "}, {"sha": "2905917cbcc7960fbe20d937490b0bb99fed6bc8", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -269,7 +269,7 @@ struct propagate_block_info\n   /* The length of mem_set_list.  */\n   int mem_set_list_len;\n \n-  /* Non-zero if the value of CC0 is live.  */\n+  /* Nonzero if the value of CC0 is live.  */\n   int cc0_live;\n \n   /* Flags controling the set of information propagate_block collects.  */\n@@ -797,7 +797,7 @@ update_life_info_in_dirty_blocks (extent, prop_flags)\n \n /* Free the variables allocated by find_basic_blocks.\n \n-   KEEP_HEAD_END_P is non-zero if basic_block_info is not to be freed.  */\n+   KEEP_HEAD_END_P is nonzero if basic_block_info is not to be freed.  */\n \n void\n free_basic_block_vars (keep_head_end_p)\n@@ -2042,7 +2042,7 @@ free_propagate_block_info (pbi)\n    case, the resulting set will be equal to the union of the two sets that\n    would otherwise be computed.\n \n-   Return non-zero if an INSN is deleted (i.e. by dead code removal).  */\n+   Return nonzero if an INSN is deleted (i.e. by dead code removal).  */\n \n int\n propagate_block (bb, live, local_set, cond_local_set, flags)\n@@ -2096,7 +2096,7 @@ propagate_block (bb, live, local_set, cond_local_set, flags)\n    (SET expressions whose destinations are registers dead after the insn).\n    NEEDED is the regset that says which regs are alive after the insn.\n \n-   Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.\n+   Unless CALL_OK is nonzero, an insn is needed if it contains a CALL.\n \n    If X is the entire body of an insn, NOTES contains the reg notes\n    pertaining to the insn.  */"}, {"sha": "2e869017dee72d33d9f0734125f1dbf6f6016255", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -649,7 +649,7 @@ div_and_round_double (code, uns,\n       int num_hi_sig, den_hi_sig;\n       unsigned HOST_WIDE_INT quo_est, scale;\n \n-      /* Find the highest non-zero divisor digit.  */\n+      /* Find the highest nonzero divisor digit.  */\n       for (i = 4 - 1;; i--)\n \tif (den[i] != 0)\n \t  {\n@@ -1350,7 +1350,7 @@ size_htab_hash (x)\n \t  ^ (TREE_OVERFLOW (t) << 20));\n }\n \n-/* Return non-zero if the value represented by *X (an INTEGER_CST tree node)\n+/* Return nonzero if the value represented by *X (an INTEGER_CST tree node)\n    is the same as that given by *Y, which is the same.  */\n \n static int\n@@ -1781,7 +1781,7 @@ truth_value_p (code)\n }\n \f\n /* Return nonzero if two operands are necessarily equal.\n-   If ONLY_CONST is non-zero, only return non-zero for constants.\n+   If ONLY_CONST is nonzero, only return nonzero for constants.\n    This function tests whether the operands are indistinguishable;\n    it does not test whether they are equal using C's == operation.\n    The distinction is important for IEEE floating point, because\n@@ -2015,7 +2015,7 @@ operand_equal_for_comparison_p (arg0, arg1, other)\n /* See if ARG is an expression that is either a comparison or is performing\n    arithmetic on comparisons.  The comparisons must only be comparing\n    two different values, which will be stored in *CVAL1 and *CVAL2; if\n-   they are non-zero it means that some operands have already been found.\n+   they are nonzero it means that some operands have already been found.\n    No variables may be used anywhere else in the expression except in the\n    comparisons.  If SAVE_P is true it means we removed a SAVE_EXPR around\n    the expression and save_expr needs to be called with CVAL1 and CVAL2.\n@@ -2400,7 +2400,7 @@ distribute_bit_expr (code, type, arg0, arg1)\n }\n \f\n /* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER\n-   starting at BITPOS.  The field is unsigned if UNSIGNEDP is non-zero.  */\n+   starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero.  */\n \n static tree\n make_bit_field_ref (inner, type, bitsize, bitpos, unsignedp)\n@@ -2673,7 +2673,7 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n   return inner;\n }\n \n-/* Return non-zero if MASK represents a mask of SIZE ones in the low-order\n+/* Return nonzero if MASK represents a mask of SIZE ones in the low-order\n    bit positions.  */\n \n static int\n@@ -4395,7 +4395,7 @@ count_cond (expr, lim)\n /* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.\n    Transform, `a + (x < y)' into `(x < y) ? (a + 1) : (a + 0)'.  Here\n    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x < y)'\n-   expression, and ARG to `a'.  If COND_FIRST_P is non-zero, then the\n+   expression, and ARG to `a'.  If COND_FIRST_P is nonzero, then the\n    COND is the first argument to CODE; otherwise (as in the example\n    given here), it is the second argument.  TYPE is the type of the\n    original expression.  */\n@@ -4527,7 +4527,7 @@ fold_binary_op_with_conditional_arg (code, type, cond, arg, cond_first_p)\n    TYPE, X + ADDEND is the same as X.  If NEGATE, return true if X -\n    ADDEND is the same as X.\n \n-   X + 0 and X - 0 both give X when X is NaN, infinite, or non-zero\n+   X + 0 and X - 0 both give X when X is NaN, infinite, or nonzero\n    and finite.  The problematic cases are when X is zero, and its mode\n    has signed zeros.  In the case of rounding towards -infinity,\n    X - 0 is not the same as X because 0 - 0 is -0.  In other rounding"}, {"sha": "374ed3c4b89507a9a0396ef2d3caae0877aa4074", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -181,13 +181,13 @@ struct temp_slot GTY(())\n   tree type;\n   /* The value of `sequence_rtl_expr' when this temporary is allocated.  */\n   tree rtl_expr;\n-  /* Non-zero if this temporary is currently in use.  */\n+  /* Nonzero if this temporary is currently in use.  */\n   char in_use;\n-  /* Non-zero if this temporary has its address taken.  */\n+  /* Nonzero if this temporary has its address taken.  */\n   char addr_taken;\n   /* Nesting level at which this slot is being used.  */\n   int level;\n-  /* Non-zero if this should survive a call to free_temp_slots.  */\n+  /* Nonzero if this should survive a call to free_temp_slots.  */\n   int keep;\n   /* The offset of the slot from the frame_pointer, including extra space\n      for alignment.  This info is for combine_temp_slots.  */\n@@ -3284,7 +3284,7 @@ insns_for_mem_hash (k)\n   return (hashval_t) m->key;\n }\n \n-/* Return non-zero if K1 and K2 (two REGs) are the same.  */\n+/* Return nonzero if K1 and K2 (two REGs) are the same.  */\n \n static int\n insns_for_mem_comp (k1, k2)\n@@ -3640,7 +3640,7 @@ instantiate_decls_1 (let, valid_only)\n /* Subroutine of the preceding procedures: Given RTL representing a\n    decl and the size of the object, do any instantiation required.\n \n-   If VALID_ONLY is non-zero, it means that the RTL should only be\n+   If VALID_ONLY is nonzero, it means that the RTL should only be\n    changed if the new address is valid.  */\n \n static void\n@@ -5204,7 +5204,7 @@ promoted_input_arg (regno, pmode, punsignedp)\n    The starting offset and size for this parm are returned in *OFFSET_PTR\n    and *ARG_SIZE_PTR, respectively.\n \n-   IN_REGS is non-zero if the argument will be passed in registers.  It will\n+   IN_REGS is nonzero if the argument will be passed in registers.  It will\n    never be set if REG_PARM_STACK_SPACE is not defined.\n \n    FNDECL is the function in which the argument was defined."}, {"sha": "c7a5e5e7e3bf6ffc1320fb6c6c2a2737331e8bcb", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -138,7 +138,7 @@ struct expr_status GTY(())\n      since code outside the conditional won't know whether or not the\n      arguments need to be popped.)\n \n-     When INHIBIT_DEFER_POP is non-zero, however, the compiler does not\n+     When INHIBIT_DEFER_POP is nonzero, however, the compiler does not\n      attempt to defer pops.  Instead, the stack is popped immediately\n      after each call.  Rather then setting this variable directly, use\n      NO_DEFER_POP and OK_DEFER_POP.  */\n@@ -222,7 +222,7 @@ struct function GTY(())\n      used for the current function's args.  */\n   CUMULATIVE_ARGS args_info;\n \n-  /* If non-zero, an RTL expression for the location at which the current \n+  /* If nonzero, an RTL expression for the location at which the current\n      function returns its result.  If the current function returns its\n      result in a register, current_function_return_rtx will always be\n      the hard register containing the result.  */"}, {"sha": "2210e2d2ea68a4936abb16d11f3d8bd70cd43bf9", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -234,7 +234,7 @@ modify_target[] = MODIFY_TARGET_NAME;\n #endif\n \n /* The number of errors that have occurred; the link phase will not be\n-   run if this is non-zero.  */\n+   run if this is nonzero.  */\n static int error_count = 0;\n \n /* Greatest exit code of sub-processes that has been encountered up to\n@@ -2151,7 +2151,7 @@ clear_failure_queue ()\n \f\n /* Build a list of search directories from PATHS.\n    PREFIX is a string to prepend to the list.\n-   If CHECK_DIR_P is non-zero we ensure the directory exists.\n+   If CHECK_DIR_P is nonzero we ensure the directory exists.\n    This is used mostly by putenv_from_prefixes so we use `collect_obstack'.\n    It is also used by the --print-search-dirs flag.  */\n "}, {"sha": "29a44017fde87ece5604b3943ead785dcd5eb8c6", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -46,7 +46,7 @@ static int __read_gcov_string PARAMS ((char *, size_t, FILE*, long))\n /* These routines only work for signed values.  */\n \n /* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.\n-   Return a non-zero value if VALUE requires more than BYTES*8-1 bits\n+   Return a nonzero value if VALUE requires more than BYTES*8-1 bits\n    to store.  */\n \n static int\n@@ -81,7 +81,7 @@ __store_gcov_type (value, dest, bytes)\n }\n \n /* Retrieve a quantity containing BYTES*8-1 bits from SOURCE and store\n-   the result in DEST. Returns a non-zero value if the value in SOURCE\n+   the result in DEST. Returns a nonzero value if the value in SOURCE\n    will not fit in DEST.  */\n \n static int\n@@ -130,7 +130,7 @@ __fetch_long (dest, source, bytes)\n   return 0;\n }\n \n-/* Write a BYTES*8-bit quantity to FILE, portably. Returns a non-zero\n+/* Write a BYTES*8-bit quantity to FILE, portably. Returns a nonzero\n    value if the write fails, or if VALUE can't be stored in BYTES*8\n    bits.\n \n@@ -168,7 +168,7 @@ __write_long (value, file, bytes)\n }\n \n /* Read a quantity containing BYTES bytes from FILE, portably. Return\n-   a non-zero value if the read fails or if the value will not fit\n+   a nonzero value if the read fails or if the value will not fit\n    in DEST.\n \n    Note that DEST may not be large enough to hold all of the requested"}, {"sha": "2360b0a25d41c74212c5e60817212384ee1f4f7b", "filename": "gcc/gcov.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -238,7 +238,7 @@ static int output_long_names = 0;\n static int output_function_summary = 0;\n \n /* Object directory file prefix.  This is the directory/file\n-   where .bb and .bbg files are looked for, if non-zero.  */\n+   where .bb and .bbg files are looked for, if nonzero.  */\n \n static char *object_directory = 0;\n \n@@ -1055,7 +1055,7 @@ scan_for_source_files ()\n \t}\n       /* There will be a zero before the first file name, in which case s_ptr\n \t will still be uninitialized.  So, only try to set the maxlineno\n-\t field if line_num is non-zero.  */\n+\t field if line_num is nonzero.  */\n       else if (line_num > 0)\n \t{\n \t  if (s_ptr->maxlineno <= line_num)"}, {"sha": "fbe3fcb1200782106c2f5d31ef0a3eac9be84f2e", "filename": "gcc/gcse.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -297,12 +297,12 @@ static FILE *debug_stderr;\n /* An obstack for our working variables.  */\n static struct obstack gcse_obstack;\n \n-/* Non-zero for each mode that supports (set (reg) (reg)).\n+/* Nonzero for each mode that supports (set (reg) (reg)).\n    This is trivially true for integer and floating point values.\n    It may or may not be true for condition codes.  */\n static char can_copy_p[(int) NUM_MACHINE_MODES];\n \n-/* Non-zero if can_copy_p has been initialized.  */\n+/* Nonzero if can_copy_p has been initialized.  */\n static int can_copy_init_p;\n \n struct reg_use {rtx reg_rtx; };\n@@ -344,9 +344,9 @@ struct occr\n   struct occr *next;\n   /* The insn that computes the expression.  */\n   rtx insn;\n-  /* Non-zero if this [anticipatable] occurrence has been deleted.  */\n+  /* Nonzero if this [anticipatable] occurrence has been deleted.  */\n   char deleted_p;\n-  /* Non-zero if this [available] occurrence has been copied to\n+  /* Nonzero if this [available] occurrence has been copied to\n      reaching_reg.  */\n   /* ??? This is mutually exclusive with deleted_p, so they could share\n      the same byte.  */\n@@ -1157,7 +1157,7 @@ compute_local_properties (transp, comp, antloc, table)\n \t    compute_transp (expr->expr, indx, transp, table->set_p);\n \n \t  /* The occurrences recorded in antic_occr are exactly those that\n-\t     we want to set to non-zero in ANTLOC.  */\n+\t     we want to set to nonzero in ANTLOC.  */\n \t  if (antloc)\n \t    for (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t      {\n@@ -1169,7 +1169,7 @@ compute_local_properties (transp, comp, antloc, table)\n \t      }\n \n \t  /* The occurrences recorded in avail_occr are exactly those that\n-\t     we want to set to non-zero in COMP.  */\n+\t     we want to set to nonzero in COMP.  */\n \t  if (comp)\n \t    for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n \t      {\n@@ -1341,7 +1341,7 @@ want_to_gcse_p (x)\n \t  && (num_clobbers == 0 || ! added_clobbers_hard_reg_p (icode)));\n }\n \n-/* Return non-zero if the operands of expression X are unchanged from the\n+/* Return nonzero if the operands of expression X are unchanged from the\n    start of INSN's basic block up to but not including INSN (if AVAIL_P == 0),\n    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */\n \n@@ -1524,7 +1524,7 @@ load_killed_in_block_p (bb, uid_limit, x, avail_p)\n   return 0;\n }\n \n-/* Return non-zero if the operands of expression X are unchanged from\n+/* Return nonzero if the operands of expression X are unchanged from\n    the start of INSN's basic block up to but not including INSN.  */\n \n static int\n@@ -1534,7 +1534,7 @@ oprs_anticipatable_p (x, insn)\n   return oprs_unchanged_p (x, insn, 0);\n }\n \n-/* Return non-zero if the operands of expression X are unchanged from\n+/* Return nonzero if the operands of expression X are unchanged from\n    INSN to the end of INSN's basic block.  */\n \n static int\n@@ -1787,7 +1787,7 @@ hash_set (regno, hash_table_size)\n   return hash % hash_table_size;\n }\n \n-/* Return non-zero if exp1 is equivalent to exp2.\n+/* Return nonzero if exp1 is equivalent to exp2.\n    ??? Borrowed from cse.c.  Might want to remerge with cse.c.  Later.  */\n \n static int\n@@ -1937,8 +1937,8 @@ expr_equiv_p (x, y)\n    MODE is the mode of the value X is being stored into.\n    It is only used if X is a CONST_INT.\n \n-   ANTIC_P is non-zero if X is an anticipatable expression.\n-   AVAIL_P is non-zero if X is an available expression.  */\n+   ANTIC_P is nonzero if X is an anticipatable expression.\n+   AVAIL_P is nonzero if X is an available expression.  */\n \n static void\n insert_expr_in_table (x, mode, insn, antic_p, avail_p, table)\n@@ -2255,7 +2255,7 @@ hash_scan_call (x, insn, table)\n    that isn't dealt with right now.  The trick is handling the CLOBBERs that\n    are also in the PARALLEL.  Later.\n \n-   If SET_P is non-zero, this is for the assignment hash table,\n+   If SET_P is nonzero, this is for the assignment hash table,\n    otherwise it is for the expression hash table.\n    If IN_LIBCALL_BLOCK nonzero, we are in a libcall block, and should\n    not record any expressions.  */\n@@ -2740,7 +2740,7 @@ reset_opr_set_tables ()\n   clear_modify_mem_tables ();\n }\n \n-/* Return non-zero if the operands of X are not set before INSN in\n+/* Return nonzero if the operands of X are not set before INSN in\n    INSN's basic block.  */\n \n static int\n@@ -3068,7 +3068,7 @@ compute_ae_gen (expr_hash_table)\n \tSET_BIT (ae_gen[BLOCK_NUM (occr->insn)], expr->bitmap_index);\n }\n \n-/* Return non-zero if expression X is killed in BB.  */\n+/* Return nonzero if expression X is killed in BB.  */\n \n static int\n expr_killed_p (x, bb)\n@@ -3157,9 +3157,9 @@ compute_ae_kill (ae_gen, ae_kill, expr_hash_table)\n \f\n /* Actually perform the Classic GCSE optimizations.  */\n \n-/* Return non-zero if occurrence OCCR of expression EXPR reaches block BB.\n+/* Return nonzero if occurrence OCCR of expression EXPR reaches block BB.\n \n-   CHECK_SELF_LOOP is non-zero if we should consider a block reaching itself\n+   CHECK_SELF_LOOP is nonzero if we should consider a block reaching itself\n    as a positive reach.  We want to do this when there are two computations\n    of the expression in the block.\n \n@@ -3318,7 +3318,7 @@ computing_insn (expr, insn)\n     }\n }\n \n-/* Return non-zero if the definition in DEF_INSN can reach INSN.\n+/* Return nonzero if the definition in DEF_INSN can reach INSN.\n    Only called by can_disregard_other_sets.  */\n \n static int\n@@ -3352,7 +3352,7 @@ def_reaches_here_p (insn, def_insn)\n   return 0;\n }\n \n-/* Return non-zero if *ADDR_THIS_REG can only have one value at INSN.  The\n+/* Return nonzero if *ADDR_THIS_REG can only have one value at INSN.  The\n    value returned is the number of definitions that reach INSN.  Returning a\n    value of zero means that [maybe] more than one definition reaches INSN and\n    the caller can't perform whatever optimization it is trying.  i.e. it is\n@@ -3404,7 +3404,7 @@ can_disregard_other_sets (addr_this_reg, insn, for_combine)\n /* Expression computed by insn is available and the substitution is legal,\n    so try to perform the substitution.\n \n-   The result is non-zero if any changes were made.  */\n+   The result is nonzero if any changes were made.  */\n \n static int\n handle_avail_expr (insn, expr)\n@@ -3562,7 +3562,7 @@ handle_avail_expr (insn, expr)\n /* Perform classic GCSE.  This is called by one_classic_gcse_pass after all\n    the dataflow analysis has been done.\n \n-   The result is non-zero if a change was made.  */\n+   The result is nonzero if a change was made.  */\n \n static int\n classic_gcse ()\n@@ -3621,7 +3621,7 @@ classic_gcse ()\n \n /* Top level routine to perform one classic GCSE pass.\n \n-   Return non-zero if a change was made.  */\n+   Return nonzero if a change was made.  */\n \n static int\n one_classic_gcse_pass (pass)\n@@ -3917,7 +3917,7 @@ find_used_regs (xptr, data)\n }\n \n /* Try to replace all non-SET_DEST occurrences of FROM in INSN with TO.\n-   Returns non-zero is successful.  */\n+   Returns nonzero is successful.  */\n \n static int\n try_replace_reg (from, to, insn)\n@@ -4146,7 +4146,7 @@ constprop_register (insn, from, to, alter_jumps)\n }\n \n /* Perform constant and copy propagation on INSN.\n-   The result is non-zero if a change was made.  */\n+   The result is nonzero if a change was made.  */\n \n static int\n cprop_insn (insn, alter_jumps)\n@@ -4407,7 +4407,7 @@ local_cprop_pass (alter_jumps)\n }\n \n /* Forward propagate copies.  This includes copies and constants.  Return\n-   non-zero if a change was made.  */\n+   nonzero if a change was made.  */\n \n static int\n cprop (alter_jumps)\n@@ -4838,7 +4838,7 @@ compute_pre_data ()\n \f\n /* PRE utilities */\n \n-/* Return non-zero if an occurrence of expression EXPR in OCCR_BB would reach\n+/* Return nonzero if an occurrence of expression EXPR in OCCR_BB would reach\n    block BB.\n \n    VISITED is a pointer to a working buffer for tracking which BB's have\n@@ -5294,7 +5294,7 @@ gcse_emit_move_after (src, dest, insn)\n    the expression into the result of the SET.  It is left to later passes\n    (cprop, cse2, flow, combine, regmove) to propagate the copy or eliminate it.\n \n-   Returns non-zero if a change is made.  */\n+   Returns nonzero if a change is made.  */\n \n static int\n pre_delete ()\n@@ -5419,7 +5419,7 @@ pre_gcse ()\n \n /* Top level routine to perform one PRE GCSE pass.\n \n-   Return non-zero if a change was made.  */\n+   Return nonzero if a change was made.  */\n \n static int\n one_pre_gcse_pass (pass)\n@@ -6192,7 +6192,7 @@ hoist_code ()\n \n /* Top level routine to perform one code hoisting (aka unification) pass\n \n-   Return non-zero if a change was made.  */\n+   Return nonzero if a change was made.  */\n \n static int\n one_code_hoisting_pass ()\n@@ -6658,7 +6658,7 @@ reg_set_info (dest, setter, data)\n     SET_BIT (*regvec, REGNO (dest));\n }\n \n-/* Return non-zero if the register operands of expression X are killed\n+/* Return nonzero if the register operands of expression X are killed\n    anywhere in basic block BB.  */\n \n static int\n@@ -7131,7 +7131,7 @@ insert_insn_start_bb (insn, bb)\n }\n \n /* This routine will insert a store on an edge. EXPR is the ldst entry for\n-   the memory reference, and E is the edge to insert it on.  Returns non-zero\n+   the memory reference, and E is the edge to insert it on.  Returns nonzero\n    if an edge insertion was performed.  */\n \n static int"}, {"sha": "bbc5a45c3eb7854291e394fb24a9162716f7530f", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -2093,7 +2093,7 @@ expand_units ()\n \t     fill the unit given the minimum issue delay.  FILL-TIME is the\n \t     constant \"MIN (ISSUE-DELAY (*,*)) * (SIMULTANEITY - 1)\", and\n \t     the simultaneity constraint is \"READY-COST (E) - FILL-TIME\"\n-\t     if SIMULTANEITY is non-zero and zero otherwise.\n+\t     if SIMULTANEITY is nonzero and zero otherwise.\n \n \t     Thus, BLOCKAGE (E,C) when SIMULTANEITY is zero is\n \n@@ -4315,7 +4315,7 @@ count_alternatives (exp)\n   return 0;\n }\n \f\n-/* Returns non-zero if the given expression contains an EQ_ATTR with the\n+/* Returns nonzero if the given expression contains an EQ_ATTR with the\n    `alternative' attribute.  */\n \n static int\n@@ -4348,7 +4348,7 @@ compares_alternatives_p (exp)\n   return 0;\n }\n \f\n-/* Returns non-zero is INNER is contained in EXP.  */\n+/* Returns nonzero is INNER is contained in EXP.  */\n \n static int\n contained_in_p (inner, exp)\n@@ -4558,7 +4558,7 @@ gen_unit (def, lineno)\n /* Given a piece of RTX, print a C expression to test its truth value.\n    We use AND and IOR both for logical and bit-wise operations, so\n    interpret them as logical unless they are inside a comparison expression.\n-   The first bit of FLAGS will be non-zero in that case.\n+   The first bit of FLAGS will be nonzero in that case.\n \n    Set the second bit of FLAGS to make references to attribute values use\n    a cached local variable instead of calling a function.  */\n@@ -5488,7 +5488,7 @@ write_indent (indent)\n }\n \f\n /* Write a subroutine that is given an insn that requires a delay slot, a\n-   delay slot ordinal, and a candidate insn.  It returns non-zero if the\n+   delay slot ordinal, and a candidate insn.  It returns nonzero if the\n    candidate can be placed in the specified delay slot of the insn.\n \n    We can write as many as three subroutines.  `eligible_for_delay'\n@@ -5807,7 +5807,7 @@ next_comma_elt (pstr)\n }\n \n /* Return a `struct attr_desc' pointer for a given named attribute.  If CREATE\n-   is non-zero, build a new attribute, if one does not exist.  */\n+   is nonzero, build a new attribute, if one does not exist.  */\n \n static struct attr_desc *\n find_attr (name, create)"}, {"sha": "795e312035654544cbf39bed6aa5e4155df7653a", "filename": "gcc/genconfig.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -55,10 +55,10 @@ static void gen_split PARAMS ((rtx));\n static void gen_peephole PARAMS ((rtx));\n static void gen_peephole2 PARAMS ((rtx));\n \n-/* RECOG_P will be non-zero if this pattern was seen in a context where it will\n+/* RECOG_P will be nonzero if this pattern was seen in a context where it will\n    be used to recognize, rather than just generate an insn. \n \n-   NON_PC_SET_SRC will be non-zero if this pattern was seen in a SET_SRC\n+   NON_PC_SET_SRC will be nonzero if this pattern was seen in a SET_SRC\n    of a SET whose destination is not (pc).  */\n \n static void"}, {"sha": "9900b990a66138fdfe96777d7f5b3f164de7873b", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -1200,7 +1200,7 @@ maybe_both_true_1 (d1, d2)\n    D1 and D2.  Otherwise, return 1 (it may be that there is an RTL that\n    can match both or just that we couldn't prove there wasn't such an RTL).\n \n-   TOPLEVEL is non-zero if we are to only look at the top level and not\n+   TOPLEVEL is nonzero if we are to only look at the top level and not\n    recursively descend.  */\n \n static int\n@@ -1677,7 +1677,7 @@ find_afterward (head, real_afterward)\n \f\n /* Assuming that the state of argument is denoted by OLDPOS, take whatever\n    actions are necessary to move to NEWPOS.  If we fail to move to the\n-   new state, branch to node AFTERWARD if non-zero, otherwise return.\n+   new state, branch to node AFTERWARD if nonzero, otherwise return.\n \n    Failure to move to the new state can only occur if we are trying to\n    match multiple insns and we try to step past the end of the stream.  */"}, {"sha": "9a2c03ef721184843d2a841a9c8d8736cca9d0a5", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -405,7 +405,7 @@ static void poison_pages PARAMS ((void));\n \n void debug_print_page_list PARAMS ((int));\n \f\n-/* Returns non-zero if P was allocated in GC'able memory.  */\n+/* Returns nonzero if P was allocated in GC'able memory.  */\n \n static inline int\n ggc_allocated_p (p)\n@@ -874,7 +874,7 @@ static unsigned char size_lookup[257] =\n   8\n };\n \n-/* Allocate a chunk of memory of SIZE bytes.  If ZERO is non-zero, the\n+/* Allocate a chunk of memory of SIZE bytes.  If ZERO is nonzero, the\n    memory is zeroed; otherwise, its contents are undefined.  */\n \n void *"}, {"sha": "4cd6242ee92cf3b8978aad0f1668d83b7f510d0c", "filename": "gcc/ggc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -130,7 +130,7 @@ extern void ggc_collect\t\t\tPARAMS ((void));\n \n /* Actually set the mark on a particular region of memory, but don't\n    follow pointers.  This function is called by ggc_mark_*.  It\n-   returns zero if the object was not previously marked; non-zero if\n+   returns zero if the object was not previously marked; nonzero if\n    the object was already marked, or if, for any other reason,\n    pointers in this data structure should not be traversed.  */\n extern int ggc_set_mark\t\t\tPARAMS ((const void *));"}, {"sha": "a100096238043e132b04d3ae6d8b4d7b1efdecf6", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -951,7 +951,7 @@ prune_preferences ()\n    of a long enough stretch of hard regs none of which conflicts with ALLOCNO.\n    The registers marked in PREFREGS are tried first.\n \n-   LOSERS, if non-zero, is a HARD_REG_SET indicating registers that cannot\n+   LOSERS, if nonzero, is a HARD_REG_SET indicating registers that cannot\n    be used for this allocation.\n \n    If ALT_REGS_P is zero, consider only the preferred class of ALLOCNO's reg."}, {"sha": "113fa5b79018e71c475012ae95f3ff2c0529410b", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -348,7 +348,7 @@ typedef void* __gthread_mutex_t;\n #if __MINGW32_MAJOR_VERSION >= 1 || \\\n   (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n #define MINGW32_SUPPORTS_MT_EH 1\n-/* Mingw runtime >= v0.3 provides a magic variable that is set to non-zero\n+/* Mingw runtime >= v0.3 provides a magic variable that is set to nonzero\n    if -mthreads option was specified, or 0 otherwise. This is to get around\n    the lack of weak symbols in PE-COFF.  */\n extern int _CRT_MT;"}, {"sha": "0e54e48b1cfcbe2ed87e6b3927c9b520a207c49e", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -1295,7 +1295,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n    Copying is done in two passes, first the insns and then their REG_NOTES.\n \n-   If static_chain_value is non-zero, it represents the context-pointer\n+   If static_chain_value is nonzero, it represents the context-pointer\n    register for the function.  */\n \n static void"}, {"sha": "5fef7b7311f5edb338e13797b623ca0eeecf731a", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -962,7 +962,7 @@ signed_condition (code)\n     }\n }\n \f\n-/* Return non-zero if CODE1 is more strict than CODE2, i.e., if the\n+/* Return nonzero if CODE1 is more strict than CODE2, i.e., if the\n    truth of CODE1 implies the truth of CODE2.  */\n \n int\n@@ -1255,7 +1255,7 @@ onlyjump_p (insn)\n \n #ifdef HAVE_cc0\n \n-/* Return non-zero if X is an RTX that only sets the condition codes\n+/* Return nonzero if X is an RTX that only sets the condition codes\n    and has no side effects.  */\n \n int"}, {"sha": "ccbb53485aa713c53410072bd9949cca05c0abeb", "filename": "gcc/langhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -260,7 +260,7 @@ lhd_decl_printable_name (decl, verbosity)\n    completely handled within this function, it should set *SUBTREES to\n    0, so that generic handling isn't attempted.  For language-specific\n    tree codes, generic handling would abort(), so make sure it is set\n-   properly.  Both SUBTREES and *SUBTREES is guaranteed to be non-zero\n+   properly.  Both SUBTREES and *SUBTREES is guaranteed to be nonzero\n    when the function is called.  */\n \n tree\n@@ -376,7 +376,7 @@ lhd_tree_inlining_anon_aggr_type_p (t)\n \n /* lang_hooks.tree_inlining.start_inlining and end_inlining perform any\n    language-specific bookkeeping necessary for processing\n-   FN. start_inlining returns non-zero if inlining should proceed, zero if\n+   FN. start_inlining returns nonzero if inlining should proceed, zero if\n    not.\n \n    For instance, the C++ version keeps track of template instantiations to\n@@ -408,7 +408,7 @@ lhd_tree_inlining_convert_parm_for_inlining (parm, value, fndecl)\n }\n \n /* lang_hooks.tree_dump.dump_tree:  Dump language-specific parts of tree\n-   nodes.  Returns non-zero if it does not want the usual dumping of the\n+   nodes.  Returns nonzero if it does not want the usual dumping of the\n    second argument.  */\n \n int"}, {"sha": "0518afed0ef729b61870dbaafca08dd7536a8767", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -78,7 +78,7 @@ struct lang_hooks_for_functions\n \n struct lang_hooks_for_tree_dump\n {\n-  /* Dump language-specific parts of tree nodes.  Returns non-zero if it\n+  /* Dump language-specific parts of tree nodes.  Returns nonzero if it\n      does not want the usual dumping of the second argument.  */\n   int (*dump_tree) PARAMS ((void *, tree));\n \n@@ -142,7 +142,7 @@ struct lang_hooks_for_decls\n      FUNCTIONBODY -- nonzero if this level is the body of a function.  */\n   tree (*poplevel) PARAMS ((int, int, int));\n \n-  /* Returns non-zero if we are in the global binding level.  Ada\n+  /* Returns nonzero if we are in the global binding level.  Ada\n      returns -1 for an undocumented reason used in stor-layout.c.  */\n   int (*global_bindings_p) PARAMS ((void));\n \n@@ -201,7 +201,7 @@ struct lang_hooks\n      Should return zero unless the compiler back-end does not need to\n      be initialized, such as with the -E option.\n      \n-     If errorcount is non-zero after this call the compiler exits\n+     If errorcount is nonzero after this call the compiler exits\n      immediately and the finish hook is not called.  */\n   bool (*post_options) PARAMS ((void));\n \n@@ -216,7 +216,7 @@ struct lang_hooks\n   /* Called at the end of compilation, as a finalizer.  */\n   void (*finish) PARAMS ((void));\n \n-  /* Parses the entire file.  The argument is non-zero to cause bison\n+  /* Parses the entire file.  The argument is nonzero to cause bison\n      parsers to dump debugging information during parsing.  */\n   void (*parse_file) PARAMS ((int));\n "}, {"sha": "60201887f491fd9826c5e4733ed909e22a81d0ce", "filename": "gcc/line-map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -109,7 +109,7 @@ extern void print_containing_files\n /* Returns the map a given map was included from.  */\n #define INCLUDED_FROM(SET, MAP) (&(SET)->maps[(MAP)->included_from])\n \n-/* Non-zero if the map is at the bottom of the include stack.  */\n+/* Nonzero if the map is at the bottom of the include stack.  */\n #define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n \n /* The current line map.  Saves a call to lookup_line if the caller is"}, {"sha": "9c94924aec92e896023bad355b785451dd524d85", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -577,7 +577,7 @@ equiv_init_varies_p (x)\n   return 0;\n }\n \n-/* Returns non-zero if X (used to initialize register REGNO) is movable.\n+/* Returns nonzero if X (used to initialize register REGNO) is movable.\n    X is only movable if the registers it uses have equivalent initializations\n    which appear to be within the same loop (or in an inner loop) and movable\n    or if they are not candidates for local_alloc and don't vary.  */\n@@ -1778,11 +1778,11 @@ qty_sugg_compare_1 (q1p, q2p)\n    If we really combined them, we could lose if the pseudo lives\n    across an insn that clobbers the hard reg (eg, movstr).\n \n-   ALREADY_DEAD is non-zero if USEDREG is known to be dead even though\n+   ALREADY_DEAD is nonzero if USEDREG is known to be dead even though\n    there is no REG_DEAD note on INSN.  This occurs during the processing\n    of REG_NO_CONFLICT blocks.\n \n-   MAY_SAVE_COPYCOPY is non-zero if this insn is simply copying USEDREG to\n+   MAY_SAVE_COPYCOPY is nonzero if this insn is simply copying USEDREG to\n    SETREG or if the input and output must share a register.\n    In that case, we record a hard reg suggestion in QTY_PHYS_COPY_SUGG.\n \n@@ -2099,7 +2099,7 @@ reg_is_born (reg, birth)\n     }\n }\n \n-/* Record the death of REG in the current insn.  If OUTPUT_P is non-zero,\n+/* Record the death of REG in the current insn.  If OUTPUT_P is nonzero,\n    REG is an output that is dying (i.e., it is never used), otherwise it\n    is an input (the normal case).\n    If OUTPUT_P is 1, then we extend the life past the end of this insn.  */\n@@ -2168,7 +2168,7 @@ wipe_dead_reg (reg, output_p)\n    If QTYNO crosses calls, insist on a register preserved by calls,\n    unless ACCEPT_CALL_CLOBBERED is nonzero.\n \n-   If JUST_TRY_SUGGESTED is non-zero, only try to see if the suggested\n+   If JUST_TRY_SUGGESTED is nonzero, only try to see if the suggested\n    register is available.  If not, return -1.  */\n \n static int\n@@ -2327,7 +2327,7 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n }\n \f\n /* Mark that REGNO with machine-mode MODE is live starting from the current\n-   insn (if LIFE is non-zero) or dead starting at the current insn (if LIFE\n+   insn (if LIFE is nonzero) or dead starting at the current insn (if LIFE\n    is zero).  */\n \n static void\n@@ -2346,7 +2346,7 @@ mark_life (regno, mode, life)\n }\n \n /* Mark register number REGNO (with machine-mode MODE) as live (if LIFE\n-   is non-zero) or dead (if LIFE is zero) from insn number BIRTH (inclusive)\n+   is nonzero) or dead (if LIFE is zero) from insn number BIRTH (inclusive)\n    to insn number DEATH (exclusive).  */\n \n static void"}, {"sha": "ca1dc7b3b4d72ba2b4d30faa52c57c1368fe238d", "filename": "gcc/longlong.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -66,7 +66,7 @@\n    is rounded towards 0.\n \n    5) count_leading_zeros(count, x) counts the number of zero-bits from the\n-   msb to the first non-zero bit in the UWtype X.  This is the number of\n+   msb to the first nonzero bit in the UWtype X.  This is the number of\n    steps X needs to be shifted left to set the msb.  Undefined for X == 0,\n    unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.\n "}, {"sha": "0a7fa9b262c3a9e50447bd6793bc30e7c991d22b", "filename": "gcc/loop.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -4222,7 +4222,7 @@ emit_prefetch_instructions (loop)\n \n static rtx note_insn;\n \n-/* Dummy register to have non-zero DEST_REG for DEST_ADDR type givs.  */\n+/* Dummy register to have nonzero DEST_REG for DEST_ADDR type givs.  */\n \n static rtx addr_placeholder;\n \n@@ -4594,7 +4594,7 @@ loop_givs_check (loop)\n }\n \n \n-/* Return non-zero if it is possible to eliminate the biv BL provided\n+/* Return nonzero if it is possible to eliminate the biv BL provided\n    all givs are reduced.  This is possible if either the reg is not\n    used outside the loop, or we can compute what its final value will\n    be.  */\n@@ -6498,7 +6498,7 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n    expression that is neither invariant nor a biv or giv), this routine\n    returns 0.\n \n-   For a non-zero return, the result will have a code of CONST_INT, USE,\n+   For a nonzero return, the result will have a code of CONST_INT, USE,\n    REG (for a BIV), PLUS, or MULT.  No other codes will occur.\n \n    *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */\n@@ -6851,7 +6851,7 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t\t      return simplify_giv_expr (loop, m->match->set_dest,\n \t\t\t\t\t\text_val, benefit);\n \n-\t\t    /* If consec is non-zero, this is a member of a group of\n+\t\t    /* If consec is nonzero, this is a member of a group of\n \t\t       instructions that were moved together.  We handle this\n \t\t       case only to the point of seeking to the last insn and\n \t\t       looking for a REG_EQUAL.  Fail if we don't find one.  */\n@@ -8586,7 +8586,7 @@ check_dbra_loop (loop, insn_count)\n /* Verify whether the biv BL appears to be eliminable,\n    based on the insns in the loop that refer to it.\n \n-   If ELIMINATE_P is non-zero, actually do the elimination.\n+   If ELIMINATE_P is nonzero, actually do the elimination.\n \n    THRESHOLD and INSN_COUNT are from loop_optimize and are used to\n    determine whether invariant insns should be placed inside or at the\n@@ -8658,7 +8658,7 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n }\n \f\n /* INSN and REFERENCE are instructions in the same insn chain.\n-   Return non-zero if INSN is first.  */\n+   Return nonzero if INSN is first.  */\n \n int\n loop_insn_first_p (insn, reference)\n@@ -8691,7 +8691,7 @@ loop_insn_first_p (insn, reference)\n     }\n }\n \n-/* We are trying to eliminate BIV in INSN using GIV.  Return non-zero if\n+/* We are trying to eliminate BIV in INSN using GIV.  Return nonzero if\n    the offset that we have to take into account due to auto-increment /\n    div derivation is zero.  */\n static int\n@@ -8718,10 +8718,10 @@ biv_elimination_giv_has_0_offset (biv, giv, insn)\n \n    If BIV does not appear in X, return 1.\n \n-   If ELIMINATE_P is non-zero, actually do the elimination.\n+   If ELIMINATE_P is nonzero, actually do the elimination.\n    WHERE_INSN/WHERE_BB indicate where extra insns should be added.\n    Depending on how many items have been moved out of the loop, it\n-   will either be before INSN (when WHERE_INSN is non-zero) or at the\n+   will either be before INSN (when WHERE_INSN is nonzero) or at the\n    start of the loop (when WHERE_INSN is zero).  */\n \n static int\n@@ -9191,14 +9191,14 @@ update_reg_last_use (x, insn)\n    If the condition cannot be understood, or is an inequality floating-point\n    comparison which needs to be reversed, 0 will be returned.\n \n-   If REVERSE is non-zero, then reverse the condition prior to canonizing it.\n+   If REVERSE is nonzero, then reverse the condition prior to canonizing it.\n \n-   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n+   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n    insn used in locating the condition was found.  If a replacement test\n    of the condition is desired, it should be placed in front of that\n    insn and we will be sure that the inputs are still valid.\n \n-   If WANT_REG is non-zero, we wish the condition to be relative to that\n+   If WANT_REG is nonzero, we wish the condition to be relative to that\n    register, if possible.  Therefore, do not canonicalize the condition\n    further.  */\n \n@@ -9240,7 +9240,7 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n \t && op1 == CONST0_RTX (GET_MODE (op0))\n \t && op0 != want_reg)\n     {\n-      /* Set non-zero when we find something of interest.  */\n+      /* Set nonzero when we find something of interest.  */\n       rtx x = 0;\n \n #ifdef HAVE_cc0\n@@ -9448,7 +9448,7 @@ canonicalize_condition (insn, cond, reverse, earliest, want_reg)\n    inequality floating-point comparison which needs to be reversed, 0 will\n    be returned.\n \n-   If EARLIEST is non-zero, it is a pointer to a place where the earliest\n+   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n    insn used in locating the condition was found.  If a replacement test\n    of the condition is desired, it should be placed in front of that\n    insn and we will be sure that the inputs are still valid.  */\n@@ -10448,7 +10448,7 @@ loop_insn_emit_after (loop, where_bb, where_insn, pattern)\n }\n \n \n-/* If WHERE_INSN is non-zero emit insn for PATTERN before WHERE_INSN\n+/* If WHERE_INSN is nonzero emit insn for PATTERN before WHERE_INSN\n    in basic block WHERE_BB (ignored in the interim) within the loop\n    otherwise hoist PATTERN into the loop pre-header.  */\n "}, {"sha": "d5fe0436dada2468e95a246f8fd640ee61eefbae", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2902df52a39b343d5094a39d3e6efb868015de/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=cc2902df52a39b343d5094a39d3e6efb868015de", "patch": "@@ -145,7 +145,7 @@ struct induction\n \t\t\t\t   same biv register.  */\n   struct induction *same;\t/* If this giv has been combined with another\n \t\t\t\t   giv, this points to the base giv.  The base\n-\t\t\t\t   giv will have COMBINED_WITH non-zero.  */\n+\t\t\t\t   giv will have COMBINED_WITH nonzero.  */\n   HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n \t\t\t\t   is split, and a constant is eliminated from\n \t\t\t\t   the address, the -constant is stored here\n@@ -377,7 +377,7 @@ struct loop_info\n   struct loop_regs regs;\n   /* The induction variable information in loop.  */\n   struct loop_ivs ivs;\n-  /* Non-zero if call is in pre_header extended basic block.  */\n+  /* Nonzero if call is in pre_header extended basic block.  */\n   int pre_header_has_call;\n };\n "}]}