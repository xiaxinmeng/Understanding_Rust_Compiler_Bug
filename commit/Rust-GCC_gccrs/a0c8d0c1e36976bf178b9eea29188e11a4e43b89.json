{"sha": "a0c8d0c1e36976bf178b9eea29188e11a4e43b89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBjOGQwYzFlMzY5NzZiZjE3OGI5ZWVhMjkxODhlMTFhNGU0M2I4OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-12-20T22:34:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-20T22:34:30Z"}, "message": "morestack.S (__morestack_non_split): If there is enough stack space already, don't split.\n\n\t* config/i386/morestack.S (__morestack_non_split): If there is\n\tenough stack space already, don't split.  Ask for more stack space\n\tthan we required.\n\nFrom-SVN: r182555", "tree": {"sha": "bbef8556fa5a1916624b2d5a114a335e949690c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbef8556fa5a1916624b2d5a114a335e949690c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0c8d0c1e36976bf178b9eea29188e11a4e43b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c8d0c1e36976bf178b9eea29188e11a4e43b89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0c8d0c1e36976bf178b9eea29188e11a4e43b89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0c8d0c1e36976bf178b9eea29188e11a4e43b89/comments", "author": null, "committer": null, "parents": [{"sha": "3752b2ab7cddf20ed4c99638a3ecf6ecfed6cf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3752b2ab7cddf20ed4c99638a3ecf6ecfed6cf55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3752b2ab7cddf20ed4c99638a3ecf6ecfed6cf55"}], "stats": {"total": 110, "additions": 108, "deletions": 2}, "files": [{"sha": "f5d02dd79fdec34485f25deb3fc98f42f029c01d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0c8d0c1e36976bf178b9eea29188e11a4e43b89/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0c8d0c1e36976bf178b9eea29188e11a4e43b89/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=a0c8d0c1e36976bf178b9eea29188e11a4e43b89", "patch": "@@ -1,3 +1,9 @@\n+2011-12-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* config/i386/morestack.S (__morestack_non_split): If there is\n+\tenough stack space already, don't split.  Ask for more stack space\n+\tthan we required.\n+\n 2011-12-20  Sergio Durigan Junior  <sergiodj@redhat.com>\n \n \t* unwind-arm-common.inc: Include `tconfig.h', `tsystem.h' and"}, {"sha": "8e0eb2009bc21063a996f89e208f9afb126eb355", "filename": "libgcc/config/i386/morestack.S", "status": "modified", "additions": 102, "deletions": 2, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0c8d0c1e36976bf178b9eea29188e11a4e43b89/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0c8d0c1e36976bf178b9eea29188e11a4e43b89/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fmorestack.S?ref=a0c8d0c1e36976bf178b9eea29188e11a4e43b89", "patch": "@@ -96,13 +96,113 @@\n #endif\n \n __morestack_non_split:\n+\t.cfi_startproc\n \n #ifndef __x86_64__\n-\taddl\t$0x4000,4(%esp)\n+\n+\t# See below for an extended explanation of the CFI instructions.\n+\t.cfi_offset 8, 8\t\t# New PC stored at CFA + 8\n+\t.cfi_escape 0x15, 4, 0x7d\t# DW_CFA_val_offset_sf, %esp, 12/-4\n+\t\t\t\t\t# i.e., next %esp is CFA + 12\n+\n+\tpushl\t%eax\t\t\t# Save %eax in case it is a parameter.\n+\n+\t.cfi_def_cfa %esp,8\t\t# Account for pushed register.\n+\n+\tmovl\t%esp,%eax\t\t# Current stack,\n+\tsubl\t8(%esp),%eax\t\t# less required stack frame size,\n+\tsubl\t$0x4000,%eax\t\t# less space for non-split code.\n+\tcmpl\t%gs:0x30,%eax\t\t# See if we have enough space.\n+\tjb\t2f\t\t\t# Get more space if we need it.\n+\n+\t# Here the stack is\n+\t#\t%esp + 20:\tstack pointer after two returns\n+\t#\t%esp + 16:\treturn address of morestack caller's caller\n+\t#\t%esp + 12:\tsize of parameters\n+\t#\t%esp + 8:\tnew stack frame size\n+\t#\t%esp + 4:\treturn address of this function\n+\t#\t%esp:\t\tsaved %eax\n+\t#\n+\t# Since we aren't doing a full split stack, we don't need to\n+\t# do anything when our caller returns.  So we return to our\n+\t# caller rather than calling it, and let it return as usual.\n+\t# To make that work we adjust the return address.\n+\n+\t# This breaks call/return address prediction for the call to\n+\t# this function.  I can't figure out a way to make it work\n+\t# short of copying the parameters down the stack, which will\n+\t# probably take more clock cycles than we will lose breaking\n+\t# call/return address prediction.  We will only break\n+\t# prediction for this call, not for our caller.\n+\n+\tmovl\t4(%esp),%eax\t\t# Increment the return address\n+\tcmpb\t$0xc3,(%eax)\t\t# to skip the ret instruction;\n+\tje\t1f\t\t\t# see above.\n+\taddl\t$2,%eax\n+1:\tinc\t%eax\n+\tmovl\t%eax,4(%esp)\t\t# Update return address.\n+\n+\tpopl\t%eax\t\t\t# Restore %eax and stack.\n+\n+\t.cfi_def_cfa %esp,4\t\t# Account for popped register.\n+\n+\tret\t$8\t\t\t# Return to caller, popping args.\n+\n+2:\n+\t.cfi_def_cfa %esp,8\t\t# Back to where we were.\n+\n+\tpopl\t%eax\t\t\t# Restore %eax and stack.\n+\n+\t.cfi_def_cfa %esp,4\t\t# Account for popped register.\n+\n+\taddl\t$0x5000+BACKOFF,4(%esp)\t# Increment space we request.\n+\n+\t# Fall through into morestack.\n+\n #else\n-\taddq\t$0x4000,%r10\n+\n+\t# See below for an extended explanation of the CFI instructions.\n+\t.cfi_offset 16, 0\n+\t.cfi_escape 0x15, 7, 0x7f\t# DW_CFA_val_offset_sf, %esp, 8/-8\n+\n+\tpushq\t%rax\t\t\t# Save %rax in case caller is using\n+\t\t\t\t\t# it to preserve original %r10.\n+\t.cfi_def_cfa %rsp,16\t\t# Adjust for pushed register.\n+\n+\tmovq\t%rsp,%rax\t\t# Current stack,\n+\tsubq\t%r10,%rax\t\t# less required stack frame size,\n+\tsubq\t$0x4000,%rax\t\t# less space for non-split code.\n+\n+#ifdef __LP64__\n+\tcmpq\t%fs:0x70,%rax\t\t# See if we have enough space.\n+#else\n+\tcmpl\t%fs:0x40,%eax\n #endif\n+\tjb\t2f\t\t\t# Get more space if we need it.\n+\n+\t# This breaks call/return prediction, as described above.\n+\tincq\t8(%rsp)\t\t\t# Increment the return address.\n+\n+\tpopq\t%rax\t\t\t# Restore register.\n+\n+\t.cfi_def_cfa %rsp,8\t\t# Adjust for popped register.\n \n+\tret\t\t\t\t# Return to caller.\n+\n+2:\n+\t.cfi_def_cfa %rsp,16\t\t# Back to where we were.\n+\n+\tpopq\t%rax\t\t\t# Restore register.\n+\n+\t.cfi_def_cfa %rsp,8\t\t# Adjust for popped register.\n+\n+\taddq\t$0x5000+BACKOFF,%r10\t# Increment space we request.\n+\n+\t# Fall throug into morestack.\n+\n+#endif\n+\n+\t.cfi_endproc\n #ifdef __ELF__\n \t.size\t__morestack_non_split, . - __morestack_non_split\n #endif"}]}