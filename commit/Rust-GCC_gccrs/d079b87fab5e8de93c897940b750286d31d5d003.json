{"sha": "d079b87fab5e8de93c897940b750286d31d5d003", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA3OWI4N2ZhYjVlOGRlOTNjODk3OTQwYjc1MDI4NmQzMWQ1ZDAwMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-06T18:18:42Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-06T18:18:42Z"}, "message": "i386-protos.h (x86_maybe_negate_const_int): Declare.\n\n\t* config/i386/i386-protos.h (x86_maybe_negate_const_int): Declare.\n\t* config/i386/i386.c (x86_maybe_negate_const_int): New.\n\t(x86_output_mi_thunk): Use x86_maybe_negate_const_int.\n\t* config/i386/i386.md (*add<mode>_1, *addsi_1_zext, *addhi_1,\n\t*addhi_1_lea, *addqi_1, *addqi_1_lea, *addqi_1_slp, *add<mode>_2,\n\t*addsi_2_zext, *addhi_2, *addqi_2, *add<mode>_3, *addsi_3_zext,\n\t*addhi_3, *addqi_3,*add<mode>_5, *addhi_5, *addqi_5):\n\tUse x86_maybe_negate_const_int to output insn mnemonic.\n\t(*adddi_4, *addsi_4, *addhi_4, *addqi_4): Ditto.  Remove overflow\n\tcheck from instruction predicate.  Update comments.\n\t* config/i386/sync.md (sync_add<mode>): Use\n\tx86_maybe_negate_const_int to output insn mnemonic.\n\nFrom-SVN: r158013", "tree": {"sha": "63fdad1fa0b970340be7cdd0dec1efa5a59642e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63fdad1fa0b970340be7cdd0dec1efa5a59642e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d079b87fab5e8de93c897940b750286d31d5d003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d079b87fab5e8de93c897940b750286d31d5d003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d079b87fab5e8de93c897940b750286d31d5d003", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d079b87fab5e8de93c897940b750286d31d5d003/comments", "author": null, "committer": null, "parents": [{"sha": "be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be59db2d47d5de2c73132b9ea45bdfa7692a4bd8"}], "stats": {"total": 373, "additions": 144, "deletions": 229}, "files": [{"sha": "a958473c12c9bd38fec223d63438062cbae26ef9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d079b87fab5e8de93c897940b750286d31d5d003", "patch": "@@ -1,12 +1,28 @@\n-2010-04-06  Jan Hubicka  <jh@suse.czpli\n+2010-04-06  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-protos.h (x86_maybe_negate_const_int): Declare.\n+\t* config/i386/i386.c (x86_maybe_negate_const_int): New.\n+\t(x86_output_mi_thunk): Use x86_maybe_negate_const_int.\n+\t* config/i386/i386.md (*add<mode>_1, *addsi_1_zext, *addhi_1,\n+\t*addhi_1_lea, *addqi_1, *addqi_1_lea, *addqi_1_slp, *add<mode>_2,\n+\t*addsi_2_zext, *addhi_2, *addqi_2, *add<mode>_3, *addsi_3_zext,\n+\t*addhi_3, *addqi_3,*add<mode>_5, *addhi_5, *addqi_5):\n+\tUse x86_maybe_negate_const_int to output insn mnemonic.\n+\t(*adddi_4, *addsi_4, *addhi_4, *addqi_4): Ditto.  Remove overflow\n+\tcheck from instruction predicate.  Update comments.\n+\t* config/i386/sync.md (sync_add<mode>): Use\n+\tx86_maybe_negate_const_int to output insn mnemonic.\n \n-\tPR tree-optimization/42906\n \n-\t* tree-ssa-dce.c (mark_control_dependent_edges_necessary): Add IGNORE_SELF\n-\targument; set visited_control_parents for fully processed BBs.\n+2010-04-06  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/42906\n+\t* tree-ssa-dce.c (mark_control_dependent_edges_necessary): Add\n+\tIGNORE_SELF argument.  Set visited_control_parents for fully\n+\tprocessed BBs.\n \t(find_obviously_necessary_stmts): Update call of\n \tmark_control_dependent_edges_necessary.\n-\t(propagate_necessity): Likewise; handle PHI edges more curefully.\n+\t(propagate_necessity): Likewise.  Handle PHI edges more curefully.\n \n 2010-04-06  Uros Bizjak  <ubizjak@gmail.com>\n \n@@ -52,7 +68,7 @@\n \n 2010-04-02  Steven Bosscher  <steven@gcc.gnu.org>\n \n-\t* ada/gcc-interface/Make-lang.in, alias.c, attribs.c, auto-inc-dec.c, \n+\t* ada/gcc-interface/Make-lang.in, alias.c, attribs.c, auto-inc-dec.c,\n \tbasic-block.h, bb-reorder.c, calls.c, c-common.c, cgraph.h,\n \tcollect2.h, config/alpha/alpha.c, config/alpha/alpha.md,\n \tconfig/alpha/predicates.md, config/arm/arm.md,\n@@ -123,7 +139,7 @@\n 2010-04-02  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/43469\n-\t* arm.c (legitimize_tls_address): Adjust call to \n+\t* arm.c (legitimize_tls_address): Adjust call to\n \tgen_tls_load_dot_plus_four.\n \t(arm_note_pic_base): New function.\n \t(arm_cannot_copy_insn_p): Use it.\n@@ -2684,7 +2700,7 @@\n \n 2010-02-15  Nick Clifton  <nickc@redhat.com>\n \n-\t* config/h8300/h8300.c: (h8300_push_pop): Use bool type for\n+\t* config/h8300/h8300.c (h8300_push_pop): Use bool type for\n \tboolean parameters.  Use emit_jump_insn when emitting a pop\n \tinstruction containing a return insn.\n \t(push): Use 'true' rather than '1' as second parameter to F."}, {"sha": "5c6140d88a0ba33212f3ce40eb47ac56945607c4", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=d079b87fab5e8de93c897940b750286d31d5d003", "patch": "@@ -44,6 +44,7 @@ extern int symbolic_reference_mentioned_p (rtx);\n extern bool extended_reg_mentioned_p (rtx);\n extern bool x86_extended_QIreg_mentioned_p (rtx);\n extern bool x86_extended_reg_mentioned_p (rtx);\n+extern bool x86_maybe_negate_const_int (rtx *, enum machine_mode);\n extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n \n extern int avx_vpermilp_parallel (rtx par, enum machine_mode mode);"}, {"sha": "d498b4730ebbb7a256e2f869d93753337db51c17", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d079b87fab5e8de93c897940b750286d31d5d003", "patch": "@@ -26202,10 +26202,7 @@ x86_output_mi_thunk (FILE *file,\n   /* Adjust the this parameter by a fixed constant.  */\n   if (delta)\n     {\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-         Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      bool sub = delta < 0 || delta == 128;\n-      xops[0] = GEN_INT (sub ? -delta : delta);\n+      xops[0] = GEN_INT (delta);\n       xops[1] = this_reg ? this_reg : this_param;\n       if (TARGET_64BIT)\n \t{\n@@ -26217,12 +26214,12 @@ x86_output_mi_thunk (FILE *file,\n \t      xops[0] = tmp;\n \t      xops[1] = this_param;\n \t    }\n-\t  if (sub)\n+\t  if (x86_maybe_negate_const_int (&xops[0], DImode))\n \t    output_asm_insn (\"sub{q}\\t{%0, %1|%1, %0}\", xops);\n \t  else\n \t    output_asm_insn (\"add{q}\\t{%0, %1|%1, %0}\", xops);\n \t}\n-      else if (sub)\n+      else if (x86_maybe_negate_const_int (&xops[0], SImode))\n \toutput_asm_insn (\"sub{l}\\t{%0, %1|%1, %0}\", xops);\n       else\n \toutput_asm_insn (\"add{l}\\t{%0, %1|%1, %0}\", xops);\n@@ -26649,6 +26646,52 @@ x86_extended_reg_mentioned_p (rtx insn)\n \t\t       extended_reg_mentioned_1, NULL);\n }\n \n+/* If profitable, negate (without causing overflow) integer constant\n+   of mode MODE at location LOC.  Return true in this case.  */\n+bool\n+x86_maybe_negate_const_int (rtx *loc, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT val;\n+\n+  if (!CONST_INT_P (*loc))\n+    return false;\n+\n+  switch (mode)\n+    {\n+    case DImode:\n+      /* DImode x86_64 constants must fit in 32 bits.  */\n+      gcc_assert (x86_64_immediate_operand (*loc, mode));\n+\n+      mode = SImode;\n+      break;\n+\n+    case SImode:\n+    case HImode:\n+    case QImode:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Avoid overflows.  */\n+  if (mode_signbit_p (mode, *loc))\n+    return false;\n+\n+  val = INTVAL (*loc);\n+\n+  /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n+     Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n+  if ((val < 0 && val != -128)\n+      || val == 128)\n+    {\n+      *loc = GEN_INT (-val);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Generate an unsigned DImode/SImode to FP conversion.  This is the same code\n    optabs would emit if we didn't have TFmode patterns.  */\n "}, {"sha": "8bd8e0f133abc11885a7e14f60819c9ee49549be", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 67, "deletions": 215, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d079b87fab5e8de93c897940b750286d31d5d003", "patch": "@@ -6010,20 +6010,9 @@\n         return \"add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n         \n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n+      if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n+        return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n \n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-\t  /* Avoid overflows.  */\n-\t  && (<MODE>mode != DImode\n-\t      || ((INTVAL (operands[2]) & ((((unsigned int) 1) << 31) - 1))))\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-        }\n       return \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6078,16 +6067,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], SImode))\n+        return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n+\n       return \"add{l}\\t{%2, %k0|%k0, %2}\";\n     }\n }\n@@ -6129,16 +6111,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subw $4,%ax' rather than `addw $-4,%ax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{w}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], HImode))\n+\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6179,16 +6154,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subw $4,%ax' rather than `addw $-4,%ax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{w}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], HImode))\n+\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6226,14 +6194,8 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subb $4,%al' rather than `addb $-4,%al'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n \t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n \t  if (widen)\n \t    return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n \t  else\n@@ -6280,14 +6242,8 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subb $4,%al' rather than `addb $-4,%al'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n \t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n \t  if (widen)\n \t    return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n \t  else\n@@ -6332,13 +6288,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subb $4,%al' rather than `addb $-4,%al'.  */\n-      if (CONST_INT_P (operands[1])\n-\t  && INTVAL (operands[1]) < 0)\n-\t{\n-\t  operands[1] = GEN_INT (-INTVAL (operands[1]));\n-\t  return \"sub{b}\\t{%1, %0|%0, %1}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[1], QImode))\n+\treturn \"sub{b}\\t{%1, %0|%0, %1}\";\n+\n       return \"add{b}\\t{%1, %0|%0, %1}\";\n     }\n }\n@@ -6383,19 +6335,9 @@\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       /* ???? In DImode, we ought to handle there the 32bit case too\n \t - do we need new constraint?  */\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-\t  /* Avoid overflows.  */\n-\t  && (<MODE>mode != DImode\n-\t      || ((INTVAL (operands[2]) & ((((unsigned int) 1) << 31) - 1))))\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n+        return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6437,16 +6379,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], SImode))\n+        return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n+\n       return \"add{l}\\t{%2, %k0|%k0, %2}\";\n     }\n }\n@@ -6484,16 +6419,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subw $4,%ax' rather than `addw $-4,%ax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{w}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], HImode))\n+\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6533,13 +6461,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subb $4,%al' rather than `addb $-4,%al'.  */\n-      if (CONST_INT_P (operands[2])\n-          && INTVAL (operands[2]) < 0)\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{b}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n+\treturn \"sub{b}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{b}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6577,19 +6501,9 @@\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n       /* ???? In DImode, we ought to handle there the 32bit case too\n \t - do we need new constraint?  */\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-\t  /* Avoid overflows.  */\n-\t  && (<MODE>mode != DImode\n-\t      || ((INTVAL (operands[2]) & ((((unsigned int) 1) << 31) - 1))))\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n+        return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6630,16 +6544,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], SImode))\n+        return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n+\n       return \"add{l}\\t{%2, %k0|%k0, %2}\";\n     }\n }\n@@ -6675,16 +6582,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subw $4,%ax' rather than `addw $-4,%ax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{w}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], HImode))\n+\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6722,13 +6622,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subb $4,%al' rather than `addb $-4,%al'.  */\n-      if (CONST_INT_P (operands[2])\n-          && INTVAL (operands[2]) < 0)\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{b}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n+\treturn \"sub{b}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{b}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6742,8 +6638,6 @@\n ; by converting cmp to add, inc or dec as done by peephole2.  This pattern\n ; is matched then.  We can't accept general immediate, because for\n ; case of overflows,  the result is messed up.\n-; This pattern also don't hold of 0x8000000000000000, since the value\n-; overflows when negated.\n ; Also carry flag is reversed compared to cmp, so this conversion is valid\n ; only for comparisons not depending on it.\n \n@@ -6769,16 +6663,10 @@\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if ((INTVAL (operands[2]) == -128\n-\t   || (INTVAL (operands[2]) > 0\n-\t       && INTVAL (operands[2]) != 128))\n-\t  /* Avoid overflows.  */\n-\t  && ((INTVAL (operands[2]) & ((((unsigned int) 1) << 31) - 1))))\n-\treturn \"sub{q}\\t{%2, %0|%0, %2}\";\n-      operands[2] = GEN_INT (-INTVAL (operands[2]));\n-      return \"add{q}\\t{%2, %0|%0, %2}\";\n+      if (x86_maybe_negate_const_int (&operands[2], DImode))\n+\treturn \"add{q}\\t{%2, %0|%0, %2}\";\n+\n+      return \"sub{q}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -6796,8 +6684,6 @@\n ; by converting cmp to add, inc or dec as done by peephole2.  This pattern\n ; is matched then.  We can't accept general immediate, because for\n ; case of overflows,  the result is messed up.\n-; This pattern also don't hold of 0x80000000, since the value overflows\n-; when negated.\n ; Also carry flag is reversed compared to cmp, so this conversion is valid\n ; only for comparisons not depending on it.\n \n@@ -6807,8 +6693,7 @@\n \t  (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n \t  (match_operand:SI 2 \"const_int_operand\" \"n\")))\n    (clobber (match_scratch:SI 0 \"=rm\"))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && (INTVAL (operands[2]) & 0xffffffff) != 0x80000000\"\n+  \"ix86_match_ccmode (insn, CCGCmode)\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -6823,14 +6708,10 @@\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if ((INTVAL (operands[2]) == -128\n-\t   || (INTVAL (operands[2]) > 0\n-\t       && INTVAL (operands[2]) != 128)))\n-\treturn \"sub{l}\\t{%2, %0|%0, %2}\";\n-      operands[2] = GEN_INT (-INTVAL (operands[2]));\n-      return \"add{l}\\t{%2, %0|%0, %2}\";\n+      if (x86_maybe_negate_const_int (&operands[2], SImode))\n+\treturn \"add{l}\\t{%2, %0|%0, %2}\";\n+\n+      return \"sub{l}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -6852,8 +6733,7 @@\n \t  (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n \t  (match_operand:HI 2 \"const_int_operand\" \"n\")))\n    (clobber (match_scratch:HI 0 \"=rm\"))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && (INTVAL (operands[2]) & 0xffff) != 0x8000\"\n+  \"ix86_match_ccmode (insn, CCGCmode)\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -6868,14 +6748,10 @@\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      /* Make things pretty and `subw $4,%ax' rather than `addw $-4,%ax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if ((INTVAL (operands[2]) == -128\n-\t   || (INTVAL (operands[2]) > 0\n-\t       && INTVAL (operands[2]) != 128)))\n-\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n-      operands[2] = GEN_INT (-INTVAL (operands[2]));\n-      return \"add{w}\\t{%2, %0|%0, %2}\";\n+      if (x86_maybe_negate_const_int (&operands[2], HImode))\n+\treturn \"add{w}\\t{%2, %0|%0, %2}\";\n+\n+      return \"sub{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -6897,8 +6773,7 @@\n \t  (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n \t  (match_operand:QI 2 \"const_int_operand\" \"n\")))\n    (clobber (match_scratch:QI 0 \"=qm\"))]\n-  \"ix86_match_ccmode (insn, CCGCmode)\n-   && (INTVAL (operands[2]) & 0xff) != 0x80\"\n+  \"ix86_match_ccmode (insn, CCGCmode)\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -6915,11 +6790,9 @@\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      if (INTVAL (operands[2]) < 0)\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"add{b}\\t{%2, %0|%0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n+\treturn \"add{b}\\t{%2, %0|%0, %2}\";\n+\n       return \"sub{b}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -6957,19 +6830,9 @@\n \n     default:\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      /* Make things pretty and `subl $4,%eax' rather than `addl $-4,%eax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-\t  /* Avoid overflows.  */\n-\t  && (<MODE>mode != DImode\n-\t      || ((INTVAL (operands[2]) & ((((unsigned int) 1) << 31) - 1))))\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-        {\n-          operands[2] = GEN_INT (-INTVAL (operands[2]));\n-          return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n-        }\n+      if (x86_maybe_negate_const_int (&operands[2], <MODE>mode))\n+        return \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -7006,16 +6869,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subw $4,%ax' rather than `addw $-4,%ax'.\n-\t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n-      if (CONST_INT_P (operands[2])\n-          && (INTVAL (operands[2]) == 128\n-\t      || (INTVAL (operands[2]) < 0\n-\t\t  && INTVAL (operands[2]) != -128)))\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{w}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], HImode))\n+\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n@@ -7054,13 +6910,9 @@\n \t}\n \n     default:\n-      /* Make things pretty and `subb $4,%al' rather than `addb $-4,%al'.  */\n-      if (CONST_INT_P (operands[2])\n-          && INTVAL (operands[2]) < 0)\n-\t{\n-\t  operands[2] = GEN_INT (-INTVAL (operands[2]));\n-\t  return \"sub{b}\\t{%2, %0|%0, %2}\";\n-\t}\n+      if (x86_maybe_negate_const_int (&operands[2], QImode))\n+\treturn \"sub{b}\\t{%2, %0|%0, %2}\";\n+\n       return \"add{b}\\t{%2, %0|%0, %2}\";\n     }\n }"}, {"sha": "feea16176bf33e5a06eb4669b25eb28f5323a5b6", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d079b87fab5e8de93c897940b750286d31d5d003/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=d079b87fab5e8de93c897940b750286d31d5d003", "patch": "@@ -202,6 +202,9 @@\n \treturn \"lock{%;| }dec{<imodesuffix>}\\t%0\";\n     }\n \n+  if (x86_maybe_negate_const_int (&operands[1], <MODE>mode))\n+    return \"lock{%;| }sub{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n+\n   return \"lock{%;| }add{<imodesuffix>}\\t{%1, %0|%0, %1}\";\n })\n "}]}