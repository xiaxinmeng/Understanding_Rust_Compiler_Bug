{"sha": "0e77949e878dd109ee7daffcda12faa1a8000d29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU3Nzk0OWU4NzhkZDEwOWVlN2RhZmZjZGExMmZhYTFhODAwMGQyOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-07T13:05:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-07T13:05:08Z"}, "message": "[multiple changes]\n\n2016-07-07  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.ads, sem_prag.adb (Build_Classwide_Expression): Include\n\toverridden operation as parameter, in order to map formals of\n\tthe overridden and overring operation properly prior to rewriting\n\tthe inherited condition.\n\t* freeze.adb (Check_Inherited_Cnonditions): Change call to\n\tBuild_Class_Wide_Expression accordingly.  In Spark_Mode, add\n\tcall to analyze the contract of the parent operation, prior to\n\tmapping formals between operations.\n\n2016-07-07  Arnaud Charlet  <charlet@adacore.com>\n\n\t* adabkend.adb (Scan_Back_End_Switches): Ignore -o/-G switches\n\tas done in back_end.adb.\n\t(Scan_Compiler_Args): Remove special case for CodePeer/SPARK, no longer\n\tneeded, and prevents proper handling of multi-unit sources.\n\n2016-07-07  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-sechas.adb, g-sechas.ads (GNAT.Secure_Hashes.H): Add Hash_Stream\n\ttype with Write primitive calling Update on the underlying context\n\t(and dummy Read primitive raising P_E).\n\n2016-07-07  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb: Minor reformatting.\n\nFrom-SVN: r238111", "tree": {"sha": "5124c182f5e68317d94f9bf2746f501ba4f7e9e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5124c182f5e68317d94f9bf2746f501ba4f7e9e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e77949e878dd109ee7daffcda12faa1a8000d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e77949e878dd109ee7daffcda12faa1a8000d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e77949e878dd109ee7daffcda12faa1a8000d29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e77949e878dd109ee7daffcda12faa1a8000d29/comments", "author": null, "committer": null, "parents": [{"sha": "7dccd19430283ffe5aac0bf55e42f84f5edcddcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dccd19430283ffe5aac0bf55e42f84f5edcddcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dccd19430283ffe5aac0bf55e42f84f5edcddcb"}], "stats": {"total": 274, "additions": 171, "deletions": 103}, "files": [{"sha": "d4e6482fe6e006dd33d542be26ca70fe98d422c2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -1,3 +1,31 @@\n+2016-07-07  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.ads, sem_prag.adb (Build_Classwide_Expression): Include\n+\toverridden operation as parameter, in order to map formals of\n+\tthe overridden and overring operation properly prior to rewriting\n+\tthe inherited condition.\n+\t* freeze.adb (Check_Inherited_Cnonditions): Change call to\n+\tBuild_Class_Wide_Expression accordingly.  In Spark_Mode, add\n+\tcall to analyze the contract of the parent operation, prior to\n+\tmapping formals between operations.\n+\n+2016-07-07  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* adabkend.adb (Scan_Back_End_Switches): Ignore -o/-G switches\n+\tas done in back_end.adb.\n+\t(Scan_Compiler_Args): Remove special case for CodePeer/SPARK, no longer\n+\tneeded, and prevents proper handling of multi-unit sources.\n+\n+2016-07-07  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-sechas.adb, g-sechas.ads (GNAT.Secure_Hashes.H): Add Hash_Stream\n+\ttype with Write primitive calling Update on the underlying context\n+\t(and dummy Read primitive raising P_E).\n+\n+2016-07-07  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch13.adb: Minor reformatting.\n+\n 2016-07-07  Thomas Quinot  <quinot@adacore.com>\n \n \t* g-socket.ads: Document performance consideration for stream"}, {"sha": "7eee887901904ec0a3a7ff89d7475945a611e8f5", "filename": "gcc/ada/adabkend.adb", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fadabkend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fadabkend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadabkend.adb?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -98,31 +98,15 @@ package body Adabkend is\n          --  affect code generation or falling through if it does, so the\n          --  switch will get stored.\n \n-         if Is_Internal_GCC_Switch (Switch_Chars) then\n+         --  Skip -o, -G or internal GCC switches together with their argument.\n+\n+         if Switch_Chars (First .. Last) = \"o\"\n+           or else Switch_Chars (First .. Last) = \"G\"\n+           or else Is_Internal_GCC_Switch (Switch_Chars)\n+         then\n             Next_Arg := Next_Arg + 1;\n             return; -- ignore this switch\n \n-         --  Record that an object file name has been specified. The actual\n-         --  file name argument is picked up and saved below by the main body\n-         --  of Scan_Compiler_Arguments.\n-\n-         elsif Switch_Chars (First .. Last) = \"o\" then\n-            if First = Last then\n-               if Opt.Output_File_Name_Present then\n-\n-                  --  Ignore extra -o when -gnatO has already been specified\n-\n-                  Next_Arg := Next_Arg + 1;\n-\n-               else\n-                  Opt.Output_File_Name_Present := True;\n-               end if;\n-\n-               return;\n-            else\n-               Fail (\"invalid switch: \" & Switch_Chars);\n-            end if;\n-\n          --  Set optimization indicators appropriately. In gcc-based GNAT this\n          --  is picked up from imported variables set by the gcc driver, but\n          --  for compilers with non-gcc back ends we do it here to allow use\n@@ -244,16 +228,6 @@ package body Adabkend is\n             then\n                if Is_Switch (Argv) then\n                   Fail (\"Object file name missing after -gnatO\");\n-\n-               --  In GNATprove_Mode, such an object file is never written, and\n-               --  the call to Set_Output_Object_File_Name may fail (e.g. when\n-               --  the object file name does not have the expected suffix).\n-               --  So we skip that call when GNATprove_Mode is set. Same for\n-               --  CodePeer_Mode.\n-\n-               elsif GNATprove_Mode or CodePeer_Mode then\n-                  Output_File_Name_Seen := True;\n-\n                else\n                   Set_Output_Object_File_Name (Argv);\n                   Output_File_Name_Seen := True;"}, {"sha": "9b94fceb228106066e516dd32319d79b200eba10", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -23,51 +23,52 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Checks;   use Checks;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Exp_Ch3;  use Exp_Ch3;\n-with Exp_Ch7;  use Exp_Ch7;\n-with Exp_Disp; use Exp_Disp;\n-with Exp_Pakd; use Exp_Pakd;\n-with Exp_Util; use Exp_Util;\n-with Exp_Tss;  use Exp_Tss;\n-with Fname;    use Fname;\n-with Ghost;    use Ghost;\n-with Layout;   use Layout;\n-with Lib;      use Lib;\n-with Namet;    use Namet;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Cat;  use Sem_Cat;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch7;  use Sem_Ch7;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Mech; use Sem_Mech;\n-with Sem_Prag; use Sem_Prag;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n-with Snames;   use Snames;\n-with Stand;    use Stand;\n-with Targparm; use Targparm;\n-with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n-with Uintp;    use Uintp;\n-with Urealp;   use Urealp;\n-with Warnsw;   use Warnsw;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Checks;    use Checks;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Elists;    use Elists;\n+with Errout;    use Errout;\n+with Exp_Ch3;   use Exp_Ch3;\n+with Exp_Ch7;   use Exp_Ch7;\n+with Exp_Disp;  use Exp_Disp;\n+with Exp_Pakd;  use Exp_Pakd;\n+with Exp_Util;  use Exp_Util;\n+with Exp_Tss;   use Exp_Tss;\n+with Fname;     use Fname;\n+with Ghost;     use Ghost;\n+with Layout;    use Layout;\n+with Lib;       use Lib;\n+with Namet;     use Namet;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Cat;   use Sem_Cat;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch7;   use Sem_Ch7;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Mech;  use Sem_Mech;\n+with Sem_Prag;  use Sem_Prag;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Util;  use Sem_Util;\n+with Sinfo;     use Sinfo;\n+with Snames;    use Snames;\n+with Stand;     use Stand;\n+with Targparm;  use Targparm;\n+with Tbuild;    use Tbuild;\n+with Ttypes;    use Ttypes;\n+with Uintp;     use Uintp;\n+with Urealp;    use Urealp;\n+with Warnsw;    use Warnsw;\n \n package body Freeze is\n \n@@ -1417,6 +1418,16 @@ package body Freeze is\n             --  overriding operations.\n \n             if SPARK_Mode = On then\n+\n+               --  Analyze the contract items of the parent operation, before\n+               --  they are rewritten when inherited.\n+\n+               Analyze_Entry_Or_Subprogram_Contract\n+                 (Overridden_Operation (Prim));\n+\n+               --  Now verify the legality of inherited contracts for LSP\n+               --  conformance.\n+\n                Collect_Inherited_Class_Wide_Conditions (Prim);\n             end if;\n          end if;\n@@ -1440,15 +1451,15 @@ package body Freeze is\n             A_Pre    := Find_Aspect (Par_Prim, Aspect_Pre);\n \n             if Present (A_Pre) and then Class_Present (A_Pre) then\n-               Build_Classwide_Expression (Expression (A_Pre), Prim,\n-                                           Adjust_Sloc => False);\n+               Build_Classwide_Expression\n+                 (Expression (A_Pre), Prim, Par_Prim, Adjust_Sloc => False);\n             end if;\n \n             A_Post := Find_Aspect (Par_Prim, Aspect_Post);\n \n             if Present (A_Post) and then Class_Present (A_Post) then\n-               Build_Classwide_Expression (Expression (A_Post), Prim,\n-                                           Adjust_Sloc => False);\n+               Build_Classwide_Expression\n+                 (Expression (A_Post), Prim, Par_Prim, Adjust_Sloc => False);\n             end if;\n          end if;\n "}, {"sha": "f2e8d5d1a06ea8e78e370b08193bb9558b0892b3", "filename": "gcc/ada/g-sechas.adb", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fg-sechas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fg-sechas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sechas.adb?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -341,6 +341,20 @@ package body GNAT.Secure_Hashes is\n          end return;\n       end HMAC_Initial_Context;\n \n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Stream : in out Hash_Stream;\n+         Item   : out Stream_Element_Array;\n+         Last   : out Stream_Element_Offset)\n+      is\n+         pragma Unreferenced (Stream, Item, Last);\n+      begin\n+         raise Program_Error with \"Hash_Stream is write-only\";\n+      end Read;\n+\n       ------------\n       -- Update --\n       ------------\n@@ -364,7 +378,6 @@ package body GNAT.Secure_Hashes is\n                C.M_State.Last := 0;\n             end if;\n          end loop;\n-\n       end Update;\n \n       ------------\n@@ -422,6 +435,18 @@ package body GNAT.Secure_Hashes is\n          return Digest (C);\n       end Wide_Digest;\n \n+      -----------\n+      -- Write --\n+      -----------\n+\n+      procedure Write\n+         (Stream : in out Hash_Stream;\n+          Item   : Stream_Element_Array)\n+      is\n+      begin\n+         Update (Stream.C.all, Item);\n+      end Write;\n+\n    end H;\n \n    -------------------------"}, {"sha": "33e635ce544ef8a3527fc1eb349bf945b15e8ee4", "filename": "gcc/ada/g-sechas.ads", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fg-sechas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fg-sechas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sechas.ads?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2009-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -191,6 +191,12 @@ package GNAT.Secure_Hashes is\n       --  Wide_Update) on a default initialized Context, followed by Digest\n       --  on the resulting Context.\n \n+      type Hash_Stream (C : access Context) is\n+        new Root_Stream_Type with private;\n+      --  Stream wrapper converting Write calls to Update calls on C.\n+      --  Arbitrary data structures can thus be conveniently hashed using\n+      --  their stream attributes.\n+\n    private\n \n       Block_Length : constant Natural := Block_Words * Word_Length;\n@@ -215,6 +221,20 @@ package GNAT.Secure_Hashes is\n       Initial_Context : constant Context (KL => 0) := (others => <>);\n       --  Initial values are provided by default initialization of Context\n \n+      type Hash_Stream (C : access Context) is\n+        new Root_Stream_Type with null record;\n+\n+      procedure Read\n+        (Stream : in out Hash_Stream;\n+         Item   : out Stream_Element_Array;\n+         Last   : out Stream_Element_Offset);\n+      --  Raise Program_Error: hash streams are write-only\n+\n+      procedure Write\n+         (Stream : in out Hash_Stream;\n+          Item   : Stream_Element_Array);\n+      --  Call Update\n+\n    end H;\n \n end GNAT.Secure_Hashes;"}, {"sha": "c0ff2edb1e749e3a5cd7e3a9b5d97661663a5c6a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -3823,8 +3823,8 @@ package body Sem_Ch13 is\n       U_Ent : Entity_Id;\n       --  The underlying entity to which the attribute applies. Generally this\n       --  is the Underlying_Type of Ent, except in the case where the clause\n-      --  applies to full view of incomplete type or private type in which case\n-      --  U_Ent is just a copy of Ent.\n+      --  applies to the full view of an incomplete or private type, in which\n+      --  case U_Ent is just a copy of Ent.\n \n       FOnly : Boolean := False;\n       --  Reset to True for subtype specific attribute (Alignment, Size)"}, {"sha": "6e86b1cc936d4d6f9903780e8ab10da3c5ba0633", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -26396,8 +26396,12 @@ package body Sem_Prag is\n    procedure Build_Classwide_Expression\n      (Prag        : Node_Id;\n       Subp        : Entity_Id;\n+      Par_Subp    : Entity_Id;\n       Adjust_Sloc : Boolean)\n    is\n+      Par_Formal  : Entity_Id;\n+      Subp_Formal : Entity_Id;\n+\n       function Replace_Entity (N : Node_Id) return Traverse_Result;\n       --  Replace reference to formal of inherited operation or to primitive\n       --  operation of root type, with corresponding entity for derived type,\n@@ -26503,6 +26507,17 @@ package body Sem_Prag is\n    --  Start of processing for Build_Classwide_Expression\n \n    begin\n+      --  Add mapping from old formals to new formals.\n+\n+      Par_Formal := First_Formal (Par_Subp);\n+      Subp_Formal  := First_Formal (Subp);\n+\n+      while Present (Par_Formal) and then Present (Subp_Formal) loop\n+         Primitives_Mapping.Set (Par_Formal, Subp_Formal);\n+         Next_Formal (Par_Formal);\n+         Next_Formal (Subp_Formal);\n+      end loop;\n+\n       Replace_Condition_Entities (Prag);\n    end Build_Classwide_Expression;\n \n@@ -26555,10 +26570,8 @@ package body Sem_Prag is\n       Loc          : constant Source_Ptr := Sloc (Prag);\n       Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n       Check_Prag   : Node_Id;\n-      Inher_Formal : Entity_Id;\n       Msg_Arg      : Node_Id;\n       Nam          : Name_Id;\n-      Subp_Formal  : Entity_Id;\n \n    --  Start of processing for Build_Pragma_Check_Equivalent\n \n@@ -26573,16 +26586,6 @@ package body Sem_Prag is\n \n          Update_Primitives_Mapping (Inher_Id, Subp_Id);\n \n-         --  Add mapping from old formals to new formals.\n-\n-         Inher_Formal := First_Formal (Inher_Id);\n-         Subp_Formal  := First_Formal (Subp_Id);\n-         while Present (Inher_Formal) and then Present (Subp_Formal) loop\n-            Primitives_Mapping.Set (Inher_Formal, Subp_Formal);\n-            Next_Formal (Inher_Formal);\n-            Next_Formal (Subp_Formal);\n-         end loop;\n-\n          --  Use generic machinery to copy inherited pragma, as if it were an\n          --  instantiation, resetting source locations appropriately, so that\n          --  expressions inside the inherited pragma use chained locations.\n@@ -26592,9 +26595,13 @@ package body Sem_Prag is\n          Set_Copied_Sloc_For_Inherited_Pragma\n            (Unit_Declaration_Node (Subp_Id), Inher_Id);\n          Check_Prag := New_Copy_Tree (Source => Prag);\n-         Build_Classwide_Expression (Check_Prag, Subp_Id, Adjust_Sloc => True);\n \n-      --  Otherwise simply copy the original pragma\n+         --  Build the inherited classwide condition.\n+\n+         Build_Classwide_Expression\n+           (Check_Prag, Subp_Id, Inher_Id, Adjust_Sloc => True);\n+\n+      --  If not an inherited condition simply copy the original pragma\n \n       else\n          Check_Prag := New_Copy_Tree (Source => Prag);\n@@ -29301,7 +29308,8 @@ package body Sem_Prag is\n       Subp_Id  : Entity_Id)\n    is\n       function Overridden_Ancestor (S : Entity_Id) return Entity_Id;\n-      --  ??? what does this routine do?\n+      --  Locate the primitive operation with the name of S whose controlling\n+      --  type is the dispatching type of Inher_Id.\n \n       -------------------------\n       -- Overridden_Ancestor --\n@@ -29333,7 +29341,7 @@ package body Sem_Prag is\n       Old_Prim : Entity_Id;\n       Prim     : Entity_Id;\n \n-   --  Start of processing for Primitive_Mapping\n+   --  Start of processing for Update_Primitives_Mapping\n \n    begin\n       --  If the types are already in the map, it has been previously built for"}, {"sha": "16ff72dc2da921b64ae3ab4a4fcad4950dd2fe0e", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e77949e878dd109ee7daffcda12faa1a8000d29/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=0e77949e878dd109ee7daffcda12faa1a8000d29", "patch": "@@ -247,10 +247,12 @@ package Sem_Prag is\n    procedure Build_Classwide_Expression\n      (Prag        : Node_Id;\n       Subp        : Entity_Id;\n+      Par_Subp    : Entity_Id;\n       Adjust_Sloc : Boolean);\n    --  Build the expression for an inherited classwide condition. Prag is\n    --  the pragma constructed from the corresponding aspect of the parent\n-   --  subprogram, and Subp is the overridding operation. Adjust_Sloc is True\n+   --  subprogram, and Subp is the overridding operation and Par_Subp is\n+   --  the overridden operation that has the condition. Adjust_Sloc is True\n    --  when the sloc of nodes traversed should be adjusted for the inherited\n    --  pragma. The routine is also called to check whether an inherited\n    --  operation that is not overridden but has inherited conditions need"}]}