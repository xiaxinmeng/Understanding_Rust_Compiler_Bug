{"sha": "a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxZGY1NGU0ODdjZjFlMDNiNmQwMWZmYTI0NDZhNjllMmIyNWM3OQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2015-04-06T12:40:28Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-04-06T12:40:28Z"}, "message": "libgomp: rework initialization of offloading\n\ngcc/\n\t* config/i386/intelmic-mkoffload.c (generate_host_descr_file): Call\n\tGOMP_offload_unregister from the destructor.\nlibgomp/\n\t* libgomp-plugin.h (struct mapping_table): Replace with addr_pair.\n\t* libgomp.h (struct gomp_memory_mapping): Remove.\n\t(struct target_mem_desc): Change type of mem_map from\n\tgomp_memory_mapping * to splay_tree_s *.\n\t(struct gomp_device_descr): Remove register_image_func, get_table_func.\n\tAdd load_image_func, unload_image_func.\n\tChange type of mem_map from gomp_memory_mapping to splay_tree_s.\n\tRemove offload_regions_registered.\n\t(gomp_init_tables): Remove.\n\t(gomp_free_memmap): Change type of argument from gomp_memory_mapping *\n\tto splay_tree_s *.\n\t* libgomp.map (GOMP_4.0.1): Add GOMP_offload_unregister.\n\t* oacc-host.c (host_dispatch): Do not initialize register_image_func,\n\tget_table_func, mem_map.is_initialized, mem_map.splay_tree.root,\n\toffload_regions_registered.\n\tInitialize load_image_func, unload_image_func, mem_map.root.\n\t(goacc_host_init): Do not initialize host_dispatch.mem_map.lock.\n\t* oacc-init.c (lazy_open): Don't call gomp_init_tables.\n\t(acc_shutdown_1): Use dev's lock and splay_tree instead of mem_map's.\n\t* oacc-mem.c (lookup_host): Get gomp_device_descr *dev instead of\n\tgomp_memory_mapping *.  Use dev's lock and splay_tree.\n\t(lookup_dev): Use dev's lock.\n\t(acc_deviceptr): Pass dev to lookup_host instead of mem_map.\n\t(acc_is_present): Likewise.\n\t(acc_map_data): Likewise.\n\t(acc_unmap_data): Likewise.  Use dev's lock.\n\t(present_create_copy): Likewise.\n\t(delete_copyout): Pass dev to lookup_host instead of mem_map.\n\t(update_dev_host): Likewise.\n\t(gomp_acc_remove_pointer): Likewise.  Use dev's lock.\n\t* oacc-parallel.c (GOACC_parallel): Use dev's lock and splay_tree.\n\t* plugin/plugin-host.c (GOMP_OFFLOAD_register_image): Remove.\n\t(GOMP_OFFLOAD_get_table): Remove\n\t(GOMP_OFFLOAD_load_image): New function.\n\t(GOMP_OFFLOAD_unload_image): New function.\n\t* target.c (register_lock): New mutex for offload image registration.\n\t(num_devices): Do not guard with PLUGIN_SUPPORT.\n\t(gomp_realloc_unlock): New static function.\n\t(gomp_map_vars_existing): Add device descriptor argument.  Unlock mutex\n\tbefore gomp_fatal.\n\t(gomp_map_vars): Use dev's lock and splay_tree instead of mem_map's.\n\tPass devicep to gomp_map_vars_existing.  Unlock mutex before gomp_fatal.\n\t(gomp_copy_from_async): Use dev's lock and splay_tree instead of\n\tmem_map's.\n\t(gomp_unmap_vars): Likewise.\n\t(gomp_update): Remove gomp_memory_mapping argument.  Use dev's lock and\n\tsplay_tree instead of mm's.  Unlock mutex before gomp_fatal.\n\t(gomp_offload_image_to_device): New static function.\n\t(GOMP_offload_register): Add mutex lock.\n\tCall gomp_offload_image_to_device for all initialized devices.\n\tReplace gomp_realloc with gomp_realloc_unlock.\n\t(GOMP_offload_unregister): New function.\n\t(gomp_init_tables): Replace with gomp_init_device.  Replace a call to\n\tget_table_func from the plugin with calls to init_device_func and\n\tgomp_offload_image_to_device.\n\t(gomp_free_memmap): Change type of argument from gomp_memory_mapping *\n\tto splay_tree_s *.\n\t(GOMP_target): Do not call gomp_init_tables.  Use dev's lock and\n\tsplay_tree instead of mem_map's.  Unlock mutex before gomp_fatal.\n\t(GOMP_target_data): Do not call gomp_init_tables.\n\t(GOMP_target_update): Likewise.  Remove argument from gomp_update.\n\t(gomp_load_plugin_for_device): Replace register_image and get_table\n\twith load_image and unload_image in DLSYM ().\n\t(gomp_register_images_for_device): Remove function.\n\t(gomp_target_init): Do not initialize current_device.mem_map.*,\n\tcurrent_device.offload_regions_registered.\n\tRemove call to gomp_register_images_for_device.\n\tDo not free offload_images and num_offload_images.\nliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp: Include map.\n\t(AddrVect, DevAddrVect, ImgDevAddrMap): New typedefs.\n\t(num_devices, num_images, address_table): New static vars.\n\t(num_libraries, lib_descrs): Remove static vars.\n\t(set_mic_lib_path): Rename to ...\n\t(init): ... this.  Allocate address_table and get num_devices.\n\t(GOMP_OFFLOAD_get_num_devices): return num_devices.\n\t(load_lib_and_get_table): Remove static function.\n\t(offload_image): New static function.\n\t(GOMP_OFFLOAD_get_table): Remove function.\n\t(GOMP_OFFLOAD_load_image, GOMP_OFFLOAD_unload_image): New functions.\n\nFrom-SVN: r221878", "tree": {"sha": "e7d774fabd484c0dd0c0c0e4c3452c47b0ee8b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7d774fabd484c0dd0c0c0e4c3452c47b0ee8b26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/comments", "author": null, "committer": null, "parents": [{"sha": "71671f5d5259f40720b0636625b1edd11fb11f18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71671f5d5259f40720b0636625b1edd11fb11f18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71671f5d5259f40720b0636625b1edd11fb11f18"}], "stats": {"total": 898, "additions": 552, "deletions": 346}, "files": [{"sha": "5f44928a22479b89417398aacb3320651f791286", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -1,3 +1,8 @@\n+2015-04-06  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* config/i386/intelmic-mkoffload.c (generate_host_descr_file): Call\n+\tGOMP_offload_unregister from the destructor.\n+\n 2015-04-06  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* ipa-chkp.c (chkp_maybe_create_clone): Reset cdtor"}, {"sha": "e5e5c35fc43a9004c0de1c2ae5c21e9311caf20f", "filename": "gcc/config/i386/intelmic-mkoffload.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -350,14 +350,27 @@ generate_host_descr_file (const char *host_compiler)\n \t   \"#ifdef __cplusplus\\n\"\n \t   \"extern \\\"C\\\"\\n\"\n \t   \"#endif\\n\"\n-\t   \"void GOMP_offload_register (void *, int, void *);\\n\\n\"\n+\t   \"void GOMP_offload_register (void *, int, void *);\\n\"\n+\t   \"#ifdef __cplusplus\\n\"\n+\t   \"extern \\\"C\\\"\\n\"\n+\t   \"#endif\\n\"\n+\t   \"void GOMP_offload_unregister (void *, int, void *);\\n\\n\"\n \n \t   \"__attribute__((constructor))\\n\"\n \t   \"static void\\n\"\n \t   \"init (void)\\n\"\n \t   \"{\\n\"\n \t   \"  GOMP_offload_register (&__OFFLOAD_TABLE__, %d, __offload_target_data);\\n\"\n+\t   \"}\\n\\n\", GOMP_DEVICE_INTEL_MIC);\n+\n+  fprintf (src_file,\n+\t   \"__attribute__((destructor))\\n\"\n+\t   \"static void\\n\"\n+\t   \"fini (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  GOMP_offload_unregister (&__OFFLOAD_TABLE__, %d, __offload_target_data);\\n\"\n \t   \"}\\n\", GOMP_DEVICE_INTEL_MIC);\n+\n   fclose (src_file);\n \n   unsigned new_argc = 0;"}, {"sha": "aa1468f15430959dc544e40f76dcb1965c5d80be", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -1,3 +1,74 @@\n+2015-04-06  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* libgomp-plugin.h (struct mapping_table): Replace with addr_pair.\n+\t* libgomp.h (struct gomp_memory_mapping): Remove.\n+\t(struct target_mem_desc): Change type of mem_map from\n+\tgomp_memory_mapping * to splay_tree_s *.\n+\t(struct gomp_device_descr): Remove register_image_func, get_table_func.\n+\tAdd load_image_func, unload_image_func.\n+\tChange type of mem_map from gomp_memory_mapping to splay_tree_s.\n+\tRemove offload_regions_registered.\n+\t(gomp_init_tables): Remove.\n+\t(gomp_free_memmap): Change type of argument from gomp_memory_mapping *\n+\tto splay_tree_s *.\n+\t* libgomp.map (GOMP_4.0.1): Add GOMP_offload_unregister.\n+\t* oacc-host.c (host_dispatch): Do not initialize register_image_func,\n+\tget_table_func, mem_map.is_initialized, mem_map.splay_tree.root,\n+\toffload_regions_registered.\n+\tInitialize load_image_func, unload_image_func, mem_map.root.\n+\t(goacc_host_init): Do not initialize host_dispatch.mem_map.lock.\n+\t* oacc-init.c (lazy_open): Don't call gomp_init_tables.\n+\t(acc_shutdown_1): Use dev's lock and splay_tree instead of mem_map's.\n+\t* oacc-mem.c (lookup_host): Get gomp_device_descr *dev instead of\n+\tgomp_memory_mapping *.  Use dev's lock and splay_tree.\n+\t(lookup_dev): Use dev's lock.\n+\t(acc_deviceptr): Pass dev to lookup_host instead of mem_map.\n+\t(acc_is_present): Likewise.\n+\t(acc_map_data): Likewise.\n+\t(acc_unmap_data): Likewise.  Use dev's lock.\n+\t(present_create_copy): Likewise.\n+\t(delete_copyout): Pass dev to lookup_host instead of mem_map.\n+\t(update_dev_host): Likewise.\n+\t(gomp_acc_remove_pointer): Likewise.  Use dev's lock.\n+\t* oacc-parallel.c (GOACC_parallel): Use dev's lock and splay_tree.\n+\t* plugin/plugin-host.c (GOMP_OFFLOAD_register_image): Remove.\n+\t(GOMP_OFFLOAD_get_table): Remove\n+\t(GOMP_OFFLOAD_load_image): New function.\n+\t(GOMP_OFFLOAD_unload_image): New function.\n+\t* target.c (register_lock): New mutex for offload image registration.\n+\t(num_devices): Do not guard with PLUGIN_SUPPORT.\n+\t(gomp_realloc_unlock): New static function.\n+\t(gomp_map_vars_existing): Add device descriptor argument.  Unlock mutex\n+\tbefore gomp_fatal.\n+\t(gomp_map_vars): Use dev's lock and splay_tree instead of mem_map's.\n+\tPass devicep to gomp_map_vars_existing.  Unlock mutex before gomp_fatal.\n+\t(gomp_copy_from_async): Use dev's lock and splay_tree instead of\n+\tmem_map's.\n+\t(gomp_unmap_vars): Likewise.\n+\t(gomp_update): Remove gomp_memory_mapping argument.  Use dev's lock and\n+\tsplay_tree instead of mm's.  Unlock mutex before gomp_fatal.\n+\t(gomp_offload_image_to_device): New static function.\n+\t(GOMP_offload_register): Add mutex lock.\n+\tCall gomp_offload_image_to_device for all initialized devices.\n+\tReplace gomp_realloc with gomp_realloc_unlock.\n+\t(GOMP_offload_unregister): New function.\n+\t(gomp_init_tables): Replace with gomp_init_device.  Replace a call to\n+\tget_table_func from the plugin with calls to init_device_func and\n+\tgomp_offload_image_to_device.\n+\t(gomp_free_memmap): Change type of argument from gomp_memory_mapping *\n+\tto splay_tree_s *.\n+\t(GOMP_target): Do not call gomp_init_tables.  Use dev's lock and\n+\tsplay_tree instead of mem_map's.  Unlock mutex before gomp_fatal.\n+\t(GOMP_target_data): Do not call gomp_init_tables.\n+\t(GOMP_target_update): Likewise.  Remove argument from gomp_update.\n+\t(gomp_load_plugin_for_device): Replace register_image and get_table\n+\twith load_image and unload_image in DLSYM ().\n+\t(gomp_register_images_for_device): Remove function.\n+\t(gomp_target_init): Do not initialize current_device.mem_map.*,\n+\tcurrent_device.offload_regions_registered.\n+\tRemove call to gomp_register_images_for_device.\n+\tDo not free offload_images and num_offload_images.\n+\n 2015-03-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/65597"}, {"sha": "1072ae467be9819404d1046b509fba65e2895a2c", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -51,14 +51,12 @@ enum offload_target_type\n   OFFLOAD_TARGET_TYPE_INTEL_MIC = 6\n };\n \n-/* Auxiliary struct, used for transferring a host-target address range mapping\n-   from plugin to libgomp.  */\n-struct mapping_table\n+/* Auxiliary struct, used for transferring pairs of addresses from plugin\n+   to libgomp.  */\n+struct addr_pair\n {\n-  uintptr_t host_start;\n-  uintptr_t host_end;\n-  uintptr_t tgt_start;\n-  uintptr_t tgt_end;\n+  uintptr_t start;\n+  uintptr_t end;\n };\n \n /* Miscellaneous functions.  */"}, {"sha": "a1d42c58d262e5c92fbdc9dd56dd96b7ff6705f6", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -224,7 +224,6 @@ struct gomp_team_state\n };\n \n struct target_mem_desc;\n-struct gomp_memory_mapping;\n \n /* These are the OpenMP 4.0 Internal Control Variables described in\n    section 2.3.1.  Those described as having one copy per task are\n@@ -657,7 +656,7 @@ struct target_mem_desc {\n   struct gomp_device_descr *device_descr;\n \n   /* Memory mapping info for the thread that created this descriptor.  */\n-  struct gomp_memory_mapping *mem_map;\n+  struct splay_tree_s *mem_map;\n \n   /* List of splay keys to remove (or decrease refcount)\n      at the end of region.  */\n@@ -683,20 +682,6 @@ struct splay_tree_key_s {\n \n #include \"splay-tree.h\"\n \n-/* Information about mapped memory regions (per device/context).  */\n-\n-struct gomp_memory_mapping\n-{\n-  /* Mutex for operating with the splay tree and other shared structures.  */\n-  gomp_mutex_t lock;\n-\n-  /* True when tables have been added to this memory map.  */\n-  bool is_initialized;\n-\n-  /* Splay tree containing information about mapped memory regions.  */\n-  struct splay_tree_s splay_tree;\n-};\n-\n typedef struct acc_dispatch_t\n {\n   /* This is a linked list of data mapped using the\n@@ -773,29 +758,25 @@ struct gomp_device_descr\n   unsigned int (*get_caps_func) (void);\n   int (*get_type_func) (void);\n   int (*get_num_devices_func) (void);\n-  void (*register_image_func) (void *, void *);\n   void (*init_device_func) (int);\n   void (*fini_device_func) (int);\n-  int (*get_table_func) (int, struct mapping_table **);\n+  int (*load_image_func) (int, void *, struct addr_pair **);\n+  void (*unload_image_func) (int, void *);\n   void *(*alloc_func) (int, size_t);\n   void (*free_func) (int, void *);\n   void *(*dev2host_func) (int, void *, const void *, size_t);\n   void *(*host2dev_func) (int, void *, const void *, size_t);\n   void (*run_func) (int, void *, void *);\n \n-  /* Memory-mapping info for this device instance.  */\n-  /* Uses a separate lock.  */\n-  struct gomp_memory_mapping mem_map;\n+  /* Splay tree containing information about mapped memory regions.  */\n+  struct splay_tree_s mem_map;\n \n   /* Mutex for the mutable data.  */\n   gomp_mutex_t lock;\n \n   /* Set to true when device is initialized.  */\n   bool is_initialized;\n \n-  /* True when offload regions have been registered with this device.  */\n-  bool offload_regions_registered;\n-\n   /* OpenACC-specific data and functions.  */\n   /* This is mutable because of its mutable data_environ and target_data\n      members.  */\n@@ -811,9 +792,7 @@ extern struct target_mem_desc *gomp_map_vars (struct gomp_device_descr *,\n extern void gomp_copy_from_async (struct target_mem_desc *);\n extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n extern void gomp_init_device (struct gomp_device_descr *);\n-extern void gomp_init_tables (struct gomp_device_descr *,\n-\t\t\t      struct gomp_memory_mapping *);\n-extern void gomp_free_memmap (struct gomp_memory_mapping *);\n+extern void gomp_free_memmap (struct splay_tree_s *);\n extern void gomp_fini_device (struct gomp_device_descr *);\n \n /* work.c */"}, {"sha": "2b2b953e489068c1dcb3d89c79b4915c931d564a", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -231,6 +231,7 @@ GOMP_4.0 {\n GOMP_4.0.1 {\n   global:\n \tGOMP_offload_register;\n+\tGOMP_offload_unregister;\n } GOMP_4.0;\n \n OACC_2.0 {"}, {"sha": "e4756b67a77d3aa42b2369e1363546f73b09146b", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -43,20 +43,18 @@ static struct gomp_device_descr host_dispatch =\n     .get_caps_func = GOMP_OFFLOAD_get_caps,\n     .get_type_func = GOMP_OFFLOAD_get_type,\n     .get_num_devices_func = GOMP_OFFLOAD_get_num_devices,\n-    .register_image_func = GOMP_OFFLOAD_register_image,\n     .init_device_func = GOMP_OFFLOAD_init_device,\n     .fini_device_func = GOMP_OFFLOAD_fini_device,\n-    .get_table_func = GOMP_OFFLOAD_get_table,\n+    .load_image_func = GOMP_OFFLOAD_load_image,\n+    .unload_image_func = GOMP_OFFLOAD_unload_image,\n     .alloc_func = GOMP_OFFLOAD_alloc,\n     .free_func = GOMP_OFFLOAD_free,\n     .dev2host_func = GOMP_OFFLOAD_dev2host,\n     .host2dev_func = GOMP_OFFLOAD_host2dev,\n     .run_func = GOMP_OFFLOAD_run,\n \n-    .mem_map.is_initialized = false,\n-    .mem_map.splay_tree.root = NULL,\n+    .mem_map.root = NULL,\n     .is_initialized = false,\n-    .offload_regions_registered = false,\n \n     .openacc = {\n       .open_device_func = GOMP_OFFLOAD_openacc_open_device,\n@@ -94,7 +92,6 @@ static struct gomp_device_descr host_dispatch =\n static __attribute__ ((constructor))\n void goacc_host_init (void)\n {\n-  gomp_mutex_init (&host_dispatch.mem_map.lock);\n   gomp_mutex_init (&host_dispatch.lock);\n   goacc_register (&host_dispatch);\n }"}, {"sha": "1e0243ede44c2b71739bdd6763bcfb1877f29b4c", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -284,12 +284,6 @@ lazy_open (int ord)\n     = acc_dev->openacc.create_thread_data_func (acc_dev->openacc.target_data);\n \n   acc_dev->openacc.async_set_async_func (acc_async_sync);\n-\n-  struct gomp_memory_mapping *mem_map = &acc_dev->mem_map;\n-  gomp_mutex_lock (&mem_map->lock);\n-  if (!mem_map->is_initialized)\n-    gomp_init_tables (acc_dev, mem_map);\n-  gomp_mutex_unlock (&mem_map->lock);\n }\n \n /* OpenACC 2.0a (3.2.12, 3.2.13) doesn't specify whether the serialization of\n@@ -351,10 +345,9 @@ acc_shutdown_1 (acc_device_t d)\n \n \t  walk->dev->openacc.target_data = target_data = NULL;\n \n-\t  struct gomp_memory_mapping *mem_map = &walk->dev->mem_map;\n-\t  gomp_mutex_lock (&mem_map->lock);\n-\t  gomp_free_memmap (mem_map);\n-\t  gomp_mutex_unlock (&mem_map->lock);\n+\t  gomp_mutex_lock (&walk->dev->lock);\n+\t  gomp_free_memmap (&walk->dev->mem_map);\n+\t  gomp_mutex_unlock (&walk->dev->lock);\n \n \t  walk->dev = NULL;\n \t}"}, {"sha": "fdc82e654f948a43dbe078c19a63dd6eda45fa96", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -38,19 +38,17 @@\n /* Return block containing [H->S), or NULL if not contained.  */\n \n static splay_tree_key\n-lookup_host (struct gomp_memory_mapping *mem_map, void *h, size_t s)\n+lookup_host (struct gomp_device_descr *dev, void *h, size_t s)\n {\n   struct splay_tree_key_s node;\n   splay_tree_key key;\n \n   node.host_start = (uintptr_t) h;\n   node.host_end = (uintptr_t) h + s;\n \n-  gomp_mutex_lock (&mem_map->lock);\n-\n-  key = splay_tree_lookup (&mem_map->splay_tree, &node);\n-\n-  gomp_mutex_unlock (&mem_map->lock);\n+  gomp_mutex_lock (&dev->lock);\n+  key = splay_tree_lookup (&dev->mem_map, &node);\n+  gomp_mutex_unlock (&dev->lock);\n \n   return key;\n }\n@@ -65,22 +63,19 @@ lookup_dev (struct target_mem_desc *tgt, void *d, size_t s)\n {\n   int i;\n   struct target_mem_desc *t;\n-  struct gomp_memory_mapping *mem_map;\n \n   if (!tgt)\n     return NULL;\n \n-  mem_map = tgt->mem_map;\n-\n-  gomp_mutex_lock (&mem_map->lock);\n+  gomp_mutex_lock (&tgt->device_descr->lock);\n \n   for (t = tgt; t != NULL; t = t->prev)\n     {\n       if (t->tgt_start <= (uintptr_t) d && t->tgt_end >= (uintptr_t) d + s)\n         break;\n     }\n \n-  gomp_mutex_unlock (&mem_map->lock);\n+  gomp_mutex_unlock (&tgt->device_descr->lock);\n \n   if (!t)\n     return NULL;\n@@ -176,7 +171,7 @@ acc_deviceptr (void *h)\n \n   struct goacc_thread *thr = goacc_thread ();\n \n-  n = lookup_host (&thr->dev->mem_map, h, 1);\n+  n = lookup_host (thr->dev, h, 1);\n \n   if (!n)\n     return NULL;\n@@ -229,7 +224,7 @@ acc_is_present (void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n-  n = lookup_host (&acc_dev->mem_map, h, s);\n+  n = lookup_host (acc_dev, h, s);\n \n   if (n && ((uintptr_t)h < n->host_start\n \t    || (uintptr_t)h + s > n->host_end\n@@ -271,7 +266,7 @@ acc_map_data (void *h, void *d, size_t s)\n \tgomp_fatal (\"[%p,+%d]->[%p,+%d] is a bad map\",\n                     (void *)h, (int)s, (void *)d, (int)s);\n \n-      if (lookup_host (&acc_dev->mem_map, h, s))\n+      if (lookup_host (acc_dev, h, s))\n \tgomp_fatal (\"host address [%p, +%d] is already mapped\", (void *)h,\n \t\t    (int)s);\n \n@@ -296,7 +291,7 @@ acc_unmap_data (void *h)\n   /* No need to call lazy open, as the address must have been mapped.  */\n \n   size_t host_size;\n-  splay_tree_key n = lookup_host (&acc_dev->mem_map, h, 1);\n+  splay_tree_key n = lookup_host (acc_dev, h, 1);\n   struct target_mem_desc *t;\n \n   if (!n)\n@@ -320,7 +315,7 @@ acc_unmap_data (void *h)\n       t->tgt_end = 0;\n       t->to_free = 0;\n \n-      gomp_mutex_lock (&acc_dev->mem_map.lock);\n+      gomp_mutex_lock (&acc_dev->lock);\n \n       for (tp = NULL, t = acc_dev->openacc.data_environ; t != NULL;\n \t   tp = t, t = t->prev)\n@@ -334,7 +329,7 @@ acc_unmap_data (void *h)\n \t    break;\n \t  }\n \n-      gomp_mutex_unlock (&acc_dev->mem_map.lock);\n+      gomp_mutex_unlock (&acc_dev->lock);\n     }\n \n   gomp_unmap_vars (t, true);\n@@ -358,7 +353,7 @@ present_create_copy (unsigned f, void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n-  n = lookup_host (&acc_dev->mem_map, h, s);\n+  n = lookup_host (acc_dev, h, s);\n   if (n)\n     {\n       /* Present. */\n@@ -389,13 +384,13 @@ present_create_copy (unsigned f, void *h, size_t s)\n       tgt = gomp_map_vars (acc_dev, mapnum, &hostaddrs, NULL, &s, &kinds, true,\n \t\t\t   false);\n \n-      gomp_mutex_lock (&acc_dev->mem_map.lock);\n+      gomp_mutex_lock (&acc_dev->lock);\n \n       d = tgt->to_free;\n       tgt->prev = acc_dev->openacc.data_environ;\n       acc_dev->openacc.data_environ = tgt;\n \n-      gomp_mutex_unlock (&acc_dev->mem_map.lock);\n+      gomp_mutex_unlock (&acc_dev->lock);\n     }\n \n   return d;\n@@ -436,7 +431,7 @@ delete_copyout (unsigned f, void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n-  n = lookup_host (&acc_dev->mem_map, h, s);\n+  n = lookup_host (acc_dev, h, s);\n \n   /* No need to call lazy open, as the data must already have been\n      mapped.  */\n@@ -479,7 +474,7 @@ update_dev_host (int is_dev, void *h, size_t s)\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n-  n = lookup_host (&acc_dev->mem_map, h, s);\n+  n = lookup_host (acc_dev, h, s);\n \n   /* No need to call lazy open, as the data must already have been\n      mapped.  */\n@@ -532,7 +527,7 @@ gomp_acc_remove_pointer (void *h, bool force_copyfrom, int async, int mapnum)\n   struct target_mem_desc *t;\n   int minrefs = (mapnum == 1) ? 2 : 3;\n \n-  n = lookup_host (&acc_dev->mem_map, h, 1);\n+  n = lookup_host (acc_dev, h, 1);\n \n   if (!n)\n     gomp_fatal (\"%p is not a mapped block\", (void *)h);\n@@ -543,7 +538,7 @@ gomp_acc_remove_pointer (void *h, bool force_copyfrom, int async, int mapnum)\n \n   struct target_mem_desc *tp;\n \n-  gomp_mutex_lock (&acc_dev->mem_map.lock);\n+  gomp_mutex_lock (&acc_dev->lock);\n \n   if (t->refcount == minrefs)\n     {\n@@ -570,7 +565,7 @@ gomp_acc_remove_pointer (void *h, bool force_copyfrom, int async, int mapnum)\n   if (force_copyfrom)\n     t->list[0]->copy_from = 1;\n \n-  gomp_mutex_unlock (&acc_dev->mem_map.lock);\n+  gomp_mutex_unlock (&acc_dev->lock);\n \n   /* If running synchronously, unmap immediately.  */\n   if (async < acc_async_noval)"}, {"sha": "563f9bb5b4b8514cb3a656c09f295e212ecd2ce6", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -144,9 +144,9 @@ GOACC_parallel (int device, void (*fn) (void *),\n     {\n       k.host_start = (uintptr_t) fn;\n       k.host_end = k.host_start + 1;\n-      gomp_mutex_lock (&acc_dev->mem_map.lock);\n-      tgt_fn_key = splay_tree_lookup (&acc_dev->mem_map.splay_tree, &k);\n-      gomp_mutex_unlock (&acc_dev->mem_map.lock);\n+      gomp_mutex_lock (&acc_dev->lock);\n+      tgt_fn_key = splay_tree_lookup (&acc_dev->mem_map, &k);\n+      gomp_mutex_unlock (&acc_dev->lock);\n \n       if (tgt_fn_key == NULL)\n \tgomp_fatal (\"target function wasn't mapped\");"}, {"sha": "bc60f72d05e886137814ffe674a605420145d115", "filename": "libgomp/plugin/plugin-host.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Fplugin%2Fplugin-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Fplugin%2Fplugin-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-host.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -94,12 +94,6 @@ GOMP_OFFLOAD_get_num_devices (void)\n   return 1;\n }\n \n-STATIC void\n-GOMP_OFFLOAD_register_image (void *host_table __attribute__ ((unused)),\n-\t\t\t     void *target_data __attribute__ ((unused)))\n-{\n-}\n-\n STATIC void\n GOMP_OFFLOAD_init_device (int n __attribute__ ((unused)))\n {\n@@ -111,12 +105,19 @@ GOMP_OFFLOAD_fini_device (int n __attribute__ ((unused)))\n }\n \n STATIC int\n-GOMP_OFFLOAD_get_table (int n __attribute__ ((unused)),\n-\t\t\tstruct mapping_table **table __attribute__ ((unused)))\n+GOMP_OFFLOAD_load_image (int n __attribute__ ((unused)),\n+\t\t\t void *i __attribute__ ((unused)),\n+\t\t\t struct addr_pair **r __attribute__ ((unused)))\n {\n   return 0;\n }\n \n+STATIC void\n+GOMP_OFFLOAD_unload_image (int n __attribute__ ((unused)),\n+\t\t\t   void *i __attribute__ ((unused)))\n+{\n+}\n+\n STATIC void *\n GOMP_OFFLOAD_openacc_open_device (int n)\n {"}, {"sha": "dfe7fb9dbf92612110f26d09044bcfd5a20167d7", "filename": "libgomp/target.c", "status": "modified", "additions": 299, "deletions": 155, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -49,6 +49,9 @@ static void gomp_target_init (void);\n /* The whole initialization code for offloading plugins is only run one.  */\n static pthread_once_t gomp_is_initialized = PTHREAD_ONCE_INIT;\n \n+/* Mutex for offload image registration.  */\n+static gomp_mutex_t register_lock;\n+\n /* This structure describes an offload image.\n    It contains type of the target device, pointer to host table descriptor, and\n    pointer to target data.  */\n@@ -67,14 +70,26 @@ static int num_offload_images;\n /* Array of descriptors for all available devices.  */\n static struct gomp_device_descr *devices;\n \n-#ifdef PLUGIN_SUPPORT\n /* Total number of available devices.  */\n static int num_devices;\n-#endif\n \n /* Number of GOMP_OFFLOAD_CAP_OPENMP_400 devices.  */\n static int num_devices_openmp;\n \n+/* Similar to gomp_realloc, but release register_lock before gomp_fatal.  */\n+\n+static void *\n+gomp_realloc_unlock (void *old, size_t size)\n+{\n+  void *ret = realloc (old, size);\n+  if (ret == NULL)\n+    {\n+      gomp_mutex_unlock (&register_lock);\n+      gomp_fatal (\"Out of memory allocating %lu bytes\", (unsigned long) size);\n+    }\n+  return ret;\n+}\n+\n /* The comparison function.  */\n \n attribute_hidden int\n@@ -125,16 +140,19 @@ resolve_device (int device_id)\n    Helper function of gomp_map_vars.  */\n \n static inline void\n-gomp_map_vars_existing (splay_tree_key oldn, splay_tree_key newn,\n-\t\t\tunsigned char kind)\n+gomp_map_vars_existing (struct gomp_device_descr *devicep, splay_tree_key oldn,\n+\t\t\tsplay_tree_key newn, unsigned char kind)\n {\n   if ((kind & GOMP_MAP_FLAG_FORCE)\n       || oldn->host_start > newn->host_start\n       || oldn->host_end < newn->host_end)\n-    gomp_fatal (\"Trying to map into device [%p..%p) object when \"\n-\t\t\"[%p..%p) is already mapped\",\n-\t\t(void *) newn->host_start, (void *) newn->host_end,\n-\t\t(void *) oldn->host_start, (void *) oldn->host_end);\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      gomp_fatal (\"Trying to map into device [%p..%p) object when \"\n+\t\t  \"[%p..%p) is already mapped\",\n+\t\t  (void *) newn->host_start, (void *) newn->host_end,\n+\t\t  (void *) oldn->host_start, (void *) oldn->host_end);\n+    }\n   oldn->refcount++;\n }\n \n@@ -153,14 +171,14 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n   size_t i, tgt_align, tgt_size, not_found_cnt = 0;\n   const int rshift = is_openacc ? 8 : 3;\n   const int typemask = is_openacc ? 0xff : 0x7;\n-  struct gomp_memory_mapping *mm = &devicep->mem_map;\n+  struct splay_tree_s *mem_map = &devicep->mem_map;\n   struct splay_tree_key_s cur_node;\n   struct target_mem_desc *tgt\n     = gomp_malloc (sizeof (*tgt) + sizeof (tgt->list[0]) * mapnum);\n   tgt->list_count = mapnum;\n   tgt->refcount = 1;\n   tgt->device_descr = devicep;\n-  tgt->mem_map = mm;\n+  tgt->mem_map = mem_map;\n \n   if (mapnum == 0)\n     return tgt;\n@@ -174,7 +192,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n       tgt_size = mapnum * sizeof (void *);\n     }\n \n-  gomp_mutex_lock (&mm->lock);\n+  gomp_mutex_lock (&devicep->lock);\n \n   for (i = 0; i < mapnum; i++)\n     {\n@@ -189,11 +207,11 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \tcur_node.host_end = cur_node.host_start + sizes[i];\n       else\n \tcur_node.host_end = cur_node.host_start + sizeof (void *);\n-      splay_tree_key n = splay_tree_lookup (&mm->splay_tree, &cur_node);\n+      splay_tree_key n = splay_tree_lookup (mem_map, &cur_node);\n       if (n)\n \t{\n \t  tgt->list[i] = n;\n-\t  gomp_map_vars_existing (n, &cur_node, kind & typemask);\n+\t  gomp_map_vars_existing (devicep, n, &cur_node, kind & typemask);\n \t}\n       else\n \t{\n@@ -228,7 +246,10 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n   if (devaddrs)\n     {\n       if (mapnum != 1)\n-        gomp_fatal (\"unexpected aggregation\");\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  gomp_fatal (\"unexpected aggregation\");\n+\t}\n       tgt->to_free = devaddrs[0];\n       tgt->tgt_start = (uintptr_t) tgt->to_free;\n       tgt->tgt_end = tgt->tgt_start + sizes[0];\n@@ -274,11 +295,11 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t      k->host_end = k->host_start + sizes[i];\n \t    else\n \t      k->host_end = k->host_start + sizeof (void *);\n-\t    splay_tree_key n = splay_tree_lookup (&mm->splay_tree, k);\n+\t    splay_tree_key n = splay_tree_lookup (mem_map, k);\n \t    if (n)\n \t      {\n \t\ttgt->list[i] = n;\n-\t\tgomp_map_vars_existing (n, k, kind & typemask);\n+\t\tgomp_map_vars_existing (devicep, n, k, kind & typemask);\n \t      }\n \t    else\n \t      {\n@@ -294,7 +315,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\ttgt->refcount++;\n \t\tarray->left = NULL;\n \t\tarray->right = NULL;\n-\t\tsplay_tree_insert (&mm->splay_tree, array);\n+\t\tsplay_tree_insert (mem_map, array);\n \t\tswitch (kind & typemask)\n \t\t  {\n \t\t  case GOMP_MAP_ALLOC:\n@@ -332,22 +353,25 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t    /* Add bias to the pointer value.  */\n \t\t    cur_node.host_start += sizes[i];\n \t\t    cur_node.host_end = cur_node.host_start + 1;\n-\t\t    n = splay_tree_lookup (&mm->splay_tree, &cur_node);\n+\t\t    n = splay_tree_lookup (mem_map, &cur_node);\n \t\t    if (n == NULL)\n \t\t      {\n \t\t\t/* Could be possibly zero size array section.  */\n \t\t\tcur_node.host_end--;\n-\t\t\tn = splay_tree_lookup (&mm->splay_tree, &cur_node);\n+\t\t\tn = splay_tree_lookup (mem_map, &cur_node);\n \t\t\tif (n == NULL)\n \t\t\t  {\n \t\t\t    cur_node.host_start--;\n-\t\t\t    n = splay_tree_lookup (&mm->splay_tree, &cur_node);\n+\t\t\t    n = splay_tree_lookup (mem_map, &cur_node);\n \t\t\t    cur_node.host_start++;\n \t\t\t  }\n \t\t      }\n \t\t    if (n == NULL)\n-\t\t      gomp_fatal (\"Pointer target of array section \"\n-\t\t\t\t  \"wasn't mapped\");\n+\t\t      {\n+\t\t\tgomp_mutex_unlock (&devicep->lock);\n+\t\t\tgomp_fatal (\"Pointer target of array section \"\n+\t\t\t\t    \"wasn't mapped\");\n+\t\t      }\n \t\t    cur_node.host_start -= n->host_start;\n \t\t    cur_node.tgt_offset = n->tgt->tgt_start + n->tgt_offset\n \t\t\t\t\t  + cur_node.host_start;\n@@ -400,24 +424,25 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t  /* Add bias to the pointer value.  */\n \t\t\t  cur_node.host_start += sizes[j];\n \t\t\t  cur_node.host_end = cur_node.host_start + 1;\n-\t\t\t  n = splay_tree_lookup (&mm->splay_tree, &cur_node);\n+\t\t\t  n = splay_tree_lookup (mem_map, &cur_node);\n \t\t\t  if (n == NULL)\n \t\t\t    {\n \t\t\t      /* Could be possibly zero size array section.  */\n \t\t\t      cur_node.host_end--;\n-\t\t\t      n = splay_tree_lookup (&mm->splay_tree,\n-\t\t\t\t\t\t     &cur_node);\n+\t\t\t      n = splay_tree_lookup (mem_map, &cur_node);\n \t\t\t      if (n == NULL)\n \t\t\t\t{\n \t\t\t\t  cur_node.host_start--;\n-\t\t\t\t  n = splay_tree_lookup (&mm->splay_tree,\n-\t\t\t\t\t\t\t &cur_node);\n+\t\t\t\t  n = splay_tree_lookup (mem_map, &cur_node);\n \t\t\t\t  cur_node.host_start++;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t  if (n == NULL)\n-\t\t\t    gomp_fatal (\"Pointer target of array section \"\n-\t\t\t\t\t\"wasn't mapped\");\n+\t\t\t    {\n+\t\t\t      gomp_mutex_unlock (&devicep->lock);\n+\t\t\t      gomp_fatal (\"Pointer target of array section \"\n+\t\t\t\t\t  \"wasn't mapped\");\n+\t\t\t    }\n \t\t\t  cur_node.host_start -= n->host_start;\n \t\t\t  cur_node.tgt_offset = n->tgt->tgt_start\n \t\t\t\t\t\t+ n->tgt_offset\n@@ -441,6 +466,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t      /* We already looked up the memory region above and it\n \t\t\t was missing.  */\n \t\t      size_t size = k->host_end - k->host_start;\n+\t\t      gomp_mutex_unlock (&devicep->lock);\n #ifdef HAVE_INTTYPES_H\n \t\t      gomp_fatal (\"present clause: !acc_is_present (%p, \"\n \t\t\t\t  \"%\"PRIu64\" (0x%\"PRIx64\"))\",\n@@ -463,6 +489,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t\t\t\t\t    sizeof (void *));\n \t\t    break;\n \t\t  default:\n+\t\t    gomp_mutex_unlock (&devicep->lock);\n \t\t    gomp_fatal (\"%s: unhandled kind 0x%.2x\", __FUNCTION__,\n \t\t\t\tkind);\n \t\t  }\n@@ -489,7 +516,7 @@ gomp_map_vars (struct gomp_device_descr *devicep, size_t mapnum,\n \t}\n     }\n \n-  gomp_mutex_unlock (&mm->lock);\n+  gomp_mutex_unlock (&devicep->lock);\n   return tgt;\n }\n \n@@ -514,10 +541,9 @@ attribute_hidden void\n gomp_copy_from_async (struct target_mem_desc *tgt)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n-  struct gomp_memory_mapping *mm = tgt->mem_map;\n   size_t i;\n \n-  gomp_mutex_lock (&mm->lock);\n+  gomp_mutex_lock (&devicep->lock);\n \n   for (i = 0; i < tgt->list_count; i++)\n     if (tgt->list[i] == NULL)\n@@ -536,7 +562,7 @@ gomp_copy_from_async (struct target_mem_desc *tgt)\n \t\t\t\t  k->host_end - k->host_start);\n       }\n \n-  gomp_mutex_unlock (&mm->lock);\n+  gomp_mutex_unlock (&devicep->lock);\n }\n \n /* Unmap variables described by TGT.  If DO_COPYFROM is true, copy relevant\n@@ -547,15 +573,14 @@ attribute_hidden void\n gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n-  struct gomp_memory_mapping *mm = tgt->mem_map;\n \n   if (tgt->list_count == 0)\n     {\n       free (tgt);\n       return;\n     }\n \n-  gomp_mutex_lock (&mm->lock);\n+  gomp_mutex_lock (&devicep->lock);\n \n   size_t i;\n   for (i = 0; i < tgt->list_count; i++)\n@@ -572,7 +597,7 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n \t  devicep->dev2host_func (devicep->target_id, (void *) k->host_start,\n \t\t\t\t  (void *) (k->tgt->tgt_start + k->tgt_offset),\n \t\t\t\t  k->host_end - k->host_start);\n-\tsplay_tree_remove (&mm->splay_tree, k);\n+\tsplay_tree_remove (tgt->mem_map, k);\n \tif (k->tgt->refcount > 1)\n \t  k->tgt->refcount--;\n \telse\n@@ -584,13 +609,12 @@ gomp_unmap_vars (struct target_mem_desc *tgt, bool do_copyfrom)\n   else\n     gomp_unmap_tgt (tgt);\n \n-  gomp_mutex_unlock (&mm->lock);\n+  gomp_mutex_unlock (&devicep->lock);\n }\n \n static void\n-gomp_update (struct gomp_device_descr *devicep, struct gomp_memory_mapping *mm,\n-\t     size_t mapnum, void **hostaddrs, size_t *sizes, void *kinds,\n-\t     bool is_openacc)\n+gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n+\t     size_t *sizes, void *kinds, bool is_openacc)\n {\n   size_t i;\n   struct splay_tree_key_s cur_node;\n@@ -602,25 +626,27 @@ gomp_update (struct gomp_device_descr *devicep, struct gomp_memory_mapping *mm,\n   if (mapnum == 0)\n     return;\n \n-  gomp_mutex_lock (&mm->lock);\n+  gomp_mutex_lock (&devicep->lock);\n   for (i = 0; i < mapnum; i++)\n     if (sizes[i])\n       {\n \tcur_node.host_start = (uintptr_t) hostaddrs[i];\n \tcur_node.host_end = cur_node.host_start + sizes[i];\n-\tsplay_tree_key n = splay_tree_lookup (&mm->splay_tree,\n-\t\t\t\t\t      &cur_node);\n+\tsplay_tree_key n = splay_tree_lookup (&devicep->mem_map, &cur_node);\n \tif (n)\n \t  {\n \t    int kind = get_kind (is_openacc, kinds, i);\n \t    if (n->host_start > cur_node.host_start\n \t\t|| n->host_end < cur_node.host_end)\n-\t      gomp_fatal (\"Trying to update [%p..%p) object when\"\n-\t\t\t  \"only [%p..%p) is mapped\",\n-\t\t\t  (void *) cur_node.host_start,\n-\t\t\t  (void *) cur_node.host_end,\n-\t\t\t  (void *) n->host_start,\n-\t\t\t  (void *) n->host_end);\n+\t      {\n+\t\tgomp_mutex_unlock (&devicep->lock);\n+\t\tgomp_fatal (\"Trying to update [%p..%p) object when \"\n+\t\t\t    \"only [%p..%p) is mapped\",\n+\t\t\t    (void *) cur_node.host_start,\n+\t\t\t    (void *) cur_node.host_end,\n+\t\t\t    (void *) n->host_start,\n+\t\t\t    (void *) n->host_end);\n+\t      }\n \t    if (GOMP_MAP_COPY_TO_P (kind & typemask))\n \t      devicep->host2dev_func (devicep->target_id,\n \t\t\t\t      (void *) (n->tgt->tgt_start\n@@ -639,98 +665,259 @@ gomp_update (struct gomp_device_descr *devicep, struct gomp_memory_mapping *mm,\n \t\t\t\t      cur_node.host_end - cur_node.host_start);\n \t  }\n \telse\n-\t  gomp_fatal (\"Trying to update [%p..%p) object that is not mapped\",\n-\t\t      (void *) cur_node.host_start,\n-\t\t      (void *) cur_node.host_end);\n+\t  {\n+\t    gomp_mutex_unlock (&devicep->lock);\n+\t    gomp_fatal (\"Trying to update [%p..%p) object that is not mapped\",\n+\t\t\t(void *) cur_node.host_start,\n+\t\t\t(void *) cur_node.host_end);\n+\t  }\n       }\n-  gomp_mutex_unlock (&mm->lock);\n+  gomp_mutex_unlock (&devicep->lock);\n+}\n+\n+/* Load image pointed by TARGET_DATA to the device, specified by DEVICEP.\n+   And insert to splay tree the mapping between addresses from HOST_TABLE and\n+   from loaded target image.  */\n+\n+static void\n+gomp_offload_image_to_device (struct gomp_device_descr *devicep,\n+\t\t\t      void *host_table, void *target_data,\n+\t\t\t      bool is_register_lock)\n+{\n+  void **host_func_table = ((void ***) host_table)[0];\n+  void **host_funcs_end  = ((void ***) host_table)[1];\n+  void **host_var_table  = ((void ***) host_table)[2];\n+  void **host_vars_end   = ((void ***) host_table)[3];\n+\n+  /* The func table contains only addresses, the var table contains addresses\n+     and corresponding sizes.  */\n+  int num_funcs = host_funcs_end - host_func_table;\n+  int num_vars  = (host_vars_end - host_var_table) / 2;\n+\n+  /* Load image to device and get target addresses for the image.  */\n+  struct addr_pair *target_table = NULL;\n+  int i, num_target_entries\n+    = devicep->load_image_func (devicep->target_id, target_data, &target_table);\n+\n+  if (num_target_entries != num_funcs + num_vars)\n+    {\n+      gomp_mutex_unlock (&devicep->lock);\n+      if (is_register_lock)\n+\tgomp_mutex_unlock (&register_lock);\n+      gomp_fatal (\"Can't map target functions or variables\");\n+    }\n+\n+  /* Insert host-target address mapping into splay tree.  */\n+  struct target_mem_desc *tgt = gomp_malloc (sizeof (*tgt));\n+  tgt->array = gomp_malloc ((num_funcs + num_vars) * sizeof (*tgt->array));\n+  tgt->refcount = 1;\n+  tgt->tgt_start = 0;\n+  tgt->tgt_end = 0;\n+  tgt->to_free = NULL;\n+  tgt->prev = NULL;\n+  tgt->list_count = 0;\n+  tgt->device_descr = devicep;\n+  splay_tree_node array = tgt->array;\n+\n+  for (i = 0; i < num_funcs; i++)\n+    {\n+      splay_tree_key k = &array->key;\n+      k->host_start = (uintptr_t) host_func_table[i];\n+      k->host_end = k->host_start + 1;\n+      k->tgt = tgt;\n+      k->tgt_offset = target_table[i].start;\n+      k->refcount = 1;\n+      k->async_refcount = 0;\n+      k->copy_from = false;\n+      array->left = NULL;\n+      array->right = NULL;\n+      splay_tree_insert (&devicep->mem_map, array);\n+      array++;\n+    }\n+\n+  for (i = 0; i < num_vars; i++)\n+    {\n+      struct addr_pair *target_var = &target_table[num_funcs + i];\n+      if (target_var->end - target_var->start\n+\t  != (uintptr_t) host_var_table[i * 2 + 1])\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  if (is_register_lock)\n+\t    gomp_mutex_unlock (&register_lock);\n+\t  gomp_fatal (\"Can't map target variables (size mismatch)\");\n+\t}\n+\n+      splay_tree_key k = &array->key;\n+      k->host_start = (uintptr_t) host_var_table[i * 2];\n+      k->host_end = k->host_start + (uintptr_t) host_var_table[i * 2 + 1];\n+      k->tgt = tgt;\n+      k->tgt_offset = target_var->start;\n+      k->refcount = 1;\n+      k->async_refcount = 0;\n+      k->copy_from = false;\n+      array->left = NULL;\n+      array->right = NULL;\n+      splay_tree_insert (&devicep->mem_map, array);\n+      array++;\n+    }\n+\n+  free (target_table);\n }\n \n-/* This function should be called from every offload image.\n+/* This function should be called from every offload image while loading.\n    It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n    the target, and TARGET_DATA needed by target plugin.  */\n \n void\n GOMP_offload_register (void *host_table, enum offload_target_type target_type,\n \t\t       void *target_data)\n {\n-  offload_images = gomp_realloc (offload_images,\n-\t\t\t\t (num_offload_images + 1)\n-\t\t\t\t * sizeof (struct offload_image_descr));\n+  int i;\n+  gomp_mutex_lock (&register_lock);\n+\n+  /* Load image to all initialized devices.  */\n+  for (i = 0; i < num_devices; i++)\n+    {\n+      struct gomp_device_descr *devicep = &devices[i];\n+      gomp_mutex_lock (&devicep->lock);\n+      if (devicep->type == target_type && devicep->is_initialized)\n+\tgomp_offload_image_to_device (devicep, host_table, target_data, true);\n+      gomp_mutex_unlock (&devicep->lock);\n+    }\n \n+  /* Insert image to array of pending images.  */\n+  offload_images\n+    = gomp_realloc_unlock (offload_images,\n+\t\t\t   (num_offload_images + 1)\n+\t\t\t   * sizeof (struct offload_image_descr));\n   offload_images[num_offload_images].type = target_type;\n   offload_images[num_offload_images].host_table = host_table;\n   offload_images[num_offload_images].target_data = target_data;\n \n   num_offload_images++;\n+  gomp_mutex_unlock (&register_lock);\n }\n \n-/* This function initializes the target device, specified by DEVICEP.  DEVICEP\n-   must be locked on entry, and remains locked on return.  */\n+/* This function should be called from every offload image while unloading.\n+   It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n+   the target, and TARGET_DATA needed by target plugin.  */\n \n-attribute_hidden void\n-gomp_init_device (struct gomp_device_descr *devicep)\n+void\n+GOMP_offload_unregister (void *host_table, enum offload_target_type target_type,\n+\t\t\t void *target_data)\n {\n-  devicep->init_device_func (devicep->target_id);\n-  devicep->is_initialized = true;\n+  void **host_func_table = ((void ***) host_table)[0];\n+  void **host_funcs_end  = ((void ***) host_table)[1];\n+  void **host_var_table  = ((void ***) host_table)[2];\n+  void **host_vars_end   = ((void ***) host_table)[3];\n+  int i;\n+\n+  /* The func table contains only addresses, the var table contains addresses\n+     and corresponding sizes.  */\n+  int num_funcs = host_funcs_end - host_func_table;\n+  int num_vars  = (host_vars_end - host_var_table) / 2;\n+\n+  gomp_mutex_lock (&register_lock);\n+\n+  /* Unload image from all initialized devices.  */\n+  for (i = 0; i < num_devices; i++)\n+    {\n+      int j;\n+      struct gomp_device_descr *devicep = &devices[i];\n+      gomp_mutex_lock (&devicep->lock);\n+      if (devicep->type != target_type || !devicep->is_initialized)\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  continue;\n+\t}\n+\n+      devicep->unload_image_func (devicep->target_id, target_data);\n+\n+      /* Remove mapping from splay tree.  */\n+      struct splay_tree_key_s k;\n+      splay_tree_key node = NULL;\n+      if (num_funcs > 0)\n+\t{\n+\t  k.host_start = (uintptr_t) host_func_table[0];\n+\t  k.host_end = k.host_start + 1;\n+\t  node = splay_tree_lookup (&devicep->mem_map, &k);\n+\t}\n+      else if (num_vars > 0)\n+\t{\n+\t  k.host_start = (uintptr_t) host_var_table[0];\n+\t  k.host_end = k.host_start + (uintptr_t) host_var_table[1];\n+\t  node = splay_tree_lookup (&devicep->mem_map, &k);\n+\t}\n+\n+      for (j = 0; j < num_funcs; j++)\n+\t{\n+\t  k.host_start = (uintptr_t) host_func_table[j];\n+\t  k.host_end = k.host_start + 1;\n+\t  splay_tree_remove (&devicep->mem_map, &k);\n+\t}\n+\n+      for (j = 0; j < num_vars; j++)\n+\t{\n+\t  k.host_start = (uintptr_t) host_var_table[j * 2];\n+\t  k.host_end = k.host_start + (uintptr_t) host_var_table[j * 2 + 1];\n+\t  splay_tree_remove (&devicep->mem_map, &k);\n+\t}\n+\n+      if (node)\n+\t{\n+\t  free (node->tgt);\n+\t  free (node);\n+\t}\n+\n+      gomp_mutex_unlock (&devicep->lock);\n+    }\n+\n+  /* Remove image from array of pending images.  */\n+  for (i = 0; i < num_offload_images; i++)\n+    if (offload_images[i].target_data == target_data)\n+      {\n+\toffload_images[i] = offload_images[--num_offload_images];\n+\tbreak;\n+      }\n+\n+  gomp_mutex_unlock (&register_lock);\n }\n \n-/* Initialize address mapping tables.  MM must be locked on entry, and remains\n-   locked on return.  */\n+/* This function initializes the target device, specified by DEVICEP.  DEVICEP\n+   must be locked on entry, and remains locked on return.  */\n \n attribute_hidden void\n-gomp_init_tables (struct gomp_device_descr *devicep,\n-\t\t  struct gomp_memory_mapping *mm)\n+gomp_init_device (struct gomp_device_descr *devicep)\n {\n-  /* Get address mapping table for device.  */\n-  struct mapping_table *table = NULL;\n-  int num_entries = devicep->get_table_func (devicep->target_id, &table);\n-\n-  /* Insert host-target address mapping into dev_splay_tree.  */\n   int i;\n-  for (i = 0; i < num_entries; i++)\n+  devicep->init_device_func (devicep->target_id);\n+\n+  /* Load to device all images registered by the moment.  */\n+  for (i = 0; i < num_offload_images; i++)\n     {\n-      struct target_mem_desc *tgt = gomp_malloc (sizeof (*tgt));\n-      tgt->refcount = 1;\n-      tgt->array = gomp_malloc (sizeof (*tgt->array));\n-      tgt->tgt_start = table[i].tgt_start;\n-      tgt->tgt_end = table[i].tgt_end;\n-      tgt->to_free = NULL;\n-      tgt->list_count = 0;\n-      tgt->device_descr = devicep;\n-      splay_tree_node node = tgt->array;\n-      splay_tree_key k = &node->key;\n-      k->host_start = table[i].host_start;\n-      k->host_end = table[i].host_end;\n-      k->tgt_offset = 0;\n-      k->refcount = 1;\n-      k->copy_from = false;\n-      k->tgt = tgt;\n-      node->left = NULL;\n-      node->right = NULL;\n-      splay_tree_insert (&mm->splay_tree, node);\n+      struct offload_image_descr *image = &offload_images[i];\n+      if (image->type == devicep->type)\n+\tgomp_offload_image_to_device (devicep, image->host_table,\n+\t\t\t\t      image->target_data, false);\n     }\n \n-  free (table);\n-  mm->is_initialized = true;\n+  devicep->is_initialized = true;\n }\n \n /* Free address mapping tables.  MM must be locked on entry, and remains locked\n    on return.  */\n \n attribute_hidden void\n-gomp_free_memmap (struct gomp_memory_mapping *mm)\n+gomp_free_memmap (struct splay_tree_s *mem_map)\n {\n-  while (mm->splay_tree.root)\n+  while (mem_map->root)\n     {\n-      struct target_mem_desc *tgt = mm->splay_tree.root->key.tgt;\n+      struct target_mem_desc *tgt = mem_map->root->key.tgt;\n \n-      splay_tree_remove (&mm->splay_tree, &mm->splay_tree.root->key);\n+      splay_tree_remove (mem_map, &mem_map->root->key);\n       free (tgt->array);\n       free (tgt);\n     }\n-\n-  mm->is_initialized = false;\n }\n \n /* This function de-initializes the target device, specified by DEVICEP.\n@@ -791,22 +978,19 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n     fn_addr = (void *) fn;\n   else\n     {\n-      struct gomp_memory_mapping *mm = &devicep->mem_map;\n-      gomp_mutex_lock (&mm->lock);\n-\n-      if (!mm->is_initialized)\n-\tgomp_init_tables (devicep, mm);\n-\n+      gomp_mutex_lock (&devicep->lock);\n       struct splay_tree_key_s k;\n       k.host_start = (uintptr_t) fn;\n       k.host_end = k.host_start + 1;\n-      splay_tree_key tgt_fn = splay_tree_lookup (&mm->splay_tree, &k);\n+      splay_tree_key tgt_fn = splay_tree_lookup (&devicep->mem_map, &k);\n       if (tgt_fn == NULL)\n-\tgomp_fatal (\"Target function wasn't mapped\");\n-\n-      gomp_mutex_unlock (&mm->lock);\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  gomp_fatal (\"Target function wasn't mapped\");\n+\t}\n+      gomp_mutex_unlock (&devicep->lock);\n \n-      fn_addr = (void *) tgt_fn->tgt->tgt_start;\n+      fn_addr = (void *) tgt_fn->tgt_offset;\n     }\n \n   struct target_mem_desc *tgt_vars\n@@ -856,12 +1040,6 @@ GOMP_target_data (int device, const void *unused, size_t mapnum,\n     gomp_init_device (devicep);\n   gomp_mutex_unlock (&devicep->lock);\n \n-  struct gomp_memory_mapping *mm = &devicep->mem_map;\n-  gomp_mutex_lock (&mm->lock);\n-  if (!mm->is_initialized)\n-    gomp_init_tables (devicep, mm);\n-  gomp_mutex_unlock (&mm->lock);\n-\n   struct target_mem_desc *tgt\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n \t\t     false);\n@@ -897,13 +1075,7 @@ GOMP_target_update (int device, const void *unused, size_t mapnum,\n     gomp_init_device (devicep);\n   gomp_mutex_unlock (&devicep->lock);\n \n-  struct gomp_memory_mapping *mm = &devicep->mem_map;\n-  gomp_mutex_lock (&mm->lock);\n-  if (!mm->is_initialized)\n-    gomp_init_tables (devicep, mm);\n-  gomp_mutex_unlock (&mm->lock);\n-\n-  gomp_update (devicep, mm, mapnum, hostaddrs, sizes, kinds, false);\n+  gomp_update (devicep, mapnum, hostaddrs, sizes, kinds, false);\n }\n \n void\n@@ -972,10 +1144,10 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n   DLSYM (get_caps);\n   DLSYM (get_type);\n   DLSYM (get_num_devices);\n-  DLSYM (register_image);\n   DLSYM (init_device);\n   DLSYM (fini_device);\n-  DLSYM (get_table);\n+  DLSYM (load_image);\n+  DLSYM (unload_image);\n   DLSYM (alloc);\n   DLSYM (free);\n   DLSYM (dev2host);\n@@ -1038,22 +1210,6 @@ gomp_load_plugin_for_device (struct gomp_device_descr *device,\n   return err == NULL;\n }\n \n-/* This function adds a compatible offload image IMAGE to an accelerator device\n-   DEVICE.  DEVICE must be locked on entry, and remains locked on return.  */\n-\n-static void\n-gomp_register_image_for_device (struct gomp_device_descr *device,\n-\t\t\t\tstruct offload_image_descr *image)\n-{\n-  if (!device->offload_regions_registered\n-      && (device->type == image->type\n-\t  || device->type == OFFLOAD_TARGET_TYPE_HOST))\n-    {\n-      device->register_image_func (image->host_table, image->target_data);\n-      device->offload_regions_registered = true;\n-    }\n-}\n-\n /* This function initializes the runtime needed for offloading.\n    It parses the list of offload targets and tries to load the plugins for\n    these targets.  On return, the variables NUM_DEVICES and NUM_DEVICES_OPENMP\n@@ -1112,17 +1268,14 @@ gomp_target_init (void)\n \t\tcurrent_device.name = current_device.get_name_func ();\n \t\t/* current_device.capabilities has already been set.  */\n \t\tcurrent_device.type = current_device.get_type_func ();\n-\t\tcurrent_device.mem_map.is_initialized = false;\n-\t\tcurrent_device.mem_map.splay_tree.root = NULL;\n+\t\tcurrent_device.mem_map.root = NULL;\n \t\tcurrent_device.is_initialized = false;\n-\t\tcurrent_device.offload_regions_registered = false;\n \t\tcurrent_device.openacc.data_environ = NULL;\n \t\tcurrent_device.openacc.target_data = NULL;\n \t\tfor (i = 0; i < new_num_devices; i++)\n \t\t  {\n \t\t    current_device.target_id = i;\n \t\t    devices[num_devices] = current_device;\n-\t\t    gomp_mutex_init (&devices[num_devices].mem_map.lock);\n \t\t    gomp_mutex_init (&devices[num_devices].lock);\n \t\t    num_devices++;\n \t\t  }\n@@ -1157,21 +1310,12 @@ gomp_target_init (void)\n \n   for (i = 0; i < num_devices; i++)\n     {\n-      int j;\n-\n-      for (j = 0; j < num_offload_images; j++)\n-\tgomp_register_image_for_device (&devices[i], &offload_images[j]);\n-\n       /* The 'devices' array can be moved (by the realloc call) until we have\n \t found all the plugins, so registering with the OpenACC runtime (which\n \t takes a copy of the pointer argument) must be delayed until now.  */\n       if (devices[i].capabilities & GOMP_OFFLOAD_CAP_OPENACC_200)\n \tgoacc_register (&devices[i]);\n     }\n-\n-  free (offload_images);\n-  offload_images = NULL;\n-  num_offload_images = 0;\n }\n \n #else /* PLUGIN_SUPPORT */"}, {"sha": "c43e9fcda55213f66df3ab083750e1006ca5b154", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -1,3 +1,17 @@\n+2015-04-06  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* plugin/libgomp-plugin-intelmic.cpp: Include map.\n+\t(AddrVect, DevAddrVect, ImgDevAddrMap): New typedefs.\n+\t(num_devices, num_images, address_table): New static vars.\n+\t(num_libraries, lib_descrs): Remove static vars.\n+\t(set_mic_lib_path): Rename to ...\n+\t(init): ... this.  Allocate address_table and get num_devices.\n+\t(GOMP_OFFLOAD_get_num_devices): return num_devices.\n+\t(load_lib_and_get_table): Remove static function.\n+\t(offload_image): New static function.\n+\t(GOMP_OFFLOAD_get_table): Remove function.\n+\t(GOMP_OFFLOAD_load_image, GOMP_OFFLOAD_unload_image): New functions.\n+\n 2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_name)"}, {"sha": "a2d61b15783ed49b1c002db44d2b6e7a331dcd83", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 99, "deletions": 104, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51df54e487cf1e03b6d01ffa2446a69e2b25c79/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=a51df54e487cf1e03b6d01ffa2446a69e2b25c79", "patch": "@@ -34,6 +34,7 @@\n #include <string.h>\n #include <utility>\n #include <vector>\n+#include <map>\n #include \"libgomp-plugin.h\"\n #include \"compiler_if_host.h\"\n #include \"main_target_image.h\"\n@@ -53,6 +54,29 @@ fprintf (stderr, \"\\n\");\t\t\t\t\t    \\\n #endif\n \n \n+/* Start/end addresses of functions and global variables on a device.  */\n+typedef std::vector<addr_pair> AddrVect;\n+\n+/* Addresses for one image and all devices.  */\n+typedef std::vector<AddrVect> DevAddrVect;\n+\n+/* Addresses for all images and all devices.  */\n+typedef std::map<void *, DevAddrVect> ImgDevAddrMap;\n+\n+\n+/* Total number of available devices.  */\n+static int num_devices;\n+\n+/* Total number of shared libraries with offloading to Intel MIC.  */\n+static int num_images;\n+\n+/* Two dimensional array: one key is a pointer to image,\n+   second key is number of device.  Contains a vector of pointer pairs.  */\n+static ImgDevAddrMap *address_table;\n+\n+/* Thread-safe registration of the main image.  */\n+static pthread_once_t main_image_is_registered = PTHREAD_ONCE_INIT;\n+\n static VarDesc vd_host2tgt = {\n   { 1, 1 },\t\t      /* dst, src\t\t\t      */\n   { 1, 0 },\t\t      /* in, out\t\t\t      */\n@@ -90,28 +114,17 @@ static VarDesc vd_tgt2host = {\n };\n \n \n-/* Total number of shared libraries with offloading to Intel MIC.  */\n-static int num_libraries;\n-\n-/* Pointers to the descriptors, containing pointers to host-side tables and to\n-   target images.  */\n-static std::vector< std::pair<void *, void *> > lib_descrs;\n-\n-/* Thread-safe registration of the main image.  */\n-static pthread_once_t main_image_is_registered = PTHREAD_ONCE_INIT;\n-\n-\n /* Add path specified in LD_LIBRARY_PATH to MIC_LD_LIBRARY_PATH, which is\n    required by liboffloadmic.  */\n __attribute__((constructor))\n static void\n-set_mic_lib_path (void)\n+init (void)\n {\n   const char *ld_lib_path = getenv (LD_LIBRARY_PATH_ENV);\n   const char *mic_lib_path = getenv (MIC_LD_LIBRARY_PATH_ENV);\n \n   if (!ld_lib_path)\n-    return;\n+    goto out;\n \n   if (!mic_lib_path)\n     setenv (MIC_LD_LIBRARY_PATH_ENV, ld_lib_path, 1);\n@@ -133,6 +146,10 @@ set_mic_lib_path (void)\n       if (!use_alloca)\n \tfree (mic_lib_path_new);\n     }\n+\n+out:\n+  address_table = new ImgDevAddrMap;\n+  num_devices = _Offload_number_of_devices ();\n }\n \n extern \"C\" const char *\n@@ -162,18 +179,8 @@ GOMP_OFFLOAD_get_type (void)\n extern \"C\" int\n GOMP_OFFLOAD_get_num_devices (void)\n {\n-  int res = _Offload_number_of_devices ();\n-  TRACE (\"(): return %d\", res);\n-  return res;\n-}\n-\n-/* This should be called from every shared library with offloading.  */\n-extern \"C\" void\n-GOMP_OFFLOAD_register_image (void *host_table, void *target_image)\n-{\n-  TRACE (\"(host_table = %p, target_image = %p)\", host_table, target_image);\n-  lib_descrs.push_back (std::make_pair (host_table, target_image));\n-  num_libraries++;\n+  TRACE (\"(): return %d\", num_devices);\n+  return num_devices;\n }\n \n static void\n@@ -196,7 +203,8 @@ register_main_image ()\n   __offload_register_image (&main_target_image);\n }\n \n-/* Load offload_target_main on target.  */\n+/* liboffloadmic loads and runs offload_target_main on all available devices\n+   during a first call to offload ().  */\n extern \"C\" void\n GOMP_OFFLOAD_init_device (int device)\n {\n@@ -243,9 +251,11 @@ get_target_table (int device, int &num_funcs, int &num_vars, void **&table)\n     }\n }\n \n+/* Offload TARGET_IMAGE to all available devices and fill address_table with\n+   corresponding target addresses.  */\n+\n static void\n-load_lib_and_get_table (int device, int lib_num, mapping_table *&table,\n-\t\t\tint &table_size)\n+offload_image (void *target_image)\n {\n   struct TargetImage {\n     int64_t size;\n@@ -254,19 +264,11 @@ load_lib_and_get_table (int device, int lib_num, mapping_table *&table,\n     char data[];\n   } __attribute__ ((packed));\n \n-  void ***host_table_descr = (void ***) lib_descrs[lib_num].first;\n-  void **host_func_start = host_table_descr[0];\n-  void **host_func_end   = host_table_descr[1];\n-  void **host_var_start  = host_table_descr[2];\n-  void **host_var_end    = host_table_descr[3];\n+  void *image_start = ((void **) target_image)[0];\n+  void *image_end   = ((void **) target_image)[1];\n \n-  void **target_image_descr = (void **) lib_descrs[lib_num].second;\n-  void *image_start = target_image_descr[0];\n-  void *image_end   = target_image_descr[1];\n-\n-  TRACE (\"() host_table_descr { %p, %p, %p, %p }\", host_func_start,\n-\t host_func_end, host_var_start, host_var_end);\n-  TRACE (\"() target_image_descr { %p, %p }\", image_start, image_end);\n+  TRACE (\"(target_image = %p { %p, %p })\",\n+\t target_image, image_start, image_end);\n \n   int64_t image_size = (uintptr_t) image_end - (uintptr_t) image_start;\n   TargetImage *image\n@@ -279,94 +281,87 @@ load_lib_and_get_table (int device, int lib_num, mapping_table *&table,\n     }\n \n   image->size = image_size;\n-  sprintf (image->name, \"lib%010d.so\", lib_num);\n+  sprintf (image->name, \"lib%010d.so\", num_images++);\n   memcpy (image->data, image_start, image->size);\n \n   TRACE (\"() __offload_register_image %s { %p, %d }\",\n \t image->name, image_start, image->size);\n   __offload_register_image (image);\n \n-  int tgt_num_funcs = 0;\n-  int tgt_num_vars = 0;\n-  void **tgt_table = NULL;\n-  get_target_table (device, tgt_num_funcs, tgt_num_vars, tgt_table);\n-  free (image);\n-\n-  /* The func table contains only addresses, the var table contains addresses\n-     and corresponding sizes.  */\n-  int host_num_funcs = host_func_end - host_func_start;\n-  int host_num_vars  = (host_var_end - host_var_start) / 2;\n-  TRACE (\"() host_num_funcs = %d, tgt_num_funcs = %d\",\n-\t host_num_funcs, tgt_num_funcs);\n-  TRACE (\"() host_num_vars = %d, tgt_num_vars = %d\",\n-\t host_num_vars, tgt_num_vars);\n-  if (host_num_funcs != tgt_num_funcs)\n+  /* Receive tables for target_image from all devices.  */\n+  DevAddrVect dev_table;\n+  for (int dev = 0; dev < num_devices; dev++)\n     {\n-      fprintf (stderr, \"%s: Can't map target functions\\n\", __FILE__);\n-      exit (1);\n-    }\n-  if (host_num_vars != tgt_num_vars)\n-    {\n-      fprintf (stderr, \"%s: Can't map target variables\\n\", __FILE__);\n-      exit (1);\n-    }\n+      int num_funcs = 0;\n+      int num_vars = 0;\n+      void **table = NULL;\n \n-  table = (mapping_table *) realloc (table, (table_size + host_num_funcs\n-\t\t\t\t\t     + host_num_vars)\n-\t\t\t\t\t    * sizeof (mapping_table));\n-  if (table == NULL)\n-    {\n-      fprintf (stderr, \"%s: Can't allocate memory\\n\", __FILE__);\n-      exit (1);\n-    }\n+      get_target_table (dev, num_funcs, num_vars, table);\n \n-  for (int i = 0; i < host_num_funcs; i++)\n-    {\n-      mapping_table t;\n-      t.host_start = (uintptr_t) host_func_start[i];\n-      t.host_end = t.host_start + 1;\n-      t.tgt_start = (uintptr_t) tgt_table[i];\n-      t.tgt_end = t.tgt_start + 1;\n-\n-      TRACE (\"() lib %d, func %d:\\t0x%llx -- 0x%llx\",\n-\t     lib_num, i, t.host_start, t.tgt_start);\n-\n-      table[table_size++] = t;\n-    }\n+      AddrVect curr_dev_table;\n \n-  for (int i = 0; i < host_num_vars * 2; i += 2)\n-    {\n-      mapping_table t;\n-      t.host_start = (uintptr_t) host_var_start[i];\n-      t.host_end = t.host_start + (uintptr_t) host_var_start[i+1];\n-      t.tgt_start = (uintptr_t) tgt_table[tgt_num_funcs+i];\n-      t.tgt_end = t.tgt_start + (uintptr_t) tgt_table[tgt_num_funcs+i+1];\n+      for (int i = 0; i < num_funcs; i++)\n+\t{\n+\t  addr_pair tgt_addr;\n+\t  tgt_addr.start = (uintptr_t) table[i];\n+\t  tgt_addr.end = tgt_addr.start + 1;\n+\t  TRACE (\"() func %d:\\t0x%llx..0x%llx\", i,\n+\t\t tgt_addr.start, tgt_addr.end);\n+\t  curr_dev_table.push_back (tgt_addr);\n+\t}\n \n-      TRACE (\"() lib %d, var %d:\\t0x%llx (%d) -- 0x%llx (%d)\", lib_num, i/2,\n-\t     t.host_start, t.host_end - t.host_start,\n-\t     t.tgt_start, t.tgt_end - t.tgt_start);\n+      for (int i = 0; i < num_vars; i++)\n+\t{\n+\t  addr_pair tgt_addr;\n+\t  tgt_addr.start = (uintptr_t) table[num_funcs+i*2];\n+\t  tgt_addr.end = tgt_addr.start + (uintptr_t) table[num_funcs+i*2+1];\n+\t  TRACE (\"() var %d:\\t0x%llx..0x%llx\", i, tgt_addr.start, tgt_addr.end);\n+\t  curr_dev_table.push_back (tgt_addr);\n+\t}\n \n-      table[table_size++] = t;\n+      dev_table.push_back (curr_dev_table);\n     }\n \n-  delete [] tgt_table;\n+  address_table->insert (std::make_pair (target_image, dev_table));\n+\n+  free (image);\n }\n \n extern \"C\" int\n-GOMP_OFFLOAD_get_table (int device, void *result)\n+GOMP_OFFLOAD_load_image (int device, void *target_image, addr_pair **result)\n {\n-  TRACE (\"(num_libraries = %d)\", num_libraries);\n+  TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n \n-  mapping_table *table = NULL;\n-  int table_size = 0;\n+  /* If target_image is already present in address_table, then there is no need\n+     to offload it.  */\n+  if (address_table->count (target_image) == 0)\n+    offload_image (target_image);\n \n-  for (int i = 0; i < num_libraries; i++)\n-    load_lib_and_get_table (device, i, table, table_size);\n+  AddrVect *curr_dev_table = &(*address_table)[target_image][device];\n+  int table_size = curr_dev_table->size ();\n+  addr_pair *table = (addr_pair *) malloc (table_size * sizeof (addr_pair));\n+  if (table == NULL)\n+    {\n+      fprintf (stderr, \"%s: Can't allocate memory\\n\", __FILE__);\n+      exit (1);\n+    }\n \n-  *(void **) result = table;\n+  std::copy (curr_dev_table->begin (), curr_dev_table->end (), table);\n+  *result = table;\n   return table_size;\n }\n \n+extern \"C\" void\n+GOMP_OFFLOAD_unload_image (int device, void *target_image)\n+{\n+  TRACE (\"(device = %d, target_image = %p)\", device, target_image);\n+\n+  /* TODO: Currently liboffloadmic doesn't support __offload_unregister_image\n+     for libraries.  */\n+\n+  address_table->erase (target_image);\n+}\n+\n extern \"C\" void *\n GOMP_OFFLOAD_alloc (int device, size_t size)\n {"}]}