{"sha": "7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ1ODAyNmIwMThlNjYzNWI5ZDFiYWU5ZWMzYjlmNDczOGMzZDk0YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-09-27T19:48:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-09-27T19:48:20Z"}, "message": "common.opt (fsplit-stack): New option.\n\ngcc/:\n\t* common.opt (fsplit-stack): New option.\n\t* opts.c (decode_options): Set flag_split_stack to final value.\n\t* target.def (supports_split_stack): New hook.\n\t* gcc.c (STACK_SPLIT_SPEC): Define.\n\t(LINK_COMMAND_SPEC): Use STACK_SPLIT_SPEC.\n\t* doc/invoke.texi (Option Summary): Mention -fsplit-stack.\n\t(Code Gen Options): Document -fsplit-stack.\n\t* doc/extend.texi (Function Attributes): Mention no_split_stack.\n\t(Function Attributes): Document no_split_stack.\n\t* doc/tm.texi.in (Stack Smashing Protection): Add @hook\n\tTARGET_SUPPORTS_SPLIT_STACK.\n\t* doc/tm.texi: Rebuild.\n\t* function.c (thread_prologue_and_epilogue_insns): If\n\tflag_split_stack, add split stack prologue.\n\t* explow.c (allocate_dynamic_stack_space): Support -fsplit-stack.\n\t* varasm.c (saw_no_split_stack): New static variable.\n\t(assemble_start_function): Set saw_no_split_stack if the function\n\thas the no_split_stack attribute.\n\t(file_end_indicate_split_stack): New function.\n\t* output.h (file_end_indicate_split_stack): Declare.\n\t* libgcc-std.ver (GCC_4.6.0): Add -fsplit-stack support variables\n\tand function.\n\t* doc/libgcc.texi (Miscellaneous routines): Document -fsplit-stack\n\troutines.\n\t* config/i386/i386.c (ix86_option_override_internal): Don't set\n\texpand_builtin_va_start to NULL if -fsplit-stack.\n\t(ix86_function_regparm): Reduce local regparm by 1 for 32-bit\n\t-fsplit-stack.\n\t(ix86_va_start): If -fsplit-stack, get overflow pointer\tfrom\n\tscratch register set by prologue.\n\t(ix86_code_end): If -fsplit-stack, call\n\tfile_end_indicate_split_stack.\n\t(ix86_supports_split_stack): New static function.\n\t(SPLIT_STACK_AVAILABLE): Define.\n\t(split_stack_prologue_scratch_regno): New static function.\n\t(split_stack_fn): New static variable.\n\t(ix86_expand_split_stack_prologue): New function.\n\t(ix86_live_on_entry): New static function.\n\t(ix86_legitimate_address_p): Handle UNSPEC_STACK_CHECK.\n\t(output_pic_addr_const): Likewise.\n\t(i386_asm_output_addr_const_extra): Likewise.\n\t(ix86_expand_call): Change return type to rtx.  Return the new\n\tcall instruction.\n\t(TARGET_SUPPORTS_SPLIT_STACK): Define.\n\t(TARGET_EXTRA_LIVE_ON_ENTRY): Define.\n\t* config/i386/i386.md (UNSPEC_STACK_CHECK): Define.\n\t(split_stack_prologue, split_stack_return): New insns.\n\t(split_stack_space_check): New insn.\n\t* config/i386/i386.h (struct machine_function): Add\n\tsplit_stack_varargs_pointer field.\n\t* config/i386/linux.h (TARGET_CAN_SPLIT_STACK): Define.\n\t(TARGET_THREAD_SPLIT_STACK_OFFSET): Define.\n\t* config/i386/linux64.h (TARGET_CAN_SPLIT_STACK): Define.\n\t(TARGET_THREAD_SPLIT_STACK_OFFSET): Define.\n\t* config/i386/i386-protos.h (ix86_expand_split_stack_prologue):\n\tDeclare.\n\t(ix86_expand_call): Update declaration.\ngcc/c-family/:\n\t* c-common.c (c_common_attribute_table): Add no_split_stack.\n\t(handle_no_split_stack_attribute): New static function.\ngcc/testsuite/:\n\t* lib/target-supports.exp (check_effective_target_split_stack):\n\tNew procedure.\n\t* gcc.dg/split-1.c: New test.\n\t* gcc.dg/split-2.c: New test.\n\t* gcc.dg/split-3.c: New test.\n\t* gcc.dg/split-4.c: New test.\nlibgcc/:\n\t* generic-morestack.h: New file.\n\t* generic-morestack.c: New file.\n\t* generic-morestack-thread.c: New file.\n\t* config/i386/morestack.S: New file.\n\t* config/t-stack: New file.\n\t* config/i386/t-stack-i386: New file.\n\t* config.host (i[34567]86-*-linux* and friends): Add t-stack and\n\ti386/t-stack-i386 to tmake_file.\n\nFrom-SVN: r164661", "tree": {"sha": "69a38455d6a1f5425700674e4dc6483284eed579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69a38455d6a1f5425700674e4dc6483284eed579"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/comments", "author": null, "committer": null, "parents": [{"sha": "177b48f93077a03a72cee7ab5897996e2ea47cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/177b48f93077a03a72cee7ab5897996e2ea47cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/177b48f93077a03a72cee7ab5897996e2ea47cdc"}], "stats": {"total": 2775, "additions": 2742, "deletions": 33}, "files": [{"sha": "1970bd74cdf63249e292255b4d089e3ef93a6630", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1,3 +1,63 @@\n+2010-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* common.opt (fsplit-stack): New option.\n+\t* opts.c (decode_options): Set flag_split_stack to final value.\n+\t* target.def (supports_split_stack): New hook.\n+\t* gcc.c (STACK_SPLIT_SPEC): Define.\n+\t(LINK_COMMAND_SPEC): Use STACK_SPLIT_SPEC.\n+\t* doc/invoke.texi (Option Summary): Mention -fsplit-stack.\n+\t(Code Gen Options): Document -fsplit-stack.\n+\t* doc/extend.texi (Function Attributes): Mention no_split_stack.\n+\t(Function Attributes): Document no_split_stack.\n+\t* doc/tm.texi.in (Stack Smashing Protection): Add @hook\n+\tTARGET_SUPPORTS_SPLIT_STACK.\n+\t* doc/tm.texi: Rebuild.\n+\t* function.c (thread_prologue_and_epilogue_insns): If\n+\tflag_split_stack, add split stack prologue.\n+\t* explow.c (allocate_dynamic_stack_space): Support -fsplit-stack.\n+\t* varasm.c (saw_no_split_stack): New static variable.\n+\t(assemble_start_function): Set saw_no_split_stack if the function\n+\thas the no_split_stack attribute.\n+\t(file_end_indicate_split_stack): New function.\n+\t* output.h (file_end_indicate_split_stack): Declare.\n+\t* libgcc-std.ver (GCC_4.6.0): Add -fsplit-stack support variables\n+\tand function.\n+\t* doc/libgcc.texi (Miscellaneous routines): Document -fsplit-stack\n+\troutines.\n+\t* config/i386/i386.c (ix86_option_override_internal): Don't set\n+\texpand_builtin_va_start to NULL if -fsplit-stack.\n+\t(ix86_function_regparm): Reduce local regparm by 1 for 32-bit\n+\t-fsplit-stack.\n+\t(ix86_va_start): If -fsplit-stack, get overflow pointer\tfrom\n+\tscratch register set by prologue.\n+\t(ix86_code_end): If -fsplit-stack, call\n+\tfile_end_indicate_split_stack.\n+\t(ix86_supports_split_stack): New static function.\n+\t(SPLIT_STACK_AVAILABLE): Define.\n+\t(split_stack_prologue_scratch_regno): New static function.\n+\t(split_stack_fn): New static variable.\n+\t(ix86_expand_split_stack_prologue): New function.\n+\t(ix86_live_on_entry): New static function.\n+\t(ix86_legitimate_address_p): Handle UNSPEC_STACK_CHECK.\n+\t(output_pic_addr_const): Likewise.\n+\t(i386_asm_output_addr_const_extra): Likewise.\n+\t(ix86_expand_call): Change return type to rtx.  Return the new\n+\tcall instruction.\n+\t(TARGET_SUPPORTS_SPLIT_STACK): Define.\n+\t(TARGET_EXTRA_LIVE_ON_ENTRY): Define.\n+\t* config/i386/i386.md (UNSPEC_STACK_CHECK): Define.\n+\t(split_stack_prologue, split_stack_return): New insns.\n+\t(split_stack_space_check): New insn.\n+\t* config/i386/i386.h (struct machine_function): Add\n+\tsplit_stack_varargs_pointer field.\n+\t* config/i386/linux.h (TARGET_CAN_SPLIT_STACK): Define.\n+\t(TARGET_THREAD_SPLIT_STACK_OFFSET): Define.\n+\t* config/i386/linux64.h (TARGET_CAN_SPLIT_STACK): Define.\n+\t(TARGET_THREAD_SPLIT_STACK_OFFSET): Define.\n+\t* config/i386/i386-protos.h (ix86_expand_split_stack_prologue):\n+\tDeclare.\n+\t(ix86_expand_call): Update declaration.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* doc/objc.texi (Type encoding): Added the new 'long double' (D)"}, {"sha": "e16c8718b8872b3e17cace77fb65a74a3192a663", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1,3 +1,8 @@\n+2010-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c-common.c (c_common_attribute_table): Add no_split_stack.\n+\t(handle_no_split_stack_attribute): New static function.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\t"}, {"sha": "63e2d70fa9d1461afb8e755cb64a19b876cb5977", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -358,6 +358,7 @@ static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_no_split_stack_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n \n static void check_function_nonnull (tree, int, tree *);\n@@ -661,6 +662,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_target_attribute },\n   { \"optimize\",               1, -1, true, false, false,\n \t\t\t      handle_optimize_attribute },\n+  { \"no_split_stack\",\t      0, 0, true,  false, false,\n+\t\t\t      handle_no_split_stack_attribute },\n   /* For internal use (marking of builtins and runtime functions) only.\n      The name contains space to prevent its usage in source code.  */\n   { \"fn spec\",\t \t      1, 1, false, true, true,\n@@ -7841,6 +7844,32 @@ handle_optimize_attribute (tree *node, tree name, tree args,\n \n   return NULL_TREE;\n }\n+\n+/* Handle a \"no_split_stack\" attribute.  */\n+\n+static tree\n+handle_no_split_stack_attribute (tree *node, tree name,\n+\t\t\t\t tree ARG_UNUSED (args),\n+\t\t\t\t int ARG_UNUSED (flags),\n+\t\t\t\t bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute applies only to functions\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"can%'t set %qE attribute after definition\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n \f\n /* Check for valid arguments being passed to a function.\n    ATTRS is a list of attributes.  There are NARGS arguments in the array"}, {"sha": "aa17ae80b3f2dcb1ad14a69313cda70e1a3d7f55", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1426,6 +1426,10 @@ fsplit-ivs-in-unroller\n Common Report Var(flag_split_ivs_in_unroller) Init(1) Optimization\n Split lifetimes of induction variables when loops are unrolled\n \n+fsplit-stack\n+Common Report Var(flag_split_stack) Init(-1)\n+Generate discontiguous stack frames\n+\n fsplit-wide-types\n Common Report Var(flag_split_wide_types) Optimization\n Split wide types into independent registers"}, {"sha": "700dec1e520b1a48a12a808e8ac64c4f4ad4ca39", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -29,6 +29,7 @@ extern void ix86_setup_frame_addresses (void);\n extern HOST_WIDE_INT ix86_initial_elimination_offset (int, int);\n extern void ix86_expand_prologue (void);\n extern void ix86_expand_epilogue (int);\n+extern void ix86_expand_split_stack_prologue (void);\n \n extern void ix86_output_addr_vec_elt (FILE *, int);\n extern void ix86_output_addr_diff_elt (FILE *, int, int);\n@@ -117,7 +118,7 @@ extern bool ix86_expand_int_vcond (rtx[]);\n extern void ix86_expand_sse_unpack (rtx[], bool, bool);\n extern void ix86_expand_sse4_unpack (rtx[], bool, bool);\n extern bool ix86_expand_int_addcc (rtx[]);\n-extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n+extern rtx ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);\n extern rtx ix86_zero_extend_to_Pmode (rtx);\n extern void ix86_split_long_move (rtx[]);"}, {"sha": "7d4126beece4c51a91c113e9b645e04513e16a4f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 392, "deletions": 4, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1989,6 +1989,8 @@ static void ix86_add_new_builtins (int);\n static rtx ix86_expand_vec_perm_builtin (tree);\n static tree ix86_canonical_va_list_type (tree);\n static void predict_jump (int);\n+static unsigned int split_stack_prologue_scratch_regno (void);\n+static bool i386_asm_output_addr_const_extra (FILE *, rtx);\n \n enum ix86_function_specific_strings\n {\n@@ -3649,7 +3651,7 @@ ix86_option_override_internal (bool main_args_p)\n \n   /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n      can be optimized to ap = __builtin_next_arg (0).  */\n-  if (!TARGET_64BIT)\n+  if (!TARGET_64BIT && !flag_split_stack)\n     targetm.expand_builtin_va_start = NULL;\n \n   if (TARGET_64BIT)\n@@ -4890,6 +4892,10 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \t  if (local_regparm == 3 && DECL_STATIC_CHAIN (decl))\n \t    local_regparm = 2;\n \n+\t  /* In 32-bit mode save a register for the split stack.  */\n+\t  if (!TARGET_64BIT && local_regparm == 3 && flag_split_stack)\n+\t    local_regparm = 2;\n+\n \t  /* Each fixed register usage increases register pressure,\n \t     so less registers should be used for argument passing.\n \t     This functionality can be overriden by an explicit\n@@ -7248,10 +7254,56 @@ ix86_va_start (tree valist, rtx nextarg)\n   tree gpr, fpr, ovf, sav, t;\n   tree type;\n \n+  rtx ovf_rtx;\n+\n+  if (flag_split_stack\n+      && cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n+    {\n+      unsigned int scratch_regno;\n+\n+      /* When we are splitting the stack, we can't refer to the stack\n+\t arguments using internal_arg_pointer, because they may be on\n+\t the old stack.  The split stack prologue will arrange to\n+\t leave a pointer to the old stack arguments in a scratch\n+\t register, which we here copy to a pseudo-register.  The split\n+\t stack prologue can't set the pseudo-register directly because\n+\t it (the prologue) runs before any registers have been saved.  */\n+\n+      scratch_regno = split_stack_prologue_scratch_regno ();\n+      if (scratch_regno != INVALID_REGNUM)\n+\t{\n+\t  rtx reg, seq;\n+\n+\t  reg = gen_reg_rtx (Pmode);\n+\t  cfun->machine->split_stack_varargs_pointer = reg;\n+\n+\t  start_sequence ();\n+\t  emit_move_insn (reg, gen_rtx_REG (Pmode, scratch_regno));\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  push_topmost_sequence ();\n+\t  emit_insn_after (seq, entry_of_function ());\n+\t  pop_topmost_sequence ();\n+\t}\n+    }\n+\n   /* Only 64bit target needs something special.  */\n   if (!TARGET_64BIT || is_va_list_char_pointer (TREE_TYPE (valist)))\n     {\n-      std_expand_builtin_va_start (valist, nextarg);\n+      if (cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n+\tstd_expand_builtin_va_start (valist, nextarg);\n+      else\n+\t{\n+\t  rtx va_r, next;\n+\n+\t  va_r = expand_expr (valist, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+\t  next = expand_binop (ptr_mode, add_optab,\n+\t\t\t       cfun->machine->split_stack_varargs_pointer,\n+\t\t\t       crtl->args.arg_offset_rtx,\n+\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t  convert_move (va_r, next, 0);\n+\t}\n       return;\n     }\n \n@@ -7297,7 +7349,11 @@ ix86_va_start (tree valist, rtx nextarg)\n \n   /* Find the overflow area.  */\n   type = TREE_TYPE (ovf);\n-  t = make_tree (type, crtl->args.internal_arg_pointer);\n+  if (cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n+    ovf_rtx = crtl->args.internal_arg_pointer;\n+  else\n+    ovf_rtx = cfun->machine->split_stack_varargs_pointer;\n+  t = make_tree (type, ovf_rtx);\n   if (words != 0)\n     t = build2 (POINTER_PLUS_EXPR, type, t,\n \t        size_int (words * UNITS_PER_WORD));\n@@ -8042,6 +8098,9 @@ ix86_code_end (void)\n       set_cfun (NULL);\n       current_function_decl = NULL;\n     }\n+\n+  if (flag_split_stack)\n+    file_end_indicate_split_stack ();\n }\n \n /* Emit code for the SET_GOT patterns.  */\n@@ -8344,6 +8403,29 @@ ix86_builtin_setjmp_frame_value (void)\n   return stack_realign_fp ? hard_frame_pointer_rtx : virtual_stack_vars_rtx;\n }\n \n+/* On the x86 -fsplit-stack and -fstack-protector both use the same\n+   field in the TCB, so they can not be used together.  */\n+\n+static bool\n+ix86_supports_split_stack (bool report ATTRIBUTE_UNUSED)\n+{\n+  bool ret = true;\n+\n+#ifndef TARGET_THREAD_SPLIT_STACK_OFFSET\n+  if (report)\n+    error (\"%<-fsplit-stack%> currently only supported on GNU/Linux\");\n+  ret = false;\n+#endif\n+\n+  return ret;\n+}\n+\n+/* When using -fsplit-stack, the allocation routines set a field in\n+   the TCB to the bottom of the stack plus this much space, measured\n+   in bytes.  */\n+\n+#define SPLIT_STACK_AVAILABLE 256\n+\n /* Fill structure ix86_frame about frame of currently computed function.  */\n \n static void\n@@ -10334,6 +10416,277 @@ ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n #endif\n \n }\n+\n+/* Return a scratch register to use in the split stack prologue.  The\n+   split stack prologue is used for -fsplit-stack.  It is the first\n+   instructions in the function, even before the regular prologue.\n+   The scratch register can be any caller-saved register which is not\n+   used for parameters or for the static chain.  */\n+\n+static unsigned int\n+split_stack_prologue_scratch_regno (void)\n+{\n+  if (TARGET_64BIT)\n+    return R11_REG;\n+  else\n+    {\n+      bool is_fastcall;\n+      int regparm;\n+\n+      is_fastcall = (lookup_attribute (\"fastcall\",\n+\t\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl)))\n+\t\t     != NULL);\n+      regparm = ix86_function_regparm (TREE_TYPE (cfun->decl), cfun->decl);\n+\n+      if (is_fastcall)\n+\t{\n+\t  if (DECL_STATIC_CHAIN (cfun->decl))\n+\t    {\n+\t      sorry (\"-fsplit-stack does not support fastcall with \"\n+\t\t     \"nested function\");\n+\t      return INVALID_REGNUM;\n+\t    }\n+\t  return AX_REG;\n+\t}\n+      else if (regparm < 3)\n+\t{\n+\t  if (!DECL_STATIC_CHAIN (cfun->decl))\n+\t    return CX_REG;\n+\t  else\n+\t    {\n+\t      if (regparm >= 2)\n+\t\t{\n+\t\t  sorry (\"-fsplit-stack does not support 2 register \"\n+\t\t\t \" parameters for a nested function\");\n+\t\t  return INVALID_REGNUM;\n+\t\t}\n+\t      return DX_REG;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* FIXME: We could make this work by pushing a register\n+\t     around the addition and comparison.  */\n+\t  sorry (\"-fsplit-stack does not support 3 register parameters\");\n+\t  return INVALID_REGNUM;\n+\t}\n+    }\n+}\n+\n+/* A SYMBOL_REF for the function which allocates new stackspace for\n+   -fsplit-stack.  */\n+\n+static GTY(()) rtx split_stack_fn;\n+\n+/* Handle -fsplit-stack.  These are the first instructions in the\n+   function, even before the regular prologue.  */\n+\n+void\n+ix86_expand_split_stack_prologue (void)\n+{\n+  struct ix86_frame frame;\n+  HOST_WIDE_INT allocate;\n+  int args_size;\n+  rtx label, limit, current, jump_insn, allocate_rtx, call_insn, call_fusage;\n+  rtx scratch_reg = NULL_RTX;\n+  rtx varargs_label = NULL_RTX;\n+\n+  gcc_assert (flag_split_stack && reload_completed);\n+\n+  ix86_finalize_stack_realign_flags ();\n+  ix86_compute_frame_layout (&frame);\n+  allocate = frame.stack_pointer_offset - INCOMING_FRAME_SP_OFFSET;\n+\n+  /* This is the label we will branch to if we have enough stack\n+     space.  We expect the basic block reordering pass to reverse this\n+     branch if optimizing, so that we branch in the unlikely case.  */\n+  label = gen_label_rtx ();\n+\n+  /* We need to compare the stack pointer minus the frame size with\n+     the stack boundary in the TCB.  The stack boundary always gives\n+     us SPLIT_STACK_AVAILABLE bytes, so if we need less than that we\n+     can compare directly.  Otherwise we need to do an addition.  */\n+\n+  limit = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t  UNSPEC_STACK_CHECK);\n+  limit = gen_rtx_CONST (Pmode, limit);\n+  limit = gen_rtx_MEM (Pmode, limit);\n+  if (allocate < SPLIT_STACK_AVAILABLE)\n+    current = stack_pointer_rtx;\n+  else\n+    {\n+      unsigned int scratch_regno;\n+      rtx offset;\n+\n+      /* We need a scratch register to hold the stack pointer minus\n+\t the required frame size.  Since this is the very start of the\n+\t function, the scratch register can be any caller-saved\n+\t register which is not used for parameters.  */\n+      offset = GEN_INT (- allocate);\n+      scratch_regno = split_stack_prologue_scratch_regno ();\n+      if (scratch_regno == INVALID_REGNUM)\n+\treturn;\n+      scratch_reg = gen_rtx_REG (Pmode, scratch_regno);\n+      if (!TARGET_64BIT || x86_64_immediate_operand (offset, Pmode))\n+\t{\n+\t  /* We don't use ix86_gen_add3 in this case because it will\n+\t     want to split to lea, but when not optimizing the insn\n+\t     will not be split after this point.  */\n+\t  emit_insn (gen_rtx_SET (VOIDmode, scratch_reg,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\toffset)));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (scratch_reg, offset);\n+\t  emit_insn (gen_adddi3 (scratch_reg, scratch_reg,\n+\t\t\t\t stack_pointer_rtx));\n+\t}\n+      current = scratch_reg;\n+    }\n+\n+  ix86_expand_branch (GEU, current, limit, label);\n+  jump_insn = get_last_insn ();\n+  JUMP_LABEL (jump_insn) = label;\n+\n+  /* Mark the jump as very likely to be taken.  */\n+  add_reg_note (jump_insn, REG_BR_PROB,\n+\t\tGEN_INT (REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100));\n+\n+  /* Get more stack space.  We pass in the desired stack space and the\n+     size of the arguments to copy to the new stack.  In 32-bit mode\n+     we push the parameters; __morestack will return on a new stack\n+     anyhow.  In 64-bit mode we pass the parameters in r10 and\n+     r11.  */\n+  allocate_rtx = GEN_INT (allocate);\n+  args_size = crtl->args.size >= 0 ? crtl->args.size : 0;\n+  call_fusage = NULL_RTX;\n+  if (TARGET_64BIT)\n+    {\n+      rtx reg;\n+\n+      reg = gen_rtx_REG (Pmode, R10_REG);\n+\n+      /* If this function uses a static chain, it will be in %r10.\n+\t Preserve it across the call to __morestack.  */\n+      if (DECL_STATIC_CHAIN (cfun->decl))\n+\t{\n+\t  rtx rax;\n+\n+\t  rax = gen_rtx_REG (Pmode, AX_REG);\n+\t  emit_move_insn (rax, reg);\n+\t  use_reg (&call_fusage, rax);\n+\t}\n+\n+      emit_move_insn (reg, allocate_rtx);\n+      use_reg (&call_fusage, reg);\n+      reg = gen_rtx_REG (Pmode, R11_REG);\n+      emit_move_insn (reg, GEN_INT (args_size));\n+      use_reg (&call_fusage, reg);\n+    }\n+  else\n+    {\n+      emit_insn (gen_push (GEN_INT (args_size)));\n+      emit_insn (gen_push (allocate_rtx));\n+    }\n+  if (split_stack_fn == NULL_RTX)\n+    split_stack_fn = gen_rtx_SYMBOL_REF (Pmode, \"__morestack\");\n+  call_insn = ix86_expand_call (NULL_RTX, gen_rtx_MEM (QImode, split_stack_fn),\n+\t\t\t\tGEN_INT (UNITS_PER_WORD), constm1_rtx,\n+\t\t\t\tNULL_RTX, 0);\n+  add_function_usage_to (call_insn, call_fusage);\n+\n+  /* In order to make call/return prediction work right, we now need\n+     to execute a return instruction.  See\n+     libgcc/config/i386/morestack.S for the details on how this works.\n+\n+     For flow purposes gcc must not see this as a return\n+     instruction--we need control flow to continue at the subsequent\n+     label.  Therefore, we use an unspec.  */\n+  gcc_assert (crtl->args.pops_args < 65536);\n+  emit_insn (gen_split_stack_return (GEN_INT (crtl->args.pops_args)));\n+\n+  /* If we are in 64-bit mode and this function uses a static chain,\n+     we saved %r10 in %rax before calling _morestack.  */\n+  if (TARGET_64BIT && DECL_STATIC_CHAIN (cfun->decl))\n+    emit_move_insn (gen_rtx_REG (Pmode, R10_REG),\n+\t\t    gen_rtx_REG (Pmode, AX_REG));\n+\n+  /* If this function calls va_start, we need to store a pointer to\n+     the arguments on the old stack, because they may not have been\n+     all copied to the new stack.  At this point the old stack can be\n+     found at the frame pointer value used by __morestack, because\n+     __morestack has set that up before calling back to us.  Here we\n+     store that pointer in a scratch register, and in\n+     ix86_expand_prologue we store the scratch register in a stack\n+     slot.  */\n+  if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n+    {\n+      unsigned int scratch_regno;\n+      rtx frame_reg;\n+      int words;\n+\n+      scratch_regno = split_stack_prologue_scratch_regno ();\n+      scratch_reg = gen_rtx_REG (Pmode, scratch_regno);\n+      frame_reg = gen_rtx_REG (Pmode, BP_REG);\n+\n+      /* 64-bit:\n+\t fp -> old fp value\n+\t       return address within this function\n+\t       return address of caller of this function\n+\t       stack arguments\n+\t So we add three words to get to the stack arguments.\n+\n+\t 32-bit:\n+\t fp -> old fp value\n+\t       return address within this function\n+               first argument to __morestack\n+               second argument to __morestack\n+               return address of caller of this function\n+               stack arguments\n+         So we add five words to get to the stack arguments.\n+      */\n+      words = TARGET_64BIT ? 3 : 5;\n+      emit_insn (gen_rtx_SET (VOIDmode, scratch_reg,\n+\t\t\t      gen_rtx_PLUS (Pmode, frame_reg,\n+\t\t\t\t\t    GEN_INT (words * UNITS_PER_WORD))));\n+\n+      varargs_label = gen_label_rtx ();\n+      emit_jump_insn (gen_jump (varargs_label));\n+      JUMP_LABEL (get_last_insn ()) = varargs_label;\n+\n+      emit_barrier ();\n+    }\n+\n+  emit_label (label);\n+  LABEL_NUSES (label) = 1;\n+\n+  /* If this function calls va_start, we now have to set the scratch\n+     register for the case where we do not call __morestack.  In this\n+     case we need to set it based on the stack pointer.  */\n+  if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, scratch_reg,\n+\t\t\t      gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t    GEN_INT (UNITS_PER_WORD))));\n+\n+      emit_label (varargs_label);\n+      LABEL_NUSES (varargs_label) = 1;\n+    }\n+}\n+\n+/* We may have to tell the dataflow pass that the split stack prologue\n+   is initializing a scratch register.  */\n+\n+static void\n+ix86_live_on_entry (bitmap regs)\n+{\n+  if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n+    {\n+      gcc_assert (flag_split_stack);\n+      bitmap_set_bit (regs, split_stack_prologue_scratch_regno ());\n+    }\n+}\n \f\n /* Extract the parts of an RTL expression that is a valid memory address\n    for an instruction.  Return 0 if the structure of the address is\n@@ -10979,6 +11332,10 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t  case UNSPEC_DTPOFF:\n \t    break;\n \n+\t  case UNSPEC_STACK_CHECK:\n+\t    gcc_assert (flag_split_stack);\n+\t    break;\n+\n \t  default:\n \t    /* Invalid address unspec.  */\n \t    return false;\n@@ -11870,6 +12227,13 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n       break;\n \n      case UNSPEC:\n+       if (XINT (x, 1) == UNSPEC_STACK_CHECK)\n+\t {\n+\t   bool f = i386_asm_output_addr_const_extra (file, x);\n+\t   gcc_assert (f);\n+\t   break;\n+\t }\n+\n        gcc_assert (XVECLEN (x, 0) == 1);\n        output_pic_addr_const (file, XVECEXP (x, 0, 0), code);\n        switch (XINT (x, 1))\n@@ -13273,6 +13637,22 @@ i386_asm_output_addr_const_extra (FILE *file, rtx x)\n       break;\n #endif\n \n+    case UNSPEC_STACK_CHECK:\n+      {\n+\tint offset;\n+\n+\tgcc_assert (flag_split_stack);\n+\n+#ifdef TARGET_THREAD_SPLIT_STACK_OFFSET\n+\toffset = TARGET_THREAD_SPLIT_STACK_OFFSET;\n+#else\n+\tgcc_unreachable ();\n+#endif\n+\n+\tfprintf (file, \"%s:%d\", TARGET_64BIT ? \"%fs\" : \"%gs\", offset);\n+      }\n+      break;\n+\n     default:\n       return false;\n     }\n@@ -20359,7 +20739,7 @@ construct_plt_address (rtx symbol)\n   return tmp;\n }\n \n-void\n+rtx\n ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \t\t  rtx callarg2,\n \t\t  rtx pop, int sibcall)\n@@ -20450,6 +20830,8 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   call = emit_call_insn (call);\n   if (use)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n+\n+  return call;\n }\n \n \f\n@@ -32856,6 +33238,9 @@ ix86_units_per_simd_word (enum machine_mode mode)\n #undef TARGET_STACK_PROTECT_FAIL\n #define TARGET_STACK_PROTECT_FAIL ix86_stack_protect_fail\n \n+#undef TARGET_SUPPORTS_SPLIT_STACK\n+#define TARGET_SUPPORTS_SPLIT_STACK ix86_supports_split_stack\n+\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE ix86_function_value\n \n@@ -32914,6 +33299,9 @@ ix86_units_per_simd_word (enum machine_mode mode)\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE ix86_can_eliminate\n \n+#undef TARGET_EXTRA_LIVE_ON_ENTRY\n+#define TARGET_EXTRA_LIVE_ON_ENTRY ix86_live_on_entry\n+\n #undef TARGET_ASM_CODE_END\n #define TARGET_ASM_CODE_END ix86_code_end\n "}, {"sha": "e1c13ac3af4057fb0ca463b26e0e8f60e7019245", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -2277,6 +2277,13 @@ struct GTY(()) machine_function {\n      has been computed for.  */\n   int use_fast_prologue_epilogue_nregs;\n \n+  /* For -fsplit-stack support: A stack local which holds a pointer to\n+     the stack arguments for a function with a variable number of\n+     arguments.  This is set at the start of the function and is used\n+     to initialize the overflow_arg_area field of the va_list\n+     structure.  */\n+  rtx split_stack_varargs_pointer;\n+\n   /* This value is used for amd64 targets and specifies the current abi\n      to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */\n   ENUM_BITFIELD(calling_abi) call_abi : 8;"}, {"sha": "51e375470e1433e0c4fe039e26c862163f2c148c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -85,6 +85,7 @@\n   UNSPEC_SET_RIP\n   UNSPEC_SET_GOT_OFFSET\n   UNSPEC_MEMORY_BLOCKAGE\n+  UNSPEC_STACK_CHECK\n \n   ;; TLS support\n   UNSPEC_TP\n@@ -11612,6 +11613,64 @@\n   \"leave\"\n   [(set_attr \"type\" \"leave\")])\n \f\n+;; Handle -fsplit-stack.\n+\n+(define_expand \"split_stack_prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  ix86_expand_split_stack_prologue ();\n+  DONE;\n+})\n+\n+;; In order to support the call/return predictor, we use a return\n+;; instruction which the middle-end doesn't see.\n+(define_insn \"split_stack_return\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"\")]\n+\t\t    UNSPEC_STACK_CHECK)]\n+  \"\"\n+{\n+  if (operands[0] == const0_rtx)\n+    return \"ret\";\n+  else\n+    return \"ret\\t%0\";\n+}\n+  [(set_attr \"atom_unit\" \"jeu\")\n+   (set_attr \"modrm\" \"0\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_operand:SI 0 \"const0_operand\" \"\")\n+\t\t      (const_int 1)\n+\t\t      (const_int 3)))\n+   (set (attr \"length_immediate\")\n+\t(if_then_else (match_operand:SI 0 \"const0_operand\" \"\")\n+\t\t      (const_int 0)\n+\t\t      (const_int 2)))])\n+\n+;; If there are operand 0 bytes available on the stack, jump to\n+;; operand 1.\n+\n+(define_expand \"split_stack_space_check\"\n+  [(set (pc) (if_then_else\n+\t      (ltu (minus (reg SP_REG)\n+\t\t\t  (match_operand 0 \"register_operand\" \"\"))\n+\t\t   (unspec [(const_int 0)] UNSPEC_STACK_CHECK))\n+\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+{\n+  rtx reg, size, limit;\n+\n+  reg = gen_reg_rtx (Pmode);\n+  size = force_reg (Pmode, operands[0]);\n+  emit_insn (gen_sub3_insn (reg, stack_pointer_rtx, size));\n+  limit = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t  UNSPEC_STACK_CHECK);\n+  limit = gen_rtx_MEM (Pmode, gen_rtx_CONST (Pmode, limit));\n+  ix86_expand_branch (GEU, reg, limit, operands[1]);\n+\n+  DONE;\n+})\n+\f\n ;; Bit manipulation instructions.\n \n (define_expand \"ffs<mode>2\""}, {"sha": "7564c70b6d20d193e06df0e10074aa71dfef6a63", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -218,4 +218,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifdef TARGET_LIBC_PROVIDES_SSP\n /* i386 glibc provides __stack_chk_guard in %gs:0x14.  */\n #define TARGET_THREAD_SSP_OFFSET\t0x14\n+\n+/* We steal the last transactional memory word.  */\n+#define TARGET_CAN_SPLIT_STACK\n+#define TARGET_THREAD_SPLIT_STACK_OFFSET 0x30\n #endif"}, {"sha": "4a3e366fb4e58fb449cf5bc04547ca4318bcd66a", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -123,4 +123,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* i386 glibc provides __stack_chk_guard in %gs:0x14,\n    x86_64 glibc provides it in %fs:0x28.  */\n #define TARGET_THREAD_SSP_OFFSET\t(TARGET_64BIT ? 0x28 : 0x14)\n+\n+/* We steal the last transactional memory word.  */\n+#define TARGET_CAN_SPLIT_STACK\n+#define TARGET_THREAD_SPLIT_STACK_OFFSET (TARGET_64BIT ? 0x70 : 0x30)\n #endif"}, {"sha": "877dec2395993c47d5f3b5b6b720f30249bd96b0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1926,7 +1926,8 @@ attributes are currently defined for functions on all targets:\n @code{returns_twice}, @code{noinline}, @code{noclone},\n @code{always_inline}, @code{flatten}, @code{pure}, @code{const},\n @code{nothrow}, @code{sentinel}, @code{format}, @code{format_arg},\n-@code{no_instrument_function}, @code{section}, @code{constructor},\n+@code{no_instrument_function}, @code{no_split_stack},\n+@code{section}, @code{constructor},\n @code{destructor}, @code{used}, @code{unused}, @code{deprecated},\n @code{weak}, @code{malloc}, @code{alias}, @code{ifunc},\n @code{warn_unused_result}, @code{nonnull}, @code{gnu_inline},\n@@ -2856,6 +2857,14 @@ If @option{-finstrument-functions} is given, profiling function calls will\n be generated at entry and exit of most user-compiled functions.\n Functions with this attribute will not be so instrumented.\n \n+@item no_split_stack\n+@cindex @code{no_split_stack} function attribute\n+@opindex fsplit-stack\n+If @option{-fsplit-stack} is given, functions will have a small\n+prologue which decides whether to split the stack.  Functions with the\n+@code{no_split_stack} attribute will not have that prologue, and thus\n+may run with only a small amount of stack space available.\n+\n @item noinline\n @cindex @code{noinline} function attribute\n This function attribute prevents a function from being considered for"}, {"sha": "bb17a0e2cacc48a09d20ffb4fc1a017dd1aa7763", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -927,7 +927,7 @@ See S/390 and zSeries Options.\n -fshort-double  -fshort-wchar @gol\n -fverbose-asm  -fpack-struct[=@var{n}]  -fstack-check @gol\n -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol\n--fno-stack-limit @gol\n+-fno-stack-limit -fsplit-stack @gol\n -fleading-underscore  -ftls-model=@var{model} @gol\n -ftrapv  -fwrapv  -fbounds-check @gol\n -fvisibility}\n@@ -17857,6 +17857,25 @@ and grows downwards, you can use the flags\n @option{-Wl,--defsym,__stack_limit=0x7ffe0000} to enforce a stack limit\n of 128KB@.  Note that this may only work with the GNU linker.\n \n+@item -fsplit-stack\n+@opindex fsplit-stack\n+Generate code to automatically split the stack before it overflows.\n+The resulting program has a discontiguous stack which can only\n+overflow if the program is unable to allocate any more memory.  This\n+is most useful when running threaded programs, as it is no longer\n+necessary to calculate a good stack size to use for each thread.  This\n+is currently only implemented for the i386 and x86_64 backends running\n+GNU/Linux.\n+\n+When code compiled with @option{-fsplit-stack} calls code compiled\n+without @option{-fsplit-stack}, there may not be much stack space\n+available for the latter code to run.  If compiling all code,\n+including library code, with @option{-fsplit-stack} is not an option,\n+then the linker can fix up these calls so that the code compiled\n+without @option{-fsplit-stack} always has a large stack.  Support for\n+this is implemented in the gold linker in GNU binutils release 2.21\n+and later.\n+\n @item -fleading-underscore\n @opindex fleading-underscore\n This option and its counterpart, @option{-fno-leading-underscore}, forcibly"}, {"sha": "5be6c306729acda4127d355868420a49b1b88821", "filename": "gcc/doc/libgcc.texi", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Flibgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Flibgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flibgcc.texi?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -2262,3 +2262,43 @@ document me!\n @deftypefn {Runtime Function} void __clear_cache (char *@var{beg}, char *@var{end})\n This function clears the instruction cache between @var{beg} and @var{end}.\n @end deftypefn\n+\n+@subsection Split stack functions and variables\n+@deftypefn {Runtime Function} {void *} __splitstack_find (void *@var{segment_arg}, @\n+void *@var{sp}, size_t @var{len}, void **@var{next_segment}, @\n+void **@var{next_sp}, void **@var{initial_sp})\n+When using @option{-fsplit-stack}, this call may be used to iterate\n+over the stack segments.  It may be called like this:\n+@smallexample\n+  void *next_segment = NULL;\n+  void *next_sp = NULL;\n+  void *initial_sp = NULL;\n+  void *stack;\n+  size_t stack_size;\n+  while ((stack = __splitstack_find (next_segment, next_sp,\n+                                     &stack_size, &next_segment,\n+                                     &next_sp, &initial_sp))\n+         != NULL)\n+    @{\n+      /* Stack segment starts at stack and is\n+         stack_size bytes long.  */\n+    @}\n+@end smallexample\n+\n+There is no way to iterate over the stack segments of a different\n+thread.  However, what is permitted is for one thread to call this\n+with the @var{segment_arg} and @var{sp} arguments NULL, to pass\n+@var{next_segment}, @var{next_sp}, and @var{initial_sp} to a different\n+thread, and then to suspend one way or another.  A different thread\n+may run the subsequent @code{__splitstack_find} iterations.  Of\n+course, this will only work if the first thread is suspended while the\n+second thread is calling @code{__splitstack_find}.  If not, the second\n+thread could be looking at the stack while it is changing, and\n+anything could happen.\n+@end deftypefn\n+\n+@defvar __morestack_segments\n+@defvarx __morestack_current_segment\n+@defvarx __morestack_initial_sp\n+Internal variables used by the @option{-fsplit-stack} implementation.\n+@end defvar"}, {"sha": "3737314d0c566c83120e2f6d4e6c0ffb4e35e88f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -4960,6 +4960,10 @@ The default version of this hook invokes a function called\n normally defined in @file{libgcc2.c}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SUPPORTS_SPLIT_STACK (bool)\n+Whether this target supports splitting the stack.  This is called after options have been parsed, so the target may reject splitting the stack in some configurations.  The default version of this hook returns false.  If @var{report} is true, this function may issue a warning or error; if @var{report} is false, it must simply return a value\n+@end deftypefn\n+\n @node Varargs\n @section Implementing the Varargs Macros\n @cindex varargs implementation"}, {"sha": "ea3087fb29cac541afbe17b3a456286f36d9c491", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -4960,6 +4960,8 @@ The default version of this hook invokes a function called\n normally defined in @file{libgcc2.c}.\n @end deftypefn\n \n+@hook TARGET_SUPPORTS_SPLIT_STACK\n+\n @node Varargs\n @section Implementing the Varargs Macros\n @cindex varargs implementation"}, {"sha": "21af58a7c815087b74e148de6cb3618f1a591e12", "filename": "gcc/explow.c", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for manipulating rtx's in semantically interesting ways.\n    Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1146,6 +1146,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n {\n   HOST_WIDE_INT stack_usage_size = -1;\n   bool known_align_valid = true;\n+  rtx final_label, final_target;\n \n   /* If we're asking for zero bytes, it doesn't matter what we point\n      to since we can't dereference it.  But return a reasonable\n@@ -1284,6 +1285,14 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n \t}\n     }\n \n+  /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */\n+  if (target == 0 || !REG_P (target)\n+      || REGNO (target) < FIRST_PSEUDO_REGISTER\n+      || GET_MODE (target) != Pmode)\n+    target = gen_reg_rtx (Pmode);\n+\n+  mark_reg_pointer (target, known_align);\n+\n   /* The size is supposed to be fully adjusted at this point so record it\n      if stack usage info is requested.  */\n   if (flag_stack_usage)\n@@ -1296,6 +1305,52 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n \tcurrent_function_has_unbounded_dynamic_stack_size = 1;\n     }\n \n+  final_label = NULL_RTX;\n+  final_target = NULL_RTX;\n+\n+  /* If we are splitting the stack, we need to ask the backend whether\n+     there is enough room on the current stack.  If there isn't, or if\n+     the backend doesn't know how to tell is, then we need to call a\n+     function to allocate memory in some other way.  This memory will\n+     be released when we release the current stack segment.  The\n+     effect is that stack allocation becomes less efficient, but at\n+     least it doesn't cause a stack overflow.  */\n+  if (flag_split_stack)\n+    {\n+      rtx available_label, space, func;\n+\n+      available_label = NULL_RTX;\n+\n+#ifdef HAVE_split_stack_space_check\n+      if (HAVE_split_stack_space_check)\n+\t{\n+\t  available_label = gen_label_rtx ();\n+\n+\t  /* This instruction will branch to AVAILABLE_LABEL if there\n+\t     are SIZE bytes available on the stack.  */\n+\t  emit_insn (gen_split_stack_space_check (size, available_label));\n+\t}\n+#endif\n+\n+      func = init_one_libfunc (\"__morestack_allocate_stack_space\");\n+\n+      space = emit_library_call_value (func, target, LCT_NORMAL, Pmode,\n+\t\t\t\t       1, size, Pmode);\n+\n+      if (available_label == NULL_RTX)\n+\treturn space;\n+\n+      final_target = gen_reg_rtx (Pmode);\n+      mark_reg_pointer (final_target, known_align);\n+\n+      emit_move_insn (final_target, space);\n+\n+      final_label = gen_label_rtx ();\n+      emit_jump (final_label);\n+\n+      emit_label (available_label);\n+    }\n+\n   do_pending_stack_adjust ();\n \n  /* We ought to be called always on the toplevel and stack ought to be aligned\n@@ -1313,14 +1368,6 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n   else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n     probe_stack_range (STACK_CHECK_PROTECT, size);\n \n-  /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */\n-  if (target == 0 || !REG_P (target)\n-      || REGNO (target) < FIRST_PSEUDO_REGISTER\n-      || GET_MODE (target) != Pmode)\n-    target = gen_reg_rtx (Pmode);\n-\n-  mark_reg_pointer (target, known_align);\n-\n   /* Perform the required allocation from the stack.  Some systems do\n      this differently than simply incrementing/decrementing from the\n      stack pointer, such as acquiring the space by calling malloc().  */\n@@ -1413,6 +1460,15 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n   if (cfun->nonlocal_goto_save_area != 0)\n     update_nonlocal_goto_save_area ();\n \n+  /* Finish up the split stack handling.  */\n+  if (final_label != NULL_RTX)\n+    {\n+      gcc_assert (flag_split_stack);\n+      emit_move_insn (final_target, target);\n+      emit_label (final_label);\n+      target = final_target;\n+    }\n+\n   return target;\n }\n \f"}, {"sha": "04a2ebcb4f112068214af4d2348ca5b0e7870f8d", "filename": "gcc/function.c", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -5214,17 +5214,50 @@ emit_return_into_block (basic_block bb)\n static void\n thread_prologue_and_epilogue_insns (void)\n {\n-  int inserted = 0;\n+  bool inserted;\n+  rtx seq, epilogue_end;\n+  edge entry_edge;\n   edge e;\n-#if defined (HAVE_sibcall_epilogue) || defined (HAVE_epilogue) || defined (HAVE_return) || defined (HAVE_prologue)\n-  rtx seq;\n-#endif\n-#if defined (HAVE_epilogue) || defined(HAVE_return)\n-  rtx epilogue_end = NULL_RTX;\n-#endif\n   edge_iterator ei;\n \n   rtl_profile_for_bb (ENTRY_BLOCK_PTR);\n+\n+  inserted = false;\n+  seq = NULL_RTX;\n+  epilogue_end = NULL_RTX;\n+\n+  /* Can't deal with multiple successors of the entry block at the\n+     moment.  Function should always have at least one entry\n+     point.  */\n+  gcc_assert (single_succ_p (ENTRY_BLOCK_PTR));\n+  entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n+\n+  if (flag_split_stack\n+      && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n+\t  == NULL))\n+    {\n+#ifndef HAVE_split_stack_prologue\n+      gcc_unreachable ();\n+#else\n+      gcc_assert (HAVE_split_stack_prologue);\n+\n+      start_sequence ();\n+      emit_insn (gen_split_stack_prologue ());\n+      seq = get_insns ();\n+      end_sequence ();\n+\n+      record_insns (seq, NULL, &prologue_insn_hash);\n+      set_insn_locators (seq, prologue_locator);\n+\n+      /* This relies on the fact that committing the edge insertion\n+\t will look for basic blocks within the inserted instructions,\n+\t which in turn relies on the fact that we are not in CFG\n+\t layout mode here.  */\n+      insert_insn_on_edge (seq, entry_edge);\n+      inserted = true;\n+#endif\n+    }\n+\n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n     {\n@@ -5251,13 +5284,8 @@ thread_prologue_and_epilogue_insns (void)\n       end_sequence ();\n       set_insn_locators (seq, prologue_locator);\n \n-      /* Can't deal with multiple successors of the entry block\n-         at the moment.  Function should always have at least one\n-         entry point.  */\n-      gcc_assert (single_succ_p (ENTRY_BLOCK_PTR));\n-\n-      insert_insn_on_edge (seq, single_succ_edge (ENTRY_BLOCK_PTR));\n-      inserted = 1;\n+      insert_insn_on_edge (seq, entry_edge);\n+      inserted = true;\n     }\n #endif\n \n@@ -5427,7 +5455,7 @@ thread_prologue_and_epilogue_insns (void)\n       end_sequence ();\n \n       insert_insn_on_edge (seq, e);\n-      inserted = 1;\n+      inserted = true;\n     }\n   else\n #endif"}, {"sha": "cd201f53b95abef3c3a6bf330f619937a3ab4168", "filename": "gcc/gcc.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -545,6 +545,16 @@ proper position among the other output files.  */\n #define MFLIB_SPEC \"%{fmudflap|fmudflapth: -export-dynamic}\"\n #endif\n \n+/* When using -fsplit-stack we need to wrap pthread_create, in order\n+   to initialize the stack guard.  We always use wrapping, rather than\n+   shared library ordering, and we keep the wrapper function in\n+   libgcc.  This is not yet a real spec, though it could become one;\n+   it is currently just stuffed into LINK_SPEC.  FIXME: This wrapping\n+   only works with GNU ld and gold.  FIXME: This is incompatible with\n+   -fmudflap when linking statically, which wants to do its own\n+   wrapping.  */\n+#define STACK_SPLIT_SPEC \" %{fsplit-stack: --wrap=pthread_create}\"\n+\n /* config.h can define LIBGCC_SPEC to override how and when libgcc.a is\n    included.  */\n #ifndef LIBGCC_SPEC\n@@ -657,7 +667,8 @@ proper position among the other output files.  */\n    \"%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\\\n     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\\\n-    %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)} %(mflib)\\\n+    %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\\\n+    %(mflib) \" STACK_SPLIT_SPEC \"\\\n     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\\\n     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\\\n     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}\""}, {"sha": "c1326351025a5144a8e71df811c241eae221d6de", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1914,4 +1914,8 @@ GCC_4.5.0 {\n \n %inherit GCC_4.6.0 GCC_4.5.0\n GCC_4.6.0 {\n+  __morestack_segments\n+  __morestack_current_segment\n+  __morestack_initial_sp\n+  __splitstack_find\n }"}, {"sha": "40e6acde26238360e893bb8c6be693e965de60b7", "filename": "gcc/opts.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1086,6 +1086,20 @@ decode_options (unsigned int argc, const char **argv,\n      check option consistency.  */\n   if (flag_lto && flag_whopr)\n     error (\"-flto and -fwhopr are mutually exclusive\");\n+\n+  /* We initialize flag_split_stack to -1 so that targets can set a\n+     default value if they choose based on other options.  */\n+  if (flag_split_stack == -1)\n+    flag_split_stack = 0;\n+  else\n+    {\n+      if (!targetm.supports_split_stack (true))\n+\t{\n+\t  error (\"%<-fsplit-stack%> is not supported by \"\n+\t\t \"this compiler configuration\");\n+\t  flag_split_stack = 0;\n+\t}\n+    }\n }\n \n #define LEFT_COLUMN\t27"}, {"sha": "2a70fd25bdd4b34ae5efa5b0f625c6ee9dc6ce37", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -632,6 +632,7 @@ extern void default_asm_declare_constant_name (FILE *, const char *,\n \t\t\t\t\t       const_tree, HOST_WIDE_INT);\n extern void default_file_start (void);\n extern void file_end_indicate_exec_stack (void);\n+extern void file_end_indicate_split_stack (void);\n \n extern void default_elf_asm_output_external (FILE *file, tree,\n \t\t\t\t\t     const char *);"}, {"sha": "a60e75f3e3a2682bf628f6724a4c5aa3c81f337c", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1679,6 +1679,16 @@ DEFHOOK\n  tree, (void),\n  default_external_stack_protect_fail)\n \n+DEFHOOK\n+(supports_split_stack,\n+ \"Whether this target supports splitting the stack.  This is called\\\n+ after options have been parsed, so the target may reject splitting\\\n+ the stack in some configurations.  The default version of this hook\\\n+ returns false.  If @var{report} is true, this function may issue a warning\\\n+ or error; if @var{report} is false, it must simply return a value\",\n+ bool, (bool),\n+ hook_bool_bool_false)\n+\n /* Returns NULL if target supports the insn within a doloop block,\n    otherwise it returns an error message.  */\n DEFHOOK"}, {"sha": "4f795dddb99e90c881002710c17f6c1a81738c6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1,3 +1,12 @@\n+2010-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_split_stack):\n+\tNew procedure.\n+\t* gcc.dg/split-1.c: New test.\n+\t* gcc.dg/split-2.c: New test.\n+\t* gcc.dg/split-3.c: New test.\n+\t* gcc.dg/split-4.c: New test.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc/25464"}, {"sha": "044b4e2889bc7c2bdd878e01757d99ff1370813d", "filename": "gcc/testsuite/gcc.dg/split-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-1.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,49 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target *-*-linux* *-*-solaris* *-*-darwin* } } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack\" } */\n+\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* Each recursive call uses 10,000 bytes.  We call it 1000 times,\n+   using a total of 10,000,000 bytes.  If -fsplit-stack is not\n+   working, that will overflow our stack limit.  */\n+\n+static void\n+down (int i)\n+{\n+  char buf[10000];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down (1000);\n+  return 0;\n+}"}, {"sha": "208169aa09501a6269bd49523827f6e549ab3de5", "filename": "gcc/testsuite/gcc.dg/split-2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-2.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-require-effective-target pthread_h } */\n+/* { dg-options \"-pthread -fsplit-stack\" } */\n+\n+#include <stdlib.h>\n+#include <pthread.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* Each recursive call uses 10,000 bytes.  We call it 1000 times,\n+   using a total of 10,000,000 bytes.  If -fsplit-stack is not\n+   working, that will overflow our stack limit.  */\n+\n+static void\n+down (int i)\n+{\n+  char buf[10000];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1);\n+    }\n+}\n+\n+static void *\n+thread_routine (void *arg __attribute__ ((unused)))\n+{\n+  down (1000);\n+  return NULL;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  pthread_t tid;\n+  void *dummy;\n+\n+  i = pthread_create (&tid, NULL, thread_routine, NULL);\n+  if (i != 0)\n+    abort ();\n+  i = pthread_join (tid, &dummy);\n+  if (i != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "360f6720c78c4954b6a69110b260e88785a61e05", "filename": "gcc/testsuite/gcc.dg/split-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-3.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,64 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target *-*-linux* *-*-solaris* *-*-darwin* } } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack\" } */\n+\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+/* Each recursive call uses 10,000 bytes.  We call it 1000 times,\n+   using a total of 10,000,000 bytes.  If -fsplit-stack is not\n+   working, that will overflow our stack limit.  */\n+\n+static void\n+down (int i, ...)\n+{\n+  char buf[10000];\n+  va_list ap;\n+\n+  va_start (ap, i);\n+  if (va_arg (ap, int) != 1\n+      || va_arg (ap, int) != 2\n+      || va_arg (ap, int) != 3\n+      || va_arg (ap, int) != 4\n+      || va_arg (ap, int) != 5\n+      || va_arg (ap, int) != 6\n+      || va_arg (ap, int) != 7\n+      || va_arg (ap, int) != 8\n+      || va_arg (ap, int) != 9\n+      || va_arg (ap, int) != 10)\n+    abort ();\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      down (i - 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down (1000, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+  return 0;\n+}"}, {"sha": "38196bed6c7768c6121e8144a44f4a083cb4366f", "filename": "gcc/testsuite/gcc.dg/split-4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-4.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,68 @@\n+/* This test needs to use setrlimit to set the stack size, so it can\n+   only run on Unix.  */\n+/* { dg-do run { target *-*-linux* *-*-solaris* *-*-darwin* } } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-options \"-fsplit-stack\" } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf, size_t) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf, size_t c)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < c; ++i)\n+    buf[i] = (char) i;\n+}\n+\n+/* Each recursive call uses 10 * i bytes.  We call it 1000 times,\n+   using a total of 5,000,000 bytes.  If -fsplit-stack is not working,\n+   that will overflow our stack limit.  */\n+\n+static void\n+down1 (int i)\n+{\n+  char buf[10 * i];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf, 10 * i);\n+      down1 (i - 1);\n+    }\n+}\n+\n+/* Same thing, using alloca.  */\n+\n+static void\n+down2 (int i)\n+{\n+  char *buf = alloca (10 * i);\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf, 10 * i);\n+      down2 (i - 1);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct rlimit r;\n+\n+  /* We set a stack limit because we are usually invoked via make, and\n+     make sets the stack limit to be as large as possible.  */\n+  r.rlim_cur = 8192 * 1024;\n+  r.rlim_max = 8192 * 1024;\n+  if (setrlimit (RLIMIT_STACK, &r) != 0)\n+    abort ();\n+  down1 (1000);\n+  down2 (1000);\n+  return 0;\n+}"}, {"sha": "e2174b71dee7f89f1181d10d80029347e7fa8a64", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -3664,6 +3664,15 @@ proc check_effective_target_lto { } {\n     return [info exists ENABLE_LTO]\n }\n \n+# Return 1 if this target supports the -fsplit-stack option, 0\n+# otherwise.\n+\n+proc check_effective_target_split_stack {} {\n+    return [check_no_compiler_messages split_stack object {\n+\tvoid foo (void) { }\n+    } \"-fsplit-stack\"]\n+}\n+\n # Return 1 if the language for the compiler under test is C.\n \n proc check_effective_target_c { } {"}, {"sha": "bc314940347e69a3dfc07a3aed1b472160f58397", "filename": "gcc/varasm.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -99,6 +99,10 @@ bool first_function_block_is_cold;\n \n static alias_set_type const_alias_set;\n \n+/* Whether we saw any functions with no_split_stack.  */\n+\n+static bool saw_no_split_stack;\n+\n static const char *strip_reg_name (const char *);\n static int contains_pointers_p (tree);\n #ifdef ASM_OUTPUT_EXTERNAL\n@@ -1549,6 +1553,9 @@ assemble_start_function (tree decl, const char *fnname)\n   /* Standard thing is just output label for the function.  */\n   ASM_OUTPUT_FUNCTION_LABEL (asm_out_file, fnname, current_function_decl);\n #endif /* ASM_DECLARE_FUNCTION_NAME */\n+\n+  if (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (decl)))\n+    saw_no_split_stack = true;\n }\n \n /* Output assembler code associated with defining the size of the\n@@ -6649,6 +6656,28 @@ file_end_indicate_exec_stack (void)\n   switch_to_section (get_section (\".note.GNU-stack\", flags, NULL));\n }\n \n+/* Emit a special section directive to indicate that this object file\n+   was compiled with -fsplit-stack.  This is used to let the linker\n+   detect calls between split-stack code and non-split-stack code, so\n+   that it can modify the split-stack code to allocate a sufficiently\n+   large stack.  We emit another special section if there are any\n+   functions in this file which have the no_split_stack attribute, to\n+   prevent the linker from warning about being unable to convert the\n+   functions if they call non-split-stack code.  */\n+\n+void\n+file_end_indicate_split_stack (void)\n+{\n+  if (flag_split_stack)\n+    {\n+      switch_to_section (get_section (\".note.GNU-split-stack\", SECTION_DEBUG,\n+\t\t\t\t      NULL));\n+      if (saw_no_split_stack)\n+\tswitch_to_section (get_section (\".note.GNU-no-split-stack\",\n+\t\t\t\t\tSECTION_DEBUG, NULL));\n+    }\n+}\n+\n /* Output DIRECTIVE (a C string) followed by a newline.  This is used as\n    a get_unnamed_section callback.  */\n "}, {"sha": "1bbebd96fa6b3b9155059eba6c138b6d083787de", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -1,3 +1,14 @@\n+2010-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* generic-morestack.h: New file.\n+\t* generic-morestack.c: New file.\n+\t* generic-morestack-thread.c: New file.\n+\t* config/i386/morestack.S: New file.\n+\t* config/t-stack: New file.\n+\t* config/i386/t-stack-i386: New file.\n+\t* config.host (i[34567]86-*-linux* and friends): Add t-stack and\n+\ti386/t-stack-i386 to tmake_file.\n+\n 2010-09-21  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* Makefile.in (libgcc-extra-parts):  Check for static archives and"}, {"sha": "8476218216ca21f82c85e9e91bd83218e6148e46", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -602,7 +602,7 @@ case ${host} in\n i[34567]86-*-linux* | x86_64-*-linux* | \\\n   i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | \\\n   i[34567]86-*-gnu*)\n-\ttmake_file=\"${tmake_file} t-tls\"\n+\ttmake_file=\"${tmake_file} t-tls t-stack i386/t-stack-i386\"\n \t;;\n esac\n "}, {"sha": "79abba3ead192a26a86b510b8c9b9aec3797b4f0", "filename": "libgcc/config/i386/morestack.S", "status": "added", "additions": 559, "deletions": 0, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fmorestack.S?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,559 @@\n+# x86/x86_64 support for -fsplit-stack.\n+# Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+# Contributed by Ian Lance Taylor <iant@google.com>.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# Support for allocating more stack space when using -fsplit-stack.\n+# When a function discovers that it needs more stack space, it will\n+# call __morestack with the size of the stack frame and the size of\n+# the parameters to copy from the old stack frame to the new one.\n+# The __morestack function preserves the parameter registers and\n+# calls __generic_morestack to actually allocate the stack space.\n+\n+# When this is called stack space is very low, but we ensure that\n+# there is enough space to push the parameter registers and to call\n+# __generic_morestack.\n+\n+# When calling __generic_morestack, FRAME_SIZE points to the size of\n+# the desired frame when the function is called, and the function\n+# sets it to the size of the allocated stack.  OLD_STACK points to\n+# the parameters on the old stack and PARAM_SIZE is the number of\n+# bytes of parameters to copy to the new stack.  These are the\n+# parameters of the function that called __morestack.  The\n+# __generic_morestack function returns the new stack pointer,\n+# pointing to the address of the first copied parameter.  The return\n+# value minus the returned *FRAME_SIZE will be the first address on\n+# the stack which we should not use.\n+\n+# void *__generic_morestack (size_t *frame_size, void *old_stack,\n+#\t\t\t     size_t param_size);\n+\n+# The __morestack routine has to arrange for the caller to return to a\n+# stub on the new stack.  The stub is responsible for restoring the\n+# old stack pointer and returning to the caller's caller.  This calls\n+# __generic_releasestack to retrieve the old stack pointer and release\n+# the newly allocated stack.\n+\n+# void *__generic_releasestack (size_t *available);\n+\n+# We do a little dance so that the processor's call/return return\n+# address prediction works out.  The compiler arranges for the caller\n+# to look like this:\n+#   call __generic_morestack\n+#   ret\n+#  L:\n+#   // carry on with function\n+# After we allocate more stack, we call L, which is in our caller.\n+# When that returns (to the predicted instruction), we release the\n+# stack segment and reset the stack pointer.  We then return to the\n+# predicted instruction, namely the ret instruction immediately after\n+# the call to __generic_morestack.  That then returns to the caller of\n+# the original caller.\n+\n+\n+# The amount of extra space we ask for.  In general this has to be\n+# enough for the dynamic loader to find a symbol and for a signal\n+# handler to run.\n+\t\n+#ifndef __x86_64__\n+#define BACKOFF (1024)\n+#else\n+#define BACKOFF (1536)\n+#endif\n+\n+\n+# This entry point is for split-stack code which calls non-split-stack\n+# code.  When the linker sees this case, it converts the call to\n+# __morestack to call __morestack_non_split instead.  We just bump the\n+# requested stack space by 16K.\n+\n+\t.global __morestack_non_split\n+\t.hidden\t__morestack_non_split\n+\n+#ifdef __ELF__\n+       .type\t__morestack_non_split,@function\n+#endif\n+\n+__morestack_non_split:\n+\n+#ifndef __x86_64__\n+\taddl\t$0x4000,4(%esp)\n+#else\n+\taddq\t$0x4000,%r10\n+#endif\n+\n+#ifdef __ELF__\n+\t.size\t__morestack_non_split, . - __morestack_non_split\n+#endif\n+\n+# __morestack_non_split falls through into __morestack.\n+\n+\n+# The __morestack function.\n+\n+\t.global\t__morestack\n+\t.hidden\t__morestack\n+\n+#ifdef __ELF__\n+\t.type\t__morestack,@function\n+#endif\n+\n+__morestack:\n+.LFB1:\n+\t.cfi_startproc\n+\n+\n+#ifndef __x86_64__\n+\n+\n+# The 32-bit __morestack function.\n+\n+\t# We use a cleanup to restore the stack guard if an exception\n+\t# is thrown through this code.\n+#ifndef __PIC__\n+\t.cfi_personality 0,__gcc_personality_v0\n+\t.cfi_lsda 0,.LLSDA1\n+#else\n+\t.cfi_personality 0x9b,DW.ref.__gcc_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA1\n+#endif\n+\n+\t# Set up a normal backtrace.\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset %ebp, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register %ebp\n+\n+\t# We return below with a ret $8.  We will return to a single\n+\t# return instruction, which will return to the caller of our\n+\t# caller.  We let the unwinder skip that single return\n+\t# instruction, and just return to the real caller.\n+\t.cfi_offset 8, 8\n+\t.cfi_escape 0x15, 4, 0x7d\t# DW_CFA_val_offset_sf, %esp, 12/-4\n+\n+\t# In 32-bit mode the parameters are pushed on the stack.  The\n+\t# argument size is pushed then the new stack frame size is\n+\t# pushed.\n+\n+\t# In 32-bit mode the registers %eax, %edx, and %ecx may be\n+\t# used for parameters, depending on the regparm and fastcall\n+\t# attributes.\n+\n+\tpushl\t%eax\n+\tpushl\t%edx\n+\tpushl\t%ecx\n+\n+\tcall\t__morestack_block_signals\n+\n+\tpushl\t12(%ebp)\t\t# The size of the parameters.\n+\tleal\t20(%ebp),%eax\t\t# Address of caller's parameters.\n+\tpushl\t%eax\n+\taddl\t$BACKOFF,8(%ebp)\t# Ask for backoff bytes.\n+\tleal\t8(%ebp),%eax\t\t# The address of the new frame size.\n+\tpushl\t%eax\n+\n+\t# Note that %esp is exactly 32 bytes below the CFA -- perfect for\n+\t# a 16-byte aligned stack.  That said, we still ought to compile\n+\t# generic-morestack.c with -mpreferred-stack-boundary=2.  FIXME.\n+\tcall\t__generic_morestack\n+\n+\tmovl\t%eax,%esp\t\t# Switch to the new stack.\n+\tsubl\t8(%ebp),%eax\t\t# The end of the stack space.\n+\taddl\t$BACKOFF,%eax\t\t# Back off 512 bytes.\n+\n+.LEHB0:\n+\t# FIXME: The offset must match\n+\t# TARGET_THREAD_SPLIT_STACK_OFFSET in\n+\t# gcc/config/i386/linux.h.\n+\tmovl\t%eax,%gs:0x30\t\t# Save the new stack boundary.\n+\n+\tcall\t__morestack_unblock_signals\n+\n+\tmovl\t-8(%ebp),%edx\t\t# Restore registers.\n+\tmovl\t-12(%ebp),%ecx\n+\n+\tmovl\t4(%ebp),%eax\t\t# Increment the return address\n+\tcmpb\t$0xc3,(%eax)\t\t# to skip the ret instruction;\n+\tje\t1f\t\t\t# see above.\n+\taddl\t$2,%eax\n+1:\tinc\t%eax\n+\n+\tmovl\t%eax,-8(%ebp)\t\t# Store return address in an\n+\t\t\t\t\t# unused slot.\n+\n+\tmovl\t-4(%ebp),%eax\t\t# Restore the last register.\n+\n+\tcall\t*-8(%ebp)\t\t# Call our caller!\n+\n+\t# The caller will return here, as predicted.\n+\n+\t# Save the registers which may hold a return value.  We\n+\t# assume that __generic_releasestack does not touch any\n+\t# floating point or vector registers.\n+\tpushl\t%eax\n+\tpushl\t%edx\n+\n+\t# Push the arguments to __generic_releasestack now so that the\n+\t# stack is at a 16-byte boundary for\n+\t# __morestack_block_signals.\n+\tpushl\t$0\t\t\t# Where the available space is returned.\n+\tleal\t0(%esp),%eax\t\t# Push its address.\n+\tpush\t%eax\n+\n+\tcall\t__morestack_block_signals\n+\n+\tcall\t__generic_releasestack\n+\n+\tsubl\t4(%esp),%eax\t\t# Subtract available space.\n+\taddl\t$BACKOFF,%eax\t\t# Back off 512 bytes.\n+.LEHE0:\n+\tmovl\t%eax,%gs:0x30\t\t# Save the new stack boundary.\n+\n+\taddl\t$8,%esp\t\t\t# Remove values from stack.\n+\n+\t# We need to restore the old stack pointer, which is in %rbp,\n+\t# before we unblock signals.  We also need to restore %eax and\n+\t# %edx after we unblock signals but before we return.  Do this\n+\t# by moving %eax and %edx from the current stack to the old\n+\t# stack.\n+\n+\tpopl\t%edx\t\t\t# Pop return value from current stack.\n+\tpopl\t%eax\n+\n+\tmovl\t%ebp,%esp\t\t# Restore stack pointer.\n+\n+\tpushl\t%eax\t\t\t# Push return value on old stack.\n+\tpushl\t%edx\n+\tsubl\t$8,%esp\t\t\t# Align stack to 16-byte boundary.\n+\n+\tcall\t__morestack_unblock_signals\n+\n+\taddl\t$8,%esp\n+\tpopl\t%edx\t\t\t# Restore return value.\n+\tpopl\t%eax\n+\n+\t.cfi_remember_state\n+\tpopl\t%ebp\n+\t.cfi_restore %ebp\n+\t.cfi_def_cfa %esp, 12\n+\tret\t$8\t\t\t# Return to caller, which will\n+\t\t\t\t\t# immediately return.  Pop\n+\t\t\t\t\t# arguments as we go.\n+\n+# This is the cleanup code called by the stack unwinder when unwinding\n+# through the code between .LEHB0 and .LEHE0 above.\n+\t\n+.L1:\n+\t.cfi_restore_state\n+\tsubl\t$16,%esp\t\t# Maintain 16 byte alignment.\n+\tmovl\t%eax,4(%esp)\t\t# Save exception header.\n+\tmovl\t%ebp,(%esp)\t\t# Stack pointer after resume.\n+\tcall\t__generic_findstack\n+\tmovl\t%ebp,%ecx\t\t# Get the stack pointer.\n+\tsubl\t%eax,%ecx\t\t# Subtract available space.\n+\taddl\t$BACKOFF,%ecx\t\t# Back off 512 bytes.\n+\tmovl\t%ecx,%gs:0x30\t\t# Save new stack boundary.\n+\tmovl\t4(%esp),%eax\t\t# Function argument.\n+\tmovl\t%eax,(%esp)\n+#ifdef __PIC__\n+#undef __i686\n+\tcall\t__i686.get_pc_thunk.bx\t# %ebx may not be set up for us.\n+\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n+\tcall\t_Unwind_Resume@PLT\t# Resume unwinding.\n+#else\n+\tcall\t_Unwind_Resume\n+#endif\n+\n+#else /* defined(__x86_64__) */\n+\n+\n+# The 64-bit __morestack function.\n+\n+\t# We use a cleanup to restore the stack guard if an exception\n+\t# is thrown through this code.\n+#ifndef __PIC__\n+\t.cfi_personality 0x3,__gcc_personality_v0\n+\t.cfi_lsda 0x3,.LLSDA1\n+#else\n+\t.cfi_personality 0x9b,DW.ref.__gcc_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA1\n+#endif\n+\n+\t# Set up a normal backtrace.\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset %rbp, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register %rbp\n+\n+\t# We will return a single return instruction, which will\n+\t# return to the caller of our caller.  Let the unwinder skip\n+\t# that single return instruction, and just return to the real\n+\t# caller.\n+\t.cfi_offset 16, 0\n+\t.cfi_escape 0x15, 7, 0x7f\t# DW_CFA_val_offset_sf, %esp, 8/-8\n+\n+\t# In 64-bit mode the new stack frame size is passed in r10\n+        # and the argument size is passed in r11.\n+\n+\taddq\t$BACKOFF,%r10\t\t# Ask for backoff bytes.\n+\tpushq\t%r10\t\t\t# Save new frame size.\n+\n+\t# In 64-bit mode the registers %rdi, %rsi, %rdx, %rcx, %r8,\n+\t# and %r9 may be used for parameters.  We also preserve %rax\n+\t# which the caller may use to hold %r10.\n+\n+\tpushq\t%rax\n+\tpushq\t%rdi\n+\tpushq\t%rsi\n+\tpushq\t%rdx\n+\tpushq\t%rcx\n+\tpushq\t%r8\n+\tpushq\t%r9\n+\n+\tpushq\t%r11\n+\tpushq\t$0\t\t\t# For alignment.\n+\n+\tcall\t__morestack_block_signals\n+\n+\tleaq\t-8(%rbp),%rdi\t\t# Address of new frame size.\n+\tleaq\t24(%rbp),%rsi\t\t# The caller's parameters.\n+\taddq\t$8,%rsp\n+\tpopq\t%rdx\t\t\t# The size of the parameters.\n+\n+\tcall\t__generic_morestack\n+\n+\tmovq\t-8(%rbp),%r10\t\t# Reload modified frame size\n+\tmovq\t%rax,%rsp\t\t# Switch to the new stack.\n+\tsubq\t%r10,%rax\t\t# The end of the stack space.\n+\taddq\t$BACKOFF,%rax\t\t# Back off 1024 bytes.\n+\n+.LEHB0:\n+\t# FIXME: The offset must match\n+\t# TARGET_THREAD_SPLIT_STACK_OFFSET in\n+\t# gcc/config/i386/linux64.h.\n+\tmovq\t%rax,%fs:0x70\t\t# Save the new stack boundary.\n+\n+\tcall\t__morestack_unblock_signals\n+\n+\tmovq\t-24(%rbp),%rdi\t\t# Restore registers.\n+\tmovq\t-32(%rbp),%rsi\n+\tmovq\t-40(%rbp),%rdx\n+\tmovq\t-48(%rbp),%rcx\n+\tmovq\t-56(%rbp),%r8\n+\tmovq\t-64(%rbp),%r9\n+\n+\tmovq\t8(%rbp),%r10\t\t# Increment the return address\n+\tincq\t%r10\t\t\t# to skip the ret instruction;\n+\t\t\t\t\t# see above.\n+\n+\tmovq\t-16(%rbp),%rax\t\t# Restore caller's %rax.\n+\n+\tcall\t*%r10\t\t\t# Call our caller!\n+\n+\t# The caller will return here, as predicted.\n+\n+\t# Save the registers which may hold a return value.  We\n+\t# assume that __generic_releasestack does not touch any\n+\t# floating point or vector registers.\n+\tpushq\t%rax\n+\tpushq\t%rdx\n+\n+\tcall\t__morestack_block_signals\n+\n+\tpushq\t$0\t\t\t# For alignment.\n+\tpushq\t$0\t\t\t# Where the available space is returned.\n+\tleaq\t0(%rsp),%rdi\t\t# Pass its address.\n+\n+\tcall\t__generic_releasestack\n+\n+\tsubq\t0(%rsp),%rax\t\t# Subtract available space.\n+\taddq\t$BACKOFF,%rax\t\t# Back off 1024 bytes.\n+.LEHE0:\n+\tmovq\t%rax,%fs:0x70\t\t# Save the new stack boundary.\n+\n+\taddq\t$16,%rsp\t\t# Remove values from stack.\n+\n+\t# We need to restore the old stack pointer, which is in %rbp,\n+\t# before we unblock signals.  We also need to restore %rax and\n+\t# %rdx after we unblock signals but before we return.  Do this\n+\t# by moving %rax and %rdx from the current stack to the old\n+\t# stack.\n+\n+\tpopq\t%rdx\t\t\t# Pop return value from current stack.\n+\tpopq\t%rax\n+\n+\tmovq\t%rbp,%rsp\t\t# Restore stack pointer.\n+\n+\tpushq\t%rax\t\t\t# Push return value on old stack.\n+\tpushq\t%rdx\n+\n+\tcall\t__morestack_unblock_signals\n+\n+\tpopq\t%rdx\t\t\t# Restore return value.\n+\tpopq\t%rax\n+\n+\t.cfi_remember_state\n+\tpopq\t%rbp\n+\t.cfi_restore %rbp\n+\t.cfi_def_cfa %rsp, 8\n+\tret\t\t\t\t# Return to caller, which will\n+\t\t\t\t\t# immediately return.\n+\n+# This is the cleanup code called by the stack unwinder when unwinding\n+# through the code between .LEHB0 and .LEHE0 above.\n+\t\n+.L1:\n+\t.cfi_restore_state\n+\tsubq\t$16,%rsp\t\t# Maintain 16 byte alignment.\n+\tmovq\t%rax,(%rsp)\t\t# Save exception header.\n+\tmovq\t%rbp,%rdi\t\t# Stack pointer after resume.\n+\tcall\t__generic_findstack\n+\tmovq\t%rbp,%rcx\t\t# Get the stack pointer.\n+\tsubq\t%rax,%rcx\t\t# Subtract available space.\n+\taddq\t$BACKOFF,%rcx\t\t# Back off 1024 bytes.\n+\tmovq\t%rcx,%fs:0x70\t\t# Save new stack boundary.\n+\tmovq\t(%rsp),%rdi\t\t# Restore exception data for call.\n+#ifdef __PIC__\n+\tcall\t_Unwind_Resume@PLT\t# Resume unwinding.\n+#else\n+\tcall\t_Unwind_Resume\t\t# Resume unwinding.\n+#endif\n+\n+#endif /* defined(__x86_64__) */\n+\n+\t.cfi_endproc\n+#ifdef __ELF__\n+\t.size\t__morestack, . - __morestack\n+#endif\n+\n+\n+# The exception table.  This tells the personality routine to execute\n+# the exception handler.\n+\n+\t.section\t.gcc_except_table,\"a\",@progbits\n+\t.align\t4\n+.LLSDA1:\n+\t.byte\t0xff\t# @LPStart format (omit)\n+\t.byte\t0xff\t# @TType format (omit)\n+\t.byte\t0x1\t# call-site format (uleb128)\n+\t.uleb128 .LLSDACSE1-.LLSDACSB1\t# Call-site table length\n+.LLSDACSB1:\n+\t.uleb128 .LEHB0-.LFB1\t# region 0 start\n+\t.uleb128 .LEHE0-.LEHB0\t# length\n+\t.uleb128 .L1-.LFB1\t# landing pad\n+\t.uleb128 0\t\t# action\n+.LLSDACSE1:\n+\n+\n+\t.global __gcc_personality_v0\n+#ifdef __PIC__\n+\t# Build a position independent reference to the basic\n+        # personality function.\n+\t.hidden DW.ref.__gcc_personality_v0\n+\t.weak   DW.ref.__gcc_personality_v0\n+\t.section .data.DW.ref.__gcc_personality_v0,\"awG\",@progbits,DW.ref.__gcc_personality_v0,comdat\n+\t.type\tDW.ref.__gcc_personality_v0, @object\n+DW.ref.__gcc_personality_v0:\n+#ifndef __x86_64\n+\t.align 4\n+\t.size\tDW.ref.__gcc_personality_v0, 4\n+\t.long\t__gcc_personality_v0\n+#else\n+\t.align 8\n+\t.size\tDW.ref.__gcc_personality_v0, 8\n+\t.quad\t__gcc_personality_v0\n+#endif\n+#endif\n+\n+\n+# Initialize the stack test value when the program starts or when a\n+# new thread starts.  We don't know how large the main stack is, so we\n+# guess conservatively.  We might be able to use getrlimit here.\n+\n+\t.text\n+\t.global\t__stack_split_initialize\n+\t.hidden\t__stack_split_initialize\n+\n+#ifdef __ELF__\n+\t.type\t__stack_split_initialize, @function\n+#endif\n+\n+__stack_split_initialize:\n+\n+#ifndef __x86_64__\n+\n+\tleal\t-16000(%esp),%eax\t# We should have at least 16K.\n+\tmovl\t%eax,%gs:0x30\n+\tpushl\t$16000\n+\tpushl\t%esp\n+#ifdef __PIC__\n+\tcall\t__generic_morestack_set_initial_sp@PLT\n+#else\n+\tcall\t__generic_morestack_set_initial_sp\n+#endif\n+\taddl\t$8,%esp\n+\tret\n+\n+#else /* defined(__x86_64__) */\n+\n+\tleaq\t-16000(%rsp),%rax\t# We should have at least 16K.\n+\tmovq\t%rax,%fs:0x70\n+\tmovq\t%rsp,%rdi\n+\tmovq\t$16000,%rsi\n+#ifdef __PIC__\n+\tcall\t__generic_morestack_set_initial_sp@PLT\n+#else\n+\tcall\t__generic_morestack_set_initial_sp\n+#endif\n+\tret\n+\n+#endif /* defined(__x86_64__) */\n+\n+#ifdef __ELF__\n+\t.size\t__stack_split_initialize, . - __stack_split_initialize\n+#endif\n+\n+\n+# Make __stack_split_initialize a high priority constructor.  FIXME:\n+# This is ELF specific.\n+\n+\t.section\t.ctors.65535,\"aw\",@progbits\n+\n+#ifndef __x86_64__\n+\t.align\t4\n+\t.long\t__stack_split_initialize\n+\t.long\t__morestack_load_mmap\n+#else\n+\t.align\t8\n+\t.quad\t__stack_split_initialize\n+\t.quad\t__morestack_load_mmap\n+#endif\n+\n+#ifdef __ELF__\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+\t.section\t.note.GNU-split-stack,\"\",@progbits\n+\t.section\t.note.GNU-no-split-stack,\"\",@progbits\n+#endif"}, {"sha": "6391cd2d46ad13baa7de112c11d43861c7685ceb", "filename": "libgcc/config/i386/t-stack-i386", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig%2Fi386%2Ft-stack-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig%2Fi386%2Ft-stack-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-stack-i386?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,2 @@\n+# Makefile fragment to support -fsplit-stack for x86.\n+LIB2ADD += $(srcdir)/config/i386/morestack.S"}, {"sha": "9ac223d8497724af016430d32e0d5766b8ab6a80", "filename": "libgcc/config/t-stack", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig%2Ft-stack", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fconfig%2Ft-stack", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Ft-stack?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,4 @@\n+# Makefile fragment to provide generic support for -fsplit-stack.\n+# This should be used in config.host for any host which supports\n+# -fsplit-stack.\n+LIB2ADD += $(srcdir)/generic-morestack.c $(srcdir)/generic-morestack-thread.c"}, {"sha": "bc237957ef64486769a998f81af8fc673884db8f", "filename": "libgcc/generic-morestack-thread.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fgeneric-morestack-thread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fgeneric-morestack-thread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack-thread.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,162 @@\n+/* Thread library support for -fsplit-stack.  */\n+/* Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Contributed by Ian Lance Taylor <iant@google.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+/* If inhibit_libc is defined, we can not compile this file.  The\n+   effect is that people will not be able to use -fsplit-stack.  That\n+   is much better than failing the build particularly since people\n+   will want to define inhibit_libc while building a compiler which\n+   can build glibc.  */\n+\n+#ifndef inhibit_libc\n+\n+#include <pthread.h>\n+\n+#include \"generic-morestack.h\"\n+\n+/* We declare the pthread functions we need as weak, so that\n+   libgcc_s.so does not need to be linked against -lpthread.  */\n+\n+extern int pthread_once (pthread_once_t *, void (*) (void))\n+  __attribute__ ((weak));\n+\n+extern int pthread_key_create (pthread_key_t *, void (*) (void *))\n+  __attribute__ ((weak));\n+\n+extern int pthread_setspecific (pthread_key_t, const void *)\n+  __attribute__ ((weak));\n+\n+/* The key for the list of stack segments to free when the thread\n+   exits.  This is created by pthread_key_create.  */\n+\n+static pthread_key_t segment_list_key;\n+\n+/* Used to only run create_key once.  */\n+\n+static pthread_once_t create_key_once = PTHREAD_ONCE_INIT;\n+\n+/* Release all the segments for a thread.  This is the destructor\n+   function used by pthread_key_create, and is called when a thread\n+   exits.  */\n+\n+static void\n+free_segments (void* arg)\n+{\n+  __morestack_release_segments ((struct stack_segment **) arg, 1);\n+}\n+\n+/* Set up the key for the list of segments.  This is called via\n+   pthread_once.  */\n+\n+static void\n+create_key (void)\n+{\n+  int err;\n+\n+  err = pthread_key_create (&segment_list_key, free_segments);\n+  if (err != 0)\n+    {\n+      static const char msg[] = \"pthread_key_create failed: errno \";\n+      __morestack_fail (msg, sizeof msg - 1, err);\n+    }\n+}\n+\n+/* Pass information from the pthread_create wrapper to\n+   stack_split_initialize_thread.  */\n+\n+struct pthread_create_args\n+{\n+  void *(*start_routine) (void *);\n+  void *arg;\n+};\n+\n+/* Initialize a thread.  This is called via pthread_create.  It calls\n+   a target dependent function to set up any required stack guard.  */\n+\n+static void* stack_split_initialize_thread (void *)\n+  __attribute__ ((no_split_stack));\n+\n+static void *\n+stack_split_initialize_thread (void *varg)\n+{\n+  struct pthread_create_args *args = (struct pthread_create_args *) varg;\n+  int err;\n+  void *(*start_routine) (void *);\n+  void *arg;\n+\n+  __stack_split_initialize ();\n+\n+  err = pthread_setspecific (segment_list_key, (void *) &__morestack_segments);\n+  if (err != 0)\n+    {\n+      static const char msg[] = \"pthread_setspecific failed: errno \";\n+      __morestack_fail (msg, sizeof msg - 1, err);\n+    }\n+\n+  start_routine = args->start_routine;\n+  arg = args->arg;\n+  free (args);\n+  return (*start_routine) (arg);\n+}\n+\n+/* This function wraps calls to pthread_create to make sure that the\n+   stack guard is initialized for new threads.  FIXME: This hack will\n+   not be necessary if glibc supports -fsplit-stack directly.  */\n+\n+int __wrap_pthread_create (pthread_t *, const pthread_attr_t *,\n+\t\t\t   void *(*start_routine) (void *), void *)\n+  __attribute__ ((visibility (\"hidden\")));\n+\n+extern int __real_pthread_create (pthread_t *, const pthread_attr_t *,\n+\t\t\t\t  void *(*start_routine) (void *), void *)\n+  __attribute__ ((weak));\n+\n+int\n+__wrap_pthread_create (pthread_t *tid, const pthread_attr_t *attr,\n+\t\t       void *(*start_routine) (void *), void *arg)\n+{\n+  int err;\n+  struct pthread_create_args* args;\n+\n+  err = pthread_once (&create_key_once, create_key);\n+  if (err != 0)\n+    {\n+      static const char msg[] = \"pthread_once failed: errno \";\n+      __morestack_fail (msg, sizeof msg - 1, err);\n+    }\n+\n+  args = malloc (sizeof (struct pthread_create_args));\n+  if (args == NULL)\n+    return EAGAIN;\n+  args->start_routine = start_routine;\n+  args->arg = arg;\n+  return __real_pthread_create (tid, attr, stack_split_initialize_thread, args);\n+}\n+\n+#endif /* !defined (inhibit_libc) */"}, {"sha": "3709d32086458488d2aeb18bc5018e29dbbb3f22", "filename": "libgcc/generic-morestack.c", "status": "added", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fgeneric-morestack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fgeneric-morestack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.c?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,876 @@\n+/* Library support for -fsplit-stack.  */\n+/* Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Contributed by Ian Lance Taylor <iant@google.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+/* If inhibit_libc is defined, we can not compile this file.  The\n+   effect is that people will not be able to use -fsplit-stack.  That\n+   is much better than failing the build particularly since people\n+   will want to define inhibit_libc while building a compiler which\n+   can build glibc.  */\n+\n+#ifndef inhibit_libc\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#include <sys/uio.h>\n+\n+#include \"generic-morestack.h\"\n+\n+/* This file contains subroutines that are used by code compiled with\n+   -fsplit-stack.  */\n+\n+/* Declare functions to avoid warnings--there is no header file for\n+   these internal functions.  We give most of these functions the\n+   flatten attribute in order to minimize their stack usage--here we\n+   must minimize stack usage even at the cost of code size, and in\n+   general inlining everything will do that.  */\n+\n+extern void\n+__generic_morestack_set_initial_sp (void *sp, size_t len)\n+  __attribute__ ((no_split_stack, flatten, visibility (\"hidden\")));\n+\n+extern void *\n+__generic_morestack (size_t *frame_size, void *old_stack, size_t param_size)\n+  __attribute__ ((no_split_stack, flatten, visibility (\"hidden\")));\n+\n+extern void *\n+__generic_releasestack (size_t *pavailable)\n+  __attribute__ ((no_split_stack, flatten, visibility (\"hidden\")));\n+\n+extern void\n+__morestack_block_signals (void)\n+  __attribute__ ((no_split_stack, flatten, visibility (\"hidden\")));\n+\n+extern void\n+__morestack_unblock_signals (void)\n+  __attribute__ ((no_split_stack, flatten, visibility (\"hidden\")));\n+\n+extern size_t\n+__generic_findstack (void *stack)\n+  __attribute__ ((no_split_stack, flatten, visibility (\"hidden\")));\n+\n+extern void\n+__morestack_load_mmap (void)\n+  __attribute__ ((no_split_stack, visibility (\"hidden\")));\n+\n+extern void *\n+__morestack_allocate_stack_space (size_t size)\n+  __attribute__ ((visibility (\"hidden\")));\n+\n+/* This is a function which -fsplit-stack code can call to get a list\n+   of the stacks.  Since it is not called only by the compiler, it is\n+   not hidden.  */\n+\n+extern void *\n+__splitstack_find (void *, void *, size_t *, void **, void **, void **)\n+  __attribute__ ((visibility (\"default\")));\n+\n+/* When we allocate a stack segment we put this header at the\n+   start.  */\n+\n+struct stack_segment\n+{\n+  /* The previous stack segment--when a function running on this stack\n+     segment returns, it will run on the previous one.  */\n+  struct stack_segment *prev;\n+  /* The next stack segment, if it has been allocated--when a function\n+     is running on this stack segment, the next one is not being\n+     used.  */\n+  struct stack_segment *next;\n+  /* The total size of this stack segment.  */\n+  size_t size;\n+  /* The stack address when this stack was created.  This is used when\n+     popping the stack.  */\n+  void *old_stack;\n+  /* A list of memory blocks allocated by dynamic stack\n+     allocation.  */\n+  struct dynamic_allocation_blocks *dynamic_allocation;\n+  /* A list of dynamic memory blocks no longer needed.  */\n+  struct dynamic_allocation_blocks *free_dynamic_allocation;\n+  /* An extra pointer in case we need some more information some\n+     day.  */\n+  void *extra;\n+};\n+\n+/* This structure holds the (approximate) initial stack pointer and\n+   size for the system supplied stack for a thread.  This is set when\n+   the thread is created.  We also store a sigset_t here to hold the\n+   signal mask while splitting the stack, since we don't want to store\n+   that on the stack.  */\n+\n+struct initial_sp\n+{\n+  /* The initial stack pointer.  */\n+  void *sp;\n+  /* The stack length.  */\n+  size_t len;\n+  /* A signal mask, put here so that the thread can use it without\n+     needing stack space.  */\n+  sigset_t mask;\n+  /* Some extra space for later extensibility.  */\n+  void *extra[5];\n+};\n+\n+/* A list of memory blocks allocated by dynamic stack allocation.\n+   This is used for code that calls alloca or uses variably sized\n+   arrays.  */\n+\n+struct dynamic_allocation_blocks\n+{\n+  /* The next block in the list.  */\n+  struct dynamic_allocation_blocks *next;\n+  /* The size of the allocated memory.  */\n+  size_t size;\n+  /* The allocated memory.  */\n+  void *block;\n+};\n+\n+/* These thread local global variables must be shared by all split\n+   stack code across shared library boundaries.  Therefore, they have\n+   default visibility.  They have extensibility fields if needed for\n+   new versions.  If more radical changes are needed, new code can be\n+   written using new variable names, while still using the existing\n+   variables in a backward compatible manner.  Symbol versioning is\n+   also used, although, since these variables are only referenced by\n+   code in this file and generic-morestack-thread.c, it is likely that\n+   simply using new names will suffice.  */\n+\n+/* The first stack segment allocated for this thread.  */\n+\n+__thread struct stack_segment *__morestack_segments\n+  __attribute__ ((visibility (\"default\")));\n+\n+/* The stack segment that we think we are currently using.  This will\n+   be correct in normal usage, but will be incorrect if an exception\n+   unwinds into a different stack segment or if longjmp jumps to a\n+   different stack segment.  */\n+\n+__thread struct stack_segment *__morestack_current_segment\n+  __attribute__ ((visibility (\"default\")));\n+\n+/* The initial stack pointer and size for this thread.  */\n+\n+__thread struct initial_sp __morestack_initial_sp\n+  __attribute__ ((visibility (\"default\")));\n+\n+/* A static signal mask, to avoid taking up stack space.  */\n+\n+static sigset_t __morestack_fullmask;\n+\n+/* Convert an integer to a decimal string without using much stack\n+   space.  Return a pointer to the part of the buffer to use.  We this\n+   instead of sprintf because sprintf will require too much stack\n+   space.  */\n+\n+static char *\n+print_int (int val, char *buf, int buflen, size_t *print_len)\n+{\n+  int is_negative;\n+  int i;\n+  unsigned int uval;\n+\n+  uval = (unsigned int) val;\n+  if (val >= 0)\n+    is_negative = 0;\n+  else\n+    {\n+      is_negative = 1;\n+      uval = - uval;\n+    }\n+\n+  i = buflen;\n+  do\n+    {\n+      --i;\n+      buf[i] = '0' + (uval % 10);\n+      uval /= 10;\n+    }\n+  while (uval != 0 && i > 0);\n+\n+  if (is_negative)\n+    {\n+      if (i > 0)\n+\t--i;\n+      buf[i] = '-';\n+    }\n+\n+  *print_len = buflen - i;\n+  return buf + i;\n+}\n+\n+/* Print the string MSG/LEN, the errno number ERR, and a newline on\n+   stderr.  Then crash.  */\n+\n+void\n+__morestack_fail (const char *, size_t, int) __attribute__ ((noreturn));\n+\n+void\n+__morestack_fail (const char *msg, size_t len, int err)\n+{\n+  char buf[24];\n+  static const char nl[] = \"\\n\";\n+  struct iovec iov[3];\n+  union { char *p; const char *cp; } const_cast;\n+\n+  const_cast.cp = msg;\n+  iov[0].iov_base = const_cast.p;\n+  iov[0].iov_len = len;\n+  /* We can't call strerror, because it may try to translate the error\n+     message, and that would use too much stack space.  */\n+  iov[1].iov_base = print_int (err, buf, sizeof buf, &iov[1].iov_len);\n+  const_cast.cp = &nl[0];\n+  iov[2].iov_base = const_cast.p;\n+  iov[2].iov_len = sizeof nl - 1;\n+  /* FIXME: On systems without writev we need to issue three write\n+     calls, or punt on printing errno.  For now this is irrelevant\n+     since stack splitting only works on GNU/Linux anyhow.  */\n+  writev (2, iov, 3);\n+  abort ();\n+}\n+\n+/* Allocate a new stack segment.  FRAME_SIZE is the required frame\n+   size.  */\n+\n+static struct stack_segment *\n+allocate_segment (size_t frame_size)\n+{\n+  static unsigned int static_pagesize;\n+  static int use_guard_page;\n+  unsigned int pagesize;\n+  unsigned int overhead;\n+  unsigned int allocate;\n+  void *space;\n+  struct stack_segment *pss;\n+\n+  pagesize = static_pagesize;\n+  if (pagesize == 0)\n+    {\n+      unsigned int p;\n+\n+      pagesize = getpagesize ();\n+\n+#ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\n+      p = __sync_val_compare_and_swap (&static_pagesize, 0, pagesize);\n+#else\n+      /* Just hope this assignment is atomic.  */\n+      static_pagesize = pagesize;\n+      p = 0;\n+#endif\n+\n+      use_guard_page = getenv (\"SPLIT_STACK_GUARD\") != 0;\n+\n+      /* FIXME: I'm not sure this assert should be in the released\n+\t code.  */\n+      assert (p == 0 || p == pagesize);\n+    }\n+\n+  overhead = sizeof (struct stack_segment);\n+\n+  allocate = pagesize;\n+  if (allocate < MINSIGSTKSZ)\n+    allocate = ((MINSIGSTKSZ + overhead + pagesize - 1)\n+\t\t& ~ (pagesize - 1));\n+  if (allocate < frame_size)\n+    allocate = ((frame_size + overhead + pagesize - 1)\n+\t\t& ~ (pagesize - 1));\n+\n+  if (use_guard_page)\n+    allocate += pagesize;\n+\n+  /* FIXME: If this binary requires an executable stack, then we need\n+     to set PROT_EXEC.  Unfortunately figuring that out is complicated\n+     and target dependent.  We would need to use dl_iterate_phdr to\n+     see if there is any object which does not have a PT_GNU_STACK\n+     phdr, though only for architectures which use that mechanism.  */\n+  space = mmap (NULL, allocate, PROT_READ | PROT_WRITE,\n+\t\tMAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n+  if (space == MAP_FAILED)\n+    {\n+      static const char msg[] =\n+\t\"unable to allocate additional stack space: errno \";\n+      __morestack_fail (msg, sizeof msg - 1, errno);\n+    }\n+\n+  if (use_guard_page)\n+    {\n+      void *guard;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+      guard = space;\n+      space = (char *) space + pagesize;\n+#else\n+      guard = space + allocate - pagesize;\n+#endif\n+\n+      mprotect (guard, pagesize, PROT_NONE);\n+      allocate -= pagesize;\n+    }\n+\n+  pss = (struct stack_segment *) space;\n+\n+  pss->prev = __morestack_current_segment;\n+  pss->next = NULL;\n+  pss->size = allocate - overhead;\n+  pss->dynamic_allocation = NULL;\n+  pss->free_dynamic_allocation = NULL;\n+  pss->extra = NULL;\n+\n+  if (__morestack_current_segment != NULL)\n+    __morestack_current_segment->next = pss;\n+  else\n+    __morestack_segments = pss;\n+\n+  return pss;\n+}\n+\n+/* Free a list of dynamic blocks.  */\n+\n+static void\n+free_dynamic_blocks (struct dynamic_allocation_blocks *p)\n+{\n+  while (p != NULL)\n+    {\n+      struct dynamic_allocation_blocks *next;\n+\n+      next = p->next;\n+      free (p->block);\n+      free (p);\n+      p = next;\n+    }\n+}\n+\n+/* Merge two lists of dynamic blocks.  */\n+\n+static struct dynamic_allocation_blocks *\n+merge_dynamic_blocks (struct dynamic_allocation_blocks *a,\n+\t\t      struct dynamic_allocation_blocks *b)\n+{\n+  struct dynamic_allocation_blocks **pp;\n+\n+  if (a == NULL)\n+    return b;\n+  if (b == NULL)\n+    return a;\n+  for (pp = &a->next; *pp != NULL; pp = &(*pp)->next)\n+    ;\n+  *pp = b;\n+  return a;\n+}\n+\n+/* Release stack segments.  If FREE_DYNAMIC is non-zero, we also free\n+   any dynamic blocks.  Otherwise we return them.  */\n+\n+struct dynamic_allocation_blocks *\n+__morestack_release_segments (struct stack_segment **pp, int free_dynamic)\n+{\n+  struct dynamic_allocation_blocks *ret;\n+  struct stack_segment *pss;\n+\n+  ret = NULL;\n+  pss = *pp;\n+  while (pss != NULL)\n+    {\n+      struct stack_segment *next;\n+      unsigned int allocate;\n+\n+      next = pss->next;\n+\n+      if (pss->dynamic_allocation != NULL\n+\t  || pss->free_dynamic_allocation != NULL)\n+\t{\n+\t  if (free_dynamic)\n+\t    {\n+\t      free_dynamic_blocks (pss->dynamic_allocation);\n+\t      free_dynamic_blocks (pss->free_dynamic_allocation);\n+\t    }\n+\t  else\n+\t    {\n+\t      ret = merge_dynamic_blocks (pss->dynamic_allocation, ret);\n+\t      ret = merge_dynamic_blocks (pss->free_dynamic_allocation, ret);\n+\t    }\n+\t}\n+\n+      allocate = pss->size + sizeof (struct stack_segment);\n+      if (munmap (pss, allocate) < 0)\n+\t{\n+\t  static const char msg[] = \"munmap of stack space failed: errno \";\n+\t  __morestack_fail (msg, sizeof msg - 1, errno);\n+\t}\n+\n+      pss = next;\n+    }\n+  *pp = NULL;\n+\n+  return ret;\n+}\n+\n+/* This function is called by a processor specific function to set the\n+   initial stack pointer for a thread.  The operating system will\n+   always create a stack for a thread.  Here we record a stack pointer\n+   near the base of that stack.  The size argument lets the processor\n+   specific code estimate how much stack space is available on this\n+   initial stack.  */\n+\n+void\n+__generic_morestack_set_initial_sp (void *sp, size_t len)\n+{\n+  /* The stack pointer most likely starts on a page boundary.  Adjust\n+     to the nearest 512 byte boundary.  It's not essential that we be\n+     precise here; getting it wrong will just leave some stack space\n+     unused.  */\n+#ifdef STACK_GROWS_DOWNWARD\n+  sp = (void *) ((((__UINTPTR_TYPE__) sp + 511U) / 512U) * 512U);\n+#else\n+  sp = (void *) ((((__UINTPTR_TYPE__) sp - 511U) / 512U) * 512U);\n+#endif\n+\n+  __morestack_initial_sp.sp = sp;\n+  __morestack_initial_sp.len = len;\n+  sigemptyset (&__morestack_initial_sp.mask);\n+\n+  sigfillset (&__morestack_fullmask);\n+#ifdef __linux__\n+  /* On Linux, the first two real time signals are used by the NPTL\n+     threading library.  By taking them out of the set of signals, we\n+     avoiding copying the signal mask in pthread_sigmask.  More\n+     importantly, pthread_sigmask uses less stack space on x86_64.  */\n+  sigdelset (&__morestack_fullmask, __SIGRTMIN);\n+  sigdelset (&__morestack_fullmask, __SIGRTMIN + 1);\n+#endif\n+}\n+\n+/* This function is called by a processor specific function which is\n+   run in the prologue when more stack is needed.  The processor\n+   specific function handles the details of saving registers and\n+   frobbing the actual stack pointer.  This function is responsible\n+   for allocating a new stack segment and for copying a parameter\n+   block from the old stack to the new one.  On function entry\n+   *PFRAME_SIZE is the size of the required stack frame--the returned\n+   stack must be at least this large.  On function exit *PFRAME_SIZE\n+   is the amount of space remaining on the allocated stack.  OLD_STACK\n+   points at the parameters the old stack (really the current one\n+   while this function is running).  OLD_STACK is saved so that it can\n+   be returned by a later call to __generic_releasestack.  PARAM_SIZE\n+   is the size in bytes of parameters to copy to the new stack.  This\n+   function returns a pointer to the new stack segment, pointing to\n+   the memory after the parameters have been copied.  The returned\n+   value minus the returned *PFRAME_SIZE (or plus if the stack grows\n+   upward) is the first address on the stack which should not be used.\n+\n+   This function is running on the old stack and has only a limited\n+   amount of stack space available.  */\n+\n+void *\n+__generic_morestack (size_t *pframe_size, void *old_stack, size_t param_size)\n+{\n+  size_t frame_size = *pframe_size;\n+  struct stack_segment *current;\n+  struct stack_segment **pp;\n+  struct dynamic_allocation_blocks *dynamic;\n+  char *from;\n+  char *to;\n+  void *ret;\n+  size_t i;\n+\n+  current = __morestack_current_segment;\n+\n+  pp = current != NULL ? &current->next : &__morestack_segments;\n+  if (*pp != NULL && (*pp)->size < frame_size)\n+    dynamic = __morestack_release_segments (pp, 0);\n+  else\n+    dynamic = NULL;\n+  current = *pp;\n+\n+  if (current == NULL)\n+    current = allocate_segment (frame_size);\n+\n+  current->old_stack = old_stack;\n+\n+  __morestack_current_segment = current;\n+\n+  if (dynamic != NULL)\n+    {\n+      /* Move the free blocks onto our list.  We don't want to call\n+\t free here, as we are short on stack space.  */\n+      current->free_dynamic_allocation =\n+\tmerge_dynamic_blocks (dynamic, current->free_dynamic_allocation);\n+    }\n+\n+  *pframe_size = current->size - param_size;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+  {\n+    char *bottom = (char *) (current + 1) + current->size;\n+    to = bottom - param_size;\n+    ret = bottom - param_size;\n+  }\n+#else\n+  to = current + 1;\n+  ret = (char *) (current + 1) + param_size;\n+#endif\n+\n+  /* We don't call memcpy to avoid worrying about the dynamic linker\n+     trying to resolve it.  */\n+  from = (char *) old_stack;\n+  for (i = 0; i < param_size; i++)\n+    *to++ = *from++;\n+\n+  return ret;\n+}\n+\n+/* This function is called by a processor specific function when it is\n+   ready to release a stack segment.  We don't actually release the\n+   stack segment, we just move back to the previous one.  The current\n+   stack segment will still be available if we need it in\n+   __generic_morestack.  This returns a pointer to the new stack\n+   segment to use, which is the one saved by a previous call to\n+   __generic_morestack.  The processor specific function is then\n+   responsible for actually updating the stack pointer.  This sets\n+   *PAVAILABLE to the amount of stack space now available.  */\n+\n+void *\n+__generic_releasestack (size_t *pavailable)\n+{\n+  struct stack_segment *current;\n+  void *old_stack;\n+\n+  current = __morestack_current_segment;\n+  old_stack = current->old_stack;\n+  current = current->prev;\n+  __morestack_current_segment = current;\n+\n+  if (current != NULL)\n+    {\n+#ifdef STACK_GROWS_DOWNWARD\n+      *pavailable = (char *) old_stack - (char *) (current + 1);\n+#else\n+      *pavailable = (char *) (current + 1) + current->size - (char *) old_stack;\n+#endif\n+    }\n+  else\n+    {\n+      size_t used;\n+\n+      /* We have popped back to the original stack.  */\n+#ifdef STACK_GROWS_DOWNWARD\n+      if ((char *) old_stack >= (char *) __morestack_initial_sp.sp)\n+\tused = 0;\n+      else\n+\tused = (char *) __morestack_initial_sp.sp - (char *) old_stack;\n+#else\n+      if ((char *) old_stack <= (char *) __morestack_initial_sp.sp)\n+\tused = 0;\n+      else\n+\tused = (char *) old_stack - (char *) __morestack_initial_sp.sp;\n+#endif\n+\n+      if (used > __morestack_initial_sp.len)\n+\t*pavailable = 0;\n+      else\n+\t*pavailable = __morestack_initial_sp.len - used;\n+    }\n+\n+  return old_stack;\n+}\n+\n+/* Block signals while splitting the stack.  This avoids trouble if we\n+   try to invoke a signal handler which itself wants to split the\n+   stack.  */\n+\n+extern int pthread_sigmask (int, const sigset_t *, sigset_t *)\n+  __attribute__ ((weak));\n+\n+void\n+__morestack_block_signals (void)\n+{\n+  if (pthread_sigmask)\n+    pthread_sigmask (SIG_BLOCK, &__morestack_fullmask,\n+\t\t     &__morestack_initial_sp.mask);\n+  else\n+    sigprocmask (SIG_BLOCK, &__morestack_fullmask,\n+\t\t &__morestack_initial_sp.mask);\n+}\n+\n+/* Unblock signals while splitting the stack.  */\n+\n+void\n+__morestack_unblock_signals (void)\n+{\n+  if (pthread_sigmask)\n+    pthread_sigmask (SIG_SETMASK, &__morestack_initial_sp.mask, NULL);\n+  else\n+    sigprocmask (SIG_SETMASK, &__morestack_initial_sp.mask, NULL);\n+}\n+\n+/* This function is called to allocate dynamic stack space, for alloca\n+   or a variably sized array.  This is a regular function with\n+   sufficient stack space, so we just use malloc to allocate the\n+   space.  We attach the allocated blocks to the current stack\n+   segment, so that they will eventually be reused or freed.  */\n+\n+void *\n+__morestack_allocate_stack_space (size_t size)\n+{\n+  struct stack_segment *seg, *current;\n+  struct dynamic_allocation_blocks *p;\n+\n+  /* We have to block signals to avoid getting confused if we get\n+     interrupted by a signal whose handler itself uses alloca or a\n+     variably sized array.  */\n+  __morestack_block_signals ();\n+\n+  /* Since we don't want to call free while we are low on stack space,\n+     we may have a list of already allocated blocks waiting to be\n+     freed.  Release them all, unless we find one that is large\n+     enough.  We don't look at every block to see if one is large\n+     enough, just the first one, because we aren't trying to build a\n+     memory allocator here, we're just trying to speed up common\n+     cases.  */\n+\n+  current = __morestack_current_segment;\n+  p = NULL;\n+  for (seg = __morestack_segments; seg != NULL; seg = seg->next)\n+    {\n+      p = seg->free_dynamic_allocation;\n+      if (p != NULL)\n+\t{\n+\t  if (p->size >= size)\n+\t    {\n+\t      seg->free_dynamic_allocation = p->next;\n+\t      break;\n+\t    }\n+\n+\t  free_dynamic_blocks (p);\n+\t  seg->free_dynamic_allocation = NULL;\n+\t  p = NULL;\n+\t}\n+    }\n+\n+  if (p == NULL)\n+    {\n+      /* We need to allocate additional memory.  */\n+      p = malloc (sizeof (*p));\n+      if (p == NULL)\n+\tabort ();\n+      p->size = size;\n+      p->block = malloc (size);\n+      if (p->block == NULL)\n+\tabort ();\n+    }\n+\n+  /* If we are still on the initial stack, then we have a space leak.\n+     FIXME.  */\n+  if (current != NULL)\n+    {\n+      p->next = current->dynamic_allocation;\n+      current->dynamic_allocation = p;\n+    }\n+\n+  __morestack_unblock_signals ();\n+\n+  return p->block;\n+}\n+\n+/* Find the stack segment for STACK and return the amount of space\n+   available.  This is used when unwinding the stack because of an\n+   exception, in order to reset the stack guard correctly.  */\n+\n+size_t\n+__generic_findstack (void *stack)\n+{\n+  struct stack_segment *pss;\n+  size_t used;\n+\n+  for (pss = __morestack_current_segment; pss != NULL; pss = pss->prev)\n+    {\n+      if ((char *) pss < (char *) stack\n+\t  && (char *) pss + pss->size > (char *) stack)\n+\t{\n+\t  __morestack_current_segment = pss;\n+#ifdef STACK_GROWS_DOWNWARD\n+\t  return (char *) stack - (char *) (pss + 1);\n+#else\n+\t  return (char *) (pss + 1) + pss->size - (char *) stack;\n+#endif\n+\t}\n+    }\n+\n+  /* We have popped back to the original stack.  */\n+#ifdef STACK_GROWS_DOWNWARD\n+  if ((char *) stack >= (char *) __morestack_initial_sp.sp)\n+    used = 0;\n+  else\n+    used = (char *) __morestack_initial_sp.sp - (char *) stack;\n+#else\n+  if ((char *) stack <= (char *) __morestack_initial_sp.sp)\n+    used = 0;\n+  else\n+    used = (char *) stack - (char *) __morestack_initial_sp.sp;\n+#endif\n+\n+  if (used > __morestack_initial_sp.len)\n+    return 0;\n+  else\n+    return __morestack_initial_sp.len - used;\n+}\n+\n+/* This function is called at program startup time to make sure that\n+   mmap, munmap, and getpagesize are resolved if linking dynamically.\n+   We want to resolve them while we have enough stack for them, rather\n+   than calling into the dynamic linker while low on stack space.  */\n+\n+void\n+__morestack_load_mmap (void)\n+{\n+  /* Call with bogus values to run faster.  We don't care if the call\n+     fails.  Pass __MORESTACK_CURRENT_SEGMENT to make sure that any\n+     TLS accessor function is resolved.  */\n+  mmap (__morestack_current_segment, 0, PROT_READ, MAP_ANONYMOUS, -1, 0);\n+  mprotect (NULL, 0, 0);\n+  munmap (0, getpagesize ());\n+}\n+\n+/* This function may be used to iterate over the stack segments.\n+   This can be called like this.\n+     void *next_segment = NULL;\n+     void *next_sp = NULL;\n+     void *initial_sp = NULL;\n+     void *stack;\n+     size_t stack_size;\n+     while ((stack = __splitstack_find (next_segment, next_sp, &stack_size,\n+                                        &next_segment, &next_sp,\n+\t\t\t\t\t&initial_sp)) != NULL)\n+       {\n+         // Stack segment starts at stack and is stack_size bytes long.\n+       }\n+\n+   There is no way to iterate over the stack segments of a different\n+   thread.  However, what is permitted is for one thread to call this\n+   with the first two values NULL, to pass next_segment, next_sp, and\n+   initial_sp to a different thread, and then to suspend one way or\n+   another.  A different thread may run the subsequent\n+   __morestack_find iterations.  Of course, this will only work if the\n+   first thread is suspended during the __morestack_find iterations.\n+   If not, the second thread will be looking at the stack while it is\n+   changing, and anything could happen.\n+\n+   FIXME: This should be declared in some header file, but where?  */\n+\n+void *\n+__splitstack_find (void *segment_arg, void *sp, size_t *len,\n+\t\t   void **next_segment, void **next_sp,\n+\t\t   void **initial_sp)\n+{\n+  struct stack_segment *segment;\n+  void *ret;\n+  char *nsp;\n+\n+  if (segment_arg == (void *) 1)\n+    {\n+      char *isp = (char *) *initial_sp;\n+\n+      *next_segment = (void *) 2;\n+      *next_sp = NULL;\n+#ifdef STACK_GROWS_DOWNWARD\n+      if ((char *) sp >= isp)\n+\treturn NULL;\n+      *len = (char *) isp - (char *) sp;\n+      return sp;\n+#else\n+      if ((char *) sp <= (char *) isp)\n+\treturn NULL;\n+      *len = (char *) sp - (char *) isp;\n+      return (void *) isp;\n+#endif\n+    }\n+  else if (segment_arg == (void *) 2)\n+    return NULL;\n+  else if (segment_arg != NULL)\n+    segment = (struct stack_segment *) segment_arg;\n+  else\n+    {\n+      *initial_sp = __morestack_initial_sp.sp;\n+      segment = __morestack_current_segment;\n+      sp = (void *) &segment;\n+      while (1)\n+\t{\n+\t  if (segment == NULL)\n+\t    return __splitstack_find ((void *) 1, sp, len, next_segment,\n+\t\t\t\t      next_sp, initial_sp);\n+\t  if ((char *) sp >= (char *) (segment + 1)\n+\t      && (char *) sp <= (char *) (segment + 1) + segment->size)\n+\t    break;\n+\t  segment = segment->prev;\n+\t}\n+    }\n+\n+  if (segment->prev == NULL)\n+    *next_segment = (void *) 1;\n+  else\n+    *next_segment = segment->prev;\n+\n+  /* The old_stack value is the address of the function parameters of\n+     the function which called __morestack.  So if f1 called f2 which\n+     called __morestack, the stack looks like this:\n+\n+         parameters       <- old_stack\n+         return in f1\n+\t return in f2\n+\t data pushed by __morestack\n+\n+     On x86, the data pushed by __morestack includes the saved value\n+     of the ebp/rbp register.  We want our caller to be able to see\n+     that value, which can not be found on any other stack.  So we\n+     adjust accordingly.  This may need to be tweaked for other\n+     targets.  */\n+\n+  nsp = (char *) segment->old_stack;\n+#ifdef STACK_GROWS_DOWNWARD\n+  nsp -= 3 * sizeof (void *);\n+#else\n+  nsp += 3 * sizeof (void *);\n+#endif\n+  *next_sp = (void *) nsp;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+  *len = (char *) (segment + 1) + segment->size - (char *) sp;\n+  ret = (void *) sp;\n+#else\n+  *len = (char *) sp - (char *) (segment + 1);\n+  ret = (void *) (segment + 1);\n+#endif\n+\n+  return ret;\n+}\n+\n+#endif /* !defined (inhibit_libc) */"}, {"sha": "12da0acfee4d943d84aa0c2d295d74ad5ebb85f2", "filename": "libgcc/generic-morestack.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fgeneric-morestack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7458026b018e6635b9d1bae9ec3b9f4738c3d94a/libgcc%2Fgeneric-morestack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.h?ref=7458026b018e6635b9d1bae9ec3b9f4738c3d94a", "patch": "@@ -0,0 +1,53 @@\n+/* Library support for -fsplit-stack.  */\n+/* Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Contributed by Ian Lance Taylor <iant@google.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This is a libgcc internal header file for functions shared between\n+   generic-morestack.c and generic-morestack-thread.c.  The latter\n+   file is only used when linking with the pthread library.  */\n+\n+/* The stack segment structure, defined in generic-morestack.c.  */\n+\n+struct stack_segment;\n+\n+/* The list of stack segments for this thread.  */\n+\n+extern __thread struct stack_segment *__morestack_segments;\n+\n+/* Print the string MSG/LEN, the errno number ERR, and a newline on\n+   stderr, without using printf.  Then crash.  */\n+\n+extern void __morestack_fail (const char *msg, size_t len, int err)\n+  __attribute__ ((noreturn, visibility (\"hidden\")));\n+\n+/* Release stack segments.  */\n+\n+extern struct dynamic_allocation_blocks *\n+  __morestack_release_segments (struct stack_segment **, int)\n+  __attribute__ ((visibility (\"hidden\")));\n+\n+/* Store the stack information in a processor dependent manner.  */\n+\n+extern void __stack_split_initialize (void)\n+  __attribute__ ((visibility (\"hidden\")));"}]}