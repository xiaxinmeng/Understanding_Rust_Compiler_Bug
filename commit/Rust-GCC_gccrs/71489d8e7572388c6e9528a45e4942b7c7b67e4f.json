{"sha": "71489d8e7572388c6e9528a45e4942b7c7b67e4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0ODlkOGU3NTcyMzg4YzZlOTUyOGE0NWU0OTQyYjdjN2I2N2U0Zg==", "commit": {"author": {"name": "guojiufu", "email": "guojiufu@linux.ibm.com", "date": "2020-05-28T05:42:23Z"}, "committer": {"name": "guojiufu", "email": "guojiufu@linux.ibm.com", "date": "2020-06-07T09:35:01Z"}, "message": "Introduce flag_cunroll_grow_size for cunroll\n\nCurrently GIMPLE complete unroller(cunroll) is checking\nflag_unroll_loops and flag_peel_loops to see if allow size growth.\nBeside affects curnoll, flag_unroll_loops also controls RTL unroler.\nTo have more freedom to control cunroll and RTL unroller, this patch\nintroduces flag_cunroll_grow_size.  With this patch, we can control\ncunroll and RTL unroller indepently.\n\ngcc/ChangeLog\n2020-06-07  Jiufu Guo  <guojiufu@linux.ibm.com>\n\n\t* common.opt (flag_cunroll_grow_size): New flag.\n\t* toplev.c (process_options): Set flag_cunroll_grow_size.\n\t* tree-ssa-loop-ivcanon.c (pass_complete_unroll::execute):\n\tUse flag_cunroll_grow_size.", "tree": {"sha": "a4b5cb277348fe0df2f53f9ab0de532dd4ad8d9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4b5cb277348fe0df2f53f9ab0de532dd4ad8d9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71489d8e7572388c6e9528a45e4942b7c7b67e4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71489d8e7572388c6e9528a45e4942b7c7b67e4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71489d8e7572388c6e9528a45e4942b7c7b67e4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71489d8e7572388c6e9528a45e4942b7c7b67e4f/comments", "author": null, "committer": null, "parents": [{"sha": "905ba62ec96f8469c1085861d9ceec58fbee5709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/905ba62ec96f8469c1085861d9ceec58fbee5709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/905ba62ec96f8469c1085861d9ceec58fbee5709"}], "stats": {"total": 14, "additions": 11, "deletions": 3}, "files": [{"sha": "df8af365d1ba8883b80a20c357fc9f677a7ce833", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71489d8e7572388c6e9528a45e4942b7c7b67e4f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71489d8e7572388c6e9528a45e4942b7c7b67e4f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=71489d8e7572388c6e9528a45e4942b7c7b67e4f", "patch": "@@ -2863,6 +2863,10 @@ funroll-all-loops\n Common Report Var(flag_unroll_all_loops) Optimization\n Perform loop unrolling for all loops.\n \n+funroll-completely-grow-size\n+Undocumented Var(flag_cunroll_grow_size) Init(2) Optimization\n+; Internal undocumented flag, allow size growth during complete unrolling\n+\n ; Nonzero means that loop optimizer may assume that the induction variables\n ; that control loops do not overflow and that the loops with nontrivial\n ; exit condition are not infinite"}, {"sha": "95eea63380f60ceae4996cac5f974d8a24b20061", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71489d8e7572388c6e9528a45e4942b7c7b67e4f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71489d8e7572388c6e9528a45e4942b7c7b67e4f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=71489d8e7572388c6e9528a45e4942b7c7b67e4f", "patch": "@@ -1482,6 +1482,11 @@ process_options (void)\n   if (flag_unroll_all_loops)\n     flag_unroll_loops = 1;\n \n+  /* Allow cunroll to grow size accordingly.  */\n+  if (flag_cunroll_grow_size == AUTODETECT_VALUE)\n+    flag_cunroll_grow_size\n+      = flag_unroll_loops || flag_peel_loops || optimize >= 3;\n+\n   /* web and rename-registers help when run after loop unrolling.  */\n   if (flag_web == AUTODETECT_VALUE)\n     flag_web = flag_unroll_loops;"}, {"sha": "298ab2155301b08710d0be67ac63699e1748000d", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71489d8e7572388c6e9528a45e4942b7c7b67e4f/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71489d8e7572388c6e9528a45e4942b7c7b67e4f/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=71489d8e7572388c6e9528a45e4942b7c7b67e4f", "patch": "@@ -1603,9 +1603,8 @@ pass_complete_unroll::execute (function *fun)\n      re-peeling the same loop multiple times.  */\n   if (flag_peel_loops)\n     peeled_loops = BITMAP_ALLOC (NULL);\n-  unsigned int val = tree_unroll_loops_completely (flag_unroll_loops\n-\t\t\t\t\t\t   || flag_peel_loops\n-\t\t\t\t\t\t   || optimize >= 3, true);\n+  unsigned int val = tree_unroll_loops_completely (flag_cunroll_grow_size, \n+\t\t\t\t\t\t   true);\n   if (peeled_loops)\n     {\n       BITMAP_FREE (peeled_loops);"}]}