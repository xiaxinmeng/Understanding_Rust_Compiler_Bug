{"sha": "232abc3ff8954a9b040ea11dd8e3291759a159c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMyYWJjM2ZmODk1NGE5YjA0MGVhMTFkZDhlMzI5MTc1OWExNTljNg==", "commit": {"author": {"name": "Robert Kidd", "email": "rkidd@gcc.gnu.org", "date": "2007-09-10T12:49:46Z"}, "committer": {"name": "Robert Kidd", "email": "rkidd@gcc.gnu.org", "date": "2007-09-10T12:49:46Z"}, "message": "bb-reorder.c (rest_of_handler_reorder_blocks): Removed call to RTL level tracer pass.\n\n2007-09-10 Robert Kidd <rkidd@crhc.uiuc.edu>\n\n\t* bb-reorder.c (rest_of_handler_reorder_blocks): Removed call to\n\tRTL level tracer pass.\n\t* passes.c (init_optimization_passes): Move pass_tracer from\n\tafter pass_rtl_ifcvt to after pass_dce.\n\t* tracer.c: Update copyright.\n\t(layout_superblocks): Remove function.\n\t(mark_bb_seen): New.\n\t(bb_seen_p): New.\n\t(count_insns): Change to estimate instructions in a Tree-SSA\n\tstatement.\n\t(find_trace): Use bb_seen_p.\n\t(tail_duplicate): Use bb_seen_p.  Call add_phi_args_after_copy\n\tafter duplicate_block.\n\t(tracer): Change prototype to match that of a pass execute\n\tcallback.\n\t(gate_tracer): Rename from gate_handle_tracer.\n\t(rest_of_handle_tracer): Remove function.\n\t* rtl.h: Remove prototype for tracer.\n\t* testsuite/gcc.dg/tree-prof/tracer-1.c: New.\n\nFrom-SVN: r128341", "tree": {"sha": "beede6b03e0a31fcf7974e27cc39df96abf78663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beede6b03e0a31fcf7974e27cc39df96abf78663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/232abc3ff8954a9b040ea11dd8e3291759a159c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/232abc3ff8954a9b040ea11dd8e3291759a159c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/232abc3ff8954a9b040ea11dd8e3291759a159c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/232abc3ff8954a9b040ea11dd8e3291759a159c6/comments", "author": null, "committer": null, "parents": [{"sha": "281b604e6b81db532a717590a6fc58b13d087cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281b604e6b81db532a717590a6fc58b13d087cd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/281b604e6b81db532a717590a6fc58b13d087cd0"}], "stats": {"total": 197, "additions": 94, "deletions": 103}, "files": [{"sha": "0b7077171243a05a23b45a89601c8acc30ec9416", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=232abc3ff8954a9b040ea11dd8e3291759a159c6", "patch": "@@ -2198,19 +2198,12 @@ rest_of_handle_reorder_blocks (void)\n      splitting possibly introduced more crossjumping opportunities.  */\n   cfg_layout_initialize (CLEANUP_EXPENSIVE);\n \n-  if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n+  if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n     {\n-      timevar_push (TV_TRACER);\n-      tracer ();\n-      timevar_pop (TV_TRACER);\n+      reorder_basic_blocks ();\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n     }\n \n-  if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n-    reorder_basic_blocks ();\n-  if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n-      || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)\n       bb->aux = bb->next_bb;"}, {"sha": "48f4af099d0d76bea403192fde1584b5189a9f60", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=232abc3ff8954a9b040ea11dd8e3291759a159c6", "patch": "@@ -648,6 +648,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_phi_only_cprop);\n \n       NEXT_PASS (pass_cd_dce);\n+      NEXT_PASS (pass_tracer);\n \n       /* FIXME: If DCE is not run before checking for uninitialized uses,\n \t we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n@@ -692,7 +693,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_rtl_fwprop);\n       NEXT_PASS (pass_gcse);\n       NEXT_PASS (pass_rtl_ifcvt);\n-      NEXT_PASS (pass_tracer);\n       /* Perform loop optimizations.  It might be better to do them a bit\n \t sooner, but we want the profile feedback to work more\n \t efficiently.  */"}, {"sha": "64dc3bc85988e75ab045ab0ff0f03c21bbaa4654", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=232abc3ff8954a9b040ea11dd8e3291759a159c6", "patch": "@@ -2269,8 +2269,6 @@ extern void invert_br_probabilities (rtx);\n extern bool expensive_function_p (int);\n /* In cfgexpand.c */\n extern void add_reg_br_prob_note (rtx last, int probability);\n-/* In tracer.c */\n-extern void tracer (void);\n \n /* In var-tracking.c */\n extern unsigned int variable_tracking_main (void);"}, {"sha": "1eac6e3b10dcc916698aeab44d8d75d98fdc3099", "filename": "gcc/testsuite/gcc.dg/tree-prof/tracer-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftracer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftracer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftracer-1.c?ref=232abc3ff8954a9b040ea11dd8e3291759a159c6", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-options \"-O2 -ftracer -fdump-tree-tracer\" } */\n+main ()\n+{\n+  int i;\n+  int a, b, c;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      if (i % 17)\n+\ta++;\n+      else\n+\tb++;\n+      c++;\n+    }\n+  return 0;\n+}\n+/* Superblock formation should produce two copies of the increment of c */\n+/* { dg-final-generate { scan-tree-dump-times \"goto <bb 6>;\" 2 \"tracer\" } } */\n+/* { dg-final-generate { cleanup-tree-dump \"tracer\" } } */"}, {"sha": "ca505490639d213312ab9cad03de89805905b100", "filename": "gcc/tracer.c", "status": "modified", "additions": 72, "deletions": 90, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/232abc3ff8954a9b040ea11dd8e3291759a159c6/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=232abc3ff8954a9b040ea11dd8e3291759a159c6", "patch": "@@ -1,5 +1,6 @@\n /* The tracer pass for the GNU compiler.\n    Contributed by Jan Hubicka, SuSE Labs.\n+   Adapted to work on GIMPLE instead of RTL by Robert Kidd, UIUC.\n    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n@@ -49,24 +50,41 @@\n #include \"params.h\"\n #include \"coverage.h\"\n #include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-inline.h\"\n \n-static int count_insns (const_basic_block);\n+static int count_insns (basic_block);\n static bool ignore_bb_p (const_basic_block);\n static bool better_p (const_edge, const_edge);\n static edge find_best_successor (basic_block);\n static edge find_best_predecessor (basic_block);\n static int find_trace (basic_block, basic_block *);\n static void tail_duplicate (void);\n-static void layout_superblocks (void);\n \n /* Minimal outgoing edge probability considered for superblock formation.  */\n static int probability_cutoff;\n static int branch_ratio_cutoff;\n \n-/* Return true if BB has been seen - it is connected to some trace\n-   already.  */\n+/* A bit BB->index is set if BB has already been seen, i.e. it is\n+   connected to some trace already.  */\n+sbitmap bb_seen;\n \n-#define seen(bb) (bb->il.rtl->visited || bb->aux)\n+static inline void\n+mark_bb_seen (basic_block bb)\n+{\n+  unsigned int size = SBITMAP_SIZE_BYTES (bb_seen) * 8;\n+\n+  if ((unsigned int)bb->index >= size)\n+    bb_seen = sbitmap_resize (bb_seen, size * 2, 0);\n+\n+  SET_BIT (bb_seen, bb->index);\n+}\n+\n+static inline bool\n+bb_seen_p (basic_block bb)\n+{\n+  return TEST_BIT (bb_seen, bb->index);\n+}\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */\n static bool\n@@ -82,16 +100,17 @@ ignore_bb_p (const_basic_block bb)\n /* Return number of instructions in the block.  */\n \n static int\n-count_insns (const_basic_block bb)\n+count_insns (basic_block bb)\n {\n-  const_rtx insn;\n+  block_stmt_iterator bsi;\n+  tree stmt;\n   int n = 0;\n \n-  for (insn = BB_HEAD (bb);\n-       insn != NEXT_INSN (BB_END (bb));\n-       insn = NEXT_INSN (insn))\n-    if (active_insn_p (insn))\n-      n++;\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+      n += estimate_num_insns (stmt, &eni_size_weights);\n+    }\n   return n;\n }\n \n@@ -166,7 +185,7 @@ find_trace (basic_block bb, basic_block *trace)\n   while ((e = find_best_predecessor (bb)) != NULL)\n     {\n       basic_block bb2 = e->src;\n-      if (seen (bb2) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n+      if (bb_seen_p (bb2) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t  || find_best_successor (bb2) != e)\n \tbreak;\n       if (dump_file)\n@@ -181,7 +200,7 @@ find_trace (basic_block bb, basic_block *trace)\n   while ((e = find_best_successor (bb)) != NULL)\n     {\n       bb = e->dest;\n-      if (seen (bb) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n+      if (bb_seen_p (bb) || (e->flags & (EDGE_DFS_BACK | EDGE_COMPLEX))\n \t  || find_best_predecessor (bb) != e)\n \tbreak;\n       if (dump_file)\n@@ -209,6 +228,12 @@ tail_duplicate (void)\n   int max_dup_insns;\n   basic_block bb;\n \n+  /* Create an oversized sbitmap to reduce the chance that we need to\n+     resize it.  */\n+  bb_seen = sbitmap_alloc (last_basic_block * 2);\n+  sbitmap_zero (bb_seen);\n+  initialize_original_copy_tables ();\n+\n   if (profile_info && flag_branch_probabilities)\n     probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n   else\n@@ -250,7 +275,7 @@ tail_duplicate (void)\n \n       if (ignore_bb_p (bb))\n \tcontinue;\n-      gcc_assert (!seen (bb));\n+      gcc_assert (!bb_seen_p (bb));\n \n       n = find_trace (bb, trace);\n \n@@ -276,25 +301,30 @@ tail_duplicate (void)\n \t      && can_duplicate_block_p (bb2))\n \t    {\n \t      edge e;\n-\t      basic_block old = bb2;\n+\t      basic_block copy;\n+\n+\t      nduplicated += counts [bb2->index];\n \n \t      e = find_edge (bb, bb2);\n+\t      \n+\t      copy = duplicate_block (bb2, e, bb);\n+\t      flush_pending_stmts (e);\n \n-\t      nduplicated += counts [bb2->index];\n-\t      bb2 = duplicate_block (bb2, e, bb);\n+\t      add_phi_args_after_copy (&copy, 1);\n \n \t      /* Reconsider the original copy of block we've duplicated.\n \t         Removing the most common predecessor may make it to be\n \t         head.  */\n-\t      blocks[old->index] =\n-\t\tfibheap_insert (heap, -old->frequency, old);\n+\t      blocks[bb2->index] =\n+\t\tfibheap_insert (heap, -bb2->frequency, bb2);\n \n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Duplicated %i as %i [%i]\\n\",\n-\t\t\t old->index, bb2->index, bb2->frequency);\n+\t\t\t bb2->index, copy->index, copy->frequency);\n+\n+\t      bb2 = copy;\n \t    }\n-\t  bb->aux = bb2;\n-\t  bb2->il.rtl->visited = 1;\n+\t  mark_bb_seen (bb2);\n \t  bb = bb2;\n \t  /* In case the trace became infrequent, stop duplicating.  */\n \t  if (ignore_bb_p (bb))\n@@ -308,100 +338,51 @@ tail_duplicate (void)\n     fprintf (dump_file, \"Duplicated %i insns (%i%%)\\n\", nduplicated,\n \t     nduplicated * 100 / ninsns);\n \n+  free_original_copy_tables ();\n+  sbitmap_free (bb_seen);\n   free (blocks);\n   free (trace);\n   free (counts);\n   fibheap_delete (heap);\n }\n \n-/* Connect the superblocks into linear sequence.  At the moment we attempt to keep\n-   the original order as much as possible, but the algorithm may be made smarter\n-   later if needed.  BB reordering pass should void most of the benefits of such\n-   change though.  */\n-\n-static void\n-layout_superblocks (void)\n-{\n-  basic_block end = single_succ (ENTRY_BLOCK_PTR);\n-  basic_block bb = end->next_bb;\n-\n-  while (bb != EXIT_BLOCK_PTR)\n-    {\n-      edge_iterator ei;\n-      edge e, best = NULL;\n-      while (end->aux)\n-\tend = end->aux;\n-\n-      FOR_EACH_EDGE (e, ei, end->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR\n-\t    && e->dest != single_succ (ENTRY_BLOCK_PTR)\n-\t    && !e->dest->il.rtl->visited\n-\t    && (!best || EDGE_FREQUENCY (e) > EDGE_FREQUENCY (best)))\n-\t  best = e;\n-\n-      if (best)\n-\t{\n-\t  end->aux = best->dest;\n-\t  best->dest->il.rtl->visited = 1;\n-\t}\n-      else\n-\tfor (; bb != EXIT_BLOCK_PTR; bb = bb->next_bb)\n-\t  {\n-\t    if (!bb->il.rtl->visited)\n-\t      {\n-\t\tend->aux = bb;\n-\t\tbb->il.rtl->visited = 1;\n-\t\tbreak;\n-\t      }\n-\t  }\n-    }\n-}\n-\n /* Main entry point to this file.  */\n \n-void\n+static unsigned int\n tracer (void)\n {\n-  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n+  gcc_assert (current_ir_type () == IR_GIMPLE);\n \n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n-    return;\n+    return 0;\n \n   mark_dfs_back_edges ();\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n+\n+  /* Trace formation is done on the fly inside tail_duplicate */\n   tail_duplicate ();\n-  layout_superblocks ();\n-  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n-  \n+\n+  /* FIXME: We really only need to do this when we know tail duplication\n+            has altered the CFG. */\n+  free_dominance_info (CDI_DOMINATORS);\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n \n-  /* Merge basic blocks in duplicated traces.  */\n-  cleanup_cfg (0);\n+  return 0;\n }\n \f\n static bool\n-gate_handle_tracer (void)\n+gate_tracer (void)\n {\n-  return (optimize > 0 && flag_tracer);\n-}\n-\n-/* Run tracer.  */\n-static unsigned int\n-rest_of_handle_tracer (void)\n-{\n-  if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n-  tracer ();\n-  return 0;\n+  return (optimize > 0 && flag_tracer && flag_reorder_blocks);\n }\n \n struct tree_opt_pass pass_tracer =\n {\n   \"tracer\",                             /* name */\n-  gate_handle_tracer,                   /* gate */\n-  rest_of_handle_tracer,                /* execute */\n+  gate_tracer,                          /* gate */\n+  tracer,                               /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -410,7 +391,8 @@ struct tree_opt_pass pass_tracer =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  TODO_dump_func | TODO_verify_rtl_sharing, /* todo_flags_finish */\n+  TODO_dump_func\n+    | TODO_update_ssa\n+    | TODO_verify_ssa,                  /* todo_flags_finish */\n   'T'                                   /* letter */\n };\n-"}]}