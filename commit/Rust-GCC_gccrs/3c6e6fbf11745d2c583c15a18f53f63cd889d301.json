{"sha": "3c6e6fbf11745d2c583c15a18f53f63cd889d301", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M2ZTZmYmYxMTc0NWQyYzU4M2MxNWExOGY1M2Y2M2NkODg5ZDMwMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-01-11T01:18:58Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-11T01:18:58Z"}, "message": "c-decl.c (duplicate_decls): Break apart into...\n\n\t* c-decl.c (duplicate_decls): Break apart into...\n\t(diagnose_arglist_conflict, validate_proto_after_old_defn)\n\t(locate_old_defn, diagnose_mismatched_decls, merge_decls):\n\t... these new functions.  Restructure for comprehensibility.\n\tRemove various archaic special cases.  Always report the\n\tlocation of the previous declaration when a diagnostic is issued.\n\t(redeclaration_error_message): Fold into diagnose_mismatched_decls.\n\t(match_builtin_function_types): Delete unnecessary forward declaration.\ntestsuite:\n\t* gcc.dg/Wshadow-1.c, gcc.dg/attr-noinline.c, gcc.dg/decl3.c\n\t* gcc.dg/redecl-1.c, gcc.dg/visibility-7.c, gcc.dg/wtr-static-1.c\n\t* gcc.dg/noncompile/20020220-1.c, objc.dg/method-1.m:\n\tUpdate dg-error regexps.\n\nFrom-SVN: r75667", "tree": {"sha": "c27f7a971534ddc43e590439ef9efa353e830bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c27f7a971534ddc43e590439ef9efa353e830bbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c6e6fbf11745d2c583c15a18f53f63cd889d301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c6e6fbf11745d2c583c15a18f53f63cd889d301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c6e6fbf11745d2c583c15a18f53f63cd889d301", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c6e6fbf11745d2c583c15a18f53f63cd889d301/comments", "author": null, "committer": null, "parents": [{"sha": "1e8dcb41f48b06b1b78dcd72de250a579c71e12e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e8dcb41f48b06b1b78dcd72de250a579c71e12e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e8dcb41f48b06b1b78dcd72de250a579c71e12e"}], "stats": {"total": 1158, "additions": 565, "deletions": 593}, "files": [{"sha": "4c0fa09bff699c0b1379bcb4defc99f101f7a6ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -1,3 +1,14 @@\n+2004-01-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (duplicate_decls): Break apart into...\n+\t(diagnose_arglist_conflict, validate_proto_after_old_defn)\n+\t(locate_old_defn, diagnose_mismatched_decls, merge_decls):\n+\t... these new functions.  Restructure for comprehensibility.\n+\tRemove various archaic special cases.  Always report the\n+\tlocation of the previous declaration when a diagnostic is issued.\n+\t(redeclaration_error_message): Fold into diagnose_mismatched_decls.\n+\t(match_builtin_function_types): Delete unnecessary forward declaration.\n+\n 2004-01-10  Zack Weinberg  <zack@codesourcery.com>\n \n \t* genautomata.c (make_automaton, NDFA_to_DFA):"}, {"sha": "639ad221f2f95f60cab89f9ea78a86f1eaea4aa2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 524, "deletions": 567, "changes": 1091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -306,9 +306,6 @@ tree static_ctors, static_dtors;\n \n static struct c_scope *make_scope (void);\n static void pop_scope (void);\n-static tree match_builtin_function_types (tree, tree);\n-static int duplicate_decls (tree, tree, int, int);\n-static int redeclaration_error_message (tree, tree);\n static tree make_label (tree, location_t);\n static void bind_label (tree, tree, struct c_scope *);\n static void implicit_decl_warning (tree);\n@@ -755,12 +752,12 @@ pushtag (tree name, tree type)\n   TYPE_CONTEXT (type) = DECL_CONTEXT (TYPE_STUB_DECL (type));\n }\n \f\n-/* Subroutine of duplicate_decls.  Allow harmless mismatches in return\n+/* Subroutine of compare_decls.  Allow harmless mismatches in return\n    and argument types provided that the type modes match.  This function\n    return a unified type given a suitable match, and 0 otherwise.  */\n \n static tree\n-match_builtin_function_types (tree oldtype, tree newtype)\n+match_builtin_function_types (tree newtype, tree oldtype)\n {\n   tree newrettype, oldrettype;\n   tree newargs, oldargs;\n@@ -795,580 +792,583 @@ match_builtin_function_types (tree oldtype, tree newtype)\n   return build_type_attribute_variant (trytype, TYPE_ATTRIBUTES (oldtype));\n }\n \n-/* Handle when a new declaration NEWDECL\n-   has the same name as an old one OLDDECL\n-   in the same binding contour.\n-   Prints an error message if appropriate.\n+/* Subroutine of diagnose_mismathed_decls.  Check for function type\n+   mismatch involving an empty arglist vs a nonempty one and give clearer\n+   diagnostics. */\n+static void\n+diagnose_arglist_conflict (tree newdecl, tree olddecl,\n+\t\t\t   tree newtype, tree oldtype)\n+{\n+  tree t;\n \n-   If safely possible, alter OLDDECL to look like NEWDECL, and return 1.\n-   Otherwise, return 0.\n+  if (TREE_CODE (olddecl) != FUNCTION_DECL\n+      || !comptypes (TREE_TYPE (oldtype), TREE_TYPE (newtype), COMPARE_STRICT)\n+      || !((TYPE_ARG_TYPES (oldtype) == 0 && DECL_INITIAL (olddecl) == 0)\n+\t   ||\n+\t   (TYPE_ARG_TYPES (newtype) == 0 && DECL_INITIAL (newdecl) == 0)))\n+    return;\n \n-   When DIFFERENT_BINDING_LEVEL is true, NEWDECL is an external declaration,\n-   and OLDDECL is in an outer scope and should thus not be changed.  */\n+  t = TYPE_ARG_TYPES (oldtype);\n+  if (t == 0)\n+    t = TYPE_ARG_TYPES (newtype);\n+  for (; t; t = TREE_CHAIN (t))\n+    {\n+      tree type = TREE_VALUE (t);\n \n-static int\n-duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n-\t\t int different_tu)\n-{\n-  int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl),\n-\t\t\t       COMPARE_STRICT);\n-  int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n-\t\t\t   && DECL_INITIAL (newdecl) != 0);\n-  tree oldtype = TREE_TYPE (olddecl);\n-  tree newtype = TREE_TYPE (newdecl);\n-  int errmsg = 0;\n+      if (TREE_CHAIN (t) == 0\n+\t  && TYPE_MAIN_VARIANT (type) != void_type_node)\n+\t{\n+\t  inform (\"a parameter list with an ellipsis can't match\"\n+\t\t  \"an empty parameter name list declaration\");\n+\t  break;\n+\t}\n \n-  if (DECL_P (olddecl))\n-    {\n-      if (TREE_CODE (newdecl) == FUNCTION_DECL\n-\t  && TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  && (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl)))\n+      if (c_type_promotes_to (type) != type)\n \t{\n-\t  if (DECL_DECLARED_INLINE_P (newdecl)\n-\t      && DECL_UNINLINABLE (newdecl)\n-\t      && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n-\t    /* Already warned elsewhere.  */;\n-\t  else if (DECL_DECLARED_INLINE_P (olddecl)\n-\t\t   && DECL_UNINLINABLE (olddecl)\n-\t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n-\t    /* Already warned.  */;\n-\t  else if (DECL_DECLARED_INLINE_P (newdecl)\n-\t\t   && ! DECL_DECLARED_INLINE_P (olddecl)\n-\t\t   && DECL_UNINLINABLE (olddecl)\n-\t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n-\t    {\n-\t      warning (\"%Jfunction '%D' redeclared as inline\",\n-\t\t       newdecl, newdecl);\n-\t      warning (\"%Jprevious declaration of function '%D' \"\n-                       \"with attribute noinline\", olddecl, olddecl);\n-\t    }\n-\t  else if (DECL_DECLARED_INLINE_P (olddecl)\n-\t\t   && DECL_UNINLINABLE (newdecl)\n-\t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n-\t    {\n-\t      warning (\"%Jfunction '%D' redeclared with attribute noinline\",\n-                       newdecl, newdecl);\n-\t      warning (\"%Jprevious declaration of function '%D' was inline\",\n-                       olddecl, olddecl);\n-\t    }\n+\t  inform (\"an argument type that has a default promotion can't match\"\n+\t\t  \"an empty parameter name list declaration\");\n+\t  break;\n \t}\n+    }\n+}\n \n-      DECL_ATTRIBUTES (newdecl)\n-\t= (*targetm.merge_decl_attributes) (olddecl, newdecl);\n+/* Another subroutine of diagnose_mismatched_decls.  OLDDECL is an\n+   old-style function definition, NEWDECL is a prototype declaration.\n+   Diagnose inconsistencies in the argument list.  Returns TRUE if\n+   the prototype is compatible, FALSE if not.  */\n+static bool\n+validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n+{\n+  tree type, parm;\n+  int nargs;\n+  /* Prototype decl follows defn w/o prototype.  */\n+\n+  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),\n+\t type = TYPE_ARG_TYPES (newtype),\n+\t nargs = 1;\n+       ;\n+       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type), nargs++)\n+    {\n+      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n+\t  && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n+\t{\n+\t  /* End of list.  */\n+\t  warning (\"%Jprototype for '%D' follows non-prototype definition\",\n+\t\t   newdecl, newdecl);\n+\t  return true;\n+\t}\n+\n+      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n+\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n+\t{\n+\t  error (\"%Jprototype for '%D' with different number of arguments \"\n+\t\t \"follows non-prototype definition\", newdecl, newdecl);\n+\t  return false;\n+\t}\n+      /* Type for passing arg must be consistent\n+\t with that declared for the arg.  */\n+      if (! comptypes (TREE_VALUE (parm), TREE_VALUE (type),\n+\t\t       COMPARE_STRICT))\n+\t{\n+\t  error (\"%Jprototype for '%D' with incompatible argument %d \"\n+\t\t \"follows non-prototype definition\", newdecl, newdecl, nargs);\n+\t  return false;\n+\t}\n     }\n+}\n+\n+/* Subroutine of diagnose_mismatched_decls.  Report the location of DECL,\n+   first in a pair of mismatched declarations, using the diagnostic\n+   function DIAG.  */\n+static void\n+locate_old_decl (tree decl, void (*diag)(const char *, ...))\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))\n+    ;\n+  else if (DECL_INITIAL (decl))\n+    diag (N_(\"%Jprevious definition of '%D' was here\"), decl, decl);\n+  else if (C_DECL_IMPLICIT (decl))\n+    diag (N_(\"%Jprevious implicit declaration of '%D' was here\"), decl, decl);\n+  else\n+    diag (N_(\"%Jprevious declaration of '%D' was here\"), decl, decl);\n+}\n \n-  if (TREE_CODE (newtype) == ERROR_MARK\n-      || TREE_CODE (oldtype) == ERROR_MARK)\n-    types_match = 0;\n+/* Subroutine of duplicate_decls.  Compare NEWDECL to OLDDECL.\n+   Returns true if the caller should proceed to merge the two, false\n+   if OLDDECL should simply be discarded.  As a side effect, issues\n+   all necessary diagnostics for invalid or poor-style combinations.\n+   If it returns true, writes the types of NEWDECL and OLDDECL to\n+   *NEWTYPEP and *OLDTYPEP - these may have been adjusted from\n+   TREE_TYPE (NEWDECL, OLDDECL) respectively.  */\n \n-  /* New decl is completely inconsistent with the old one =>\n-     tell caller to replace the old one.\n-     This is always an error except in the case of shadowing a builtin.  */\n+static bool\n+diagnose_mismatched_decls (tree newdecl, tree olddecl,\n+\t\t\t   tree *newtypep, tree *oldtypep)\n+{\n+  tree newtype, oldtype;\n+  bool pedwarned = false;\n+  bool warned = false;\n+\n+  /* If we have error_mark_node for either decl or type, just discard\n+     the previous decl - we're in an error cascade already.  */\n+  if (olddecl == error_mark_node || newdecl == error_mark_node)\n+    return false;\n+  oldtype = TREE_TYPE (olddecl);\n+  newtype = TREE_TYPE (newdecl);\n+  if (oldtype == error_mark_node || newtype == error_mark_node)\n+    return false;\n+\n+  /* Two different categories of symbol altogether.  This is an error\n+     unless OLDDECL is a builtin.  OLDDECL will be discarded in any case.  */\n   if (TREE_CODE (olddecl) != TREE_CODE (newdecl))\n     {\n-      if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  && DECL_BUILT_IN (olddecl))\n+      if (TREE_CODE (olddecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n \t{\n-\t  /* If you declare a built-in or predefined function name as static,\n-\t     the old definition is overridden,\n-\t     but optionally warn this was a bad choice of name.  */\n-\t  if (!TREE_PUBLIC (newdecl))\n+\t  error (\"%J'%D' redeclared as different kind of symbol\",\n+\t\t newdecl, newdecl);\n+\t  locate_old_decl (olddecl, error);\n+\t}\n+      else if (TREE_PUBLIC (newdecl))\n+\twarning (\"%Jbuilt-in function '%D' declared as non-function\",\n+\t\t newdecl, newdecl);\n+      else if (warn_shadow)\n+\twarning (\"%Jshadowing built-in function '%D'\",\n+\t\t newdecl, newdecl);\n+      return false;\n+    }\n+\n+  if (!comptypes (oldtype, newtype, COMPARE_STRICT))\n+    {\n+      if (TREE_CODE (olddecl) == FUNCTION_DECL && DECL_BUILT_IN (olddecl))\n+\t{\n+\t  /* Accept harmless mismatch in function types.\n+\t     This is for the ffs and fprintf builtins.  */\n+\t  tree trytype = match_builtin_function_types (newtype, oldtype);\n+\n+\t  if (trytype && comptypes (newtype, trytype, COMPARE_STRICT))\n+\t    oldtype = trytype;\n+\t  else\n \t    {\n-\t      if (warn_shadow)\n-\t\twarning (\"%Jshadowing built-in function '%D'\",\n-\t\t\t newdecl, newdecl);\n+\t      /* If types don't match for a built-in, throw away the\n+\t\t built-in.  No point in calling locate_old_decl here, it\n+\t\t won't print anything. */\n+\t      warning (\"%Jconflicting types for built-in function '%D'\",\n+\t\t       newdecl, newdecl);\n+\t      return false;\n \t    }\n-\t  else\n-\t    warning (\"%Jbuilt-in function '%D' declared as non-function\",\n-                     newdecl, newdecl);\n+\t}\n+      else if (TREE_CODE (olddecl) == FUNCTION_DECL\n+\t       && DECL_SOURCE_LINE (olddecl) == 0)\n+\t{\n+\t  /* A conflicting function declaration for a predeclared\n+\t     function that isn't actually built in.  Objective C uses\n+\t     these.  The new declaration silently overrides everything\n+\t     but the volatility (i.e. noreturn) indication.  See also\n+\t     below.  FIXME: Make Objective C use normal builtins.  */\n+\t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n+\t  return false;\n+\t}\n+      /* Permit void foo (...) to match int foo (...) if the latter is\n+\t the definition and implicit int was used.  See\n+\t c-torture/compile/920625-2.c.  */\n+      else if (TREE_CODE (newdecl) == FUNCTION_DECL && DECL_INITIAL (newdecl)\n+\t       && TYPE_MAIN_VARIANT (TREE_TYPE (oldtype)) == void_type_node\n+\t       && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n+\t       && C_FUNCTION_IMPLICIT_INT (newdecl))\n+\t{\n+\t  pedwarn (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n+\t  /* Make sure we keep void as the return type.  */\n+\t  TREE_TYPE (newdecl) = newtype = oldtype;\n+\t  C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n+\t  pedwarned = true;\n \t}\n       else\n \t{\n-\t  error (\"%J'%D' redeclared as different kind of symbol\",\n-\t\t newdecl, newdecl);\n-\t  error (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n+\t  error (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n+\t  diagnose_arglist_conflict (newdecl, olddecl, newtype, oldtype);\n+\t  locate_old_decl (olddecl, error);\n+\t  return false;\n \t}\n-\n-      return 0;\n     }\n \n-  /* For real parm decl following a forward decl, return 1 so old decl\n-     will be reused.  Only allow this to happen once.  */\n-  if (types_match && TREE_CODE (newdecl) == PARM_DECL\n-      && TREE_ASM_WRITTEN (olddecl) && ! TREE_ASM_WRITTEN (newdecl))\n+  /* Redeclaration of a type is a constraint violation (6.7.2.3p1),\n+     but silently ignore the redeclaration if either is in a system\n+     header.  (Conflicting redeclarations were handled above.)  */\n+  if (TREE_CODE (newdecl) == TYPE_DECL)\n     {\n-      TREE_ASM_WRITTEN (olddecl) = 0;\n-      return 1;\n+      if (DECL_IN_SYSTEM_HEADER (newdecl) || DECL_IN_SYSTEM_HEADER (olddecl))\n+\treturn true;  /* allow OLDDECL to continue in use */\n+      \n+      error (\"%Jredefinition of typedef '%D'\", newdecl, newdecl);\n+      locate_old_decl (olddecl, error);\n+      return false;\n     }\n \n-  /* The new declaration is the same kind of object as the old one.\n-     The declarations may partially match.  Print warnings if they don't\n-     match enough.  Ultimately, copy most of the information from the new\n-     decl to the old one, and keep using the old one.  */\n-\n-  if (TREE_CODE (olddecl) == FUNCTION_DECL && DECL_BUILT_IN (olddecl))\n+  /* Function declarations can either be 'static' or 'extern' (no\n+     qualifier is equivalent to 'extern' - C99 6.2.2p5) and therefore\n+     can never conflict with each other on account of linkage (6.2.2p4).\n+     Multiple definitions are not allowed (6.9p3,5) but GCC permits\n+     two definitions if one is 'extern inline' and one is not.  The non-\n+     extern-inline definition supersedes the extern-inline definition.  */\n+  else if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      /* A function declaration for a built-in function.  */\n-      if (!TREE_PUBLIC (newdecl))\n+      if (DECL_BUILT_IN (olddecl) && !TREE_PUBLIC (newdecl))\n \t{\n \t  /* If you declare a built-in function name as static, the\n \t     built-in definition is overridden,\n \t     but optionally warn this was a bad choice of name.  */\n \t  if (warn_shadow)\n \t    warning (\"%Jshadowing built-in function '%D'\", newdecl, newdecl);\n \t  /* Discard the old built-in function.  */\n-\t  return 0;\n+\t  return false;\n \t}\n-      if (!types_match)\n+      \n+      if (DECL_INITIAL (newdecl))\n \t{\n-\t  /* Accept harmless mismatch in function types.\n-\t     This is for the ffs and fprintf builtins.  */\n-\t  tree trytype = match_builtin_function_types (oldtype, newtype);\n-\n-\t  if (trytype)\n+\t  if (DECL_INITIAL (olddecl)\n+\t      && !(DECL_DECLARED_INLINE_P (olddecl)\n+\t\t   && DECL_EXTERNAL (olddecl)\n+\t\t   && !(DECL_DECLARED_INLINE_P (newdecl)\n+\t\t\t&& DECL_EXTERNAL (newdecl))))\n \t    {\n-\t      types_match = comptypes (newtype, trytype, COMPARE_STRICT);\n-\t      if (types_match)\n-\t\toldtype = trytype;\n-\t      if (! different_binding_level)\n-\t\tTREE_TYPE (olddecl) = oldtype;\n+\t      error (\"%Jredefinition of '%D'\", newdecl, newdecl);\n+\t      locate_old_decl (olddecl, error);\n+\t      return false;\n \t    }\n \t}\n-      if (!types_match)\n+      /* If we have a prototype after an old-style function definition,\n+\t the argument types must be checked specially.  */\n+      else if (DECL_INITIAL (olddecl)\n+\t       && !TYPE_ARG_TYPES (oldtype) && TYPE_ARG_TYPES (newtype)\n+\t       && TYPE_ACTUAL_ARG_TYPES (oldtype)\n+\t       && !validate_proto_after_old_defn (newdecl, newtype, oldtype))\n \t{\n-\t  /* If types don't match for a built-in, throw away the built-in.  */\n-\t  warning (\"%Jconflicting types for built-in function '%D'\",\n-\t\t   newdecl, newdecl);\n-\t  return 0;\n+\t  locate_old_decl (olddecl, error);\n+\t  return false;\n+\t}\n+      /* Mismatched non-static and static is considered poor style.\n+         We only diagnose static then non-static if -Wtraditional,\n+\t because it is the most convenient way to get some effects\n+\t (see e.g.  what unwind-dw2-fde-glibc.c does to the definition\n+\t of _Unwind_Find_FDE in unwind-dw2-fde.c).  Revisit?  */\n+      if (TREE_PUBLIC (olddecl) && !TREE_PUBLIC (newdecl))\n+\t{\n+\t  /* A static function declaration for a predeclared function\n+\t     that isn't actually built in, silently overrides the\n+\t     default.  Objective C uses these.  See also above.\n+\t     FIXME: Make Objective C use normal builtins.  */\n+\t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n+\t      && DECL_SOURCE_LINE (olddecl) == 0)\n+\t    return false;\n+\t  else\n+\t    {\n+\t      warning (\"%Jstatic declaration of '%D' follows \"\n+\t\t       \"non-static declaration\", newdecl, newdecl);\n+\t      warned = true;\n+\t    }\n+\t}\n+      else if (TREE_PUBLIC (newdecl) && !TREE_PUBLIC (olddecl)\n+\t       && warn_traditional)\n+\t{\n+\t  warning (\"%Jnon-static declaration of '%D' follows \"\n+\t\t   \"static declaration\", newdecl, newdecl);\n+\t  warned = true;\n \t}\n     }\n-  else if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t   && DECL_SOURCE_LINE (olddecl) == 0)\n+  else if (TREE_CODE (newdecl) == VAR_DECL)\n     {\n-      /* A function declaration for a predeclared function\n-\t that isn't actually built in.  */\n-      if (!TREE_PUBLIC (newdecl))\n+      /* Only variables can be thread-local, and all declarations must\n+\t agree on this property.  */\n+      if (DECL_THREAD_LOCAL (newdecl) != DECL_THREAD_LOCAL (olddecl))\n \t{\n-\t  /* If you declare it as static, the\n-\t     default definition is overridden.  */\n-\t  return 0;\n+\t  if (DECL_THREAD_LOCAL (newdecl))\n+\t    error (\"%Jthread-local declaration of '%D' follows \"\n+\t\t   \"non-thread-local declaration\", newdecl, newdecl);\n+\t  else\n+\t    error (\"%Jnon-thread-local declaration of '%D' follows \"\n+\t\t   \"thread-local declaration\", newdecl, newdecl);\n+\n+\t  locate_old_decl (olddecl, error);\n+\t  return false;\n \t}\n-      else if (!types_match)\n+\n+      /* Multiple initialized definitions are not allowed (6.9p3,5).  */\n+      if (DECL_INITIAL (newdecl) && DECL_INITIAL (olddecl))\n \t{\n-\t  /* If the types don't match, preserve volatility indication.\n-\t     Later on, we will discard everything else about the\n-\t     default declaration.  */\n-\t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n+\t  error (\"%Jredefinition of '%D'\", newdecl, newdecl);\n+\t  locate_old_decl (olddecl, error);\n+\t  return false;\n \t}\n-    }\n-  /* Permit char *foo () to match void *foo (...) if not pedantic,\n-     if one of them came from a system header file.  */\n-  else if (!types_match\n-\t   && TREE_CODE (olddecl) == FUNCTION_DECL\n-\t   && TREE_CODE (newdecl) == FUNCTION_DECL\n-\t   && TREE_CODE (TREE_TYPE (oldtype)) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (newtype)) == POINTER_TYPE\n-\t   && (DECL_IN_SYSTEM_HEADER (olddecl)\n-\t       || DECL_IN_SYSTEM_HEADER (newdecl))\n-\t   && ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (newtype))) == void_type_node\n-\t\t&& TYPE_ARG_TYPES (oldtype) == 0\n-\t\t&& self_promoting_args_p (TYPE_ARG_TYPES (newtype))\n-\t\t&& TREE_TYPE (TREE_TYPE (oldtype)) == char_type_node)\n-\t       ||\n-\t       (TREE_TYPE (TREE_TYPE (newtype)) == char_type_node\n-\t\t&& TYPE_ARG_TYPES (newtype) == 0\n-\t\t&& self_promoting_args_p (TYPE_ARG_TYPES (oldtype))\n-\t\t&& TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)))\n-    {\n-      if (pedantic)\n-\tpedwarn (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n-      /* Make sure we keep void * as ret type, not char *.  */\n-      if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)\n-\tTREE_TYPE (newdecl) = newtype = oldtype;\n-\n-      /* Set DECL_IN_SYSTEM_HEADER, so that if we see another declaration\n-\t we will come back here again.  */\n-      DECL_IN_SYSTEM_HEADER (newdecl) = 1;\n-    }\n-  /* Permit void foo (...) to match int foo (...) if the latter is the\n-     definition and implicit int was used.  See c-torture/compile/920625-2.c.  */\n-  else if (!types_match\t&& new_is_definition\n-\t   && TREE_CODE (olddecl) == FUNCTION_DECL\n-\t   && TREE_CODE (newdecl) == FUNCTION_DECL\n-\t   && TYPE_MAIN_VARIANT (TREE_TYPE (oldtype)) == void_type_node\n-\t   && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n-\t   && C_FUNCTION_IMPLICIT_INT (newdecl))\n-    {\n-      pedwarn (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n-      /* Make sure we keep void as the return type.  */\n-      TREE_TYPE (newdecl) = newtype = oldtype;\n-      C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n-    }\n-  else if (!types_match\n-\t   /* Permit char *foo (int, ...); followed by char *foo ();\n-\t      if not pedantic.  */\n-\t   && ! (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t\t && ! pedantic\n-\t\t /* Return types must still match.  */\n-\t\t && comptypes (TREE_TYPE (oldtype),\n-\t\t\t       TREE_TYPE (newtype), COMPARE_STRICT)\n-\t\t && TYPE_ARG_TYPES (newtype) == 0))\n-    {\n-      error (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n-      /* Check for function type mismatch\n-\t involving an empty arglist vs a nonempty one.  */\n-      if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  && comptypes (TREE_TYPE (oldtype),\n-\t\t\tTREE_TYPE (newtype), COMPARE_STRICT)\n-\t  && ((TYPE_ARG_TYPES (oldtype) == 0\n-\t       && DECL_INITIAL (olddecl) == 0)\n-\t      ||\n-\t      (TYPE_ARG_TYPES (newtype) == 0\n-\t       && DECL_INITIAL (newdecl) == 0)))\n+\n+      /* Objects declared at file scope: if at least one is 'extern',\n+\t it's fine (6.2.2p4); otherwise the linkage must agree (6.2.2p7).  */\n+      if (DECL_FILE_SCOPE_P (newdecl))\n \t{\n-\t  /* Classify the problem further.  */\n-\t  tree t = TYPE_ARG_TYPES (oldtype);\n-\t  if (t == 0)\n-\t    t = TYPE_ARG_TYPES (newtype);\n-\t  for (; t; t = TREE_CHAIN (t))\n+\t  if (!DECL_EXTERNAL (newdecl)\n+\t      && !DECL_EXTERNAL (olddecl)\n+\t      && TREE_PUBLIC (newdecl) != TREE_PUBLIC (olddecl))\n \t    {\n-\t      tree type = TREE_VALUE (t);\n-\n-\t      if (TREE_CHAIN (t) == 0\n-\t\t  && TYPE_MAIN_VARIANT (type) != void_type_node)\n-\t\t{\n-\t\t  error (\"a parameter list with an ellipsis can't match an empty parameter name list declaration\");\n-\t\t  break;\n-\t\t}\n+\t      if (TREE_PUBLIC (newdecl))\n+\t\terror (\"%Jnon-static declaration of '%D' follows \"\n+\t\t       \"static declaration\", newdecl, newdecl);\n+\t      else\n+\t\terror (\"%Jstatic declaration of '%D' follows \"\n+\t\t       \"non-static declaration\", newdecl, newdecl);\n \n-\t      if (c_type_promotes_to (type) != type)\n-\t\t{\n-\t\t  error (\"an argument type that has a default promotion can't match an empty parameter name list declaration\");\n-\t\t  break;\n-\t\t}\n+\t      locate_old_decl (olddecl, error);\n+\t      return false;\n \t    }\n \t}\n-      if (C_DECL_IMPLICIT (olddecl))\n-\terror (\"%Jprevious implicit declaration of '%D'\", olddecl, olddecl);\n-      else\n-\terror (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n+      /* Two objects with the same name declared at the same block\n+\t scope must both be external references (6.7p3).  */\n+      else if (DECL_CONTEXT (newdecl) == DECL_CONTEXT (olddecl)\n+\t       && (!DECL_EXTERNAL (newdecl) || !DECL_EXTERNAL (olddecl)))\n+\t{\n+\t  if (DECL_EXTERNAL (newdecl))\n+\t    error (\"%Jextern declaration of '%D' follows \"\n+\t\t   \"declaration with no linkage\", newdecl, newdecl);\n+\t  else if (DECL_EXTERNAL (olddecl))\n+\t    error (\"%Jdeclaration of '%D' with no linkage follows \"\n+\t\t   \"extern declaration\", newdecl, newdecl);\n+\t  else\n+\t    error (\"%Jredeclaration of '%D' with no linkage\",\n+\t\t   newdecl, newdecl);\n \n-      /* This is safer because the initializer might contain references\n-\t to variables that were declared between olddecl and newdecl. This\n-\t will make the initializer invalid for olddecl in case it gets\n-\t assigned to olddecl below.  */\n-      if (TREE_CODE (newdecl) == VAR_DECL)\n-\tDECL_INITIAL (newdecl) = 0;\n-    }\n-  /* TLS cannot follow non-TLS declaration.  */\n-  else if (TREE_CODE (olddecl) == VAR_DECL && TREE_CODE (newdecl) == VAR_DECL\n-\t   && !DECL_THREAD_LOCAL (olddecl) && DECL_THREAD_LOCAL (newdecl))\n-    {\n-      error (\"%Jthread-local declaration of '%D' follows non thread-local \"\n-             \"declaration\", newdecl, newdecl);\n-      error (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n+\t  locate_old_decl (olddecl, error);\n+\t  return false;\n+\t}\n     }\n-  /* non-TLS declaration cannot follow TLS declaration.  */\n-  else if (TREE_CODE (olddecl) == VAR_DECL && TREE_CODE (newdecl) == VAR_DECL\n-\t   && DECL_THREAD_LOCAL (olddecl) && !DECL_THREAD_LOCAL (newdecl))\n+\n+  /* warnings */\n+  /* All decls must agree on a non-default visibility.  */\n+  if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT\n+      && DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT\n+      && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n-      error (\"%Jnon thread-local declaration of '%D' follows \"\n-             \"thread-local declaration\", newdecl, newdecl);\n-      error (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n+      warning (\"%Jredeclaration of '%D' with different visibility \"\n+\t       \"(old visibility preserved)\", newdecl, newdecl);\n+      warned = true;\n     }\n-  else\n+\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      errmsg = redeclaration_error_message (newdecl, olddecl);\n-      if (errmsg)\n+      /* Diagnose inline __attribute__ ((noinline)) which is silly.  */\n+      if (DECL_DECLARED_INLINE_P (newdecl)\n+\t  && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  switch (errmsg)\n-\t    {\n-\t    case 1:\n-\t      error (\"%Jredefinition of '%D'\", newdecl, newdecl);\n-\t      break;\n-\t    case 2:\n-\t      error (\"%Jredeclaration of '%D'\", newdecl, newdecl);\n-\t      break;\n-\t    case 3:\n-\t      error (\"%Jconflicting declarations of '%D'\", newdecl, newdecl);\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-          if (DECL_INITIAL (olddecl)\n-              && current_scope == global_scope)\n-            error (\"%J'%D' previously defined here\", olddecl, olddecl);\n-          else\n-            error (\"%J'%D' previously declared here\", olddecl, olddecl);\n-\t  return 0;\n+\t  warning (\"%Jinline declaration of '%D' follows \"\n+\t\t   \"declaration with attribute noinline\", newdecl, newdecl);\n+\t  warned = true;\n \t}\n-      else if (TREE_CODE (newdecl) == TYPE_DECL\n-               && (DECL_IN_SYSTEM_HEADER (olddecl)\n-                   || DECL_IN_SYSTEM_HEADER (newdecl)))\n+      else if (DECL_DECLARED_INLINE_P (olddecl)\n+\t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warning (\"%Jredefinition of '%D'\", newdecl, newdecl);\n-          if (DECL_INITIAL (olddecl) && current_scope == global_scope)\n-            warning (\"%J'%D' previously defined here\", olddecl, olddecl);\n-          else\n-            warning (\"%J'%D' previously declared here\", olddecl, olddecl);\n+\t  warning (\"%Jdeclaration of '%D' with attribute noinline follows \"\n+\t\t   \"inline declaration \", newdecl, newdecl);\n+\t  warned = true;\n \t}\n-      else if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t       && DECL_INITIAL (olddecl) != 0\n-\t       && TYPE_ARG_TYPES (oldtype) == 0\n-\t       && TYPE_ARG_TYPES (newtype) != 0\n-\t       && TYPE_ACTUAL_ARG_TYPES (oldtype) != 0)\n+\n+      /* Inline declaration after use or definition.\n+\t ??? Should we still warn about this now we have unit-at-a-time\n+\t mode and can get it right?  */\n+      if (DECL_DECLARED_INLINE_P (newdecl) && !DECL_DECLARED_INLINE_P (olddecl))\n \t{\n-\t  tree type, parm;\n-\t  int nargs;\n-\t  /* Prototype decl follows defn w/o prototype.  */\n-\n-\t  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),\n-\t       type = TYPE_ARG_TYPES (newtype),\n-\t       nargs = 1;\n-\t       ;\n-\t       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type), nargs++)\n+\t  if (TREE_USED (olddecl))\n \t    {\n-\t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n-\t\t  && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n-\t\t{\n-\t\t  warning (\"%Jprototype for '%D' follows\", newdecl, newdecl);\n-\t\t  warning (\"%Jnon-prototype definition here\", olddecl);\n-\t\t  break;\n-\t\t}\n-\t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n-\t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n-\t\t{\n-\t\t  error (\"%Jprototype for '%D' follows and number of \"\n-                         \"arguments doesn't match\", newdecl, newdecl);\n-\t\t  error (\"%Jnon-prototype definition here\", olddecl);\n-\t\t  errmsg = 1;\n-\t\t  break;\n-\t\t}\n-\t      /* Type for passing arg must be consistent\n-\t\t with that declared for the arg.  */\n-\t      if (! comptypes (TREE_VALUE (parm), TREE_VALUE (type),\n-\t\t\t       COMPARE_STRICT))\n-\t\t{\n-\t\t  error (\"%Jprototype for '%D' follows and argument %d \"\n-                         \"doesn't match\", newdecl, newdecl, nargs);\n-\t\t  error (\"%Jnon-prototype definition here\", olddecl);\n-\t\t  errmsg = 1;\n-\t\t  break;\n-\t\t}\n+\t      warning (\"%J'%D' declared inline after being called\");\n+\t      warned = true;\n+\t    }\n+\t  else if (DECL_INITIAL (olddecl))\n+\t    {\n+\t      warning (\"%J'%D' declared inline after its definition\");\n+\t      warned = true;\n \t    }\n \t}\n-      /* Warn about mismatches in various flags.  */\n-      else\n+    }\n+  else /* VAR_DECL */\n+    {\n+      /* These bits are only type qualifiers when applied to objects.  */\n+      if (TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl))\n \t{\n-\t  /* Warn if function is now inline\n-\t     but was previously declared not inline and has been called.  */\n-\t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && ! DECL_DECLARED_INLINE_P (olddecl)\n-\t      && DECL_DECLARED_INLINE_P (newdecl)\n-\t      && TREE_USED (olddecl))\n-\t    warning (\"%J'%D' declared inline after being called\",\n-\t\t     newdecl, newdecl);\n-\t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && ! DECL_DECLARED_INLINE_P (olddecl)\n-\t      && DECL_DECLARED_INLINE_P (newdecl)\n-\t      && DECL_INITIAL (olddecl) != 0)\n-\t    warning (\"%J'%D' declared inline after its definition\",\n-\t\t     newdecl, newdecl);\n-\n-\t  /* If pedantic, warn when static declaration follows a non-static\n-\t     declaration.  Otherwise, do so only for functions.\t */\n-\t  if ((pedantic || TREE_CODE (olddecl) == FUNCTION_DECL)\n-\t      && TREE_PUBLIC (olddecl)\n-\t      && !TREE_PUBLIC (newdecl))\n-\t    warning (\"%Jstatic declaration for '%D' follows non-static\",\n-\t\t     newdecl, newdecl);\n-\n-\t  /* If warn_traditional, warn when a non-static function\n-\t     declaration follows a static one.\t*/\n-\t  if (warn_traditional && !in_system_header\n-\t      && TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && !TREE_PUBLIC (olddecl)\n-\t      && TREE_PUBLIC (newdecl))\n-\t    warning (\"%Jnon-static declaration for '%D' follows static\",\n-\t\t     newdecl, newdecl);\n-\n-\t  /* Warn when const declaration follows a non-const\n-\t     declaration, but not for functions.  */\n-\t  if (TREE_CODE (olddecl) != FUNCTION_DECL\n-\t      && !TREE_READONLY (olddecl)\n-\t      && TREE_READONLY (newdecl))\n-\t    warning (\"%Jconst declaration for '%D' follows non-const\",\n-\t\t     newdecl, newdecl);\n-\t  /* These bits are logically part of the type, for variables.\n-\t     But not for functions\n-\t     (where qualifiers are not valid ANSI anyway).  */\n-\t  else if (pedantic && TREE_CODE (olddecl) != FUNCTION_DECL\n-\t      && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n-\t\t  || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))\n-\t    pedwarn (\"%Jtype qualifiers for '%D' conflict with previous \"\n-\t\t     \"declaration\", newdecl, newdecl);\n+\t  if (TREE_THIS_VOLATILE (newdecl))\n+\t    pedwarn (\"%Jvolatile declaration of '%D' follows \"\n+\t\t     \"non-volatile declaration\", newdecl, newdecl);\n+\t  else\n+\t    pedwarn (\"%Jnon-volatile declaration of '%D' follows \"\n+\t\t     \"volatile declaration\", newdecl, newdecl);\n+\t  pedwarned = true;\n+\t}\n+      if (TREE_READONLY (newdecl) != TREE_READONLY (olddecl))\n+\t{\n+\t  if (TREE_READONLY (newdecl))\n+\t    pedwarn (\"%Jconst declaration of '%D' follows \"\n+\t\t     \"non-const declaration\", newdecl, newdecl);\n+\t  else\n+\t    pedwarn (\"%Jnon-const declaration of '%D' follows \"\n+\t\t     \"const declaration\", newdecl, newdecl);\n+\t  pedwarned = true;\n \t}\n     }\n \n-  /* Optionally warn about more than one declaration for the same name.  */\n-  if (errmsg == 0 && warn_redundant_decls && DECL_SOURCE_LINE (olddecl) != 0\n-      /* Don't warn about a function declaration\n-\t followed by a definition.  */\n-      && !(TREE_CODE (newdecl) == FUNCTION_DECL && DECL_INITIAL (newdecl) != 0\n-\t   && DECL_INITIAL (olddecl) == 0)\n-      /* Don't warn about extern decl followed by (tentative) definition.  */\n-      && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl)))\n+  /* Optional warning for completely redundant decls.  */\n+  if (!warned && !pedwarned\n+      && warn_redundant_decls\n+      /* Don't warn about a function declaration followed by a\n+\t definition.  */\n+    && !(TREE_CODE (newdecl) == FUNCTION_DECL\n+\t && DECL_INITIAL (newdecl) && !DECL_INITIAL (olddecl))\n+    /* Don't warn about an extern followed by a definition.  */\n+    && !(DECL_EXTERNAL (olddecl) && !DECL_EXTERNAL (newdecl)))\n     {\n-      warning (\"%Jredundant redeclaration of '%D' in same scope\",\n-\t       newdecl, newdecl);\n-      warning (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n+      warning (\"%Jredundant redeclaration of '%D'\", newdecl, newdecl);\n+      warned = true;\n     }\n \n-  /* Copy all the DECL_... slots specified in the new decl\n-     except for any that we copy here from the old type.\n+  /* Report location of previous decl/defn in a consistent manner.  */\n+  if (warned || pedwarned)\n+    locate_old_decl (olddecl, pedwarned ? pedwarn : warning);\n+\n+  *newtypep = newtype;\n+  *oldtypep = oldtype;\n+  return true;\n+}\n \n-     Past this point, we don't change OLDTYPE and NEWTYPE\n-     even if we change the types of NEWDECL and OLDDECL.  */\n+/* Subroutine of duplicate_decls.  NEWDECL has been found to be\n+   consistent with OLDDECL, but carries new information.  Merge the\n+   new information into OLDDECL.  If DIFFERENT_BINDING_LEVEL or\n+   DIFFERENT_TU is true, avoid completely merging the decls, as this\n+   will break assumptions elsewhere.  This function issues no\n+   diagnostics.  */\n \n-  if (types_match)\n+static void\n+merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n+\t     bool different_binding_level, bool different_tu)\n+{\n+  int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n+\t\t\t   && DECL_INITIAL (newdecl) != 0);\n+\n+  /* When copying info to olddecl, we store into write_olddecl\n+     instead.  This allows us to avoid modifying olddecl when\n+     different_binding_level is true.  */\n+  tree write_olddecl = different_binding_level ? newdecl : olddecl;\n+\n+  /* For real parm decl following a forward decl, return 1 so old decl\n+     will be reused.  Only allow this to happen once.  */\n+  if (TREE_CODE (newdecl) == PARM_DECL\n+      && TREE_ASM_WRITTEN (olddecl) && ! TREE_ASM_WRITTEN (newdecl))\n     {\n-      /* When copying info to olddecl, we store into write_olddecl\n-\t instead.  This allows us to avoid modifying olddecl when\n-\t different_binding_level is true.  */\n-      tree write_olddecl = different_binding_level ? newdecl : olddecl;\n+      TREE_ASM_WRITTEN (olddecl) = 0;\n+      return;\n+    }\n+\n+  DECL_ATTRIBUTES (newdecl)\n+    = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n \n-      /* Merge the data types specified in the two decls.  */\n-      if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n+  /* Merge the data types specified in the two decls.  */\n+  if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n+    {\n+      if (different_binding_level)\n \t{\n-\t  if (different_binding_level)\n-\t    {\n-\t      if (TYPE_ARG_TYPES (oldtype) != 0\n-\t\t  && TYPE_ARG_TYPES (newtype) == 0)\n-\t\tTREE_TYPE (newdecl) = common_type (newtype, oldtype);\n-\t      else\n-\t\tTREE_TYPE (newdecl)\n-\t\t  = build_type_attribute_variant\n-\t\t    (newtype,\n-\t\t     merge_attributes (TYPE_ATTRIBUTES (newtype),\n-\t\t\t\t       TYPE_ATTRIBUTES (oldtype)));\n-\t    }\n+\t  if (TYPE_ARG_TYPES (oldtype) != 0\n+\t      && TYPE_ARG_TYPES (newtype) == 0)\n+\t    TREE_TYPE (newdecl) = common_type (newtype, oldtype);\n \t  else\n \t    TREE_TYPE (newdecl)\n-\t      = TREE_TYPE (olddecl)\n-\t\t= common_type (newtype, oldtype);\n-\t}\n-\n-      /* Lay the type out, unless already done.  */\n-      if (oldtype != TREE_TYPE (newdecl))\n-\t{\n-\t  if (TREE_TYPE (newdecl) != error_mark_node)\n-\t    layout_type (TREE_TYPE (newdecl));\n-\t  if (TREE_CODE (newdecl) != FUNCTION_DECL\n-\t      && TREE_CODE (newdecl) != TYPE_DECL\n-\t      && TREE_CODE (newdecl) != CONST_DECL)\n-\t    layout_decl (newdecl, 0);\n+\t      = build_type_attribute_variant\n+\t      (newtype,\n+\t       merge_attributes (TYPE_ATTRIBUTES (newtype),\n+\t\t\t\t TYPE_ATTRIBUTES (oldtype)));\n \t}\n       else\n-\t{\n-\t  /* Since the type is OLDDECL's, make OLDDECL's size go with.  */\n-\t  DECL_SIZE (newdecl) = DECL_SIZE (olddecl);\n-\t  DECL_SIZE_UNIT (newdecl) = DECL_SIZE_UNIT (olddecl);\n-\t  DECL_MODE (newdecl) = DECL_MODE (olddecl);\n-\t  if (TREE_CODE (olddecl) != FUNCTION_DECL)\n-\t    if (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))\n-\t      {\n-\t\tDECL_ALIGN (newdecl) = DECL_ALIGN (olddecl);\n-\t\tDECL_USER_ALIGN (newdecl) |= DECL_ALIGN (olddecl);\n-\t      }\n-\t}\n+\tTREE_TYPE (newdecl)\n+\t  = TREE_TYPE (olddecl)\n+\t  = common_type (newtype, oldtype);\n+    }\n \n-      /* Keep the old rtl since we can safely use it.  */\n-      COPY_DECL_RTL (olddecl, newdecl);\n+  /* Lay the type out, unless already done.  */\n+  if (oldtype != TREE_TYPE (newdecl))\n+    {\n+      if (TREE_TYPE (newdecl) != error_mark_node)\n+\tlayout_type (TREE_TYPE (newdecl));\n+      if (TREE_CODE (newdecl) != FUNCTION_DECL\n+\t  && TREE_CODE (newdecl) != TYPE_DECL\n+\t  && TREE_CODE (newdecl) != CONST_DECL)\n+\tlayout_decl (newdecl, 0);\n+    }\n+  else\n+    {\n+      /* Since the type is OLDDECL's, make OLDDECL's size go with.  */\n+      DECL_SIZE (newdecl) = DECL_SIZE (olddecl);\n+      DECL_SIZE_UNIT (newdecl) = DECL_SIZE_UNIT (olddecl);\n+      DECL_MODE (newdecl) = DECL_MODE (olddecl);\n+      if (TREE_CODE (olddecl) != FUNCTION_DECL)\n+\tif (DECL_ALIGN (olddecl) > DECL_ALIGN (newdecl))\n+\t  {\n+\t    DECL_ALIGN (newdecl) = DECL_ALIGN (olddecl);\n+\t    DECL_USER_ALIGN (newdecl) |= DECL_ALIGN (olddecl);\n+\t  }\n+    }\n \n-      /* Merge the type qualifiers.  */\n-      if (TREE_READONLY (newdecl))\n-\tTREE_READONLY (write_olddecl) = 1;\n+  /* Keep the old rtl since we can safely use it.  */\n+  COPY_DECL_RTL (olddecl, newdecl);\n \n-      if (TREE_THIS_VOLATILE (newdecl))\n-\t{\n-\t  TREE_THIS_VOLATILE (write_olddecl) = 1;\n-\t  if (TREE_CODE (newdecl) == VAR_DECL\n-\t      /* If an automatic variable is re-declared in the same\n-\t\t function scope, but the old declaration was not\n-\t\t volatile, make_var_volatile() would crash because the\n-\t\t variable would have been assigned to a pseudo, not a\n-\t\t MEM.  Since this duplicate declaration is invalid\n-\t\t anyway, we just skip the call.  */\n-\t      && errmsg == 0)\n-\t    make_var_volatile (newdecl);\n-\t}\n+  /* Merge the type qualifiers.  */\n+  if (TREE_READONLY (newdecl))\n+    TREE_READONLY (write_olddecl) = 1;\n \n-      /* Keep source location of definition rather than declaration.  */\n-      /* When called with different_binding_level set, keep the old\n-\t information so that meaningful diagnostics can be given.  */\n-      if (DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0\n-\t  && ! different_binding_level)\n-\tDECL_SOURCE_LOCATION (newdecl) = DECL_SOURCE_LOCATION (olddecl);\n-\n-      /* Merge the unused-warning information.  */\n-      if (DECL_IN_SYSTEM_HEADER (olddecl))\n-\tDECL_IN_SYSTEM_HEADER (newdecl) = 1;\n-      else if (DECL_IN_SYSTEM_HEADER (newdecl))\n-\tDECL_IN_SYSTEM_HEADER (write_olddecl) = 1;\n-\n-      /* Merge the initialization information.  */\n-      /* When called with different_binding_level set, don't copy over\n-\t DECL_INITIAL, so that we don't accidentally change function\n-\t declarations into function definitions.  */\n-      if (DECL_INITIAL (newdecl) == 0 && ! different_binding_level)\n-\tDECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n-\n-      /* Merge the section attribute.\n-         We want to issue an error if the sections conflict but that must be\n-\t done later in decl_attributes since we are called before attributes\n-\t are assigned.  */\n-      if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n-\tDECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n-\n-      /* Copy the assembler name.\n-\t Currently, it can only be defined in the prototype.  */\n-      COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n-\n-      /* If either declaration has a nondefault visibility, use it.  */\n-      if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)\n-\t{\n-\t  if (DECL_VISIBILITY (newdecl) != VISIBILITY_DEFAULT\n-\t      && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n-\t    {\n-\t      warning (\"%J'%D': visibility attribute ignored because it\",\n-\t\t       newdecl, newdecl);\n-\t      warning (\"%Jconflicts with previous declaration here\", olddecl);\n-\t    }\n-\t  DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n-\t}\n+  if (TREE_THIS_VOLATILE (newdecl))\n+    {\n+      TREE_THIS_VOLATILE (write_olddecl) = 1;\n+      if (TREE_CODE (newdecl) == VAR_DECL)\n+\tmake_var_volatile (newdecl);\n+    }\n+\n+  /* Keep source location of definition rather than declaration.  */\n+  /* When called with different_binding_level set, keep the old\n+     information so that meaningful diagnostics can be given.  */\n+  if (DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0\n+      && ! different_binding_level)\n+    DECL_SOURCE_LOCATION (newdecl) = DECL_SOURCE_LOCATION (olddecl);\n+\n+  /* Merge the unused-warning information.  */\n+  if (DECL_IN_SYSTEM_HEADER (olddecl))\n+    DECL_IN_SYSTEM_HEADER (newdecl) = 1;\n+  else if (DECL_IN_SYSTEM_HEADER (newdecl))\n+    DECL_IN_SYSTEM_HEADER (write_olddecl) = 1;\n+\n+  /* Merge the initialization information.  */\n+  /* When called with different_binding_level set, don't copy over\n+     DECL_INITIAL, so that we don't accidentally change function\n+     declarations into function definitions.  */\n+  if (DECL_INITIAL (newdecl) == 0 && ! different_binding_level)\n+    DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+\n+  /* Merge the section attribute.\n+     We want to issue an error if the sections conflict but that must be\n+     done later in decl_attributes since we are called before attributes\n+     are assigned.  */\n+  if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n+    DECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n+\n+  /* Copy the assembler name.\n+     Currently, it can only be defined in the prototype.  */\n+  COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n+\n+  /* If either declaration has a nondefault visibility, use it.  */\n+  if (DECL_VISIBILITY (olddecl) != VISIBILITY_DEFAULT)\n+    DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n \n-      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-\t{\n-\t  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n-\t  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n-\t  DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n-\t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n-\t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n-\t  TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n-\t  TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n-\t  DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n-\t  DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n-\t}\n-    }\n-  /* If cannot merge, then use the new type and qualifiers,\n-     and don't preserve the old rtl.  */\n-  else if (! different_binding_level)\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n-      TREE_READONLY (olddecl) = TREE_READONLY (newdecl);\n-      TREE_THIS_VOLATILE (olddecl) = TREE_THIS_VOLATILE (newdecl);\n-      TREE_SIDE_EFFECTS (olddecl) = TREE_SIDE_EFFECTS (newdecl);\n+      DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n+      DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n+      DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);\n+      DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n+\t|= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n+      TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);\n+      TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);\n+      DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);\n+      DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n     }\n \n   /* Merge the storage class information.  */\n@@ -1448,9 +1448,9 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \n       if (DECL_BUILT_IN (olddecl))\n \t{\n-\t  /* Get rid of any built-in function if new arg types don't match it\n-\t     or if we have a function definition.  */\n-\t  if (! types_match || new_is_definition)\n+\t  /* Get rid of any built-in function if we have a function\n+\t     definition.  */\n+\t  if (new_is_definition)\n \t    {\n \t      if (! different_binding_level)\n \t\t{\n@@ -1502,7 +1502,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t}\n     }\n   if (different_binding_level)\n-    return 0;\n+    return;\n \n   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID.  */\n@@ -1515,10 +1515,6 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n     DECL_UID (olddecl) = olddecl_uid;\n   }\n \n-  /* NEWDECL contains the merged attribute lists.\n-     Update OLDDECL to be the same.  */\n-  DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);\n-\n   /* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl\n      so that encode_section_info has a chance to look at the new decl\n      flags and attributes.  */\n@@ -1527,10 +1523,34 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t  || (TREE_CODE (olddecl) == VAR_DECL\n \t      && TREE_STATIC (olddecl))))\n     make_decl_rtl (olddecl, NULL);\n-\n-  return 1;\n }\n \n+/* Handle when a new declaration NEWDECL has the same name as an old\n+   one OLDDECL in the same binding contour.  Prints an error message\n+   if appropriate.\n+\n+   If safely possible, alter OLDDECL to look like NEWDECL, and return\n+   true.  Otherwise, return false.\n+\n+   When DIFFERENT_BINDING_LEVEL is true, NEWDECL is an external\n+   declaration, and OLDDECL is in an outer scope and should thus not\n+   be changed.  */\n+\n+static bool\n+duplicate_decls (tree newdecl, tree olddecl,\n+\t\t bool different_binding_level, bool different_tu)\n+{\n+  tree newtype, oldtype;\n+\n+  if (!diagnose_mismatched_decls (newdecl, olddecl, &newtype, &oldtype))\n+    return false;\n+\n+  merge_decls (newdecl, olddecl, newtype, oldtype,\n+\t       different_binding_level, different_tu);\n+  return !different_binding_level;\n+}\n+  \n+\f\n /* Return any external DECL associated with ID, whether or not it is\n    currently in scope.  */\n \n@@ -1890,69 +1910,6 @@ implicit_decl_warning (tree id)\n     warning (\"implicit declaration of function `%s'\", name);\n }\n \n-/* Return zero if the declaration NEWDECL is valid\n-   when the declaration OLDDECL (assumed to be for the same name)\n-   has already been seen.\n-   Otherwise return 1 if NEWDECL is a redefinition, 2 if it is a redeclaration,\n-   and 3 if it is a conflicting declaration.  */\n-\n-static int\n-redeclaration_error_message (tree newdecl, tree olddecl)\n-{\n-  if (TREE_CODE (newdecl) == TYPE_DECL)\n-    {\n-      /* Do not complain about type redeclarations where at least one\n-\t declaration was in a system header.  */\n-      if (DECL_IN_SYSTEM_HEADER (olddecl) || DECL_IN_SYSTEM_HEADER (newdecl))\n-\treturn 0;\n-      return 1;\n-    }\n-  else if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-    {\n-      /* Declarations of functions can insist on internal linkage\n-\t but they can't be inconsistent with internal linkage,\n-\t so there can be no error on that account.\n-\t However defining the same name twice is no good.  */\n-      if (DECL_INITIAL (olddecl) != 0 && DECL_INITIAL (newdecl) != 0\n-\t  /* However, defining once as extern inline and a second\n-\t     time in another way is ok.  */\n-\t  && ! (DECL_DECLARED_INLINE_P (olddecl) && DECL_EXTERNAL (olddecl)\n-\t       && ! (DECL_DECLARED_INLINE_P (newdecl)\n-\t\t     && DECL_EXTERNAL (newdecl))))\n-\treturn 1;\n-      return 0;\n-    }\n-  else if (DECL_FILE_SCOPE_P (newdecl))\n-    {\n-      /* Objects declared at file scope:  */\n-      /* If at least one is a reference, it's ok.  */\n-      if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n-\treturn 0;\n-      /* Reject two definitions.  */\n-      if (DECL_INITIAL (olddecl) != 0 && DECL_INITIAL (newdecl) != 0)\n-\treturn 1;\n-      /* Now we have two tentative defs, or one tentative and one real def.  */\n-      /* Insist that the linkage match.  */\n-      if (TREE_PUBLIC (olddecl) != TREE_PUBLIC (newdecl))\n-\treturn 3;\n-      return 0;\n-    }\n-  else if (current_scope->parm_flag\n-\t   && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl))\n-    return 0;\n-  else\n-    {\n-      /* Newdecl has block scope.  If olddecl has block scope also, then\n-\t reject two definitions, and reject a definition together with an\n-\t external reference.  Otherwise, it is OK, because newdecl must\n-\t be an extern reference to olddecl.  */\n-      if (!(DECL_EXTERNAL (newdecl) && DECL_EXTERNAL (olddecl))\n-\t  && DECL_CONTEXT (newdecl) == DECL_CONTEXT (olddecl))\n-\treturn 2;\n-      return 0;\n-    }\n-}\n-\n /* Issue an error message for a reference to an undeclared variable\n    ID, including a reference to a builtin outside of function-call\n    context.  Establish a binding of the identifier to error_mark_node"}, {"sha": "2d7b5067e19fe20f9c68ec29da16e9d058887ef5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -1,3 +1,10 @@\n+2004-01-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/Wshadow-1.c, gcc.dg/attr-noinline.c, gcc.dg/decl3.c\n+\t* gcc.dg/redecl-1.c, gcc.dg/visibility-7.c, gcc.dg/wtr-static-1.c\n+\t* gcc.dg/noncompile/20020220-1.c, objc.dg/method-1.m:\n+\tUpdate dg-error regexps.\n+\n 2004-01-10  Zack Weinberg  <zack@codesourcery.com>\n \n \t* gcc.c-torture/compile/20021123-2.c: Delete; dup of 20021120-1.c."}, {"sha": "c4553a435614bf7a05f488d47db0ed841978f4ca", "filename": "gcc/testsuite/gcc.dg/Wshadow-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-1.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -10,7 +10,7 @@ void foo (double decl1)\t\t/* { dg-warning \"shadows a global decl\" } */\n {\t\t\t\t\n }\n \n-void foo1 (int d)\t\t/* { dg-warning \"previous declaration\" } */\n+void foo1 (int d)\t\t/* { dg-warning \"previous definition\" } */\n {\n   double d;\t /* { dg-bogus \"warning\" \"warning in place of error\" } */\n   /* { dg-error \"redeclared as different\" \"\" { target *-*-* } 15 } */"}, {"sha": "9124e4f76886830d66e74b7354414efc900f65e7", "filename": "gcc/testsuite/gcc.dg/attr-noinline.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -13,33 +13,33 @@ static inline void __attribute__((__noinline__)) function_declaration_both_after\n \n static void function_declaration_both_after(void) {}\n \n-static void function_declaration_noinline_before(void) __attribute__((__noinline__)); /* { dg-warning \"previous declaration \\[^\\n\\]* with attribute noinline\" \"\" } */\n+static void function_declaration_noinline_before(void) __attribute__((__noinline__)); /* { dg-warning \"previous declaration\" \"\" } */\n \n-static inline void function_declaration_noinline_before(void) {} /* { dg-warning \"function \\[^\\n\\]* redeclared as inline\" \"\" } */\n+static inline void function_declaration_noinline_before(void) {} /* { dg-warning \"follows declaration with attribute noinline\" \"\" } */\n \n-static inline void function_declaration_noinline_after(void) {} /* { dg-warning \"previous declaration \\[^\\n\\]* was inline\" \"\" } */\n+static inline void function_declaration_noinline_after(void) {} /* { dg-warning \"previous definition\" \"\" } */\n \n-static void function_declaration_noinline_after(void) __attribute__((__noinline__)); /* { dg-warning \"function \\[^\\n\\]* redeclared with attribute noinline\" \"\" } */\n+static void function_declaration_noinline_after(void) __attribute__((__noinline__)); /* { dg-warning \"follows inline declaration\" \"\" } */\n \n-static inline void function_declaration_inline_before(void); /* { dg-warning \"previous declaration \\[^\\n\\]* was inline\" \"\" } */\n+static inline void function_declaration_inline_before(void); /* { dg-warning \"previous declaration\" \"\" } */\n \n-static void __attribute__((__noinline__)) function_declaration_inline_before(void) {} /* { dg-warning \"function \\[^\\n\\]* redeclared with attribute noinline\" \"\" } */\n+static void __attribute__((__noinline__)) function_declaration_inline_before(void) {} /* { dg-warning \"follows inline declaration\" \"\" } */\n \n-static inline void function_declaration_inline_noinline_before(void); /* { dg-warning \"previous declaration \\[^\\n\\]* was inline\" \"\" } */\n+static inline void function_declaration_inline_noinline_before(void); /* { dg-warning \"previous declaration\" \"\" } */\n \n-static void function_declaration_inline_noinline_before(void) __attribute__((__noinline__)); /* { dg-warning \"function \\[^\\n\\]* redeclared with attribute noinline\" \"\" } */\n+static void function_declaration_inline_noinline_before(void) __attribute__((__noinline__)); /* { dg-warning \"follows inline declaration\" \"\" } */\n \n static void function_declaration_inline_noinline_before(void) {}\n \n static inline void function_declaration_inline_noinline_after(void);\n \n-static void function_declaration_inline_noinline_after(void) {} /* { dg-warning \"previous declaration \\[^\\n\\]* was inline\" \"\" } */\n+static void function_declaration_inline_noinline_after(void) {} /* { dg-warning \"previous definition\" \"\" } */\n \n-static void function_declaration_inline_noinline_after(void) __attribute__((__noinline__)); /* { dg-warning \"function \\[^\\n\\]* redeclared with attribute noinline\" \"\" } */\n+static void function_declaration_inline_noinline_after(void) __attribute__((__noinline__)); /* { dg-warning \"follows inline declaration\" \"\" } */\n \n-static void function_declaration_noinline_inline_before(void) __attribute__((__noinline__)); /* { dg-warning \"previous declaration\\[^\\n\\]* with attribute noinline\" \"\" } */\n+static void function_declaration_noinline_inline_before(void) __attribute__((__noinline__)); /* { dg-warning \"previous declaration\" \"\" } */\n \n-static inline void function_declaration_noinline_inline_before(void); /* { dg-warning \"function \\[^\\n\\]* redeclared as inline\" \"\" } */\n+static inline void function_declaration_noinline_inline_before(void); /* { dg-warning \"follows declaration with attribute noinline\" \"\" } */\n \n static void function_declaration_noinline_inline_before(void) {}\n "}, {"sha": "2bfac89c1360baca44db3cd01de389a1551b2b09", "filename": "gcc/testsuite/gcc.dg/decl-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fdecl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fdecl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdecl-3.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -1,5 +1,5 @@\n /* PR c/9928 */\n /* { dg-do compile } */\n \n-enum { CODES }; /* { dg-error \"previous declaration\" } */\n+enum { CODES }; /* { dg-error \"previous definition\" } */\n enum { CODES }; /* { dg-error \"conflicting types\" } */"}, {"sha": "079daf01e2fc7c3a71e59b1a4ac01289117c097f", "filename": "gcc/testsuite/gcc.dg/noncompile/20020213-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -24,7 +24,6 @@ int main ()\n   return 0;\n }\n \n-/* { dg-warning \"passing arg 2 of\" \"2nd incompatible\" { target *-*-* } 15 } */\n /* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 16 } */\n /* { dg-warning \"passing arg 2 of\" \"2nd incompatible\" { target *-*-* } 16 } */\n /* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 18 } */"}, {"sha": "aa57dc3d4932ab93df176805abea96d545c1894f", "filename": "gcc/testsuite/gcc.dg/noncompile/20020220-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020220-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020220-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020220-1.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -6,7 +6,7 @@ int foo (const char*, const char*);\n void bar (void)\n {\n   const char *s = \"bar\";\n-  int i;\t\t\t/* { dg-error \"previously declared here\" } */\n+  int i;\t\t\t/* { dg-error \"previous declaration\" } */\n   int size = 2;\n   int i = foo (s, s + size);\t/* { dg-error \"redeclaration of\" } */\n }"}, {"sha": "09b70d7b6cdc0afc18d5a0c2304b2f3e97eb4722", "filename": "gcc/testsuite/gcc.dg/redecl-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-1.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -74,7 +74,7 @@ void test5(void)\n \n /* Extern then static, both at file scope.  */\n \n-extern int test6(int);\t\t/* { dg-warning \"previous\" \"\" { xfail *-*-* } } */\n+extern int test6(int);\t\t/* { dg-warning \"previous\" \"\" } */\n static int test6(int x)\t\t\t\n { return x; }\t\t\t/* { dg-warning \"follows non-static\" } */\n \n@@ -83,7 +83,7 @@ static int test6(int x)\n \n void prime7(void)\n {\n-  extern int test7(int);\t/* { dg-warning \"previous\" \"\" { xfail *-*-* } } */\n+  extern int test7(int);\t/* { dg-warning \"previous\" \"\" } */\n }\n \n static int test7(int x)\n@@ -93,7 +93,7 @@ static int test7(int x)\n \n void prime8(void)\n {\n-  test8();\t\t\t/* { dg-warning \"previous\" \"\" { xfail *-*-* } } */\n+  test8();\t\t\t/* { dg-warning \"previous\" \"\" } */\n                                 /* { dg-warning \"implicit\" \"\" { target *-*-* } 96 } */\n }\n "}, {"sha": "5bdc2b0280864c00daa4ae6b7e1f44f35878a3ef", "filename": "gcc/testsuite/gcc.dg/visibility-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-7.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -5,8 +5,8 @@\n \n extern int \n __attribute__((visibility (\"hidden\")))\n-xyzzy; /* { dg-warning \"previous declaration here\" \"\" } */\n+xyzzy; /* { dg-warning \"previous declaration\" \"\" } */\n \n int \n __attribute__((visibility (\"protected\")))\n-xyzzy = 5; /* { dg-warning \"visibility attribute ignored\" \"\" } */\n+xyzzy = 5; /* { dg-warning \"different visibility\" \"\" } */"}, {"sha": "42760e8cf6bcfff62f32eae84566294ec0d3c0f9", "filename": "gcc/testsuite/gcc.dg/wtr-static-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-static-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-static-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-static-1.c?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -4,7 +4,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-Wtraditional\" } */\n \n-static void testfunc1(void);\n+static void testfunc1(void); /* { dg-warning \"previous declaration\" } */\n void testfunc1() {} /* { dg-warning \"non-static.*follows static\" \"non-static follows static\" } */\n \n # 11 \"sys-header.h\" 3"}, {"sha": "a73a0f4921d3b6e7dc8567e62c67aab25a7abf13", "filename": "gcc/testsuite/objc.dg/method-1.m", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c6e6fbf11745d2c583c15a18f53f63cd889d301/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fmethod-1.m?ref=3c6e6fbf11745d2c583c15a18f53f63cd889d301", "patch": "@@ -16,17 +16,15 @@ - (int) meth1;\n @end\n \n @implementation class3\n-- (int) meth1 { return 0; }\n+- (int) meth1 { return 0; } /* { dg-error \"previous definition\" } */\n - (int) meth1 { return 0; } /* { dg-error \"redefinition of\" } */\n-/* { dg-error \"previously defined here\" \"\" { target *-*-* } 19 } */\n @end\n \n @interface class4\n + (void) meth1;\n @end\n \n @implementation class4\n-+ (void) meth1 {}\n++ (void) meth1 {} /* { dg-error \"previous definition\" } */\n + (void) meth1 {} /* { dg-error \"redefinition of\" } */\n-/* { dg-error \"previously defined here\" \"\" { target *-*-* } 29 } */\n @end"}]}