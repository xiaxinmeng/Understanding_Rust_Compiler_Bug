{"sha": "8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1N2M4MzhlMmExMGQ3YzMyYTk5MWZkYzg2NDlhM2RmZWFhNmE5NA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-30T23:15:40Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-30T23:15:40Z"}, "message": "gimple-ssa-sprintf.c (fmtresult::adjust_for_width_or_precision): Move constant to the right of a relational operator.\n\ngcc/ChangeLog:\n\t* gimple-ssa-sprintf.c (fmtresult::adjust_for_width_or_precision):\n\tMove constant to the right of a relational operator.\n\t(get_mpfr_format_length, format_character, format_string): Ditto.\n\t(should_warn_p, maybe_warn): Same.\n\nFrom-SVN: r245040", "tree": {"sha": "037abbb5e66e568d8ed3bc9fe0208efa6038aae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/037abbb5e66e568d8ed3bc9fe0208efa6038aae7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fec56cf14675d1fcd5281c3e8bdfa0350894259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fec56cf14675d1fcd5281c3e8bdfa0350894259", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fec56cf14675d1fcd5281c3e8bdfa0350894259"}], "stats": {"total": 33, "additions": 19, "deletions": 14}, "files": [{"sha": "7a9d9b1c097eb4efcb7ec71eaf8ba40479392094", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "patch": "@@ -6,6 +6,11 @@\n \n 2017-01-30  Martin Sebor  <msebor@redhat.com>\n \n+\t* gimple-ssa-sprintf.c (fmtresult::adjust_for_width_or_precision):\n+\tMove constant to the right of a relational operator.\n+\t(get_mpfr_format_length, format_character, format_string): Ditto.\n+\t(should_warn_p, maybe_warn): Same.\n+\n \t* doc/invoke.texi (-Wformat-truncation=1): Fix typo.\n \n 2017-01-30  Maxim Ostapenko  <m.ostapenko@samsung.com>"}, {"sha": "11f41741f95f38d389226590f08111f548974649", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8657c838e2a10d7c32a991fdc8649a3dfeaa6a94/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=8657c838e2a10d7c32a991fdc8649a3dfeaa6a94", "patch": "@@ -520,7 +520,7 @@ fmtresult::adjust_for_width_or_precision (const HOST_WIDE_INT adjust[2],\n   bool minadjusted = false;\n \n   /* Adjust the minimum and likely counters.  */\n-  if (0 <= adjust[0])\n+  if (adjust[0] >= 0)\n     {\n       if (range.min < (unsigned HOST_WIDE_INT)adjust[0])\n \t{\n@@ -537,7 +537,7 @@ fmtresult::adjust_for_width_or_precision (const HOST_WIDE_INT adjust[2],\n     knownrange = false;\n \n   /* Adjust the maximum counter.  */\n-  if (0 < adjust[1])\n+  if (adjust[1] > 0)\n     {\n       if (range.max < (unsigned HOST_WIDE_INT)adjust[1])\n \t{\n@@ -1456,7 +1456,7 @@ get_mpfr_format_length (mpfr_ptr x, const char *flags, HOST_WIDE_INT prec,\n     {\n       /* Cap precision arbitrarily at 1KB and add the difference\n \t (if any) to the MPFR result.  */\n-      if (1024 < prec)\n+      if (prec > 1024)\n \tp = 1024;\n     }\n \n@@ -1873,7 +1873,7 @@ format_character (const directive &dir, tree arg)\n \t      res.range.likely = 0;\n \t      res.range.unlikely = 0;\n \t    }\n-\t  else if (0 < min && min < 128)\n+\t  else if (min > 0 && min < 128)\n \t    {\n \t      /* A wide character in the ASCII range most likely results\n \t\t in a single byte, and only unlikely in up to MB_LEN_MAX.  */\n@@ -1942,7 +1942,7 @@ format_string (const directive &dir, tree arg)\n \t     2 * wcslen (S).*/\n \t  res.range.likely = res.range.min * 2;\n \n-\t  if (0 <= dir.prec[1]\n+\t  if (dir.prec[1] >= 0\n \t      && (unsigned HOST_WIDE_INT)dir.prec[1] < res.range.max)\n \t    {\n \t      res.range.max = dir.prec[1];\n@@ -1952,7 +1952,7 @@ format_string (const directive &dir, tree arg)\n \n \t  if (dir.prec[0] < 0 && dir.prec[1] > -1)\n \t    res.range.min = 0;\n-\t  else if (0 <= dir.prec[0])\n+\t  else if (dir.prec[0] >= 0)\n \t    res.range.likely = dir.prec[0];\n \n \t  /* Even a non-empty wide character string need not convert into\n@@ -1992,7 +1992,7 @@ format_string (const directive &dir, tree arg)\n \t in mode 2, and the maximum is PRECISION or -1 to disable\n \t tracking.  */\n \n-      if (0 <= dir.prec[0])\n+      if (dir.prec[0] >= 0)\n \t{\n \t  if (slen.range.min >= target_int_max ())\n \t    slen.range.min = 0;\n@@ -2054,15 +2054,15 @@ should_warn_p (const pass_sprintf_length::call_info &info,\n \n   if (info.bounded)\n     {\n-      if (1 == warn_format_trunc && result.min <= avail.max\n+      if (warn_format_trunc == 1 && result.min <= avail.max\n \t  && info.retval_used ())\n \t{\n \t  /* The likely amount of space remaining in the destination is big\n \t     enough for the least output and the return value is used.  */\n \t  return false;\n \t}\n \n-      if (1 == warn_format_trunc && result.likely <= avail.likely\n+      if (warn_format_trunc == 1 && result.likely <= avail.likely\n \t  && !info.retval_used ())\n \t{\n \t  /* The likely amount of space remaining in the destination is big\n@@ -2082,7 +2082,7 @@ should_warn_p (const pass_sprintf_length::call_info &info,\n     }\n   else\n     {\n-      if (1 == warn_level && result.likely <= avail.likely)\n+      if (warn_level == 1 && result.likely <= avail.likely)\n \t{\n \t  /* The likely amount of space remaining in the destination is big\n \t     enough for the likely output.  */\n@@ -2196,7 +2196,7 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t\t  navail);\n \t}\n \n-      if (0 == res.min && res.max < maxbytes)\n+      if (res.min == 0 && res.max < maxbytes)\n \t{\n \t  const char* fmtstr\n \t    = (info.bounded\n@@ -2213,7 +2213,7 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t\t  res.max, navail);\n \t}\n \n-      if (0 == res.min && maxbytes <= res.max)\n+      if (res.min == 0 && maxbytes <= res.max)\n \t{\n \t  /* This is a special case to avoid issuing the potentially\n \t     confusing warning:\n@@ -2325,7 +2325,7 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t      avail_range.min, avail_range.max);\n     }\n \n-  if (0 == res.min && res.max < maxbytes)\n+  if (res.min == 0 && res.max < maxbytes)\n     {\n       const char* fmtstr\n \t= (info.bounded\n@@ -2344,7 +2344,7 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t      avail_range.min, avail_range.max);\n     }\n \n-  if (0 == res.min && maxbytes <= res.max)\n+  if (res.min == 0 && maxbytes <= res.max)\n     {\n       /* This is a special case to avoid issuing the potentially confusing\n \t warning:"}]}