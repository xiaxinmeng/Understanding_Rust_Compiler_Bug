{"sha": "8944b5b36e04894f7a0768440e3253400c3c7857", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk0NGI1YjM2ZTA0ODk0ZjdhMDc2ODQ0MGUzMjUzNDAwYzNjNzg1Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:02:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:02:53Z"}, "message": "poly_int: compute_data_ref_alignment\n\nThis patch makes vect_compute_data_ref_alignment treat DR_INIT as a\npoly_int and handles cases in which the calculated misalignment might\nnot be constant.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment):\n\tTreat drb->init as a poly_int.  Fail if its misalignment wrt\n\tvector_alignment isn't known.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255935", "tree": {"sha": "766896dfe4d80dff7d71436e756913e05a53633e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/766896dfe4d80dff7d71436e756913e05a53633e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8944b5b36e04894f7a0768440e3253400c3c7857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8944b5b36e04894f7a0768440e3253400c3c7857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8944b5b36e04894f7a0768440e3253400c3c7857", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8944b5b36e04894f7a0768440e3253400c3c7857/comments", "author": null, "committer": null, "parents": [{"sha": "a696bc4fec986318a1765c31ac9ee2db3849934a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a696bc4fec986318a1765c31ac9ee2db3849934a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a696bc4fec986318a1765c31ac9ee2db3849934a"}], "stats": {"total": 28, "additions": 25, "deletions": 3}, "files": [{"sha": "6d924992054a5fbe426d1e350d1c556f29a64ad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8944b5b36e04894f7a0768440e3253400c3c7857/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8944b5b36e04894f7a0768440e3253400c3c7857/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8944b5b36e04894f7a0768440e3253400c3c7857", "patch": "@@ -1,3 +1,11 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment):\n+\tTreat drb->init as a poly_int.  Fail if its misalignment wrt\n+\tvector_alignment isn't known.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "014862a5b1b588a095a1b824c91e6c028a76c377", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8944b5b36e04894f7a0768440e3253400c3c7857/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8944b5b36e04894f7a0768440e3253400c3c7857/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=8944b5b36e04894f7a0768440e3253400c3c7857", "patch": "@@ -944,8 +944,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       DR_VECT_AUX (dr)->base_misaligned = true;\n       base_misalignment = 0;\n     }\n-  unsigned int misalignment = (base_misalignment\n-\t\t\t       + TREE_INT_CST_LOW (drb->init));\n+  poly_int64 misalignment\n+    = base_misalignment + wi::to_poly_offset (drb->init).force_shwi ();\n \n   /* If this is a backward running DR then first access in the larger\n      vectype actually is N-1 elements before the address in the DR.\n@@ -955,7 +955,21 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n     misalignment += ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n \t\t     * TREE_INT_CST_LOW (drb->step));\n \n-  SET_DR_MISALIGNMENT (dr, misalignment & (vector_alignment - 1));\n+  unsigned int const_misalignment;\n+  if (!known_misalignment (misalignment, vector_alignment,\n+\t\t\t   &const_misalignment))\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"Non-constant misalignment for access: \");\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t}\n+      return true;\n+    }\n+\n+  SET_DR_MISALIGNMENT (dr, const_misalignment);\n \n   if (dump_enabled_p ())\n     {"}]}