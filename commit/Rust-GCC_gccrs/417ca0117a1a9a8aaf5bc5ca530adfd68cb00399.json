{"sha": "417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3Y2EwMTE3YTFhOWE4YWFmNWJjNWNhNTMwYWRmZDY4Y2IwMDM5OQ==", "commit": {"author": {"name": "Torsten Duwe", "email": "duwe@suse.de", "date": "2017-07-25T14:16:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-07-25T14:16:10Z"}, "message": "c-attribs.c (c_common_attribute_table): Add entry for \"patchable_function_entry\".\n\n2017-07-07  Torsten Duwe  <duwe@suse.de>\n\n        c-family/\n\t* c-attribs.c (c_common_attribute_table): Add entry for\n\t\"patchable_function_entry\".\n\n        lto/\n\t* lto-lang.c (lto_attribute_table): Add entry for\n\t\"patchable_function_entry\".\n\n\t* common.opt: Introduce -fpatchable-function-entry\n\tcommand line option, and its variables function_entry_patch_area_size\n\tand function_entry_patch_area_start.\n\t* opts.c (common_handle_option): Add -fpatchable_function_entry_ case,\n\tincluding a two-value parser.\n\t* target.def (print_patchable_function_entry): New target hook.\n\t* targhooks.h (default_print_patchable_function_entry): New function.\n\t* targhooks.c (default_print_patchable_function_entry): Likewise.\n\t* toplev.c (process_options): Switch off IPA-RA if\n\tpatchable function entries are being generated.\n\t* varasm.c (assemble_start_function): Look at the\n\tpatchable-function-entry command line switch and current\n\tfunction attributes and maybe generate NOP instructions by\n\tcalling the print_patchable_function_entry hook.\n\t* doc/extend.texi: Document patchable_function_entry attribute.\n\t* doc/invoke.texi: Document -fpatchable_function_entry\n\tcommand line option.\n\t* doc/tm.texi.in (TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY):\n\tNew target hook.\n\t* doc/tm.texi: Re-generate.\n\n\t* c-c++-common/patchable_function_entry-default.c: New test.\n\t* c-c++-common/patchable_function_entry-decl.c: Likewise.\n\t* c-c++-common/patchable_function_entry-definition.c: Likewise.\n\nFrom-SVN: r250521", "tree": {"sha": "c8993d80cd0cc0675b2677e7902c261e0625dd63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8993d80cd0cc0675b2677e7902c261e0625dd63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/comments", "author": null, "committer": null, "parents": [{"sha": "774cccdc1a36493ae6925148c08dfbdcb2789e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774cccdc1a36493ae6925148c08dfbdcb2789e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774cccdc1a36493ae6925148c08dfbdcb2789e0c"}], "stats": {"total": 319, "additions": 318, "deletions": 1}, "files": [{"sha": "242d89dfd4ff83700e984c702b49a2fce27e282b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -1,3 +1,26 @@\n+2017-07-07  Torsten Duwe  <duwe@suse.de>\n+\n+\t* common.opt: Introduce -fpatchable-function-entry\n+\tcommand line option, and its variables function_entry_patch_area_size\n+\tand function_entry_patch_area_start.\n+\t* opts.c (common_handle_option): Add -fpatchable_function_entry_ case,\n+\tincluding a two-value parser.\n+\t* target.def (print_patchable_function_entry): New target hook.\n+\t* targhooks.h (default_print_patchable_function_entry): New function.\n+\t* targhooks.c (default_print_patchable_function_entry): Likewise.\n+\t* toplev.c (process_options): Switch off IPA-RA if\n+\tpatchable function entries are being generated.\n+\t* varasm.c (assemble_start_function): Look at the\n+\tpatchable-function-entry command line switch and current\n+\tfunction attributes and maybe generate NOP instructions by\n+\tcalling the print_patchable_function_entry hook.\n+\t* doc/extend.texi: Document patchable_function_entry attribute.\n+\t* doc/invoke.texi: Document -fpatchable_function_entry\n+\tcommand line option.\n+\t* doc/tm.texi.in (TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY):\n+\tNew target hook.\n+\t* doc/tm.texi: Re-generate.\n+\n 2017-07-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/81532"}, {"sha": "a457a6c78e4cd4d1bda1dba4342c554e4b675546", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -1,3 +1,8 @@\n+2017-07-07  Torsten Duwe  <duwe@suse.de>\n+\n+\t* c-attribs.c (c_common_attribute_table): Add entry for\n+\t\"patchable_function_entry\".\n+\n 2017-07-20  Nathan Sidwell  <nathan@acm.org>\n \n \tRemove TYPE_METHODS."}, {"sha": "ecb00c1d5b9ec56226ce351d0a4f39a879f0f936", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -142,6 +142,8 @@ static tree handle_bnd_variable_size_attribute (tree *, tree, tree, int, bool *)\n static tree handle_bnd_legacy (tree *, tree, tree, int, bool *);\n static tree handle_bnd_instrument (tree *, tree, tree, int, bool *);\n static tree handle_fallthrough_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t       int, bool *);\n \n /* Table of machine-independent attributes common to all C-like languages.\n \n@@ -351,6 +353,9 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_bnd_instrument, false },\n   { \"fallthrough\",\t      0, 0, false, false, false,\n \t\t\t      handle_fallthrough_attribute, false },\n+  { \"patchable_function_entry\",\t1, 2, true, false, false,\n+\t\t\t      handle_patchable_function_entry_attribute,\n+\t\t\t      false },\n   { NULL,                     0, 0, false, false, false, NULL, false }\n };\n \n@@ -3260,3 +3265,10 @@ handle_fallthrough_attribute (tree *, tree name, tree, int,\n   *no_add_attrs = true;\n   return NULL_TREE;\n }\n+\n+static tree\n+handle_patchable_function_entry_attribute (tree *, tree, tree, int, bool *)\n+{\n+  /* Nothing to be done here.  */\n+  return NULL_TREE;\n+}"}, {"sha": "78cfa568a95d1da7cae0402311c6ecabf1e2b9e5", "filename": "gcc/common.opt", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -163,6 +163,13 @@ bool flag_stack_usage_info = false\n Variable\n int flag_debug_asm\n \n+; How many NOP insns to place at each function entry by default\n+Variable\n+HOST_WIDE_INT function_entry_patch_area_size\n+\n+; And how far the real asm entry point is into this area\n+Variable\n+HOST_WIDE_INT function_entry_patch_area_start\n \n ; Balance between GNAT encodings and standard DWARF to emit.\n Variable\n@@ -2030,6 +2037,10 @@ fprofile-reorder-functions\n Common Report Var(flag_profile_reorder_functions)\n Enable function reordering that improves code placement.\n \n+fpatchable-function-entry=\n+Common Joined Optimization\n+Insert NOP instructions at each function entry.\n+\n frandom-seed\n Common Var(common_deferred_options) Defer\n "}, {"sha": "562666e82638d58f95c7fc11451dfde8c56068bb", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -3105,6 +3105,27 @@ that affect more than one function.\n This attribute should be used for debugging purposes only.  It is not\n suitable in production code.\n \n+@item patchable_function_entry\n+@cindex @code{patchable_function_entry} function attribute\n+@cindex extra NOP instructions at the function entry point\n+In case the target's text segment can be made writable at run time by\n+any means, padding the function entry with a number of NOPs can be\n+used to provide a universal tool for instrumentation.\n+\n+The @code{patchable_function_entry} function attribute can be used to\n+change the number of NOPs to any desired value.  The two-value syntax\n+is the same as for the command-line switch\n+@option{-fpatchable-function-entry=N,M}, generating @var{N} NOPs, with\n+the function entry point before the @var{M}th NOP instruction.\n+@var{M} defaults to 0 if omitted e.g. function entry point is before\n+the first NOP.\n+\n+If patchable function entries are enabled globally using the command-line\n+option @option{-fpatchable-function-entry=N,M}, then you must disable\n+instrumentation on all functions that are part of the instrumentation\n+framework with the attribute @code{patchable_function_entry (0)}\n+to prevent recursion.\n+\n @item pure\n @cindex @code{pure} function attribute\n @cindex functions that have no side effects"}, {"sha": "a6da37c82033e5b4b870e66c2283708b3824cfec", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -11519,6 +11519,34 @@ of the function name, it is considered to be a match.  For C99 and C++\n extended identifiers, the function name must be given in UTF-8, not\n using universal character names.\n \n+@item -fpatchable-function-entry=@var{N}[,@var{M}]\n+@opindex fpatchable-function-entry\n+Generate @var{N} NOPs right at the beginning\n+of each function, with the function entry point before the @var{M}th NOP.\n+If @var{M} is omitted, it defaults to @code{0} so the\n+function entry points to the address just at the first NOP.\n+The NOP instructions reserve extra space which can be used to patch in\n+any desired instrumentation at run time, provided that the code segment\n+is writable.  The amount of space is controllable indirectly via\n+the number of NOPs; the NOP instruction used corresponds to the instruction\n+emitted by the internal GCC back-end interface @code{gen_nop}.  This behavior\n+is target-specific and may also depend on the architecture variant and/or\n+other compilation options.\n+\n+For run-time identification, the starting addresses of these areas,\n+which correspond to their respective function entries minus @var{M},\n+are additionally collected in the @code{__patchable_function_entries}\n+section of the resulting binary.\n+\n+Note that the value of @code{__attribute__ ((patchable_function_entry\n+(N,M)))} takes precedence over command-line option\n+@option{-fpatchable-function-entry=N,M}.  This can be used to increase\n+the area size or to remove it completely on a single function.\n+If @code{N=0}, no pad location is recorded.\n+\n+The NOP instructions are inserted at---and maybe before, depending on\n+@var{M}---the function entry address, even before the prologue.\n+\n @end table\n \n "}, {"sha": "23e85c7afea9f8d788ba0e609e9618cbb29404de", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -4573,6 +4573,15 @@ will select the smallest suitable mode.\n This section describes the macros that output function entry\n (@dfn{prologue}) and exit (@dfn{epilogue}) code.\n \n+@deftypefn {Target Hook} void TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY (FILE *@var{file}, unsigned HOST_WIDE_INT @var{patch_area_size}, bool @var{record_p})\n+Generate a patchable area at the function start, consisting of\n+@var{patch_area_size} NOP instructions.  If the target supports named\n+sections and if @var{record_p} is true, insert a pointer to the current\n+location in the table of patchable functions.  The default implementation\n+of the hook places the table of pointers in the special section named\n+@code{__patchable_function_entries}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_ASM_FUNCTION_PROLOGUE (FILE *@var{file}, HOST_WIDE_INT @var{size})\n If defined, a function that outputs the assembler code for entry to a\n function.  The prologue is responsible for setting up the stack frame,"}, {"sha": "6df08a2c477a7e186edbe54163896a53d6b42b78", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -3650,6 +3650,8 @@ will select the smallest suitable mode.\n This section describes the macros that output function entry\n (@dfn{prologue}) and exit (@dfn{epilogue}) code.\n \n+@hook TARGET_ASM_PRINT_PATCHABLE_FUNCTION_ENTRY\n+\n @hook TARGET_ASM_FUNCTION_PROLOGUE\n \n @hook TARGET_ASM_FUNCTION_END_PROLOGUE"}, {"sha": "cfe8178b8874e993b0dc4e2d7b18d500cd510cc3", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -1,3 +1,8 @@\n+2017-07-07  Torsten Duwe  <duwe@suse.de>\n+\n+\t* lto-lang.c (lto_attribute_table): Add entry for\n+\t\"patchable_function_entry\".\n+\n 2017-07-19  Nathan Sidwell  <nathan@acm.org>\n \n \t* lto.c (mentions_vars_p_type): Use TYPE_{MIN,MAX}_VALUE_RAW."}, {"sha": "6e9a138fa3b6ce4f4d63f39de8f8a646e4d86057", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -48,6 +48,8 @@ static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_transaction_pure_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t       int, bool *);\n static tree ignore_attribute (tree *, tree, tree, int, bool *);\n \n static tree handle_format_attribute (tree *, tree, tree, int, bool *);\n@@ -76,6 +78,9 @@ const struct attribute_spec lto_attribute_table[] =\n \t\t\t      handle_nonnull_attribute, false },\n   { \"nothrow\",                0, 0, true,  false, false,\n \t\t\t      handle_nothrow_attribute, false },\n+  { \"patchable_function_entry\", 1, 2, true, false, false,\n+\t\t\t      handle_patchable_function_entry_attribute,\n+\t\t\t      false },\n   { \"returns_twice\",          0, 0, true,  false, false,\n \t\t\t      handle_returns_twice_attribute, false },\n   { \"sentinel\",               0, 1, false, true, true,\n@@ -473,6 +478,13 @@ handle_returns_twice_attribute (tree *node, tree ARG_UNUSED (name),\n   return NULL_TREE;\n }\n \n+static tree\n+handle_patchable_function_entry_attribute (tree *, tree, tree, int, bool *)\n+{\n+  /* Nothing to be done here.  */\n+  return NULL_TREE;\n+}\n+\n /* Ignore the given attribute.  Used when this attribute may be usefully\n    overridden by the target, but is not used generically.  */\n "}, {"sha": "ec45a0fca7bd5ca86151a982997e73f194b1f192", "filename": "gcc/opts.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -2207,6 +2207,33 @@ common_handle_option (struct gcc_options *opts,\n         opts->x_flag_ipa_reference = false;\n       break;\n \n+    case OPT_fpatchable_function_entry_:\n+      {\n+\tchar *patch_area_arg = xstrdup (arg);\n+\tchar *comma = strchr (patch_area_arg, ',');\n+\tif (comma)\n+\t  {\n+\t    *comma = '\\0';\n+\t    function_entry_patch_area_size = \n+\t      integral_argument (patch_area_arg);\n+\t    function_entry_patch_area_start =\n+\t      integral_argument (comma + 1);\n+\t  }\n+\telse\n+\t  {\n+\t    function_entry_patch_area_size =\n+\t      integral_argument (patch_area_arg);\n+\t    function_entry_patch_area_start = 0;\n+\t  }\n+\tif (function_entry_patch_area_size < 0\n+\t    || function_entry_patch_area_start < 0\n+\t    || function_entry_patch_area_size \n+\t\t< function_entry_patch_area_start)\n+\t  error (\"invalid arguments for %<-fpatchable_function_entry%>\");\n+\tfree (patch_area_arg);\n+      }\n+      break;\n+\n     case OPT_ftree_vectorize:\n       if (!opts_set->x_flag_tree_loop_vectorize)\n         opts->x_flag_tree_loop_vectorize = value;"}, {"sha": "6d67b1fe8bae42dfec2d26f79367804f35459394", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -288,6 +288,17 @@ hidden, protected or internal visibility as specified by @var{visibility}.\",\n  void, (tree decl, int visibility),\n  default_assemble_visibility)\n \n+DEFHOOK\n+(print_patchable_function_entry,\n+ \"Generate a patchable area at the function start, consisting of\\n\\\n+@var{patch_area_size} NOP instructions.  If the target supports named\\n\\\n+sections and if @var{record_p} is true, insert a pointer to the current\\n\\\n+location in the table of patchable functions.  The default implementation\\n\\\n+of the hook places the table of pointers in the special section named\\n\\\n+@code{__patchable_function_entries}.\",\n+ void, (FILE *file, unsigned HOST_WIDE_INT patch_area_size, bool record_p),\n+ default_print_patchable_function_entry)\n+\n /* Output the assembler code for entry to a function.  */\n DEFHOOK\n (function_prologue,"}, {"sha": "6a8fae656d037f635f6958a767f7b6f0e203c6f9", "filename": "gcc/targhooks.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -73,6 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"expr.h\"\n #include \"output.h\"\n+#include \"common/common-target.h\"\n #include \"reload.h\"\n #include \"intl.h\"\n #include \"opts.h\"\n@@ -1610,6 +1611,51 @@ default_compare_by_pieces_branch_ratio (machine_mode)\n   return 1;\n }\n \n+/* Write PATCH_AREA_SIZE NOPs into the asm outfile FILE around a function\n+   entry.  If RECORD_P is true and the target supports named sections,\n+   the location of the NOPs will be recorded in a special object section\n+   called \"__patchable_function_entries\".  This routine may be called\n+   twice per function to put NOPs before and after the function\n+   entry.  */\n+\n+void\n+default_print_patchable_function_entry (FILE *file,\n+\t\t\t\t\tunsigned HOST_WIDE_INT patch_area_size,\n+\t\t\t\t\tbool record_p)\n+{\n+  const char *nop_templ = 0;\n+  int code_num;\n+  rtx_insn *my_nop = make_insn_raw (gen_nop ());\n+\n+  /* We use the template alone, relying on the (currently sane) assumption\n+     that the NOP template does not have variable operands.  */\n+  code_num = recog_memoized (my_nop);\n+  nop_templ = get_insn_template (code_num, my_nop);\n+\n+  if (record_p && targetm_common.have_named_sections)\n+    {\n+      char buf[256];\n+      static int patch_area_number;\n+      section *previous_section = in_section;\n+\n+      patch_area_number++;\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPFE\", patch_area_number);\n+\n+      switch_to_section (get_section (\"__patchable_function_entries\",\n+\t\t\t\t      0, NULL));\n+      fputs (integer_asm_op (POINTER_SIZE_UNITS, false), file);\n+      assemble_name_raw (file, buf);\n+      fputc ('\\n', file);\n+\n+      switch_to_section (previous_section);\n+      ASM_OUTPUT_LABEL (file, buf);\n+    }\n+\n+  unsigned i;\n+  for (i = 0; i < patch_area_size; ++i)\n+    fprintf (file, \"\\t%s\\n\", nop_templ);\n+}\n+\n bool\n default_profile_before_prologue (void)\n {"}, {"sha": "c73ea0bda2096ff0f4807c83385c60eb9bdb7409", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -203,6 +203,9 @@ extern bool default_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT,\n \t\t\t\t\t\t    bool);\n extern int default_compare_by_pieces_branch_ratio (machine_mode);\n \n+extern void default_print_patchable_function_entry (FILE *,\n+\t\t\t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t    bool);\n extern bool default_profile_before_prologue (void);\n extern reg_class_t default_preferred_reload_class (rtx, reg_class_t);\n extern reg_class_t default_preferred_output_reload_class (rtx, reg_class_t);"}, {"sha": "d8515ed3ed4b4e905e056e6791ee623aa832b104", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -1,3 +1,9 @@\n+2017-07-07  Torsten Duwe  <duwe@suse.de>\n+\n+\t* c-c++-common/patchable_function_entry-default.c: New test.\n+\t* c-c++-common/patchable_function_entry-decl.c: Likewise.\n+\t* c-c++-common/patchable_function_entry-definition.c: Likewise.\n+\n 2017-07-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/81532"}, {"sha": "8514b10e820597e3a484dda468d4ce6e60622903", "filename": "gcc/testsuite/c-c++-common/patchable_function_entry-decl.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-decl.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fpatchable-function-entry=3,1\" } */\n+/* { dg-final { scan-assembler-times \"nop\" 2 } } */\n+\n+extern int a;\n+\n+/* Respect overriding attributes in the declaration.  */\n+int f3 (void) __attribute__((patchable_function_entry(2)));\n+\n+/* F3 should now get 2 NOPs.  */\n+int\n+__attribute__((noinline))\n+f3 (void)\n+{\n+  return 5*a;\n+}"}, {"sha": "0dcf1181dde93a2920cd07bf8c83ce40e259bc60", "filename": "gcc/testsuite/c-c++-common/patchable_function_entry-default.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-default.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-default.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-default.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fpatchable-function-entry=3,1\" } */\n+/* { dg-final { scan-assembler-times \"nop\" 3 } } */\n+\n+extern int a;\n+\n+/* Nothing declared must not mean anything.  */\n+int f3 (void);\n+\n+/* F3 should get a default-sized NOP area.  */\n+int\n+__attribute__((noinline))\n+f3 (void)\n+{\n+  return 5*a;\n+}"}, {"sha": "a007867dcb0a966aa4341ca0654ed51b6e9faed2", "filename": "gcc/testsuite/c-c++-common/patchable_function_entry-definition.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-definition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-definition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpatchable_function_entry-definition.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fpatchable-function-entry=3,1\" } */\n+/* { dg-final { scan-assembler-times \"nop\" 1 } } */\n+\n+extern int a;\n+\n+int f3 (void);\n+\n+/* F3 should now get 1 NOP.  */\n+int\n+__attribute__((noinline))\n+__attribute__((patchable_function_entry(1)))\n+f3 (void)\n+{\n+  return 5*a;\n+}"}, {"sha": "b28f1847c839c825fb315dbb360318e48274aa25", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -1630,8 +1630,10 @@ process_options (void)\n     }\n \n  /* Do not use IPA optimizations for register allocation if profiler is active\n+    or patchable function entries are inserted for run-time instrumentation\n     or port does not emit prologue and epilogue as RTL.  */\n-  if (profile_flag || !targetm.have_prologue () || !targetm.have_epilogue ())\n+  if (profile_flag || function_entry_patch_area_size\n+      || !targetm.have_prologue () || !targetm.have_epilogue ())\n     flag_ipa_ra = 0;\n \n   /* Enable -Werror=coverage-mismatch when -Werror and -Wno-error"}, {"sha": "6eccbe4b3f72d88f0542373026fc0d3fde9bf8ff", "filename": "gcc/varasm.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/417ca0117a1a9a8aaf5bc5ca530adfd68cb00399/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=417ca0117a1a9a8aaf5bc5ca530adfd68cb00399", "patch": "@@ -1825,6 +1825,46 @@ assemble_start_function (tree decl, const char *fnname)\n   if (DECL_PRESERVE_P (decl))\n     targetm.asm_out.mark_decl_preserved (fnname);\n \n+  unsigned HOST_WIDE_INT patch_area_size = function_entry_patch_area_size;\n+  unsigned HOST_WIDE_INT patch_area_entry = function_entry_patch_area_start;\n+\n+  tree patchable_function_entry_attr\n+    = lookup_attribute (\"patchable_function_entry\", DECL_ATTRIBUTES (decl));\n+  if (patchable_function_entry_attr)\n+    {\n+      tree pp_val = TREE_VALUE (patchable_function_entry_attr);\n+      tree patchable_function_entry_value1 = TREE_VALUE (pp_val);\n+\n+      if (tree_fits_uhwi_p (patchable_function_entry_value1))\n+\tpatch_area_size = tree_to_uhwi (patchable_function_entry_value1);\n+      else\n+\tgcc_unreachable ();\n+\n+      patch_area_entry = 0;\n+      if (list_length (pp_val) > 1)\n+\t{\n+\t  tree patchable_function_entry_value2 =\n+\t    TREE_VALUE (TREE_CHAIN (pp_val));\n+\n+\t  if (tree_fits_uhwi_p (patchable_function_entry_value2))\n+\t    patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+\n+  if (patch_area_entry > patch_area_size)\n+    {\n+      if (patch_area_size > 0)\n+\twarning (OPT_Wattributes, \"Patchable function entry > size\");\n+      patch_area_entry = 0;\n+    }\n+\n+  /* Emit the patching area before the entry label, if any.  */\n+  if (patch_area_entry > 0)\n+    targetm.asm_out.print_patchable_function_entry (asm_out_file,\n+\t\t\t\t\t\t    patch_area_entry, true);\n+\n   /* Do any machine/system dependent processing of the function name.  */\n #ifdef ASM_DECLARE_FUNCTION_NAME\n   ASM_DECLARE_FUNCTION_NAME (asm_out_file, fnname, current_function_decl);\n@@ -1833,6 +1873,12 @@ assemble_start_function (tree decl, const char *fnname)\n   ASM_OUTPUT_FUNCTION_LABEL (asm_out_file, fnname, current_function_decl);\n #endif /* ASM_DECLARE_FUNCTION_NAME */\n \n+  /* And the area after the label.  Record it if we haven't done so yet.  */\n+  if (patch_area_size > patch_area_entry)\n+    targetm.asm_out.print_patchable_function_entry (asm_out_file,\n+\t\t\t\t\t     patch_area_size-patch_area_entry,\n+\t\t\t\t\t\t    patch_area_entry == 0);\n+\n   if (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (decl)))\n     saw_no_split_stack = true;\n }"}]}