{"sha": "83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkMmIzYjlkYzY5MTE2ODcxOWIwYzc3YmM1YzlhNGQxMGU2Mzg0Yg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-14T00:46:57Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-14T00:46:57Z"}, "message": "cccp.c: PROTO -> PARAMS.\n\n\t* cccp.c: PROTO -> PARAMS.\n\t* cexp.y: Likewise.\n\t* collect2.c: Likewise.\n\t* combine.c: Likewise.\n\t* convert.h: Likewise.\n\t* cse.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* dbxout.h: Likewise.\n\t* diagnostic.c: Likewise.\n\t* doprint.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* dwarf2out.h: Likewise.\n\t* dwarfout.c: Likewise.\n\t* dwarfout.h: Likewise.\n\t* dyn-string.h: Likewise.\n\nFrom-SVN: r31399", "tree": {"sha": "777969cebe29c86ba06933f784b922ec19ce6063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/777969cebe29c86ba06933f784b922ec19ce6063"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/comments", "author": null, "committer": null, "parents": [{"sha": "57bed15271e83402b6d8d6647f6589718e70916d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57bed15271e83402b6d8d6647f6589718e70916d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57bed15271e83402b6d8d6647f6589718e70916d"}], "stats": {"total": 1654, "additions": 840, "deletions": 814}, "files": [{"sha": "d19d122b416000c1d50615500641b1b22526f23a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,3 +1,21 @@\n+2000-01-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cccp.c: PROTO -> PARAMS.\n+\t* cexp.y: Likewise.\n+\t* collect2.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* convert.h: Likewise.\n+\t* cse.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* dbxout.h: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* doprint.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* dwarf2out.h: Likewise.\n+\t* dwarfout.c: Likewise.\n+\t* dwarfout.h: Likewise.\n+\t* dyn-string.h: Likewise.\n+\n 2000-01-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* calls.c (emit_call_1): Wrap varaible `struct_value_size_rtx' in"}, {"sha": "910a98d263d2eff4dd0bf84adcd143e140954e3b", "filename": "gcc/cccp.c", "status": "modified", "additions": 129, "deletions": 127, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -96,8 +96,8 @@ static void hack_vms_include_specification ();\n /* External declarations.  */\n \n extern char *version_string;\n-HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n-HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n+HOST_WIDEST_INT parse_escape PARAMS ((char **, HOST_WIDEST_INT));\n+HOST_WIDEST_INT parse_c_expression PARAMS ((char *, int));\n \f\n /* Name under which this program was invoked.  */\n \n@@ -749,7 +749,7 @@ static int assertions_flag;\n \f\n /* `struct directive' defines one #-directive, including how to handle it.  */\n \n-#define DO_PROTO PROTO((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *))\n+#define DO_PROTO PARAMS ((U_CHAR *, U_CHAR *, FILE_BUF *, struct directive *))\n \n struct directive {\n   int length;\t\t\t/* Length of name */\n@@ -869,163 +869,165 @@ static int deps_column;\n    so don't look for #include \"foo\" the source-file directory.  */\n static int ignore_srcdir;\n \f\n-static int safe_read PROTO((int, char *, int));\n-static void safe_write PROTO((int, const char *, int));\n+static int safe_read PARAMS ((int, char *, int));\n+static void safe_write PARAMS ((int, const char *, int));\n \n-int main PROTO((int, char **));\n+int main PARAMS ((int, char **));\n \n-static void path_include PROTO((char *));\n+static void path_include PARAMS ((char *));\n \n-static const U_CHAR *index0 PROTO((const U_CHAR *, int, size_t));\n+static const U_CHAR *index0 PARAMS ((const U_CHAR *, int, size_t));\n \n-static void trigraph_pcp PROTO((FILE_BUF *));\n-static void check_white_space PROTO((FILE_BUF *));\n+static void trigraph_pcp PARAMS ((FILE_BUF *));\n+static void check_white_space PARAMS ((FILE_BUF *));\n \n-static void newline_fix PROTO((U_CHAR *));\n-static void name_newline_fix PROTO((U_CHAR *));\n+static void newline_fix PARAMS ((U_CHAR *));\n+static void name_newline_fix PARAMS ((U_CHAR *));\n \n-static const char *get_lintcmd PROTO((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t      const U_CHAR **, int *, int *));\n+static const char *get_lintcmd PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\tconst U_CHAR **, int *, int *));\n \n-static void rescan PROTO((FILE_BUF *, int));\n+static void rescan PARAMS ((FILE_BUF *, int));\n \n-static FILE_BUF expand_to_temp_buffer PROTO((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t\t     int, int));\n+static FILE_BUF expand_to_temp_buffer PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t       int, int));\n \n-static int handle_directive PROTO((FILE_BUF *, FILE_BUF *));\n+static int handle_directive PARAMS ((FILE_BUF *, FILE_BUF *));\n \n-static struct tm *timestamp PROTO((void));\n-static void special_symbol PROTO((HASHNODE *, FILE_BUF *));\n+static struct tm *timestamp PARAMS ((void));\n+static void special_symbol PARAMS ((HASHNODE *, FILE_BUF *));\n \n-static int is_system_include PROTO((const char *));\n-static char *base_name PROTO((const char *));\n-static int absolute_filename PROTO((const char *));\n-static size_t simplify_filename PROTO((char *));\n+static int is_system_include PARAMS ((const char *));\n+static char *base_name PARAMS ((const char *));\n+static int absolute_filename PARAMS ((const char *));\n+static size_t simplify_filename PARAMS ((char *));\n \n-static char *read_filename_string PROTO((int, FILE *));\n-static struct file_name_map *read_name_map PROTO((const char *));\n-static int open_include_file PROTO((char *, struct file_name_list *,\n-\t\t\t\t    const U_CHAR *, struct include_file **));\n-static char *remap_include_file PROTO((char *, struct file_name_list *));\n-static int lookup_ino_include PROTO((struct include_file *));\n+static char *read_filename_string PARAMS ((int, FILE *));\n+static struct file_name_map *read_name_map PARAMS ((const char *));\n+static int open_include_file PARAMS ((char *, struct file_name_list *,\n+\t\t\t\t      const U_CHAR *, struct include_file **));\n+static char *remap_include_file PARAMS ((char *, struct file_name_list *));\n+static int lookup_ino_include PARAMS ((struct include_file *));\n \n-static void finclude PROTO((int, struct include_file *, FILE_BUF *, int, struct file_name_list *));\n-static void record_control_macro PROTO((struct include_file *, const U_CHAR *));\n+static void finclude PARAMS ((int, struct include_file *, FILE_BUF *, int,\n+\t\t\t      struct file_name_list *));\n+static void record_control_macro PARAMS ((struct include_file *,\n+\t\t\t\t\t  const U_CHAR *));\n \n-static char *check_precompiled PROTO((int, struct stat *, const char *,\n-\t\t\t\t      const char **));\n-static int check_preconditions PROTO((const char *));\n-static void pcfinclude PROTO((U_CHAR *, const U_CHAR *, FILE_BUF *));\n-static void pcstring_used PROTO((HASHNODE *));\n-static void write_output PROTO((void));\n-static void pass_thru_directive PROTO((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t       FILE_BUF *, struct directive *));\n+static char *check_precompiled PARAMS ((int, struct stat *, const char *,\n+\t\t\t\t\tconst char **));\n+static int check_preconditions PARAMS ((const char *));\n+static void pcfinclude PARAMS ((U_CHAR *, const U_CHAR *, FILE_BUF *));\n+static void pcstring_used PARAMS ((HASHNODE *));\n+static void write_output PARAMS ((void));\n+static void pass_thru_directive PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t FILE_BUF *, struct directive *));\n \n-static MACRODEF create_definition PROTO((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t\t FILE_BUF *));\n+static MACRODEF create_definition PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t   FILE_BUF *));\n \n-static int check_macro_name PROTO((const U_CHAR *, int));\n-static int compare_defs PROTO((DEFINITION *, DEFINITION *));\n-static int comp_def_part PROTO((int, const U_CHAR *, int, const U_CHAR *,\n-\t\t\t\tint, int));\n+static int check_macro_name PARAMS ((const U_CHAR *, int));\n+static int compare_defs PARAMS ((DEFINITION *, DEFINITION *));\n+static int comp_def_part PARAMS ((int, const U_CHAR *, int, const U_CHAR *,\n+\t\t\t\t  int, int));\n \n-static DEFINITION *collect_expansion  PROTO((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t\t     int, struct arglist *));\n+static DEFINITION *collect_expansion  PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t       int, struct arglist *));\n \n-int check_assertion PROTO((const U_CHAR *, int, int, struct arglist *));\n-static int compare_token_lists PROTO((struct arglist *, struct arglist *));\n+int check_assertion PARAMS ((const U_CHAR *, int, int, struct arglist *));\n+static int compare_token_lists PARAMS ((struct arglist *, struct arglist *));\n \n-static struct arglist *read_token_list PROTO((const U_CHAR **, const U_CHAR *,\n-\t\t\t\t\t      int *));\n-static void free_token_list PROTO((struct arglist *));\n+static struct arglist *read_token_list PARAMS ((const U_CHAR **,\n+\t\t\t\t\t\tconst U_CHAR *, int *));\n+static void free_token_list PARAMS ((struct arglist *));\n \n-static ASSERTION_HASHNODE *assertion_install PROTO((const U_CHAR *, int, int));\n-static ASSERTION_HASHNODE *assertion_lookup PROTO((const U_CHAR *, int, int));\n-static void delete_assertion PROTO((ASSERTION_HASHNODE *));\n+static ASSERTION_HASHNODE *assertion_install PARAMS ((const U_CHAR *, int, int));\n+static ASSERTION_HASHNODE *assertion_lookup PARAMS ((const U_CHAR *, int, int));\n+static void delete_assertion PARAMS ((ASSERTION_HASHNODE *));\n \n-static void do_once PROTO((void));\n+static void do_once PARAMS ((void));\n \n-static HOST_WIDEST_INT eval_if_expression PROTO((const U_CHAR *, int));\n-static void conditional_skip PROTO((FILE_BUF *, int, enum node_type,\n-\t\t\t\t    const U_CHAR *, FILE_BUF *));\n-static void skip_if_group PROTO((FILE_BUF *, int, FILE_BUF *));\n-static void validate_else PROTO((const U_CHAR *, const U_CHAR *));\n+static HOST_WIDEST_INT eval_if_expression PARAMS ((const U_CHAR *, int));\n+static void conditional_skip PARAMS ((FILE_BUF *, int, enum node_type,\n+\t\t\t\t      const U_CHAR *, FILE_BUF *));\n+static void skip_if_group PARAMS ((FILE_BUF *, int, FILE_BUF *));\n+static void validate_else PARAMS ((const U_CHAR *, const U_CHAR *));\n \n-static U_CHAR *skip_to_end_of_comment PROTO((FILE_BUF *, int *, int));\n-static U_CHAR *skip_quoted_string PROTO((const U_CHAR *, const U_CHAR *,\n-\t\t\t\t\t int, int *, int *, int *));\n-static char *quote_string PROTO((char *, const char *, size_t));\n-static U_CHAR *skip_paren_group PROTO((FILE_BUF *));\n+static U_CHAR *skip_to_end_of_comment PARAMS ((FILE_BUF *, int *, int));\n+static U_CHAR *skip_quoted_string PARAMS ((const U_CHAR *, const U_CHAR *,\n+\t\t\t\t\t   int, int *, int *, int *));\n+static char *quote_string PARAMS ((char *, const char *, size_t));\n+static U_CHAR *skip_paren_group PARAMS ((FILE_BUF *));\n \n /* Last arg to output_line_directive.  */\n enum file_change_code {same_file, enter_file, leave_file};\n-static void output_line_directive PROTO((FILE_BUF *, FILE_BUF *, int, enum file_change_code));\n+static void output_line_directive PARAMS ((FILE_BUF *, FILE_BUF *, int, enum file_change_code));\n \n-static void macroexpand PROTO((HASHNODE *, FILE_BUF *));\n+static void macroexpand PARAMS ((HASHNODE *, FILE_BUF *));\n \n struct argdata;\n-static int macarg PROTO((struct argdata *, int));\n+static int macarg PARAMS ((struct argdata *, int));\n \n-static U_CHAR *macarg1 PROTO((U_CHAR *, const U_CHAR *, struct hashnode *, int *, int *, int *, int));\n+static U_CHAR *macarg1 PARAMS ((U_CHAR *, const U_CHAR *, struct hashnode *, int *, int *, int *, int));\n \n-static int discard_comments PROTO((U_CHAR *, int, int));\n+static int discard_comments PARAMS ((U_CHAR *, int, int));\n \n-static void change_newlines PROTO((struct argdata *));\n+static void change_newlines PARAMS ((struct argdata *));\n \n-static void notice PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-static void vnotice PROTO((const char *, va_list));\n-void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void verror PROTO((const char *, va_list));\n-static void error_from_errno PROTO((const char *));\n-void warning PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-static void vwarning PROTO((const char *, va_list));\n-static void error_with_line PVPROTO((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n-static void verror_with_line PROTO((int, const char *, va_list));\n-static void vwarning_with_line PROTO((int, const char *, va_list));\n-static void warning_with_line PVPROTO((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n-void pedwarn PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void pedwarn_with_line PVPROTO((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n-static void pedwarn_with_file_and_line PVPROTO((const char *, size_t, int, const char *, ...)) ATTRIBUTE_PRINTF_4;\n-static void pedwarn_strange_white_space PROTO((int));\n+static void notice PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+static void vnotice PARAMS ((const char *, va_list));\n+void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void verror PARAMS ((const char *, va_list));\n+static void error_from_errno PARAMS ((const char *));\n+void warning PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+static void vwarning PARAMS ((const char *, va_list));\n+static void error_with_line PARAMS ((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n+static void verror_with_line PARAMS ((int, const char *, va_list));\n+static void vwarning_with_line PARAMS ((int, const char *, va_list));\n+static void warning_with_line PARAMS ((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n+void pedwarn PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void pedwarn_with_line PARAMS ((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n+static void pedwarn_with_file_and_line PARAMS ((const char *, size_t, int, const char *, ...)) ATTRIBUTE_PRINTF_4;\n+static void pedwarn_strange_white_space PARAMS ((int));\n \n-static void print_containing_files PROTO((void));\n+static void print_containing_files PARAMS ((void));\n \n-static int line_for_error PROTO((int));\n-static int grow_outbuf PROTO((FILE_BUF *, int));\n+static int line_for_error PARAMS ((int));\n+static int grow_outbuf PARAMS ((FILE_BUF *, int));\n \n-static HASHNODE *install PROTO((const U_CHAR *, int, enum node_type,\n-\t\t\t\tconst char *, int));\n-HASHNODE *lookup PROTO((const U_CHAR *, int, int));\n-static void delete_macro PROTO((HASHNODE *));\n-static int hashf PROTO((const U_CHAR *, int, int));\n+static HASHNODE *install PARAMS ((const U_CHAR *, int, enum node_type,\n+\t\t\t\t  const char *, int));\n+HASHNODE *lookup PARAMS ((const U_CHAR *, int, int));\n+static void delete_macro PARAMS ((HASHNODE *));\n+static int hashf PARAMS ((const U_CHAR *, int, int));\n \n-static void dump_single_macro PROTO((HASHNODE *, FILE *));\n-static void dump_all_macros PROTO((void));\n-static void dump_defn_1 PROTO((const U_CHAR *, int, int, FILE *));\n-static void dump_arg_n PROTO((DEFINITION *, int, FILE *));\n+static void dump_single_macro PARAMS ((HASHNODE *, FILE *));\n+static void dump_all_macros PARAMS ((void));\n+static void dump_defn_1 PARAMS ((const U_CHAR *, int, int, FILE *));\n+static void dump_arg_n PARAMS ((DEFINITION *, int, FILE *));\n \n-static void initialize_char_syntax PROTO((void));\n-static void initialize_builtins PROTO((FILE_BUF *, FILE_BUF *));\n+static void initialize_char_syntax PARAMS ((void));\n+static void initialize_builtins PARAMS ((FILE_BUF *, FILE_BUF *));\n \n-static void make_definition PROTO((char *));\n-static void make_undef PROTO((char *, FILE_BUF *));\n+static void make_definition PARAMS ((char *));\n+static void make_undef PARAMS ((char *, FILE_BUF *));\n \n-static void make_assertion PROTO((const char *, const char *));\n+static void make_assertion PARAMS ((const char *, const char *));\n \n-static struct file_name_list *new_include_prefix PROTO((struct file_name_list *, const char *, const char *, const char *));\n-static void append_include_chain PROTO((struct file_name_list *, struct file_name_list *));\n+static struct file_name_list *new_include_prefix PARAMS ((struct file_name_list *, const char *, const char *, const char *));\n+static void append_include_chain PARAMS ((struct file_name_list *, struct file_name_list *));\n \n-static int quote_string_for_make PROTO((char *, const char *));\n-static void deps_output PROTO((const char *, int));\n+static int quote_string_for_make PARAMS ((char *, const char *));\n+static void deps_output PARAMS ((const char *, int));\n \n-void fatal PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-void fancy_abort PROTO((void)) ATTRIBUTE_NORETURN;\n-static void perror_with_name PROTO((const char *));\n-static void pfatal_with_name PROTO((const char *)) ATTRIBUTE_NORETURN;\n-static void pipe_closed PROTO((int)) ATTRIBUTE_NORETURN;\n+void fatal PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n+static void perror_with_name PARAMS ((const char *));\n+static void pfatal_with_name PARAMS ((const char *)) ATTRIBUTE_NORETURN;\n+static void pipe_closed PARAMS ((int)) ATTRIBUTE_NORETURN;\n \n-static void memory_full PROTO((void)) ATTRIBUTE_NORETURN;\n-static void print_help PROTO((void));\n+static void memory_full PARAMS ((void)) ATTRIBUTE_NORETURN;\n+static void print_help PARAMS ((void));\n \f\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n    retrying if necessary.  If MAX_READ_LEN is defined, read at most\n@@ -4912,7 +4914,7 @@ absolute_filename (filename)\n \n /* Returns whether or not a given character is a directory separator.\n    Used by simplify_filename.  */\n-static inline int is_dir_separator PROTO ((int));\n+static inline int is_dir_separator PARAMS ((int));\n \n static inline\n int\n@@ -9445,7 +9447,7 @@ change_newlines (arg)\n /* notice - output message to stderr */\n \n static void\n-notice VPROTO ((const char * msgid, ...))\n+notice VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -9473,7 +9475,7 @@ vnotice (msgid, args)\n /* error - print error message and increment count of errors.  */\n \n void\n-error VPROTO ((const char * msgid, ...))\n+error VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -9548,7 +9550,7 @@ error_from_errno (name)\n /* Print error message but don't count it.  */\n \n void\n-warning VPROTO ((const char * msgid, ...))\n+warning VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -9598,7 +9600,7 @@ vwarning (msgid, args)\n }\n \n static void\n-error_with_line VPROTO ((int line, const char * msgid, ...))\n+error_with_line VPARAMS ((int line, const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int line;\n@@ -9646,7 +9648,7 @@ verror_with_line (line, msgid, args)\n }\n \n static void\n-warning_with_line VPROTO ((int line, const char * msgid, ...))\n+warning_with_line VPARAMS ((int line, const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int line;\n@@ -9704,7 +9706,7 @@ vwarning_with_line (line, msgid, args)\n /* Print an error message and maybe count it.  */\n \n void\n-pedwarn VPROTO ((const char * msgid, ...))\n+pedwarn VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -9725,7 +9727,7 @@ pedwarn VPROTO ((const char * msgid, ...))\n }\n \n void\n-pedwarn_with_line VPROTO ((int line, const char * msgid, ...))\n+pedwarn_with_line VPARAMS ((int line, const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int line;\n@@ -9751,8 +9753,8 @@ pedwarn_with_line VPROTO ((int line, const char * msgid, ...))\n    giving specified file name and line number, not current.  */\n \n static void\n-pedwarn_with_file_and_line VPROTO ((const char *file, size_t file_len, int line,\n-\t\t\t\t    const char * msgid, ...))\n+pedwarn_with_file_and_line VPARAMS ((const char *file, size_t file_len,\n+\t\t\t\t     int line, const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n@@ -10805,7 +10807,7 @@ deps_output (string, spacer)\n }\n \f\n void\n-fatal VPROTO ((const char * msgid, ...))\n+fatal VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;"}, {"sha": "577088755b7b75b7fb8b5a2cbba3603cece175db", "filename": "gcc/cexp.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -43,10 +43,10 @@ struct arglist {\n   int argno;\n };\n \n-HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n+HOST_WIDEST_INT parse_c_expression PARAMS ((char *, int));\n \n-static int yylex PROTO((void));\n-static void yyerror PVPROTO((const char *, ...))\n+static int yylex PARAMS ((void));\n+static void yyerror PARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n static HOST_WIDEST_INT expression_value;\n #ifdef TEST_EXP_READER\n@@ -129,18 +129,18 @@ extern int c89;\n \n struct constant;\n \n-HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n-int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n-struct hashnode *lookup PROTO((U_CHAR *, int, int));\n-void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void verror PROTO((const char *, va_list));\n-void pedwarn PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void warning PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+HOST_WIDEST_INT parse_escape PARAMS ((char **, HOST_WIDEST_INT));\n+int check_assertion PARAMS ((U_CHAR *, int, int, struct arglist *));\n+struct hashnode *lookup PARAMS ((U_CHAR *, int, int));\n+void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void verror PARAMS ((const char *, va_list));\n+void pedwarn PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void warning PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n-static int parse_number PROTO((int));\n-static HOST_WIDEST_INT left_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n-static HOST_WIDEST_INT right_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n-static void integer_overflow PROTO((void));\n+static int parse_number PARAMS ((int));\n+static HOST_WIDEST_INT left_shift PARAMS ((struct constant *, unsigned HOST_WIDEST_INT));\n+static HOST_WIDEST_INT right_shift PARAMS ((struct constant *, unsigned HOST_WIDEST_INT));\n+static void integer_overflow PARAMS ((void));\n \n /* `signedp' values */\n #define SIGNED (~0)\n@@ -1919,7 +1919,7 @@ parse_c_expression (string, warn_undefined)\n }\n \n static void\n-yyerror VPROTO ((const char * msgid, ...))\n+yyerror VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -1949,9 +1949,9 @@ int pedantic;\n int traditional;\n int c89;\n \n-int main PROTO((int, char **));\n-static void initialize_random_junk PROTO((void));\n-static void print_unsigned_host_widest_int PROTO((unsigned HOST_WIDEST_INT));\n+int main PARAMS ((int, char **));\n+static void initialize_random_junk PARAMS ((void));\n+static void print_unsigned_host_widest_int PARAMS ((unsigned HOST_WIDEST_INT));\n \n /* Main program for testing purposes.  */\n int\n@@ -2050,7 +2050,7 @@ initialize_random_junk ()\n }\n \n void\n-error VPROTO ((char * msgid, ...))\n+error VPARAMS ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char * msgid;\n@@ -2070,7 +2070,7 @@ error VPROTO ((char * msgid, ...))\n }\n \n void\n-pedwarn VPROTO ((char * msgid, ...))\n+pedwarn VPARAMS ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char * msgid;\n@@ -2090,7 +2090,7 @@ pedwarn VPROTO ((char * msgid, ...))\n }\n \n void\n-warning VPROTO ((char * msgid, ...))\n+warning VPARAMS ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char * msgid;"}, {"sha": "0e94036632a0d83960abf11ff53f41126b5e02ca", "filename": "gcc/cexp.y", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Parse C expressions for CCCP.\n-   Copyright (C) 1987, 92, 94-98, 1999 Free Software Foundation.\n+   Copyright (C) 1987, 92, 94-99, 2000 Free Software Foundation.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -47,10 +47,10 @@ struct arglist {\n   int argno;\n };\n \n-HOST_WIDEST_INT parse_c_expression PROTO((char *, int));\n+HOST_WIDEST_INT parse_c_expression PARAMS ((char *, int));\n \n-static int yylex PROTO((void));\n-static void yyerror PVPROTO((const char *, ...))\n+static int yylex PARAMS ((void));\n+static void yyerror PARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n static HOST_WIDEST_INT expression_value;\n #ifdef TEST_EXP_READER\n@@ -133,18 +133,18 @@ extern int c89;\n \n struct constant;\n \n-HOST_WIDEST_INT parse_escape PROTO((char **, HOST_WIDEST_INT));\n-int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n-struct hashnode *lookup PROTO((U_CHAR *, int, int));\n-void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void verror PROTO((const char *, va_list));\n-void pedwarn PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void warning PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+HOST_WIDEST_INT parse_escape PARAMS ((char **, HOST_WIDEST_INT));\n+int check_assertion PARAMS ((U_CHAR *, int, int, struct arglist *));\n+struct hashnode *lookup PARAMS ((U_CHAR *, int, int));\n+void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void verror PARAMS ((const char *, va_list));\n+void pedwarn PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+void warning PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n \n-static int parse_number PROTO((int));\n-static HOST_WIDEST_INT left_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n-static HOST_WIDEST_INT right_shift PROTO((struct constant *, unsigned HOST_WIDEST_INT));\n-static void integer_overflow PROTO((void));\n+static int parse_number PARAMS ((int));\n+static HOST_WIDEST_INT left_shift PARAMS ((struct constant *, unsigned HOST_WIDEST_INT));\n+static HOST_WIDEST_INT right_shift PARAMS ((struct constant *, unsigned HOST_WIDEST_INT));\n+static void integer_overflow PARAMS ((void));\n \n /* `signedp' values */\n #define SIGNED (~0)\n@@ -1003,7 +1003,7 @@ parse_c_expression (string, warn_undefined)\n }\n \n static void\n-yyerror VPROTO ((const char * msgid, ...))\n+yyerror VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -1033,9 +1033,9 @@ int pedantic;\n int traditional;\n int c89;\n \n-int main PROTO((int, char **));\n-static void initialize_random_junk PROTO((void));\n-static void print_unsigned_host_widest_int PROTO((unsigned HOST_WIDEST_INT));\n+int main PARAMS ((int, char **));\n+static void initialize_random_junk PARAMS ((void));\n+static void print_unsigned_host_widest_int PARAMS ((unsigned HOST_WIDEST_INT));\n \n /* Main program for testing purposes.  */\n int\n@@ -1134,7 +1134,7 @@ initialize_random_junk ()\n }\n \n void\n-error VPROTO ((char * msgid, ...))\n+error VPARAMS ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char * msgid;\n@@ -1154,7 +1154,7 @@ error VPROTO ((char * msgid, ...))\n }\n \n void\n-pedwarn VPROTO ((char * msgid, ...))\n+pedwarn VPARAMS ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char * msgid;\n@@ -1174,7 +1174,7 @@ pedwarn VPROTO ((char * msgid, ...))\n }\n \n void\n-warning VPROTO ((char * msgid, ...))\n+warning VPARAMS ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char * msgid;"}, {"sha": "3f7cba482365f2d4af2e2048a16442e435d3d958", "filename": "gcc/collect2.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -263,43 +263,43 @@ static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n static const char *libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n #endif\n \n-static void handler\t\tPROTO((int));\n-static int is_ctor_dtor\t\tPROTO((const char *));\n-static char *find_a_file\tPROTO((struct path_prefix *, const char *));\n-static void add_prefix\t\tPROTO((struct path_prefix *, const char *));\n-static void prefix_from_env\tPROTO((const char *, struct path_prefix *));\n-static void prefix_from_string\tPROTO((const char *, struct path_prefix *));\n-static void do_wait\t\tPROTO((const char *));\n-static void fork_execute\tPROTO((const char *, char **));\n-static void maybe_unlink\tPROTO((const char *));\n-static void add_to_list\t\tPROTO((struct head *, const char *));\n-static int extract_init_priority PROTO((const char *));\n-static void sort_ids\t\tPROTO((struct head *));\n-static void write_list\t\tPROTO((FILE *, const char *, struct id *));\n+static void handler\t\tPARAMS ((int));\n+static int is_ctor_dtor\t\tPARAMS ((const char *));\n+static char *find_a_file\tPARAMS ((struct path_prefix *, const char *));\n+static void add_prefix\t\tPARAMS ((struct path_prefix *, const char *));\n+static void prefix_from_env\tPARAMS ((const char *, struct path_prefix *));\n+static void prefix_from_string\tPARAMS ((const char *, struct path_prefix *));\n+static void do_wait\t\tPARAMS ((const char *));\n+static void fork_execute\tPARAMS ((const char *, char **));\n+static void maybe_unlink\tPARAMS ((const char *));\n+static void add_to_list\t\tPARAMS ((struct head *, const char *));\n+static int extract_init_priority PARAMS ((const char *));\n+static void sort_ids\t\tPARAMS ((struct head *));\n+static void write_list\t\tPARAMS ((FILE *, const char *, struct id *));\n #ifdef COLLECT_EXPORT_LIST\n-static void dump_list\t\tPROTO((FILE *, const char *, struct id *));\n+static void dump_list\t\tPARAMS ((FILE *, const char *, struct id *));\n #endif\n #if 0\n-static void dump_prefix_list\tPROTO((FILE *, const char *, struct prefix_list *));\n+static void dump_prefix_list\tPARAMS ((FILE *, const char *, struct prefix_list *));\n #endif\n-static void write_list_with_asm PROTO((FILE *, const char *, struct id *));\n-static void write_c_file\tPROTO((FILE *, const char *));\n-static void write_c_file_stat\tPROTO((FILE *, const char *));\n+static void write_list_with_asm PARAMS ((FILE *, const char *, struct id *));\n+static void write_c_file\tPARAMS ((FILE *, const char *));\n+static void write_c_file_stat\tPARAMS ((FILE *, const char *));\n #ifndef LD_INIT_SWITCH\n-static void write_c_file_glob\tPROTO((FILE *, const char *));\n+static void write_c_file_glob\tPARAMS ((FILE *, const char *));\n #endif\n-static void scan_prog_file\tPROTO((const char *, enum pass));\n+static void scan_prog_file\tPARAMS ((const char *, enum pass));\n #ifdef SCAN_LIBRARIES\n-static void scan_libraries\tPROTO((const char *));\n+static void scan_libraries\tPARAMS ((const char *));\n #endif\n #ifdef COLLECT_EXPORT_LIST\n-static int is_in_list\t\tPROTO((const char *, struct id *));\n-static void write_aix_file\tPROTO((FILE *, struct id *));\n-static char *resolve_lib_name\tPROTO((const char *));\n-static int use_import_list\tPROTO((const char *));\n-static int ignore_library\tPROTO((const char *));\n+static int is_in_list\t\tPARAMS ((const char *, struct id *));\n+static void write_aix_file\tPARAMS ((FILE *, struct id *));\n+static char *resolve_lib_name\tPARAMS ((const char *));\n+static int use_import_list\tPARAMS ((const char *));\n+static int ignore_library\tPARAMS ((const char *));\n #endif\n-static char *extract_string\tPROTO((const char **));\n+static char *extract_string\tPARAMS ((const char **));\n \f\n #ifdef NO_DUP2\n int\n@@ -358,7 +358,7 @@ collect_exit (status)\n \f\n /* Notify user of a non-error.  */\n void\n-notice VPROTO((const char *msgid, ...))\n+notice VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -378,7 +378,7 @@ notice VPROTO((const char *msgid, ...))\n /* Die when sys call fails.  */\n \n void\n-fatal_perror VPROTO((const char * msgid, ...))\n+fatal_perror VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -403,7 +403,7 @@ fatal_perror VPROTO((const char * msgid, ...))\n /* Just die.  */\n \n void\n-fatal VPROTO((const char * msgid, ...))\n+fatal VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -427,7 +427,7 @@ fatal VPROTO((const char * msgid, ...))\n /* Write error message.  */\n \n void\n-error VPROTO((const char * msgid, ...))\n+error VPARAMS ((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * msgid;\n@@ -832,7 +832,7 @@ prefix_from_string (p, pprefix)\n \f\n /* Main program.  */\n \n-int main \t\tPROTO ((int, char *[]));\n+int main \t\tPARAMS ((int, char *[]));\n int\n main (argc, argv)\n      int argc;\n@@ -2111,8 +2111,8 @@ scan_prog_file (prog_name, which_pass)\n      const char *prog_name;\n      enum pass which_pass;\n {\n-  void (*int_handler) PROTO ((int));\n-  void (*quit_handler) PROTO ((int));\n+  void (*int_handler) PARAMS ((int));\n+  void (*quit_handler) PARAMS ((int));\n   char *real_nm_argv[4];\n   const char **nm_argv = (const char **) real_nm_argv;\n   int pid;\n@@ -2179,9 +2179,9 @@ scan_prog_file (prog_name, which_pass)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*) PROTO ((int))) signal (SIGINT,  SIG_IGN);\n+  int_handler  = (void (*) PARAMS ((int))) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n-  quit_handler = (void (*) PROTO ((int))) signal (SIGQUIT, SIG_IGN);\n+  quit_handler = (void (*) PARAMS ((int))) signal (SIGQUIT, SIG_IGN);\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n@@ -2296,7 +2296,7 @@ struct head libraries;\n \n /* Map the file indicated by NAME into memory and store its address.  */\n \n-static void mapfile\t\t\tPROTO ((const char *));\n+static void mapfile\t\t\tPARAMS ((const char *));\n \n static void\n mapfile (name)\n@@ -2322,7 +2322,7 @@ mapfile (name)\n \n static const char *libname;\n \n-static int libselect\t\t\tPROTO ((struct direct *));\n+static int libselect\t\t\tPARAMS ((struct direct *));\n \n static int\n libselect (d)\n@@ -2338,7 +2338,7 @@ libselect (d)\n    We must verify that the extension is numeric, because Sun saves the\n    original versions of patched libraries with a .FCS extension.  Files with\n    invalid extensions must go last in the sort, so that they will not be used.  */\n-static int libcompare\t\tPROTO ((struct direct **, struct direct **));\n+static int libcompare\t\tPARAMS ((struct direct **, struct direct **));\n \n static int\n libcompare (d1, d2)\n@@ -2383,7 +2383,7 @@ libcompare (d1, d2)\n \n /* Given the name NAME of a dynamic dependency, find its pathname and add\n    it to the list of libraries.  */\n-static void locatelib\t\t\tPROTO ((const char *));\n+static void locatelib\t\t\tPARAMS ((const char *));\n \n static void\n locatelib (name)\n@@ -2556,8 +2556,8 @@ scan_libraries (prog_name)\n {\n   static struct head libraries;\t\t/* list of shared libraries found */\n   struct id *list;\n-  void (*int_handler) PROTO ((int));\n-  void (*quit_handler) PROTO ((int));\n+  void (*int_handler) PARAMS ((int));\n+  void (*quit_handler) PARAMS ((int));\n   char *real_ldd_argv[4];\n   const char **ldd_argv = (const char **) real_ldd_argv;\n   int pid;\n@@ -2621,9 +2621,9 @@ scan_libraries (prog_name)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*) PROTO ((int))) signal (SIGINT,  SIG_IGN);\n+  int_handler  = (void (*) PARAMS ((int))) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n-  quit_handler = (void (*) PROTO ((int))) signal (SIGQUIT, SIG_IGN);\n+  quit_handler = (void (*) PARAMS ((int))) signal (SIGQUIT, SIG_IGN);\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n@@ -3073,13 +3073,13 @@ struct file_info\n extern int decode_mach_o_hdr ();\n extern int encode_mach_o_hdr ();\n \n-static void add_func_table\tPROTO((mo_header_t *, load_all_t *,\n+static void add_func_table\tPARAMS ((mo_header_t *, load_all_t *,\n \t\t\t\t       symbol_info_t *, int));\n-static void print_header\tPROTO((mo_header_t *));\n-static void print_load_command\tPROTO((load_union_t *, size_t, int));\n-static void bad_header\t\tPROTO((int));\n-static struct file_info\t*read_file  PROTO((const char *, int, int));\n-static void end_file\t\tPROTO((struct file_info *));\n+static void print_header\tPARAMS ((mo_header_t *));\n+static void print_load_command\tPARAMS ((load_union_t *, size_t, int));\n+static void bad_header\t\tPARAMS ((int));\n+static struct file_info\t*read_file  PARAMS ((const char *, int, int));\n+static void end_file\t\tPARAMS ((struct file_info *));\n \f\n /* OSF/rose specific version to scan the name list of the loaded\n    program for the symbols g++ uses for static constructors and"}, {"sha": "4bf6dd83a57cf6081e63834290bd6ec7e832ba92", "filename": "gcc/combine.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -350,73 +350,73 @@ static struct undobuf undobuf;\n \n static int n_occurrences;\n \n-static void do_SUBST\t\t\tPROTO((rtx *, rtx));\n-static void do_SUBST_INT\t\tPROTO((int *, int));\n-static void init_reg_last_arrays\tPROTO((void));\n-static void setup_incoming_promotions   PROTO((void));\n-static void set_nonzero_bits_and_sign_copies  PROTO((rtx, rtx, void *));\n-static int can_combine_p\tPROTO((rtx, rtx, rtx, rtx, rtx *, rtx *));\n-static int sets_function_arg_p\tPROTO((rtx));\n-static int combinable_i3pat\tPROTO((rtx, rtx *, rtx, rtx, int, rtx *));\n-static int contains_muldiv\tPROTO((rtx));\n-static rtx try_combine\t\tPROTO((rtx, rtx, rtx));\n-static void undo_all\t\tPROTO((void));\n-static void undo_commit\t\tPROTO((void));\n-static rtx *find_split_point\tPROTO((rtx *, rtx));\n-static rtx subst\t\tPROTO((rtx, rtx, rtx, int, int));\n-static rtx combine_simplify_rtx\tPROTO((rtx, enum machine_mode, int, int));\n-static rtx simplify_if_then_else  PROTO((rtx));\n-static rtx simplify_set\t\tPROTO((rtx));\n-static rtx simplify_logical\tPROTO((rtx, int));\n-static rtx expand_compound_operation  PROTO((rtx));\n-static rtx expand_field_assignment  PROTO((rtx));\n-static rtx make_extraction\tPROTO((enum machine_mode, rtx, int, rtx, int,\n-\t\t\t\t       int, int, int));\n-static rtx extract_left_shift\tPROTO((rtx, int));\n-static rtx make_compound_operation  PROTO((rtx, enum rtx_code));\n-static int get_pos_from_mask\tPROTO((unsigned HOST_WIDE_INT, int *));\n-static rtx force_to_mode\tPROTO((rtx, enum machine_mode,\n-\t\t\t\t       unsigned HOST_WIDE_INT, rtx, int));\n-static rtx if_then_else_cond\tPROTO((rtx, rtx *, rtx *));\n-static rtx known_cond\t\tPROTO((rtx, enum rtx_code, rtx, rtx));\n-static int rtx_equal_for_field_assignment_p PROTO((rtx, rtx));\n-static rtx make_field_assignment  PROTO((rtx));\n-static rtx apply_distributive_law  PROTO((rtx));\n-static rtx simplify_and_const_int  PROTO((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t  unsigned HOST_WIDE_INT));\n-static unsigned HOST_WIDE_INT nonzero_bits  PROTO((rtx, enum machine_mode));\n-static int num_sign_bit_copies  PROTO((rtx, enum machine_mode));\n-static int merge_outer_ops\tPROTO((enum rtx_code *, HOST_WIDE_INT *,\n-\t\t\t\t       enum rtx_code, HOST_WIDE_INT,\n-\t\t\t\t       enum machine_mode, int *));\n-static rtx simplify_shift_const\tPROTO((rtx, enum rtx_code, enum machine_mode,\n-\t\t\t\t       rtx, int));\n-static int recog_for_combine\tPROTO((rtx *, rtx, rtx *));\n-static rtx gen_lowpart_for_combine  PROTO((enum machine_mode, rtx));\n-static rtx gen_rtx_combine PVPROTO((enum rtx_code code, enum machine_mode mode,\n-\t\t\t\t  ...));\n-static rtx gen_binary\t\tPROTO((enum rtx_code, enum machine_mode,\n-\t\t\t\t       rtx, rtx));\n-static rtx gen_unary\t\tPROTO((enum rtx_code, enum machine_mode,\n-\t\t\t\t       enum machine_mode, rtx));\n-static enum rtx_code simplify_comparison  PROTO((enum rtx_code, rtx *, rtx *));\n-static int reversible_comparison_p  PROTO((rtx));\n-static void update_table_tick\tPROTO((rtx));\n-static void record_value_for_reg  PROTO((rtx, rtx, rtx));\n-static void check_promoted_subreg PROTO((rtx, rtx));\n-static void record_dead_and_set_regs_1  PROTO((rtx, rtx, void *));\n-static void record_dead_and_set_regs  PROTO((rtx));\n-static int get_last_value_validate  PROTO((rtx *, rtx, int, int));\n-static rtx get_last_value\tPROTO((rtx));\n-static int use_crosses_set_p\tPROTO((rtx, int));\n-static void reg_dead_at_p_1\tPROTO((rtx, rtx, void *));\n-static int reg_dead_at_p\tPROTO((rtx, rtx));\n-static void move_deaths\t\tPROTO((rtx, rtx, int, rtx, rtx *));\n-static int reg_bitfield_target_p  PROTO((rtx, rtx));\n-static void distribute_notes\tPROTO((rtx, rtx, rtx, rtx, rtx, rtx));\n-static void distribute_links\tPROTO((rtx));\n-static void mark_used_regs_combine PROTO((rtx));\n-static int insn_cuid\t\tPROTO((rtx));\n+static void do_SUBST\t\t\tPARAMS ((rtx *, rtx));\n+static void do_SUBST_INT\t\tPARAMS ((int *, int));\n+static void init_reg_last_arrays\tPARAMS ((void));\n+static void setup_incoming_promotions   PARAMS ((void));\n+static void set_nonzero_bits_and_sign_copies  PARAMS ((rtx, rtx, void *));\n+static int can_combine_p\tPARAMS ((rtx, rtx, rtx, rtx, rtx *, rtx *));\n+static int sets_function_arg_p\tPARAMS ((rtx));\n+static int combinable_i3pat\tPARAMS ((rtx, rtx *, rtx, rtx, int, rtx *));\n+static int contains_muldiv\tPARAMS ((rtx));\n+static rtx try_combine\t\tPARAMS ((rtx, rtx, rtx));\n+static void undo_all\t\tPARAMS ((void));\n+static void undo_commit\t\tPARAMS ((void));\n+static rtx *find_split_point\tPARAMS ((rtx *, rtx));\n+static rtx subst\t\tPARAMS ((rtx, rtx, rtx, int, int));\n+static rtx combine_simplify_rtx\tPARAMS ((rtx, enum machine_mode, int, int));\n+static rtx simplify_if_then_else  PARAMS ((rtx));\n+static rtx simplify_set\t\tPARAMS ((rtx));\n+static rtx simplify_logical\tPARAMS ((rtx, int));\n+static rtx expand_compound_operation  PARAMS ((rtx));\n+static rtx expand_field_assignment  PARAMS ((rtx));\n+static rtx make_extraction\tPARAMS ((enum machine_mode, rtx, int, rtx, int,\n+\t\t\t\t\t int, int, int));\n+static rtx extract_left_shift\tPARAMS ((rtx, int));\n+static rtx make_compound_operation  PARAMS ((rtx, enum rtx_code));\n+static int get_pos_from_mask\tPARAMS ((unsigned HOST_WIDE_INT, int *));\n+static rtx force_to_mode\tPARAMS ((rtx, enum machine_mode,\n+\t\t\t\t\t unsigned HOST_WIDE_INT, rtx, int));\n+static rtx if_then_else_cond\tPARAMS ((rtx, rtx *, rtx *));\n+static rtx known_cond\t\tPARAMS ((rtx, enum rtx_code, rtx, rtx));\n+static int rtx_equal_for_field_assignment_p PARAMS ((rtx, rtx));\n+static rtx make_field_assignment  PARAMS ((rtx));\n+static rtx apply_distributive_law  PARAMS ((rtx));\n+static rtx simplify_and_const_int  PARAMS ((rtx, enum machine_mode, rtx,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT));\n+static unsigned HOST_WIDE_INT nonzero_bits  PARAMS ((rtx, enum machine_mode));\n+static int num_sign_bit_copies  PARAMS ((rtx, enum machine_mode));\n+static int merge_outer_ops\tPARAMS ((enum rtx_code *, HOST_WIDE_INT *,\n+\t\t\t\t\t enum rtx_code, HOST_WIDE_INT,\n+\t\t\t\t\t enum machine_mode, int *));\n+static rtx simplify_shift_const\tPARAMS ((rtx, enum rtx_code, enum machine_mode,\n+\t\t\t\t\t rtx, int));\n+static int recog_for_combine\tPARAMS ((rtx *, rtx, rtx *));\n+static rtx gen_lowpart_for_combine  PARAMS ((enum machine_mode, rtx));\n+static rtx gen_rtx_combine PARAMS ((enum rtx_code code, enum machine_mode mode,\n+\t\t\t\t    ...));\n+static rtx gen_binary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n+\t\t\t\t\t rtx, rtx));\n+static rtx gen_unary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n+\t\t\t\t\t enum machine_mode, rtx));\n+static enum rtx_code simplify_comparison  PARAMS ((enum rtx_code, rtx *, rtx *));\n+static int reversible_comparison_p  PARAMS ((rtx));\n+static void update_table_tick\tPARAMS ((rtx));\n+static void record_value_for_reg  PARAMS ((rtx, rtx, rtx));\n+static void check_promoted_subreg PARAMS ((rtx, rtx));\n+static void record_dead_and_set_regs_1  PARAMS ((rtx, rtx, void *));\n+static void record_dead_and_set_regs  PARAMS ((rtx));\n+static int get_last_value_validate  PARAMS ((rtx *, rtx, int, int));\n+static rtx get_last_value\tPARAMS ((rtx));\n+static int use_crosses_set_p\tPARAMS ((rtx, int));\n+static void reg_dead_at_p_1\tPARAMS ((rtx, rtx, void *));\n+static int reg_dead_at_p\tPARAMS ((rtx, rtx));\n+static void move_deaths\t\tPARAMS ((rtx, rtx, int, rtx, rtx *));\n+static int reg_bitfield_target_p  PARAMS ((rtx, rtx));\n+static void distribute_notes\tPARAMS ((rtx, rtx, rtx, rtx, rtx, rtx));\n+static void distribute_links\tPARAMS ((rtx));\n+static void mark_used_regs_combine PARAMS ((rtx));\n+static int insn_cuid\t\tPARAMS ((rtx));\n \f\n /* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n    insn.  The substitution can be undone by undo_all.  If INTO is already\n@@ -9595,7 +9595,7 @@ gen_lowpart_for_combine (mode, x)\n \n /*VARARGS2*/\n static rtx\n-gen_rtx_combine VPROTO((enum rtx_code code, enum machine_mode mode, ...))\n+gen_rtx_combine VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   enum rtx_code code;"}, {"sha": "28ca1617022b991ca9131cfbbde268c0625e5e9f", "filename": "gcc/convert.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Definition of functions in convert.c.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,7 +18,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern tree convert_to_integer PROTO ((tree, tree));\n-extern tree convert_to_pointer PROTO ((tree, tree));\n-extern tree convert_to_real PROTO ((tree, tree));\n-extern tree convert_to_complex PROTO ((tree, tree));\n+extern tree convert_to_integer PARAMS ((tree, tree));\n+extern tree convert_to_pointer PARAMS ((tree, tree));\n+extern tree convert_to_real PARAMS ((tree, tree));\n+extern tree convert_to_complex PARAMS ((tree, tree));"}, {"sha": "25821abdb2b8a7f1b6a56ed8dc7a477eac660d5b", "filename": "gcc/cse.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -645,57 +645,57 @@ struct cse_basic_block_data\n \t   || XEXP (X, 0) == virtual_outgoing_args_rtx))\t\\\n    || GET_CODE (X) == ADDRESSOF)\n \n-static int notreg_cost\t\tPROTO((rtx));\n-static void new_basic_block\tPROTO((void));\n-static void make_new_qty\tPROTO((int, enum machine_mode));\n-static void make_regs_eqv\tPROTO((int, int));\n-static void delete_reg_equiv\tPROTO((int));\n-static int mention_regs\t\tPROTO((rtx));\n-static int insert_regs\t\tPROTO((rtx, struct table_elt *, int));\n-static void remove_from_table\tPROTO((struct table_elt *, unsigned));\n-static struct table_elt *lookup\tPROTO((rtx, unsigned, enum machine_mode)),\n-       *lookup_for_remove PROTO((rtx, unsigned, enum machine_mode));\n-static rtx lookup_as_function\tPROTO((rtx, enum rtx_code));\n-static struct table_elt *insert PROTO((rtx, struct table_elt *, unsigned,\n-\t\t\t\t       enum machine_mode));\n-static void merge_equiv_classes PROTO((struct table_elt *,\n-\t\t\t\t       struct table_elt *));\n-static void invalidate\t\tPROTO((rtx, enum machine_mode));\n-static int cse_rtx_varies_p\tPROTO((rtx));\n-static void remove_invalid_refs\tPROTO((int));\n-static void remove_invalid_subreg_refs\tPROTO((int, int, enum machine_mode));\n-static void rehash_using_reg\tPROTO((rtx));\n-static void invalidate_memory\tPROTO((void));\n-static void invalidate_for_call\tPROTO((void));\n-static rtx use_related_value\tPROTO((rtx, struct table_elt *));\n-static unsigned canon_hash\tPROTO((rtx, enum machine_mode));\n-static unsigned safe_hash\tPROTO((rtx, enum machine_mode));\n-static int exp_equiv_p\t\tPROTO((rtx, rtx, int, int));\n-static rtx canon_reg\t\tPROTO((rtx, rtx));\n-static void find_best_addr\tPROTO((rtx, rtx *));\n-static enum rtx_code find_comparison_args PROTO((enum rtx_code, rtx *, rtx *,\n-\t\t\t\t\t\t enum machine_mode *,\n-\t\t\t\t\t\t enum machine_mode *));\n-static rtx fold_rtx\t\tPROTO((rtx, rtx));\n-static rtx equiv_constant\tPROTO((rtx));\n-static void record_jump_equiv\tPROTO((rtx, int));\n-static void record_jump_cond\tPROTO((enum rtx_code, enum machine_mode,\n-\t\t\t\t       rtx, rtx, int));\n-static void cse_insn\t\tPROTO((rtx, rtx));\n-static int addr_affects_sp_p\tPROTO((rtx));\n-static void invalidate_from_clobbers PROTO((rtx));\n-static rtx cse_process_notes\tPROTO((rtx, rtx));\n-static void cse_around_loop\tPROTO((rtx));\n-static void invalidate_skipped_set PROTO((rtx, rtx, void *));\n-static void invalidate_skipped_block PROTO((rtx));\n-static void cse_check_loop_start PROTO((rtx, rtx, void *));\n-static void cse_set_around_loop\tPROTO((rtx, rtx, rtx));\n-static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n-static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n-extern void dump_class          PROTO((struct table_elt*));\n-static struct cse_reg_info* get_cse_reg_info PROTO((int));\n-\n-static void flush_hash_table\tPROTO((void));\n+static int notreg_cost\t\tPARAMS ((rtx));\n+static void new_basic_block\tPARAMS ((void));\n+static void make_new_qty\tPARAMS ((int, enum machine_mode));\n+static void make_regs_eqv\tPARAMS ((int, int));\n+static void delete_reg_equiv\tPARAMS ((int));\n+static int mention_regs\t\tPARAMS ((rtx));\n+static int insert_regs\t\tPARAMS ((rtx, struct table_elt *, int));\n+static void remove_from_table\tPARAMS ((struct table_elt *, unsigned));\n+static struct table_elt *lookup\tPARAMS ((rtx, unsigned, enum machine_mode)),\n+       *lookup_for_remove PARAMS ((rtx, unsigned, enum machine_mode));\n+static rtx lookup_as_function\tPARAMS ((rtx, enum rtx_code));\n+static struct table_elt *insert PARAMS ((rtx, struct table_elt *, unsigned,\n+\t\t\t\t\t enum machine_mode));\n+static void merge_equiv_classes PARAMS ((struct table_elt *,\n+\t\t\t\t\t struct table_elt *));\n+static void invalidate\t\tPARAMS ((rtx, enum machine_mode));\n+static int cse_rtx_varies_p\tPARAMS ((rtx));\n+static void remove_invalid_refs\tPARAMS ((int));\n+static void remove_invalid_subreg_refs\tPARAMS ((int, int, enum machine_mode));\n+static void rehash_using_reg\tPARAMS ((rtx));\n+static void invalidate_memory\tPARAMS ((void));\n+static void invalidate_for_call\tPARAMS ((void));\n+static rtx use_related_value\tPARAMS ((rtx, struct table_elt *));\n+static unsigned canon_hash\tPARAMS ((rtx, enum machine_mode));\n+static unsigned safe_hash\tPARAMS ((rtx, enum machine_mode));\n+static int exp_equiv_p\t\tPARAMS ((rtx, rtx, int, int));\n+static rtx canon_reg\t\tPARAMS ((rtx, rtx));\n+static void find_best_addr\tPARAMS ((rtx, rtx *));\n+static enum rtx_code find_comparison_args PARAMS ((enum rtx_code, rtx *, rtx *,\n+\t\t\t\t\t\t   enum machine_mode *,\n+\t\t\t\t\t\t   enum machine_mode *));\n+static rtx fold_rtx\t\tPARAMS ((rtx, rtx));\n+static rtx equiv_constant\tPARAMS ((rtx));\n+static void record_jump_equiv\tPARAMS ((rtx, int));\n+static void record_jump_cond\tPARAMS ((enum rtx_code, enum machine_mode,\n+\t\t\t\t\t rtx, rtx, int));\n+static void cse_insn\t\tPARAMS ((rtx, rtx));\n+static int addr_affects_sp_p\tPARAMS ((rtx));\n+static void invalidate_from_clobbers PARAMS ((rtx));\n+static rtx cse_process_notes\tPARAMS ((rtx, rtx));\n+static void cse_around_loop\tPARAMS ((rtx));\n+static void invalidate_skipped_set PARAMS ((rtx, rtx, void *));\n+static void invalidate_skipped_block PARAMS ((rtx));\n+static void cse_check_loop_start PARAMS ((rtx, rtx, void *));\n+static void cse_set_around_loop\tPARAMS ((rtx, rtx, rtx));\n+static rtx cse_basic_block\tPARAMS ((rtx, rtx, struct branch_path *, int));\n+static void count_reg_usage\tPARAMS ((rtx, int *, rtx, int));\n+extern void dump_class          PARAMS ((struct table_elt*));\n+static struct cse_reg_info* get_cse_reg_info PARAMS ((int));\n+\n+static void flush_hash_table\tPARAMS ((void));\n \f\n /* Dump the expressions in the equivalence class indicated by CLASSP.\n    This function is used only for debugging.  */"}, {"sha": "8c7b32879b8a5270757709e0d88fc668a121aa10", "filename": "gcc/dbxout.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Output dbx-format symbol table information from GNU compiler.\n-   Copyright (C) 1987, 88, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-99, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -320,27 +320,27 @@ static int current_sym_nchars;\n #endif\n \n #if defined(ASM_OUTPUT_SECTION_NAME)\n-static void dbxout_function_end\t\tPROTO((void));\n+static void dbxout_function_end\t\tPARAMS ((void));\n #endif\n-static void dbxout_typedefs\t\tPROTO((tree));\n-static void dbxout_type_index\t\tPROTO((tree));\n+static void dbxout_typedefs\t\tPARAMS ((tree));\n+static void dbxout_type_index\t\tPARAMS ((tree));\n #if DBX_CONTIN_LENGTH > 0\n-static void dbxout_continue\t\tPROTO((void));\n-#endif\n-static void dbxout_type_fields\t\tPROTO((tree));\n-static void dbxout_type_method_1\tPROTO((tree, const char *));\n-static void dbxout_type_methods\t\tPROTO((tree));\n-static void dbxout_range_type\t\tPROTO((tree));\n-static void dbxout_type\t\t\tPROTO((tree, int, int));\n-static void print_int_cst_octal\t\tPROTO((tree));\n-static void print_octal\t\t\tPROTO((unsigned HOST_WIDE_INT, int));\n-static void dbxout_type_name\t\tPROTO((tree));\n-static void dbxout_symbol_location\tPROTO((tree, tree, const char *, rtx));\n-static void dbxout_symbol_name\t\tPROTO((tree, const char *, int));\n-static void dbxout_prepare_symbol\tPROTO((tree));\n-static void dbxout_finish_symbol\tPROTO((tree));\n-static void dbxout_block\t\tPROTO((tree, int, tree));\n-static void dbxout_really_begin_function PROTO((tree));\n+static void dbxout_continue\t\tPARAMS ((void));\n+#endif\n+static void dbxout_type_fields\t\tPARAMS ((tree));\n+static void dbxout_type_method_1\tPARAMS ((tree, const char *));\n+static void dbxout_type_methods\t\tPARAMS ((tree));\n+static void dbxout_range_type\t\tPARAMS ((tree));\n+static void dbxout_type\t\t\tPARAMS ((tree, int, int));\n+static void print_int_cst_octal\t\tPARAMS ((tree));\n+static void print_octal\t\t\tPARAMS ((unsigned HOST_WIDE_INT, int));\n+static void dbxout_type_name\t\tPARAMS ((tree));\n+static void dbxout_symbol_location\tPARAMS ((tree, tree, const char *, rtx));\n+static void dbxout_symbol_name\t\tPARAMS ((tree, const char *, int));\n+static void dbxout_prepare_symbol\tPARAMS ((tree));\n+static void dbxout_finish_symbol\tPARAMS ((tree));\n+static void dbxout_block\t\tPARAMS ((tree, int, tree));\n+static void dbxout_really_begin_function PARAMS ((tree));\n \f\n #if defined(ASM_OUTPUT_SECTION_NAME)\n static void"}, {"sha": "899d5d9bb6793fc065b902fd30a29148344f4b28", "filename": "gcc/dbxout.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdbxout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdbxout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.h?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* dbxout.h - Various declarations for functions found in dbxout.c\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,19 +18,19 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern void dbxout_init \t\tPROTO ((FILE *, const char *, tree));\n-extern void dbxout_finish\t\tPROTO ((FILE *, const char *));\n+extern void dbxout_init \t\tPARAMS ((FILE *, const char *, tree));\n+extern void dbxout_finish\t\tPARAMS ((FILE *, const char *));\n \n-extern void dbxout_start_new_source_file \tPROTO ((const char *));\n-extern void dbxout_resume_previous_source_file\tPROTO ((void));\n+extern void dbxout_start_new_source_file \tPARAMS ((const char *));\n+extern void dbxout_resume_previous_source_file\tPARAMS ((void));\n \n-extern void dbxout_source_file\t\tPROTO ((FILE *, const char *));\n-extern void dbxout_types\t\tPROTO ((tree));\n-extern void dbxout_args\t\t\tPROTO ((tree));\n-extern void dbxout_symbol\t\tPROTO ((tree, int));\n-extern void dbxout_parms\t\tPROTO ((tree));\n-extern void dbxout_reg_parms\t\tPROTO ((tree));\n-extern void dbxout_syms\t\t\tPROTO ((tree));\n-extern void dbxout_function\t\tPROTO ((tree));\n-extern void dbxout_source_line\t\tPROTO ((FILE *, const char *, int));\n-extern void dbxout_begin_function\tPROTO ((tree));\n+extern void dbxout_source_file\t\tPARAMS ((FILE *, const char *));\n+extern void dbxout_types\t\tPARAMS ((tree));\n+extern void dbxout_args\t\t\tPARAMS ((tree));\n+extern void dbxout_symbol\t\tPARAMS ((tree, int));\n+extern void dbxout_parms\t\tPARAMS ((tree));\n+extern void dbxout_reg_parms\t\tPARAMS ((tree));\n+extern void dbxout_syms\t\t\tPARAMS ((tree));\n+extern void dbxout_function\t\tPARAMS ((tree));\n+extern void dbxout_source_line\t\tPARAMS ((FILE *, const char *, int));\n+extern void dbxout_begin_function\tPARAMS ((tree));"}, {"sha": "175151bac6cab455787fe4ef624903e2d11c6b5c", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 68, "deletions": 67, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Top level of GNU C compiler\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -51,49 +51,50 @@ struct output_buffer\n };\n \n /* Prototypes. */\n-static int doing_line_wrapping PROTO((void));\n-static void init_output_buffer PROTO((struct output_buffer*,\n-                                      const char *, int));\n-static const char *get_output_prefix PROTO((const struct output_buffer *));\n-static int output_space_left PROTO((const struct output_buffer *));\n-static void emit_output_prefix PROTO((struct output_buffer *));\n-static void output_newline PROTO((struct output_buffer *));\n-static void output_append PROTO((struct output_buffer *, const char *,\n-                                 const char *));\n-static void output_puts PROTO((struct output_buffer *, const char *));\n-static void dump_output PROTO((struct output_buffer *, FILE *));\n-static const char *vbuild_message_string PROTO((const char *, va_list));\n-static const char *build_message_string PVPROTO((const char *, ...));\n-static const char *build_location_prefix PROTO((const char *, int, int));\n-static void voutput_notice PROTO((struct output_buffer *, const char *,\n-                                  va_list));\n-static void output_printf PVPROTO((struct output_buffer *, const char *, ...));\n-static void line_wrapper_printf PVPROTO((FILE *, const char *, ...));\n-static void vline_wrapper_message_with_location PROTO((const char *, int, int,\n-                                                       const char *, va_list));\n-static void notice PVPROTO((const char *s, ...)) ATTRIBUTE_PRINTF_1;\n-static void v_message_with_file_and_line PROTO((const char *, int, int,\n+static int doing_line_wrapping PARAMS ((void));\n+static void init_output_buffer PARAMS ((struct output_buffer*,\n+\t\t\t\t\tconst char *, int));\n+static const char *get_output_prefix PARAMS ((const struct output_buffer *));\n+static int output_space_left PARAMS ((const struct output_buffer *));\n+static void emit_output_prefix PARAMS ((struct output_buffer *));\n+static void output_newline PARAMS ((struct output_buffer *));\n+static void output_append PARAMS ((struct output_buffer *, const char *,\n+\t\t\t\t   const char *));\n+static void output_puts PARAMS ((struct output_buffer *, const char *));\n+static void dump_output PARAMS ((struct output_buffer *, FILE *));\n+static const char *vbuild_message_string PARAMS ((const char *, va_list));\n+static const char *build_message_string PARAMS ((const char *, ...));\n+static const char *build_location_prefix PARAMS ((const char *, int, int));\n+static void voutput_notice PARAMS ((struct output_buffer *, const char *,\n+\t\t\t\t    va_list));\n+static void output_printf PARAMS ((struct output_buffer *, const char *, ...));\n+static void line_wrapper_printf PARAMS ((FILE *, const char *, ...));\n+static void vline_wrapper_message_with_location PARAMS ((const char *, int,\n+\t\t\t\t\t\t\t int, const char *,\n+\t\t\t\t\t\t\t va_list));\n+static void notice PARAMS ((const char *s, ...)) ATTRIBUTE_PRINTF_1;\n+static void v_message_with_file_and_line PARAMS ((const char *, int, int,\n+\t\t\t\t\t\t  const char *, va_list));\n+static void v_message_with_decl PARAMS ((tree, int, const char *, va_list));\n+static void file_and_line_for_asm PARAMS ((rtx, char **, int *));\n+static void v_error_with_file_and_line PARAMS ((const char *, int,\n \t\t\t\t\t\tconst char *, va_list));\n-static void v_message_with_decl PROTO((tree, int, const char *, va_list));\n-static void file_and_line_for_asm PROTO((rtx, char **, int *));\n-static void v_error_with_file_and_line PROTO((const char *, int,\n-\t\t\t\t\t      const char *, va_list));\n-static void v_error_with_decl PROTO((tree, const char *, va_list));\n-static void v_error_for_asm PROTO((rtx, const char *, va_list));\n-static void verror PROTO((const char *, va_list));\n-static void vfatal PROTO((const char *, va_list)) ATTRIBUTE_NORETURN;\n-static void v_warning_with_file_and_line PROTO ((const char *, int,\n-\t\t\t\t\t\t const char *, va_list));\n-static void v_warning_with_decl PROTO((tree, const char *, va_list));\n-static void v_warning_for_asm PROTO((rtx, const char *, va_list));\n-static void vwarning PROTO((const char *, va_list));\n-static void vpedwarn PROTO((const char *, va_list));\n-static void v_pedwarn_with_decl PROTO((tree, const char *, va_list));\n-static void v_pedwarn_with_file_and_line PROTO((const char *, int,\n-\t\t\t\t\t\tconst char *, va_list));\n-static void vsorry PROTO((const char *, va_list));\n-static void report_file_and_line PROTO ((const char *, int, int));\n-static void vnotice PROTO ((FILE *, const char *, va_list));\n+static void v_error_with_decl PARAMS ((tree, const char *, va_list));\n+static void v_error_for_asm PARAMS ((rtx, const char *, va_list));\n+static void verror PARAMS ((const char *, va_list));\n+static void vfatal PARAMS ((const char *, va_list)) ATTRIBUTE_NORETURN;\n+static void v_warning_with_file_and_line PARAMS ((const char *, int,\n+\t\t\t\t\t\t  const char *, va_list));\n+static void v_warning_with_decl PARAMS ((tree, const char *, va_list));\n+static void v_warning_for_asm PARAMS ((rtx, const char *, va_list));\n+static void vwarning PARAMS ((const char *, va_list));\n+static void vpedwarn PARAMS ((const char *, va_list));\n+static void v_pedwarn_with_decl PARAMS ((tree, const char *, va_list));\n+static void v_pedwarn_with_file_and_line PARAMS ((const char *, int,\n+\t\t\t\t\t\t  const char *, va_list));\n+static void vsorry PARAMS ((const char *, va_list));\n+static void report_file_and_line PARAMS ((const char *, int, int));\n+static void vnotice PARAMS ((FILE *, const char *, va_list));\n \n \n extern int rtl_dump_and_exit;\n@@ -115,7 +116,7 @@ static int last_error_tick;\n /* Called by report_error_function to print out function name.\n  * Default may be overridden by language front-ends.  */\n \n-void (*print_error_function) PROTO((const char *)) =\n+void (*print_error_function) PARAMS ((const char *)) =\n   default_print_error_function;\n \n /* Maximum characters per line in automatic line wrapping mode.\n@@ -283,7 +284,7 @@ vbuild_message_string (msgid, ap)\n     printf.  The caller is reponsible for freeing the memory.  */\n \n static const char *\n-build_message_string VPROTO((const char *msgid, ...))\n+build_message_string VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -341,7 +342,7 @@ voutput_notice (buffer, msgid, ap)\n /* Format a message into BUFFER a la printf.  */\n \n static void\n-output_printf VPROTO((struct output_buffer *buffer, const char *msgid, ...))\n+output_printf VPARAMS ((struct output_buffer *buffer, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   struct output_buffer *buffer;\n@@ -365,7 +366,7 @@ output_printf VPROTO((struct output_buffer *buffer, const char *msgid, ...))\n    with PREFIX.  */\n \n static void\n-line_wrapper_printf VPROTO((FILE *file, const char *msgid, ...))\n+line_wrapper_printf VPARAMS ((FILE *file, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   FILE *file;\n@@ -422,7 +423,7 @@ vnotice (file, msgid, ap)\n /* Print MSGID on stderr.  */\n \n static void\n-notice VPROTO((const char *msgid, ...))\n+notice VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *msgid;\n@@ -656,7 +657,7 @@ verror (msgid, ap)\n /* Report a fatal error at the current line number.  Allow a front end to\n    intercept the message.  */\n \n-static void (*fatal_function) PROTO ((const char *, va_list));\n+static void (*fatal_function) PARAMS ((const char *, va_list));\n \n static void\n vfatal (msgid, ap)\n@@ -838,7 +839,7 @@ count_error (warningp)\n \n /* Print a diagnistic MSGID on FILE.  */\n void\n-fnotice VPROTO((FILE *file, const char *msgid, ...))\n+fnotice VPARAMS ((FILE *file, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   FILE *file;\n@@ -880,7 +881,7 @@ fatal_io_error (name)\n \n /* Issue a pedantic warning MSGID.  */\n void\n-pedwarn VPROTO((const char *msgid, ...))\n+pedwarn VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -899,7 +900,7 @@ pedwarn VPROTO((const char *msgid, ...))\n \n /* Issue a pedantic waring about DECL.  */\n void\n-pedwarn_with_decl VPROTO((tree decl, const char *msgid, ...))\n+pedwarn_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n@@ -920,8 +921,8 @@ pedwarn_with_decl VPROTO((tree decl, const char *msgid, ...))\n \n /* Same as above but within the context FILE and LINE. */\n void\n-pedwarn_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t   const char *msgid, ...))\n+pedwarn_with_file_and_line VPARAMS ((const char *file, int line,\n+\t\t\t\t     const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n@@ -944,7 +945,7 @@ pedwarn_with_file_and_line VPROTO((const char *file, int line,\n \n /* Just apologize with MSGID.  */\n void\n-sorry VPROTO((const char *msgid, ...))\n+sorry VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -1081,8 +1082,8 @@ report_error_function (file)\n }\n \n void\n-error_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t const char *msgid, ...))\n+error_with_file_and_line VPARAMS ((const char *file, int line,\n+\t\t\t\t   const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n@@ -1104,7 +1105,7 @@ error_with_file_and_line VPROTO((const char *file, int line,\n }\n \n void\n-error_with_decl VPROTO((tree decl, const char *msgid, ...))\n+error_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n@@ -1124,7 +1125,7 @@ error_with_decl VPROTO((tree decl, const char *msgid, ...))\n }\n \n void\n-error_for_asm VPROTO((rtx insn, const char *msgid, ...))\n+error_for_asm VPARAMS ((rtx insn, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx insn;\n@@ -1144,7 +1145,7 @@ error_for_asm VPROTO((rtx insn, const char *msgid, ...))\n }\n \n void\n-error VPROTO((const char *msgid, ...))\n+error VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -1165,13 +1166,13 @@ error VPROTO((const char *msgid, ...))\n \n void\n set_fatal_function (f)\n-     void (*f) PROTO ((const char *, va_list));\n+     void (*f) PARAMS ((const char *, va_list));\n {\n   fatal_function = f;\n }\n \n void\n-fatal VPROTO((const char *msgid, ...))\n+fatal VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -1216,8 +1217,8 @@ _fatal_insn_not_found (insn, file, line, function)\n }\n \n void\n-warning_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t   const char *msgid, ...))\n+warning_with_file_and_line VPARAMS ((const char *file, int line,\n+\t\t\t\t     const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n@@ -1239,7 +1240,7 @@ warning_with_file_and_line VPROTO((const char *file, int line,\n }\n \n void\n-warning_with_decl VPROTO((tree decl, const char *msgid, ...))\n+warning_with_decl VPARAMS ((tree decl, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n@@ -1259,7 +1260,7 @@ warning_with_decl VPROTO((tree decl, const char *msgid, ...))\n }\n \n void\n-warning_for_asm VPROTO((rtx insn, const char *msgid, ...))\n+warning_for_asm VPARAMS ((rtx insn, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx insn;\n@@ -1279,7 +1280,7 @@ warning_for_asm VPROTO((rtx insn, const char *msgid, ...))\n }\n \n void\n-warning VPROTO((const char *msgid, ...))\n+warning VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;"}, {"sha": "5564421df0b2676fc0e021a29df92f7d35d5819c", "filename": "gcc/doprint.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdoprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdoprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoprint.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Provide a version _doprnt in terms of fprintf.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Kaveh Ghazi  (ghazi@caip.rutgers.edu)  3/29/98\n \n This program is free software; you can redistribute it and/or modify it\n@@ -204,10 +204,10 @@ _doprnt (format, ap, stream)\n     fflush(stdin); \\\n } while (0)\n \n-static int checkit PVPROTO ((const char * format, ...)) ATTRIBUTE_PRINTF_1;\n+static int checkit PARAMS ((const char * format, ...)) ATTRIBUTE_PRINTF_1;\n \n static int\n-checkit VPROTO ((const char* format, ...))\n+checkit VPARAMS ((const char* format, ...))\n {\n   va_list args;\n   int result;"}, {"sha": "3fcc05f18d665e6f52c525bb0e075f0da7cab767", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 202, "deletions": 197, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Output Dwarf2 format symbol table information from the GNU C compiler.\n-   Copyright (C) 1992, 93, 95-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 93, 95-99, 2000 Free Software Foundation, Inc.\n    Contributed by Gary Funck (gary@intrepid.com).\n    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).\n    Extensively modified by Jason Merrill (jason@cygnus.com).\n@@ -199,26 +199,26 @@ static unsigned current_funcdef_fde;\n \n /* Forward declarations for functions defined in this file.  */\n \n-static char *stripattributes\t\tPROTO((const char *));\n-static const char *dwarf_cfi_name\tPROTO((unsigned));\n-static dw_cfi_ref new_cfi\t\tPROTO((void));\n-static void add_cfi\t\t\tPROTO((dw_cfi_ref *, dw_cfi_ref));\n-static unsigned long size_of_uleb128\tPROTO((unsigned long));\n-static unsigned long size_of_sleb128\tPROTO((long));\n-static void output_uleb128\t\tPROTO((unsigned long));\n-static void output_sleb128\t\tPROTO((long));\n-static void add_fde_cfi\t\t\tPROTO((char *, dw_cfi_ref));\n-static void lookup_cfa_1\t\tPROTO((dw_cfi_ref, unsigned long *,\n-\t\t\t\t\t       long *));\n-static void lookup_cfa\t\t\tPROTO((unsigned long *, long *));\n-static void reg_save\t\t\tPROTO((char *, unsigned, unsigned,\n-\t\t\t\t\t       long));\n-static void initial_return_save\t\tPROTO((rtx));\n-static void output_cfi\t\t\tPROTO((dw_cfi_ref, dw_fde_ref));\n-static void output_call_frame_info\tPROTO((int));\n-static unsigned reg_number\t\tPROTO((rtx));\n-static void dwarf2out_stack_adjust\tPROTO((rtx));\n-static void dwarf2out_frame_debug_expr\tPROTO((rtx, char *));\n+static char *stripattributes\t\tPARAMS ((const char *));\n+static const char *dwarf_cfi_name\tPARAMS ((unsigned));\n+static dw_cfi_ref new_cfi\t\tPARAMS ((void));\n+static void add_cfi\t\t\tPARAMS ((dw_cfi_ref *, dw_cfi_ref));\n+static unsigned long size_of_uleb128\tPARAMS ((unsigned long));\n+static unsigned long size_of_sleb128\tPARAMS ((long));\n+static void output_uleb128\t\tPARAMS ((unsigned long));\n+static void output_sleb128\t\tPARAMS ((long));\n+static void add_fde_cfi\t\t\tPARAMS ((char *, dw_cfi_ref));\n+static void lookup_cfa_1\t\tPARAMS ((dw_cfi_ref, unsigned long *,\n+\t\t\t\t\t\t long *));\n+static void lookup_cfa\t\t\tPARAMS ((unsigned long *, long *));\n+static void reg_save\t\t\tPARAMS ((char *, unsigned, unsigned,\n+\t\t\t\t\t\t long));\n+static void initial_return_save\t\tPARAMS ((rtx));\n+static void output_cfi\t\t\tPARAMS ((dw_cfi_ref, dw_fde_ref));\n+static void output_call_frame_info\tPARAMS ((int));\n+static unsigned reg_number\t\tPARAMS ((rtx));\n+static void dwarf2out_stack_adjust\tPARAMS ((rtx));\n+static void dwarf2out_frame_debug_expr\tPARAMS ((rtx, char *));\n \n /* Definitions of defaults for assembler-dependent names of various\n    pseudo-ops and section names.\n@@ -2332,186 +2332,191 @@ static int comp_unit_has_inlines;\n \n /* Forward declarations for functions defined in this file.  */\n \n-static void addr_const_to_string\tPROTO((dyn_string_t, rtx));\n-static char *addr_to_string\t\tPROTO((rtx));\n-static int is_pseudo_reg\t\tPROTO((rtx));\n-static tree type_main_variant\t\tPROTO((tree));\n-static int is_tagged_type\t\tPROTO((tree));\n-static const char *dwarf_tag_name\tPROTO((unsigned));\n-static const char *dwarf_attr_name\tPROTO((unsigned));\n-static const char *dwarf_form_name\tPROTO((unsigned));\n-static const char *dwarf_stack_op_name\tPROTO((unsigned));\n+static void addr_const_to_string\tPARAMS ((dyn_string_t, rtx));\n+static char *addr_to_string\t\tPARAMS ((rtx));\n+static int is_pseudo_reg\t\tPARAMS ((rtx));\n+static tree type_main_variant\t\tPARAMS ((tree));\n+static int is_tagged_type\t\tPARAMS ((tree));\n+static const char *dwarf_tag_name\tPARAMS ((unsigned));\n+static const char *dwarf_attr_name\tPARAMS ((unsigned));\n+static const char *dwarf_form_name\tPARAMS ((unsigned));\n+static const char *dwarf_stack_op_name\tPARAMS ((unsigned));\n #if 0\n-static const char *dwarf_type_encoding_name PROTO((unsigned));\n+static const char *dwarf_type_encoding_name PARAMS ((unsigned));\n #endif\n-static tree decl_ultimate_origin\tPROTO((tree));\n-static tree block_ultimate_origin\tPROTO((tree));\n-static tree decl_class_context\t\tPROTO((tree));\n-static void add_dwarf_attr\t\tPROTO((dw_die_ref, dw_attr_ref));\n-static void add_AT_flag\t\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       unsigned));\n-static void add_AT_int\t\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute, long));\n-static void add_AT_unsigned\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       unsigned long));\n-static void add_AT_long_long\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       unsigned long, unsigned long));\n-static void add_AT_float\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       unsigned, long *));\n-static void add_AT_string\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       const char *));\n-static void add_AT_die_ref\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       dw_die_ref));\n-static void add_AT_fde_ref\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       unsigned));\n-static void add_AT_loc\t\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute,\n-\t\t\t\t\t       dw_loc_descr_ref));\n-static void add_AT_addr\t\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute, char *));\n-static void add_AT_lbl_id\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute, char *));\n-static void add_AT_lbl_offset\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute, char *));\n-static dw_attr_ref get_AT\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute));\n-static const char *get_AT_low_pc\tPROTO((dw_die_ref));\n-static const char *get_AT_hi_pc\t\tPROTO((dw_die_ref));\n-static const char *get_AT_string\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute));\n-static int get_AT_flag\t\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute));\n-static unsigned get_AT_unsigned\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute));\n-static int is_c_family\t\t\tPROTO((void));\n-static int is_fortran\t\t\tPROTO((void));\n-static void remove_AT\t\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute));\n-static void remove_children\t\tPROTO((dw_die_ref));\n-static void add_child_die\t\tPROTO((dw_die_ref, dw_die_ref));\n-static dw_die_ref new_die\t\tPROTO((enum dwarf_tag, dw_die_ref));\n-static dw_die_ref lookup_type_die\tPROTO((tree));\n-static void equate_type_number_to_die\tPROTO((tree, dw_die_ref));\n-static dw_die_ref lookup_decl_die\tPROTO((tree));\n-static void equate_decl_number_to_die\tPROTO((tree, dw_die_ref));\n-static dw_loc_descr_ref new_loc_descr\tPROTO((enum dwarf_location_atom,\n-\t\t\t\t\t       unsigned long, unsigned long));\n-static void add_loc_descr\t\tPROTO((dw_loc_descr_ref *,\n-\t\t\t\t\t       dw_loc_descr_ref));\n-static void print_spaces\t\tPROTO((FILE *));\n-static void print_die\t\t\tPROTO((dw_die_ref, FILE *));\n-static void print_dwarf_line_table\tPROTO((FILE *));\n-static void add_sibling_attributes\tPROTO((dw_die_ref));\n-static void build_abbrev_table\t\tPROTO((dw_die_ref));\n-static unsigned long size_of_string\tPROTO((const char *));\n-static unsigned long size_of_loc_descr\tPROTO((dw_loc_descr_ref));\n-static unsigned long size_of_locs\tPROTO((dw_loc_descr_ref));\n-static int constant_size\t\tPROTO((long unsigned));\n-static unsigned long size_of_die\tPROTO((dw_die_ref));\n-static void calc_die_sizes\t\tPROTO((dw_die_ref));\n-static unsigned long size_of_line_prolog\tPROTO((void));\n-static unsigned long size_of_pubnames\tPROTO((void));\n-static unsigned long size_of_aranges\tPROTO((void));\n-static enum dwarf_form value_format\tPROTO((dw_attr_ref));\n-static void output_value_format\t\tPROTO((dw_attr_ref));\n-static void output_abbrev_section\tPROTO((void));\n-static void output_loc_operands\t\tPROTO((dw_loc_descr_ref));\n-static void output_die\t\t\tPROTO((dw_die_ref));\n-static void output_compilation_unit_header PROTO((void));\n-static const char *dwarf2_name\t\tPROTO((tree, int));\n-static void add_pubname\t\t\tPROTO((tree, dw_die_ref));\n-static void output_pubnames\t\tPROTO((void));\n-static void add_arange\t\t\tPROTO((tree, dw_die_ref));\n-static void output_aranges\t\tPROTO((void));\n-static void output_line_info\t\tPROTO((void));\n-static int is_body_block\t\tPROTO((tree));\n-static dw_die_ref base_type_die\t\tPROTO((tree));\n-static tree root_type\t\t\tPROTO((tree));\n-static int is_base_type\t\t\tPROTO((tree));\n-static dw_die_ref modified_type_die\tPROTO((tree, int, int, dw_die_ref));\n-static int type_is_enum\t\t\tPROTO((tree));\n-static dw_loc_descr_ref reg_loc_descriptor PROTO((rtx));\n-static dw_loc_descr_ref based_loc_descr\tPROTO((unsigned, long));\n-static int is_based_loc\t\t\tPROTO((rtx));\n-static dw_loc_descr_ref mem_loc_descriptor PROTO((rtx, enum machine_mode mode));\n-static dw_loc_descr_ref concat_loc_descriptor PROTO((rtx, rtx));\n-static dw_loc_descr_ref loc_descriptor\tPROTO((rtx));\n-static unsigned ceiling\t\t\tPROTO((unsigned, unsigned));\n-static tree field_type\t\t\tPROTO((tree));\n-static unsigned simple_type_align_in_bits PROTO((tree));\n-static unsigned simple_type_size_in_bits PROTO((tree));\n-static unsigned field_byte_offset\t\tPROTO((tree));\n-static void add_AT_location_description\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute, rtx));\n-static void add_data_member_location_attribute PROTO((dw_die_ref, tree));\n-static void add_const_value_attribute\tPROTO((dw_die_ref, rtx));\n-static void add_location_or_const_value_attribute PROTO((dw_die_ref, tree));\n-static void add_name_attribute\t\tPROTO((dw_die_ref, const char *));\n-static void add_bound_info\t\tPROTO((dw_die_ref,\n-\t\t\t\t\t       enum dwarf_attribute, tree));\n-static void add_subscript_info\t\tPROTO((dw_die_ref, tree));\n-static void add_byte_size_attribute\tPROTO((dw_die_ref, tree));\n-static void add_bit_offset_attribute\tPROTO((dw_die_ref, tree));\n-static void add_bit_size_attribute\tPROTO((dw_die_ref, tree));\n-static void add_prototyped_attribute\tPROTO((dw_die_ref, tree));\n-static void add_abstract_origin_attribute PROTO((dw_die_ref, tree));\n-static void add_pure_or_virtual_attribute PROTO((dw_die_ref, tree));\n-static void add_src_coords_attributes\tPROTO((dw_die_ref, tree));\n-static void add_name_and_src_coords_attributes PROTO((dw_die_ref, tree));\n-static void push_decl_scope\t\tPROTO((tree));\n-static dw_die_ref scope_die_for\t\tPROTO((tree, dw_die_ref));\n-static void pop_decl_scope\t\tPROTO((void));\n-static void add_type_attribute\t\tPROTO((dw_die_ref, tree, int, int,\n-\t\t\t\t\t       dw_die_ref));\n-static char *type_tag\t\t\tPROTO((tree));\n-static tree member_declared_type\tPROTO((tree));\n+static tree decl_ultimate_origin\tPARAMS ((tree));\n+static tree block_ultimate_origin\tPARAMS ((tree));\n+static tree decl_class_context\t\tPARAMS ((tree));\n+static void add_dwarf_attr\t\tPARAMS ((dw_die_ref, dw_attr_ref));\n+static void add_AT_flag\t\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t unsigned));\n+static void add_AT_int\t\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute, long));\n+static void add_AT_unsigned\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t unsigned long));\n+static void add_AT_long_long\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t unsigned long,\n+\t\t\t\t\t\t unsigned long));\n+static void add_AT_float\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t unsigned, long *));\n+static void add_AT_string\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t const char *));\n+static void add_AT_die_ref\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t dw_die_ref));\n+static void add_AT_fde_ref\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t unsigned));\n+static void add_AT_loc\t\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t dw_loc_descr_ref));\n+static void add_AT_addr\t\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t char *));\n+static void add_AT_lbl_id\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t char *));\n+static void add_AT_lbl_offset\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute,\n+\t\t\t\t\t\t char *));\n+static dw_attr_ref get_AT\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute));\n+static const char *get_AT_low_pc\tPARAMS ((dw_die_ref));\n+static const char *get_AT_hi_pc\t\tPARAMS ((dw_die_ref));\n+static const char *get_AT_string\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute));\n+static int get_AT_flag\t\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute));\n+static unsigned get_AT_unsigned\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute));\n+static int is_c_family\t\t\tPARAMS ((void));\n+static int is_fortran\t\t\tPARAMS ((void));\n+static void remove_AT\t\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute));\n+static void remove_children\t\tPARAMS ((dw_die_ref));\n+static void add_child_die\t\tPARAMS ((dw_die_ref, dw_die_ref));\n+static dw_die_ref new_die\t\tPARAMS ((enum dwarf_tag, dw_die_ref));\n+static dw_die_ref lookup_type_die\tPARAMS ((tree));\n+static void equate_type_number_to_die\tPARAMS ((tree, dw_die_ref));\n+static dw_die_ref lookup_decl_die\tPARAMS ((tree));\n+static void equate_decl_number_to_die\tPARAMS ((tree, dw_die_ref));\n+static dw_loc_descr_ref new_loc_descr\tPARAMS ((enum dwarf_location_atom,\n+\t\t\t\t\t\t unsigned long,\n+\t\t\t\t\t\t unsigned long));\n+static void add_loc_descr\t\tPARAMS ((dw_loc_descr_ref *,\n+\t\t\t\t\t\t dw_loc_descr_ref));\n+static void print_spaces\t\tPARAMS ((FILE *));\n+static void print_die\t\t\tPARAMS ((dw_die_ref, FILE *));\n+static void print_dwarf_line_table\tPARAMS ((FILE *));\n+static void add_sibling_attributes\tPARAMS ((dw_die_ref));\n+static void build_abbrev_table\t\tPARAMS ((dw_die_ref));\n+static unsigned long size_of_string\tPARAMS ((const char *));\n+static unsigned long size_of_loc_descr\tPARAMS ((dw_loc_descr_ref));\n+static unsigned long size_of_locs\tPARAMS ((dw_loc_descr_ref));\n+static int constant_size\t\tPARAMS ((long unsigned));\n+static unsigned long size_of_die\tPARAMS ((dw_die_ref));\n+static void calc_die_sizes\t\tPARAMS ((dw_die_ref));\n+static unsigned long size_of_line_prolog PARAMS ((void));\n+static unsigned long size_of_pubnames\tPARAMS ((void));\n+static unsigned long size_of_aranges\tPARAMS ((void));\n+static enum dwarf_form value_format\tPARAMS ((dw_attr_ref));\n+static void output_value_format\t\tPARAMS ((dw_attr_ref));\n+static void output_abbrev_section\tPARAMS ((void));\n+static void output_loc_operands\t\tPARAMS ((dw_loc_descr_ref));\n+static void output_die\t\t\tPARAMS ((dw_die_ref));\n+static void output_compilation_unit_header PARAMS ((void));\n+static const char *dwarf2_name\t\tPARAMS ((tree, int));\n+static void add_pubname\t\t\tPARAMS ((tree, dw_die_ref));\n+static void output_pubnames\t\tPARAMS ((void));\n+static void add_arange\t\t\tPARAMS ((tree, dw_die_ref));\n+static void output_aranges\t\tPARAMS ((void));\n+static void output_line_info\t\tPARAMS ((void));\n+static int is_body_block\t\tPARAMS ((tree));\n+static dw_die_ref base_type_die\t\tPARAMS ((tree));\n+static tree root_type\t\t\tPARAMS ((tree));\n+static int is_base_type\t\t\tPARAMS ((tree));\n+static dw_die_ref modified_type_die\tPARAMS ((tree, int, int, dw_die_ref));\n+static int type_is_enum\t\t\tPARAMS ((tree));\n+static dw_loc_descr_ref reg_loc_descriptor PARAMS ((rtx));\n+static dw_loc_descr_ref based_loc_descr\tPARAMS ((unsigned, long));\n+static int is_based_loc\t\t\tPARAMS ((rtx));\n+static dw_loc_descr_ref mem_loc_descriptor PARAMS ((rtx, enum machine_mode mode));\n+static dw_loc_descr_ref concat_loc_descriptor PARAMS ((rtx, rtx));\n+static dw_loc_descr_ref loc_descriptor\tPARAMS ((rtx));\n+static unsigned ceiling\t\t\tPARAMS ((unsigned, unsigned));\n+static tree field_type\t\t\tPARAMS ((tree));\n+static unsigned simple_type_align_in_bits PARAMS ((tree));\n+static unsigned simple_type_size_in_bits PARAMS ((tree));\n+static unsigned field_byte_offset\tPARAMS ((tree));\n+static void add_AT_location_description\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute, rtx));\n+static void add_data_member_location_attribute PARAMS ((dw_die_ref, tree));\n+static void add_const_value_attribute\tPARAMS ((dw_die_ref, rtx));\n+static void add_location_or_const_value_attribute PARAMS ((dw_die_ref, tree));\n+static void add_name_attribute\t\tPARAMS ((dw_die_ref, const char *));\n+static void add_bound_info\t\tPARAMS ((dw_die_ref,\n+\t\t\t\t\t\t enum dwarf_attribute, tree));\n+static void add_subscript_info\t\tPARAMS ((dw_die_ref, tree));\n+static void add_byte_size_attribute\tPARAMS ((dw_die_ref, tree));\n+static void add_bit_offset_attribute\tPARAMS ((dw_die_ref, tree));\n+static void add_bit_size_attribute\tPARAMS ((dw_die_ref, tree));\n+static void add_prototyped_attribute\tPARAMS ((dw_die_ref, tree));\n+static void add_abstract_origin_attribute PARAMS ((dw_die_ref, tree));\n+static void add_pure_or_virtual_attribute PARAMS ((dw_die_ref, tree));\n+static void add_src_coords_attributes\tPARAMS ((dw_die_ref, tree));\n+static void add_name_and_src_coords_attributes PARAMS ((dw_die_ref, tree));\n+static void push_decl_scope\t\tPARAMS ((tree));\n+static dw_die_ref scope_die_for\t\tPARAMS ((tree, dw_die_ref));\n+static void pop_decl_scope\t\tPARAMS ((void));\n+static void add_type_attribute\t\tPARAMS ((dw_die_ref, tree, int, int,\n+\t\t\t\t\t\t dw_die_ref));\n+static char *type_tag\t\t\tPARAMS ((tree));\n+static tree member_declared_type\tPARAMS ((tree));\n #if 0\n-static char *decl_start_label\t\tPROTO((tree));\n+static char *decl_start_label\t\tPARAMS ((tree));\n #endif\n-static void gen_array_type_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_set_type_die\t\tPROTO((tree, dw_die_ref));\n+static void gen_array_type_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_set_type_die\t\tPARAMS ((tree, dw_die_ref));\n #if 0\n-static void gen_entry_point_die\t\tPROTO((tree, dw_die_ref));\n+static void gen_entry_point_die\t\tPARAMS ((tree, dw_die_ref));\n #endif\n-static void gen_inlined_enumeration_type_die PROTO((tree, dw_die_ref));\n-static void gen_inlined_structure_type_die PROTO((tree, dw_die_ref));\n-static void gen_inlined_union_type_die\tPROTO((tree, dw_die_ref));\n-static void gen_enumeration_type_die\tPROTO((tree, dw_die_ref));\n-static dw_die_ref gen_formal_parameter_die PROTO((tree, dw_die_ref));\n-static void gen_unspecified_parameters_die PROTO((tree, dw_die_ref));\n-static void gen_formal_types_die\tPROTO((tree, dw_die_ref));\n-static void gen_subprogram_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_variable_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_label_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_lexical_block_die\tPROTO((tree, dw_die_ref, int));\n-static void gen_inlined_subroutine_die\tPROTO((tree, dw_die_ref, int));\n-static void gen_field_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_ptr_to_mbr_type_die\tPROTO((tree, dw_die_ref));\n-static dw_die_ref gen_compile_unit_die\tPROTO((const char *));\n-static void gen_string_type_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_inheritance_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_member_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_struct_or_union_type_die PROTO((tree, dw_die_ref));\n-static void gen_subroutine_type_die\tPROTO((tree, dw_die_ref));\n-static void gen_typedef_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_type_die\t\tPROTO((tree, dw_die_ref));\n-static void gen_tagged_type_instantiation_die PROTO((tree, dw_die_ref));\n-static void gen_block_die\t\tPROTO((tree, dw_die_ref, int));\n-static void decls_for_scope\t\tPROTO((tree, dw_die_ref, int));\n-static int is_redundant_typedef\t\tPROTO((tree));\n-static void gen_decl_die\t\tPROTO((tree, dw_die_ref));\n-static unsigned lookup_filename\t\tPROTO((const char *));\n-static void add_incomplete_type\t\tPROTO((tree));\n-static void retry_incomplete_types\tPROTO((void));\n-static void gen_type_die_for_member\tPROTO((tree, tree, dw_die_ref));\n-static void gen_abstract_function\tPROTO((tree));\n+static void gen_inlined_enumeration_type_die PARAMS ((tree, dw_die_ref));\n+static void gen_inlined_structure_type_die PARAMS ((tree, dw_die_ref));\n+static void gen_inlined_union_type_die\tPARAMS ((tree, dw_die_ref));\n+static void gen_enumeration_type_die\tPARAMS ((tree, dw_die_ref));\n+static dw_die_ref gen_formal_parameter_die PARAMS ((tree, dw_die_ref));\n+static void gen_unspecified_parameters_die PARAMS ((tree, dw_die_ref));\n+static void gen_formal_types_die\tPARAMS ((tree, dw_die_ref));\n+static void gen_subprogram_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_variable_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_label_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_lexical_block_die\tPARAMS ((tree, dw_die_ref, int));\n+static void gen_inlined_subroutine_die\tPARAMS ((tree, dw_die_ref, int));\n+static void gen_field_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_ptr_to_mbr_type_die\tPARAMS ((tree, dw_die_ref));\n+static dw_die_ref gen_compile_unit_die\tPARAMS ((const char *));\n+static void gen_string_type_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_inheritance_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_member_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_struct_or_union_type_die PARAMS ((tree, dw_die_ref));\n+static void gen_subroutine_type_die\tPARAMS ((tree, dw_die_ref));\n+static void gen_typedef_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_type_die\t\tPARAMS ((tree, dw_die_ref));\n+static void gen_tagged_type_instantiation_die PARAMS ((tree, dw_die_ref));\n+static void gen_block_die\t\tPARAMS ((tree, dw_die_ref, int));\n+static void decls_for_scope\t\tPARAMS ((tree, dw_die_ref, int));\n+static int is_redundant_typedef\t\tPARAMS ((tree));\n+static void gen_decl_die\t\tPARAMS ((tree, dw_die_ref));\n+static unsigned lookup_filename\t\tPARAMS ((const char *));\n+static void add_incomplete_type\t\tPARAMS ((tree));\n+static void retry_incomplete_types\tPARAMS ((void));\n+static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n+static void gen_abstract_function\tPARAMS ((tree));\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -2632,11 +2637,11 @@ static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n /* We allow a language front-end to designate a function that is to be\n    called to \"demangle\" any name before it it put into a DIE.  */\n \n-static const char *(*demangle_name_func) PROTO((const char *));\n+static const char *(*demangle_name_func) PARAMS ((const char *));\n \n void\n dwarf2out_set_demangle_name_func (func)\n-     const char *(*func) PROTO((const char *));\n+     const char *(*func) PARAMS ((const char *));\n {\n   demangle_name_func = func;\n }"}, {"sha": "8046c11246a665c0d36792686dffbdf57ff529a5", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* dwarf2out.h - Various declarations for functions found in dwarf2out.c\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,24 +18,24 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern void dwarf2out_init \t\tPROTO ((FILE *asm_out_file, \n-\t\t\t\t\t\tchar *main_input_filename));\n-extern void dwarf2out_finish\t\tPROTO ((void));\n-\n-extern void dwarf2out_define\t\tPROTO ((unsigned, const char *));\n-extern void dwarf2out_undef \t\tPROTO ((unsigned, const char *));\n-extern void dwarf2out_start_source_file\tPROTO ((const char *));\n-extern void dwarf2out_end_source_file \tPROTO ((void));\n-\n-extern void dwarf2out_begin_block\tPROTO ((unsigned));\n-extern void dwarf2out_end_block\t\tPROTO ((unsigned));\n-extern void dwarf2out_label\t\tPROTO ((rtx));\t\t\t\n-extern void dwarf2out_decl\t\tPROTO ((tree));\t\n-extern void dwarf2out_line\t\tPROTO ((const char *, unsigned));\n-extern void dwarf2out_frame_init\tPROTO ((void));\n-extern void dwarf2out_frame_debug\tPROTO ((rtx));\n-extern void dwarf2out_frame_finish\tPROTO ((void));\n-\n-extern void debug_dwarf\t\t\tPROTO ((void));\n+extern void dwarf2out_init \t\tPARAMS ((FILE *asm_out_file, \n+\t\t\t\t\t\t char *main_input_filename));\n+extern void dwarf2out_finish\t\tPARAMS ((void));\n+\n+extern void dwarf2out_define\t\tPARAMS ((unsigned, const char *));\n+extern void dwarf2out_undef \t\tPARAMS ((unsigned, const char *));\n+extern void dwarf2out_start_source_file\tPARAMS ((const char *));\n+extern void dwarf2out_end_source_file \tPARAMS ((void));\n+\n+extern void dwarf2out_begin_block\tPARAMS ((unsigned));\n+extern void dwarf2out_end_block\t\tPARAMS ((unsigned));\n+extern void dwarf2out_label\t\tPARAMS ((rtx));\t\t\t\n+extern void dwarf2out_decl\t\tPARAMS ((tree));\t\n+extern void dwarf2out_line\t\tPARAMS ((const char *, unsigned));\n+extern void dwarf2out_frame_init\tPARAMS ((void));\n+extern void dwarf2out_frame_debug\tPARAMS ((rtx));\n+extern void dwarf2out_frame_finish\tPARAMS ((void));\n+\n+extern void debug_dwarf\t\t\tPARAMS ((void));\n struct die_struct;\n-extern void debug_dwarf_die\t\tPROTO ((struct die_struct *));\n+extern void debug_dwarf_die\t\tPARAMS ((struct die_struct *));"}, {"sha": "37d33c92fc527588161cf87f75fbe09c924c5335", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* Output Dwarf format symbol table information from the GNU C compiler.\n-   Copyright (C) 1992, 1993, 95-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 95-99, 2000 Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@monkeys.com) of Network Computing Devices.\n \n This file is part of GNU CC.\n@@ -38,7 +38,7 @@ Boston, MA 02111-1307, USA.  */\n \n #if defined(DWARF_TIMESTAMPS)\n #if !defined(POSIX)\n-extern time_t time PROTO ((time_t *)); /* FIXME: use NEED_DECLARATION_TIME */\n+extern time_t time PARAMS ((time_t *)); /* FIXME: use NEED_DECLARATION_TIME */\n #endif /* !defined(POSIX) */\n #endif /* defined(DWARF_TIMESTAMPS) */\n \n@@ -315,140 +315,140 @@ static int in_class;\n \n /* Forward declarations for functions defined in this file.  */\n \n-static const char *dwarf_tag_name\tPROTO((unsigned));\n-static const char *dwarf_attr_name\tPROTO((unsigned));\n-static const char *dwarf_stack_op_name\tPROTO((unsigned));\n-static const char *dwarf_typemod_name\tPROTO((unsigned));\n-static const char *dwarf_fmt_byte_name\tPROTO((unsigned));\n-static const char *dwarf_fund_type_name\tPROTO((unsigned));\n-static tree decl_ultimate_origin\tPROTO((tree));\n-static tree block_ultimate_origin\tPROTO((tree));\n-static tree decl_class_context \t\tPROTO((tree));\n+static const char *dwarf_tag_name\tPARAMS ((unsigned));\n+static const char *dwarf_attr_name\tPARAMS ((unsigned));\n+static const char *dwarf_stack_op_name\tPARAMS ((unsigned));\n+static const char *dwarf_typemod_name\tPARAMS ((unsigned));\n+static const char *dwarf_fmt_byte_name\tPARAMS ((unsigned));\n+static const char *dwarf_fund_type_name\tPARAMS ((unsigned));\n+static tree decl_ultimate_origin\tPARAMS ((tree));\n+static tree block_ultimate_origin\tPARAMS ((tree));\n+static tree decl_class_context \t\tPARAMS ((tree));\n #if 0\n-static void output_unsigned_leb128\tPROTO((unsigned long));\n-static void output_signed_leb128\tPROTO((long));\n+static void output_unsigned_leb128\tPARAMS ((unsigned long));\n+static void output_signed_leb128\tPARAMS ((long));\n #endif\n-static inline int is_body_block\t\tPROTO((tree));\n-static int fundamental_type_code\tPROTO((tree));\n-static tree root_type_1\t\t\tPROTO((tree, int));\n-static tree root_type\t\t\tPROTO((tree));\n-static void write_modifier_bytes_1\tPROTO((tree, int, int, int));\n-static void write_modifier_bytes\tPROTO((tree, int, int));\n-static inline int type_is_fundamental\tPROTO((tree));\n-static void equate_decl_number_to_die_number PROTO((tree));\n-static inline void equate_type_number_to_die_number PROTO((tree));\n-static void output_reg_number\t\tPROTO((rtx));\n-static void output_mem_loc_descriptor\tPROTO((rtx));\n-static void output_loc_descriptor\tPROTO((rtx));\n-static void output_bound_representation\tPROTO((tree, unsigned, int));\n-static void output_enumeral_list\tPROTO((tree));\n-static inline unsigned ceiling\t\tPROTO((unsigned, unsigned));\n-static inline tree field_type\t\tPROTO((tree));\n-static inline unsigned simple_type_align_in_bits PROTO((tree));\n-static inline unsigned simple_type_size_in_bits  PROTO((tree));\n-static unsigned field_byte_offset\tPROTO((tree));\n-static inline void sibling_attribute\tPROTO((void));\n-static void location_attribute\t\tPROTO((rtx));\n-static void data_member_location_attribute PROTO((tree));\n-static void const_value_attribute\tPROTO((rtx));\n-static void location_or_const_value_attribute PROTO((tree));\n-static inline void name_attribute\tPROTO((const char *));\n-static inline void fund_type_attribute\tPROTO((unsigned));\n-static void mod_fund_type_attribute\tPROTO((tree, int, int));\n-static inline void user_def_type_attribute PROTO((tree));\n-static void mod_u_d_type_attribute\tPROTO((tree, int, int));\n+static inline int is_body_block\t\tPARAMS ((tree));\n+static int fundamental_type_code\tPARAMS ((tree));\n+static tree root_type_1\t\t\tPARAMS ((tree, int));\n+static tree root_type\t\t\tPARAMS ((tree));\n+static void write_modifier_bytes_1\tPARAMS ((tree, int, int, int));\n+static void write_modifier_bytes\tPARAMS ((tree, int, int));\n+static inline int type_is_fundamental\tPARAMS ((tree));\n+static void equate_decl_number_to_die_number PARAMS ((tree));\n+static inline void equate_type_number_to_die_number PARAMS ((tree));\n+static void output_reg_number\t\tPARAMS ((rtx));\n+static void output_mem_loc_descriptor\tPARAMS ((rtx));\n+static void output_loc_descriptor\tPARAMS ((rtx));\n+static void output_bound_representation\tPARAMS ((tree, unsigned, int));\n+static void output_enumeral_list\tPARAMS ((tree));\n+static inline unsigned ceiling\t\tPARAMS ((unsigned, unsigned));\n+static inline tree field_type\t\tPARAMS ((tree));\n+static inline unsigned simple_type_align_in_bits PARAMS ((tree));\n+static inline unsigned simple_type_size_in_bits  PARAMS ((tree));\n+static unsigned field_byte_offset\tPARAMS ((tree));\n+static inline void sibling_attribute\tPARAMS ((void));\n+static void location_attribute\t\tPARAMS ((rtx));\n+static void data_member_location_attribute PARAMS ((tree));\n+static void const_value_attribute\tPARAMS ((rtx));\n+static void location_or_const_value_attribute PARAMS ((tree));\n+static inline void name_attribute\tPARAMS ((const char *));\n+static inline void fund_type_attribute\tPARAMS ((unsigned));\n+static void mod_fund_type_attribute\tPARAMS ((tree, int, int));\n+static inline void user_def_type_attribute PARAMS ((tree));\n+static void mod_u_d_type_attribute\tPARAMS ((tree, int, int));\n #ifdef USE_ORDERING_ATTRIBUTE\n-static inline void ordering_attribute\tPROTO((unsigned));\n+static inline void ordering_attribute\tPARAMS ((unsigned));\n #endif /* defined(USE_ORDERING_ATTRIBUTE) */\n-static void subscript_data_attribute\tPROTO((tree));\n-static void byte_size_attribute\t\tPROTO((tree));\n-static inline void bit_offset_attribute\tPROTO((tree));\n-static inline void bit_size_attribute\tPROTO((tree));\n-static inline void element_list_attribute PROTO((tree));\n-static inline void stmt_list_attribute\tPROTO((const char *));\n-static inline void low_pc_attribute\tPROTO((const char *));\n-static inline void high_pc_attribute\tPROTO((const char *));\n-static inline void body_begin_attribute\tPROTO((const char *));\n-static inline void body_end_attribute\tPROTO((const char *));\n-static inline void language_attribute\tPROTO((unsigned));\n-static inline void member_attribute\tPROTO((tree));\n+static void subscript_data_attribute\tPARAMS ((tree));\n+static void byte_size_attribute\t\tPARAMS ((tree));\n+static inline void bit_offset_attribute\tPARAMS ((tree));\n+static inline void bit_size_attribute\tPARAMS ((tree));\n+static inline void element_list_attribute PARAMS ((tree));\n+static inline void stmt_list_attribute\tPARAMS ((const char *));\n+static inline void low_pc_attribute\tPARAMS ((const char *));\n+static inline void high_pc_attribute\tPARAMS ((const char *));\n+static inline void body_begin_attribute\tPARAMS ((const char *));\n+static inline void body_end_attribute\tPARAMS ((const char *));\n+static inline void language_attribute\tPARAMS ((unsigned));\n+static inline void member_attribute\tPARAMS ((tree));\n #if 0\n-static inline void string_length_attribute PROTO((tree));\n+static inline void string_length_attribute PARAMS ((tree));\n #endif\n-static inline void comp_dir_attribute\tPROTO((const char *));\n-static inline void sf_names_attribute\tPROTO((const char *));\n-static inline void src_info_attribute\tPROTO((const char *));\n-static inline void mac_info_attribute\tPROTO((const char *));\n-static inline void prototyped_attribute\tPROTO((tree));\n-static inline void producer_attribute\tPROTO((const char *));\n-static inline void inline_attribute\tPROTO((tree));\n-static inline void containing_type_attribute PROTO((tree));\n-static inline void abstract_origin_attribute PROTO((tree));\n+static inline void comp_dir_attribute\tPARAMS ((const char *));\n+static inline void sf_names_attribute\tPARAMS ((const char *));\n+static inline void src_info_attribute\tPARAMS ((const char *));\n+static inline void mac_info_attribute\tPARAMS ((const char *));\n+static inline void prototyped_attribute\tPARAMS ((tree));\n+static inline void producer_attribute\tPARAMS ((const char *));\n+static inline void inline_attribute\tPARAMS ((tree));\n+static inline void containing_type_attribute PARAMS ((tree));\n+static inline void abstract_origin_attribute PARAMS ((tree));\n #ifdef DWARF_DECL_COORDINATES\n-static inline void src_coords_attribute PROTO((unsigned, unsigned));\n+static inline void src_coords_attribute PARAMS ((unsigned, unsigned));\n #endif /* defined(DWARF_DECL_COORDINATES) */\n-static inline void pure_or_virtual_attribute PROTO((tree));\n-static void name_and_src_coords_attributes PROTO((tree));\n-static void type_attribute\t\tPROTO((tree, int, int));\n-static char *type_tag\t\t\tPROTO((tree));\n-static inline void dienum_push\t\tPROTO((void));\n-static inline void dienum_pop\t\tPROTO((void));\n-static inline tree member_declared_type PROTO((tree));\n-static char *function_start_label\tPROTO((tree));\n-static void output_array_type_die\tPROTO((void *));\n-static void output_set_type_die\t\tPROTO((void *));\n+static inline void pure_or_virtual_attribute PARAMS ((tree));\n+static void name_and_src_coords_attributes PARAMS ((tree));\n+static void type_attribute\t\tPARAMS ((tree, int, int));\n+static char *type_tag\t\t\tPARAMS ((tree));\n+static inline void dienum_push\t\tPARAMS ((void));\n+static inline void dienum_pop\t\tPARAMS ((void));\n+static inline tree member_declared_type PARAMS ((tree));\n+static char *function_start_label\tPARAMS ((tree));\n+static void output_array_type_die\tPARAMS ((void *));\n+static void output_set_type_die\t\tPARAMS ((void *));\n #if 0\n-static void output_entry_point_die\tPROTO((void *));\n+static void output_entry_point_die\tPARAMS ((void *));\n #endif\n-static void output_inlined_enumeration_type_die PROTO((void *));\n-static void output_inlined_structure_type_die PROTO((void *));\n-static void output_inlined_union_type_die PROTO((void *));\n-static void output_enumeration_type_die\tPROTO((void *));\n-static void output_formal_parameter_die\tPROTO((void *));\n-static void output_global_subroutine_die PROTO((void *));\n-static void output_global_variable_die\tPROTO((void *));\n-static void output_label_die\t\tPROTO((void *));\n-static void output_lexical_block_die\tPROTO((void *));\n-static void output_inlined_subroutine_die PROTO((void *));\n-static void output_local_variable_die\tPROTO((void *));\n-static void output_member_die\t\tPROTO((void *));\n+static void output_inlined_enumeration_type_die PARAMS ((void *));\n+static void output_inlined_structure_type_die PARAMS ((void *));\n+static void output_inlined_union_type_die PARAMS ((void *));\n+static void output_enumeration_type_die\tPARAMS ((void *));\n+static void output_formal_parameter_die\tPARAMS ((void *));\n+static void output_global_subroutine_die PARAMS ((void *));\n+static void output_global_variable_die\tPARAMS ((void *));\n+static void output_label_die\t\tPARAMS ((void *));\n+static void output_lexical_block_die\tPARAMS ((void *));\n+static void output_inlined_subroutine_die PARAMS ((void *));\n+static void output_local_variable_die\tPARAMS ((void *));\n+static void output_member_die\t\tPARAMS ((void *));\n #if 0\n-static void output_pointer_type_die\tPROTO((void *));\n-static void output_reference_type_die\tPROTO((void *));\n+static void output_pointer_type_die\tPARAMS ((void *));\n+static void output_reference_type_die\tPARAMS ((void *));\n #endif\n-static void output_ptr_to_mbr_type_die\tPROTO((void *));\n-static void output_compile_unit_die\tPROTO((void *));\n-static void output_string_type_die\tPROTO((void *));\n-static void output_inheritance_die\tPROTO((void *));\n-static void output_structure_type_die\tPROTO((void *));\n-static void output_local_subroutine_die PROTO((void *));\n-static void output_subroutine_type_die\tPROTO((void *));\n-static void output_typedef_die\t\tPROTO((void *));\n-static void output_union_type_die\tPROTO((void *));\n-static void output_unspecified_parameters_die PROTO((void *));\n-static void output_padded_null_die\tPROTO((void *));\n-static void output_die\t\t\tPROTO((void (*) PROTO((void *)), void *));\n-static void end_sibling_chain\t\tPROTO((void));\n-static void output_formal_types\t\tPROTO((tree));\n-static void pend_type\t\t\tPROTO((tree));\n-static int type_ok_for_scope\t\tPROTO((tree, tree));\n-static void output_pending_types_for_scope PROTO((tree));\n-static void output_type\t\t\tPROTO((tree, tree));\n-static void output_tagged_type_instantiation PROTO((tree));\n-static void output_block\t\tPROTO((tree, int));\n-static void output_decls_for_scope\tPROTO((tree, int));\n-static void output_decl\t\t\tPROTO((tree, tree));\n-static void shuffle_filename_entry\tPROTO((filename_entry *));\n-static void generate_new_sfname_entry\tPROTO((void));\n-static unsigned lookup_filename\t\tPROTO((const char *));\n-static void generate_srcinfo_entry\tPROTO((unsigned, unsigned));\n-static void generate_macinfo_entry\tPROTO((const char *, const char *));\n-static int is_pseudo_reg\t\tPROTO((rtx));\n-static tree type_main_variant\t\tPROTO((tree));\n-static int is_tagged_type\t\tPROTO((tree));\n-static int is_redundant_typedef\t\tPROTO((tree));\n-static void add_incomplete_type\t\tPROTO((tree));\n-static void retry_incomplete_types\tPROTO((void));\n+static void output_ptr_to_mbr_type_die\tPARAMS ((void *));\n+static void output_compile_unit_die\tPARAMS ((void *));\n+static void output_string_type_die\tPARAMS ((void *));\n+static void output_inheritance_die\tPARAMS ((void *));\n+static void output_structure_type_die\tPARAMS ((void *));\n+static void output_local_subroutine_die PARAMS ((void *));\n+static void output_subroutine_type_die\tPARAMS ((void *));\n+static void output_typedef_die\t\tPARAMS ((void *));\n+static void output_union_type_die\tPARAMS ((void *));\n+static void output_unspecified_parameters_die PARAMS ((void *));\n+static void output_padded_null_die\tPARAMS ((void *));\n+static void output_die\t\t\tPARAMS ((void (*)(void *), void *));\n+static void end_sibling_chain\t\tPARAMS ((void));\n+static void output_formal_types\t\tPARAMS ((tree));\n+static void pend_type\t\t\tPARAMS ((tree));\n+static int type_ok_for_scope\t\tPARAMS ((tree, tree));\n+static void output_pending_types_for_scope PARAMS ((tree));\n+static void output_type\t\t\tPARAMS ((tree, tree));\n+static void output_tagged_type_instantiation PARAMS ((tree));\n+static void output_block\t\tPARAMS ((tree, int));\n+static void output_decls_for_scope\tPARAMS ((tree, int));\n+static void output_decl\t\t\tPARAMS ((tree, tree));\n+static void shuffle_filename_entry\tPARAMS ((filename_entry *));\n+static void generate_new_sfname_entry\tPARAMS ((void));\n+static unsigned lookup_filename\t\tPARAMS ((const char *));\n+static void generate_srcinfo_entry\tPARAMS ((unsigned, unsigned));\n+static void generate_macinfo_entry\tPARAMS ((const char *, const char *));\n+static int is_pseudo_reg\t\tPARAMS ((rtx));\n+static tree type_main_variant\t\tPARAMS ((tree));\n+static int is_tagged_type\t\tPARAMS ((tree));\n+static int is_redundant_typedef\t\tPARAMS ((tree));\n+static void add_incomplete_type\t\tPARAMS ((tree));\n+static void retry_incomplete_types\tPARAMS ((void));\n \f\n /* Definitions of defaults for assembler-dependent names of various\n    pseudo-ops and section names.\n@@ -3999,7 +3999,7 @@ output_padded_null_die (arg)\n \n static void\n output_die (die_specific_output_function, param)\n-     register void (*die_specific_output_function) PROTO ((void *));\n+     register void (*die_specific_output_function) PARAMS ((void *));\n      register void *param;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -5094,7 +5094,7 @@ output_decl (decl, containing_scope)\n \t function.  */\n \n       {\n-        register void (*func) PROTO((void *));\n+        register void (*func) PARAMS ((void *));\n \tregister tree origin = decl_ultimate_origin (decl);\n \n \tif (origin != NULL && TREE_CODE (origin) == PARM_DECL)"}, {"sha": "c09469a36a88335db02f367e6711b84301a2cb14", "filename": "gcc/dwarfout.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarfout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdwarfout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.h?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* dwarfout.h - Various declarations for functions found in dwarfout.c\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -18,25 +18,25 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern void dwarfout_init \t\tPROTO ((FILE *asm_out_file, \n+extern void dwarfout_init \t\tPARAMS ((FILE *asm_out_file, \n \t\t\t\t\t\tchar *main_input_filename));\n-extern void dwarfout_finish\t\tPROTO ((void));\n+extern void dwarfout_finish\t\tPARAMS ((void));\n \n-extern void dwarfout_define\t\tPROTO ((unsigned, const char *));\n-extern void dwarfout_undef \t\tPROTO ((unsigned, const char *));\n-extern void dwarfout_file_scope_decl \tPROTO ((tree , int));\n-extern void dwarfout_start_new_source_file \tPROTO ((const char *));\n-extern void dwarfout_resume_previous_source_file\tPROTO((unsigned));\n+extern void dwarfout_define\t\tPARAMS ((unsigned, const char *));\n+extern void dwarfout_undef \t\tPARAMS ((unsigned, const char *));\n+extern void dwarfout_file_scope_decl \tPARAMS ((tree , int));\n+extern void dwarfout_start_new_source_file PARAMS ((const char *));\n+extern void dwarfout_resume_previous_source_file PARAMS ((unsigned));\n \n-extern void dwarfout_begin_function\tPROTO ((void));\n-extern void dwarfout_end_function\tPROTO ((void));\n-extern void dwarfout_begin_epilogue\tPROTO ((void));\n-extern void dwarfout_end_epilogue\tPROTO ((void));\n-extern void dwarfout_begin_block\tPROTO ((unsigned));\n-extern void dwarfout_end_block\t\tPROTO ((unsigned));\n+extern void dwarfout_begin_function\tPARAMS ((void));\n+extern void dwarfout_end_function\tPARAMS ((void));\n+extern void dwarfout_begin_epilogue\tPARAMS ((void));\n+extern void dwarfout_end_epilogue\tPARAMS ((void));\n+extern void dwarfout_begin_block\tPARAMS ((unsigned));\n+extern void dwarfout_end_block\t\tPARAMS ((unsigned));\n \n #ifdef RTX_CODE\n-extern void dwarfout_label\t\tPROTO ((rtx));\n+extern void dwarfout_label\t\tPARAMS ((rtx));\n #endif\n-extern void dwarfout_line\t\tPROTO ((const char *, unsigned));\n+extern void dwarfout_line\t\tPARAMS ((const char *, unsigned));\n "}, {"sha": "561bff4351cd3fa7621a32244083c842fbbf25a4", "filename": "gcc/dyn-string.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d2b3b9dc691168719b0c77bc5c9a4d10e6384b/gcc%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdyn-string.h?ref=83d2b3b9dc691168719b0c77bc5c9a4d10e6384b", "patch": "@@ -1,5 +1,5 @@\n /* An abstract string datatype.\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n \n This file is part of GNU CC.\n@@ -27,7 +27,7 @@ typedef struct dyn_string\n   char *s;\t\t/* The string itself, NUL-terminated.  */\n }* dyn_string_t;\n \n-extern dyn_string_t dyn_string_new      PROTO((int));\n-extern void dyn_string_delete           PROTO((dyn_string_t));\n-extern dyn_string_t dyn_string_append   PROTO((dyn_string_t, const char*));\n-extern dyn_string_t dyn_string_resize   PROTO((dyn_string_t, int));\n+extern dyn_string_t dyn_string_new      PARAMS ((int));\n+extern void dyn_string_delete           PARAMS ((dyn_string_t));\n+extern dyn_string_t dyn_string_append   PARAMS ((dyn_string_t, const char*));\n+extern dyn_string_t dyn_string_resize   PARAMS ((dyn_string_t, int));"}]}