{"sha": "ea41822adfb3ea39ba43e033acd1f745abd79083", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE0MTgyMmFkZmIzZWEzOWJhNDNlMDMzYWNkMWY3NDVhYmQ3OTA4Mw==", "commit": {"author": {"name": "Yury Gribov", "email": "y.gribov@samsung.com", "date": "2014-10-28T09:43:20Z"}, "committer": {"name": "Yury Gribov", "email": "ygribov@gcc.gnu.org", "date": "2014-10-28T09:43:20Z"}, "message": "Add strtoll and strtoull to libiberty.\n\n2014-10-28  Yury Gribov  <y.gribov@samsung.com>\n\ninclude/\n\t* libiberty.h (strtol, strtoul, strtoll, strtoull): New prototypes.\n\nlibiberty/\n\t* strtoll.c: New file.\n\t* strtoull.c: New file.\n\t* configure.ac: Add long long checks.  Add harness for strtoll and\n\tstrtoull.  Check decls for strtol, strtoul, strtoll, strtoull.\n\t* Makefile.in (CFILES, CONFIGURED_OFILES): Add strtoll and strtoull.\n\t* config.in: Regenerate.\n\t* configure: Regenerate.\n\t* functions.texi: Regenerate.\n\t* testsuite/Makefile.in (check-strtol): New rule.\n\t(test-strtol): Likewise.\n\t(mostlyclean): Clean up strtol test.\n\t* testsuite/test-strtol.c: New test.\n\nFrom-SVN: r216772", "tree": {"sha": "dedbff4ce1f502ec222e9433c1109ec7759babf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dedbff4ce1f502ec222e9433c1109ec7759babf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea41822adfb3ea39ba43e033acd1f745abd79083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea41822adfb3ea39ba43e033acd1f745abd79083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea41822adfb3ea39ba43e033acd1f745abd79083", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea41822adfb3ea39ba43e033acd1f745abd79083/comments", "author": null, "committer": null, "parents": [{"sha": "5b595d80ce5f3f74415e91532542a58c1be6a9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b595d80ce5f3f74415e91532542a58c1be6a9c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b595d80ce5f3f74415e91532542a58c1be6a9c4"}], "stats": {"total": 770, "additions": 752, "deletions": 18}, "files": [{"sha": "d2d14721f093872cb08ac93f71fa282e8c37ad03", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -1,3 +1,7 @@\n+2014-10-28  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* libiberty.h (strtol, strtoul, strtoll, strtoull): New prototypes.\n+\n 2014-10-27  Phil Muldoon  <pmuldoon@redhat.com>\n \t    Jan Kratochvil  <jan.kratochvil@redhat.com>\n \t    Tom Tromey  <tromey@redhat.com>"}, {"sha": "571e85f1e9ee99f5f879b26af55f10056ddf6cc8", "filename": "include/libiberty.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -655,6 +655,33 @@ extern size_t strnlen (const char *, size_t);\n extern int strverscmp (const char *, const char *);\n #endif\n \n+#if defined(HAVE_DECL_STRTOL) && !HAVE_DECL_STRTOL\n+extern long int strtol (const char *nptr,\n+                        char **endptr, int base);\n+#endif\n+\n+#if defined(HAVE_DECL_STRTOUL) && !HAVE_DECL_STRTOUL\n+extern unsigned long int strtoul (const char *nptr,\n+                                  char **endptr, int base);\n+#endif\n+\n+#if defined(HAVE_LONG_LONG) && defined(HAVE_DECL_STRTOLL) && !HAVE_DECL_STRTOLL\n+__extension__\n+extern long long int strtoll (const char *nptr,\n+                              char **endptr, int base);\n+#endif\n+\n+#if defined(HAVE_LONG_LONG) && defined(HAVE_DECL_STRTOULL) && !HAVE_DECL_STRTOULL\n+__extension__\n+extern unsigned long long int strtoull (const char *nptr,\n+                                        char **endptr, int base);\n+#endif\n+\n+#if defined(HAVE_DECL_STRVERSCMP) && !HAVE_DECL_STRVERSCMP\n+/* Compare version strings.  */\n+extern int strverscmp (const char *, const char *);\n+#endif\n+\n /* Set the title of a process */\n extern void setproctitle (const char *name, ...);\n "}, {"sha": "d30a80b22abd6917d6ade7dd397e4d210507e0f9", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -1,3 +1,18 @@\n+2014-10-28  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* strtoll.c: New file.\n+\t* strtoull.c: New file.\n+\t* configure.ac: Add long long checks.  Add harness for strtoll and\n+\tstrtoull.  Check decls for strtol, strtoul, strtoll, strtoull.\n+\t* Makefile.in (CFILES, CONFIGURED_OFILES): Add strtoll and strtoull.\n+\t* config.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* functions.texi: Regenerate.\n+\t* testsuite/Makefile.in (check-strtol): New rule.\n+\t(test-strtol): Likewise.\n+\t(mostlyclean): Clean up strtol test.\n+\t* testsuite/test-strtol.c: New test.\n+\n 2014-10-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* choose-temp.c (choose_tmpdir): Remove now-redundant local"}, {"sha": "1b0d8ae782bfd579c4e339c4563c16aebd67ea90", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -152,8 +152,8 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \t spaces.c splay-tree.c stack-limit.c stpcpy.c stpncpy.c\t\t\\\n \t strcasecmp.c strchr.c strdup.c strerror.c strncasecmp.c\t\\\n \t strncmp.c strrchr.c strsignal.c strstr.c strtod.c strtol.c\t\\\n-\t strtoul.c strndup.c strnlen.c strverscmp.c\t\t\t\\\n-\ttimeval-utils.c tmpnam.c\t\t\t\t\t\\\n+\t strtoll.c strtoul.c strtoull.c strndup.c strnlen.c             \\\n+\t strverscmp.c timeval-utils.c tmpnam.c\t\t\t\t\\\n \tunlink-if-ordinary.c\t\t\t\t\t\t\\\n \tvasprintf.c vfork.c vfprintf.c vprintf.c vsnprintf.c vsprintf.c\t\\\n \twaitpid.c\t\t\t\t\t\t\t\\\n@@ -219,8 +219,8 @@ CONFIGURED_OFILES = ./asprintf.$(objext) ./atexit.$(objext)\t\t\\\n \t ./strchr.$(objext) ./strdup.$(objext) ./strncasecmp.$(objext)\t\\\n \t ./strncmp.$(objext) ./strndup.$(objext) ./strnlen.$(objext)\t\\\n \t ./strrchr.$(objext) ./strstr.$(objext) ./strtod.$(objext)\t\\\n-\t ./strtol.$(objext) ./strtoul.$(objext) ./strverscmp.$(objext)\t\\\n-\t./tmpnam.$(objext)\t\t\t\t\t\t\\\n+\t ./strtol.$(objext) ./strtoul.$(objext) strtoll.$(objext)\t\\\n+\t./strtoull.$(objext) ./tmpnam.$(objext) ./strverscmp.$(objext)\t\\\n \t./vasprintf.$(objext) ./vfork.$(objext) ./vfprintf.$(objext)\t\\\n \t ./vprintf.$(objext) ./vsnprintf.$(objext) ./vsprintf.$(objext)\t\\\n \t./waitpid.$(objext)\n@@ -694,6 +694,17 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/crc32.c $(OUTPUT_OPTION)\n \n+./d-demangle.$(objext): $(srcdir)/d-demangle.c config.h $(INCDIR)/ansidecl.h \\\n+\t$(INCDIR)/demangle.h $(INCDIR)/libiberty.h \\\n+\t$(INCDIR)/safe-ctype.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/d-demangle.c -o pic/$@; \\\n+\telse true; fi\n+\tif [ x\"$(NOASANFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/d-demangle.c -o noasan/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/d-demangle.c $(OUTPUT_OPTION)\n+\n ./dwarfnames.$(objext): $(srcdir)/dwarfnames.c $(INCDIR)/dwarf2.def \\\n \t$(INCDIR)/dwarf2.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n@@ -714,14 +725,6 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/dyn-string.c $(OUTPUT_OPTION)\n \n-./d-demangle.$(objext): $(srcdir)/d-demangle.c config.h $(INCDIR)/ansidecl.h \\\n-\t$(srcdir)/cp-demangle.h $(INCDIR)/demangle.h \\\n-\t$(INCDIR)/dyn-string.h $(INCDIR)/getopt.h $(INCDIR)/libiberty.h\n-\tif [ x\"$(PICFLAG)\" != x ]; then \\\n-\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/d-demangle.c -o pic/$@; \\\n-\telse true; fi\n-\t$(COMPILE.c) $(srcdir)/d-demangle.c $(OUTPUT_OPTION)\n-\n ./fdmatch.$(objext): $(srcdir)/fdmatch.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n@@ -1471,6 +1474,15 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/strtol.c $(OUTPUT_OPTION)\n \n+./strtoll.$(objext): $(srcdir)/strtoll.c config.h $(INCDIR)/safe-ctype.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/strtoll.c -o pic/$@; \\\n+\telse true; fi\n+\tif [ x\"$(NOASANFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/strtoll.c -o noasan/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/strtoll.c $(OUTPUT_OPTION)\n+\n ./strtoul.$(objext): $(srcdir)/strtoul.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/safe-ctype.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n@@ -1481,6 +1493,16 @@ $(CONFIGURED_OFILES): stamp-picdir stamp-noasandir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/strtoul.c $(OUTPUT_OPTION)\n \n+./strtoull.$(objext): $(srcdir)/strtoull.c config.h $(INCDIR)/ansidecl.h \\\n+\t$(INCDIR)/safe-ctype.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/strtoull.c -o pic/$@; \\\n+\telse true; fi\n+\tif [ x\"$(NOASANFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(NOASANFLAG) $(srcdir)/strtoull.c -o noasan/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/strtoull.c $(OUTPUT_OPTION)\n+\n ./strverscmp.$(objext): $(srcdir)/strverscmp.c $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\"}, {"sha": "7c05b9d846e62f1218825128a68a638322c71f3f", "filename": "libiberty/config.in", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.in?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -79,6 +79,22 @@\n    don't. */\n #undef HAVE_DECL_SNPRINTF\n \n+/* Define to 1 if you have the declaration of `strtol', and to 0 if you don't.\n+   */\n+#undef HAVE_DECL_STRTOL\n+\n+/* Define to 1 if you have the declaration of `strtoll', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_STRTOLL\n+\n+/* Define to 1 if you have the declaration of `strtoul', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_STRTOUL\n+\n+/* Define to 1 if you have the declaration of `strtoull', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_STRTOULL\n+\n /* Define to 1 if you have the declaration of `strverscmp', and to 0 if you\n    don't. */\n #undef HAVE_DECL_STRVERSCMP\n@@ -136,6 +152,9 @@\n /* Define to 1 if you have the <limits.h> header file. */\n #undef HAVE_LIMITS_H\n \n+/* Define if you have the `long long' type. */\n+#undef HAVE_LONG_LONG\n+\n /* Define to 1 if you have the <machine/hal_sysinfo.h> header file. */\n #undef HAVE_MACHINE_HAL_SYSINFO_H\n \n@@ -280,9 +299,15 @@\n /* Define to 1 if you have the `strtol' function. */\n #undef HAVE_STRTOL\n \n+/* Define to 1 if you have the `strtoll' function. */\n+#undef HAVE_STRTOLL\n+\n /* Define to 1 if you have the `strtoul' function. */\n #undef HAVE_STRTOUL\n \n+/* Define to 1 if you have the `strtoull' function. */\n+#undef HAVE_STRTOULL\n+\n /* Define to 1 if you have the `strverscmp' function. */\n #undef HAVE_STRVERSCMP\n \n@@ -439,6 +464,12 @@\n /* The size of `int', as computed by sizeof. */\n #undef SIZEOF_INT\n \n+/* The size of `long', as computed by sizeof. */\n+#undef SIZEOF_LONG\n+\n+/* The size of `long long', as computed by sizeof. */\n+#undef SIZEOF_LONG_LONG\n+\n /* Define if you know the direction of stack growth for your system; otherwise\n    it will be automatically deduced at run-time. STACK_DIRECTION > 0 => grows\n    toward higher addresses STACK_DIRECTION < 0 => grows toward lower addresses"}, {"sha": "4a5e40ab8cc46defedd08e60ca9d3a1d4cfd5b8e", "filename": "libiberty/configure", "status": "modified", "additions": 120, "deletions": 2, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -5124,7 +5124,7 @@ $as_echo \"#define NEED_DECLARATION_ERRNO 1\" >>confdefs.h\n fi\n \n \n-# Determine the size of an int for struct fibnode.\n+# Determine sizes of some types.\n # The cast to long int works around a bug in the HP C Compiler\n # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n@@ -5159,6 +5159,82 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n+# The cast to long int works around a bug in the HP C Compiler\n+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n+# This bug is HP SR number 8606223364.\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking size of long\" >&5\n+$as_echo_n \"checking size of long... \" >&6; }\n+if test \"${ac_cv_sizeof_long+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if ac_fn_c_compute_int \"$LINENO\" \"(long int) (sizeof (long))\" \"ac_cv_sizeof_long\"        \"$ac_includes_default\"; then :\n+\n+else\n+  if test \"$ac_cv_type_long\" = yes; then\n+     { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+{ as_fn_set_status 77\n+as_fn_error \"cannot compute sizeof (long)\n+See \\`config.log' for more details.\" \"$LINENO\" 5; }; }\n+   else\n+     ac_cv_sizeof_long=0\n+   fi\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long\" >&5\n+$as_echo \"$ac_cv_sizeof_long\" >&6; }\n+\n+\n+\n+cat >>confdefs.h <<_ACEOF\n+#define SIZEOF_LONG $ac_cv_sizeof_long\n+_ACEOF\n+\n+\n+\n+# Check for presense of long long\n+ac_fn_c_check_type \"$LINENO\" \"long long\" \"ac_cv_type_long_long\" \"$ac_includes_default\"\n+if test \"x$ac_cv_type_long_long\" = x\"\"yes; then :\n+\n+$as_echo \"#define HAVE_LONG_LONG 1\" >>confdefs.h\n+ # The cast to long int works around a bug in the HP C Compiler\n+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n+# This bug is HP SR number 8606223364.\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking size of long long\" >&5\n+$as_echo_n \"checking size of long long... \" >&6; }\n+if test \"${ac_cv_sizeof_long_long+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if ac_fn_c_compute_int \"$LINENO\" \"(long int) (sizeof (long long))\" \"ac_cv_sizeof_long_long\"        \"$ac_includes_default\"; then :\n+\n+else\n+  if test \"$ac_cv_type_long_long\" = yes; then\n+     { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+{ as_fn_set_status 77\n+as_fn_error \"cannot compute sizeof (long long)\n+See \\`config.log' for more details.\" \"$LINENO\" 5; }; }\n+   else\n+     ac_cv_sizeof_long_long=0\n+   fi\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_long_long\" >&5\n+$as_echo \"$ac_cv_sizeof_long_long\" >&6; }\n+\n+\n+\n+cat >>confdefs.h <<_ACEOF\n+#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long\n+_ACEOF\n+\n+\n+fi\n+\n \n # Look for a 64-bit type.\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for a 64-bit type\" >&5\n@@ -5387,6 +5463,8 @@ funcs=\"$funcs strstr\"\n funcs=\"$funcs strtod\"\n funcs=\"$funcs strtol\"\n funcs=\"$funcs strtoul\"\n+funcs=\"$funcs strtoll\"\n+funcs=\"$funcs strtoull\"\n funcs=\"$funcs strverscmp\"\n funcs=\"$funcs tmpnam\"\n funcs=\"$funcs vasprintf\"\n@@ -5423,7 +5501,7 @@ if test \"x\" = \"y\"; then\n     sbrk setenv setproctitle setrlimit sigsetmask snprintf spawnve spawnvpe \\\n      stpcpy stpncpy strcasecmp strchr strdup \\\n      strerror strncasecmp strndup strnlen strrchr strsignal strstr strtod \\\n-     strtol strtoul strverscmp sysconf sysctl sysmp \\\n+     strtol strtoul strtoll strtoull strverscmp sysconf sysctl sysmp \\\n     table times tmpnam \\\n     vasprintf vfprintf vprintf vsprintf \\\n     wait3 wait4 waitpid\n@@ -5499,6 +5577,46 @@ fi\n cat >>confdefs.h <<_ACEOF\n #define HAVE_DECL_VSNPRINTF $ac_have_decl\n _ACEOF\n+ac_fn_c_check_decl \"$LINENO\" \"strtol\" \"ac_cv_have_decl_strtol\" \"$ac_includes_default\"\n+if test \"x$ac_cv_have_decl_strtol\" = x\"\"yes; then :\n+  ac_have_decl=1\n+else\n+  ac_have_decl=0\n+fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_STRTOL $ac_have_decl\n+_ACEOF\n+ac_fn_c_check_decl \"$LINENO\" \"strtoul\" \"ac_cv_have_decl_strtoul\" \"$ac_includes_default\"\n+if test \"x$ac_cv_have_decl_strtoul\" = x\"\"yes; then :\n+  ac_have_decl=1\n+else\n+  ac_have_decl=0\n+fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_STRTOUL $ac_have_decl\n+_ACEOF\n+ac_fn_c_check_decl \"$LINENO\" \"strtoll\" \"ac_cv_have_decl_strtoll\" \"$ac_includes_default\"\n+if test \"x$ac_cv_have_decl_strtoll\" = x\"\"yes; then :\n+  ac_have_decl=1\n+else\n+  ac_have_decl=0\n+fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_STRTOLL $ac_have_decl\n+_ACEOF\n+ac_fn_c_check_decl \"$LINENO\" \"strtoull\" \"ac_cv_have_decl_strtoull\" \"$ac_includes_default\"\n+if test \"x$ac_cv_have_decl_strtoull\" = x\"\"yes; then :\n+  ac_have_decl=1\n+else\n+  ac_have_decl=0\n+fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_STRTOULL $ac_have_decl\n+_ACEOF\n \n \n $as_echo \"#define HAVE_SYS_ERRLIST 1\" >>confdefs.h"}, {"sha": "90adaea1ad2f3ef38cb1c01e714265fdca0955f2", "filename": "libiberty/configure.ac", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.ac?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -272,8 +272,14 @@ AC_HEADER_TIME\n \n libiberty_AC_DECLARE_ERRNO\n \n-# Determine the size of an int for struct fibnode.\n+# Determine sizes of some types.\n AC_CHECK_SIZEOF([int])\n+AC_CHECK_SIZEOF([long])\n+\n+# Check for presense of long long\n+AC_CHECK_TYPE([long long],\n+  [AC_DEFINE(HAVE_LONG_LONG, 1, [Define if you have the `long long' type.]) AC_CHECK_SIZEOF([long long])],\n+  [])\n \n # Look for a 64-bit type.\n AC_MSG_CHECKING([for a 64-bit type])\n@@ -365,6 +371,8 @@ funcs=\"$funcs strstr\"\n funcs=\"$funcs strtod\"\n funcs=\"$funcs strtol\"\n funcs=\"$funcs strtoul\"\n+funcs=\"$funcs strtoll\"\n+funcs=\"$funcs strtoull\"\n funcs=\"$funcs strverscmp\"\n funcs=\"$funcs tmpnam\"\n funcs=\"$funcs vasprintf\"\n@@ -401,11 +409,11 @@ if test \"x\" = \"y\"; then\n     sbrk setenv setproctitle setrlimit sigsetmask snprintf spawnve spawnvpe \\\n      stpcpy stpncpy strcasecmp strchr strdup \\\n      strerror strncasecmp strndup strnlen strrchr strsignal strstr strtod \\\n-     strtol strtoul strverscmp sysconf sysctl sysmp \\\n+     strtol strtoul strtoll strtoull strverscmp sysconf sysctl sysmp \\\n     table times tmpnam \\\n     vasprintf vfprintf vprintf vsprintf \\\n     wait3 wait4 waitpid)\n-  AC_CHECK_DECLS([basename(char *), ffs, asprintf, vasprintf, snprintf, vsnprintf])\n+  AC_CHECK_DECLS([basename(char *), ffs, asprintf, vasprintf, snprintf, vsnprintf, strtol, strtoul, strtoll, strtoull])\n   AC_DEFINE(HAVE_SYS_ERRLIST, 1, [Define if you have the sys_errlist variable.])\n   AC_DEFINE(HAVE_SYS_NERR,    1, [Define if you have the sys_nerr variable.])\n   AC_DEFINE(HAVE_SYS_SIGLIST, 1, [Define if you have the sys_siglist variable.])"}, {"sha": "3627285f9059c9cf552f0a247e221079208176a5", "filename": "libiberty/functions.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -1714,6 +1714,24 @@ that the converted value is unsigned.\n \n @end deftypefn\n \n+@c strtoll.c:33\n+@deftypefn Supplemental {long long int} strtoll (const char *@var{string}, @\n+  char **@var{endptr}, int @var{base})\n+@deftypefnx Supplemental {unsigned long long int} strtoul (@\n+  const char *@var{string}, char **@var{endptr}, int @var{base})\n+\n+The @code{strtoll} function converts the string in @var{string} to a\n+long long integer value according to the given @var{base}, which must be\n+between 2 and 36 inclusive, or be the special value 0.  If @var{base}\n+is 0, @code{strtoll} will look for the prefixes @code{0} and @code{0x}\n+to indicate bases 8 and 16, respectively, else default to base 10.\n+When the base is 16 (either explicitly or implicitly), a prefix of\n+@code{0x} is allowed.  The handling of @var{endptr} is as that of\n+@code{strtod} above.  The @code{strtoull} function is the same, except\n+that the converted value is unsigned.\n+\n+@end deftypefn\n+\n @c strsignal.c:502\n @deftypefn Extension int strtosigno (const char *@var{name})\n "}, {"sha": "37ff8cd3d4c4579cc81572a1cba13b920a4f380e", "filename": "libiberty/strtoll.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fstrtoll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fstrtoll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrtoll.c?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -0,0 +1,175 @@\n+/*-\n+ * Copyright (c) 2014 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. [rescinded 22 July 1999]\n+ * 4. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\n+\n+/*\n+\n+@deftypefn Supplemental {long long int} strtoll (const char *@var{string}, @\n+  char **@var{endptr}, int @var{base})\n+@deftypefnx Supplemental {unsigned long long int} strtoul (@\n+  const char *@var{string}, char **@var{endptr}, int @var{base})\n+\n+The @code{strtoll} function converts the string in @var{string} to a\n+long long integer value according to the given @var{base}, which must be\n+between 2 and 36 inclusive, or be the special value 0.  If @var{base}\n+is 0, @code{strtoll} will look for the prefixes @code{0} and @code{0x}\n+to indicate bases 8 and 16, respectively, else default to base 10.\n+When the base is 16 (either explicitly or implicitly), a prefix of\n+@code{0x} is allowed.  The handling of @var{endptr} is as that of\n+@code{strtod} above.  The @code{strtoull} function is the same, except\n+that the converted value is unsigned.\n+\n+@end deftypefn\n+\n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>\n+#endif\n+#include <errno.h>\n+#ifdef NEED_DECLARATION_ERRNO\n+extern int errno;\n+#endif\n+#include \"safe-ctype.h\"\n+\n+#ifdef HAVE_LONG_LONG\n+\n+__extension__\n+typedef unsigned long long ullong_type;\n+\n+__extension__\n+typedef long long llong_type;\n+\n+/* FIXME: It'd be nice to configure around these, but the include files are too\n+   painful.  These macros should at least be more portable than hardwired hex\n+   constants. */\n+\n+#ifndef ULLONG_MAX\n+#define ULLONG_MAX (~(ullong_type)0) /* 0xFFFFFFFFFFFFFFFF */\n+#endif\n+\n+#ifndef LLONG_MAX\n+#define LLONG_MAX ((llong_type)(ULLONG_MAX >> 1)) /* 0x7FFFFFFFFFFFFFFF */\n+#endif\n+\n+#ifndef LLONG_MIN\n+#define LLONG_MIN (~LLONG_MAX) /* 0x8000000000000000 */\n+#endif\n+\n+/*\n+ * Convert a string to a long long integer.\n+ *\n+ * Ignores `locale' stuff.  Assumes that the upper and lower case\n+ * alphabets and digits are each contiguous.\n+ */\n+llong_type\n+strtoll(const char *nptr, char **endptr, register int base)\n+{\n+\tregister const char *s = nptr;\n+\tregister ullong_type acc;\n+\tregister int c;\n+\tregister ullong_type cutoff;\n+\tregister int neg = 0, any, cutlim;\n+\n+\t/*\n+\t * Skip white space and pick up leading +/- sign if any.\n+\t * If base is 0, allow 0x for hex and 0 for octal, else\n+\t * assume decimal; if base is already 16, allow 0x.\n+\t */\n+\tdo {\n+\t\tc = *s++;\n+\t} while (ISSPACE(c));\n+\tif (c == '-') {\n+\t\tneg = 1;\n+\t\tc = *s++;\n+\t} else if (c == '+')\n+\t\tc = *s++;\n+\tif ((base == 0 || base == 16) &&\n+\t    c == '0' && (*s == 'x' || *s == 'X')) {\n+\t\tc = s[1];\n+\t\ts += 2;\n+\t\tbase = 16;\n+\t}\n+\tif (base == 0)\n+\t\tbase = c == '0' ? 8 : 10;\n+\n+\t/*\n+\t * Compute the cutoff value between legal numbers and illegal\n+\t * numbers.  That is the largest legal value, divided by the\n+\t * base.  An input number that is greater than this value, if\n+\t * followed by a legal input character, is too big.  One that\n+\t * is equal to this value may be valid or not; the limit\n+\t * between valid and invalid numbers is then based on the last\n+\t * digit.  For instance, if the range for longs is\n+\t * [-2147483648..2147483647] and the input base is 10,\n+\t * cutoff will be set to 214748364 and cutlim to either\n+\t * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated\n+\t * a value > 214748364, or equal but the next digit is > 7 (or 8),\n+\t * the number is too big, and we will return a range error.\n+\t *\n+\t * Set any if any `digits' consumed; make it negative to indicate\n+\t * overflow.\n+\t */\n+\tcutoff = neg ? -(ullong_type)LLONG_MIN : LLONG_MAX;\n+\tcutlim = cutoff % (ullong_type)base;\n+\tcutoff /= (ullong_type)base;\n+\tfor (acc = 0, any = 0;; c = *s++) {\n+\t\tif (ISDIGIT(c))\n+\t\t\tc -= '0';\n+\t\telse if (ISALPHA(c))\n+\t\t\tc -= ISUPPER(c) ? 'A' - 10 : 'a' - 10;\n+\t\telse\n+\t\t\tbreak;\n+\t\tif (c >= base)\n+\t\t\tbreak;\n+\t\tif (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))\n+\t\t\tany = -1;\n+\t\telse {\n+\t\t\tany = 1;\n+\t\t\tacc *= base;\n+\t\t\tacc += c;\n+\t\t}\n+\t}\n+\tif (any < 0) {\n+\t\tacc = neg ? LLONG_MIN : LLONG_MAX;\n+\t\terrno = ERANGE;\n+\t} else if (neg)\n+\t\tacc = -acc;\n+\tif (endptr != 0)\n+\t\t*endptr = (char *) (any ? s - 1 : nptr);\n+\treturn (acc);\n+}\n+\n+#endif /* ifdef HAVE_LONG_LONG */"}, {"sha": "2f580fb34544faebad430d3e8934f4b0e6b4e071", "filename": "libiberty/strtoull.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fstrtoull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Fstrtoull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fstrtoull.c?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2014 Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. [rescinded 22 July 1999]\n+ * 4. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+#ifdef HAVE_LIMITS_H\n+#include <limits.h>\n+#endif\n+#ifdef HAVE_SYS_PARAM_H\n+#include <sys/param.h>\n+#endif\n+#include <errno.h>\n+#ifdef NEED_DECLARATION_ERRNO\n+extern int errno;\n+#endif\n+#if 0\n+#include <stdlib.h>\n+#endif\n+#include \"ansidecl.h\"\n+#include \"safe-ctype.h\"\n+\n+#ifdef HAVE_LONG_LONG\n+\n+__extension__\n+typedef unsigned long long ullong_type;\n+\n+#ifndef ULLONG_MAX\n+#define ULLONG_MAX (~(ullong_type)0) /* 0xFFFFFFFFFFFFFFFF */\n+#endif\n+\n+/*\n+ * Convert a string to an unsigned long long integer.\n+ *\n+ * Ignores `locale' stuff.  Assumes that the upper and lower case\n+ * alphabets and digits are each contiguous.\n+ */\n+ullong_type\n+strtoull(const char *nptr, char **endptr, register int base)\n+{\n+\tregister const char *s = nptr;\n+\tregister ullong_type acc;\n+\tregister int c;\n+\tregister ullong_type cutoff;\n+\tregister int neg = 0, any, cutlim;\n+\n+\t/*\n+\t * See strtol for comments as to the logic used.\n+\t */\n+\tdo {\n+\t\tc = *s++;\n+\t} while (ISSPACE(c));\n+\tif (c == '-') {\n+\t\tneg = 1;\n+\t\tc = *s++;\n+\t} else if (c == '+')\n+\t\tc = *s++;\n+\tif ((base == 0 || base == 16) &&\n+\t    c == '0' && (*s == 'x' || *s == 'X')) {\n+\t\tc = s[1];\n+\t\ts += 2;\n+\t\tbase = 16;\n+\t}\n+\tif (base == 0)\n+\t\tbase = c == '0' ? 8 : 10;\n+\tcutoff = (ullong_type)ULLONG_MAX / (ullong_type)base;\n+\tcutlim = (ullong_type)ULLONG_MAX % (ullong_type)base;\n+\tfor (acc = 0, any = 0;; c = *s++) {\n+\t\tif (ISDIGIT(c))\n+\t\t\tc -= '0';\n+\t\telse if (ISALPHA(c))\n+\t\t\tc -= ISUPPER(c) ? 'A' - 10 : 'a' - 10;\n+\t\telse\n+\t\t\tbreak;\n+\t\tif (c >= base)\n+\t\t\tbreak;\n+\t\tif (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))\n+\t\t\tany = -1;\n+\t\telse {\n+\t\t\tany = 1;\n+\t\t\tacc *= base;\n+\t\t\tacc += c;\n+\t\t}\n+\t}\n+\tif (any < 0) {\n+\t\tacc = ULLONG_MAX;\n+\t\terrno = ERANGE;\n+\t} else if (neg)\n+\t\tacc = -acc;\n+\tif (endptr != 0)\n+\t\t*endptr = (char *) (any ? s - 1 : nptr);\n+\treturn (acc);\n+}\n+\n+#endif /* ifdef HAVE_LONG_LONG */"}, {"sha": "4324a8f1dc4d2b43b2186a504345052d713c20d4", "filename": "libiberty/testsuite/Makefile.in", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2FMakefile.in?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -45,7 +45,8 @@ all:\n # CHECK is set to \"really_check\" or the empty string by configure.\n check: @CHECK@\n \n-really-check: check-cplus-dem check-d-demangle check-pexecute check-expandargv\n+really-check: check-cplus-dem check-d-demangle check-pexecute check-expandargv \\\n+\t\tcheck-strtol\n \n # Run some tests of the demangler.\n check-cplus-dem: test-demangle $(srcdir)/demangle-expected\n@@ -62,6 +63,10 @@ check-pexecute: test-pexecute\n check-expandargv: test-expandargv\n \t./test-expandargv\n \n+# Check the strtol functionality\n+check-strtol: test-strtol\n+\t./test-strtol\n+\n # Run the demangler fuzzer\n fuzz-demangler: demangler-fuzzer\n \t./demangler-fuzzer\n@@ -79,6 +84,10 @@ test-expandargv: $(srcdir)/test-expandargv.c ../libiberty.a\n \t$(TEST_COMPILE) -DHAVE_CONFIG_H -I.. -o test-expandargv \\\n \t\t$(srcdir)/test-expandargv.c ../libiberty.a\n \n+test-strtol: $(srcdir)/test-strtol.c ../libiberty.a\n+\t$(TEST_COMPILE) -DHAVE_CONFIG_H -I.. -o test-strtol \\\n+\t\t$(srcdir)/test-strtol.c ../libiberty.a\n+\n demangler-fuzzer: $(srcdir)/demangler-fuzzer.c ../libiberty.a\n \t$(TEST_COMPILE) -o demangler-fuzzer \\\n \t\t$(srcdir)/demangler-fuzzer.c ../libiberty.a\n@@ -92,6 +101,7 @@ mostlyclean:\n \trm -f test-demangle\n \trm -f test-pexecute\n \trm -f test-expandargv\n+\trm -f test-strtol\n \trm -f demangler-fuzzer\n \trm -f core\n clean: mostlyclean"}, {"sha": "96d6871c777c9dd7877cf12caec25ee135c21ed1", "filename": "libiberty/testsuite/test-strtol.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Ftestsuite%2Ftest-strtol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea41822adfb3ea39ba43e033acd1f745abd79083/libiberty%2Ftestsuite%2Ftest-strtol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Ftest-strtol.c?ref=ea41822adfb3ea39ba43e033acd1f745abd79083", "patch": "@@ -0,0 +1,184 @@\n+/* Test program for strtol family of funtions,\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Written by Yury Gribov <y.gribov@samsung.com>\n+\n+   This file is part of the libiberty library, which is part of GCC.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2 of the License, or\n+   (at your option) any later version.\n+\n+   In addition to the permissions in the GNU General Public License, the\n+   Free Software Foundation gives you unlimited permission to link the\n+   compiled version of this file into combinations with other programs,\n+   and to distribute those combinations without any restriction coming\n+   from the use of this file.  (The General Public License restrictions\n+   do apply in other respects; for example, they cover modification of\n+   the file, and distribution when not linked into a combined\n+   executable.)\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. \n+*/\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+#include \"libiberty.h\"\n+#include <stdio.h>\n+#include <errno.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifndef EXIT_SUCCESS\n+#define EXIT_SUCCESS 0\n+#endif\n+\n+#ifndef EXIT_FAILURE\n+#define EXIT_FAILURE 1\n+#endif\n+\n+\n+/* Test input data. */\n+\n+enum conversion_fun\n+{\n+  STRTOL,\n+  STRTOLL,\n+  STRTOUL,\n+  STRTOULL,\n+};\n+\n+#ifdef HAVE_LONG_LONG\n+typedef unsigned long long integer_type;\n+#else\n+typedef unsigned long integer_type;\n+#endif\n+\n+struct test_data_t\n+{\n+  enum conversion_fun fun;\n+  const char *nptr;\n+  int base;\n+  integer_type res;\n+  int errnum;\n+};\n+\n+const struct test_data_t test_data[] = {\n+  { STRTOL,  \"0x123\",       0, 0x123L,        0      },\n+  { STRTOL,  \"123\",         0, 123L,          0      },\n+  { STRTOL,  \"0123\",        0, 0123L,         0      },\n+  { STRTOL,  \"0x7FFFFFFF\",  0, 0x7fffffffL,   0      },\n+  { STRTOL,  \"-0x80000000\", 0, -0x80000000L,  0      },\n+  { STRTOUL, \"0x123\",       0, 0x123UL,       0      },\n+  { STRTOUL, \"123\",         0, 123UL,         0      },\n+  { STRTOUL, \"0123\",        0, 0123UL,        0      },\n+  { STRTOUL, \"0xFFFFFFFF\",  0, 0xffffffffUL,  0      },\n+#if SIZEOF_LONG == 4\n+  { STRTOL,  \"0x80000000\",  0, 0x7fffffffL,   ERANGE },\n+  { STRTOL,  \"-0x80000001\", 0, -0x80000000L,  ERANGE },\n+  { STRTOUL, \"0x100000000\", 0, 0xffffffffUL,  ERANGE },\n+#endif\n+#ifdef HAVE_LONG_LONG\n+  { STRTOLL,  \"0x123\",               0, 0x123LL,               0      },\n+  { STRTOLL,  \"123\",                 0, 123LL,                 0      },\n+  { STRTOLL,  \"0123\",                0, 0123LL,                0      },\n+  { STRTOLL,  \"0x7FFFFFFFFFFFFFFF\",  0, 0x7fffffffffffffffLL,  0      },\n+  { STRTOLL,  \"-0x8000000000000000\", 0, -0x8000000000000000LL, 0      },\n+  { STRTOULL, \"0x123\",               0, 0x123ULL,              0      },\n+  { STRTOULL, \"123\",                 0, 123ULL,                0      },\n+  { STRTOULL, \"0123\",                0, 0123ULL,               0      },\n+  { STRTOULL, \"0xFFFFFFFFFFFFFFFF\",  0, 0xffffffffffffffffULL, 0      },\n+#if SIZEOF_LONG_LONG == 8\n+  { STRTOLL,  \"0x8000000000000000\",  0, 0x7fffffffffffffffLL,  ERANGE },\n+  { STRTOLL,  \"-0x8000000000000001\", 0, -0x8000000000000000LL, ERANGE },\n+  { STRTOULL, \"0x10000000000000000\", 0, 0xffffffffffffffffULL, ERANGE },\n+#endif\n+#endif\n+};\n+\n+/* run_tests:\n+    Run conversion function\n+    Compare results\n+    Return number of fails */\n+\n+int\n+run_tests (const struct test_data_t *test_data, size_t ntests)\n+{\n+  int fails = 0, failed;\n+  size_t i;\n+\n+  for (i = 0; i < ntests; ++i)\n+    {\n+      integer_type res;\n+      int saved_errno;\n+\n+      errno = 0;\n+\n+      switch (test_data[i].fun)\n+\t{\n+\tcase STRTOL:\n+\t  res = strtol (test_data[i].nptr, 0, test_data[i].base);\n+\t  break;\n+\tcase STRTOUL:\n+\t  res = strtoul (test_data[i].nptr, 0, test_data[i].base);\n+\t  break;\n+#ifdef HAVE_LONG_LONG\n+\tcase STRTOLL:\n+\t  res = strtoll (test_data[i].nptr, 0, test_data[i].base);\n+\t  break;\n+\tcase STRTOULL:\n+\t  res = strtoull (test_data[i].nptr, 0, test_data[i].base);\n+\t  break;\n+#endif\n+\t}\n+\n+      saved_errno = errno;\n+\n+      failed = 0;\n+\n+      /* Compare result */\n+      if (res != test_data[i].res)\n+        {\n+          printf (\"FAIL: test-strtol-%zd. Results don't match.\\n\", i);\n+\t  failed++;\n+        }\n+\n+      /* Compare errno */\n+      if (saved_errno != test_data[i].errnum)\n+        {\n+          printf (\"FAIL: test-strtol-%zd. Errnos don't match.\\n\", i);\n+\t  failed++;\n+        }\n+\n+      if (!failed)\n+        printf (\"PASS: test-strtol-%zd.\\n\", i);\n+      else\n+        fails++;\n+    }\n+\n+  return fails;\n+}\n+\n+int \n+main(int argc, char **argv)\n+{\n+  int fails;\n+  fails = run_tests (test_data, sizeof (test_data) / sizeof (test_data[0]));\n+  exit (fails ? EXIT_FAILURE : EXIT_SUCCESS);\n+}\n+"}]}