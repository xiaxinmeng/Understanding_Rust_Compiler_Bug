{"sha": "fffa9c1d2e774bb163859c10b9b491ed918bca99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmYTljMWQyZTc3NGJiMTYzODU5YzEwYjliNDkxZWQ5MThiY2E5OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-06T23:04:56Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-06T23:04:56Z"}, "message": "(emit_group_load, emit_group_store): New functions.\n\n(use_group_regs): New function.\n(emit_push_insn): Handle PARALLEL parameter in REG.\n(expand_assignment): Handle PARALLEL to_rtx.\n(store_expr): Handle PARALLEL target.\n\nFrom-SVN: r12189", "tree": {"sha": "5ccc1ccdc8ba86018c12062cf036bb0417e495ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ccc1ccdc8ba86018c12062cf036bb0417e495ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fffa9c1d2e774bb163859c10b9b491ed918bca99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffa9c1d2e774bb163859c10b9b491ed918bca99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fffa9c1d2e774bb163859c10b9b491ed918bca99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffa9c1d2e774bb163859c10b9b491ed918bca99/comments", "author": null, "committer": null, "parents": [{"sha": "cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cacbd53270c2cd3f67d1e3c72ad0f7b5bf5ba124"}], "stats": {"total": 127, "additions": 125, "deletions": 2}, "files": [{"sha": "c39c190f84357cacac8801c038b9dcaaef615468", "filename": "gcc/expr.c", "status": "modified", "additions": 125, "deletions": 2, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fffa9c1d2e774bb163859c10b9b491ed918bca99/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fffa9c1d2e774bb163859c10b9b491ed918bca99/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fffa9c1d2e774bb163859c10b9b491ed918bca99", "patch": "@@ -1817,6 +1817,92 @@ move_block_from_reg (regno, x, nregs, size)\n     }\n }\n \n+/* Emit code to move a block Y to a block X, where X is non-consecutive\n+   registers represented by a PARALLEL.  */\n+\n+void\n+emit_group_load (x, y)\n+     rtx x, y;\n+{\n+  rtx target_reg, source;\n+  int i;\n+\n+  if (GET_CODE (x) != PARALLEL)\n+    abort ();\n+\n+  /* Check for a NULL entry, used to indicate that the parameter goes\n+     both on the stack and in registers.  */\n+  if (XEXP (XVECEXP (x, 0, 0), 0))\n+    i = 0;\n+  else\n+    i = 1;\n+\n+  for (; i < XVECLEN (x, 0); i++)\n+    {\n+      rtx element = XVECEXP (x, 0, i);\n+\n+      target_reg = XEXP (element, 0);\n+\n+      if (GET_CODE (y) == MEM)\n+\tsource = change_address (y, GET_MODE (target_reg),\n+\t\t\t\t plus_constant (XEXP (y, 0),\n+\t\t\t\t\t\tINTVAL (XEXP (element, 1))));\n+      else if (XEXP (element, 1) == const0_rtx)\n+\t{\n+\t  if (GET_MODE (target_reg) == GET_MODE (y))\n+\t    source = y;\n+\t  else if (GET_MODE_SIZE (GET_MODE (target_reg))\n+\t\t   == GET_MODE_SIZE (GET_MODE (y)))\n+\t    source = gen_rtx (SUBREG, GET_MODE (target_reg), y, 0);\n+\t  else\n+\t    abort ();\t    \n+\t}\n+      else\n+\tabort ();\n+\n+      emit_move_insn (target_reg, source);\n+    }\n+}\n+\n+/* Emit code to move a block Y to a block X, where Y is non-consecutive\n+   registers represented by a PARALLEL.  */\n+\n+void\n+emit_group_store (x, y)\n+     rtx x, y;\n+{\n+  rtx source_reg, target;\n+  int i;\n+\n+  if (GET_CODE (y) != PARALLEL)\n+    abort ();\n+\n+  /* Check for a NULL entry, used to indicate that the parameter goes\n+     both on the stack and in registers.  */\n+  if (XEXP (XVECEXP (y, 0, 0), 0))\n+    i = 0;\n+  else\n+    i = 1;\n+\n+  for (; i < XVECLEN (y, 0); i++)\n+    {\n+      rtx element = XVECEXP (y, 0, i);\n+\n+      source_reg = XEXP (element, 0);\n+\n+      if (GET_CODE (x) == MEM)\n+\ttarget = change_address (x, GET_MODE (source_reg),\n+\t\t\t\t plus_constant (XEXP (x, 0),\n+\t\t\t\t\t\tINTVAL (XEXP (element, 1))));\n+      else if (XEXP (element, 1) == const0_rtx)\n+\ttarget = x;\n+      else\n+\tabort ();\n+\n+      emit_move_insn (target, source_reg);\n+    }\n+}\n+\n /* Add a USE expression for REG to the (possibly empty) list pointed\n    to by CALL_FUSAGE.  REG must denote a hard register.  */\n \n@@ -1850,6 +1936,28 @@ use_regs (call_fusage, regno, nregs)\n   for (i = 0; i < nregs; i++)\n     use_reg (call_fusage, gen_rtx (REG, reg_raw_mode[regno + i], regno + i));\n }\n+\n+/* Add USE expressions to *CALL_FUSAGE for each REG contained in the\n+   PARALLEL REGS.  This is for calls that pass values in multiple\n+   non-contiguous locations.  The Irix 6 ABI has examples of this.  */\n+\n+void\n+use_group_regs (call_fusage, regs)\n+     rtx *call_fusage;\n+     rtx regs;\n+{\n+  int i;\n+\n+  /* Check for a NULL entry, used to indicate that the parameter goes\n+     both on the stack and in registers.  */\n+  if (XEXP (XVECEXP (regs, 0, 0), 0))\n+    i = 0;\n+  else\n+    i = 1;\n+\n+  for (; i < XVECLEN (regs, 0); i++)\n+    use_reg (call_fusage, XEXP (XVECEXP (regs, 0, i), 0));\n+}\n \f\n /* Generate several move instructions to clear LEN bytes of block TO.\n    (A MEM rtx with BLKmode).   The caller must pass TO through\n@@ -2648,7 +2756,14 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n      into the appropriate registers.  Do this now, at the end,\n      since mem-to-mem copies above may do function calls.  */\n   if (partial > 0 && reg != 0)\n-    move_block_to_reg (REGNO (reg), x, partial, mode);\n+    {\n+      /* Handle calls that pass values in multiple non-contiguous locations.\n+\t The Irix 6 ABI has examples of this.  */\n+      if (GET_CODE (reg) == PARALLEL)\n+\temit_group_load (reg, x);\n+      else\n+\tmove_block_to_reg (REGNO (reg), x, partial, mode);\n+    }\n \n   if (extra && args_addr == 0 && where_pad == stack_direction)\n     anti_adjust_stack (GEN_INT (extra));\n@@ -2812,7 +2927,11 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (to_rtx == 0)\n \tto_rtx = expand_expr (to, NULL_RTX, VOIDmode, 0);\n \n-      if (GET_MODE (to_rtx) == BLKmode)\n+      /* Handle calls that return values in multiple non-contiguous locations.\n+\t The Irix 6 ABI has examples of this.  */\n+      if (GET_CODE (to_rtx) == PARALLEL)\n+\temit_group_load (to_rtx, value);\n+      else if (GET_MODE (to_rtx) == BLKmode)\n \temit_block_move (to_rtx, value, expr_size (from),\n \t\t\t TYPE_ALIGN (TREE_TYPE (from)) / BITS_PER_UNIT);\n       else\n@@ -3167,6 +3286,10 @@ store_expr (exp, target, want_value)\n \t\temit_label (label);\n \t    }\n \t}\n+      /* Handle calls that return values in multiple non-contiguous locations.\n+\t The Irix 6 ABI has examples of this.  */\n+      else if (GET_CODE (target) == PARALLEL)\n+\temit_group_load (target, temp);\n       else if (GET_MODE (temp) == BLKmode)\n \temit_block_move (target, temp, expr_size (exp),\n \t\t\t TYPE_ALIGN (TREE_TYPE (exp)) / BITS_PER_UNIT);"}]}