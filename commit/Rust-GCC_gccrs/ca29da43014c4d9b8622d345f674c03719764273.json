{"sha": "ca29da43014c4d9b8622d345f674c03719764273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EyOWRhNDMwMTRjNGQ5Yjg2MjJkMzQ1ZjY3NGMwMzcxOTc2NDI3Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-21T19:48:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-21T19:48:10Z"}, "message": "Break out coverage routines to new file.\n\n        * Makefile.in (COVERAGE_H): New variable\n        (C_OBJS): Add coverage.o\n        (coverage.o): New target.\n        (profile.o, loop-init.o, sched-ebb.o, predict.o, tracer.o): Adjust\n        dependencies.\n        (GTFILES): Adjust.\n        (gt-coverage.h): New target.\n        (gt-profile.h): Remove.\n        * profile.h: Remove. Move to ...\n        * coverage.h: ... here. New. #include gcov-io.h.\n        * gcov-io.h: Move function definitions to ...\n        * gcov-io.c: ... here. New.\n        * profile.c: Move coverage routines to coverage.c.\n        (instrument_edges, get_exec_counts, branch_prob, init_branch_prob,\n        end_branch_prob): Adjust.\n        * coverage.c: New. Coverage routines from profile.c\n        (coverage_counter_ref, coverage_init, coverage_finish,\n        coverage_end_function, coverage_begin_output,\n        coverage_counter_ref, get_coverage_counts): Define.\n        * gcov-dump.c, gcov.c: #include gcov-io.c.\n        * libgcov.c: Likewise. Adjust.\n        * loop-init.c: Don't #include profile.h\n        * tracer.c, predict.c, sched-ebb.c: Adjust #includes.\n        * rtl.h: Add coverage prototypes.\n        * toplev.c (compile_file): Init coverage, not branch_prob.\n        Always call coverage_finish.\n        (rest_of_compilation): Call coverage_end_function.\n\nFrom-SVN: r65897", "tree": {"sha": "0a33e6cf7e2f1c1de67fd4c82a44dac7bbd92d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a33e6cf7e2f1c1de67fd4c82a44dac7bbd92d79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca29da43014c4d9b8622d345f674c03719764273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca29da43014c4d9b8622d345f674c03719764273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca29da43014c4d9b8622d345f674c03719764273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca29da43014c4d9b8622d345f674c03719764273/comments", "author": null, "committer": null, "parents": [{"sha": "1774b2132fde85e3c20894333b20e36bdc9fe124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1774b2132fde85e3c20894333b20e36bdc9fe124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1774b2132fde85e3c20894333b20e36bdc9fe124"}], "stats": {"total": 3367, "additions": 1802, "deletions": 1565}, "files": [{"sha": "43c1f0557486e1d5e7df95fd528fb81e385dbb9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -1,3 +1,34 @@\n+2003-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+        Break out coverage routines to new file.\n+        * Makefile.in (COVERAGE_H): New variable\n+        (C_OBJS): Add coverage.o\n+        (coverage.o): New target.\n+        (profile.o, loop-init.o, sched-ebb.o, predict.o, tracer.o): Adjust\n+        dependencies.\n+        (GTFILES): Adjust.\n+        (gt-coverage.h): New target.\n+        (gt-profile.h): Remove.\n+        * profile.h: Remove. Move to ...\n+        * coverage.h: ... here. New. #include gcov-io.h.\n+        * gcov-io.h: Move function definitions to ...\n+        * gcov-io.c: ... here. New.\n+        * profile.c: Move coverage routines to coverage.c.\n+        (instrument_edges, get_exec_counts, branch_prob, init_branch_prob,\n+        end_branch_prob): Adjust.\n+        * coverage.c: New. Coverage routines from profile.c\n+        (coverage_counter_ref, coverage_init, coverage_finish,\n+        coverage_end_function, coverage_begin_output,\n+        coverage_counter_ref, get_coverage_counts): Define.\n+        * gcov-dump.c, gcov.c: #include gcov-io.c.\n+        * libgcov.c: Likewise. Adjust.\n+        * loop-init.c: Don't #include profile.h\n+        * tracer.c, predict.c, sched-ebb.c: Adjust #includes.\n+        * rtl.h: Add coverage prototypes.\n+        * toplev.c (compile_file): Init coverage, not branch_prob.\n+        Always call coverage_finish.\n+        (rest_of_compilation): Call coverage_end_function.\n+\n 2003-04-21  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* config/rs6000/rs6000.md (*movsf_softfloat): Add \"h\" <- \"0\" case.\n@@ -417,20 +448,23 @@ Sat Apr 19 14:56:17 CEST 2003  Jan Hubicka  <jh@suse.cz>\n Fri Apr 18 01:28:51 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcov-dump.c (tag_summary): Remove max_sum\n-\t* gcov-io.h (gcov_summary, gcov_write_summary, gcov_read_summary): Kill\n-\tmax_sum.\n-\t* libgcov.c (gcov_exit): Do one pass over the data.  Make error message\n-\tmore verbose.\n-\n-\t* emit-rtl.c (subreg_hard_regno):  Check that register is representable.\n+\t* gcov-io.h (gcov_summary, gcov_write_summary,\n+\tgcov_read_summary): Kill max_sum.\n+\t* libgcov.c (gcov_exit): Do one pass over the data.  Make error\n+\tmessage more verbose.\n+\n+\t* emit-rtl.c (subreg_hard_regno):  Check that register is\n+\trepresentable.\n+\t\n \t* reload.c (reload_inner_reg_of_subreg):  When register is not\n \trepresentable, reload the whole thing.\n \t(find_reloads): Likewsie.\n \t* rtlanal.c (subreg_representable_p):  New function.\n \n \t* profile.c (compute_branch_probabilities):  Cleanup sanity checking;\n \tallow negative probabilities for edges from the call to exit.\n-\t(branch_prob): Do not add fake edges for functions that may return twice\n+\t(branch_prob): Do not add fake edges for functions that may return\n+\ttwice.\n \n 2003-04-17  DJ Delorie  <dj@redhat.com>\n "}, {"sha": "67e94128b7648250dacf1579b44a90adfeab2e5e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -636,6 +636,7 @@ TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h version.h builtins.def \\\n           location.h\n BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \\\n           hard-reg-set.h\n+COVERAGE_H = coverage.h gcov-io.h gcov-iov.h\n DEMANGLE_H = $(srcdir)/../include/demangle.h\n RECOG_H = recog.h\n EXPR_H = expr.h\n@@ -803,8 +804,8 @@ C_OBJS = c-parse.o c-lang.o c-pretty-print.o $(C_AND_OBJC_OBJS)\n OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n- cfgrtl.o combine.o conflict.o convert.o cse.o cselib.o dbxout.o\t   \\\n- debug.o df.o diagnostic.o dojump.o doloop.o dominance.o\t\t         \\\n+ cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n+ dbxout.o debug.o df.o diagnostic.o dojump.o doloop.o dominance.o\t   \\\n  dwarf2asm.o dwarf2out.o dwarfout.o emit-rtl.o except.o explow.o\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n@@ -1584,6 +1585,10 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h tree-inline.h toplev.h flags.h ggc.h  $(TARGET_H) cgraph.h gt-cgraph.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h tree-inline.h toplev.h flags.h ggc.h  $(TARGET_H) cgraph.h\n+coverage.o : coverage.c gcov-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(RTL_H) $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n+   toplev.h $(GGC_H) $(TARGET_H) langhooks.h $(COVERAGE_H) libfuncs.h \\\n+   gt-coverage.h $(HASHTAB_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h\n@@ -1615,10 +1620,9 @@ df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) df.h $(FIBHEAP_H)\n conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n-profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-   flags.h insn-config.h output.h $(REGS_H) $(EXPR_H) function.h \\\n-   gcov-io.h gcov-iov.h toplev.h $(GGC_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n-   $(TARGET_H) langhooks.h profile.h libfuncs.h gt-profile.h $(HASHTAB_H)\n+profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h cfgloop.h \\\n@@ -1656,7 +1660,7 @@ cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h output.h coretypes.h $(TM_H)\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h profile.h \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h \\\n    coretypes.h $(TM_H)\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h cfglayout.h params.h \\\n@@ -1728,7 +1732,7 @@ sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(TARGET_H)\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    sched-int.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(PARAMS_H) profile.h\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h $(TM_P_H) $(PARAMS_H)\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    sched-int.h hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H) $(TM_P_H) \\\n    $(TARGET_H) real.h\n@@ -1747,14 +1751,14 @@ sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) sreal.h \\\n-   $(PARAMS_H) $(TARGET_H) cfgloop.h\n+   $(PARAMS_H) $(TARGET_H) cfgloop.h $(COVERAGE_H)\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(BASIC_BLOCK_H) flags.h output.h cfglayout.h $(FIBHEAP_H) \\\n    $(TARGET_H)\n tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h flags.h \\\n-   $(PARAMS_H) profile.h\n+   $(PARAMS_H) $(COVERAGE_H)\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h \\\n    function.h cfglayout.h cfgloop.h $(TARGET_H)\n@@ -1966,10 +1970,10 @@ s-preds: genpreds$(build_exeext) $(srcdir)/move-if-change\n \n GTFILES = $(srcdir)/location.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(host_xm_file_list) $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) \\\n-  $(srcdir)/bitmap.h $(srcdir)/function.h  $(srcdir)/rtl.h $(srcdir)/optabs.h \\\n-  $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h $(srcdir)/real.h \\\n-  $(srcdir)/varray.h $(srcdir)/ssa.h $(srcdir)/insn-addr.h $(srcdir)/cselib.h \\\n-  $(srcdir)/basic-block.h $(srcdir)/location.h \\\n+  $(srcdir)/bitmap.h $(srcdir)/coverage.c $(srcdir)/function.h  $(srcdir)/rtl.h \\\n+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h \\\n+  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/ssa.h $(srcdir)/insn-addr.h \\\n+  $(srcdir)/cselib.h $(srcdir)/basic-block.h $(srcdir)/location.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n@@ -1988,14 +1992,15 @@ GTFILES_FILES_FILES = @all_gtfiles_files_files@\n GTFILES_LANG_DIR_NAMES = @subdirs@\n GTFILES_SRCDIR = @srcdir@\n \n-gt-cgraph.h gtype-desc.h gtype-desc.c gt-except.h gt-function.h : s-gtype; @true\n-gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h gt-emit-rtl.h : s-gtype; @true\n-gt-explow.h gt-stor-layout.h gt-regclass.h gt-lists.h : s-gtype; @true\n-gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h gt-profile.h : s-gtype; @true\n-gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dwarf2out.h : s-gtype ; @true\n-gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h gt-dbxout.h : s-gtype ; @true\n-gt-c-common.h gt-c-decl.h gt-c-parse.h gt-c-pragma.h : s-gtype; @true\n-gt-c-objc-common.h gtype-c.h gt-location.h gt-stringpool.h : s-gtype ; @true\n+gt-cgraph.h gt-coverage.h gtype-desc.h gtype-desc.c gt-except.h \\\n+gt-function.h gt-integrate.h gt-stmt.h gt-tree.h gt-varasm.h \\\n+gt-emit-rtl.h gt-explow.h gt-stor-layout.h gt-regclass.h \\\n+gt-lists.h gt-alias.h gt-cselib.h gt-fold-const.h gt-gcse.h \\\n+gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h \\\n+gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \\\n+gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \\\n+gt-c-pragma.h gt-c-objc-common.h gtype-c.h gt-location.h \\\n+gt-stringpool.h : s-gtype ; @true\n \n gtyp-gen.h: Makefile\n \techo \"/* This file is machine generated.  Do not edit.  */\" > tmp-gtyp.h"}, {"sha": "07c56a3ffc706518f4ea45b55625e46dab975f2e", "filename": "gcc/coverage.c", "status": "added", "additions": 1146, "deletions": 0, "changes": 1146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -0,0 +1,1146 @@\n+/* Read and write coverage files, and associated functionality.\n+   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,\n+   2000, 2001, 2003  Free Software Foundation, Inc.\n+   Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n+   based on some ideas from Dain Samples of UC Berkeley.\n+   Further mangling by Bob Manson, Cygnus Support.\n+   Further mangled by Nathan Sidwell, CodeSourcery\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+\n+#define GCOV_LINKAGE\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"regs.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"toplev.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"coverage.h\"\n+#include \"libfuncs.h\"\n+#include \"langhooks.h\"\n+#include \"hashtab.h\"\n+\n+#include \"gcov-io.c\"\n+\n+struct function_list\n+{\n+  struct function_list *next; \t/* next function */\n+  const char *name; \t\t/* function name */\n+  unsigned cfg_checksum;\t/* function checksum */\n+  unsigned n_counter_sections;\t/* number of counter sections */\n+  struct gcov_counter_section counter_sections[MAX_COUNTER_SECTIONS];\n+  \t\t\t\t/* the sections */\n+};\n+\n+/* Counts information for a function.  */\n+typedef struct counts_entry\n+{\n+  /* We hash by  */\n+  char *function_name;\n+  unsigned section;\n+  \n+  /* Store  */\n+  unsigned checksum;\n+  unsigned n_counts;\n+  gcov_type *counts;\n+  unsigned merged;\n+  gcov_type max_counter;\n+  gcov_type max_counter_sum;\n+\n+  /* Workspace */\n+  struct counts_entry *chain;\n+  \n+} counts_entry_t;\n+\n+static struct function_list *functions_head = 0;\n+static struct function_list **functions_tail = &functions_head;\n+\n+/* Instantiate the profile info structure.  */\n+\n+struct profile_info profile_info;\n+\n+/* Name of the output file for coverage output file.  */\n+static char *bbg_file_name;\n+static unsigned bbg_file_opened;\n+static int bbg_function_announced;\n+\n+/* Name of the count data file.  */\n+static char *da_file_name;\n+\n+/* Hash table of count data.  */\n+static htab_t counts_hash = NULL;\n+\n+/* The name of the count table. Used by the edge profiling code.  */\n+static GTY(()) rtx profiler_label;\n+\n+/* Forward declarations.  */\n+static hashval_t htab_counts_entry_hash PARAMS ((const void *));\n+static int htab_counts_entry_eq PARAMS ((const void *, const void *));\n+static void htab_counts_entry_del PARAMS ((void *));\n+static void read_counts_file PARAMS ((void));\n+static unsigned compute_checksum PARAMS ((void));\n+static unsigned checksum_string PARAMS ((unsigned, const char *));\n+static void set_purpose PARAMS ((tree, tree));\n+static rtx label_for_tag PARAMS ((unsigned));\n+static tree build_counter_section_fields PARAMS ((void));\n+static tree build_counter_section_value PARAMS ((unsigned, unsigned));\n+static tree build_counter_section_data_fields PARAMS ((void));\n+static tree build_counter_section_data_value PARAMS ((unsigned, unsigned));\n+static tree build_function_info_fields PARAMS ((void));\n+static tree build_function_info_value PARAMS ((struct function_list *));\n+static tree build_gcov_info_fields PARAMS ((tree));\n+static tree build_gcov_info_value PARAMS ((void));\n+static void create_coverage PARAMS ((void));\n+\n+\f\n+static hashval_t\n+htab_counts_entry_hash (of)\n+     const void *of;\n+{\n+  const counts_entry_t *entry = of;\n+\n+  return htab_hash_string (entry->function_name) ^ entry->section;\n+}\n+\n+static int\n+htab_counts_entry_eq (of1, of2)\n+     const void *of1;\n+     const void *of2;\n+{\n+  const counts_entry_t *entry1 = of1;\n+  const counts_entry_t *entry2 = of2;\n+\n+  return !strcmp (entry1->function_name, entry2->function_name)\n+    && entry1->section == entry2->section;\n+}\n+\n+static void\n+htab_counts_entry_del (of)\n+     void *of;\n+{\n+  counts_entry_t *entry = of;\n+\n+  free (entry->function_name);\n+  free (entry->counts);\n+  free (entry);\n+}\n+\n+/* Read in the counts file, if available.  */\n+\n+static void\n+read_counts_file ()\n+{\n+  char *function_name_buffer = NULL;\n+  unsigned version, ix, checksum = -1;\n+  counts_entry_t *summaried = NULL;\n+  unsigned seen_summary = 0;\n+  \n+  if (!gcov_open (da_file_name, 1))\n+    return;\n+  \n+  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n+    {\n+      warning (\"`%s' is not a gcov data file\", da_file_name);\n+      gcov_close ();\n+      return;\n+    }\n+  else if ((version = gcov_read_unsigned ()) != GCOV_VERSION)\n+    {\n+      char v[4], e[4];\n+      unsigned required = GCOV_VERSION;\n+      \n+      for (ix = 4; ix--; required >>= 8, version >>= 8)\n+\t{\n+\t  v[ix] = version;\n+\t  e[ix] = required;\n+\t}\n+      warning (\"`%s' is version `%.4s', expected version `%.4s'\",\n+\t       da_file_name, v, e);\n+      gcov_close ();\n+      return;\n+    }\n+  \n+  counts_hash = htab_create (10,\n+\t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n+\t\t\t     htab_counts_entry_del);\n+  while (!gcov_is_eof ())\n+    {\n+      unsigned tag, length;\n+      unsigned long offset;\n+      int error;\n+      \n+      tag = gcov_read_unsigned ();\n+      length = gcov_read_unsigned ();\n+      offset = gcov_position ();\n+      if (tag == GCOV_TAG_FUNCTION)\n+\t{\n+\t  const char *string = gcov_read_string ();\n+\t  free (function_name_buffer);\n+\t  function_name_buffer = string ? xstrdup (string) : NULL;\n+\t  checksum = gcov_read_unsigned ();\n+\t  if (seen_summary)\n+\t    {\n+\t      /* We have already seen a summary, this means that this\n+\t\t new function begins a new set of program runs. We\n+\t\t must unlink the summaried chain.  */\n+\t      counts_entry_t *entry, *chain;\n+\t      \n+\t      for (entry = summaried; entry; entry = chain)\n+\t\t{\n+\t\t  chain = entry->chain;\n+\t\t  \n+\t\t  entry->max_counter_sum += entry->max_counter;\n+\t\t  entry->chain = NULL;\n+\t\t}\n+\t      summaried = NULL;\n+\t      seen_summary = 0;\n+\t    }\n+\t}\n+      else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n+\t{\n+\t  counts_entry_t *entry;\n+\t  struct gcov_summary summary;\n+\t  \n+\t  gcov_read_summary (&summary);\n+\t  seen_summary = 1;\n+\t  for (entry = summaried; entry; entry = entry->chain)\n+\t    {\n+\t      entry->merged += summary.runs;\n+\t      if (entry->max_counter < summary.arc_sum_max)\n+\t\tentry->max_counter = summary.arc_sum_max;\n+\t    }\n+\t}\n+      else if (GCOV_TAG_IS_SUBTAG (GCOV_TAG_FUNCTION, tag)\n+\t       && function_name_buffer)\n+\t{\n+\t  counts_entry_t **slot, *entry, elt;\n+\t  unsigned n_counts = length / 8;\n+\t  unsigned ix;\n+\n+\t  elt.function_name = function_name_buffer;\n+\t  elt.section = tag;\n+\n+\t  slot = (counts_entry_t **) htab_find_slot\n+\t    (counts_hash, &elt, INSERT);\n+\t  entry = *slot;\n+\t  if (!entry)\n+\t    {\n+\t      *slot = entry = xmalloc (sizeof (counts_entry_t));\n+\t      entry->function_name = xstrdup (function_name_buffer);\n+\t      entry->section = tag;\n+\t      entry->checksum = checksum;\n+\t      entry->n_counts = n_counts;\n+\t      entry->counts = xcalloc (n_counts, sizeof (gcov_type));\n+\t    }\n+\t  else if (entry->checksum != checksum || entry->n_counts != n_counts)\n+\t    {\n+\t      warning (\"profile mismatch for `%s'\", function_name_buffer);\n+\t      htab_delete (counts_hash);\n+\t      break;\n+\t    }\n+\t  \n+\t  /* This should always be true for a just allocated entry,\n+\t     and always false for an existing one. Check this way, in\n+\t     case the gcov file is corrupt.  */\n+\t  if (!entry->chain || summaried != entry)\n+\t    {\n+\t      entry->chain = summaried;\n+\t      summaried = entry;\n+\t    }\n+\t  for (ix = 0; ix != n_counts; ix++)\n+\t    entry->counts[ix] += gcov_read_counter ();\n+\t}\n+      gcov_seek (offset, length);\n+      if ((error = gcov_is_error ()))\n+\t{\n+\t  warning (error < 0 ? \"`%s' has overflowed\" : \"`%s' is corrupted\",\n+\t\t   da_file_name);\n+\t  htab_delete (counts_hash);\n+\t  break;\n+\t}\n+    }\n+\n+  free (function_name_buffer);\n+  gcov_close ();\n+}\n+\n+/* Returns the counters for a particular tag.  */\n+\n+gcov_type *\n+get_coverage_counts (unsigned tag, unsigned expected)\n+{\n+  counts_entry_t *entry, elt;\n+\n+  profile_info.max_counter_in_program = 0;\n+  profile_info.count_profiles_merged = 0;\n+\n+  /* No hash table, no counts. */\n+  if (!counts_hash)\n+    {\n+      static int warned = 0;\n+\n+      if (!warned++)\n+\twarning (\"file %s not found, execution counts assumed to be zero\",\n+\t\t da_file_name);\n+      return NULL;\n+    }\n+\n+  elt.function_name\n+    = (char *) IDENTIFIER_POINTER\n+    (DECL_ASSEMBLER_NAME (current_function_decl));\n+  elt.section = tag;\n+  entry = htab_find (counts_hash, &elt);\n+  if (!entry)\n+    {\n+      warning (\"No profile for function '%s' found.\", elt.function_name);\n+      return 0;\n+    }\n+  \n+  if (expected != entry->n_counts\n+      || compute_checksum () != entry->checksum)\n+    {\n+      warning (\"profile mismatch for `%s'\", elt.function_name);\n+      return NULL;\n+    }\n+\n+  profile_info.count_profiles_merged = entry->merged;\n+  profile_info.max_counter_in_program = entry->max_counter_sum;\n+\n+  return entry->counts;\n+}\n+\f\n+/* Generate a checksum for a string.  CHKSUM is the current\n+   checksum. */\n+\n+static unsigned\n+checksum_string (unsigned chksum, const char *string)\n+{\n+  do\n+    {\n+      unsigned value = *string << 24;\n+      unsigned ix;\n+\n+      for (ix = 8; ix--; value <<= 1)\n+\t{\n+\t  unsigned feedback;\n+\t  \n+\t  feedback = (value ^ chksum) & 0x80000000 ? 0x04c11db7 : 0;\n+\t  chksum <<= 1;\n+\t  chksum ^= feedback;\n+\t}\n+    }\n+  while (*string++);\n+  \n+  return chksum;\n+}\n+\n+/* Compute checksum for the current function.  We generate a CRC32.  */\n+\n+static unsigned\n+compute_checksum ()\n+{\n+  unsigned chksum = DECL_SOURCE_LINE (current_function_decl);\n+\n+  chksum = checksum_string (chksum, DECL_SOURCE_FILE (current_function_decl));\n+  chksum = checksum_string\n+    (chksum, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)));\n+\n+  return chksum;\n+}\n+\f\n+/* Begin output to the graph file for the current function.\n+   Opens the output file, if not already done. Writes the\n+   function header, if not already done. Returns non-zero if data\n+   should be output.  */\n+\n+int\n+coverage_begin_output ()\n+{\n+  if (!bbg_function_announced)\n+    {\n+      const char *file = DECL_SOURCE_FILE (current_function_decl);\n+      unsigned line = DECL_SOURCE_LINE (current_function_decl);\n+      unsigned long offset;\n+      \n+      if (!bbg_file_opened)\n+\t{\n+\t  if (!gcov_open (bbg_file_name, -1))\n+\t    error (\"cannot open %s\", bbg_file_name);\n+\t  else\n+\t    {\n+\t      gcov_write_unsigned (GCOV_GRAPH_MAGIC);\n+\t      gcov_write_unsigned (GCOV_VERSION);\n+\t    }\n+\t  bbg_file_opened = 1;\n+\t}\n+      \n+      /* Announce function */\n+      offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n+      gcov_write_string (IDENTIFIER_POINTER\n+\t\t\t (DECL_ASSEMBLER_NAME (current_function_decl)));\n+      gcov_write_unsigned (compute_checksum ());\n+      gcov_write_string (file);\n+      gcov_write_unsigned (line);\n+      gcov_write_length (offset);\n+\n+      bbg_function_announced = 1;\n+    }\n+  return !gcov_is_error ();\n+}\n+\n+/* Finish coverage data for the current function. Verify no output\n+   error has occurred.  Save function coverage counts.  */\n+\n+void\n+coverage_end_function ()\n+{\n+  unsigned i;\n+  \n+  if (bbg_file_opened > 1 && gcov_is_error ())\n+    {\t\n+      warning (\"error writing `%s'\", bbg_file_name);\n+      bbg_file_opened = -1;\n+    }\n+  \n+  for (i = 0; i != profile_info.n_sections; i++)\n+    if (profile_info.section_info[i].n_counters_now)\n+      {\n+\tstruct function_list *item;\n+      \n+\t/* ??? Probably should re-use the existing struct function.  */\n+\titem = xmalloc (sizeof (struct function_list));\n+      \n+\t*functions_tail = item;\n+\tfunctions_tail = &item->next;\n+\t\n+\titem->next = 0;\n+\titem->name = xstrdup (IDENTIFIER_POINTER\n+\t\t\t      (DECL_ASSEMBLER_NAME (current_function_decl)));\n+\titem->cfg_checksum = compute_checksum ();\n+\titem->n_counter_sections = 0;\n+\tfor (i = 0; i < profile_info.n_sections; i++)\n+\t  if (profile_info.section_info[i].n_counters_now)\n+\t    {\n+\t      item->counter_sections[item->n_counter_sections].tag = \n+\t\tprofile_info.section_info[i].tag;\n+\t      item->counter_sections[item->n_counter_sections].n_counters =\n+\t\tprofile_info.section_info[i].n_counters_now;\n+\t      item->n_counter_sections++;\n+\t      profile_info.section_info[i].n_counters\n+\t\t+= profile_info.section_info[i].n_counters_now;\n+\t      profile_info.section_info[i].n_counters_now = 0;\n+\t    }\n+\tbreak;\n+      }\n+  bbg_function_announced = 0;\n+}\n+\n+/* Set FIELDS as purpose to VALUE.  */\n+static void\n+set_purpose (value, fields)\n+     tree value;\n+     tree fields;\n+{\n+  tree act_field, act_value;\n+  \n+  for (act_field = fields, act_value = value;\n+       act_field;\n+       act_field = TREE_CHAIN (act_field), act_value = TREE_CHAIN (act_value))\n+    TREE_PURPOSE (act_value) = act_field;\n+}\n+\n+/* Returns label for base of counters inside TAG section.  */\n+static rtx\n+label_for_tag (tag)\n+     unsigned tag;\n+{\n+  switch (tag)\n+    {\n+    case GCOV_TAG_ARC_COUNTS:\n+      return profiler_label;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Creates fields of struct counter_section (in gcov-io.h).  */\n+static tree\n+build_counter_section_fields ()\n+{\n+  tree field, fields;\n+\n+  /* tag */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+\n+  /* n_counters */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates value of struct counter_section (in gcov-io.h).  */\n+static tree\n+build_counter_section_value (tag, n_counters)\n+     unsigned tag;\n+     unsigned n_counters;\n+{\n+  tree value = NULL_TREE;\n+\n+  /* tag */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (tag, 0)),\n+\t\t     value);\n+  \n+  /* n_counters */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (n_counters, 0)),\n+\t\t     value);\n+\n+  return value;\n+}\n+\n+/* Creates fields of struct counter_section_data (in gcov-io.h).  */\n+static tree\n+build_counter_section_data_fields ()\n+{\n+  tree field, fields, gcov_type, gcov_ptr_type;\n+\n+  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n+  gcov_ptr_type =\n+\t  build_pointer_type (build_qualified_type (gcov_type,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+\n+  /* tag */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+\n+  /* n_counters */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* counters */\n+  field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates value of struct counter_section_data (in gcov-io.h).  */\n+static tree\n+build_counter_section_data_value (tag, n_counters)\n+     unsigned tag;\n+     unsigned n_counters;\n+{\n+  tree value = NULL_TREE, counts_table, gcov_type, gcov_ptr_type;\n+\n+  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n+  gcov_ptr_type\n+    = build_pointer_type (build_qualified_type\n+\t\t\t  (gcov_type, TYPE_QUAL_CONST));\n+\n+  /* tag */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (tag, 0)),\n+\t\t     value);\n+  \n+  /* n_counters */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (n_counters, 0)),\n+\t\t     value);\n+\n+  /* counters */\n+  if (n_counters)\n+    {\n+      tree gcov_type_array_type =\n+\t      build_array_type (gcov_type,\n+\t\t\t\tbuild_index_type (build_int_2 (n_counters - 1,\n+\t\t\t\t\t\t\t       0)));\n+      counts_table =\n+\t      build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n+      TREE_STATIC (counts_table) = 1;\n+      DECL_NAME (counts_table) = get_identifier (XSTR (label_for_tag (tag), 0));\n+      assemble_variable (counts_table, 0, 0, 0);\n+      counts_table = build1 (ADDR_EXPR, gcov_ptr_type, counts_table);\n+    }\n+  else\n+    counts_table = null_pointer_node;\n+\n+  value = tree_cons (NULL_TREE, counts_table, value);\n+\n+  return value;\n+}\n+\n+/* Creates fields for struct function_info type (in gcov-io.h).  */\n+static tree\n+build_function_info_fields ()\n+{\n+  tree field, fields, counter_section_fields, counter_section_type;\n+  tree counter_sections_ptr_type;\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  /* name */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, string_type);\n+\n+  /* checksum */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* n_counter_sections */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* counter_sections */\n+  counter_section_fields = build_counter_section_fields ();\n+  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  finish_builtin_struct (counter_section_type, \"__counter_section\",\n+\t\t\t counter_section_fields, NULL_TREE);\n+  counter_sections_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, counter_sections_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates value for struct function_info (in gcov-io.h).  */\n+static tree\n+build_function_info_value (function)\n+     struct function_list *function;\n+{\n+  tree value = NULL_TREE;\n+  size_t name_len = strlen (function->name);\n+  tree fname = build_string (name_len + 1, function->name);\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree counter_section_fields, counter_section_type, counter_sections_value;\n+  tree counter_sections_ptr_type, counter_sections_array_type;\n+  unsigned i;\n+\n+  /* name */\n+  TREE_TYPE (fname) =\n+\t  build_array_type (char_type_node,\n+\t\t\t    build_index_type (build_int_2 (name_len, 0)));\n+  value = tree_cons (NULL_TREE,\n+\t\t     build1 (ADDR_EXPR,\n+\t\t\t     string_type,\n+\t\t\t     fname),\n+\t\t     value);\n+\n+  /* checksum */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (function->cfg_checksum, 0)),\n+\t\t     value);\n+\n+  /* n_counter_sections */\n+\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (function->n_counter_sections, 0)),\n+\t    \t    value);\n+\n+  /* counter_sections */\n+  counter_section_fields = build_counter_section_fields ();\n+  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  counter_sections_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  counter_sections_array_type =\n+\t  build_array_type (counter_section_type,\n+\t\t\t    build_index_type (\n+      \t\t\t\tbuild_int_2 (function->n_counter_sections - 1,\n+\t\t  \t\t\t     0)));\n+\n+  counter_sections_value = NULL_TREE;\n+  for (i = 0; i < function->n_counter_sections; i++)\n+    {\n+      tree counter_section_value\n+\t= build_counter_section_value (function->counter_sections[i].tag,\n+\t\t\t\t       function->counter_sections[i].n_counters);\n+      set_purpose (counter_section_value, counter_section_fields);\n+      counter_sections_value =\n+\ttree_cons (NULL_TREE,\n+\t\t   build_constructor (counter_section_type,\n+\t\t\t\t      nreverse (counter_section_value)),\n+\t\t   counter_sections_value);\n+    }\n+  finish_builtin_struct (counter_section_type, \"__counter_section\",\n+\t\t\t counter_section_fields, NULL_TREE);\n+\n+  if (function->n_counter_sections)\n+    {\n+      counter_sections_value = \n+\t      build_constructor (counter_sections_array_type,\n+\t\t\t\t nreverse (counter_sections_value)),\n+      counter_sections_value = build1 (ADDR_EXPR,\n+\t\t\t\t       counter_sections_ptr_type,\n+\t\t\t\t       counter_sections_value);\n+    }\n+  else\n+    counter_sections_value = null_pointer_node;\n+\n+  value = tree_cons (NULL_TREE, counter_sections_value, value);\n+\n+  return value;\n+}\n+\n+/* Creates fields of struct gcov_info type (in gcov-io.h).  */\n+static tree\n+build_gcov_info_fields (gcov_info_type)\n+     tree gcov_info_type;\n+{\n+  tree field, fields;\n+  char *filename;\n+  int filename_len;\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree function_info_fields, function_info_type, function_info_ptr_type;\n+  tree counter_section_data_fields, counter_section_data_type;\n+  tree counter_section_data_ptr_type;\n+\n+  /* Version ident */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, long_unsigned_type_node);\n+\n+  /* next -- NULL */\n+  field = build_decl (FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type\n+\t\t      (build_qualified_type\n+\t\t       (gcov_info_type, TYPE_QUAL_CONST)));\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  \n+  /* Filename */\n+  filename = getpwd ();\n+  filename = (filename && da_file_name[0] != '/'\n+\t      ? concat (filename, \"/\", da_file_name, NULL)\n+\t      : da_file_name);\n+  filename_len = strlen (filename);\n+  if (filename != da_file_name)\n+    free (filename);\n+\n+  field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  \n+  /* Workspace */\n+  field = build_decl (FIELD_DECL, NULL_TREE, long_integer_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* number of functions */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+      \n+  /* function_info table */\n+  function_info_fields = build_function_info_fields ();\n+  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  finish_builtin_struct (function_info_type, \"__function_info\",\n+\t\t\t function_info_fields, NULL_TREE);\n+  function_info_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (function_info_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, function_info_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+    \n+  /* n_counter_sections  */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+  \n+  /* counter sections */\n+  counter_section_data_fields = build_counter_section_data_fields ();\n+  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n+\t\t\t counter_section_data_fields, NULL_TREE);\n+  counter_section_data_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_data_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, counter_section_data_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates struct gcov_info value (in gcov-io.h).  */\n+static tree\n+build_gcov_info_value ()\n+{\n+  tree value = NULL_TREE;\n+  tree filename_string;\n+  char *filename;\n+  int filename_len;\n+  unsigned n_functions, i;\n+  struct function_list *item;\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree function_info_fields, function_info_type, function_info_ptr_type;\n+  tree functions;\n+  tree counter_section_data_fields, counter_section_data_type;\n+  tree counter_section_data_ptr_type, counter_sections;\n+\n+  /* Version ident */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (long_unsigned_type_node,\n+\t\t\t      build_int_2 (GCOV_VERSION, 0)),\n+\t\t     value);\n+\n+  /* next -- NULL */\n+  value = tree_cons (NULL_TREE, null_pointer_node, value);\n+  \n+  /* Filename */\n+  filename = getpwd ();\n+  filename = (filename && da_file_name[0] != '/'\n+\t      ? concat (filename, \"/\", da_file_name, NULL)\n+\t      : da_file_name);\n+  filename_len = strlen (filename);\n+  filename_string = build_string (filename_len + 1, filename);\n+  if (filename != da_file_name)\n+    free (filename);\n+  TREE_TYPE (filename_string) =\n+\t  build_array_type (char_type_node,\n+\t\t\t    build_index_type (build_int_2 (filename_len, 0)));\n+  value = tree_cons (NULL_TREE,\n+\t\t     build1 (ADDR_EXPR,\n+\t\t\t     string_type,\n+\t\t       \t     filename_string),\n+\t\t     value);\n+  \n+  /* Workspace */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (long_integer_type_node, integer_zero_node),\n+\t\t     value);\n+      \n+  /* number of functions */\n+  n_functions = 0;\n+  for (item = functions_head; item != 0; item = item->next, n_functions++)\n+    continue;\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (n_functions, 0)),\n+\t\t     value);\n+\n+  /* function_info table */\n+  function_info_fields = build_function_info_fields ();\n+  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  function_info_ptr_type =\n+\t  build_pointer_type (\n+\t\tbuild_qualified_type (function_info_type,\n+\t       \t\t\t      TYPE_QUAL_CONST));\n+  functions = NULL_TREE;\n+  for (item = functions_head; item != 0; item = item->next)\n+    {\n+      tree function_info_value = build_function_info_value (item);\n+      set_purpose (function_info_value, function_info_fields);\n+      functions\n+\t= tree_cons (NULL_TREE,\n+\t\t     build_constructor (function_info_type,\n+\t\t\t\t\tnreverse (function_info_value)),\n+\t\t     functions);\n+    }\n+  finish_builtin_struct (function_info_type, \"__function_info\",\n+\t\t\t function_info_fields, NULL_TREE);\n+\n+  /* Create constructor for array.  */\n+  if (n_functions)\n+    {\n+      tree array_type;\n+\n+      array_type = build_array_type (\n+\t\t\tfunction_info_type,\n+   \t\t\tbuild_index_type (build_int_2 (n_functions - 1, 0)));\n+      functions = build_constructor (array_type, nreverse (functions));\n+      functions = build1 (ADDR_EXPR,\n+\t\t\t  function_info_ptr_type,\n+\t\t\t  functions);\n+    }\n+  else\n+    functions = null_pointer_node;\n+\n+  value = tree_cons (NULL_TREE, functions, value);\n+\n+  /* n_counter_sections  */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (profile_info.n_sections, 0)),\n+\t\t     value);\n+  \n+  /* counter sections */\n+  counter_section_data_fields = build_counter_section_data_fields ();\n+  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  counter_sections = NULL_TREE;\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    {\n+      tree counter_sections_value =\n+\t      build_counter_section_data_value (\n+\t\tprofile_info.section_info[i].tag,\n+\t\tprofile_info.section_info[i].n_counters);\n+      set_purpose (counter_sections_value, counter_section_data_fields);\n+      counter_sections =\n+\ttree_cons (NULL_TREE,\n+\t\t   build_constructor (counter_section_data_type,\n+\t\t\t\t      nreverse (counter_sections_value)),\n+\t\t   counter_sections);\n+    }\n+  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n+\t\t\t counter_section_data_fields, NULL_TREE);\n+  counter_section_data_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_data_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+\n+  if (profile_info.n_sections)\n+    {\n+      tree cst_type = build_index_type (build_int_2 (profile_info.n_sections-1,\n+\t\t\t\t\t\t     0));\n+      cst_type = build_array_type (counter_section_data_type, cst_type);\n+      counter_sections = build_constructor (cst_type,\n+\t\t\t\t\t    nreverse (counter_sections));\n+      counter_sections = build1 (ADDR_EXPR,\n+\t\t\t\t counter_section_data_ptr_type,\n+\t\t\t\t counter_sections);\n+    }\n+  else\n+    counter_sections = null_pointer_node;\n+  value = tree_cons (NULL_TREE, counter_sections, value);\n+\n+  return value;\n+}\n+\n+/* Write out the structure which libgcc uses to locate all the arc\n+   counters.  The structures used here must match those defined in\n+   gcov-io.h.  Write out the constructor to call __gcov_init.  */\n+\n+static void\n+create_coverage ()\n+{\n+  tree gcov_info_fields, gcov_info_type, gcov_info_value, gcov_info;\n+  char name[20];\n+  char *ctor_name;\n+  tree ctor;\n+  rtx gcov_info_address;\n+  int save_flag_inline_functions = flag_inline_functions;\n+  unsigned i;\n+\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    if (profile_info.section_info[i].n_counters)\n+      break;\n+  if (i == profile_info.n_sections)\n+    return;\n+  \n+  gcov_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  gcov_info_fields = build_gcov_info_fields (gcov_info_type);\n+  gcov_info_value = build_gcov_info_value ();\n+  set_purpose (gcov_info_value, gcov_info_fields);\n+  finish_builtin_struct (gcov_info_type, \"__gcov_info\",\n+\t\t\t gcov_info_fields, NULL_TREE);\n+\n+  gcov_info = build (VAR_DECL, gcov_info_type, NULL_TREE, NULL_TREE);\n+  DECL_INITIAL (gcov_info) =\n+    build_constructor (gcov_info_type, nreverse (gcov_info_value));\n+\n+  TREE_STATIC (gcov_info) = 1;\n+  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n+  DECL_NAME (gcov_info) = get_identifier (name);\n+  \n+  /* Build structure.  */\n+  assemble_variable (gcov_info, 0, 0, 0);\n+\n+  /* Build the constructor function to invoke __gcov_init.  */\n+  ctor_name = concat (IDENTIFIER_POINTER (get_file_function_name ('I')),\n+\t\t      \"_GCOV\", NULL);\n+  ctor = build_decl (FUNCTION_DECL, get_identifier (ctor_name),\n+\t\t     build_function_type (void_type_node, NULL_TREE));\n+  free (ctor_name);\n+  DECL_EXTERNAL (ctor) = 0;\n+\n+  /* It can be a static function as long as collect2 does not have\n+     to scan the object file to find its ctor/dtor routine.  */\n+  TREE_PUBLIC (ctor) = ! targetm.have_ctors_dtors;\n+  TREE_USED (ctor) = 1;\n+  DECL_RESULT (ctor) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+\n+  ctor = (*lang_hooks.decls.pushdecl) (ctor);\n+  rest_of_decl_compilation (ctor, 0, 1, 0);\n+  announce_function (ctor);\n+  current_function_decl = ctor;\n+  DECL_INITIAL (ctor) = error_mark_node;\n+  make_decl_rtl (ctor, NULL);\n+  init_function_start (ctor, input_filename, lineno);\n+  (*lang_hooks.decls.pushlevel) (0);\n+  expand_function_start (ctor, 0);\n+  cfun->arc_profile = 0;\n+\n+  /* Actually generate the code to call __gcov_init.  */\n+  gcov_info_address = force_reg (Pmode, XEXP (DECL_RTL (gcov_info), 0));\n+  emit_library_call (gcov_init_libfunc, LCT_NORMAL, VOIDmode, 1,\n+\t\t     gcov_info_address, Pmode);\n+\n+  expand_function_end (input_filename, lineno, 0);\n+  (*lang_hooks.decls.poplevel) (1, 0, 1);\n+\n+  /* Since ctor isn't in the list of globals, it would never be emitted\n+     when it's considered to be 'safe' for inlining, so turn off\n+     flag_inline_functions.  */\n+  flag_inline_functions = 0;\n+\n+  rest_of_compilation (ctor);\n+\n+  /* Reset flag_inline_functions to its original value.  */\n+  flag_inline_functions = save_flag_inline_functions;\n+\n+  if (! quiet_flag)\n+    fflush (asm_out_file);\n+  current_function_decl = NULL_TREE;\n+\n+  if (targetm.have_ctors_dtors)\n+    (* targetm.asm_out.constructor) (XEXP (DECL_RTL (ctor), 0),\n+\t\t\t\t     DEFAULT_INIT_PRIORITY);\n+}\n+\f\n+/* Find (and create if not present) a section with TAG for the current\n+   function.  */\n+struct section_info *\n+find_counters_section (tag)\n+     unsigned tag;\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    if (profile_info.section_info[i].tag == tag)\n+      return profile_info.section_info + i;\n+\n+  if (i == MAX_COUNTER_SECTIONS)\n+    abort ();\n+\n+  profile_info.section_info[i].tag = tag;\n+  profile_info.section_info[i].present = 0;\n+  profile_info.section_info[i].n_counters = 0;\n+  profile_info.section_info[i].n_counters_now = 0;\n+  profile_info.n_sections++;\n+\n+  return profile_info.section_info + i;\n+}\n+\n+/* Generate a MEM rtl to access counter NO in counter section TAG.  */\n+\n+rtx\n+coverage_counter_ref (unsigned tag, unsigned no)\n+{\n+  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n+  struct section_info *sect = find_counters_section (tag);\n+  rtx ref;\n+\n+  if (!profiler_label)\n+    {\n+      /* Generate and save a copy of this so it can be shared.  */\n+      char buf[20];\n+      \n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 2);\n+      profiler_label = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n+    }\n+  if (no + 1 > (unsigned) sect->n_counters_now)\n+    sect->n_counters_now = no + 1;\n+\n+  no += sect->n_counters;\n+  ref = plus_constant (profiler_label, GCOV_TYPE_SIZE / BITS_PER_UNIT * no);\n+  ref = gen_rtx_MEM (mode, ref);\n+  set_mem_alias_set (ref, new_alias_set ());\n+\n+  return ref;\n+}\n+\n+\f\n+/* Perform file-level initialization. Read in data file, generate name\n+   of graph file. */\n+\n+void\n+coverage_init (filename)\n+  const char *filename;\n+{\n+  int len = strlen (filename);\n+\n+  da_file_name = (char *) xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n+  strcpy (da_file_name, filename);\n+  strcat (da_file_name, GCOV_DATA_SUFFIX);\n+  \n+  read_counts_file ();\n+\n+  /* Open the bbg output file.  */\n+  bbg_file_name = (char *) xmalloc (len + strlen (GCOV_GRAPH_SUFFIX) + 1);\n+  strcpy (bbg_file_name, filename);\n+  strcat (bbg_file_name, GCOV_GRAPH_SUFFIX);\n+}\n+\n+/* Performs file-level cleanup.  Close graph file, generate coverage\n+   variables and constructor.  */\n+\n+void\n+coverage_finish ()\n+{\n+  create_coverage ();\n+  if (bbg_file_opened)\n+    {\n+      int error = gcov_close ();\n+      \n+      if (error)\n+\tunlink (bbg_file_name);\n+#if SELF_COVERAGE\n+      /* If the compiler is instrumented, we should not\n+         unconditionally remove the counts file, because we might be\n+         recompiling ourselves. The .da files are all removed during\n+         copying the stage1 files.  */\n+      if (error)\n+#endif\n+\tunlink (da_file_name);\n+    }\n+}\n+\n+\n+#include \"gt-coverage.h\""}, {"sha": "f6ead44a59711501dcd5504abb3798518f6ee520", "filename": "gcc/coverage.h", "status": "renamed", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -1,5 +1,5 @@\n-/* profile.h - Defines data exported from profile.c to other passes.\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+/* coverage.h - Defines data exported from coverage.c\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -18,8 +18,10 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-#ifndef GCC_PROFILE_H\n-#define GCC_PROFILE_H\n+#ifndef GCC_COVERAGE_H\n+#define GCC_COVERAGE_H\n+\n+#include \"gcov-io.h\"\n \n /* The number of different counter sections.  */\n #define MAX_COUNTER_SECTIONS\t1\n@@ -57,6 +59,14 @@ struct profile_info\n \n extern struct profile_info profile_info;\n \n+extern void coverage_init (const char *);\n+extern void coverage_finish (void);\n+extern void coverage_end_function (void);\n+extern int coverage_begin_output (void);\n+extern rtx coverage_counter_ref (unsigned /*tag*/, unsigned/*num*/);\n+\n+gcov_type *get_coverage_counts (unsigned /*tag*/, unsigned /*expected*/);\n struct section_info *find_counters_section\tPARAMS ((unsigned));\n \n+\n #endif", "previous_filename": "gcc/profile.h"}, {"sha": "fd9d1228467bb18a2a52a720d1d194a8c1111563", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include <getopt.h>\n #define IN_GCOV (-1)\n #include \"gcov-io.h\"\n+#include \"gcov-io.c\"\n \n static void dump_file PARAMS ((const char *));\n static void print_prefix PARAMS ((const char *, unsigned));"}, {"sha": "94002a9c42ba859b9cb9c3a897d4ba34844313ff", "filename": "gcc/gcov-io.c", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -0,0 +1,431 @@\n+/* File format for coverage information\n+   Copyright (C) 1996, 1997, 1998, 2000, 2002,\n+   2003  Free Software Foundation, Inc.\n+   Contributed by Bob Manson <manson@cygnus.com>.\n+   Completely remangled by Nathan Sidwell <nathan@codesourcery.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Routines declared in gcov-io.h.  This file should be #included by\n+   another source file, after having #included gcov-io.h.  */\n+\n+/* Open a gcov file. NAME is the name of the file to open and MODE\n+   indicates whether a new file should be created, or an existing file\n+   opened for modification. If MODE is >= 0 an existing file will be\n+   opened, if possible, and if MODE is <= 0, a new file will be\n+   created. Use MODE=0 to attempt to reopen an existing file and then\n+   fall back on creating a new one.  Return zero on failure, >0 on\n+   opening an existing file and <0 on creating a new one.  */\n+\n+GCOV_LINKAGE int\n+gcov_open (const char *name, int mode)\n+{\n+  int result = 1;\n+  size_t alloc = 1024;\n+#if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n+  struct flock s_flock;\n+\n+  s_flock.l_type = F_WRLCK;\n+  s_flock.l_whence = SEEK_SET;\n+  s_flock.l_start = 0;\n+  s_flock.l_len = 0; /* Until EOF.  */\n+  s_flock.l_pid = getpid ();\n+#endif\n+  \n+  if (gcov_var.file)\n+    abort ();\n+  gcov_var.position = gcov_var.length = 0;\n+  gcov_var.error = gcov_var.modified = 0;\n+  if (mode >= 0)\n+    gcov_var.file = fopen (name, \"r+b\");\n+  if (!gcov_var.file && mode <= 0)\n+    {\n+      result = -1;\n+      gcov_var.file = fopen (name, \"w+b\");\n+    }\n+  if (!gcov_var.file)\n+    return 0;\n+\n+#if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n+  while (fcntl (fileno (gcov_var.file), F_SETLKW, &s_flock)\n+\t && errno == EINTR)\n+    continue;\n+#endif\n+\n+  if (result >= 0)\n+    {\n+      if (fseek (gcov_var.file, 0, SEEK_END))\n+\t{\n+\t  fclose (gcov_var.file);\n+\t  gcov_var.file = 0;\n+\t  return 0;\n+\t}\n+      gcov_var.length = ftell (gcov_var.file);\n+      fseek (gcov_var.file, 0, SEEK_SET);\n+      alloc += gcov_var.length;\n+    }\n+  if (alloc > gcov_var.alloc)\n+    {\n+      if (gcov_var.buffer)\n+\tfree (gcov_var.buffer);\n+      gcov_var.alloc = alloc;\n+#if IN_LIBGCOV\n+      gcov_var.buffer = malloc (gcov_var.alloc);\n+      if (!gcov_var.buffer)\n+\t{\n+\t  fclose (gcov_var.file);\n+\t  gcov_var.file = 0;\n+\t  gcov_var.length = 0;\n+\t  gcov_var.alloc = 0;\n+\t  return 0;\n+\t}\n+#else\n+      gcov_var.buffer = xmalloc (gcov_var.alloc);\n+#endif\n+    }\n+  if (result >= 0\n+      && fread (gcov_var.buffer, gcov_var.length, 1, gcov_var.file) != 1)\n+    {\n+      fclose (gcov_var.file);\n+      gcov_var.file = 0;\n+      gcov_var.length = 0;\n+      return 0;\n+    }\n+  return result;\n+}\n+\n+/* Close the current gcov file. Flushes data to disk. Returns nonzero\n+   on failure or error flag set.  */\n+\n+GCOV_LINKAGE int\n+gcov_close ()\n+{\n+  int result = 0;\n+  \n+  if (gcov_var.file)\n+    {\n+      if (gcov_var.modified\n+\t  && (fseek (gcov_var.file, 0, SEEK_SET)\n+\t      || fwrite (gcov_var.buffer, gcov_var.length,\n+\t\t\t 1, gcov_var.file) != 1))\n+\tresult = 1;\n+      fclose (gcov_var.file);\n+      gcov_var.file = 0;\n+      gcov_var.length = 0;\n+    }\n+#if !IN_LIBGCOV\n+  free (gcov_var.buffer);\n+  gcov_var.alloc = 0;\n+  gcov_var.buffer = 0;\n+#endif\n+  return result ? 1 : gcov_var.error;\n+}\n+\n+#if !IN_GCOV\n+/* Allocate space to write BYTES bytes to the gcov file. Return a\n+   pointer to those bytes, or NULL on failure.  */\n+\n+GCOV_LINKAGE unsigned char *\n+gcov_write_bytes (unsigned bytes)\n+{\n+  char unsigned *result;\n+\n+  if (gcov_var.position + bytes > gcov_var.alloc)\n+    {\n+      size_t new_size = (gcov_var.alloc + bytes) * 3 / 2;\n+\n+      if (!gcov_var.buffer)\n+\treturn 0;\n+#if IN_LIBGCOV\n+      result = realloc (gcov_var.buffer, new_size);\n+      if (!result)\n+\t{\n+\t  free (gcov_var.buffer);\n+\t  gcov_var.buffer = 0;\n+\t  gcov_var.alloc = 0;\n+\t  gcov_var.position = gcov_var.length = 0;\n+\t  gcov_var.error = 1;\n+\t  return 0;\n+\t}\n+#else\n+      result = xrealloc (gcov_var.buffer, new_size);\n+#endif\n+      gcov_var.alloc = new_size;\n+      gcov_var.buffer = result;\n+    }\n+  \n+  result = &gcov_var.buffer[gcov_var.position];\n+  gcov_var.position += bytes;\n+  gcov_var.modified = 1;\n+  if (gcov_var.position > gcov_var.length)\n+    gcov_var.length = gcov_var.position;\n+  return result;\n+}\n+\n+/* Write unsigned VALUE to coverage file.  Sets error flag\n+   appropriately.  */\n+\n+GCOV_LINKAGE void\n+gcov_write_unsigned (unsigned value)\n+{\n+  unsigned char *buffer = gcov_write_bytes (4);\n+  unsigned ix;\n+\n+  if (!buffer)\n+    return;\n+  for (ix = 4; ix--; )\n+    {\n+      buffer[ix] = value;\n+      value >>= 8;\n+    }\n+  if (sizeof (value) > 4 && value)\n+    gcov_var.error = -1;\n+\n+  return;\n+}\n+\n+/* Write counter VALUE to coverage file.  Sets error flag\n+   appropriately.  */\n+\n+#if IN_LIBGCOV\n+GCOV_LINKAGE void\n+gcov_write_counter (gcov_type value)\n+{\n+  unsigned char *buffer = gcov_write_bytes (8);\n+  unsigned ix;\n+\n+  if (!buffer)\n+    return;\n+  for (ix = 8; ix--; )\n+    {\n+      buffer[ix] = value;\n+      value >>= 8;\n+    }\n+  if ((sizeof (value) > 8 && value) || value < 0)\n+    gcov_var.error = -1;\n+  return;\n+}\n+#endif /* IN_LIBGCOV */\n+\n+/* Write STRING to coverage file.  Sets error flag on file\n+   error, overflow flag on overflow */\n+\n+GCOV_LINKAGE void\n+gcov_write_string (const char *string)\n+{\n+  unsigned length = 0;\n+  unsigned pad = 0;\n+  unsigned rem = 0;\n+  unsigned char *buffer;\n+\n+  if (string)\n+    {\n+      length = strlen (string);\n+      rem = 4 - (length & 3);\n+    }\n+  \n+  buffer = gcov_write_bytes (4 + length + rem);\n+  if (buffer)\n+    {\n+      unsigned ix;\n+      unsigned value = length;\n+      \n+      for (ix = 4; ix--; )\n+\t{\n+\t  buffer[ix] = value;\n+\t  value >>= 8;\n+\t}\n+      memcpy (buffer + 4, string, length);\n+      memcpy (buffer + 4 + length, &pad, rem);\n+    }\n+}\n+\n+/* Write a tag TAG and reserve space for the record length. Return a\n+   value to be used for gcov_write_length.  */\n+\n+GCOV_LINKAGE unsigned long\n+gcov_write_tag (unsigned tag)\n+{\n+  unsigned long result = gcov_var.position;\n+  unsigned char *buffer = gcov_write_bytes (8);\n+  unsigned ix;\n+\n+  if (!buffer)\n+    return 0;\n+  for (ix = 4; ix--; )\n+    {\n+      buffer[ix] = tag;\n+      tag >>= 8;\n+    }\n+  memset (buffer + 4, 0, 4);\n+  return result;\n+}\n+\n+/* Write a record length using POSITION, which was returned by\n+   gcov_write_tag.  The current file position is the end of the\n+   record, and is restored before returning.  Returns nonzero on\n+   overflow.  */\n+\n+GCOV_LINKAGE void\n+gcov_write_length (unsigned long position)\n+{\n+  if (position)\n+    {\n+      unsigned length = gcov_var.position - position - 8;\n+      unsigned char *buffer = &gcov_var.buffer[position + 4];\n+      unsigned ix;\n+      \n+      for (ix = 4; ix--; )\n+\t{\n+\t  buffer[ix] = length;\n+\t  length >>= 8;\n+\t}\n+    }\n+}\n+\n+#if IN_LIBGCOV\n+/* Write a summary structure to the gcov file.  Return non-zero on\n+   overflow.  */\n+\n+GCOV_LINKAGE void\n+gcov_write_summary (unsigned tag, const struct gcov_summary *summary)\n+{\n+  unsigned long base;\n+\n+  base = gcov_write_tag (tag);\n+  gcov_write_unsigned (summary->checksum);\n+  gcov_write_unsigned (summary->runs);\n+  gcov_write_unsigned (summary->arcs);\n+  gcov_write_counter (summary->arc_sum);\n+  gcov_write_counter (summary->arc_max_one);\n+  gcov_write_counter (summary->arc_sum_max);\n+  gcov_write_length (base);\n+}\n+#endif /* IN_LIBGCOV */\n+\n+#endif /*!IN_GCOV */\n+\n+/* Return a pointer to read BYTES bytes from the gcov file. Returns\n+   NULL on failure (read past EOF). */\n+\n+GCOV_LINKAGE const unsigned char *\n+gcov_read_bytes (unsigned bytes)\n+{\n+  const unsigned char *result;\n+  \n+  if (gcov_var.position + bytes > gcov_var.length)\n+    {\n+      gcov_var.error = 1;\n+      return 0;\n+    }\n+  \n+  result = &gcov_var.buffer[gcov_var.position];\n+  gcov_var.position += bytes;\n+  return result;\n+}\n+\n+/* Read unsigned value from a coverage file. Sets error flag on file\n+   error, overflow flag on overflow */\n+\n+GCOV_LINKAGE unsigned\n+gcov_read_unsigned ()\n+{\n+  unsigned value = 0;\n+  unsigned ix;\n+  const unsigned char *buffer = gcov_read_bytes (4);\n+\n+  if (!buffer)\n+    return 0;\n+  for (ix = sizeof (value); ix < 4; ix++)\n+    if (buffer[ix])\n+      gcov_var.error = -1;\n+  for (ix = 0; ix != 4; ix++)\n+    {\n+      value <<= 8;\n+      value |= buffer[ix];\n+    }\n+  return value;\n+}\n+\n+/* Read counter value from a coverage file. Sets error flag on file\n+   error, overflow flag on overflow */\n+\n+GCOV_LINKAGE gcov_type\n+gcov_read_counter ()\n+{\n+  gcov_type value = 0;\n+  unsigned ix;\n+  const unsigned char *buffer = gcov_read_bytes (8);\n+\n+  if (!buffer)\n+    return 0;\n+  for (ix = sizeof (value); ix < 8; ix++)\n+    if (buffer[ix])\n+      gcov_var.error = -1;\n+  for (ix = 0; ix != 8; ix++)\n+    {\n+      value <<= 8;\n+      value |= buffer[ix];\n+    }\n+  if (value < 0)\n+    gcov_var.error = -1;\n+  return value;\n+}\n+\n+/* Read string from coverage file. Returns a pointer to a static\n+   buffer, or NULL on empty string. You must copy the string before\n+   calling another gcov function.  */\n+\n+GCOV_LINKAGE const char *\n+gcov_read_string ()\n+{\n+  unsigned length = gcov_read_unsigned ();\n+  \n+  if (!length)\n+    return 0;\n+\n+  length += 4 - (length & 3);\n+  return (const char *) gcov_read_bytes (length);\n+}\n+\n+GCOV_LINKAGE void\n+gcov_read_summary (struct gcov_summary *summary)\n+{\n+  summary->checksum = gcov_read_unsigned ();\n+  summary->runs = gcov_read_unsigned ();\n+  summary->arcs = gcov_read_unsigned ();\n+  summary->arc_sum = gcov_read_counter ();\n+  summary->arc_max_one = gcov_read_counter ();\n+  summary->arc_sum_max = gcov_read_counter ();\n+}\n+\n+\n+#if IN_GCOV > 0\n+/* Return the modification time of the current gcov file.  */\n+\n+GCOV_LINKAGE time_t\n+gcov_time ()\n+{\n+  struct stat status;\n+  \n+  if (fstat (fileno (gcov_var.file), &status))\n+    return 0;\n+  else\n+    return status.st_mtime;\n+}\n+#endif /* IN_GCOV */"}, {"sha": "634f6b3d534209cc93e80f8a194b48a183e2367d", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 35, "deletions": 434, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -1,5 +1,6 @@\n /* File format for coverage information\n-   Copyright (C) 1996, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 2000, 2002,\n+   2003 Free Software Foundation, Inc.\n    Contributed by Bob Manson <manson@cygnus.com>.\n    Completely remangled by Nathan Sidwell <nathan@codesourcery.com>.\n \n@@ -160,6 +161,17 @@ typedef HOST_WIDEST_INT gcov_type;\n #endif\n #endif\n \n+/* In lib gcov we want function linkage to be static, so we do not\n+   polute the global namespace. In the compiler we want it extern, so\n+   that they can be accessed from elsewhere.  */\n+#if IN_LIBGCOV || IN_GCOV\n+#define GCOV_LINKAGE static\n+#else\n+#ifndef GCOV_LINKAGE\n+#define GCOV_LINKAGE extern\n+#endif\n+#endif\n+\n /* File suffixes.  */\n #define GCOV_DATA_SUFFIX \".da\"\n #define GCOV_GRAPH_SUFFIX \".bbg\"\n@@ -227,28 +239,28 @@ struct gcov_summary\n    by write_profile must match these.  */\n \n /* Information about section of counters for a function.  */\n-struct counter_section\n+struct gcov_counter_section\n {\n   unsigned tag;\t\t/* Tag of the section.  */\n   unsigned n_counters;\t/* Number of counters in the section.  */\n };\n \n #if IN_LIBGCOV\n /* Information about section of counters for an object file.  */\n-struct counter_section_data\n+struct gcov_counter_section_data\n {\n   unsigned tag;\t\t/* Tag of the section.  */\n   unsigned n_counters;\t/* Number of counters in the section.  */\n   gcov_type *counters;\t/* The data.  */\n };\n \n /* Information about a single function.  */\n-struct function_info\n+struct gcov_function_info\n {\n   const char *name;\t        /* (mangled) name of function */\n   unsigned checksum;\t\t/* function checksum */\n   unsigned n_counter_sections;\t/* Number of types of counters */\n-  const struct counter_section *counter_sections;\n+  const struct gcov_counter_section *counter_sections;\n   \t\t\t\t/* The section descriptions */\n };\n \n@@ -262,10 +274,10 @@ struct gcov_info\n   long wkspc;\t  \t        /* libgcc workspace */\n \n   unsigned n_functions;             /* number of functions */\n-  const struct function_info *functions; /* table of functions */\n+  const struct gcov_function_info *functions; /* table of functions */\n \n   unsigned n_counter_sections;\t/* Number of types of counters */\n-  const struct counter_section_data *counter_sections;\n+  const struct gcov_counter_section_data *counter_sections;\n   \t\t\t\t/* The data to be put into the sections.  */\n };\n \n@@ -275,18 +287,12 @@ extern void __gcov_init (struct gcov_info *);\n /* Called before fork, to avoid double counting.  */\n extern void __gcov_flush (void);\n \n-/* Since this file is used in both host and target files, and we don't\n-   include ansidecl.h in target files, provide some necessary macros.  */\n-#ifndef ATTRIBUTE_UNUSED\n-# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n-#endif\n-\n #endif /* IN_LIBGCOV */\n \n /* Because small reads and writes, interspersed with seeks cause lots\n    of disk activity, we buffer the entire count files.  */\n \n-static struct gcov_var\n+GCOV_LINKAGE struct gcov_var\n {\n   FILE *file;\n   size_t position;\n@@ -298,426 +304,35 @@ static struct gcov_var\n } gcov_var;\n \n /* Functions for reading and writing gcov files.  */\n-static int gcov_open (const char */*name*/, int /*truncate*/);\n-static int gcov_close (void);\n+GCOV_LINKAGE int gcov_open (const char */*name*/, int /*truncate*/);\n+GCOV_LINKAGE int gcov_close (void);\n #if !IN_GCOV\n-static unsigned char *gcov_write_bytes (unsigned);\n-static void gcov_write_unsigned (unsigned);\n+GCOV_LINKAGE unsigned char *gcov_write_bytes (unsigned);\n+GCOV_LINKAGE void gcov_write_unsigned (unsigned);\n #if IN_LIBGCOV\n-static void gcov_write_counter (gcov_type);\n+GCOV_LINKAGE void gcov_write_counter (gcov_type);\n #endif\n-static void gcov_write_string (const char *);\n-static unsigned long gcov_write_tag (unsigned);\n-static void gcov_write_length (unsigned long /*position*/);\n+GCOV_LINKAGE void gcov_write_string (const char *);\n+GCOV_LINKAGE unsigned long gcov_write_tag (unsigned);\n+GCOV_LINKAGE void gcov_write_length (unsigned long /*position*/);\n #if IN_LIBGCOV\n-static void gcov_write_summary (unsigned, const struct gcov_summary *);\n+GCOV_LINKAGE void gcov_write_summary (unsigned, const struct gcov_summary *);\n #endif\n #endif /* !IN_GCOV */\n-static const unsigned char *gcov_read_bytes (unsigned);\n-static unsigned gcov_read_unsigned (void);\n-static gcov_type gcov_read_counter (void);\n-static const char *gcov_read_string (void);\n-static void gcov_read_summary (struct gcov_summary *);\n+GCOV_LINKAGE const unsigned char *gcov_read_bytes (unsigned);\n+GCOV_LINKAGE unsigned gcov_read_unsigned (void);\n+GCOV_LINKAGE gcov_type gcov_read_counter (void);\n+GCOV_LINKAGE const char *gcov_read_string (void);\n+GCOV_LINKAGE void gcov_read_summary (struct gcov_summary *);\n \n static unsigned long gcov_position (void);\n static void gcov_seek (unsigned long /*base*/, unsigned /*length */);\n static unsigned long gcov_seek_end (void);\n static int gcov_is_eof (void);\n static int gcov_is_error (void);\n #if IN_GCOV > 0\n-static time_t gcov_time (void);\n-#endif\n-\n-/* Open a gcov file. NAME is the name of the file to open and MODE\n-   indicates whether a new file should be created, or an existing file\n-   opened for modification. If MODE is >= 0 an existing file will be\n-   opened, if possible, and if MODE is <= 0, a new file will be\n-   created. Use MODE=0 to attempt to reopen an existing file and then\n-   fall back on creating a new one.  Return zero on failure, >0 on\n-   opening an existing file and <0 on creating a new one.  */\n-\n-static int\n-gcov_open (const char *name, int mode)\n-{\n-  int result = 1;\n-  size_t alloc = 1024;\n-#if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n-  struct flock s_flock;\n-\n-  s_flock.l_type = F_WRLCK;\n-  s_flock.l_whence = SEEK_SET;\n-  s_flock.l_start = 0;\n-  s_flock.l_len = 0; /* Until EOF.  */\n-  s_flock.l_pid = getpid ();\n-#endif\n-  \n-  if (gcov_var.file)\n-    abort ();\n-  gcov_var.position = gcov_var.length = 0;\n-  gcov_var.error = gcov_var.modified = 0;\n-  if (mode >= 0)\n-    gcov_var.file = fopen (name, \"r+b\");\n-  if (!gcov_var.file && mode <= 0)\n-    {\n-      result = -1;\n-      gcov_var.file = fopen (name, \"w+b\");\n-    }\n-  if (!gcov_var.file)\n-    return 0;\n-\n-#if defined (TARGET_HAS_F_SETLKW) && IN_LIBGCOV\n-  while (fcntl (fileno (gcov_var.file), F_SETLKW, &s_flock)\n-\t && errno == EINTR)\n-    continue;\n-#endif\n-\n-  if (result >= 0)\n-    {\n-      if (fseek (gcov_var.file, 0, SEEK_END))\n-\t{\n-\t  fclose (gcov_var.file);\n-\t  gcov_var.file = 0;\n-\t  return 0;\n-\t}\n-      gcov_var.length = ftell (gcov_var.file);\n-      fseek (gcov_var.file, 0, SEEK_SET);\n-      alloc += gcov_var.length;\n-    }\n-  if (alloc > gcov_var.alloc)\n-    {\n-      if (gcov_var.buffer)\n-\tfree (gcov_var.buffer);\n-      gcov_var.alloc = alloc;\n-#if IN_LIBGCOV\n-      gcov_var.buffer = malloc (gcov_var.alloc);\n-      if (!gcov_var.buffer)\n-\t{\n-\t  fclose (gcov_var.file);\n-\t  gcov_var.file = 0;\n-\t  gcov_var.length = 0;\n-\t  gcov_var.alloc = 0;\n-\t  return 0;\n-\t}\n-#else\n-      gcov_var.buffer = xmalloc (gcov_var.alloc);\n-#endif\n-    }\n-  if (result >= 0\n-      && fread (gcov_var.buffer, gcov_var.length, 1, gcov_var.file) != 1)\n-    {\n-      fclose (gcov_var.file);\n-      gcov_var.file = 0;\n-      gcov_var.length = 0;\n-      return 0;\n-    }\n-  return result;\n-}\n-\n-/* Close the current gcov file. Flushes data to disk. Returns nonzero\n-   on failure or error flag set.  */\n-\n-static int\n-gcov_close ()\n-{\n-  int result = 0;\n-  \n-  if (gcov_var.file)\n-    {\n-      if (gcov_var.modified\n-\t  && (fseek (gcov_var.file, 0, SEEK_SET)\n-\t      || fwrite (gcov_var.buffer, gcov_var.length,\n-\t\t\t 1, gcov_var.file) != 1))\n-\tresult = 1;\n-      fclose (gcov_var.file);\n-      gcov_var.file = 0;\n-      gcov_var.length = 0;\n-    }\n-#if !IN_LIBGCOV\n-  free (gcov_var.buffer);\n-  gcov_var.alloc = 0;\n-  gcov_var.buffer = 0;\n+GCOV_LINKAGE time_t gcov_time (void);\n #endif\n-  return result ? 1 : gcov_var.error;\n-}\n-\n-#if !IN_GCOV\n-/* Allocate space to write BYTES bytes to the gcov file. Return a\n-   pointer to those bytes, or NULL on failure.  */\n-\n-static unsigned char *\n-gcov_write_bytes (unsigned bytes)\n-{\n-  char unsigned *result;\n-\n-  if (gcov_var.position + bytes > gcov_var.alloc)\n-    {\n-      size_t new_size = (gcov_var.alloc + bytes) * 3 / 2;\n-\n-      if (!gcov_var.buffer)\n-\treturn 0;\n-#if IN_LIBGCOV\n-      result = realloc (gcov_var.buffer, new_size);\n-      if (!result)\n-\t{\n-\t  free (gcov_var.buffer);\n-\t  gcov_var.buffer = 0;\n-\t  gcov_var.alloc = 0;\n-\t  gcov_var.position = gcov_var.length = 0;\n-\t  gcov_var.error = 1;\n-\t  return 0;\n-\t}\n-#else\n-      result = xrealloc (gcov_var.buffer, new_size);\n-#endif\n-      gcov_var.alloc = new_size;\n-      gcov_var.buffer = result;\n-    }\n-  \n-  result = &gcov_var.buffer[gcov_var.position];\n-  gcov_var.position += bytes;\n-  gcov_var.modified = 1;\n-  if (gcov_var.position > gcov_var.length)\n-    gcov_var.length = gcov_var.position;\n-  return result;\n-}\n-\n-/* Write unsigned VALUE to coverage file.  Sets error flag\n-   appropriately.  */\n-\n-static void\n-gcov_write_unsigned (unsigned value)\n-{\n-  unsigned char *buffer = gcov_write_bytes (4);\n-  unsigned ix;\n-\n-  if (!buffer)\n-    return;\n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = value;\n-      value >>= 8;\n-    }\n-  if (sizeof (value) > 4 && value)\n-    gcov_var.error = -1;\n-\n-  return;\n-}\n-\n-/* Write counter VALUE to coverage file.  Sets error flag\n-   appropriately.  */\n-\n-#if IN_LIBGCOV\n-static void\n-gcov_write_counter (gcov_type value)\n-{\n-  unsigned char *buffer = gcov_write_bytes (8);\n-  unsigned ix;\n-\n-  if (!buffer)\n-    return;\n-  for (ix = 8; ix--; )\n-    {\n-      buffer[ix] = value;\n-      value >>= 8;\n-    }\n-  if ((sizeof (value) > 8 && value) || value < 0)\n-    gcov_var.error = -1;\n-  return;\n-}\n-#endif /* IN_LIBGCOV */\n-\n-/* Write STRING to coverage file.  Sets error flag on file\n-   error, overflow flag on overflow */\n-\n-static void\n-gcov_write_string (const char *string)\n-{\n-  unsigned length = 0;\n-  unsigned pad = 0;\n-  unsigned rem = 0;\n-  unsigned char *buffer;\n-\n-  if (string)\n-    {\n-      length = strlen (string);\n-      rem = 4 - (length & 3);\n-    }\n-  \n-  buffer = gcov_write_bytes (4 + length + rem);\n-  if (buffer)\n-    {\n-      unsigned ix;\n-      unsigned value = length;\n-      \n-      for (ix = 4; ix--; )\n-\t{\n-\t  buffer[ix] = value;\n-\t  value >>= 8;\n-\t}\n-      memcpy (buffer + 4, string, length);\n-      memcpy (buffer + 4 + length, &pad, rem);\n-    }\n-}\n-\n-/* Write a tag TAG and reserve space for the record length. Return a\n-   value to be used for gcov_write_length.  */\n-\n-static unsigned long\n-gcov_write_tag (unsigned tag)\n-{\n-  unsigned long result = gcov_var.position;\n-  unsigned char *buffer = gcov_write_bytes (8);\n-  unsigned ix;\n-\n-  if (!buffer)\n-    return 0;\n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = tag;\n-      tag >>= 8;\n-    }\n-  memset (buffer + 4, 0, 4);\n-  return result;\n-}\n-\n-/* Write a record length using POSITION, which was returned by\n-   gcov_write_tag.  The current file position is the end of the\n-   record, and is restored before returning.  Returns nonzero on\n-   overflow.  */\n-\n-static void\n-gcov_write_length (unsigned long position)\n-{\n-  if (position)\n-    {\n-      unsigned length = gcov_var.position - position - 8;\n-      unsigned char *buffer = &gcov_var.buffer[position + 4];\n-      unsigned ix;\n-      \n-      for (ix = 4; ix--; )\n-\t{\n-\t  buffer[ix] = length;\n-\t  length >>= 8;\n-\t}\n-    }\n-}\n-\n-#if IN_LIBGCOV\n-/* Write a summary structure to the gcov file.  Return non-zero on\n-   overflow.  */\n-\n-static void\n-gcov_write_summary (unsigned tag, const struct gcov_summary *summary)\n-{\n-  unsigned long base;\n-\n-  base = gcov_write_tag (tag);\n-  gcov_write_unsigned (summary->checksum);\n-  gcov_write_unsigned (summary->runs);\n-  gcov_write_unsigned (summary->arcs);\n-  gcov_write_counter (summary->arc_sum);\n-  gcov_write_counter (summary->arc_max_one);\n-  gcov_write_counter (summary->arc_sum_max);\n-  gcov_write_length (base);\n-}\n-#endif /* IN_LIBGCOV */\n-\n-#endif /*!IN_GCOV */\n-\n-/* Return a pointer to read BYTES bytes from the gcov file. Returns\n-   NULL on failure (read past EOF). */\n-\n-static const unsigned char *\n-gcov_read_bytes (unsigned bytes)\n-{\n-  const unsigned char *result;\n-  \n-  if (gcov_var.position + bytes > gcov_var.length)\n-    {\n-      gcov_var.error = 1;\n-      return 0;\n-    }\n-  \n-  result = &gcov_var.buffer[gcov_var.position];\n-  gcov_var.position += bytes;\n-  return result;\n-}\n-\n-/* Read unsigned value from a coverage file. Sets error flag on file\n-   error, overflow flag on overflow */\n-\n-static unsigned\n-gcov_read_unsigned ()\n-{\n-  unsigned value = 0;\n-  unsigned ix;\n-  const unsigned char *buffer = gcov_read_bytes (4);\n-\n-  if (!buffer)\n-    return 0;\n-  for (ix = sizeof (value); ix < 4; ix++)\n-    if (buffer[ix])\n-      gcov_var.error = -1;\n-  for (ix = 0; ix != 4; ix++)\n-    {\n-      value <<= 8;\n-      value |= buffer[ix];\n-    }\n-  return value;\n-}\n-\n-/* Read counter value from a coverage file. Sets error flag on file\n-   error, overflow flag on overflow */\n-\n-static gcov_type\n-gcov_read_counter ()\n-{\n-  gcov_type value = 0;\n-  unsigned ix;\n-  const unsigned char *buffer = gcov_read_bytes (8);\n-\n-  if (!buffer)\n-    return 0;\n-  for (ix = sizeof (value); ix < 8; ix++)\n-    if (buffer[ix])\n-      gcov_var.error = -1;\n-  for (ix = 0; ix != 8; ix++)\n-    {\n-      value <<= 8;\n-      value |= buffer[ix];\n-    }\n-  if (value < 0)\n-    gcov_var.error = -1;\n-  return value;\n-}\n-\n-/* Read string from coverage file. Returns a pointer to a static\n-   buffer, or NULL on empty string. You must copy the string before\n-   calling another gcov function.  */\n-\n-static const char *\n-gcov_read_string ()\n-{\n-  unsigned length = gcov_read_unsigned ();\n-  \n-  if (!length)\n-    return 0;\n-\n-  length += 4 - (length & 3);\n-  return (const char *) gcov_read_bytes (length);\n-}\n-\n-#define GCOV_SUMMARY_LENGTH 44\n-static void\n-gcov_read_summary (struct gcov_summary *summary)\n-{\n-  summary->checksum = gcov_read_unsigned ();\n-  summary->runs = gcov_read_unsigned ();\n-  summary->arcs = gcov_read_unsigned ();\n-  summary->arc_sum = gcov_read_counter ();\n-  summary->arc_max_one = gcov_read_counter ();\n-  summary->arc_sum_max = gcov_read_counter ();\n-}\n \n /* Save the current position in the gcov file.  */\n \n@@ -770,18 +385,4 @@ gcov_is_error ()\n   return gcov_var.file ? gcov_var.error : 1;\n }\n \n-#if IN_GCOV > 0\n-/* Return the modification time of the current gcov file.  */\n-\n-static time_t\n-gcov_time ()\n-{\n-  struct stat status;\n-  \n-  if (fstat (fileno (gcov_var.file), &status))\n-    return 0;\n-  else\n-    return status.st_mtime;\n-}\n-#endif /* IN_GCOV */\n #endif /* GCC_GCOV_IO_H */"}, {"sha": "237da2d39e37fd29b4c6411d4c716a12a15e176a", "filename": "gcc/libgcov.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -59,6 +59,7 @@ void __gcov_flush (void) { }\n #endif\n #define IN_LIBGCOV 1\n #include \"gcov-io.h\"\n+#include \"gcov-io.c\"\n \n /* Chain of per-object gcov structures.  */\n static struct gcov_info *gcov_list;\n@@ -136,7 +137,7 @@ gcov_exit (void)\n       int error;\n       int merging;\n       unsigned long base;\n-      const struct function_info *fn_info;\n+      const struct gcov_function_info *fn_info;\n       gcov_type **counters;\n       gcov_type *count_ptr;\n       gcov_type object_max_one = 0;"}, {"sha": "6cae157e66dec9abce45d21774c3d6dc3a90c064", "filename": "gcc/loop-init.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -27,7 +27,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n-#include \"profile.h\"\n \n /* Initialize loop optimizer.  */\n "}, {"sha": "3472bd05d9c550db15e4ba8fb06e723db4aebf65", "filename": "gcc/profile.c", "status": "modified", "additions": 90, "deletions": 1086, "changes": 1176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -1,6 +1,6 @@\n /* Calculate branch probabilities, and basic block execution counts.\n    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,\n-   2000, 2001  Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003  Free Software Foundation, Inc.\n    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n    based on some ideas from Dain Samples of UC Berkeley.\n    Further mangling by Bob Manson, Cygnus Support.\n@@ -53,23 +53,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n-#include \"tree.h\"\n #include \"flags.h\"\n-#include \"insn-config.h\"\n #include \"output.h\"\n #include \"regs.h\"\n #include \"expr.h\"\n #include \"function.h\"\n #include \"toplev.h\"\n-#include \"ggc.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-#include \"gcov-io.h\"\n-#include \"target.h\"\n-#include \"profile.h\"\n-#include \"libfuncs.h\"\n-#include \"langhooks.h\"\n-#include \"hashtab.h\"\n+#include \"coverage.h\"\n \n /* Additional information about the edges we need.  */\n struct edge_info {\n@@ -91,17 +81,6 @@ struct bb_info {\n   gcov_type pred_count;\n };\n \n-struct function_list\n-{\n-  struct function_list *next; \t/* next function */\n-  const char *name; \t\t/* function name */\n-  unsigned cfg_checksum;\t/* function checksum */\n-  unsigned n_counter_sections;\t/* number of counter sections */\n-  struct counter_section counter_sections[MAX_COUNTER_SECTIONS];\n-  \t\t\t\t/* the sections */\n-};\n-\n-\n /* Counts information for a function.  */\n typedef struct counts_entry\n {\n@@ -122,9 +101,6 @@ typedef struct counts_entry\n   \n } counts_entry_t;\n \n-static struct function_list *functions_head = 0;\n-static struct function_list **functions_tail = &functions_head;\n-\n #define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n #define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n \n@@ -134,21 +110,6 @@ static struct function_list **functions_tail = &functions_head;\n \t\t\t       : ((bb) == EXIT_BLOCK_PTR\t\t\\\n \t\t\t\t  ? last_basic_block + 1 : (bb)->index + 1))\n \n-/* Instantiate the profile info structure.  */\n-\n-struct profile_info profile_info;\n-\n-/* Name and file pointer of the output file for the basic block graph.  */\n-\n-static char *bbg_file_name;\n-\n-/* Name and file pointer of the input file for the arc count data.  */\n-\n-static char *da_file_name;\n-\n-/* The name of the count table. Used by the edge profiling code.  */\n-static GTY(()) rtx profiler_label;\n-\n /* Collect statistics on the performance of this pass for the entire source\n    file.  */\n \n@@ -168,24 +129,9 @@ static void find_spanning_tree PARAMS ((struct edge_list *));\n static rtx gen_edge_profiler PARAMS ((int));\n static void instrument_edges PARAMS ((struct edge_list *));\n static void compute_branch_probabilities PARAMS ((void));\n-static hashval_t htab_counts_entry_hash PARAMS ((const void *));\n-static int htab_counts_entry_eq PARAMS ((const void *, const void *));\n-static void htab_counts_entry_del PARAMS ((void *));\n-static void read_counts_file PARAMS ((const char *));\n static gcov_type * get_exec_counts PARAMS ((void));\n-static unsigned compute_checksum PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n static void union_groups PARAMS ((basic_block, basic_block));\n-static void set_purpose PARAMS ((tree, tree));\n-static rtx label_for_tag PARAMS ((unsigned));\n-static tree build_counter_section_fields PARAMS ((void));\n-static tree build_counter_section_value PARAMS ((unsigned, unsigned));\n-static tree build_counter_section_data_fields PARAMS ((void));\n-static tree build_counter_section_data_value PARAMS ((unsigned, unsigned));\n-static tree build_function_info_fields PARAMS ((void));\n-static tree build_function_info_value PARAMS ((struct function_list *));\n-static tree build_gcov_info_fields PARAMS ((tree));\n-static tree build_gcov_info_value PARAMS ((void));\n \n \f\n /* Add edge instrumentation code to the entire insn chain.\n@@ -200,7 +146,6 @@ instrument_edges (el)\n   int num_instr_edges = 0;\n   int num_edges = NUM_EDGES (el);\n   basic_block bb;\n-  struct section_info *section_info;\n   remove_fake_edges ();\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n@@ -218,196 +163,18 @@ instrument_edges (el)\n \t\t\t e->src->index, e->dest->index,\n \t\t\t EDGE_CRITICAL_P (e) ? \" (and split)\" : \"\");\n \t      insert_insn_on_edge (\n-\t\t\t gen_edge_profiler (total_num_edges_instrumented\n-\t\t\t\t\t    + num_instr_edges++), e);\n+\t\t\t gen_edge_profiler (num_instr_edges++), e);\n \t      rebuild_jump_labels (e->insns);\n \t    }\n \t  e = e->succ_next;\n \t}\n     }\n \n-  section_info = find_counters_section (GCOV_TAG_ARC_COUNTS);\n-  section_info->n_counters_now = num_instr_edges;\n-  total_num_edges_instrumented += num_instr_edges;\n-  section_info->n_counters = total_num_edges_instrumented;\n-\n   total_num_blocks_created += num_edges;\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n }\n \f\n-static hashval_t\n-htab_counts_entry_hash (of)\n-     const void *of;\n-{\n-  const counts_entry_t *entry = of;\n-\n-  return htab_hash_string (entry->function_name) ^ entry->section;\n-}\n-\n-static int\n-htab_counts_entry_eq (of1, of2)\n-     const void *of1;\n-     const void *of2;\n-{\n-  const counts_entry_t *entry1 = of1;\n-  const counts_entry_t *entry2 = of2;\n-\n-  return !strcmp (entry1->function_name, entry2->function_name)\n-    && entry1->section == entry2->section;\n-}\n-\n-static void\n-htab_counts_entry_del (of)\n-     void *of;\n-{\n-  counts_entry_t *entry = of;\n-\n-  free (entry->function_name);\n-  free (entry->counts);\n-  free (entry);\n-}\n-\n-static htab_t counts_hash = NULL;\n-\n-static void\n-read_counts_file (const char *name)\n-{\n-  char *function_name_buffer = NULL;\n-  unsigned version, ix, checksum = -1;\n-  counts_entry_t *summaried = NULL;\n-  unsigned seen_summary = 0;\n-  \n-  if (!gcov_open (name, 1))\n-    {\n-      warning (\"file %s not found, execution counts assumed to be zero\", name);\n-      return;\n-    }\n-  \n-  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n-    {\n-      warning (\"`%s' is not a gcov data file\", name);\n-      gcov_close ();\n-      return;\n-    }\n-  else if ((version = gcov_read_unsigned ()) != GCOV_VERSION)\n-    {\n-      char v[4], e[4];\n-      unsigned required = GCOV_VERSION;\n-      \n-      for (ix = 4; ix--; required >>= 8, version >>= 8)\n-\t{\n-\t  v[ix] = version;\n-\t  e[ix] = required;\n-\t}\n-      warning (\"`%s' is version `%.4s', expected version `%.4s'\", name, v, e);\n-      gcov_close ();\n-      return;\n-    }\n-  \n-  counts_hash = htab_create (10,\n-\t\t\t     htab_counts_entry_hash, htab_counts_entry_eq,\n-\t\t\t     htab_counts_entry_del);\n-  while (!gcov_is_eof ())\n-    {\n-      unsigned tag, length;\n-      unsigned long offset;\n-      int error;\n-      \n-      tag = gcov_read_unsigned ();\n-      length = gcov_read_unsigned ();\n-      offset = gcov_position ();\n-      if (tag == GCOV_TAG_FUNCTION)\n-\t{\n-\t  const char *string = gcov_read_string ();\n-\t  free (function_name_buffer);\n-\t  function_name_buffer = string ? xstrdup (string) : NULL;\n-\t  checksum = gcov_read_unsigned ();\n-\t  if (seen_summary)\n-\t    {\n-\t      /* We have already seen a summary, this means that this\n-\t\t new function begins a new set of program runs. We\n-\t\t must unlink the summaried chain.  */\n-\t      counts_entry_t *entry, *chain;\n-\t      \n-\t      for (entry = summaried; entry; entry = chain)\n-\t\t{\n-\t\t  chain = entry->chain;\n-\t\t  \n-\t\t  entry->max_counter_sum += entry->max_counter;\n-\t\t  entry->chain = NULL;\n-\t\t}\n-\t      summaried = NULL;\n-\t      seen_summary = 0;\n-\t    }\n-\t}\n-      else if (tag == GCOV_TAG_PROGRAM_SUMMARY)\n-\t{\n-\t  counts_entry_t *entry;\n-\t  struct gcov_summary summary;\n-\t  \n-\t  gcov_read_summary (&summary);\n-\t  seen_summary = 1;\n-\t  for (entry = summaried; entry; entry = entry->chain)\n-\t    {\n-\t      entry->merged += summary.runs;\n-\t      if (entry->max_counter < summary.arc_sum_max)\n-\t\tentry->max_counter = summary.arc_sum_max;\n-\t    }\n-\t}\n-      else if (GCOV_TAG_IS_SUBTAG (GCOV_TAG_FUNCTION, tag)\n-\t       && function_name_buffer)\n-\t{\n-\t  counts_entry_t **slot, *entry, elt;\n-\t  unsigned n_counts = length / 8;\n-\t  unsigned ix;\n-\n-\t  elt.function_name = function_name_buffer;\n-\t  elt.section = tag;\n-\n-\t  slot = (counts_entry_t **) htab_find_slot\n-\t    (counts_hash, &elt, INSERT);\n-\t  entry = *slot;\n-\t  if (!entry)\n-\t    {\n-\t      *slot = entry = xmalloc (sizeof (counts_entry_t));\n-\t      entry->function_name = xstrdup (function_name_buffer);\n-\t      entry->section = tag;\n-\t      entry->checksum = checksum;\n-\t      entry->n_counts = n_counts;\n-\t      entry->counts = xcalloc (n_counts, sizeof (gcov_type));\n-\t    }\n-\t  else if (entry->checksum != checksum || entry->n_counts != n_counts)\n-\t    {\n-\t      warning (\"profile mismatch for `%s'\", function_name_buffer);\n-\t      htab_delete (counts_hash);\n-\t      break;\n-\t    }\n-\t  \n-\t  /* This should always be true for a just allocated entry,\n-\t     and always false for an existing one. Check this way, in\n-\t     case the gcov file is corrupt.  */\n-\t  if (!entry->chain || summaried != entry)\n-\t    {\n-\t      entry->chain = summaried;\n-\t      summaried = entry;\n-\t    }\n-\t  for (ix = 0; ix != n_counts; ix++)\n-\t    entry->counts[ix] += gcov_read_counter ();\n-\t}\n-      gcov_seek (offset, length);\n-      if ((error = gcov_is_error ()))\n-\t{\n-\t  warning (error < 0 ? \"`%s' has overflowed\" : \"`%s' is corrupted\",\n-\t\t   name);\n-\t  htab_delete (counts_hash);\n-\t  break;\n-\t}\n-    }\n-\n-  free (function_name_buffer);\n-  gcov_close ();\n-}\n \n /* Computes hybrid profile for all matching entries in da_file.\n    Sets max_counter_in_program as a side effect.  */\n@@ -417,16 +184,8 @@ get_exec_counts ()\n {\n   unsigned num_edges = 0;\n   basic_block bb;\n-  const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n-  counts_entry_t *entry, elt;\n-\n-  profile_info.max_counter_in_program = 0;\n-  profile_info.count_profiles_merged = 0;\n-\n-  /* No hash table, no counts. */\n-  if (!counts_hash)\n-    return NULL;\n-\n+  gcov_type *counts;\n+  \n   /* Count the edges to be (possibly) instrumented.  */\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n@@ -436,24 +195,9 @@ get_exec_counts ()\n \t  num_edges++;\n     }\n \n-  elt.function_name = (char *) name;\n-  elt.section = GCOV_TAG_ARC_COUNTS;\n-  entry = htab_find (counts_hash, &elt);\n-  if (!entry)\n-    {\n-      warning (\"No profile for function '%s' found.\", name);\n-      return NULL;\n-    }\n-  \n-  if (entry->checksum != profile_info.current_function_cfg_checksum\n-      || num_edges != entry->n_counts)\n-    {\n-      warning (\"profile mismatch for `%s'\", current_function_name);\n-      return NULL;\n-    }\n-\n-  profile_info.count_profiles_merged = entry->merged;\n-  profile_info.max_counter_in_program = entry->max_counter_sum;\n+  counts = get_coverage_counts (GCOV_TAG_ARC_COUNTS, num_edges);\n+  if (!counts)\n+    return NULL;\n \n   if (rtl_dump_file)\n     {\n@@ -462,7 +206,7 @@ get_exec_counts ()\n \t      (int)profile_info.max_counter_in_program);\n     }\n \n-  return entry->counts;\n+  return counts;\n }\n \f\n \n@@ -806,45 +550,6 @@ compute_branch_probabilities ()\n   find_counters_section (GCOV_TAG_ARC_COUNTS)->present = 1;\n }\n \n-/* Compute checksum for the current function.  We generate a CRC32.  */\n-\n-static unsigned\n-compute_checksum ()\n-{\n-  unsigned chksum = 0;\n-  basic_block bb;\n-  \n-  FOR_EACH_BB (bb)\n-    {\n-      edge e = NULL;\n-      \n-      do\n-\t{\n-\t  unsigned value = BB_TO_GCOV_INDEX (e ? e->dest : bb);\n-\t  unsigned ix;\n-\n-\t  /* No need to use all bits in value identically, nearly all\n-\t     functions have less than 256 blocks.  */\n-\t  value ^= value << 16;\n-\t  value ^= value << 8;\n-\t  \n-\t  for (ix = 8; ix--; value <<= 1)\n-\t    {\n-\t      unsigned feedback;\n-\n-\t      feedback = (value ^ chksum) & 0x80000000 ? 0x04c11db7 : 0;\n-\t      chksum <<= 1;\n-\t      chksum ^= feedback;\n-\t    }\n-\t  \n-\t  e = e ? e->succ_next : bb->succ;\n-\t}\n-      while (e);\n-    }\n-\n-  return chksum;\n-}\n-\n /* Instrument and/or analyze program behavior based on program flow graph.\n    In either case, this function builds a flow graph for the function being\n    compiled.  The flow graph is stored in BB_GRAPH.\n@@ -868,19 +573,6 @@ branch_prob ()\n   unsigned i;\n   unsigned num_edges, ignored_edges;\n   struct edge_list *el;\n-  const char *name = IDENTIFIER_POINTER\n-    (DECL_ASSEMBLER_NAME (current_function_decl));\n-\n-  profile_info.current_function_cfg_checksum = compute_checksum ();\n-  for (i = 0; i < profile_info.n_sections; i++)\n-    {\n-      profile_info.section_info[i].n_counters_now = 0;\n-      profile_info.section_info[i].present = 0;\n-    }\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"CFG checksum is %u\\n\",\n-\tprofile_info.current_function_cfg_checksum);\n \n   total_num_times_called++;\n \n@@ -998,25 +690,15 @@ branch_prob ()\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"%d ignored edges\\n\", ignored_edges);\n \n-  /* Create a .bbg file from which gcov can reconstruct the basic block\n+  /* Write the .bbg data from which gcov can reconstruct the basic block\n      graph.  First output the number of basic blocks, and then for every\n      edge output the source and target basic block numbers.\n      NOTE: The format of this file must be compatible with gcov.  */\n \n-  if (!gcov_is_error ())\n+  if (coverage_begin_output ())\n     {\n       long offset;\n-      const char *file = DECL_SOURCE_FILE (current_function_decl);\n-      unsigned line = DECL_SOURCE_LINE (current_function_decl);\n       \n-      /* Announce function */\n-      offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n-      gcov_write_string (name);\n-      gcov_write_unsigned (profile_info.current_function_cfg_checksum);\n-      gcov_write_string (file);\n-      gcov_write_unsigned (line);\n-      gcov_write_length (offset);\n-\n       /* Basic block flags */\n       offset = gcov_write_tag (GCOV_TAG_BLOCKS);\n       for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n@@ -1052,77 +734,77 @@ branch_prob ()\n \n \t  gcov_write_length (offset);\n \t}\n-\n-      /* Output line number information about each basic block for\n-     \t GCOV utility.  */\n-      {\n-\tchar const *prev_file_name = NULL;\n-\t\n-\tFOR_EACH_BB (bb)\n-\t  {\n-\t    rtx insn = bb->head;\n-\t    int ignore_next_note = 0;\n-\t    \n-\t    offset = 0;\n-\t    \n-\t    /* We are looking for line number notes.  Search backward\n-\t       before basic block to find correct ones.  */\n-\t    insn = prev_nonnote_insn (insn);\n-\t    if (!insn)\n-\t      insn = get_insns ();\n-\t    else\n+    }\n+  \n+  /* Output line number information about each basic block for GCOV\n+     utility.  */\n+  if (coverage_begin_output ())\n+    {\n+      char const *prev_file_name = NULL;\n+      long offset;\n+      \n+      FOR_EACH_BB (bb)\n+\t{\n+\t  rtx insn = bb->head;\n+\t  int ignore_next_note = 0;\n+\t  \n+\t  offset = 0;\n+\t  \n+\t  /* We are looking for line number notes.  Search backward\n+\t     before basic block to find correct ones.  */\n+\t  insn = prev_nonnote_insn (insn);\n+\t  if (!insn)\n+\t    insn = get_insns ();\n+\t  else\n+\t    insn = NEXT_INSN (insn);\n+\t  \n+\t  while (insn != bb->end)\n+\t    {\n+\t      if (GET_CODE (insn) == NOTE)\n+\t\t{\n+\t\t  /* Must ignore the line number notes that\n+\t\t     immediately follow the end of an inline function\n+\t\t     to avoid counting it twice.  There is a note\n+\t\t     before the call, and one after the call.  */\n+\t\t  if (NOTE_LINE_NUMBER (insn)\n+\t\t      == NOTE_INSN_REPEATED_LINE_NUMBER)\n+\t\t    ignore_next_note = 1;\n+\t\t  else if (NOTE_LINE_NUMBER (insn) <= 0)\n+\t\t    /*NOP*/;\n+\t\t  else if (ignore_next_note)\n+\t\t    ignore_next_note = 0;\n+\t\t  else\n+\t\t    {\n+\t\t      if (!offset)\n+\t\t\t{\n+\t\t\t  offset = gcov_write_tag (GCOV_TAG_LINES);\n+\t\t\t  gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n+\t\t\t}\n+\t\t      \n+\t\t      /* If this is a new source file, then output the\n+\t\t\t file's name to the .bb file.  */\n+\t\t      if (!prev_file_name\n+\t\t\t  || strcmp (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t     prev_file_name))\n+\t\t\t{\n+\t\t\t  prev_file_name = NOTE_SOURCE_FILE (insn);\n+\t\t\t  gcov_write_unsigned (0);\n+\t\t\t  gcov_write_string (prev_file_name);\n+\t\t\t}\n+\t\t      gcov_write_unsigned (NOTE_LINE_NUMBER (insn));\n+\t\t    }\n+\t\t}\n \t      insn = NEXT_INSN (insn);\n-\n-\t    while (insn != bb->end)\n-\t      {\n-\t\tif (GET_CODE (insn) == NOTE)\n-\t\t  {\n-\t\t     /* Must ignore the line number notes that immediately\n-\t\t     \tfollow the end of an inline function to avoid counting\n-\t\t     \tit twice.  There is a note before the call, and one\n-\t\t     \tafter the call.  */\n-\t\t    if (NOTE_LINE_NUMBER (insn)\n-\t\t\t== NOTE_INSN_REPEATED_LINE_NUMBER)\n-\t\t      ignore_next_note = 1;\n-\t\t    else if (NOTE_LINE_NUMBER (insn) <= 0)\n-\t\t      /*NOP*/;\n-\t\t    else if (ignore_next_note)\n-\t\t      ignore_next_note = 0;\n-\t\t    else\n-\t\t      {\n-\t\t\tif (!offset)\n-\t\t\t  {\n-\t\t\t    offset = gcov_write_tag (GCOV_TAG_LINES);\n-\t\t\t    gcov_write_unsigned (BB_TO_GCOV_INDEX (bb));\n-\t\t\t  }\n-\n-\t\t\t/* If this is a new source file, then output\n-\t\t\t   the file's name to the .bb file.  */\n-\t\t\tif (!prev_file_name\n-\t\t\t    || strcmp (NOTE_SOURCE_FILE (insn),\n-\t\t\t\t       prev_file_name))\n-\t\t\t  {\n-\t\t\t    prev_file_name = NOTE_SOURCE_FILE (insn);\n-\t\t\t    gcov_write_unsigned (0);\n-\t\t\t    gcov_write_string (prev_file_name);\n-\t\t\t  }\n-\t\t\tgcov_write_unsigned (NOTE_LINE_NUMBER (insn));\n-\t\t      }\n-\t\t  }\n-\t\tinsn = NEXT_INSN (insn);\n-\t      }\n-\n-\t    if (offset)\n-\t      {\n-\t\t/* A file of NULL indicates the end of run.  */\n-\t\tgcov_write_unsigned (0);\n-\t\tgcov_write_string (NULL);\n-\t\tgcov_write_length (offset);\n-\t      }\n-\t    if (gcov_is_error ())\n-\t      warning (\"error writing `%s'\", bbg_file_name);\n-\t  }\n-      }\n+\t    }\n+\t  \n+\t  if (offset)\n+\t    {\n+\t      /* A file of NULL indicates the end of run.  */\n+\t      gcov_write_unsigned (0);\n+\t      gcov_write_string (NULL);\n+\t      gcov_write_length (offset);\n+\t    }\n+\t}\n     }\n \n   if (flag_branch_probabilities)\n@@ -1132,33 +814,11 @@ branch_prob ()\n \n   if (cfun->arc_profile && profile_arc_flag)\n     {\n-      struct function_list *item;\n-      \n       instrument_edges (el);\n \n       /* Commit changes done by instrumentation.  */\n       commit_edge_insertions_watch_calls ();\n       allocate_reg_info (max_reg_num (), FALSE, FALSE);\n-\n-      /* ??? Probably should re-use the existing struct function.  */\n-      item = xmalloc (sizeof (struct function_list));\n-      \n-      *functions_tail = item;\n-      functions_tail = &item->next;\n-      \n-      item->next = 0;\n-      item->name = xstrdup (name);\n-      item->cfg_checksum = profile_info.current_function_cfg_checksum;\n-      item->n_counter_sections = 0;\n-      for (i = 0; i < profile_info.n_sections; i++)\n-\tif (profile_info.section_info[i].n_counters_now)\n-\t  {\n-\t    item->counter_sections[item->n_counter_sections].tag = \n-\t\t    profile_info.section_info[i].tag;\n-\t    item->counter_sections[item->n_counter_sections].n_counters =\n-\t\t    profile_info.section_info[i].n_counters_now;\n-\t    item->n_counter_sections++;\n-\t  }\n     }\n \n   remove_fake_edges ();\n@@ -1289,40 +949,10 @@ find_spanning_tree (el)\n /* Perform file-level initialization for branch-prob processing.  */\n \n void\n-init_branch_prob (filename)\n-  const char *filename;\n+init_branch_prob ()\n {\n-  int len = strlen (filename);\n   int i;\n \n-  da_file_name = (char *) xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n-  strcpy (da_file_name, filename);\n-  strcat (da_file_name, GCOV_DATA_SUFFIX);\n-  \n-  if (flag_branch_probabilities)\n-    read_counts_file (da_file_name);\n-\n-  if (flag_test_coverage)\n-    {\n-      /* Open the bbg output file.  */\n-      bbg_file_name = (char *) xmalloc (len + strlen (GCOV_GRAPH_SUFFIX) + 1);\n-      strcpy (bbg_file_name, filename);\n-      strcat (bbg_file_name, GCOV_GRAPH_SUFFIX);\n-      if (!gcov_open (bbg_file_name, -1))\n-\terror (\"cannot open %s\", bbg_file_name);\n-      gcov_write_unsigned (GCOV_GRAPH_MAGIC);\n-      gcov_write_unsigned (GCOV_VERSION);\n-    }\n-\n-  if (profile_arc_flag)\n-    {\n-      /* Generate and save a copy of this so it can be shared.  */\n-      char buf[20];\n-      \n-      ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 2);\n-      profiler_label = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n-    }\n-  \n   total_num_blocks = 0;\n   total_num_edges = 0;\n   total_num_edges_ignored = 0;\n@@ -1342,22 +972,6 @@ init_branch_prob (filename)\n void\n end_branch_prob ()\n {\n-  if (flag_test_coverage)\n-    {\n-      int error = gcov_close ();\n-      \n-      if (error)\n-\tunlink (bbg_file_name);\n-#if SELF_COVERAGE\n-      /* If the compiler is instrumented, we should not\n-         unconditionally remove the counts file, because we might be\n-         recompiling ourselves. The .da files are all removed during\n-         copying the stage1 files.  */\n-      if (error)\n-#endif\n-\tunlink (da_file_name);\n-    }\n-\n   if (rtl_dump_file)\n     {\n       fprintf (rtl_dump_file, \"\\n\");\n@@ -1392,638 +1006,28 @@ end_branch_prob ()\n     }\n }\n \n-/* Find (and create if not present) a section with TAG.  */\n-struct section_info *\n-find_counters_section (tag)\n-     unsigned tag;\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < profile_info.n_sections; i++)\n-    if (profile_info.section_info[i].tag == tag)\n-      return profile_info.section_info + i;\n-\n-  if (i == MAX_COUNTER_SECTIONS)\n-    abort ();\n-\n-  profile_info.section_info[i].tag = tag;\n-  profile_info.section_info[i].present = 0;\n-  profile_info.section_info[i].n_counters = 0;\n-  profile_info.section_info[i].n_counters_now = 0;\n-  profile_info.n_sections++;\n-\n-  return profile_info.section_info + i;\n-}\n-\n-/* Set FIELDS as purpose to VALUE.  */\n-static void\n-set_purpose (value, fields)\n-     tree value;\n-     tree fields;\n-{\n-  tree act_field, act_value;\n-  \n-  for (act_field = fields, act_value = value;\n-       act_field;\n-       act_field = TREE_CHAIN (act_field), act_value = TREE_CHAIN (act_value))\n-    TREE_PURPOSE (act_value) = act_field;\n-}\n-\n-/* Returns label for base of counters inside TAG section.  */\n-static rtx\n-label_for_tag (tag)\n-     unsigned tag;\n-{\n-  switch (tag)\n-    {\n-    case GCOV_TAG_ARC_COUNTS:\n-      return profiler_label;\n-    default:\n-      abort ();\n-    }\n-}\n-\n-/* Creates fields of struct counter_section (in gcov-io.h).  */\n-static tree\n-build_counter_section_fields ()\n-{\n-  tree field, fields;\n-\n-  /* tag */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-\n-  /* n_counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  return fields;\n-}\n-\n-/* Creates value of struct counter_section (in gcov-io.h).  */\n-static tree\n-build_counter_section_value (tag, n_counters)\n-     unsigned tag;\n-     unsigned n_counters;\n-{\n-  tree value = NULL_TREE;\n-\n-  /* tag */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (tag, 0)),\n-\t\t     value);\n-  \n-  /* n_counters */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (n_counters, 0)),\n-\t\t     value);\n-\n-  return value;\n-}\n-\n-/* Creates fields of struct counter_section_data (in gcov-io.h).  */\n-static tree\n-build_counter_section_data_fields ()\n-{\n-  tree field, fields, gcov_type, gcov_ptr_type;\n-\n-  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n-  gcov_ptr_type =\n-\t  build_pointer_type (build_qualified_type (gcov_type,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-\n-  /* tag */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-\n-  /* n_counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  /* counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  return fields;\n-}\n-\n-/* Creates value of struct counter_section_data (in gcov-io.h).  */\n-static tree\n-build_counter_section_data_value (tag, n_counters)\n-     unsigned tag;\n-     unsigned n_counters;\n-{\n-  tree value = NULL_TREE, counts_table, gcov_type, gcov_ptr_type;\n-\n-  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n-  gcov_ptr_type\n-    = build_pointer_type (build_qualified_type\n-\t\t\t  (gcov_type, TYPE_QUAL_CONST));\n-\n-  /* tag */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (tag, 0)),\n-\t\t     value);\n-  \n-  /* n_counters */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (n_counters, 0)),\n-\t\t     value);\n-\n-  /* counters */\n-  if (n_counters)\n-    {\n-      tree gcov_type_array_type =\n-\t      build_array_type (gcov_type,\n-\t\t\t\tbuild_index_type (build_int_2 (n_counters - 1,\n-\t\t\t\t\t\t\t       0)));\n-      counts_table =\n-\t      build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n-      TREE_STATIC (counts_table) = 1;\n-      DECL_NAME (counts_table) = get_identifier (XSTR (label_for_tag (tag), 0));\n-      assemble_variable (counts_table, 0, 0, 0);\n-      counts_table = build1 (ADDR_EXPR, gcov_ptr_type, counts_table);\n-    }\n-  else\n-    counts_table = null_pointer_node;\n-\n-  value = tree_cons (NULL_TREE, counts_table, value);\n-\n-  return value;\n-}\n-\n-/* Creates fields for struct function_info type (in gcov-io.h).  */\n-static tree\n-build_function_info_fields ()\n-{\n-  tree field, fields, counter_section_fields, counter_section_type;\n-  tree counter_sections_ptr_type;\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  /* name */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, string_type);\n-\n-  /* checksum */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  /* n_counter_sections */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  /* counter_sections */\n-  counter_section_fields = build_counter_section_fields ();\n-  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  finish_builtin_struct (counter_section_type, \"__counter_section\",\n-\t\t\t counter_section_fields, NULL_TREE);\n-  counter_sections_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, counter_sections_ptr_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  return fields;\n-}\n-\n-/* Creates value for struct function_info (in gcov-io.h).  */\n-static tree\n-build_function_info_value (function)\n-     struct function_list *function;\n-{\n-  tree value = NULL_TREE;\n-  size_t name_len = strlen (function->name);\n-  tree fname = build_string (name_len + 1, function->name);\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  tree counter_section_fields, counter_section_type, counter_sections_value;\n-  tree counter_sections_ptr_type, counter_sections_array_type;\n-  unsigned i;\n-\n-  /* name */\n-  TREE_TYPE (fname) =\n-\t  build_array_type (char_type_node,\n-\t\t\t    build_index_type (build_int_2 (name_len, 0)));\n-  value = tree_cons (NULL_TREE,\n-\t\t     build1 (ADDR_EXPR,\n-\t\t\t     string_type,\n-\t\t\t     fname),\n-\t\t     value);\n-\n-  /* checksum */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (function->cfg_checksum, 0)),\n-\t\t     value);\n-\n-  /* n_counter_sections */\n-\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (function->n_counter_sections, 0)),\n-\t    \t    value);\n-\n-  /* counter_sections */\n-  counter_section_fields = build_counter_section_fields ();\n-  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  counter_sections_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  counter_sections_array_type =\n-\t  build_array_type (counter_section_type,\n-\t\t\t    build_index_type (\n-      \t\t\t\tbuild_int_2 (function->n_counter_sections - 1,\n-\t\t  \t\t\t     0)));\n-\n-  counter_sections_value = NULL_TREE;\n-  for (i = 0; i < function->n_counter_sections; i++)\n-    {\n-      tree counter_section_value =\n-\t      build_counter_section_value (function->counter_sections[i].tag,\n-\t\t\t\t\t   function->counter_sections[i].n_counters);\n-      set_purpose (counter_section_value, counter_section_fields);\n-      counter_sections_value =\n-\ttree_cons (NULL_TREE,\n-\t\t   build_constructor (counter_section_type,\n-\t\t\t\t      nreverse (counter_section_value)),\n-\t\t   counter_sections_value);\n-    }\n-  finish_builtin_struct (counter_section_type, \"__counter_section\",\n-\t\t\t counter_section_fields, NULL_TREE);\n-\n-  if (function->n_counter_sections)\n-    {\n-      counter_sections_value = \n-\t      build_constructor (counter_sections_array_type,\n-\t\t\t\t nreverse (counter_sections_value)),\n-      counter_sections_value = build1 (ADDR_EXPR,\n-\t\t\t\t       counter_sections_ptr_type,\n-\t\t\t\t       counter_sections_value);\n-    }\n-  else\n-    counter_sections_value = null_pointer_node;\n-\n-  value = tree_cons (NULL_TREE, counter_sections_value, value);\n-\n-  return value;\n-}\n-\n-/* Creates fields of struct gcov_info type (in gcov-io.h).  */\n-static tree\n-build_gcov_info_fields (gcov_info_type)\n-     tree gcov_info_type;\n-{\n-  tree field, fields;\n-  char *filename;\n-  int filename_len;\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  tree function_info_fields, function_info_type, function_info_ptr_type;\n-  tree counter_section_data_fields, counter_section_data_type;\n-  tree counter_section_data_ptr_type;\n-\n-  /* Version ident */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, long_unsigned_type_node);\n-\n-  /* next -- NULL */\n-  field = build_decl (FIELD_DECL, NULL_TREE,\n-\t\t      build_pointer_type (build_qualified_type (gcov_info_type,\n-\t\t\t\t\t\t\t\tTYPE_QUAL_CONST)));\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-  \n-  /* Filename */\n-  filename = getpwd ();\n-  filename = (filename && da_file_name[0] != '/'\n-\t      ? concat (filename, \"/\", da_file_name, NULL)\n-\t      : da_file_name);\n-  filename_len = strlen (filename);\n-  if (filename != da_file_name)\n-    free (filename);\n-\n-  field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-  \n-  /* Workspace */\n-  field = build_decl (FIELD_DECL, NULL_TREE, long_integer_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  /* number of functions */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-      \n-  /* function_info table */\n-  function_info_fields = build_function_info_fields ();\n-  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  finish_builtin_struct (function_info_type, \"__function_info\",\n-\t\t\t function_info_fields, NULL_TREE);\n-  function_info_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (function_info_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, function_info_ptr_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-    \n-  /* n_counter_sections  */\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-  \n-  /* counter sections */\n-  counter_section_data_fields = build_counter_section_data_fields ();\n-  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n-\t\t\t counter_section_data_fields, NULL_TREE);\n-  counter_section_data_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_data_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, counter_section_data_ptr_type);\n-  TREE_CHAIN (field) = fields;\n-  fields = field;\n-\n-  return fields;\n-}\n-\n-/* Creates struct gcov_info value (in gcov-io.h).  */\n-static tree\n-build_gcov_info_value ()\n-{\n-  tree value = NULL_TREE;\n-  tree filename_string;\n-  char *filename;\n-  int filename_len;\n-  unsigned n_functions, i;\n-  struct function_list *item;\n-  tree string_type =\n-\t  build_pointer_type (build_qualified_type (char_type_node,\n-\t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  tree function_info_fields, function_info_type, function_info_ptr_type;\n-  tree functions;\n-  tree counter_section_data_fields, counter_section_data_type;\n-  tree counter_section_data_ptr_type, counter_sections;\n-\n-  /* Version ident */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (long_unsigned_type_node,\n-\t\t\t      build_int_2 (GCOV_VERSION, 0)),\n-\t\t     value);\n-\n-  /* next -- NULL */\n-  value = tree_cons (NULL_TREE, null_pointer_node, value);\n-  \n-  /* Filename */\n-  filename = getpwd ();\n-  filename = (filename && da_file_name[0] != '/'\n-\t      ? concat (filename, \"/\", da_file_name, NULL)\n-\t      : da_file_name);\n-  filename_len = strlen (filename);\n-  filename_string = build_string (filename_len + 1, filename);\n-  if (filename != da_file_name)\n-    free (filename);\n-  TREE_TYPE (filename_string) =\n-\t  build_array_type (char_type_node,\n-\t\t\t    build_index_type (build_int_2 (filename_len, 0)));\n-  value = tree_cons (NULL_TREE,\n-\t\t     build1 (ADDR_EXPR,\n-\t\t\t     string_type,\n-\t\t       \t     filename_string),\n-\t\t     value);\n-  \n-  /* Workspace */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (long_integer_type_node, integer_zero_node),\n-\t\t     value);\n-      \n-  /* number of functions */\n-  n_functions = 0;\n-  for (item = functions_head; item != 0; item = item->next, n_functions++)\n-    continue;\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (n_functions, 0)),\n-\t\t     value);\n-\n-  /* function_info table */\n-  function_info_fields = build_function_info_fields ();\n-  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  function_info_ptr_type =\n-\t  build_pointer_type (\n-\t\tbuild_qualified_type (function_info_type,\n-\t       \t\t\t      TYPE_QUAL_CONST));\n-  functions = NULL_TREE;\n-  for (item = functions_head; item != 0; item = item->next)\n-    {\n-      tree function_info_value = build_function_info_value (item);\n-      set_purpose (function_info_value, function_info_fields);\n-      functions = tree_cons (NULL_TREE,\n-    \t\t\t     build_constructor (function_info_type,\n-\t\t\t\t\t\tnreverse (function_info_value)),\n-\t\t\t     functions);\n-    }\n-  finish_builtin_struct (function_info_type, \"__function_info\",\n-\t\t\t function_info_fields, NULL_TREE);\n-\n-  /* Create constructor for array.  */\n-  if (n_functions)\n-    {\n-      tree array_type;\n-\n-      array_type = build_array_type (\n-\t\t\tfunction_info_type,\n-   \t\t\tbuild_index_type (build_int_2 (n_functions - 1, 0)));\n-      functions = build_constructor (array_type, nreverse (functions));\n-      functions = build1 (ADDR_EXPR,\n-\t\t\t  function_info_ptr_type,\n-\t\t\t  functions);\n-    }\n-  else\n-    functions = null_pointer_node;\n-\n-  value = tree_cons (NULL_TREE, functions, value);\n-\n-  /* n_counter_sections  */\n-  value = tree_cons (NULL_TREE,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (profile_info.n_sections, 0)),\n-\t\t     value);\n-  \n-  /* counter sections */\n-  counter_section_data_fields = build_counter_section_data_fields ();\n-  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  counter_sections = NULL_TREE;\n-  for (i = 0; i < profile_info.n_sections; i++)\n-    {\n-      tree counter_sections_value =\n-\t      build_counter_section_data_value (\n-\t\tprofile_info.section_info[i].tag,\n-\t\tprofile_info.section_info[i].n_counters);\n-      set_purpose (counter_sections_value, counter_section_data_fields);\n-      counter_sections =\n-\ttree_cons (NULL_TREE,\n-\t\t   build_constructor (counter_section_data_type,\n-\t\t\t\t      nreverse (counter_sections_value)),\n-\t\t   counter_sections);\n-    }\n-  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n-\t\t\t counter_section_data_fields, NULL_TREE);\n-  counter_section_data_ptr_type =\n-\t  build_pointer_type\n-\t  \t(build_qualified_type (counter_section_data_type,\n-\t\t\t\t       TYPE_QUAL_CONST));\n-\n-  if (profile_info.n_sections)\n-    {\n-      tree cst_type = build_index_type (build_int_2 (profile_info.n_sections-1,\n-\t\t\t\t\t\t     0));\n-      cst_type = build_array_type (counter_section_data_type, cst_type);\n-      counter_sections = build_constructor (cst_type,\n-\t\t\t\t\t    nreverse (counter_sections));\n-      counter_sections = build1 (ADDR_EXPR,\n-\t\t\t\t counter_section_data_ptr_type,\n-\t\t\t\t counter_sections);\n-    }\n-  else\n-    counter_sections = null_pointer_node;\n-  value = tree_cons (NULL_TREE, counter_sections, value);\n-\n-  return value;\n-}\n-\n-/* Write out the structure which libgcc uses to locate all the arc\n-   counters.  The structures used here must match those defined in\n-   gcov-io.h.  Write out the constructor to call __gcov_init.  */\n-\n-void\n-create_profiler ()\n-{\n-  tree gcov_info_fields, gcov_info_type, gcov_info_value, gcov_info;\n-  char name[20];\n-  char *ctor_name;\n-  tree ctor;\n-  rtx gcov_info_address;\n-  int save_flag_inline_functions = flag_inline_functions;\n-  unsigned i;\n-\n-  for (i = 0; i < profile_info.n_sections; i++)\n-    if (profile_info.section_info[i].n_counters_now)\n-      break;\n-  if (i == profile_info.n_sections)\n-    return;\n-  \n-  gcov_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  gcov_info_fields = build_gcov_info_fields (gcov_info_type);\n-  gcov_info_value = build_gcov_info_value ();\n-  set_purpose (gcov_info_value, gcov_info_fields);\n-  finish_builtin_struct (gcov_info_type, \"__gcov_info\",\n-\t\t\t gcov_info_fields, NULL_TREE);\n-\n-  gcov_info = build (VAR_DECL, gcov_info_type, NULL_TREE, NULL_TREE);\n-  DECL_INITIAL (gcov_info) =\n-    build_constructor (gcov_info_type, nreverse (gcov_info_value));\n-\n-  TREE_STATIC (gcov_info) = 1;\n-  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n-  DECL_NAME (gcov_info) = get_identifier (name);\n-  \n-  /* Build structure.  */\n-  assemble_variable (gcov_info, 0, 0, 0);\n-\n-  /* Build the constructor function to invoke __gcov_init.  */\n-  ctor_name = concat (IDENTIFIER_POINTER (get_file_function_name ('I')),\n-\t\t      \"_GCOV\", NULL);\n-  ctor = build_decl (FUNCTION_DECL, get_identifier (ctor_name),\n-\t\t     build_function_type (void_type_node, NULL_TREE));\n-  free (ctor_name);\n-  DECL_EXTERNAL (ctor) = 0;\n-\n-  /* It can be a static function as long as collect2 does not have\n-     to scan the object file to find its ctor/dtor routine.  */\n-  TREE_PUBLIC (ctor) = ! targetm.have_ctors_dtors;\n-  TREE_USED (ctor) = 1;\n-  DECL_RESULT (ctor) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n-\n-  ctor = (*lang_hooks.decls.pushdecl) (ctor);\n-  rest_of_decl_compilation (ctor, 0, 1, 0);\n-  announce_function (ctor);\n-  current_function_decl = ctor;\n-  DECL_INITIAL (ctor) = error_mark_node;\n-  make_decl_rtl (ctor, NULL);\n-  init_function_start (ctor, input_filename, lineno);\n-  (*lang_hooks.decls.pushlevel) (0);\n-  expand_function_start (ctor, 0);\n-  cfun->arc_profile = 0;\n-\n-  /* Actually generate the code to call __gcov_init.  */\n-  gcov_info_address = force_reg (Pmode, XEXP (DECL_RTL (gcov_info), 0));\n-  emit_library_call (gcov_init_libfunc, LCT_NORMAL, VOIDmode, 1,\n-\t\t     gcov_info_address, Pmode);\n-\n-  expand_function_end (input_filename, lineno, 0);\n-  (*lang_hooks.decls.poplevel) (1, 0, 1);\n-\n-  /* Since ctor isn't in the list of globals, it would never be emitted\n-     when it's considered to be 'safe' for inlining, so turn off\n-     flag_inline_functions.  */\n-  flag_inline_functions = 0;\n-\n-  rest_of_compilation (ctor);\n-\n-  /* Reset flag_inline_functions to its original value.  */\n-  flag_inline_functions = save_flag_inline_functions;\n-\n-  if (! quiet_flag)\n-    fflush (asm_out_file);\n-  current_function_decl = NULL_TREE;\n-\n-  if (targetm.have_ctors_dtors)\n-    (* targetm.asm_out.constructor) (XEXP (DECL_RTL (ctor), 0),\n-\t\t\t\t     DEFAULT_INIT_PRIORITY);\n-}\n \f\n /* Output instructions as RTL to increment the edge execution count.  */\n \n static rtx\n gen_edge_profiler (edgeno)\n      int edgeno;\n {\n-  enum machine_mode mode = mode_for_size (GCOV_TYPE_SIZE, MODE_INT, 0);\n-  rtx mem_ref, tmp;\n+  rtx ref = coverage_counter_ref (GCOV_TAG_ARC_COUNTS, edgeno);\n+  rtx tmp;\n+  enum machine_mode mode = GET_MODE (ref);\n   rtx sequence;\n \n   start_sequence ();\n+  ref = validize_mem (ref);\n \n-  tmp = force_reg (Pmode, profiler_label);\n-  tmp = plus_constant (tmp, GCOV_TYPE_SIZE / BITS_PER_UNIT * edgeno);\n-  mem_ref = validize_mem (gen_rtx_MEM (mode, tmp));\n-\n-  set_mem_alias_set (mem_ref, new_alias_set ());\n+  tmp = expand_simple_binop (mode, PLUS, ref, const1_rtx,\n+\t\t\t     ref, 0, OPTAB_WIDEN);\n \n-  tmp = expand_simple_binop (mode, PLUS, mem_ref, const1_rtx,\n-\t\t\t     mem_ref, 0, OPTAB_WIDEN);\n-\n-  if (tmp != mem_ref)\n-    emit_move_insn (copy_rtx (mem_ref), tmp);\n+  if (tmp != ref)\n+    emit_move_insn (copy_rtx (ref), tmp);\n \n   sequence = get_insns ();\n   end_sequence ();\n   return sequence;\n }\n-\n-#include \"gt-profile.h\""}, {"sha": "acd724353ce5a545619997991770af74468107d7", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -2210,11 +2210,15 @@ extern void dump_local_alloc\t\tPARAMS ((FILE *));\n extern int local_alloc\t\t\tPARAMS ((void));\n extern int function_invariant_p\t\tPARAMS ((rtx));\n \n+/* In coverage.c */\n+extern void coverage_init (const char *);\n+extern void coverage_finish (void);\n+extern void coverage_end_function (void);\n+\n /* In profile.c */\n-extern void init_branch_prob\t\tPARAMS ((const char *));\n+extern void init_branch_prob\t\tPARAMS ((void));\n extern void branch_prob\t\t\tPARAMS ((void));\n extern void end_branch_prob\t\tPARAMS ((void));\n-extern void create_profiler\t\tPARAMS ((void));\n \n /* In reg-stack.c */\n #ifdef BUFSIZ"}, {"sha": "bf879929973546ef7e30c9ac1f7cd960235460a3", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -2195,7 +2195,7 @@ compile_file ()\n   /* Initialize yet another pass.  */\n \n   init_final (main_input_filename);\n-  init_branch_prob (aux_base_name);\n+  coverage_init (aux_base_name);\n \n   timevar_push (TV_PARSE);\n \n@@ -2216,11 +2216,10 @@ compile_file ()\n \n   (*lang_hooks.decls.final_write_globals)();\n \n-    if (profile_arc_flag)\n-      /* This must occur after the loop to output deferred functions.\n-         Else the profiler initializer would not be emitted if all the\n-         functions in this compilation unit were deferred.  */\n-      create_profiler ();\n+  /* This must occur after the loop to output deferred functions.\n+     Else the coverage initializer would not be emitted if all the\n+     functions in this compilation unit were deferred.  */\n+  coverage_finish ();\n \n   /* Write out any pending weak symbol declarations.  */\n \n@@ -3765,6 +3764,8 @@ rest_of_compilation (decl)\n \n  exit_rest_of_compilation:\n \n+  coverage_end_function ();\n+  \n   /* In case the function was not output,\n      don't leave any temporary anonymous types\n      queued up for sdb output.  */"}, {"sha": "1448670ddc6a2ba9e6086a99a96b386234a4b9c8", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca29da43014c4d9b8622d345f674c03719764273/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=ca29da43014c4d9b8622d345f674c03719764273", "patch": "@@ -1,6 +1,6 @@\n /* The tracer pass for the GNU compiler.\n    Contributed by Jan Hubicka, SuSE Labs.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -46,7 +46,7 @@\n #include \"fibheap.h\"\n #include \"flags.h\"\n #include \"params.h\"\n-#include \"profile.h\"\n+#include \"coverage.h\"\n \n static int count_insns\t\tPARAMS ((basic_block));\n static bool ignore_bb_p\t\tPARAMS ((basic_block));"}]}