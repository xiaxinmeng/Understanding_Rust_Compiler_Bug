{"sha": "7ea18c086b6128de4aec84fe69da2102e2b60dec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VhMThjMDg2YjYxMjhkZTRhZWM4NGZlNjlkYTIxMDJlMmI2MGRlYw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2004-07-13T01:35:43Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2004-07-13T01:35:43Z"}, "message": "re PR target/16477 (Failure of gcc.c-torture/execute/strct-stdarg-1.c)\n\n\tPR target/16477\n\t* pa.c (function_arg): Update comment.\n\t* pa.h (BLOCK_REG_PADDING): Define.\n\nFrom-SVN: r84598", "tree": {"sha": "2148b738acfa1087ac20cfc3202465ee8904a7d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2148b738acfa1087ac20cfc3202465ee8904a7d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ea18c086b6128de4aec84fe69da2102e2b60dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea18c086b6128de4aec84fe69da2102e2b60dec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea18c086b6128de4aec84fe69da2102e2b60dec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea18c086b6128de4aec84fe69da2102e2b60dec/comments", "author": null, "committer": null, "parents": [{"sha": "7a1c3d48ab726eba42466131a41ba02615f306ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1c3d48ab726eba42466131a41ba02615f306ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1c3d48ab726eba42466131a41ba02615f306ad"}], "stats": {"total": 37, "additions": 22, "deletions": 15}, "files": [{"sha": "fe84ab5ec21144e0a11b1b6a43c141b5a6665c88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea18c086b6128de4aec84fe69da2102e2b60dec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea18c086b6128de4aec84fe69da2102e2b60dec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ea18c086b6128de4aec84fe69da2102e2b60dec", "patch": "@@ -1,3 +1,9 @@\n+2004-07-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/16477\n+\t* pa.c (function_arg): Update comment.\n+\t* pa.h (BLOCK_REG_PADDING): Define.\n+\n 2004-07-12  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \tPR tree-optimization/16461"}, {"sha": "ccc8f288fb692dccd7e18124029c98acfc37a33d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea18c086b6128de4aec84fe69da2102e2b60dec/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea18c086b6128de4aec84fe69da2102e2b60dec/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=7ea18c086b6128de4aec84fe69da2102e2b60dec", "patch": "@@ -8915,21 +8915,9 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \t  /* Structures 5 to 8 bytes in size are passed in the general\n \t     registers in the same manner as other non floating-point\n \t     objects.  The data is right-justified and zero-extended\n-\t     to 64 bits.\n-\n-\t     This is magic.  Normally, using a PARALLEL results in left\n-\t     justified data on a big-endian target.  However, using a\n-\t     single double-word register provides the required right\n-\t     justification for 5 to 8 byte structures.  This has nothing\n-\t     to do with the direction of padding specified for the argument.\n-\t     It has to do with how the data is widened and shifted into\n-\t     and from the register.\n-\n-\t     Aside from adding load_multiple and store_multiple patterns,\n-\t     this is the only way that I have found to obtain right\n-\t     justification of BLKmode data when it has a size greater\n-\t     than one word.  Splitting the operation into two SImode loads\n-\t     or returning a DImode REG results in left justified data.  */\n+\t     to 64 bits.  This is opposite to the normal justification\n+\t     used on big endian targets and requires special treatment.\n+\t     We now define BLOCK_REG_PADDING to pad these objects.  */\n \t  if (mode == BLKmode)\n \t    {\n \t      rtx loc = gen_rtx_EXPR_LIST (VOIDmode,"}, {"sha": "f82e09b1687193749e14591a94d7a2aa8d89401b", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea18c086b6128de4aec84fe69da2102e2b60dec/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea18c086b6128de4aec84fe69da2102e2b60dec/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=7ea18c086b6128de4aec84fe69da2102e2b60dec", "patch": "@@ -869,8 +869,21 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n   the standard parameter passing conventions on the RS6000.  That's why\n   you'll see lots of similar code in rs6000.h.  */\n \n+/* If defined, a C expression which determines whether, and in which\n+   direction, to pad out an argument with extra space.  */\n #define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding ((MODE), (TYPE))\n \n+/* Specify padding for the last element of a block move between registers\n+   and memory.\n+\n+   The 64-bit runtime specifies that objects need to be left justified\n+   (i.e., the normal justification for a big endian target).  The 32-bit\n+   runtime specifies right justification for objects smaller than 64 bits.\n+   We use a DImode register in the parallel for 5 to 7 byte structures\n+   so that there is only one element.  This allows the object to be\n+   correctly padded.  */\n+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) (TARGET_64BIT ? upward : downward)\n+\n /* Do not expect to understand this without reading it several times.  I'm\n    tempted to try and simply it, but I worry about breaking something.  */\n "}]}