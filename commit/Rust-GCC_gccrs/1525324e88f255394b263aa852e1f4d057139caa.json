{"sha": "1525324e88f255394b263aa852e1f4d057139caa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyNTMyNGU4OGYyNTUzOTRiMjYzYWE4NTJlMWY0ZDA1NzEzOWNhYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:12:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T08:12:03Z"}, "message": "Minor reformatting.\n\n(Install_Null_Excluding_Check): Moved to the package specification\nto use it from other packages to generate the run-time check\nassociated with the null-exclusion attribute.\n\nFrom-SVN: r103896", "tree": {"sha": "c727be86038d2e4661022df49f0c10ea2f7f5103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c727be86038d2e4661022df49f0c10ea2f7f5103"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1525324e88f255394b263aa852e1f4d057139caa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1525324e88f255394b263aa852e1f4d057139caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1525324e88f255394b263aa852e1f4d057139caa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1525324e88f255394b263aa852e1f4d057139caa/comments", "author": null, "committer": null, "parents": [{"sha": "d124a2302d8331862e1921f3d034ab182c4bea2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d124a2302d8331862e1921f3d034ab182c4bea2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d124a2302d8331862e1921f3d034ab182c4bea2c"}], "stats": {"total": 217, "additions": 109, "deletions": 108}, "files": [{"sha": "c16495dd1a26952d8fb5766cf602e84f5d731115", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 109, "deletions": 108, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1525324e88f255394b263aa852e1f4d057139caa/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1525324e88f255394b263aa852e1f4d057139caa/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=1525324e88f255394b263aa852e1f4d057139caa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -159,16 +159,20 @@ package Checks is\n       OK : out Boolean;\n       Lo : out Uint;\n       Hi : out Uint);\n-   --  N is a node for a subexpression. If N is of a discrete type with\n-   --  no error indications, and no other peculiarities (e.g. missing\n-   --  type fields), then OK is True on return, and Lo and Hi are set\n-   --  to a conservative estimate of the possible range of values of N.\n-   --  Thus if OK is True on return, the value of the subexpression N is\n-   --  known to like in the range Lo .. Hi (inclusive). If the expression\n-   --  is not of a discrete type, or some kind of error condition is\n-   --  detected, then OK is False on exit, and Lo/Hi are set to No_Uint.\n-   --  Thus the significance of OK being False on return is that no\n-   --  useful information is available on the range of the expression.\n+   --  N is a node for a subexpression. If N is of a discrete type with no\n+   --  error indications, and no other peculiarities (e.g. missing type\n+   --  fields), then OK is True on return, and Lo and Hi are set to a\n+   --  conservative estimate of the possible range of values of N. Thus if OK\n+   --  is True on return, the value of the subexpression N is known to like in\n+   --  the range Lo .. Hi (inclusive). If the expression is not of a discrete\n+   --  type, or some kind of error condition is detected, then OK is False on\n+   --  exit, and Lo/Hi are set to No_Uint. Thus the significance of OK being\n+   --  False on return is that no useful information is available on the range\n+   --  of the expression.\n+\n+   procedure Install_Null_Excluding_Check (N : Node_Id);\n+   --  Determines whether an access node requires a runtime access check and\n+   --  if so inserts the appropriate run-time check.\n \n    -------------------------------------------------------\n    -- Control and Optimization of Range/Overflow Checks --\n@@ -181,12 +185,12 @@ package Checks is\n    --  in the transitional phase where some of these checks are still done\n    --  by the back end, but many are done by the front end.\n \n-   --  Overflow checks are similarly controlled by the Do_Overflow_Check\n-   --  flag. The difference here is that if Backend_Overflow_Checks is\n-   --  is (Backend_Overflow_Checks_On_Target set False), then the actual\n-   --  overflow checks are generated by the front end, but if back end\n-   --  overflow checks are active (Backend_Overflow_Checks_On_Target\n-   --  set True), then the back end does generate the checks.\n+   --  Overflow checks are similarly controlled by the Do_Overflow_Check flag.\n+   --  The difference here is that if Backend_Overflow_Checks is is\n+   --  (Backend_Overflow_Checks_On_Target set False), then the actual overflow\n+   --  checks are generated by the front end, but if back end overflow checks\n+   --  are active (Backend_Overflow_Checks_On_Target set True), then the back\n+   --  end does generate the checks.\n \n    --  The following two routines are used to set these flags, they allow\n    --  for the possibility of eliminating checks. Checks can be eliminated\n@@ -266,17 +270,16 @@ package Checks is\n \n    --  The checks operate in one of two modes:\n \n-   --    If Source_Typ is Empty, then the node Expr is examined, at the\n-   --    very least to get the source subtype. In addition for some of\n-   --    the checks, the actual form of the node may be examined. For\n-   --    example, a node of type Integer whose actual form is an Integer\n-   --    conversion from a type with range 0 .. 3 can be determined to\n-   --    have a value in the range 0 .. 3.\n+   --    If Source_Typ is Empty, then the node Expr is examined, at the very\n+   --    least to get the source subtype. In addition for some of the checks,\n+   --    the actual form of the node may be examined. For example, a node of\n+   --    type Integer whose actual form is an Integer conversion from a type\n+   --    with range 0 .. 3 can be determined to have a value in range 0 .. 3.\n \n-   --    If Source_Typ is given, then nothing can be assumed about the\n-   --    Expr, and indeed its contents are not examined. In this case the\n-   --    check is based on the assumption that Expr can be an arbitrary\n-   --    value of the given Source_Typ.\n+   --    If Source_Typ is given, then nothing can be assumed about the Expr,\n+   --    and indeed its contents are not examined. In this case the check is\n+   --    based on the assumption that Expr can be an arbitrary value of the\n+   --    given Source_Typ.\n \n    --  Currently, the only case in which a Source_Typ is explicitly supplied\n    --  is for the case of Out and In_Out parameters, where, for the conversion\n@@ -293,8 +296,8 @@ package Checks is\n    --  to Insert_Actions.\n    --\n    --  For access types, the Directly_Designated_Type is retrieved and\n-   --  processing continues as enumerated above, with a guard against\n-   --  null values.\n+   --  processing continues as enumerated above, with a guard against null\n+   --  values.\n    --\n    --  Note: calls to Apply_Length_Check currently never supply an explicit\n    --  Source_Typ parameter, but Apply_Length_Check takes this parameter and\n@@ -305,9 +308,9 @@ package Checks is\n      (Ck_Node    : Node_Id;\n       Target_Typ : Entity_Id;\n       Source_Typ : Entity_Id := Empty);\n-   --  For an Node of kind N_Range, constructs a range check action that\n-   --  tests first that the range is not null and then that the range\n-   --  is contained in the Target_Typ range.\n+   --  For an Node of kind N_Range, constructs a range check action that tests\n+   --  first that the range is not null and then that the range is contained in\n+   --  the Target_Typ range.\n    --\n    --  For scalar types, constructs a range check action that first tests that\n    --  the expression is contained in the Target_Typ range. The difference\n@@ -318,13 +321,13 @@ package Checks is\n    --  to check that each Expr range is properly contained in the range of\n    --  Target_Typ.\n    --\n-   --  For a type conversion to an unconstrained array type, constructs\n-   --  a range check action to check that the bounds of the source type\n-   --  are within the constraints imposed by the Target_Typ.\n+   --  For a type conversion to an unconstrained array type, constructs a range\n+   --  check action to check that the bounds of the source type are within the\n+   --  constraints imposed by the Target_Typ.\n    --\n    --  For access types, the Directly_Designated_Type is retrieved and\n-   --  processing continues as enumerated above, with a guard against\n-   --  null values.\n+   --  processing continues as enumerated above, with a guard against null\n+   --  values.\n    --\n    --  The source type is used by type conversions to unconstrained array\n    --  types to retrieve the corresponding bounds.\n@@ -344,10 +347,10 @@ package Checks is\n       Source_Typ : Entity_Id := Empty;\n       Fixed_Int  : Boolean   := False);\n    --  For scalar types, determines whether an expression node should be\n-   --  flagged as needing a runtime range check. If the node requires such\n-   --  a check, the Do_Range_Check flag is turned on. The Fixed_Int flag\n-   --  if set causes any fixed-point values to be treated as though they\n-   --  were discrete values (i.e. the underlying integer value is used).\n+   --  flagged as needing a runtime range check. If the node requires such a\n+   --  check, the Do_Range_Check flag is turned on. The Fixed_Int flag if set\n+   --  causes any fixed-point values to be treated as though they were discrete\n+   --  values (i.e. the underlying integer value is used).\n \n    type Check_Result is private;\n    --  Type used to return result of Range_Check call, for later use in\n@@ -360,12 +363,11 @@ package Checks is\n       Static_Sloc  : Source_Ptr;\n       Flag_Node    : Node_Id);\n    --  Called to append range checks as returned by a call to Range_Check.\n-   --  Stmts is a list to which either the dynamic check is appended or\n-   --  the raise Constraint_Error statement is appended (for static checks).\n-   --  Static_Sloc is the Sloc at which the raise CE node points,\n-   --  Flag_Node is used as the node at which to set the Has_Dynamic_Check\n-   --  flag. Checks_On is a boolean value that says if range and index checking\n-   --  is on or not.\n+   --  Stmts is a list to which either the dynamic check is appended or the\n+   --  raise Constraint_Error statement is appended (for static checks).\n+   --  Static_Sloc is the Sloc at which the raise CE node points, Flag_Node is\n+   --  used as the node at which to set the Has_Dynamic_Check flag. Checks_On\n+   --  is a boolean value that says if range and index checking is on or not.\n \n    procedure Insert_Range_Checks\n      (Checks       : Check_Result;\n@@ -402,12 +404,12 @@ package Checks is\n    -- Expander Routines --\n    -----------------------\n \n-   --  Some of the earlier processing for checks results in temporarily\n-   --  setting the Do_Range_Check flag rather than actually generating\n-   --  checks. Now we are moving the generation of such checks into the\n-   --  front end for reasons of efficiency and simplicity (there were\n-   --  difficutlies in handling this in the back end when side effects\n-   --  were present in the expressions being checked).\n+   --  Some of the earlier processing for checks results in temporarily setting\n+   --  the Do_Range_Check flag rather than actually generating checks. Now we\n+   --  are moving the generation of such checks into the front end for reasons\n+   --  of efficiency and simplicity (there were difficutlies in handling this\n+   --  in the back end when side effects were present in the expressions being\n+   --  checked).\n \n    --  Probably we could eliminate the Do_Range_Check flag entirely and\n    --  generate the checks earlier, but this is a delicate area and it\n@@ -419,53 +421,52 @@ package Checks is\n      (N           : Node_Id;\n       Target_Type : Entity_Id;\n       Reason      : RT_Exception_Code);\n-   --  This procedure is called to actually generate and insert a range\n-   --  check. A check is generated to ensure that the value of N lies\n-   --  within the range of the target type. Note that the base type of\n-   --  N may be different from the base type of the target type. This\n-   --  happens in the conversion case. The Reason parameter is the\n-   --  exception code to be used for the exception if raised.\n+   --  This procedure is called to actually generate and insert a range check.\n+   --  A check is generated to ensure that the value of N lies within the range\n+   --  of the target type. Note that the base type of N may be different from\n+   --  the base type of the target type. This happens in the conversion case.\n+   --  The Reason parameter is the exception code to be used for the exception\n+   --  if raised.\n    --\n-   --  Note on the relation of this routine to the Do_Range_Check flag.\n-   --  Mostly for historical reasons, we often set the Do_Range_Check\n-   --  flag and then later we call Generate_Range_Check if this flag is\n-   --  set. Most probably we could eliminate this intermediate setting\n-   --  of the flag (historically the back end dealt with range checks,\n-   --  using this flag to indicate if a check was required, then we\n-   --  moved checks into the front end).\n+   --  Note on the relation of this routine to the Do_Range_Check flag. Mostly\n+   --  for historical reasons, we often set the Do_Range_Check flag and then\n+   --  later we call Generate_Range_Check if this flag is set. Most probably we\n+   --  could eliminate this intermediate setting of the flag (historically the\n+   --  back end dealt with range checks, using this flag to indicate if a check\n+   --  was required, then we moved checks into the front end).\n \n    procedure Generate_Index_Checks (N : Node_Id);\n-   --  This procedure is called to generate index checks on the subscripts\n-   --  for the indexed component node N. Each subscript expression is\n-   --  examined, and if the Do_Range_Check flag is set, an appropriate\n-   --  index check is generated and the flag is reset.\n+   --  This procedure is called to generate index checks on the subscripts for\n+   --  the indexed component node N. Each subscript expression is examined, and\n+   --  if the Do_Range_Check flag is set, an appropriate index check is\n+   --  generated and the flag is reset.\n \n    --  Similarly, we set the flag Do_Discriminant_Check in the semantic\n-   --  analysis to indicate that a discriminant check is required for a\n-   --  selected component of a discriminated type. The following routine\n-   --  is called from the expander to actually generate the call.\n+   --  analysis to indicate that a discriminant check is required for selected\n+   --  component of a discriminated type. The following routine is called from\n+   --  the expander to actually generate the call.\n \n    procedure Generate_Discriminant_Check (N : Node_Id);\n-   --  N is a selected component for which a discriminant check is required\n-   --  to make sure that the discriminants have appropriate values for the\n-   --  selection. This is done by calling the appropriate discriminant\n-   --  checking routine for the selector.\n+   --  N is a selected component for which a discriminant check is required to\n+   --  make sure that the discriminants have appropriate values for the\n+   --  selection. This is done by calling the appropriate discriminant checking\n+   --  routine for the selector.\n \n    -----------------------\n    -- Validity Checking --\n    -----------------------\n \n    --  In (RM 13.9.1(9-11)) we have the following rules on invalid values\n \n-   --    If the representation of a scalar object does not represent a\n-   --    value of the object's subtype (perhaps because the object was not\n-   --    initialized), the object is said to have an invalid representation.\n-   --    It is a bounded error to evaluate the value of such an object.  If\n-   --    the error is detected, either Constraint_Error or Program_Error is\n-   --    raised.  Otherwise, execution continues using the invalid\n-   --    representation.  The rules of the language outside this subclause\n-   --    assume that all objects have valid representations.  The semantics\n-   --    of operations on invalid representations are as follows:\n+   --    If the representation of a scalar object does not represent value of\n+   --    the object's subtype (perhaps because the object was not initialized),\n+   --    the object is said to have an invalid representation. It is a bounded\n+   --    error to evaluate the value of such an object. If the error is\n+   --    detected, either Constraint_Error or Program_Error is raised.\n+   --    Otherwise, execution continues using the invalid representation. The\n+   --    rules of the language outside this subclause assume that all objects\n+   --    have valid representations. The semantics of operations on invalid\n+   --    representations are as follows:\n    --\n    --       10  If the representation of the object represents a value of the\n    --           object's type, the value of the type is used.\n@@ -483,9 +484,9 @@ package Checks is\n    --  array assignments, where we don't want to do wild stores, and case\n    --  statements where we don't want to do wild jumps.\n \n-   --  In GNAT, we control validity checking with a switch -gnatV that\n-   --  can take three parameters, n/d/f for None/Default/Full. These\n-   --  modes have the following meanings:\n+   --  In GNAT, we control validity checking with a switch -gnatV that can take\n+   --  three parameters, n/d/f for None/Default/Full. These modes have the\n+   --  following meanings:\n \n    --    None (no validity checking)\n \n@@ -577,12 +578,12 @@ package Checks is\n    --  are checked for validity.\n \n    procedure Check_Valid_Lvalue_Subscripts (Expr : Node_Id);\n-   --  Expr is a lvalue, i.e. an expression representing the target of\n-   --  an assignment. This procedure checks for this expression involving\n-   --  an assignment to an array value. We have to be sure that all the\n-   --  subscripts in such a case are valid, since according to the rules\n-   --  in (RM 13.9.1(9-11)) such assignments are not permitted to result\n-   --  in erroneous behavior in the case of invalid subscript values.\n+   --  Expr is a lvalue, i.e. an expression representing the target of an\n+   --  assignment. This procedure checks for this expression involving an\n+   --  assignment to an array value. We have to be sure that all the subscripts\n+   --  in such a case are valid, since according to the rules in (RM\n+   --  13.9.1(9-11)) such assignments are not permitted to result in erroneous\n+   --  behavior in the case of invalid subscript values.\n \n    procedure Ensure_Valid (Expr : Node_Id; Holes_OK : Boolean := False);\n    --  Ensure that Expr represents a valid value of its type. If this type\n@@ -602,14 +603,14 @@ package Checks is\n    --  valid, raising Constraint_Error if the value is not valid.\n \n    function Expr_Known_Valid (Expr : Node_Id) return Boolean;\n-   --  This function tests it the value of Expr is known to be valid in\n-   --  the sense of RM 13.9.1(9-11). In the case of GNAT, it is only\n-   --  discrete types which are a concern, since for non-discrete types\n-   --  we simply continue computation with invalid values, which does\n-   --  not lead to erroneous behavior. Thus Expr_Known_Valid always\n-   --  returns True if the type of Expr is non-discrete. For discrete\n-   --  types the value returned is True only if it can be determined\n-   --  that the value is Valid. Otherwise False is returned.\n+   --  This function tests it the value of Expr is known to be valid in the\n+   --  sense of RM 13.9.1(9-11). In the case of GNAT, it is only discrete types\n+   --  which are a concern, since for non-discrete types we simply continue\n+   --  computation with invalid values, which does not lead to erroneous\n+   --  behavior. Thus Expr_Known_Valid always returns True if the type of Expr\n+   --  is non-discrete. For discrete types the value returned is True only if\n+   --  it can be determined that the value is Valid. Otherwise False is\n+   --  returned.\n \n    procedure Insert_Valid_Check (Expr : Node_Id);\n    --  Inserts code that will check for the value of Expr being valid, in\n@@ -635,12 +636,12 @@ private\n    --    responsibility of the caller to rewrite and substitute the nodes with\n    --    N_Raise_Constraint_Error nodes.\n    --\n-   --    For the non-static case a single N_Raise_Constraint_Error node\n-   --    with a non-empty Condition field is returned.\n+   --    For the non-static case a single N_Raise_Constraint_Error node with a\n+   --    non-empty Condition field is returned.\n    --\n-   --  Unused entries in Check_Result, if any, are simply set to Empty\n-   --  For external clients, the required processing on this result is\n-   --  achieved using the Insert_Range_Checks routine.\n+   --  Unused entries in Check_Result, if any, are simply set to Empty For\n+   --  external clients, the required processing on this result is achieved\n+   --  using the Insert_Range_Checks routine.\n \n    pragma Inline (Apply_Length_Check);\n    pragma Inline (Apply_Range_Check);"}]}