{"sha": "3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk3N2E0YTFlZWM5NTY0NWEwM2Y3OGQ4NWVkMWYxMThjYzdjZmNiZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-02-17T17:12:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-02-17T17:12:20Z"}, "message": "i386-cpuid.h (bit_CMOV): Define.\n\n\t* gcc.dg/i386-cpuid.h (bit_CMOV): Define.\n\t(i386_cpuid): No need to test if cpuid is available on AMD64.\n\tFix assembly, so that it works onboth i386 and AMD64.\n\t* gcc.dg/i386-sse-6.c: Include stdio.h, stdlib.h and string.h.\n\t(vecInLong): Fix s[] member type to unsigned int.\n\t(vecInWord): Remove type.\n\t(mmx_tests, sse_tests, dump64_16, dump64_32, dump64_64): Remove.\n\t(a64, b64, c64, d64, e64): Remove.\n\t(main): Pass if CPU has no MMX, SSE, SSE2 or CMOV support.\n\tRemove unused variable.  Remove initialization of removed variables.\n\tDon't call mmx_tests nor sse_tests.\n\t(reference_mmx, reference_sse): Remove.\n\t(check): Add return stmt.\n\t* gcc.dg/i386-sse-7.c: New test.\n\t* gcc.dg/i386-mmx-4.c: New test.\n\nFrom-SVN: r77955", "tree": {"sha": "1153d593e73f81758a5432ce6995d76efbadcf65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1153d593e73f81758a5432ce6995d76efbadcf65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72b1de442d8ab221371ebaca87fbb0a9f13deb48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b1de442d8ab221371ebaca87fbb0a9f13deb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b1de442d8ab221371ebaca87fbb0a9f13deb48"}], "stats": {"total": 628, "additions": 427, "deletions": 201}, "files": [{"sha": "752930202650f7fa1e07dcd54e4b1def47043f6a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "patch": "@@ -1,3 +1,21 @@\n+2004-02-17  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/i386-cpuid.h (bit_CMOV): Define.\n+\t(i386_cpuid): No need to test if cpuid is available on AMD64.\n+\tFix assembly, so that it works onboth i386 and AMD64.\n+\t* gcc.dg/i386-sse-6.c: Include stdio.h, stdlib.h and string.h.\n+\t(vecInLong): Fix s[] member type to unsigned int.\n+\t(vecInWord): Remove type.\n+\t(mmx_tests, sse_tests, dump64_16, dump64_32, dump64_64): Remove.\n+\t(a64, b64, c64, d64, e64): Remove.\n+\t(main): Pass if CPU has no MMX, SSE, SSE2 or CMOV support.\n+\tRemove unused variable.  Remove initialization of removed variables.\n+\tDon't call mmx_tests nor sse_tests.\n+\t(reference_mmx, reference_sse): Remove.\n+\t(check): Add return stmt.\n+\t* gcc.dg/i386-sse-7.c: New test.\n+\t* gcc.dg/i386-mmx-4.c: New test.\n+\n 2004-02-17  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \t* g++.dg/tc1/dr176.C: Add missing semicolon (typo)."}, {"sha": "dc300e4482b7afcf361f611e6e480f61f50617dc", "filename": "gcc/testsuite/gcc.dg/i386-cpuid.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-cpuid.h?ref=3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "patch": "@@ -2,6 +2,7 @@\n    Used by 20020523-2.c and i386-sse-6.c, and possibly others.  */\n /* Plagarized from 20020523-2.c.  */\n \n+#define bit_CMOV (1 << 15)\n #define bit_MMX (1 << 23)\n #define bit_SSE (1 << 25)\n #define bit_SSE2 (1 << 26)\n@@ -17,27 +18,39 @@ i386_cpuid (void)\n {\n   int fl1, fl2;\n \n-  /* See if we can use cpuid.  */\n+#ifndef __x86_64__\n+  /* See if we can use cpuid.  On AMD64 we always can.  */\n   __asm__ (\"pushfl; pushfl; popl %0; movl %0,%1; xorl %2,%0;\"\n \t   \"pushl %0; popfl; pushfl; popl %0; popfl\"\n \t   : \"=&r\" (fl1), \"=&r\" (fl2)\n \t   : \"i\" (0x00200000));\n   if (((fl1 ^ fl2) & 0x00200000) == 0)\n     return (0);\n+#endif\n \n   /* Host supports cpuid.  See if cpuid gives capabilities, try\n      CPUID(0).  Preserve %ebx and %ecx; cpuid insn clobbers these, we\n      don't need their CPUID values here, and %ebx may be the PIC\n      register.  */\n-  __asm__ (\"push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx\"\n+#ifdef __x86_64__\n+  __asm__ (\"pushq %%rcx; pushq %%rbx; cpuid; popq %%rbx; popq %%rcx\"\n+\t   : \"=a\" (fl1) : \"0\" (0) : \"rdx\", \"cc\");\n+#else\n+  __asm__ (\"pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx\"\n \t   : \"=a\" (fl1) : \"0\" (0) : \"edx\", \"cc\");\n+#endif\n   if (fl1 == 0)\n     return (0);\n \n   /* Invoke CPUID(1), return %edx; caller can examine bits to\n      determine what's supported.  */\n-  __asm__ (\"push %%ecx ; push %%ebx ; cpuid ; pop %%ebx ; pop %%ecx\" : \"=d\" (fl2) : \"a\" (1) : \"cc\");\n+#ifdef __x86_64__\n+  __asm__ (\"pushq %%rcx; pushq %%rbx; cpuid; popq %%rbx; popq %%rcx\"\n+\t   : \"=d\" (fl2), \"=a\" (fl1) : \"1\" (1) : \"cc\");\n+#else\n+  __asm__ (\"pushl %%ecx; pushl %%ebx; cpuid; popl %%ebx; popl %%ecx\"\n+\t   : \"=d\" (fl2), \"=a\" (fl1) : \"1\" (1) : \"cc\");\n+#endif\n \n   return fl2;\n }\n-"}, {"sha": "071baf7860c7c5ede102b39b22a9d146fe476da9", "filename": "gcc/testsuite/gcc.dg/i386-mmx-4.c", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-4.c?ref=3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "patch": "@@ -0,0 +1,245 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -mmmx\" } */\n+#include <mmintrin.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"i386-cpuid.h\"\n+\n+#ifndef NOINLINE\n+#define NOINLINE __attribute__ ((noinline))\n+#endif\n+\n+#define SHIFT (4)\n+\n+typedef union {\n+  __m64 v;\n+  unsigned char c[8];\n+  unsigned short int s[4];\n+  unsigned long long t;\n+  unsigned int u[2];\n+}vecInWord;\n+\n+void mmx_tests (void) NOINLINE;\n+void dump64_16 (char *, char *, vecInWord);\n+void dump64_32 (char *, char *, vecInWord);\n+void dump64_64 (char *, char *, vecInWord);\n+int check (const char *, const char *[]);\n+\n+char buf[8000];\n+char comparison[8000];\n+static int errors = 0;\n+\n+vecInWord a64, b64, c64, d64, e64;\n+__m64 m64_16, s64, m64_32, m64_64;\n+\n+const char *reference_mmx[] = {\n+  \"_mm_srai_pi16 0012 0012 0012 0012 \\n\",\n+  \"_mm_sra_pi16 0012 0012 0012 0012 \\n\",\n+  \"_mm_srai_pi32 00123456 00123456 \\n\",\n+  \"_mm_sra_pi32 00123456 00123456 \\n\",\n+  \"_mm_srli_pi16 0012 0012 0012 0012 \\n\",\n+  \"_mm_srl_pi16 0012 0012 0012 0012 \\n\",\n+  \"_mm_srli_pi32 00123456 00123456 \\n\",\n+  \"_mm_srl_pi32 00123456 00123456 \\n\",\n+  \"_mm_srli_si64 00123456789abcde\\n\",\n+  \"_mm_srl_si64 00123456789abcde\\n\",\n+  \"_mm_slli_pi16 1230 1230 1230 1230 \\n\",\n+  \"_mm_sll_pi16 1230 1230 1230 1230 \\n\",\n+  \"_mm_slli_pi32 12345670 12345670 \\n\",\n+  \"_mm_sll_pi32 12345670 12345670 \\n\",\n+  \"_mm_slli_si64 123456789abcdef0\\n\",\n+  \"_mm_sll_si64 123456789abcdef0\\n\",\n+  \"\"\n+};\n+\n+int main()\n+{\n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_cpuid ();\n+\n+  if ((cpu_facilities & bit_MMX) == 0)\n+    exit (0);\n+\n+  d64.u[0]  = 0x01234567;\n+  d64.u[1]  = 0x01234567;\n+\n+  m64_32 = d64.v;\n+\n+  e64.t  = 0x0123456789abcdefULL;\n+\n+  m64_64 = e64.v;\n+\n+  a64.s[0] = 0x0123;\n+  a64.s[1] = 0x0123;\n+  a64.s[2] = 0x0123;\n+  a64.s[3] = 0x0123;\n+\n+  m64_16 = a64.v;\n+\n+  b64.s[0] = SHIFT;\n+  b64.s[1] = 0;\n+  b64.s[2] = 0;\n+  b64.s[3] = 0;\n+\n+  s64 = b64.v;\n+\n+  if (cpu_facilities & bit_MMX)\n+    {\n+      mmx_tests();\n+      check (buf, reference_mmx);\n+#ifdef DEBUG\n+      printf (\"mmx testing:\\n\");\n+      printf (buf);\n+      printf (\"\\ncomparison:\\n\");\n+      printf (comparison);\n+#endif\n+      buf[0] = '\\0';\n+    }\n+\n+  if (errors != 0)\n+    abort ();\n+  exit (0);\n+}\n+\n+void NOINLINE\n+mmx_tests (void)\n+{\n+  /* psraw */\n+  c64.v = _mm_srai_pi16 (m64_16, SHIFT);\n+  dump64_16 (buf, \"_mm_srai_pi16\", c64);\n+  c64.v  = _mm_sra_pi16 (m64_16, s64);\n+  dump64_16 (buf, \"_mm_sra_pi16\", c64);\n+\n+  /* psrad */\n+  c64.v  = _mm_srai_pi32 (m64_32, SHIFT);\n+  dump64_32 (buf, \"_mm_srai_pi32\", c64);\n+  c64.v = _mm_sra_pi32 (m64_32, s64);\n+  dump64_32 (buf, \"_mm_sra_pi32\", c64);\n+\n+  /* psrlw */\n+  c64.v = _mm_srli_pi16 (m64_16, SHIFT);\n+  dump64_16 (buf, \"_mm_srli_pi16\", c64);\n+  c64.v = _mm_srl_pi16 (m64_16, s64);\n+  dump64_16 (buf, \"_mm_srl_pi16\", c64);\n+\n+  /* psrld */\n+  c64.v = _mm_srli_pi32 (m64_32, SHIFT);\n+  dump64_32 (buf, \"_mm_srli_pi32\", c64);\n+  c64.v = _mm_srl_pi32 (m64_32, s64);\n+  dump64_32 (buf, \"_mm_srl_pi32\", c64);\n+\n+  /* psrlq */\n+  c64.v = _mm_srli_si64 (m64_64, SHIFT);\n+  dump64_64 (buf, \"_mm_srli_si64\", c64);\n+  c64.v = _mm_srl_si64 (m64_64, s64);\n+  dump64_64 (buf, \"_mm_srl_si64\", c64);\n+\n+  /* psllw */\n+  c64.v = _mm_slli_pi16 (m64_16, SHIFT);\n+  dump64_16 (buf, \"_mm_slli_pi16\", c64);\n+  c64.v = _mm_sll_pi16 (m64_16, s64);\n+  dump64_16 (buf, \"_mm_sll_pi16\", c64);\n+\n+  /* pslld */\n+  c64.v = _mm_slli_pi32 (m64_32, SHIFT);\n+  dump64_32 (buf, \"_mm_slli_pi32\", c64);\n+  c64.v = _mm_sll_pi32 (m64_32, s64);\n+  dump64_32 (buf, \"_mm_sll_pi32\", c64);\n+\n+  /* psllq */\n+  c64.v = _mm_slli_si64 (m64_64, SHIFT);\n+  dump64_64 (buf, \"_mm_slli_si64\", c64);\n+  c64.v = _mm_sll_si64 (m64_64, s64);\n+  dump64_64 (buf, \"_mm_sll_si64\", c64);\n+}\n+\n+void\n+dump64_16 (char *buf, char *name, vecInWord x)\n+{\n+  int i;\n+  char *p = buf + strlen (buf);\n+\n+  sprintf (p, \"%s \", name);\n+  p += strlen (p);\n+\n+  for (i=0; i<4; i++)\n+    {\n+      sprintf (p, \"%4.4x \", x.s[i]);\n+      p += strlen (p);\n+    }\n+  strcat (p, \"\\n\");\n+}\n+\n+void\n+dump64_32 (char *buf, char *name, vecInWord x)\n+{\n+  int i;\n+  char *p = buf + strlen (buf);\n+\n+  sprintf (p, \"%s \", name);\n+  p += strlen (p);\n+\n+  for (i=0; i<2; i++)\n+    {\n+      sprintf (p, \"%8.8x \", x.u[i]);\n+      p += strlen (p);\n+    }\n+  strcat (p, \"\\n\");\n+}\n+\n+void\n+dump64_64 (char *buf, char *name, vecInWord x)\n+{\n+  char *p = buf + strlen (buf);\n+\n+  sprintf (p, \"%s \", name);\n+  p += strlen (p);\n+\n+  sprintf (p, \"%16.16llx\\n\", x.t);\n+}\n+\n+int\n+check (const char *input, const char *reference[])\n+{\n+  int broken, i, j, len;\n+  const char *p_input;\n+  char *p_comparison;\n+  int new_errors = 0;\n+\n+  p_comparison = &comparison[0];\n+  p_input = input;\n+\n+  for (i = 0; *reference[i] != '\\0'; i++)\n+    {\n+      broken = 0;\n+      len = strlen (reference[i]);\n+      for (j = 0; j < len; j++)\n+\t{\n+\t  /* Ignore the terminating NUL characters at the end of every string in 'reference[]'.  */\n+\t  if (!broken && *p_input != reference[i][j])\n+\t    {\n+\t      *p_comparison = '\\0';\n+\t      strcat (p_comparison, \" >>> \");\n+\t      p_comparison += strlen (p_comparison);\n+\t      new_errors++;\n+\t      broken = 1;\n+\t    }\n+\t  *p_comparison = *p_input;\n+\t  p_comparison++;\n+\t  p_input++;\n+\t}\n+      if (broken)\n+\t{\n+\t  *p_comparison = '\\0';\n+\t  strcat (p_comparison, \"expected:\\n\");\n+\t  strcat (p_comparison, reference[i]);\n+\t  p_comparison += strlen (p_comparison);\n+\t}\n+    }\n+  *p_comparison = '\\0';\n+  strcat (p_comparison, new_errors ? \"failure\\n\\n\" : \"O.K.\\n\\n\") ;\n+  errors += new_errors;\n+  return 0;\n+}"}, {"sha": "6642891485bf420375409e32ad810700c11b32be", "filename": "gcc/testsuite/gcc.dg/i386-sse-6.c", "status": "modified", "additions": 8, "deletions": 197, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-6.c?ref=3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "patch": "@@ -1,6 +1,9 @@\n /* { dg-do run { target i?86-*-* x86_64-*-* } } */\n /* { dg-options \"-O2 -msse2\" } */\n #include <xmmintrin.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n #include \"i386-cpuid.h\"\n \n #ifndef NOINLINE\n@@ -11,26 +14,13 @@\n \n typedef union {\n   __m128i v;\n-  unsigned long s[4];\n+  unsigned int s[4];\n   unsigned short int t[8];\n   unsigned long long u[2];\n   unsigned char c[16];\n }vecInLong;\n \n-typedef union {\n-  __m64 v;\n-  unsigned char c[8];\n-  unsigned short int s[4];\n-  unsigned long long t;\n-  unsigned int u[2];\n-}vecInWord;\n-\n-void mmx_tests (void) NOINLINE;\n-void sse_tests (void) NOINLINE;\n void sse2_tests (void) NOINLINE;\n-void dump64_16 (char *, char *, vecInWord);\n-void dump64_32 (char *, char *, vecInWord);\n-void dump64_64 (char *, char *, vecInWord);\n void dump128_16 (char *, char *, vecInLong);\n void dump128_32 (char *, char *, vecInLong);\n void dump128_64 (char *, char *, vecInLong);\n@@ -42,35 +32,9 @@ char comparison[8000];\n static int errors = 0;\n \n vecInLong a128, b128, c128, d128, e128, f128;\n-vecInWord a64, b64, c64, d64, e64;\n __m128i m128_16, m128_32, s128, m128_64, m128_128;\n __m64 m64_16, s64, m64_32, m64_64;\n \n-const char *reference_mmx[] = {\n-  \"_mm_srai_pi16 0012 0012 0012 0012 \\n\",\n-  \"_mm_sra_pi16 0012 0012 0012 0012 \\n\",\n-  \"_mm_srai_pi32 00123456 00123456 \\n\",\n-  \"_mm_sra_pi32 00123456 00123456 \\n\",\n-  \"_mm_srli_pi16 0012 0012 0012 0012 \\n\",\n-  \"_mm_srl_pi16 0012 0012 0012 0012 \\n\",\n-  \"_mm_srli_pi32 00123456 00123456 \\n\",\n-  \"_mm_srl_pi32 00123456 00123456 \\n\",\n-  \"_mm_srli_si64 00123456789abcde\\n\",\n-  \"_mm_srl_si64 00123456789abcde\\n\",\n-  \"_mm_slli_pi16 1230 1230 1230 1230 \\n\",\n-  \"_mm_sll_pi16 1230 1230 1230 1230 \\n\",\n-  \"_mm_slli_pi32 12345670 12345670 \\n\",\n-  \"_mm_sll_pi32 12345670 12345670 \\n\",\n-  \"_mm_slli_si64 123456789abcdef0\\n\",\n-  \"_mm_sll_si64 123456789abcdef0\\n\",\n-  \"\"\n-};\n-\n-const char *reference_sse[] = {\n-  \"_mm_shuffle_pi16 0123 4567 89ab cdef \\n\",\n-  \"\"\n-};\n-\n const char *reference_sse2[] = {\n   \"_mm_srai_epi16 0012 0012 0012 0012 0012 0012 0012 0012 \\n\",\n   \"_mm_sra_epi16 0012 0012 0012 0012 0012 0012 0012 0012 \\n\",\n@@ -98,12 +62,13 @@ const char *reference_sse2[] = {\n \n int main()\n {\n-  unsigned long *p;\n   unsigned long cpu_facilities;\n \n   cpu_facilities = i386_cpuid ();\n \n-  if (!cpu_facilities)\t/* If host has no vector support, pass.  */\n+  if ((cpu_facilities & (bit_MMX | bit_SSE | bit_SSE2 | bit_CMOV))\n+      != (bit_MMX | bit_SSE | bit_SSE2 | bit_CMOV))\n+    /* If host has no vector support, pass.  */\n     exit (0);\n \n   a128.s[0] = 0x01234567;\n@@ -136,62 +101,13 @@ int main()\n \n   m128_128 = e128.v;\n \n-  d64.u[0]  = 0x01234567;\n-  d64.u[1]  = 0x01234567;\n-\n-  m64_32 = d64.v;\n-\n-  e64.t  = 0x0123456789abcdefULL;\n-\n-  m64_64 = e64.v;\n-\n-  a64.s[0] = 0x0123;\n-  a64.s[1] = 0x0123;\n-  a64.s[2] = 0x0123;\n-  a64.s[3] = 0x0123;\n-\n-  m64_16 = a64.v;\n-\n   b128.s[0] = SHIFT;\n   b128.s[1] = 0;\n   b128.s[2] = 0;\n   b128.s[3] = 0;\n \n   s128 = b128.v;\n \n-  b64.s[0] = SHIFT;\n-  b64.s[1] = 0;\n-  b64.s[2] = 0;\n-  b64.s[3] = 0;\n-\n-  s64 = b64.v;\n-\n-  if (cpu_facilities & bit_MMX)\n-    {\n-      mmx_tests();\n-      check (buf, reference_mmx);\n-#ifdef DEBUG\n-      printf (\"mmx testing:\\n\");\n-      printf (buf);\n-      printf (\"\\ncomparison:\\n\");\n-      printf (comparison);\n-#endif\n-      buf[0] = '\\0';\n-    }\n-\n-  if (cpu_facilities & bit_SSE)\n-    {\n-      sse_tests();\n-      check (buf, reference_sse);\n-#ifdef DEBUG\n-      printf (\"sse testing:\\n\");\n-      printf (buf);\n-      printf (\"\\ncomparison:\\n\");\n-      printf (comparison);\n-#endif\n-      buf[0] = '\\0';\n-    }\n-\n   if (cpu_facilities & bit_SSE2)\n     {\n       sse2_tests();\n@@ -210,66 +126,6 @@ int main()\n   exit (0);\n }\n \n-void NOINLINE\n-mmx_tests (void)\n-{\n-  /* psraw */\n-  c64.v = _mm_srai_pi16 (m64_16, SHIFT);\n-  dump64_16 (buf, \"_mm_srai_pi16\", c64);\n-  c64.v  = _mm_sra_pi16 (m64_16, s64);\n-  dump64_16 (buf, \"_mm_sra_pi16\", c64);\n-\n-  /* psrad */\n-  c64.v  = _mm_srai_pi32 (m64_32, SHIFT);\n-  dump64_32 (buf, \"_mm_srai_pi32\", c64);\n-  c64.v = _mm_sra_pi32 (m64_32, s64);\n-  dump64_32 (buf, \"_mm_sra_pi32\", c64);\n-\n-  /* psrlw */\n-  c64.v = _mm_srli_pi16 (m64_16, SHIFT);\n-  dump64_16 (buf, \"_mm_srli_pi16\", c64);\n-  c64.v = _mm_srl_pi16 (m64_16, s64);\n-  dump64_16 (buf, \"_mm_srl_pi16\", c64);\n-\n-  /* psrld */\n-  c64.v = _mm_srli_pi32 (m64_32, SHIFT);\n-  dump64_32 (buf, \"_mm_srli_pi32\", c64);\n-  c64.v = _mm_srl_pi32 (m64_32, s64);\n-  dump64_32 (buf, \"_mm_srl_pi32\", c64);\n-\n-  /* psrlq */\n-  c64.v = _mm_srli_si64 (m64_64, SHIFT);\n-  dump64_64 (buf, \"_mm_srli_si64\", c64);\n-  c64.v = _mm_srl_si64 (m64_64, s64);\n-  dump64_64 (buf, \"_mm_srl_si64\", c64);\n-\n-  /* psllw */\n-  c64.v = _mm_slli_pi16 (m64_16, SHIFT);\n-  dump64_16 (buf, \"_mm_slli_pi16\", c64);\n-  c64.v = _mm_sll_pi16 (m64_16, s64);\n-  dump64_16 (buf, \"_mm_sll_pi16\", c64);\n-\n-  /* pslld */\n-  c64.v = _mm_slli_pi32 (m64_32, SHIFT);\n-  dump64_32 (buf, \"_mm_slli_pi32\", c64);\n-  c64.v = _mm_sll_pi32 (m64_32, s64);\n-  dump64_32 (buf, \"_mm_sll_pi32\", c64);\n-\n-  /* psllq */\n-  c64.v = _mm_slli_si64 (m64_64, SHIFT);\n-  dump64_64 (buf, \"_mm_slli_si64\", c64);\n-  c64.v = _mm_sll_si64 (m64_64, s64);\n-  dump64_64 (buf, \"_mm_sll_si64\", c64);\n-}\n-\n-void NOINLINE\n-sse_tests (void)\n-{\n-  /* pshufw */\n-  c64.v = _mm_shuffle_pi16 (m64_64, 0x1b);\n-  dump64_16 (buf, \"_mm_shuffle_pi16\", c64);\n-}\n-\n void NOINLINE\n sse2_tests (void)\n {\n@@ -344,52 +200,6 @@ sse2_tests (void)\n   dump128_16 (buf, \"_mm_shuffehi_epi16\", c128);\n }\n \n-void\n-dump64_16 (char *buf, char *name, vecInWord x)\n-{\n-  int i;\n-  char *p = buf + strlen (buf);\n-\n-  sprintf (p, \"%s \", name);\n-  p += strlen (p);\n-\n-  for (i=0; i<4; i++)\n-    {\n-      sprintf (p, \"%4.4x \", x.s[i]);\n-      p += strlen (p);\n-    }\n-  strcat (p, \"\\n\");\n-}\n-\n-void\n-dump64_32 (char *buf, char *name, vecInWord x)\n-{\n-  int i;\n-  char *p = buf + strlen (buf);\n-\n-  sprintf (p, \"%s \", name);\n-  p += strlen (p);\n-\n-  for (i=0; i<2; i++)\n-    {\n-      sprintf (p, \"%8.8x \", x.u[i]);\n-      p += strlen (p);\n-    }\n-  strcat (p, \"\\n\");\n-}\n-\n-void\n-dump64_64 (char *buf, char *name, vecInWord x)\n-{\n-  int i;\n-  char *p = buf + strlen (buf);\n-\n-  sprintf (p, \"%s \", name);\n-  p += strlen (p);\n-\n-  sprintf (p, \"%16.16llx\\n\", x.t);\n-}\n-\n void\n dump128_16 (char *buf, char *name, vecInLong x)\n {\n@@ -502,4 +312,5 @@ check (const char *input, const char *reference[])\n   *p_comparison = '\\0';\n   strcat (p_comparison, new_errors ? \"failure\\n\\n\" : \"O.K.\\n\\n\") ;\n   errors += new_errors;\n+  return 0;\n }"}, {"sha": "62e06e94ac8d903f69d21c6595f35e48d8bbc0a7", "filename": "gcc/testsuite/gcc.dg/i386-sse-7.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3977a4a1eec95645a03f78d85ed1f118cc7cfcbd/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-7.c?ref=3977a4a1eec95645a03f78d85ed1f118cc7cfcbd", "patch": "@@ -0,0 +1,139 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse\" } */\n+#include <xmmintrin.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"i386-cpuid.h\"\n+\n+#ifndef NOINLINE\n+#define NOINLINE __attribute__ ((noinline))\n+#endif\n+\n+#define SHIFT (4)\n+\n+typedef union {\n+  __m64 v;\n+  unsigned char c[8];\n+  unsigned short int s[4];\n+  unsigned long long t;\n+  unsigned int u[2];\n+}vecInWord;\n+\n+void sse_tests (void) NOINLINE;\n+void dump64_16 (char *, char *, vecInWord);\n+int check (const char *, const char *[]);\n+\n+char buf[8000];\n+char comparison[8000];\n+static int errors = 0;\n+\n+vecInWord c64, e64;\n+__m64 m64_64;\n+\n+const char *reference_sse[] = {\n+  \"_mm_shuffle_pi16 0123 4567 89ab cdef \\n\",\n+  \"\"\n+};\n+\n+int main()\n+{\n+  unsigned long cpu_facilities;\n+\n+  cpu_facilities = i386_cpuid ();\n+\n+  if ((cpu_facilities & (bit_MMX | bit_SSE | bit_CMOV))\n+      != (bit_MMX | bit_SSE | bit_CMOV))\n+    /* If host has no vector support, pass.  */\n+    exit (0);\n+\n+  e64.t  = 0x0123456789abcdefULL;\n+\n+  m64_64 = e64.v;\n+\n+  if (cpu_facilities & bit_SSE)\n+    {\n+      sse_tests();\n+      check (buf, reference_sse);\n+#ifdef DEBUG\n+      printf (\"sse testing:\\n\");\n+      printf (buf);\n+      printf (\"\\ncomparison:\\n\");\n+      printf (comparison);\n+#endif\n+      buf[0] = '\\0';\n+    }\n+\n+  if (errors != 0)\n+    abort ();\n+  exit (0);\n+}\n+\n+void NOINLINE\n+sse_tests (void)\n+{\n+  /* pshufw */\n+  c64.v = _mm_shuffle_pi16 (m64_64, 0x1b);\n+  dump64_16 (buf, \"_mm_shuffle_pi16\", c64);\n+}\n+\n+void\n+dump64_16 (char *buf, char *name, vecInWord x)\n+{\n+  int i;\n+  char *p = buf + strlen (buf);\n+\n+  sprintf (p, \"%s \", name);\n+  p += strlen (p);\n+\n+  for (i=0; i<4; i++)\n+    {\n+      sprintf (p, \"%4.4x \", x.s[i]);\n+      p += strlen (p);\n+    }\n+  strcat (p, \"\\n\");\n+}\n+\n+int\n+check (const char *input, const char *reference[])\n+{\n+  int broken, i, j, len;\n+  const char *p_input;\n+  char *p_comparison;\n+  int new_errors = 0;\n+\n+  p_comparison = &comparison[0];\n+  p_input = input;\n+\n+  for (i = 0; *reference[i] != '\\0'; i++)\n+    {\n+      broken = 0;\n+      len = strlen (reference[i]);\n+      for (j = 0; j < len; j++)\n+\t{\n+\t  /* Ignore the terminating NUL characters at the end of every string in 'reference[]'.  */\n+\t  if (!broken && *p_input != reference[i][j])\n+\t    {\n+\t      *p_comparison = '\\0';\n+\t      strcat (p_comparison, \" >>> \");\n+\t      p_comparison += strlen (p_comparison);\n+\t      new_errors++;\n+\t      broken = 1;\n+\t    }\n+\t  *p_comparison = *p_input;\n+\t  p_comparison++;\n+\t  p_input++;\n+\t}\n+      if (broken)\n+\t{\n+\t  *p_comparison = '\\0';\n+\t  strcat (p_comparison, \"expected:\\n\");\n+\t  strcat (p_comparison, reference[i]);\n+\t  p_comparison += strlen (p_comparison);\n+\t}\n+    }\n+  *p_comparison = '\\0';\n+  strcat (p_comparison, new_errors ? \"failure\\n\\n\" : \"O.K.\\n\\n\") ;\n+  errors += new_errors;\n+  return 0;\n+}"}]}