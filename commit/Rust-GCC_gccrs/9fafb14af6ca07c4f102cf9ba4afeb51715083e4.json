{"sha": "9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhZmIxNGFmNmNhMDdjNGYxMDJjZjliYTRhZmViNTE3MTUwODNlNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T11:56:04Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T11:56:04Z"}, "message": "tree-loop-distribution.c (params.h): Include header file.\n\n\t* tree-loop-distribution.c (params.h): Include header file.\n\t(MAX_DATAREFS_NUM, DR_INDEX): New macro.\n\t(datarefs_vec): New global var.\n\t(create_rdg_vertices): Use datarefs_vec directly.\n\t(free_rdg): Don't free data references.\n\t(build_rdg): Update use.  Don't free data references.\n\t(distribute_loop): Compute global variable for data references.\n\tBail out if there are too many data references.\n\nFrom-SVN: r249988", "tree": {"sha": "4dc745dda6f4ecef5a0b44879c20a4228febaeef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dc745dda6f4ecef5a0b44879c20a4228febaeef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fafb14af6ca07c4f102cf9ba4afeb51715083e4/comments", "author": null, "committer": null, "parents": [{"sha": "4084ea5fc528fd4a3c11b4aad15f5fa7bca0e699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4084ea5fc528fd4a3c11b4aad15f5fa7bca0e699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4084ea5fc528fd4a3c11b4aad15f5fa7bca0e699"}], "stats": {"total": 64, "additions": 50, "deletions": 14}, "files": [{"sha": "7b7d047f5d4e9f2cb7f22edc550ac85b4861c431", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fafb14af6ca07c4f102cf9ba4afeb51715083e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fafb14af6ca07c4f102cf9ba4afeb51715083e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "patch": "@@ -1,3 +1,14 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (params.h): Include header file.\n+\t(MAX_DATAREFS_NUM, DR_INDEX): New macro.\n+\t(datarefs_vec): New global var.\n+\t(create_rdg_vertices): Use datarefs_vec directly.\n+\t(free_rdg): Don't free data references.\n+\t(build_rdg): Update use.  Don't free data references.\n+\t(distribute_loop): Compute global variable for data references.\n+\tBail out if there are too many data references.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (loop_nest): New global var."}, {"sha": "a01355685ccf2ba8ffe9232cefb7d05f9df1739b", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fafb14af6ca07c4f102cf9ba4afeb51715083e4/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fafb14af6ca07c4f102cf9ba4afeb51715083e4/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "patch": "@@ -63,12 +63,22 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"params.h\"\n #include \"tree-vectorizer.h\"\n \n \n+#define MAX_DATAREFS_NUM \\\n+\t((unsigned) PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n+\n /* The loop (nest) to be distributed.  */\n static vec<loop_p> loop_nest;\n \n+/* Vector of data references in the loop to be distributed.  */\n+static vec<data_reference_p> datarefs_vec;\n+\n+/* Store index of data reference in aux field.  */\n+#define DR_INDEX(dr)      ((uintptr_t) (dr)->aux)\n+\n /* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n struct rdg_vertex\n {\n@@ -339,8 +349,7 @@ create_rdg_cd_edges (struct graph *rdg, control_dependences *cd, loop_p loop)\n    if that failed.  */\n \n static bool\n-create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop,\n-\t\t     vec<data_reference_p> *datarefs)\n+create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop)\n {\n   int i;\n   gimple *stmt;\n@@ -360,12 +369,12 @@ create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop,\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \tcontinue;\n \n-      unsigned drp = datarefs->length ();\n-      if (!find_data_references_in_stmt (loop, stmt, datarefs))\n+      unsigned drp = datarefs_vec.length ();\n+      if (!find_data_references_in_stmt (loop, stmt, &datarefs_vec))\n \treturn false;\n-      for (unsigned j = drp; j < datarefs->length (); ++j)\n+      for (unsigned j = drp; j < datarefs_vec.length (); ++j)\n \t{\n-\t  data_reference_p dr = (*datarefs)[j];\n+\t  data_reference_p dr = datarefs_vec[j];\n \t  if (DR_IS_READ (dr))\n \t    RDGV_HAS_MEM_READS (v) = true;\n \t  else\n@@ -449,7 +458,7 @@ free_rdg (struct graph *rdg)\n       if (v->data)\n \t{\n \t  gimple_set_uid (RDGV_STMT (v), -1);\n-\t  free_data_refs (RDGV_DATAREFS (v));\n+\t  (RDGV_DATAREFS (v)).release ();\n \t  free (v->data);\n \t}\n     }\n@@ -459,22 +468,20 @@ free_rdg (struct graph *rdg)\n \n /* Build the Reduced Dependence Graph (RDG) with one vertex per statement of\n    LOOP, and one edge per flow dependence or control dependence from control\n-   dependence CD.  */\n+   dependence CD.  During visiting each statement, data references are also\n+   collected and recorded in global data DATAREFS_VEC.  */\n \n static struct graph *\n build_rdg (struct loop *loop, control_dependences *cd)\n {\n   struct graph *rdg;\n-  vec<data_reference_p> datarefs;\n \n   /* Create the RDG vertices from the stmts of the loop nest.  */\n   auto_vec<gimple *, 10> stmts;\n   stmts_from_loop (loop, &stmts);\n   rdg = new_graph (stmts.length ());\n-  datarefs.create (10);\n-  if (!create_rdg_vertices (rdg, stmts, loop, &datarefs))\n+  if (!create_rdg_vertices (rdg, stmts, loop))\n     {\n-      datarefs.release ();\n       free_rdg (rdg);\n       return NULL;\n     }\n@@ -484,8 +491,6 @@ build_rdg (struct loop *loop, control_dependences *cd)\n   if (cd)\n     create_rdg_cd_edges (rdg, cd, loop);\n \n-  datarefs.release ();\n-\n   return rdg;\n }\n \n@@ -1518,6 +1523,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n       return 0;\n     }\n \n+  datarefs_vec.create (20);\n   rdg = build_rdg (loop, cd);\n   if (!rdg)\n     {\n@@ -1527,9 +1533,27 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \t\t loop->num);\n \n       loop_nest.release ();\n+      free_data_refs (datarefs_vec);\n+      return 0;\n+    }\n+\n+  if (datarefs_vec.length () > MAX_DATAREFS_NUM)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Loop %d not distributed: too many memory references.\\n\",\n+\t\t loop->num);\n+\n+      free_rdg (rdg);\n+      loop_nest.release ();\n+      free_data_refs (datarefs_vec);\n       return 0;\n     }\n \n+  data_reference_p dref;\n+  for (i = 0; datarefs_vec.iterate (i, &dref); ++i)\n+    dref->aux = (void *) (uintptr_t) i;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_rdg (dump_file, rdg);\n \n@@ -1735,6 +1759,7 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \n  ldist_done:\n   loop_nest.release ();\n+  free_data_refs (datarefs_vec);\n \n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     partition_free (partition);"}]}