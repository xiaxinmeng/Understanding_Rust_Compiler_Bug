{"sha": "6c69a0297aaba3d66ff1726005ba66e7e48d8a50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM2OWEwMjk3YWFiYTNkNjZmZjE3MjYwMDViYTY2ZTdlNDhkOGE1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-13T13:12:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-13T13:12:23Z"}, "message": "ipa-inline-transform.c (+can_remove_node_now_p_1): Break out from...\n\n\t* ipa-inline-transform.c (+can_remove_node_now_p_1): Break out from...\n\t(can_remove_node_now_p): ... here; handle same comdat groups.\n\t(clone_inlined_nodes): Update use of can_remove_node_now_p add TODO.\n\t(inline_call): Update use of can_remove_node_now_p.\n\nFrom-SVN: r174989", "tree": {"sha": "ca87ca86dc33c31ec407e6e9ad663cfd3f532ff1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca87ca86dc33c31ec407e6e9ad663cfd3f532ff1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c69a0297aaba3d66ff1726005ba66e7e48d8a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c69a0297aaba3d66ff1726005ba66e7e48d8a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c69a0297aaba3d66ff1726005ba66e7e48d8a50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c69a0297aaba3d66ff1726005ba66e7e48d8a50/comments", "author": null, "committer": null, "parents": [{"sha": "32dccc18a1f71026179fa086cc327cf5b2587db3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32dccc18a1f71026179fa086cc327cf5b2587db3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32dccc18a1f71026179fa086cc327cf5b2587db3"}], "stats": {"total": 47, "additions": 40, "deletions": 7}, "files": [{"sha": "d13e7fa4efc9321e1db56e8e39112e4de7607a1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c69a0297aaba3d66ff1726005ba66e7e48d8a50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c69a0297aaba3d66ff1726005ba66e7e48d8a50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c69a0297aaba3d66ff1726005ba66e7e48d8a50", "patch": "@@ -1,3 +1,10 @@\n+2011-06-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-transform.c (+can_remove_node_now_p_1): Break out from...\n+\t(can_remove_node_now_p): ... here; handle same comdat groups.\n+\t(clone_inlined_nodes): Update use of can_remove_node_now_p add TODO.\n+\t(inline_call): Update use of can_remove_node_now_p.\n+\n 2011-06-13  Kaushik Phatak <kaushik.phatak@kpitcummins.com>\n \n \t* config/h8300/h8300.md (bsetqi_msx, bclrqi_msx, bnotqi_msx): Added "}, {"sha": "2e1375437d5b1a71c7475eed9526278a7c067343", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c69a0297aaba3d66ff1726005ba66e7e48d8a50/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c69a0297aaba3d66ff1726005ba66e7e48d8a50/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=6c69a0297aaba3d66ff1726005ba66e7e48d8a50", "patch": "@@ -83,7 +83,7 @@ update_noncloned_frequencies (struct cgraph_node *node,\n    copy of function was removed.  */\n \n static bool\n-can_remove_node_now_p (struct cgraph_node *node)\n+can_remove_node_now_p_1 (struct cgraph_node *node)\n {\n   /* FIXME: When address is taken of DECL_EXTERNAL function we still\n      can remove its offline copy, but we would need to keep unanalyzed node in\n@@ -98,15 +98,34 @@ can_remove_node_now_p (struct cgraph_node *node)\n \t  && (!DECL_VIRTUAL_P (node->decl)\n \t      || (!DECL_COMDAT (node->decl)\n \t\t  && !DECL_EXTERNAL (node->decl)))\n-\t  /* Don't reuse if more than one function shares a comdat group.\n-\t     If the other function(s) are needed, we need to emit even\n-\t     this function out of line.  */\n-\t  && !node->same_comdat_group\n \t  /* During early inlining some unanalyzed cgraph nodes might be in the\n \t     callgraph and they might reffer the function in question.  */\n \t  && !cgraph_new_nodes);\n }\n \n+/* We are going to eliminate last direct call to NODE (or alias of it) via edge E.\n+   Verify that the NODE can be removed from unit and if it is contained in comdat\n+   group that the whole comdat group is removable.  */\n+\n+static bool\n+can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n+{\n+  struct cgraph_node *next;\n+  if (!can_remove_node_now_p_1 (node))\n+    return false;\n+\n+  /* When we see same comdat group, we need to be sure that all\n+     items can be removed.  */\n+  if (!node->same_comdat_group)\n+    return true;\n+  for (next = node->same_comdat_group;\n+       next != node; next = next->same_comdat_group)\n+    if (node->callers && node->callers != e\n+\t&& !can_remove_node_now_p_1 (node))\n+      return false;\n+  return true;\n+}\n+\n \n /* E is expected to be an edge being inlined.  Clone destination node of\n    the edge and redirect it to the new clone.\n@@ -128,8 +147,15 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  /* Recursive inlining never wants the master clone to\n \t     be overwritten.  */\n \t  && update_original\n-\t  && can_remove_node_now_p (e->callee))\n+\t  && can_remove_node_now_p (e->callee, e))\n \t{\n+\t  /* TODO: When callee is in a comdat group, we could remove all of it,\n+\t     including all inline clones inlined into it.  That would however\n+\t     need small function inlining to register edge removal hook to\n+\t     maintain the priority queue.\n+\n+\t     For now we keep the ohter functions in the group in program until\n+\t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n \t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n \t    {\n@@ -200,7 +226,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n       while (alias && alias != callee)\n \t{\n \t  if (!alias->callers\n-\t      && can_remove_node_now_p (alias))\n+\t      && can_remove_node_now_p (alias, e))\n \t    {\n \t      next_alias = cgraph_alias_aliased_node (alias);\n \t      cgraph_remove_node (alias);"}]}