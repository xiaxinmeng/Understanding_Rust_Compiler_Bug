{"sha": "c310f35c2845b7dc499753516222f8709b226615", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMxMGYzNWMyODQ1YjdkYzQ5OTc1MzUxNjIyMmY4NzA5YjIyNjYxNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-01-18T23:51:26Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-01-18T23:51:26Z"}, "message": "tree.c (count_functions, [...]): Remove.\n\n\t* tree.c (count_functions, bound_pmf_p, cp_is_overload_p,\n\tcp_update_decl_after_saving, name_p): Remove.\n\t* cp-tree.h: Remove the corresponding prototypes.\n\nFrom-SVN: r93869", "tree": {"sha": "e581c4b8b206f524cbce1bf4a379d8db9d3d24a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e581c4b8b206f524cbce1bf4a379d8db9d3d24a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c310f35c2845b7dc499753516222f8709b226615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c310f35c2845b7dc499753516222f8709b226615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c310f35c2845b7dc499753516222f8709b226615", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c310f35c2845b7dc499753516222f8709b226615/comments", "author": null, "committer": null, "parents": [{"sha": "e35b30c7774cff1c5f57f92daec1abee798d2c48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35b30c7774cff1c5f57f92daec1abee798d2c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e35b30c7774cff1c5f57f92daec1abee798d2c48"}], "stats": {"total": 73, "additions": 4, "deletions": 69}, "files": [{"sha": "dc11ad8a131f25aec0b8b26e59051ae3af0dc432", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c310f35c2845b7dc499753516222f8709b226615/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c310f35c2845b7dc499753516222f8709b226615/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c310f35c2845b7dc499753516222f8709b226615", "patch": "@@ -8,6 +8,10 @@\n \tRemove.\n \t* cp-tree.h: Remove the corresponding prototypes.\n \n+\t* tree.c (count_functions, bound_pmf_p, cp_is_overload_p,\n+\tcp_update_decl_after_saving, name_p): Remove.\n+\t* cp-tree.h: Remove the corresponding prototypes.\n+\n 2005-01-18  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c/19472"}, {"sha": "d0d0d70a8ea578feccac406819d1394d7e769902", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c310f35c2845b7dc499753516222f8709b226615/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c310f35c2845b7dc499753516222f8709b226615/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c310f35c2845b7dc499753516222f8709b226615", "patch": "@@ -4235,10 +4235,8 @@ extern tree build_cplus_staticfn_type\t\t(tree, tree, tree);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n-extern int count_functions\t\t\t(tree);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree get_first_fn\t\t\t(tree);\n-extern int bound_pmf_p\t\t\t\t(tree);\n extern tree ovl_cons                            (tree, tree);\n extern tree build_overload                      (tree, tree);\n extern tree function_arg_chain\t\t\t(tree);\n@@ -4269,7 +4267,6 @@ extern tree cp_build_qualified_type_real        (tree, int, tsubst_flags_t);\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), tf_error | tf_warning)\n extern special_function_kind special_function_p (tree);\n-extern bool name_p                              (tree);\n extern int count_trees                          (tree);\n extern int char_type_p                          (tree);\n extern void verify_stmt_tree                    (tree);\n@@ -4279,9 +4276,7 @@ extern tree cp_walk_subtrees (tree*, int*, walk_tree_fn,\n \t\t\t\t      void*, struct pointer_set_t*);\n extern int cp_cannot_inline_tree_fn (tree*);\n extern tree cp_add_pending_fn_decls (void*,tree);\n-extern int cp_is_overload_p (tree);\n extern int cp_auto_var_in_fn_p (tree,tree);\n-extern void cp_update_decl_after_saving (tree, void *);\n extern tree fold_if_not_in_template             (tree);\n \n /* in typeck.c */"}, {"sha": "0a0b3ec33a0676bf81fa14e8e3f81de2e949811a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c310f35c2845b7dc499753516222f8709b226615/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c310f35c2845b7dc499753516222f8709b226615/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c310f35c2845b7dc499753516222f8709b226615", "patch": "@@ -768,20 +768,6 @@ debug_binfo (tree elem)\n     }\n }\n \n-int\n-count_functions (tree t)\n-{\n-  int i;\n-  \n-  if (TREE_CODE (t) == FUNCTION_DECL)\n-    return 1;\n-  gcc_assert (TREE_CODE (t) == OVERLOAD);\n-  \n-  for (i = 0; t; t = OVL_CHAIN (t))\n-    i++;\n-  return i;\n-}\n-\n int\n is_overloaded_fn (tree x)\n {\n@@ -820,16 +806,6 @@ get_first_fn (tree from)\n   return OVL_CURRENT (from);\n }\n \n-/* Returns nonzero if T is a ->* or .* expression that refers to a\n-   member function.  */\n-\n-int\n-bound_pmf_p (tree t)\n-{\n-  return (TREE_CODE (t) == OFFSET_REF\n-\t  && TYPE_PTRMEMFUNC_P (TREE_TYPE (TREE_OPERAND (t, 1))));\n-}\n-\n /* Return a new OVL node, concatenating it with the old one.  */\n \n tree\n@@ -2059,16 +2035,6 @@ cp_add_pending_fn_decls (void* fns_p, tree prev_fn)\n   return prev_fn;\n }\n \n-/* Determine whether a tree node is an OVERLOAD node.  Used to decide\n-   whether to copy a node or to preserve its chain when inlining a\n-   function.  */\n-\n-int\n-cp_is_overload_p (tree t)\n-{\n-  return TREE_CODE (t) == OVERLOAD;\n-}\n-\n /* Determine whether VAR is a declaration of an automatic variable in\n    function FN.  */\n \n@@ -2079,20 +2045,6 @@ cp_auto_var_in_fn_p (tree var, tree fn)\n \t  && nonstatic_local_decl_p (var));\n }\n \n-/* FN body has been duplicated.  Update language specific fields.  */\n-\n-void\n-cp_update_decl_after_saving (tree fn,\n-                             void* decl_map_)\n-{\n-  splay_tree decl_map = (splay_tree)decl_map_;\n-  tree nrv = DECL_SAVED_FUNCTION_DATA (fn)->x_return_value;\n-  if (nrv)\n-    {\n-      DECL_SAVED_FUNCTION_DATA (fn)->x_return_value\n-\t= (tree) splay_tree_lookup (decl_map, (splay_tree_key) nrv)->value;\n-    }\n-}\n /* Initialize tree.c.  */\n \n void\n@@ -2131,22 +2083,6 @@ special_function_p (tree decl)\n   return sfk_none;\n }\n \n-/* Returns true if and only if NODE is a name, i.e., a node created\n-   by the parser when processing an id-expression.  */\n-\n-bool\n-name_p (tree node)\n-{\n-  if (TREE_CODE (node) == TEMPLATE_ID_EXPR)\n-    node = TREE_OPERAND (node, 0);\n-  return (/* An ordinary unqualified name.  */\n-\t  TREE_CODE (node) == IDENTIFIER_NODE\n-\t  /* A destructor name.  */\n-\t  || TREE_CODE (node) == BIT_NOT_EXPR\n-\t  /* A qualified name.  */\n-\t  || TREE_CODE (node) == SCOPE_REF);\n-}\n-\n /* Returns nonzero if TYPE is a character type, including wchar_t.  */\n \n int"}]}