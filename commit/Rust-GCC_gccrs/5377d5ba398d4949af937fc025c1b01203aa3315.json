{"sha": "5377d5ba398d4949af937fc025c1b01203aa3315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM3N2Q1YmEzOThkNDk0OWFmOTM3ZmMwMjVjMWIwMTIwM2FhMzMxNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-07-06T02:20:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-07-06T02:20:16Z"}, "message": "langhooks-def.h (LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P): Extra arg.\n\n\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P): Extra arg.\n\t* langhooks.h (var_mod_type_p): Likewise.\n\t* c-decl.c (finish_decl): Add extra arg to variably_modified_type_p.\n\t* expr.c (count_type_elements): Properly handle return from\n\tarray_type_nelts and properly test for overflow.\n\t* gimplify.c (gimplify_init_constructor): Properly handle return\n\tfrom array_type_nelts.\n\t(gimplify_addr_expr): Remove redundant clear of TREE_SIDE_EFFECTS.\n\t* integrate.c (copy_decl_for_inlining): Correct comments.\n\t* tree-inline.c (remap_decl): Update comments, remove dead code,\n\tand copy DECL_FIELD_OFFSET and DECL_QUALIFIER, if they exist.\n\t(remap_type): Only remap if variably modified by vars in function\n\tbeing inlined.\n\t(copy_body_r): Use compatible_type langhooks to see when can fold.\n\t(setup_one_parameter): Don't remap type.\n\t(inline_forbidden_p_1): Add arg to variably_modified_type_p.\n\t* tree.c (recompute_tree_invarant_for_addr_expr): Properly\n\tcompute TREE_INVARIANT for decl case.\n\t(find_var_from_fn): New function.\n\t(variably_modified_type_p): Add arg and call new function.\n\t* tree.h (variably_modified_type_p): Add extra arg.\n\n\t* cp/cp-lang.c (cp_var_mod_type_p): Add extra arg.\n\t* cp/decl.c (grokdeclarator): Extra arg to variably_modified_type_p.\n\t* cp/pt.c (check_instantiated_args, unify): Likewise.\n\nFrom-SVN: r84144", "tree": {"sha": "e36b5564359495ed12dc4107ed22bf65a3afddcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e36b5564359495ed12dc4107ed22bf65a3afddcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5377d5ba398d4949af937fc025c1b01203aa3315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5377d5ba398d4949af937fc025c1b01203aa3315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5377d5ba398d4949af937fc025c1b01203aa3315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5377d5ba398d4949af937fc025c1b01203aa3315/comments", "author": null, "committer": null, "parents": [{"sha": "aac1d259ac0a17ccce902d1f151422554ee5f2d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac1d259ac0a17ccce902d1f151422554ee5f2d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac1d259ac0a17ccce902d1f151422554ee5f2d8"}], "stats": {"total": 242, "additions": 145, "deletions": 97}, "files": [{"sha": "878bc56282bbc404e92022cf110175c9542be212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -1,3 +1,27 @@\n+2004-07-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* langhooks-def.h (LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P): Extra arg.\n+\t* langhooks.h (var_mod_type_p): Likewise.\n+\t* c-decl.c (finish_decl): Add extra arg to variably_modified_type_p.\n+\t* expr.c (count_type_elements): Properly handle return from\n+\tarray_type_nelts and properly test for overflow.\n+\t* gimplify.c (gimplify_init_constructor): Properly handle return\n+\tfrom array_type_nelts.\n+\t(gimplify_addr_expr): Remove redundant clear of TREE_SIDE_EFFECTS.\n+\t* integrate.c (copy_decl_for_inlining): Correct comments.\n+\t* tree-inline.c (remap_decl): Update comments, remove dead code,\n+\tand copy DECL_FIELD_OFFSET and DECL_QUALIFIER, if they exist.\n+\t(remap_type): Only remap if variably modified by vars in function\n+\tbeing inlined.\n+\t(copy_body_r): Use compatible_type langhooks to see when can fold.\n+\t(setup_one_parameter): Don't remap type.\n+\t(inline_forbidden_p_1): Add arg to variably_modified_type_p.\n+\t* tree.c (recompute_tree_invarant_for_addr_expr): Properly\n+\tcompute TREE_INVARIANT for decl case.\n+\t(find_var_from_fn): New function.\n+\t(variably_modified_type_p): Add arg and call new function.\n+\t* tree.h (variably_modified_type_p): Add extra arg.\n+\t\n 2004-07-05  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sparc.md (nonlocal_goto): Remove disabled code."}, {"sha": "3f6be35d91a7eb6b4efa09685f7b67d2f9e243a8", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -3037,7 +3037,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n-\t  && variably_modified_type_p (TREE_TYPE (decl)))\n+\t  && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n \tadd_stmt (build_stmt (DECL_EXPR, decl));\n \n       rest_of_decl_compilation (decl, NULL, DECL_FILE_SCOPE_P (decl), 0);"}, {"sha": "2d7f89dcb19ec1486819e80666eaf1731d5a94e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -1,3 +1,9 @@\n+2004-07-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cp-lang.c (cp_var_mod_type_p): Add extra arg.\n+\t* decl.c (grokdeclarator): Extra arg to variably_modified_type_p.\n+\t* pt.c (check_instantiated_args, unify): Likewise.\n+\n 2004-07-05  Phil Edwards  <phil@codesourcery.com>\n \n \t* Make-lang.in (check-c++, lang_checks):  Add some comments."}, {"sha": "5e403d86d97d3ba43311d4f50bab34352f386265", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -38,7 +38,7 @@ static HOST_WIDE_INT cxx_get_alias_set (tree);\n static bool cxx_warn_unused_global_decl (tree);\n static tree cp_expr_size (tree);\n static size_t cp_tree_size (enum tree_code);\n-static bool cp_var_mod_type_p (tree);\n+static bool cp_var_mod_type_p (tree, tree);\n static int cxx_types_compatible_p (tree, tree);\n static void cxx_initialize_diagnostics (diagnostic_context *);\n \n@@ -307,17 +307,19 @@ cp_tree_size (enum tree_code code)\n }\n \n /* Returns true if T is a variably modified type, in the sense of C99.\n+   FN is as passed to variably_modified_p.\n    This routine needs only check cases that cannot be handled by the\n-   language-independent logic in tree-inline.c.  */\n+   language-independent logic in tree.c.  */\n \n static bool\n-cp_var_mod_type_p (tree type)\n+cp_var_mod_type_p (tree type, tree fn)\n {\n   /* If TYPE is a pointer-to-member, it is variably modified if either\n      the class or the member are variably modified.  */\n   if (TYPE_PTR_TO_MEMBER_P (type))\n-    return (variably_modified_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n-\t    || variably_modified_type_p (TYPE_PTRMEM_POINTED_TO_TYPE (type)));\n+    return (variably_modified_type_p (TYPE_PTRMEM_CLASS_TYPE (type), fn)\n+\t    || variably_modified_type_p (TYPE_PTRMEM_POINTED_TO_TYPE (type),\n+\t\t\t\t\t fn));\n \n   /* All other types are not variably modified.  */\n   return false;"}, {"sha": "25ecca7ab1cb7c3c09b0dc1a45db223a68a357a6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -7329,7 +7329,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n   if ((decl_context == FIELD || decl_context == PARM)\n       && !processing_template_decl \n-      && variably_modified_type_p (type))\n+      && variably_modified_type_p (type, NULL_TREE))\n     {\n       if (decl_context == FIELD)\n \terror (\"data member may not have variably modified type `%T'\", type);"}, {"sha": "5a644b421a8b0256eabcfbf8214ab8c7372de83a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -8557,7 +8557,7 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n \t    }\n \t  /* In order to avoid all sorts of complications, we do not\n \t     allow variably-modified types as template arguments.  */\n-\t  else if (variably_modified_type_p (t))\n+\t  else if (variably_modified_type_p (t, NULL_TREE))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"`%T' is a variably modified type\", t);\n@@ -9732,7 +9732,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t     the bound of the array will not be computable in an\n \t     instantiation.  Besides, such types are not allowed in\n \t     ISO C++, so we can do as we please here.  */\n-\t  if (variably_modified_type_p (arg))\n+\t  if (variably_modified_type_p (arg, NULL_TREE))\n \t    return 1;\n \t}\n "}, {"sha": "6e4f5c739a48daca85b7817cef29c69f7d454d7f", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -4497,11 +4497,11 @@ count_type_elements (tree type)\n \ttree telts = array_type_nelts (type);\n \tif (telts && host_integerp (telts, 1))\n \t  {\n-\t    HOST_WIDE_INT n = tree_low_cst (telts, 1);\n+\t    HOST_WIDE_INT n = tree_low_cst (telts, 1) + 1;\n \t    HOST_WIDE_INT m = count_type_elements (TREE_TYPE (type));\n \t    if (n == 0)\n \t      return 0;\n-\t    if (max / n < m)\n+\t    else if (max / n > m)\n \t      return n * m;\n \t  }\n \treturn -1;"}, {"sha": "0493efa0b379b91bb7d0483ff627069f7154d74c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -2514,7 +2514,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t      {\n \t\ttree nelts = array_type_nelts (type);\n \t\tif (!host_integerp (nelts, 1)\n-\t\t    || tree_low_cst (nelts, 1) != len)\n+\t\t    || tree_low_cst (nelts, 1) + 1 != len)\n \t\t  cleared = 1;;\n \t      }\n \t    else if (len != fields_length (type))\n@@ -3050,12 +3050,8 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \t\t\t   is_gimple_addr_expr_arg, fb_either);\n       if (ret != GS_ERROR)\n \t{\n-\t  /* At this point, the argument of the ADDR_EXPR should be\n-\t     sufficiently simple that there are never side effects.  */\n-\t  /* ??? Could split out the decision code from build1 to verify.  */\n-\t  TREE_SIDE_EFFECTS (expr) = 0;\n-\n-\t  /* Make sure TREE_INVARIANT/TREE_CONSTANT is set properly.  */\n+\t  /* Make sure TREE_INVARIANT, TREE_CONSTANT, and TREE_SIDE_EFFECTS\n+\t     is set properly.  */\n \t  recompute_tree_invarant_for_addr_expr (expr);\n \n \t  /* Mark the RHS addressable.  */"}, {"sha": "892f4534f8121320a5685a2a8e822f3f2e21e956", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -105,9 +105,8 @@ function_attribute_inlinable_p (tree fndecl)\n   return true;\n }\n \f\n-/* Copy NODE (which must be a DECL, but not a PARM_DECL).  The DECL\n-   originally was in the FROM_FN, but now it will be in the\n-   TO_FN.  */\n+/* Copy NODE (which must be a DECL).  The DECL originally was in the FROM_FN,\n+   but now it will be in the TO_FN.  */\n \n tree\n copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n@@ -132,7 +131,7 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n       else\n \ttype = TREE_TYPE (decl);\n \n-      /* For a parameter, we must make an equivalent VAR_DECL, not a\n+      /* For a parameter or result, we must make an equivalent VAR_DECL, not a\n \t new PARM_DECL.  */\n       copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n       if (!invisiref)"}, {"sha": "f3182603a6d8451e502fe59b995ed31557be70b0", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -157,7 +157,7 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n   lhd_tree_inlining_anon_aggr_type_p\n #define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P \\\n-  hook_bool_tree_false\n+  hook_bool_tree_tree_false\n #define LANG_HOOKS_TREE_INLINING_START_INLINING \\\n   lhd_tree_inlining_start_inlining\n #define LANG_HOOKS_TREE_INLINING_END_INLINING \\"}, {"sha": "ac785feb4acc6752595d0a2307f0de0bcedab7ad", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -43,7 +43,7 @@ struct lang_hooks_for_tree_inlining\n   tree (*copy_res_decl_for_inlining) (tree, tree, tree,\n \t\t\t\t      void *, int *, tree);\n   int (*anon_aggr_type_p) (tree);\n-  bool (*var_mod_type_p) (tree);\n+  bool (*var_mod_type_p) (tree, tree);\n   int (*start_inlining) (tree);\n   void (*end_inlining) (tree);\n   tree (*convert_parm_for_inlining) (tree, tree, tree, int);"}, {"sha": "fcda4ad5f7713041a687de40271f6680e450b39b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -155,35 +155,21 @@ insert_decl_map (inline_data *id, tree key, tree value)\n \t\t       (splay_tree_value) value);\n }\n \n-/* Remap DECL during the copying of the BLOCK tree for the function.  */\n+/* Remap DECL during the copying of the BLOCK tree for the function. \n+   We are only called to remap local variables in the current function.  */\n \n static tree\n remap_decl (tree decl, inline_data *id)\n {\n-  splay_tree_node n;\n-  tree fn;\n-\n-  /* We only remap local variables in the current function.  */\n-  fn = VARRAY_TOP_TREE (id->fns);\n-#if 0\n-  /* We need to remap statics, too, so that they get expanded even if the\n-     inline function is never emitted out of line.  We might as well also\n-     remap extern decls so that they show up in the debug info.  */\n-  if (! lang_hooks.tree_inlining.auto_var_in_fn_p (decl, fn))\n-    return NULL_TREE;\n-#endif\n-\n-  /* See if we have remapped this declaration.  */\n-  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+  splay_tree_node n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+  tree fn = VARRAY_TOP_TREE (id->fns);\n \n-  /* If we didn't already have an equivalent for this declaration,\n-     create one now.  */\n+  /* See if we have remapped this declaration.  If we didn't already have an\n+     equivalent for this declaration, create one now.  */\n   if (!n)\n     {\n-      tree t;\n-\n       /* Make a copy of the variable or label.  */\n-      t = copy_decl_for_inlining (decl, fn, VARRAY_TREE (id->fns, 0));\n+      tree t = copy_decl_for_inlining (decl, fn, VARRAY_TREE (id->fns, 0));\n \n       /* Remap types, if necessary.  */\n       TREE_TYPE (t) = remap_type (TREE_TYPE (t), id);\n@@ -197,6 +183,14 @@ remap_decl (tree decl, inline_data *id)\n       walk_tree (&DECL_SIZE (t), copy_body_r, id, NULL);\n       walk_tree (&DECL_SIZE_UNIT (t), copy_body_r, id, NULL);\n \n+      /* If fields, do likewise for offset and qualifier. */\n+      if (TREE_CODE (t) == FIELD_DECL)\n+\t{\n+\t  walk_tree (&DECL_FIELD_OFFSET (t), copy_body_r, id, NULL);\n+\t  if (TREE_CODE (DECL_CONTEXT (t)) == QUAL_UNION_TYPE)\n+\t    walk_tree (&DECL_QUALIFIER (t), copy_body_r, id, NULL);\n+\t}\n+\n #if 0\n       /* FIXME handle anon aggrs.  */\n       if (! DECL_NAME (t) && TREE_TYPE (t)\n@@ -243,8 +237,9 @@ remap_type (tree type, inline_data *id)\n   if (node)\n     return (tree) node->value;\n \n-  /* The type only needs remapping if it's variably modified.  */\n-  if (! variably_modified_type_p (type))\n+  /* The type only needs remapping if it's variably modified by a variable\n+     in the function we are inlining.  */\n+  if (! variably_modified_type_p (type, VARRAY_TOP_TREE (id->fns)))\n     {\n       insert_decl_map (id, type, type);\n       return type;\n@@ -458,12 +453,8 @@ copy_bind_expr (tree *tp, int *walk_subtrees, inline_data *id)\n static tree\n copy_body_r (tree *tp, int *walk_subtrees, void *data)\n {\n-  inline_data* id;\n-  tree fn;\n-\n-  /* Set up.  */\n-  id = (inline_data *) data;\n-  fn = VARRAY_TOP_TREE (id->fns);\n+  inline_data *id = (inline_data *) data;\n+  tree fn = VARRAY_TOP_TREE (id->fns);\n \n #if 0\n   /* All automatic variables should have a DECL_CONTEXT indicating\n@@ -507,7 +498,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n   /* Local variables and labels need to be replaced by equivalent\n      variables.  We don't want to copy static variables; there's only\n      one of those, no matter how many times we inline the containing\n-     function.  */\n+     function.  Similarly for globals from an outer function.  */\n   else if (lang_hooks.tree_inlining.auto_var_in_fn_p (*tp, fn))\n     {\n       tree new_decl;\n@@ -603,13 +594,13 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      value = (tree) n->value;\n \t      if (TREE_CODE (value) == INDIRECT_REF)\n \t\t{\n-\t\t  /* Assume that the argument types properly match the\n-\t\t     parameter types.  We can't compare them well enough\n-\t\t     without a comptypes langhook, and we don't want to\n-\t\t     call convert and introduce a NOP_EXPR to convert\n-\t\t     between two equivalent types (i.e. that only differ\n-\t\t     in use of typedef names).  */\n-\t\t  *tp = TREE_OPERAND (value, 0);\n+\t\t  if  (!lang_hooks.types_compatible_p\n+\t\t       (TREE_TYPE (*tp), TREE_TYPE (TREE_OPERAND (value, 0))))\n+\t\t    *tp = fold_convert (TREE_TYPE (*tp),\n+\t\t\t\t\tTREE_OPERAND (value, 0));\n+\t\t  else\n+\t\t    *tp = TREE_OPERAND (value, 0);\n+\n \t\t  return copy_body_r (tp, walk_subtrees, data);\n \t\t}\n \t    }\n@@ -626,7 +617,9 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    {\n \t      value = (tree) n->value;\n \t      STRIP_NOPS (value);\n-\t      if (TREE_CODE (value) == ADDR_EXPR)\n+\t      if (TREE_CODE (value) == ADDR_EXPR\n+\t\t  && (lang_hooks.types_compatible_p\n+\t\t      (TREE_TYPE (*tp), TREE_TYPE (TREE_OPERAND (value, 0)))))\n \t\t{\n \t\t  *tp = TREE_OPERAND (value, 0);\n \t\t  return copy_body_r (tp, walk_subtrees, data);\n@@ -739,9 +732,10 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n \t}\n     }\n \n-  /* Make an equivalent VAR_DECL with the remapped type.  */\n+  /* Make an equivalent VAR_DECL.  Note that we must NOT remap the type\n+     here since the type of this decl must be visible to the calling\n+     function. */\n   var = copy_decl_for_inlining (p, fn, VARRAY_TREE (id->fns, 0));\n-  TREE_TYPE (var) = remap_type (TREE_TYPE (var), id);\n \n   /* See if the frontend wants to pass this by invisible reference.  If\n      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n@@ -1072,7 +1066,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t then the type node for S doesn't get adjusted properly when\n \t F is inlined, and we abort in find_function_data.  */\n       for (t = TYPE_FIELDS (node); t; t = TREE_CHAIN (t))\n-\tif (variably_modified_type_p (TREE_TYPE (t)))\n+\tif (variably_modified_type_p (TREE_TYPE (t), NULL))\n \t  {\n \t    inline_forbidden_reason\n \t      = N_(\"%Jfunction '%F' can never be inlined \""}, {"sha": "410acdfb5521c9ce7f2b4915a57bdfe6d9bf78fe", "filename": "gcc/tree.c", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -2352,16 +2352,20 @@ do { tree _node = (NODE); \\\n     }\n \t      \n   /* Now see what's inside.  If it's an INDIRECT_REF, copy our properties from\n-     it.  If it's a decl, it's definitely invariant and it's constant if the\n-     decl is static.  (Taking the address of a volatile variable is not\n-     volatile.)  If it's a constant, the address is both invariant and\n-     constant.  Otherwise it's neither.  */\n+     it.  If it's a decl, it's invariant and constant if the decl is static.\n+     It's also invariant if it's a decl in the current function.  (Taking the\n+     address of a volatile variable is not volatile.)  If it's a constant,\n+     the address is both invariant and constant.  Otherwise it's neither.  */\n   if (TREE_CODE (node) == INDIRECT_REF)\n     UPDATE_TITCSE (node);\n   else if (DECL_P (node))\n     {\n-      if (!staticp (node))\n+      if (staticp (node))\n+\t;\n+      else if (decl_function_context (node) == current_function_decl)\n \ttc = false;\n+      else\n+\tti = tc = false;\n     }\n   else if (TREE_CODE_CLASS (TREE_CODE (node)) == 'c')\n     ;\n@@ -4685,21 +4689,50 @@ int_fits_type_p (tree c, tree type)\n     }\n }\n \n+/* Subprogram of following function.  Called by walk_tree.\n+\n+   Return *TP if it is an automatic variable or parameter of the\n+   function passed in as DATA.  */\n+\n+static tree\n+find_var_from_fn (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree fn = (tree) data;\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  else if (DECL_P (*tp) && lang_hooks.tree_inlining.auto_var_in_fn_p (*tp, fn))\n+    return *tp;\n+\n+  return NULL_TREE;\n+}\n+\n /* Returns true if T is, contains, or refers to a type with variable\n-   size.  This concept is more general than that of C99 'variably\n-   modified types': in C99, a struct type is never variably modified\n-   because a VLA may not appear as a structure member.  However, in\n-   GNU C code like:\n+   size.  If FN is nonzero, only return true if a modifier of the type\n+   or position of FN is a variable or parameter inside FN.\n+\n+   This concept is more general than that of C99 'variably modified types':\n+   in C99, a struct type is never variably modified because a VLA may not\n+   appear as a structure member.  However, in GNU C code like:\n \n      struct S { int i[f()]; };\n \n    is valid, and other languages may define similar constructs.  */\n \n bool\n-variably_modified_type_p (tree type)\n+variably_modified_type_p (tree type, tree fn)\n {\n   tree t;\n \n+/* Test if T is either variable (if FN is zero) or an expression containing\n+   a variable in FN.  */\n+#define RETURN_TRUE_IF_VAR(T)\t\t\t\t\t\t\\\n+  do { tree _t = (T);\t\t\t\t\t\t\t\\\n+    if (_t && _t != error_mark_node && TREE_CODE (_t) != INTEGER_CST\t\\\n+        && (!fn || walk_tree (&_t, find_var_from_fn, fn, NULL)))\t\\\n+      return true;  } while (0)\n+\n   if (type == error_mark_node)\n     return false;\n \n@@ -4708,9 +4741,8 @@ variably_modified_type_p (tree type)\n      We do not yet have a representation of the C99 '[*]' syntax.\n      When a representation is chosen, this function should be modified\n      to test for that case as well.  */\n-  t = TYPE_SIZE (type);\n-  if (t && t != error_mark_node && TREE_CODE (t) != INTEGER_CST)\n-    return true;\n+  RETURN_TRUE_IF_VAR (TYPE_SIZE (type));\n+  RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT(type));\n \n   switch (TREE_CODE (type))\n     {\n@@ -4719,21 +4751,21 @@ variably_modified_type_p (tree type)\n     case ARRAY_TYPE:\n     case SET_TYPE:\n     case VECTOR_TYPE:\n-      if (variably_modified_type_p (TREE_TYPE (type)))\n+      if (variably_modified_type_p (TREE_TYPE (type), fn))\n \treturn true;\n       break;\n \n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       /* If TYPE is a function type, it is variably modified if any of the\n          parameters or the return type are variably modified.  */\n-      if (variably_modified_type_p (TREE_TYPE (type)))\n+      if (variably_modified_type_p (TREE_TYPE (type), fn))\n \t  return true;\n \n       for (t = TYPE_ARG_TYPES (type);\n \t   t && t != void_list_node;\n \t   t = TREE_CHAIN (t))\n-\tif (variably_modified_type_p (TREE_VALUE (t)))\n+\tif (variably_modified_type_p (TREE_VALUE (t), fn))\n \t  return true;\n       break;\n \n@@ -4744,13 +4776,8 @@ variably_modified_type_p (tree type)\n     case CHAR_TYPE:\n       /* Scalar types are variably modified if their end points\n \t aren't constant.  */\n-      t = TYPE_MIN_VALUE (type);\n-      if (t && t != error_mark_node && TREE_CODE (t) != INTEGER_CST)\n-\treturn true;\n-\n-      t = TYPE_MAX_VALUE (type);\n-      if (t && t != error_mark_node && TREE_CODE (t) != INTEGER_CST)\n-\treturn true;\n+      RETURN_TRUE_IF_VAR (TYPE_MIN_VALUE (type));\n+      RETURN_TRUE_IF_VAR (TYPE_MAX_VALUE (type));\n       break;\n \n     case RECORD_TYPE:\n@@ -4763,14 +4790,12 @@ variably_modified_type_p (tree type)\n       for (t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n \tif (TREE_CODE (t) == FIELD_DECL)\n \t  {\n-\t    tree t1 = DECL_FIELD_OFFSET (t);\n+\t    RETURN_TRUE_IF_VAR (DECL_FIELD_OFFSET (t));\n+\t    RETURN_TRUE_IF_VAR (DECL_SIZE (t));\n+\t    RETURN_TRUE_IF_VAR (DECL_SIZE_UNIT (t));\n \n-\t    if (t1 && t1 != error_mark_node && TREE_CODE (t1) != INTEGER_CST)\n-\t      return true;\n-\n-\t    t1 = DECL_SIZE (t);\n-\t    if (t1 && t1 != error_mark_node && TREE_CODE (t1) != INTEGER_CST)\n-\t      return true;\n+\t    if (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t      RETURN_TRUE_IF_VAR (DECL_QUALIFIER (t));\n \t  }\n \tbreak;\n \n@@ -4780,7 +4805,9 @@ variably_modified_type_p (tree type)\n \n   /* The current language may have other cases to check, but in general,\n      all other types are not variably modified.  */\n-  return lang_hooks.tree_inlining.var_mod_type_p (type);\n+  return lang_hooks.tree_inlining.var_mod_type_p (type, fn);\n+\n+#undef RETURN_TRUE_IF_VAR\n }\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or"}, {"sha": "d8fed6c61ed4a05152a4237610f7368ccc1a7506", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5377d5ba398d4949af937fc025c1b01203aa3315/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5377d5ba398d4949af937fc025c1b01203aa3315", "patch": "@@ -3469,7 +3469,7 @@ extern int objects_must_conflict_p (tree, tree);\n /* In tree.c */\n extern int really_constant_p (tree);\n extern int int_fits_type_p (tree, tree);\n-extern bool variably_modified_type_p (tree);\n+extern bool variably_modified_type_p (tree, tree);\n extern int tree_log2 (tree);\n extern int tree_floor_log2 (tree);\n extern int simple_cst_equal (tree, tree);"}]}