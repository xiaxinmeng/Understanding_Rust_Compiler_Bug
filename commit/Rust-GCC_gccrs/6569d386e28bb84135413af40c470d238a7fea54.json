{"sha": "6569d386e28bb84135413af40c470d238a7fea54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU2OWQzODZlMjhiYjg0MTM1NDEzYWY0MGM0NzBkMjM4YTdmZWE1NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-19T21:33:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-19T21:33:21Z"}, "message": "tree.c (substitute_in_expr): Tweak and reformat.\n\n\t* tree.c (substitute_in_expr) <COMPONENT_REF>: Tweak and reformat.\n\t<tcc_vl_exp>: Call process_call_operands on the new CALL_EXPR.\n\tPropagate the TREE_READONLY flag without overwriting it.\n\t(substitute_placeholder_in_expr) <tcc_vl_exp>: Likewise.\n\tPropagate the TREE_READONLY flag onto the result.\n\t(process_call_operands): Move around.  Use correct constant value.\n\nFrom-SVN: r148729", "tree": {"sha": "dfb7b06c5ec8138aeeeb8d117e191a4058bd79e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfb7b06c5ec8138aeeeb8d117e191a4058bd79e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6569d386e28bb84135413af40c470d238a7fea54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6569d386e28bb84135413af40c470d238a7fea54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6569d386e28bb84135413af40c470d238a7fea54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6569d386e28bb84135413af40c470d238a7fea54/comments", "author": null, "committer": null, "parents": [{"sha": "ce41c38bfcb5f4f45791fd13b52dcd687834c818", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce41c38bfcb5f4f45791fd13b52dcd687834c818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce41c38bfcb5f4f45791fd13b52dcd687834c818"}], "stats": {"total": 188, "additions": 109, "deletions": 79}, "files": [{"sha": "c946499cf506bba1220dd4d098a992dce6c02113", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6569d386e28bb84135413af40c470d238a7fea54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6569d386e28bb84135413af40c470d238a7fea54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6569d386e28bb84135413af40c470d238a7fea54", "patch": "@@ -1,3 +1,12 @@\n+2009-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.c (substitute_in_expr) <COMPONENT_REF>: Tweak and reformat.\n+\t<tcc_vl_exp>: Call process_call_operands on the new CALL_EXPR.\n+\tPropagate the TREE_READONLY flag without overwriting it.\n+\t(substitute_placeholder_in_expr) <tcc_vl_exp>: Likewise.\n+\tPropagate the TREE_READONLY flag onto the result.\n+\t(process_call_operands): Move around.  Use correct constant value.\n+\n 2009-06-19  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/40482"}, {"sha": "139c1e55757239ca8d844eb13e63638b6cd55bfd", "filename": "gcc/tree.c", "status": "modified", "additions": 100, "deletions": 79, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6569d386e28bb84135413af40c470d238a7fea54/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6569d386e28bb84135413af40c470d238a7fea54/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6569d386e28bb84135413af40c470d238a7fea54", "patch": "@@ -2473,6 +2473,36 @@ tree_node_structure (const_tree t)\n       gcc_unreachable ();\n     }\n }\n+\n+/* Set various status flags when building a CALL_EXPR object T.  */\n+\n+static void\n+process_call_operands (tree t)\n+{\n+  bool side_effects = TREE_SIDE_EFFECTS (t);\n+  int i;\n+\n+  if (!side_effects)\n+    for (i = 1; i < TREE_OPERAND_LENGTH (t); i++)\n+      {\n+\ttree op = TREE_OPERAND (t, i);\n+\tif (op && TREE_SIDE_EFFECTS (op))\n+\t  {\n+\t    side_effects = true;\n+\t    break;\n+\t  }\n+      }\n+\n+  if (!side_effects)\n+    {\n+      /* Calls have side-effects, except those to const or pure functions.  */\n+      i = call_expr_flags (t);\n+      if ((i & ECF_LOOPING_CONST_OR_PURE) || !(i & (ECF_CONST | ECF_PURE)))\n+\tside_effects = true;\n+    }\n+\n+  TREE_SIDE_EFFECTS (t) = side_effects;\n+}\n \f\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.  */\n@@ -2660,7 +2690,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree op0, op1, op2, op3;\n-  tree new_tree, inner;\n+  tree new_tree;\n \n   /* We handle TREE_LIST and COMPONENT_REF separately.  */\n   if (code == TREE_LIST)\n@@ -2673,27 +2703,32 @@ substitute_in_expr (tree exp, tree f, tree r)\n       return tree_cons (TREE_PURPOSE (exp), op1, op0);\n     }\n   else if (code == COMPONENT_REF)\n-   {\n-     /* If this expression is getting a value from a PLACEHOLDER_EXPR\n-\tand it is the right field, replace it with R.  */\n-     for (inner = TREE_OPERAND (exp, 0);\n-\t  REFERENCE_CLASS_P (inner);\n-\t  inner = TREE_OPERAND (inner, 0))\n-       ;\n-     if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n-\t && TREE_OPERAND (exp, 1) == f)\n-       return r;\n-\n-     /* If this expression hasn't been completed let, leave it alone.  */\n-     if (TREE_CODE (inner) == PLACEHOLDER_EXPR && TREE_TYPE (inner) == 0)\n-       return exp;\n-\n-     op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n-     if (op0 == TREE_OPERAND (exp, 0))\n-       return exp;\n-\n-     new_tree = fold_build3 (COMPONENT_REF, TREE_TYPE (exp),\n-\t\t\top0, TREE_OPERAND (exp, 1), NULL_TREE);\n+    {\n+      tree inner;\n+\n+      /* If this expression is getting a value from a PLACEHOLDER_EXPR\n+\t and it is the right field, replace it with R.  */\n+      for (inner = TREE_OPERAND (exp, 0);\n+\t   REFERENCE_CLASS_P (inner);\n+\t   inner = TREE_OPERAND (inner, 0))\n+\t;\n+\n+      /* The field.  */\n+      op1 = TREE_OPERAND (exp, 1);\n+\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)\n+\treturn r;\n+\n+      /* If this expression hasn't been completed let, leave it alone.  */\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))\n+\treturn exp;\n+\n+      op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      new_tree\n+\t= fold_build3 (COMPONENT_REF, TREE_TYPE (exp), op0, op1, NULL_TREE);\n    }\n   else\n     switch (TREE_CODE_CLASS (code))\n@@ -2754,7 +2789,8 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t\t&& op3 == TREE_OPERAND (exp, 3))\n \t      return exp;\n \n-\t    new_tree = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n+\t    new_tree\n+\t      = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n \t    break;\n \n \t  default:\n@@ -2764,23 +2800,28 @@ substitute_in_expr (tree exp, tree f, tree r)\n \n       case tcc_vl_exp:\n \t{\n-\t  tree copy = NULL_TREE;\n \t  int i;\n \n+\t  new_tree = NULL_TREE;\n+\n \t  for (i = 1; i < TREE_OPERAND_LENGTH (exp); i++)\n \t    {\n \t      tree op = TREE_OPERAND (exp, i);\n \t      tree new_op = SUBSTITUTE_IN_EXPR (op, f, r);\n \t      if (new_op != op)\n \t\t{\n-\t\t  if (!copy)\n-\t\t    copy = copy_node (exp);\n-\t\t  TREE_OPERAND (copy, i) = new_op;\n+\t\t  if (!new_tree)\n+\t\t    new_tree = copy_node (exp);\n+\t\t  TREE_OPERAND (new_tree, i) = new_op;\n \t\t}\n \t    }\n \n-\t  if (copy)\n-\t    new_tree = fold (copy);\n+\t  if (new_tree)\n+\t    {\n+\t      new_tree = fold (new_tree);\n+\t      if (TREE_CODE (new_tree) == CALL_EXPR)\n+\t\tprocess_call_operands (new_tree);\n+\t    }\n \t  else\n \t    return exp;\n \t}\n@@ -2790,7 +2831,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \tgcc_unreachable ();\n       }\n \n-  TREE_READONLY (new_tree) = TREE_READONLY (exp);\n+  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n   return new_tree;\n }\n \n@@ -2802,6 +2843,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree op0, op1, op2, op3;\n+  tree new_tree;\n \n   /* If this is a PLACEHOLDER_EXPR, see if we find a corresponding type\n      in the chain of OBJ.  */\n@@ -2877,17 +2919,19 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n \t    if (op0 == TREE_OPERAND (exp, 0))\n \t      return exp;\n-\t    else\n-\t      return fold_build1 (code, TREE_TYPE (exp), op0);\n+\n+\t    new_tree = fold_build1 (code, TREE_TYPE (exp), op0);\n+\t    break;\n \n \t  case 2:\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n \t    op1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 1), obj);\n \n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n \t      return exp;\n-\t    else\n-\t      return fold_build2 (code, TREE_TYPE (exp), op0, op1);\n+\n+\t    new_tree = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n+\t    break;\n \n \t  case 3:\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n@@ -2897,8 +2941,9 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n \t\t&& op2 == TREE_OPERAND (exp, 2))\n \t      return exp;\n-\t    else\n-\t      return fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n+\n+\t    new_tree = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n+\t    break;\n \n \t  case 4:\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n@@ -2910,8 +2955,10 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t\t&& op2 == TREE_OPERAND (exp, 2)\n \t\t&& op3 == TREE_OPERAND (exp, 3))\n \t      return exp;\n-\t    else\n-\t      return fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n+\n+\t    new_tree\n+\t      = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n+\t    break;\n \n \t  default:\n \t    gcc_unreachable ();\n@@ -2920,30 +2967,39 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \n       case tcc_vl_exp:\n \t{\n-\t  tree copy = NULL_TREE;\n \t  int i;\n \n+\t  new_tree = NULL_TREE;\n+\n \t  for (i = 1; i < TREE_OPERAND_LENGTH (exp); i++)\n \t    {\n \t      tree op = TREE_OPERAND (exp, i);\n \t      tree new_op = SUBSTITUTE_PLACEHOLDER_IN_EXPR (op, obj);\n \t      if (new_op != op)\n \t\t{\n-\t\t  if (!copy)\n-\t\t    copy = copy_node (exp);\n-\t\t  TREE_OPERAND (copy, i) = new_op;\n+\t\t  if (!new_tree)\n+\t\t    new_tree = copy_node (exp);\n+\t\t  TREE_OPERAND (new_tree, i) = new_op;\n \t\t}\n \t    }\n \n-\t  if (copy)\n-\t    return fold (copy);\n+\t  if (new_tree)\n+\t    {\n+\t      new_tree = fold (new_tree);\n+\t      if (TREE_CODE (new_tree) == CALL_EXPR)\n+\t\tprocess_call_operands (new_tree);\n+\t    }\n \t  else\n \t    return exp;\n \t}\n+\tbreak;\n \n       default:\n \tgcc_unreachable ();\n       }\n+\n+  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n+  return new_tree;\n }\n \f\n /* Stabilize a reference so that we can use it any number of times\n@@ -8183,41 +8239,6 @@ build_omp_clause (location_t loc, enum omp_clause_code code)\n   return t;\n }\n \n-/* Set various status flags when building a CALL_EXPR object T.  */\n-\n-static void\n-process_call_operands (tree t)\n-{\n-  bool side_effects;\n-\n-  side_effects = TREE_SIDE_EFFECTS (t);\n-  if (!side_effects)\n-    {\n-      int i, n;\n-      n = TREE_OPERAND_LENGTH (t);\n-      for (i = 1; i < n; i++)\n-\t{\n-\t  tree op = TREE_OPERAND (t, i);\n-\t  if (op && TREE_SIDE_EFFECTS (op))\n-\t    {\n-\t      side_effects = 1;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  if (!side_effects)\n-    {\n-      int i;\n-\n-      /* Calls have side-effects, except those to const or\n-\t pure functions.  */\n-      i = call_expr_flags (t);\n-      if ((i & ECF_LOOPING_CONST_OR_PURE) || !(i & (ECF_CONST | ECF_PURE)))\n-\tside_effects = 1;\n-    }\n-  TREE_SIDE_EFFECTS (t) = side_effects;\n-}\n-\n /* Build a tcc_vl_exp object with code CODE and room for LEN operands.  LEN\n    includes the implicit operand count in TREE_OPERAND 0, and so must be >= 1.\n    Except for the CODE and operand count field, other storage for the"}]}