{"sha": "48f25c7ad60d9bbfba2926e7ece89d8c4568c557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhmMjVjN2FkNjBkOWJiZmJhMjkyNmU3ZWNlODlkOGM0NTY4YzU1Nw==", "commit": {"author": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-09-10T22:20:15Z"}, "committer": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-09-10T22:20:15Z"}, "message": "(shorten_branches): Do shorten branches with delay slots\n\tif the number of delay slots is constant.\n\nFrom-SVN: r2098", "tree": {"sha": "085d7912e332a366b6169fe11315d31a422a28dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/085d7912e332a366b6169fe11315d31a422a28dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48f25c7ad60d9bbfba2926e7ece89d8c4568c557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f25c7ad60d9bbfba2926e7ece89d8c4568c557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f25c7ad60d9bbfba2926e7ece89d8c4568c557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f25c7ad60d9bbfba2926e7ece89d8c4568c557/comments", "author": null, "committer": null, "parents": [{"sha": "ed50ab354cc6a70b81a14fc72298d4ac7af07b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed50ab354cc6a70b81a14fc72298d4ac7af07b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed50ab354cc6a70b81a14fc72298d4ac7af07b36"}], "stats": {"total": 60, "additions": 50, "deletions": 10}, "files": [{"sha": "166c5279a635ca23df78f9a02dc41a3acea0206a", "filename": "gcc/final.c", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f25c7ad60d9bbfba2926e7ece89d8c4568c557/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f25c7ad60d9bbfba2926e7ece89d8c4568c557/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=48f25c7ad60d9bbfba2926e7ece89d8c4568c557", "patch": "@@ -527,13 +527,15 @@ shorten_branches (first)\n       else if (GET_CODE (body) == SEQUENCE)\n \t{\n \t  int i;\n-\n+\t  int const_delay_slots;\n+#ifdef DELAY_SLOTS\n+\t  const_delay_slots = const_num_delay_slots (XVECEXP (body, 0, 1));\n+#else\n+\t  const_delay_slots = 0;\n+#endif\n \t  /* Inside a delay slot sequence, we do not do any branch shortening\n-\t     (on the only machine known to have both variable-length branches\n-\t     and delay slots, the ROMP, branch-with-execute is the same size\n-\t     as the maximum branch anyway).  So we only have to handle normal\n-\t     insns (actually, reorg never puts ASM insns in a delay slot, but\n-\t     we don't take advantage of that knowledge here).  */\n+\t     if the shortening could change the number of delay slots\n+\t     of the branch. */\n \t  for (i = 0; i < XVECLEN (body, 0); i++)\n \t    {\n \t      rtx inner_insn = XVECEXP (body, 0, i);\n@@ -547,7 +549,16 @@ shorten_branches (first)\n \t\tinner_length = insn_default_length (inner_insn);\n \t      \n \t      insn_lengths[inner_uid] = inner_length;\n-\t      varying_length[inner_uid] = 0;\n+\t      if (const_delay_slots)\n+\t\t{\n+\t\t  if ((varying_length[inner_uid]\n+\t\t       = insn_variable_length_p (inner_insn)) != 0)\n+\t\t    varying_length[uid] = 1;\n+\t\t  insn_addresses[inner_uid] = (insn_current_address +\n+\t\t\t\t\t       insn_lengths[uid]);\n+\t\t}\n+\t      else\n+\t\tvarying_length[inner_uid] = 0;\n \t      insn_lengths[uid] += inner_length;\n \t    }\n \t}\n@@ -572,16 +583,45 @@ shorten_branches (first)\n       something_changed = 0;\n       for (insn_current_address = FIRST_INSN_ADDRESS, insn = first;\n \t   insn != 0;\n-\t   insn_current_address += insn_lengths[uid], insn = NEXT_INSN (insn))\n+\t   insn = NEXT_INSN (insn))\n \t{\n \t  int new_length;\n \n \t  uid = INSN_UID (insn);\n \t  insn_addresses[uid] = insn_current_address;\n \t  if (! varying_length[uid])\n-\t    continue;\n+\t    {\n+\t      insn_current_address += insn_lengths[uid];\n+\t      continue;\n+\t    }\n+\t  if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t    {\n+\t      int i;\n+\t      \n+\t      body = PATTERN (insn);\n+\t      new_length = 0;\n+\t      for (i = 0; i < XVECLEN (body, 0); i++)\n+\t\t{\n+\t\t  rtx inner_insn = XVECEXP (body, 0, i);\n+\t\t  int inner_uid = INSN_UID (inner_insn);\n+\t\t  int inner_length;\n \n-\t  new_length = insn_current_length (insn);\n+\t\t  insn_addresses[inner_uid] = insn_current_address;\n+\t\t  inner_length = insn_current_length (inner_insn);\n+\t\t  if (inner_length != insn_lengths[inner_uid])\n+\t\t    {\n+\t\t      insn_lengths[inner_uid] = inner_length;\n+\t\t      something_changed = 1;\n+\t\t    }\n+\t\t  insn_current_address += insn_lengths[inner_uid];\n+\t\t  new_length += inner_length;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      new_length = insn_current_length (insn);\n+\t      insn_current_address += new_length;\n+\t    }\n \t  if (new_length != insn_lengths[uid])\n \t    {\n \t      insn_lengths[uid] = new_length;"}]}