{"sha": "dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiMjFmMzdmZGU0ZjllMTFlOWIzYjZiNmVhNmRjOWQ1ZmJlZDY0NA==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:24Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:24Z"}, "message": "VAX: Rationalize expression and address costs\n\nExpression costs are required to be given in terms of COSTS_N_INSNS (n),\nwhich is defined to stand for the count of single fast instructions, and\nactually returns `n * 4'.  The VAX backend however instead operates on\nnaked numbers, causing an anomaly for the integer const zero rtx, where\nthe cost given is 4 as opposed to 1 for integers in the [1:63] range, as\nwell as -1 for comparisons.  This is because the value of 0 returned by\n`vax_rtx_costs' is converted to COSTS_N_INSNS (1) in `pattern_cost':\n\n  return cost > 0 ? cost : COSTS_N_INSNS (1);\n\nConsequently, where feasible, 1 or -1 are preferred over 0 by the middle\nend causing code pessimization, e.g. rather than producing this:\n\n\tsubl2 $4,%sp\n\tmovl 4(%ap),%r0\n\tjgtr .L2\n\taddl2 $2,%r0\n.L2:\n\tret\n\nor this:\n\n\tsubl2 $4,%sp\n\taddl3 4(%ap),8(%ap),%r0\n\tjlss .L6\n\taddl2 $2,%r0\n.L6:\n\tret\n\ncode is produced like this:\n\n\tsubl2 $4,%sp\n\tmovl 4(%ap),%r0\n\tcmpl %r0,$1\n\tjgeq .L2\n\taddl2 $2,%r0\n.L2:\n\tret\n\nor this:\n\n\tsubl2 $4,%sp\n\taddl3 4(%ap),8(%ap),%r0\n\tcmpl %r0,$-1\n\tjleq .L6\n\taddl2 $2,%r0\n.L6:\n\tret\n\nfrom this:\n\nint\ncompare_mov (int x)\n{\n  if (x > 0)\n    return x;\n  else\n    return x + 2;\n}\n\nand this:\n\nint\ncompare_add (int x, int y)\n{\n  int z;\n\n  z = x + y;\n  if (z < 0)\n    return z;\n  else\n    return z + 2;\n}\n\nrespectively, which is slower and larger both at a time.\n\nFurthermore once the backend is converted to MODE_CC this anomaly makes\nit usually impossible to remove redundant comparisons in the comparison\nelimination pass, because most VAX instructions set the condition codes\nas per the relation of the instruction's result to 0 and not -1.\n\nThe middle end has some other assumptions as to rtx costs being given in\nterms of COSTS_N_INSNS, so wrap all the VAX rtx costs then as they stand\ninto COSTS_N_INSNS invocations, effectively scaling the costs by 4 while\npreserving their relative values, except for the integer const zero rtx\ngiven the value of `COSTS_N_INSNS (1) / 2', half of a fast instruction\n(this can be further halved if needed in the future).\n\nAdjust address costs likewise so that they remain proportional to the\nnew absolute values of rtx costs.\n\nCode size stats are as follows, collected from 17639 executables built\nin `check-c' GCC testing:\n\n              samples average  median\n--------------------------------------\nregressions      1420  0.400%  0.195%\nunchanged       13811  0.000%  0.000%\nprogressions     2408 -0.504% -0.201%\n--------------------------------------\ntotal           17639 -0.037%  0.000%\n\nwith a small number of outliers only (over 5% size change):\n\nold     new     change  %change filename\n----------------------------------------------------\n4991    5249     258     5.1693 981001-1.exe\n2637    2777     140     5.3090 interchange-6.exe\n2187    2307     120     5.4869 sprintf.x7\n3969    4197     228     5.7445 pr28982a.exe\n8264    8816     552     6.6795 vector-compare-1.exe\n5199    5575     376     7.2321 pr28982b.exe\n2113    2411     298    14.1031 20030323-1.exe\n2113    2411     298    14.1031 20030323-1.exe\n2113    2411     298    14.1031 20030323-1.exe\n\nso it seems we are looking good, and we have complementing reductions\nto compensate:\n\nold     new     change  %change filename\n----------------------------------------------------\n2919    2631    -288    -9.8663 pr57521.exe\n3427    3167    -260    -7.5868 sabd_1.exe\n2985    2765    -220    -7.3701 ssad-run.exe\n2985    2765    -220    -7.3701 ssad-run.exe\n2985    2765    -220    -7.3701 usad-run.exe\n2985    2765    -220    -7.3701 usad-run.exe\n4509    4253    -256    -5.6775 vshuf-v2sf.exe\n4541    4285    -256    -5.6375 vshuf-v2si.exe\n4673    4417    -256    -5.4782 vshuf-v2df.exe\n2993    2841    -152    -5.0785 abs-2.x4\n2993    2841    -152    -5.0785 abs-3.x4\n\nThis actually causes `loop-8.c' to regress:\n\nFAIL: gcc.dg/loop-8.c scan-rtl-dump-times loop2_invariant \"Decided\" 1\nFAIL: gcc.dg/loop-8.c scan-rtl-dump-not loop2_invariant \"without introducing a new temporary register\"\n\nbut upon a closer inspection this is a red herring.  Old code looks as\nfollows:\n\n\t.file\t\"loop-8.c\"\n\t.text\n\t.align 1\n.globl f\n\t.type\tf, @function\nf:\n\t.word 0\n\tsubl2 $4,%sp\n\tmovl 4(%ap),%r2\n\tmovl 8(%ap),%r3\n\tmovl $42,(%r2)\n\tclrl %r0\n\tmovl $42,%r1\n\tmovl %r1,%r4\n\tjbr .L2\n.L5:\n\tmovl %r4,%r1\n.L2:\n\tmovl %r1,(%r3)[%r0]\n\tincl %r0\n\tcmpl %r0,$100\n\tjeql .L6\n\tmovl $42,(%r2)[%r0]\n\tbicl3 $-2,%r0,%r1\n\tjeql .L5\n\tmovl %r0,%r1\n\tjbr .L2\n.L6:\n\tret\n\t.size\tf, .-f\n\nwhile new one is like below:\n\n\t.file\t\"loop-8.c\"\n\t.text\n\t.align 1\n.globl f\n\t.type\tf, @function\nf:\n\t.word 0\n\tsubl2 $4,%sp\n\tmovl 4(%ap),%r2\n\tmovl $42,(%r2)+\n\tmovl 8(%ap),%r1\n\tclrl %r0\n\tmovl $42,%r3\n\tmovzbl $100,%r4\n\tmovl %r3,%r5\n\tjbr .L2\n.L5:\n\tmovl %r5,%r3\n.L2:\n\tmovl %r3,(%r1)+\n\tincl %r0\n\tcmpl %r0,%r4\n\tjeql .L6\n\tmovl $42,(%r2)+\n\tbicl3 $-2,%r0,%r3\n\tjeql .L5\n\tmovl %r0,%r3\n\tjbr .L2\n.L6:\n\tret\n\t.size\tf, .-f\n\nand is clearly better: not only it is smaller, but it also uses the\npost-increment rather than indexed addressing mode in the loop, of\nwhich the former comes for free in terms of both performance and code\nsize while the latter causes an extra byte per operand to be produced\nfor the index register and also incurs an execution penalty for the\nextra address calculation.\n\nExclude the case from VAX testing then, as already done for some other\ntargets and discussed with commit d242fdaec186 (\"gcc.dg/loop-8.c: Skip\nfor mmix.\").\n\n\tgcc/\n\t* config/vax/vax.c (vax_address_cost): Express the cost in terms\n\tof COSTS_N_INSNS.\n\t(vax_rtx_costs): Likewise.\n\n\tgcc/testsuite/\n\t* gcc.dg/loop-8.c: Exclude for `vax-*-*'.\n\t* gcc.target/vax/compare-add-zero.c: New test.\n\t* gcc.target/vax/compare-mov-zero.c: New test.", "tree": {"sha": "14d88856c2d52b48d55c91dd18c3c720f594171a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14d88856c2d52b48d55c91dd18c3c720f594171a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/comments", "author": null, "committer": null, "parents": [{"sha": "7920fe3d81ece3a23360ce0d8899f1568a9037c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7920fe3d81ece3a23360ce0d8899f1568a9037c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7920fe3d81ece3a23360ce0d8899f1568a9037c8"}], "stats": {"total": 163, "additions": 109, "deletions": 54}, "files": [{"sha": "b6c2210ca6beaa52a45f4c173779032894666f62", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "patch": "@@ -748,7 +748,7 @@ vax_address_cost (rtx x, machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  addr_space_t as ATTRIBUTE_UNUSED,\n \t\t  bool speed ATTRIBUTE_UNUSED)\n {\n-  return (1 + (REG_P (x) ? 0 : vax_address_cost_1 (x)));\n+  return COSTS_N_INSNS (1 + (REG_P (x) ? 0 : vax_address_cost_1 (x)));\n }\n \n /* Cost of an expression on a VAX.  This version has costs tuned for the\n@@ -778,12 +778,13 @@ vax_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case CONST_INT:\n       if (INTVAL (x) == 0)\n \t{\n-\t  *total = 0;\n+\t  *total = COSTS_N_INSNS (1) / 2;\n \t  return true;\n \t}\n       if (outer_code == AND)\n \t{\n-\t  *total = ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077) ? 1 : 2;\n+\t  *total = ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077\n+\t\t    ? COSTS_N_INSNS (1) : COSTS_N_INSNS (2));\n \t  return true;\n \t}\n       if ((unsigned HOST_WIDE_INT) INTVAL (x) <= 077\n@@ -792,120 +793,122 @@ vax_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t  || ((outer_code == PLUS || outer_code == MINUS)\n \t      && (unsigned HOST_WIDE_INT) -INTVAL (x) <= 077))\n \t{\n-\t  *total = 1;\n+\t  *total = COSTS_N_INSNS (1);\n \t  return true;\n \t}\n       /* FALLTHRU */\n \n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      *total = 3;\n+      *total = COSTS_N_INSNS (3);\n       return true;\n \n     case CONST_DOUBLE:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t*total = vax_float_literal (x) ? 5 : 8;\n+\t*total = vax_float_literal (x) ? COSTS_N_INSNS (5) : COSTS_N_INSNS (8);\n       else\n \t*total = ((CONST_DOUBLE_HIGH (x) == 0\n \t\t   && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x) < 64)\n \t\t  || (outer_code == PLUS\n \t\t      && CONST_DOUBLE_HIGH (x) == -1\n-\t\t      && (unsigned HOST_WIDE_INT)-CONST_DOUBLE_LOW (x) < 64))\n-\t\t ? 2 : 5;\n+\t\t      && (unsigned HOST_WIDE_INT)-CONST_DOUBLE_LOW (x) < 64)\n+\t\t  ? COSTS_N_INSNS (2) : COSTS_N_INSNS (5));\n       return true;\n \n     case POST_INC:\n-      *total = 2;\n-      return true;\t\t/* Implies register operand.  */\n+      *total = COSTS_N_INSNS (2);\n+      return true;\t\t\t/* Implies register operand.  */\n \n     case PRE_DEC:\n-      *total = 3;\n-      return true;\t\t/* Implies register operand.  */\n+      *total = COSTS_N_INSNS (3);\n+      return true;\t\t\t/* Implies register operand.  */\n \n     case MULT:\n       switch (mode)\n \t{\n \tcase E_DFmode:\n-\t  *total = 16;\t\t/* 4 on VAX 9000 */\n+\t  *total = COSTS_N_INSNS (16);\t/* 4 on VAX 9000 */\n \t  break;\n \tcase E_SFmode:\n-\t  *total = 9;\t\t/* 4 on VAX 9000, 12 on VAX 2 */\n+\t  *total = COSTS_N_INSNS (9);\t/* 4 on VAX 9000, 12 on VAX 2 */\n \t  break;\n \tcase E_DImode:\n-\t  *total = 16;\t\t/* 6 on VAX 9000, 28 on VAX 2 */\n+\t  *total = COSTS_N_INSNS (16);\t/* 6 on VAX 9000, 28 on VAX 2 */\n \t  break;\n \tcase E_SImode:\n \tcase E_HImode:\n \tcase E_QImode:\n-\t  *total = 10;\t\t/* 3-4 on VAX 9000, 20-28 on VAX 2 */\n+\t  *total = COSTS_N_INSNS (10);\t/* 3-4 on VAX 9000, 20-28 on VAX 2 */\n \t  break;\n \tdefault:\n-\t  *total = MAX_COST;\t/* Mode is not supported.  */\n+\t  *total = MAX_COST;\t\t/* Mode is not supported.  */\n \t  return true;\n \t}\n       break;\n \n     case UDIV:\n       if (mode != SImode)\n \t{\n-\t  *total = MAX_COST;\t/* Mode is not supported.  */\n+\t  *total = MAX_COST;\t\t/* Mode is not supported.  */\n \t  return true;\n \t}\n-      *total = 17;\n+      *total = COSTS_N_INSNS (17);\n       break;\n \n     case DIV:\n       if (mode == DImode)\n-\t*total = 30;\t\t/* Highly variable.  */\n+\t*total = COSTS_N_INSNS (30);\t/* Highly variable.  */\n       else if (mode == DFmode)\n \t/* divide takes 28 cycles if the result is not zero, 13 otherwise */\n-\t*total = 24;\n+\t*total = COSTS_N_INSNS (24);\n       else\n-\t*total = 11;\t\t/* 25 on VAX 2 */\n+\t*total = COSTS_N_INSNS (11);\t/* 25 on VAX 2 */\n       break;\n \n     case MOD:\n-      *total = 23;\n+      *total = COSTS_N_INSNS (23);\n       break;\n \n     case UMOD:\n       if (mode != SImode)\n \t{\n-\t  *total = MAX_COST;\t/* Mode is not supported.  */\n+\t  *total = MAX_COST;\t\t/* Mode is not supported.  */\n \t  return true;\n \t}\n-      *total = 29;\n+      *total = COSTS_N_INSNS (29);\n       break;\n \n     case FLOAT:\n-      *total = (6\t\t/* 4 on VAX 9000 */\n-\t\t+ (mode == DFmode) + (GET_MODE (XEXP (x, 0)) != SImode));\n+      *total = COSTS_N_INSNS (6\t\t/* 4 on VAX 9000 */\n+\t\t\t      + (mode == DFmode)\n+\t\t\t      + (GET_MODE (XEXP (x, 0)) != SImode));\n       break;\n \n     case FIX:\n-      *total = 7;\t\t/* 17 on VAX 2 */\n+      *total = COSTS_N_INSNS (7);\t/* 17 on VAX 2 */\n       break;\n \n     case ASHIFT:\n     case LSHIFTRT:\n     case ASHIFTRT:\n       if (mode == DImode)\n-\t*total = 12;\n+\t*total = COSTS_N_INSNS (12);\n       else\n-\t*total = 10;\t\t/* 6 on VAX 9000 */\n+\t*total = COSTS_N_INSNS (10);\t/* 6 on VAX 9000 */\n       break;\n \n     case ROTATE:\n     case ROTATERT:\n-      *total = 6;\t\t/* 5 on VAX 2, 4 on VAX 9000 */\n+      *total = COSTS_N_INSNS (6);\t/* 5 on VAX 2, 4 on VAX 9000 */\n       if (CONST_INT_P (XEXP (x, 1)))\n \tfmt = \"e\"; \t\t/* all constant rotate counts are short */\n       break;\n \n     case PLUS:\n     case MINUS:\n-      *total = (mode == DFmode) ? 13 : 8; /* 6/8 on VAX 9000, 16/15 on VAX 2 */\n+      *total = (mode == DFmode\t\t/* 6/8 on VAX 9000, 16/15 on VAX 2 */\n+\t\t? COSTS_N_INSNS (13) : COSTS_N_INSNS (8));\n       /* Small integer operands can use subl2 and addl2.  */\n       if ((CONST_INT_P (XEXP (x, 1)))\n \t  && (unsigned HOST_WIDE_INT)(INTVAL (XEXP (x, 1)) + 63) < 127)\n@@ -914,55 +917,55 @@ vax_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \n     case IOR:\n     case XOR:\n-      *total = 3;\n+      *total = COSTS_N_INSNS (3);\n       break;\n \n     case AND:\n       /* AND is special because the first operand is complemented.  */\n-      *total = 3;\n+      *total = COSTS_N_INSNS (3);\n       if (CONST_INT_P (XEXP (x, 0)))\n \t{\n \t  if ((unsigned HOST_WIDE_INT)~INTVAL (XEXP (x, 0)) > 63)\n-\t    *total = 4;\n+\t    *total = COSTS_N_INSNS (4);\n \t  fmt = \"e\";\n \t  i = 1;\n \t}\n       break;\n \n     case NEG:\n       if (mode == DFmode)\n-\t*total = 9;\n+\t*total = COSTS_N_INSNS (9);\n       else if (mode == SFmode)\n-\t*total = 6;\n+\t*total = COSTS_N_INSNS (6);\n       else if (mode == DImode)\n-\t*total = 4;\n+\t*total = COSTS_N_INSNS (4);\n       else\n-\t*total = 2;\n+\t*total = COSTS_N_INSNS (2);\n       break;\n \n     case NOT:\n-      *total = 2;\n+      *total = COSTS_N_INSNS (2);\n       break;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n-      *total = 15;\n+      *total = COSTS_N_INSNS (15);\n       break;\n \n     case MEM:\n       if (mode == DImode || mode == DFmode)\n-\t*total = 5;\t\t/* 7 on VAX 2 */\n+\t*total = COSTS_N_INSNS (5);\t/* 7 on VAX 2 */\n       else\n-\t*total = 3;\t\t/* 4 on VAX 2 */\n+\t*total = COSTS_N_INSNS (3);\t/* 4 on VAX 2 */\n       x = XEXP (x, 0);\n       if (!REG_P (x) && GET_CODE (x) != POST_INC)\n-\t*total += vax_address_cost_1 (x);\n+\t*total += COSTS_N_INSNS (vax_address_cost_1 (x));\n       return true;\n \n     case FLOAT_EXTEND:\n     case FLOAT_TRUNCATE:\n     case TRUNCATE:\n-      *total = 3;\t\t/* FIXME: Costs need to be checked  */\n+      *total = COSTS_N_INSNS (3);\t/* FIXME: Costs need to be checked  */\n       break;\n \n     default:\n@@ -993,40 +996,41 @@ vax_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \tcase CONST_INT:\n \t  if ((unsigned HOST_WIDE_INT)INTVAL (op) > 63\n \t      && mode != QImode)\n-\t    *total += 1;\t/* 2 on VAX 2 */\n+\t    *total += COSTS_N_INSNS (1);\t/* 2 on VAX 2 */\n \t  break;\n \tcase CONST:\n \tcase LABEL_REF:\n \tcase SYMBOL_REF:\n-\t  *total += 1;\t\t/* 2 on VAX 2 */\n+\t  *total += COSTS_N_INSNS (1);\t\t/* 2 on VAX 2 */\n \t  break;\n \tcase CONST_DOUBLE:\n \t  if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT)\n \t    {\n \t      /* Registers are faster than floating point constants -- even\n \t\t those constants which can be encoded in a single byte.  */\n \t      if (vax_float_literal (op))\n-\t\t*total += 1;\n+\t\t*total += COSTS_N_INSNS (1);\n \t      else\n-\t\t*total += (GET_MODE (x) == DFmode) ? 3 : 2;\n+\t\t*total += (GET_MODE (x) == DFmode\n+\t\t\t   ? COSTS_N_INSNS (3) : COSTS_N_INSNS (2));\n \t    }\n \t  else\n \t    {\n \t      if (CONST_DOUBLE_HIGH (op) != 0\n \t\t  || (unsigned HOST_WIDE_INT)CONST_DOUBLE_LOW (op) > 63)\n-\t\t*total += 2;\n+\t\t*total += COSTS_N_INSNS (2);\n \t    }\n \t  break;\n \tcase MEM:\n-\t  *total += 1;\t\t/* 2 on VAX 2 */\n+\t  *total += COSTS_N_INSNS (1);\t\t/* 2 on VAX 2 */\n \t  if (!REG_P (XEXP (op, 0)))\n-\t    *total += vax_address_cost_1 (XEXP (op, 0));\n+\t    *total += COSTS_N_INSNS (vax_address_cost_1 (XEXP (op, 0)));\n \t  break;\n \tcase REG:\n \tcase SUBREG:\n \t  break;\n \tdefault:\n-\t  *total += 1;\n+\t  *total += COSTS_N_INSNS (1);\n \t  break;\n \t}\n     }"}, {"sha": "90ea1c4552438c53c672582791e16501960c79eb", "filename": "gcc/testsuite/gcc.dg/loop-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Ftestsuite%2Fgcc.dg%2Floop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Ftestsuite%2Fgcc.dg%2Floop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-8.c?ref=dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-O1 -fdump-rtl-loop2_invariant\" } */\n-/* { dg-skip-if \"unexpected IV\" { \"hppa*-*-* mips*-*-* visium-*-* powerpc*-*-* riscv*-*-* mmix-*-*\" } } */\n+/* { dg-skip-if \"unexpected IV\" { \"hppa*-*-* mips*-*-* visium-*-* powerpc*-*-* riscv*-*-* mmix-*-* vax-*-*\" } } */\n /* Load immediate on condition is available from z13 on and prevents moving\n    the load out of the loop, so always run this test with -march=zEC12 that\n    does not have load immediate on condition.  */"}, {"sha": "97d4c535c73fafe752495de59045fb17505c50fe", "filename": "gcc/testsuite/gcc.target/vax/compare-add-zero.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Ftestsuite%2Fgcc.target%2Fvax%2Fcompare-add-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Ftestsuite%2Fgcc.target%2Fvax%2Fcompare-add-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fvax%2Fcompare-add-zero.c?ref=dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int\n+compare_add (int x, int y)\n+{\n+  int z;\n+\n+  z = x + y;\n+  if (z < 0)\n+    return z;\n+  else\n+    return z + 2;\n+}\n+\n+/* Expect assembly like:\n+\n+\taddl3 4(%ap),8(%ap),%r0\n+\tjlss .L1\n+\taddl2 $2,%r0\n+.L1:\n+\n+A reverse branch may be used at some optimization levels.  */\n+\n+/* Make sure the comparison is made against 0 rather than -1.  */\n+/* { dg-final { scan-assembler-not \"\\tj(gtr|leq) \" } } */\n+/* { dg-final { scan-assembler \"\\tj(geq|lss) \" } } */"}, {"sha": "c802049f58e648eeeb88697796d4176b86faf4d2", "filename": "gcc/testsuite/gcc.target/vax/compare-mov-zero.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Ftestsuite%2Fgcc.target%2Fvax%2Fcompare-mov-zero.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644/gcc%2Ftestsuite%2Fgcc.target%2Fvax%2Fcompare-mov-zero.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fvax%2Fcompare-mov-zero.c?ref=dfb21f37fde4f9e11e9b3b6b6ea6dc9d5fbed644", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+int\n+compare_mov (int x)\n+{\n+  if (x > 0)\n+    return x;\n+  else\n+    return x + 2;\n+}\n+\n+/* Expect assembly like:\n+\n+\tmovl 4(%ap),%r0\n+\tjgtr .L2\n+\taddl2 $2,%r0\n+.L2:\n+\n+A reverse branch may be used at some optimization levels.  */\n+\n+/* Make sure the comparison is made against 0 rather than 1.  */\n+/* { dg-final { scan-assembler-not \"\\tj(geq|lss) \" } } */\n+/* { dg-final { scan-assembler \"\\tj(gtr|leq) \" } } */"}]}