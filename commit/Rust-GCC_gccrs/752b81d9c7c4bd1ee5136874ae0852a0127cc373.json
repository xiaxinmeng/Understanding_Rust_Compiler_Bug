{"sha": "752b81d9c7c4bd1ee5136874ae0852a0127cc373", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUyYjgxZDljN2M0YmQxZWU1MTM2ODc0YWUwODUyYTAxMjdjYzM3Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T13:10:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T13:10:28Z"}, "message": "[multiple changes]\n\n2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n\n\t* xgnatugn.adb: Remove obsolete comments.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* back_end.ads, back_end.adb: Minor reformatting.\n\t* set_targ.ads, set_targ.adb: New files.\n\n2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_case.adb (Check_Against_Predicate): New routine.\n\t(Check_Choices): When the type covered by the list of choices\n\tis a static subtype with a static predicate, check all choices\n\tagains the predicate.\n\t(Issue_Msg): All versions removed.\n\t(Missing_Choice): New routines.\n\t* sem_ch4.adb: Code and comment reformatting.\n\t(Analyze_Case_Expression): Do not check the choices when the case\n\texpression is being preanalyzed and the type of the expression\n\tis a subtype with a static predicate.\n\t(Has_Static_Predicate): New routine.\n\t* sem_ch13.adb: Code and comment reformatting.\t(Build_Range):\n\tAlways build a range even if the low and hi bounds denote the\n\tsame value. This is needed by the machinery in Check_Choices.\n\t(Build_Static_Predicate): Always build a range even if the low and\n\thi bounds denote the same value. This is needed by the machinery\n\tin Check_Choices.\n\nFrom-SVN: r197789", "tree": {"sha": "2ff1bfe09d4c66c1b6f53715c52673ba86c791ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ff1bfe09d4c66c1b6f53715c52673ba86c791ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/752b81d9c7c4bd1ee5136874ae0852a0127cc373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752b81d9c7c4bd1ee5136874ae0852a0127cc373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/752b81d9c7c4bd1ee5136874ae0852a0127cc373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752b81d9c7c4bd1ee5136874ae0852a0127cc373/comments", "author": null, "committer": null, "parents": [{"sha": "4b342b91f00c9b8a1768c906edea9407ea18f76c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b342b91f00c9b8a1768c906edea9407ea18f76c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b342b91f00c9b8a1768c906edea9407ea18f76c"}], "stats": {"total": 1847, "additions": 1631, "deletions": 216}, "files": [{"sha": "4852ff9fa11a6f7acdfb9fef7059ed0f14db69ce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -1,3 +1,32 @@\n+2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* xgnatugn.adb: Remove obsolete comments.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* back_end.ads, back_end.adb: Minor reformatting.\n+\t* set_targ.ads, set_targ.adb: New files.\n+\n+2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_case.adb (Check_Against_Predicate): New routine.\n+\t(Check_Choices): When the type covered by the list of choices\n+\tis a static subtype with a static predicate, check all choices\n+\tagains the predicate.\n+\t(Issue_Msg): All versions removed.\n+\t(Missing_Choice): New routines.\n+\t* sem_ch4.adb: Code and comment reformatting.\n+\t(Analyze_Case_Expression): Do not check the choices when the case\n+\texpression is being preanalyzed and the type of the expression\n+\tis a subtype with a static predicate.\n+\t(Has_Static_Predicate): New routine.\n+\t* sem_ch13.adb: Code and comment reformatting.\t(Build_Range):\n+\tAlways build a range even if the low and hi bounds denote the\n+\tsame value. This is needed by the machinery in Check_Choices.\n+\t(Build_Static_Predicate): Always build a range even if the low and\n+\thi bounds denote the same value. This is needed by the machinery\n+\tin Check_Choices.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* einfo.ads, sem_util.adb, exp_ch6.adb, xgnatugn.adb: Minor"}, {"sha": "fafbbc4dc2f3073b9f25e659dc55621f544937f5", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -347,7 +347,6 @@ package body Back_End is\n    procedure Register_Back_End_Types (Call_Back : Register_Type_Proc) is\n       procedure Enumerate_Modes (Call_Back : Register_Type_Proc);\n       pragma Import (C, Enumerate_Modes, \"enumerate_modes\");\n-\n    begin\n       Enumerate_Modes (Call_Back);\n    end Register_Back_End_Types;"}, {"sha": "4f30b039f39f6254850736a8b5d150c41b1585e9", "filename": "gcc/ada/back_end.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fback_end.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fback_end.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.ads?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,7 +24,8 @@\n ------------------------------------------------------------------------------\n \n --  Call the back end with all the information needed. Also contains other\n---  back-end specific interfaces required by the front end.\n+--  back-end specific interfaces required by the front end. See also Get_Targ,\n+--  which defines additional interfaces to the back end.\n \n with Einfo; use Einfo;\n \n@@ -63,13 +64,13 @@ package Back_End is\n    --  the back end.\n \n    procedure Register_Back_End_Types (Call_Back : Register_Type_Proc);\n-   --  Calls the Call_Back function with information for each supported type.\n+   --  Calls the Call_Back function with information for each supported type\n \n    procedure Call_Back_End (Mode : Back_End_Mode_Type);\n    --  Call back end, i.e. make call to driver traversing the tree and\n-   --  outputting code. This call is made with all tables locked.\n-   --  The back end is responsible for unlocking any tables it may need\n-   --  to change, and locking them again before returning.\n+   --  outputting code. This call is made with all tables locked. The back\n+   --  end is responsible for unlocking any tables it may need to change,\n+   --  and locking them again before returning.\n \n    procedure Scan_Compiler_Arguments;\n    --  Acquires command-line parameters passed to the compiler and processes"}, {"sha": "6f066fe917ba1ecd14b04166357907f4470d3099", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 485, "deletions": 124, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -114,6 +114,18 @@ package body Sem_Case is\n       Others_Present : Boolean;\n       Case_Node      : Node_Id)\n    is\n+      procedure Check_Against_Predicate\n+        (Pred    : in out Node_Id;\n+         Choice  : Choice_Bounds;\n+         Prev_Lo : in out Uint;\n+         Prev_Hi : in out Uint;\n+         Error   : in out Boolean);\n+      --  Determine whether a choice covers legal values as defined by a static\n+      --  predicate set. Pred is a static predicate range. Choice is the choice\n+      --  to be examined. Prev_Lo and Prev_Hi are the bounds of the previous\n+      --  choice that covered a predicate set. Error denotes whether the check\n+      --  found an illegal intersection.\n+\n       procedure Explain_Non_Static_Bound;\n       --  Called when we find a non-static bound, requiring the base type to\n       --  be covered. Provides where possible a helpful explanation of why the\n@@ -123,102 +135,292 @@ package body Sem_Case is\n       --  Comparison routine for comparing Choice_Table entries. Use the lower\n       --  bound of each Choice as the key.\n \n+      procedure Missing_Choice (Value1 : Node_Id; Value2 : Node_Id);\n+      procedure Missing_Choice (Value1 : Node_Id; Value2 : Uint);\n+      procedure Missing_Choice (Value1 : Uint;    Value2 : Node_Id);\n+      procedure Missing_Choice (Value1 : Uint;    Value2 : Uint);\n+      --  Issue an error message indicating that there are missing choices,\n+      --  followed by the image of the missing choices themselves which lie\n+      --  between Value1 and Value2 inclusive.\n+\n+      procedure Missing_Choices (Pred : Node_Id; Prev_Hi : Uint);\n+      --  Emit an error message for each non-covered static predicate set.\n+      --  Prev_Hi denotes the upper bound of the last choice that covered a\n+      --  set.\n+\n       procedure Move_Choice (From : Natural; To : Natural);\n       --  Move routine for sorting the Choice_Table\n \n       package Sorting is new GNAT.Heap_Sort_G (Move_Choice, Lt_Choice);\n \n-      procedure Issue_Msg (Value1 : Node_Id; Value2 : Node_Id);\n-      procedure Issue_Msg (Value1 : Node_Id; Value2 : Uint);\n-      procedure Issue_Msg (Value1 : Uint;    Value2 : Node_Id);\n-      procedure Issue_Msg (Value1 : Uint;    Value2 : Uint);\n-      --  Issue an error message indicating that there are missing choices,\n-      --  followed by the image of the missing choices themselves which lie\n-      --  between Value1 and Value2 inclusive.\n+      -----------------------------\n+      -- Check_Against_Predicate --\n+      -----------------------------\n \n-      ---------------\n-      -- Issue_Msg --\n-      ---------------\n+      procedure Check_Against_Predicate\n+        (Pred    : in out Node_Id;\n+         Choice  : Choice_Bounds;\n+         Prev_Lo : in out Uint;\n+         Prev_Hi : in out Uint;\n+         Error   : in out Boolean)\n+      is\n+         procedure Illegal_Range\n+           (Loc : Source_Ptr;\n+            Lo  : Uint;\n+            Hi  : Uint);\n+         --  Emit an error message regarding a choice that clashes with the\n+         --  legal static predicate sets. Loc is the location of the choice\n+         --  that introduced the illegal range. Lo .. Hi is the range.\n+\n+         function Inside_Range\n+           (Lo  : Uint;\n+            Hi  : Uint;\n+            Val : Uint) return Boolean;\n+         --  Determine whether position Val within a discrete type is within\n+         --  the range Lo .. Hi inclusive.\n+\n+         -------------------\n+         -- Illegal_Range --\n+         -------------------\n+\n+         procedure Illegal_Range\n+           (Loc : Source_Ptr;\n+            Lo  : Uint;\n+            Hi  : Uint)\n+         is\n+         begin\n+            Error_Msg_Name_1 := Chars (Bounds_Type);\n \n-      procedure Issue_Msg (Value1 : Node_Id; Value2 : Node_Id) is\n-      begin\n-         Issue_Msg (Expr_Value (Value1), Expr_Value (Value2));\n-      end Issue_Msg;\n+            --  Single value\n \n-      procedure Issue_Msg (Value1 : Node_Id; Value2 : Uint) is\n-      begin\n-         Issue_Msg (Expr_Value (Value1), Value2);\n-      end Issue_Msg;\n+            if Lo = Hi then\n+               if Is_Integer_Type (Bounds_Type) then\n+                  Error_Msg_Uint_1 := Lo;\n+                  Error_Msg (\"static predicate on % excludes value ^!\", Loc);\n+               else\n+                  Error_Msg_Name_2 := Choice_Image (Lo, Bounds_Type);\n+                  Error_Msg (\"static predicate on % excludes value %!\", Loc);\n+               end if;\n \n-      procedure Issue_Msg (Value1 : Uint; Value2 : Node_Id) is\n-      begin\n-         Issue_Msg (Value1, Expr_Value (Value2));\n-      end Issue_Msg;\n+            --  Range\n \n-      procedure Issue_Msg (Value1 : Uint; Value2 : Uint) is\n-         Msg_Sloc : constant Source_Ptr := Sloc (Case_Node);\n+            else\n+               if Is_Integer_Type (Bounds_Type) then\n+                  Error_Msg_Uint_1 := Lo;\n+                  Error_Msg_Uint_2 := Hi;\n+                  Error_Msg\n+                    (\"static predicate on % excludes range ^ .. ^!\", Loc);\n+               else\n+                  Error_Msg_Name_2 := Choice_Image (Lo, Bounds_Type);\n+                  Error_Msg_Name_3 := Choice_Image (Hi, Bounds_Type);\n+                  Error_Msg\n+                    (\"static predicate on % excludes range % .. %!\", Loc);\n+               end if;\n+            end if;\n+         end Illegal_Range;\n+\n+         ------------------\n+         -- Inside_Range --\n+         ------------------\n+\n+         function Inside_Range\n+           (Lo  : Uint;\n+            Hi  : Uint;\n+            Val : Uint) return Boolean\n+         is\n+         begin\n+            return\n+              Val = Lo or else Val = Hi or else (Lo < Val and then Val < Hi);\n+         end Inside_Range;\n+\n+         --  Local variables\n+\n+         Choice_Hi : constant Uint := Expr_Value (Choice.Hi);\n+         Choice_Lo : constant Uint := Expr_Value (Choice.Lo);\n+         Loc       : Source_Ptr;\n+         Next_Hi   : Uint;\n+         Next_Lo   : Uint;\n+         Pred_Hi   : Uint;\n+         Pred_Lo   : Uint;\n+\n+      --  Start of processing for Check_Against_Predicate\n \n       begin\n-         --  AI05-0188 : within an instance the non-others choices do not\n-         --  have to belong to the actual subtype.\n+         --  Find the proper error message location\n \n-         if Ada_Version >= Ada_2012 and then In_Instance then\n-            return;\n+         if Present (Choice.Node) then\n+            Loc := Sloc (Choice.Node);\n+         else\n+            Loc := Sloc (Case_Node);\n          end if;\n \n-         --  In some situations, we call this with a null range, and\n-         --  obviously we don't want to complain in this case!\n+         if Present (Pred) then\n+            Pred_Lo := Expr_Value (Low_Bound  (Pred));\n+            Pred_Hi := Expr_Value (High_Bound (Pred));\n+\n+         --  Previous choices managed to satisfy all static predicate sets\n+\n+         else\n+            Illegal_Range (Loc, Choice_Lo, Choice_Hi);\n+            Error := True;\n \n-         if Value1 > Value2 then\n             return;\n          end if;\n \n-         --  Case of only one value that is missing\n+         --  Step 1: Detect duplicate choices\n \n-         if Value1 = Value2 then\n-            if Is_Integer_Type (Bounds_Type) then\n-               Error_Msg_Uint_1 := Value1;\n-               Error_Msg (\"missing case value: ^!\", Msg_Sloc);\n+         if Inside_Range (Choice_Lo, Choice_Hi, Prev_Lo)\n+           or else Inside_Range (Choice_Lo, Choice_Hi, Prev_Hi)\n+         then\n+            Error_Msg (\"duplication of choice value\", Loc);\n+            Error := True;\n+\n+         --  Step 2: Detect full coverage\n+\n+         --  Choice_Lo    Choice_Hi\n+         --  +============+\n+         --  Pred_Lo      Pred_Hi\n+\n+         elsif Choice_Lo = Pred_Lo and then Choice_Hi = Pred_Hi then\n+            Prev_Lo := Choice_Lo;\n+            Prev_Hi := Choice_Hi;\n+            Next (Pred);\n+\n+         --  Step 3: Detect all cases where a choice mentions values that are\n+         --  not part of the static predicate sets.\n+\n+         --  Choice_Lo   Choice_Hi   Pred_Lo   Pred_Hi\n+         --  +-----------+ . . . . . +=========+\n+         --   ^ illegal ^\n+\n+         elsif Choice_Lo < Pred_Lo and then Choice_Hi < Pred_Lo then\n+            Illegal_Range (Loc, Choice_Lo, Choice_Hi);\n+            Error := True;\n+\n+         --  Choice_Lo   Pred_Lo   Choice_Hi   Pred_Hi\n+         --  +-----------+=========+===========+\n+         --   ^ illegal ^\n+\n+         elsif Choice_Lo < Pred_Lo\n+           and then Inside_Range (Pred_Lo, Pred_Hi, Choice_Hi)\n+         then\n+            Illegal_Range (Loc, Choice_Lo, Pred_Lo - 1);\n+            Error := True;\n+\n+         --  Pred_Lo   Pred_Hi   Choice_Lo   Choice_Hi\n+         --  +=========+ . . . . +-----------+\n+         --                       ^ illegal ^\n+\n+         elsif Pred_Lo < Choice_Lo and then Pred_Hi < Choice_Lo then\n+            Missing_Choice (Pred_Lo, Pred_Hi);\n+            Error := True;\n+\n+            --  There may be several static predicate sets between the current\n+            --  one and the choice. Inspect the next static predicate set.\n+\n+            Next (Pred);\n+            Check_Against_Predicate\n+              (Pred    => Pred,\n+               Choice  => Choice,\n+               Prev_Lo => Prev_Lo,\n+               Prev_Hi => Prev_Hi,\n+               Error   => Error);\n+\n+         --  Pred_Lo   Choice_Lo   Pred_Hi     Choice_Hi\n+         --  +=========+===========+-----------+\n+         --                         ^ illegal ^\n+\n+         elsif Pred_Hi < Choice_Hi\n+           and then Inside_Range (Pred_Lo, Pred_Hi, Choice_Lo)\n+         then\n+            Next (Pred);\n+\n+            --  The choice may fall in a static predicate set. If this is the\n+            --  case, avoid mentioning legal values in the error message.\n+\n+            if Present (Pred) then\n+               Next_Lo := Expr_Value (Low_Bound  (Pred));\n+               Next_Hi := Expr_Value (High_Bound (Pred));\n+\n+               --  The next static predicate set is to the right of the choice\n+\n+               if Choice_Hi < Next_Lo and then Choice_Hi < Next_Hi then\n+                  Illegal_Range (Loc, Pred_Hi + 1, Choice_Hi);\n+               else\n+                  Illegal_Range (Loc, Pred_Hi + 1, Next_Lo - 1);\n+               end if;\n             else\n-               Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n-               Error_Msg (\"missing case value: %!\", Msg_Sloc);\n+               Illegal_Range (Loc, Pred_Hi + 1, Choice_Hi);\n             end if;\n \n-         --  More than one choice value, so print range of values\n+            Error := True;\n+\n+         --  Choice_Lo   Pred_Lo   Pred_Hi     Choice_Hi\n+         --  +-----------+=========+-----------+\n+         --   ^ illegal ^           ^ illegal ^\n+\n+         --  Emit an error on the low gap, disregard the upper gap\n+\n+         elsif Choice_Lo < Pred_Lo and then Pred_Hi < Choice_Hi then\n+            Illegal_Range (Loc, Choice_Lo, Pred_Lo - 1);\n+            Error := True;\n+\n+         --  Step 4: Detect all cases of partial or missing coverage\n+\n+         --  Pred_Lo   Choice_Lo  Choice_Hi   Pred_Hi\n+         --  +=========+==========+===========+\n+         --   ^  gap  ^            ^   gap   ^\n \n          else\n-            if Is_Integer_Type (Bounds_Type) then\n-               Error_Msg_Uint_1 := Value1;\n-               Error_Msg_Uint_2 := Value2;\n-               Error_Msg (\"missing case values: ^ .. ^!\", Msg_Sloc);\n-            else\n-               Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n-               Error_Msg_Name_2 := Choice_Image (Value2, Bounds_Type);\n-               Error_Msg (\"missing case values: % .. %!\", Msg_Sloc);\n-            end if;\n-         end if;\n-      end Issue_Msg;\n+            --  An \"others\" choice covers all gaps\n \n-      ---------------\n-      -- Lt_Choice --\n-      ---------------\n+            if Others_Present then\n+               Prev_Lo := Choice_Lo;\n+               Prev_Hi := Choice_Hi;\n+               Next (Pred);\n \n-      function Lt_Choice (C1, C2 : Natural) return Boolean is\n-      begin\n-         return\n-           Expr_Value (Choice_Table (Nat (C1)).Lo)\n-             <\n-           Expr_Value (Choice_Table (Nat (C2)).Lo);\n-      end Lt_Choice;\n+            --  Choice_Lo   Choice_Hi   Pred_Hi\n+            --  +===========+===========+\n+            --  Pred_Lo      ^   gap   ^\n \n-      -----------------\n-      -- Move_Choice --\n-      -----------------\n+            --  The upper gap may be covered by a subsequent choice\n \n-      procedure Move_Choice (From : Natural; To : Natural) is\n-      begin\n-         Choice_Table (Nat (To)) := Choice_Table (Nat (From));\n-      end Move_Choice;\n+            elsif Pred_Lo = Choice_Lo then\n+               Prev_Lo := Choice_Lo;\n+               Prev_Hi := Choice_Hi;\n+\n+            --  Pred_Lo     Prev_Hi   Choice_Lo   Choice_Hi   Pred_Hi\n+            --  +===========+=========+===========+===========+\n+            --   ^ covered ^ ^  gap  ^\n+\n+            else pragma Assert (Pred_Lo < Choice_Lo);\n+\n+               --  A previous choice covered the gap up to the current choice\n+\n+               if Prev_Hi = Choice_Lo - 1 then\n+                  Prev_Lo := Choice_Lo;\n+                  Prev_Hi := Choice_Hi;\n+\n+                  if Choice_Hi = Pred_Hi then\n+                     Next (Pred);\n+                  end if;\n+\n+               --  The previous choice did not intersect with the current\n+               --  static predicate set.\n+\n+               elsif Prev_Hi < Pred_Lo then\n+                  Missing_Choice (Pred_Lo, Choice_Lo - 1);\n+                  Error := True;\n+\n+               --  The previous choice covered part of the static predicate set\n+\n+               else\n+                  Missing_Choice (Prev_Hi, Choice_Lo - 1);\n+                  Error := True;\n+               end if;\n+            end if;\n+         end if;\n+      end Check_Against_Predicate;\n \n       ------------------------------\n       -- Explain_Non_Static_Bound --\n@@ -236,16 +438,16 @@ package body Sem_Case is\n \n          if Bounds_Type /= Subtyp then\n \n-            --  If the case is a variant part, the expression is given by\n-            --  the discriminant itself, and the bounds are the culprits.\n+            --  If the case is a variant part, the expression is given by the\n+            --  discriminant itself, and the bounds are the culprits.\n \n             if Nkind (Case_Node) = N_Variant_Part then\n                Error_Msg_NE\n                  (\"bounds of & are not static,\" &\n                      \" alternatives must cover base type\", Expr, Expr);\n \n-            --  If this is a case statement, the expression may be\n-            --  non-static or else the subtype may be at fault.\n+            --  If this is a case statement, the expression may be non-static\n+            --  or else the subtype may be at fault.\n \n             elsif Is_Entity_Name (Expr) then\n                Error_Msg_NE\n@@ -269,90 +471,249 @@ package body Sem_Case is\n          end if;\n       end Explain_Non_Static_Bound;\n \n-      --  Variables local to Check_Choices\n+      ---------------\n+      -- Lt_Choice --\n+      ---------------\n+\n+      function Lt_Choice (C1, C2 : Natural) return Boolean is\n+      begin\n+         return\n+           Expr_Value (Choice_Table (Nat (C1)).Lo)\n+             <\n+           Expr_Value (Choice_Table (Nat (C2)).Lo);\n+      end Lt_Choice;\n+\n+      --------------------\n+      -- Missing_Choice --\n+      --------------------\n \n-      Choice    : Node_Id;\n-      Bounds_Lo : constant Node_Id := Type_Low_Bound  (Bounds_Type);\n-      Bounds_Hi : constant Node_Id := Type_High_Bound (Bounds_Type);\n+      procedure Missing_Choice (Value1 : Node_Id; Value2 : Node_Id) is\n+      begin\n+         Missing_Choice (Expr_Value (Value1), Expr_Value (Value2));\n+      end Missing_Choice;\n \n-      Prev_Choice : Node_Id;\n+      procedure Missing_Choice (Value1 : Node_Id; Value2 : Uint) is\n+      begin\n+         Missing_Choice (Expr_Value (Value1), Value2);\n+      end Missing_Choice;\n+\n+      procedure Missing_Choice (Value1 : Uint; Value2 : Node_Id) is\n+      begin\n+         Missing_Choice (Value1, Expr_Value (Value2));\n+      end Missing_Choice;\n+\n+      procedure Missing_Choice (Value1 : Uint; Value2 : Uint) is\n+         Msg_Sloc : constant Source_Ptr := Sloc (Case_Node);\n+\n+      begin\n+         --  AI05-0188 : within an instance the non-others choices do not have\n+         --  to belong to the actual subtype.\n+\n+         if Ada_Version >= Ada_2012 and then In_Instance then\n+            return;\n+\n+         --  In some situations, we call this with a null range, and obviously\n+         --  we don't want to complain in this case.\n+\n+         elsif Value1 > Value2 then\n+            return;\n+         end if;\n+\n+         --  Case of only one value that is missing\n+\n+         if Value1 = Value2 then\n+            if Is_Integer_Type (Bounds_Type) then\n+               Error_Msg_Uint_1 := Value1;\n+               Error_Msg (\"missing case value: ^!\", Msg_Sloc);\n+            else\n+               Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n+               Error_Msg (\"missing case value: %!\", Msg_Sloc);\n+            end if;\n+\n+         --  More than one choice value, so print range of values\n+\n+         else\n+            if Is_Integer_Type (Bounds_Type) then\n+               Error_Msg_Uint_1 := Value1;\n+               Error_Msg_Uint_2 := Value2;\n+               Error_Msg (\"missing case values: ^ .. ^!\", Msg_Sloc);\n+            else\n+               Error_Msg_Name_1 := Choice_Image (Value1, Bounds_Type);\n+               Error_Msg_Name_2 := Choice_Image (Value2, Bounds_Type);\n+               Error_Msg (\"missing case values: % .. %!\", Msg_Sloc);\n+            end if;\n+         end if;\n+      end Missing_Choice;\n+\n+      ---------------------\n+      -- Missing_Choices --\n+      ---------------------\n \n-      Hi      : Uint;\n-      Lo      : Uint;\n-      Prev_Hi : Uint;\n+      procedure Missing_Choices (Pred : Node_Id; Prev_Hi : Uint) is\n+         Hi  : Uint;\n+         Lo  : Uint;\n+         Set : Node_Id;\n+\n+      begin\n+         Set := Pred;\n+         while Present (Set) loop\n+            Lo := Expr_Value (Low_Bound (Set));\n+            Hi := Expr_Value (High_Bound (Set));\n+\n+            --  A choice covered part of a static predicate set\n+\n+            if Lo <= Prev_Hi and then Prev_Hi < Hi then\n+               Missing_Choice (Prev_Hi + 1, Hi);\n+\n+            else\n+               Missing_Choice (Lo, Hi);\n+            end if;\n+\n+            Next (Set);\n+         end loop;\n+      end Missing_Choices;\n+\n+      -----------------\n+      -- Move_Choice --\n+      -----------------\n+\n+      procedure Move_Choice (From : Natural; To : Natural) is\n+      begin\n+         Choice_Table (Nat (To)) := Choice_Table (Nat (From));\n+      end Move_Choice;\n+\n+      --  Local variables\n+\n+      Bounds_Hi     : constant Node_Id := Type_High_Bound (Bounds_Type);\n+      Bounds_Lo     : constant Node_Id := Type_Low_Bound  (Bounds_Type);\n+      Has_Predicate : constant Boolean :=\n+                        Is_Static_Subtype (Bounds_Type)\n+                          and then Present (Static_Predicate (Bounds_Type));\n+      Num_Choices   : constant Nat     := Choice_Table'Last;\n+\n+      Choice      : Node_Id;\n+      Choice_Hi   : Uint;\n+      Choice_Lo   : Uint;\n+      Error       : Boolean;\n+      Pred        : Node_Id;\n+      Prev_Choice : Node_Id;\n+      Prev_Lo     : Uint;\n+      Prev_Hi     : Uint;\n \n    --  Start of processing for Check_Choices\n \n    begin\n-      --  Choice_Table must start at 0 which is an unused location used\n-      --  by the sorting algorithm. However the first valid position for\n-      --  a discrete choice is 1.\n+      --  Choice_Table must start at 0 which is an unused location used by the\n+      --  sorting algorithm. However the first valid position for a discrete\n+      --  choice is 1.\n \n       pragma Assert (Choice_Table'First = 0);\n \n-      if Choice_Table'Last = 0 then\n+      --  The choices do not cover the base range. Emit an error if \"others\" is\n+      --  not available and return as there is no need for further processing.\n+\n+      if Num_Choices = 0 then\n          if not Others_Present then\n-            Issue_Msg (Bounds_Lo, Bounds_Hi);\n+            Missing_Choice (Bounds_Lo, Bounds_Hi);\n          end if;\n \n          return;\n       end if;\n \n       Sorting.Sort (Positive (Choice_Table'Last));\n \n-      Lo      := Expr_Value (Choice_Table (1).Lo);\n-      Hi      := Expr_Value (Choice_Table (1).Hi);\n-      Prev_Hi := Hi;\n+      --  The type covered by the list of choices is actually a static subtype\n+      --  subject to a static predicate. The predicate defines subsets of legal\n+      --  values and requires finer grained analysis.\n+\n+      if Has_Predicate then\n+         Pred    := First (Static_Predicate (Bounds_Type));\n+         Prev_Lo := Uint_Minus_1;\n+         Prev_Hi := Uint_Minus_1;\n+         Error   := False;\n+\n+         for Index in 1 .. Num_Choices loop\n+            Check_Against_Predicate\n+              (Pred    => Pred,\n+               Choice  => Choice_Table (Index),\n+               Prev_Lo => Prev_Lo,\n+               Prev_Hi => Prev_Hi,\n+               Error   => Error);\n+\n+            --  The analysis detected an illegal intersection between a choice\n+            --  and a static predicate set.\n \n-      if not Others_Present and then Expr_Value (Bounds_Lo) < Lo then\n-         Issue_Msg (Bounds_Lo, Lo - 1);\n+            if Error then\n+               return;\n+            end if;\n+         end loop;\n \n-         --  If values are missing outside of the subtype, add explanation.\n-         --  No additional message if only one value is missing.\n+         --  The choices may legally cover some of the static predicate sets,\n+         --  but not all. Emit an error for each non-covered set.\n \n-         if Expr_Value (Bounds_Lo) < Lo - 1 then\n-            Explain_Non_Static_Bound;\n+         if not Others_Present then\n+            Missing_Choices (Pred, Prev_Hi);\n          end if;\n-      end if;\n \n-      for J in 2 .. Choice_Table'Last loop\n-         Lo := Expr_Value (Choice_Table (J).Lo);\n-         Hi := Expr_Value (Choice_Table (J).Hi);\n+      --  Default analysis\n \n-         if Lo <= Prev_Hi then\n-            Choice := Choice_Table (J).Node;\n+      else\n+         Choice_Lo := Expr_Value (Choice_Table (1).Lo);\n+         Choice_Hi := Expr_Value (Choice_Table (1).Hi);\n+         Prev_Hi   := Choice_Hi;\n \n-            --  Find first previous choice that overlaps\n+         if not Others_Present and then Expr_Value (Bounds_Lo) < Choice_Lo then\n+            Missing_Choice (Bounds_Lo, Choice_Lo - 1);\n \n-            for K in 1 .. J - 1 loop\n-               if Lo <= Expr_Value (Choice_Table (K).Hi) then\n-                  Prev_Choice := Choice_Table (K).Node;\n-                  exit;\n-               end if;\n-            end loop;\n+            --  If values are missing outside of the subtype, add explanation.\n+            --  No additional message if only one value is missing.\n \n-            if Sloc (Prev_Choice) <= Sloc (Choice) then\n-               Error_Msg_Sloc := Sloc (Prev_Choice);\n-               Error_Msg_N (\"duplication of choice value#\", Choice);\n-            else\n-               Error_Msg_Sloc := Sloc (Choice);\n-               Error_Msg_N (\"duplication of choice value#\", Prev_Choice);\n+            if Expr_Value (Bounds_Lo) < Choice_Lo - 1 then\n+               Explain_Non_Static_Bound;\n             end if;\n-\n-         elsif not Others_Present and then Lo /= Prev_Hi + 1 then\n-            Issue_Msg (Prev_Hi + 1, Lo - 1);\n          end if;\n \n-         if Hi > Prev_Hi then\n-            Prev_Hi := Hi;\n-         end if;\n-      end loop;\n+         for Outer_Index in 2 .. Num_Choices loop\n+            Choice_Lo := Expr_Value (Choice_Table (Outer_Index).Lo);\n+            Choice_Hi := Expr_Value (Choice_Table (Outer_Index).Hi);\n+\n+            if Choice_Lo <= Prev_Hi then\n+               Choice := Choice_Table (Outer_Index).Node;\n \n-      if not Others_Present and then Expr_Value (Bounds_Hi) > Hi then\n-         Issue_Msg (Hi + 1, Bounds_Hi);\n+               --  Find first previous choice that overlaps\n \n-         if Expr_Value (Bounds_Hi) > Hi + 1 then\n-            Explain_Non_Static_Bound;\n+               for Inner_Index in 1 .. Outer_Index - 1 loop\n+                  if Choice_Lo <=\n+                       Expr_Value (Choice_Table (Inner_Index).Hi)\n+                  then\n+                     Prev_Choice := Choice_Table (Inner_Index).Node;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               if Sloc (Prev_Choice) <= Sloc (Choice) then\n+                  Error_Msg_Sloc := Sloc (Prev_Choice);\n+                  Error_Msg_N (\"duplication of choice value#\", Choice);\n+               else\n+                  Error_Msg_Sloc := Sloc (Choice);\n+                  Error_Msg_N (\"duplication of choice value#\", Prev_Choice);\n+               end if;\n+\n+            elsif not Others_Present and then Choice_Lo /= Prev_Hi + 1 then\n+               Missing_Choice (Prev_Hi + 1, Choice_Lo - 1);\n+            end if;\n+\n+            if Choice_Hi > Prev_Hi then\n+               Prev_Hi := Choice_Hi;\n+            end if;\n+         end loop;\n+\n+         if not Others_Present and then Expr_Value (Bounds_Hi) > Choice_Hi then\n+            Missing_Choice (Choice_Hi + 1, Bounds_Hi);\n+\n+            if Expr_Value (Bounds_Hi) > Choice_Hi + 1 then\n+               Explain_Non_Static_Bound;\n+            end if;\n          end if;\n       end if;\n    end Check_Choices;"}, {"sha": "654df4320c012a41d370eeedb45e37baa19dcbd1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 61, "deletions": 67, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -93,7 +93,7 @@ package body Sem_Ch13 is\n    --  the function is inserted before the freeze node, and the body of the\n    --  function is inserted after the freeze node. If the predicate expression\n    --  has at least one Raise_Expression, then this procedure also builds the\n-   --  M version of the predicate function for ue in membership tests.\n+   --  M version of the predicate function for use in membership tests.\n \n    procedure Build_Static_Predicate\n      (Typ  : Entity_Id;\n@@ -6188,15 +6188,15 @@ package body Sem_Ch13 is\n       type REnt is record\n          Lo, Hi : Uint;\n       end record;\n-      --  One entry in a Rlist value, a single REnt (range entry) value\n-      --  denotes one range from Lo to Hi. To represent a single value\n-      --  range Lo = Hi = value.\n+      --  One entry in a Rlist value, a single REnt (range entry) value denotes\n+      --  one range from Lo to Hi. To represent a single value range Lo = Hi =\n+      --  value.\n \n       type RList is array (Nat range <>) of REnt;\n-      --  A list of ranges. The ranges are sorted in increasing order,\n-      --  and are disjoint (there is a gap of at least one value between\n-      --  each range in the table). A value is in the set of ranges in\n-      --  Rlist if it lies within one of these ranges\n+      --  A list of ranges. The ranges are sorted in increasing order, and are\n+      --  disjoint (there is a gap of at least one value between each range in\n+      --  the table). A value is in the set of ranges in Rlist if it lies\n+      --  within one of these ranges.\n \n       False_Range : constant RList :=\n                       RList'(1 .. 0 => REnt'(No_Uint, No_Uint));\n@@ -6210,41 +6210,41 @@ package body Sem_Ch13 is\n       True_Range : constant RList := RList'(1 => REnt'(BLo, BHi));\n       --  Range representing True, value must be in the base range\n \n-      function \"and\" (Left, Right : RList) return RList;\n-      --  And's together two range lists, returning a range list. This is\n-      --  a set intersection operation.\n+      function \"and\" (Left : RList; Right : RList) return RList;\n+      --  And's together two range lists, returning a range list. This is a set\n+      --  intersection operation.\n \n-      function \"or\" (Left, Right : RList) return RList;\n-      --  Or's together two range lists, returning a range list. This is a\n-      --  set union operation.\n+      function \"or\" (Left : RList; Right : RList) return RList;\n+      --  Or's together two range lists, returning a range list. This is a set\n+      --  union operation.\n \n       function \"not\" (Right : RList) return RList;\n       --  Returns complement of a given range list, i.e. a range list\n-      --  representing all the values in TLo .. THi that are not in the\n-      --  input operand Right.\n+      --  representing all the values in TLo .. THi that are not in the input\n+      --  operand Right.\n \n       function Build_Val (V : Uint) return Node_Id;\n       --  Return an analyzed N_Identifier node referencing this value, suitable\n       --  for use as an entry in the Static_Predicate list. This node is typed\n       --  with the base type.\n \n-      function Build_Range (Lo, Hi : Uint) return Node_Id;\n-      --  Return an analyzed N_Range node referencing this range, suitable\n-      --  for use as an entry in the Static_Predicate list. This node is typed\n-      --  with the base type.\n+      function Build_Range (Lo : Uint; Hi : Uint) return Node_Id;\n+      --  Return an analyzed N_Range node referencing this range, suitable for\n+      --  use as an entry in the Static_Predicate list. This node is typed with\n+      --  the base type.\n \n       function Get_RList (Exp : Node_Id) return RList;\n-      --  This is a recursive routine that converts the given expression into\n-      --  a list of ranges, suitable for use in building the static predicate.\n+      --  This is a recursive routine that converts the given expression into a\n+      --  list of ranges, suitable for use in building the static predicate.\n \n       function Is_False (R : RList) return Boolean;\n       pragma Inline (Is_False);\n-      --  Returns True if the given range list is empty, and thus represents\n-      --  a False list of ranges that can never be satisfied.\n+      --  Returns True if the given range list is empty, and thus represents a\n+      --  False list of ranges that can never be satisfied.\n \n       function Is_True (R : RList) return Boolean;\n-      --  Returns True if R trivially represents the True predicate by having\n-      --  a single range from BLo to BHi.\n+      --  Returns True if R trivially represents the True predicate by having a\n+      --  single range from BLo to BHi.\n \n       function Is_Type_Ref (N : Node_Id) return Boolean;\n       pragma Inline (Is_Type_Ref);\n@@ -6277,7 +6277,7 @@ package body Sem_Ch13 is\n       -- \"and\" --\n       -----------\n \n-      function \"and\" (Left, Right : RList) return RList is\n+      function \"and\" (Left : RList; Right : RList) return RList is\n          FEnt : REnt;\n          --  First range of result\n \n@@ -6302,8 +6302,8 @@ package body Sem_Ch13 is\n             return False_Range;\n          end if;\n \n-         --  Loop to remove entries at start that are disjoint, and thus\n-         --  just get discarded from the result entirely.\n+         --  Loop to remove entries at start that are disjoint, and thus just\n+         --  get discarded from the result entirely.\n \n          loop\n             --  If no operands left in either operand, result is false\n@@ -6328,26 +6328,26 @@ package body Sem_Ch13 is\n             end if;\n          end loop;\n \n-         --  Now we have two non-null operands, and first entries overlap.\n-         --  The first entry in the result will be the overlapping part of\n-         --  these two entries.\n+         --  Now we have two non-null operands, and first entries overlap. The\n+         --  first entry in the result will be the overlapping part of these\n+         --  two entries.\n \n          FEnt := REnt'(Lo => UI_Max (Left (SLeft).Lo, Right (SRight).Lo),\n                        Hi => UI_Min (Left (SLeft).Hi, Right (SRight).Hi));\n \n-         --  Now we can remove the entry that ended at a lower value, since\n-         --  its contribution is entirely contained in Fent.\n+         --  Now we can remove the entry that ended at a lower value, since its\n+         --  contribution is entirely contained in Fent.\n \n          if Left (SLeft).Hi <= Right (SRight).Hi then\n             SLeft := SLeft + 1;\n          else\n             SRight := SRight + 1;\n          end if;\n \n-         --  Compute result by concatenating this first entry with the \"and\"\n-         --  of the remaining parts of the left and right operands. Note that\n-         --  if either of these is empty, \"and\" will yield empty, so that we\n-         --  will end up with just Fent, which is what we want in that case.\n+         --  Compute result by concatenating this first entry with the \"and\" of\n+         --  the remaining parts of the left and right operands. Note that if\n+         --  either of these is empty, \"and\" will yield empty, so that we will\n+         --  end up with just Fent, which is what we want in that case.\n \n          return\n            FEnt & (Left (SLeft .. Left'Last) and Right (SRight .. Right'Last));\n@@ -6411,7 +6411,7 @@ package body Sem_Ch13 is\n       -- \"or\" --\n       ----------\n \n-      function \"or\" (Left, Right : RList) return RList is\n+      function \"or\" (Left : RList; Right : RList) return RList is\n          FEnt : REnt;\n          --  First range of result\n \n@@ -6436,8 +6436,8 @@ package body Sem_Ch13 is\n             return Left;\n          end if;\n \n-         --  Initialize result first entry from left or right operand\n-         --  depending on which starts with the lower range.\n+         --  Initialize result first entry from left or right operand depending\n+         --  on which starts with the lower range.\n \n          if Left (SLeft).Lo < Right (SRight).Lo then\n             FEnt := Left (SLeft);\n@@ -6447,29 +6447,29 @@ package body Sem_Ch13 is\n             SRight := SRight + 1;\n          end if;\n \n-         --  This loop eats ranges from left and right operands that\n-         --  are contiguous with the first range we are gathering.\n+         --  This loop eats ranges from left and right operands that are\n+         --  contiguous with the first range we are gathering.\n \n          loop\n-            --  Eat first entry in left operand if contiguous or\n-            --  overlapped by gathered first operand of result.\n+            --  Eat first entry in left operand if contiguous or overlapped by\n+            --  gathered first operand of result.\n \n             if SLeft <= Left'Last\n               and then Left (SLeft).Lo <= FEnt.Hi + 1\n             then\n                FEnt.Hi := UI_Max (FEnt.Hi, Left (SLeft).Hi);\n                SLeft := SLeft + 1;\n \n-               --  Eat first entry in right operand if contiguous or\n-               --  overlapped by gathered right operand of result.\n+            --  Eat first entry in right operand if contiguous or overlapped by\n+            --  gathered right operand of result.\n \n             elsif SRight <= Right'Last\n               and then Right (SRight).Lo <= FEnt.Hi + 1\n             then\n                FEnt.Hi := UI_Max (FEnt.Hi, Right (SRight).Hi);\n                SRight := SRight + 1;\n \n-               --  All done if no more entries to eat!\n+            --  All done if no more entries to eat\n \n             else\n                exit;\n@@ -6488,20 +6488,18 @@ package body Sem_Ch13 is\n       -- Build_Range --\n       -----------------\n \n-      function Build_Range (Lo, Hi : Uint) return Node_Id is\n+      function Build_Range (Lo : Uint; Hi : Uint) return Node_Id is\n          Result : Node_Id;\n+\n       begin\n-         if Lo = Hi then\n-            return Build_Val (Hi);\n-         else\n-            Result :=\n-              Make_Range (Loc,\n-                Low_Bound  => Build_Val (Lo),\n-                High_Bound => Build_Val (Hi));\n-            Set_Etype (Result, Btyp);\n-            Set_Analyzed (Result);\n-            return Result;\n-         end if;\n+         Result :=\n+           Make_Range (Loc,\n+             Low_Bound  => Build_Val (Lo),\n+             High_Bound => Build_Val (Hi));\n+         Set_Etype (Result, Btyp);\n+         Set_Analyzed (Result);\n+\n+         return Result;\n       end Build_Range;\n \n       ---------------\n@@ -6911,11 +6909,7 @@ package body Sem_Ch13 is\n \n                   --  Convert range into required form\n \n-                  if Lo = Hi then\n-                     Append_To (Plist, Build_Val (Lo));\n-                  else\n-                     Append_To (Plist, Build_Range (Lo, Hi));\n-                  end if;\n+                  Append_To (Plist, Build_Range (Lo, Hi));\n                end if;\n             end;\n          end loop;\n@@ -9452,12 +9446,12 @@ package body Sem_Ch13 is\n       --  storage orders differ.\n \n       if (Is_Record_Type (T1) or else Is_Array_Type (T1))\n-        and then\n+            and then\n          (Is_Record_Type (T2) or else Is_Array_Type (T2))\n         and then\n          (Component_Alignment (T1) /= Component_Alignment (T2)\n             or else\n-          Reverse_Storage_Order (T1) /= Reverse_Storage_Order (T2))\n+              Reverse_Storage_Order (T1) /= Reverse_Storage_Order (T2))\n       then\n          return False;\n       end if;"}, {"sha": "cd262601cdb2d723e0bd86fe430a00c459280992", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -1248,14 +1248,8 @@ package body Sem_Ch4 is\n    -----------------------------\n \n    procedure Analyze_Case_Expression (N : Node_Id) is\n-      Expr      : constant Node_Id := Expression (N);\n-      FirstX    : constant Node_Id := Expression (First (Alternatives (N)));\n-      Alt       : Node_Id;\n-      Exp_Type  : Entity_Id;\n-      Exp_Btype : Entity_Id;\n-\n-      Dont_Care      : Boolean;\n-      Others_Present : Boolean;\n+      function Has_Static_Predicate (Subtyp : Entity_Id) return Boolean;\n+      --  Determine whether subtype Subtyp has aspect Static_Predicate\n \n       procedure Non_Static_Choice_Error (Choice : Node_Id);\n       --  Error routine invoked by the generic instantiation below when\n@@ -1270,6 +1264,28 @@ package body Sem_Ch4 is\n            Process_Associated_Node   => No_OP);\n       use Case_Choices_Processing;\n \n+      --------------------------\n+      -- Has_Static_Predicate --\n+      --------------------------\n+\n+      function Has_Static_Predicate (Subtyp : Entity_Id) return Boolean is\n+         Item : Node_Id;\n+\n+      begin\n+         Item := First_Rep_Item (Subtyp);\n+         while Present (Item) loop\n+            if Nkind (Item) = N_Aspect_Specification\n+              and then Chars (Identifier (Item)) = Name_Static_Predicate\n+            then\n+               return True;\n+            end if;\n+\n+            Next_Rep_Item (Item);\n+         end loop;\n+\n+         return False;\n+      end Has_Static_Predicate;\n+\n       -----------------------------\n       -- Non_Static_Choice_Error --\n       -----------------------------\n@@ -1280,6 +1296,17 @@ package body Sem_Ch4 is\n            (\"choice given in case expression is not static!\", Choice);\n       end Non_Static_Choice_Error;\n \n+      --  Local variables\n+\n+      Expr      : constant Node_Id := Expression (N);\n+      FirstX    : constant Node_Id := Expression (First (Alternatives (N)));\n+      Alt       : Node_Id;\n+      Exp_Type  : Entity_Id;\n+      Exp_Btype : Entity_Id;\n+\n+      Dont_Care      : Boolean;\n+      Others_Present : Boolean;\n+\n    --  Start of processing for Analyze_Case_Expression\n \n    begin\n@@ -1364,9 +1391,22 @@ package body Sem_Ch4 is\n          Exp_Type := Exp_Btype;\n       end if;\n \n+      --  The case expression alternatives cover the range of a static subtype\n+      --  subject to aspect Static_Predicate. Do not check the choices when the\n+      --  case expression has not been fully analyzed yet because this may lead\n+      --  to bogus errors.\n+\n+      if Is_Static_Subtype (Exp_Type)\n+        and then Has_Static_Predicate (Exp_Type)\n+        and then In_Spec_Expression\n+      then\n+         null;\n+\n       --  Call instantiated Analyze_Choices which does the rest of the work\n \n-      Analyze_Choices (N, Exp_Type, Dont_Care, Others_Present);\n+      else\n+         Analyze_Choices (N, Exp_Type, Dont_Care, Others_Present);\n+      end if;\n \n       if Exp_Type = Universal_Integer and then not Others_Present then\n          Error_Msg_N\n@@ -1896,10 +1936,9 @@ package body Sem_Ch4 is\n \n    begin\n       A := First (Actions (N));\n-      loop\n+      while Present (A) loop\n          Analyze (A);\n          Next (A);\n-         exit when No (A);\n       end loop;\n \n       --  This test needs a comment ???"}, {"sha": "ee72d575614633e400f559b29d63ffeb97fe7a87", "filename": "gcc/ada/set_targ.adb", "status": "added", "additions": 854, "deletions": 0, "changes": 854, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -0,0 +1,854 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E T _ T A R G                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Debug;    use Debug;\n+with Get_Targ; use Get_Targ;\n+with Opt;      use Opt;\n+with Output;   use Output;\n+\n+with System;        use System;\n+with System.OS_Lib; use System.OS_Lib;\n+\n+with Unchecked_Conversion;\n+\n+package body Set_Targ is\n+\n+   ---------------------------------------------\n+   -- Data Used to Read/Write target.atp File --\n+   ---------------------------------------------\n+\n+   File_Name : aliased constant String := \"target.atp\";\n+   --  Name of file to read/write\n+\n+   --  Table of string names written to file\n+\n+   subtype Str is String;\n+\n+   S_Bits_BE                    : constant Str := \"Bits_BE\";\n+   S_Bits_Per_Unit              : constant Str := \"Bits_Per_Unit\";\n+   S_Bits_Per_Word              : constant Str := \"Bits_Per_Word\";\n+   S_Bytes_BE                   : constant Str := \"Bytes_BE\";\n+   S_Char_Size                  : constant Str := \"Char_Size\";\n+   S_Double_Float_Alignment     : constant Str := \"Double_Float_Alignment\";\n+   S_Double_Scalar_Alignment    : constant Str := \"Double_Scalar_Alignment\";\n+   S_Double_Size                : constant Str := \"Double_Size\";\n+   S_Float_Size                 : constant Str := \"Float_Size\";\n+   S_Float_Words_BE             : constant Str := \"Float_Words_BE\";\n+   S_Int_Size                   : constant Str := \"Int_Size\";\n+   S_Long_Double_Size           : constant Str := \"Long_Double_Size\";\n+   S_Long_Long_Size             : constant Str := \"Long_Long_Size\";\n+   S_Long_Size                  : constant Str := \"Long_Size\";\n+   S_Maximum_Alignment          : constant Str := \"Maximum_Alignment\";\n+   S_Max_Unaligned_Field        : constant Str := \"Max_Unaligned_Field\";\n+   S_Pointer_Size               : constant Str := \"Pointer_Size\";\n+   S_Short_Size                 : constant Str := \"Short_Size\";\n+   S_Strict_Alignment           : constant Str := \"Strict_Alignment\";\n+   S_System_Allocator_Alignment : constant Str := \"System_Allocator_Alignment\";\n+   S_Wchar_T_Size               : constant Str := \"Wchar_T_Size\";\n+   S_Words_BE                   : constant Str := \"Words_BE\";\n+\n+   --  Table of names\n+\n+   type AStr is access all String;\n+\n+   DTN : constant array (Nat range <>) of AStr := (\n+          S_Bits_BE                    'Unrestricted_Access,\n+          S_Bits_Per_Unit              'Unrestricted_Access,\n+          S_Bits_Per_Word              'Unrestricted_Access,\n+          S_Bytes_BE                   'Unrestricted_Access,\n+          S_Char_Size                  'Unrestricted_Access,\n+          S_Double_Float_Alignment     'Unrestricted_Access,\n+          S_Double_Scalar_Alignment    'Unrestricted_Access,\n+          S_Double_Size                'Unrestricted_Access,\n+          S_Float_Size                 'Unrestricted_Access,\n+          S_Float_Words_BE             'Unrestricted_Access,\n+          S_Int_Size                   'Unrestricted_Access,\n+          S_Long_Double_Size           'Unrestricted_Access,\n+          S_Long_Long_Size             'Unrestricted_Access,\n+          S_Long_Size                  'Unrestricted_Access,\n+          S_Maximum_Alignment          'Unrestricted_Access,\n+          S_Max_Unaligned_Field        'Unrestricted_Access,\n+          S_Pointer_Size               'Unrestricted_Access,\n+          S_Short_Size                 'Unrestricted_Access,\n+          S_Strict_Alignment           'Unrestricted_Access,\n+          S_System_Allocator_Alignment 'Unrestricted_Access,\n+          S_Wchar_T_Size               'Unrestricted_Access,\n+          S_Words_BE                   'Unrestricted_Access);\n+\n+   --  Table of corresponding value pointers\n+\n+   DTV : constant array (Nat range <>) of System.Address := (\n+          Bits_BE                    'Address,\n+          Bits_Per_Unit              'Address,\n+          Bits_Per_Word              'Address,\n+          Bytes_BE                   'Address,\n+          Char_Size                  'Address,\n+          Double_Float_Alignment     'Address,\n+          Double_Scalar_Alignment    'Address,\n+          Double_Size                'Address,\n+          Float_Size                 'Address,\n+          Float_Words_BE             'Address,\n+          Int_Size                   'Address,\n+          Long_Double_Size           'Address,\n+          Long_Long_Size             'Address,\n+          Long_Size                  'Address,\n+          Maximum_Alignment          'Address,\n+          Max_Unaligned_Field        'Address,\n+          Pointer_Size               'Address,\n+          Short_Size                 'Address,\n+          Strict_Alignment           'Address,\n+          System_Allocator_Alignment 'Address,\n+          Wchar_T_Size               'Address,\n+          Words_BE                   'Address);\n+\n+   DTR : array (Nat range DTV'Range) of Boolean := (others => False);\n+   --  Table of flags used to validate that all values are present in file\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Fail (E : String);\n+   pragma No_Return (Fail);\n+   --  Terminate program with fatal error message passed as parameter\n+\n+   type C_String is array (0 .. 255) of aliased Character;\n+   pragma Convention (C, C_String);\n+   --  String long enough to hold any mode name for the following call\n+\n+   procedure Register_Float_Type\n+     (Name      : C_String;\n+      Digs      : Natural;\n+      Complex   : Boolean;\n+      Count     : Natural;\n+      Float_Rep : Float_Rep_Kind;\n+      Size      : Positive;\n+      Alignment : Natural);\n+   pragma Convention (C, Register_Float_Type);\n+   --  Call back to allow the back end to register available types. This call\n+   --  back makes entries in the FPT_Mode_Table for any floating point types\n+   --  reported by the back end. Name is the name of the type as a normal\n+   --  format Null-terminated string. Digs is the number of digits, where 0\n+   --  means it is not a fpt type (ignored during registration). Complex is\n+   --  non-zero if the type has real and imaginary parts (also ignored during\n+   --  registration). Count is the number of elements in a vector type (zero =\n+   --  not a vector, registration ignores vectors). Float_Rep shows the kind of\n+   --  floating-point type, and Size/Alignment are the size/alignment in bits.\n+   --\n+   --  So to summarize, the only types that are actually registered have Digs\n+   --  non-zero, Complex zero (false), and Count zero (not a vector).\n+\n+   ----------\n+   -- Fail --\n+   ----------\n+\n+   procedure Fail (E : String) is\n+      E_Fatal : constant := 4;\n+      --  Code for fatal error\n+   begin\n+      Write_Str (E);\n+      Write_Eol;\n+      OS_Exit (E_Fatal);\n+   end Fail;\n+\n+   -------------------------\n+   -- Register_Float_Type --\n+   -------------------------\n+\n+   procedure Register_Float_Type\n+     (Name      : C_String;\n+      Digs      : Natural;\n+      Complex   : Boolean;\n+      Count     : Natural;\n+      Float_Rep : Float_Rep_Kind;\n+      Size      : Positive;\n+      Alignment : Natural)\n+   is\n+      T    : String (1 .. Name'Length);\n+      Last : Natural := 0;\n+\n+      procedure Dump;\n+      --  Dump information given by the back end for the type to register\n+\n+      ----------\n+      -- Dump --\n+      ----------\n+\n+      procedure Dump is\n+      begin\n+         Write_Str (\"type \" & T (1 .. Last) & \" is \");\n+\n+         if Count > 0 then\n+            Write_Str (\"array (1 .. \");\n+            Write_Int (Int (Count));\n+\n+            if Complex then\n+               Write_Str (\", 1 .. 2\");\n+            end if;\n+\n+            Write_Str (\") of \");\n+\n+         elsif Complex then\n+            Write_Str (\"array (1 .. 2) of \");\n+         end if;\n+\n+         if Digs > 0 then\n+            Write_Str (\"digits \");\n+            Write_Int (Int (Digs));\n+            Write_Line (\";\");\n+\n+            Write_Str (\"pragma Float_Representation (\");\n+\n+            case Float_Rep is\n+               when IEEE_Binary =>\n+                  Write_Str (\"IEEE\");\n+\n+               when VAX_Native =>\n+                  case Digs is\n+                     when  6 =>\n+                        Write_Str (\"VAXF\");\n+\n+                     when  9 =>\n+                        Write_Str (\"VAXD\");\n+\n+                     when 15 =>\n+                        Write_Str (\"VAXG\");\n+\n+                     when others =>\n+                        Write_Str (\"VAX_\");\n+                        Write_Int (Int (Digs));\n+                  end case;\n+\n+               when AAMP =>         Write_Str (\"AAMP\");\n+            end case;\n+\n+            Write_Line (\", \" & T (1 .. Last) & \");\");\n+\n+         else\n+            Write_Str (\"mod 2**\");\n+            Write_Int (Int (Size / Positive'Max (1, Count)));\n+            Write_Line (\";\");\n+         end if;\n+\n+         Write_Str (\"for \" & T (1 .. Last) & \"'Size use \");\n+         Write_Int (Int (Size));\n+         Write_Line (\";\");\n+\n+         Write_Str (\"for \" & T (1 .. Last) & \"'Alignment use \");\n+         Write_Int (Int (Alignment / 8));\n+         Write_Line (\";\");\n+         Write_Eol;\n+      end Dump;\n+\n+   --  Start of processing for Register_Float_Type\n+\n+   begin\n+      --  Acquire name\n+\n+      for J in T'Range loop\n+         T (J) := Name (Name'First + J - 1);\n+\n+         if T (J) = ASCII.NUL then\n+            Last := J - 1;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Dump info if debug flag set\n+\n+      if Debug_Flag_Dot_B then\n+         Dump;\n+      end if;\n+\n+      --  Acquire entry if non-vector non-complex fpt type (digits non-zero)\n+\n+      if Digs > 0 and then not Complex and then Count = 0 then\n+         Num_FPT_Modes := Num_FPT_Modes + 1;\n+         FPT_Mode_Table (Num_FPT_Modes) :=\n+           (NAME      => new String'(T (1 .. Last)),\n+            DIGS      => Digs,\n+            FLOAT_REP => Float_Rep,\n+            SIZE      => Size,\n+            ALIGNMENT => Alignment);\n+      end if;\n+   end Register_Float_Type;\n+\n+   -----------------------------------\n+   -- Write_Target_Dependent_Values --\n+   -----------------------------------\n+\n+   --  We do this at the System.Os_Lib level, since we have to do the read at\n+   --  that level anyway, so it is easier and more consistent to follow the\n+   --  same path for the write.\n+\n+   procedure Write_Target_Dependent_Values is\n+      Fdesc  : File_Descriptor;\n+      OK     : Boolean;\n+\n+      Buffer : String (1 .. 80);\n+      Buflen : Natural;\n+      --  Buffer used to build line one of file\n+\n+      type ANat is access all Natural;\n+      --  Pointer to Nat or Pos value (it is harmless to treat Pos values and\n+      --  Nat values as Natural via Unchecked_Conversion).\n+\n+      function To_ANat is new Unchecked_Conversion (Address, ANat);\n+\n+      procedure AddC (C : Character);\n+      --  Add one character to buffer\n+\n+      procedure AddN (N : Natural);\n+      --  Add representation of integer N to Buffer, updating Buflen. N\n+      --  must be less than 1000, and output is 3 characters with leading\n+      --  spaces as needed.\n+\n+      procedure Write_Line;\n+      --  Output contents of Buffer (1 .. Buflen) followed by a New_Line,\n+      --  and set Buflen back to zero.\n+\n+      ----------\n+      -- AddC --\n+      ----------\n+\n+      procedure AddC (C : Character) is\n+      begin\n+         Buflen := Buflen + 1;\n+         Buffer (Buflen) := C;\n+      end AddC;\n+\n+      ----------\n+      -- AddN --\n+      ----------\n+\n+      procedure AddN (N : Natural) is\n+      begin\n+         if N > 999 then\n+            raise Program_Error;\n+         end if;\n+\n+         if N > 99 then\n+            AddC (Character'Val (48 + N / 100));\n+         else\n+            AddC (' ');\n+         end if;\n+\n+         if N > 9 then\n+            AddC (Character'Val (48 + N / 10 mod 10));\n+         else\n+            AddC (' ');\n+         end if;\n+\n+         AddC (Character'Val (48 + N mod 10));\n+      end AddN;\n+\n+      ----------------\n+      -- Write_Line --\n+      ----------------\n+\n+      procedure Write_Line is\n+      begin\n+         AddC (ASCII.LF);\n+\n+         if Buflen /= Write (Fdesc, Buffer'Address, Buflen) then\n+            Delete_File (File_Name'Address, OK);\n+            Fail (\"disk full writing target.atp\");\n+         end if;\n+\n+         Buflen := 0;\n+      end Write_Line;\n+\n+   --  Start of processing for Write_Target_Dependent_Values\n+\n+   begin\n+      Fdesc := Create_File (File_Name'Address, Text);\n+\n+      if Fdesc = Invalid_FD then\n+         Fail (\"cannot create target.atp\");\n+      end if;\n+\n+      --  Loop through values\n+\n+      for J in DTN'Range loop\n+\n+         --  Output name\n+\n+         Buflen := DTN (J)'Length;\n+         Buffer (1 .. Buflen) := DTN (J).all;\n+\n+         --  Line up values\n+\n+         while Buflen < 26 loop\n+            AddC (' ');\n+         end loop;\n+\n+         AddC (' ');\n+         AddC (' ');\n+\n+         --  Output value and write line\n+\n+         AddN (To_ANat (DTV (J)).all);\n+         Write_Line;\n+      end loop;\n+\n+      --  Blank line to separate sections\n+\n+      Write_Line;\n+\n+      --  Write lines for registered FPT types\n+\n+      for J in 1 .. Num_FPT_Modes loop\n+         declare\n+            E : FPT_Mode_Entry renames FPT_Mode_Table (J);\n+         begin\n+            Buflen := E.NAME'Last;\n+            Buffer (1 .. Buflen) := E.NAME.all;\n+\n+            --  Pad out to line up values\n+\n+            while Buflen < 11 loop\n+               AddC (' ');\n+            end loop;\n+\n+            AddC (' ');\n+            AddC (' ');\n+\n+            AddN (E.DIGS);\n+            AddC (' ');\n+            AddC (' ');\n+\n+            case E.FLOAT_REP is\n+               when IEEE_Binary =>\n+                  AddC ('I');\n+               when VAX_Native  =>\n+                  AddC ('V');\n+               when AAMP        =>\n+                  AddC ('A');\n+            end case;\n+\n+            AddC (' ');\n+\n+            AddN (E.SIZE);\n+            AddC (' ');\n+\n+            AddN (E.ALIGNMENT);\n+            Write_Line;\n+         end;\n+      end loop;\n+\n+      --  Close file\n+\n+      Close (Fdesc, OK);\n+\n+      if not OK then\n+         Fail (\"disk full writing target.atp\");\n+      end if;\n+   end Write_Target_Dependent_Values;\n+\n+--  Package Initialization, set target dependent values. This must be done\n+--  early on, before we start accessing various compiler packages, since\n+--  these values are used all over the place.\n+\n+begin\n+   --  First step: see if the -gnateT switch is present. As we have noted,\n+   --  this has to be done very early, so can not depend on the normal circuit\n+   --  for reading switches and setting switches in opt. The following code\n+   --  will set Opt.Target_Dependent_Info_Read if an option starting -gnatet\n+   --  is present in the options string.\n+\n+   declare\n+      type Arg_Array is array (Nat) of Big_String_Ptr;\n+      type Arg_Array_Ptr is access Arg_Array;\n+      --  Types to access compiler arguments\n+\n+      save_argc : Nat;\n+      pragma Import (C, save_argc);\n+      --  Saved value of argc (number of arguments), imported from misc.c\n+\n+      save_argv : Arg_Array_Ptr;\n+      pragma Import (C, save_argv);\n+      --  Saved value of argv (argument pointers), imported from misc.c\n+\n+   begin\n+      --  Loop through arguments looking for -gnateT, also look for -gnatd.b\n+\n+      for Arg in 1 .. save_argc - 1 loop\n+         declare\n+            Argv_Ptr : constant Big_String_Ptr := save_argv (Arg);\n+         begin\n+            if Argv_Ptr (1 .. 7) = \"-gnateT\" then\n+               Opt.Target_Dependent_Info_Read := True;\n+            elsif Argv_Ptr (1 .. 8) = \"-gnatd.b\" then\n+               Debug_Flag_Dot_B := True;\n+            end if;\n+         end;\n+      end loop;\n+   end;\n+\n+   --  If the switch is not set, we get all values from the back end\n+\n+   if not Opt.Target_Dependent_Info_Read then\n+\n+      --  Set values set by direct calls to the back end\n+\n+      Bits_BE                    := Get_Bits_BE;\n+      Bits_Per_Unit              := Get_Bits_Per_Unit;\n+      Bits_Per_Word              := Get_Bits_Per_Word;\n+      Bytes_BE                   := Get_Bytes_BE;\n+      Char_Size                  := Get_Char_Size;\n+      Double_Float_Alignment     := Get_Double_Float_Alignment;\n+      Double_Scalar_Alignment    := Get_Double_Scalar_Alignment;\n+      Double_Size                := Get_Double_Size;\n+      Float_Size                 := Get_Float_Size;\n+      Float_Words_BE             := Get_Float_Words_BE;\n+      Int_Size                   := Get_Int_Size;\n+      Long_Double_Size           := Get_Long_Double_Size;\n+      Long_Long_Size             := Get_Long_Long_Size;\n+      Long_Size                  := Get_Long_Size;\n+      Maximum_Alignment          := Get_Maximum_Alignment;\n+      Max_Unaligned_Field        := Get_Max_Unaligned_Field;\n+      Pointer_Size               := Get_Pointer_Size;\n+      Short_Size                 := Get_Short_Size;\n+      Strict_Alignment           := Get_Strict_Alignment;\n+      System_Allocator_Alignment := Get_System_Allocator_Alignment;\n+      Wchar_T_Size               := Get_Wchar_T_Size;\n+      Words_BE                   := Get_Words_BE;\n+\n+      --  Register floating-point types from the back end (depending on the\n+      --  back end in use, we have to do different things to get this info).\n+\n+      case Get_Back_End is\n+\n+         --  GCC back end, get information using Enumerate_Modes\n+\n+         when GCC =>\n+            declare\n+               type Register_Type_Proc is access procedure\n+                 (C_Name    : C_String;\n+                  Digs      : Natural;\n+                  Complex   : Boolean;\n+                  Count     : Natural;\n+                  Float_Rep : Float_Rep_Kind;\n+                  Size      : Positive;\n+                  Alignment : Natural);\n+               pragma Convention (C, Register_Type_Proc);\n+               --  Call back procedure for Register_Back_End_Types\n+\n+               procedure Enumerate_Modes (Call_Back : Register_Type_Proc);\n+               pragma Import (C, Enumerate_Modes, \"enumerate_modes\");\n+               --  Back end procedure that does the call backs (see misc.c)\n+\n+            begin\n+               Num_FPT_Modes := 0;\n+               Enumerate_Modes (Register_Float_Type'Access);\n+            end;\n+\n+         --  AAMP back end, supply the two needed types directly\n+\n+         when AAMP =>\n+            declare\n+               Str : C_String;\n+\n+            begin\n+               Str (1 .. 6) := \"float\" & ASCII.NUL;\n+               Register_Float_Type\n+                 (Name      => Str,\n+                  Digs      => 6,\n+                  Complex   => False,\n+                  Count     => 0,\n+                  Float_Rep => AAMP,\n+                  Size      => 32,\n+                  Alignment => 16);\n+\n+               Str (1 .. 7) := \"double\" & ASCII.NUL;\n+               Register_Float_Type\n+                 (Name      => Str,\n+                  Digs      => 9,\n+                  Complex   => False,\n+                  Count     => 0,\n+                  Float_Rep => AAMP,\n+                  Size      => 48,\n+                  Alignment => 16);\n+            end;\n+\n+            --  DotNet TBD\n+\n+         when DOTNET =>\n+            null;\n+      end case;\n+\n+      --  Case of reading the target dependent values from target.atp\n+\n+      --  This is bit more complex than might be expected, because it has to\n+      --  be done very early. All kinds of packages depend on these values,\n+      --  and we can't wait till the normal processing of reading command line\n+      --  switches etc to read the file. We do this at the System.OS_Lib level\n+      --  since it is too early to be using Osint directly.\n+\n+   else\n+      Read_File : declare\n+         File_Desc : File_Descriptor;\n+         N         : Natural;\n+\n+         type ANat is access all Natural;\n+         --  Pointer to Nat or Pos value (it is harmless to treat Pos values\n+         --  as Nat via Unchecked_Conversion).\n+\n+         function To_ANat is new Unchecked_Conversion (Address, ANat);\n+\n+         VP : ANat;\n+\n+         Buffer : String (1 .. 2000);\n+         Buflen : Natural;\n+         --  File information and length (2000 easily enough!)\n+\n+         Nam_Buf : String (1 .. 40);\n+         Nam_Len : Natural;\n+\n+         procedure Check_Spaces;\n+         --  Checks that we have one or more spaces and skips them\n+\n+         procedure FailN (S : String);\n+         --  Calls Fail prefixing \"target.atp: \" to the start of the given\n+         --  string, and \" name\" to the end where name is the currently\n+         --  gathered name in Nam_Buf, surrounded by quotes.\n+\n+         procedure Get_Name;\n+         --  Scan out name, leaving it in Nam_Buf with Nam_Len set. Calls\n+         --  Skip_Spaces to skip any following spaces. Note that the name is\n+         --  terminated by a sequence of at least two spaces.\n+\n+         function Get_Nat return Natural;\n+         --  N on entry points to decimal integer, scan out decimal integer\n+         --  and return it, leaving N pointing to following space or LF.\n+\n+         procedure Skip_Spaces;\n+         --  Skip past spaces\n+\n+         ------------------\n+         -- Check_Spaces --\n+         ------------------\n+\n+         procedure Check_Spaces is\n+         begin\n+            if N > Buflen or else Buffer (N) /= ' ' then\n+               FailN (\"missing space for\");\n+            end if;\n+\n+            Skip_Spaces;\n+            return;\n+         end Check_Spaces;\n+\n+         -----------\n+         -- FailN --\n+         -----------\n+\n+         procedure FailN (S : String) is\n+         begin\n+            Fail (\"target.atp: \" & S & \" \"\"\" & Nam_Buf (1 .. Nam_Len) & '\"');\n+         end FailN;\n+\n+         --------------\n+         -- Get_Name --\n+         --------------\n+\n+         procedure Get_Name is\n+         begin\n+            Nam_Len := 0;\n+\n+            --  Scan out name and put it in Nam_Buf\n+\n+            loop\n+               if N > Buflen or else Buffer (N) = ASCII.LF then\n+                  FailN (\"incorrectly formatted line for\");\n+               end if;\n+\n+               --  Name is terminated by two blanks\n+\n+               exit when N < Buflen and then Buffer (N .. N + 1) = \"  \";\n+\n+               Nam_Len := Nam_Len + 1;\n+\n+               if Nam_Len > Nam_Buf'Last then\n+                  Fail (\"name too long\");\n+               end if;\n+\n+               Nam_Buf (Nam_Len) := Buffer (N);\n+               N := N + 1;\n+            end loop;\n+\n+            Check_Spaces;\n+         end Get_Name;\n+\n+         -------------\n+         -- Get_Nat --\n+         -------------\n+\n+         function Get_Nat return Natural is\n+            Result : Natural := 0;\n+\n+         begin\n+            loop\n+               if N > Buflen\n+                 or else Buffer (N) not in '0' .. '9'\n+                 or else Result > 999\n+               then\n+                  FailN (\"bad value for\");\n+               end if;\n+\n+               Result := Result * 10 + (Character'Pos (Buffer (N)) - 48);\n+               N := N + 1;\n+\n+               exit when N <= Buflen\n+                 and then (Buffer (N) = ASCII.LF or else Buffer (N) = ' ');\n+            end loop;\n+\n+            return Result;\n+         end Get_Nat;\n+\n+         -----------------\n+         -- Skip_Spaces --\n+         -----------------\n+\n+         procedure Skip_Spaces is\n+         begin\n+            while N <= Buflen and Buffer (N) = ' ' loop\n+               N := N + 1;\n+            end loop;\n+         end Skip_Spaces;\n+\n+      --  Start of processing for Read_File\n+\n+      begin\n+         File_Desc := Open_Read (\"target.atp\", Text);\n+\n+         if File_Desc = Invalid_FD then\n+            Fail (\"cannot read target.atp file\");\n+         end if;\n+\n+         Buflen := Read (File_Desc, Buffer'Address, Buffer'Length);\n+\n+         if Buflen = Buffer'Length then\n+            Fail (\"target.atp file is too long\");\n+         end if;\n+\n+         --  Scan through file for properly formatted entries in first section\n+\n+         N := 1;\n+         while N <= Buflen and then Buffer (N) /= ASCII.LF loop\n+            Get_Name;\n+\n+            --  Validate name and get corresponding value pointer\n+\n+            VP := null;\n+\n+            for J in DTN'Range loop\n+               if DTN (J).all = Nam_Buf (1 .. Nam_Len) then\n+                  VP := To_ANat (DTV (J));\n+                  DTR (J) := True;\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            if VP = null then\n+               FailN (\"unrecognized name\");\n+            end if;\n+\n+            --  Scan out value\n+\n+            VP.all := Get_Nat;\n+\n+            if N > Buflen or else Buffer (N) /= ASCII.LF then\n+               FailN (\"misformatted line for\");\n+            end if;\n+\n+            N := N + 1; -- skip LF\n+         end loop;\n+\n+         --  Fall through this loop when all lines in first section read.\n+         --  Check that values have been supplied for all entries.\n+\n+         for J in DTR'Range loop\n+            if not DTR (J) then\n+               Fail (\"missing entry in target.atp for \" & DTN (J).all);\n+            end if;\n+         end loop;\n+\n+         --  Now acquire FPT entries\n+\n+         if N >= Buflen then\n+            Fail (\"target.atp is missing entries for FPT modes\");\n+         end if;\n+\n+         if Buffer (N) = ASCII.LF then\n+            N := N + 1;\n+         else\n+            Fail (\"target.atp is missing blank line\");\n+         end if;\n+\n+         Num_FPT_Modes := 0;\n+         while N <= Buflen loop\n+            Get_Name;\n+\n+            Num_FPT_Modes := Num_FPT_Modes + 1;\n+\n+            declare\n+               E : FPT_Mode_Entry renames FPT_Mode_Table (Num_FPT_Modes);\n+\n+            begin\n+               E.NAME := new String'(Nam_Buf (1 .. Nam_Len));\n+\n+               E.DIGS := Get_Nat;\n+               Check_Spaces;\n+\n+               case Buffer (N) is\n+                  when 'I'    =>\n+                     E.FLOAT_REP := IEEE_Binary;\n+                  when 'V'    =>\n+                     E.FLOAT_REP := VAX_Native;\n+                  when 'A'    =>\n+                     E.FLOAT_REP := AAMP;\n+                  when others =>\n+                     FailN (\"bad float rep field for\");\n+               end case;\n+\n+               N := N + 1;\n+               Check_Spaces;\n+\n+               E.SIZE := Get_Nat;\n+               Check_Spaces;\n+\n+               E.ALIGNMENT := Get_Nat;\n+\n+               if Buffer (N) /= ASCII.LF then\n+                  FailN (\"junk at end of line for\");\n+               end if;\n+\n+               N := N + 1;\n+            end;\n+         end loop;\n+      end Read_File;\n+   end if;\n+end Set_Targ;"}, {"sha": "5b5820c4b477644c653fbac7bf2a273ce16a6115", "filename": "gcc/ada/set_targ.ads", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fset_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fset_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.ads?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -0,0 +1,144 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             S E T _ T A R G                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package handles setting target dependent parameters. If the -gnatet\n+--  switch is not set, then these values are taken from the back end (via the\n+--  routines in Get_Targ, and the enumerate_modes routine in misc.c). If the\n+--  switch is set, then the values are read from the target.atp file in the\n+--  current directory (usually written with the Write_Target_Dependent_Values\n+--  procedure defined in this package).\n+\n+--  Note that all these values return sizes of C types with corresponding\n+--  names. This allows GNAT to define the corresponding Ada types to have\n+--  the same representation. There is one exception: the representation\n+--  of Wide_Character_Type uses twice the size of a C char, instead of the\n+--  size of wchar_t, since this corresponds to expected Ada usage.\n+\n+with Einfo; use Einfo;\n+with Types; use Types;\n+\n+package Set_Targ is\n+\n+   -----------------------------\n+   -- Target-Dependent Values --\n+   -----------------------------\n+\n+   --  The following is a table of target dependent values. In normal operation\n+   --  these values are set by calling the appropriate C backend routines that\n+   --  interface to back end routines that determine target characteristics.\n+\n+   --  If the -gnateT switch is used, then any values that are read from the\n+   --  file target.atp in the current directory overwrite values set from the\n+   --  back end. This is used by tools other than the compiler, e.g. to do\n+   --  semantic analysis of programs that will run on some other target than\n+   --  the machine on which the tool is run.\n+\n+   --  Note: fields marked with a question mark are boolean fields, where a\n+   --  value of 0 is False, and a value of 1 is True.\n+\n+   Bits_BE                    : Nat; -- Bits stored big-endian?\n+   Bits_Per_Unit              : Pos; -- Bits in a storage unit\n+   Bits_Per_Word              : Pos; -- Bits in a word\n+   Bytes_BE                   : Nat; -- Bytes stored big-endian?\n+   Char_Size                  : Pos; -- Standard.Character'Size\n+   Double_Float_Alignment     : Nat; -- Alignment of double float\n+   Double_Scalar_Alignment    : Nat; -- Alignment of double length scalar\n+   Double_Size                : Pos; -- Standard.Long_Float'Size\n+   Float_Size                 : Pos; -- Standard.Float'Size\n+   Float_Words_BE             : Nat; -- Float words stored big-endian?\n+   Int_Size                   : Pos; -- Standard.Integer'Size\n+   Long_Double_Size           : Pos; -- Standard.Long_Long_Float'Size\n+   Long_Long_Size             : Pos; -- Standard.Long_Long_Integer'Size\n+   Long_Size                  : Pos; -- Standard.Long_Integer'Size\n+   Maximum_Alignment          : Pos; -- Maximum permitted alignment\n+   Max_Unaligned_Field        : Pos; -- Maximum size for unaligned bit field\n+   Pointer_Size               : Pos; -- System.Address'Size\n+   Short_Size                 : Pos; -- Standard.Short_Integer'Size\n+   Strict_Alignment           : Nat; -- Strict alignment?\n+   System_Allocator_Alignment : Nat; -- Alignment for malloc calls\n+   Wchar_T_Size               : Pos; -- Interfaces.C.wchar_t'Size\n+   Words_BE                   : Nat; -- Words stored big-endian?\n+\n+   -------------------------------------\n+   -- Registered Floating-Point Types --\n+   -------------------------------------\n+\n+   --  This table contains the list of modes supported by the back-end as\n+   --  provided by the back end routine enumerate_modes in misc.c. Note that\n+   --  we only store floating-point modes (see Register_Float_Type).\n+\n+   type FPT_Mode_Entry is record\n+      NAME      : String_Ptr;     -- Name of mode (no null character at end)\n+      DIGS      : Natural;        -- Digits for floating-point type\n+      FLOAT_REP : Float_Rep_Kind; -- Float representation\n+      SIZE      : Natural;        -- Size in bits\n+      ALIGNMENT : Natural;        -- Alignment in bits\n+   end record;\n+\n+   FPT_Mode_Table : array (1 .. 1000) of FPT_Mode_Entry;\n+   Num_FPT_Modes  : Natural;\n+   --  Table containing the supported modes and number of entries\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Write_Target_Dependent_Values;\n+   --  This routine writes the file target.atp in the current directory with\n+   --  the values of the global target parameters as listed above, and as set\n+   --  by prior calls to Initialize/Read_Target_Dependent_Values. The format\n+   --  of the target.atp file is as follows\n+   --\n+   --    First come the values of the variables defined in this spec:\n+   --\n+   --      One line per value\n+   --\n+   --        name  value\n+   --\n+   --      where name is the name of the parameter, spelled out in full,\n+   --      and cased as in the above list, and value is an unsigned decimal\n+   --      integer. Two or more blanks separates the name from the value.\n+   --\n+   --      All the variables must be present, in alphabetical order (i.e. the\n+   --      same order as the declarations in this spec).\n+   --\n+   --   Then there is a blank line to separate the two parts of the file. Then\n+   --   come the lines showing the floating-point types to be registered.\n+   --\n+   --     One line per registered mode\n+   --\n+   --       name  digs float_rep size alignment\n+   --\n+   --     where name is the string name of the type (which can have single\n+   --     spaces embedded in the name (e.g. long double). The name is followed\n+   --     by at least two blanks. The following fields are as described above\n+   --     for a Mode_Entry (where float_rep is I/V/A for IEEE-754-Binary,\n+   --     Vax_Native, AAMP), fields are separated by at least one blank, and\n+   --     a LF character immediately follows the alignment field.\n+   --\n+   --    It is a fatal error to call this procedure if the target.atp file is\n+   --    not found in the current directory.\n+\n+end Set_Targ;"}, {"sha": "4706701e9b1081357842750aa50cd241b2d566a8", "filename": "gcc/ada/xgnatugn.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fxgnatugn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752b81d9c7c4bd1ee5136874ae0852a0127cc373/gcc%2Fada%2Fxgnatugn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxgnatugn.adb?ref=752b81d9c7c4bd1ee5136874ae0852a0127cc373", "patch": "@@ -85,12 +85,6 @@\n --       output. A line containing this escape sequence may not also contain\n --       a ^alpha^beta^ sequence.\n \n---       Process @ifset and @ifclear for the target flags (unw, vms);\n---       this is because we have menu problems if we let makeinfo handle\n---       these ifset/ifclear pairs.\n---       Note: @ifset/@ifclear commands for the edition flags (FSFEDITION,\n---       PROEDITION, GPLEDITION) are passed through unchanged\n-\n with Ada.Command_Line;           use Ada.Command_Line;\n with Ada.Strings;                use Ada.Strings;\n with Ada.Strings.Fixed;          use Ada.Strings.Fixed;"}]}