{"sha": "1d2aa262482fc9b23201200ca82aa3b8659b072e", "node_id": "C_kwDOANBUbNoAKDFkMmFhMjYyNDgyZmM5YjIzMjAxMjAwY2E4MmFhM2I4NjU5YjA3MmU", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-07-05T14:54:26Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-07-05T17:16:47Z"}, "message": "Provide a relation verification mechanism.\n\nProvide a relation oracle API which validates a relation between 2 ranges.\nThis allows relation queries that are symbolicly true to be overridden\nby range specific information.  ie. x == x is true symbolically, but for\nfloating point a NaN may invalidate this assumption.\n\n\t* value-relation.cc (relation_to_code): New vector.\n\t(relation_oracle::validate_relation): New.\n\t(set_relation): Allow ssa1 == ssa2 to be registered.\n\t* value-relation.h (validate_relation): New prototype.\n\t(query_relation): Make internal variant protected.", "tree": {"sha": "aed4d0661260354ea1124c1f6b66127502afa8cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed4d0661260354ea1124c1f6b66127502afa8cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d2aa262482fc9b23201200ca82aa3b8659b072e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2aa262482fc9b23201200ca82aa3b8659b072e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2aa262482fc9b23201200ca82aa3b8659b072e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2aa262482fc9b23201200ca82aa3b8659b072e/comments", "author": null, "committer": null, "parents": [{"sha": "c73e8d45ca0111f51d7187641963df97f5c9c63f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73e8d45ca0111f51d7187641963df97f5c9c63f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c73e8d45ca0111f51d7187641963df97f5c9c63f"}], "stats": {"total": 80, "additions": 75, "deletions": 5}, "files": [{"sha": "13ce44199f7319e8f673927c2b0a33cf5e958fa4", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d2aa262482fc9b23201200ca82aa3b8659b072e/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d2aa262482fc9b23201200ca82aa3b8659b072e/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=1d2aa262482fc9b23201200ca82aa3b8659b072e", "patch": "@@ -184,6 +184,71 @@ relation_transitive (relation_kind r1, relation_kind r2)\n   return rr_transitive_table[r1][r2];\n }\n \n+// This vector maps a relation to the equivalent tree code.\n+\n+tree_code relation_to_code [VREL_LAST + 1] = {\n+  ERROR_MARK, ERROR_MARK, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EQ_EXPR,\n+  NE_EXPR };\n+\n+// This routine validates that a relation can be applied to a specific set of\n+// ranges.  In particular, floating point x == x may not be true if the NaN bit\n+// is set in the range.  Symbolically the oracle will determine x == x,\n+// but specific range instances may override this.\n+// To verify, attempt to fold the relation using the supplied ranges.\n+// One would expect [1,1] to be returned, anything else means there is something\n+// in the range preventing the relation from applying.\n+// If there is no mechanism to verify, assume the relation is acceptable.\n+\n+relation_kind\n+relation_oracle::validate_relation (relation_kind rel, vrange &op1, vrange &op2)\n+{\n+  // If there is no mapping to a tree code, leave the relation as is.\n+  tree_code code = relation_to_code [rel];\n+  if (code == ERROR_MARK)\n+    return rel;\n+\n+  // Undefined ranges cannot be checked either.\n+  if (op1.undefined_p () || op2.undefined_p ())\n+    return rel;\n+\n+  tree t1 = op1.type ();\n+  tree t2 = op2.type ();\n+\n+  // If the range types are not compatible, no relation can exist.\n+  if (!range_compatible_p (t1, t2))\n+    return VREL_VARYING;\n+\n+  // If there is no handler, leave the relation as is.\n+  range_op_handler handler (code, t1);\n+  if (!handler)\n+    return rel;\n+\n+  // If the relation cannot be folded for any reason, leave as is.\n+  Value_Range result (boolean_type_node);\n+  if (!handler.fold_range (result, boolean_type_node, op1, op2, rel))\n+    return rel;\n+\n+  // The expression op1 REL op2 using REL should fold to [1,1].\n+  // Any other result means the relation is not verified to be true.\n+  if (result.varying_p () || result.zero_p ())\n+    return VREL_VARYING;\n+\n+  return rel;\n+}\n+\n+// If no range is available, create a varying range for each SSA name and\n+// verify.\n+\n+relation_kind\n+relation_oracle::validate_relation (relation_kind rel, tree ssa1, tree ssa2)\n+{\n+  Value_Range op1, op2;\n+  op1.set_varying (TREE_TYPE (ssa1));\n+  op2.set_varying (TREE_TYPE (ssa2));\n+\n+  return validate_relation (rel, op1, op2);\n+}\n+\n // Given an equivalence set EQUIV, set all the bits in B that are still valid\n // members of EQUIV in basic block BB.\n \n@@ -602,7 +667,8 @@ class value_relation\n inline void\n value_relation::set_relation (relation_kind r, tree n1, tree n2)\n {\n-  gcc_checking_assert (SSA_NAME_VERSION (n1) != SSA_NAME_VERSION (n2));\n+  gcc_checking_assert (SSA_NAME_VERSION (n1) != SSA_NAME_VERSION (n2)\n+\t\t       || r == VREL_EQ);\n   related = r;\n   name1 = n1;\n   name2 = n2;\n@@ -1199,7 +1265,7 @@ dom_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n   if (kind != VREL_VARYING)\n     return kind;\n \n-  // Query using the equiovalence sets.\n+  // Query using the equivalence sets.\n   kind = query_relation (bb, equiv1, equiv2);\n   return kind;\n }"}, {"sha": "77e12085eea521884a39187887b8dd207a268a65", "filename": "gcc/value-relation.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d2aa262482fc9b23201200ca82aa3b8659b072e/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d2aa262482fc9b23201200ca82aa3b8659b072e/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=1d2aa262482fc9b23201200ca82aa3b8659b072e", "patch": "@@ -95,15 +95,19 @@ class relation_oracle\n   virtual void register_relation (basic_block, relation_kind, tree, tree) = 0;\n   // Query for a relation between two ssa names in a basic block.\n   virtual relation_kind query_relation (basic_block, tree, tree) = 0;\n-  // Query for a relation between two equivalency stes in a basic block.\n-  virtual relation_kind query_relation (basic_block, const_bitmap,\n-\t\t\t\t\tconst_bitmap) = 0;\n+\n+  relation_kind validate_relation (relation_kind, tree, tree);\n+  relation_kind validate_relation (relation_kind, vrange &, vrange &);\n \n   virtual void dump (FILE *, basic_block) const = 0;\n   virtual void dump (FILE *) const = 0;\n   void debug () const;\n protected:\n   void valid_equivs (bitmap b, const_bitmap equivs, basic_block bb);\n+  // Query for a relation between two equivalency sets in a basic block.\n+  virtual relation_kind query_relation (basic_block, const_bitmap,\n+\t\t\t\t\tconst_bitmap) = 0;\n+  friend class path_oracle;\n };\n \n // This class represents an equivalency set, and contains a link to the next"}]}