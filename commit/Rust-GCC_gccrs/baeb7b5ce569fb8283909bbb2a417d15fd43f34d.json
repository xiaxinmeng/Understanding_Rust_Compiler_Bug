{"sha": "baeb7b5ce569fb8283909bbb2a417d15fd43f34d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFlYjdiNWNlNTY5ZmI4MjgzOTA5YmJiMmE0MTdkMTVmZDQzZjM0ZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2016-11-01T09:03:21Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-01T09:03:21Z"}, "message": "target-supports.exp: Normalize order of i?86 and x86_64 targets.\n\n\t* lib/target-supports.exp: Normalize order of i?86 and x86_64 targets.\n\tWhitespace fixes.\n\t(check_effective_target_vect_cmdline_needed): Check\n\tis-effective-target ia32 for x86 targets.\n\t(check_effective_target_vect_simd_clones): Simplify condition.\n\t(check_effective_target_vect_double): Ditto.\n\t(check_effective_target_vect_aligned_arrays): Check\n\tis-effective-target ia32 for x86 targets.  Simplify condition.\n\t(check_effective_target_vect_multiple_sizes): Simplify condition.\n\t(check_effective_target_sqrt_insn): Add i?86-*-* target.\n\t(check_effective_target_sync_int_128): Simplify condition.\n\t(check_effective_target_sync_int_128_runtime): Ditto.\n\t(check_effective_target_sync_long_long_runtime): Ditto.\n\t(check_effective_target_divmod): Add i?86-*-* target.\n\nFrom-SVN: r241733", "tree": {"sha": "e01e770cd5de2144e8e38fa9e761cd54c2313621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e01e770cd5de2144e8e38fa9e761cd54c2313621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baeb7b5ce569fb8283909bbb2a417d15fd43f34d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baeb7b5ce569fb8283909bbb2a417d15fd43f34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baeb7b5ce569fb8283909bbb2a417d15fd43f34d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baeb7b5ce569fb8283909bbb2a417d15fd43f34d/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d"}], "stats": {"total": 361, "additions": 179, "deletions": 182}, "files": [{"sha": "e57678e060dfafc67ee6dd8d1367e54a2910bc12", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baeb7b5ce569fb8283909bbb2a417d15fd43f34d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baeb7b5ce569fb8283909bbb2a417d15fd43f34d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=baeb7b5ce569fb8283909bbb2a417d15fd43f34d", "patch": "@@ -1,3 +1,20 @@\n+2016-11-01  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* lib/target-supports.exp: Normalize order of i?86 and x86_64 targets.\n+\tWhitespace fixes.\n+\t(check_effective_target_vect_cmdline_needed): Check\n+\tis-effective-target ia32 for x86 targets.\n+\t(check_effective_target_vect_simd_clones): Simplify condition.\n+\t(check_effective_target_vect_double): Ditto.\n+\t(check_effective_target_vect_aligned_arrays): Check\n+\tis-effective-target ia32 for x86 targets.  Simplify condition.\n+\t(check_effective_target_vect_multiple_sizes): Simplify condition.\n+\t(check_effective_target_sqrt_insn): Add i?86-*-* target.\n+\t(check_effective_target_sync_int_128): Simplify condition.\n+\t(check_effective_target_sync_int_128_runtime): Ditto.\n+\t(check_effective_target_sync_long_long_runtime): Ditto.\n+\t(check_effective_target_divmod): Add i?86-*-* target.\n+\n 2016-10-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/vsx-extract-4.c: New test."}, {"sha": "722955a04a1584489f9b2b5b7a2b909714593ed5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 162, "deletions": 182, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baeb7b5ce569fb8283909bbb2a417d15fd43f34d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baeb7b5ce569fb8283909bbb2a417d15fd43f34d/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=baeb7b5ce569fb8283909bbb2a417d15fd43f34d", "patch": "@@ -533,7 +533,7 @@ proc check_profiling_available { test_what } {\n     }\n \n     if { $test_what == \"-fauto-profile\" } {\n-\tif { ! ([istarget x86_64-*-linux*] || [istarget i?86-*-linux*]) } {\n+\tif { !([istarget i?86-*-linux*] || [istarget x86_64-*-linux*]) } {\n             verbose \"autofdo only supported on linux\"\n             return 0\n         }\n@@ -1521,7 +1521,7 @@ proc check_750cl_hw_available { } {\n proc check_sse_os_support_available { } {\n     return [check_cached_effective_target sse_os_support_available {\n \t# If this is not the right target then we can skip the test.\n-\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \t    expr 0\n \t} elseif { [istarget i?86-*-solaris2*] } {\n \t    # The Solaris 2 kernel doesn't save and restore SSE registers\n@@ -1545,7 +1545,7 @@ proc check_sse_os_support_available { } {\n proc check_avx_os_support_available { } {\n     return [check_cached_effective_target avx_os_support_available {\n \t# If this is not the right target then we can skip the test.\n-\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \t    expr 0\n \t} else {\n \t    # Check that OS has AVX and SSE saving enabled.\n@@ -1568,7 +1568,7 @@ proc check_avx_os_support_available { } {\n proc check_sse_hw_available { } {\n     return [check_cached_effective_target sse_hw_available {\n \t# If this is not the right target then we can skip the test.\n-\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \t    expr 0\n \t} else {\n \t    check_runtime_nocache sse_hw_available {\n@@ -1668,7 +1668,7 @@ proc check_mips_msa_hw_available { } {\n proc check_sse2_hw_available { } {\n     return [check_cached_effective_target sse2_hw_available {\n \t# If this is not the right target then we can skip the test.\n-\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \t    expr 0\n \t} else {\n \t    check_runtime_nocache sse2_hw_available {\n@@ -1691,7 +1691,7 @@ proc check_sse2_hw_available { } {\n proc check_sse4_hw_available { } {\n     return [check_cached_effective_target sse4_hw_available {\n \t# If this is not the right target then we can skip the test.\n-\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \t    expr 0\n \t} else {\n \t    check_runtime_nocache sse4_hw_available {\n@@ -1714,7 +1714,7 @@ proc check_sse4_hw_available { } {\n proc check_avx_hw_available { } {\n     return [check_cached_effective_target avx_hw_available {\n \t# If this is not the right target then we can skip the test.\n-\tif { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\tif { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \t    expr 0\n \t} else {\n \t    check_runtime_nocache avx_hw_available {\n@@ -2619,8 +2619,7 @@ proc check_effective_target___float128 { } {\n \treturn [check_ppc_float128_sw_available]\n     }\n     if { [istarget ia64-*-*]\n-\t || [istarget i?86-*-*]\n-\t || [istarget x86_64-*-*] } {\n+\t || [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n \treturn 1\n     }\n     return 0\n@@ -2776,9 +2775,8 @@ proc check_effective_target_vect_cmdline_needed { } {\n \tset et_vect_cmdline_needed_saved 1\n \tif { [istarget alpha*-*-*]\n \t     || [istarget ia64-*-*]\n-\t     || (([istarget x86_64-*-*] || [istarget i?86-*-*])\n-\t\t && ([check_effective_target_x32]\n-\t\t     || [check_effective_target_lp64]))\n+\t     || (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t\t && ![is-effective-target ia32])\n \t     || ([istarget powerpc*-*-*]\n \t\t && ([check_effective_target_powerpc_spe]\n \t\t     || [check_effective_target_powerpc_altivec]))\n@@ -2808,16 +2806,16 @@ proc check_effective_target_vect_int { } {\n \tset et_vect_int_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n              || ([istarget powerpc*-*-*]\n-                  && ![istarget powerpc-*-linux*paired*])\n-\t      || [istarget spu-*-*]\n-\t      || [istarget sparc*-*-*]\n-\t      || [istarget alpha*-*-*]\n-\t      || [istarget ia64-*-*] \n-\t      || [istarget aarch64*-*-*]\n-\t      || [check_effective_target_arm32]\n-\t      || ([istarget mips*-*-*]\n-\t\t  && ([et-is-effective-target mips_loongson]\n-\t\t      || [et-is-effective-target mips_msa])) } {\n+\t\t && ![istarget powerpc-*-linux*paired*])\n+\t     || [istarget spu-*-*]\n+\t     || [istarget sparc*-*-*]\n+\t     || [istarget alpha*-*-*]\n+\t     || [istarget ia64-*-*] \n+\t     || [istarget aarch64*-*-*]\n+\t     || [check_effective_target_arm32]\n+\t     || ([istarget mips*-*-*]\n+\t\t && ([et-is-effective-target mips_loongson]\n+\t\t     || [et-is-effective-target mips_msa])) } {\n \t    set et_vect_int_saved($et_index) 1\n \t}\n     }\n@@ -2840,13 +2838,13 @@ proc check_effective_target_vect_intfloat_cvt { } {\n     } else {\n \tset et_vect_intfloat_cvt_saved($et_index) 0\n         if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-              || ([istarget powerpc*-*-*]\n-                   && ![istarget powerpc-*-linux*paired*])\n-              || ([istarget arm*-*-*]\n-\t\t  && [check_effective_target_arm_neon_ok])\n-\t      || ([istarget mips*-*-*]\n-\t\t  && [et-is-effective-target mips_msa]) } {\n-\t   set et_vect_intfloat_cvt_saved($et_index) 1\n+\t     || ([istarget powerpc*-*-*]\n+\t\t && ![istarget powerpc-*-linux*paired*])\n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok])\n+\t     || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa]) } {\n+\t    set et_vect_intfloat_cvt_saved($et_index) 1\n         }\n     }\n \n@@ -2882,14 +2880,14 @@ proc check_effective_target_vect_uintfloat_cvt { } {\n     } else {\n \tset et_vect_uintfloat_cvt_saved($et_index) 0\n         if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t      || ([istarget powerpc*-*-*]\n-\t\t  && ![istarget powerpc-*-linux*paired*])\n-\t      || [istarget aarch64*-*-*]\n-\t      || ([istarget arm*-*-*]\n-\t\t  && [check_effective_target_arm_neon_ok])\n-\t      || ([istarget mips*-*-*]\n-\t\t  && [et-is-effective-target mips_msa]) } {\n-\t   set et_vect_uintfloat_cvt_saved($et_index) 1\n+\t     || ([istarget powerpc*-*-*]\n+\t\t && ![istarget powerpc-*-linux*paired*])\n+\t     || [istarget aarch64*-*-*]\n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok])\n+\t     || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa]) } {\n+\t    set et_vect_uintfloat_cvt_saved($et_index) 1\n         }\n     }\n \n@@ -2912,13 +2910,13 @@ proc check_effective_target_vect_floatint_cvt { } {\n     } else {\n \tset et_vect_floatint_cvt_saved($et_index) 0\n         if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-              || ([istarget powerpc*-*-*]\n-                   && ![istarget powerpc-*-linux*paired*])\n-              || ([istarget arm*-*-*]\n-\t\t  && [check_effective_target_arm_neon_ok])\n-\t      || ([istarget mips*-*-*]\n-\t\t  && [et-is-effective-target mips_msa]) } {\n-\t   set et_vect_floatint_cvt_saved($et_index) 1\n+\t     || ([istarget powerpc*-*-*]\n+\t\t && ![istarget powerpc-*-linux*paired*])\n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok])\n+\t     || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa]) } {\n+\t    set et_vect_floatint_cvt_saved($et_index) 1\n         }\n     }\n \n@@ -2966,14 +2964,13 @@ proc check_effective_target_vect_simd_clones { } {\n \tverbose \"check_effective_target_vect_simd_clones: using cached result\" 2\n     } else {\n \tset et_vect_simd_clones_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n-\t    # On i?86/x86_64 #pragma omp declare simd builds a sse2, avx, avx2\n-\t    # and avx512f clone.  Only the right clone for the specified arch\n-\t    # will be chosen, but still we need to at least be able to assemble\n-\t    # avx512f.\n-\t    if { [check_effective_target_avx512f] } {\n-\t\tset et_vect_simd_clones_saved($et_index) 1\n-\t    }\n+\t# On i?86/x86_64 #pragma omp declare simd builds a sse2, avx,\n+\t# avx2 and avx512f clone.  Only the right clone for the\n+\t# specified arch will be chosen, but still we need to at least\n+\t# be able to assemble avx512f.\n+\tif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t      && [check_effective_target_avx512f]) } {\n+\t    set et_vect_simd_clones_saved($et_index) 1\n \t}\n     }\n \n@@ -4778,7 +4775,7 @@ proc check_effective_target_vect_shift { } {\n     } else {\n \tset et_vect_shift_saved($et_index) 0\n \tif { ([istarget powerpc*-*-*]\n-             && ![istarget powerpc-*-linux*paired*])\n+\t      && ![istarget powerpc-*-linux*paired*])\n \t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget aarch64*-*-*]\n@@ -4896,16 +4893,16 @@ proc check_effective_target_vect_float { } {\n     } else {\n \tset et_vect_float_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t      || [istarget powerpc*-*-*]\n-\t      || [istarget spu-*-*]\n-\t      || [istarget mips-sde-elf]\n-\t      || [istarget mipsisa64*-*-*]\n-\t      || [istarget ia64-*-*]\n-\t      || [istarget aarch64*-*-*]\n-\t      || ([istarget mips*-*-*]\n-\t\t  && [et-is-effective-target mips_msa])\n-\t      || [check_effective_target_arm32] } {\n-\t   set et_vect_float_saved($et_index) 1\n+\t     || [istarget powerpc*-*-*]\n+\t     || [istarget spu-*-*]\n+\t     || [istarget mips-sde-elf]\n+\t     || [istarget mipsisa64*-*-*]\n+\t     || [istarget ia64-*-*]\n+\t     || [istarget aarch64*-*-*]\n+\t     || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa])\n+\t     || [check_effective_target_arm32] } {\n+\t    set et_vect_float_saved($et_index) 1\n \t}\n     }\n \n@@ -4926,22 +4923,18 @@ proc check_effective_target_vect_double { } {\n \tverbose \"check_effective_target_vect_double: using cached result\" 2\n     } else {\n \tset et_vect_double_saved($et_index) 0\n-\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t     || [istarget aarch64*-*-*] } {\n-\t   if { [check_no_compiler_messages vect_double assembly {\n-\t\t #ifdef __tune_atom__\n-\t\t # error No double vectorizer support.\n-\t\t #endif\n-\t\t}] } {\n-\t\tset et_vect_double_saved($et_index) 1\n-\t    } else {\n-\t\tset et_vect_double_saved($et_index) 0\n-\t    }\n-\t} elseif { [istarget spu-*-*]\n-\t\t   || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n-\t\t   || ([istarget mips*-*-*]\n-\t\t       && [et-is-effective-target mips_msa]) } {\n-\t   set et_vect_double_saved($et_index) 1\n+\tif { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t      && [check_no_compiler_messages vect_double assembly {\n+\t\t  #ifdef __tune_atom__\n+\t\t  # error No double vectorizer support.\n+\t\t  #endif\n+\t      }])\n+\t     || [istarget aarch64*-*-*]\n+\t     || [istarget spu-*-*]\n+\t     || ([istarget powerpc*-*-*] && [check_vsx_hw_available])\n+\t     || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa]) } {\n+\t    set et_vect_double_saved($et_index) 1\n \t}\n     }\n \n@@ -4963,8 +4956,8 @@ proc check_effective_target_vect_long_long { } {\n     } else {\n \tset et_vect_long_long_saved($et_index) 0\n \tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t      || ([istarget mips*-*-*]\n-\t\t  && [et-is-effective-target mips_msa]) } {\n+\t     || ([istarget mips*-*-*]\n+\t\t && [et-is-effective-target mips_msa]) } {\n \t   set et_vect_long_long_saved($et_index) 1\n         }\n     }\n@@ -5293,12 +5286,12 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n \t  set et_vect_widen_mult_hi_to_si_saved($et_index) 0\n         }\n         if { [istarget powerpc*-*-*]\n-\t      || [istarget spu-*-*]\n-\t      || [istarget ia64-*-*]\n-\t      || [istarget aarch64*-*-*]\n-\t      || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-\t      || ([istarget arm*-*-*]\n-\t\t  && [check_effective_target_arm_neon_ok]) } {\n+\t     || [istarget spu-*-*]\n+\t     || [istarget ia64-*-*]\n+\t     || [istarget aarch64*-*-*]\n+\t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok]) } {\n \t    set et_vect_widen_mult_hi_to_si_saved($et_index) 1\n         }\n     }\n@@ -5348,12 +5341,12 @@ proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n     } else {\n \tset et_vect_widen_mult_hi_to_si_pattern_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n-              || [istarget spu-*-*]\n-              || [istarget ia64-*-*]\n-              || [istarget i?86-*-*] || [istarget x86_64-*-*]\n-              || ([istarget arm*-*-*]\n-\t\t  && [check_effective_target_arm_neon_ok]\n-\t\t  && [check_effective_target_arm_little_endian]) } {\n+\t     || [istarget spu-*-*]\n+\t     || [istarget ia64-*-*]\n+\t     || [istarget i?86-*-*] || [istarget x86_64-*-*]\n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok]\n+\t\t && [check_effective_target_arm_little_endian]) } {\n \t    set et_vect_widen_mult_hi_to_si_pattern_saved($et_index) 1\n         }\n     }\n@@ -5520,7 +5513,7 @@ proc check_effective_target_vect_usad_char { } {\n         verbose \"check_effective_target_vect_usad_char: using cached result\" 2\n     } else {\n \tset et_vect_usad_char_saved($et_index) 0\n-        if { ([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n+        if { [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n \t    set et_vect_usad_char_saved($et_index) 1\n         }\n     }\n@@ -5665,16 +5658,13 @@ proc check_effective_target_vect_hw_misalign { } {\n \n proc check_effective_target_vect_aligned_arrays { } {\n     set et_vect_aligned_arrays 0\n-    if { ([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n-\tif { ([is-effective-target lp64]\n-\t      && ( ![check_avx_available]\n-\t\t || [check_prefer_avx128])) } {\n-\t     set et_vect_aligned_arrays 1\n-\t}\n-    }\n-    if [istarget spu-*-*] {\n+    if { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t  && !([is-effective-target ia32]\n+\t       || ([check_avx_available] && ![check_prefer_avx128])))\n+\t || [istarget spu-*-*] } {\n \tset et_vect_aligned_arrays 1\n     }\n+\n     verbose \"check_effective_target_vect_aligned_arrays:\\\n \t     returning $et_vect_aligned_arrays\" 2\n     return $et_vect_aligned_arrays\n@@ -5988,7 +5978,7 @@ proc check_effective_target_vect_interleave { } {\n \t     || ([istarget mips*-*-*]\n \t\t && ([et-is-effective-target mpaired_single]\n \t\t     || [et-is-effective-target mips_msa])) } {\n-\t   set et_vect_interleave_saved($et_index) 1\n+\t    set et_vect_interleave_saved($et_index) 1\n         }\n     }\n \n@@ -6034,14 +6024,11 @@ proc check_effective_target_vect_multiple_sizes { } {\n     global et_index\n \n     set et_vect_multiple_sizes_saved($et_index) 0\n-    if { ([istarget aarch64*-*-*]\n-\t  || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])) } {\n-       set et_vect_multiple_sizes_saved($et_index) 1\n-    }\n-    if { ([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n-      if { ([check_avx_available] && ![check_prefer_avx128]) } {\n+    if { [istarget aarch64*-*-*]\n+\t || ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])\n+\t || (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t     && ([check_avx_available] && ![check_prefer_avx128])) } {\n \tset et_vect_multiple_sizes_saved($et_index) 1\n-      }\n     }\n \n     verbose \"check_effective_target_vect_multiple_sizes:\\\n@@ -6104,7 +6091,7 @@ proc check_effective_target_sqrt_insn { } {\n \tverbose \"check_effective_target_hw_sqrt: using cached result\" 2\n     } else {\n \tset et_sqrt_insn_saved 0\n-\tif { [istarget x86_64-*-*]\n+\tif { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || ([istarget arm*-*-*] && [check_effective_target_arm_vfp_ok]) } {\n@@ -6142,8 +6129,8 @@ proc check_effective_target_vect_call_sqrtf { } {\n \n proc check_effective_target_vect_call_lrint { } {\n     set et_vect_call_lrint 0\n-    if { ([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t && [check_effective_target_ilp32] } {\n+    if { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t  && [check_effective_target_ilp32]) } {\n \tset et_vect_call_lrint 1\n     }\n \n@@ -6417,10 +6404,9 @@ proc check_effective_target_section_anchors { } {\n # Return 1 if the target supports atomic operations on \"int_128\" values.\n \n proc check_effective_target_sync_int_128 { } {\n-    if { ([istarget x86_64-*-*] || [istarget i?86-*-*])\n-\t && ![is-effective-target ia32] } {\n-\treturn 1\n-    } elseif { [istarget spu-*-*] } {\n+    if { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t  && ![is-effective-target ia32])\n+\t || [istarget spu-*-*] } {\n \treturn 1\n     } else {\n \treturn 0\n@@ -6431,21 +6417,21 @@ proc check_effective_target_sync_int_128 { } {\n # and can execute them.\n \n proc check_effective_target_sync_int_128_runtime { } {\n-    if { ([istarget x86_64-*-*] || [istarget i?86-*-*])\n-\t && ![is-effective-target ia32] } {\n-\treturn [check_cached_effective_target sync_int_128_available {\n-\t    check_runtime_nocache sync_int_128_available {\n-\t\t#include \"cpuid.h\"\n-\t\tint main ()\n-\t\t{\n-\t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-\t\t    return !(ecx & bit_CMPXCHG16B);\n-\t\t  return 1;\n-\t\t}\n-\t    } \"\"\n-\t}]\n-    } elseif { [istarget spu-*-*] } {\n+    if { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t  && ![is-effective-target ia32]\n+\t  && [check_cached_effective_target sync_int_128_available {\n+\t      check_runtime_nocache sync_int_128_available {\n+\t\t  #include \"cpuid.h\"\n+\t\t  int main ()\n+\t\t  {\n+\t\t      unsigned int eax, ebx, ecx, edx;\n+\t\t      if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+\t\t\treturn !(ecx & bit_CMPXCHG16B);\n+\t\t      return 1;\n+\t\t  }\n+\t      } \"\"\n+\t  }])\n+\t || [istarget spu-*-*] } {\n \treturn 1\n     } else {\n \treturn 0\n@@ -6458,7 +6444,7 @@ proc check_effective_target_sync_int_128_runtime { } {\n # Note: 32bit s390 targets require -mzarch in dg-options.\n \n proc check_effective_target_sync_long_long { } {\n-    if { [istarget x86_64-*-*] || [istarget i?86-*-*])\n+    if { [istarget i?86-*-*] || [istarget x86_64-*-*])\n \t || [istarget aarch64*-*-*]\n \t || [istarget arm*-*-*]\n \t || [istarget alpha*-*-*]\n@@ -6477,46 +6463,43 @@ proc check_effective_target_sync_long_long { } {\n # Note: 32bit x86 targets require -march=pentium in dg-options.\n \n proc check_effective_target_sync_long_long_runtime { } {\n-    if { [istarget x86_64-*-*] || [istarget i?86-*-*] } {\n-\treturn [check_cached_effective_target sync_long_long_available {\n-\t    check_runtime_nocache sync_long_long_available {\n-\t\t#include \"cpuid.h\"\n-\t\tint main ()\n-\t\t{\n-\t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-\t\t    return !(edx & bit_CMPXCHG8B);\n-\t\t  return 1;\n-\t\t}\n-\t    } \"\"\n-\t}]\n-    } elseif { [istarget aarch64*-*-*] } {\n-\treturn 1\n-    } elseif { [istarget arm*-*-linux-*] } {\n-\treturn [check_runtime sync_longlong_runtime {\n-\t    #include <stdlib.h>\n-\t    int main ()\n-\t    {\n-\t      long long l1;\n-\n-\t      if (sizeof (long long) != 8)\n-\t\texit (1);\n+    if { (([istarget x86_64-*-*] || [istarget i?86-*-*])\n+\t  && [check_cached_effective_target sync_long_long_available {\n+\t      check_runtime_nocache sync_long_long_available {\n+\t\t  #include \"cpuid.h\"\n+\t\t  int main ()\n+\t\t  {\n+\t\t      unsigned int eax, ebx, ecx, edx;\n+\t\t      if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+\t\t\treturn !(edx & bit_CMPXCHG8B);\n+\t\t      return 1;\n+\t\t  }\n+\t      } \"\"\n+\t  }])\n+\t || [istarget aarch64*-*-*]\n+\t || ([istarget arm*-*-linux-*]\n+\t     && [check_runtime sync_longlong_runtime {\n+\t\t #include <stdlib.h>\n+\t\t int main ()\n+\t\t {\n+\t\t     long long l1;\n \n-\t      /* Just check for native; checking for kernel fallback is tricky.  */\n-\t      asm volatile (\"ldrexd r0,r1, [%0]\" : : \"r\" (&l1) : \"r0\", \"r1\");\n+\t\t     if (sizeof (long long) != 8)\n+\t\t     exit (1);\n \n-\t      exit (0);\n-\t    }\n-\t} \"\" ]\n-    } elseif { [istarget alpha*-*-*] } {\n-\treturn 1\n-    } elseif { ([istarget sparc*-*-*]\n-\t\t && [check_effective_target_lp64]\n-\t\t && [check_effective_target_ultrasparc_hw]) } {\n-\treturn 1\n-    } elseif { [istarget spu-*-*] } {\n-\treturn 1\n-    } elseif { [istarget powerpc*-*-*] && [check_effective_target_lp64] } {\n+\t\t     /* Just check for native;\n+\t\t\tchecking for kernel fallback is tricky.  */\n+\t\t     asm volatile (\"ldrexd r0,r1, [%0]\"\n+\t\t\t\t   : : \"r\" (&l1) : \"r0\", \"r1\");\n+\t\t     exit (0);\n+\t\t }\n+\t     } \"\" ])\n+\t || [istarget alpha*-*-*]\n+\t || ([istarget sparc*-*-*]\n+\t     && [check_effective_target_lp64]\n+\t     && [check_effective_target_ultrasparc_hw])\n+\t || [istarget spu-*-*]\n+\t || ([istarget powerpc*-*-*] && [check_effective_target_lp64]) } {\n \treturn 1\n     } else {\n \treturn 0\n@@ -6538,18 +6521,15 @@ proc check_effective_target_bswap { } {\n \t     || [istarget m68k-*-*]\n \t     || [istarget powerpc*-*-*]\n \t     || [istarget rs6000-*-*]\n-\t     || [istarget s390*-*-*] } {\n-\t    set et_bswap_saved 1\n-\t} else {\n-\t    if { [istarget arm*-*-*]\n+\t     || [istarget s390*-*-*]\n+\t     || ([istarget arm*-*-*]\n \t\t && [check_no_compiler_messages_nocache arm_v6_or_later object {\n \t\t     #if __ARM_ARCH < 6\n \t\t     #error not armv6 or later\n \t\t     #endif\n \t\t     int i;\n-\t\t } \"\"] } {\n+\t\t } \"\"]) } {\n \t\tset et_bswap_saved 1\n-\t    }\n \t}\n     }\n \n@@ -7228,7 +7208,7 @@ proc check_effective_target_avx512f { } {\n # Return 1 if avx instructions can be compiled.\n \n proc check_effective_target_avx { } {\n-    if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+    if { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \treturn 0\n     }\n     return [check_no_compiler_messages avx object {\n@@ -7894,7 +7874,7 @@ proc check_effective_target_pie_copyreloc { } {\n     global tool\n     global GCC_UNDER_TEST\n \n-    if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+    if { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \treturn 0\n     }\n \n@@ -7946,7 +7926,7 @@ proc check_effective_target_got32x_reloc { } {\n     global tool\n     global GCC_UNDER_TEST\n \n-    if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+    if { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \treturn 0\n     }\n \n@@ -7997,7 +7977,7 @@ proc check_effective_target_tls_get_addr_via_got { } {\n     global tool\n     global GCC_UNDER_TEST\n \n-    if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+    if { !([istarget i?86-*-*] || [istarget x86_64-*-*]) } {\n \treturn 0\n     }\n \n@@ -8110,7 +8090,7 @@ proc check_effective_target_divmod { } {\n     #TODO: Add checks for all targets that have either hardware divmod insn\n     # or define libfunc for divmod.\n     if { [istarget arm*-*-*]\n-\t || [istarget x86_64-*-*] } {\n+\t || [istarget i?86-*-*] || [istarget x86_64-*-*] } {\n \treturn 1\n     }\n     return 0"}]}