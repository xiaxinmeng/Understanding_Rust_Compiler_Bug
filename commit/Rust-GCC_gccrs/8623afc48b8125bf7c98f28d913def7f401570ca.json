{"sha": "8623afc48b8125bf7c98f28d913def7f401570ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyM2FmYzQ4YjgxMjViZjdjOThmMjhkOTEzZGVmN2Y0MDE1NzBjYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-06-29T08:10:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-06-29T08:10:20Z"}, "message": "decl.c (gnat_to_gnu_entity): If the type requires strict alignment, then set the RM size to the type size.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: If the\n\ttype requires strict alignment, then set the RM size to the type size.\n\tRework handling of alignment and sizes of tagged types in ASIS mode.\n\t(validate_size): Rename local variable and remove special handling for\n\tstrict-alignment types.\n\t* gcc-interface/utils.c (finish_record_type): Constify local variables\n\tand use properly typed constants.\n\nFrom-SVN: r272820", "tree": {"sha": "716529cf3ec42c151359f725dc3e5bedfada5f11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/716529cf3ec42c151359f725dc3e5bedfada5f11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8623afc48b8125bf7c98f28d913def7f401570ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8623afc48b8125bf7c98f28d913def7f401570ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8623afc48b8125bf7c98f28d913def7f401570ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8623afc48b8125bf7c98f28d913def7f401570ca/comments", "author": null, "committer": null, "parents": [{"sha": "26cf78991015e0f96f9bc4d771816322e58e56ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26cf78991015e0f96f9bc4d771816322e58e56ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26cf78991015e0f96f9bc4d771816322e58e56ec"}], "stats": {"total": 162, "additions": 87, "deletions": 75}, "files": [{"sha": "157ca3684d001ef2022b8e0d0e27f4a05c5b54c4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8623afc48b8125bf7c98f28d913def7f401570ca", "patch": "@@ -1,3 +1,13 @@\n+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Record_Type>: If the\n+\ttype requires strict alignment, then set the RM size to the type size.\n+\tRework handling of alignment and sizes of tagged types in ASIS mode.\n+\t(validate_size): Rename local variable and remove special handling for\n+\tstrict-alignment types.\n+\t* gcc-interface/utils.c (finish_record_type): Constify local variables\n+\tand use properly typed constants.\n+\n 2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_field): Rework error messages for"}, {"sha": "e99aeb4ad0f26767f48dbac82de58e7153d924fe", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 57, "deletions": 59, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8623afc48b8125bf7c98f28d913def7f401570ca", "patch": "@@ -3004,9 +3004,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    SET_TYPE_ALIGN (gnu_type, 0);\n \n-\t    /* If a type needs strict alignment, the minimum size will be the\n-\t       type size instead of the RM size (see validate_size).  Cap the\n-\t       alignment lest it causes this type size to become too large.  */\n+\t    /* If a type needs strict alignment, then its type size will also\n+\t       be the RM size (see below).  Cap the alignment if needed, lest\n+\t       it may cause this type size to become too large.  */\n \t    if (Strict_Alignment (gnat_entity) && Known_RM_Size (gnat_entity))\n \t      {\n \t\tunsigned int max_size = UI_To_Int (RM_Size (gnat_entity));\n@@ -3283,6 +3283,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\tcompute_record_mode (gnu_type);\n \t      }\n \n+\t    /* If the type needs strict alignment, then no object of the type\n+\t       may have a size smaller than the natural size, which means that\n+\t       the RM size of the type is equal to the type size.  */\n+\t    if (Strict_Alignment (gnat_entity))\n+\t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_SIZE (gnu_type));\n+\n \t    /* If there are entities in the chain corresponding to components\n \t       that we did not elaborate, ensure we elaborate their types if\n \t       they are Itypes.  */\n@@ -4187,7 +4193,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t already defined so we cannot pass true for IN_PLACE here.  */\n       process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \n-      /* ??? Don't set the size for a String_Literal since it is either\n+      /* See if a size was specified, by means of either an Object_Size or\n+         a regular Size clause, and validate it if so.\n+\n+\t ??? Don't set the size for a String_Literal since it is either\n \t confirming or we don't handle it properly (if the low bound is\n \t non-constant).  */\n       if (!gnu_size && kind != E_String_Literal_Subtype)\n@@ -4309,49 +4318,44 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t  /* If we are just annotating types and the type is tagged, the tag\n \t     and the parent components are not generated by the front-end so\n-\t     alignment and sizes must be adjusted if there is no rep clause.  */\n-\t  if (type_annotate_only\n-\t      && Is_Tagged_Type (gnat_entity)\n-\t      && Unknown_RM_Size (gnat_entity)\n-\t      && !VOID_TYPE_P (gnu_type)\n-\t      && (!TYPE_FIELDS (gnu_type)\n-\t\t  || integer_zerop (bit_position (TYPE_FIELDS (gnu_type)))))\n+\t     alignment and sizes must be adjusted.  */\n+\t  if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n \t    {\n-\t      tree offset;\n-\n-\t      if (Is_Derived_Type (gnat_entity))\n-\t\t{\n-\t\t  Entity_Id gnat_parent = Etype (Base_Type (gnat_entity));\n-\t\t  offset = UI_To_gnu (Esize (gnat_parent), bitsizetype);\n-\t\t  Set_Alignment (gnat_entity, Alignment (gnat_parent));\n-\t\t}\n-\t      else\n+\t      const bool derived_p = Is_Derived_Type (gnat_entity);\n+\t      const Entity_Id gnat_parent\n+\t\t= derived_p ? Etype (Base_Type (gnat_entity)) : Empty;\n+\t      const unsigned int inherited_align\n+\t\t= derived_p\n+\t\t  ? UI_To_Int (Alignment (gnat_parent)) * BITS_PER_UNIT\n+\t\t  : POINTER_SIZE;\n+\t      const unsigned int align\n+\t\t= MAX (TYPE_ALIGN (gnu_type), inherited_align);\n+\n+\t      Set_Alignment (gnat_entity, UI_From_Int (align / BITS_PER_UNIT));\n+\n+\t      /* If there is neither size clause nor representation clause, the\n+\t\t sizes need to be adjusted.  */\n+\t      if (Unknown_RM_Size (gnat_entity)\n+\t\t  && !VOID_TYPE_P (gnu_type)\n+\t\t  && (!TYPE_FIELDS (gnu_type)\n+\t\t      || integer_zerop (bit_position (TYPE_FIELDS (gnu_type)))))\n \t\t{\n-\t\t  unsigned int align\n-\t\t    = MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n-\t\t  offset = bitsize_int (POINTER_SIZE);\n-\t\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t\t  tree offset\n+\t\t    = derived_p\n+\t\t      ? UI_To_gnu (Esize (gnat_parent), bitsizetype)\n+\t\t      : bitsize_int (POINTER_SIZE);\n+\t\t  if (TYPE_FIELDS (gnu_type))\n+\t\t    offset\n+\t\t      = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n+\t\t  gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n \t\t}\n \n-\t      if (TYPE_FIELDS (gnu_type))\n-\t\toffset\n-\t\t  = round_up (offset, DECL_ALIGN (TYPE_FIELDS (gnu_type)));\n-\n-\t      gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n-\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n-\t      Uint uint_size = annotate_value (gnu_size);\n-\t      Set_RM_Size (gnat_entity, uint_size);\n-\t      Set_Esize (gnat_entity, uint_size);\n-\t    }\n-\n-\t  /* If there is a rep clause, only adjust alignment and Esize.  */\n-\t  else if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n-\t    {\n-\t      unsigned int align\n-\t\t= MAX (TYPE_ALIGN (gnu_type), POINTER_SIZE) / BITS_PER_UNIT;\n-\t      Set_Alignment (gnat_entity, UI_From_Int (align));\n-\t      gnu_size = round_up (gnu_size, POINTER_SIZE);\n+\t      gnu_size = round_up (gnu_size, align);\n \t      Set_Esize (gnat_entity, annotate_value (gnu_size));\n+\n+\t      /* Tagged types are Strict_Alignment so RM_Size = Esize.  */\n+\t      if (Unknown_RM_Size (gnat_entity))\n+\t\tSet_RM_Size (gnat_entity, Esize (gnat_entity));\n \t    }\n \n \t  /* Otherwise no adjustment is needed.  */\n@@ -8732,7 +8736,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n \t       enum tree_code kind, bool component_p, bool zero_ok)\n {\n   Node_Id gnat_error_node;\n-  tree type_size, size;\n+  tree old_size, size;\n \n   /* Return 0 if no size was specified.  */\n   if (uint_size == No_Uint)\n@@ -8797,17 +8801,11 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       && TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n     size = size_binop (PLUS_EXPR, DECL_SIZE (TYPE_FIELDS (gnu_type)), size);\n \n-  if (kind == VAR_DECL\n-      /* If a type needs strict alignment, a component of this type in\n-\t a packed record cannot be packed and thus uses the type size.  */\n-      || (kind == TYPE_DECL && Strict_Alignment (gnat_object)))\n-    type_size = TYPE_SIZE (gnu_type);\n-  else\n-    type_size = rm_size (gnu_type);\n+  old_size = (kind == VAR_DECL ? TYPE_SIZE (gnu_type) : rm_size (gnu_type));\n \n-  /* Modify the size of a discriminated type to be the maximum size.  */\n-  if (type_size && CONTAINS_PLACEHOLDER_P (type_size))\n-    type_size = max_size (type_size, true);\n+  /* If the old size is self-referential, get the maximum size.  */\n+  if (CONTAINS_PLACEHOLDER_P (old_size))\n+    old_size = max_size (old_size, true);\n \n   /* If this is an access type or a fat pointer, the minimum size is that given\n      by the smallest integral mode that's valid for pointers.  */\n@@ -8816,23 +8814,23 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       scalar_int_mode p_mode = NARROWEST_INT_MODE;\n       while (!targetm.valid_pointer_mode (p_mode))\n \tp_mode = GET_MODE_WIDER_MODE (p_mode).require ();\n-      type_size = bitsize_int (GET_MODE_BITSIZE (p_mode));\n+      old_size = bitsize_int (GET_MODE_BITSIZE (p_mode));\n     }\n \n   /* Issue an error either if the default size of the object isn't a constant\n      or if the new size is smaller than it.  */\n-  if (TREE_CODE (type_size) != INTEGER_CST\n-      || TREE_OVERFLOW (type_size)\n-      || tree_int_cst_lt (size, type_size))\n+  if (TREE_CODE (old_size) != INTEGER_CST\n+      || TREE_OVERFLOW (old_size)\n+      || tree_int_cst_lt (size, old_size))\n     {\n       if (component_p)\n \tpost_error_ne_tree\n \t  (\"component size for& too small{, minimum allowed is ^}\",\n-\t   gnat_error_node, gnat_object, type_size);\n+\t   gnat_error_node, gnat_object, old_size);\n       else\n \tpost_error_ne_tree\n \t  (\"size for& too small{, minimum allowed is ^}\",\n-\t   gnat_error_node, gnat_object, type_size);\n+\t   gnat_error_node, gnat_object, old_size);\n       return NULL_TREE;\n     }\n "}, {"sha": "9da606e1494d13c93e2b051d4ed3b3f0088437f8", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=8623afc48b8125bf7c98f28d913def7f401570ca", "patch": "@@ -1859,13 +1859,18 @@ void\n finish_record_type (tree record_type, tree field_list, int rep_level,\n \t\t    bool debug_info_p)\n {\n-  enum tree_code code = TREE_CODE (record_type);\n+  const enum tree_code orig_code = TREE_CODE (record_type);\n+  const bool had_size = TYPE_SIZE (record_type) != NULL_TREE;\n+  const bool had_size_unit = TYPE_SIZE_UNIT (record_type) != NULL_TREE;\n+  const bool had_align = TYPE_ALIGN (record_type) > 0;\n+  /* For all-repped records with a size specified, lay the QUAL_UNION_TYPE\n+     out just like a UNION_TYPE, since the size will be fixed.  */\n+  const enum tree_code code\n+    = (orig_code == QUAL_UNION_TYPE && rep_level > 0 && had_size\n+       ? UNION_TYPE : orig_code);\n   tree name = TYPE_IDENTIFIER (record_type);\n   tree ada_size = bitsize_zero_node;\n   tree size = bitsize_zero_node;\n-  bool had_size = TYPE_SIZE (record_type) != 0;\n-  bool had_size_unit = TYPE_SIZE_UNIT (record_type) != 0;\n-  bool had_align = TYPE_ALIGN (record_type) != 0;\n   tree field;\n \n   TYPE_FIELDS (record_type) = field_list;\n@@ -1878,26 +1883,21 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n      that just means some initializations; otherwise, layout the record.  */\n   if (rep_level > 0)\n     {\n-      SET_TYPE_ALIGN (record_type, MAX (BITS_PER_UNIT,\n-\t\t\t\t\tTYPE_ALIGN (record_type)));\n-\n-      if (!had_size_unit)\n-\tTYPE_SIZE_UNIT (record_type) = size_zero_node;\n+      if (TYPE_ALIGN (record_type) < BITS_PER_UNIT)\n+\tSET_TYPE_ALIGN (record_type, BITS_PER_UNIT);\n \n       if (!had_size)\n \tTYPE_SIZE (record_type) = bitsize_zero_node;\n \n-      /* For all-repped records with a size specified, lay the QUAL_UNION_TYPE\n-\t out just like a UNION_TYPE, since the size will be fixed.  */\n-      else if (code == QUAL_UNION_TYPE)\n-\tcode = UNION_TYPE;\n+      if (!had_size_unit)\n+\tTYPE_SIZE_UNIT (record_type) = size_zero_node;\n     }\n   else\n     {\n       /* Ensure there isn't a size already set.  There can be in an error\n \t case where there is a rep clause but all fields have errors and\n \t no longer have a position.  */\n-      TYPE_SIZE (record_type) = 0;\n+      TYPE_SIZE (record_type) = NULL_TREE;\n \n       /* Ensure we use the traditional GCC layout for bitfields when we need\n \t to pack the record type or have a representation clause.  The other"}, {"sha": "d2d59903dd3e5fd1b865a24b6f5f2295e29e7c68", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8623afc48b8125bf7c98f28d913def7f401570ca", "patch": "@@ -1,3 +1,7 @@\n+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/size_clause3.ads: Adjust error message.\n+\n 2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/atomic2.ads: Adjust error message."}, {"sha": "12ca2d1aba6e8432b080dcd8367e4b80fac23531", "filename": "gcc/testsuite/gnat.dg/specs/size_clause3.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8623afc48b8125bf7c98f28d913def7f401570ca/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads?ref=8623afc48b8125bf7c98f28d913def7f401570ca", "patch": "@@ -14,7 +14,7 @@ package Size_Clause3 is\n     rr : R1; -- size must be 40\n   end record;\n   for S1 use record\n-    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. with aliased or tagged\" }\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. too small\" }\n   end record;\n \n   -- The record is explicitly given alignment 1 so its real type is 40.\n@@ -44,7 +44,7 @@ package Size_Clause3 is\n     rr : R3; -- size must be 40\n   end record;\n   for S3 use record\n-    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. with aliased or tagged\" }\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size for .rr. too small\" }\n   end record;\n \n end Size_Clause3;"}]}