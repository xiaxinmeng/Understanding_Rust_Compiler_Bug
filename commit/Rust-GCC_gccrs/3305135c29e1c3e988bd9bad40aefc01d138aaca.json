{"sha": "3305135c29e1c3e988bd9bad40aefc01d138aaca", "node_id": "C_kwDOANBUbNoAKDMzMDUxMzVjMjllMWMzZTk4OGJkOWJhZDQwYWVmYzAxZDEzOGFhY2E", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-12-14T15:50:27Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-12-14T15:50:27Z"}, "message": "Determine global memory accesses in ipa-modref\n\nAs discussed in PR103585, fatigue2 is now only benchmark from my usual testing\nset (SPEC2k6, SPEC2k17, CPP benchmarks, polyhedron, Firefox, clang) which sees\nimportant regression when inlining functions called once is limited.  This\nprevents us from solving runtime issues in roms benchmarks and elsewhere.\n\nThe problem is that there is perdida function that takes many arguments and\nsome of them are array descriptors.  We constant propagate most of their fields\nbut still keep their initialization. Because perdida is quite fast, the call\noverhead dominates, since we need over 100 memory stores consuing about 35%\nof the overall benchmark runtime.\n\nThe memory stores would be eliminated if perdida did not call fortran I/O which\nmakes modref to thin that the array descriptors could be accessed. We are\nquite close discovering that they can't becuase they are non-escaping from\nfunction.  This patch makes modref to distingush between global memory access\n(only things that escapes) and unkonwn accesss (that may access also\nnonescaping things reaching the function).  This makes disambiguation for\nfunctions containing error handling better.\n\nUnfortunately the patch hits two semi-latent issues in Fortran frontned.\nFirst is wrong code in gfortran.dg/unlimited_polymorphic_3.f03. This can be\nturned into wrong code testcase on both mainline and gcc11 if the runtime\ncall is removed, so I filled PR 103662 for it. There is TBAA mismatch for\nstructure produced in FE.\n\nSecond is issue with GOMP where Fortran marks certain parameters as non-escaping\nand then makes them escape via GOMP_parallel.  For this I disabled the use of\nescape info in verify_arg which also disables the useful transform on perdida\nbut still does useful work for e.g. GCC error handling.  I will work on this\nincrementally.\n\nBootstrapped/regtested x86_64-linux, lto-bootstrapped and also tested with\nclang build.  I plan to commit this tomorrow if there are no complains\n(the patch is not completely short but conceptualy simple and handles a lot\nof common cases).\n\ngcc/ChangeLog:\n\n2021-12-12  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/103585\n\t* ipa-modref-tree.c (modref_access_node::range_info_useful_p): Handle\n\tMODREF_GLOBAL_MEMORY_PARM.\n\t(modref_access_node::dump): Likewise.\n\t(modref_access_node::get_call_arg): Likewise.\n\t* ipa-modref-tree.h (enum modref_special_parms): Add\n\tMODREF_GLOBAL_MEMORY_PARM.\n\t(modref_access_node::useful_for_kill): Handle\n\tMODREF_GLOBAL_MEMORY_PARM.\n\t(modref:tree::merge): Add promote_unknown_to_global.\n\t* ipa-modref.c (verify_arg):New function.\n\t(may_access_nonescaping_parm_p): New function.\n\t(modref_access_analysis::record_global_memory_load): New member\n\tfunction.\n\t(modref_access_analysis::record_global_memory_store): Likewise.\n\t(modref_access_analysis::process_fnspec): Distingush global and local\n\tmemory.\n\t(modref_access_analysis::analyze_call): Likewise.\n\t* tree-ssa-alias.c (ref_may_access_global_memory_p): New function.\n\t(modref_may_conflict): Use it.\n\ngcc/testsuite/ChangeLog:\n\n2021-12-12  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.dg/analyzer/data-model-1.c: Disable ipa-modref.\n\t* gcc.dg/uninit-38.c: Likewise.\n\t* gcc.dg/uninit-pr98578.c: Liewise.", "tree": {"sha": "3f0da4068b4a95c7f1796caa91e7c44dd2ca62ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f0da4068b4a95c7f1796caa91e7c44dd2ca62ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3305135c29e1c3e988bd9bad40aefc01d138aaca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3305135c29e1c3e988bd9bad40aefc01d138aaca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3305135c29e1c3e988bd9bad40aefc01d138aaca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3305135c29e1c3e988bd9bad40aefc01d138aaca/comments", "author": null, "committer": null, "parents": [{"sha": "44aa890d8fb4afa843cf6cb7452fd5d6f3dd61fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44aa890d8fb4afa843cf6cb7452fd5d6f3dd61fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44aa890d8fb4afa843cf6cb7452fd5d6f3dd61fe"}], "stats": {"total": 240, "additions": 214, "deletions": 26}, "files": [{"sha": "64ef0772343f6702f7138fc4503621e2da31af71", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -36,7 +36,8 @@ modref_access_node::operator == (modref_access_node &a) const\n {\n   if (parm_index != a.parm_index)\n     return false;\n-  if (parm_index != MODREF_UNKNOWN_PARM)\n+  if (parm_index != MODREF_UNKNOWN_PARM\n+      && parm_index != MODREF_GLOBAL_MEMORY_PARM)\n     {\n       if (parm_offset_known != a.parm_offset_known)\n \treturn false;\n@@ -613,7 +614,9 @@ modref_access_node::insert (vec <modref_access_node, va_gc> *&accesses,\n bool\n modref_access_node::range_info_useful_p () const\n {\n-  return parm_index != MODREF_UNKNOWN_PARM && parm_offset_known\n+  return parm_index != MODREF_UNKNOWN_PARM\n+\t && parm_index != MODREF_GLOBAL_MEMORY_PARM\n+\t && parm_offset_known\n \t && (known_size_p (size)\n \t     || known_size_p (max_size)\n \t     || known_ge (offset, 0));\n@@ -625,7 +628,9 @@ modref_access_node::dump (FILE *out)\n {\n   if (parm_index != MODREF_UNKNOWN_PARM)\n     {\n-      if (parm_index >= 0)\n+      if (parm_index == MODREF_GLOBAL_MEMORY_PARM)\n+\tfprintf (out, \" Base in global memory\");\n+      else if (parm_index >= 0)\n \tfprintf (out, \" Parm %i\", parm_index);\n       else if (parm_index == MODREF_STATIC_CHAIN_PARM)\n \tfprintf (out, \" Static chain\");\n@@ -655,7 +660,8 @@ modref_access_node::dump (FILE *out)\n tree\n modref_access_node::get_call_arg (const gcall *stmt) const\n {\n-  if (parm_index == MODREF_UNKNOWN_PARM)\n+  if (parm_index == MODREF_UNKNOWN_PARM\n+      || parm_index == MODREF_GLOBAL_MEMORY_PARM)\n     return NULL;\n   if (parm_index == MODREF_STATIC_CHAIN_PARM)\n     return gimple_call_chain (stmt);"}, {"sha": "94fcebda4680d3e4421fd3e3252087b44c4e75b4", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -48,10 +48,12 @@ enum modref_special_parms {\n   MODREF_UNKNOWN_PARM = -1,\n   MODREF_STATIC_CHAIN_PARM = -2,\n   MODREF_RETSLOT_PARM = -3,\n+  /* Used for bases that points to memory that escapes from function.  */\n+  MODREF_GLOBAL_MEMORY_PARM = -4,\n   /* Used in modref_parm_map to tak references which can be removed\n      from the summary during summary update since they now points to loca\n      memory.  */\n-  MODREF_LOCAL_MEMORY_PARM = -4\n+  MODREF_LOCAL_MEMORY_PARM = -5\n };\n \n /* Modref record accesses relative to function parameters.\n@@ -86,6 +88,7 @@ struct GTY(()) modref_access_node\n   bool useful_for_kill_p () const\n     {\n       return parm_offset_known && parm_index != MODREF_UNKNOWN_PARM\n+\t     && parm_index != MODREF_GLOBAL_MEMORY_PARM\n \t     && parm_index != MODREF_RETSLOT_PARM && known_size_p (size)\n \t     && known_eq (max_size, size)\n \t     && known_gt (size, 0);\n@@ -175,6 +178,7 @@ struct GTY((user)) modref_ref_node\n        in the caller.  */\n     gcc_checking_assert (a.parm_index >= 0\n \t\t\t || a.parm_index == MODREF_STATIC_CHAIN_PARM\n+\t\t\t || a.parm_index == MODREF_GLOBAL_MEMORY_PARM\n \t\t\t || a.parm_index == MODREF_UNKNOWN_PARM);\n \n     if (!a.useful_p ())\n@@ -524,7 +528,8 @@ struct GTY((user)) modref_tree\n \t      unsigned int max_accesses,\n \t      modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n \t      modref_parm_map *static_chain_map,\n-\t      bool record_accesses)\n+\t      bool record_accesses,\n+\t      bool promote_unknown_to_global = false)\n   {\n     if (!other || every_base)\n       return false;\n@@ -579,7 +584,9 @@ struct GTY((user)) modref_tree\n \t\t  {\n \t\t    modref_access_node a = *access_node;\n \n-\t\t    if (a.parm_index != MODREF_UNKNOWN_PARM && parm_map)\n+\t\t    if (a.parm_index != MODREF_UNKNOWN_PARM\n+\t\t\t&& a.parm_index != MODREF_GLOBAL_MEMORY_PARM\n+\t\t\t&& parm_map)\n \t\t      {\n \t\t\tif (a.parm_index >= (int)parm_map->length ())\n \t\t\t  a.parm_index = MODREF_UNKNOWN_PARM;\n@@ -596,6 +603,9 @@ struct GTY((user)) modref_tree\n \t\t\t    a.parm_index = m.parm_index;\n \t\t\t  }\n \t\t      }\n+\t\t    if (a.parm_index == MODREF_UNKNOWN_PARM\n+\t\t\t&& promote_unknown_to_global)\n+\t\t      a.parm_index = MODREF_GLOBAL_MEMORY_PARM;\n \t\t    changed |= insert (max_bases, max_refs, max_accesses,\n \t\t\t\t       base_node->base, ref_node->ref,\n \t\t\t\t       a, record_accesses);\n@@ -614,12 +624,14 @@ struct GTY((user)) modref_tree\n   bool merge (tree fndecl,\n \t      modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n \t      modref_parm_map *static_chain_map,\n-\t      bool record_accesses)\n+\t      bool record_accesses,\n+\t      bool promote_unknown_to_global = false)\n   {\n      return merge (opt_for_fn (fndecl, param_modref_max_bases),\n \t\t   opt_for_fn (fndecl, param_modref_max_refs),\n \t\t   opt_for_fn (fndecl, param_modref_max_accesses),\n-\t\t   other, parm_map, static_chain_map, record_accesses);\n+\t\t   other, parm_map, static_chain_map, record_accesses,\n+\t\t   promote_unknown_to_global);\n   }\n \n   /* Copy OTHER to THIS.  */\n@@ -657,7 +669,8 @@ struct GTY((user)) modref_tree\n \t    if (ref_node->every_access)\n \t      return true;\n \t    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n-\t      if (access_node->parm_index == MODREF_UNKNOWN_PARM)\n+\t      if (access_node->parm_index == MODREF_UNKNOWN_PARM\n+\t\t  || access_node->parm_index == MODREF_GLOBAL_MEMORY_PARM)\n \t\treturn true;\n \t  }\n       }"}, {"sha": "d3590f0b62bbff43838b0d4e37338cf3c2411f7e", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 146, "deletions": 14, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -869,6 +869,66 @@ parm_map_for_ptr (tree op)\n   return parm_map;\n }\n \n+/* Return true if ARG with EAF flags FLAGS can not make any caller's parameter\n+   used (if LOAD is true we check loads, otherwise stores).  */\n+\n+static bool\n+verify_arg (tree arg, int flags, bool load)\n+{\n+  if (flags & EAF_UNUSED)\n+    return true;\n+  if (load && (flags & EAF_NO_DIRECT_READ))\n+    return true;\n+  if (!load\n+      && (flags & (EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER))\n+\t  == (EAF_NO_DIRECT_CLOBBER | EAF_NO_INDIRECT_CLOBBER))\n+    return true;\n+  if (is_gimple_constant (arg))\n+    return true;\n+  if (DECL_P (arg) && TREE_READONLY (arg))\n+    return true;\n+  if (TREE_CODE (arg) == ADDR_EXPR)\n+    {\n+      tree t = get_base_address (TREE_OPERAND (arg, 0));\n+      if (is_gimple_constant (t))\n+\treturn true;\n+      if (DECL_P (t)\n+\t  && (TREE_READONLY (t) || TREE_CODE (t) == FUNCTION_DECL))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if STMT may access memory that is pointed to by parameters\n+   of caller and which is not seen as an escape by PTA.\n+   CALLEE_ECF_FLAGS are ECF flags of callee.  If LOAD is true then by access\n+   we mean load, otherwise we mean store.  */\n+\n+static bool\n+may_access_nonescaping_parm_p (gcall *call, int callee_ecf_flags, bool load)\n+{\n+  int implicit_flags = 0;\n+\n+  if (ignore_stores_p (current_function_decl, callee_ecf_flags))\n+    implicit_flags |= ignore_stores_eaf_flags;\n+  if (callee_ecf_flags & ECF_PURE)\n+    implicit_flags |= implicit_pure_eaf_flags;\n+  if (callee_ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+    implicit_flags |= implicit_const_eaf_flags;\n+  if (gimple_call_chain (call)\n+      && !verify_arg (gimple_call_chain (call),\n+\t\t      gimple_call_static_chain_flags (call) | implicit_flags,\n+\t\t      load))\n+    return true;\n+  for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n+    if (!verify_arg (gimple_call_arg (call, i),\n+\t\t     gimple_call_arg_flags (call, i) | implicit_flags,\n+\t\t     load))\n+      return true;\n+  return false;\n+}\n+\n+\n /* Analyze memory accesses (loads, stores and kills) performed\n    by the function.  Set also side_effects, calls_interposable\n    and nondeterminism flags.  */\n@@ -892,6 +952,8 @@ class modref_access_analysis\n   bool record_access_p (tree);\n   bool record_unknown_load ();\n   bool record_unknown_store ();\n+  bool record_global_memory_load ();\n+  bool record_global_memory_store ();\n   bool merge_call_side_effects (gimple *, modref_summary *,\n \t\t\t\tcgraph_node *, bool);\n   modref_access_node get_access_for_fnspec (gcall *, attr_fnspec &,\n@@ -1149,6 +1211,41 @@ modref_access_analysis::record_unknown_store ()\n   return changed;\n }\n \n+/* Record unknown load from gloal memory.  */\n+\n+bool\n+modref_access_analysis::record_global_memory_load ()\n+{\n+  bool changed = false;\n+  modref_access_node a = {0, -1, -1,\n+\t\t\t  0, MODREF_GLOBAL_MEMORY_PARM, false, 0};\n+\n+  if (m_summary && !m_summary->loads->every_base)\n+    changed |= m_summary->loads->insert (current_function_decl, 0, 0, a, false);\n+  if (m_summary_lto && !m_summary_lto->loads->every_base)\n+    changed |= m_summary_lto->loads->insert (current_function_decl,\n+\t\t\t\t\t     0, 0, a, false);\n+  return changed;\n+}\n+\n+/* Record unknown store from gloal memory.  */\n+\n+bool\n+modref_access_analysis::record_global_memory_store ()\n+{\n+  bool changed = false;\n+  modref_access_node a = {0, -1, -1,\n+\t\t\t  0, MODREF_GLOBAL_MEMORY_PARM, false, 0};\n+\n+  if (m_summary && !m_summary->stores->every_base)\n+    changed |= m_summary->stores->insert (current_function_decl,\n+\t\t\t\t\t  0, 0, a, false);\n+  if (m_summary_lto && !m_summary_lto->stores->every_base)\n+    changed |= m_summary_lto->stores->insert (current_function_decl,\n+\t\t\t\t\t     0, 0, a, false);\n+  return changed;\n+}\n+\n /* Merge side effects of call STMT to function with CALLEE_SUMMARY.\n    Return true if something changed.\n    If IGNORE_STORES is true, do not merge stores.\n@@ -1160,7 +1257,8 @@ modref_access_analysis::merge_call_side_effects\n \t (gimple *stmt, modref_summary *callee_summary,\n \t  cgraph_node *callee_node, bool record_adjustments)\n {\n-  int flags = gimple_call_flags (stmt);\n+  gcall *call = as_a <gcall *> (stmt);\n+  int flags = gimple_call_flags (call);\n \n   /* Nothing to do for non-looping cont functions.  */\n   if ((flags & (ECF_CONST | ECF_NOVOPS))\n@@ -1223,10 +1321,10 @@ modref_access_analysis::merge_call_side_effects\n     fprintf (dump_file, \"   Parm map:\");\n \n   auto_vec <modref_parm_map, 32> parm_map;\n-  parm_map.safe_grow_cleared (gimple_call_num_args (stmt), true);\n-  for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n+  parm_map.safe_grow_cleared (gimple_call_num_args (call), true);\n+  for (unsigned i = 0; i < gimple_call_num_args (call); i++)\n     {\n-      parm_map[i] = parm_map_for_ptr (gimple_call_arg (stmt, i));\n+      parm_map[i] = parm_map_for_ptr (gimple_call_arg (call, i));\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \" %i\", parm_map[i].parm_index);\n@@ -1240,9 +1338,9 @@ modref_access_analysis::merge_call_side_effects\n     }\n \n   modref_parm_map chain_map;\n-  if (gimple_call_chain (stmt))\n+  if (gimple_call_chain (call))\n     {\n-      chain_map = parm_map_for_ptr (gimple_call_chain (stmt));\n+      chain_map = parm_map_for_ptr (gimple_call_chain (call));\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"static chain %i\", chain_map.parm_index);\n@@ -1262,7 +1360,7 @@ modref_access_analysis::merge_call_side_effects\n   if (m_always_executed\n       && callee_summary->kills.length ()\n       && (!cfun->can_throw_non_call_exceptions\n-\t  || !stmt_could_throw_p (cfun, stmt)))\n+\t  || !stmt_could_throw_p (cfun, call)))\n     {\n       /* Watch for self recursive updates.  */\n       auto_vec<modref_access_node, 32> saved_kills;\n@@ -1295,14 +1393,18 @@ modref_access_analysis::merge_call_side_effects\n   changed |= m_summary->loads->merge (current_function_decl,\n \t\t\t\t      callee_summary->loads,\n \t\t\t\t      &parm_map, &chain_map,\n-\t\t\t\t      record_adjustments);\n+\t\t\t\t      record_adjustments,\n+\t\t\t\t      !may_access_nonescaping_parm_p\n+\t\t\t\t\t (call, flags, true));\n   /* Merge in stores.  */\n   if (!ignore_stores_p (current_function_decl, flags))\n     {\n       changed |= m_summary->stores->merge (current_function_decl,\n \t\t\t\t\t   callee_summary->stores,\n \t\t\t\t\t   &parm_map, &chain_map,\n-\t\t\t\t\t   record_adjustments);\n+\t\t\t\t\t   record_adjustments,\n+\t\t\t\t\t   !may_access_nonescaping_parm_p\n+\t\t\t\t\t       (call, flags, false));\n       if (!m_summary->writes_errno\n \t  && callee_summary->writes_errno)\n \t{\n@@ -1350,7 +1452,6 @@ modref_access_analysis::get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n     }\n   return a;\n }\n-\n /* Apply side effects of call STMT to CUR_SUMMARY using FNSPEC.\n    If IGNORE_STORES is true ignore them.\n    Return false if no useful summary can be produced.   */\n@@ -1383,14 +1484,34 @@ modref_access_analysis::process_fnspec (gcall *call)\n       if (dump_file && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n \tfprintf (dump_file, \"      Builtin with no fnspec: %s\\n\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl (call))));\n-      record_unknown_load ();\n       if (!ignore_stores_p (current_function_decl, flags))\n-\trecord_unknown_store ();\n+\t{\n+\t  if (!may_access_nonescaping_parm_p (call, flags, false))\n+\t    record_global_memory_store ();\n+\t  else\n+\t    record_unknown_store ();\n+\t  if (!may_access_nonescaping_parm_p (call, flags, true))\n+\t    record_global_memory_load ();\n+\t  else\n+\t    record_unknown_load ();\n+\t}\n+      else\n+\t{\n+\t  if (!may_access_nonescaping_parm_p (call, flags, true))\n+\t    record_global_memory_load ();\n+\t  else\n+\t    record_unknown_load ();\n+\t}\n       return;\n     }\n   /* Process fnspec.  */\n   if (fnspec.global_memory_read_p ())\n-    record_unknown_load ();\n+    {\n+      if (may_access_nonescaping_parm_p (call, flags, true))\n+\trecord_unknown_load ();\n+      else\n+\trecord_global_memory_load ();\n+    }\n   else\n     {\n       for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n@@ -1422,7 +1543,12 @@ modref_access_analysis::process_fnspec (gcall *call)\n   if (ignore_stores_p (current_function_decl, flags))\n     return;\n   if (fnspec.global_memory_written_p ())\n-    record_unknown_store ();\n+    {\n+      if (may_access_nonescaping_parm_p (call, flags, false))\n+\trecord_unknown_store ();\n+      else\n+\trecord_global_memory_store ();\n+    }\n   else\n     {\n       for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n@@ -1470,6 +1596,12 @@ modref_access_analysis::analyze_call (gcall *stmt)\n      simplified.  */\n   int flags = gimple_call_flags (stmt);\n \n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \" - Analyzing call:\");\n+      print_gimple_stmt (dump_file, stmt, 0);\n+    }\n+\n   if ((flags & (ECF_CONST | ECF_NOVOPS))\n       && !(flags & ECF_LOOPING_CONST_OR_PURE))\n     {"}, {"sha": "511ed4b5297788db880d4904608b33b81d9cf204", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -1,4 +1,5 @@\n /* { dg-require-effective-target alloca } */\n+/* { dg-additional-options \"-fno-ipa-modref\" } */\n \n #include <stdlib.h>\n #include <string.h>"}, {"sha": "ff2aee6cccf4acf698e2f6e08ec3b5d0bac7b1cf", "filename": "gcc/testsuite/gcc.dg/uninit-38.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -6,7 +6,7 @@\n    be adjusted.  Ditto if -Wuninitialized output changes for some\n    other reason.\n    { dg-do compile { target { { lp64 || ilp32 } || llp64 } } }\n-   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0 -fno-ipa-modref\" } */\n \n #define CONCAT(x, y)   x ## y\n #define CAT(x, y)      CONCAT(x, y)"}, {"sha": "745328b9f8d6b617992b2a0cf6ea47ab3ba61f0a", "filename": "gcc/testsuite/gcc.dg/uninit-pr98578.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr98578.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr98578.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr98578.c?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -1,6 +1,6 @@\n /* PR middle-end/98578 - ICE warning on uninitialized VLA access\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -fno-ipa-modref\" } */\n \n void* malloc (__SIZE_TYPE__);\n "}, {"sha": "011298998b7eb1a239e9ed57df41aed50e625a4b", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3305135c29e1c3e988bd9bad40aefc01d138aaca/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3305135c29e1c3e988bd9bad40aefc01d138aaca", "patch": "@@ -2544,6 +2544,30 @@ refs_output_dependent_p (tree store1, tree store2)\n   return refs_may_alias_p_1 (&r1, &r2, false);\n }\n \n+/* Return ture if REF may access global memory.  */\n+\n+bool\n+ref_may_access_global_memory_p (ao_ref *ref)\n+{\n+  if (!ref->ref)\n+    return true;\n+  tree base = ao_ref_base (ref);\n+  if (TREE_CODE (base) == MEM_REF\n+      || TREE_CODE (base) == TARGET_MEM_REF)\n+    {\n+      if (ptr_deref_may_alias_global_p (TREE_OPERAND (base, 0)))\n+\treturn true;\n+    }\n+  else\n+    {\n+      if (!auto_var_in_fn_p (base, current_function_decl)\n+\t  || pt_solution_includes (&cfun->gimple_df->escaped,\n+\t\t\t\t   base))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Returns true if and only if REF may alias any access stored in TT.\n    IF TBAA_P is true, use TBAA oracle.  */\n \n@@ -2552,6 +2576,7 @@ modref_may_conflict (const gcall *stmt,\n \t\t     modref_tree <alias_set_type> *tt, ao_ref *ref, bool tbaa_p)\n {\n   alias_set_type base_set, ref_set;\n+  bool global_memory_ok = false;\n \n   if (tt->every_base)\n     return true;\n@@ -2602,6 +2627,17 @@ modref_may_conflict (const gcall *stmt,\n \t      if (num_tests >= max_tests)\n \t\treturn true;\n \n+\t      if (access_node.parm_index == MODREF_GLOBAL_MEMORY_PARM)\n+\t\t{\n+\t\t  if (global_memory_ok)\n+\t\t    continue;\n+\t\t  if (ref_may_access_global_memory_p (ref))\n+\t\t    return true;\n+\t\t  global_memory_ok = true;\n+\t\t  num_tests++;\n+\t\t  continue;\n+\t\t}\n+\n \t      tree arg = access_node.get_call_arg (stmt);\n \t      if (!arg)\n \t\treturn true;"}]}