{"sha": "d81b4c614be057ac515828a6b7a92745a542c551", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxYjRjNjE0YmUwNTdhYzUxNTgyOGE2YjdhOTI3NDVhNTQyYzU1MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-06-17T08:58:35Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2009-06-17T08:58:35Z"}, "message": "Relax constraints on Machine_Attribute argument types:\n\n        * sem_prag.adb (Check_Arg_Is_Static_Expression): Allow for\n        missing type.\n        (Analyze_Attribute, case Machine_Attribute): Allow any type for\n        arg 3.\n        * gcc-interface/decl.c (prepend_attributes): Accept static\n        expressions of any type as attribute arguments, not only string\n        literals.\n        * gnat_rm.texi (pragma Machine_Attribute section): Adjust to\n        reflect the relaxation of the restriction on the Info argument type.\n\n\nCo-Authored-By: Olivier Hainque <hainque@adacore.com>\n\nFrom-SVN: r148589", "tree": {"sha": "aa75a40b9083178acea3520fb04e4af0469d6b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa75a40b9083178acea3520fb04e4af0469d6b59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d81b4c614be057ac515828a6b7a92745a542c551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81b4c614be057ac515828a6b7a92745a542c551", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d81b4c614be057ac515828a6b7a92745a542c551", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81b4c614be057ac515828a6b7a92745a542c551/comments", "author": null, "committer": null, "parents": [{"sha": "a4d99c865e40ce9ff43b6463324c00c31c6ea66e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4d99c865e40ce9ff43b6463324c00c31c6ea66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4d99c865e40ce9ff43b6463324c00c31c6ea66e"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "d9e6bcbd235bf55ea4aa49ecc824dcb8b19a98da", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d81b4c614be057ac515828a6b7a92745a542c551", "patch": "@@ -1,3 +1,16 @@\n+2009-06-16  Robert Dewar  <dewar@adacore.com>\n+            Olivier Hainque  <hainque@adacore.com>\n+\n+\tRelax constraints on Machine_Attribute argument types:\n+\t* sem_prag.adb (Check_Arg_Is_Static_Expression): Allow for\n+\tmissing type.\n+\t(Analyze_Attribute, case Machine_Attribute): Allow any type for arg 3.\n+\t* gcc-interface/decl.c (prepend_attributes): Accept static\n+\texpressions of any type as attribute arguments, not only string\n+\tliterals.\n+\t* gnat_rm.texi (pragma Machine_Attribute section): Adjust to reflect\n+\tthe relaxation of the restriction on the Info argument type.\n+\t\n 2009-06-13  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gcc-interface/utils.c (record_builtin_type): Pass location"}, {"sha": "974f6f0931b5d1cdf4c54e12c829ca3b41f24b9a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d81b4c614be057ac515828a6b7a92745a542c551", "patch": "@@ -5568,6 +5568,8 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n {\n   Node_Id gnat_temp;\n \n+  /* Attributes are stored as Representation Item pragmas.  */\n+\n   for (gnat_temp = First_Rep_Item (gnat_entity); Present (gnat_temp);\n        gnat_temp = Next_Rep_Item (gnat_temp))\n     if (Nkind (gnat_temp) == N_Pragma)\n@@ -5576,24 +5578,8 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n \tNode_Id gnat_assoc = Pragma_Argument_Associations (gnat_temp);\n \tenum attr_type etype;\n \n-\tif (Present (gnat_assoc) && Present (First (gnat_assoc))\n-\t    && Present (Next (First (gnat_assoc)))\n-\t    && (Nkind (Expression (Next (First (gnat_assoc))))\n-\t\t== N_String_Literal))\n-\t  {\n-\t    gnu_arg0 = get_identifier (TREE_STRING_POINTER\n-\t\t\t\t       (gnat_to_gnu\n-\t\t\t\t\t(Expression (Next\n-\t\t\t\t\t\t     (First (gnat_assoc))))));\n-\t    if (Present (Next (Next (First (gnat_assoc))))\n-\t\t&& (Nkind (Expression (Next (Next (First (gnat_assoc)))))\n-\t\t    == N_String_Literal))\n-\t      gnu_arg1 = get_identifier (TREE_STRING_POINTER\n-\t\t\t\t\t (gnat_to_gnu\n-\t\t\t\t\t  (Expression\n-\t\t\t\t\t   (Next (Next\n-\t\t\t\t\t\t  (First (gnat_assoc)))))));\n-\t  }\n+\t/* Map the kind of pragma at hand.  Skip if this is not one\n+\t   we know how to handle.  */\n \n \tswitch (Get_Pragma_Id (Chars (Pragma_Identifier (gnat_temp))))\n \t  {\n@@ -5629,6 +5615,35 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n \t    continue;\n \t  }\n \n+\t/* See what arguments we have and turn them into GCC trees for\n+\t   attribute handlers.  These expect identifier for strings.  We\n+\t   handle at most two arguments, static expressions only.  */\n+\n+\tif (Present (gnat_assoc) && Present (First (gnat_assoc)))\n+\t  {\n+\t    Node_Id gnat_arg0 = Next (First (gnat_assoc));\n+\t    Node_Id gnat_arg1 = Empty;\n+\n+\t    if (Present (gnat_arg0)\n+\t\t&& Is_Static_Expression (Expression (gnat_arg0)))\n+\t      {\n+\t\tgnu_arg0 = gnat_to_gnu (Expression (gnat_arg0));\n+\n+\t\tif (TREE_CODE (gnu_arg0) == STRING_CST)\n+\t\t  gnu_arg0 = get_identifier (TREE_STRING_POINTER (gnu_arg0));\n+\n+\t\tgnat_arg1 = Next (gnat_arg0);\n+\t      }\n+\n+\t    if (Present (gnat_arg1)\n+\t\t&& Is_Static_Expression (Expression (gnat_arg1)))\n+\t      {\n+\t\tgnu_arg1 = gnat_to_gnu (Expression (gnat_arg1));\n+\n+\t\tif (TREE_CODE (gnu_arg1) == STRING_CST)\n+\t\t  gnu_arg1 = get_identifier (TREE_STRING_POINTER (gnu_arg1));\n+\t      }\n+\t  }\n \n \t/* Prepend to the list now.  Make a list of the argument we might\n \t   have, as GCC expects it.  */"}, {"sha": "ba84ee17cb7e0109ab1a291b303941794197dc90", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=d81b4c614be057ac515828a6b7a92745a542c551", "patch": "@@ -3243,7 +3243,7 @@ Syntax:\n pragma Machine_Attribute (\n      [Entity         =>] LOCAL_NAME,\n      [Attribute_Name =>] static_string_EXPRESSION\n-  [, [Info           =>] static_string_EXPRESSION] );\n+  [, [Info           =>] static_EXPRESSION] );\n @end smallexample\n \n @noindent\n@@ -3252,15 +3252,12 @@ declarations.  This pragma is semantically equivalent to\n @code{__attribute__((@var{attribute_name}))} (if @var{info} is not\n specified) or @code{__attribute__((@var{attribute_name}(@var{info})))}\n in GNU C, where @code{@var{attribute_name}} is recognized by the\n-target macro @code{TARGET_ATTRIBUTE_TABLE} which is defined for each\n-machine.  The optional parameter @var{info} is transformed into an\n-identifier, which may make this pragma unusable for some attributes\n-(parameter of some attributes must be a number or a string).\n-@xref{Target Attributes,, Defining target-specific uses of\n-@code{__attribute__}, gccint, GNU Compiler Colletion (GCC) Internals},\n-further information.  It is not possible to specify\n-attributes defined by other languages, only attributes defined by the\n-machine the code is intended to run on.\n+compiler middle-end or the @code{TARGET_ATTRIBUTE_TABLE} machine\n+specific macro.  A string literal for the optional parameter @var{info}\n+is transformed into an identifier, which may make this pragma unusable\n+for some attributes.  @xref{Target Attributes,, Defining target-specific\n+uses of @code{__attribute__}, gccint, GNU Compiler Collection (GCC)\n+Internals}, further information.\n \n @node Pragma Main\n @unnumberedsec Pragma Main"}, {"sha": "f69fcda99eb8582a24e852635c710d30ce0cdaea", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4c614be057ac515828a6b7a92745a542c551/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d81b4c614be057ac515828a6b7a92745a542c551", "patch": "@@ -368,11 +368,12 @@ package body Sem_Prag is\n \n       procedure Check_Arg_Is_Static_Expression\n         (Arg : Node_Id;\n-         Typ : Entity_Id);\n+         Typ : Entity_Id := Empty);\n       --  Check the specified argument Arg to make sure that it is a static\n       --  expression of the given type (i.e. it will be analyzed and resolved\n       --  using this type, which can be any valid argument to Resolve, e.g.\n-      --  Any_Integer is OK). If not, given error and raise Pragma_Exit.\n+      --  Any_Integer is OK). If not, given error and raise Pragma_Exit. If\n+      --  Typ is left Empty, then any static expression is allowed.\n \n       procedure Check_Arg_Is_String_Literal (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it is a string\n@@ -966,12 +967,16 @@ package body Sem_Prag is\n \n       procedure Check_Arg_Is_Static_Expression\n         (Arg : Node_Id;\n-         Typ : Entity_Id)\n+         Typ : Entity_Id := Empty)\n       is\n          Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n \n       begin\n-         Analyze_And_Resolve (Argx, Typ);\n+         if Present (Typ) then\n+            Analyze_And_Resolve (Argx, Typ);\n+         else\n+            Analyze_And_Resolve (Argx);\n+         end if;\n \n          if Is_OK_Static_Expression (Argx) then\n             return;\n@@ -8819,7 +8824,7 @@ package body Sem_Prag is\n          --  pragma Machine_Attribute (\n          --       [Entity         =>] LOCAL_NAME,\n          --       [Attribute_Name =>] static_string_EXPRESSION\n-         --    [, [Info           =>] static_string_EXPRESSION] );\n+         --    [, [Info           =>] static_EXPRESSION] );\n \n          when Pragma_Machine_Attribute => Machine_Attribute : declare\n             Def_Id : Entity_Id;\n@@ -8830,7 +8835,7 @@ package body Sem_Prag is\n \n             if Arg_Count = 3 then\n                Check_Optional_Identifier (Arg3, Name_Info);\n-               Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n+               Check_Arg_Is_Static_Expression (Arg3);\n             else\n                Check_Arg_Count (2);\n             end if;"}]}