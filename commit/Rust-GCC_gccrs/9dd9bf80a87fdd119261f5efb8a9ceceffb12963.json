{"sha": "9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRkOWJmODBhODdmZGQxMTkyNjFmNWVmYjhhOWNlY2VmZmIxMjk2Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-04-07T09:37:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-04-07T09:37:51Z"}, "message": "Removal of Return with Depressed Stack Pointer support\n\n\tRemoval of Return with Depressed Stack Pointer support\n\t* tree.h (TYPE_RETURNS_STACK_DEPRESSED): Delete.\n\t(ECF_SP_DEPRESSED): Likewise.\n\t(ECF_LIBCALL_BLOCK, ECF_NOVOPS): Adjust.\n\t* calls.c (emit_call_1): Do not test ECF_SP_DEPRESSED.\n\t(flags_from_decl_or_type): Do not test TYPE_RETURNS_STACK_DEPRESSED.\n\t(expand_call): Do not test ECF_SP_DEPRESSED.\n\t* dse.c (dse_step0): Do not test TYPE_RETURNS_STACK_DEPRESSED.\n\t* function.c (keep_stack_depressed): Delete.\n\t(handle_epilogue_set): Likewise.\n\t(update_epilogue_consts): Likewise.\n\t(emit_equiv_load): Likewise.\n\t(thread_prologue_and_epilogue_insns): Remove support for Return with\n\tDepressed Stack Pointer.\n\t* print-tree.c (print_node): Do not test TYPE_RETURNS_STACK_DEPRESSED.\n\nada/\n\t* gigi.h (create_subprog_type): Remove returns_with_dsp parameter.\n\t* decl.c (gnat_to_gnu_entity): Adjust for above new prototype.\n\t* utils.c (create_subprog_type): Remove returns_with_dsp parameter.\n\t* trans.c (gnat_to_gnu) <N_Return_Statement>: Remove code dealing with\n\tReturn by Depressed Stack Pointer.\n\nFrom-SVN: r133976", "tree": {"sha": "347d5e4db385dd943a52f0d226ebaf0dc3200e8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/347d5e4db385dd943a52f0d226ebaf0dc3200e8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/comments", "author": null, "committer": null, "parents": [{"sha": "f9985df51b32cb265f429d024e955e71fd23a4f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9985df51b32cb265f429d024e955e71fd23a4f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9985df51b32cb265f429d024e955e71fd23a4f1"}], "stats": {"total": 528, "additions": 53, "deletions": 475}, "files": [{"sha": "3e158244c682b943be995a66ad51c84930c27b7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -1,3 +1,21 @@\n+2008-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tRemoval of Return with Depressed Stack Pointer support\n+\t* tree.h (TYPE_RETURNS_STACK_DEPRESSED): Delete.\n+\t(ECF_SP_DEPRESSED): Likewise.\n+\t(ECF_LIBCALL_BLOCK, ECF_NOVOPS): Adjust.\n+\t* calls.c (emit_call_1): Do not test ECF_SP_DEPRESSED.\n+\t(flags_from_decl_or_type): Do not test TYPE_RETURNS_STACK_DEPRESSED.\n+\t(expand_call): Do not test ECF_SP_DEPRESSED.\n+\t* dse.c (dse_step0): Do not test TYPE_RETURNS_STACK_DEPRESSED.\n+\t* function.c (keep_stack_depressed): Delete.\n+\t(handle_epilogue_set): Likewise.\n+\t(update_epilogue_consts): Likewise.\n+\t(emit_equiv_load): Likewise.\n+\t(thread_prologue_and_epilogue_insns): Remove support for Return with\n+\tDepressed Stack Pointer.\n+\t* print-tree.c (print_node): Do not test TYPE_RETURNS_STACK_DEPRESSED.\n+\n 2008-04-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/35400"}, {"sha": "44c64cecc1f1925df91044cc48cbf0c78ebb65b2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -1,3 +1,11 @@\n+2008-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gigi.h (create_subprog_type): Remove returns_with_dsp parameter.\n+\t* decl.c (gnat_to_gnu_entity): Adjust for above new prototype.\n+\t* utils.c (create_subprog_type): Remove returns_with_dsp parameter.\n+\t* trans.c (gnat_to_gnu) <N_Return_Statement>: Remove code dealing with\n+\tReturn by Depressed Stack Pointer.\n+\n 2008-04-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* decl.c (is_variable_size): Do not unconditionally return false"}, {"sha": "c45492f34da84d657c8f51056cf13873fde5d3fe", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -3863,17 +3863,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type\n \t  = create_subprog_type (gnu_return_type, gnu_param_list,\n \t\t\t\t gnu_return_list, returns_unconstrained,\n-\t\t\t\t returns_by_ref,\n-\t\t\t\t Function_Returns_With_DSP (gnat_entity),\n-\t\t\t\t returns_by_target_ptr);\n+\t\t\t\t returns_by_ref, returns_by_target_ptr);\n \n \tif (has_stub)\n \t  gnu_stub_type\n \t    = create_subprog_type (gnu_return_type, gnu_stub_param_list,\n \t\t\t\t   gnu_return_list, returns_unconstrained,\n-\t\t\t\t   returns_by_ref,\n-\t\t\t\t   Function_Returns_With_DSP (gnat_entity),\n-\t\t\t\t   returns_by_target_ptr);\n+\t\t\t\t   returns_by_ref, returns_by_target_ptr);\n \n \t/* A subprogram (something that doesn't return anything) shouldn't\n \t   be considered Pure since there would be no reason for such a"}, {"sha": "21ea4fe41fd7e35564e3442f6e1b82da79f41473", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -522,13 +522,11 @@ extern void rest_of_record_type_compilation (tree record_type);\n    copy-in/copy-out list to be stored into TYPE_CI_CO_LIST.\n    RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n    object.  RETURNS_BY_REF is true if the function returns by reference.\n-   RETURNS_WITH_DSP is true if the function is to return with a\n-   depressed stack pointer.  RETURNS_BY_TARGET_PTR is true if the function\n-   is to be passed (as its first parameter) the address of the place to copy\n-   its result.  */\n+   RETURNS_BY_TARGET_PTR is true if the function is to be passed (as its\n+   first parameter) the address of the place to copy its result.  */\n extern tree create_subprog_type (tree return_type, tree param_decl_list,\n                                  tree cico_list, bool returns_unconstrained,\n-                                 bool returns_by_ref, bool returns_with_dsp,\n+                                 bool returns_by_ref,\n                                  bool returns_by_target_ptr);\n \n /* Return a copy of TYPE, but safe to modify in any way.  */"}, {"sha": "f3dc87dd43d02295f8f8802f5ad14144762e912e", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -4182,26 +4182,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\telse if (TYPE_RETURNS_UNCONSTRAINED_P (gnu_subprog_type))\n \t\t  {\n \t\t    gnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n-\n-\t\t    /* We have two cases: either the function returns with\n-\t\t       depressed stack or not.  If not, we allocate on the\n-\t\t       secondary stack.  If so, we allocate in the stack frame.\n-\t\t       if no copy is needed, the front end will set By_Ref,\n-\t\t       which we handle in the case above.  */\n-\t\t    if (TYPE_RETURNS_STACK_DEPRESSED (gnu_subprog_type))\n-\t\t      gnu_ret_val\n-\t\t\t= build_allocator (TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\t   gnu_ret_val,\n-\t\t\t\t\t   TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t\t   0, -1, gnat_node, false);\n-\t\t    else\n-\t\t      gnu_ret_val\n-\t\t\t= build_allocator (TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\t   gnu_ret_val,\n-\t\t\t\t\t   TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t\t   Procedure_To_Call (gnat_node),\n-\t\t\t\t\t   Storage_Pool (gnat_node),\n-\t\t\t\t\t   gnat_node, false);\n+\t\t    gnu_ret_val\n+\t\t      = build_allocator (TREE_TYPE (gnu_ret_val),\n+\t\t\t\t\t gnu_ret_val,\n+\t\t\t\t\t TREE_TYPE (gnu_subprog_type),\n+\t\t\t\t\t Procedure_To_Call (gnat_node),\n+\t\t\t\t\t Storage_Pool (gnat_node),\n+\t\t\t\t\t gnat_node, false);\n \t\t  }\n \t      }\n \t  }"}, {"sha": "5c962170c8e62ef1aa0c84068ab17ed95fc17386", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -1255,17 +1255,15 @@ split_plus (tree in, tree *pvar)\n    otherwise we are dealing with a function. PARAM_DECL_LIST is a list of\n    PARM_DECL nodes that are the subprogram arguments.  CICO_LIST is the\n    copy-in/copy-out list to be stored into TYPE_CICO_LIST.\n-   RETURNS_UNCONSTRAINED is nonzero if the function returns an unconstrained\n-   object.  RETURNS_BY_REF is nonzero if the function returns by reference.\n-   RETURNS_WITH_DSP is nonzero if the function is to return with a\n-   depressed stack pointer.  RETURNS_BY_TARGET_PTR is true if the function\n-   is to be passed (as its first parameter) the address of the place to copy\n-   its result.  */\n+   RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n+   object.  RETURNS_BY_REF is true if the function returns by reference.\n+   RETURNS_BY_TARGET_PTR is true if the function is to be passed (as its\n+   first parameter) the address of the place to copy its result.  */\n \n tree\n create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n                      bool returns_unconstrained, bool returns_by_ref,\n-                     bool returns_with_dsp, bool returns_by_target_ptr)\n+                     bool returns_by_target_ptr)\n {\n   /* A chain of TREE_LIST nodes whose TREE_VALUEs are the data type nodes of\n      the subprogram formal parameters. This list is generated by traversing the\n@@ -1302,7 +1300,6 @@ create_subprog_type (tree return_type, tree param_decl_list, tree cico_list,\n \n   TYPE_CI_CO_LIST (type) = cico_list;\n   TYPE_RETURNS_UNCONSTRAINED_P (type) = returns_unconstrained;\n-  TYPE_RETURNS_STACK_DEPRESSED (type) = returns_with_dsp;\n   TYPE_RETURNS_BY_REF_P (type) = returns_by_ref;\n   TYPE_RETURNS_BY_TARGET_PTR_P (type) = returns_by_target_ptr;\n   return type;"}, {"sha": "3eb8b5f1402c55cefa63a91e84b85809a514c330", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -297,7 +297,7 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n      even if the call has no arguments to pop.  */\n #if defined (HAVE_call) && defined (HAVE_call_value)\n   if (HAVE_call && HAVE_call_value && HAVE_call_pop && HAVE_call_value_pop\n-      && n_popped > 0 && ! (ecf_flags & ECF_SP_DEPRESSED))\n+      && n_popped > 0)\n #else\n   if (HAVE_call_pop && HAVE_call_value_pop)\n #endif\n@@ -432,7 +432,7 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n \n       if (rounded_stack_size != 0)\n \t{\n-\t  if (ecf_flags & (ECF_SP_DEPRESSED | ECF_NORETURN))\n+\t  if (ecf_flags & ECF_NORETURN)\n \t    /* Just pretend we did the pop.  */\n \t    stack_pointer_delta -= rounded_stack_size;\n \t  else if (flag_defer_pop && inhibit_defer_pop == 0\n@@ -602,14 +602,6 @@ flags_from_decl_or_type (const_tree exp)\n   if (TREE_THIS_VOLATILE (exp))\n     flags |= ECF_NORETURN;\n \n-  /* Mark if the function returns with the stack pointer depressed.   We\n-     cannot consider it pure or constant in that case.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE && TYPE_RETURNS_STACK_DEPRESSED (type))\n-    {\n-      flags |= ECF_SP_DEPRESSED;\n-      flags &= ~(ECF_PURE | ECF_CONST);\n-    }\n-\n   return flags;\n }\n \n@@ -2354,13 +2346,12 @@ expand_call (tree exp, rtx target, int ignore)\n       /* Don't let pending stack adjusts add up to too much.\n \t Also, do all pending adjustments now if there is any chance\n \t this might be a call to alloca or if we are expanding a sibling\n-\t call sequence or if we are calling a function that is to return\n-\t with stack pointer depressed.\n+\t call sequence.\n \t Also do the adjustments before a throwing call, otherwise\n \t exception handling can fail; PR 19225. */\n       if (pending_stack_adjust >= 32\n \t  || (pending_stack_adjust > 0\n-\t      && (flags & (ECF_MAY_BE_ALLOCA | ECF_SP_DEPRESSED)))\n+\t      && (flags & ECF_MAY_BE_ALLOCA))\n \t  || (pending_stack_adjust > 0\n \t      && flag_exceptions && !(flags & ECF_NOTHROW))\n \t  || pass == 0)\n@@ -3071,7 +3062,7 @@ expand_call (tree exp, rtx target, int ignore)\n       /* If size of args is variable or this was a constructor call for a stack\n \t argument, restore saved stack-pointer value.  */\n \n-      if (old_stack_level && ! (flags & ECF_SP_DEPRESSED))\n+      if (old_stack_level)\n \t{\n \t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n \t  stack_pointer_delta = old_stack_pointer_delta;\n@@ -3177,16 +3168,6 @@ expand_call (tree exp, rtx target, int ignore)\n \n   currently_expanding_call--;\n \n-  /* If this function returns with the stack pointer depressed, ensure\n-     this block saves and restores the stack pointer, show it was\n-     changed, and adjust for any outgoing arg space.  */\n-  if (flags & ECF_SP_DEPRESSED)\n-    {\n-      clear_pending_stack_adjust ();\n-      emit_insn (gen_rtx_CLOBBER (VOIDmode, stack_pointer_rtx));\n-      emit_move_insn (virtual_stack_dynamic_rtx, stack_pointer_rtx);\n-    }\n-\n   if (stack_usage_map_buf)\n     free (stack_usage_map_buf);\n "}, {"sha": "d5db62834440b5f9ca2a3e12fe585948c3ea0aa7", "filename": "gcc/dse.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -522,11 +522,8 @@ struct clear_alias_mode_holder\n \n static alloc_pool clear_alias_mode_pool;\n \n-/* This is true except for two cases:\n-   (1) current_function_stdarg -- i.e. we cannot do this \n-       for vararg functions because they play games with the frame.  \n-   (2) In ada, it is sometimes not safe to do assume that any stores\n-       based off the stack frame go dead at the exit to a function.  */\n+/* This is true except if current_function_stdarg -- i.e. we cannot do\n+   this for vararg functions because they play games with the frame.  */\n static bool stores_off_frame_dead_at_return;\n \n /* Counter for stats.  */\n@@ -712,10 +709,7 @@ dse_step0 (void)\n   bb_table = XCNEWVEC (bb_info_t, last_basic_block);\n   rtx_group_next_id = 0;\n \n-  stores_off_frame_dead_at_return = \n-    (!(TREE_CODE (TREE_TYPE (current_function_decl)) == FUNCTION_TYPE\n-       && (TYPE_RETURNS_STACK_DEPRESSED (TREE_TYPE (current_function_decl)))))\n-    && (!current_function_stdarg);\n+  stores_off_frame_dead_at_return = !current_function_stdarg;\n \n   init_alias_analysis ();\n   "}, {"sha": "4f7a1eff1d2aa922415aebfaf97ea1d0a26c1fee", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 390, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -207,9 +207,6 @@ static int contains (const_rtx, VEC(int,heap) **);\n #ifdef HAVE_return\n static void emit_return_into_block (basic_block);\n #endif\n-#if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n-static rtx keep_stack_depressed (rtx);\n-#endif\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n@@ -4720,383 +4717,6 @@ emit_return_into_block (basic_block bb)\n }\n #endif /* HAVE_return */\n \n-#if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n-\n-/* These functions convert the epilogue into a variant that does not\n-   modify the stack pointer.  This is used in cases where a function\n-   returns an object whose size is not known until it is computed.\n-   The called function leaves the object on the stack, leaves the\n-   stack depressed, and returns a pointer to the object.\n-\n-   What we need to do is track all modifications and references to the\n-   stack pointer, deleting the modifications and changing the\n-   references to point to the location the stack pointer would have\n-   pointed to had the modifications taken place.\n-\n-   These functions need to be portable so we need to make as few\n-   assumptions about the epilogue as we can.  However, the epilogue\n-   basically contains three things: instructions to reset the stack\n-   pointer, instructions to reload registers, possibly including the\n-   frame pointer, and an instruction to return to the caller.\n-\n-   We must be sure of what a relevant epilogue insn is doing.  We also\n-   make no attempt to validate the insns we make since if they are\n-   invalid, we probably can't do anything valid.  The intent is that\n-   these routines get \"smarter\" as more and more machines start to use\n-   them and they try operating on different epilogues.\n-\n-   We use the following structure to track what the part of the\n-   epilogue that we've already processed has done.  We keep two copies\n-   of the SP equivalence, one for use during the insn we are\n-   processing and one for use in the next insn.  The difference is\n-   because one part of a PARALLEL may adjust SP and the other may use\n-   it.  */\n-\n-struct epi_info\n-{\n-  rtx sp_equiv_reg;\t\t/* REG that SP is set from, perhaps SP.  */\n-  HOST_WIDE_INT sp_offset;\t/* Offset from SP_EQUIV_REG of present SP.  */\n-  rtx new_sp_equiv_reg;\t\t/* REG to be used at end of insn.  */\n-  HOST_WIDE_INT new_sp_offset;\t/* Offset to be used at end of insn.  */\n-  rtx equiv_reg_src;\t\t/* If nonzero, the value that SP_EQUIV_REG\n-\t\t\t\t   should be set to once we no longer need\n-\t\t\t\t   its value.  */\n-  rtx const_equiv[FIRST_PSEUDO_REGISTER]; /* Any known constant equivalences\n-\t\t\t\t\t     for registers.  */\n-};\n-\n-static void handle_epilogue_set (rtx, struct epi_info *);\n-static void update_epilogue_consts (rtx, const_rtx, void *);\n-static void emit_equiv_load (struct epi_info *);\n-\n-/* Modify INSN, a list of one or more insns that is part of the epilogue, to\n-   no modifications to the stack pointer.  Return the new list of insns.  */\n-\n-static rtx\n-keep_stack_depressed (rtx insns)\n-{\n-  int j;\n-  struct epi_info info;\n-  rtx insn, next;\n-\n-  /* If the epilogue is just a single instruction, it must be OK as is.  */\n-  if (NEXT_INSN (insns) == NULL_RTX)\n-    return insns;\n-\n-  /* Otherwise, start a sequence, initialize the information we have, and\n-     process all the insns we were given.  */\n-  start_sequence ();\n-\n-  info.sp_equiv_reg = stack_pointer_rtx;\n-  info.sp_offset = 0;\n-  info.equiv_reg_src = 0;\n-\n-  for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-    info.const_equiv[j] = 0;\n-\n-  insn = insns;\n-  next = NULL_RTX;\n-  while (insn != NULL_RTX)\n-    {\n-      next = NEXT_INSN (insn);\n-\n-      if (!INSN_P (insn))\n-\t{\n-\t  add_insn (insn);\n-\t  insn = next;\n-\t  continue;\n-\t}\n-\n-      /* If this insn references the register that SP is equivalent to and\n-\t we have a pending load to that register, we must force out the load\n-\t first and then indicate we no longer know what SP's equivalent is.  */\n-      if (info.equiv_reg_src != 0\n-\t  && reg_referenced_p (info.sp_equiv_reg, PATTERN (insn)))\n-\t{\n-\t  emit_equiv_load (&info);\n-\t  info.sp_equiv_reg = 0;\n-\t}\n-\n-      info.new_sp_equiv_reg = info.sp_equiv_reg;\n-      info.new_sp_offset = info.sp_offset;\n-\n-      /* If this is a (RETURN) and the return address is on the stack,\n-\t update the address and change to an indirect jump.  */\n-      if (GET_CODE (PATTERN (insn)) == RETURN\n-\t  || (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t      && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == RETURN))\n-\t{\n-\t  rtx retaddr = INCOMING_RETURN_ADDR_RTX;\n-\t  rtx base = 0;\n-\t  HOST_WIDE_INT offset = 0;\n-\t  rtx jump_insn, jump_set;\n-\n-\t  /* If the return address is in a register, we can emit the insn\n-\t     unchanged.  Otherwise, it must be a MEM and we see what the\n-\t     base register and offset are.  In any case, we have to emit any\n-\t     pending load to the equivalent reg of SP, if any.  */\n-\t  if (REG_P (retaddr))\n-\t    {\n-\t      emit_equiv_load (&info);\n-\t      add_insn (insn);\n-\t      insn = next;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx ret_ptr;\n-\t      gcc_assert (MEM_P (retaddr));\n-\n-\t      ret_ptr = XEXP (retaddr, 0);\n-\t      \n-\t      if (REG_P (ret_ptr))\n-\t\t{\n-\t\t  base = gen_rtx_REG (Pmode, REGNO (ret_ptr));\n-\t\t  offset = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gcc_assert (GET_CODE (ret_ptr) == PLUS\n-\t\t\t      && REG_P (XEXP (ret_ptr, 0))\n-\t\t\t      && GET_CODE (XEXP (ret_ptr, 1)) == CONST_INT);\n-\t\t  base = gen_rtx_REG (Pmode, REGNO (XEXP (ret_ptr, 0)));\n-\t\t  offset = INTVAL (XEXP (ret_ptr, 1));\n-\t\t}\n-\t    }\n-\n-\t  /* If the base of the location containing the return pointer\n-\t     is SP, we must update it with the replacement address.  Otherwise,\n-\t     just build the necessary MEM.  */\n-\t  retaddr = plus_constant (base, offset);\n-\t  if (base == stack_pointer_rtx)\n-\t    retaddr = simplify_replace_rtx (retaddr, stack_pointer_rtx,\n-\t\t\t\t\t    plus_constant (info.sp_equiv_reg,\n-\t\t\t\t\t\t\t   info.sp_offset));\n-\n-\t  retaddr = gen_rtx_MEM (Pmode, retaddr);\n-\t  MEM_NOTRAP_P (retaddr) = 1;\n-\n-\t  /* If there is a pending load to the equivalent register for SP\n-\t     and we reference that register, we must load our address into\n-\t     a scratch register and then do that load.  */\n-\t  if (info.equiv_reg_src\n-\t      && reg_overlap_mentioned_p (info.equiv_reg_src, retaddr))\n-\t    {\n-\t      unsigned int regno;\n-\t      rtx reg;\n-\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif (HARD_REGNO_MODE_OK (regno, Pmode)\n-\t\t    && !fixed_regs[regno]\n-\t\t    && TEST_HARD_REG_BIT (regs_invalidated_by_call, regno)\n-\t\t    && !REGNO_REG_SET_P\n-\t\t    (DF_LR_IN (EXIT_BLOCK_PTR), regno)\n-\t\t    && !refers_to_regno_p (regno,\n-\t\t\t\t\t   end_hard_regno (Pmode, regno),\n-\t\t\t\t\t   info.equiv_reg_src, NULL)\n-\t\t    && info.const_equiv[regno] == 0)\n-\t\t  break;\n-\n-\t      gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n-\n-\t      reg = gen_rtx_REG (Pmode, regno);\n-\t      emit_move_insn (reg, retaddr);\n-\t      retaddr = reg;\n-\t    }\n-\n-\t  emit_equiv_load (&info);\n-\t  jump_insn = emit_jump_insn (gen_indirect_jump (retaddr));\n-\n-\t  /* Show the SET in the above insn is a RETURN.  */\n-\t  jump_set = single_set (jump_insn);\n-\t  gcc_assert (jump_set);\n-\t  SET_IS_RETURN_P (jump_set) = 1;\n-\t}\n-\n-      /* If SP is not mentioned in the pattern and its equivalent register, if\n-\t any, is not modified, just emit it.  Otherwise, if neither is set,\n-\t replace the reference to SP and emit the insn.  If none of those are\n-\t true, handle each SET individually.  */\n-      else if (!reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))\n-\t       && (info.sp_equiv_reg == stack_pointer_rtx\n-\t\t   || !reg_set_p (info.sp_equiv_reg, insn)))\n-\tadd_insn (insn);\n-      else if (! reg_set_p (stack_pointer_rtx, insn)\n-\t       && (info.sp_equiv_reg == stack_pointer_rtx\n-\t\t   || !reg_set_p (info.sp_equiv_reg, insn)))\n-\t{\n-\t  int changed;\n-\n-\t  changed = validate_replace_rtx (stack_pointer_rtx,\n-\t\t\t\t\t  plus_constant (info.sp_equiv_reg,\n-\t\t\t\t\t\t\t info.sp_offset),\n-\t\t\t\t\t  insn);\n-\t  gcc_assert (changed);\n-\n-\t  add_insn (insn);\n-\t}\n-      else if (GET_CODE (PATTERN (insn)) == SET)\n-\thandle_epilogue_set (PATTERN (insn), &info);\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t{\n-\t  for (j = 0; j < XVECLEN (PATTERN (insn), 0); j++)\n-\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET)\n-\t      handle_epilogue_set (XVECEXP (PATTERN (insn), 0, j), &info);\n-\t}\n-      else\n-\tadd_insn (insn);\n-\n-      info.sp_equiv_reg = info.new_sp_equiv_reg;\n-      info.sp_offset = info.new_sp_offset;\n-\n-      /* Now update any constants this insn sets.  */\n-      note_stores (PATTERN (insn), update_epilogue_consts, &info);\n-      insn = next;\n-    }\n-\n-  insns = get_insns ();\n-  end_sequence ();\n-  return insns;\n-}\n-\n-/* SET is a SET from an insn in the epilogue.  P is a pointer to the epi_info\n-   structure that contains information about what we've seen so far.  We\n-   process this SET by either updating that data or by emitting one or\n-   more insns.  */\n-\n-static void\n-handle_epilogue_set (rtx set, struct epi_info *p)\n-{\n-  /* First handle the case where we are setting SP.  Record what it is being\n-     set from, which we must be able to determine  */\n-  if (reg_set_p (stack_pointer_rtx, set))\n-    {\n-      gcc_assert (SET_DEST (set) == stack_pointer_rtx);\n-\n-      if (GET_CODE (SET_SRC (set)) == PLUS)\n-\t{\n-\t  p->new_sp_equiv_reg = XEXP (SET_SRC (set), 0);\n-\t  if (GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n-\t    p->new_sp_offset = INTVAL (XEXP (SET_SRC (set), 1));\n-\t  else\n-\t    {\n-\t      gcc_assert (REG_P (XEXP (SET_SRC (set), 1))\n-\t\t\t  && (REGNO (XEXP (SET_SRC (set), 1))\n-\t\t\t      < FIRST_PSEUDO_REGISTER)\n-\t\t\t  && p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))]);\n-\t      p->new_sp_offset\n-\t\t= INTVAL (p->const_equiv[REGNO (XEXP (SET_SRC (set), 1))]);\n-\t    }\n-\t}\n-      else\n-\tp->new_sp_equiv_reg = SET_SRC (set), p->new_sp_offset = 0;\n-\n-      /* If we are adjusting SP, we adjust from the old data.  */\n-      if (p->new_sp_equiv_reg == stack_pointer_rtx)\n-\t{\n-\t  p->new_sp_equiv_reg = p->sp_equiv_reg;\n-\t  p->new_sp_offset += p->sp_offset;\n-\t}\n-\n-      gcc_assert (p->new_sp_equiv_reg && REG_P (p->new_sp_equiv_reg));\n-\n-      return;\n-    }\n-\n-  /* Next handle the case where we are setting SP's equivalent\n-     register.  We must not already have a value to set it to.  We\n-     could update, but there seems little point in handling that case.\n-     Note that we have to allow for the case where we are setting the\n-     register set in the previous part of a PARALLEL inside a single\n-     insn.  But use the old offset for any updates within this insn.\n-     We must allow for the case where the register is being set in a\n-     different (usually wider) mode than Pmode).  */\n-  else if (p->new_sp_equiv_reg != 0 && reg_set_p (p->new_sp_equiv_reg, set))\n-    {\n-      gcc_assert (!p->equiv_reg_src\n-\t\t  && REG_P (p->new_sp_equiv_reg)\n-\t\t  && REG_P (SET_DEST (set))\n-\t\t  && (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set)))\n-\t\t      <= BITS_PER_WORD)\n-\t\t  && REGNO (p->new_sp_equiv_reg) == REGNO (SET_DEST (set)));\n-      p->equiv_reg_src\n-\t= simplify_replace_rtx (SET_SRC (set), stack_pointer_rtx,\n-\t\t\t\tplus_constant (p->sp_equiv_reg,\n-\t\t\t\t\t       p->sp_offset));\n-    }\n-\n-  /* Otherwise, replace any references to SP in the insn to its new value\n-     and emit the insn.  */\n-  else\n-    {\n-      SET_SRC (set) = simplify_replace_rtx (SET_SRC (set), stack_pointer_rtx,\n-\t\t\t\t\t    plus_constant (p->sp_equiv_reg,\n-\t\t\t\t\t\t\t   p->sp_offset));\n-      SET_DEST (set) = simplify_replace_rtx (SET_DEST (set), stack_pointer_rtx,\n-\t\t\t\t\t     plus_constant (p->sp_equiv_reg,\n-\t\t\t\t\t\t\t    p->sp_offset));\n-      emit_insn (set);\n-    }\n-}\n-\n-/* Update the tracking information for registers set to constants.  */\n-\n-static void\n-update_epilogue_consts (rtx dest, const_rtx x, void *data)\n-{\n-  struct epi_info *p = (struct epi_info *) data;\n-  rtx new;\n-\n-  if (!REG_P (dest) || REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n-    return;\n-\n-  /* If we are either clobbering a register or doing a partial set,\n-     show we don't know the value.  */\n-  else if (GET_CODE (x) == CLOBBER || ! rtx_equal_p (dest, SET_DEST (x)))\n-    p->const_equiv[REGNO (dest)] = 0;\n-\n-  /* If we are setting it to a constant, record that constant.  */\n-  else if (GET_CODE (SET_SRC (x)) == CONST_INT)\n-    p->const_equiv[REGNO (dest)] = SET_SRC (x);\n-\n-  /* If this is a binary operation between a register we have been tracking\n-     and a constant, see if we can compute a new constant value.  */\n-  else if (ARITHMETIC_P (SET_SRC (x))\n-\t   && REG_P (XEXP (SET_SRC (x), 0))\n-\t   && REGNO (XEXP (SET_SRC (x), 0)) < FIRST_PSEUDO_REGISTER\n-\t   && p->const_equiv[REGNO (XEXP (SET_SRC (x), 0))] != 0\n-\t   && GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n-\t   && 0 != (new = simplify_binary_operation\n-\t\t    (GET_CODE (SET_SRC (x)), GET_MODE (dest),\n-\t\t     p->const_equiv[REGNO (XEXP (SET_SRC (x), 0))],\n-\t\t     XEXP (SET_SRC (x), 1)))\n-\t   && GET_CODE (new) == CONST_INT)\n-    p->const_equiv[REGNO (dest)] = new;\n-\n-  /* Otherwise, we can't do anything with this value.  */\n-  else\n-    p->const_equiv[REGNO (dest)] = 0;\n-}\n-\n-/* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */\n-\n-static void\n-emit_equiv_load (struct epi_info *p)\n-{\n-  if (p->equiv_reg_src != 0)\n-    {\n-      rtx dest = p->sp_equiv_reg;\n-\n-      if (GET_MODE (p->equiv_reg_src) != GET_MODE (dest))\n-\tdest = gen_rtx_REG (GET_MODE (p->equiv_reg_src),\n-\t\t\t    REGNO (p->sp_equiv_reg));\n-\n-      emit_move_insn (dest, p->equiv_reg_src);\n-      p->equiv_reg_src = 0;\n-    }\n-}\n-#endif\n-\n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n    the epilogue begins.  Update the basic block information when possible.  */\n@@ -5274,17 +4894,7 @@ thread_prologue_and_epilogue_insns (void)\n     {\n       start_sequence ();\n       epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n-\n       seq = gen_epilogue ();\n-\n-#ifdef INCOMING_RETURN_ADDR_RTX\n-      /* If this function returns with the stack depressed and we can support\n-\t it, massage the epilogue to actually do that.  */\n-      if (TREE_CODE (TREE_TYPE (current_function_decl)) == FUNCTION_TYPE\n-\t  && TYPE_RETURNS_STACK_DEPRESSED (TREE_TYPE (current_function_decl)))\n-\tseq = keep_stack_depressed (seq);\n-#endif\n-\n       emit_jump_insn (seq);\n \n       /* Retain a map of the epilogue insns.  */"}, {"sha": "f7097a415d42e3c9862f427e9e02e4d905817034", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -565,9 +565,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       else if (TREE_CODE (node) == INTEGER_TYPE\n \t       && TYPE_IS_SIZETYPE (node))\n \tfputs (\" sizetype\", file);\n-      else if (TREE_CODE (node) == FUNCTION_TYPE\n-\t       && TYPE_RETURNS_STACK_DEPRESSED (node))\n-\tfputs (\" returns-stack-depressed\", file);\n \n       if (TYPE_STRING_FLAG (node))\n \tfputs (\" string-flag\", file);"}, {"sha": "3d87a72f295f613419e6350a092f30a6d2bdff68", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dd9bf80a87fdd119261f5efb8a9ceceffb12963/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9dd9bf80a87fdd119261f5efb8a9ceceffb12963", "patch": "@@ -2207,11 +2207,6 @@ struct tree_block GTY(())\n #define TYPE_IS_SIZETYPE(NODE) \\\n   (INTEGER_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n \n-/* In a FUNCTION_TYPE, indicates that the function returns with the stack\n-   pointer depressed.  */\n-#define TYPE_RETURNS_STACK_DEPRESSED(NODE) \\\n-  (FUNCTION_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n-\n /* Nonzero in a type considered volatile as a whole.  */\n #define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->base.volatile_flag)\n \n@@ -5002,14 +4997,11 @@ extern tree build_duplicate_type (tree);\n /* Nonzero if this is a call to \"pure\" function (like const function,\n    but may read memory.  */\n #define ECF_PURE\t\t128\n-/* Nonzero if this is a call to a function that returns with the stack\n-   pointer depressed.  */\n-#define ECF_SP_DEPRESSED\t256\n /* Create libcall block around the call.  */\n-#define ECF_LIBCALL_BLOCK\t512\n+#define ECF_LIBCALL_BLOCK\t256\n /* Function does not read or write memory (but may have side effects, so\n    it does not necessarily fit ECF_CONST).  */\n-#define ECF_NOVOPS\t\t1024\n+#define ECF_NOVOPS\t\t512\n \n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);"}]}