{"sha": "9dee6758c3677473917b41309fd8d04f1145b377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlZTY3NThjMzY3NzQ3MzkxN2I0MTMwOWZkOGQwNGYxMTQ1YjM3Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-28T23:43:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-28T23:43:21Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r853", "tree": {"sha": "b1a590760546f00736f748e9fe61a668ba03aa6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1a590760546f00736f748e9fe61a668ba03aa6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dee6758c3677473917b41309fd8d04f1145b377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dee6758c3677473917b41309fd8d04f1145b377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dee6758c3677473917b41309fd8d04f1145b377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dee6758c3677473917b41309fd8d04f1145b377/comments", "author": null, "committer": null, "parents": [{"sha": "00a8faa302f7eba507852e21fc85a5d5a9650494", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00a8faa302f7eba507852e21fc85a5d5a9650494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00a8faa302f7eba507852e21fc85a5d5a9650494"}], "stats": {"total": 243, "additions": 133, "deletions": 110}, "files": [{"sha": "fb512cce1100f4700228884c08a2d4e39c0f86db", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 133, "deletions": 110, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dee6758c3677473917b41309fd8d04f1145b377/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dee6758c3677473917b41309fd8d04f1145b377/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=9dee6758c3677473917b41309fd8d04f1145b377", "patch": "@@ -84,6 +84,22 @@ char *objc_tree_code_name[] = {\n };\n #undef DEFTREECODE\n \f\n+/* Set up for use of obstacks.  */\n+\n+#include \"obstack.h\"\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern int xmalloc ();\n+extern void free ();\n+\n+/* This obstack is used to accumulate the encoding of a data type.  */\n+static struct obstack util_obstack;\n+/* This points to the beginning of obstack contents,\n+   so we can free the whole contents.  */\n+char *util_firstobj;\n+\n /* for encode_method_def */\n #include \"rtl.h\"\n \n@@ -274,7 +290,6 @@ static int  method_slot = 0;\t/* used by start_method_def */\n #define BUFSIZE\t\t512\n \n static char *errbuf;\t/* a buffer for error diagnostics */\n-static char *utlbuf;\t/* a buffer for general utility */\n \n extern char *strcpy (), *strcat ();\n \n@@ -1805,10 +1820,10 @@ build_ivar_list_initializer (field_decl, size)\n       }\n \n       /* set type */\n-      bzero (utlbuf, BUFSIZE);\n-      encode_field_decl (field_decl, utlbuf, OBJC_ENCODE_DONT_INLINE_DEFS);\n+      encode_field_decl (field_decl, OBJC_ENCODE_DONT_INLINE_DEFS);\n+      offset = add_objc_string (get_identifier (obstack_finish (&util_obstack)));\n+      obstack_free (&util_obstack, util_firstobj);\n \n-      offset = add_objc_string (get_identifier (utlbuf));\n       initlist = tree_cons (NULLT, build_msg_pool_reference (offset), initlist);\n \n       /* set offset */\n@@ -2920,17 +2935,19 @@ tree\n build_encode_expr (type)\n      tree type;\n {\n+  tree result;\n+  char *string;\n+\n   if (!doing_objc_thang)\n     fatal (\"Objective-C text in C source file\");\n \n-  if (!utlbuf)\n-    utlbuf = (char *)xmalloc (BUFSIZE);\n-  bzero (utlbuf, BUFSIZE);\n-\n-  encode_type (type, utlbuf, OBJC_ENCODE_INLINE_DEFS);\n+  encode_type (type, OBJC_ENCODE_INLINE_DEFS);\n+  string = obstack_finish (&util_obstack);\n \n   /* synthesize a string that represents the encoded struct/union */\n-  return my_build_string (strlen (utlbuf) + 1, utlbuf);\n+  result = my_build_string (strlen (string) + 1, string);\n+  obstack_free (&util_obstack, util_firstobj);\n+  return result;\n }\n \n tree\n@@ -3620,9 +3637,7 @@ finish_class (class)\n }\n \f\n /* \"Encode\" a data type into a string, whichg rows  in util_obstack.\n-   ??? What is the FORMAT?  */\n-\n-#error rms is in middle of changing this part\n+   ??? What is the FORMAT?  Someone please document this!  */\n \n /* Encode a pointer type.  */\n \n@@ -3671,7 +3686,7 @@ encode_pointer (type, format)\n \n   /* NeXT extension */\n   obstack_1grow (&util_obstack, '^');\n-  encode_type (pointer_to, str, format);\n+  encode_type (pointer_to, format);\n }\n \n static void\n@@ -3726,7 +3741,7 @@ encode_aggregate (type, format)\n \t\tobstack_1grow (&util_obstack, '}');\n \t      }\n \t    else /* we have an untagged structure or a typedef */\n-\t      obstack_grow (&util_obstack, \"{?}\");\n+\t      obstack_grow (&util_obstack, \"{?}\", 3);\n \t  }\n \telse\n \t  {\n@@ -3755,7 +3770,7 @@ encode_aggregate (type, format)\n \t\tobstack_1grow (&util_obstack, '>');\n \t      }\n \t    else /* we have an untagged structure or a typedef */\n-\t      obstack_grow (&util_obstack, \"<?>\");\n+\t      obstack_grow (&util_obstack, \"<?>\", 3);\n \t  }\n \telse\n \t  {\n@@ -3786,12 +3801,13 @@ encode_aggregate (type, format)\n  *  hand generating this string (which is tedious).\n  */\n static void\n-encode_bitfield (width, str, format)\n+encode_bitfield (width, format)\n      int width;\n-     char *str;\n      int format;\n {\n-  sprintf (str + strlen (str), \"b%d\", width);\n+  char buffer[40];\n+  sprintf (buffer, \"b%d\", width);\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n }\n \f\n /*\n@@ -3800,9 +3816,8 @@ encode_bitfield (width, str, format)\n  *\tOBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS\n  */\n static void\n-encode_type (type, str, format)\n+encode_type (type, format)\n      tree type;\n-     char *str;\n      int format;\n {\n   enum tree_code code = TREE_CODE (type);\n@@ -3814,29 +3829,29 @@ encode_type (type, str, format)\n \t  /* unsigned integer types */\n \n \t  if (TYPE_MODE (type) == QImode) /* 'C' */\n-\t    strcat (str, \"C\");\n+\t    obstack_1grow (&util_obstack, 'C');\n \t  else if (TYPE_MODE (type) == HImode) /* 'S' */\n-\t    strcat (str, \"S\");\n+\t    obstack_1grow (&util_obstack, 'S');\n \t  else if (TYPE_MODE (type) == SImode)\n \t    {\n \t      if (type == long_unsigned_type_node)\n-\t\tstrcat (str, \"L\"); /* 'L' */\n+\t\tobstack_1grow (&util_obstack, 'L'); /* 'L' */\n \t      else\n-\t\tstrcat (str, \"I\"); /* 'I' */\n+\t\tobstack_1grow (&util_obstack, 'I'); /* 'I' */\n \t    }\n \t}\n       else\t\t\t/* signed integer types */\n \t{\n \t  if (TYPE_MODE (type) == QImode) /* 'c' */\n-\t    strcat (str, \"c\");\n+\t    obstack_1grow (&util_obstack, 'c');\n \t  else if (TYPE_MODE (type) == HImode) /* 's' */\n-\t    strcat (str, \"s\");\n+\t    obstack_1grow (&util_obstack, 's');\n \t  else if (TYPE_MODE (type) == SImode) /* 'i' */\n \t    {\n \t      if (type == long_integer_type_node)\n-\t\tstrcat (str, \"l\"); /* 'l' */\n+\t\tobstack_1grow (&util_obstack, 'l'); /* 'l' */\n \t      else\n-\t\tstrcat (str, \"i\"); /* 'i' */\n+\t\tobstack_1grow (&util_obstack, 'i'); /* 'i' */\n \t    }\n \t}\n     }\n@@ -3845,38 +3860,37 @@ encode_type (type, str, format)\n       /* floating point types */\n \n       if (TYPE_MODE (type) == SFmode) /* 'f' */\n-\tstrcat (str, \"f\");\n+\tobstack_1grow (&util_obstack, 'f');\n       else if (TYPE_MODE (type) == DFmode\n \t       || TYPE_MODE (type) == TFmode) /* 'd' */\n-\tstrcat (str, \"d\");\n+\tobstack_1grow (&util_obstack, 'd');\n     }\n \n   else if (code == VOID_TYPE)\t/* 'v' */\n-    strcat (str, \"v\");\n+    obstack_1grow (&util_obstack, 'v');\n \n   else if (code == ARRAY_TYPE)\n-    encode_array (type, str, format);\n+    encode_array (type, format);\n \n   else if (code == POINTER_TYPE)\n-    encode_pointer (type, str, format);\n+    encode_pointer (type, format);\n \n   else if (code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)\n-    encode_aggregate (type, str, format);\n+    encode_aggregate (type, format);\n \n   else if (code == FUNCTION_TYPE) /* '?' */\n-    strcat (str, \"?\");\n+    obstack_1grow (&util_obstack, '?');\n }\n \n static void\n-encode_field_decl (field_decl, str, format)\n+encode_field_decl (field_decl, format)\n      tree field_decl;\n-     char *str;\n      int format;\n {\n   if (DECL_BIT_FIELD (field_decl))\n-    encode_bitfield (DECL_FIELD_SIZE (field_decl), str, format);\n+    encode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n   else\n-    encode_type (TREE_TYPE (field_decl), str, format);\n+    encode_type (TREE_TYPE (field_decl), format);\n }\n \n static tree\n@@ -4314,19 +4328,20 @@ encode_method_def (func_decl)\n {\n   tree parms;\n   int stack_size = 0;\n-\n-  bzero (utlbuf, BUFSIZE);\n+  char buffer[40];\n+  tree result;\n \n   /* return type */\n-  encode_type (TREE_TYPE (TREE_TYPE (func_decl)), utlbuf, \n+  encode_type (TREE_TYPE (TREE_TYPE (func_decl)),\n \t       OBJC_ENCODE_DONT_INLINE_DEFS);\n   /* stack size */\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n        parms = TREE_CHAIN (parms))\n     stack_size += TREE_INT_CST_LOW (TYPE_SIZE (DECL_ARG_TYPE (parms)))\n \t\t  / BITS_PER_UNIT;\n \n-  sprintf (&utlbuf[strlen (utlbuf)], \"%d\", stack_size);\n+  sprintf (buffer, \"%d\", stack_size);\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n \n   /* argument types */\n   for (parms = DECL_ARGUMENTS (func_decl); parms;\n@@ -4335,7 +4350,7 @@ encode_method_def (func_decl)\n       int offset_in_bytes;\n   \n       /* type */ \n-      encode_type (TREE_TYPE (parms), utlbuf, OBJC_ENCODE_DONT_INLINE_DEFS);\n+      encode_type (TREE_TYPE (parms), OBJC_ENCODE_DONT_INLINE_DEFS);\n   \n       /* compute offset */\n       if (GET_CODE (DECL_INCOMING_RTL (parms)) == MEM)\n@@ -4369,10 +4384,13 @@ encode_method_def (func_decl)\n       \n       /* The \"+ 4\" is a total hack to account for the return pc and\n          saved fp on the 68k.  We should redefine this format! */\n-      sprintf (&utlbuf[strlen (utlbuf)], \"%d\", offset_in_bytes + 8);\n+      sprintf (buffer, \"%d\", offset_in_bytes + 8);\n+      obstack_grow (&util_obstack, buffer, strlen (buffer));\n     }\n \n-  return get_identifier (utlbuf);\n+  result = get_identifier (obstack_finish (&util_obstack));\n+  obstack_free (&util_obstack, util_firstobj);\n+  return result;\n }\n \n void\n@@ -4859,6 +4877,9 @@ init_objc ()\n {\n   /* Add the special tree codes of Objective C to the tables.  */\n \n+  gcc_obstack_init (&util_obstack);\n+  util_firstobj = (char *) obstack_finish (&util_obstack);\n+\n   tree_code_type\n     = (char **) realloc (tree_code_type,\n \t\t\t sizeof (char *) * LAST_OBJC_TREE_CODE);\n@@ -4882,11 +4903,10 @@ init_objc ()\n \t  * sizeof (char *)));\n \n   errbuf = (char *)xmalloc (BUFSIZE);\n-  utlbuf = (char *)xmalloc (BUFSIZE);\n   hash_init ();\n   synth_module_prologue ();\n }\n-\n+\f\n void\n finish_objc ()\n {\n@@ -4949,70 +4969,11 @@ finish_objc ()\n      linked environment\n      */\n   for (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))\n-    {\n-      tree decl;\n-\n-#if 0 /* Grossly unportable.  */\n-      sprintf (utlbuf, \".reference .objc_class_name_%s\",\n-\t       IDENTIFIER_POINTER (TREE_VALUE (chain)));\n-      assemble_asm (my_build_string (strlen (utlbuf) + 1, utlbuf));\n-#else\n-      sprintf (utlbuf, \".objc_class_name_%s\",\n-\t       IDENTIFIER_POINTER (TREE_VALUE (chain)));\n-#endif\n-      /* Make a decl for this name, so we can use its address in a tree.  */\n-      decl = build_decl (VAR_DECL, get_identifier (utlbuf), char_type_node);\n-      TREE_EXTERNAL (decl) = 1;\n-      TREE_PUBLIC (decl) = 1;\n-      \n-      pushdecl (decl);\n-      rest_of_decl_compilation (decl, 0, 0, 0);\n-\n-      /* Make following constant read-only (why not)?  */\n-      text_section ();\n-\n-      /* Output a constant to reference this address.  */\n-      output_constant (build1 (ADDR_EXPR, string_type_node, decl),\n-\t\t       int_size_in_bytes (string_type_node));\n-    }\n+    handle_class_ref (chain);\n \n   for (impent = imp_list; impent; impent = impent->next)\n-    {\n-      implementation_context = impent->imp_context;\n-      implementation_template = impent->imp_template;\n+    handle_impent (impent);\n \n-      if (TREE_CODE (impent->imp_context) == IMPLEMENTATION_TYPE)\n-\t{\n-#if 0 /* Grossly unportable.\n-\t\t\t    People should know better than to assume\n-\t\t\t    such things about assembler syntax!  */\n-\t  sprintf (utlbuf, \".objc_class_name_%s=0\",\n-\t\t   IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n-\t  assemble_asm (my_build_string (strlen (utlbuf) + 1, utlbuf));\n-#endif\n-\t  sprintf (utlbuf, \".objc_class_name_%s\",\n-\t\t   IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n-\t  assemble_global (utlbuf);\n-\t  assemble_label (utlbuf);\n-\t}\n-      else if (TREE_CODE (impent->imp_context) == CATEGORY_TYPE)\n-\t{\n-\t  /* Do the same for categories.  Even though no references to these\n-\t      symbols are generated automatically by the compiler, it gives\n-\t      you a handle to pull them into an archive by hand. */\n-#if 0 /* Grossly unportable.  */\n-\t  sprintf (utlbuf, \".objc_category_name_%s_%s=0\",\n-\t\t   IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)),\n-\t\t   IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context)));\n-\t  assemble_asm (my_build_string (strlen (utlbuf) + 1, utlbuf));\n-#endif\n-\t  sprintf (utlbuf, \".objc_category_name_%s_%s\",\n-\t\t   IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)),\n-\t\t   IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context)));\n-\t  assemble_global (utlbuf);\n-\t  assemble_label (utlbuf);\n-\t}\n-    }\n #if 0 /* If GAS has such a bug, let's fix it.  */\n   /*** this fixes a gross bug in the assembler...it `expects' #APP to have\n    *** a matching #NO_APP, or it crashes (sometimes). app_disable () will\n@@ -5079,7 +5040,69 @@ finish_objc ()\n \t}\n     }\n }\n+\f\n+/* Subroutines of finish_objc.  */\n+\n+handle_class_ref (chain)\n+     tree chain;\n+{\n+  tree decl;\n+  char *string\n+    = (char *) alloca (strlen (IDENTIFIER_POINTER (TREE_VALUE (chain))) + 30);\n \n+  sprintf (string, \".objc_class_name_%s\",\n+\t   IDENTIFIER_POINTER (TREE_VALUE (chain)));\n+\n+  /* Make a decl for this name, so we can use its address in a tree.  */\n+  decl = build_decl (VAR_DECL, get_identifier (string), char_type_node);\n+  TREE_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+\n+  pushdecl (decl);\n+  rest_of_decl_compilation (decl, 0, 0, 0);\n+\n+  /* Make following constant read-only (why not)?  */\n+  text_section ();\n+\n+  /* Output a constant to reference this address.  */\n+  output_constant (build1 (ADDR_EXPR, string_type_node, decl),\n+\t\t   int_size_in_bytes (string_type_node));\n+}\n+\n+handle_impent (impent)\n+     struct imp_entry *impent;\n+{\n+  implementation_context = impent->imp_context;\n+  implementation_template = impent->imp_template;\n+\n+  if (TREE_CODE (impent->imp_context) == IMPLEMENTATION_TYPE)\n+    {\n+      char *string\n+\t= (char *) alloca (strlen (IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context))) + 30);\n+\n+      sprintf (string, \".objc_class_name_%s\",\n+\t       IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n+      assemble_global (string);\n+      assemble_label (string);\n+    }\n+  else if (TREE_CODE (impent->imp_context) == CATEGORY_TYPE)\n+    {\n+      char *string\n+\t= (char *) alloca (strlen (IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)))\n+\t\t\t   + strlen (IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context)))\n+\t\t\t   + 30);\n+\n+      /* Do the same for categories.  Even though no references to these\n+\t  symbols are generated automatically by the compiler, it gives\n+\t  you a handle to pull them into an archive by hand. */\n+      sprintf (string, \".objc_category_name_%s_%s\",\n+\t       IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)),\n+\t       IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context)));\n+      assemble_global (string);\n+      assemble_label (string);\n+    }\n+}\n+\f\n #ifdef DEBUG\n \n static void"}]}