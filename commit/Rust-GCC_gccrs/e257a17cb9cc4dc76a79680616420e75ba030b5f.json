{"sha": "e257a17cb9cc4dc76a79680616420e75ba030b5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1N2ExN2NiOWNjNGRjNzZhNzk2ODA2MTY0MjBlNzViYTAzMGI1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-11T05:51:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-11T05:51:23Z"}, "message": "varasm.c (set_implicit_section): New function.\n\n\n\t* varasm.c (set_implicit_section): New function.\n\t(resolve_unique_section): Use it to set implicit section\n\tfor aliases, too.\n\t(get_named_text_section): Use symtab_get_node (decl)->implicit_section\n\t(default_function_section): Likewise.\n\t(decl_binds_to_current_def_p): Constify argument.\n\t* varasm.h (decl_binds_to_current_def_p): Update prototype.\n\t* asan.c (asan_protect_global): Use symtab_get_node (decl)->implicit_section.\n\t* symtab.c (dump_symtab_base): Dump implicit sections.\n\t(verify_symtab_base): Verify sanity of sectoins and comdats.\n\t(symtab_resolve_alias): Alias share the section of its target.\n\t(set_section_1): New function.\n\t(symtab_node::set_section): Move here, recurse to aliases.\n\t(verify_symtab): Check for duplicated symtab lists.\n\t* tree-core.h (implicit_section_name_p): Remove.\n\t* tree-vect-data-refs.c: Include varasm.h.\n\t(vect_can_force_dr_alignment_p): Fix conditional on when\n\tdecl bints to current definition; use\n\tsymtab_get_node (decl)->implicit_section.\n\t* cgraph.c (cgraph_make_node_local_1): Fix section set.\n\t* cgraph.h (struct symtab_node): Add implicit_section.\n\t(set_section): Rename to ...\n\t(set_section_for_node): ... this one.\n\t(set_section): Declare.\n\t* tree.h (DECL_HAS_IMPLICIT_SECTION_NAME_P): Remove.\n\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n\tinput_overwrite_node, input_varpool_node): Stream implicit_section.\n\t* ipa.c (symtab_remove_unreachable_nodes): Do not check symtab before\n\tremoval; it will fail in LTO.\n\t\n\t* vtable-class-hierarchy.c: Use symtab_get_node (var_decl)->implicit_section.\n\t* optimize.c (cdtor_comdat_group): Fix handling of aliases.\n\t(maybe_clone_body): Move symbol across comdat groups.\n\t* method.c (use_thunk): Copy implicit section flag.\n\n\t* go/go-gcc.cc (Gcc_backend::global_variable_set_init): Use\n\tsymtab_get_node(var_decl)->implicit_section.\n\n\t* lto.c (read_cgraph_and_symbols): Remove unreachable symbols.\n\t(do_whole_program_analysis): Use verify_symtab.\n\nFrom-SVN: r211434", "tree": {"sha": "1eaa587ddb6f0f91bbd446438e1bb46f9b1df815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eaa587ddb6f0f91bbd446438e1bb46f9b1df815"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e257a17cb9cc4dc76a79680616420e75ba030b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e257a17cb9cc4dc76a79680616420e75ba030b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e257a17cb9cc4dc76a79680616420e75ba030b5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e257a17cb9cc4dc76a79680616420e75ba030b5f/comments", "author": null, "committer": null, "parents": [{"sha": "58170a6621f1677c692634d28c4f67a24da42b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58170a6621f1677c692634d28c4f67a24da42b13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58170a6621f1677c692634d28c4f67a24da42b13"}], "stats": {"total": 288, "additions": 240, "deletions": 48}, "files": [{"sha": "80887df7f7a9340b36b4f999e99bb5048495bcb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1,3 +1,35 @@\n+2014-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* varasm.c (set_implicit_section): New function.\n+\t(resolve_unique_section): Use it to set implicit section\n+\tfor aliases, too.\n+\t(get_named_text_section): Use symtab_get_node (decl)->implicit_section\n+\t(default_function_section): Likewise.\n+\t(decl_binds_to_current_def_p): Constify argument.\n+\t* varasm.h (decl_binds_to_current_def_p): Update prototype.\n+\t* asan.c (asan_protect_global): Use symtab_get_node (decl)->implicit_section.\n+\t* symtab.c (dump_symtab_base): Dump implicit sections.\n+\t(verify_symtab_base): Verify sanity of sectoins and comdats.\n+\t(symtab_resolve_alias): Alias share the section of its target.\n+\t(set_section_1): New function.\n+\t(symtab_node::set_section): Move here, recurse to aliases.\n+\t(verify_symtab): Check for duplicated symtab lists.\n+\t* tree-core.h (implicit_section_name_p): Remove.\n+\t* tree-vect-data-refs.c: Include varasm.h.\n+\t(vect_can_force_dr_alignment_p): Fix conditional on when\n+\tdecl bints to current definition; use\n+\tsymtab_get_node (decl)->implicit_section.\n+\t* cgraph.c (cgraph_make_node_local_1): Fix section set.\n+\t* cgraph.h (struct symtab_node): Add implicit_section.\n+\t(set_section): Rename to ...\n+\t(set_section_for_node): ... this one.\n+\t(set_section): Declare.\n+\t* tree.h (DECL_HAS_IMPLICIT_SECTION_NAME_P): Remove.\n+\t* lto-cgraph.c (lto_output_node, lto_output_varpool_node,\n+\tinput_overwrite_node, input_varpool_node): Stream implicit_section.\n+\t* ipa.c (symtab_remove_unreachable_nodes): Do not check symtab before\n+\tremoval; it will fail in LTO.\n+\n 2014-06-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (move_lo_quad_<mode>):"}, {"sha": "faa609d7673a84085fe7414f6d1555961f25e46d", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1289,7 +1289,7 @@ asan_protect_global (tree decl)\n \t to be an array of such vars, putting padding in there\n \t breaks this assumption.  */\n       || (DECL_SECTION_NAME (decl) != NULL_TREE\n-\t  && !DECL_HAS_IMPLICIT_SECTION_NAME_P (decl))\n+\t  && !symtab_get_node (decl)->implicit_section)\n       || DECL_SIZE (decl) == 0\n       || ASAN_RED_ZONE_SIZE * BITS_PER_UNIT > MAX_OFILE_ALIGNMENT\n       || !valid_constant_size_p (DECL_SIZE_UNIT (decl))"}, {"sha": "610bf6717c153e35de26cf21d4cd286023785d8d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -2264,7 +2264,7 @@ cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n       node->externally_visible = false;\n       node->forced_by_abi = false;\n       node->local.local = true;\n-      node->set_comdat_group (NULL);\n+      node->set_section (NULL);\n       node->unique_name = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t  || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n       node->resolution = LDPR_PREVAILING_DEF_IRONLY;"}, {"sha": "dc286d9e68552df19bbebbff958b6cd157534d15", "filename": "gcc/cgraph.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -93,6 +93,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   unsigned forced_by_abi : 1;\n   /* True when the name is known to be unique and thus it does not need mangling.  */\n   unsigned unique_name : 1;\n+  /* Specify whether the section was set by user or by\n+     compiler via -ffunction-sections.  */\n+  unsigned implicit_section : 1;\n   /* True when body and other characteristics have been removed by\n      symtab_remove_unreachable_nodes. */\n   unsigned body_removed : 1;\n@@ -162,17 +165,29 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n       comdat_group_ = group;\n     }\n \n-  /* Return section.  */\n-  tree get_section ()\n+  /* Return section as STRING_CST.  */\n+  tree get_section_name ()\n     {\n       return section_;\n     }\n \n-  /* Set section.  */\n-  void set_section (tree section)\n+  /* Return section as string.  */\n+  const char * get_section ()\n+    {\n+      if (!section_)\n+\treturn NULL;\n+      return TREE_STRING_POINTER (section_);\n+    }\n+\n+  /* Set section, do not recurse into aliases.\n+     When one wants to change section of symbol and its aliases,\n+     use set_section  */\n+  void set_section_for_node (tree section)\n     {\n       gcc_checking_assert (!section || TREE_CODE (section) == STRING_CST);\n       section_ = section;\n+      if (!section)\n+\timplicit_section = false;\n     }\n \n   /* Vectors of referring and referenced entities.  */\n@@ -193,6 +208,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   /* Section name. Again can be private, if allowed.  */\n   tree section_;\n+\n+  /* Set section for symbol and its aliases.  */\n+  void set_section (tree section);\n };\n \n enum availability"}, {"sha": "35aa7bf218e1f6d36cd88b7c51816f4ea2fb1b8c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1,3 +1,10 @@\n+2014-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* vtable-class-hierarchy.c: Use symtab_get_node (var_decl)->implicit_section.\n+\t* optimize.c (cdtor_comdat_group): Fix handling of aliases.\n+\t(maybe_clone_body): Move symbol across comdat groups.\n+\t* method.c (use_thunk): Copy implicit section flag.\n+\n 2014-06-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/22556"}, {"sha": "447334fdefe8541433f28452acd8559ced050f9d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -356,14 +356,27 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   if (TARGET_USE_LOCAL_THUNK_ALIAS_P (function)\n       && targetm_common.have_named_sections)\n     {\n-      resolve_unique_section (function, 0, flag_function_sections);\n+      tree fn = function;\n+      struct symtab_node *symbol;\n \n-      if (DECL_SECTION_NAME (function) != NULL && DECL_ONE_ONLY (function))\n+      if ((symbol = symtab_get_node (function))\n+\t  && symbol->alias)\n+\t{\n+\t  if (symbol->analyzed)\n+\t    fn = symtab_alias_ultimate_target (symtab_get_node (function))->decl;\n+\t  else\n+\t    fn = symtab_get_node (function)->alias_target;\n+\t}\n+      resolve_unique_section (fn, 0, flag_function_sections);\n+\n+      if (DECL_SECTION_NAME (fn) != NULL && DECL_ONE_ONLY (fn))\n \t{\n \t  resolve_unique_section (thunk_fndecl, 0, flag_function_sections);\n \n \t  /* Output the thunk into the same section as function.  */\n-\t  set_decl_section_name (thunk_fndecl, DECL_SECTION_NAME (function));\n+\t  set_decl_section_name (thunk_fndecl, DECL_SECTION_NAME (fn));\n+\t  symtab_get_node (thunk_fndecl)->implicit_section\n+\t    = symtab_get_node (fn)->implicit_section;\n \t}\n     }\n "}, {"sha": "c16e163826ecce548c32bdccd1d9ac3c31e920d7", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -191,7 +191,7 @@ cdtor_comdat_group (tree complete, tree base)\n \tdiff_seen = true;\n       }\n   grp_name[idx] = '\\0';\n-  gcc_assert (diff_seen);\n+  gcc_assert (diff_seen || symtab_get_node (complete)->alias);\n   return get_identifier (grp_name);\n }\n \n@@ -553,6 +553,8 @@ maybe_clone_body (tree fn)\n \t\t *[CD][12]*.  */\n \t      comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n \t      cgraph_get_create_node (fns[0])->set_comdat_group (comdat_group);\n+\t      if (symtab_get_node (clone)->same_comdat_group)\n+\t\tsymtab_remove_from_same_comdat_group (symtab_get_node (clone));\n \t      symtab_add_to_same_comdat_group (symtab_get_node (clone),\n \t\t\t\t\t       symtab_get_node (fns[0]));\n \t    }"}, {"sha": "15a8a1ce0332b1bd8fe62afadc50c401912c4555", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1249,7 +1249,7 @@ vtable_find_or_create_map_decl (tree base_type)\n \n       set_decl_section_name (var_decl, build_string (strlen (\".vtable_map_vars\"),\n                                                      \".vtable_map_vars\"));\n-      DECL_HAS_IMPLICIT_SECTION_NAME_P (var_decl) = true;\n+      symtab_get_node (var_decl)->implicit_section = true;\n       DECL_INITIAL (var_decl) = initial_value;\n \n       comdat_linkage (var_decl);"}, {"sha": "16d13409cde4f7b28f336e996dde443cd3d2a3d4", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1,3 +1,8 @@\n+2014-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* go/go-gcc.cc (Gcc_backend::global_variable_set_init): Use\n+\tsymtab_get_node(var_decl)->implicit_section.\n+\n 2014-06-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* go-gcc.cc (global_variable_set_init): Use"}, {"sha": "0c9cb70a655d7e62f558410db47456328fd3c6d6", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -2374,7 +2374,8 @@ Gcc_backend::global_variable_set_init(Bvariable* var, Bexpression* expr)\n \n   // If this variable goes in a unique section, it may need to go into\n   // a different one now that DECL_INITIAL is set.\n-  if (DECL_HAS_IMPLICIT_SECTION_NAME_P (var_decl))\n+  if (symtab_get_node(var_decl)\n+      && symtab_get_node(var_decl)->implicit_section)\n     {\n       set_decl_section_name (var_decl, NULL);\n       resolve_unique_section (var_decl,"}, {"sha": "2d63441622604ae99449dd67fda599adc03fee93", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -512,7 +512,8 @@ function_and_variable_visibility (bool whole_program)\n \t\t     next = next->same_comdat_group)\n \t\t{\n \t\t  next->set_comdat_group (NULL);\n-\t\t  next->set_section (NULL);\n+\t\t  if (!next->alias)\n+\t\t    next->set_section (NULL);\n \t\t  symtab_make_decl_local (next->decl);\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n@@ -527,7 +528,7 @@ function_and_variable_visibility (bool whole_program)\n \t    }\n \t  if (TREE_PUBLIC (node->decl))\n \t    node->set_comdat_group (NULL);\n-\t  if (DECL_COMDAT (node->decl))\n+\t  if (DECL_COMDAT (node->decl) && !node->alias)\n \t    node->set_section (NULL);\n \t  symtab_make_decl_local (node->decl);\n \t}\n@@ -646,7 +647,8 @@ function_and_variable_visibility (bool whole_program)\n \t\t     next = next->same_comdat_group)\n \t\t{\n \t\t  next->set_comdat_group (NULL);\n-\t\t  next->set_section (NULL);\n+\t\t  if (!next->alias)\n+\t\t    next->set_section (NULL);\n \t\t  symtab_make_decl_local (next->decl);\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n@@ -657,7 +659,7 @@ function_and_variable_visibility (bool whole_program)\n \t    }\n \t  if (TREE_PUBLIC (vnode->decl))\n \t    vnode->set_comdat_group (NULL);\n-\t  if (DECL_COMDAT (vnode->decl))\n+\t  if (DECL_COMDAT (vnode->decl) && !vnode->alias)\n \t    vnode->set_section (NULL);\n \t  symtab_make_decl_local (vnode->decl);\n \t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;"}, {"sha": "5128b4dbd2e5049b26559ace2fb6c03c175c6f68", "filename": "gcc/ipa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -281,9 +281,6 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n \n   timevar_push (TV_IPA_UNREACHABLE);\n-#ifdef ENABLE_CHECKING\n-  verify_symtab ();\n-#endif\n   if (optimize && flag_devirtualize)\n     build_type_inheritance_graph ();\n   if (file)"}, {"sha": "70e813dcbaabb713fe5b7b3b70b389c690d3efa3", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -501,10 +501,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  group = node->get_section ();\n-  if (group)\n-    section = TREE_STRING_POINTER (group);\n-  else\n+  section = node->get_section ();\n+  if (!section)\n     section = \"\";\n   lto_output_data_stream (ob->main_stream, section, strlen (section) + 1);\n \n@@ -521,6 +519,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->forced_by_abi, 1);\n   bp_pack_value (&bp, node->unique_name, 1);\n   bp_pack_value (&bp, node->body_removed, 1);\n+  bp_pack_value (&bp, node->implicit_section, 1);\n   bp_pack_value (&bp, node->address_taken, 1);\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n \t\t && symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION\n@@ -585,6 +584,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   bp_pack_value (&bp, node->forced_by_abi, 1);\n   bp_pack_value (&bp, node->unique_name, 1);\n   bp_pack_value (&bp, node->body_removed, 1);\n+  bp_pack_value (&bp, node->implicit_section, 1);\n   bp_pack_value (&bp, node->writeonly, 1);\n   bp_pack_value (&bp, node->definition, 1);\n   alias_p = node->alias && (!boundary_p || node->weakref);\n@@ -631,10 +631,8 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  group = node->get_section ();\n-  if (group)\n-    section = TREE_STRING_POINTER (group);\n-  else\n+  section = node->get_section ();\n+  if (!section)\n     section = \"\";\n   lto_output_data_stream (ob->main_stream, section, strlen (section) + 1);\n \n@@ -1054,6 +1052,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->forced_by_abi = bp_unpack_value (bp, 1);\n   node->unique_name = bp_unpack_value (bp, 1);\n   node->body_removed = bp_unpack_value (bp, 1);\n+  node->implicit_section = bp_unpack_value (bp, 1);\n   node->address_taken = bp_unpack_value (bp, 1);\n   node->used_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n@@ -1194,7 +1193,7 @@ input_node (struct lto_file_decl_data *file_data,\n   else\n     node->same_comdat_group = (symtab_node *) (intptr_t) LCC_NOT_FOUND;\n   if (section)\n-    node->set_section (section);\n+    node->set_section_for_node (section);\n \n   if (node->thunk.thunk_p)\n     {\n@@ -1251,6 +1250,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->forced_by_abi = bp_unpack_value (&bp, 1);\n   node->unique_name = bp_unpack_value (&bp, 1);\n   node->body_removed = bp_unpack_value (&bp, 1);\n+  node->implicit_section = bp_unpack_value (&bp, 1);\n   node->writeonly = bp_unpack_value (&bp, 1);\n   node->definition = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n@@ -1277,7 +1277,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n     node->same_comdat_group = (symtab_node *) (intptr_t) LCC_NOT_FOUND;\n   section = read_string_cst (ib);\n   if (section)\n-    node->set_section (section);\n+    node->set_section_for_node (section);\n   node->resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n \t\t\t\t\t        LDPR_NUM_KNOWN);\n   gcc_assert (flag_ltrans"}, {"sha": "ae48cdc0571c13ec45e4c50a0ad5cab87dfc6472", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1,3 +1,8 @@\n+2014-06-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (read_cgraph_and_symbols): Remove unreachable symbols.\n+\t(do_whole_program_analysis): Use verify_symtab.\n+\n 2014-06-07  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (mentions_vars_p_decl_with_vis, compare_tree_sccs_1,"}, {"sha": "c6c6c8251808fb2d52e3e0589eb46da940defd2b", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -3090,6 +3090,10 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       dump_symtab (cgraph_dump_file);\n     }\n   lto_symtab_merge_symbols ();\n+  /* Removal of unreacable symbols is needed to make verify_symtab to pass;\n+     we are still having duplicated comdat groups containing local statics.\n+     We could also just remove them while merging.  */\n+  symtab_remove_unreachable_nodes (false, dump_file);\n   ggc_collect ();\n   cgraph_state = CGRAPH_STATE_IPA_SSA;\n \n@@ -3261,7 +3265,7 @@ do_whole_program_analysis (void)\n       dump_symtab (cgraph_dump_file);\n     }\n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  verify_symtab ();\n #endif\n   bitmap_obstack_release (NULL);\n "}, {"sha": "d7977f1e8d41c65c15fc1efb6ac3eeb4b64fe64e", "filename": "gcc/symtab.c", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -565,7 +565,9 @@ dump_symtab_base (FILE *f, symtab_node *node)\n     fprintf (f, \" one_only\");\n   if (node->get_section ())\n     fprintf (f, \" section:%s\",\n-\t     TREE_STRING_POINTER (node->get_section ()));\n+\t     node->get_section ());\n+  if (node->implicit_section)\n+    fprintf (f,\" (implicit_section)\");\n   if (DECL_VISIBILITY_SPECIFIED (node->decl))\n     fprintf (f, \" visibility_specified\");\n   if (DECL_VISIBILITY (node->decl))\n@@ -791,6 +793,7 @@ verify_symtab_base (symtab_node *node)\n \t{\n \t  struct ipa_ref_list *refs = &node->ref_list;\n \t  struct ipa_ref *ref;\n+\n \t  for (int i = 0; ipa_ref_list_referring_iterate (refs, i, ref); ++i)\n \t    {\n \t      if (!symtab_in_same_comdat_p (ref->referring, node))\n@@ -803,6 +806,38 @@ verify_symtab_base (symtab_node *node)\n \t    }\n \t}\n     }\n+  if (node->implicit_section && !node->get_section ())\n+    {\n+      error (\"implicit_section flag is set but section isn't\");\n+      error_found = true;\n+    }\n+  if (node->get_section () && node->get_comdat_group ()\n+      && !node->implicit_section)\n+    {\n+      error (\"Both section and comdat group is set\");\n+      error_found = true;\n+    }\n+  /* TODO: Add string table for sections, so we do not keep holding duplicated\n+     strings.  */\n+  if (node->alias && node->definition\n+      && node->get_section () != symtab_alias_target (node)->get_section ()\n+      && (!node->get_section()\n+\t  || !symtab_alias_target (node)->get_section ()\n+\t  || strcmp (node->get_section(),\n+\t\t     symtab_alias_target (node)->get_section ())))\n+    {\n+      error (\"Alias and target's section differs\");\n+      dump_symtab_node (stderr, symtab_alias_target (node));\n+      error_found = true;\n+    }\n+  if (node->alias && node->definition\n+      && node->get_comdat_group () != symtab_alias_target (node)->get_comdat_group ())\n+    {\n+      error (\"Alias and target's comdat groups differs\");\n+      dump_symtab_node (stderr, symtab_alias_target (node));\n+      error_found = true;\n+    }\n+\n   return error_found;\n }\n \n@@ -832,8 +867,30 @@ DEBUG_FUNCTION void\n verify_symtab (void)\n {\n   symtab_node *node;\n+  pointer_map<symtab_node *> comdat_head_map;\n+\n   FOR_EACH_SYMBOL (node)\n-   verify_symtab_node (node);\n+    {\n+      verify_symtab_node (node);\n+      if (node->get_comdat_group ())\n+\t{\n+\t  symtab_node **entry, *s;\n+\t  bool existed;\n+\n+\t  entry = comdat_head_map.insert (node->get_comdat_group (), &existed);\n+\t  if (!existed)\n+\t    *entry = node;\n+\t  else\n+\t    for (s = (*entry)->same_comdat_group; s != NULL && s != node; s = s->same_comdat_group)\n+\t      if (!s || s == *entry)\n+\t\t{\n+\t\t  error (\"Two symbols with same comdat_group are not linked by the same_comdat_group list.\");\n+\t\t  dump_symtab_node (stderr, *entry);\n+\t\t  dump_symtab_node (stderr, s);\n+\t\t  internal_error (\"verify_symtab failed\");\n+\t\t}\n+\t}\n+    }\n }\n \n /* Return true when RESOLUTION indicate that linker will use\n@@ -1024,6 +1081,33 @@ fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target)\n   node->externally_visible = target->externally_visible;\n }\n \n+/* Worker for set_section.  */\n+\n+static bool\n+set_section_1 (struct symtab_node *n, void *s)\n+{\n+  n->set_section_for_node ((tree)s);\n+  return false;\n+}\n+\n+/* Set section of symbol and its aliases.  */\n+\n+void\n+symtab_node::set_section (tree section)\n+{\n+  gcc_assert (!this->alias);\n+  symtab_for_node_and_aliases (this, set_section_1, section, true);\n+}\n+\n+/* Worker for symtab_resolve_alias.  */\n+\n+static bool\n+set_implicit_section (struct symtab_node *n, void *data ATTRIBUTE_UNUSED)\n+{\n+  n->implicit_section = true;\n+  return false;\n+}\n+\n /* Add reference recording that NODE is alias of TARGET.\n    The function can fail in the case of aliasing cycles; in this case\n    it returns false.  */\n@@ -1058,6 +1142,25 @@ symtab_resolve_alias (symtab_node *node, symtab_node *target)\n   node->analyzed = true;\n   ipa_record_reference (node, target, IPA_REF_ALIAS, NULL);\n \n+  /* Add alias into the comdat group of its target unless it is already there.  */\n+  if (node->same_comdat_group)\n+    symtab_remove_from_same_comdat_group (node);\n+  node->set_comdat_group (NULL);\n+  if (target->get_comdat_group ())\n+    symtab_add_to_same_comdat_group (node, target);\n+\n+  if ((node->get_section () != target->get_section ()\n+       || target->get_comdat_group ())\n+      && node->get_section () && !node->implicit_section)\n+    {\n+      error (\"section of alias %q+D must match section of its target\",\n+\t     node->decl);\n+    }\n+  symtab_for_node_and_aliases (node, set_section_1, target->get_section_name (), true);\n+  if (target->implicit_section)\n+    symtab_for_node_and_aliases (node,\n+\t\t\t\t set_implicit_section, NULL, true);\n+\n   /* Alias targets become redundant after alias is resolved into an reference.\n      We do not want to keep it around or we would have to mind updating them\n      when renaming symbols.  */"}, {"sha": "b35ec773e8164704d8cb70a58a3efbfb01662529", "filename": "gcc/tree-core.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -1452,8 +1452,6 @@ struct GTY(()) tree_decl_with_vis {\n  unsigned dllimport_flag : 1;\n  /* Don't belong to VAR_DECL exclusively.  */\n  unsigned weak_flag : 1;\n- /* When SECTION_NAME is implied by -ffunction-section.  */\n- unsigned implicit_section_name_p : 1;\n \n  unsigned seen_in_bind_expr : 1;\n  unsigned comdat_flag : 1;\n@@ -1472,7 +1470,7 @@ struct GTY(()) tree_decl_with_vis {\n  unsigned cxx_destructor : 1;\n  /* Belong to FUNCTION_DECL exclusively.  */\n  unsigned final : 1;\n- /* 11 unused bits. */\n+ /* 12 unused bits. */\n };\n \n struct GTY(()) tree_var_decl {"}, {"sha": "1a30ea1cb0a851eb0857f9d27680ad9db5be6fea", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -5215,7 +5215,7 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n      software projects.  */\n   if (TREE_STATIC (decl) \n       && DECL_SECTION_NAME (decl) != NULL_TREE\n-      && !DECL_HAS_IMPLICIT_SECTION_NAME_P (decl))\n+      && !symtab_get_node (decl)->implicit_section)\n     return false;\n \n   if (TREE_STATIC (decl))"}, {"sha": "040433e02d57728e9d5f7f9fd79493999fcd04b7", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -634,7 +634,7 @@ decl_section_name (const_tree node)\n   struct symtab_node *snode = symtab_get_node (node);\n   if (!snode)\n     return NULL;\n-  return snode->get_section ();\n+  return snode->get_section_name ();\n }\n \n /* Set section section name of NODE to VALUE (that is expected to"}, {"sha": "63b714cd859a6e8c59cd9c29295294a8ca8005e2", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -2399,11 +2399,6 @@ extern void decl_value_expr_insert (tree, tree);\n #define DECL_HAS_INIT_PRIORITY_P(NODE) \\\n   (VAR_DECL_CHECK (NODE)->decl_with_vis.init_priority_p)\n \n-/* Specify whether the section name was set by user or by\n-   compiler via -ffunction-sections.  */\n-#define DECL_HAS_IMPLICIT_SECTION_NAME_P(NODE) \\\n-  (DECL_WITH_VIS_CHECK (NODE)->decl_with_vis.implicit_section_name_p)\n-\n extern tree decl_debug_expr_lookup (tree);\n extern void decl_debug_expr_insert (tree, tree);\n "}, {"sha": "d56e67a2d4494d387311094f6c63b539ef173a28", "filename": "gcc/varasm.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -418,6 +418,15 @@ get_named_section (tree decl, const char *name, int reloc)\n   return get_section (name, flags, decl);\n }\n \n+/* Worker for resolve_unique_section.  */\n+\n+static bool\n+set_implicit_section (struct symtab_node *n, void *data ATTRIBUTE_UNUSED)\n+{\n+  n->implicit_section = true;\n+  return false;\n+}\n+\n /* If required, set DECL_SECTION_NAME to a unique name.  */\n \n void\n@@ -430,7 +439,9 @@ resolve_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n \t  || DECL_COMDAT_GROUP (decl)))\n     {\n       targetm.asm_out.unique_section (decl, reloc);\n-      DECL_HAS_IMPLICIT_SECTION_NAME_P (decl) = true;\n+      if (DECL_SECTION_NAME (decl))\n+        symtab_for_node_and_aliases (symtab_get_node (decl),\n+\t\t\t\t     set_implicit_section, NULL, true);\n     }\n }\n \n@@ -510,7 +521,7 @@ get_named_text_section (tree decl,\n \t  buffer = ACONCAT ((stripped_name, named_section_suffix, NULL));\n \t  return get_named_section (decl, buffer, 0);\n \t}\n-      else if (DECL_HAS_IMPLICIT_SECTION_NAME_P (decl))\n+      else if (symtab_get_node (decl)->implicit_section)\n \t{\n \t  const char *name;\n \n@@ -539,8 +550,7 @@ default_function_section (tree decl, enum node_frequency freq,\n   /* Old GNU linkers have buggy --gc-section support, which sometimes\n      results in .gcc_except_table* sections being garbage collected.  */\n   if (decl\n-      && DECL_SECTION_NAME (decl)\n-      && DECL_HAS_IMPLICIT_SECTION_NAME_P (decl))\n+      && symtab_get_node (decl)->implicit_section)\n     return NULL;\n #endif\n \n@@ -6764,7 +6774,7 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n    definition from different object file) and when resolution info is available\n    we simply use the knowledge passed to us by linker plugin.  */\n bool\n-decl_binds_to_current_def_p (tree decl)\n+decl_binds_to_current_def_p (const_tree decl)\n {\n   gcc_assert (DECL_P (decl));\n   if (!targetm.binds_local_p (decl))"}, {"sha": "aa9d47a5a65f715cb664fc5ef8801a293047e451", "filename": "gcc/varasm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fvarasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e257a17cb9cc4dc76a79680616420e75ba030b5f/gcc%2Fvarasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.h?ref=e257a17cb9cc4dc76a79680616420e75ba030b5f", "patch": "@@ -32,7 +32,7 @@ extern void notice_global_symbol (tree);\n extern void set_user_assembler_name (tree, const char *);\n extern void process_pending_assemble_externals (void);\n extern bool decl_replaceable_p (tree);\n-extern bool decl_binds_to_current_def_p (tree);\n+extern bool decl_binds_to_current_def_p (const_tree);\n extern enum tls_model decl_default_tls_model (const_tree);\n \n /* Declare DECL to be a weak symbol.  */"}]}