{"sha": "f576dfc407d1c68d514c2be8c8505c33b00ccee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3NmRmYzQwN2QxYzY4ZDUxNGMyYmU4Yzg1MDVjMzNiMDBjY2VlNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-01-13T09:14:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-01-13T09:14:47Z"}, "message": "re PR c++/8748 (ICE in cp_expr_size at cp/cp-lang.c: 307)\n\n        PR c++/8748\n        * class.c (build_base_path): Take the address before calling save_expr.\n\n        * call.c (build_user_type_conversion_1): Do set ICS_BAD_FLAG if\n        all the ambiguous conversions are bad.\n\n        * class.c (maybe_warn_about_overly_private_class): Don't stop\n        searching when we find a nonprivate method.\n\n        * typeck.c (build_class_member_access_expr): Use unary_complex_lvalue.\n\nFrom-SVN: r61246", "tree": {"sha": "1ac795ce86106645cb0dc296028567adf1a9970e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac795ce86106645cb0dc296028567adf1a9970e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f576dfc407d1c68d514c2be8c8505c33b00ccee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f576dfc407d1c68d514c2be8c8505c33b00ccee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f576dfc407d1c68d514c2be8c8505c33b00ccee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f576dfc407d1c68d514c2be8c8505c33b00ccee6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e308bc5ad33c3ee703fbc4b1860ecd1caa5fb353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e308bc5ad33c3ee703fbc4b1860ecd1caa5fb353", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e308bc5ad33c3ee703fbc4b1860ecd1caa5fb353"}], "stats": {"total": 69, "additions": 34, "deletions": 35}, "files": [{"sha": "b209ca4c0ea9e85ffcf6f906b775c860e39edf9f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f576dfc407d1c68d514c2be8c8505c33b00ccee6", "patch": "@@ -1,3 +1,16 @@\n+2003-01-13  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/8748\n+\t* class.c (build_base_path): Take the address before calling save_expr.\n+\n+\t* call.c (build_user_type_conversion_1): Do set ICS_BAD_FLAG if\n+\tall the ambiguous conversions are bad.\n+\n+\t* class.c (maybe_warn_about_overly_private_class): Don't stop\n+\tsearching when we find a nonprivate method.\n+\n+\t* typeck.c (build_class_member_access_expr): Use unary_complex_lvalue.\n+\n 2003-01-12  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (get_arglist_len_in_bytes): Remove."}, {"sha": "5340356d4d552770b4500747c04323041e59f035", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f576dfc407d1c68d514c2be8c8505c33b00ccee6", "patch": "@@ -2536,8 +2536,11 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       cand = candidates;\t/* any one will do */\n       cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n       ICS_USER_FLAG (cand->second_conv) = 1;\n-      /* Don't set ICS_BAD_FLAG; an ambiguous conversion is no worse than\n-\t another user-defined conversion.  */\n+      if (!any_strictly_viable (candidates))\n+\tICS_BAD_FLAG (cand->second_conv) = 1;\n+      /* If there are viable candidates, don't set ICS_BAD_FLAG; an\n+\t ambiguous conversion is no worse than another user-defined\n+\t conversion.  */\n \n       return cand;\n     }"}, {"sha": "6d492f962f881532d6629623b718569d169fa6e7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f576dfc407d1c68d514c2be8c8505c33b00ccee6", "patch": "@@ -291,13 +291,15 @@ build_base_path (code, expr, binfo, nonnull)\n       return error_mark_node;\n     }\n \n+  if (!want_pointer)\n+    /* This must happen before the call to save_expr.  */\n+    expr = build_unary_op (ADDR_EXPR, expr, 0);\n+\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n   if (fixed_type_p <= 0 && TREE_SIDE_EFFECTS (expr))\n     expr = save_expr (expr);\n \n-  if (!want_pointer)\n-    expr = build_unary_op (ADDR_EXPR, expr, 0);\n-  else if (!nonnull)\n+  if (want_pointer && !nonnull)\n     null_test = build (EQ_EXPR, boolean_type_node, expr, integer_zero_node);\n   \n   offset = BINFO_OFFSET (binfo);\n@@ -1833,7 +1835,7 @@ maybe_warn_about_overly_private_class (t)\n \t      return;\n \t\t\n \t    has_nonprivate_method = 1;\n-\t    break;\n+\t    /* Keep searching for a static member function.  */\n \t  }\n \telse if (!DECL_CONSTRUCTOR_P (fn) && !DECL_DESTRUCTOR_P (fn))\n \t  has_member_fn = 1;\n@@ -1980,7 +1982,7 @@ resort_field_decl_cmp (x_p, y_p)\n void \n resort_sorted_fields (obj, orig_obj, new_value, cookie)\n      void *obj;\n-     void *orig_obj;\n+     void *orig_obj ATTRIBUTE_UNUSED;\n      gt_pointer_operator new_value;\n      void *cookie;\n {\n@@ -2042,7 +2044,7 @@ resort_method_name_cmp (m1_p, m2_p)\n void \n resort_type_method_vec (obj, orig_obj, new_value, cookie)\n      void *obj;\n-     void *orig_obj;\n+     void *orig_obj ATTRIBUTE_UNUSED;\n      gt_pointer_operator new_value;\n      void *cookie;\n {"}, {"sha": "2c896d4ef20ee8846f194b84b66d1964ac042163", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f576dfc407d1c68d514c2be8c8505c33b00ccee6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f576dfc407d1c68d514c2be8c8505c33b00ccee6", "patch": "@@ -1904,33 +1904,14 @@ build_class_member_access_expr (tree object, tree member,\n       return error_mark_node;\n     }\n \n-  /* Transform `(a, b).x' into `(*(a, &b)).x' and `(a ? b : c).x' into\n-     `(*(a ?  &b : &c)).x'.  Unfortunately, expand_expr cannot handle a\n-     COMPONENT_REF where the first operand is a conditional or comma\n-     expression with class type.  */\n-  if (TREE_CODE (object) == COMPOUND_EXPR)\n-    {\n-      object = build (COMPOUND_EXPR, \n-\t\t      build_pointer_type (object_type),\n-\t\t      TREE_OPERAND (object, 0),\n-\t\t      build_unary_op (ADDR_EXPR, \n-\t\t\t\t      TREE_OPERAND (object, 1),\n-\t\t\t\t      /*noconvert=*/1));\n-      object = build_indirect_ref (object, NULL);\n-    }\n-  else if (TREE_CODE (object) == COND_EXPR)\n-    {\n-      object = build (COND_EXPR, \n-\t\t      build_pointer_type (object_type),\n-\t\t      TREE_OPERAND (object, 0),\n-\t\t      build_unary_op (ADDR_EXPR, \n-\t\t\t\t      TREE_OPERAND (object, 1),\n-\t\t\t\t      /*noconvert=*/1),\n-\t\t      build_unary_op (ADDR_EXPR, \n-\t\t\t\t      TREE_OPERAND (object, 2),\n-\t\t\t\t      /*noconvert=*/1));\n-      object = build_indirect_ref (object, NULL);\n-    }\n+  /* Transform `(a, b).x' into `(*(a, &b)).x', `(a ? b : c).x' into\n+     `(*(a ?  &b : &c)).x', and so on.  A COND_EXPR is only an lvalue\n+     in the frontend; only _DECLs and _REFs are lvalues in the backend.  */\n+  {\n+    tree temp = unary_complex_lvalue (ADDR_EXPR, object);\n+    if (temp)\n+      object = build_indirect_ref (temp, NULL);\n+  }\n \n   /* In [expr.ref], there is an explicit list of the valid choices for\n      MEMBER.  We check for each of those cases here.  */"}]}