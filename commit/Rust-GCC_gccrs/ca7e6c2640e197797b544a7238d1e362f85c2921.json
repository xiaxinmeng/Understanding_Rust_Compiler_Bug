{"sha": "ca7e6c2640e197797b544a7238d1e362f85c2921", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E3ZTZjMjY0MGUxOTc3OTdiNTQ0YTcyMzhkMWUzNjJmODVjMjkyMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:29:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:29:13Z"}, "message": "[multiple changes]\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* inline.adb: Minor reformatting.\n\n2015-10-26  Yannick Moy  <moy@adacore.com>\n\n\t* get_spark_xrefs.adb (get_SPARK_Xrefs): Remove obsolete\n\tassertion.\n\t* lib-xref-spark_specific.adb (Traverse_Declaration_Or_Statement):\n\tNew procedure to factor duplicated code and add\n\ttreatment of protected entries.\n\t(Add_SPARK_Scope, Traverse_Declarations_Or_Statements): Call the new\n\tprocedure Traverse_Declaration_Or_Statement. Use same character used in\n\tnormal xrefs for SPARK xrefs, for a given entity used as scope.\n\t* spark_xrefs.ads Document character used for entries.\n\t* sem_prag.adb (Check_Loop_Pragma_Placement): Account for possible\n\tintroduction of declarations and statements by the expansion, between\n\ttwo otherwise consecutive loop pragmas.\n\t* sem_util.ads, sem_util.adb (Is_Suspension_Object): Lifted from nested\n\tfunction.\n\t(Is_Descendant_Of_Suspension_Object): nested function lifted.\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Eval_Attribute): Attribute 'Enum_Rep can be folded\n\twhen its prefix denotes a constant, an enumeration literal or\n\tan enumeration type. Use the expression of the attribute in the\n\tenumeration type form, otherwise use the prefix to fold.\n\nFrom-SVN: r229334", "tree": {"sha": "fd072a2f475cd63b318fce31b41facdc1f06f19f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd072a2f475cd63b318fce31b41facdc1f06f19f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca7e6c2640e197797b544a7238d1e362f85c2921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7e6c2640e197797b544a7238d1e362f85c2921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7e6c2640e197797b544a7238d1e362f85c2921", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7e6c2640e197797b544a7238d1e362f85c2921/comments", "author": null, "committer": null, "parents": [{"sha": "f99ff327e1901a374b4fb79b13be067b49c2c2ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99ff327e1901a374b4fb79b13be067b49c2c2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f99ff327e1901a374b4fb79b13be067b49c2c2ed"}], "stats": {"total": 616, "additions": 333, "deletions": 283}, "files": [{"sha": "81c2c0b407b1144924d3e938a3ed23cdd4078334", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -1,3 +1,32 @@\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* inline.adb: Minor reformatting.\n+\n+2015-10-26  Yannick Moy  <moy@adacore.com>\n+\n+\t* get_spark_xrefs.adb (get_SPARK_Xrefs): Remove obsolete\n+\tassertion.\n+\t* lib-xref-spark_specific.adb (Traverse_Declaration_Or_Statement):\n+\tNew procedure to factor duplicated code and add\n+\ttreatment of protected entries.\n+\t(Add_SPARK_Scope, Traverse_Declarations_Or_Statements): Call the new\n+\tprocedure Traverse_Declaration_Or_Statement. Use same character used in\n+\tnormal xrefs for SPARK xrefs, for a given entity used as scope.\n+\t* spark_xrefs.ads Document character used for entries.\n+\t* sem_prag.adb (Check_Loop_Pragma_Placement): Account for possible\n+\tintroduction of declarations and statements by the expansion, between\n+\ttwo otherwise consecutive loop pragmas.\n+\t* sem_util.ads, sem_util.adb (Is_Suspension_Object): Lifted from nested\n+\tfunction.\n+\t(Is_Descendant_Of_Suspension_Object): nested function lifted.\n+\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Eval_Attribute): Attribute 'Enum_Rep can be folded\n+\twhen its prefix denotes a constant, an enumeration literal or\n+\tan enumeration type. Use the expression of the attribute in the\n+\tenumeration type form, otherwise use the prefix to fold.\n+\n 2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* aspects.adb Add an entry for entry bodies in table"}, {"sha": "e0b58ce35dd633893d99278e51e4edbd4284b8a9", "filename": "gcc/ada/get_spark_xrefs.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fget_spark_xrefs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fget_spark_xrefs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_spark_xrefs.adb?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -293,9 +293,6 @@ begin\n                Col   := Get_Nat;\n \n                pragma Assert (Scope = Cur_Scope);\n-               pragma Assert         (Typ = 'K'\n-                              or else Typ = 'V'\n-                              or else Typ = 'U');\n \n                --  Scan out scope entity name\n "}, {"sha": "99b536c72d3c249af5ea40113445e48ef08e2a89", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -3462,14 +3462,12 @@ package body Inline is\n \n          if Nkind (D) = N_Package_Declaration then\n             Cannot_Inline\n-              (\"cannot inline & (nested package declaration)?\",\n-               D, Subp);\n+              (\"cannot inline & (nested package declaration)?\", D, Subp);\n             return True;\n \n          elsif Nkind (D) = N_Package_Instantiation then\n             Cannot_Inline\n-              (\"cannot inline & (nested package instantiation)?\",\n-               D, Subp);\n+              (\"cannot inline & (nested package instantiation)?\", D, Subp);\n             return True;\n          end if;\n \n@@ -3482,8 +3480,7 @@ package body Inline is\n            or else Nkind (D) = N_Single_Task_Declaration\n          then\n             Cannot_Inline\n-              (\"cannot inline & (nested task type declaration)?\",\n-               D, Subp);\n+              (\"cannot inline & (nested task type declaration)?\", D, Subp);\n             return True;\n \n          elsif Nkind (D) = N_Protected_Type_Declaration\n@@ -3496,22 +3493,19 @@ package body Inline is\n \n          elsif Nkind (D) = N_Subprogram_Body then\n             Cannot_Inline\n-              (\"cannot inline & (nested subprogram)?\",\n-               D, Subp);\n+              (\"cannot inline & (nested subprogram)?\", D, Subp);\n             return True;\n \n          elsif Nkind (D) = N_Function_Instantiation\n            and then not Is_Unchecked_Conversion (D)\n          then\n             Cannot_Inline\n-              (\"cannot inline & (nested function instantiation)?\",\n-               D, Subp);\n+              (\"cannot inline & (nested function instantiation)?\", D, Subp);\n             return True;\n \n          elsif Nkind (D) = N_Procedure_Instantiation then\n             Cannot_Inline\n-              (\"cannot inline & (nested procedure instantiation)?\",\n-               D, Subp);\n+              (\"cannot inline & (nested procedure instantiation)?\", D, Subp);\n             return True;\n \n          --  Subtype declarations with predicates will generate predicate\n@@ -3535,9 +3529,8 @@ package body Inline is\n                     or else A_Id = Aspect_Dynamic_Predicate\n                   then\n                      Cannot_Inline\n-                       (\"cannot inline & \"\n-                        & \"(subtype declaration with predicate)?\",\n-                        D, Subp);\n+                       (\"cannot inline & (subtype declaration with \"\n+                        & \"predicate)?\", D, Subp);\n                      return True;\n                   end if;\n "}, {"sha": "7ed6f7b91015f216022a2f54ee96781495c83012", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 188, "deletions": 217, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -104,6 +104,10 @@ package body SPARK_Specific is\n    function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range;\n    --  Hash function for hash table\n \n+   procedure Traverse_Declaration_Or_Statement\n+     (N            : Node_Id;\n+      Process      : Node_Processing;\n+      Inside_Stubs : Boolean);\n    procedure Traverse_Declarations_Or_Statements\n      (L            : List_Id;\n       Process      : Node_Processing;\n@@ -243,6 +247,11 @@ package body SPARK_Specific is\n    procedure Add_SPARK_Scope (N : Node_Id) is\n       E   : constant Entity_Id  := Defining_Entity (N);\n       Loc : constant Source_Ptr := Sloc (E);\n+\n+      --  The character describing the kind of scope is chosen to be the same\n+      --  as the one describing the corresponding entity in cross references,\n+      --  see Xref_Entity_Letters in lib-xrefs.ads\n+\n       Typ : Character;\n \n    begin\n@@ -253,39 +262,25 @@ package body SPARK_Specific is\n       end if;\n \n       case Ekind (E) is\n-         when E_Function | E_Generic_Function =>\n-            Typ := 'V';\n-\n-         when E_Procedure | E_Generic_Procedure =>\n-            Typ := 'U';\n-\n-         when E_Subprogram_Body =>\n-            declare\n-               Spec : Node_Id;\n-\n-            begin\n-               Spec := Parent (E);\n-\n-               if Nkind (Spec) = N_Defining_Program_Unit_Name then\n-                  Spec := Parent (Spec);\n-               end if;\n-\n-               if Nkind (Spec) = N_Function_Specification then\n-                  Typ := 'V';\n-               else\n-                  pragma Assert\n-                    (Nkind (Spec) = N_Procedure_Specification);\n-                  Typ := 'U';\n-               end if;\n-            end;\n-\n-         when E_Package | E_Package_Body | E_Generic_Package =>\n-            Typ := 'K';\n+         when E_Entry\n+            | E_Function\n+            | E_Generic_Function\n+            | E_Generic_Package\n+            | E_Generic_Procedure\n+            | E_Package\n+            | E_Procedure\n+         =>\n+            Typ := Xref_Entity_Letters (Ekind (E));\n+\n+         when E_Package_Body\n+            | E_Subprogram_Body\n+         =>\n+            Typ := Xref_Entity_Letters (Ekind (Unique_Entity (E)));\n \n          when E_Void =>\n-            --  Compilation of prj-attr.adb with -gnatn creates a node with\n-            --  entity E_Void for the package defined at a-charac.ads16:13\n \n+            --  Compilation of prj-attr.adb with -gnatn creates a node with\n+            --  entity E_Void for the package defined at a-charac.ads16:13.\n             --  ??? TBD\n \n             return;\n@@ -968,11 +963,14 @@ package body SPARK_Specific is\n \n    procedure Detect_And_Add_SPARK_Scope (N : Node_Id) is\n    begin\n-      if Nkind_In (N, N_Subprogram_Declaration,\n+      if Nkind_In (N, N_Entry_Body,\n+                      N_Entry_Declaration,\n+                      N_Package_Body,\n+                      N_Package_Body_Stub,\n+                      N_Package_Declaration,\n                       N_Subprogram_Body,\n                       N_Subprogram_Body_Stub,\n-                      N_Package_Declaration,\n-                      N_Package_Body)\n+                      N_Subprogram_Declaration)\n       then\n          Add_SPARK_Scope (N);\n       end if;\n@@ -1193,230 +1191,203 @@ package body SPARK_Specific is\n \n       --  Traverse the unit\n \n-      if Nkind (Lu) = N_Subprogram_Body then\n-         Traverse_Subprogram_Body (Lu, Process, Inside_Stubs);\n-\n-      elsif Nkind (Lu) = N_Subprogram_Declaration then\n-         null;\n-\n-      elsif Nkind (Lu) = N_Package_Declaration then\n-         Traverse_Package_Declaration (Lu, Process, Inside_Stubs);\n-\n-      elsif Nkind (Lu) = N_Package_Body then\n-         Traverse_Package_Body (Lu, Process, Inside_Stubs);\n-\n-      elsif Nkind (Lu) = N_Protected_Body then\n-         Traverse_Protected_Body (Lu, Process, Inside_Stubs);\n-\n-      --  All other cases of compilation units (e.g. renamings), are not\n-      --  declarations, or else generic declarations which are ignored.\n-\n-      else\n-         null;\n-      end if;\n+      Traverse_Declaration_Or_Statement (Lu, Process, Inside_Stubs);\n    end Traverse_Compilation_Unit;\n \n-   -----------------------------------------\n-   -- Traverse_Declarations_Or_Statements --\n-   -----------------------------------------\n+   ---------------------------------------\n+   -- Traverse_Declaration_Or_Statement --\n+   ---------------------------------------\n \n-   procedure Traverse_Declarations_Or_Statements\n-     (L            : List_Id;\n+   procedure Traverse_Declaration_Or_Statement\n+     (N            : Node_Id;\n       Process      : Node_Processing;\n       Inside_Stubs : Boolean)\n    is\n-      N : Node_Id;\n-\n    begin\n-      --  Loop through statements or declarations\n-\n-      N := First (L);\n-      while Present (N) loop\n-         --  Call Process on all declarations\n-\n-         if Nkind (N) in N_Declaration\n-              or else\n-            Nkind (N) in N_Later_Decl_Item\n-         then\n-            Process (N);\n-         end if;\n-\n-         case Nkind (N) is\n-\n-            --  Package declaration\n-\n-            when N_Package_Declaration =>\n-               Traverse_Package_Declaration (N, Process, Inside_Stubs);\n-\n-            --  Package body\n-\n-            when N_Package_Body =>\n-               if Ekind (Defining_Entity (N)) /= E_Generic_Package then\n-                  Traverse_Package_Body (N, Process, Inside_Stubs);\n-               end if;\n+      case Nkind (N) is\n+         when N_Package_Declaration =>\n+            Traverse_Package_Declaration (N, Process, Inside_Stubs);\n \n-            when N_Package_Body_Stub =>\n-               if Present (Library_Unit (N)) then\n-                  declare\n-                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-                  begin\n-                     if Inside_Stubs\n-                       and then\n-                         Ekind (Defining_Entity (Body_N)) /= E_Generic_Package\n-                     then\n-                        Traverse_Package_Body (Body_N, Process, Inside_Stubs);\n-                     end if;\n-                  end;\n-               end if;\n-\n-            --  Subprogram declaration\n+         when N_Package_Body =>\n+            if Ekind (Defining_Entity (N)) /= E_Generic_Package then\n+               Traverse_Package_Body (N, Process, Inside_Stubs);\n+            end if;\n \n-            when N_Subprogram_Declaration =>\n-               null;\n+         when N_Package_Body_Stub =>\n+            if Present (Library_Unit (N)) then\n+               declare\n+                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+               begin\n+                  if Inside_Stubs\n+                    and then\n+                      Ekind (Defining_Entity (Body_N)) /= E_Generic_Package\n+                  then\n+                     Traverse_Package_Body (Body_N, Process, Inside_Stubs);\n+                  end if;\n+               end;\n+            end if;\n \n-            --  Subprogram body\n+         when N_Subprogram_Declaration =>\n+            null;\n \n-            when N_Subprogram_Body =>\n-               if not Is_Generic_Subprogram (Defining_Entity (N)) then\n-                  Traverse_Subprogram_Body (N, Process, Inside_Stubs);\n-               end if;\n+         when N_Entry_Body\n+            | N_Subprogram_Body\n+         =>\n+            if not Is_Generic_Subprogram (Defining_Entity (N)) then\n+               Traverse_Subprogram_Body (N, Process, Inside_Stubs);\n+            end if;\n \n-            when N_Subprogram_Body_Stub =>\n-               if Present (Library_Unit (N)) then\n-                  declare\n-                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-                  begin\n-                     if Inside_Stubs\n-                       and then\n-                         not Is_Generic_Subprogram (Defining_Entity (Body_N))\n-                     then\n-                        Traverse_Subprogram_Body\n-                          (Body_N, Process, Inside_Stubs);\n-                     end if;\n-                  end;\n-               end if;\n+         when N_Subprogram_Body_Stub =>\n+            if Present (Library_Unit (N)) then\n+               declare\n+                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+               begin\n+                  if Inside_Stubs\n+                    and then\n+                      not Is_Generic_Subprogram (Defining_Entity (Body_N))\n+                  then\n+                     Traverse_Subprogram_Body (Body_N, Process, Inside_Stubs);\n+                  end if;\n+               end;\n+            end if;\n \n-            --  Protected unit\n+         when N_Protected_Definition =>\n+            Traverse_Declarations_Or_Statements\n+              (Visible_Declarations (N), Process, Inside_Stubs);\n+            Traverse_Declarations_Or_Statements\n+              (Private_Declarations (N), Process, Inside_Stubs);\n \n-            when N_Protected_Definition =>\n-               Traverse_Declarations_Or_Statements\n-                 (Visible_Declarations (N), Process, Inside_Stubs);\n-               Traverse_Declarations_Or_Statements\n-                 (Private_Declarations (N), Process, Inside_Stubs);\n+         when N_Protected_Body =>\n+            Traverse_Protected_Body (N, Process, Inside_Stubs);\n \n-            when N_Protected_Body =>\n-               Traverse_Protected_Body (N, Process, Inside_Stubs);\n+         when N_Protected_Body_Stub =>\n+            if Present (Library_Unit (N)) then\n+               declare\n+                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+               begin\n+                  if Inside_Stubs then\n+                     Traverse_Declarations_Or_Statements\n+                       (Declarations (Body_N), Process, Inside_Stubs);\n+                  end if;\n+               end;\n+            end if;\n \n-            when N_Protected_Body_Stub =>\n-               if Present (Library_Unit (N)) then\n-                  declare\n-                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-                  begin\n-                     if Inside_Stubs then\n-                        Traverse_Declarations_Or_Statements\n-                          (Declarations (Body_N), Process, Inside_Stubs);\n-                     end if;\n-                  end;\n-               end if;\n+         when N_Task_Definition =>\n+            Traverse_Declarations_Or_Statements\n+              (Visible_Declarations (N), Process, Inside_Stubs);\n+            Traverse_Declarations_Or_Statements\n+              (Private_Declarations (N), Process, Inside_Stubs);\n \n-            --  Task unit\n+         when N_Task_Body =>\n+            Traverse_Declarations_Or_Statements\n+              (Declarations (N), Process, Inside_Stubs);\n+            Traverse_Handled_Statement_Sequence\n+              (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n \n-            when N_Task_Definition =>\n-               Traverse_Declarations_Or_Statements\n-                 (Visible_Declarations (N), Process, Inside_Stubs);\n-               Traverse_Declarations_Or_Statements\n-                 (Private_Declarations (N), Process, Inside_Stubs);\n+         when N_Task_Body_Stub =>\n+            if Present (Library_Unit (N)) then\n+               declare\n+                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+               begin\n+                  if Inside_Stubs then\n+                     Traverse_Declarations_Or_Statements\n+                       (Declarations (Body_N), Process, Inside_Stubs);\n+                     Traverse_Handled_Statement_Sequence\n+                       (Handled_Statement_Sequence (Body_N), Process,\n+                        Inside_Stubs);\n+                  end if;\n+               end;\n+            end if;\n \n-            when N_Task_Body =>\n-               Traverse_Declarations_Or_Statements\n-                 (Declarations (N), Process, Inside_Stubs);\n-               Traverse_Handled_Statement_Sequence\n-                 (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n+         when N_Block_Statement =>\n+            Traverse_Declarations_Or_Statements\n+              (Declarations (N), Process, Inside_Stubs);\n+            Traverse_Handled_Statement_Sequence\n+              (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n \n-            when N_Task_Body_Stub =>\n-               if Present (Library_Unit (N)) then\n-                  declare\n-                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-                  begin\n-                     if Inside_Stubs then\n-                        Traverse_Declarations_Or_Statements\n-                          (Declarations (Body_N), Process, Inside_Stubs);\n-                        Traverse_Handled_Statement_Sequence\n-                          (Handled_Statement_Sequence (Body_N), Process,\n-                           Inside_Stubs);\n-                     end if;\n-                  end;\n-               end if;\n+         when N_If_Statement =>\n \n-            --  Block statement\n+            --  Traverse the statements in the THEN part\n \n-            when N_Block_Statement =>\n-               Traverse_Declarations_Or_Statements\n-                 (Declarations (N), Process, Inside_Stubs);\n-               Traverse_Handled_Statement_Sequence\n-                 (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n+            Traverse_Declarations_Or_Statements\n+              (Then_Statements (N), Process, Inside_Stubs);\n \n-            when N_If_Statement =>\n+            --  Loop through ELSIF parts if present\n \n-               --  Traverse the statements in the THEN part\n+            if Present (Elsif_Parts (N)) then\n+               declare\n+                  Elif : Node_Id := First (Elsif_Parts (N));\n \n-               Traverse_Declarations_Or_Statements\n-                 (Then_Statements (N), Process, Inside_Stubs);\n+               begin\n+                  while Present (Elif) loop\n+                     Traverse_Declarations_Or_Statements\n+                       (Then_Statements (Elif), Process, Inside_Stubs);\n+                     Next (Elif);\n+                  end loop;\n+               end;\n+            end if;\n \n-               --  Loop through ELSIF parts if present\n+            --  Finally traverse the ELSE statements if present\n \n-               if Present (Elsif_Parts (N)) then\n-                  declare\n-                     Elif : Node_Id := First (Elsif_Parts (N));\n+            Traverse_Declarations_Or_Statements\n+              (Else_Statements (N), Process, Inside_Stubs);\n \n-                  begin\n-                     while Present (Elif) loop\n-                        Traverse_Declarations_Or_Statements\n-                          (Then_Statements (Elif), Process, Inside_Stubs);\n-                        Next (Elif);\n-                     end loop;\n-                  end;\n-               end if;\n+         when N_Case_Statement =>\n \n-               --  Finally traverse the ELSE statements if present\n+            --  Process case branches\n \n-               Traverse_Declarations_Or_Statements\n-                 (Else_Statements (N), Process, Inside_Stubs);\n+            declare\n+               Alt : Node_Id;\n+            begin\n+               Alt := First (Alternatives (N));\n+               while Present (Alt) loop\n+                  Traverse_Declarations_Or_Statements\n+                    (Statements (Alt), Process, Inside_Stubs);\n+                  Next (Alt);\n+               end loop;\n+            end;\n \n-            --  Case statement\n+         when N_Extended_Return_Statement =>\n+            Traverse_Handled_Statement_Sequence\n+              (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n \n-            when N_Case_Statement =>\n+         when N_Loop_Statement =>\n+            Traverse_Declarations_Or_Statements\n+              (Statements (N), Process, Inside_Stubs);\n \n-               --  Process case branches\n+         --  Generic declarations are ignored\n \n-               declare\n-                  Alt : Node_Id;\n-               begin\n-                  Alt := First (Alternatives (N));\n-                  while Present (Alt) loop\n-                     Traverse_Declarations_Or_Statements\n-                       (Statements (Alt), Process, Inside_Stubs);\n-                     Next (Alt);\n-                  end loop;\n-               end;\n+         when others =>\n+            null;\n+      end case;\n+   end Traverse_Declaration_Or_Statement;\n \n-            --  Extended return statement\n+   -----------------------------------------\n+   -- Traverse_Declarations_Or_Statements --\n+   -----------------------------------------\n \n-            when N_Extended_Return_Statement =>\n-               Traverse_Handled_Statement_Sequence\n-                 (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n+   procedure Traverse_Declarations_Or_Statements\n+     (L            : List_Id;\n+      Process      : Node_Processing;\n+      Inside_Stubs : Boolean)\n+   is\n+      N : Node_Id;\n \n-            --  Loop\n+   begin\n+      --  Loop through statements or declarations\n \n-            when N_Loop_Statement =>\n-               Traverse_Declarations_Or_Statements\n-                 (Statements (N), Process, Inside_Stubs);\n+      N := First (L);\n+      while Present (N) loop\n+         --  Call Process on all declarations\n \n-            --  Generic declarations are ignored\n+         if Nkind (N) in N_Declaration\n+              or else\n+            Nkind (N) in N_Later_Decl_Item\n+         then\n+            Process (N);\n+         end if;\n \n-            when others =>\n-               null;\n-         end case;\n+         Traverse_Declaration_Or_Statement (N, Process, Inside_Stubs);\n \n          Next (N);\n       end loop;"}, {"sha": "df4c5ceeda540f1c9cefb7bf70dff7289009897e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 70, "deletions": 12, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -7265,20 +7265,58 @@ package body Sem_Attr is\n          return;\n       end if;\n \n-      --  Special processing for cases where the prefix is an object. For\n-      --  this purpose, a string literal counts as an object (attributes\n-      --  of string literals can only appear in generated code).\n+      --  Special processing for cases where the prefix is an object. For this\n+      --  purpose, a string literal counts as an object (attributes of string\n+      --  literals can only appear in generated code).\n \n       if Is_Object_Reference (P) or else Nkind (P) = N_String_Literal then\n \n          --  For Component_Size, the prefix is an array object, and we apply\n-         --  the attribute to the type of the object. This is allowed for\n-         --  both unconstrained and constrained arrays, since the bounds\n-         --  have no influence on the value of this attribute.\n+         --  the attribute to the type of the object. This is allowed for both\n+         --  unconstrained and constrained arrays, since the bounds have no\n+         --  influence on the value of this attribute.\n \n          if Id = Attribute_Component_Size then\n             P_Entity := Etype (P);\n \n+         --  For Enum_Rep, evaluation depends on the nature of the prefix and\n+         --  the optional argument.\n+\n+         elsif Id = Attribute_Enum_Rep then\n+            if Is_Entity_Name (P) then\n+\n+               --  The prefix denotes a constant or an enumeration literal, the\n+               --  attribute can be folded.\n+\n+               if Ekind_In (Entity (P), E_Constant, E_Enumeration_Literal) then\n+                  P_Entity := Etype (P);\n+\n+               --  The prefix denotes an enumeration type. Folding can occur\n+               --  when the argument is a constant or an enumeration literal.\n+\n+               elsif Is_Enumeration_Type (Entity (P))\n+                 and then Present (E1)\n+                 and then Is_Entity_Name (E1)\n+                 and then Ekind_In (Entity (E1), E_Constant,\n+                                                 E_Enumeration_Literal)\n+               then\n+                  P_Entity := Etype (P);\n+\n+               --  Otherwise the attribute must be expanded into a conversion\n+               --  and evaluated at runtime.\n+\n+               else\n+                  Check_Expressions;\n+                  return;\n+               end if;\n+\n+            --  Otherwise the attribute is illegal, do not attempt to perform\n+            --  any kind of folding.\n+\n+            else\n+               return;\n+            end if;\n+\n          --  For First and Last, the prefix is an array object, and we apply\n          --  the attribute to the type of the array, but we need a constrained\n          --  type for this, so we use the actual subtype if available.\n@@ -7971,7 +8009,26 @@ package body Sem_Attr is\n       -- Enum_Rep --\n       --------------\n \n-      when Attribute_Enum_Rep =>\n+      when Attribute_Enum_Rep => Enum_Rep : declare\n+         Val : Node_Id;\n+\n+      begin\n+         --  The attribute appears in the form\n+\n+         --    Enum_Typ'Enum_Rep (Const)\n+         --    Enum_Typ'Enum_Rep (Enum_Lit)\n+\n+         if Present (E1) then\n+            Val := E1;\n+\n+         --  Otherwise the prefix denotes a constant or enumeration literal\n+\n+         --    Const'Enum_Rep\n+         --    Enum_Lit'Enum_Rep\n+\n+         else\n+            Val := P;\n+         end if;\n \n          --  For an enumeration type with a non-standard representation use\n          --  the Enumeration_Rep field of the proper constant. Note that this\n@@ -7983,15 +8040,16 @@ package body Sem_Attr is\n          if Is_Enumeration_Type (P_Type)\n            and then Has_Non_Standard_Rep (P_Type)\n          then\n-            Fold_Uint (N, Enumeration_Rep (Expr_Value_E (E1)), Static);\n+            Fold_Uint (N, Enumeration_Rep (Expr_Value_E (Val)), Static);\n \n-         --  For enumeration types with standard representations and all\n-         --  other cases (i.e. all integer and modular types), Enum_Rep\n-         --  is equivalent to Pos.\n+         --  For enumeration types with standard representations and all other\n+         --  cases (i.e. all integer and modular types), Enum_Rep is equivalent\n+         --  to Pos.\n \n          else\n-            Fold_Uint (N, Expr_Value (E1), Static);\n+            Fold_Uint (N, Expr_Value (Val), Static);\n          end if;\n+      end Enum_Rep;\n \n       --------------\n       -- Enum_Val --"}, {"sha": "defb21a8858e8c1714a0759401965fabb9c7dde4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -4833,6 +4833,12 @@ package body Sem_Prag is\n                            elsif Is_Loop_Pragma (Stmt) then\n                               Prag := Stmt;\n \n+                           --  Skip declarations and statements generated by\n+                           --  the compiler during expansion.\n+\n+                           elsif not Comes_From_Source (Stmt) then\n+                              null;\n+\n                            --  A non-pragma is separating the group from the\n                            --  current pragma, the placement is illegal.\n "}, {"sha": "2332bb32ab7243dde10c681f214aff6ff994ce8a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -11309,40 +11309,9 @@ package body Sem_Util is\n       function Is_Descendant_Of_Suspension_Object\n         (Typ : Entity_Id) return Boolean\n       is\n-         function Is_Suspension_Object (Id : Entity_Id) return Boolean;\n-         --  Determine whether arbitrary entity Id denotes Suspension_Object\n-         --  defined in Ada.Synchronous_Task_Control.\n-\n-         --------------------------\n-         -- Is_Suspension_Object --\n-         --------------------------\n-\n-         function Is_Suspension_Object (Id : Entity_Id) return Boolean is\n-         begin\n-            --  This approach does an exact name match rather than to rely on\n-            --  RTSfind. Routine Is_Effectively_Volatile is used by clients of\n-            --  the front end at point where all auxiliary tables are locked\n-            --  and any modifications to them are treated as violations. Do not\n-            --  tamper with the tables, instead examine the Chars fields of all\n-            --  the scopes of Id.\n-\n-            return\n-              Chars (Id) = Name_Suspension_Object\n-                and then Present (Scope (Id))\n-                and then Chars (Scope (Id)) = Name_Synchronous_Task_Control\n-                and then Present (Scope (Scope (Id)))\n-                and then Chars (Scope (Scope (Id))) = Name_Ada\n-                and then Present (Scope (Scope (Scope (Id))))\n-                and then Scope (Scope (Scope (Id))) = Standard_Standard;\n-         end Is_Suspension_Object;\n-\n-         --  Local variables\n-\n          Cur_Typ : Entity_Id;\n          Par_Typ : Entity_Id;\n \n-      --  Start of processing for Is_Descendant_Of_Suspension_Object\n-\n       begin\n          --  Climb the type derivation chain checking each parent type against\n          --  Suspension_Object.\n@@ -13161,6 +13130,28 @@ package body Sem_Util is\n         and then Ekind (Defining_Entity (N)) /= E_Subprogram_Body;\n    end Is_Subprogram_Stub_Without_Prior_Declaration;\n \n+   --------------------------\n+   -- Is_Suspension_Object --\n+   --------------------------\n+\n+   function Is_Suspension_Object (Id : Entity_Id) return Boolean is\n+   begin\n+      --  This approach does an exact name match rather than to rely on\n+      --  RTSfind. Routine Is_Effectively_Volatile is used by clients of the\n+      --  front end at point where all auxiliary tables are locked and any\n+      --  modifications to them are treated as violations. Do not tamper with\n+      --  the tables, instead examine the Chars fields of all the scopes of Id.\n+\n+      return\n+        Chars (Id) = Name_Suspension_Object\n+          and then Present (Scope (Id))\n+          and then Chars (Scope (Id)) = Name_Synchronous_Task_Control\n+          and then Present (Scope (Scope (Id)))\n+          and then Chars (Scope (Scope (Id))) = Name_Ada\n+          and then Present (Scope (Scope (Scope (Id))))\n+          and then Scope (Scope (Scope (Id))) = Standard_Standard;\n+   end Is_Suspension_Object;\n+\n    ---------------------------------\n    -- Is_Synchronized_Tagged_Type --\n    ---------------------------------"}, {"sha": "973cb7df326f794d3a4883d3bc47eb18dfa7f875", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -1503,6 +1503,10 @@ package Sem_Util is\n    --  Return True if N is a subprogram stub with no prior subprogram\n    --  declaration.\n \n+   function Is_Suspension_Object (Id : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary entity Id denotes Suspension_Object defined\n+   --  in Ada.Synchronous_Task_Control.\n+\n    function Is_Synchronized_Tagged_Type (E : Entity_Id) return Boolean;\n    --  Returns True if E is a synchronized tagged type (AARM 3.9.4 (6/2))\n "}, {"sha": "ff5fb26c2ecf38c2277963b8064d0e61a5739018", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7e6c2640e197797b544a7238d1e362f85c2921/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=ca7e6c2640e197797b544a7238d1e362f85c2921", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -111,9 +111,10 @@ package SPARK_Xrefs is\n    --      type is a single letter identifying the type of the entity, using\n    --      the same code as in cross-references:\n \n-   --        K = package\n-   --        V = function\n-   --        U = procedure\n+   --        K = package (k = generic package)\n+   --        V = function (v = generic function)\n+   --        U = procedure (u = generic procedure)\n+   --        Y = entry\n \n    --      col is the column number of the scope entity\n "}]}