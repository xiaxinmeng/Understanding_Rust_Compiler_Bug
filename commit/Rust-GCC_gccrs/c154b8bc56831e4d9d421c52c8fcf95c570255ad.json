{"sha": "c154b8bc56831e4d9d421c52c8fcf95c570255ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE1NGI4YmM1NjgzMWU0ZDlkNDIxYzUyYzhmY2Y5NWM1NzAyNTVhZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-22T09:06:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-22T09:06:59Z"}, "message": "openmp: Compute triangular loop number of iterations at compile time\n\n2020-06-22  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-general.c (omp_extract_for_data): For triangular loops with\n\tall loop invariant expressions constant where the innermost loop is\n\texecuted at least once compute number of iterations at compile time.", "tree": {"sha": "79184317fc6e7ee3c851d6ad9b4146071603735d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79184317fc6e7ee3c851d6ad9b4146071603735d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c154b8bc56831e4d9d421c52c8fcf95c570255ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c154b8bc56831e4d9d421c52c8fcf95c570255ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c154b8bc56831e4d9d421c52c8fcf95c570255ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c154b8bc56831e4d9d421c52c8fcf95c570255ad/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4670347f10d36816e7da08796f96f087094ba58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4670347f10d36816e7da08796f96f087094ba58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4670347f10d36816e7da08796f96f087094ba58"}], "stats": {"total": 226, "additions": 201, "deletions": 25}, "files": [{"sha": "10196f671e1697a7470c817a4ee7893edc889fa5", "filename": "gcc/omp-general.c", "status": "modified", "additions": 201, "deletions": 25, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c154b8bc56831e4d9d421c52c8fcf95c570255ad/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c154b8bc56831e4d9d421c52c8fcf95c570255ad/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=c154b8bc56831e4d9d421c52c8fcf95c570255ad", "patch": "@@ -313,6 +313,44 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n     }\n \n   int cnt = fd->ordered ? fd->ordered : fd->collapse;\n+  int single_nonrect = -1;\n+  tree single_nonrect_count = NULL_TREE;\n+  enum tree_code single_nonrect_cond_code = ERROR_MARK;\n+  for (i = 1; i < cnt; i++)\n+    {\n+      tree n1 = gimple_omp_for_initial (for_stmt, i);\n+      tree n2 = gimple_omp_for_final (for_stmt, i);\n+      if (TREE_CODE (n1) == TREE_VEC)\n+\t{\n+\t  if (fd->non_rect)\n+\t    {\n+\t      single_nonrect = -1;\n+\t      break;\n+\t    }\n+\t  for (int j = i - 1; j >= 0; j--)\n+\t    if (TREE_VEC_ELT (n1, 0) == gimple_omp_for_index (for_stmt, j))\n+\t      {\n+\t\tsingle_nonrect = j;\n+\t\tbreak;\n+\t      }\n+\t  fd->non_rect = true;\n+\t}\n+      else if (TREE_CODE (n2) == TREE_VEC)\n+\t{\n+\t  if (fd->non_rect)\n+\t    {\n+\t      single_nonrect = -1;\n+\t      break;\n+\t    }\n+\t  for (int j = i - 1; j >= 0; j--)\n+\t    if (TREE_VEC_ELT (n2, 0) == gimple_omp_for_index (for_stmt, j))\n+\t      {\n+\t\tsingle_nonrect = j;\n+\t\tbreak;\n+\t      }\n+\t  fd->non_rect = true;\n+\t}\n+    }\n   for (i = 0; i < cnt; i++)\n     {\n       if (i == 0\n@@ -444,8 +482,90 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \n       if (collapse_count && *collapse_count == NULL)\n \t{\n+\t  if (count && integer_zerop (count))\n+\t    continue;\n+\t  tree n1first = NULL_TREE, n2first = NULL_TREE;\n+\t  tree n1last = NULL_TREE, n2last = NULL_TREE;\n+\t  tree ostep = NULL_TREE;\n \t  if (loop->m1 || loop->m2)\n-\t    t = NULL_TREE;\n+\t    {\n+\t      if (count == NULL_TREE)\n+\t\tcontinue;\n+\t      if (single_nonrect == -1\n+\t\t  || (loop->m1 && TREE_CODE (loop->m1) != INTEGER_CST)\n+\t\t  || (loop->m2 && TREE_CODE (loop->m2) != INTEGER_CST))\n+\t\t{\n+\t\t  count = NULL_TREE;\n+\t\t  continue;\n+\t\t}\n+\t      tree var = gimple_omp_for_initial (for_stmt, single_nonrect);\n+\t      tree itype = TREE_TYPE (var);\n+\t      tree first = gimple_omp_for_initial (for_stmt, single_nonrect);\n+\t      t = gimple_omp_for_incr (for_stmt, single_nonrect);\n+\t      ostep = omp_get_for_step_from_incr (loc, t);\n+\t      t = fold_binary (MINUS_EXPR, long_long_unsigned_type_node,\n+\t\t\t       single_nonrect_count,\n+\t\t\t       build_one_cst (long_long_unsigned_type_node));\n+\t      t = fold_convert (itype, t);\n+\t      first = fold_convert (itype, first);\n+\t      ostep = fold_convert (itype, ostep);\n+\t      tree last = fold_binary (PLUS_EXPR, itype, first,\n+\t\t\t\t       fold_binary (MULT_EXPR, itype, t,\n+\t\t\t\t\t\t    ostep));\n+\t      if (TREE_CODE (first) != INTEGER_CST\n+\t\t  || TREE_CODE (last) != INTEGER_CST)\n+\t\t{\n+\t\t  count = NULL_TREE;\n+\t\t  continue;\n+\t\t}\n+\t      if (loop->m1)\n+\t\t{\n+\t\t  tree m1 = fold_convert (itype, loop->m1);\n+\t\t  tree n1 = fold_convert (itype, loop->n1);\n+\t\t  n1first = fold_binary (PLUS_EXPR, itype,\n+\t\t\t\t\t fold_binary (MULT_EXPR, itype,\n+\t\t\t\t\t\t      first, m1), n1);\n+\t\t  n1last = fold_binary (PLUS_EXPR, itype,\n+\t\t\t\t\tfold_binary (MULT_EXPR, itype,\n+\t\t\t\t\t\t     last, m1), n1);\n+\t\t}\n+\t      else\n+\t\tn1first = n1last = loop->n1;\n+\t      if (loop->m2)\n+\t\t{\n+\t\t  tree n2 = fold_convert (itype, loop->n2);\n+\t\t  tree m2 = fold_convert (itype, loop->m2);\n+\t\t  n2first = fold_binary (PLUS_EXPR, itype,\n+\t\t\t\t\t fold_binary (MULT_EXPR, itype,\n+\t\t\t\t\t\t      first, m2), n2);\n+\t\t  n2last = fold_binary (PLUS_EXPR, itype,\n+\t\t\t\t\tfold_binary (MULT_EXPR, itype,\n+\t\t\t\t\t\t     last, m2), n2);\n+\t\t}\n+\t      else\n+\t\tn2first = n2last = loop->n2;\n+\t      n1first = fold_convert (TREE_TYPE (loop->v), n1first);\n+\t      n2first = fold_convert (TREE_TYPE (loop->v), n2first);\n+\t      n1last = fold_convert (TREE_TYPE (loop->v), n1last);\n+\t      n2last = fold_convert (TREE_TYPE (loop->v), n2last);\n+\t      t = fold_binary (loop->cond_code, boolean_type_node,\n+\t\t\t       n1first, n2first);\n+\t      tree t2 = fold_binary (loop->cond_code, boolean_type_node,\n+\t\t\t\t     n1last, n2last);\n+\t      if (t && t2 && integer_nonzerop (t) && integer_nonzerop (t2))\n+\t\t/* All outer loop iterators have at least one inner loop\n+\t\t   iteration.  Try to compute the count at compile time.  */\n+\t\tt = NULL_TREE;\n+\t      else if (t && t2 && integer_zerop (t) && integer_zerop (t2))\n+\t\t/* No iterations of the inner loop.  count will be set to\n+\t\t   zero cst below.  */;\n+\t      else\n+\t\t{\n+\t\t  /* Punt (for now).  */\n+\t\t  count = NULL_TREE;\n+\t\t  continue;\n+\t\t}\n+\t    }\n \t  else\n \t    t = fold_binary (loop->cond_code, boolean_type_node,\n \t\t\t     fold_convert (TREE_TYPE (loop->v), loop->n1),\n@@ -454,8 +574,6 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t    count = build_zero_cst (long_long_unsigned_type_node);\n \t  else if ((i == 0 || count != NULL_TREE)\n \t\t   && TREE_CODE (TREE_TYPE (loop->v)) == INTEGER_TYPE\n-\t\t   && loop->m1 == NULL_TREE\n-\t\t   && loop->m2 == NULL_TREE\n \t\t   && TREE_CONSTANT (loop->n1)\n \t\t   && TREE_CONSTANT (loop->n2)\n \t\t   && TREE_CODE (loop->step) == INTEGER_CST)\n@@ -465,31 +583,89 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      if (POINTER_TYPE_P (itype))\n \t\titype = signed_type_for (itype);\n \t      t = build_int_cst (itype, (loop->cond_code == LT_EXPR ? -1 : 1));\n-\t      t = fold_build2_loc (loc, PLUS_EXPR, itype,\n-\t\t\t\t   fold_convert_loc (loc, itype, loop->step),\n-\t\t\t\t   t);\n-\t      t = fold_build2_loc (loc, PLUS_EXPR, itype, t,\n-\t\t\t\t   fold_convert_loc (loc, itype, loop->n2));\n-\t      t = fold_build2_loc (loc, MINUS_EXPR, itype, t,\n-\t\t\t\t   fold_convert_loc (loc, itype, loop->n1));\n-\t      if (TYPE_UNSIGNED (itype) && loop->cond_code == GT_EXPR)\n+\t      t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t       fold_convert (itype, loop->step), t);\n+\t      tree n1 = loop->n1;\n+\t      tree n2 = loop->n2;\n+\t      if (loop->m1 || loop->m2)\n \t\t{\n-\t\t  tree step = fold_convert_loc (loc, itype, loop->step);\n-\t\t  t = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n-\t\t\t\t       fold_build1_loc (loc, NEGATE_EXPR,\n-\t\t\t\t\t\t\titype, t),\n-\t\t\t\t       fold_build1_loc (loc, NEGATE_EXPR,\n-\t\t\t\t\t\t\titype, step));\n+\t\t  gcc_assert (single_nonrect != -1);\n+\t\t  if (single_nonrect_cond_code == LT_EXPR)\n+\t\t    {\n+\t\t      n1 = n1first;\n+\t\t      n2 = n2first;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      n1 = n1last;\n+\t\t      n2 = n2last;\n+\t\t    }\n \t\t}\n+\t      t = fold_build2 (PLUS_EXPR, itype, t, fold_convert (itype, n2));\n+\t      t = fold_build2 (MINUS_EXPR, itype, t, fold_convert (itype, n1));\n+\t      tree step = fold_convert_loc (loc, itype, loop->step);\n+\t      if (TYPE_UNSIGNED (itype) && loop->cond_code == GT_EXPR)\n+\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t\t fold_build1 (NEGATE_EXPR, itype, step));\n \t      else\n-\t\tt = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n-\t\t\t\t     fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t       loop->step));\n-\t      t = fold_convert_loc (loc, long_long_unsigned_type_node, t);\n-\t      if (count != NULL_TREE)\n-\t\tcount = fold_build2_loc (loc, MULT_EXPR,\n-\t\t\t\t\t long_long_unsigned_type_node,\n-\t\t\t\t\t count, t);\n+\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t      tree llutype = long_long_unsigned_type_node;\n+\t      t = fold_convert (llutype, t);\n+\t      if (loop->m1 || loop->m2)\n+\t\t{\n+\t\t  /* t is number of iterations of inner loop at either first\n+\t\t     or last value of the outer iterator (the one with fewer\n+\t\t     iterations).\n+\t\t     Compute t2 = ((m2 - m1) * ostep) / step\n+\t\t     (for single_nonrect_cond_code GT_EXPR\n+\t\t      t2 = ((m1 - m2) * ostep) / step instead)\n+\t\t     and niters = outer_count * t\n+\t\t\t\t  + t2 * ((outer_count - 1) * outer_count / 2)\n+\t\t   */\n+\t\t  tree m1 = loop->m1 ? loop->m1 : integer_zero_node;\n+\t\t  tree m2 = loop->m2 ? loop->m2 : integer_zero_node;\n+\t\t  m1 = fold_convert (itype, m1);\n+\t\t  m2 = fold_convert (itype, m2);\n+\t\t  tree t2;\n+\t\t  if (single_nonrect_cond_code == LT_EXPR)\n+\t\t    t2 = fold_build2 (MINUS_EXPR, itype, m2, m1);\n+\t\t  else\n+\t\t    t2 = fold_build2 (MINUS_EXPR, itype, m1, m2);\n+\t\t  t2 = fold_build2 (MULT_EXPR, itype, t2, ostep);\n+\t\t  if (TYPE_UNSIGNED (itype) && loop->cond_code == GT_EXPR)\n+\t\t    t2 = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t      fold_build1 (NEGATE_EXPR, itype, t2),\n+\t\t\t\t      fold_build1 (NEGATE_EXPR, itype, step));\n+\t\t  else\n+\t\t    t2 = fold_build2 (TRUNC_DIV_EXPR, itype, t2, step);\n+\t\t  t2 = fold_convert (llutype, t2);\n+\t\t  t = fold_build2 (MULT_EXPR, llutype, t,\n+\t\t\t\t   single_nonrect_count);\n+\t\t  tree t3 = fold_build2 (MINUS_EXPR, llutype,\n+\t\t\t\t\t single_nonrect_count,\n+\t\t\t\t\t build_one_cst (llutype));\n+\t\t  t3 = fold_build2 (MULT_EXPR, llutype, t3,\n+\t\t\t\t    single_nonrect_count);\n+\t\t  t3 = fold_build2 (TRUNC_DIV_EXPR, llutype, t3,\n+\t\t\t\t    build_int_cst (llutype, 2));\n+\t\t  t2 = fold_build2 (MULT_EXPR, llutype, t2, t3);\n+\t\t  t = fold_build2 (PLUS_EXPR, llutype, t, t2);\n+\t\t}\n+\t      if (i == single_nonrect)\n+\t\t{\n+\t\t  if (integer_zerop (t) || TREE_CODE (t) != INTEGER_CST)\n+\t\t    count = t;\n+\t\t  else\n+\t\t    {\n+\t\t      single_nonrect_count = t;\n+\t\t      single_nonrect_cond_code = loop->cond_code;\n+\t\t      if (count == NULL_TREE)\n+\t\t\tcount = build_one_cst (llutype);\n+\t\t    }\n+\t\t}\n+\t      else if (count != NULL_TREE)\n+\t\tcount = fold_build2 (MULT_EXPR, llutype, count, t);\n \t      else\n \t\tcount = t;\n \t      if (TREE_CODE (count) != INTEGER_CST)"}]}