{"sha": "7c5848b89955c3ec45a78630f23d610f13e3e47b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M1ODQ4Yjg5OTU1YzNlYzQ1YTc4NjMwZjIzZDYxMGYxM2UzZTQ3Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-06-24T12:17:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-06-24T12:17:16Z"}, "message": "pointer-set.h (struct pointer_set_t): Move here from pointer-set.c.\n\n2013-06-24  Richard Biener  <rguenther@suse.de>\n\n\t* pointer-set.h (struct pointer_set_t): Move here from\n\tpointer-set.c.\n\t(pointer_set_lookup): Declare.\n\t(class pointer_map): New template class implementing a\n\tgeneric pointer to T map.\n\t(pointer_map<T>::pointer_map, pointer_map<T>::~pointer_map,\n\tpointer_map<T>::contains, pointer_map<T>::insert,\n\tpointer_map<T>::traverse): New functions.\n\t* pointer-set.c (struct pointer_set_t): Moved to pointer-set.h.\n\t(pointer_set_lookup): New function.\n\t(pointer_set_contains): Use pointer_set_lookup.\n\t(pointer_set_insert): Likewise.\n\t(insert_aux): Remove.\n\t(struct pointer_map_t): Embed a pointer_set_t.\n\t(pointer_map_create): Adjust.\n\t(pointer_map_destroy): Likewise.\n\t(pointer_map_contains): Likewise.\n\t(pointer_map_insert): Likewise.\n\t(pointer_map_traverse): Likewise.\n\t* tree-streamer.h (struct streamer_tree_cache_d): Use a\n\tpointer_map<unsigned> instead of a pointer_map_t.\n\t* tree-streamer.c (streamer_tree_cache_insert_1): Adjust.\n\t(streamer_tree_cache_lookup): Likewise.\n\t(streamer_tree_cache_create): Likewise.\n\t(streamer_tree_cache_delete): Likewise.\n\t* lto-streamer.h (struct lto_tree_ref_encoder): Use a\n\tpointer_map<unsigned> instead of a pointer_map_t.\n\t(lto_init_tree_ref_encoder): Adjust.\n\t(lto_destroy_tree_ref_encoder): Likewise.\n\t* lto-section-out.c (lto_output_decl_index): Likewise.\n\t(lto_record_function_out_decl_state): Likewise.\n\t* dominance.c (iterate_fix_dominators): Use pointer_map<int>.\n\nFrom-SVN: r200367", "tree": {"sha": "0b144aa71725e9242031811c26d608114f637c95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b144aa71725e9242031811c26d608114f637c95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c5848b89955c3ec45a78630f23d610f13e3e47b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5848b89955c3ec45a78630f23d610f13e3e47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c5848b89955c3ec45a78630f23d610f13e3e47b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5848b89955c3ec45a78630f23d610f13e3e47b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e04518ae25780abd0e0f70533de0f0ddb53f868c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04518ae25780abd0e0f70533de0f0ddb53f868c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04518ae25780abd0e0f70533de0f0ddb53f868c"}], "stats": {"total": 406, "additions": 266, "deletions": 140}, "files": [{"sha": "02fae673e4e063810708d0c5205c824d3c66e0de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -1,3 +1,38 @@\n+2013-06-24  Richard Biener  <rguenther@suse.de>\n+\n+\t* pointer-set.h (struct pointer_set_t): Move here from\n+\tpointer-set.c.\n+\t(pointer_set_lookup): Declare.\n+\t(class pointer_map): New template class implementing a\n+\tgeneric pointer to T map.\n+\t(pointer_map<T>::pointer_map, pointer_map<T>::~pointer_map,\n+\tpointer_map<T>::contains, pointer_map<T>::insert,\n+\tpointer_map<T>::traverse): New functions.\n+\t* pointer-set.c (struct pointer_set_t): Moved to pointer-set.h.\n+\t(pointer_set_lookup): New function.\n+\t(pointer_set_contains): Use pointer_set_lookup.\n+\t(pointer_set_insert): Likewise.\n+\t(insert_aux): Remove.\n+\t(struct pointer_map_t): Embed a pointer_set_t.\n+\t(pointer_map_create): Adjust.\n+\t(pointer_map_destroy): Likewise.\n+\t(pointer_map_contains): Likewise.\n+\t(pointer_map_insert): Likewise.\n+\t(pointer_map_traverse): Likewise.\n+\t* tree-streamer.h (struct streamer_tree_cache_d): Use a\n+\tpointer_map<unsigned> instead of a pointer_map_t.\n+\t* tree-streamer.c (streamer_tree_cache_insert_1): Adjust.\n+\t(streamer_tree_cache_lookup): Likewise.\n+\t(streamer_tree_cache_create): Likewise.\n+\t(streamer_tree_cache_delete): Likewise.\n+\t* lto-streamer.h (struct lto_tree_ref_encoder): Use a\n+\tpointer_map<unsigned> instead of a pointer_map_t.\n+\t(lto_init_tree_ref_encoder): Adjust.\n+\t(lto_destroy_tree_ref_encoder): Likewise.\n+\t* lto-section-out.c (lto_output_decl_index): Likewise.\n+\t(lto_record_function_out_decl_state): Likewise.\n+\t* dominance.c (iterate_fix_dominators): Use pointer_map<int>.\n+\n 2013-06-24  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/57488"}, {"sha": "569f1f43b21ab4bc33592b528974567b67eb2290", "filename": "gcc/dominance.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -1248,7 +1248,7 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n   size_t dom_i;\n   edge e;\n   edge_iterator ei;\n-  struct pointer_map_t *map;\n+  pointer_map<int> *map;\n   int *parent, *son, *brother;\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n@@ -1336,15 +1336,15 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n     }\n \n   /* Construct the graph G.  */\n-  map = pointer_map_create ();\n+  map = new pointer_map<int>;\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     {\n       /* If the dominance tree is conservatively correct, split it now.  */\n       if (conservative)\n \tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n-      *pointer_map_insert (map, bb) = (void *) (size_t) i;\n+      *map->insert (bb) = i;\n     }\n-  *pointer_map_insert (map, ENTRY_BLOCK_PTR) = (void *) (size_t) n;\n+  *map->insert (ENTRY_BLOCK_PTR) = n;\n \n   g = new_graph (n + 1);\n   for (y = 0; y < g->n_vertices; y++)\n@@ -1357,7 +1357,7 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n \t  if (dom == bb)\n \t    continue;\n \n-\t  dom_i = (size_t) *pointer_map_contains (map, dom);\n+\t  dom_i = *map->contains (dom);\n \n \t  /* Do not include parallel edges to G.  */\n \t  if (!bitmap_set_bit ((bitmap) g->vertices[dom_i].data, i))\n@@ -1368,7 +1368,7 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n     }\n   for (y = 0; y < g->n_vertices; y++)\n     BITMAP_FREE (g->vertices[y].data);\n-  pointer_map_destroy (map);\n+  delete map;\n \n   /* Find the dominator tree of G.  */\n   son = XNEWVEC (int, n + 1);"}, {"sha": "8145ec3335442baeded2383a9b8bf68b8e5efcc2", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -225,20 +225,21 @@ lto_output_decl_index (struct lto_output_stream *obs,\n \t\t       struct lto_tree_ref_encoder *encoder,\n \t\t       tree name, unsigned int *this_index)\n {\n-  void **slot;\n-  int index;\n+  unsigned *slot;\n+  unsigned int index;\n   bool new_entry_p = FALSE;\n+  bool existed_p;\n \n-  slot = pointer_map_insert (encoder->tree_hash_table, name);\n-  if (*slot == NULL)\n+  slot = encoder->tree_hash_table->insert (name, &existed_p);\n+  if (!existed_p)\n     {\n       index = encoder->trees.length ();\n-      *slot = (void *)(uintptr_t) index;\n+      *slot = index;\n       encoder->trees.safe_push (name);\n       new_entry_p = TRUE;\n     }\n   else\n-    index = (uintptr_t) *slot;\n+    index = *slot;\n \n   if (obs)\n     streamer_write_uhwi_stream (obs, index);\n@@ -438,7 +439,7 @@ lto_record_function_out_decl_state (tree fn_decl,\n   for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n     if (state->streams[i].tree_hash_table)\n       {\n-\tpointer_map_destroy (state->streams[i].tree_hash_table);\n+\tdelete state->streams[i].tree_hash_table;\n \tstate->streams[i].tree_hash_table = NULL;\n       }\n   state->fn_decl = fn_decl;"}, {"sha": "e7c89f16162240429daf853e00a0ea0712f9a6d4", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -479,7 +479,7 @@ struct GTY(()) lto_tree_ref_table\n \n struct lto_tree_ref_encoder\n {\n-  pointer_map_t *tree_hash_table;\t/* Maps pointers to indices. */\n+  pointer_map<unsigned> *tree_hash_table;\t/* Maps pointers to indices. */\n   vec<tree> trees;\t\t\t/* Maps indices to pointers. */\n };\n \n@@ -997,7 +997,7 @@ lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n static inline void\n lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n-  encoder->tree_hash_table = pointer_map_create ();\n+  encoder->tree_hash_table = new pointer_map<unsigned>;\n   encoder->trees.create (0);\n }\n \n@@ -1009,7 +1009,7 @@ lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   /* Hash table may be delete already.  */\n   if (encoder->tree_hash_table)\n-    pointer_map_destroy (encoder->tree_hash_table);\n+    delete encoder->tree_hash_table;\n   encoder->trees.release ();\n }\n "}, {"sha": "ef44aca2d1f5125eb04aa92f243572f940e1be13", "filename": "gcc/pointer-set.c", "status": "modified", "additions": 67, "deletions": 99, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Fpointer-set.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Fpointer-set.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.c?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -21,21 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"pointer-set.h\"\n \n-/* A pointer set is represented as a simple open-addressing hash\n-   table.  Simplifications: The hash code is based on the value of the\n-   pointer, not what it points to.  The number of buckets is always a\n-   power of 2.  Null pointers are a reserved value.  Deletion is not\n-   supported (yet).  There is no mechanism for user control of hash\n-   function, equality comparison, initial size, or resizing policy.  */\n-\n-struct pointer_set_t\n-{\n-  size_t log_slots;\n-  size_t n_slots;\t\t/* n_slots = 2^log_slots */\n-  size_t n_elements;\n-\n-  const void **slots;\n-};\n \n /* Use the multiplicative method, as described in Knuth 6.4, to obtain\n    a hash code for P in the range [0, MAX).  MAX == 2^LOGMAX.\n@@ -67,6 +52,7 @@ hash1 (const void *p, unsigned long max, unsigned long logmax)\n   return ((A * (uintptr_t) p) >> shift) & (max - 1);\n }\n \n+\n /* Allocate an empty pointer set.  */\n struct pointer_set_t *\n pointer_set_create (void)\n@@ -89,20 +75,28 @@ pointer_set_destroy (struct pointer_set_t *pset)\n   XDELETE (pset);\n }\n \n-/* Returns nonzero if PSET contains P.  P must be nonnull.\n \n-   Collisions are resolved by linear probing.  */\n-int\n-pointer_set_contains (const struct pointer_set_t *pset, const void *p)\n+/* Lookup the slot for the pointer P and return true if it exists,\n+   otherwise return false in which case *IX points to the slot that\n+   would be used on insertion.  */\n+\n+bool\n+pointer_set_lookup (const pointer_set_t *pset, const void *p, size_t *ix)\n {\n   size_t n = hash1 (p, pset->n_slots, pset->log_slots);\n \n   while (true)\n     {\n       if (pset->slots[n] == p)\n-       return 1;\n+\t{\n+\t  *ix = n;\n+\t  return true;\n+\t}\n       else if (pset->slots[n] == 0)\n-       return 0;\n+\t{\n+\t  *ix = n;\n+\t  return false;\n+\t}\n       else\n        {\n          ++n;\n@@ -112,23 +106,14 @@ pointer_set_contains (const struct pointer_set_t *pset, const void *p)\n     }\n }\n \n-/* Subroutine of pointer_set_insert.  Return the insertion slot for P into\n-   an empty element of SLOTS, an array of length N_SLOTS.  */\n-static inline size_t\n-insert_aux (const void *p, const void **slots, size_t n_slots, size_t log_slots)\n+/* Returns nonzero if PSET contains P.  P must be nonnull.\n+\n+   Collisions are resolved by linear probing.  */\n+int\n+pointer_set_contains (const struct pointer_set_t *pset, const void *p)\n {\n-  size_t n = hash1 (p, n_slots, log_slots);\n-  while (true)\n-    {\n-      if (slots[n] == p || slots[n] == 0)\n-\treturn n;\n-      else\n-\t{\n-\t  ++n;\n-\t  if (n == n_slots)\n-\t    n = 0;\n-\t}\n-    }\n+  size_t n;\n+  return pointer_set_lookup (pset, p, &n);\n }\n \n /* Inserts P into PSET if it wasn't already there.  Returns nonzero\n@@ -142,26 +127,24 @@ pointer_set_insert (struct pointer_set_t *pset, const void *p)\n      superfluous but can happen at most once.  */\n   if (pset->n_elements > pset->n_slots / 4)\n     {\n-      size_t new_log_slots = pset->log_slots + 1;\n-      size_t new_n_slots = pset->n_slots * 2;\n-      const void **new_slots = XCNEWVEC (const void *, new_n_slots);\n+      size_t old_n_slots = pset->n_slots;\n+      const void **old_slots = pset->slots;\n+      pset->log_slots = pset->log_slots + 1;\n+      pset->n_slots = pset->n_slots * 2;\n+      pset->slots = XCNEWVEC (const void *, pset->n_slots);\n       size_t i;\n \n-      for (i = 0; i < pset->n_slots; ++i)\n+      for (i = 0; i < old_n_slots; ++i)\n         {\n-\t  const void *value = pset->slots[i];\n-\t  n = insert_aux (value, new_slots, new_n_slots, new_log_slots);\n-\t  new_slots[n] = value;\n+\t  const void *value = old_slots[i];\n+\t  pointer_set_lookup (pset, value, &n);\n+\t  pset->slots[n] = value;\n \t}\n \n-      XDELETEVEC (pset->slots);\n-      pset->n_slots = new_n_slots;\n-      pset->log_slots = new_log_slots;\n-      pset->slots = new_slots;\n+      XDELETEVEC (old_slots);\n     }\n \n-  n = insert_aux (p, pset->slots, pset->n_slots, pset->log_slots);\n-  if (pset->slots[n])\n+  if (pointer_set_lookup (pset, p, &n))\n     return 1;\n \n   pset->slots[n] = p;\n@@ -190,11 +173,7 @@ void pointer_set_traverse (const struct pointer_set_t *pset,\n \n struct pointer_map_t\n {\n-  size_t log_slots;\n-  size_t n_slots;\t\t/* n_slots = 2^log_slots */\n-  size_t n_elements;\n-\n-  const void **keys;\n+  pointer_set_t pset;\n   void **values;\n };\n \n@@ -204,19 +183,19 @@ pointer_map_create (void)\n {\n   struct pointer_map_t *result = XNEW (struct pointer_map_t);\n \n-  result->n_elements = 0;\n-  result->log_slots = 8;\n-  result->n_slots = (size_t) 1 << result->log_slots;\n+  result->pset.n_elements = 0;\n+  result->pset.log_slots = 8;\n+  result->pset.n_slots = (size_t) 1 << result->pset.log_slots;\n \n-  result->keys = XCNEWVEC (const void *, result->n_slots);\n-  result->values = XCNEWVEC (void *, result->n_slots);\n+  result->pset.slots = XCNEWVEC (const void *, result->pset.n_slots);\n+  result->values = XCNEWVEC (void *, result->pset.n_slots);\n   return result;\n }\n \n /* Reclaims all memory associated with PMAP.  */\n void pointer_map_destroy (struct pointer_map_t *pmap)\n {\n-  XDELETEVEC (pmap->keys);\n+  XDELETEVEC (pmap->pset.slots);\n   XDELETEVEC (pmap->values);\n   XDELETE (pmap);\n }\n@@ -228,21 +207,11 @@ void pointer_map_destroy (struct pointer_map_t *pmap)\n void **\n pointer_map_contains (const struct pointer_map_t *pmap, const void *p)\n {\n-  size_t n = hash1 (p, pmap->n_slots, pmap->log_slots);\n-\n-  while (true)\n-    {\n-      if (pmap->keys[n] == p)\n-\treturn &pmap->values[n];\n-      else if (pmap->keys[n] == 0)\n-\treturn NULL;\n-      else\n-       {\n-         ++n;\n-         if (n == pmap->n_slots)\n-           n = 0;\n-       }\n-    }\n+  size_t n;\n+  if (pointer_set_lookup (&pmap->pset, p, &n))\n+    return &pmap->values[n];\n+  else\n+    return NULL;\n }\n \n /* Inserts P into PMAP if it wasn't already there.  Returns a pointer\n@@ -254,36 +223,34 @@ pointer_map_insert (struct pointer_map_t *pmap, const void *p)\n \n   /* For simplicity, expand the map even if P is already there.  This can be\n      superfluous but can happen at most once.  */\n-  if (pmap->n_elements > pmap->n_slots / 4)\n+  if (pmap->pset.n_elements > pmap->pset.n_slots / 4)\n     {\n-      size_t new_log_slots = pmap->log_slots + 1;\n-      size_t new_n_slots = pmap->n_slots * 2;\n-      const void **new_keys = XCNEWVEC (const void *, new_n_slots);\n-      void **new_values = XCNEWVEC (void *, new_n_slots);\n+      size_t old_n_slots = pmap->pset.n_slots;\n+      const void **old_keys = pmap->pset.slots;\n+      void **old_values = pmap->values;\n+      pmap->pset.log_slots = pmap->pset.log_slots + 1;\n+      pmap->pset.n_slots = pmap->pset.n_slots * 2;\n+      pmap->pset.slots = XCNEWVEC (const void *, pmap->pset.n_slots);\n+      pmap->values = XCNEWVEC (void *, pmap->pset.n_slots);\n       size_t i;\n \n-      for (i = 0; i < pmap->n_slots; ++i)\n-\tif (pmap->keys[i])\n+      for (i = 0; i < old_n_slots; ++i)\n+\tif (old_keys[i])\n \t  {\n-\t    const void *key = pmap->keys[i];\n-\t    n = insert_aux (key, new_keys, new_n_slots, new_log_slots);\n-\t    new_keys[n] = key;\n-\t    new_values[n] = pmap->values[i];\n+\t    const void *key = old_keys[i];\n+\t    pointer_set_lookup (&pmap->pset, key, &n);\n+\t    pmap->pset.slots[n] = key;\n+\t    pmap->values[n] = old_values[i];\n \t  }\n \n-      XDELETEVEC (pmap->keys);\n-      XDELETEVEC (pmap->values);\n-      pmap->n_slots = new_n_slots;\n-      pmap->log_slots = new_log_slots;\n-      pmap->keys = new_keys;\n-      pmap->values = new_values;\n+      XDELETEVEC (old_keys);\n+      XDELETEVEC (old_values);\n     }\n \n-  n = insert_aux (p, pmap->keys, pmap->n_slots, pmap->log_slots);\n-  if (!pmap->keys[n])\n+  if (!pointer_set_lookup (&pmap->pset, p, &n))\n     {\n-      ++pmap->n_elements;\n-      pmap->keys[n] = p;\n+      ++pmap->pset.n_elements;\n+      pmap->pset.slots[n] = p;\n     }\n \n   return &pmap->values[n];\n@@ -297,7 +264,8 @@ void pointer_map_traverse (const struct pointer_map_t *pmap,\n \t\t\t   bool (*fn) (const void *, void **, void *), void *data)\n {\n   size_t i;\n-  for (i = 0; i < pmap->n_slots; ++i)\n-    if (pmap->keys[i] && !fn (pmap->keys[i], &pmap->values[i], data))\n+  for (i = 0; i < pmap->pset.n_slots; ++i)\n+    if (pmap->pset.slots[i]\n+\t&& !fn (pmap->pset.slots[i], &pmap->values[i], data))\n       break;\n }"}, {"sha": "c026af78ff66d0b17c7dc24e0cdc8d61e1c08ebc", "filename": "gcc/pointer-set.h", "status": "modified", "additions": 135, "deletions": 7, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Fpointer-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Fpointer-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.h?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -20,23 +20,151 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef POINTER_SET_H\n #define POINTER_SET_H\n \n-struct pointer_set_t;\n+\n+/* A pointer set is represented as a simple open-addressing hash\n+   table.  Simplifications: The hash code is based on the value of the\n+   pointer, not what it points to.  The number of buckets is always a\n+   power of 2.  Null pointers are a reserved value.  Deletion is not\n+   supported (yet).  There is no mechanism for user control of hash\n+   function, equality comparison, initial size, or resizing policy.  */\n+\n+struct pointer_set_t\n+{\n+  size_t log_slots;\n+  size_t n_slots;\t\t/* n_slots = 2^log_slots */\n+  size_t n_elements;\n+  const void **slots;\n+};\n+\n struct pointer_set_t *pointer_set_create (void);\n void pointer_set_destroy (struct pointer_set_t *pset);\n-\n int pointer_set_contains (const struct pointer_set_t *pset, const void *p);\n int pointer_set_insert (struct pointer_set_t *pset, const void *p);\n void pointer_set_traverse (const struct pointer_set_t *,\n \t\t\t   bool (*) (const void *, void *),\n \t\t\t   void *);\n+bool pointer_set_lookup (const pointer_set_t *, const void *, size_t *);\n+\n+/* A pointer map is represented the same way as a pointer_set, so\n+   the hash code is based on the address of the key, rather than\n+   its contents.  Null keys are a reserved value.  Deletion is not\n+   supported (yet).  There is no mechanism for user control of hash\n+   function, equality comparison, initial size, or resizing policy.  */\n+\n+template <typename T>\n+class pointer_map : protected pointer_set_t\n+{\n+  T *values;\n+\n+public:\n+  pointer_map ();\n+  ~pointer_map ();\n+  T *contains (const void *p);\n+  T *insert (const void *p, bool *existed_p = NULL);\n+  void traverse (bool (*fn) (const void *, T *, void *), void *data);\n+};\n+\n+/* Allocate an empty pointer map.  */\n+template <typename T>\n+pointer_map<T>::pointer_map (void)\n+{\n+  n_elements = 0;\n+  log_slots = 8;\n+  n_slots = (size_t) 1 << log_slots;\n+\n+  slots = XCNEWVEC (const void *, n_slots);\n+  values = XNEWVEC (T, n_slots);\n+}\n+\n+/* Reclaims all memory associated with PMAP.  */\n+template <typename T>\n+pointer_map<T>::~pointer_map (void)\n+{\n+  XDELETEVEC (slots);\n+  XDELETEVEC (values);\n+}\n+\n+/* Returns a pointer to the value to which P maps, if PMAP contains P.  P\n+   must be nonnull.  Return NULL if PMAP does not contain P.\n+\n+   Collisions are resolved by linear probing.  */\n+template <typename T>\n+T *\n+pointer_map<T>::contains (const void *p)\n+{\n+  size_t n;\n+  if (!pointer_set_lookup (this, p, &n))\n+    return NULL;\n+  return &values[n];\n+}\n+\n+/* Inserts P into PMAP if it wasn't already there.  Returns a pointer\n+   to the value.  P must be nonnull.  */\n+template <typename T>\n+T *\n+pointer_map<T>::insert (const void *p, bool *existed_p)\n+{\n+  size_t n;\n+\n+  /* For simplicity, expand the map even if P is already there.  This can be\n+     superfluous but can happen at most once.  */\n+  /* ???  Fugly that we have to inline that here.  */\n+  if (n_elements > n_slots / 4)\n+    {\n+      size_t old_n_slots = n_slots;\n+      const void **old_keys = slots;\n+      T *old_values = values;\n+      log_slots = log_slots + 1;\n+      n_slots = n_slots * 2;\n+      slots = XCNEWVEC (const void *, n_slots);\n+      values = XNEWVEC (T, n_slots);\n+      for (size_t i = 0; i < old_n_slots; ++i)\n+\tif (old_keys[i])\n+\t  {\n+\t    const void *key = old_keys[i];\n+\t    pointer_set_lookup (this, key, &n);\n+\t    slots[n] = key;\n+\t    values[n] = old_values[i];\n+\t  }\n+      XDELETEVEC (old_keys);\n+      XDELETEVEC (old_values);\n+    }\n+\n+  if (!pointer_set_lookup (this, p, &n))\n+    {\n+      ++n_elements;\n+      slots[n] = p;\n+      if (existed_p)\n+\t*existed_p = false;\n+    }\n+  else if (existed_p)\n+    *existed_p = true;\n+\n+  return &values[n];\n+}\n+\n+/* Pass each pointer in PMAP to the function in FN, together with the pointer\n+   to the value and the fixed parameter DATA.  If FN returns false, the\n+   iteration stops.  */\n+\n+template <class T>\n+void\n+pointer_map<T>::traverse (bool (*fn) (const void *, T *, void *), void *data)\n+{\n+  for (size_t i = 0; i < n_slots; ++i)\n+    if (slots[i] && !fn (slots[i], &values[i], data))\n+      break;\n+}\n+\n \n struct pointer_map_t;\n-struct pointer_map_t *pointer_map_create (void);\n-void pointer_map_destroy (struct pointer_map_t *pmap);\n+pointer_map_t *pointer_map_create (void);\n+void pointer_map_destroy (pointer_map_t *pmap);\n \n-void **pointer_map_contains (const struct pointer_map_t *pmap, const void *p);\n-void **pointer_map_insert (struct pointer_map_t *pmap, const void *p);\n-void pointer_map_traverse (const struct pointer_map_t *,\n+void **pointer_map_contains (const pointer_map_t *pmap, const void *p);\n+void **pointer_map_insert (pointer_map_t *pmap, const void *p);\n+void pointer_map_traverse (const pointer_map_t *,\n \t\t\t   bool (*) (const void *, void **, void *), void *);\n \n+\n #endif  /* POINTER_SET_H  */"}, {"sha": "8d532d9c250818781ed32f535d96d70ccb588a29", "filename": "gcc/tree-streamer.c", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -128,30 +128,27 @@ streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n \t\t\t      tree t, hashval_t hash, unsigned *ix_p,\n \t\t\t      bool insert_at_next_slot_p)\n {\n-  void **slot;\n+  unsigned *slot;\n   unsigned ix;\n   bool existed_p;\n \n   gcc_assert (t);\n \n-  slot = pointer_map_insert (cache->node_map, t);\n-  if (!*slot)\n+  slot = cache->node_map->insert (t, &existed_p);\n+  if (!existed_p)\n     {\n       /* Determine the next slot to use in the cache.  */\n       if (insert_at_next_slot_p)\n \tix = cache->nodes.length ();\n       else\n \tix = *ix_p;\n-       *slot = (void *)(size_t) (ix + 1);\n+       *slot = ix;\n \n       streamer_tree_cache_add_to_node_array (cache, ix, t, hash);\n-\n-      /* Indicate that the item was not present in the cache.  */\n-      existed_p = false;\n     }\n   else\n     {\n-      ix = (size_t) *slot - 1;\n+      ix = *slot;\n \n       if (!insert_at_next_slot_p && ix != *ix_p)\n \t{\n@@ -160,11 +157,8 @@ streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n \t     the requested location slot.  */\n \t  ix = *ix_p;\n \t  streamer_tree_cache_add_to_node_array (cache, ix, t, hash);\n-\t  *slot = (void *)(size_t) (ix + 1);\n+\t  *slot = ix;\n \t}\n-\n-      /* Indicate that T was already in the cache.  */\n-      existed_p = true;\n     }\n \n   if (ix_p)\n@@ -225,13 +219,13 @@ bool\n streamer_tree_cache_lookup (struct streamer_tree_cache_d *cache, tree t,\n \t\t\t    unsigned *ix_p)\n {\n-  void **slot;\n+  unsigned *slot;\n   bool retval;\n   unsigned ix;\n \n   gcc_assert (t);\n \n-  slot = pointer_map_contains  (cache->node_map, t);\n+  slot = cache->node_map->contains (t);\n   if (slot == NULL)\n     {\n       retval = false;\n@@ -240,7 +234,7 @@ streamer_tree_cache_lookup (struct streamer_tree_cache_d *cache, tree t,\n   else\n     {\n       retval = true;\n-      ix = (size_t) *slot - 1;\n+      ix = *slot;\n     }\n \n   if (ix_p)\n@@ -332,7 +326,7 @@ streamer_tree_cache_create (bool with_hashes, bool with_map)\n   cache = XCNEW (struct streamer_tree_cache_d);\n \n   if (with_map)\n-    cache->node_map = pointer_map_create ();\n+    cache->node_map = new pointer_map<unsigned>;\n   cache->nodes.create (165);\n   if (with_hashes)\n     cache->hashes.create (165);\n@@ -355,7 +349,7 @@ streamer_tree_cache_delete (struct streamer_tree_cache_d *c)\n     return;\n \n   if (c->node_map)\n-    pointer_map_destroy (c->node_map);\n+    delete c->node_map;\n   c->nodes.release ();\n   c->hashes.release ();\n   free (c);"}, {"sha": "02f8f51a195f1241e8bf6e1535475221d87a009a", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c5848b89955c3ec45a78630f23d610f13e3e47b/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=7c5848b89955c3ec45a78630f23d610f13e3e47b", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n struct streamer_tree_cache_d\n {\n   /* The mapping between tree nodes and slots into the nodes array.  */\n-  struct pointer_map_t *node_map;\n+  pointer_map<unsigned> *node_map;\n \n   /* The nodes pickled so far.  */\n   vec<tree> nodes;"}]}