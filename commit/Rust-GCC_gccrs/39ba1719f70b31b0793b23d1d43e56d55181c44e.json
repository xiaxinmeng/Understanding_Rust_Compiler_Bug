{"sha": "39ba1719f70b31b0793b23d1d43e56d55181c44e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzliYTE3MTlmNzBiMzFiMDc5M2IyM2QxZDQzZTU2ZDU1MTgxYzQ0ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-04-25T08:28:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-04-25T08:28:32Z"}, "message": "mips-protos.h (mips_linked_macc_p): Declare.\n\n\t* config/mips/mips-protos.h (mips_linked_macc_p): Declare.\n\t* config/mips/mips.h (TUNE_MACC_CHAINS): New macro.\n\t* config/mips/mips.c (TARGET_SCHED_REORDER): Define.\n\t(TARGET_SCHED_VARIABLE_ISSUE): Define.\n\t(mips_adjust_cost): Move later in file, next to other sched hooks.\n\t(mips_macc_chains_last_hilo): New variable.\n\t(mips_linked_madd_p, mips_macc_chains_record, mips_macc_chains_reorder)\n\t(mips_promote_ready, mips_sched_reorder, mips_variable_issue): New.\n\t* config/mips/mips.md (may_clobber_hilo): New attribute.\n\nFrom-SVN: r81157", "tree": {"sha": "f69aaa86825e7d9056a3cdef84389b3740936811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f69aaa86825e7d9056a3cdef84389b3740936811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ba1719f70b31b0793b23d1d43e56d55181c44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ba1719f70b31b0793b23d1d43e56d55181c44e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ba1719f70b31b0793b23d1d43e56d55181c44e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ba1719f70b31b0793b23d1d43e56d55181c44e/comments", "author": null, "committer": null, "parents": [{"sha": "c1fcbbc33b5d4eae5e99192627db60438db16466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fcbbc33b5d4eae5e99192627db60438db16466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fcbbc33b5d4eae5e99192627db60438db16466"}], "stats": {"total": 212, "additions": 197, "deletions": 15}, "files": [{"sha": "b5f9080a05f70ef67b94a26ef4d2e87c30243d95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39ba1719f70b31b0793b23d1d43e56d55181c44e", "patch": "@@ -1,3 +1,15 @@\n+2004-04-25  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_linked_macc_p): Declare.\n+\t* config/mips/mips.h (TUNE_MACC_CHAINS): New macro.\n+\t* config/mips/mips.c (TARGET_SCHED_REORDER): Define.\n+\t(TARGET_SCHED_VARIABLE_ISSUE): Define.\n+\t(mips_adjust_cost): Move later in file, next to other sched hooks.\n+\t(mips_macc_chains_last_hilo): New variable.\n+\t(mips_linked_madd_p, mips_macc_chains_record, mips_macc_chains_reorder)\n+\t(mips_promote_ready, mips_sched_reorder, mips_variable_issue): New.\n+\t* config/mips/mips.md (may_clobber_hilo): New attribute.\n+\n 2004-04-24  Roger Sayle  <roger@eyesopen.com>\n \t    Bruce Korb  <bkorb@gnu.org>\n "}, {"sha": "f3b7bdbed7718f8699418a6335a8395785e96314", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=39ba1719f70b31b0793b23d1d43e56d55181c44e", "patch": "@@ -201,6 +201,7 @@ extern const char *mips_output_conditional_branch (rtx, rtx *, int, int,\n \t\t\t\t\t\t   int, int);\n extern const char *mips_output_division (const char *, rtx *);\n extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n+extern bool mips_linked_madd_p (rtx, rtx);\n extern const char *mips_emit_prefetch (rtx *);\n \n extern void irix_asm_output_align (FILE *, unsigned);"}, {"sha": "bbb664ec0b9b2161c9078d6b01146416c8596973", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 144, "deletions": 15, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=39ba1719f70b31b0793b23d1d43e56d55181c44e", "patch": "@@ -226,9 +226,14 @@ static bool mips_strict_matching_cpu_name_p (const char *, const char *);\n static bool mips_matching_cpu_name_p (const char *, const char *);\n static const struct mips_cpu_info *mips_parse_cpu (const char *, const char *);\n static const struct mips_cpu_info *mips_cpu_info_from_isa (int);\n-static int mips_adjust_cost (rtx, rtx, rtx, int);\n static bool mips_return_in_memory (tree, tree);\n static bool mips_strict_argument_naming (CUMULATIVE_ARGS *);\n+static void mips_macc_chains_record (rtx);\n+static void mips_macc_chains_reorder (rtx *, int);\n+static void mips_promote_ready (rtx *, int, int);\n+static int mips_sched_reorder (FILE *, int, rtx *, int *, int);\n+static int mips_variable_issue (FILE *, int, rtx, int);\n+static int mips_adjust_cost (rtx, rtx, rtx, int);\n static int mips_issue_rate (void);\n static int mips_use_dfa_pipeline_interface (void);\n static int mips_multipass_dfa_lookahead (void);\n@@ -670,6 +675,10 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #undef TARGET_ASM_SELECT_RTX_SECTION\n #define TARGET_ASM_SELECT_RTX_SECTION mips_select_rtx_section\n \n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER mips_sched_reorder\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE mips_variable_issue\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST mips_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n@@ -9152,20 +9161,6 @@ mips_cpu_info_from_isa (int isa)\n   return 0;\n }\n \f\n-/* Adjust the cost of INSN based on the relationship between INSN that\n-   is dependent on DEP_INSN through the dependence LINK.  The default\n-   is to make no adjustment to COST.\n-\n-   On the MIPS, ignore the cost of anti- and output-dependencies.  */\n-static int\n-mips_adjust_cost (rtx insn ATTRIBUTE_UNUSED, rtx link,\n-\t\t  rtx dep ATTRIBUTE_UNUSED, int cost)\n-{\n-  if (REG_NOTE_KIND (link) != 0)\n-    return 0;\t/* Anti or output dependence.  */\n-  return cost;\n-}\n-\n /* Implement HARD_REGNO_NREGS.  The size of FP registers are controlled\n    by UNITS_PER_FPREG.  All other registers are word sized.  */\n \n@@ -9200,6 +9195,140 @@ mips_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n   return !TARGET_OLDABI;\n }\n \f\n+/* Return true if INSN is a multiply-add or multiply-subtract\n+   instruction and PREV assigns to the accumulator operand.  */\n+\n+bool\n+mips_linked_madd_p (rtx prev, rtx insn)\n+{\n+  rtx x;\n+\n+  x = single_set (insn);\n+  if (x == 0)\n+    return false;\n+\n+  x = SET_SRC (x);\n+\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == MULT\n+      && reg_set_p (XEXP (x, 1), prev))\n+    return true;\n+\n+  if (GET_CODE (x) == MINUS\n+      && GET_CODE (XEXP (x, 1)) == MULT\n+      && reg_set_p (XEXP (x, 0), prev))\n+    return true;\n+\n+  return false;\n+}\n+\f\n+/* Used by TUNE_MACC_CHAINS to record the last scheduled instruction\n+   that may clobber hi or lo.  */\n+\n+static rtx mips_macc_chains_last_hilo;\n+\n+/* A TUNE_MACC_CHAINS helper function.  Record that instruction INSN has\n+   been scheduled, updating mips_macc_chains_last_hilo appropriately.  */\n+\n+static void\n+mips_macc_chains_record (rtx insn)\n+{\n+  if (get_attr_may_clobber_hilo (insn))\n+    mips_macc_chains_last_hilo = insn;\n+}\n+\n+/* A TUNE_MACC_CHAINS helper function.  Search ready queue READY, which\n+   has NREADY elements, looking for a multiply-add or multiply-subtract\n+   instruction that is cumulative with mips_macc_chains_last_hilo.\n+   If there is one, promote it ahead of anything else that might\n+   clobber hi or lo.  */\n+\n+static void\n+mips_macc_chains_reorder (rtx *ready, int nready)\n+{\n+  int i, j;\n+\n+  if (mips_macc_chains_last_hilo != 0)\n+    for (i = nready - 1; i >= 0; i--)\n+      if (mips_linked_madd_p (mips_macc_chains_last_hilo, ready[i]))\n+\t{\n+\t  for (j = nready - 1; j > i; j--)\n+\t    if (recog_memoized (ready[j]) >= 0\n+\t\t&& get_attr_may_clobber_hilo (ready[j]))\n+\t      {\n+\t\tmips_promote_ready (ready, i, j);\n+\t\tbreak;\n+\t      }\n+\t  break;\n+\t}\n+}\n+\f\n+/* Remove the instruction at index LOWER from ready queue READY and\n+   reinsert it in front of the instruction at index HIGHER.  LOWER must\n+   be <= HIGHER.  */\n+\n+static void\n+mips_promote_ready (rtx *ready, int lower, int higher)\n+{\n+  rtx new_head;\n+  int i;\n+\n+  new_head = ready[lower];\n+  for (i = lower; i < higher; i++)\n+    ready[i] = ready[i + 1];\n+  ready[i] = new_head;\n+}\n+\n+/* Implement TARGET_SCHED_REORDER.  */\n+\n+static int\n+mips_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n+\t\t    rtx *ready, int *nreadyp, int cycle)\n+{\n+  if (!reload_completed && TUNE_MACC_CHAINS)\n+    {\n+      if (cycle == 0)\n+\tmips_macc_chains_last_hilo = 0;\n+      if (*nreadyp > 0)\n+\tmips_macc_chains_reorder (ready, *nreadyp);\n+    }\n+  return mips_issue_rate ();\n+}\n+\n+/* Implement TARGET_SCHED_VARIABLE_ISSUE.  */\n+\n+static int\n+mips_variable_issue (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n+\t\t     rtx insn, int more)\n+{\n+  switch (GET_CODE (PATTERN (insn)))\n+    {\n+    case USE:\n+    case CLOBBER:\n+      /* Don't count USEs and CLOBBERs against the issue rate.  */\n+      break;\n+\n+    default:\n+      more--;\n+      if (!reload_completed && TUNE_MACC_CHAINS)\n+\tmips_macc_chains_record (insn);\n+      break;\n+    }\n+  return more;\n+}\n+\f\n+/* Implement TARGET_SCHED_ADJUST_COST.  We assume that anti and output\n+   dependencies have no cost.  */\n+\n+static int\n+mips_adjust_cost (rtx insn ATTRIBUTE_UNUSED, rtx link,\n+\t\t  rtx dep ATTRIBUTE_UNUSED, int cost)\n+{\n+  if (REG_NOTE_KIND (link) != 0)\n+    return 0;\n+  return cost;\n+}\n+\n /* Return the number of instructions that can be issued per cycle.  */\n \n static int"}, {"sha": "e678ba984494de0590df7572ad9549e8d17c9fb7", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=39ba1719f70b31b0793b23d1d43e56d55181c44e", "patch": "@@ -340,6 +340,39 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TUNE_MIPS9000               (mips_tune == PROCESSOR_R9000)\n #define TUNE_SB1                    (mips_tune == PROCESSOR_SB1)\n \n+/* True if the pre-reload scheduler should try to create chains of\n+   multiply-add or multiply-subtract instructions.  For example,\n+   suppose we have:\n+\n+\tt1 = a * b\n+\tt2 = t1 + c * d\n+\tt3 = c * d\n+\tt4 = t3 - c * d\n+\n+   t1 will have a higher priority and t2 and t3 will have a higher\n+   priority than t4.  However, before reload, there is no dependence\n+   between t1 and t3, and they can often have similar priorities.\n+   The scheduler will then tend to prefer:\n+\n+\tt1 = a * b\n+\tt3 = e * f\n+\tt2 = t1 + c * d\n+\tt4 = t3 - g * h\n+\n+   which stops us from making full use of macc/madd-style instructions.\n+   This sort of situation occurs frequently in Fourier transforms and\n+   in unrolled loops.\n+\n+   To counter this, the TUNE_MACC_CHAINS code will reorder the ready\n+   queue so that chained multiply-add and multiply-subtract instructions\n+   appear ahead of any other instruction that is likely to clobber lo.\n+   In the example above, if t2 and t3 become ready at the same time,\n+   the code ensures that t2 is scheduled first.\n+\n+   Multiply-accumulate instructions are a bigger win for some targets\n+   than others, so this macro is defined on an opt-in basis.  */\n+#define TUNE_MACC_CHAINS\t    TUNE_MIPS5500\n+\n #define TARGET_OLDABI\t\t    (mips_abi == ABI_32 || mips_abi == ABI_O64)\n #define TARGET_NEWABI\t\t    (mips_abi == ABI_N32 || mips_abi == ABI_64)\n "}, {"sha": "d5071dd7da32858fdb125e5dc25623ee4bad4116", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba1719f70b31b0793b23d1d43e56d55181c44e/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=39ba1719f70b31b0793b23d1d43e56d55181c44e", "patch": "@@ -277,6 +277,13 @@\n \t\t (const_string \"yes\")\n \t\t (const_string \"no\"))))\n \n+;; True if an instruction might assign to hi or lo when reloaded.\n+;; This is used by the TUNE_MACC_CHAINS code.\n+(define_attr \"may_clobber_hilo\" \"no,yes\"\n+  (if_then_else (eq_attr \"type\" \"imul,imadd,idiv,mthilo\")\n+\t\t(const_string \"yes\")\n+\t\t(const_string \"no\")))\n+\n ;; Describe a user's asm statement.\n (define_asm_attributes\n   [(set_attr \"type\" \"multi\")])"}]}