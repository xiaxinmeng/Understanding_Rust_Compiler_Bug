{"sha": "2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ4YzZkYzFkOWNjNjdiNTM1ZTcwYzZhY2U4NzFkMWE4ZjE1ODA1YQ==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2015-01-21T17:53:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-01-21T17:53:31Z"}, "message": "aarch64-protos.h (aarch64_simd_disambiguate_copy): Declare.\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_simd_disambiguate_copy):\n\tDeclare.\n\t* config/aarch64/aarch64.c (aarch64_classify_address): Allow extra\n\taddressing modes for BE.\n\t(aarch64_print_operand): Add 'R' specifier.\n\t(aarch64_simd_disambiguate_copy): Delete.\n\t(aarch64_simd_emit_reg_reg_move): New function.\n\t* config/aarch64/aarch64-simd.md: Use aarch64_simd_emit_reg_reg_move\n\tin define_splits for structural moves.\n\t(mov<mode>): Use less restrictive predicates.\n\t(*aarch64_mov<mode>): Simplify and only allow for LE.\n\t(*aarch64_be_movoi, *aarch64_be_movci, *aarch64_be_movxi): New.\n\nFrom-SVN: r219958", "tree": {"sha": "dbe19aea743f42a91641e24f740f29cca9bfac5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbe19aea743f42a91641e24f740f29cca9bfac5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ab41c76dd2db2e2880a17eb4e6d760a087dfa45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ab41c76dd2db2e2880a17eb4e6d760a087dfa45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ab41c76dd2db2e2880a17eb4e6d760a087dfa45"}], "stats": {"total": 286, "additions": 176, "deletions": 110}, "files": [{"sha": "988097b35231f01a926d2255c6bbb63871925c84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "patch": "@@ -1,3 +1,18 @@\n+2015-01-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_simd_disambiguate_copy):\n+\tDeclare.\n+\t* config/aarch64/aarch64.c (aarch64_classify_address): Allow extra\n+\taddressing modes for BE.\n+\t(aarch64_print_operand): Add 'R' specifier.\n+\t(aarch64_simd_disambiguate_copy): Delete.\n+\t(aarch64_simd_emit_reg_reg_move): New function.\n+\t* config/aarch64/aarch64-simd.md: Use aarch64_simd_emit_reg_reg_move\n+\tin define_splits for structural moves.\n+\t(mov<mode>): Use less restrictive predicates.\n+\t(*aarch64_mov<mode>): Simplify and only allow for LE.\n+\t(*aarch64_be_movoi, *aarch64_be_movci, *aarch64_be_movxi): New.\n+\n 2015-01-21  Alan Hayward  <alan.hayward@arm.com>\n \n \t* rtlanal.c (subreg_get_info): Exit early for simple and common"}, {"sha": "165aa6bac505c25862041af4c9258783d0ec0d65", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "patch": "@@ -263,7 +263,7 @@ void aarch64_emit_call_insn (rtx);\n /* Initialize builtins for SIMD intrinsics.  */\n void init_aarch64_simd_builtins (void);\n \n-void aarch64_simd_disambiguate_copy (rtx *, rtx *, rtx *, unsigned int);\n+void aarch64_simd_emit_reg_reg_move (rtx *, enum machine_mode, unsigned int);\n \n /* Emit code to place a AdvSIMD pair result in memory locations (with equal\n    registers).  */"}, {"sha": "870054dee4bd9d4122630ddb0c7830872a899b28", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 96, "deletions": 79, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "patch": "@@ -158,19 +158,10 @@\n   \"TARGET_SIMD && reload_completed\n    && GP_REGNUM_P (REGNO (operands[0]))\n    && GP_REGNUM_P (REGNO (operands[1]))\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 2) (match_dup 3))]\n+  [(const_int 0)]\n {\n-  int rdest = REGNO (operands[0]);\n-  int rsrc = REGNO (operands[1]);\n-  rtx dest[2], src[2];\n-\n-  dest[0] = gen_rtx_REG (DImode, rdest);\n-  src[0] = gen_rtx_REG (DImode, rsrc);\n-  dest[1] = gen_rtx_REG (DImode, rdest + 1);\n-  src[1] = gen_rtx_REG (DImode, rsrc + 1);\n-\n-  aarch64_simd_disambiguate_copy (operands, dest, src, 2);\n+  aarch64_simd_emit_reg_reg_move (operands, DImode, 2);\n+  DONE;\n })\n \n (define_split\n@@ -4051,8 +4042,8 @@\n ;; Reload patterns for AdvSIMD register list operands.\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:VSTRUCT 0 \"aarch64_simd_nonimmediate_operand\" \"\")\n-\t(match_operand:VSTRUCT 1 \"aarch64_simd_general_operand\" \"\"))]\n+  [(set (match_operand:VSTRUCT 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:VSTRUCT 1 \"general_operand\" \"\"))]\n   \"TARGET_SIMD\"\n {\n   if (can_create_pseudo_p ())\n@@ -4064,22 +4055,16 @@\n \n (define_insn \"*aarch64_mov<mode>\"\n   [(set (match_operand:VSTRUCT 0 \"aarch64_simd_nonimmediate_operand\" \"=w,Utv,w\")\n-\t(match_operand:VSTRUCT 1 \"aarch64_simd_general_operand\"\t\" w,w,Utv\"))]\n-  \"TARGET_SIMD\n+\t(match_operand:VSTRUCT 1 \"aarch64_simd_general_operand\" \" w,w,Utv\"))]\n+  \"TARGET_SIMD && !BYTES_BIG_ENDIAN\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n-\n-{\n-  switch (which_alternative)\n-    {\n-    case 0: return \"#\";\n-    case 1: return \"st1\\\\t{%S1.16b - %<Vendreg>1.16b}, %0\";\n-    case 2: return \"ld1\\\\t{%S0.16b - %<Vendreg>0.16b}, %1\";\n-    default: gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"neon_move,neon_store<nregs>_<nregs>reg_q,\\\n-                     neon_load<nregs>_<nregs>reg_q\")\n+  \"@\n+   #\n+   st1\\\\t{%S1.16b - %<Vendreg>1.16b}, %0\n+   ld1\\\\t{%S0.16b - %<Vendreg>0.16b}, %1\"\n+  [(set_attr \"type\" \"multiple,neon_store<nregs>_<nregs>reg_q,\\\n+\t\t     neon_load<nregs>_<nregs>reg_q\")\n    (set (attr \"length\") (symbol_ref \"aarch64_simd_attr_length_move (insn)\"))]\n )\n \n@@ -4101,70 +4086,102 @@\n   [(set_attr \"type\" \"neon_store1_1reg<q>\")]\n )\n \n+(define_insn \"*aarch64_be_movoi\"\n+  [(set (match_operand:OI 0 \"nonimmediate_operand\" \"=w,m,w\")\n+\t(match_operand:OI 1 \"general_operand\"      \" w,w,m\"))]\n+  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+   && (register_operand (operands[0], OImode)\n+       || register_operand (operands[1], OImode))\"\n+  \"@\n+   #\n+   stp\\\\t%q1, %R1, %0\n+   ldp\\\\t%q0, %R0, %1\"\n+  [(set_attr \"type\" \"multiple,neon_store2_2reg_q,neon_load2_2reg_q\")\n+   (set (attr \"length\") (symbol_ref \"aarch64_simd_attr_length_move (insn)\"))]\n+)\n+\n+(define_insn \"*aarch64_be_movci\"\n+  [(set (match_operand:CI 0 \"nonimmediate_operand\" \"=w,o,w\")\n+\t(match_operand:CI 1 \"general_operand\"      \" w,w,o\"))]\n+  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+   && (register_operand (operands[0], CImode)\n+       || register_operand (operands[1], CImode))\"\n+  \"#\"\n+  [(set_attr \"type\" \"multiple\")\n+   (set (attr \"length\") (symbol_ref \"aarch64_simd_attr_length_move (insn)\"))]\n+)\n+\n+(define_insn \"*aarch64_be_movxi\"\n+  [(set (match_operand:XI 0 \"nonimmediate_operand\" \"=w,o,w\")\n+\t(match_operand:XI 1 \"general_operand\"      \" w,w,o\"))]\n+  \"TARGET_SIMD && BYTES_BIG_ENDIAN\n+   && (register_operand (operands[0], XImode)\n+       || register_operand (operands[1], XImode))\"\n+  \"#\"\n+  [(set_attr \"type\" \"multiple\")\n+   (set (attr \"length\") (symbol_ref \"aarch64_simd_attr_length_move (insn)\"))]\n+)\n+\n (define_split\n-  [(set (match_operand:OI 0 \"register_operand\" \"\")\n-\t(match_operand:OI 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:OI 0 \"register_operand\")\n+\t(match_operand:OI 1 \"register_operand\"))]\n   \"TARGET_SIMD && reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 2) (match_dup 3))]\n+  [(const_int 0)]\n {\n-  int rdest = REGNO (operands[0]);\n-  int rsrc = REGNO (operands[1]);\n-  rtx dest[2], src[2];\n-\n-  dest[0] = gen_rtx_REG (TFmode, rdest);\n-  src[0] = gen_rtx_REG (TFmode, rsrc);\n-  dest[1] = gen_rtx_REG (TFmode, rdest + 1);\n-  src[1] = gen_rtx_REG (TFmode, rsrc + 1);\n-\n-  aarch64_simd_disambiguate_copy (operands, dest, src, 2);\n+  aarch64_simd_emit_reg_reg_move (operands, TImode, 2);\n+  DONE;\n })\n \n (define_split\n-  [(set (match_operand:CI 0 \"register_operand\" \"\")\n-\t(match_operand:CI 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:CI 0 \"nonimmediate_operand\")\n+\t(match_operand:CI 1 \"general_operand\"))]\n   \"TARGET_SIMD && reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))]\n+  [(const_int 0)]\n {\n-  int rdest = REGNO (operands[0]);\n-  int rsrc = REGNO (operands[1]);\n-  rtx dest[3], src[3];\n-\n-  dest[0] = gen_rtx_REG (TFmode, rdest);\n-  src[0] = gen_rtx_REG (TFmode, rsrc);\n-  dest[1] = gen_rtx_REG (TFmode, rdest + 1);\n-  src[1] = gen_rtx_REG (TFmode, rsrc + 1);\n-  dest[2] = gen_rtx_REG (TFmode, rdest + 2);\n-  src[2] = gen_rtx_REG (TFmode, rsrc + 2);\n-\n-  aarch64_simd_disambiguate_copy (operands, dest, src, 3);\n+  if (register_operand (operands[0], CImode)\n+      && register_operand (operands[1], CImode))\n+    {\n+      aarch64_simd_emit_reg_reg_move (operands, TImode, 3);\n+      DONE;\n+    }\n+  else if (BYTES_BIG_ENDIAN)\n+    {\n+      emit_move_insn (simplify_gen_subreg (OImode, operands[0], CImode, 0),\n+\t\t      simplify_gen_subreg (OImode, operands[1], CImode, 0));\n+      emit_move_insn (gen_lowpart (V16QImode,\n+\t\t\t\t   simplify_gen_subreg (TImode, operands[0],\n+\t\t\t\t\t\t\tCImode, 32)),\n+\t\t      gen_lowpart (V16QImode,\n+\t\t\t\t   simplify_gen_subreg (TImode, operands[1],\n+\t\t\t\t\t\t\tCImode, 32)));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n })\n \n (define_split\n-  [(set (match_operand:XI 0 \"register_operand\" \"\")\n-\t(match_operand:XI 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:XI 0 \"nonimmediate_operand\")\n+\t(match_operand:XI 1 \"general_operand\"))]\n   \"TARGET_SIMD && reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (match_dup 5))\n-   (set (match_dup 6) (match_dup 7))]\n+  [(const_int 0)]\n {\n-  int rdest = REGNO (operands[0]);\n-  int rsrc = REGNO (operands[1]);\n-  rtx dest[4], src[4];\n-\n-  dest[0] = gen_rtx_REG (TFmode, rdest);\n-  src[0] = gen_rtx_REG (TFmode, rsrc);\n-  dest[1] = gen_rtx_REG (TFmode, rdest + 1);\n-  src[1] = gen_rtx_REG (TFmode, rsrc + 1);\n-  dest[2] = gen_rtx_REG (TFmode, rdest + 2);\n-  src[2] = gen_rtx_REG (TFmode, rsrc + 2);\n-  dest[3] = gen_rtx_REG (TFmode, rdest + 3);\n-  src[3] = gen_rtx_REG (TFmode, rsrc + 3);\n-\n-  aarch64_simd_disambiguate_copy (operands, dest, src, 4);\n+  if (register_operand (operands[0], XImode)\n+      && register_operand (operands[1], XImode))\n+    {\n+      aarch64_simd_emit_reg_reg_move (operands, TImode, 4);\n+      DONE;\n+    }\n+  else if (BYTES_BIG_ENDIAN)\n+    {\n+      emit_move_insn (simplify_gen_subreg (OImode, operands[0], XImode, 0),\n+\t\t      simplify_gen_subreg (OImode, operands[1], XImode, 0));\n+      emit_move_insn (simplify_gen_subreg (OImode, operands[0], XImode, 32),\n+\t\t      simplify_gen_subreg (OImode, operands[1], XImode, 32));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n })\n \n (define_expand \"aarch64_ld2r<mode>\""}, {"sha": "d7310d95e34c6dede05003f92176411d4cf48356", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 64, "deletions": 30, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2d8c6dc1d9cc67b535e70c6ace871d1a8f15805a", "patch": "@@ -3424,12 +3424,20 @@ aarch64_classify_address (struct aarch64_address_info *info,\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx op0, op1;\n+\n+  /* On BE, we use load/store pair for all large int mode load/stores.  */\n+  bool load_store_pair_p = (outer_code == PARALLEL\n+\t\t\t    || (BYTES_BIG_ENDIAN\n+\t\t\t\t&& aarch64_vect_struct_mode_p (mode)));\n+\n   bool allow_reg_index_p =\n-    outer_code != PARALLEL && (GET_MODE_SIZE (mode) != 16\n-\t\t\t       || aarch64_vector_mode_supported_p (mode));\n-  /* Don't support anything other than POST_INC or REG addressing for\n-     AdvSIMD.  */\n-  if (aarch64_vect_struct_mode_p (mode)\n+    !load_store_pair_p\n+    && (GET_MODE_SIZE (mode) != 16 || aarch64_vector_mode_supported_p (mode))\n+    && !aarch64_vect_struct_mode_p (mode);\n+\n+  /* On LE, for AdvSIMD, don't support anything other than POST_INC or\n+     REG addressing.  */\n+  if (aarch64_vect_struct_mode_p (mode) && !BYTES_BIG_ENDIAN\n       && (code != POST_INC && code != REG))\n     return false;\n \n@@ -3481,7 +3489,29 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t    return (aarch64_offset_7bit_signed_scaled_p (mode, offset)\n \t\t    && offset_9bit_signed_unscaled_p (mode, offset));\n \n-\t  if (outer_code == PARALLEL)\n+\t  /* A 7bit offset check because OImode will emit a ldp/stp\n+\t     instruction (only big endian will get here).\n+\t     For ldp/stp instructions, the offset is scaled for the size of a\n+\t     single element of the pair.  */\n+\t  if (mode == OImode)\n+\t    return aarch64_offset_7bit_signed_scaled_p (TImode, offset);\n+\n+\t  /* Three 9/12 bit offsets checks because CImode will emit three\n+\t     ldr/str instructions (only big endian will get here).  */\n+\t  if (mode == CImode)\n+\t    return (aarch64_offset_7bit_signed_scaled_p (TImode, offset)\n+\t\t    && (offset_9bit_signed_unscaled_p (V16QImode, offset + 32)\n+\t\t\t|| offset_12bit_unsigned_scaled_p (V16QImode,\n+\t\t\t\t\t\t\t   offset + 32)));\n+\n+\t  /* Two 7bit offsets checks because XImode will emit two ldp/stp\n+\t     instructions (only big endian will get here).  */\n+\t  if (mode == XImode)\n+\t    return (aarch64_offset_7bit_signed_scaled_p (TImode, offset)\n+\t\t    && aarch64_offset_7bit_signed_scaled_p (TImode,\n+\t\t\t\t\t\t\t    offset + 32));\n+\n+\t  if (load_store_pair_p)\n \t    return ((GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n \t\t    && aarch64_offset_7bit_signed_scaled_p (mode, offset));\n \t  else\n@@ -3541,7 +3571,7 @@ aarch64_classify_address (struct aarch64_address_info *info,\n \t    return (aarch64_offset_7bit_signed_scaled_p (mode, offset)\n \t\t    && offset_9bit_signed_unscaled_p (mode, offset));\n \n-\t  if (outer_code == PARALLEL)\n+\t  if (load_store_pair_p)\n \t    return ((GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n \t\t    && aarch64_offset_7bit_signed_scaled_p (mode, offset));\n \t  else\n@@ -3555,7 +3585,8 @@ aarch64_classify_address (struct aarch64_address_info *info,\n       /* load literal: pc-relative constant pool entry.  Only supported\n          for SI mode or larger.  */\n       info->type = ADDRESS_SYMBOLIC;\n-      if (outer_code != PARALLEL && GET_MODE_SIZE (mode) >= 4)\n+\n+      if (!load_store_pair_p && GET_MODE_SIZE (mode) >= 4)\n \t{\n \t  rtx sym, addend;\n \n@@ -4208,6 +4239,16 @@ aarch64_print_operand (FILE *f, rtx x, char code)\n       asm_fprintf (f, \"v%d\", REGNO (x) - V0_REGNUM + (code - 'S'));\n       break;\n \n+    case 'R':\n+      /* Print a scalar FP/SIMD register name + 1.  */\n+      if (!REG_P (x) || !FP_REGNUM_P (REGNO (x)))\n+\t{\n+\t  output_operand_lossage (\"incompatible floating point / vector register operand for '%%%c'\", code);\n+\t  return;\n+\t}\n+      asm_fprintf (f, \"q%d\", REGNO (x) - V0_REGNUM + 1);\n+      break;\n+\n     case 'X':\n       /* Print bottom 16 bits of integer constant in hex.  */\n       if (!CONST_INT_P (x))\n@@ -8595,35 +8636,28 @@ aarch64_simd_mem_operand_p (rtx op)\n \t\t\t|| REG_P (XEXP (op, 0)));\n }\n \n-/* Set up OPERANDS for a register copy from SRC to DEST, taking care\n-   not to early-clobber SRC registers in the process.\n+/* Emit a register copy from operand to operand, taking care not to\n+   early-clobber source registers in the process.\n \n-   We assume that the operands described by SRC and DEST represent a\n-   decomposed copy of OPERANDS[1] into OPERANDS[0].  COUNT is the\n-   number of components into which the copy has been decomposed.  */\n+   COUNT is the number of components into which the copy needs to be\n+   decomposed.  */\n void\n-aarch64_simd_disambiguate_copy (rtx *operands, rtx *dest,\n-\t\t\t\trtx *src, unsigned int count)\n+aarch64_simd_emit_reg_reg_move (rtx *operands, enum machine_mode mode,\n+\t\t\t\tunsigned int count)\n {\n   unsigned int i;\n+  int rdest = REGNO (operands[0]);\n+  int rsrc = REGNO (operands[1]);\n \n   if (!reg_overlap_mentioned_p (operands[0], operands[1])\n-      || REGNO (operands[0]) < REGNO (operands[1]))\n-    {\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  operands[2 * i] = dest[i];\n-\t  operands[2 * i + 1] = src[i];\n-\t}\n-    }\n+      || rdest < rsrc)\n+    for (i = 0; i < count; i++)\n+      emit_move_insn (gen_rtx_REG (mode, rdest + i),\n+\t\t      gen_rtx_REG (mode, rsrc + i));\n   else\n-    {\n-      for (i = 0; i < count; i++)\n-\t{\n-\t  operands[2 * i] = dest[count - i - 1];\n-\t  operands[2 * i + 1] = src[count - i - 1];\n-\t}\n-    }\n+    for (i = 0; i < count; i++)\n+      emit_move_insn (gen_rtx_REG (mode, rdest + count - i - 1),\n+\t\t      gen_rtx_REG (mode, rsrc + count - i - 1));\n }\n \n /* Compute and return the length of aarch64_simd_mov<mode>, where <mode> is"}]}