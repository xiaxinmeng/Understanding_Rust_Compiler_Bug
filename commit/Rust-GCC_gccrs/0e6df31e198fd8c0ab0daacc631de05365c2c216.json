{"sha": "0e6df31e198fd8c0ab0daacc631de05365c2c216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU2ZGYzMWUxOThmZDhjMGFiMGRhYWNjNjMxZGUwNTM2NWMyYzIxNg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-08-05T05:52:01Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-08-05T05:52:01Z"}, "message": "re PR c/14516 (-fleading-underscore does not work correctly for file static variables)\n\n2004-08-04  Geoffrey Keating  <geoffk@apple.com>\n\n\tPR 14516\n\t* c-common.c (c_expand_decl): Don't special-case static VAR_DECLs.\n\t* c-common.h (make_rtl_for_local_static): Delete.\n\t* c-decl.c (shadow_tag_warned): Clean up comment.\n\t(finish_decl): Clean up spacing.  Use set_user_assembler_name when\n\tappropriate.  Don't pass asmspec to rest_of_decl_compilation.\n\t* c-semantics.c (make_rtl_for_local_static): Delete.\n\t* expr.c (init_block_move_fn): Use set_user_assembler_name.\n\t(init_block_clear_fn): Likewise.\n\t* passes.c (rest_of_decl_compilation): Remove asmspec parameter,\n\texpect it to be in DECL_ASSEMBLER_NAME.  Update callers in many files.\n\t* toplev.h (rest_of_decl_compilation): Remove asmspec parameter.\n\t* tree.h (make_decl_rtl): Remove second parameter.\n\t(set_user_assembler_name): New.\n\t* varasm.c (set_user_assembler_name): New.\n\t(make_decl_rtl): Remove second parameter.  Update callers in many\n\tfiles.\n\nIndex: cp/ChangeLog\n2004-08-04  Geoffrey Keating  <geoffk@apple.com>\n\n\t* decl.c (make_rtl_for_nonlocal_decl): Set DECL_ASSEMBLER_NAME rather\n\tthan passing it as a parameter to rest_of_decl_compilation.\n\t* decl2.c (grokfield): Use set_user_assembler_name.\n\nFrom-SVN: r85593", "tree": {"sha": "dd22110790902e6a0fb0065c11210552323ea19e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd22110790902e6a0fb0065c11210552323ea19e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e6df31e198fd8c0ab0daacc631de05365c2c216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6df31e198fd8c0ab0daacc631de05365c2c216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6df31e198fd8c0ab0daacc631de05365c2c216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6df31e198fd8c0ab0daacc631de05365c2c216/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99b1c586a59f235bb36457739f40ffe98fb18b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b1c586a59f235bb36457739f40ffe98fb18b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b1c586a59f235bb36457739f40ffe98fb18b66"}], "stats": {"total": 482, "additions": 216, "deletions": 266}, "files": [{"sha": "47916a6b899696962cb5cee44946afcf2dbac078", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1,3 +1,23 @@\n+2004-08-04  Geoffrey Keating  <geoffk@apple.com>\n+\n+\tPR 14516\n+\t* c-common.c (c_expand_decl): Don't special-case static VAR_DECLs.\n+\t* c-common.h (make_rtl_for_local_static): Delete.\n+\t* c-decl.c (shadow_tag_warned): Clean up comment.\n+\t(finish_decl): Clean up spacing.  Use set_user_assembler_name when\n+\tappropriate.  Don't pass asmspec to rest_of_decl_compilation.\n+\t* c-semantics.c (make_rtl_for_local_static): Delete.\n+\t* expr.c (init_block_move_fn): Use set_user_assembler_name.\n+\t(init_block_clear_fn): Likewise.\n+\t* passes.c (rest_of_decl_compilation): Remove asmspec parameter,\n+\texpect it to be in DECL_ASSEMBLER_NAME.  Update callers in many files.\n+\t* toplev.h (rest_of_decl_compilation): Remove asmspec parameter.\n+\t* tree.h (make_decl_rtl): Remove second parameter.\n+\t(set_user_assembler_name): New.\n+\t* varasm.c (set_user_assembler_name): New.\n+\t(make_decl_rtl): Remove second parameter.  Update callers in many\n+\tfiles.\n+\n 2004-08-05  Adam Nemet  <anemet@lnxw.com>\n \n \t* config.gcc (case i[34567]86-*-lynxos*): Update to LynxOS 4.0."}, {"sha": "262c19f9cf04894ec0c53286729f00c569d0fa64", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1270,7 +1270,7 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n   else if (code != ENUMERAL_TYPE && code != RECORD_TYPE\n       && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n \t   && TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n-    rest_of_decl_compilation (type_decl, NULL, global_bindings_p (), 0);\n+    rest_of_decl_compilation (type_decl, global_bindings_p (), 0);\n \n   if (!TYPE_IS_DUMMY_P (type))\n     gnat_pushdecl (type_decl, gnat_node);\n@@ -1354,7 +1354,7 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n     TREE_ADDRESSABLE (var_decl) = 1;\n \n   if (TREE_CODE (var_decl) != CONST_DECL)\n-    rest_of_decl_compilation (var_decl, 0, global_bindings_p (), 0);\n+    rest_of_decl_compilation (var_decl, global_bindings_p (), 0);\n \n   return var_decl;\n }\n@@ -1707,7 +1707,7 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n   gnat_pushdecl (subprog_decl, gnat_node);\n \n   /* Output the assembler code and/or RTL for the declaration.  */\n-  rest_of_decl_compilation (subprog_decl, 0, global_bindings_p (), 0);\n+  rest_of_decl_compilation (subprog_decl, global_bindings_p (), 0);\n \n   return subprog_decl;\n }\n@@ -2542,7 +2542,7 @@ update_pointer_to (tree old_type, tree new_type)\n \t    if (TYPE_NAME (ptr1)\n \t\t&& TREE_CODE (TYPE_NAME (ptr1)) == TYPE_DECL\n \t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\t      rest_of_decl_compilation (TYPE_NAME (ptr1), NULL,\n+\t      rest_of_decl_compilation (TYPE_NAME (ptr1),\n \t\t\t\t\tglobal_bindings_p (), 0);\n \t  }\n \n@@ -2555,7 +2555,7 @@ update_pointer_to (tree old_type, tree new_type)\n \t    if (TYPE_NAME (ref1)\n \t\t&& TREE_CODE (TYPE_NAME (ref1)) == TYPE_DECL\n \t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\t      rest_of_decl_compilation (TYPE_NAME (ref1), NULL,\n+\t      rest_of_decl_compilation (TYPE_NAME (ref1),\n \t\t\t\t\tglobal_bindings_p (), 0);\n \t  }\n     }"}, {"sha": "5e5bbad319d0016a43175da5ca28ba60ca461f46", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -770,8 +770,6 @@ c_expand_decl (tree decl)\n         expand_anon_union_decl (decl, NULL_TREE,\n                                 DECL_ANON_UNION_ELEMS (decl));\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n-    make_rtl_for_local_static (decl);\n   else\n     return 0;\n "}, {"sha": "6b9bd7559c6f8915c13d33b5b05b2b3769b22b81", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -789,7 +789,6 @@ extern int anon_aggr_type_p (tree);\n   (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n \n extern void emit_local_var (tree);\n-extern void make_rtl_for_local_static (tree);\n extern tree do_case (tree, tree);\n extern tree build_stmt (enum tree_code, ...);\n extern tree build_case_label (tree, tree, tree);"}, {"sha": "ff535524c4e4f6a1c1e6990f1b2298f76dd491c9", "filename": "gcc/c-decl.c", "status": "modified", "additions": 61, "deletions": 71, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1714,7 +1714,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n       && (TREE_CODE (olddecl) == FUNCTION_DECL\n \t  || (TREE_CODE (olddecl) == VAR_DECL\n \t      && TREE_STATIC (olddecl))))\n-    make_decl_rtl (olddecl, NULL);\n+    make_decl_rtl (olddecl);\n }\n \n /* Handle when a new declaration NEWDECL has the same name as an old\n@@ -2117,7 +2117,7 @@ implicitly_declare (tree functionid)\n   decl = pushdecl (decl);\n \n   /* No need to call objc_check_decl here - it's a function type.  */\n-  rest_of_decl_compilation (decl, NULL, 0, 0);\n+  rest_of_decl_compilation (decl, 0, 0);\n \n   /* Write a record describing this implicit function declaration\n      to the prototypes file (if requested).  */\n@@ -2552,12 +2552,10 @@ shadow_tag (tree declspecs)\n   shadow_tag_warned (declspecs, 0);\n }\n \n+/* WARNED is 1 if we have done a pedwarn, 2 if we have done a warning,\n+   but no pedwarn.  */\n void\n shadow_tag_warned (tree declspecs, int warned)\n-\n-\n-     /* 1 => we have done a pedwarn.  2 => we have done a warning, but\n-\tno pedwarn.  */\n {\n   int found_tag = 0;\n   tree link;\n@@ -2895,8 +2893,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n     store_init_value (decl, init);\n \n   if (c_dialect_objc () && (TREE_CODE (decl) == VAR_DECL\n-\t\t    || TREE_CODE (decl) == FUNCTION_DECL\n-\t\t    || TREE_CODE (decl) == FIELD_DECL))\n+\t\t\t    || TREE_CODE (decl) == FUNCTION_DECL\n+\t\t\t    || TREE_CODE (decl) == FIELD_DECL))\n     objc_check_decl (decl);\n \n   /* Deduce size of array from initialization, if not already known.  */\n@@ -2937,7 +2935,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t in the array, because we start counting at zero.  Therefore,\n \t warn only if the value is less than zero.  */\n       else if (pedantic && TYPE_DOMAIN (type) != 0\n-\t      && tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < 0)\n+\t       && tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < 0)\n \terror (\"%Jzero or negative size array '%D'\", decl, decl);\n \n       layout_decl (decl, 0);\n@@ -2953,22 +2951,20 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  /* Don't give an error if we already gave one earlier.  */\n \t  && TREE_TYPE (decl) != error_mark_node\n \t  && (TREE_STATIC (decl)\n-\t      ?\n-\t\t/* A static variable with an incomplete type\n-\t\t   is an error if it is initialized.\n-\t\t   Also if it is not file scope.\n-\t\t   Otherwise, let it through, but if it is not `extern'\n-\t\t   then it may cause an error message later.  */\n-\t\t(DECL_INITIAL (decl) != 0\n+\t      /* A static variable with an incomplete type\n+\t\t is an error if it is initialized.\n+\t\t Also if it is not file scope.\n+\t\t Otherwise, let it through, but if it is not `extern'\n+\t\t then it may cause an error message later.  */\n+\t      ? (DECL_INITIAL (decl) != 0\n \t\t || !DECL_FILE_SCOPE_P (decl))\n-\t      :\n-\t\t/* An automatic variable with an incomplete type\n-\t\t   is an error.  */\n-\t\t!DECL_EXTERNAL (decl)))\n-\t{\n-\t  error (\"%Jstorage size of '%D' isn't known\", decl, decl);\n-\t  TREE_TYPE (decl) = error_mark_node;\n-\t}\n+\t      /* An automatic variable with an incomplete type\n+\t\t is an error.  */\n+\t      : !DECL_EXTERNAL (decl)))\n+\t {\n+\t   error (\"%Jstorage size of '%D' isn't known\", decl, decl);\n+\t   TREE_TYPE (decl) = error_mark_node;\n+\t }\n \n       if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n \t  && DECL_SIZE (decl) != 0)\n@@ -2988,24 +2984,16 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n      was a normal built-in.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL && asmspec)\n     {\n-      /* ASMSPEC is given, and not the name of a register.  Mark the\n-      name with a star so assemble_name won't munge it.  */\n-      char *starred = (char *) alloca (strlen (asmspec) + 2);\n-      starred[0] = '*';\n-      strcpy (starred + 1, asmspec);\n-\n       if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n \t{\n \t  tree builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];\n-\t  SET_DECL_RTL (builtin, NULL_RTX);\n-\t  change_decl_assembler_name (builtin, get_identifier (starred));\n-\t  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMCPY)\n-\t    init_block_move_fn (starred);\n-\t  else if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMSET)\n-\t    init_block_clear_fn (starred);\n-\t}\n-      SET_DECL_RTL (decl, NULL_RTX);\n-      change_decl_assembler_name (decl, get_identifier (starred));\n+\t  set_user_assembler_name (builtin, asmspec);\n+\t   if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMCPY)\n+\t     init_block_move_fn (asmspec);\n+\t   else if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMSET)\n+\t     init_block_clear_fn (asmspec);\n+\t }\n+      set_user_assembler_name (decl, asmspec);\n     }\n \n   /* If #pragma weak was used, mark the decl weak now.  */\n@@ -3022,6 +3010,25 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       if (c_dialect_objc ())\n \tobjc_check_decl (decl);\n \n+      if (asmspec) \n+\t{\n+\t  /* If this is not a static variable, issue a warning.\n+\t     It doesn't make any sense to give an ASMSPEC for an\n+\t     ordinary, non-register local variable.  Historically,\n+\t     GCC has accepted -- but ignored -- the ASMSPEC in\n+\t     this case.  */\n+\t  if (! DECL_FILE_SCOPE_P (decl)\n+\t      && TREE_CODE (decl) == VAR_DECL\n+\t      && !C_DECL_REGISTER (decl)\n+\t      && !TREE_STATIC (decl))\n+\t    warning (\"%Jignoring asm-specifier for non-static local \"\n+\t\t     \"variable '%D'\", decl, decl);\n+\t  else if (C_DECL_REGISTER (decl))\n+\t    change_decl_assembler_name (decl, get_identifier (asmspec));\n+\t  else\n+\t    set_user_assembler_name (decl, asmspec);\n+\t}\n+      \n       if (DECL_FILE_SCOPE_P (decl))\n \t{\n \t  if (DECL_INITIAL (decl) == NULL_TREE\n@@ -3030,44 +3037,27 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t       when a tentative file-scope definition is seen.\n \t       But at end of compilation, do output code for them.  */\n \t    DECL_DEFER_OUTPUT (decl) = 1;\n-\t  rest_of_decl_compilation (decl, asmspec, true, 0);\n+\t  rest_of_decl_compilation (decl, true, 0);\n \t}\n       else\n \t{\n-\t  /* This is a local variable.  If there is an ASMSPEC, the\n-\t     user has requested that we handle it specially.  */\n-\t  if (asmspec)\n+\t  /* In conjunction with an ASMSPEC, the `register'\n+\t     keyword indicates that we should place the variable\n+\t     in a particular register.  */\n+\t  if (asmspec && C_DECL_REGISTER (decl))\n \t    {\n-\t      /* In conjunction with an ASMSPEC, the `register'\n-\t\t keyword indicates that we should place the variable\n-\t\t in a particular register.  */\n-\t      if (C_DECL_REGISTER (decl))\n-\t\t{\n-\t\t  DECL_HARD_REGISTER (decl) = 1;\n-\t\t  /* This cannot be done for a structure with volatile\n-\t\t     fields, on which DECL_REGISTER will have been\n-\t\t     reset.  */\n-\t\t  if (!DECL_REGISTER (decl))\n-\t\t    error (\"cannot put object with volatile field into register\");\n-\t\t}\n-\n-\t      /* If this is not a static variable, issue a warning.\n-\t\t It doesn't make any sense to give an ASMSPEC for an\n-\t\t ordinary, non-register local variable.  Historically,\n-\t\t GCC has accepted -- but ignored -- the ASMSPEC in\n-\t\t this case.  */\n-\t      if (TREE_CODE (decl) == VAR_DECL\n-\t\t  && !C_DECL_REGISTER (decl)\n-\t\t  && !TREE_STATIC (decl))\n-\t\twarning (\"%Jignoring asm-specifier for non-static local \"\n-                         \"variable '%D'\", decl, decl);\n-\t      else\n-\t\tchange_decl_assembler_name (decl, get_identifier (asmspec));\n+\t      DECL_HARD_REGISTER (decl) = 1;\n+\t      /* This cannot be done for a structure with volatile\n+\t\t fields, on which DECL_REGISTER will have been\n+\t\t reset.  */\n+\t      if (!DECL_REGISTER (decl))\n+\t\terror (\"cannot put object with volatile field into register\");\n \t    }\n \n \t  if (TREE_CODE (decl) != FUNCTION_DECL)\n \t    add_stmt (build_stmt (DECL_EXPR, decl));\n \t}\n+  \n \n       if (!DECL_FILE_SCOPE_P (decl))\n \t{\n@@ -3095,7 +3085,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n \tadd_stmt (build_stmt (DECL_EXPR, decl));\n \n-      rest_of_decl_compilation (decl, NULL, DECL_FILE_SCOPE_P (decl), 0);\n+      rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl), 0);\n     }\n \n   /* At the end of a declaration, throw away any variable type sizes\n@@ -3232,7 +3222,7 @@ build_compound_literal (tree type, tree init)\n       DECL_COMDAT (decl) = 1;\n       DECL_ARTIFICIAL (decl) = 1;\n       pushdecl (decl);\n-      rest_of_decl_compilation (decl, NULL, 1, 0);\n+      rest_of_decl_compilation (decl, 1, 0);\n     }\n \n   return complit;\n@@ -5408,7 +5398,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  layout_decl (decl, 0);\n \t  if (c_dialect_objc ())\n \t    objc_check_decl (decl);\n-\t  rest_of_decl_compilation (decl, NULL, toplevel, 0);\n+\t  rest_of_decl_compilation (decl, toplevel, 0);\n \t  if (! toplevel)\n \t    expand_decl (decl);\n \t}"}, {"sha": "f40f5a2e495a1927097c71cff0643e5adda776bb", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -195,41 +195,6 @@ build_stmt (enum tree_code code, ...)\n   return ret;\n }\n \n-/* Create RTL for the local static variable DECL.  */\n-\n-void\n-make_rtl_for_local_static (tree decl)\n-{\n-  const char *asmspec = NULL;\n-\n-  /* If we inlined this variable, we could see it's declaration\n-     again.  */\n-  if (TREE_ASM_WRITTEN (decl))\n-    return;\n-\n-  /* If the DECL_ASSEMBLER_NAME is not the same as the DECL_NAME, then\n-     either we already created RTL for this DECL (and since it was a\n-     local variable, its DECL_ASSEMBLER_NAME got hacked up to prevent\n-     clashes with other local statics with the same name by a previous\n-     call to make_decl_rtl), or the user explicitly requested a\n-     particular assembly name for this variable, using the GNU\n-     extension for this purpose:\n-\n-       int i asm (\"j\");\n-\n-     There's no way to know which case we're in, here.  But, it turns\n-     out we're safe.  If there's already RTL, then\n-     rest_of_decl_compilation ignores the ASMSPEC parameter, so we\n-     may as well not pass it in.  If there isn't RTL, then we didn't\n-     already create RTL, which means that the modification to\n-     DECL_ASSEMBLER_NAME came only via the explicit extension.  */\n-  if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl)\n-      && !DECL_RTL_SET_P (decl))\n-    asmspec = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-  rest_of_decl_compilation (decl, asmspec, /*top_level=*/0, /*at_end=*/0);\n-}\n-\n /* Let the back-end know about DECL.  */\n \n void\n@@ -241,9 +206,7 @@ emit_local_var (tree decl)\n       if (DECL_HARD_REGISTER (decl))\n \t/* The user specified an assembler name for this variable.\n \t   Set that up now.  */\n-\trest_of_decl_compilation\n-\t  (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n-\t   /*top_level=*/0, /*at_end=*/0);\n+\trest_of_decl_compilation (decl, 0, 0);\n       else\n \texpand_decl (decl);\n     }"}, {"sha": "9f17d437a66851b36142b9a65c86d83aec6e5696", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1,3 +1,9 @@\n+2004-08-04  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* decl.c (make_rtl_for_nonlocal_decl): Set DECL_ASSEMBLER_NAME rather\n+\tthan passing it as a parameter to rest_of_decl_compilation.\n+\t* decl2.c (grokfield): Use set_user_assembler_name.\n+\n 2004-08-04  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (complete_array_type): Don't gratuitously copy"}, {"sha": "194b3396db9c1abed3e58f8c047c6dff259322e7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -6516,7 +6516,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t    }\n \t  else\n \t    {\n-\t      rest_of_decl_compilation (var, NULL, /*toplev=*/1, at_eof);\n+\t      rest_of_decl_compilation (var, /*toplev=*/1, at_eof);\n \t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n \t\tstatic_aggregates = tree_cons (NULL_TREE, var,\n \t\t\t\t\t       static_aggregates);"}, {"sha": "665fd7abd165f253ae870c049dd8075e049a6916", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -3832,7 +3832,7 @@ build_clone (tree fn, tree name)\n \n   /* Create the RTL for this function.  */\n   SET_DECL_RTL (clone, NULL_RTX);\n-  rest_of_decl_compilation (clone, NULL, /*top_level=*/1, at_eof);\n+  rest_of_decl_compilation (clone, /*top_level=*/1, at_eof);\n   \n   /* Make it easy to find the CLONE given the FN.  */\n   TREE_CHAIN (clone) = TREE_CHAIN (fn);"}, {"sha": "9653436222609bc0da03fb92e21023d646a00200", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1954,7 +1954,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       && (TREE_CODE (olddecl) == FUNCTION_DECL\n \t  || (TREE_CODE (olddecl) == VAR_DECL\n \t      && TREE_STATIC (olddecl))))\n-    make_decl_rtl (olddecl, NULL);\n+    make_decl_rtl (olddecl);\n \n   return olddecl;\n }\n@@ -4512,10 +4512,25 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n   int toplev = toplevel_bindings_p ();\n   int defer_p;\n \n+  /* Set the DECL_ASSEMBLER_NAME for the object.  */\n+  if (asmspec)\n+    {\n+      /* The `register' keyword, when used together with an\n+\t asm-specification, indicates that the variable should be\n+\t placed in a particular register.  */\n+      if (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n+\t{\n+\t  change_decl_assembler_name (decl, get_identifier (asmspec));\n+\t  DECL_HARD_REGISTER (decl) = 1;\n+\t}\n+      else\n+\tset_user_assembler_name (decl, asmspec);\n+    }\n+\n   /* Handle non-variables up front.  */\n   if (TREE_CODE (decl) != VAR_DECL)\n     {\n-      rest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n+      rest_of_decl_compilation (decl, toplev, at_eof);\n       return;\n     }\n \n@@ -4530,17 +4545,6 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n \tmy_friendly_assert (DECL_EXTERNAL (decl), 20000723);\n     }\n \n-  /* Set the DECL_ASSEMBLER_NAME for the variable.  */\n-  if (asmspec)\n-    {\n-      change_decl_assembler_name (decl, get_identifier (asmspec));\n-      /* The `register' keyword, when used together with an\n-\t asm-specification, indicates that the variable should be\n-\t placed in a particular register.  */\n-      if (DECL_REGISTER (decl))\n-\tDECL_HARD_REGISTER (decl) = 1;\n-    }\n-\n   /* We don't create any RTL for local variables.  */\n   if (DECL_FUNCTION_SCOPE_P (decl) && !TREE_STATIC (decl))\n     return;\n@@ -4574,16 +4578,9 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n \t   && DECL_IMPLICIT_INSTANTIATION (decl))\n     defer_p = 1;\n \n-  /* If we're deferring the variable, we only need to make RTL if\n-     there's an ASMSPEC.  Otherwise, we'll lazily create it later when\n-     we need it.  (There's no way to lazily create RTL for things that\n-     have assembly specs because the information about the specifier\n-     isn't stored in the tree, yet)  */\n-  if (defer_p && asmspec)\n-    make_decl_rtl (decl, asmspec);\n   /* If we're not deferring, go ahead and assemble the variable.  */\n-  else if (!defer_p)\n-    rest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n+  if (!defer_p)\n+    rest_of_decl_compilation (decl, toplev, at_eof);\n }\n \n /* Generate code to initialize DECL (a local variable).  */\n@@ -4744,8 +4741,8 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  && !COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \tTYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n \n-      rest_of_decl_compilation (decl, NULL,\n-\t\t\t\tDECL_CONTEXT (decl) == NULL_TREE, at_eof);\n+      rest_of_decl_compilation (decl, DECL_CONTEXT (decl) == NULL_TREE,\n+\t\t\t\tat_eof);\n       goto finish_end;\n     }\n "}, {"sha": "90f1cd176c5a039d758295078e5c3eed88dd84ca", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -975,12 +975,7 @@ grokfield (const cp_declarator *declarator,\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n       if (asmspec)\n-\t{\n-\t  /* This must override the asm specifier which was placed\n-\t     by grokclassfn.  Lay this out fresh.  */\n-\t  SET_DECL_RTL (value, NULL_RTX);\n-\t  change_decl_assembler_name (value, get_identifier (asmspec));\n-\t}\n+\tset_user_assembler_name (value, asmspec);\n       if (!DECL_FRIEND_P (value))\n \tgrok_special_member_properties (value);\n       \n@@ -1229,7 +1224,7 @@ finish_anon_union (tree anon_union_decl)\n       && at_function_scope_p ())\n     add_decl_expr (anon_union_decl);\n   else if (!processing_template_decl)\n-    rest_of_decl_compilation (anon_union_decl, NULL,\n+    rest_of_decl_compilation (anon_union_decl,\n \t\t\t      toplevel_bindings_p (), at_eof);\n }\n \f\n@@ -1601,7 +1596,7 @@ maybe_emit_vtables (tree ctype)\n \n       /* Write it out.  */\n       DECL_EXTERNAL (vtbl) = 0;\n-      rest_of_decl_compilation (vtbl, NULL, 1, 1);\n+      rest_of_decl_compilation (vtbl, 1, 1);\n \n       /* Because we're only doing syntax-checking, we'll never end up\n \t actually marking the variable as written.  */\n@@ -2548,7 +2543,7 @@ write_out_vars (tree vars)\n       if (!var_finalized_p (var))\n \t{\n \t  import_export_decl (var);\n-\t  rest_of_decl_compilation (var, 0, 1, 1);\n+\t  rest_of_decl_compilation (var, 1, 1);\n \t}\n     }\n }"}, {"sha": "b84994c615b7916be53fd68d71796654c69dd6bc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1728,7 +1728,7 @@ build_java_class_ref (tree type)\n       DECL_ARTIFICIAL (class_decl) = 1;\n       DECL_IGNORED_P (class_decl) = 1;\n       pushdecl_top_level (class_decl);\n-      make_decl_rtl (class_decl, NULL);\n+      make_decl_rtl (class_decl);\n     }\n   return class_decl;\n }"}, {"sha": "eb4b64aa8eea677d24b862d8e6126b01e22b6692", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1024,8 +1024,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n \t       TYPE_UNQUALIFIED);\n   grok_special_member_properties (fn);\n   set_linkage_according_to_type (type, fn);\n-  rest_of_decl_compilation (fn, /*asmspec=*/NULL,\n-\t\t\t    toplevel_bindings_p (), at_eof);\n+  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n   DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;"}, {"sha": "ad30901c6b357662332bd098be070dd5b6c884f7", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1368,10 +1368,7 @@ init_block_move_fn (const char *asmspec)\n     }\n \n   if (asmspec)\n-    {\n-      SET_DECL_RTL (block_move_fn, NULL_RTX);\n-      SET_DECL_ASSEMBLER_NAME (block_move_fn, get_identifier (asmspec));\n-    }\n+    set_user_assembler_name (block_move_fn, asmspec);\n }\n \n static tree\n@@ -1385,7 +1382,7 @@ emit_block_move_libcall_fn (int for_call)\n   if (for_call && !emitted_extern)\n     {\n       emitted_extern = true;\n-      make_decl_rtl (block_move_fn, NULL);\n+      make_decl_rtl (block_move_fn);\n       assemble_external (block_move_fn);\n     }\n \n@@ -2432,10 +2429,7 @@ init_block_clear_fn (const char *asmspec)\n     }\n \n   if (asmspec)\n-    {\n-      SET_DECL_RTL (block_clear_fn, NULL_RTX);\n-      SET_DECL_ASSEMBLER_NAME (block_clear_fn, get_identifier (asmspec));\n-    }\n+    set_user_assembler_name (block_clear_fn, asmspec);\n }\n \n static tree\n@@ -2449,7 +2443,7 @@ clear_storage_libcall_fn (int for_call)\n   if (for_call && !emitted_extern)\n     {\n       emitted_extern = true;\n-      make_decl_rtl (block_clear_fn, NULL);\n+      make_decl_rtl (block_clear_fn);\n       assemble_external (block_clear_fn);\n     }\n \n@@ -6044,7 +6038,7 @@ expand_var (tree var)\n       else if (TREE_CODE (var) == VAR_DECL && !TREE_STATIC (var))\n \texpand_decl (var);\n       else if (TREE_CODE (var) == VAR_DECL && TREE_STATIC (var))\n-\trest_of_decl_compilation (var, NULL, 0, 0);\n+\trest_of_decl_compilation (var, 0, 0);\n       else if (TREE_CODE (var) == TYPE_DECL\n \t       || TREE_CODE (var) == CONST_DECL\n \t       || TREE_CODE (var) == FUNCTION_DECL"}, {"sha": "3afeb668e654a625100029e1d762147f2ec80829", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -684,7 +684,7 @@ builtin_function (const char *name,\n   TREE_PUBLIC (decl) = 1;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n-  make_decl_rtl (decl, NULL);\n+  make_decl_rtl (decl);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = function_code;"}, {"sha": "5c68cb57348c6e02a882bc2beb84677937fc4157", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1318,7 +1318,7 @@ gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n \n   pushdecl (fndecl);\n \n-  rest_of_decl_compilation (fndecl, NULL, 1, 0);\n+  rest_of_decl_compilation (fndecl, 1, 0);\n \n   return fndecl;\n }\n@@ -1802,7 +1802,7 @@ gfc_create_module_variable (gfc_symbol * sym)\n \n   /* Create the variable.  */\n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, NULL, 1, 0);\n+  rest_of_decl_compilation (decl, 1, 0);\n \n   /* Also add length of strings.  */\n   if (sym->ts.type == BT_CHARACTER)\n@@ -1813,7 +1813,7 @@ gfc_create_module_variable (gfc_symbol * sym)\n       if (!INTEGER_CST_P (length))\n         {\n           pushdecl (length);\n-          rest_of_decl_compilation (length, NULL, 1, 0);\n+          rest_of_decl_compilation (length, 1, 0);\n         }\n     }\n }\n@@ -1969,11 +1969,11 @@ gfc_generate_function_code (gfc_namespace * ns)\n   if (DECL_CONTEXT (fndecl) == NULL_TREE)\n     {\n       /* create RTL for function declaration */\n-      rest_of_decl_compilation (fndecl, NULL, 1, 0);\n+      rest_of_decl_compilation (fndecl, 1, 0);\n     }\n \n   /* create RTL for function definition */\n-  make_decl_rtl (fndecl, NULL);\n+  make_decl_rtl (fndecl);\n \n   /* Set the line and filename.  sym->decalred_at seems to point to the last\n      statement for subroutines, but it'll do for now.  */\n@@ -2135,9 +2135,9 @@ gfc_generate_constructors (void)\n \n   current_function_decl = fndecl;\n \n-  rest_of_decl_compilation (fndecl, NULL, 1, 0);\n+  rest_of_decl_compilation (fndecl, 1, 0);\n \n-  make_decl_rtl (fndecl, NULL);\n+  make_decl_rtl (fndecl);\n \n   init_function_start (fndecl, input_filename, input_line);\n "}, {"sha": "71923fa9c2fa33742c758dc55839b24b0f8eca96", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -547,7 +547,7 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n   /* Mark it __attribute__((const)), if possible.  */\n   TREE_READONLY (fndecl) = m->is_constant;\n \n-  rest_of_decl_compilation (fndecl, NULL, 1, 0);\n+  rest_of_decl_compilation (fndecl, 1, 0);\n \n   (*pdecl) = fndecl;\n   return fndecl;"}, {"sha": "f661976f03657ac7da1de2f0ef633f1d873663e9", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -993,7 +993,7 @@ gfc_finish_type (tree type)\n   TYPE_STUB_DECL (type) = decl;\n   layout_type (type);\n   rest_of_type_compilation (type, 1);\n-  rest_of_decl_compilation (decl, NULL, 1, 0);\n+  rest_of_decl_compilation (decl, 1, 0);\n }\n \f\n /* Add a field of given NAME and TYPE to the context of a UNION_TYPE"}, {"sha": "5219f23bcc8f9c601238fbf1bafbb1184016bd5c", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -144,7 +144,7 @@ define_builtin (enum built_in_function val,\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   SET_DECL_ASSEMBLER_NAME (decl, get_identifier (libname));\n-  make_decl_rtl (decl, NULL);\n+  make_decl_rtl (decl);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = BUILT_IN_NORMAL;\n   DECL_FUNCTION_CODE (decl) = val;"}, {"sha": "7f4c01c1971f47dd63973c2f9eee69a928aa9716", "filename": "gcc/java/class.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -920,9 +920,9 @@ build_utf8_ref (tree name)\n   TREE_CHAIN (decl) = utf8_decl_list;\n   layout_decl (decl, 0);\n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+  rest_of_decl_compilation (decl, global_bindings_p (), 0);\n   utf8_decl_list = decl;\n-  make_decl_rtl (decl, (char*) 0);\n+  make_decl_rtl (decl);\n   ref = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n   IDENTIFIER_UTF8_REF (name) = ref;\n   return ref;\n@@ -985,7 +985,7 @@ build_class_ref (tree type)\n \t      SET_DECL_ASSEMBLER_NAME (decl, \n \t\t\t\t       java_mangle_class_field\n \t\t\t\t       (&temporary_obstack, type));\n-\t      make_decl_rtl (decl, NULL);\n+\t      make_decl_rtl (decl);\n \t      pushdecl_top_level (decl);\n \t    }\n \t}\n@@ -1037,7 +1037,7 @@ build_class_ref (tree type)\n \t      TREE_STATIC (decl) = 1;\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_EXTERNAL (decl) = 1;\n-\t      make_decl_rtl (decl, NULL);\n+\t      make_decl_rtl (decl);\n \t      pushdecl_top_level (decl);\n \t    }\n \t}\n@@ -1073,7 +1073,7 @@ build_static_field_ref (tree fdecl)\n \t{\n \t  if (is_compiled == 1)\n \t    DECL_EXTERNAL (fdecl) = 1;\n-\t  make_decl_rtl (fdecl, NULL);\n+\t  make_decl_rtl (fdecl);\n \t}\n       return fdecl;\n     }\n@@ -1311,7 +1311,7 @@ make_method_value (tree mdecl)\n \tTREE_STATIC (array) = 1;\n \tDECL_ARTIFICIAL (array) = 1;\n \tDECL_IGNORED_P (array) = 1;\n-\trest_of_decl_compilation (array, (char*) 0, 1, 0);\n+\trest_of_decl_compilation (array, 1, 0);\n \n \ttable = build1 (ADDR_EXPR, ptr_type_node, array);\n       }\n@@ -1385,7 +1385,7 @@ get_dispatch_table (tree type, tree this_class_addr)\n       else\n \t{\n \t  if (!DECL_RTL_SET_P (method))\n-\t    make_decl_rtl (method, NULL);\n+\t    make_decl_rtl (method);\n \n \t  if (TARGET_VTABLE_USES_DESCRIPTORS)\n \t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n@@ -1528,7 +1528,7 @@ make_class_data (tree type)\n \t      if (initial != NULL_TREE\n \t\t  && TREE_TYPE (initial) == string_ptr_type_node)\n \t\tDECL_INITIAL (field) = NULL_TREE;\n-\t      rest_of_decl_compilation (field, (char*) 0, 1, 1);\n+\t      rest_of_decl_compilation (field, 1, 1);\n \t      DECL_INITIAL (field) = initial;\n \t    }\n \t  else\n@@ -1552,7 +1552,7 @@ make_class_data (tree type)\n       TREE_STATIC (fields_decl) = 1;\n       DECL_ARTIFICIAL (fields_decl) = 1;\n       DECL_IGNORED_P (fields_decl) = 1;\n-      rest_of_decl_compilation (fields_decl, (char*) 0, 1, 0);\n+      rest_of_decl_compilation (fields_decl, 1, 0);\n     }\n   else\n     fields_decl = NULL_TREE;\n@@ -1578,7 +1578,7 @@ make_class_data (tree type)\n   TREE_STATIC (methods_decl) = 1;\n   DECL_ARTIFICIAL (methods_decl) = 1;\n   DECL_IGNORED_P (methods_decl) = 1;\n-  rest_of_decl_compilation (methods_decl, (char*) 0, 1, 0);\n+  rest_of_decl_compilation (methods_decl, 1, 0);\n \n   if (supers_all_compiled (type) && ! CLASS_INTERFACE (type_decl)\n       && !flag_indirect_dispatch)\n@@ -1590,7 +1590,7 @@ make_class_data (tree type)\n       DECL_ARTIFICIAL (dtable_decl) = 1;\n       DECL_IGNORED_P (dtable_decl) = 1;\n       TREE_PUBLIC (dtable_decl) = 1;\n-      rest_of_decl_compilation (dtable_decl, (char*) 0, 1, 0);\n+      rest_of_decl_compilation (dtable_decl, 1, 0);\n       if (type == class_type_node)\n \tclass_dtable_decl = dtable_decl;\n     }\n@@ -1603,7 +1603,7 @@ make_class_data (tree type)\n       DECL_IGNORED_P (class_dtable_decl) = 1;\n       if (is_compiled_class (class_type_node) != 2)\n \tDECL_EXTERNAL (class_dtable_decl) = 1;\n-      rest_of_decl_compilation (class_dtable_decl, (char*) 0, 1, 0);\n+      rest_of_decl_compilation (class_dtable_decl, 1, 0);\n     }\n \n   super = CLASSTYPE_SUPER (type);\n@@ -1658,7 +1658,7 @@ make_class_data (tree type)\n       DECL_ARTIFICIAL (idecl) = 1;\n       DECL_IGNORED_P (idecl) = 1;\n       interfaces = build1 (ADDR_EXPR, ptr_type_node, idecl);\n-      rest_of_decl_compilation (idecl,  (char*) 0, 1, 0);\n+      rest_of_decl_compilation (idecl, 1, 0);\n     }\n \n   constant_pool_constructor = build_constants_constructor ();\n@@ -1781,7 +1781,7 @@ make_class_data (tree type)\n   if (flag_hash_synchronization && POINTER_SIZE < 64)\n     DECL_ALIGN (decl) = 64; \n   \n-  rest_of_decl_compilation (decl, (char*) 0, 1, 0);\n+  rest_of_decl_compilation (decl, 1, 0);\n }\n \n void\n@@ -1792,7 +1792,7 @@ finish_class (void)\n   current_function_decl = NULL_TREE;\n   make_class_data (current_class);\n   register_class ();\n-  rest_of_decl_compilation (TYPE_NAME (current_class), (char*) 0, 1, 0);\n+  rest_of_decl_compilation (TYPE_NAME (current_class), 1, 0);\n }\n \n /* Return 2 if CLASS is compiled by this compilation job;\n@@ -2189,7 +2189,7 @@ layout_class_method (tree this_class, tree super_class,\n   if (! METHOD_ABSTRACT (method_decl) \n       || (CLASS_INTERFACE (TYPE_NAME (this_class)) \n \t  && (DECL_CLINIT_P (method_decl))))\n-    make_decl_rtl (method_decl, NULL);\n+    make_decl_rtl (method_decl);\n \n   if (ID_INIT_P (method_name))\n     {\n@@ -2388,7 +2388,7 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n   DECL_INITIAL (the_syms_decl) = table;\n   DECL_ARTIFICIAL (the_syms_decl) = 1;\n   DECL_IGNORED_P (the_syms_decl) = 1;\n-  rest_of_decl_compilation (the_syms_decl, NULL, 1, 0);\n+  rest_of_decl_compilation (the_syms_decl, 1, 0);\n   \n   /* Now that its size is known, redefine the table as an\n      uninitialized static array of INDEX + 1 elements. The extra entry\n@@ -2399,7 +2399,7 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n   the_table = build_decl (VAR_DECL, name, the_array_type);\n   TREE_STATIC (the_table) = 1;\n   TREE_READONLY (the_table) = 1;  \n-  rest_of_decl_compilation (the_table, NULL, 1, 0);\n+  rest_of_decl_compilation (the_table, 1, 0);\n \n   return the_table;\n }\n@@ -2446,7 +2446,7 @@ emit_catch_table (tree this_class)\n   TREE_STATIC (table) = 1;\n   TREE_READONLY (table) = 1;  \n   DECL_IGNORED_P (table) = 1;\n-  rest_of_decl_compilation (table, NULL, 1, 0);\n+  rest_of_decl_compilation (table, 1, 0);\n   return table;\n }\n  "}, {"sha": "cffd5d9cc7292b97147faa7ad0af0100e41fe091", "filename": "gcc/java/constants.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -411,7 +411,7 @@ build_constant_data_ref (void)\n \n       decl = build_decl (VAR_DECL, decl_name, type);\n       TREE_STATIC (decl) = 1;\n-      make_decl_rtl (decl, NULL);\n+      make_decl_rtl (decl);\n       TYPE_CPOOL_DATA_REF (output_class) = decl;\n     }\n \n@@ -468,7 +468,7 @@ build_constants_constructor (void)\n \t\t\t\t\t\t    data_list);\n       DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));\n       DECL_SIZE_UNIT (data_decl) = TYPE_SIZE_UNIT (TREE_TYPE (data_decl));\n-      rest_of_decl_compilation (data_decl, (char *) 0, 1, 0);\n+      rest_of_decl_compilation (data_decl, 1, 0);\n       data_value = build_address_of (data_decl);\n \n       tags_type = build_array_type (unsigned_byte_type_node, index_type);\n@@ -477,7 +477,7 @@ build_constants_constructor (void)\n \t\t\t      tags_type);\n       TREE_STATIC (tags_decl) = 1;\n       DECL_INITIAL (tags_decl) = build_constructor (tags_type, tags_list);\n-      rest_of_decl_compilation (tags_decl, (char*) 0, 1, 0);\n+      rest_of_decl_compilation (tags_decl, 1, 0);\n       tags_value = build_address_of (tags_decl);\n     }\n   else"}, {"sha": "73653b29d8a79695289d834a45784b963ef0aea9", "filename": "gcc/java/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -506,7 +506,7 @@ builtin_function (const char *name,\n   TREE_PUBLIC (decl) = 1;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n-  make_decl_rtl (decl, NULL);\n+  make_decl_rtl (decl);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = cl;\n   DECL_FUNCTION_CODE (decl) = function_code;\n@@ -1983,7 +1983,7 @@ java_mark_decl_local (tree decl)\n   /* If we've already constructed DECL_RTL, give encode_section_info\n      a second chance, now that we've changed the flags.  */\n   if (DECL_RTL_SET_P (decl))\n-    make_decl_rtl (decl, NULL);\n+    make_decl_rtl (decl);\n }\n \n void"}, {"sha": "9ef549b3d2058ca4f41bc4f89d3f6626e20b0e09", "filename": "gcc/java/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -386,7 +386,7 @@ expand_catch_class (void **entry, void *x ATTRIBUTE_UNUSED)\n   tree decl;\n   STRIP_NOPS (addr);\n   decl = TREE_OPERAND (addr, 0);\n-  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+  rest_of_decl_compilation (decl, global_bindings_p (), 0);\n   return true;\n }\n   "}, {"sha": "1479b6e60b981813f2e830446dfc7c6d4d978bed", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1829,7 +1829,7 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n       if (!flag_indirect_dispatch\n \t  || (!TREE_PUBLIC (method) && DECL_CONTEXT (method)))\n \t{\n-\t  make_decl_rtl (method, NULL);\n+\t  make_decl_rtl (method);\n \t  func = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (method)),\n \t\t\t method);\n \t}"}, {"sha": "6257d3743e1ab16dc50f85306c4ce28e37478908", "filename": "gcc/java/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -91,8 +91,8 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   DECL_INITIAL (decl) = rinit;\n   layout_decl (decl, 0);\n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n-  make_decl_rtl (decl, (char*) 0);\n+  rest_of_decl_compilation (decl, global_bindings_p (), 0);\n+  make_decl_rtl (decl);\n   assemble_variable (decl, 1, 0, 0);\n \n   resources = tree_cons (NULL_TREE, decl, resources);"}, {"sha": "a54933dcb28786f16b3467b81f81154658e5b708", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1091,7 +1091,7 @@ create_builtin_decl (enum tree_code code, tree type, const char *name)\n   if (code == VAR_DECL)\n     {\n       TREE_STATIC (decl) = 1;\n-      make_decl_rtl (decl, 0);\n+      make_decl_rtl (decl);\n       pushdecl (decl);\n       DECL_ARTIFICIAL (decl) = 1;\n     }\n@@ -1488,7 +1488,7 @@ objc_add_static_instance (tree constructor, tree class_decl)\n      Postpone till end of input.  */\n   DECL_DEFER_OUTPUT (decl) = 1;\n   pushdecl_top_level (decl);\n-  rest_of_decl_compilation (decl, 0, 1, 0);\n+  rest_of_decl_compilation (decl, 1, 0);\n \n   /* Add the DECL to the head of this CLASS' list.  */\n   TREE_PURPOSE (*chain) = tree_cons (NULL_TREE, decl, TREE_PURPOSE (*chain));\n@@ -1892,7 +1892,7 @@ build_module_descriptor (void)\n     DECL_ARTIFICIAL (execclass_decl) = 1;\n     TREE_PUBLIC (execclass_decl) = 1;\n     pushdecl (execclass_decl);\n-    rest_of_decl_compilation (execclass_decl, 0, 0, 0);\n+    rest_of_decl_compilation (execclass_decl, 0, 0);\n     assemble_external (execclass_decl);\n \n     /* void _GLOBAL_$I$<gnyf> () {objc_execClass (&L_OBJC_MODULES);}  */\n@@ -2022,7 +2022,7 @@ generate_static_references (void)\n   expr = objc_build_constructor (TREE_TYPE (static_instances_decl),\n \t\t\t    nreverse (decls));\n   finish_decl (static_instances_decl, expr, NULL_TREE);\n-  rest_of_decl_compilation (static_instances_decl, 0, 0, 0);\n+  rest_of_decl_compilation (static_instances_decl, 0, 0);\n }\n \n /* Output all strings.  */\n@@ -2102,7 +2102,7 @@ build_selector_reference_decl (void)\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_CONTEXT (decl) = 0;\n \n-  make_decl_rtl (decl, 0);\n+  make_decl_rtl (decl);\n   pushdecl_top_level (decl);\n \n   return decl;\n@@ -2309,7 +2309,7 @@ build_class_reference_decl (void)\n   DECL_CONTEXT (decl) = 0;\n   DECL_ARTIFICIAL (decl) = 1;\n \n-  make_decl_rtl (decl, 0);\n+  make_decl_rtl (decl);\n   pushdecl_top_level (decl);\n \n   return decl;\n@@ -2459,7 +2459,7 @@ build_objc_string_decl (enum string_section section)\n   DECL_CONTEXT (decl) = 0;\n   DECL_ARTIFICIAL (decl) = 1;\n \n-  make_decl_rtl (decl, 0);\n+  make_decl_rtl (decl);\n   pushdecl_top_level (decl);\n \n   return decl;\n@@ -5951,7 +5951,7 @@ build_protocol_reference (tree p)\n       TREE_USED (decl) = 1;\n       DECL_ARTIFICIAL (decl) = 1;\n \n-      make_decl_rtl (decl, 0);\n+      make_decl_rtl (decl);\n       pushdecl_top_level (decl);\n    }\n \n@@ -8954,7 +8954,7 @@ handle_class_ref (tree chain)\n   TREE_PUBLIC (decl) = 1;\n \n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, 0, 0, 0);\n+  rest_of_decl_compilation (decl, 0, 0);\n \n   /* Make a decl for the address.  */\n   sprintf (string, \"%sobjc_class_ref_%s\",\n@@ -8966,7 +8966,7 @@ handle_class_ref (tree chain)\n   TREE_USED (decl) = 1;\n \n   pushdecl (decl);\n-  rest_of_decl_compilation (decl, 0, 0, 0);\n+  rest_of_decl_compilation (decl, 0, 0);\n }\n \n static void"}, {"sha": "2f625c57a6d31190517076651723ab4f0c6182a9", "filename": "gcc/passes.c", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -320,18 +320,16 @@ close_dump_file (enum dump_file_index index,\n    and TYPE_DECL nodes.\n \n    This does nothing for local (non-static) variables, unless the\n-   variable is a register variable with an ASMSPEC.  In that case, or\n-   if the variable is not an automatic, it sets up the RTL and\n-   outputs any assembler code (label definition, storage allocation\n-   and initialization).\n+   variable is a register variable with DECL_ASSEMBLER_NAME set.  In\n+   that case, or if the variable is not an automatic, it sets up the\n+   RTL and outputs any assembler code (label definition, storage\n+   allocation and initialization).\n \n-   DECL is the declaration.  If ASMSPEC is nonzero, it specifies\n-   the assembler symbol name to be used.  TOP_LEVEL is nonzero\n+   DECL is the declaration.  TOP_LEVEL is nonzero\n    if this declaration is not within a function.  */\n \n void\n rest_of_decl_compilation (tree decl,\n-\t\t\t  const char *asmspec,\n \t\t\t  int top_level,\n \t\t\t  int at_end)\n {\n@@ -348,16 +346,18 @@ rest_of_decl_compilation (tree decl,\n       }\n   }\n \n+  /* Can't defer this, because it needs to happen before any\n+     later function definitions are processed.  */\n+  if (DECL_REGISTER (decl) && DECL_ASSEMBLER_NAME_SET_P (decl))\n+    make_decl_rtl (decl);\n+\n   /* Forward declarations for nested functions are not \"external\",\n      but we need to treat them as if they were.  */\n   if (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n       || TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       timevar_push (TV_VARCONST);\n \n-      if (asmspec)\n-\tmake_decl_rtl (decl, asmspec);\n-\n       /* Don't output anything when a tentative file-scope definition\n \t is seen.  But at end of compilation, do output code for them.\n \n@@ -393,22 +393,6 @@ rest_of_decl_compilation (tree decl,\n \n       timevar_pop (TV_VARCONST);\n     }\n-  else if (DECL_REGISTER (decl) && asmspec != 0)\n-    {\n-      if (decode_reg_name (asmspec) >= 0)\n-\t{\n-\t  SET_DECL_RTL (decl, NULL_RTX);\n-\t  make_decl_rtl (decl, asmspec);\n-\t}\n-      else\n-\t{\n-\t  error (\"%Hinvalid register name `%s' for register variable\",\n-\t\t &DECL_SOURCE_LOCATION (decl), asmspec);\n-\t  DECL_REGISTER (decl) = 0;\n-\t  if (!top_level)\n-\t    expand_decl (decl);\n-\t}\n-    }\n   else if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       timevar_push (TV_SYMOUT);"}, {"sha": "80608400ccb2a2a6531cd56e70eb45902354348d", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -783,7 +783,7 @@ wrapup_global_declarations (tree *vec, int len)\n \t      if (needed)\n \t\t{\n \t\t  reconsider = 1;\n-\t\t  rest_of_decl_compilation (decl, NULL, 1, 1);\n+\t\t  rest_of_decl_compilation (decl, 1, 1);\n \t\t}\n \t    }\n \t}"}, {"sha": "64983caaeb3b7d5d98202e21c3f356ea7746873b", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -73,7 +73,7 @@ extern void pedwarn (const char *, ...) ATTRIBUTE_GCC_FE_DIAG(1,2);\n extern void sorry (const char *, ...) ATTRIBUTE_GCC_FE_DIAG(1,2);\n extern void inform (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n \n-extern void rest_of_decl_compilation (tree, const char *, int, int);\n+extern void rest_of_decl_compilation (tree, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void rest_of_compilation (void);\n extern void tree_rest_of_compilation (tree, bool);"}, {"sha": "4009d0053c2e30d914a8de39c25c4752ec33ea59", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -1862,7 +1862,7 @@ struct tree_binfo GTY (())\n #define DECL_RTL(NODE)\t\t\t\t\t\\\n   (DECL_CHECK (NODE)->decl.rtl\t\t\t\t\\\n    ? (NODE)->decl.rtl\t\t\t\t\t\\\n-   : (make_decl_rtl (NODE, NULL), (NODE)->decl.rtl))\n+   : (make_decl_rtl (NODE), (NODE)->decl.rtl))\n /* Set the DECL_RTL for NODE to RTL.  */\n #define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)\n /* Returns nonzero if the DECL_RTL for NODE has already been set.  */\n@@ -3603,7 +3603,7 @@ extern void internal_reference_types (void);\n extern unsigned int update_alignment_for_field (record_layout_info, tree,\n                                                 unsigned int);\n /* varasm.c */\n-extern void make_decl_rtl (tree, const char *);\n+extern void make_decl_rtl (tree);\n extern void make_decl_one_only (tree);\n extern int supports_one_only (void);\n extern void variable_section (tree, int);\n@@ -3612,6 +3612,7 @@ extern void resolve_unique_section (tree, int, int);\n extern void mark_referenced (tree);\n extern void mark_decl_referenced (tree);\n extern void notice_global_symbol (tree);\n+extern void set_user_assembler_name (tree, const char *);\n \n /* In stmt.c */\n extern void emit_nop (void);"}, {"sha": "5a31b8b300d2eb3f11ad8e9758e91cb5304352c3", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -347,7 +347,7 @@ tree_code_create_function_prototype (unsigned char* chars,\n     }\n \n   /* Process declaration of function defined elsewhere.  */\n-  rest_of_decl_compilation (fn_decl, NULL, 1, 0);\n+  rest_of_decl_compilation (fn_decl, 1, 0);\n \n   return fn_decl;\n }\n@@ -439,7 +439,7 @@ tree_code_create_function_initial (tree prev_saved,\n   /* Output the decl rtl (not the rtl for the function code).  ???.\n      If the function is not defined in this file, when should you\n      execute this?  */\n-  make_decl_rtl (fn_decl, NULL);\n+  make_decl_rtl (fn_decl);\n \n   init_function_start (fn_decl);\n \n@@ -616,7 +616,7 @@ tree_code_create_variable (unsigned int storage_class,\n   /* Expand declaration and initial value if any.  */\n \n   if (TREE_STATIC (var_decl))\n-    rest_of_decl_compilation (var_decl, 0, 0, 0);\n+    rest_of_decl_compilation (var_decl, 0, 0);\n   else\n     {\n       expand_decl (var_decl);\n@@ -1358,7 +1358,7 @@ builtin_function (const char *name, tree type, int function_code,\n   TREE_PUBLIC (decl) = 1;\n   if (library_name)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n-  make_decl_rtl (decl, NULL);\n+  make_decl_rtl (decl);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = function_code;"}, {"sha": "0fc93755d0e7db674b734d9a6a75cb34956e0c4d", "filename": "gcc/varasm.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e6df31e198fd8c0ab0daacc631de05365c2c216/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0e6df31e198fd8c0ab0daacc631de05365c2c216", "patch": "@@ -668,6 +668,19 @@ strip_reg_name (const char *name)\n   return name;\n }\n \f\n+/* The user has asked for a DECL to have a particular name.  Set (or\n+   change) it in such a way that we don't prefix an underscore to\n+   it.  */\n+void\n+set_user_assembler_name (tree decl, const char *name)\n+{\n+  char *starred = alloca (strlen (name) + 2);\n+  starred[0] = '*';\n+  strcpy (starred + 1, name);\n+  change_decl_assembler_name (decl, get_identifier (starred));\n+  SET_DECL_RTL (decl, NULL_RTX);\n+}\n+\f\n /* Decode an `asm' spec for a declaration as a register name.\n    Return the register number, or -1 if nothing specified,\n    or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,\n@@ -734,13 +747,10 @@ decode_reg_name (const char *asmspec)\n    There is, however, one exception: this function handles variables\n    explicitly placed in a particular register by the user.\n \n-   ASMSPEC, if not 0, is the string which the user specified as the\n-   assembler symbol name.\n-\n    This is never called for PARM_DECL nodes.  */\n \n void\n-make_decl_rtl (tree decl, const char *asmspec)\n+make_decl_rtl (tree decl)\n {\n   const char *name = 0;\n   int reg_number;\n@@ -770,6 +780,9 @@ make_decl_rtl (tree decl, const char *asmspec)\n \tSET_DECL_RTL (decl, adjust_address_nv (DECL_RTL (decl),\n \t\t\t\t\t       DECL_MODE (decl), 0));\n \n+      if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n+\treturn;\n+\n       /* ??? Another way to do this would be to maintain a hashed\n \t table of such critters.  Instead of adding stuff to a DECL\n \t to give certain attributes to it, we could use an external\n@@ -787,19 +800,10 @@ make_decl_rtl (tree decl, const char *asmspec)\n       return;\n     }\n \n-  reg_number = decode_reg_name (asmspec);\n-  if (reg_number == -2)\n-    {\n-      /* ASMSPEC is given, and not the name of a register.  Mark the\n-\t name with a star so assemble_name won't munge it.  */\n-      char *starred = alloca (strlen (asmspec) + 2);\n-      starred[0] = '*';\n-      strcpy (starred + 1, asmspec);\n-      change_decl_assembler_name (decl, get_identifier (starred));\n-    }\n-\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n+  reg_number = decode_reg_name (name);\n+\n   if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n     {\n       /* First detect errors in declaring global registers.  */\n@@ -855,7 +859,7 @@ make_decl_rtl (tree decl, const char *asmspec)\n   /* Now handle ordinary static variables and functions (in memory).\n      Also handle vars declared register invalidly.  */\n \n-  if (reg_number >= 0 || reg_number == -3)\n+  if (name[0] == '*' && (reg_number >= 0 || reg_number == -3))\n     error (\"%Jregister name given for non-register variable '%D'\", decl, decl);\n \n   /* Specifying a section attribute on a variable forces it into a\n@@ -4191,7 +4195,7 @@ assemble_alias (tree decl, tree target ATTRIBUTE_UNUSED)\n \n   /* We must force creation of DECL_RTL for debug info generation, even though\n      we don't use it here.  */\n-  make_decl_rtl (decl, NULL);\n+  make_decl_rtl (decl);\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n "}]}