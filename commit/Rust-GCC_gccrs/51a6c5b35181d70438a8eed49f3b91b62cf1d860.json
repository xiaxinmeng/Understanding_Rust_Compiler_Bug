{"sha": "51a6c5b35181d70438a8eed49f3b91b62cf1d860", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFhNmM1YjM1MTgxZDcwNDM4YThlZWQ0OWYzYjkxYjYyY2YxZDg2MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-04-04T23:34:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-04-04T23:34:03Z"}, "message": "* config/alpha/lib1funcs.asm: Remove unused file.\n\nFrom-SVN: r123510", "tree": {"sha": "2c67bb45c0c60847e84920e5600f53e379594de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c67bb45c0c60847e84920e5600f53e379594de5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51a6c5b35181d70438a8eed49f3b91b62cf1d860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a6c5b35181d70438a8eed49f3b91b62cf1d860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a6c5b35181d70438a8eed49f3b91b62cf1d860", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a6c5b35181d70438a8eed49f3b91b62cf1d860/comments", "author": null, "committer": null, "parents": [{"sha": "5a05e7d4dca61a1c5d36022e96f10c0d8e463367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a05e7d4dca61a1c5d36022e96f10c0d8e463367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a05e7d4dca61a1c5d36022e96f10c0d8e463367"}], "stats": {"total": 324, "additions": 4, "deletions": 320}, "files": [{"sha": "993e702242e4c882cfe97cf4d722089e9b9c40e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a6c5b35181d70438a8eed49f3b91b62cf1d860/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a6c5b35181d70438a8eed49f3b91b62cf1d860/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51a6c5b35181d70438a8eed49f3b91b62cf1d860", "patch": "@@ -1,3 +1,7 @@\n+2007-04-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/lib1funcs.asm: Remove unused file.\n+\n 2007-04-04  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \tPR other/31356"}, {"sha": "4c29309583c49d04b5a7a0704c5004755ceff125", "filename": "gcc/config/alpha/lib1funcs.asm", "status": "removed", "additions": 0, "deletions": 320, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a05e7d4dca61a1c5d36022e96f10c0d8e463367/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a05e7d4dca61a1c5d36022e96f10c0d8e463367/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flib1funcs.asm?ref=5a05e7d4dca61a1c5d36022e96f10c0d8e463367", "patch": "@@ -1,320 +0,0 @@\n-/* DEC Alpha division and remainder support.\n-   Copyright (C) 1994, 1999 Free Software Foundation, Inc.\n-\n-This file is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-/* This had to be written in assembler because the division functions \n-   use a non-standard calling convention. \n-\n-   This file provides an implementation of __divqu, __divq, __divlu, \n-   __divl, __remqu, __remq, __remlu and __reml.  CPP macros control\n-   the exact operation.\n-\n-   Operation performed: $27 := $24 o $25, clobber $28, return address to\n-   caller in $23, where o one of the operations.\n-\n-   The following macros need to be defined: \n-\n-\tSIZE, the number of bits, 32 or 64.\n-\n-\tTYPE, either UNSIGNED or SIGNED\n-\n-\tOPERATION, either DIVISION or REMAINDER\n-   \n-\tSPECIAL_CALLING_CONVENTION, 0 or 1.  It is useful for debugging to\n-\tdefine this to 0.  That removes the `__' prefix to make the function\n-\tname not collide with the existing libc.a names, and uses the\n-\tstandard Alpha procedure calling convention.\n-*/\n-\n-#ifndef SPECIAL_CALLING_CONVENTION\n-#define SPECIAL_CALLING_CONVENTION 1\n-#endif\n-\n-#ifdef L_divl\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __divl\n-#else\n-#define FUNCTION_NAME divl\n-#endif\n-#define SIZE 32\n-#define TYPE SIGNED\n-#define OPERATION DIVISION\n-#endif\n-\n-#ifdef L_divlu\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __divlu\n-#else\n-#define FUNCTION_NAME divlu\n-#endif\n-#define SIZE 32\n-#define TYPE UNSIGNED\n-#define OPERATION DIVISION\n-#endif\n-\n-#ifdef L_divq\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __divq\n-#else\n-#define FUNCTION_NAME divq\n-#endif\n-#define SIZE 64\n-#define TYPE SIGNED\n-#define OPERATION DIVISION\n-#endif\n-\n-#ifdef L_divqu\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __divqu\n-#else\n-#define FUNCTION_NAME divqu\n-#endif\n-#define SIZE 64\n-#define TYPE UNSIGNED\n-#define OPERATION DIVISION\n-#endif\n-\n-#ifdef L_reml\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __reml\n-#else\n-#define FUNCTION_NAME reml\n-#endif\n-#define SIZE 32\n-#define TYPE SIGNED\n-#define OPERATION REMAINDER\n-#endif\n-\n-#ifdef L_remlu\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __remlu\n-#else\n-#define FUNCTION_NAME remlu\n-#endif\n-#define SIZE 32\n-#define TYPE UNSIGNED\n-#define OPERATION REMAINDER\n-#endif\n-\n-#ifdef L_remq\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __remq\n-#else\n-#define FUNCTION_NAME remq\n-#endif\n-#define SIZE 64\n-#define TYPE SIGNED\n-#define OPERATION REMAINDER\n-#endif\n-\n-#ifdef L_remqu\n-#if SPECIAL_CALLING_CONVENTION\n-#define FUNCTION_NAME __remqu\n-#else\n-#define FUNCTION_NAME remqu\n-#endif\n-#define SIZE 64\n-#define TYPE UNSIGNED\n-#define OPERATION REMAINDER\n-#endif\n-\n-#define tmp0 $3\n-#define tmp1 $28\n-#define cnt $1\n-#define result_sign $2\n-\n-#if SPECIAL_CALLING_CONVENTION\n-#define N $24\n-#define D $25\n-#define Q RETREG\n-#define RETREG $27\n-#else\n-#define N $16\n-#define D $17\n-#define Q RETREG\n-#define RETREG $0\n-#endif\n-\n-/* Misc symbols to make alpha assembler easier to read.  */\n-#define zero $31\n-#define sp $30\n-\n-/* Symbols to make interface nicer.  */\n-#define UNSIGNED 0\n-#define SIGNED 1\n-#define DIVISION 0\n-#define REMAINDER 1\n-\n-\t.set noreorder\n-\t.set noat\n-.text\n-\t.align 3\n-\t.globl FUNCTION_NAME\n-\t.ent FUNCTION_NAME\n-FUNCTION_NAME:\n-\n-\t.frame\t$30,0,$26,0\n-\t.prologue 0\n-\n-/* Under the special calling convention, we have to preserve all register\n-   values but $23 and $28.  */\n-#if SPECIAL_CALLING_CONVENTION\n-\tlda\tsp,-64(sp)\n-#if OPERATION == DIVISION\n-\tstq\tN,0(sp)\n-#endif\n-\tstq\tD,8(sp)\n-\tstq\tcnt,16(sp)\n-\tstq\tresult_sign,24(sp)\n-\tstq\ttmp0,32(sp)\n-#endif\n-\n-/* If we are computing the remainder, move N to the register that is used\n-   for the return value, and redefine what register is used for N.  */\n-#if OPERATION == REMAINDER\n-\tbis\tN,N,RETREG\n-#undef N\n-#define N RETREG\n-#endif\n-\n-/* Perform conversion from 32-bit types to 64-bit types.  */\n-#if SIZE == 32\n-#if TYPE == SIGNED\n-\t/* If there are problems with the signed case, add these instructions.\n-\t   The caller should already have done this.\n-\taddl\tN,0,N\t\t# sign extend N\n-\taddl\tD,0,D\t\t# sign extend D\n-\t*/\n-#else /* UNSIGNED */\n-\tzap\tN,0xf0,N\t# zero extend N (caller required to sign extend)\n-\tzap\tD,0xf0,D\t# zero extend D\n-#endif\n-#endif\n-\n-/* Check for divide by zero.  */\n-\tbne\tD,$34\n-\tlda\t$16,-2(zero)\n-\tcall_pal 0xaa\n-$34:\n-\n-#if TYPE == SIGNED\n-#if OPERATION == DIVISION\n-\txor\tN,D,result_sign\n-#else\n-\tbis\tN,N,result_sign\n-#endif\n-/* Get the absolute values of N and D.  */\n-\tsubq\tzero,N,tmp0\n-\tcmovlt\tN,tmp0,N\n-\tsubq\tzero,D,tmp0\n-\tcmovlt\tD,tmp0,D\n-#endif\n-\n-/* Compute CNT = ceil(log2(N)) - ceil(log2(D)).  This is the number of\n-   divide iterations we will have to perform.  Should you wish to optimize\n-   this, check a few bits at a time, preferably using zap/zapnot.  Be\n-   careful though, this code runs fast fro the most common cases, when the\n-   quotient is small.  */\n-\tbge\tN,$35\n-\tbis\tzero,1,cnt\n-\tblt\tD,$40\n-\t.align\t3\n-$39:\taddq\tD,D,D\n-\taddl\tcnt,1,cnt\n-\tbge\tD,$39\n-\tbr\tzero,$40\n-$35:\tcmpult\tN,D,tmp0\n-\tbis\tzero,zero,cnt\n-\tbne\ttmp0,$42\n-\t.align\t3\n-$44:\taddq\tD,D,D\n-\tcmpult\tN,D,tmp0\n-\taddl\tcnt,1,cnt\n-\tbeq\ttmp0,$44\n-$42:\tsrl\tD,1,D\n-$40:\n-\tsubl\tcnt,1,cnt\n-\n-\n-/* Actual divide.  Could be optimized with unrolling.  */\n-#if OPERATION == DIVISION\n-\tbis\tzero,zero,Q\n-#endif\n-\tblt\tcnt,$46\n-\t.align\t3\n-$49:\tcmpule\tD,N,tmp1\n-\tsubq\tN,D,tmp0\n-\tsrl\tD,1,D\n-\tsubl\tcnt,1,cnt\n-\tcmovne\ttmp1,tmp0,N\n-#if OPERATION == DIVISION\n-\taddq\tQ,Q,Q\n-\tbis\tQ,tmp1,Q\n-#endif\n-\tbge\tcnt,$49\n-$46:\n-\n-\n-/* The result is now in RETREG.  NOTE!  It was written to RETREG using\n-   either N or Q as a synonym!  */\n-\n-\n-/* Change the sign of the result as needed.  */\n-#if TYPE == SIGNED\n-\tsubq\tzero,RETREG,tmp0\n-\tcmovlt\tresult_sign,tmp0,RETREG\n-#endif\n-\n-\n-/* Restore clobbered registers.  */\n-#if SPECIAL_CALLING_CONVENTION\n-#if OPERATION == DIVISION\n-\tldq\tN,0(sp)\n-#endif\n-\tldq\tD,8(sp)\n-\tldq\tcnt,16(sp)\n-\tldq\tresult_sign,24(sp)\n-\tldq\ttmp0,32(sp)\n-\n-\tlda\tsp,64(sp)\n-#endif\n-\n-\n-/* Sign extend an *unsigned* 32-bit result, as required by the Alpha\n-   conventions.  */\n-#if TYPE == UNSIGNED && SIZE == 32\n-\t/* This could be avoided by adding some CPP hair to the divide loop.\n-\t   It is probably not worth the added complexity.  */\n-\taddl\tRETREG,0,RETREG\n-#endif\n-\n-\n-#if SPECIAL_CALLING_CONVENTION\n-\tret\tzero,($23),1\n-#else\n-\tret\tzero,($26),1\n-#endif\n-\t.end\tFUNCTION_NAME"}]}