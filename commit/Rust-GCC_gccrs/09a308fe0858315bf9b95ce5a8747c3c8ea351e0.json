{"sha": "09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlhMzA4ZmUwODU4MzE1YmY5Yjk1Y2U1YTg3NDdjM2M4ZWEzNTFlMA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-10-27T02:14:12Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-10-27T02:14:12Z"}, "message": "reload.h (earlyclobber_operand_p): Declare.\n\n\t* reload.h (earlyclobber_operand_p): Declare.\n\t* reload.c (earlyclobber_operand_p): Don't declare.  No longer static.\n\t* reload1.c (reload_reg_free_for_value_p):  RELOAD_OTHER reloads with\n\tan earlyclobbered output conflict with RELOAD_INPUT reloads - handle\n\tcase where the RELOAD_OTHER reload is new.  Use earlyclobber_operand_p.\n\nFrom-SVN: r30202", "tree": {"sha": "7029a1edafb8e3f060c15a751871f7acafd0a18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7029a1edafb8e3f060c15a751871f7acafd0a18a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/comments", "author": null, "committer": null, "parents": [{"sha": "a05924f91bc802882777615e301bb79fda1f4035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05924f91bc802882777615e301bb79fda1f4035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05924f91bc802882777615e301bb79fda1f4035"}], "stats": {"total": 32, "additions": 26, "deletions": 6}, "files": [{"sha": "bbec9cfcd1ed20dd9fe31602080f89bd4095f6aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "patch": "@@ -1,3 +1,11 @@\n+Wed Oct 27 03:09:23 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload.h (earlyclobber_operand_p): Declare.\n+\t* reload.c (earlyclobber_operand_p): Don't declare.  No longer static.\n+\t* reload1.c (reload_reg_free_for_value_p):  RELOAD_OTHER reloads with\n+\tan earlyclobbered output conflict with RELOAD_INPUT reloads - handle\n+\tcase where the RELOAD_OTHER reload is new.  Use earlyclobber_operand_p.\n+\n Tue Oct 26 18:23:38 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \t\t\t  Richard Henderson  <rth@cygnus.com>\n "}, {"sha": "40103390727d333d0d04960fa1d24adb23de5a57", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "patch": "@@ -252,7 +252,6 @@ static int find_reusable_reload\tPROTO((rtx *, rtx, enum reg_class,\n static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n \t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       enum reg_class, int, int));\n-static int earlyclobber_operand_p PROTO((rtx));\n static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n static struct decomposition decompose PROTO((rtx));\n static int immune_p\t\tPROTO((rtx, rtx, struct decomposition));\n@@ -1921,7 +1920,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n \n-static int\n+int\n earlyclobber_operand_p (x)\n      rtx x;\n {"}, {"sha": "953e0592ce088a2cd8c7541b6bb6d01cca598cf8", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "patch": "@@ -354,6 +354,9 @@ extern rtx find_equiv_reg PROTO((rtx, rtx, enum reg_class, int, short *,\n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n extern int regno_clobbered_p PROTO((int, rtx));\n \n+/* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n+int earlyclobber_operand_p PROTO((rtx));\n+\n /* Functions in reload1.c:  */\n \n extern int reloads_conflict\t\tPROTO ((int, int));"}, {"sha": "955acca04942623443decb857a67b8d29248ee8e", "filename": "gcc/reload1.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a308fe0858315bf9b95ce5a8747c3c8ea351e0/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=09a308fe0858315bf9b95ce5a8747c3c8ea351e0", "patch": "@@ -5291,6 +5291,10 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n      int ignore_address_reloads;\n {\n   int time1;\n+  /* Set if we see an input reload that must not share its reload register\n+     with any new earlyclobber, but might otherwise share the reload\n+     register with an output or input-output reload.  */\n+  int check_earlyclobber = 0;\n   int i;\n   int copy = 0;\n \n@@ -5372,7 +5376,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t  if (! rld[i].in || ! rtx_equal_p (rld[i].in, value)\n \t      || rld[i].out || out)\n \t    {\n-\t      int j, time2;\n+\t      int time2;\n \t      switch (rld[i].when_needed)\n \t\t{\n \t\tcase RELOAD_FOR_OTHER_ADDRESS:\n@@ -5411,6 +5415,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t  break;\n \t\tcase RELOAD_FOR_INPUT:\n \t\t  time2 = rld[i].opnum * 4 + 4;\n+\t\t  check_earlyclobber = 1;\n \t\t  break;\n \t\t  /* rld[i].opnum * 4 + 4 <= (MAX_RECOG_OPERAND - 1) * 4 + 4\n \t\t     == MAX_RECOG_OPERAND * 4  */\n@@ -5423,6 +5428,7 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t  break;\n \t\tcase RELOAD_FOR_OPERAND_ADDRESS:\n \t\t  time2 = MAX_RECOG_OPERANDS * 4 + 2;\n+\t\t  check_earlyclobber = 1;\n \t\t  break;\n \t\tcase RELOAD_FOR_INSN:\n \t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3;\n@@ -5452,9 +5458,8 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t    {\n \t\t      time2 = MAX_RECOG_OPERANDS * 4 + 4;\n \t\t      /* Earlyclobbered outputs must conflict with inputs.  */\n-\t\t      for (j = 0; j < n_earlyclobbers; j++)\n-\t\t\tif (rld[i].out == reload_earlyclobbers[j])\n-\t\t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3;\n+\t\t      if (earlyclobber_operand_p (rld[i].out))\n+\t\t\ttime2 = MAX_RECOG_OPERANDS * 4 + 3;\n \t\t\t  \n \t\t      break;\n \t\t    }\n@@ -5478,6 +5483,11 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t    }\n \t}\n     }\n+\n+  /* Earlyclobbered outputs must conflict with inputs.  */\n+  if (check_earlyclobber && out && earlyclobber_operand_p (out))\n+    return 0;\n+\n   return 1;\n }\n "}]}