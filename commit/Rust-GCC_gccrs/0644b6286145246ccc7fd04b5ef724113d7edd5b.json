{"sha": "0644b6286145246ccc7fd04b5ef724113d7edd5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY0NGI2Mjg2MTQ1MjQ2Y2NjN2ZkMDRiNWVmNzI0MTEzZDdlZGQ1Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-13T22:32:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-13T22:32:32Z"}, "message": "i386.c (output_fp_compare): Support SSE.\n\n\n\t* i386.c (output_fp_compare): Support SSE.\n\t(prepare_fp_compare_args): SSE comparisons always support memory.\n\t* i386.h (TARGET_CMOVE): SSE imply cmove.\n\t* i386.md (cmp?f2): Enable for SSE too.\n\t(cmpfp_i*): Support SSE.\n\t(cmpfp_i_sse): New.\n\t(cmpfp_i_sse_only): New.\n\t(s*, b* fp expanters): Enable for SSE too.\n\t(fp_jcc_1_sse, fp_jcc_1_sse_only, fp_jcc_2_sse, fp_jcc_2_sse_only):\n\tNew patterns.\n\nFrom-SVN: r39647", "tree": {"sha": "ebbda60bf5ba9a6e20891e54554a332f1b7ea2b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebbda60bf5ba9a6e20891e54554a332f1b7ea2b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0644b6286145246ccc7fd04b5ef724113d7edd5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0644b6286145246ccc7fd04b5ef724113d7edd5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0644b6286145246ccc7fd04b5ef724113d7edd5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0644b6286145246ccc7fd04b5ef724113d7edd5b/comments", "author": null, "committer": null, "parents": [{"sha": "1464632be3927d37a6c8b0c188e967b426d84bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1464632be3927d37a6c8b0c188e967b426d84bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1464632be3927d37a6c8b0c188e967b426d84bda"}], "stats": {"total": 179, "additions": 157, "deletions": 22}, "files": [{"sha": "aadb722310633cddb23e61d6e9284a67e089097d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0644b6286145246ccc7fd04b5ef724113d7edd5b", "patch": "@@ -1,3 +1,16 @@\n+Tue Feb 13 23:19:27 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (output_fp_compare): Support SSE.\n+\t(prepare_fp_compare_args): SSE comparisons always support memory.\n+\t* i386.h (TARGET_CMOVE): SSE imply cmove.\n+\t* i386.md (cmp?f2): Enable for SSE too.\n+\t(cmpfp_i*): Support SSE.\n+\t(cmpfp_i_sse): New.\n+\t(cmpfp_i_sse_only): New.\n+\t(s*, b* fp expanters): Enable for SSE too.\n+\t(fp_jcc_1_sse, fp_jcc_1_sse_only, fp_jcc_2_sse, fp_jcc_2_sse_only):\n+\tNew patterns.\n+\n Tue Feb 13 23:05:42 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n  \t* regclass.c (init_reg_sets_1): Silence warning."}, {"sha": "0ef4acc21cfb5e5066d34b1733708c4cc9cfd457", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0644b6286145246ccc7fd04b5ef724113d7edd5b", "patch": "@@ -4036,12 +4036,26 @@ output_fp_compare (insn, operands, eflags_p, unordered_p)\n   int stack_top_dies;\n   rtx cmp_op0 = operands[0];\n   rtx cmp_op1 = operands[1];\n+  int is_sse = SSE_REG_P (operands[0]) | SSE_REG_P (operands[1]);\n \n   if (eflags_p == 2)\n     {\n       cmp_op0 = cmp_op1;\n       cmp_op1 = operands[2];\n     }\n+  if (is_sse)\n+    {\n+      if (GET_MODE (operands[0]) == SFmode)\n+\tif (unordered_p)\n+\t  return \"ucomiss\\t{%1, %0|%0, %1}\";\n+\telse\n+\t  return \"comiss\\t{%1, %0|%0, %y}\";\n+      else\n+\tif (unordered_p)\n+\t  return \"ucomisd\\t{%1, %0|%0, %1}\";\n+\telse\n+\t  return \"comisd\\t{%1, %0|%0, %y}\";\n+    }\n \n   if (! STACK_TOP_P (cmp_op0))\n     abort ();\n@@ -4797,15 +4811,17 @@ ix86_prepare_fp_compare_args (code, pop0, pop1)\n   enum machine_mode fpcmp_mode = ix86_fp_compare_mode (code);\n   rtx op0 = *pop0, op1 = *pop1;\n   enum machine_mode op_mode = GET_MODE (op0);\n+  int is_sse = SSE_REG_P (op0) | SSE_REG_P (op1);\n \n   /* All of the unordered compare instructions only work on registers.\n      The same is true of the XFmode compare instructions.  The same is\n      true of the fcomi compare instructions.  */\n \n-  if (fpcmp_mode == CCFPUmode\n-      || op_mode == XFmode\n-      || op_mode == TFmode\n-      || ix86_use_fcomi_compare (code))\n+  if (!is_sse\n+      && (fpcmp_mode == CCFPUmode\n+\t  || op_mode == XFmode\n+\t  || op_mode == TFmode\n+\t  || ix86_use_fcomi_compare (code)))\n     {\n       op0 = force_reg (op_mode, op0);\n       op1 = force_reg (op_mode, op1);"}, {"sha": "1dd722c9a7681ee1b673a70b140e58fe495f1947", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0644b6286145246ccc7fd04b5ef724113d7edd5b", "patch": "@@ -194,7 +194,9 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n #define TARGET_UNROLL_STRLEN (x86_unroll_strlen & CPUMASK)\n #define TARGET_USE_Q_REG (x86_use_q_reg & CPUMASK)\n #define TARGET_USE_ANY_REG (x86_use_any_reg & CPUMASK)\n-#define TARGET_CMOVE (x86_cmove & (1 << ix86_arch))\n+/* For sane SSE instruction set generation we need fcomi instruction.  It is\n+   safe to enable all CMOVE instructions.  */\n+#define TARGET_CMOVE ((x86_cmove & (1 << ix86_arch)) || TARGET_SSE)\n #define TARGET_DEEP_BRANCH_PREDICTION (x86_deep_branch & CPUMASK)\n #define TARGET_DOUBLE_WITH_ADD (x86_double_with_add & CPUMASK)\n #define TARGET_USE_SAHF (x86_use_sahf & CPUMASK)"}, {"sha": "d85ec4d251019566549adbb16701f46b720847cd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 121, "deletions": 17, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0644b6286145246ccc7fd04b5ef724113d7edd5b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0644b6286145246ccc7fd04b5ef724113d7edd5b", "patch": "@@ -1268,7 +1268,7 @@\n   [(set (reg:CC 17)\n \t(compare:CC (match_operand:DF 0 \"cmp_fp_expander_operand\" \"\")\n \t\t    (match_operand:DF 1 \"cmp_fp_expander_operand\" \"\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE2\"\n   \"\n {\n   ix86_compare_op0 = operands[0];\n@@ -1280,7 +1280,7 @@\n   [(set (reg:CC 17)\n \t(compare:CC (match_operand:SF 0 \"cmp_fp_expander_operand\" \"\")\n \t\t    (match_operand:SF 1 \"cmp_fp_expander_operand\" \"\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"\n {\n   ix86_compare_op0 = operands[0];\n@@ -1504,24 +1504,72 @@\n \t(compare:CCFP (match_operand 0 \"register_operand\" \"f\")\n \t\t      (match_operand 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387 && TARGET_CMOVE\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[0])\"\n   \"* return output_fp_compare (insn, operands, 1, 0);\"\n   [(set_attr \"type\" \"fcmp\")\n    (set_attr \"mode\" \"unknownfp\")\n    (set_attr \"athlon_decode\" \"vector\")])\n \n+(define_insn \"*cmpfp_i_sse\"\n+  [(set (reg:CCFP 17)\n+\t(compare:CCFP (match_operand 0 \"register_operand\" \"f#x,x#f\")\n+\t\t      (match_operand 1 \"nonimmediate_operand\" \"f#x,xm#f\")))]\n+  \"TARGET_80387\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && GET_MODE (operands[0]) == GET_MODE (operands[0])\"\n+  \"* return output_fp_compare (insn, operands, 1, 0);\"\n+  [(set_attr \"type\" \"fcmp,sse\")\n+   (set_attr \"mode\" \"unknownfp\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n+\n+(define_insn \"*cmpfp_i_sse_only\"\n+  [(set (reg:CCFP 17)\n+\t(compare:CCFP (match_operand 0 \"register_operand\" \"x\")\n+\t\t      (match_operand 1 \"nonimmediate_operand\" \"xm\")))]\n+  \"SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && GET_MODE (operands[0]) == GET_MODE (operands[0])\"\n+  \"* return output_fp_compare (insn, operands, 1, 0);\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"unknownfp\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n+\n (define_insn \"*cmpfp_iu\"\n   [(set (reg:CCFPU 17)\n \t(compare:CCFPU (match_operand 0 \"register_operand\" \"f\")\n \t\t       (match_operand 1 \"register_operand\" \"f\")))]\n   \"TARGET_80387 && TARGET_CMOVE\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n    && FLOAT_MODE_P (GET_MODE (operands[0]))\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n   \"* return output_fp_compare (insn, operands, 1, 1);\"\n   [(set_attr \"type\" \"fcmp\")\n    (set_attr \"mode\" \"unknownfp\")\n    (set_attr \"athlon_decode\" \"vector\")])\n+\n+(define_insn \"*cmpfp_iu_sse\"\n+  [(set (reg:CCFPU 17)\n+\t(compare:CCFPU (match_operand 0 \"register_operand\" \"f#x,x#f\")\n+\t\t       (match_operand 1 \"nonimmediate_operand\" \"f#x,xm#f\")))]\n+  \"TARGET_80387\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n+  \"* return output_fp_compare (insn, operands, 1, 1);\"\n+  [(set_attr \"type\" \"fcmp,sse\")\n+   (set_attr \"mode\" \"unknownfp\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n+\n+(define_insn \"*cmpfp_iu_sse_only\"\n+  [(set (reg:CCFPU 17)\n+\t(compare:CCFPU (match_operand 0 \"register_operand\" \"x\")\n+\t\t       (match_operand 1 \"nonimmediate_operand\" \"xm\")))]\n+  \"SSE_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && GET_MODE (operands[0]) == GET_MODE (operands[1])\"\n+  \"* return output_fp_compare (insn, operands, 1, 1);\"\n+  [(set_attr \"type\" \"sse\")\n+   (set_attr \"mode\" \"unknownfp\")\n+   (set_attr \"athlon_decode\" \"vector\")])\n \f\n ;; Move instructions.\n \n@@ -9205,7 +9253,7 @@\n (define_expand \"sunordered\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (unordered:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNORDERED, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sordered\"\n@@ -9217,37 +9265,37 @@\n (define_expand \"suneq\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (uneq:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNEQ, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunge\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (unge:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNGE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sungt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (ungt:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNGT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunle\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (unle:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNLE, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sunlt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (unlt:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (UNLT, operands[0])) DONE; else FAIL;\")\n \n (define_expand \"sltgt\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (ltgt:SI (reg:CC 17) (const_int 0)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"if (ix86_expand_setcc (LTGT, operands[0])) DONE; else FAIL;\")\n \n (define_insn \"*setcc_1\"\n@@ -9360,63 +9408,63 @@\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (UNORDERED, operands[0]); DONE;\")\n \n (define_expand \"bordered\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (ORDERED, operands[0]); DONE;\")\n \n (define_expand \"buneq\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (UNEQ, operands[0]); DONE;\")\n \n (define_expand \"bunge\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (UNGE, operands[0]); DONE;\")\n \n (define_expand \"bungt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (UNGT, operands[0]); DONE;\")\n \n (define_expand \"bunle\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (UNLE, operands[0]); DONE;\")\n \n (define_expand \"bunlt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (UNLT, operands[0]); DONE;\")\n \n (define_expand \"bltgt\"\n   [(set (pc)\n \t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 || TARGET_SSE\"\n   \"ix86_expand_branch (LTGT, operands[0]); DONE;\")\n \n (define_insn \"*jcc_1\"\n@@ -9467,10 +9515,38 @@\n    (clobber (reg:CCFP 18))\n    (clobber (reg:CCFP 17))]\n   \"TARGET_CMOVE && TARGET_80387\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n   \"#\")\n \n+(define_insn \"*fp_jcc_1_sse\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"TARGET_80387\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_1_sse_only\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n (define_insn \"*fp_jcc_2\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n@@ -9481,10 +9557,38 @@\n    (clobber (reg:CCFP 18))\n    (clobber (reg:CCFP 17))]\n   \"TARGET_CMOVE && TARGET_80387\n+   && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n   \"#\")\n \n+(define_insn \"*fp_jcc_2_sse\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f#x,x#f\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"f#x,xm#f\")])\n+\t  (pc)\n+\t  (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"TARGET_80387\n+   && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n+(define_insn \"*fp_jcc_2_sse_only\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"x\")\n+\t\t\t (match_operand 2 \"nonimmediate_operand\" \"xm\")])\n+\t  (pc)\n+\t  (label_ref (match_operand 3 \"\" \"\"))))\n+   (clobber (reg:CCFP 18))\n+   (clobber (reg:CCFP 17))]\n+  \"SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+  \"#\")\n+\n (define_insn \"*fp_jcc_3\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\""}]}