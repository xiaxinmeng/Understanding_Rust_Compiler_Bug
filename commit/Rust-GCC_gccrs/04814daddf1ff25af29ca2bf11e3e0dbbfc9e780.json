{"sha": "04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ4MTRkYWRkZjFmZjI1YWYyOWNhMmJmMTFlM2UwZGJiZmM5ZTc4MA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2005-11-15T14:02:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T14:02:22Z"}, "message": "sem_ch12.ads, [...] (Map_Entities): Exclude entities whose names are internal...\n\n2005-11-14  Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch12.ads, sem_ch12.adb (Map_Entities): Exclude entities whose\n\tnames are internal, because they will not have a corresponding partner\n\tin the actual package.\n\t(Analyze_Formal_Package): Move the setting of the formal package spec's\n\tGeneric_Parent field so that it occurs prior to analyzing the package,\n\tto allow proper operation of Install_Parent_Private_Declarations.\n\t(Analyze_Package_Instantiation): Set the instantiated package entity's\n\tPackage_Instantiation field.\n\t(Get_Package_Instantiation_Node): Move declaration to package spec.\n\tRetrieve the N_Package_Instantiation node when the Package_Instantiation\n\tfield is present.\n\t(Check_Generic_Child_Unit): Within an inlined call, the only possible\n\tinstantiation is Unchecked_Conversion, for which no parents are needed.\n\t(Inline_Instance_Body): Deinstall and record the use_clauses for all\n\tparent scopes of a scope being removed prior to inlining an instance\n\tbody.\n\t(Analyze_Package_Instantiation): Do not perform front-end inlining when\n\tthe current context is itself an instance within a non-instance child\n\tunit, to prevent scope stack errors.\n\t(Save_References): If the node is an aggregate that is an actual in a\n\tcall, rewrite as a qualified expression to preserve some type\n\tinformation, to resolve possible ambiguities in the instance.\n\t(Instance_Parent_Unit): New global variable to record the ultimate\n\tparent unit associated with a generic child unit instance (associated\n\twith the existing Parent_Unit_Visible flag).\n\t(type Instance_Env): New component Instance_Parent_Unit for stacking\n\tparents recorded in the global Instance_Parent_Unit.\n\t(Init_Env): Save value of Instance_Parent_Unit in the Instance_Env\n\tstack.\n\t(Install_Spec): Save the parent unit entity in Instance_Parent_Unit when\n\tit's not a top-level unit, and only do this if Instance_Parent_Unit is\n\tnot already set. Replace test of Is_Child_Unit with test of parent's\n\tscope against package Standard. Add comments and a ??? comment.\n\t(Remove_Parent): Revise condition for resetting Is_Immediately_Visible\n\ton a child instance parent to test that the parent equals\n\tInstance_Parent rather than simply checking that the unit is not a\n\tchild unit.\n\t(Restore_Env): Restore value of Instance_Parent_Unit from Instance_Env.\n\t(Validate_Derived_Interface_Type_Instance): Verify that all ancestors of\n\ta formal interface are ancestors of the corresponding actual.\n\t(Validate_Formal_Interface_Type): Additional legality checks.\n\t(Analyze_Formal_Derived_Interface_Type): New procedure to handle formal\n\tinterface types with ancestors.\n\t(Analyze_Formal_Package): If formal is a renaming, use renamed entity\n\tto diagnose attempts to use generic within its own declaration.\n\nFrom-SVN: r106999", "tree": {"sha": "593d96e0c814df29aaec701b54d749207520d285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/593d96e0c814df29aaec701b54d749207520d285"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81d435f35b1ff34978cb764672faf6733ced9607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81d435f35b1ff34978cb764672faf6733ced9607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81d435f35b1ff34978cb764672faf6733ced9607"}], "stats": {"total": 413, "additions": 342, "deletions": 71}, "files": [{"sha": "470f5ed237ceee89c7cb49ec397fc8908aee3b51", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 335, "deletions": 69, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,7 @@ with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n with Lib.Xref; use Lib.Xref;\n with Nlists;   use Nlists;\n+with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Rident;   use Rident;\n@@ -256,6 +257,10 @@ package body Sem_Ch12 is\n \n    --  The following procedures treat other kinds of formal parameters\n \n+   procedure Analyze_Formal_Derived_Interface_Type\n+     (T   : Entity_Id;\n+      Def : Node_Id);\n+\n    procedure Analyze_Formal_Derived_Type\n      (N   : Node_Id;\n       T   : Entity_Id;\n@@ -271,6 +276,7 @@ package body Sem_Ch12 is\n                                                 (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Discrete_Type       (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Floating_Type       (T : Entity_Id; Def : Node_Id);\n+   procedure Analyze_Formal_Interface_Type      (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Signed_Integer_Type (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Modular_Type        (T : Entity_Id; Def : Node_Id);\n    procedure Analyze_Formal_Ordinary_Fixed_Point_Type\n@@ -390,11 +396,6 @@ package body Sem_Ch12 is\n    --  (component or index type of an array type) and Gen_Scope is the scope of\n    --  the analyzed formal array type.\n \n-   function Get_Package_Instantiation_Node (A : Entity_Id) return Node_Id;\n-   --  Given the entity of a unit that is an instantiation, retrieve the\n-   --  original instance node. This is used when loading the instantiations\n-   --  of the ancestors of a child generic that is being instantiated.\n-\n    function In_Same_Declarative_Part\n      (F_Node : Node_Id;\n       Inst   : Node_Id) return Boolean;\n@@ -685,17 +686,23 @@ package body Sem_Ch12 is\n    Parent_Unit_Visible : Boolean := False;\n    --  Parent_Unit_Visible is used when the generic is a child unit, and\n    --  indicates whether the ultimate parent of the generic is visible in the\n-   --  instantiation environment. It is used to reset the visiblity of the\n+   --  instantiation environment. It is used to reset the visibility of the\n    --  parent at the end of the instantiation (see Remove_Parent).\n \n+   Instance_Parent_Unit : Entity_Id := Empty;\n+   --  This records the ultimate parent unit of an instance of a generic\n+   --  child unit and is used in conjunction with Parent_Unit_Visible to\n+   --  indicate the unit to which the Parent_Unit_Visible flag corresponds.\n+\n    type Instance_Env is record\n       Ada_Version          : Ada_Version_Type;\n       Ada_Version_Explicit : Ada_Version_Type;\n       Instantiated_Parent  : Assoc;\n       Exchanged_Views      : Elist_Id;\n       Hidden_Entities      : Elist_Id;\n       Current_Sem_Unit     : Unit_Number_Type;\n-      Parent_Unit_Visible  : Boolean := False;\n+      Parent_Unit_Visible  : Boolean   := False;\n+      Instance_Parent_Unit : Entity_Id := Empty;\n    end record;\n \n    package Instance_Envs is new Table.Table (\n@@ -1015,7 +1022,7 @@ package body Sem_Ch12 is\n                        Instantiate_Type\n                          (Formal, Match, Analyzed_Formal, Assoc));\n \n-                     --  an instantiation is a freeze point for the actuals,\n+                     --  An instantiation is a freeze point for the actuals,\n                      --  unless this is a rewritten formal package.\n \n                      if Nkind (I_Node) /= N_Formal_Package_Declaration then\n@@ -1299,6 +1306,26 @@ package body Sem_Ch12 is\n       Check_Restriction (No_Fixed_Point, Def);\n    end Analyze_Formal_Decimal_Fixed_Point_Type;\n \n+   -------------------------------------------\n+   -- Analyze_Formal_Derived_Interface_Type --\n+   -------------------------------------------\n+\n+   procedure Analyze_Formal_Derived_Interface_Type\n+     (T : Entity_Id;\n+      Def : Node_Id)\n+   is\n+   begin\n+      Enter_Name (T);\n+      Set_Ekind  (T, E_Record_Type);\n+      Set_Etype  (T, T);\n+      Analyze (Subtype_Indication (Def));\n+      Analyze_Interface_Declaration (T, Def);\n+      Make_Class_Wide_Type (T);\n+      Set_Primitive_Operations (T, New_Elmt_List);\n+      Analyze_List (Interface_List (Def));\n+      Collect_Interfaces (Def, T);\n+   end Analyze_Formal_Derived_Interface_Type;\n+\n    ---------------------------------\n    -- Analyze_Formal_Derived_Type --\n    ---------------------------------\n@@ -1452,6 +1479,20 @@ package body Sem_Ch12 is\n       Check_Restriction (No_Floating_Point, Def);\n    end Analyze_Formal_Floating_Type;\n \n+   -----------------------------------\n+   -- Analyze_Formal_Interface_Type;--\n+   -----------------------------------\n+\n+   procedure Analyze_Formal_Interface_Type (T : Entity_Id; Def : Node_Id) is\n+   begin\n+      Enter_Name (T);\n+      Set_Ekind  (T, E_Record_Type);\n+      Set_Etype  (T, T);\n+      Analyze_Interface_Declaration (T, Def);\n+      Make_Class_Wide_Type (T);\n+      Set_Primitive_Operations (T, New_Elmt_List);\n+   end Analyze_Formal_Interface_Type;\n+\n    ---------------------------------\n    -- Analyze_Formal_Modular_Type --\n    ---------------------------------\n@@ -1630,6 +1671,12 @@ package body Sem_Ch12 is\n       Check_Generic_Child_Unit (Gen_Id, Parent_Installed);\n       Gen_Unit := Entity (Gen_Id);\n \n+      --  Check for a formal package that is a package renaming\n+\n+      if Present (Renamed_Object (Gen_Unit)) then\n+         Gen_Unit := Renamed_Object (Gen_Unit);\n+      end if;\n+\n       if Ekind (Gen_Unit) /= E_Generic_Package then\n          Error_Msg_N (\"expect generic package name\", Gen_Id);\n          Restore_Env;\n@@ -1664,12 +1711,6 @@ package body Sem_Ch12 is\n          end if;\n       end if;\n \n-      --  Check for a formal package that is a package renaming\n-\n-      if Present (Renamed_Object (Gen_Unit)) then\n-         Gen_Unit := Renamed_Object (Gen_Unit);\n-      end if;\n-\n       --  The formal package is treated like a regular instance, but only\n       --  the specification needs to be instantiated, to make entities visible.\n \n@@ -1703,6 +1744,7 @@ package body Sem_Ch12 is\n              (Original_Node (Gen_Decl), Empty, Instantiating => True);\n          Rewrite (N, New_N);\n          Set_Defining_Unit_Name (Specification (New_N), Formal);\n+         Set_Generic_Parent (Specification (N), Gen_Unit);\n          Set_Instance_Env (Gen_Unit, Formal);\n \n          Enter_Name (Formal);\n@@ -1760,10 +1802,9 @@ package body Sem_Ch12 is\n          --  instantiation, the defining_unit_name we need is in the\n          --  new tree and not in the original. (see Package_Instantiation).\n          --  A generic formal package is an instance, and can be used as\n-         --  an actual for an inner instance. Mark its generic parent.\n+         --  an actual for an inner instance.\n \n          Set_Ekind (Formal, E_Package);\n-         Set_Generic_Parent (Specification (N), Gen_Unit);\n          Set_Has_Completion (Formal, True);\n \n          Set_Ekind (Pack_Id, E_Package);\n@@ -2043,6 +2084,15 @@ package body Sem_Ch12 is\n               N_Access_Procedure_Definition            =>\n             Analyze_Generic_Access_Type (T, Def);\n \n+         --  Ada 2005: a interface declaration is encoded as an abstract\n+         --  record declaration or a abstract type derivation.\n+\n+         when N_Record_Definition                      =>\n+            Analyze_Formal_Interface_Type (T, Def);\n+\n+         when N_Derived_Type_Definition                =>\n+            Analyze_Formal_Derived_Interface_Type (T, Def);\n+\n          when N_Error                                  =>\n             null;\n \n@@ -2655,6 +2705,19 @@ package body Sem_Ch12 is\n                then\n                   Inline_Now := True;\n                end if;\n+\n+               --  If the current scope is itself an instance within a child\n+               --  unit, and that unit itself is not an instance, it is\n+               --  duplicated in the scope stack, and the unstacking mechanism\n+               --  in Inline_Instance_Body will fail. This loses some rare\n+               --  cases of optimization, and might be improved some day ????\n+\n+               if Is_Generic_Instance (Current_Scope)\n+                  and then Is_Child_Unit (Scope (Current_Scope))\n+                  and then not Is_Generic_Instance (Scope (Current_Scope))\n+               then\n+                  Inline_Now := False;\n+               end if;\n             end if;\n \n             Needs_Body :=\n@@ -2856,6 +2919,7 @@ package body Sem_Ch12 is\n \n             Set_Unit (Parent (N), Act_Decl);\n             Set_Parent_Spec (Act_Decl, Parent_Spec (N));\n+            Set_Package_Instantiation (Act_Decl_Id, N);\n             Analyze (Act_Decl);\n             Set_Unit (Parent (N), N);\n             Set_Body_Required (Parent (N), False);\n@@ -2974,23 +3038,29 @@ package body Sem_Ch12 is\n       S            : Entity_Id;\n \n    begin\n-      --  Case of generic unit defined in another unit. We must remove\n-      --  the complete context of the current unit to install that of\n-      --  the generic.\n+      --  Case of generic unit defined in another unit. We must remove the\n+      --  complete context of the current unit to install that of the generic.\n \n       if Gen_Comp /= Cunit_Entity (Current_Sem_Unit) then\n-         S := Current_Scope;\n \n-         while Present (S)\n-           and then S /= Standard_Standard\n-         loop\n-            Num_Scopes := Num_Scopes + 1;\n+         --  Add some comments for the following two loops ???\n \n-            Use_Clauses (Num_Scopes) :=\n-              (Scope_Stack.Table\n-                 (Scope_Stack.Last - Num_Scopes + 1).\n-                    First_Use_Clause);\n-            End_Use_Clauses (Use_Clauses (Num_Scopes));\n+         S := Current_Scope;\n+         while Present (S) and then S /= Standard_Standard loop\n+            loop\n+               Num_Scopes := Num_Scopes + 1;\n+\n+               Use_Clauses (Num_Scopes) :=\n+                 (Scope_Stack.Table\n+                    (Scope_Stack.Last - Num_Scopes + 1).\n+                       First_Use_Clause);\n+               End_Use_Clauses (Use_Clauses (Num_Scopes));\n+\n+               exit when Scope_Stack.Last - Num_Scopes + 1 = Scope_Stack.First\n+                 or else Scope_Stack.Table\n+                           (Scope_Stack.Last - Num_Scopes).Entity\n+                             = Scope (S);\n+            end loop;\n \n             exit when Is_Generic_Instance (S)\n               and then (In_Package_Body (S)\n@@ -3018,12 +3088,12 @@ package body Sem_Ch12 is\n             S := Scope (S);\n          end loop;\n \n-         --  Remove context of current compilation unit, unless we\n-         --  are within a nested package instantiation, in which case\n-         --  the context has been removed previously.\n+         --  Remove context of current compilation unit, unless we are within a\n+         --  nested package instantiation, in which case the context has been\n+         --  removed previously.\n \n-         --  If current scope is the body of a child unit, remove context\n-         --  of spec as well.\n+         --  If current scope is the body of a child unit, remove context of\n+         --  spec as well.\n \n          S := Current_Scope;\n \n@@ -3046,7 +3116,7 @@ package body Sem_Ch12 is\n                Removed := True;\n \n                --  Remove entities in current scopes from visibility, so\n-               --  than instance body is compiled in a clean environment.\n+               --  that instance body is compiled in a clean environment.\n \n                Save_Scope_Stack (Handle_Use => False);\n \n@@ -3077,6 +3147,7 @@ package body Sem_Ch12 is\n \n             S := Scope (S);\n          end loop;\n+         pragma Assert (Num_Inner < Num_Scopes);\n \n          New_Scope (Standard_Standard);\n          Scope_Stack.Table (Scope_Stack.Last).Is_Active_Stack_Base := True;\n@@ -4301,8 +4372,18 @@ package body Sem_Ch12 is\n          Instance_Decl      : Node_Id;\n \n       begin\n-         Enclosing_Instance := Current_Scope;\n+         --  We do not inline any call that contains instantiations, except\n+         --  for instantiations of Unchecked_Conversion, so if we are within\n+         --  an inlined body the current instance does not require parents.\n+\n+         if In_Inlined_Body then\n+            pragma Assert (Chars (Gen_Id) = Name_Unchecked_Conversion);\n+            return False;\n+         end if;\n+\n+         --  Loop to check enclosing scopes\n \n+         Enclosing_Instance := Current_Scope;\n          while Present (Enclosing_Instance) loop\n             Instance_Decl := Unit_Declaration_Node (Enclosing_Instance);\n \n@@ -5755,6 +5836,24 @@ package body Sem_Ch12 is\n       Inst : Node_Id;\n \n    begin\n+      --  If the Package_Instantiation attribute has been set on the package\n+      --  entity, then use it directly when it (or its Original_Node) refers\n+      --  to an N_Package_Instantiation node. In principle it should be\n+      --  possible to have this field set in all cases, which should be\n+      --  investigated, and would allow this function to be significantly\n+      --  simplified. ???\n+\n+      if Present (Package_Instantiation (A)) then\n+         if Nkind (Package_Instantiation (A)) = N_Package_Instantiation then\n+            return Package_Instantiation (A);\n+\n+         elsif Nkind (Original_Node (Package_Instantiation (A)))\n+                 = N_Package_Instantiation\n+         then\n+            return Original_Node (Package_Instantiation (A));\n+         end if;\n+      end if;\n+\n       --  If the instantiation is a compilation unit that does not need a\n       --  body then the instantiation node has been rewritten as a package\n       --  declaration for the instance, and we return the original node.\n@@ -5880,6 +5979,7 @@ package body Sem_Ch12 is\n       Saved.Hidden_Entities      := Hidden_Entities;\n       Saved.Current_Sem_Unit     := Current_Sem_Unit;\n       Saved.Parent_Unit_Visible  := Parent_Unit_Visible;\n+      Saved.Instance_Parent_Unit := Instance_Parent_Unit;\n       Instance_Envs.Increment_Last;\n       Instance_Envs.Table (Instance_Envs.Last) := Saved;\n \n@@ -6308,16 +6408,43 @@ package body Sem_Ch12 is\n                   Specification (Unit_Declaration_Node (Par));\n \n       begin\n-         if not Is_Child_Unit (Par) then\n+         --  If this parent of the child instance is a top-level unit,\n+         --  then record the unit and its visibility for later resetting\n+         --  in Remove_Parent. We exclude units that are generic instances,\n+         --  as we only want to record this information for the ultimate\n+         --  top-level noninstance parent (is that always correct???).\n+\n+         if Scope (Par) = Standard_Standard\n+           and then not Is_Generic_Instance (Par)\n+         then\n             Parent_Unit_Visible := Is_Immediately_Visible (Par);\n-         end if;\n+            Instance_Parent_Unit := Par;\n+         end if;\n+\n+         --  Open the parent scope and make it and its declarations visible.\n+         --  If this point is not within a body, then only the visible\n+         --  declarations should be made visible, and installation of the\n+         --  private declarations is deferred until the appropriate point\n+         --  within analysis of the spec being instantiated (see the handling\n+         --  of parent visibility in Analyze_Package_Specification). This is\n+         --  relaxed in the case where the parent unit is Ada.Tags, to avoid\n+         --  private view problems that occur when compiling instantiations of\n+         --  a generic child of that package (Generic_Dispatching_Constructor).\n+         --  If the instance freezes a tagged type, inlinings of operations\n+         --  from Ada.Tags may need the full view of type Tag. If inlining\n+         --  took proper account of establishing visibility of inlined\n+         --  subprograms' parents then it should be possible to remove this\n+         --  special check. ???\n \n          New_Scope (Par);\n          Set_Is_Immediately_Visible   (Par);\n          Install_Visible_Declarations (Par);\n-         Install_Private_Declarations (Par);\n          Set_Use (Visible_Declarations (Spec));\n-         Set_Use (Private_Declarations (Spec));\n+\n+         if In_Body or else Is_RTU (Par, Ada_Tags) then\n+            Install_Private_Declarations (Par);\n+            Set_Use (Private_Declarations (Spec));\n+         end if;\n       end Install_Spec;\n \n    --  Start of processing for Install_Parent\n@@ -6682,9 +6809,13 @@ package body Sem_Ch12 is\n          while Present (E1)\n            and then E1 /= First_Private_Entity (Form)\n          loop\n+            --  Could this test be a single condition???\n+            --  Seems like it could, and isn't FPE (Form) a constant anyway???\n+\n             if not Is_Internal (E1)\n-              and then not Is_Class_Wide_Type (E1)\n               and then Present (Parent (E1))\n+              and then not Is_Class_Wide_Type (E1)\n+              and then not Is_Internal_Name (Chars (E1))\n             then\n                while Present (E2)\n                  and then Chars (E2) /= Chars (E1)\n@@ -7941,6 +8072,8 @@ package body Sem_Ch12 is\n       procedure Validate_Access_Subprogram_Instance;\n       procedure Validate_Access_Type_Instance;\n       procedure Validate_Derived_Type_Instance;\n+      procedure Validate_Derived_Interface_Type_Instance;\n+      procedure Validate_Interface_Type_Instance;\n       procedure Validate_Private_Type_Instance;\n       --  These procedures perform validation tests for the named case\n \n@@ -8177,6 +8310,44 @@ package body Sem_Ch12 is\n \n       end Validate_Array_Type_Instance;\n \n+      -----------------------------------------------\n+      --  Validate_Derived_Interface_Type_Instance --\n+      -----------------------------------------------\n+\n+      procedure Validate_Derived_Interface_Type_Instance is\n+         Par  : constant Entity_Id := Entity (Subtype_Indication (Def));\n+         Elmt : Elmt_Id;\n+\n+      begin\n+         --  First apply interface instance checks\n+\n+         Validate_Interface_Type_Instance;\n+\n+         --  Verify that immediate parent interface is an ancestor of\n+         --  the actual.\n+\n+         if Present (Par)\n+           and then  not Interface_Present_In_Ancestor (Act_T, Par)\n+         then\n+            Error_Msg_NE\n+              (\"interface actual must include progenitor&\", Actual, Par);\n+         end if;\n+\n+         --  Now verify that the actual includes all other ancestors of\n+         --  the formal.\n+\n+         Elmt := First_Elmt (Abstract_Interfaces (A_Gen_T));\n+         while Present (Elmt) loop\n+            if not Interface_Present_In_Ancestor (Act_T, Node (Elmt)) then\n+               Error_Msg_NE\n+                 (\"interface actual must include progenitor&\",\n+                    Actual, Node (Elmt));\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end Validate_Derived_Interface_Type_Instance;\n+\n       ------------------------------------\n       -- Validate_Derived_Type_Instance --\n       ------------------------------------\n@@ -8186,18 +8357,18 @@ package body Sem_Ch12 is\n          Ancestor_Discr : Entity_Id;\n \n       begin\n-         --  If the parent type in the generic declaration is itself\n-         --  a previous formal type, then it is local to the generic\n-         --  and absent from the analyzed generic definition. In  that\n-         --  case the ancestor is the instance of the formal (which must\n-         --  have been instantiated previously), unless the ancestor is\n-         --  itself a formal derived type. In this latter case (which is the\n-         --  subject of Corrigendum 8652/0038 (AI-202) the ancestor of the\n-         --  formals is the ancestor of its parent. Otherwise, the analyzed\n-         --  generic carries the parent type. If the parent type is defined\n-         --  in a previous formal package, then the scope of that formal\n-         --  package is that of the generic type itself, and it has already\n-         --  been mapped into the corresponding type in the actual package.\n+         --  If the parent type in the generic declaration is itself a previous\n+         --  formal type, then it is local to the generic and absent from the\n+         --  analyzed generic definition. In that case the ancestor is the\n+         --  instance of the formal (which must have been instantiated\n+         --  previously), unless the ancestor is itself a formal derived type.\n+         --  In this latter case (which is the subject of Corrigendum 8652/0038\n+         --  (AI-202) the ancestor of the formals is the ancestor of its\n+         --  parent. Otherwise, the analyzed generic carries the parent type.\n+         --  If the parent type is defined in a previous formal package, then\n+         --  the scope of that formal package is that of the generic type\n+         --  itself, and it has already been mapped into the corresponding type\n+         --  in the actual package.\n \n          --  Common case: parent type defined outside of the generic\n \n@@ -8396,6 +8567,33 @@ package body Sem_Ch12 is\n          end if;\n       end Validate_Derived_Type_Instance;\n \n+      --------------------------------------\n+      -- Validate_Interface_Type_Instance --\n+      --------------------------------------\n+\n+      procedure Validate_Interface_Type_Instance is\n+      begin\n+         if not Is_Interface (Act_T) then\n+            Error_Msg_NE\n+              (\"actual for formal interface type must be an interface\",\n+                Actual, Gen_T);\n+\n+         elsif Is_Limited_Type (Act_T) /= Is_Limited_Type (A_Gen_T)\n+           or else\n+             Is_Task_Interface (A_Gen_T) /= Is_Task_Interface (Act_T)\n+           or else\n+             Is_Protected_Interface (A_Gen_T) /=\n+               Is_Protected_Interface (Act_T)\n+           or else\n+             Is_Synchronized_Interface (A_Gen_T) /=\n+               Is_Synchronized_Interface (Act_T)\n+         then\n+            Error_Msg_NE\n+              (\"actual for interface& does not match ('R'M 12.5.5(5))\",\n+                 Actual, Gen_T);\n+         end if;\n+      end Validate_Interface_Type_Instance;\n+\n       ------------------------------------\n       -- Validate_Private_Type_Instance --\n       ------------------------------------\n@@ -8661,6 +8859,12 @@ package body Sem_Ch12 is\n               N_Access_Procedure_Definition =>\n             Validate_Access_Subprogram_Instance;\n \n+         when N_Record_Definition           =>\n+            Validate_Interface_Type_Instance;\n+\n+         when N_Derived_Type_Definition     =>\n+            Validate_Derived_Interface_Type_Instance;\n+\n          when others =>\n             raise Program_Error;\n \n@@ -9116,12 +9320,16 @@ package body Sem_Ch12 is\n                   Install_Private_Declarations (P);\n                end if;\n \n-            --  If the ultimate parent is a compilation unit, reset its\n-            --  visibility to what it was before instantiation.\n+            --  If the ultimate parent is a top-level unit recorded in\n+            --  Instance_Parent_Unit, then reset its visibility to what\n+            --  it was before instantiation. (It's not clear what the\n+            --  purpose is of testing whether Scope (P) is In_Open_Scopes,\n+            --  but that test was present before the ultimate parent test\n+            --  was added.???)\n \n             elsif not In_Open_Scopes (Scope (P))\n-              or else\n-               (not Is_Child_Unit (P) and then not Parent_Unit_Visible)\n+              or else (P = Instance_Parent_Unit\n+                        and then not Parent_Unit_Visible)\n             then\n                Set_Is_Immediately_Visible (P, False);\n             end if;\n@@ -9175,6 +9383,7 @@ package body Sem_Ch12 is\n       Hidden_Entities              := Saved.Hidden_Entities;\n       Current_Sem_Unit             := Saved.Current_Sem_Unit;\n       Parent_Unit_Visible          := Saved.Parent_Unit_Visible;\n+      Instance_Parent_Unit         := Saved.Instance_Parent_Unit;\n \n       Instance_Envs.Decrement_Last;\n    end Restore_Env;\n@@ -9584,9 +9793,7 @@ package body Sem_Ch12 is\n                Set_Etype  (N, Empty);\n             end if;\n \n-            if (Nkind (Parent (N)) = N_Package_Instantiation\n-                 or else Nkind (Parent (N)) = N_Function_Instantiation\n-                 or else Nkind (Parent (N)) = N_Procedure_Instantiation)\n+            if Nkind (Parent (N)) in N_Generic_Instantiation\n               and then N = Name (Parent (N))\n             then\n                Save_Global_Defaults (Parent (N), Parent (N2));\n@@ -9595,7 +9802,6 @@ package body Sem_Ch12 is\n          elsif Nkind (Parent (N)) = N_Selected_Component\n            and then Nkind (Parent (N2)) = N_Expanded_Name\n          then\n-\n             if Is_Global (Entity (Parent (N2))) then\n                Change_Selected_Component_To_Expanded_Name (Parent (N));\n                Set_Associated_Node (Parent (N), Parent (N2));\n@@ -9626,11 +9832,7 @@ package body Sem_Ch12 is\n                end if;\n             end if;\n \n-            if (Nkind (Parent (Parent (N))) = N_Package_Instantiation\n-                 or else Nkind (Parent (Parent (N)))\n-                   = N_Function_Instantiation\n-                 or else Nkind (Parent (Parent (N)))\n-                   = N_Procedure_Instantiation)\n+            if Nkind (Parent (Parent (N))) in N_Generic_Instantiation\n               and then Parent (N) = Name (Parent (Parent (N)))\n             then\n                Save_Global_Defaults\n@@ -10054,6 +10256,11 @@ package body Sem_Ch12 is\n \n          else\n             declare\n+               Loc  : constant Source_Ptr := Sloc (N);\n+               Qual : Node_Id := Empty;\n+               Typ  : Entity_Id := Empty;\n+               Nam  : Node_Id;\n+\n                use Atree.Unchecked_Access;\n                --  This code section is part of implementing an untyped tree\n                --  traversal, so it needs direct access to node fields.\n@@ -10065,18 +10272,77 @@ package body Sem_Ch12 is\n                then\n                   N2 := Get_Associated_Node (N);\n \n+                  if No (N2) then\n+                     Typ := Empty;\n+                  else\n+                     Typ := Etype (N2);\n+\n+                     --  In an instance within a generic, use the name of\n+                     --  the actual and not the original generic parameter.\n+                     --  If the actual is global in the current generic it\n+                     --  must be preserved for its instantiation.\n+\n+                     if Nkind (Parent (Typ)) = N_Subtype_Declaration\n+                       and then\n+                         Present (Generic_Parent_Type (Parent (Typ)))\n+                     then\n+                        Typ := Base_Type (Typ);\n+                        Set_Etype (N2, Typ);\n+                     end if;\n+                  end if;\n+\n                   if No (N2)\n-                    or else No (Etype (N2))\n-                    or else not Is_Global (Etype (N2))\n+                    or else No (Typ)\n+                    or else not Is_Global (Typ)\n                   then\n                      Set_Associated_Node (N, Empty);\n+\n+                     --  If the aggregate is an actual in a call, it has been\n+                     --  resolved in the current context, to some local type.\n+                     --  The enclosing call may have been disambiguated by\n+                     --  the aggregate, and this disambiguation might fail at\n+                     --  instantiation time because the type to which the\n+                     --  aggregate did resolve is not preserved. In order to\n+                     --  preserve some of this information, we wrap the\n+                     --  aggregate in a qualified expression, using the id of\n+                     --  its type. For further disambiguation we qualify the\n+                     --  type name with its scope (if visible) because both\n+                     --  id's will have corresponding entities in an instance.\n+                     --  This resolves most of the problems with missing type\n+                     --  information on aggregates in instances.\n+\n+                     if Nkind (N2) = Nkind (N)\n+                       and then\n+                         (Nkind (Parent (N2)) = N_Procedure_Call_Statement\n+                           or else Nkind (Parent (N2)) = N_Function_Call)\n+                       and then Comes_From_Source (Typ)\n+                     then\n+                        if Is_Immediately_Visible (Scope (Typ)) then\n+                           Nam := Make_Selected_Component (Loc,\n+                             Prefix =>\n+                               Make_Identifier (Loc, Chars (Scope (Typ))),\n+                             Selector_Name =>\n+                               Make_Identifier (Loc, Chars (Typ)));\n+                        else\n+                           Nam := Make_Identifier (Loc, Chars (Typ));\n+                        end if;\n+\n+                        Qual :=\n+                          Make_Qualified_Expression (Loc,\n+                            Subtype_Mark => Nam,\n+                            Expression => Relocate_Node (N));\n+                     end if;\n                   end if;\n \n                   Save_Global_Descendant (Field1 (N));\n                   Save_Global_Descendant (Field2 (N));\n                   Save_Global_Descendant (Field3 (N));\n                   Save_Global_Descendant (Field5 (N));\n \n+                  if Present (Qual) then\n+                     Rewrite (N, Qual);\n+                  end if;\n+\n                --  All other cases than aggregates\n \n                else"}, {"sha": "f9634bdff65714fe79f732af05a7b8ec9370b625", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04814daddf1ff25af29ca2bf11e3e0dbbfc9e780/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=04814daddf1ff25af29ca2bf11e3e0dbbfc9e780", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,7 +39,7 @@ package Sem_Ch12 is\n    procedure Analyze_Formal_Package                     (N : Node_Id);\n \n    procedure Start_Generic;\n-   --  Must be invoked before starting to process a generic spec or body.\n+   --  Must be invoked before starting to process a generic spec or body\n \n    procedure End_Generic;\n    --  Must be invoked just at the end of the end of the processing of a\n@@ -70,6 +70,11 @@ package Sem_Ch12 is\n    --  Retrieve actual associated with given generic parameter.\n    --  If A is uninstantiated or not a generic parameter, return A.\n \n+   function Get_Package_Instantiation_Node (A : Entity_Id) return Node_Id;\n+   --  Given the entity of a unit that is an instantiation, retrieve the\n+   --  original instance node. This is used when loading the instantiations\n+   --  of the ancestors of a child generic that is being instantiated.\n+\n    procedure Instantiate_Package_Body\n      (Body_Info    : Pending_Body_Info;\n       Inlined_Body : Boolean := False);"}]}