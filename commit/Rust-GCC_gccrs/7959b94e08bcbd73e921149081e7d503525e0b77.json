{"sha": "7959b94e08bcbd73e921149081e7d503525e0b77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk1OWI5NGUwOGJjYmQ3M2U5MjExNDkwODFlN2Q1MDM1MjVlMGI3Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-10-25T19:35:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-10-25T19:35:52Z"}, "message": "rl78.c (insn_ok_now): Always re-recognize the insn if returning false.\n\n\t* config/rl78/rl78.c (insn_ok_now): Always re-recognize the insn\n\tif returning false.\n\nFrom-SVN: r265505", "tree": {"sha": "baee35d811f07a61fe73db70f348b06677f2ad46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baee35d811f07a61fe73db70f348b06677f2ad46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7959b94e08bcbd73e921149081e7d503525e0b77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7959b94e08bcbd73e921149081e7d503525e0b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7959b94e08bcbd73e921149081e7d503525e0b77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7959b94e08bcbd73e921149081e7d503525e0b77/comments", "author": null, "committer": null, "parents": [{"sha": "b15e280216048868aca98f2c4e3aa0b6559fd468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15e280216048868aca98f2c4e3aa0b6559fd468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15e280216048868aca98f2c4e3aa0b6559fd468"}], "stats": {"total": 57, "additions": 34, "deletions": 23}, "files": [{"sha": "186ffe83a8a2ec493959c9a6c74d32b9f3ba7f99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7959b94e08bcbd73e921149081e7d503525e0b77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7959b94e08bcbd73e921149081e7d503525e0b77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7959b94e08bcbd73e921149081e7d503525e0b77", "patch": "@@ -1,3 +1,8 @@\n+2018-10-25  Jeff Law  <law@redhat.com>\n+\n+\t* config/rl78/rl78.c (insn_ok_now): Always re-recognize the insn\n+\tif returning false.\n+\n 2018-10-25  Martin Sebor  <msebor@redhat.com>\n \n \t* doc/extend.texi (aligned): Expand attribute description."}, {"sha": "7986e89e3d8e3f2af59904aacb2a3946d9bde8d8", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7959b94e08bcbd73e921149081e7d503525e0b77/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7959b94e08bcbd73e921149081e7d503525e0b77/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=7959b94e08bcbd73e921149081e7d503525e0b77", "patch": "@@ -2736,38 +2736,44 @@ insn_ok_now (rtx_insn * insn)\n \t    if (GET_CODE (OP (i)) == MEM\n \t\t&& GET_MODE (XEXP (OP (i), 0)) == SImode\n \t\t&& GET_CODE (XEXP (OP (i), 0)) != UNSPEC)\n-\t      return false;\n+\t      goto not_ok;\n \n \t  return true;\n \t}\n     }\n-  else\n-    {\n-      /* We need to re-recog the insn with virtual registers to get\n-\t the operands.  */\n-      cfun->machine->virt_insns_ok = 1;\n-      if (recog (pattern, insn, 0) > -1)\n-\t{\n-\t  extract_insn (insn);\n-\t  if (constrain_operands (0, get_preferred_alternatives (insn)))\n-\t    {\n-\t      cfun->machine->virt_insns_ok = 0;\n-\t      return false;\n-\t    }\n-\t}\n \n-#if DEBUG_ALLOC\n-      fprintf (stderr, \"\\033[41;30m Unrecognized *virtual* insn \\033[0m\\n\");\n-      debug_rtx (insn);\n-#endif\n-      gcc_unreachable ();\n-    }\n+  /* INSN is not OK as-is.  It may not be recognized in real mode or\n+     it might not have satisfied its constraints in real mode.  Either\n+     way it will require fixups.\n+\n+     It is vital we always re-recognize at this point as some insns\n+     have fewer operands in real mode than virtual mode.  If we do\n+     not re-recognize, then the recog_data will refer to real mode\n+     operands and we may read invalid data.  Usually this isn't a\n+     problem, but once in a while the data we read is bogus enough\n+     to cause a segfault or other undesirable behavior.  */\n+ not_ok:\n+\n+  /* We need to re-recog the insn with virtual registers to get\n+     the operands.  */\n+    INSN_CODE (insn) = -1;\n+    cfun->machine->virt_insns_ok = 1;\n+    if (recog (pattern, insn, 0) > -1)\n+      {\n+\textract_insn (insn);\n+\t/* In theory this should always be true.  */\n+\tif (constrain_operands (0, get_preferred_alternatives (insn)))\n+\t  {\n+\t    cfun->machine->virt_insns_ok = 0;\n+\t    return false;\n+\t  }\n+      }\n \n #if DEBUG_ALLOC\n-  fprintf (stderr, \"\\033[31m\");\n+  fprintf (stderr, \"\\033[41;30m Unrecognized *virtual* insn \\033[0m\\n\");\n   debug_rtx (insn);\n-  fprintf (stderr, \"\\033[0m\");\n #endif\n+  gcc_unreachable ();\n   return false;\n }\n "}]}