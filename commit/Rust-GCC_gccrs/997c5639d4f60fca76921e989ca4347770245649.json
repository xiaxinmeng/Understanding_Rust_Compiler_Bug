{"sha": "997c5639d4f60fca76921e989ca4347770245649", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3YzU2MzlkNGY2MGZjYTc2OTIxZTk4OWNhNDM0Nzc3MDI0NTY0OQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T00:36:14Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T00:36:14Z"}, "message": "cprop.c: Use rtx_insn\n\ngcc/\n2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n\n\t* cprop.c (struct occr): Strengthen field \"insn\" from rtx to\n\trtx_insn *.\n\t(reg_available_p): Likewise for param \"insn\".\n\t(insert_set_in_table): Likewise.\n\t(hash_scan_set): Likewise.\n\t(hash_scan_insn): Likewise.\n\t(make_set_regs_unavailable): Likewise.\n\t(compute_hash_table_work): Likewise for local \"insn\".\n\t(reg_not_set_p): Strengthen param \"insn\" from const_rtx to\n\tconst rtx_insn *.\n\t(mark_oprs_set): Strengthen param \"insn\" from rtx to rtx_insn *.\n\t(try_replace_reg): Likewise.\n\t(find_avail_set): Likewise.\n\t(cprop_jump): Likewise for params \"setcc\", \"jump\".\n\t(constprop_register): Likewise for param \"insn\".\n\t(cprop_insn): Likewise.\n\t(do_local_cprop): Likewise.\n\t(local_cprop_pass): Likewise for local \"insn\".\n\t(bypass_block): Likewise for params \"setcc\" and \"jump\".\n\t(bypass_conditional_jumps): Likewise for locals \"setcc\" and\n\t\"insn\".\n\t(one_cprop_pass): Likewise for local \"insn\".\n\nFrom-SVN: r214303", "tree": {"sha": "5836f98dbf32cdb89507fbf2bafcb62c2773aa5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5836f98dbf32cdb89507fbf2bafcb62c2773aa5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/997c5639d4f60fca76921e989ca4347770245649", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997c5639d4f60fca76921e989ca4347770245649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997c5639d4f60fca76921e989ca4347770245649", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997c5639d4f60fca76921e989ca4347770245649/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c566b8285e00ca746f6e747e78d54fad02fb746e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c566b8285e00ca746f6e747e78d54fad02fb746e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c566b8285e00ca746f6e747e78d54fad02fb746e"}], "stats": {"total": 75, "additions": 51, "deletions": 24}, "files": [{"sha": "6d91da012da9486ae8a268ebbc9bbc7f7ab0e1fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997c5639d4f60fca76921e989ca4347770245649/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997c5639d4f60fca76921e989ca4347770245649/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=997c5639d4f60fca76921e989ca4347770245649", "patch": "@@ -1,3 +1,28 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cprop.c (struct occr): Strengthen field \"insn\" from rtx to\n+\trtx_insn *.\n+\t(reg_available_p): Likewise for param \"insn\".\n+\t(insert_set_in_table): Likewise.\n+\t(hash_scan_set): Likewise.\n+\t(hash_scan_insn): Likewise.\n+\t(make_set_regs_unavailable): Likewise.\n+\t(compute_hash_table_work): Likewise for local \"insn\".\n+\t(reg_not_set_p): Strengthen param \"insn\" from const_rtx to\n+\tconst rtx_insn *.\n+\t(mark_oprs_set): Strengthen param \"insn\" from rtx to rtx_insn *.\n+\t(try_replace_reg): Likewise.\n+\t(find_avail_set): Likewise.\n+\t(cprop_jump): Likewise for params \"setcc\", \"jump\".\n+\t(constprop_register): Likewise for param \"insn\".\n+\t(cprop_insn): Likewise.\n+\t(do_local_cprop): Likewise.\n+\t(local_cprop_pass): Likewise for local \"insn\".\n+\t(bypass_block): Likewise for params \"setcc\" and \"jump\".\n+\t(bypass_conditional_jumps): Likewise for locals \"setcc\" and\n+\t\"insn\".\n+\t(one_cprop_pass): Likewise for local \"insn\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* compare-elim.c (struct comparison_use): Strengthen field \"insn\""}, {"sha": "6d2615e8702935d1f304a91723da4de869cbe2ec", "filename": "gcc/cprop.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997c5639d4f60fca76921e989ca4347770245649/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997c5639d4f60fca76921e989ca4347770245649/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=997c5639d4f60fca76921e989ca4347770245649", "patch": "@@ -60,7 +60,7 @@ struct occr\n   /* Next occurrence of this expression.  */\n   struct occr *next;\n   /* The insn that computes the expression.  */\n-  rtx insn;\n+  rtx_insn *insn;\n };\n \n typedef struct occr *occr_t;\n@@ -154,7 +154,7 @@ cprop_alloc (unsigned long size)\n    of INSN's basic block.  */\n \n static int\n-reg_available_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n+reg_available_p (const_rtx x, const rtx_insn *insn ATTRIBUTE_UNUSED)\n {\n   return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n }\n@@ -179,8 +179,8 @@ hash_mod (int regno, int hash_table_size)\n    IMPLICIT is true if it's an implicit set, false otherwise.  */\n \n static void\n-insert_set_in_table (rtx dest, rtx src, rtx insn, struct hash_table_d *table,\n-\t\t     bool implicit)\n+insert_set_in_table (rtx dest, rtx src, rtx_insn *insn,\n+\t\t     struct hash_table_d *table, bool implicit)\n {\n   bool found = false;\n   unsigned int hash;\n@@ -264,7 +264,8 @@ cprop_constant_p (const_rtx x)\n    IMPLICIT is true if it's an implicit set, false otherwise.  */\n \n static void\n-hash_scan_set (rtx set, rtx insn, struct hash_table_d *table, bool implicit)\n+hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table,\n+\t       bool implicit)\n {\n   rtx src = SET_SRC (set);\n   rtx dest = SET_DEST (set);\n@@ -307,7 +308,7 @@ hash_scan_set (rtx set, rtx insn, struct hash_table_d *table, bool implicit)\n /* Process INSN and add hash table entries as appropriate.  */\n \n static void\n-hash_scan_insn (rtx insn, struct hash_table_d *table)\n+hash_scan_insn (rtx_insn *insn, struct hash_table_d *table)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -372,7 +373,7 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n /* Record as unavailable all registers that are DEF operands of INSN.  */\n \n static void\n-make_set_regs_unavailable (rtx insn)\n+make_set_regs_unavailable (rtx_insn *insn)\n {\n   df_ref def;\n \n@@ -401,7 +402,7 @@ compute_hash_table_work (struct hash_table_d *table)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       /* Reset tables used to keep track of what's not yet invalid [since\n \t the end of the block].  */\n@@ -521,7 +522,7 @@ reset_opr_set_tables (void)\n    start of the basic block containing INSN].  */\n \n static int\n-reg_not_set_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n+reg_not_set_p (const_rtx x, const rtx_insn *insn ATTRIBUTE_UNUSED)\n {\n   return ! REGNO_REG_SET_P (reg_set_bitmap, REGNO (x));\n }\n@@ -530,7 +531,7 @@ reg_not_set_p (const_rtx x, const_rtx insn ATTRIBUTE_UNUSED)\n    This data is used by reg_not_set_p.  */\n \n static void\n-mark_oprs_set (rtx insn)\n+mark_oprs_set (rtx_insn *insn)\n {\n   df_ref def;\n \n@@ -725,7 +726,7 @@ find_used_regs (rtx *xptr, void *data ATTRIBUTE_UNUSED)\n    Return nonzero if successful.  */\n \n static int\n-try_replace_reg (rtx from, rtx to, rtx insn)\n+try_replace_reg (rtx from, rtx to, rtx_insn *insn)\n {\n   rtx note = find_reg_equal_equiv_note (insn);\n   rtx src = 0;\n@@ -799,7 +800,7 @@ try_replace_reg (rtx from, rtx to, rtx insn)\n    NULL no such set is found.  */\n \n static struct expr *\n-find_avail_set (int regno, rtx insn)\n+find_avail_set (int regno, rtx_insn *insn)\n {\n   /* SET1 contains the last set found that can be returned to the caller for\n      use in a substitution.  */\n@@ -869,7 +870,7 @@ find_avail_set (int regno, rtx insn)\n    if a change was made.  */\n \n static int\n-cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n+cprop_jump (basic_block bb, rtx_insn *setcc, rtx_insn *jump, rtx from, rtx src)\n {\n   rtx new_rtx, set_src, note_src;\n   rtx set = pc_set (jump);\n@@ -901,7 +902,7 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n \t\t\t\t      setcc_src);\n     }\n   else\n-    setcc = NULL_RTX;\n+    setcc = NULL;\n \n   new_rtx = simplify_replace_rtx (set_src, from, src);\n \n@@ -982,7 +983,7 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n    it and INSN is the instruction where this will be happening.  */\n \n static int\n-constprop_register (rtx from, rtx src, rtx insn)\n+constprop_register (rtx from, rtx src, rtx_insn *insn)\n {\n   rtx sset;\n \n@@ -1018,7 +1019,7 @@ constprop_register (rtx from, rtx src, rtx insn)\n    Return nonzero if a change was made.  */\n \n static int\n-cprop_insn (rtx insn)\n+cprop_insn (rtx_insn *insn)\n {\n   unsigned i;\n   int changed = 0, changed_this_round;\n@@ -1158,7 +1159,7 @@ local_cprop_find_used_regs (rtx *xptr, void *data)\n /* Try to perform local const/copy propagation on X in INSN.  */\n \n static bool\n-do_local_cprop (rtx x, rtx insn)\n+do_local_cprop (rtx x, rtx_insn *insn)\n {\n   rtx newreg = NULL, newcnst = NULL;\n \n@@ -1227,7 +1228,7 @@ static int\n local_cprop_pass (void)\n {\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n   bool changed = false;\n   unsigned i;\n \n@@ -1489,9 +1490,10 @@ reg_killed_on_edge (const_rtx reg, const_edge e)\n    these inserted insns when performing its transformations.  */\n \n static int\n-bypass_block (basic_block bb, rtx setcc, rtx jump)\n+bypass_block (basic_block bb, rtx_insn *setcc, rtx_insn *jump)\n {\n-  rtx insn, note;\n+  rtx_insn *insn;\n+  rtx note;\n   edge e, edest;\n   int change;\n   int may_be_loop_header = false;\n@@ -1657,8 +1659,8 @@ bypass_conditional_jumps (void)\n {\n   basic_block bb;\n   int changed;\n-  rtx setcc;\n-  rtx insn;\n+  rtx_insn *setcc;\n+  rtx_insn *insn;\n   rtx dest;\n \n   /* Note we start at block 1.  */\n@@ -1675,7 +1677,7 @@ bypass_conditional_jumps (void)\n       /* Check for more than one predecessor.  */\n       if (!single_pred_p (bb))\n \t{\n-\t  setcc = NULL_RTX;\n+\t  setcc = NULL;\n \t  FOR_BB_INSNS (bb, insn)\n \t    if (DEBUG_INSN_P (insn))\n \t      continue;\n@@ -1823,7 +1825,7 @@ one_cprop_pass (void)\n   if (set_hash_table.n_elems > 0)\n     {\n       basic_block bb;\n-      rtx insn;\n+      rtx_insn *insn;\n \n       alloc_cprop_mem (last_basic_block_for_fn (cfun),\n \t\t       set_hash_table.n_elems);"}]}