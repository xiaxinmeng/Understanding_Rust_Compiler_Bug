{"sha": "972eab51f53d1db26864ec7d62d40c2ff83407ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyZWFiNTFmNTNkMWRiMjY4NjRlYzdkNjJkNDBjMmZmODM0MDdlYw==", "commit": {"author": {"name": "Martin Uecker", "email": "muecker@gwdg.de", "date": "2021-08-22T21:47:58Z"}, "committer": {"name": "Martin Uecker", "email": "muecker@gwdg.de", "date": "2021-08-22T22:15:17Z"}, "message": "Correct treatment of qualifiers for pointers to arrays for C2X [PR98397]\n\n2021-08-22  Martin Uecker  <muecker@gwdg.de>\n\ngcc/c/\n\tPR c/98397\n\t* c-typeck.c (comp_target_types): Change pedwarn to pedwarn_c11\n\tfor pointers to arrays with qualifiers.\n\t(build_conditional_expr): For C23 don't lose qualifiers for pointers\n\tto arrays when the other pointer is a void pointer. Update warnings.\n\t(convert_for_assignment): Update warnings for C2X when converting from\n\tvoid* with qualifiers to a pointer to array with the same qualifiers.\n\ngcc/testsuite/\n\tPR c/98397\n\t* gcc.dg/c11-qual-1.c: New test.\n\t* gcc.dg/c2x-qual-1.c: New test.\n\t* gcc.dg/c2x-qual-2.c: New test.\n\t* gcc.dg/c2x-qual-3.c: New test.\n\t* gcc.dg/c2x-qual-4.c: New test.\n\t* gcc.dg/c2x-qual-5.c: New test.\n\t* gcc.dg/c2x-qual-6.c: New test.\n\t* gcc.dg/c2x-qual-7.c: New test.\n\t* gcc.dg/pointer-array-quals-1.c: Remove unnecessary flag.\n\t* gcc.dg/pointer-array-quals-2.c: Remove unnecessary flag.", "tree": {"sha": "46489f7d3076d7d301721ed6f52c6fc0531ef842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46489f7d3076d7d301721ed6f52c6fc0531ef842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/972eab51f53d1db26864ec7d62d40c2ff83407ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972eab51f53d1db26864ec7d62d40c2ff83407ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/972eab51f53d1db26864ec7d62d40c2ff83407ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972eab51f53d1db26864ec7d62d40c2ff83407ec/comments", "author": {"login": "uecker", "id": 2036635, "node_id": "MDQ6VXNlcjIwMzY2MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/2036635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uecker", "html_url": "https://github.com/uecker", "followers_url": "https://api.github.com/users/uecker/followers", "following_url": "https://api.github.com/users/uecker/following{/other_user}", "gists_url": "https://api.github.com/users/uecker/gists{/gist_id}", "starred_url": "https://api.github.com/users/uecker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uecker/subscriptions", "organizations_url": "https://api.github.com/users/uecker/orgs", "repos_url": "https://api.github.com/users/uecker/repos", "events_url": "https://api.github.com/users/uecker/events{/privacy}", "received_events_url": "https://api.github.com/users/uecker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "uecker", "id": 2036635, "node_id": "MDQ6VXNlcjIwMzY2MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/2036635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uecker", "html_url": "https://github.com/uecker", "followers_url": "https://api.github.com/users/uecker/followers", "following_url": "https://api.github.com/users/uecker/following{/other_user}", "gists_url": "https://api.github.com/users/uecker/gists{/gist_id}", "starred_url": "https://api.github.com/users/uecker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uecker/subscriptions", "organizations_url": "https://api.github.com/users/uecker/orgs", "repos_url": "https://api.github.com/users/uecker/repos", "events_url": "https://api.github.com/users/uecker/events{/privacy}", "received_events_url": "https://api.github.com/users/uecker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b08f7764cecd16cba84944f2a8b67a7f73a7ce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b08f7764cecd16cba84944f2a8b67a7f73a7ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b08f7764cecd16cba84944f2a8b67a7f73a7ce7"}], "stats": {"total": 629, "additions": 532, "deletions": 97}, "files": [{"sha": "d9f26d67bd33fad5e68e48a04989deac5ecd4658", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 93, "deletions": 95, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -1328,8 +1328,8 @@ comp_target_types (location_t location, tree ttl, tree ttr)\n   val = comptypes_check_enum_int (mvl, mvr, &enum_and_int_p);\n \n   if (val == 1 && val_ped != 1)\n-    pedwarn (location, OPT_Wpedantic, \"pointers to arrays with different qualifiers \"\n-                                      \"are incompatible in ISO C\");\n+    pedwarn_c11 (location, OPT_Wpedantic, \"invalid use of pointers to arrays with different qualifiers \"\n+\t\t\t\t\t  \"in ISO C before C2X\");\n \n   if (val == 2)\n     pedwarn (location, OPT_Wpedantic, \"types are not quite compatible\");\n@@ -5406,39 +5406,41 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t\t    \"used in conditional expression\");\n \t  return error_mark_node;\n \t}\n-      else if (VOID_TYPE_P (TREE_TYPE (type1))\n-\t       && !TYPE_ATOMIC (TREE_TYPE (type1)))\n-\t{\n-\t  if ((TREE_CODE (TREE_TYPE (type2)) == ARRAY_TYPE)\n-\t      && (TYPE_QUALS (strip_array_types (TREE_TYPE (type2)))\n-\t\t  & ~TYPE_QUALS (TREE_TYPE (type1))))\n-\t    warning_at (colon_loc, OPT_Wdiscarded_array_qualifiers,\n-\t\t\t\"pointer to array loses qualifier \"\n-\t\t\t\"in conditional expression\");\n-\n-\t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n+      else if ((VOID_TYPE_P (TREE_TYPE (type1))\n+\t\t&& !TYPE_ATOMIC (TREE_TYPE (type1)))\n+\t       || (VOID_TYPE_P (TREE_TYPE (type2))\n+\t\t   && !TYPE_ATOMIC (TREE_TYPE (type2))))\n+\t{\n+\t  tree t1 = TREE_TYPE (type1);\n+\t  tree t2 = TREE_TYPE (type2);\n+\t  if (!(VOID_TYPE_P (t1)\n+\t\t&& !TYPE_ATOMIC (t1)))\n+\t   {\n+\t     /* roles are swapped */\n+\t     t1 = t2;\n+\t     t2 = TREE_TYPE (type1);\n+\t   }\n+\t  tree t2_stripped = strip_array_types (t2);\n+\t  if ((TREE_CODE (t2) == ARRAY_TYPE)\n+\t      && (TYPE_QUALS (t2_stripped) & ~TYPE_QUALS (t1)))\n+\t    {\n+\t      if (!flag_isoc2x)\n+\t\twarning_at (colon_loc, OPT_Wdiscarded_array_qualifiers,\n+\t\t\t    \"pointer to array loses qualifier \"\n+\t\t\t    \"in conditional expression\");\n+\t      else if (warn_c11_c2x_compat > 0)\n+\t\twarning_at (colon_loc, OPT_Wc11_c2x_compat,\n+\t\t\t    \"pointer to array loses qualifier \"\n+\t\t\t    \"in conditional expression in ISO C before C2X\");\n+\t    }\n+\t  if (TREE_CODE (t2) == FUNCTION_TYPE)\n \t    pedwarn (colon_loc, OPT_Wpedantic,\n \t\t     \"ISO C forbids conditional expr between \"\n \t\t     \"%<void *%> and function pointer\");\n-\t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type1),\n-\t\t\t\t\t\t\t  TREE_TYPE (type2)));\n-\t}\n-      else if (VOID_TYPE_P (TREE_TYPE (type2))\n-\t       && !TYPE_ATOMIC (TREE_TYPE (type2)))\n-\t{\n-\t  if ((TREE_CODE (TREE_TYPE (type1)) == ARRAY_TYPE)\n-\t      && (TYPE_QUALS (strip_array_types (TREE_TYPE (type1)))\n-\t\t  & ~TYPE_QUALS (TREE_TYPE (type2))))\n-\t    warning_at (colon_loc, OPT_Wdiscarded_array_qualifiers,\n-\t\t\t\"pointer to array loses qualifier \"\n-\t\t\t\"in conditional expression\");\n-\n-\t  if (TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n-\t    pedwarn (colon_loc, OPT_Wpedantic,\n-\t\t     \"ISO C forbids conditional expr between \"\n-\t\t     \"%<void *%> and function pointer\");\n-\t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type2),\n-\t\t\t\t\t\t\t  TREE_TYPE (type1)));\n+\t  /* for array, use qualifiers of element type */\n+\t  if (flag_isoc2x)\n+\t    t2 = t2_stripped;\n+\t  result_type = build_pointer_type (qualify_type (t1, t2));\n \t}\n       /* Objective-C pointer comparisons are a bit more lenient.  */\n       else if (objc_have_common_type (type1, type2, -3, NULL_TREE))\n@@ -6797,27 +6799,40 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n-     compile time.  It is the same as PEDWARN_FOR_ASSIGNMENT but with an\n-     extra parameter to enumerate qualifiers.  */\n-#define PEDWARN_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS) \\\n+     compile time.  It can be called with 'pedwarn' or 'warning_at'.  */\n+#define WARNING_FOR_QUALIFIERS(PEDWARN, LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS) \\\n   do {                                                                   \\\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n-\t{\t\t\t\t\t\t\t\t\\\n-\tauto_diagnostic_group d;\t\t\t\t\t\t\\\n-\tif (pedwarn (PLOC, OPT, AR, parmnum, rname, QUALS))\t\t\\\n-\t  inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  auto_diagnostic_group d;\t\t\t\t\t \\\n+\t  if (PEDWARN) {\t\t\t\t\t\t \\\n+\t    if (pedwarn (PLOC, OPT, AR, parmnum, rname, QUALS))          \\\n+\t      inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);  \\\n+\t  } else {\t\t\t\t\t\t\t \\\n+\t    if (warning_at (PLOC, OPT, AR, parmnum, rname, QUALS))\t \\\n+\t      inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype);  \\\n+\t  }\t\t\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n         break;                                                           \\\n       case ic_assign:                                                    \\\n-        pedwarn (LOCATION, OPT, AS, QUALS);\t\t\t\t \\\n+\tif (PEDWARN)\t\t\t\t\t\t\t \\\n+\t  pedwarn (LOCATION, OPT, AS, QUALS);                            \\\n+\telse\t\t\t\t\t\t\t\t \\\n+\t  warning_at (LOCATION, OPT, AS, QUALS);                         \\\n         break;                                                           \\\n       case ic_init:                                                      \\\n-        pedwarn (LOCATION, OPT, IN, QUALS);\t\t\t\t \\\n+\tif (PEDWARN)\t\t\t\t\t\t\t \\\n+\t  pedwarn (LOCATION, OPT, IN, QUALS);                            \\\n+\telse\t\t\t\t\t\t\t\t \\\n+\t  warning_at (LOCATION, OPT, IN, QUALS);                         \\\n         break;                                                           \\\n       case ic_return:                                                    \\\n-        pedwarn (LOCATION, OPT, RE, QUALS);\t\t\t\t \\\n+\tif (PEDWARN)\t\t\t\t\t\t\t \\\n+\t  pedwarn (LOCATION, OPT, RE, QUALS);                            \\\n+\telse\t\t\t\t\t\t\t\t \\\n+\t  warning_at (LOCATION, OPT, RE, QUALS);                         \\\n         break;                                                           \\\n       default:                                                           \\\n         gcc_unreachable ();                                              \\\n@@ -6826,32 +6841,11 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n-     compile time.  It is the same as PEDWARN_FOR_QUALIFIERS but uses\n-     warning_at instead of pedwarn.  */\n-#define WARNING_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS) \\\n-  do {                                                                   \\\n-    switch (errtype)                                                     \\\n-      {                                                                  \\\n-      case ic_argpass:                                                   \\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  auto_diagnostic_group d;\t\t\t\t\t\t\\\n-\t  if (warning_at (PLOC, OPT, AR, parmnum, rname, QUALS))\t\\\n-\t    inform_for_arg (fundecl, (PLOC), parmnum, type, rhstype); \\\n-\t}\t\t\t\t\t\t\t\t\\\n-        break;                                                           \\\n-      case ic_assign:                                                    \\\n-        warning_at (LOCATION, OPT, AS, QUALS);                           \\\n-        break;                                                           \\\n-      case ic_init:                                                      \\\n-        warning_at (LOCATION, OPT, IN, QUALS);                           \\\n-        break;                                                           \\\n-      case ic_return:                                                    \\\n-        warning_at (LOCATION, OPT, RE, QUALS);                           \\\n-        break;                                                           \\\n-      default:                                                           \\\n-        gcc_unreachable ();                                              \\\n-      }                                                                  \\\n-  } while (0)\n+     compile time.  It is the same as PEDWARN_FOR_ASSIGNMENT but with an\n+     extra parameter to enumerate qualifiers.  */\n+#define PEDWARN_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS) \\\n+   WARNING_FOR_QUALIFIERS (true, LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS)\n+\n \n   if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n@@ -7370,17 +7364,18 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n \t      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n \t\t  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))\n-\t\tWARNING_FOR_QUALIFIERS (location, expr_loc,\n-\t\t\t\t        OPT_Wdiscarded_array_qualifiers,\n-\t\t\t\t        G_(\"passing argument %d of %qE discards \"\n+\t\tWARNING_FOR_QUALIFIERS (flag_isoc2x,\n+\t\t\t\t\tlocation, expr_loc,\n+\t\t\t\t\tOPT_Wdiscarded_array_qualifiers,\n+\t\t\t\t\tG_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t   \"%qv qualifier from pointer target type\"),\n-\t\t\t\t        G_(\"assignment discards %qv qualifier \"\n+\t\t\t\t\tG_(\"assignment discards %qv qualifier \"\n \t\t\t\t\t   \"from pointer target type\"),\n-\t\t\t\t        G_(\"initialization discards %qv qualifier \"\n+\t\t\t\t\tG_(\"initialization discards %qv qualifier \"\n \t\t\t\t\t   \"from pointer target type\"),\n-\t\t\t\t        G_(\"return discards %qv qualifier from \"\n+\t\t\t\t\tG_(\"return discards %qv qualifier from \"\n \t\t\t\t\t   \"pointer target type\"),\n-                                        TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n+\t\t\t\t\tTYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n             }\n           else if (pedantic\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)\n@@ -7403,28 +7398,31 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n+\t       /* Assignments between atomic and non-atomic objects are OK.  */\n+\t       bool warn_quals_ped = TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n+\t\t\t\t     & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl);\n+\t       bool warn_quals = TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n+\t\t\t\t & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (strip_array_types (ttl));\n+\n \t      /* Don't warn about loss of qualifier for conversions from\n \t\t qualified void* to pointers to arrays with corresponding\n-\t\t qualifier on the element type. */\n-\t      if (!pedantic)\n-\t        ttl = strip_array_types (ttl);\n+\t\t qualifier on the element type (except for pedantic before C23). */\n+\t      if (warn_quals || (warn_quals_ped && pedantic && !flag_isoc2x))\n+\t\tPEDWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t\tOPT_Wdiscarded_qualifiers,\n+\t\t\t\t\tG_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t   \"%qv qualifier from pointer target type\"),\n+\t\t\t\t\tG_(\"assignment discards %qv qualifier \"\n+\t\t\t\t\t   \"from pointer target type\"),\n+\t\t\t\t\tG_(\"initialization discards %qv qualifier \"\n+\t\t\t\t\t   \"from pointer target type\"),\n+\t\t\t\t\tG_(\"return discards %qv qualifier from \"\n+\t\t\t\t\t   \"pointer target type\"),\n+\t\t\t\t\tTYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n+\t      else if (warn_quals_ped)\n+\t\tpedwarn_c11 (location, OPT_Wc11_c2x_compat,\n+\t\t\t     \"array with qualifier on the element is not qualified before C2X\");\n \n-\t      /* Assignments between atomic and non-atomic objects are OK.  */\n-\t      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n-\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))\n-\t\t{\n-\t\t  PEDWARN_FOR_QUALIFIERS (location, expr_loc,\n-\t\t\t\t          OPT_Wdiscarded_qualifiers,\n-\t\t\t\t          G_(\"passing argument %d of %qE discards \"\n-\t\t\t\t\t     \"%qv qualifier from pointer target type\"),\n-\t\t\t\t          G_(\"assignment discards %qv qualifier \"\n-\t\t\t\t\t     \"from pointer target type\"),\n-\t\t\t\t          G_(\"initialization discards %qv qualifier \"\n-\t\t\t\t\t     \"from pointer target type\"),\n-\t\t\t\t          G_(\"return discards %qv qualifier from \"\n-\t\t\t\t\t     \"pointer target type\"),\n-\t\t\t\t          TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n-\t\t}\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n \t      else if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)"}, {"sha": "f731e068830348da71208bdebd4d314f24c1b502", "filename": "gcc/testsuite/gcc.dg/c11-qual-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-qual-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-qual-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-qual-1.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,11 @@\n+/* Test that qualifiers are lost in tertiary operator for pointers to arrays before C2X, PR98397 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors -Wno-discarded-array-qualifiers\" } */\n+\n+void foo(void)\n+{\n+\tconst int (*u)[1];\n+\tvoid *v;\n+\t_Static_assert(_Generic(1 ? u : v, const void*: 0, void*: 1), \"qualifier not lost\");\n+\t_Static_assert(_Generic(1 ? v : u, const void*: 0, void*: 1), \"qualifier not lost\");\n+}"}, {"sha": "4d33db1907d4b30a2d60d0e6f6f79e29ce7cdaea", "filename": "gcc/testsuite/gcc.dg/c2x-qual-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-1.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,30 @@\n+/* Tests related to qualifiers and pointers to arrays in C2X, PR98397 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* test that qualifiers are preserved in tertiary operator for pointers to arrays in C2X */\n+\n+void f(void)\n+{\n+\tconst int (*u)[1];\n+\tvoid *v;\n+\t_Static_assert(_Generic(1 ? u : v, const void*: 1, void*: 0), \"lost qualifier\");\n+\t_Static_assert(_Generic(1 ? v : u, const void*: 1, void*: 0), \"lost qualifier\");\n+}\n+\n+/* test that assignment of unqualified to qualified pointers works as expected */\n+\n+void g(void)\n+{\n+\tint (*x)[3];\n+\tconst int (*p)[3] = x;\n+}\n+\n+/* test that assignment of qualified void pointers works as expected */\n+\n+void h(void)\n+{\n+\tconst void* x;\n+\tconst int (*p)[3] = x;\n+}\n+"}, {"sha": "f60a5b18faa35e936db3841fa93b07e2aa866357", "filename": "gcc/testsuite/gcc.dg/c2x-qual-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-2.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,30 @@\n+/* Tests related to qualifiers and pointers to arrays in C2X, PR98397 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -Wc11-c2x-compat\" } */\n+\n+/* test that qualifiers are preserved in tertiary operator for pointers to arrays in C2X */\n+\n+void f(void)\n+{\n+\tconst int (*u)[1];\n+\tvoid *v;\n+\t_Static_assert(_Generic(1 ? u : v, const void*: 1, void*: 0), \"lost qualifier\");\t/* { dg-warning \"pointer to array loses qualifier in conditional\" } */\n+\t_Static_assert(_Generic(1 ? v : u, const void*: 1, void*: 0), \"lost qualifier\");\t/* { dg-warning \"pointer to array loses qualifier in conditional\" } */\n+}\n+\n+/* test that assignment of unqualified to qualified pointers works as expected */\n+\n+void g(void)\n+{\n+\tint (*x)[3];\n+\tconst int (*p)[3] = x; /* { dg-warning \"arrays with different qualifiers\"  } */\n+}\n+\n+/* test that assignment of qualified void pointers works as expected */\n+\n+void h(void)\n+{\n+\tconst void* x;\n+\tconst int (*p)[3] = x; /* { dg-warning \"array with qualifier on the element is not qualified before C2X\" } */\n+}\n+"}, {"sha": "31896fcb1a1116642b62777558f28cfd5df213d0", "filename": "gcc/testsuite/gcc.dg/c2x-qual-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-3.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,30 @@\n+/* Tests related to qualifiers and pointers to arrays in C2X, PR98397 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -Wc11-c2x-compat -pedantic-errors\" } */\n+\n+/* test that qualifiers are preserved in tertiary operator for pointers to arrays in C2X */\n+\n+void f(void)\n+{\n+\tconst int (*u)[1];\n+\tvoid *v;\n+\t_Static_assert(_Generic(1 ? u : v, const void*: 1, void*: 0), \"lost qualifier\");\t/* { dg-warning \"pointer to array loses qualifier in conditional\" } */\n+\t_Static_assert(_Generic(1 ? v : u, const void*: 1, void*: 0), \"lost qualifier\");\t/* { dg-warning \"pointer to array loses qualifier in conditional\" } */\n+}\n+\n+/* test that assignment of unqualified to qualified pointers works as expected */\n+\n+void g(void)\n+{\n+\tint (*x)[3];\n+\tconst int (*p)[3] = x; /* { dg-warning \"arrays with different qualifiers\"  } */\n+}\n+\n+/* test that assignment of qualified void pointers works as expected */\n+\n+void h(void)\n+{\n+\tconst void* x;\n+\tconst int (*p)[3] = x; /* { dg-warning \"array with qualifier on the element is not qualified before C2X\" } */\n+}\n+"}, {"sha": "93b4723dcd6e401a572ed4e8840abbb0880966eb", "filename": "gcc/testsuite/gcc.dg/c2x-qual-4.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-4.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,105 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x\" } */\n+void tvoid(void* x);\n+void transpose0(double* out, const double* in) { }\n+void transpose1(double out[2][2], const double in[2][2]) { }\n+void transpose2(double out[2][2][2], const double in[2][2][2]) { }\n+// return\n+int (*y2(const int x[3][3]))[3] { return x; } /* { dg-warning \"return discards 'const' qualifier from pointer target type\" } */\n+const int (*y3(int x[3][3]))[3] { return x; }\n+void test(void)\n+{\n+\tdouble x0[2];\n+\tdouble y0[2];\n+\tconst double z0[4];\n+\tdouble x1[2][2];\n+\tdouble y1[2][2];\n+\tdouble o1[2][3];\n+\tconst double z1[2][2];\n+\tdouble x2[2][2][2];\n+\tdouble y2[2][2][2];\n+\tdouble o2[2][2][3];\n+\tconst double z2[2][2][2];\n+\t// void pointers\n+\ttvoid(x0);\n+\ttvoid(x1);\n+\ttvoid(x2);\n+\ttvoid(z0); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z1); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z2); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\tvoid* p;\n+\tconst void* pc;\n+\tp = x0;\n+\tp = x1;\n+\tp = x2;\n+\tp = z0; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z1; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z2; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tpc = x0;\n+\tpc = x1;\n+\tpc = x2;\n+\tpc = z0;\n+\tpc = z1;\n+\tpc = z2;\n+\ttranspose0(pc, p); /* { dg-warning \"passing argument 1 of 'transpose0' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose1(pc, p); /* { dg-warning \"passing argument 1 of 'transpose1' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose2(pc, p); /* { dg-warning \"passing argument 1 of 'transpose2' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose0(p, pc);\n+\ttranspose1(p, pc);\n+\ttranspose2(p, pc);\n+\t// passing as arguments\n+\ttranspose0(y0, x0);\n+\ttranspose1(y1, x1);\n+\ttranspose2(y2, x2);\n+\t// initialization\n+\tconst double (*u0p) = x0;\n+\tconst double (*u1p)[2] = x1;\n+\tconst double (*u2p)[2][2] = x2;\n+\tdouble (*v0p) = z0; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v1p)[2] = z1; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v2p)[2][2] = z2; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */\n+\t// subtraction\n+\t&(x0[1]) - &(z0[0]);\n+\t&(x1[1]) - &(z1[0]);\n+\t&(x2[1]) - &(z2[0]);\n+\t// comparison\n+\tx0 == z0;\n+\tx1 == z1;\n+\tx2 == z2;\n+\tx0 < z0; \n+\tx1 < z1; \n+\tx2 < z2; \n+\tx0 > z0;\n+\tx1 > z1;\n+\tx2 > z2;\n+\t// assignment\n+\tu0p = x0;\n+\tu1p = x1;\n+\tu2p = x2;\n+\tv0p = z0; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = z1; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = z2; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\t// conditional expressions\n+\t(void)(1 ? x0 : z0);\n+\t(void)(1 ? x1 : z1);\n+\t(void)(1 ? x2 : z2);\n+\t(void)(1 ? x0 : x1); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x1 : x2); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x2 : x0); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\tv0p = (1 ? z0 : v0p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? z1 : v1p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? z2 : v2p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv0p = (1 ? x0 : u0p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? x1 : u1p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? x2 : u2p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\t(1 ? x0 : z0)[0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x1 : z1)[0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x2 : z2)[0][0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\tv0p = (1 ? p : z0); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? p : z1); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? p : z2); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv0p = (1 ? pc : x0); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? pc : x1); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? pc : x2); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+}\n+"}, {"sha": "0801fa0eed50c9acc6430ba16bc8c91122bdedd4", "filename": "gcc/testsuite/gcc.dg/c2x-qual-5.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-5.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+void tvoid(void* x);\n+void transpose0(double* out, const double* in) { }\n+void transpose1(double out[2][2], const double in[2][2]) { }\n+void transpose2(double out[2][2][2], const double in[2][2][2]) { }\n+// return\n+int (*x2(const int x[3][3]))[3] { return x; } /* { dg-error \"return discards\" } */\n+const int (*x3(int x[3][3]))[3] { return x; }\n+void test(void)\n+{\n+\tdouble x0[2];\n+\tdouble y0[2];\n+\tconst double z0[4];\n+\tdouble x1[2][2];\n+\tdouble y1[2][2];\n+\tdouble o1[2][3];\n+\tconst double z1[2][2];\n+\tdouble x2[2][2][2];\n+\tdouble y2[2][2][2];\n+\tdouble o2[2][2][3];\n+\tconst double z2[2][2][2];\n+\t// void pointers\n+\ttvoid(z0); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z1); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z2); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\tvoid* p;\n+\tconst void* pc;\n+\tp = x0;\n+\tp = x1;\n+\tp = x2;\n+\tp = z0; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z1; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z2; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tpc = x0;\n+\tpc = x1;\n+\tpc = x2;\n+\tpc = z0;\n+\tpc = z1;\n+\tpc = z2;\n+\ttranspose0(pc, p); /* { dg-error \"passing argument 1 of 'transpose0' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose1(pc, p); /* { dg-error \"passing argument 1 of 'transpose1' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose2(pc, p); /* { dg-error \"passing argument 1 of 'transpose2' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose0(p, pc);\n+\ttranspose1(p, pc);\n+\ttranspose2(p, pc);\n+\t// passing as arguments\n+\ttranspose0(y0, x0);\n+\ttranspose1(y1, o1); /* { dg-error \"passing argument 2 of 'transpose1' from incompatible pointer type\" } */\n+\ttranspose1(y1, x1);\n+\ttranspose2(y2, o2); /* { dg-error \"passing argument 2 of 'transpose2' from incompatible pointer type\" } */\n+\ttranspose2(y2, x2);\n+\t// initialization\n+\tconst double (*x0p) = x0;\n+\tconst double (*x1p)[2] = x1;\n+\tconst double (*x2p)[2][2] = x2;\n+\tdouble (*v0p) = z0; /* { dg-error \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v1p)[2] = z1; /* { dg-error \"initialization discards\" } */\n+\tdouble (*v2p)[2][2] = z2; /* { dg-error \"initialization discards\" } */\n+\t// assignment\n+\tx0p = x0;\n+\tx1p = x1;\n+\tx2p = x2;\n+\t// subtraction\n+\t&(x0[1]) - &(z0[0]);\n+\t&(x1[1]) - &(z1[0]);\n+\t&(x2[1]) - &(z2[0]);\n+\t// comparison\n+\tx0 == z0;\n+\tx1 == z1;\n+\tx2 == z2;\n+\tx0 < z0;\n+\tx1 < z1;\n+\tx2 < z2;\n+\tx0 > z0;\n+\tx1 > z1;\n+\tx2 > z2;\n+\t// conditional expressions\n+\t(void)(1 ? x0 : z0);\n+\t(void)(1 ? x1 : z1);\n+\t(void)(1 ? x2 : z2);\n+\t(void)(1 ? x0 : x1); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x1 : x2); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x2 : x0); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\tv0p = (1 ? z0 : v0p); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? z1 : v1p); /* { dg-error \"assignment discards\" } */\n+\tv2p = (1 ? z2 : v2p); /* { dg-error \"assignment discards\" } */\n+\tv0p = (1 ? x0 : x0p); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? x1 : x1p); /* { dg-error \"assignment discards\" } */\n+\tv2p = (1 ? x2 : x2p); /* { dg-error \"assignment discards\" } */\n+\t(1 ? x0 : z0)[0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x1 : z1)[0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x2 : z2)[0][0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\tv0p = (1 ? p : z0); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? p : z1); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? p : z2); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv0p = (1 ? pc : x0); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? pc : x1); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? pc : x2); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+}\n+"}, {"sha": "9c91e206e300b43873e3cbaf841574ca36655569", "filename": "gcc/testsuite/gcc.dg/c2x-qual-6.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-6.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -Wc11-c2x-compat -pedantic-errors\" } */\n+void tvoid(void* x);\n+void transpose0(double* out, const double* in) { }\n+void transpose1(double out[2][2], const double in[2][2]) { }\n+void transpose2(double out[2][2][2], const double in[2][2][2]) { }\n+// return\n+int (*x2(const int x[3][3]))[3] { return x; } /* { dg-warning \"before C2X\" } */\n+\t\t\t\t\t\t/* { dg-error \"return discards\" \"\" { target *-*-* } .-1 } */\n+const int (*x3(int x[3][3]))[3] { return x; }\t/* { dg-warning \"before C2X\" } */\n+void test(void)\n+{\n+\tdouble x0[2];\n+\tdouble y0[2];\n+\tconst double z0[4];\n+\tdouble x1[2][2];\n+\tdouble y1[2][2];\n+\tdouble o1[2][3];\n+\tconst double z1[2][2];\n+\tdouble x2[2][2][2];\n+\tdouble y2[2][2][2];\n+\tdouble o2[2][2][3];\n+\tconst double z2[2][2][2];\n+\t// void pointers\n+\ttvoid(z0); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z1); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z2); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\tvoid* p;\n+\tconst void* pc;\n+\tp = x0;\n+\tp = x1;\n+\tp = x2;\n+\tp = z0; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z1; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z2; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tpc = x0;\n+\tpc = x1;\n+\tpc = x2;\n+\tpc = z0;\n+\tpc = z1;\n+\tpc = z2;\n+\ttranspose0(pc, p); /* { dg-error \"passing argument 1 of 'transpose0' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose1(pc, p); /* { dg-error \"passing argument 1 of 'transpose1' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose2(pc, p); /* { dg-error \"passing argument 1 of 'transpose2' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose0(p, pc); \n+\ttranspose1(p, pc); /* { dg-warning \"before C2X\" } */\n+\ttranspose2(p, pc); /* { dg-warning \"before C2X\" } */\n+\t// passing as arguments\n+\ttranspose0(y0, x0);\n+\ttranspose1(y1, o1); /* { dg-error \"passing argument 2 of 'transpose1' from incompatible pointer type\" } */\n+\ttranspose1(y1, x1); /* { dg-warning \"before C2X\" } */\n+\ttranspose2(y2, o2); /* { dg-error \"passing argument 2 of 'transpose2' from incompatible pointer type\" } */\n+\ttranspose2(y2, x2); /* { dg-warning \"before C2X\" } */\n+\t// initialization\n+\tconst double (*x0p) = x0;\n+\tconst double (*x1p)[2] = x1; /* { dg-warning \"before C2X\" } */\n+\tconst double (*x2p)[2][2] = x2; /* { dg-warning \"before C2X\" } */\n+\tdouble (*v0p) = z0; /* { dg-error \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v1p)[2] = z1; /* { dg-warning \"before C2X\" } */\n+\t\t\t\t/* { dg-error \"initialization discards\" \"\" { target *-*-* } .-1 } */\n+\tdouble (*v2p)[2][2] = z2; /* { dg-warning \"before C2X\" } */\n+\t\t\t\t/* { dg-error \"initialization discards\" \"\" { target *-*-* } .-1 } */\n+\t\t\t\t\n+\t// assignment\n+\tx0p = x0;\n+\tx1p = x1; /* { dg-warning \"before C2X\" } */\n+\tx2p = x2; /* { dg-warning \"before C2X\" } */\n+\n+\t// subtraction\n+\t&(x0[1]) - &(z0[0]);\n+\t&(x1[1]) - &(z1[0]); /* { dg-warning \"before C2X\" } */\n+\t&(x2[1]) - &(z2[0]); /* { dg-warning \"before C2X\" } */\n+\t// comparison\n+\tx0 == z0;\n+\tx1 == z1; /* { dg-warning \"before C2X\" } */\n+\tx2 == z2; /* { dg-warning \"before C2X\" } */\n+\tx0 < z0;\n+\tx1 < z1; /* { dg-warning \"before C2X\" } */\n+\tx2 < z2; /* { dg-warning \"before C2X\" } */\n+\tx0 > z0;\n+\tx1 > z1; /* { dg-warning \"before C2X\" } */\n+\tx2 > z2; /* { dg-warning \"before C2X\" } */\n+\t// conditional expressions\n+\t(void)(1 ? x0 : z0);\n+\t(void)(1 ? x1 : z1); /* { dg-warning \"before C2X\" } */\n+\t(void)(1 ? x2 : z2); /* { dg-warning \"before C2X\" } */\n+\t(void)(1 ? x0 : x1); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x1 : x2); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x2 : x0); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\tv0p = (1 ? z0 : v0p); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? z1 : v1p); /* { dg-warning \"before C2X\" } */\n+\t\t\t\t/* { dg-error \"assignment discards\" \"\" { target *-*-* } .-1 } */\n+\tv2p = (1 ? z2 : v2p); /* { dg-warning \"before C2X\" } */\n+\t\t\t\t/* { dg-error \"assignment discards\" \"\" { target *-*-* } .-1 } */\n+\tv0p = (1 ? x0 : x0p); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? x1 : x1p); /* { dg-error \"assignment discards\" } */\n+\t\t\t\t/* { dg-warning \"before C2X\" \"\" { target *-*-* } .-1 } */\n+\tv2p = (1 ? x2 : x2p); /* { dg-error \"assignment discards\" } */\n+\t\t\t\t/* { dg-warning \"before C2X\" \"\" { target *-*-* } .-1 } */\n+\t(1 ? x0 : z0)[0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x1 : z1)[0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t\t\t\t/* { dg-warning \"before C2X\" \"\" { target *-*-* } .-1 } */\n+\t(1 ? x2 : z2)[0][0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t\t\t\t/* { dg-warning \"before C2X\" \"\" { target *-*-* } .-1 } */\n+\tv0p = (1 ? p : z0); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? p : z1); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\t\t\t\t/* { dg-warning \"before C2X\" \"\" { target *-*-* } .-1 } */\n+\tv2p = (1 ? p : z2); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\t\t\t\t/* { dg-warning \"before C2X\" \"\" { target *-*-* } .-1 } */\n+\tv0p = (1 ? pc : x0); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? pc : x1); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? pc : x2); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+}\n+"}, {"sha": "5fe15e1d2cbb3fb86a56bdb6d68be03f54ba66ed", "filename": "gcc/testsuite/gcc.dg/c2x-qual-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-qual-7.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -0,0 +1,16 @@\n+/* Tests related to qualifiers and pointers to arrays in C2X, PR98397 */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* test that _Atomic qualifier is not preserved in tertiary operator for pointers to arrays in C2X */\n+\n+void f(void)\n+{\n+\t_Atomic void *u;\n+\tvoid *v;\n+\t_Static_assert(_Generic(1 ? u : v, _Atomic void*: 0, void*: 1), \"_Atomic should be removed\");\n+\t_Static_assert(_Generic(1 ? v : u, _Atomic void*: 0, void*: 1), \"_Atomic should be removed\");\n+}\n+\n+\n+"}, {"sha": "498ab223162711d0c2f19292d2743af9a5272908", "filename": "gcc/testsuite/gcc.dg/pointer-array-quals-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-1.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* Origin: Martin Uecker <uecker@eecs.berkeley.edu> */\n-/* { dg-options \"-Wdiscarded-array-qualifiers\" } */\n+/* { dg-options \"\" } */\n void tvoid(void* x);\n void transpose0(double* out, const double* in) { }\n void transpose1(double out[2][2], const double in[2][2]) { }"}, {"sha": "4c95d8a3a7858059074927069a2283b06ff2c87c", "filename": "gcc/testsuite/gcc.dg/pointer-array-quals-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972eab51f53d1db26864ec7d62d40c2ff83407ec/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-2.c?ref=972eab51f53d1db26864ec7d62d40c2ff83407ec", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Wdiscarded-array-qualifiers -pedantic-errors\" } */\n+/* { dg-options \"-pedantic-errors\" } */\n /* Origin: Martin Uecker <uecker@eecs.berkeley.edu> */\n void tvoid(void* x);\n void transpose0(double* out, const double* in) { }"}]}