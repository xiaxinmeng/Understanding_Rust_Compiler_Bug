{"sha": "ef268d34b78bed8d3e253fa00143b16817f68816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyNjhkMzRiNzhiZWQ4ZDNlMjUzZmEwMDE0M2IxNjgxN2Y2ODgxNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2009-05-03T23:27:10Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2009-05-03T23:27:10Z"}, "message": "expmed.c (shiftsub_cost): Rename to shiftsub0_cost.\n\n\t* expmed.c (shiftsub_cost): Rename to shiftsub0_cost.\n\t(shiftsub1_cost): New.\n\t(init_expmed): Compute shiftsub1_cost.\n\t(synth_mult): Optimize multiplications by constants of the form\n\t-(2^^m-1) for some constant positive integer m.\n\nFrom-SVN: r147086", "tree": {"sha": "24dec62f38d937b9c1c8a9813f88d9050a054187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24dec62f38d937b9c1c8a9813f88d9050a054187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef268d34b78bed8d3e253fa00143b16817f68816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef268d34b78bed8d3e253fa00143b16817f68816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef268d34b78bed8d3e253fa00143b16817f68816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef268d34b78bed8d3e253fa00143b16817f68816/comments", "author": null, "committer": null, "parents": [{"sha": "97f0e9d9e03c46413c8abdb41b4e34191e8c950e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97f0e9d9e03c46413c8abdb41b4e34191e8c950e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97f0e9d9e03c46413c8abdb41b4e34191e8c950e"}], "stats": {"total": 64, "additions": 52, "deletions": 12}, "files": [{"sha": "b67be5b78e0dfa8f97d9a511027c18a8ac0ba26c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef268d34b78bed8d3e253fa00143b16817f68816/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef268d34b78bed8d3e253fa00143b16817f68816/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef268d34b78bed8d3e253fa00143b16817f68816", "patch": "@@ -1,3 +1,11 @@\n+2009-05-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* expmed.c (shiftsub_cost): Rename to shiftsub0_cost.\n+\t(shiftsub1_cost): New.\n+\t(init_expmed): Compute shiftsub1_cost.\n+\t(synth_mult): Optimize multiplications by constants of the form\n+\t-(2^^m-1) for some constant positive integer m.\n+\n 2009-05-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR c/39983"}, {"sha": "7ffb693dcdd4db18fca0d01733251b9beca79e4b", "filename": "gcc/expmed.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef268d34b78bed8d3e253fa00143b16817f68816/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef268d34b78bed8d3e253fa00143b16817f68816/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ef268d34b78bed8d3e253fa00143b16817f68816", "patch": "@@ -103,7 +103,8 @@ static int add_cost[2][NUM_MACHINE_MODES];\n static int neg_cost[2][NUM_MACHINE_MODES];\n static int shift_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n static int shiftadd_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n-static int shiftsub_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int shiftsub0_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n+static int shiftsub1_cost[2][NUM_MACHINE_MODES][MAX_BITS_PER_WORD];\n static int mul_cost[2][NUM_MACHINE_MODES];\n static int sdiv_cost[2][NUM_MACHINE_MODES];\n static int udiv_cost[2][NUM_MACHINE_MODES];\n@@ -130,7 +131,8 @@ init_expmed (void)\n     struct rtx_def shift;\trtunion shift_fld1;\n     struct rtx_def shift_mult;\trtunion shift_mult_fld1;\n     struct rtx_def shift_add;\trtunion shift_add_fld1;\n-    struct rtx_def shift_sub;\trtunion shift_sub_fld1;\n+    struct rtx_def shift_sub0;\trtunion shift_sub0_fld1;\n+    struct rtx_def shift_sub1;\trtunion shift_sub1_fld1;\n   } all;\n \n   rtx pow2[MAX_BITS_PER_WORD];\n@@ -201,9 +203,13 @@ init_expmed (void)\n   XEXP (&all.shift_add, 0) = &all.shift_mult;\n   XEXP (&all.shift_add, 1) = &all.reg;\n \n-  PUT_CODE (&all.shift_sub, MINUS);\n-  XEXP (&all.shift_sub, 0) = &all.shift_mult;\n-  XEXP (&all.shift_sub, 1) = &all.reg;\n+  PUT_CODE (&all.shift_sub0, MINUS);\n+  XEXP (&all.shift_sub0, 0) = &all.shift_mult;\n+  XEXP (&all.shift_sub0, 1) = &all.reg;\n+\n+  PUT_CODE (&all.shift_sub1, MINUS);\n+  XEXP (&all.shift_sub1, 0) = &all.reg;\n+  XEXP (&all.shift_sub1, 1) = &all.shift_mult;\n \n   for (speed = 0; speed < 2; speed++)\n     {\n@@ -226,7 +232,8 @@ init_expmed (void)\n \t  PUT_MODE (&all.shift, mode);\n \t  PUT_MODE (&all.shift_mult, mode);\n \t  PUT_MODE (&all.shift_add, mode);\n-\t  PUT_MODE (&all.shift_sub, mode);\n+\t  PUT_MODE (&all.shift_sub0, mode);\n+\t  PUT_MODE (&all.shift_sub1, mode);\n \n \t  add_cost[speed][mode] = rtx_cost (&all.plus, SET, speed);\n \t  neg_cost[speed][mode] = rtx_cost (&all.neg, SET, speed);\n@@ -254,8 +261,8 @@ init_expmed (void)\n \t    }\n \n \t  shift_cost[speed][mode][0] = 0;\n-\t  shiftadd_cost[speed][mode][0] = shiftsub_cost[speed][mode][0]\n-\t    = add_cost[speed][mode];\n+\t  shiftadd_cost[speed][mode][0] = shiftsub0_cost[speed][mode][0]\n+\t    = shiftsub1_cost[speed][mode][0] = add_cost[speed][mode];\n \n \t  n = MIN (MAX_BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n \t  for (m = 1; m < n; m++)\n@@ -265,7 +272,8 @@ init_expmed (void)\n \n \t      shift_cost[speed][mode][m] = rtx_cost (&all.shift, SET, speed);\n \t      shiftadd_cost[speed][mode][m] = rtx_cost (&all.shift_add, SET, speed);\n-\t      shiftsub_cost[speed][mode][m] = rtx_cost (&all.shift_sub, SET, speed);\n+\t      shiftsub0_cost[speed][mode][m] = rtx_cost (&all.shift_sub0, SET, speed);\n+\t      shiftsub1_cost[speed][mode][m] = rtx_cost (&all.shift_sub1, SET, speed);\n \t    }\n \t}\n     }\n@@ -2397,6 +2405,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   struct mult_cost best_cost;\n   struct mult_cost new_limit;\n   int op_cost, op_latency;\n+  unsigned HOST_WIDE_INT orig_t = t;\n   unsigned HOST_WIDE_INT q;\n   int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n   int hash_index;\n@@ -2604,6 +2613,29 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      best_alg->op[best_alg->ops] = alg_add_t_m2;\n \t    }\n \t}\n+\n+      /* We may be able to calculate a * -7, a * -15, a * -31, etc\n+\t quickly with a - a * n for some appropriate constant n.  */\n+      m = exact_log2 (-orig_t + 1);\n+      if (m >= 0 && m < maxm)\n+\t{\n+\t  op_cost = shiftsub1_cost[speed][mode][m];\n+\t  new_limit.cost = best_cost.cost - op_cost;\n+\t  new_limit.latency = best_cost.latency - op_cost;\n+\t  synth_mult (alg_in, (unsigned HOST_WIDE_INT) (-orig_t + 1) >> m, &new_limit, mode);\n+\n+\t  alg_in->cost.cost += op_cost;\n+\t  alg_in->cost.latency += op_cost;\n+\t  if (CHEAPER_MULT_COST (&alg_in->cost, &best_cost))\n+\t    {\n+\t      struct algorithm *x;\n+\t      best_cost = alg_in->cost;\n+\t      x = alg_in, alg_in = best_alg, best_alg = x;\n+\t      best_alg->log[best_alg->ops] = m;\n+\t      best_alg->op[best_alg->ops] = alg_sub_t_m2;\n+\t    }\n+\t}\n+\n       if (cache_hit)\n \tgoto done;\n     }\n@@ -2673,9 +2705,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t     hardware the shift may be executed concurrently with the\n \t     earlier steps in the algorithm.  */\n \t  op_cost = add_cost[speed][mode] + shift_cost[speed][mode][m];\n-\t  if (shiftsub_cost[speed][mode][m] < op_cost)\n+\t  if (shiftsub0_cost[speed][mode][m] < op_cost)\n \t    {\n-\t      op_cost = shiftsub_cost[speed][mode][m];\n+\t      op_cost = shiftsub0_cost[speed][mode][m];\n \t      op_latency = op_cost;\n \t    }\n \t  else\n@@ -2738,7 +2770,7 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n       m = exact_log2 (q);\n       if (m >= 0 && m < maxm)\n \t{\n-\t  op_cost = shiftsub_cost[speed][mode][m];\n+\t  op_cost = shiftsub0_cost[speed][mode][m];\n \t  new_limit.cost = best_cost.cost - op_cost;\n \t  new_limit.latency = best_cost.latency - op_cost;\n \t  synth_mult (alg_in, (t + 1) >> m, &new_limit, mode);"}]}