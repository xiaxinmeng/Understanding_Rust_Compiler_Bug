{"sha": "cbb5c732c20e385bf3d0bf04b533b22281a7dde2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiNWM3MzJjMjBlMzg1YmYzZDBiZjA0YjUzM2IyMjI4MWE3ZGRlMg==", "commit": {"author": {"name": "David Wohlferd", "email": "dw@LimeGreenSocks.com", "date": "2015-10-21T15:39:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-21T15:39:08Z"}, "message": "Proposed doc update for Explicit Reg Vars 2/3\n\n\t* doc/extend.exp (Local Register Variables): Rewrite.\n\nFrom-SVN: r229124", "tree": {"sha": "5f8c1b170929317906097f6158e7199698d4c98d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f8c1b170929317906097f6158e7199698d4c98d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb5c732c20e385bf3d0bf04b533b22281a7dde2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb5c732c20e385bf3d0bf04b533b22281a7dde2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb5c732c20e385bf3d0bf04b533b22281a7dde2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb5c732c20e385bf3d0bf04b533b22281a7dde2/comments", "author": null, "committer": null, "parents": [{"sha": "5d3498b4e03cbd1639cff5d1b19515393b0009b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3498b4e03cbd1639cff5d1b19515393b0009b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3498b4e03cbd1639cff5d1b19515393b0009b5"}], "stats": {"total": 141, "additions": 70, "deletions": 71}, "files": [{"sha": "1c27b69cb0dea9f62e39443d77da3047899eef26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb5c732c20e385bf3d0bf04b533b22281a7dde2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb5c732c20e385bf3d0bf04b533b22281a7dde2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbb5c732c20e385bf3d0bf04b533b22281a7dde2", "patch": "@@ -1,3 +1,7 @@\n+2015-10-21  David Wohlferd  <dw@LimeGreenSocks.com>\n+\n+\t* doc/extend.exp (Local Register Variables): Rewrite.\n+\n 2015-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* match.pd: Add rules to simplify ccos, ccosh, hypot, copysign"}, {"sha": "e54fe67e5b862266bcd61e3d70bf7523f9f0df15", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb5c732c20e385bf3d0bf04b533b22281a7dde2/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb5c732c20e385bf3d0bf04b533b22281a7dde2/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cbb5c732c20e385bf3d0bf04b533b22281a7dde2", "patch": "@@ -8473,7 +8473,7 @@ the assembler code should be @code{MYFUNC}.\n GNU C allows you to associate specific hardware registers with C \n variables.  In almost all cases, allowing the compiler to assign\n registers produces the best code.  However under certain unusual\n-circumstances,  more precise control over the variable storage is \n+circumstances, more precise control over the variable storage is \n required.\n \n Both global and local variables can be associated with a register.  The\n@@ -8492,98 +8492,93 @@ the two, as explained in the sections below.\n @cindex registers, global variables in\n @cindex registers, global allocation\n \n-You can define a global register variable in GNU C like this:\n+You can define a global register variable and associate it with a specified \n+register like this:\n \n @smallexample\n-register int *foo asm (\"a5\");\n+register int *foo asm (\"r12\");\n @end smallexample\n \n @noindent\n-Here @code{a5} is the name of the register that should be used.  Choose a\n-register that is normally saved and restored by function calls on your\n-machine, so that library routines will not clobber it.\n-\n-Naturally the register name is CPU-dependent, so you need to\n-conditionalize your program according to CPU type.  The register\n-@code{a5} is a good choice on a 68000 for a variable of pointer\n-type.  On machines with register windows, be sure to choose a ``global''\n-register that is not affected magically by the function call mechanism.\n+Here @code{r12} is the name of the register that should be used. Note that \n+this is the same syntax used for defining local register variables, but for \n+a global variable the declaration appears outside a function. The \n+@code{register} keyword is required, and cannot be combined with \n+@code{static}. The register name must be a valid register name for the\n+target platform.\n+\n+Registers are a scarce resource on most systems and allowing the \n+compiler to manage their usage usually results in the best code. However, \n+under special circumstances it can make sense to reserve some globally.\n+For example this may be useful in programs such as programming language \n+interpreters that have a couple of global variables that are accessed \n+very often.\n+\n+After defining a global register variable, for the current compilation\n+unit:\n \n-In addition, different operating systems on the same CPU may differ in how they\n-name the registers; then you need additional conditionals.  For\n-example, some 68000 operating systems call this register @code{%a5}.\n+@itemize @bullet\n+@item The register is reserved entirely for this use, and will not be \n+allocated for any other purpose.\n+@item The register is not saved and restored by any functions.\n+@item Stores into this register are never deleted even if they appear to be \n+dead, but references may be deleted, moved or simplified.\n+@end itemize\n+\n+Note that these points @emph{only} apply to code that is compiled with the\n+definition. The behavior of code that is merely linked in (for example \n+code from libraries) is not affected.\n \n-Eventually there may be a way of asking the compiler to choose a register\n-automatically, but first we need to figure out how it should choose and\n-how to enable you to guide the choice.  No solution is evident.\n+If you want to recompile source files that do not actually use your global \n+register variable so they do not use the specified register for any other \n+purpose, you need not actually add the global register declaration to \n+their source code. It suffices to specify the compiler option \n+@option{-ffixed-@var{reg}} (@pxref{Code Gen Options}) to reserve the \n+register.\n \n-Defining a global register variable in a certain register reserves that\n-register entirely for this use, at least within the current compilation.\n-The register is not allocated for any other purpose in the functions\n-in the current compilation, and is not saved and restored by\n-these functions.  Stores into this register are never deleted even if they\n-appear to be dead, but references may be deleted or moved or\n-simplified.\n+@subsubheading Declaring the variable\n+\n+Global register variables can not have initial values, because an\n+executable file has no means to supply initial contents for a register.\n \n-It is not safe to access the global register variables from signal\n-handlers, or from more than one thread of control, because the system\n-library routines may temporarily use the register for other things (unless\n-you recompile them specially for the task at hand).\n+When selecting a register, choose one that is normally saved and \n+restored by function calls on your machine. This ensures that code\n+which is unaware of this reservation (such as library routines) will \n+restore it before returning.\n+\n+On machines with register windows, be sure to choose a global\n+register that is not affected magically by the function call mechanism.\n+\n+@subsubheading Using the variable\n \n @cindex @code{qsort}, and global register variables\n-It is not safe for one function that uses a global register variable to\n-call another such function @code{foo} by way of a third function\n-@code{lose} that is compiled without knowledge of this variable (i.e.@: in a\n-different source file in which the variable isn't declared).  This is\n-because @code{lose} might save the register and put some other value there.\n-For example, you can't expect a global register variable to be available in\n-the comparison-function that you pass to @code{qsort}, since @code{qsort}\n-might have put something else in that register.  (If you are prepared to\n-recompile @code{qsort} with the same global register variable, you can\n-solve this problem.)\n-\n-If you want to recompile @code{qsort} or other source files that do not\n-actually use your global register variable, so that they do not use that\n-register for any other purpose, then it suffices to specify the compiler\n-option @option{-ffixed-@var{reg}}.  You need not actually add a global\n-register declaration to their source code.\n-\n-A function that can alter the value of a global register variable cannot\n-safely be called from a function compiled without this variable, because it\n-could clobber the value the caller expects to find there on return.\n-Therefore, the function that is the entry point into the part of the\n-program that uses the global register variable must explicitly save and\n-restore the value that belongs to its caller.\n+When calling routines that are not aware of the reservation, be \n+cautious if those routines call back into code which uses them. As an \n+example, if you call the system library version of @code{qsort}, it may \n+clobber your registers during execution, but (if you have selected \n+appropriate registers) it will restore them before returning. However \n+it will @emph{not} restore them before calling @code{qsort}'s comparison \n+function. As a result, global values will not reliably be available to \n+the comparison function unless the @code{qsort} function itself is rebuilt.\n+\n+Similarly, it is not safe to access the global register variables from signal\n+handlers or from more than one thread of control. Unless you recompile \n+them specially for the task at hand, the system library routines may \n+temporarily use the register for other things.\n \n @cindex register variable after @code{longjmp}\n @cindex global register after @code{longjmp}\n @cindex value after @code{longjmp}\n @findex longjmp\n @findex setjmp\n On most machines, @code{longjmp} restores to each global register\n-variable the value it had at the time of the @code{setjmp}.  On some\n+variable the value it had at the time of the @code{setjmp}. On some\n machines, however, @code{longjmp} does not change the value of global\n-register variables.  To be portable, the function that called @code{setjmp}\n+register variables. To be portable, the function that called @code{setjmp}\n should make other arrangements to save the values of the global register\n-variables, and to restore them in a @code{longjmp}.  This way, the same\n+variables, and to restore them in a @code{longjmp}. This way, the same\n thing happens regardless of what @code{longjmp} does.\n \n-All global register variable declarations must precede all function\n-definitions.  If such a declaration could appear after function\n-definitions, the declaration would be too late to prevent the register from\n-being used for other purposes in the preceding functions.\n-\n-Global register variables may not have initial values, because an\n-executable file has no means to supply initial contents for a register.\n-\n-On the SPARC, there are reports that g3 @dots{} g7 are suitable\n-registers, but certain library functions, such as @code{getwd}, as well\n-as the subroutines for division and remainder, modify g3 and g4.  g1 and\n-g2 are local temporaries.\n-\n-On the 68000, a2 @dots{} a5 should be suitable, as should d2 @dots{} d7.\n-Of course, it does not do to use more than a few of those.\n-\n @node Local Register Variables\n @subsubsection Specifying Registers for Local Variables\n @anchor{Local Reg Vars}"}]}