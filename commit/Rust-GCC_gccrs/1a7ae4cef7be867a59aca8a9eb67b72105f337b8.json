{"sha": "1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE3YWU0Y2VmN2JlODY3YTU5YWNhOGE5ZWI2N2I3MjEwNWYzMzdiOA==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2015-05-11T07:53:33Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2015-05-11T07:53:33Z"}, "message": "arm.c (arm_option_override): Reoganized and split into : (arm_option_params_internal); New function.\n\n2014-09-23  Christian Bruel  <christian.bruel@st.com>\n\n\t* config/arm/arm.c (arm_option_override): Reoganized and split into :\n\t(arm_option_params_internal); New function.\n\t(arm_option_check_internal): New function.\n\t(arm_option_override_internal): New function.\n\t(thumb_code, thumb1_code): Remove.\n\t* config/arm/arm.h (TREE_TARGET_THUMB, TREE_TARGET_THUMB1): New macros.\n\t(TREE_TARGET_THUM2, TREE_TARGET_ARM): Likewise.\n\t(thumb_code, thumb1_code): Remove.\n\t* config/arm/arm.md (is_thumb, is_thumb1): Check TARGET flag.\n\nFrom-SVN: r222995", "tree": {"sha": "019a8c17f1aa6a069f9bf083c6d109a728871423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/019a8c17f1aa6a069f9bf083c6d109a728871423"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/comments", "author": null, "committer": null, "parents": [{"sha": "c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37aa43b98642686a5cd02f2bcb911cfa03c3c56"}], "stats": {"total": 315, "additions": 175, "deletions": 140}, "files": [{"sha": "30a802f04d42cf1e95a25e0783fc03b1ba4fa1ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "patch": "@@ -1,3 +1,15 @@\n+2014-09-23  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* config/arm/arm.c (arm_option_override): Reoganized and split into :\n+\t(arm_option_params_internal); New function.\n+\t(arm_option_check_internal): New function.\n+\t(arm_option_override_internal): New function.\n+\t(thumb_code, thumb1_code): Remove.\n+\t* config/arm/arm.h (TREE_TARGET_THUMB, TREE_TARGET_THUMB1): New macros.\n+\t(TREE_TARGET_THUM2, TREE_TARGET_ARM): Likewise.\n+\t(thumb_code, thumb1_code): Remove.\n+\t* config/arm/arm.md (is_thumb, is_thumb1): Check TARGET flag.\n+\n 2015-05-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (alpha_emit_set_const_1)"}, {"sha": "57f91c51490adf314fe89ca1c8e2e36de2fcad8b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 150, "deletions": 132, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "patch": "@@ -846,12 +846,6 @@ int arm_tune_wbuf = 0;\n /* Nonzero if tuning for Cortex-A9.  */\n int arm_tune_cortex_a9 = 0;\n \n-/* Nonzero if generating Thumb instructions.  */\n-int thumb_code = 0;\n-\n-/* Nonzero if generating Thumb-1 instructions.  */\n-int thumb1_code = 0;\n-\n /* Nonzero if we should define __THUMB_INTERWORK__ in the\n    preprocessor.\n    XXX This is a bit of a hack, it's intended to help work around\n@@ -2669,6 +2663,150 @@ arm_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n }\n \n+/* Check any incompatible options that the user has specified.  */\n+static void\n+arm_option_check_internal (struct gcc_options *opts)\n+{\n+  /* Make sure that the processor choice does not conflict with any of the\n+     other command line choices.  */\n+  if (TREE_TARGET_ARM (opts) && !(insn_flags & FL_NOTM))\n+    error (\"target CPU does not support ARM mode\");\n+\n+  /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n+     from here where no function is being compiled currently.  */\n+  if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TREE_TARGET_ARM (opts))\n+    warning (0, \"enabling backtrace support is only meaningful when compiling for the Thumb\");\n+\n+  if (TREE_TARGET_ARM (opts) && TARGET_CALLEE_INTERWORKING)\n+    warning (0, \"enabling callee interworking support is only meaningful when compiling for the Thumb\");\n+\n+  /* If this target is normally configured to use APCS frames, warn if they\n+     are turned off and debugging is turned on.  */\n+  if (TREE_TARGET_ARM (opts)\n+      && write_symbols != NO_DEBUG\n+      && !TARGET_APCS_FRAME\n+      && (TARGET_DEFAULT & MASK_APCS_FRAME))\n+    warning (0, \"-g with -mno-apcs-frame may not give sensible debugging\");\n+\n+  /* iWMMXt unsupported under Thumb mode.  */\n+  if (TREE_TARGET_THUMB (opts) && TARGET_IWMMXT)\n+    error (\"iWMMXt unsupported under Thumb mode\");\n+\n+  if (TARGET_HARD_TP && TREE_TARGET_THUMB1 (opts))\n+    error (\"can not use -mtp=cp15 with 16-bit Thumb\");\n+\n+  if (TREE_TARGET_THUMB (opts) && TARGET_VXWORKS_RTP && flag_pic)\n+    {\n+      error (\"RTP PIC is incompatible with Thumb\");\n+      flag_pic = 0;\n+    }\n+\n+  /* We only support -mslow-flash-data on armv7-m targets.  */\n+  if (target_slow_flash_data\n+      && ((!(arm_arch7 && !arm_arch_notm) && !arm_arch7em)\n+\t  || (TREE_TARGET_THUMB1 (opts) || flag_pic || TARGET_NEON)))\n+    error (\"-mslow-flash-data only supports non-pic code on armv7-m targets\");\n+}\n+\n+/* Set params depending on attributes and optimization options.  */\n+static void\n+arm_option_params_internal (struct gcc_options *opts)\n+{\n+ /* If we are not using the default (ARM mode) section anchor offset\n+     ranges, then set the correct ranges now.  */\n+  if (TREE_TARGET_THUMB1 (opts))\n+    {\n+      /* Thumb-1 LDR instructions cannot have negative offsets.\n+         Permissible positive offset ranges are 5-bit (for byte loads),\n+         6-bit (for halfword loads), or 7-bit (for word loads).\n+         Empirical results suggest a 7-bit anchor range gives the best\n+         overall code size.  */\n+      targetm.min_anchor_offset = 0;\n+      targetm.max_anchor_offset = 127;\n+    }\n+  else if (TREE_TARGET_THUMB2 (opts))\n+    {\n+      /* The minimum is set such that the total size of the block\n+         for a particular anchor is 248 + 1 + 4095 bytes, which is\n+         divisible by eight, ensuring natural spacing of anchors.  */\n+      targetm.min_anchor_offset = -248;\n+      targetm.max_anchor_offset = 4095;\n+    }\n+  else\n+    {\n+      targetm.min_anchor_offset = TARGET_MIN_ANCHOR_OFFSET;\n+      targetm.max_anchor_offset = TARGET_MAX_ANCHOR_OFFSET;\n+    }\n+\n+  if (optimize_size)\n+    {\n+      /* If optimizing for size, bump the number of instructions that we\n+         are prepared to conditionally execute (even on a StrongARM).  */\n+      max_insns_skipped = 6;\n+\n+      /* For THUMB2, we limit the conditional sequence to one IT block.  */\n+      if (TREE_TARGET_THUMB2 (opts))\n+        max_insns_skipped = opts->x_arm_restrict_it ? 1 : 4;\n+    }\n+  else\n+    max_insns_skipped = current_tune->max_insns_skipped;\n+}\n+\n+/* Reset options between modes that the user has specified.  */\n+static void\n+arm_option_override_internal (struct gcc_options *opts,\n+\t\t\t      struct gcc_options *opts_set)\n+{\n+  if (TREE_TARGET_THUMB (opts) && !(insn_flags & FL_THUMB))\n+    {\n+      warning (0, \"target CPU does not support THUMB instructions\");\n+      opts->x_target_flags &= ~MASK_THUMB;\n+    }\n+\n+  if (TARGET_APCS_FRAME && TREE_TARGET_THUMB (opts))\n+    {\n+      /* warning (0, \"ignoring -mapcs-frame because -mthumb was used\"); */\n+      opts->x_target_flags &= ~MASK_APCS_FRAME;\n+    }\n+\n+  /* Callee super interworking implies thumb interworking.  Adding\n+     this to the flags here simplifies the logic elsewhere.  */\n+  if (TREE_TARGET_THUMB (opts) && TARGET_CALLEE_INTERWORKING)\n+    opts->x_target_flags |= MASK_INTERWORK;\n+\n+  if (! opts_set->x_arm_restrict_it)\n+    opts->x_arm_restrict_it = arm_arch8;\n+\n+  if (!TREE_TARGET_THUMB2 (opts))\n+    opts->x_arm_restrict_it = 0;\n+\n+  if (TREE_TARGET_THUMB1 (opts))\n+    {\n+      /* Don't warn since it's on by default in -O2.  */\n+      opts->x_flag_schedule_insns = 0;\n+    }\n+\n+  /* Disable shrink-wrap when optimizing function for size, since it tends to\n+     generate additional returns.  */\n+  if (optimize_function_for_size_p (cfun) && TREE_TARGET_THUMB2 (opts))\n+    opts->x_flag_shrink_wrap = false;\n+\n+  /* In Thumb1 mode, we emit the epilogue in RTL, but the last insn\n+     - epilogue_insns - does not accurately model the corresponding insns\n+     emitted in the asm file.  In particular, see the comment in thumb_exit\n+     'Find out how many of the (return) argument registers we can corrupt'.\n+     As a consequence, the epilogue may clobber registers without fipa-ra\n+     finding out about it.  Therefore, disable fipa-ra in Thumb1 mode.\n+     TODO: Accurately model clobbers for epilogue_insns and reenable\n+     fipa-ra.  */\n+  if (TREE_TARGET_THUMB1 (opts))\n+    opts->x_flag_ipa_ra = 0;\n+\n+  /* Thumb2 inline assembly code should always use unified syntax.\n+     This will apply to ARM and Thumb1 eventually.  */\n+  opts->x_inline_asm_unified = TREE_TARGET_THUMB2 (opts);\n+}\n+\n /* Fix up any incompatible options that the user has specified.  */\n static void\n arm_option_override (void)\n@@ -2815,10 +2953,9 @@ arm_option_override (void)\n   tune_flags = arm_selected_tune->flags;\n   current_tune = arm_selected_tune->tune;\n \n-  /* Make sure that the processor choice does not conflict with any of the\n-     other command line choices.  */\n-  if (TARGET_ARM && !(insn_flags & FL_NOTM))\n-    error (\"target CPU does not support ARM mode\");\n+  /* TBD: Dwarf info for apcs frame is not handled yet.  */\n+  if (TARGET_APCS_FRAME)\n+    flag_shrink_wrap = false;\n \n   /* BPABI targets use linker tricks to allow interworking on cores\n      without thumb support.  */\n@@ -2828,31 +2965,6 @@ arm_option_override (void)\n       target_flags &= ~MASK_INTERWORK;\n     }\n \n-  if (TARGET_THUMB && !(insn_flags & FL_THUMB))\n-    {\n-      warning (0, \"target CPU does not support THUMB instructions\");\n-      target_flags &= ~MASK_THUMB;\n-    }\n-\n-  if (TARGET_APCS_FRAME && TARGET_THUMB)\n-    {\n-      /* warning (0, \"ignoring -mapcs-frame because -mthumb was used\"); */\n-      target_flags &= ~MASK_APCS_FRAME;\n-    }\n-\n-  /* Callee super interworking implies thumb interworking.  Adding\n-     this to the flags here simplifies the logic elsewhere.  */\n-  if (TARGET_THUMB && TARGET_CALLEE_INTERWORKING)\n-    target_flags |= MASK_INTERWORK;\n-\n-  /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n-     from here where no function is being compiled currently.  */\n-  if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TARGET_ARM)\n-    warning (0, \"enabling backtrace support is only meaningful when compiling for the Thumb\");\n-\n-  if (TARGET_ARM && TARGET_CALLEE_INTERWORKING)\n-    warning (0, \"enabling callee interworking support is only meaningful when compiling for the Thumb\");\n-\n   if (TARGET_APCS_STACK && !TARGET_APCS_FRAME)\n     {\n       warning (0, \"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n@@ -2868,14 +2980,6 @@ arm_option_override (void)\n   if (TARGET_APCS_REENT)\n     warning (0, \"APCS reentrant code not supported.  Ignored\");\n \n-  /* If this target is normally configured to use APCS frames, warn if they\n-     are turned off and debugging is turned on.  */\n-  if (TARGET_ARM\n-      && write_symbols != NO_DEBUG\n-      && !TARGET_APCS_FRAME\n-      && (TARGET_DEFAULT & MASK_APCS_FRAME))\n-    warning (0, \"-g with -mno-apcs-frame may not give sensible debugging\");\n-\n   if (TARGET_APCS_FLOAT)\n     warning (0, \"passing floating point arguments in fp regs not yet supported\");\n \n@@ -2897,8 +3001,6 @@ arm_option_override (void)\n \n   arm_ld_sched = (tune_flags & FL_LDSCHED) != 0;\n   arm_tune_strongarm = (tune_flags & FL_STRONG) != 0;\n-  thumb_code = TARGET_ARM == 0;\n-  thumb1_code = TARGET_THUMB1 != 0;\n   arm_tune_wbuf = (tune_flags & FL_WBUF) != 0;\n   arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;\n   arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;\n@@ -2909,32 +3011,6 @@ arm_option_override (void)\n   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;\n   arm_arch_crc = (insn_flags & FL_CRC32) != 0;\n   arm_m_profile_small_mul = (insn_flags & FL_SMALLMUL) != 0;\n-  if (arm_restrict_it == 2)\n-    arm_restrict_it = arm_arch8 && TARGET_THUMB2;\n-\n-  if (!TARGET_THUMB2)\n-    arm_restrict_it = 0;\n-\n-  /* If we are not using the default (ARM mode) section anchor offset\n-     ranges, then set the correct ranges now.  */\n-  if (TARGET_THUMB1)\n-    {\n-      /* Thumb-1 LDR instructions cannot have negative offsets.\n-         Permissible positive offset ranges are 5-bit (for byte loads),\n-         6-bit (for halfword loads), or 7-bit (for word loads).\n-         Empirical results suggest a 7-bit anchor range gives the best\n-         overall code size.  */\n-      targetm.min_anchor_offset = 0;\n-      targetm.max_anchor_offset = 127;\n-    }\n-  else if (TARGET_THUMB2)\n-    {\n-      /* The minimum is set such that the total size of the block\n-         for a particular anchor is 248 + 1 + 4095 bytes, which is\n-         divisible by eight, ensuring natural spacing of anchors.  */\n-      targetm.min_anchor_offset = -248;\n-      targetm.max_anchor_offset = 4095;\n-    }\n \n   /* V5 code we generate is completely interworking capable, so we turn off\n      TARGET_INTERWORK here to avoid many tests later on.  */\n@@ -2994,10 +3070,6 @@ arm_option_override (void)\n   if (TARGET_IWMMXT && TARGET_NEON)\n     error (\"iWMMXt and NEON are incompatible\");\n \n-  /* iWMMXt unsupported under Thumb mode.  */\n-  if (TARGET_THUMB && TARGET_IWMMXT)\n-    error (\"iWMMXt unsupported under Thumb mode\");\n-\n   /* __fp16 support currently assumes the core has ldrh.  */\n   if (!arm_arch4 && arm_fp16_format != ARM_FP16_FORMAT_NONE)\n     sorry (\"__fp16 and no ldrh\");\n@@ -3042,9 +3114,6 @@ arm_option_override (void)\n \ttarget_thread_pointer = TP_SOFT;\n     }\n \n-  if (TARGET_HARD_TP && TARGET_THUMB1)\n-    error (\"can not use -mtp=cp15 with 16-bit Thumb\");\n-\n   /* Override the default structure alignment for AAPCS ABI.  */\n   if (!global_options_set.x_arm_structure_size_boundary)\n     {\n@@ -3067,12 +3136,6 @@ arm_option_override (void)\n \t}\n     }\n \n-  if (!TARGET_ARM && TARGET_VXWORKS_RTP && flag_pic)\n-    {\n-      error (\"RTP PIC is incompatible with Thumb\");\n-      flag_pic = 0;\n-    }\n-\n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  The EABI specifies r9 as the PIC register.  */\n   if (flag_pic && TARGET_SINGLE_PIC_BASE)\n@@ -3140,25 +3203,6 @@ arm_option_override (void)\n       unaligned_access = 0;\n     }\n \n-  if (TARGET_THUMB1 && flag_schedule_insns)\n-    {\n-      /* Don't warn since it's on by default in -O2.  */\n-      flag_schedule_insns = 0;\n-    }\n-\n-  if (optimize_size)\n-    {\n-      /* If optimizing for size, bump the number of instructions that we\n-         are prepared to conditionally execute (even on a StrongARM).  */\n-      max_insns_skipped = 6;\n-\n-      /* For THUMB2, we limit the conditional sequence to one IT block.  */\n-      if (TARGET_THUMB2)\n-\tmax_insns_skipped = MAX_INSN_PER_IT_BLOCK;\n-    }\n-  else\n-    max_insns_skipped = current_tune->max_insns_skipped;\n-\n   /* Hot/Cold partitioning is not currently supported, since we can't\n      handle literal pool placement in that case.  */\n   if (flag_reorder_blocks_and_partition)\n@@ -3236,45 +3280,19 @@ arm_option_override (void)\n                          global_options.x_param_values,\n                          global_options_set.x_param_values);\n \n-  /* Disable shrink-wrap when optimizing function for size, since it tends to\n-     generate additional returns.  */\n-  if (optimize_function_for_size_p (cfun) && TARGET_THUMB2)\n-    flag_shrink_wrap = false;\n-  /* TBD: Dwarf info for apcs frame is not handled yet.  */\n-  if (TARGET_APCS_FRAME)\n-    flag_shrink_wrap = false;\n-\n-  /* We only support -mslow-flash-data on armv7-m targets.  */\n-  if (target_slow_flash_data\n-      && ((!(arm_arch7 && !arm_arch_notm) && !arm_arch7em)\n-\t  || (TARGET_THUMB1 || flag_pic || TARGET_NEON)))\n-    error (\"-mslow-flash-data only supports non-pic code on armv7-m targets\");\n-\n   /* Currently, for slow flash data, we just disable literal pools.  */\n   if (target_slow_flash_data)\n     arm_disable_literal_pool = true;\n \n-  /* Thumb2 inline assembly code should always use unified syntax.\n-     This will apply to ARM and Thumb1 eventually.  */\n-  if (TARGET_THUMB2)\n-    inline_asm_unified = 1;\n-\n   /* Disable scheduling fusion by default if it's not armv7 processor\n      or doesn't prefer ldrd/strd.  */\n   if (flag_schedule_fusion == 2\n       && (!arm_arch7 || !current_tune->prefer_ldrd_strd))\n     flag_schedule_fusion = 0;\n \n-  /* In Thumb1 mode, we emit the epilogue in RTL, but the last insn\n-     - epilogue_insns - does not accurately model the corresponding insns\n-     emitted in the asm file.  In particular, see the comment in thumb_exit\n-     'Find out how many of the (return) argument registers we can corrupt'.\n-     As a consequence, the epilogue may clobber registers without fipa-ra\n-     finding out about it.  Therefore, disable fipa-ra in Thumb1 mode.\n-     TODO: Accurately model clobbers for epilogue_insns and reenable\n-     fipa-ra.  */\n-  if (TARGET_THUMB1)\n-    flag_ipa_ra = 0;\n+  arm_option_override_internal (&global_options, &global_options_set);\n+  arm_option_check_internal (&global_options);\n+  arm_option_params_internal (&global_options);\n \n   /* Register global variables with the garbage collector.  */\n   arm_add_gc_roots ();"}, {"sha": "aec5fb8e19ae13b36e93ba2b061160423e70eea6", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "patch": "@@ -252,6 +252,13 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define SUBTARGET_CPP_SPEC      \"\"\n #endif\n \f\n+/* Tree Target Specification.  */\n+#define TREE_TARGET_THUMB(opts)  (TARGET_THUMB_P (opts->x_target_flags))\n+#define TREE_TARGET_ARM(opts)    (!TARGET_THUMB_P (opts->x_target_flags))\n+#define TREE_TARGET_THUMB1(opts) (TARGET_THUMB_P (opts->x_target_flags) \\\n+\t\t\t\t  && !arm_arch_thumb2)\n+#define TREE_TARGET_THUMB2(opts) (TARGET_THUMB_P (opts->x_target_flags) \\\n+\t\t\t\t  && arm_arch_thumb2)\n /* Run-time Target Specification.  */\n #define TARGET_SOFT_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_SOFT)\n /* Use hardware floating point instructions. */\n@@ -528,12 +535,6 @@ extern int arm_arch8;\n /* Nonzero if this chip can benefit from load scheduling.  */\n extern int arm_ld_sched;\n \n-/* Nonzero if generating Thumb code, either Thumb-1 or Thumb-2.  */\n-extern int thumb_code;\n-\n-/* Nonzero if generating Thumb-1 code.  */\n-extern int thumb1_code;\n-\n /* Nonzero if this chip is a StrongARM.  */\n extern int arm_tune_strongarm;\n "}, {"sha": "3dd5f961933f911b91d34c2e1b6d55178d1ca309", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a7ae4cef7be867a59aca8a9eb67b72105f337b8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=1a7ae4cef7be867a59aca8a9eb67b72105f337b8", "patch": "@@ -69,13 +69,17 @@\n ; IS_THUMB is set to 'yes' when we are generating Thumb code, and 'no' when\n ; generating ARM code.  This is used to control the length of some insn\n ; patterns that share the same RTL in both ARM and Thumb code.\n-(define_attr \"is_thumb\" \"no,yes\" (const (symbol_ref \"thumb_code\")))\n+(define_attr \"is_thumb\" \"yes,no\"\n+  (const (if_then_else (symbol_ref \"TARGET_THUMB\")\n+\t\t       (const_string \"yes\") (const_string \"no\"))))\n \n ; IS_ARCH6 is set to 'yes' when we are generating code form ARMv6.\n (define_attr \"is_arch6\" \"no,yes\" (const (symbol_ref \"arm_arch6\")))\n \n ; IS_THUMB1 is set to 'yes' iff we are generating Thumb-1 code.\n-(define_attr \"is_thumb1\" \"no,yes\" (const (symbol_ref \"thumb1_code\")))\n+(define_attr \"is_thumb1\" \"yes,no\"\n+  (const (if_then_else (symbol_ref \"TARGET_THUMB1\")\n+\t\t       (const_string \"yes\") (const_string \"no\"))))\n \n ; We use this attribute to disable alternatives that can produce 32-bit\n ; instructions inside an IT-block in Thumb2 state.  ARMv8 deprecates IT blocks"}]}