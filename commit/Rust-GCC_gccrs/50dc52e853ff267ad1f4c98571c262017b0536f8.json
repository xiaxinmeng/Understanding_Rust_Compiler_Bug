{"sha": "50dc52e853ff267ad1f4c98571c262017b0536f8", "node_id": "C_kwDOANBUbNoAKDUwZGM1MmU4NTNmZjI2N2FkMWY0Yzk4NTcxYzI2MjAxN2IwNTM2Zjg", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-04-13T20:02:21Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-04-13T20:02:21Z"}, "message": "c++: 'typename T::X' vs 'struct T::X' lookup [PR109420]\n\nr13-6098-g46711ff8e60d64 made make_typename_type no longer ignore\nnon-types during the lookup, unless the TYPENAME_TYPE in question was\nfollowed by the :: scope resolution operator.  But there is another\nexception to this rule: we need to ignore non-types during the lookup\nalso if the TYPENAME_TYPE was named with a tag other than 'typename',\nsuch as 'struct' or 'enum', since in that case we're dealing with an\nelaborated-type-specifier and so [basic.lookup.elab] applies.  This\npatch implements this additional exception.\n\n\tPR c++/109420\n\ngcc/cp/ChangeLog:\n\n\t* decl.cc (make_typename_type): Also ignore non-types during the\n\tlookup if tag_type corresponds to an elaborated-type-specifier.\n\t* pt.cc (tsubst) <case TYPENAME_TYPE>: Pass class_type or\n\tenum_type as tag_type to make_typename_type accordingly instead\n\tof always passing typename_type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/typename27.C: New test.", "tree": {"sha": "311b6c8f217974e3959d8a7da177f63964405261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/311b6c8f217974e3959d8a7da177f63964405261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50dc52e853ff267ad1f4c98571c262017b0536f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dc52e853ff267ad1f4c98571c262017b0536f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50dc52e853ff267ad1f4c98571c262017b0536f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dc52e853ff267ad1f4c98571c262017b0536f8/comments", "author": null, "committer": null, "parents": [{"sha": "f32f7881fb0db085479525b5a23db5dabd990c3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32f7881fb0db085479525b5a23db5dabd990c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32f7881fb0db085479525b5a23db5dabd990c3b"}], "stats": {"total": 40, "additions": 38, "deletions": 2}, "files": [{"sha": "772c059dc2c340c706269e878ce59cead76c8ab4", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc52e853ff267ad1f4c98571c262017b0536f8/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc52e853ff267ad1f4c98571c262017b0536f8/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=50dc52e853ff267ad1f4c98571c262017b0536f8", "patch": "@@ -4307,7 +4307,17 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n      lookup will stop when we hit a dependent base.  */\n   if (!dependent_scope_p (context))\n     {\n-      bool want_type = (complain & tf_qualifying_scope);\n+      /* We generally don't ignore non-types during TYPENAME_TYPE lookup\n+\t (as per [temp.res.general]/3), unless\n+\t   - the tag corresponds to a class-key or 'enum' so\n+\t     [basic.lookup.elab] applies, or\n+\t   - the tag corresponds to scope_type or tf_qualifying_scope is\n+\t     set so [basic.lookup.qual]/1 applies.\n+\t TODO: If we'd set/track the scope_type tag thoroughly on all\n+\t TYPENAME_TYPEs that are followed by :: then we wouldn't need the\n+\t tf_qualifying_scope flag.  */\n+      bool want_type = (tag_type != none_type && tag_type != typename_type)\n+\t|| (complain & tf_qualifying_scope);\n       t = lookup_member (context, name, /*protect=*/2, want_type, complain);\n     }\n   else"}, {"sha": "fcc8e0d1d571ce4f8887d7b94d57afe8825534a2", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc52e853ff267ad1f4c98571c262017b0536f8/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc52e853ff267ad1f4c98571c262017b0536f8/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=50dc52e853ff267ad1f4c98571c262017b0536f8", "patch": "@@ -16580,9 +16580,16 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      return error_mark_node;\n \t  }\n \n+\t/* FIXME: TYPENAME_IS_CLASS_P conflates 'class' vs 'struct' vs 'union'\n+\t   tags.  TYPENAME_TYPE should probably remember the exact tag that\n+\t   was written.  */\n+\tenum tag_types tag_type\n+\t  = TYPENAME_IS_CLASS_P (t) ? class_type\n+\t  : TYPENAME_IS_ENUM_P (t) ? enum_type\n+\t  : typename_type;\n \ttsubst_flags_t tcomplain = complain | tf_keep_type_decl;\n \ttcomplain |= tst_ok_flag | qualifying_scope_flag;\n-\tf = make_typename_type (ctx, f, typename_type, tcomplain);\n+\tf = make_typename_type (ctx, f, tag_type, tcomplain);\n \tif (f == error_mark_node)\n \t  return f;\n \tif (TREE_CODE (f) == TYPE_DECL)"}, {"sha": "61b3efd998eadcbe83d6027976aa157956e64f02", "filename": "gcc/testsuite/g++.dg/template/typename27.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50dc52e853ff267ad1f4c98571c262017b0536f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50dc52e853ff267ad1f4c98571c262017b0536f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename27.C?ref=50dc52e853ff267ad1f4c98571c262017b0536f8", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/109420\n+\n+struct A {\n+  struct X { };\n+  int X;\n+};\n+\n+struct B {\n+  enum E { };\n+  enum F { E };\n+};\n+\n+template<class T, class U>\n+void f() {\n+  struct T::X x; // OK, lookup ignores the data member 'int A::X'\n+  enum U::E e;   // OK, lookup ignores the enumerator 'B::F::E'\n+}\n+\n+template void f<A, B>();"}]}