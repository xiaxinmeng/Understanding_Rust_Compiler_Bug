{"sha": "84d594532534434f54c8b2476482316c41abd164", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRkNTk0NTMyNTM0NDM0ZjU0YzhiMjQ3NjQ4MjMxNmM0MWFiZDE2NA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-07-02T02:07:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-07-02T02:07:28Z"}, "message": "dwarfout.c (field_byte_offset): Correctly compute the object's byte offset for the first bit of a field which...\n\n        * dwarfout.c (field_byte_offset): Correctly compute the object's\n        byte offset for the first bit of a field which crosses an alignment\n        boundary on a !BYTES_BIG_ENDIAN target.\n\nFrom-SVN: r27921", "tree": {"sha": "4b7fed61e920b41d368b481f726229b1eb4530f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b7fed61e920b41d368b481f726229b1eb4530f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84d594532534434f54c8b2476482316c41abd164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d594532534434f54c8b2476482316c41abd164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d594532534434f54c8b2476482316c41abd164", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d594532534434f54c8b2476482316c41abd164/comments", "author": null, "committer": null, "parents": [{"sha": "92080f30a2a71f0555bfb7fc433cc1a030141e24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92080f30a2a71f0555bfb7fc433cc1a030141e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92080f30a2a71f0555bfb7fc433cc1a030141e24"}], "stats": {"total": 18, "additions": 16, "deletions": 2}, "files": [{"sha": "c3ef1de4260658a4cec59cfe57b360267f12782b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d594532534434f54c8b2476482316c41abd164/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d594532534434f54c8b2476482316c41abd164/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84d594532534434f54c8b2476482316c41abd164", "patch": "@@ -1,3 +1,9 @@\n+Fri Jul  2 03:05:44 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* dwarfout.c (field_byte_offset): Correctly compute the object's\n+\tbyte offset for the first bit of a field which crosses an alignment\n+\tboundary on a !BYTES_BIG_ENDIAN target.\n+\n Fri Jul  2 01:36:36 1999  Robert Lipe  <robertlipe@usa.net>\n \n \t* fixinc.svr4: Fix <arpa/inet.h> by deleting protos for htons and"}, {"sha": "9c419a8bca1df1ea93a409d9c4db78621a5b2549", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84d594532534434f54c8b2476482316c41abd164/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84d594532534434f54c8b2476482316c41abd164/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=84d594532534434f54c8b2476482316c41abd164", "patch": "@@ -2106,8 +2106,16 @@ field_byte_offset (decl)\n      negative.  Gdb fails when given negative bit offsets.  We avoid this\n      by recomputing using the first bit of the bitfield.  This will give\n      us an object which does not completely contain the bitfield, but it\n-     will be aligned, and it will contain the first bit of the bitfield.  */\n-  if (object_offset_in_bits > bitpos_int)\n+     will be aligned, and it will contain the first bit of the bitfield.\n+\n+     However, only do this for a BYTES_BIG_ENDIAN target.  For a\n+     ! BYTES_BIG_ENDIAN target, bitpos_int + field_size_in_bits is the first\n+     first bit of the bitfield.  If we recompute using bitpos_int + 1 below,\n+     then we end up computing the object byte offset for the wrong word of the\n+     desired bitfield, which in turn causes the field offset to be negative\n+     in bit_offset_attribute.  */\n+  if (BYTES_BIG_ENDIAN\n+      && object_offset_in_bits > bitpos_int)\n     {\n       deepest_bitpos = bitpos_int + 1;\n       object_offset_in_bits"}]}