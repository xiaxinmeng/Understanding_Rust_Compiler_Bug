{"sha": "7d69de618e732d343228a07d797a30e39a6363f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q2OWRlNjE4ZTczMmQzNDMyMjhhMDdkNzk3YTMwZTM5YTYzNjNmNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-27T07:41:16Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-06-27T07:41:16Z"}, "message": "c-cppbuiltin.c (c_cpp_builtins): Add __SSP_ALL__ and __SSP__.\n\n\t* c-cppbuiltin.c (c_cpp_builtins): Add __SSP_ALL__ and __SSP__.\n\t* cfgexpand.c: Include params.h.\n\t(has_protected_decls, has_short_buffer): New.\n\t(expand_stack_vars): Take a predicate to determine what to expand.\n\t(defer_stack_allocation): True when flag_stack_protect on.\n\t(SPCT_HAS_LARGE_CHAR_ARRAY, SPCT_HAS_SMALL_CHAR_ARRAY): New.\n\t(SPCT_HAS_ARRAY, SPCT_HAS_AGGREGATE): New.\n\t(stack_protect_classify_type, stack_protect_decl_phase): New.\n\t(stack_protect_decl_phase_1, stack_protect_decl_phase_2): New.\n\t(add_stack_protection_conflicts, create_stack_guard): New.\n\t(expand_used_vars): Add stack protection logic.\n\t(tree_expand_cfg): Likewise.\n\t* common.opt (Wstack-protector): New.\n\t(fstack-protector, fstack-protector-all): New.\n\t* function.c: Include predict.h.\n\t(assign_parm_adjust_stack_rtl): Zap stack_parm when stack protect\n\twants to copy the parameter into the stack frame.\n\t(stack_protect_prologue, stack_protect_epilogue): New.\n\t(expand_function_end): Call stack_protect_epilogue.  Do\n\tsjlj_emit_function_exit_after after naked_return_label.\n\t* function.h (struct function): Add stack_protect_guard.\n\t* params.def (PARAM_SSP_BUFFER_SIZE): New.\n\t* toplev.c (process_options): Disable flag_stack_protect and/or\n\twarn_stack_protect based on FRAME_GROWS_DOWNWARD.\n\t* tree.h (stack_protect_prologue): Declare.\n\n\t* target-def.h (TARGET_STACK_PROTECT_GUARD): New.\n\t(TARGET_STACK_PROTECT_FAIL): New.\n\t(TARGET_INITIALIZER): Add them.\n\t* target.h (struct gcc_target): Add stack_protect_guard and\n\tstack_protect_fail.\n\t* targhooks.c: Include ggc.h, gty header.\n\t(stack_chk_guard_decl, default_stack_protect_guard): New.\n\t(stack_chk_fail_decl, default_external_stack_protect_fail): New.\n\t(default_hidden_stack_protect_fail): New.\n\t* targhooks.h (default_stack_protect_guard): Declare.\n\t(default_external_stack_protect_fail): Declare.\n\t(default_hidden_stack_protect_fail): Declare.\n\t* config/i386/i386.c (TARGET_STACK_PROTECT_FAIL): New.\n\t* config/i386/i386.md (UNSPEC_SP_SET, UNSPEC_SP_TEST): New.\n\t(trap): Use ud2.\n\t(conditional_trap, conditional_trap_1): Remove.\n\t(stack_protect_set, stack_protect_set_si, stack_protect_set_di): New.\n\t(stack_protect_test, stack_protect_test_si, stack_protect_test_di): New.\n\t* doc/md.texi (stack_protect_set, stack_protect_test): New.\n\t* doc/tm.texi (TARGET_STACK_PROTECT_GUARD): New.\n\t(TARGET_STACK_PROTECT_FAIL): New.\n\n\t* libgcc-std.ver (GCC_4.1.0): New.\n\t* libgcc.h (__stack_chk_guard): Declare.\n\t(__stack_chk_fail, __stack_chk_fail_local): Declare.\n\t* libgcc2.c (L_stack_chk, L_stack_chk_local): New.\n\t* mklibgcc.in (lib2funcs): Add them.\n\nFrom-SVN: r101348", "tree": {"sha": "ec9a39649967b762606a254cf15ed23a12ed7401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec9a39649967b762606a254cf15ed23a12ed7401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d69de618e732d343228a07d797a30e39a6363f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d69de618e732d343228a07d797a30e39a6363f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d69de618e732d343228a07d797a30e39a6363f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d69de618e732d343228a07d797a30e39a6363f4/comments", "author": null, "committer": null, "parents": [{"sha": "2bcf2e2bf17d13a20c587d056f3426fda0106379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bcf2e2bf17d13a20c587d056f3426fda0106379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bcf2e2bf17d13a20c587d056f3426fda0106379"}], "stats": {"total": 869, "additions": 809, "deletions": 60}, "files": [{"sha": "efa4b6e8fcab69aab527cca57e12fd7277dc11a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -1,3 +1,59 @@\n+2005-06-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-cppbuiltin.c (c_cpp_builtins): Add __SSP_ALL__ and __SSP__.\n+\t* cfgexpand.c: Include params.h.\n+\t(has_protected_decls, has_short_buffer): New.\n+\t(expand_stack_vars): Take a predicate to determine what to expand.\n+\t(defer_stack_allocation): True when flag_stack_protect on.\n+\t(SPCT_HAS_LARGE_CHAR_ARRAY, SPCT_HAS_SMALL_CHAR_ARRAY): New.\n+\t(SPCT_HAS_ARRAY, SPCT_HAS_AGGREGATE): New.\n+\t(stack_protect_classify_type, stack_protect_decl_phase): New.\n+\t(stack_protect_decl_phase_1, stack_protect_decl_phase_2): New.\n+\t(add_stack_protection_conflicts, create_stack_guard): New.\n+\t(expand_used_vars): Add stack protection logic.\n+\t(tree_expand_cfg): Likewise.\n+\t* common.opt (Wstack-protector): New.\n+\t(fstack-protector, fstack-protector-all): New.\n+\t* function.c: Include predict.h.\n+\t(assign_parm_adjust_stack_rtl): Zap stack_parm when stack protect\n+\twants to copy the parameter into the stack frame.\n+\t(stack_protect_prologue, stack_protect_epilogue): New.\n+\t(expand_function_end): Call stack_protect_epilogue.  Do \n+\tsjlj_emit_function_exit_after after naked_return_label.\n+\t* function.h (struct function): Add stack_protect_guard.\n+\t* params.def (PARAM_SSP_BUFFER_SIZE): New.\n+\t* toplev.c (process_options): Disable flag_stack_protect and/or\n+\twarn_stack_protect based on FRAME_GROWS_DOWNWARD.\n+\t* tree.h (stack_protect_prologue): Declare.\n+\n+\t* target-def.h (TARGET_STACK_PROTECT_GUARD): New.\n+\t(TARGET_STACK_PROTECT_FAIL): New.\n+\t(TARGET_INITIALIZER): Add them.\n+\t* target.h (struct gcc_target): Add stack_protect_guard and\n+\tstack_protect_fail.\n+\t* targhooks.c: Include ggc.h, gty header.\n+\t(stack_chk_guard_decl, default_stack_protect_guard): New.\n+\t(stack_chk_fail_decl, default_external_stack_protect_fail): New.\n+\t(default_hidden_stack_protect_fail): New.\n+\t* targhooks.h (default_stack_protect_guard): Declare.\n+\t(default_external_stack_protect_fail): Declare.\n+\t(default_hidden_stack_protect_fail): Declare.\n+\t* config/i386/i386.c (TARGET_STACK_PROTECT_FAIL): New.\n+\t* config/i386/i386.md (UNSPEC_SP_SET, UNSPEC_SP_TEST): New.\n+\t(trap): Use ud2.\n+\t(conditional_trap, conditional_trap_1): Remove.\n+\t(stack_protect_set, stack_protect_set_si, stack_protect_set_di): New.\n+\t(stack_protect_test, stack_protect_test_si, stack_protect_test_di): New.\n+\t* doc/md.texi (stack_protect_set, stack_protect_test): New.\n+\t* doc/tm.texi (TARGET_STACK_PROTECT_GUARD): New.\n+\t(TARGET_STACK_PROTECT_FAIL): New.\n+\n+\t* libgcc-std.ver (GCC_4.1.0): New.\n+\t* libgcc.h (__stack_chk_guard): Declare.\n+\t(__stack_chk_fail, __stack_chk_fail_local): Declare.\n+\t* libgcc2.c (L_stack_chk, L_stack_chk_local): New.\n+\t* mklibgcc.in (lib2funcs): Add them.\n+\n 2005-06-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tPR c/21911"}, {"sha": "628d36ca4212018ef9c019c38b2168d11ee5db15", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -1972,7 +1972,7 @@ opts.o : opts.c opts.h options.h toplev.h $(CONFIG_H) $(SYSTEM_H) \\\n    $(FLAGS_H) $(PARAMS_H)\n targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n    $(EXPR_H) $(TM_H) $(RTL_H) $(TM_P_H) function.h output.h toplev.h \\\n-   $(MACHMODE_H) $(TARGET_DEF_H) $(TARGET_H)\n+   $(MACHMODE_H) $(TARGET_DEF_H) $(TARGET_H) $(GGC_H) gt-targhooks.h\n \n toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    version.h $(RTL_H) function.h $(FLAGS_H) xcoffout.h input.h \\\n@@ -2025,7 +2025,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(CFGLAYOUT_H) $(TREE_GIMPLE_H) $(FLAGS_H) function.h $(EXPR_H) \\\n    $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n-   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H)\n+   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H)\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) function.h insn-config.h hard-reg-set.h $(EXPR_H) \\\n    libfuncs.h except.h $(RECOG_H) toplev.h output.h $(GGC_H) $(TM_P_H) \\\n@@ -2221,7 +2221,7 @@ cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) function.h $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) except.h langhooks.h tree-pass.h $(RTL_H) \\\n-   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H)\n+   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H) $(PARAMS_H)\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h toplev.h function.h except.h $(TM_P_H) insn-config.h $(EXPR_H) \\\n@@ -2675,7 +2675,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-chrec.h $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \\\n   $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \\\n-  $(out_file) \\\n+  $(srcdir)/targhooks.c $(out_file) \\\n   @all_gtfiles@\n \n GTFILES_FILES_LANGS = @all_gtfiles_files_langs@\n@@ -2696,7 +2696,7 @@ gt-tree-profile.h gt-tree-ssa-address.h \\\n gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \\\n-gt-stringpool.h : s-gtype ; @true\n+gt-stringpool.h gt-targhooks.h : s-gtype ; @true\n \n gtyp-gen.h: s-gtyp-gen ; @true\n s-gtyp-gen: Makefile"}, {"sha": "44c7a3797ddb0305c559249e6ad72f4c3eb1cdd0", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -440,6 +440,12 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (targetm.handle_pragma_extern_prefix)\n     cpp_define (pfile, \"__PRAGMA_EXTERN_PREFIX\");\n \n+  /* Make the choice of the stack protector runtime visible to source code.  */\n+  if (flag_stack_protect == 2)\n+    cpp_define (pfile, \"__SSP_ALL__=2\");\n+  else if (flag_stack_protect == 1)\n+    cpp_define (pfile, \"__SSP__=1\");\n+\n   /* A straightforward target hook doesn't work, because of problems\n      linking that hook's body when part of non-C front ends.  */\n # define preprocessing_asm_p() (cpp_get_options (pfile)->lang == CLK_ASM)"}, {"sha": "bb6ca4ac5622b80f83c72c6f53a1f6546e809e1d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 214, "deletions": 3, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -37,6 +37,8 @@ Boston, MA 02110-1301, USA.  */\n #include \"flags.h\"\n #include \"diagnostic.h\"\n #include \"toplev.h\"\n+#include \"params.h\"\n+\n \n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n@@ -137,6 +139,13 @@ static size_t stack_vars_conflict_alloc;\n    (frame_offset+frame_phase) % PREFERRED_STACK_BOUNDARY == 0.  */\n static int frame_phase;\n \n+/* Used during expand_used_vars to remember if we saw any decls for\n+   which we'd like to enable stack smashing protection.  */\n+static bool has_protected_decls;\n+\n+/* Used during expand_used_vars.  Remember if we say a character buffer\n+   smaller than our cutoff threshold.  Used for -Wstack-protector.  */\n+static bool has_short_buffer;\n \n /* Discover the byte alignment to use for DECL.  Ignore alignment\n    we can't do with expected alignment of the stack boundary.  */\n@@ -487,7 +496,7 @@ expand_one_stack_var_at (tree decl, HOST_WIDE_INT offset)\n    with that location.  */\n \n static void\n-expand_stack_vars (void)\n+expand_stack_vars (bool (*pred) (tree))\n {\n   size_t si, i, j, n = stack_vars_num;\n \n@@ -501,6 +510,16 @@ expand_stack_vars (void)\n       if (stack_vars[i].representative != i)\n \tcontinue;\n \n+      /* Skip variables that have already had rtl assigned.  See also\n+\t add_stack_var where we perpetrate this pc_rtx hack.  */\n+      if (DECL_RTL (stack_vars[i].decl) != pc_rtx)\n+\tcontinue;\n+\n+      /* Check the predicate to see whether this variable should be \n+\t allocated in this pass.  */\n+      if (pred && !pred (stack_vars[i].decl))\n+\tcontinue;\n+\n       offset = alloc_stack_frame_space (stack_vars[i].size,\n \t\t\t\t\tstack_vars[i].alignb);\n \n@@ -620,6 +639,11 @@ expand_one_error_var (tree var)\n static bool\n defer_stack_allocation (tree var, bool toplevel)\n {\n+  /* If stack protection is enabled, *all* stack variables must be deferred,\n+     so that we can re-order the strings to the top of the frame.  */\n+  if (flag_stack_protect)\n+    return true;\n+\n   /* Variables in the outermost scope automatically conflict with\n      every other variable.  The only reason to want to defer them\n      at all is that, after sorting, we can more efficiently pack\n@@ -725,6 +749,144 @@ clear_tree_used (tree block)\n     clear_tree_used (t);\n }\n \n+/* Examine TYPE and determine a bit mask of the following features.  */\n+\n+#define SPCT_HAS_LARGE_CHAR_ARRAY\t1\n+#define SPCT_HAS_SMALL_CHAR_ARRAY\t2\n+#define SPCT_HAS_ARRAY\t\t\t4\n+#define SPCT_HAS_AGGREGATE\t\t8\n+\n+static unsigned int\n+stack_protect_classify_type (tree type)\n+{\n+  unsigned int ret = 0;\n+  tree t;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case ARRAY_TYPE:\n+      t = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+      if (t == char_type_node\n+\t  || t == signed_char_type_node\n+\t  || t == unsigned_char_type_node)\n+\t{\n+\t  HOST_WIDE_INT max = PARAM_VALUE (PARAM_SSP_BUFFER_SIZE);\n+\t  HOST_WIDE_INT len;\n+\n+\t  if (!TYPE_DOMAIN (type)\n+\t      || !TYPE_MAX_VALUE (TYPE_DOMAIN (type))\n+\t      || !host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 1))\n+\t    len = max + 1;\n+\t  else\n+\t    len = tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 1);\n+\n+\t  if (len < max)\n+\t    ret = SPCT_HAS_SMALL_CHAR_ARRAY | SPCT_HAS_ARRAY;\n+\t  else\n+\t    ret = SPCT_HAS_LARGE_CHAR_ARRAY | SPCT_HAS_ARRAY;\n+\t}\n+      else\n+\tret = SPCT_HAS_ARRAY;\n+      break;\n+\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+    case RECORD_TYPE:\n+      ret = SPCT_HAS_AGGREGATE;\n+      for (t = TYPE_FIELDS (type); t ; t = TREE_CHAIN (t))\n+\tif (TREE_CODE (t) == FIELD_DECL)\n+\t  ret |= stack_protect_classify_type (TREE_TYPE (t));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Return non-zero if DECL should be segregated into the \"vulnerable\" upper\n+   part of the local stack frame.  Remember if we ever return non-zero for\n+   any variable in this function.  The return value is the phase number in\n+   which the variable should be allocated.  */\n+\n+static int\n+stack_protect_decl_phase (tree decl)\n+{\n+  unsigned int bits = stack_protect_classify_type (TREE_TYPE (decl));\n+  int ret = 0;\n+\n+  if (bits & SPCT_HAS_SMALL_CHAR_ARRAY)\n+    has_short_buffer = true;\n+\n+  if (flag_stack_protect == 2)\n+    {\n+      if ((bits & (SPCT_HAS_SMALL_CHAR_ARRAY | SPCT_HAS_LARGE_CHAR_ARRAY))\n+\t  && !(bits & SPCT_HAS_AGGREGATE))\n+\tret = 1;\n+      else if (bits & SPCT_HAS_ARRAY)\n+\tret = 2;\n+    }\n+  else\n+    ret = (bits & SPCT_HAS_LARGE_CHAR_ARRAY) != 0;\n+\n+  if (ret)\n+    has_protected_decls = true;\n+\n+  return ret;\n+}\n+\n+/* Two helper routines that check for phase 1 and phase 2.  These are used\n+   as callbacks for expand_stack_vars.  */\n+\n+static bool\n+stack_protect_decl_phase_1 (tree decl)\n+{\n+  return stack_protect_decl_phase (decl) == 1;\n+}\n+\n+static bool\n+stack_protect_decl_phase_2 (tree decl)\n+{\n+  return stack_protect_decl_phase (decl) == 2;\n+}\n+\n+/* Ensure that variables in different stack protection phases conflict\n+   so that they are not merged and share the same stack slot.  */\n+\n+static void\n+add_stack_protection_conflicts (void)\n+{\n+  size_t i, j, n = stack_vars_num;\n+  unsigned char *phase;\n+\n+  phase = XNEWVEC (unsigned char, n);\n+  for (i = 0; i < n; ++i)\n+    phase[i] = stack_protect_decl_phase (stack_vars[i].decl);\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      unsigned char ph_i = phase[i];\n+      for (j = 0; j < i; ++j)\n+\tif (ph_i != phase[j])\n+\t  add_stack_var_conflict (i, j);\n+    }\n+\n+  XDELETEVEC (phase);\n+}\n+\n+/* Create a decl for the guard at the top of the stack frame.  */\n+\n+static void\n+create_stack_guard (void)\n+{\n+  tree guard = build_decl (VAR_DECL, NULL, ptr_type_node);\n+  TREE_THIS_VOLATILE (guard) = 1;\n+  TREE_USED (guard) = 1;\n+  expand_one_stack_var (guard);\n+  cfun->stack_protect_guard = guard;\n+}\n+\n /* Expand all variables used in the function.  */\n \n static void\n@@ -746,6 +908,10 @@ expand_used_vars (void)\n   /* Clear TREE_USED on all variables associated with a block scope.  */\n   clear_tree_used (outer_block);\n \n+  /* Initialize local stack smashing state.  */\n+  has_protected_decls = false;\n+  has_short_buffer = false;\n+\n   /* At this point all variables on the unexpanded_var_list with TREE_USED\n      set are not associated with any block scope.  Lay them out.  */\n   for (t = cfun->unexpanded_var_list; t; t = TREE_CHAIN (t))\n@@ -794,14 +960,44 @@ expand_used_vars (void)\n \t reflect this.  */\n       add_alias_set_conflicts ();\n \n+      /* If stack protection is enabled, we don't share space between \n+\t vulnerable data and non-vulnerable data.  */\n+      if (flag_stack_protect)\n+\tadd_stack_protection_conflicts ();\n+\n       /* Now that we have collected all stack variables, and have computed a \n \t minimal interference graph, attempt to save some stack space.  */\n       partition_stack_vars ();\n       if (dump_file)\n \tdump_stack_var_partition ();\n+    }\n+\n+  /* There are several conditions under which we should create a\n+     stack guard: protect-all, alloca used, protected decls present.  */\n+  if (flag_stack_protect == 2\n+      || (flag_stack_protect\n+\t  && (current_function_calls_alloca || has_protected_decls)))\n+    create_stack_guard ();\n \n-      /* Assign rtl to each variable based on these partitions.  */\n-      expand_stack_vars ();\n+  /* Assign rtl to each variable based on these partitions.  */\n+  if (stack_vars_num > 0)\n+    {\n+      /* Reorder decls to be protected by iterating over the variables\n+\t array multiple times, and allocating out of each phase in turn.  */\n+      /* ??? We could probably integrate this into the qsort we did \n+\t earlier, such that we naturally see these variables first,\n+\t and thus naturally allocate things in the right order.  */\n+      if (has_protected_decls)\n+\t{\n+\t  /* Phase 1 contains only character arrays.  */\n+\t  expand_stack_vars (stack_protect_decl_phase_1);\n+\n+\t  /* Phase 2 contains other kinds of arrays.  */\n+\t  if (flag_stack_protect == 2)\n+\t    expand_stack_vars (stack_protect_decl_phase_2);\n+\t}\n+\n+      expand_stack_vars (NULL);\n \n       /* Free up stack variable graph data.  */\n       XDELETEVEC (stack_vars);\n@@ -1288,6 +1484,16 @@ tree_expand_cfg (void)\n   /* Expand the variables recorded during gimple lowering.  */\n   expand_used_vars ();\n \n+  /* Honor stack protection warnings.  */\n+  if (warn_stack_protect)\n+    {\n+      if (current_function_calls_alloca)\n+\twarning (0, \"not protecting local variables: variable length buffer\");\n+      if (has_short_buffer && !cfun->stack_protect_guard)\n+\twarning (0, \"not protecting function: no buffer at least %d bytes long\",\n+\t\t (int) PARAM_VALUE (PARAM_SSP_BUFFER_SIZE));\n+    }\n+\n   /* Set up parameters and prepare for return, for the function.  */\n   expand_function_start (current_function_decl);\n \n@@ -1298,6 +1504,11 @@ tree_expand_cfg (void)\n       && DECL_FILE_SCOPE_P (current_function_decl))\n     expand_main_function ();\n \n+  /* Initialize the stack_protect_guard field.  This must happen after the\n+     call to __main (if any) so that the external decl is initialized.  */\n+  if (cfun->stack_protect_guard)\n+    stack_protect_prologue ();\n+\n   /* Register rtl specific functions for cfg.  */\n   rtl_register_cfg_hooks ();\n "}, {"sha": "4d097c78fc33e490a028ca198bc2aa0832cd3100", "filename": "gcc/common.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -109,6 +109,10 @@ Wshadow\n Common Var(warn_shadow)\n Warn when one local variable shadows another\n \n+Wstack-protector\n+Common Var(warn_stack_protect)\n+Warn when not issuing stack smashing protection for some reason\n+\n Wstrict-aliasing\n Common\n Warn about code which might break strict aliasing rules\n@@ -784,6 +788,14 @@ fstack-limit-symbol=\n Common RejectNegative Joined\n -fstack-limit-symbol=<name>\tTrap if the stack goes past symbol <name>\n \n+fstack-protector\n+Common Report Var(flag_stack_protect, 1)\n+Use propolice as a stack protection method\n+\n+fstack-protector-all\n+Common Report RejectNegative Var(flag_stack_protect, 2) VarExists\n+Use a stack protection method for every function\n+\n fstrength-reduce\n Common Report Var(flag_strength_reduce)\n Perform strength reduction optimizations"}, {"sha": "0f487c47f921be62beb3a359a3e0214ee76117c8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -1081,6 +1081,9 @@ static void init_ext_80387_constants (void);\n #undef TARGET_MANGLE_FUNDAMENTAL_TYPE\n #define TARGET_MANGLE_FUNDAMENTAL_TYPE ix86_mangle_fundamental_type\n \n+#undef TARGET_STACK_PROTECT_FAIL\n+#define TARGET_STACK_PROTECT_FAIL default_hidden_stack_protect_fail\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "8aaad7b817dd702128747c74a52b7b7db52935cd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 77, "deletions": 45, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -81,6 +81,8 @@\n    (UNSPEC_FLDCW\t\t25)\n    (UNSPEC_REP\t\t\t26)\n    (UNSPEC_EH_RETURN\t\t27)\n+   (UNSPEC_SP_SET\t\t28)\n+   (UNSPEC_SP_TEST\t\t29)\n \n    ; For SSE/MMX support:\n    (UNSPEC_FIX_NOTRUNC\t\t30)\n@@ -19436,53 +19438,16 @@\n   \"jmp\\t*%%r11\"\n   [(set_attr \"type\" \"callv\")])\n \f\n+;; We used to use \"int $5\", in honor of #BR which maps to interrupt vector 5.\n+;; That, however, is usually mapped by the OS to SIGSEGV, which is often \n+;; caught for use by garbage collectors and the like.  Using an insn that\n+;; maps to SIGILL makes it more likely the program will rightfully die.\n+;; Keeping with tradition, \"6\" is in honor of #UD.\n (define_insn \"trap\"\n-  [(trap_if (const_int 1) (const_int 5))]\n+  [(trap_if (const_int 1) (const_int 6))]\n   \"\"\n-  \"int\\t$5\")\n-\n-;;; ix86 doesn't have conditional trap instructions, but we fake them\n-;;; for the sake of bounds checking.  By emitting bounds checks as\n-;;; conditional traps rather than as conditional jumps around\n-;;; unconditional traps we avoid introducing spurious basic-block\n-;;; boundaries and facilitate elimination of redundant checks.  In\n-;;; honor of the too-inflexible-for-BPs `bound' instruction, we use\n-;;; interrupt 5.\n-;;; \n-;;; FIXME: Static branch prediction rules for ix86 are such that\n-;;; forward conditional branches predict as untaken.  As implemented\n-;;; below, pseudo conditional traps violate that rule.  We should use\n-;;; .pushsection/.popsection to place all of the `int 5's in a special\n-;;; section loaded at the end of the text segment and branch forward\n-;;; there on bounds-failure, and then jump back immediately (in case\n-;;; the system chooses to ignore bounds violations, or to report\n-;;; violations and continue execution).\n-\n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(match_dup 2) (const_int 0)])\n-\t    (match_operand 1 \"const_int_operand\" \"\"))]\n-  \"\"\n-{\n-  emit_insn (gen_rtx_TRAP_IF (VOIDmode,\n-\t\t\t      ix86_expand_compare (GET_CODE (operands[0]),\n-\t\t\t\t\t\t   NULL, NULL),\n-\t\t\t      operands[1]));\n-  DONE;\n-})\n-\n-(define_insn \"*conditional_trap_1\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(reg FLAGS_REG) (const_int 0)])\n-\t    (match_operand 1 \"const_int_operand\" \"\"))]\n-  \"\"\n-{\n-  operands[2] = gen_label_rtx ();\n-  output_asm_insn (\"j%c0\\t%l2\\; int\\t%1\", operands);\n-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t     CODE_LABEL_NUMBER (operands[2]));\n-  RET;\n-})\n+  \"ud2\"\n+  [(set_attr \"length\" \"2\")])\n \n (define_expand \"sse_prologue_save\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n@@ -19633,6 +19598,73 @@\n   [(set_attr \"type\" \"mmx\")\n    (set_attr \"memory\" \"none\")])\n \n+(define_expand \"stack_protect_set\"\n+  [(match_operand 0 \"memory_operand\" \"\")\n+   (match_operand 1 \"memory_operand\" \"\")]\n+  \"\"\n+{\n+  if (TARGET_64BIT)\n+    emit_insn (gen_stack_protect_set_di (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_stack_protect_set_si (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"stack_protect_set_si\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+   (clobber (match_scratch:SI 2 \"=r\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"mov{l}\\t{%1, %2|%2, %1}\\;mov{l}\\t{%2, %0|%0, %2}\\;xor{l}\\t%2, %2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"stack_protect_set_di\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+   (clobber (match_scratch:DI 2 \"=r\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  \"mov{q}\\t{%1, %2|%2, %1}\\;mov{q}\\t{%2, %0|%0, %2}\\;xor{l}\\t%2, %2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_expand \"stack_protect_test\"\n+  [(match_operand 0 \"memory_operand\" \"\")\n+   (match_operand 1 \"memory_operand\" \"\")]\n+  \"\"\n+{\n+  rtx flags = gen_rtx_REG (CCZmode, FLAGS_REG);\n+  ix86_compare_op0 = operands[0];\n+  ix86_compare_op1 = operands[1];\n+  ix86_compare_emitted = flags;\n+\n+  if (TARGET_64BIT)\n+    emit_insn (gen_stack_protect_test_di (flags, operands[0], operands[1]));\n+  else\n+    emit_insn (gen_stack_protect_test_si (flags, operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"stack_protect_test_si\"\n+  [(set (match_operand:CCZ 0 \"flags_reg_operand\" \"\")\n+\t(unspec:CCZ [(match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (match_operand:SI 2 \"memory_operand\" \"m\")]\n+\t\t    UNSPEC_SP_TEST))\n+   (clobber (match_scratch:SI 3 \"=r\"))]\n+  \"\"\n+  \"mov{l}\\t{%1, %3|%3, %1}\\;xor{l}\\t{%2, %3|%3, %2}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"stack_protect_test_di\"\n+  [(set (match_operand:CCZ 0 \"flags_reg_operand\" \"\")\n+\t(unspec:CCZ [(match_operand:DI 1 \"memory_operand\" \"m\")\n+\t\t     (match_operand:DI 2 \"memory_operand\" \"m\")]\n+\t\t    UNSPEC_SP_TEST))\n+   (clobber (match_scratch:DI 3 \"=r\"))]\n+  \"TARGET_64BIT\"\n+  \"mov{q}\\t{%1, %3|%3, %1}\\;xor{q}\\t{%2, %3|%3, %2}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n (include \"sse.md\")\n (include \"mmx.md\")\n (include \"sync.md\")"}, {"sha": "ed07a2fd88c360ba05bbf18cb167569327df6745", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -4094,6 +4094,30 @@ released only after all previous memory operations have completed.\n If this pattern is not defined, then a @code{memory_barrier} pattern\n will be emitted, followed by a store of the value to the memory operand.\n \n+@cindex @code{stack_protect_set} instruction pattern\n+@item @samp{stack_protect_set}\n+\n+This pattern, if defined, moves a @code{Pmode} value from the memory\n+in operand 1 to the memory in operand 0 without leaving the value in\n+a register afterward.  This is to avoid leaking the value some place\n+that an attacker might use to rewrite the stack guard slot after \n+having clobbered it.\n+\n+If this pattern is not defined, then a plain move pattern is generated.\n+\n+@cindex @code{stack_protect_test} instruction pattern\n+@item @samp{stack_protect_test}\n+\n+This pattern, if defined, compares a @code{Pmode} value from the\n+memory in operand 1 with the memory in operand 0 without leaving the\n+value in a register afterward.  Further, it initializes the data\n+structures in the target as if the normal @code{cmp@var{mode}} \n+pattern had been emitted.  If the pattern does not @code{FAIL}, then\n+the rtl expanders will be invoking either the @code{beq} or @code{bne}\n+pattern to make use of the comparison.\n+\n+If this pattern is not defined, then a plain compare pattern is used.\n+\n @end table\n \n @end ifset"}, {"sha": "cd2bf87a032c03d468e0040a584c1ee0bc2ed62c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -2716,6 +2716,7 @@ This describes the stack layout and calling conventions.\n * Function Entry::\n * Profiling::\n * Tail Calls::\n+* Stack Smashing Protection::\n @end menu\n \n @node Frame Layout\n@@ -4379,6 +4380,31 @@ as the @code{sibcall} md pattern can not fail, or fall over to a\n may vary greatly between different architectures.\n @end deftypefn\n \n+@node Stack Smashing Protection\n+@subsection Stack smashing protection\n+@cindex stack smashing protection\n+\n+@deftypefn {Target Hook} tree TARGET_STACK_PROTECT_GUARD (void)\n+This hook returns a @code{DECL} node for the external variable to use\n+for the stack protection guard.  This variable is initialized by the \n+runtime to some random value and is used to initialize the guard value\n+that is placed at the top of the local stack frame.  The type of this\n+variable must be @code{ptr_type_node}.\n+\n+The default version of this hook creates a variable called\n+@samp{__stack_chk_guard}, which is normally defined in @file{libgcc2.c}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_STACK_PROTECT_FAIL (void)\n+This hook returns a tree expression that alerts the runtime that the\n+stack protect guard variable has been modified.  This expression should\n+involve a call to a @code{noreturn} function.\n+\n+The default version of this hook invokes a function called\n+@samp{__stack_chk_fail}, taking no arguments.  This function is \n+normally defined in @file{libgcc2.c}.\n+@end deftypefn\n+\n @node Varargs\n @section Implementing the Varargs Macros\n @cindex varargs implementation"}, {"sha": "7ab698bd9858618469d19ee53e6b5c557dc422cc", "filename": "gcc/function.c", "status": "modified", "additions": 110, "deletions": 5, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -61,6 +61,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n+#include \"predict.h\"\n+\n \n #ifndef LOCAL_ALIGNMENT\n #define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n@@ -2334,6 +2336,14 @@ assign_parm_adjust_stack_rtl (struct assign_parm_data_one *data)\n \t   && data->nominal_mode != data->passed_mode)\n     stack_parm = NULL;\n \n+  /* If stack protection is in effect for this function, don't leave any\n+     pointers in their passed stack slots.  */\n+  else if (cfun->stack_protect_guard\n+\t   && (flag_stack_protect == 2\n+\t       || data->passed_pointer\n+\t       || POINTER_TYPE_P (data->nominal_type)))\n+    stack_parm = NULL;\n+\n   data->stack_parm = stack_parm;\n }\n \n@@ -3921,6 +3931,97 @@ expand_main_function (void)\n #endif\n }\n \f\n+/* Expand code to initialize the stack_protect_guard.  This is invoked at\n+   the beginning of a function to be protected.  */\n+\n+#ifndef HAVE_stack_protect_set\n+# define HAVE_stack_protect_set\t\t0\n+# define gen_stack_protect_set(x,y)\t(gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+void\n+stack_protect_prologue (void)\n+{\n+  tree guard_decl = targetm.stack_protect_guard ();\n+  rtx x, y;\n+\n+  /* Avoid expand_expr here, because we don't want guard_decl pulled\n+     into registers unless absolutely necessary.  And we know that\n+     cfun->stack_protect_guard is a local stack slot, so this skips\n+     all the fluff.  */\n+  x = validize_mem (DECL_RTL (cfun->stack_protect_guard));\n+  y = validize_mem (DECL_RTL (guard_decl));\n+\n+  /* Allow the target to copy from Y to X without leaking Y into a\n+     register.  */\n+  if (HAVE_stack_protect_set)\n+    {\n+      rtx insn = gen_stack_protect_set (x, y);\n+      if (insn)\n+\t{\n+\t  emit_insn (insn);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Otherwise do a straight move.  */\n+  emit_move_insn (x, y);\n+}\n+\n+/* Expand code to verify the stack_protect_guard.  This is invoked at\n+   the end of a function to be protected.  */\n+\n+#ifndef HAVE_stack_protect_test\n+# define HAVE_stack_protect_test\t0\n+# define gen_stack_protect_test(x, y)\t(gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+static void\n+stack_protect_epilogue (void)\n+{\n+  tree guard_decl = targetm.stack_protect_guard ();\n+  rtx label = gen_label_rtx ();\n+  rtx x, y, tmp;\n+\n+  /* Avoid expand_expr here, because we don't want guard_decl pulled\n+     into registers unless absolutely necessary.  And we know that\n+     cfun->stack_protect_guard is a local stack slot, so this skips\n+     all the fluff.  */\n+  x = validize_mem (DECL_RTL (cfun->stack_protect_guard));\n+  y = validize_mem (DECL_RTL (guard_decl));\n+\n+  /* Allow the target to compare Y with X without leaking either into\n+     a register.  */\n+  switch (HAVE_stack_protect_test != 0)\n+    {\n+    case 1:\n+      tmp = gen_stack_protect_test (x, y);\n+      if (tmp)\n+\t{\n+\t  emit_insn (tmp);\n+\t  emit_jump_insn (bcc_gen_fctn[EQ] (label));\n+\t  break;\n+\t}\n+      /* FALLTHRU */\n+\n+    default:\n+      emit_cmp_and_jump_insns (x, y, EQ, NULL_RTX, ptr_mode, 1, label);\n+      break;\n+    }\n+\n+  /* The noreturn predictor has been moved to the tree level.  The rtl-level\n+     predictors estimate this branch about 20%, which isn't enough to get\n+     things moved out of line.  Since this is the only extant case of adding\n+     a noreturn function at the rtl level, it doesn't seem worth doing ought\n+     except adding the prediction by hand.  */\n+  tmp = get_last_insn ();\n+  if (JUMP_P (tmp))\n+    predict_insn_def (tmp, PRED_NORETURN, TAKEN);\n+\n+  expand_expr_stmt (targetm.stack_protect_fail ());\n+  emit_label (label);\n+}\n+\f\n /* Start the RTL for a new function, and set variables used for\n    emitting RTL.\n    SUBR is the FUNCTION_DECL node.\n@@ -4267,11 +4368,6 @@ expand_function_end (void)\n   /* Output the label for the actual return from the function.  */\n   emit_label (return_label);\n \n-  /* Let except.c know where it should emit the call to unregister\n-     the function context for sjlj exceptions.  */\n-  if (flag_exceptions && USING_SJLJ_EXCEPTIONS)\n-    sjlj_emit_function_exit_after (get_last_insn ());\n-\n   /* If scalar return value was computed in a pseudo-reg, or was a named\n      return value that got dumped to the stack, copy that to the hard\n      return register.  */\n@@ -4399,6 +4495,15 @@ expand_function_end (void)\n   /* Output the label for the naked return from the function.  */\n   emit_label (naked_return_label);\n \n+  /* Let except.c know where it should emit the call to unregister\n+     the function context for sjlj exceptions.  */\n+  if (flag_exceptions && USING_SJLJ_EXCEPTIONS)\n+    sjlj_emit_function_exit_after (get_last_insn ());\n+\n+  /* If stack protection is enabled for this function, check the guard.  */\n+  if (cfun->stack_protect_guard)\n+    stack_protect_epilogue ();\n+\n   /* If we had calls to alloca, and this machine needs\n      an accurate stack pointer to exit the function,\n      insert some code to save and restore the stack pointer.  */"}, {"sha": "2d59d235141f2c4166a9c64a3e8ee0024d512010", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -368,6 +368,10 @@ struct function GTY(())\n \n   const char *unlikely_text_section_name;\n \n+  /* A variable living at the top of the frame that holds a known value.\n+     Used for detecting stack clobbers.  */\n+  tree stack_protect_guard;\n+\n   /* Collected bit flags.  */\n \n   /* Nonzero if function being compiled needs to be given an address"}, {"sha": "d6c182130a7a769bbf52c0f4766aaf7603448ea7", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -252,3 +252,10 @@ GCC_4.0.0 {\n   __mulxc3\n   __multc3\n }\n+\n+%inherit GCC_4.1.0 GCC_4.0.0\n+GCC_4.1.0 {\n+  # stack smash handler symbols\n+  __stack_chk_guard\n+  __stack_chk_fail\n+}"}, {"sha": "a49c8c128f9d581211affbf8a5e5358a4ae2a2d2", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -2015,3 +2015,141 @@ func_ptr __DTOR_LIST__[2];\n #endif\n #endif /* no INIT_SECTION_ASM_OP and not CTOR_LISTS_DEFINED_EXTERNALLY */\n #endif /* L_ctors */\n+\f\n+#ifdef L_stack_chk\n+#ifndef TARGET_LIBC_PROVIDES_SSP\n+\n+#ifndef inhibit_libc\n+# include <string.h>\n+# include <unistd.h>\n+# include <fcntl.h>\n+# ifdef HAVE_PATHS_H\n+#  include <paths.h>\n+# endif\n+# ifndef _PATH_TTY\n+#  define _PATH_TTY \"/dev/tty\"\n+# endif\n+# ifdef HAVE_SYSLOG_H\n+#  include <syslog.h>\n+# endif\n+#endif\n+\n+void *__stack_chk_guard = 0;\n+\n+static void __attribute__ ((constructor))\n+__guard_setup (void)\n+{\n+  unsigned char *p;\n+\n+  if (__stack_chk_guard != 0)\n+    return;\n+\n+#ifndef inhibit_libc\n+  {\n+    int fd = open (\"/dev/urandom\", O_RDONLY);\n+    if (fd != -1)\n+      {\n+\tssize_t size = read (fd, &__stack_chk_guard,\n+\t\t\t     sizeof (__stack_chk_guard));\n+\tclose (fd);\n+\tif (size == sizeof(__stack_chk_guard))\n+\t  return;\n+      }\n+  }\n+#endif\n+\n+  /* If a random generator can't be used, the protector switches the guard\n+     to the \"terminator canary\".  */\n+  p = (unsigned char *)&__stack_chk_guard;\n+  p[sizeof(__stack_chk_guard)-1] = 255;\n+  p[sizeof(__stack_chk_guard)-2] = '\\n';\n+  p[0] = 0;\n+}\n+\n+void\n+__stack_chk_fail (void)\n+{\n+#ifndef inhibit_libc\n+# ifdef __GNU_LIBRARY__\n+  extern char * __progname;\n+# else\n+  static const char __progname[] = \"\";\n+# endif\n+\n+  int fd;\n+\n+  /* Print error message directly to the tty.  This avoids Bad Things\n+     happening if stderr is redirected.  */\n+  fd = open (_PATH_TTY, O_WRONLY);\n+  if (fd != -1)\n+    {\n+      static const char msg1[] = \"*** stack smashing detected ***: \";\n+      static const char msg2[] = \" terminated\\n\";\n+      size_t progname_len, len;\n+      char *buf, *p;\n+\n+      progname_len = strlen (__progname);\n+      len = sizeof(msg1)-1 + progname_len + sizeof(msg2)-1 + 1;\n+      p = buf = alloca (len);\n+\n+      memcpy (p, msg1, sizeof(msg1)-1);\n+      p += sizeof(msg1)-1;\n+      memcpy (p, __progname, progname_len);\n+      p += progname_len;\n+      memcpy (p, msg2, sizeof(msg2));\n+\n+      while (len > 0)\n+\t{\n+\t  ssize_t wrote = write (fd, buf, len);\n+\t  if (wrote < 0)\n+\t    break;\n+\t  len -= wrote;\n+\t}\n+      close (fd);\n+    }\n+\n+# ifdef HAVE_SYSLOG_H\n+  /* Only send the error to syslog if there was no tty available.  */\n+  else\n+    syslog (LOG_CRIT, \"stack smashing detected: terminated\");\n+# endif /* HAVE_SYSLOG_H */\n+#endif /* inhibit_libc */\n+\n+  /* Try very hard to exit.  Note that signals may be blocked preventing\n+     the first two options from working.  The use of volatile is here to\n+     prevent optimizers from \"knowing\" that __builtin_trap is called first,\n+     and that it doesn't return, and so \"obviously\" the rest of the code\n+     is dead.  */\n+  {\n+    volatile int state;\n+    for (state = 0; ; state++)\n+      switch (state)\n+\t{\n+\tcase 0:\n+\t  __builtin_trap ();\n+\t  break;\n+\tcase 1:\n+\t  *(volatile int *)-1L = 0;\n+\t  break;\n+\tcase 2:\n+\t  _exit (127);\n+\t  break;\n+\t}\n+  }\n+}\n+#endif /* TARGET_LIBC_PROVIDES_SSP */\n+#endif /* L_stack_chk */\n+\f\n+#ifdef L_stack_chk_local\n+#ifndef TARGET_LIBC_PROVIDES_SSP\n+/* Some targets can avoid loading a GP for calls to hidden functions.\n+   Using this entry point may avoid the load of a GP entirely for the\n+   function, making the overall code smaller.  */\n+\n+void\n+__stack_chk_fail_local (void)\n+{\n+  __stack_chk_fail ();\n+}\n+#endif /* TARGET_LIBC_PROVIDES_SSP */\n+#endif /* L_stack_chk_local */"}, {"sha": "cd1e47e11377b30d2b0919ab12c01d3601902d88", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -390,6 +390,11 @@ extern int __parityDI2 (UDWtype);\n \n extern void __enable_execute_stack (void *);\n \n+extern void *__stack_chk_guard;\n+extern void __stack_chk_fail (void) __attribute__ ((__noreturn__));\n+extern void __stack_chk_fail_local (void)\n+\t__attribute__ ((__noreturn__)) ATTRIBUTE_HIDDEN;\n+\n #ifndef HIDE_EXPORTS\n #pragma GCC visibility pop\n #endif"}, {"sha": "d2581d55b1e9f8922cfbed9f13eec2a6c40fabbe", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -63,7 +63,7 @@ lib2funcs='_muldi3 _negdi2 _lshrdi3 _ashldi3 _ashrdi3\n \t_ffssi2 _ffsdi2 _clz _clzsi2 _clzdi2 _ctzsi2 _ctzdi2 _popcount_tab\n \t_popcountsi2 _popcountdi2 _paritysi2 _paritydi2 _powisf2 _powidf2\n \t_powixf2 _powitf2 _mulsc3 _muldc3 _mulxc3 _multc3 _divsc3 _divdc3\n-\t_divxc3 _divtc3'\n+\t_divxc3 _divtc3 _stack_chk _stack_chk_local'\n \n # Disable SHLIB_LINK if shared libgcc not enabled.\n if [ \"@enable_shared@\" = \"no\" ]; then"}, {"sha": "0948c40d0c540321936229f129c8c5d9efea8266", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -467,6 +467,11 @@ DEFPARAM (PARAM_VIRTUAL_MAPPINGS_TO_SYMS_RATIO,\n \t  \"Ratio between virtual mappings and virtual symbols to do full virtual renames\",\n \t  3, 0, 0)\n \n+DEFPARAM (PARAM_SSP_BUFFER_SIZE,\n+\t  \"ssp-buffer-size\",\n+\t  \"The lower bound for a buffer to be considered for stack smashing protection\",\n+\t  8, 1, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "cdaf3d368ae1e331bca97b9bceaf5cb423f7a021", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -398,6 +398,9 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n \n #define TARGET_STDARG_OPTIMIZE_HOOK 0\n \n+#define TARGET_STACK_PROTECT_GUARD  default_stack_protect_guard\n+#define TARGET_STACK_PROTECT_FAIL   default_external_stack_protect_fail\n+\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_false\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_false\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_false\n@@ -564,6 +567,8 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_DWARF_CALLING_CONVENTION,              \\\n   TARGET_DWARF_HANDLE_FRAME_UNSPEC,\t\t\\\n   TARGET_STDARG_OPTIMIZE_HOOK,\t\t\t\\\n+  TARGET_STACK_PROTECT_GUARD,\t\t\t\\\n+  TARGET_STACK_PROTECT_FAIL,\t\t\t\\\n   TARGET_INVALID_WITHIN_DOLOOP,\t\t\t\\\n   TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\"}, {"sha": "87e644b02acf4fdb2cc65e6323a91f7c39e16f19", "filename": "gcc/target.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -526,7 +526,16 @@ struct gcc_target\n      from VA_ARG_EXPR.  LHS is left hand side of MODIFY_EXPR, RHS\n      is right hand side.  Returns true if the statements doesn't need\n      to be checked for va_list references.  */\n-  bool (*stdarg_optimize_hook) (struct stdarg_info *ai, tree lhs, tree rhs);\n+  bool (* stdarg_optimize_hook) (struct stdarg_info *ai, tree lhs, tree rhs);\n+\n+  /* This target hook allows the operating system to override the DECL\n+     that represents the external variable that contains the stack\n+     protection guard variable.  The type of this DECL is ptr_type_node.  */\n+  tree (* stack_protect_guard) (void);\n+\n+  /* This target hook allows the operating system to override the CALL_EXPR\n+     that is invoked when a check vs the guard variable fails.  */\n+  tree (* stack_protect_fail) (void);\n \n   /* Returns NULL if target supports the insn within a doloop block,\n      otherwise it returns an error message.  */"}, {"sha": "ec374c6593a51e3ad327ca2c2dc10bcc428ce3ae", "filename": "gcc/targhooks.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -61,6 +61,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"tm_p.h\"\n #include \"target-def.h\"\n+#include \"ggc.h\"\n \n \n void\n@@ -321,3 +322,86 @@ hook_invalid_arg_for_unprototyped_fn (\n {\n   return NULL;\n }\n+\n+/* Initialize the stack protection decls.  */\n+\n+/* Stack protection related decls living in libgcc.  */\n+static GTY(()) tree stack_chk_guard_decl;\n+\n+tree\n+default_stack_protect_guard (void)\n+{\n+  tree t = stack_chk_guard_decl;\n+\n+  if (t == NULL)\n+    {\n+      t = build_decl (VAR_DECL, get_identifier (\"__stack_chk_guard\"),\n+\t\t      ptr_type_node);\n+      TREE_STATIC (t) = 1;\n+      TREE_PUBLIC (t) = 1;\n+      DECL_EXTERNAL (t) = 1;\n+      TREE_USED (t) = 1;\n+      TREE_THIS_VOLATILE (t) = 1;\n+      DECL_ARTIFICIAL (t) = 1;\n+      DECL_IGNORED_P (t) = 1;\n+\n+      stack_chk_guard_decl = t;\n+    }\n+\n+  return t;\n+}\n+\n+static GTY(()) tree stack_chk_fail_decl;\n+\n+tree \n+default_external_stack_protect_fail (void)\n+{\n+  tree t = stack_chk_fail_decl;\n+\n+  if (t == NULL_TREE)\n+    {\n+      t = build_function_type_list (void_type_node, NULL_TREE);\n+      t = build_decl (FUNCTION_DECL, get_identifier (\"__stack_chk_fail\"), t);\n+      TREE_STATIC (t) = 1;\n+      TREE_PUBLIC (t) = 1;\n+      DECL_EXTERNAL (t) = 1;\n+      TREE_USED (t) = 1;\n+      TREE_THIS_VOLATILE (t) = 1;\n+      TREE_NOTHROW (t) = 1;\n+      DECL_ARTIFICIAL (t) = 1;\n+      DECL_IGNORED_P (t) = 1;\n+\n+      stack_chk_fail_decl = t;\n+    }\n+\n+  return build_function_call_expr (t, NULL_TREE);\n+}\n+\n+tree\n+default_hidden_stack_protect_fail (void)\n+{\n+  tree t = stack_chk_fail_decl;\n+\n+  if (stack_chk_fail_decl == NULL_TREE)\n+    {\n+      t = build_function_type_list (void_type_node, NULL_TREE);\n+      t = build_decl (FUNCTION_DECL,\n+\t\t      get_identifier (\"__stack_chk_fail_local\"), t);\n+      TREE_STATIC (t) = 1;\n+      TREE_PUBLIC (t) = 1;\n+      DECL_EXTERNAL (t) = 1;\n+      TREE_USED (t) = 1;\n+      TREE_THIS_VOLATILE (t) = 1;\n+      TREE_NOTHROW (t) = 1;\n+      DECL_ARTIFICIAL (t) = 1;\n+      DECL_IGNORED_P (t) = 1;\n+      DECL_VISIBILITY_SPECIFIED (t) = 1;\n+      DECL_VISIBILITY (t) = VISIBILITY_HIDDEN;\n+\n+      stack_chk_fail_decl = t;\n+    }\n+\n+  return build_function_call_expr (t, NULL_TREE);\n+}\n+\n+#include \"gt-targhooks.h\""}, {"sha": "80c49c8764b27a399f8fb2cc60532ac13434c5b8", "filename": "gcc/targhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -34,6 +34,10 @@ extern enum machine_mode default_eh_return_filter_mode (void);\n extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n   (enum machine_mode);\n \n+extern tree default_stack_protect_guard (void);\n+extern tree default_external_stack_protect_fail (void);\n+extern tree default_hidden_stack_protect_fail (void);\n+\n extern tree default_cxx_guard_type (void);\n extern tree default_cxx_get_cookie_size (tree);\n "}, {"sha": "495e104dd6a4882b6d12cf9b3dcc0d2ad0f8ec49", "filename": "gcc/toplev.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -1747,6 +1747,18 @@ process_options (void)\n   /* With -fcx-limited-range, we do cheap and quick complex arithmetic.  */\n   if (flag_cx_limited_range)\n     flag_complex_method = 0;\n+\n+#ifndef FRAME_GROWS_DOWNWARD\n+  /* Targets must be able to place spill slots at lower addresses.  If the\n+     target already uses a soft frame pointer, the transition is trivial.  */\n+  if (flag_stack_protect)\n+    {\n+      warning (0, \"-fstack-protector not supported for this target\");\n+      flag_stack_protect = 0;\n+    }\n+#endif\n+  if (!flag_stack_protect)\n+    warn_stack_protect = 0;\n }\n \n /* Initialize the compiler back end.  */"}, {"sha": "1c0a4be2fcb9f24c8669fed5ac1548a27ffbb4b7", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d69de618e732d343228a07d797a30e39a6363f4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7d69de618e732d343228a07d797a30e39a6363f4", "patch": "@@ -3659,6 +3659,7 @@ extern int simple_cst_list_equal (tree, tree);\n extern void dump_tree_statistics (void);\n extern void expand_function_end (void);\n extern void expand_function_start (tree);\n+extern void stack_protect_prologue (void);\n extern void recompute_tree_invarant_for_addr_expr (tree);\n extern bool is_global_var (tree t);\n extern bool needs_to_live_in_memory (tree);"}]}