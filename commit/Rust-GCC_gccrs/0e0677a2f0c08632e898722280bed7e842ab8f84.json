{"sha": "0e0677a2f0c08632e898722280bed7e842ab8f84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwNjc3YTJmMGMwODYzMmU4OTg3MjIyODBiZWQ3ZTg0MmFiOGY4NA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-08-06T14:20:09Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-08-06T14:20:09Z"}, "message": "In libobjc/: 2011-08-06 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/50002\n\t* class.c (__objc_update_classes_with_methods): Iterate over meta\n\tclasses as well as normal classes when refreshing the method\n\timplementations.  This fixes replacing class methods.\n\n2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* class.c (class_getSuperclass): Fixed to work with meta classes\n\tstill in construction too.\n\nIn gcc/testsuite/:\n2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/50002\n\t* objc.dg/gnu-api-2-class.m: Updated comments.\n\t* obj-c++.dg/gnu-api-2-class.mm: Likewise.\n\t* objc.dg/gnu-api-2-class-meta.m: New test.\n\t* obj-c++.dg/gnu-api-2-class-meta.mm: Likewise.\n\t\n2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n\t\n\tPR libobjc/49882\n\t* obj-c++.dg/gnu-api-2-class.mm (main): Test class_getSuperclass()\n\twith classes that are in construction.\n\nFrom-SVN: r177510", "tree": {"sha": "2eebcd872b6090c0533651d1c56a014d20130d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eebcd872b6090c0533651d1c56a014d20130d9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e0677a2f0c08632e898722280bed7e842ab8f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0677a2f0c08632e898722280bed7e842ab8f84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e0677a2f0c08632e898722280bed7e842ab8f84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0677a2f0c08632e898722280bed7e842ab8f84/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7dff453e64108f7010812e7f85e35f8a78cb096f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dff453e64108f7010812e7f85e35f8a78cb096f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dff453e64108f7010812e7f85e35f8a78cb096f"}], "stats": {"total": 767, "additions": 743, "deletions": 24}, "files": [{"sha": "3b004cf4f607618dc255c866e7ea72467d217606", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -1,3 +1,17 @@\n+2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/50002\n+\t* objc.dg/gnu-api-2-class.m: Updated comments.\n+\t* obj-c++.dg/gnu-api-2-class.mm: Likewise.\n+\t* objc.dg/gnu-api-2-class-meta.m: New test.\n+\t* obj-c++.dg/gnu-api-2-class-meta.mm: Likewise.\n+\t\n+2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\t\n+\tPR libobjc/49882\n+\t* obj-c++.dg/gnu-api-2-class.mm (main): Test class_getSuperclass()\n+\twith classes that are in construction.\n+\t\n 2011-08-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/48084"}, {"sha": "e7c5fc20e4340d5a65ddec5626325c1b2be23bb2", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-class-meta.mm", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class-meta.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class-meta.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class-meta.mm?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -0,0 +1,327 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'class-meta', covering calling functions starting with\n+  'class' but using a meta class as argument.\n+\n+  Functions that manipulate methods (adding, replacing methods)\n+  usually take a meta class argument to manipulate the class methods\n+  instead of the instance ones.  This is an important part of the API\n+  that needs testing.\n+\n+  Functions that manipulate instances, instance variables, properties\n+  and protocols at the moment must take a normal class as argument;\n+  calling them with a meta class as argument is of no particular use\n+  and generally produces a behaviour that is undocumented and/or\n+  undefined (and this is true with all runtimes).  As in the future\n+  this behaviour may be defined or documented (for example, if class\n+  variables are implemented as instance variables of meta classes) we\n+  avoid testing it for compatibility with future runtimes.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"No API#2 pre-Darwin9\" { *-*-darwin[5-8]* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n++ initialize;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n++ initialize { return self; }\n+@end\n+\n+static id static_variable = nil;\n+\n+@interface MySubClass : MyRootClass\n++ (void) setVariable: (id)value;\n++ (id) variable;\n+@end\n+\n+@implementation MySubClass\n++ (void) setVariable: (id)value { static_variable = value; }\n++ (id) variable { return static_variable; }\n+@end\n+\n+@interface DifferentClass : MyRootClass\n++ (id) myClass;\n+@end\n+\n+@implementation DifferentClass\n++ (id) myClass { return self; }\n+@end\n+\n+@interface MySubClass (MySelf)\n++ (id) mySelf;\n+@end\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  /* Calling class_addIvar() with a meta class is not documented and\n+     (currently) of no use.  */\n+  /* std::cout << \"Testing class_addIvar ()...\\n\"; */\n+  \n+  std::cout << \"Testing class_addMethod () on a meta class...\\n\";\n+  {\n+    /* Here we test adding methods to meta classes, ie, adding class methods.  */\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass2\", 0);\n+    Method method1 = class_getInstanceMethod (objc_getMetaClass (\"MySubClass\"), @selector (setVariable:));\n+    Method method2 = class_getInstanceMethod (objc_getMetaClass (\"MySubClass\"), @selector (variable));\n+\n+    if (new_class == Nil)\n+      abort ();\n+    \n+    if (! class_addMethod (object_getClass (new_class), @selector (setVariable:), method_getImplementation (method1),\n+\t\t\t   method_getTypeEncoding (method1)))\n+      abort ();\n+\n+    if (! class_addMethod (object_getClass (new_class), @selector (variable), method_getImplementation (method2),\n+\t\t\t   method_getTypeEncoding (method2)))\n+      abort ();\n+    \n+    /* Test that if the method already exists in the class,\n+       class_addMethod() returns NO.  */\n+    if (class_addMethod (object_getClass (new_class), @selector (variable), method_getImplementation (method2),\n+\t\t\t method_getTypeEncoding (method2)))\n+      abort ();\n+    \n+    objc_registerClassPair (new_class);\n+    \n+    /* Now, MySubClass2 is basically the same as MySubClass!  We'll\n+       use the +variable and +setVariable: methods on it.  */\n+    {\n+      Class c = objc_getClass (\"MySubClass2\");\n+      id o = [[MyRootClass alloc] init];\n+\n+      [c setVariable: o];\n+      \n+      if ([c variable] != o)\n+\tabort ();\n+    }\n+    \n+    /* Now, try that if you take an existing class and try to add an\n+       already existing method, class_addMethod returns NO.  This is\n+       subtly different from before, when 'new_class' was still in\n+       construction.  Now it's a real class and the libobjc internals\n+       differ between the two cases.  */\n+    if (class_addMethod (object_getClass (new_class), @selector (variable), method_getImplementation (method2),\n+\t\t\t method_getTypeEncoding (method2)))\n+      abort ();\n+  }\n+\n+  /* Calling class_addProtocol() on a meta class is not documented and\n+     (currently) of no use.  */\n+  /* std::cout << \"Testing class_addProtocol () on a meta class...\\n\"; */\n+\n+  /* Calling class_conformsToProtocol() on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_conformsToProtocol () on a meta class...\\n\"; */\n+  \n+  /* Calling class_copyIvarList() on a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_copyIvarList () on a meta class...\\n\"; */\n+\n+  std::cout << \"Testing class_copyMethodList () on a meta class...\\n\";\n+  {\n+    /* Test that you can copy the method list of a meta class.  They\n+       are the class methods of the class.  */\n+    unsigned int count;\n+    Method * list = class_copyMethodList (objc_getMetaClass (\"MySubClass\"), &count);\n+\n+    if (count != 2)\n+      abort ();\n+    \n+    if (! ((std::strcmp (sel_getName (method_getName (list[0])), \"variable\") == 0\n+\t    && std::strcmp (sel_getName (method_getName (list[1])), \"setVariable:\") == 0)\n+\t   || (std::strcmp (sel_getName (method_getName (list[0])), \"setVariable:\") == 0\n+\t       && std::strcmp (sel_getName (method_getName (list[1])), \"variable\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  /* Calling class_copyPropertyList() on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_copyPropertyList () on a meta class...\\n\"; */\n+\n+  /* Calling class_copyProtocolList() on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_copyProtocolList () on a meta class...\\n\"; */\n+\n+  /* Calling class_createInstance() on a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_createInstance () on a meta class...\\n\"; */\n+\n+  /* Calling class_getClassMethod () on a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getClassMethod () on a meta class...\\n\"; */\n+\n+  /* Calling class_getClassVariable () on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getClassVariable () on a meta class ...\\n\"; */\n+\n+  std::cout << \"Testing class_getInstanceMethod () on a meta class...\\n\";\n+  {\n+    /* The instance method of a meta class is the class method with\n+       the same name of the class. */\n+    Method method_1 = class_getInstanceMethod (objc_getMetaClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector(variable));\n+    Method method_2 = class_getClassMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t    @selector(variable));\n+    \n+    if (method_1 == NULL || method_2 == NULL)\n+      abort ();\n+\n+    if (method_1 != method_2)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (method_getName (method_1)), \"variable\") != 0)\n+      abort ();\n+  }\n+\n+  /* Calling class_getInstanceSize() with a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getInstanceSize () on a meta class...\\n\"; */\n+\n+  /* Calling class_getInstanceVariable() with a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getInstanceVariable () on a meta class...\\n\"; */\n+\n+  /* Calling class_getIvarLayout() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getIvarLayout () on a meta class...\\n\"; */\n+\n+  std::cout << \"Testing class_getMethodImplementation () on a meta class...\\n\";\n+  {\n+    /* Getting the method implementation with a meta class returns a\n+       class method.  */\n+    MySubClass *object = [[MySubClass alloc] init];\n+    IMP imp = class_getMethodImplementation (objc_getMetaClass (\"MySubClass\"), \n+\t\t\t\t\t     @selector(variable));\n+\n+    if (imp == NULL)\n+      abort ();\n+\n+    [MySubClass setVariable: object];\n+\n+    if ((*imp)(objc_getClass (\"MySubClass\"), @selector(variable)) != object)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* std::cout << \"Testing class_getMethodImplementation_stret () on a meta class...\\n\"; */\n+\n+  std::cout << \"Testing class_getName () on a meta class...\\n\";\n+  {\n+    /* Traditionally, a meta class has the same name as the class.  */\n+    if (std::strcmp (class_getName (objc_getMetaClass (\"MyRootClass\")),\n+\t\t     \"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  /* Calling class_getProperty() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getProperty ()...\\n\"; */\n+\n+  std::cout << \"Testing class_getSuperclass () on a meta class...\\n\";\n+  {\n+    /* The superclass of a meta class is the meta class of the superclass.  */\n+    if (class_getSuperclass (objc_getMetaClass (\"MySubClass\")) != objc_getMetaClass (\"MyRootClass\"))\n+      abort ();\n+\n+    /* Test that it works on a newly created, but not registered, class.  */\n+    {\n+      Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass3\", 0);\n+\n+      if (class_getSuperclass (object_getClass (new_class)) != object_getClass (objc_getClass (\"MyRootClass\")))\n+\tabort ();\n+    }\n+  }\n+\n+  /* Calling class_getVersion() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getVersion ()...\\n\"; */\n+\n+  /* Calling class_getWeakIvarLayout() with a meta class is not\n+     documented and (currently) of no use.  */\n+  /* std::cout << \"Testing class_getWeakIvarLayout () on a meta class...\\n\"; */\n+\n+  /* class_isMetaClass() is already tested in gnu-api-2-class.m  */\n+  /* std::cout << \"Testing class_isMetaClass ()...\\n\"; */\n+\n+  std::cout << \"Testing class_replaceMethod () on a meta class...\\n\";\n+  {\n+    /* We are going to replace the [MySubclass +variable] method with\n+       the [DifferentClass +myClass] one.  */\n+    Method new_method = class_getClassMethod (objc_getClass (\"DifferentClass\"),\n+\t\t\t\t\t      @selector (myClass));\n+    Method old_method = class_getClassMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t      @selector (variable));\n+    const char *new_types = method_getTypeEncoding (new_method);\n+    IMP new_imp = method_getImplementation (new_method);\n+    const char *old_types = method_getTypeEncoding (old_method);\n+    IMP old_imp = class_replaceMethod (objc_getMetaClass (\"MySubClass\"), @selector (variable),\n+\t\t\t\t       method_getImplementation (new_method),\n+\t\t\t\t       method_getTypeEncoding (new_method));\n+    id o = [[MyRootClass alloc] init];\n+\n+    [MySubClass setVariable: o];\n+\n+    /* Try the new method implementation.  */\n+    if ([MySubClass variable] != objc_getClass (\"MySubClass\"))\n+      abort ();\n+\n+    /* Put the original method back.  */\n+    class_replaceMethod (objc_getMetaClass (\"MySubClass\"), @selector (variable),\n+\t\t\t old_imp, old_types);\n+\n+    /* Test it's back to what it was.  */\n+    if ([MySubClass variable] != o)\n+      abort ();\n+\n+    {\n+      /* Finally, try adding a new method.  */\n+      class_replaceMethod (objc_getMetaClass (\"DifferentClass\"), @selector (mySelf),\n+\t\t\t   new_imp, new_types);\n+      \n+      if ([(Class)objc_getClass (\"DifferentClass\") mySelf] != objc_getClass (\"DifferentClass\"))\n+\tabort ();\n+    }\n+  }\n+\n+  std::cout << \"Testing class_respondsToSelector () on a meta class...\\n\";\n+  {\n+    /* A meta class responds to a selector if and only if the class\n+       responds to the corresponding class method.  */\n+    if (! class_respondsToSelector (objc_getMetaClass (\"MySubClass\"), @selector(setVariable:)))\n+      abort ();\n+\n+    if (class_respondsToSelector (objc_getMetaClass (\"MyRootClass\"), @selector(setVariable:)))\n+      abort ();\n+  }\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* std::cout << \"Testing class_setIvarLayout () on a meta class...\\n\"; */\n+\n+  /* Calling class_setVersion() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* std::cout << \"Testing class_setVersion () on a meta class...\\n\"; */\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* std::cout << \"Testing class_setWeakIvarLayout () on a meta class...\\n\"; */\n+\n+return (0);\n+}"}, {"sha": "9a7c092f3b27580e8b40b009d40b40c0fd3d6b85", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-class.mm", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-class.mm?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -1,6 +1,8 @@\n /* Test the Modern GNU Objective-C Runtime API.\n \n-  This is test 'class', covering all functions starting with 'class'.  */\n+  This is test 'class', covering all functions starting with 'class'.\n+  Tests calling the functions with a meta class as argument are covered\n+  in the separate file, gnu-api-2-class-meta.mm.  */\n \n /* { dg-do run } */\n /* { dg-skip-if \"No API#2 pre-Darwin9\" { *-*-darwin[5-8]* } { \"-fnext-runtime\" } { \"\" } } */\n@@ -394,6 +396,14 @@ int main ()\n     MySubClass *object = [[MySubClass alloc] init];\n     if (class_getSuperclass (object_getClass (object)) != objc_getClass (\"MyRootClass\"))\n       abort ();\n+\n+    /* Test that it works on a newly created, but not registered, class.  */\n+    {\n+      Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass3\", 0);\n+\n+      if (class_getSuperclass (new_class) != objc_getClass (\"MyRootClass\"))\n+\tabort ();\n+    }\n   }\n \n   std::cout << \"Testing class_getVersion ()...\\n\";"}, {"sha": "ea187b6a45a46b303ce62a75c481ee866bcb2c89", "filename": "gcc/testsuite/objc.dg/gnu-api-2-class-meta.m", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class-meta.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class-meta.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class-meta.m?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -0,0 +1,327 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'class-meta', covering calling functions starting with\n+  'class' but using a meta class as argument.\n+\n+  Functions that manipulate methods (adding, replacing methods)\n+  usually take a meta class argument to manipulate the class methods\n+  instead of the instance ones.  This is an important part of the API\n+  that needs testing.\n+\n+  Functions that manipulate instances, instance variables, properties\n+  and protocols at the moment must take a normal class as argument;\n+  calling them with a meta class as argument is of no particular use\n+  and generally produces a behaviour that is undocumented and/or\n+  undefined (and this is true with all runtimes).  As in the future\n+  this behaviour may be defined or documented (for example, if class\n+  variables are implemented as instance variables of meta classes) we\n+  avoid testing it for compatibility with future runtimes.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"No API#2 pre-Darwin9\" { *-*-darwin[5-8]* } { \"-fnext-runtime\" } { \"\" } } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n++ initialize;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n++ initialize { return self; }\n+@end\n+\n+static id static_variable = nil;\n+\n+@interface MySubClass : MyRootClass\n++ (void) setVariable: (id)value;\n++ (id) variable;\n+@end\n+\n+@implementation MySubClass\n++ (void) setVariable: (id)value { static_variable = value; }\n++ (id) variable { return static_variable; }\n+@end\n+\n+@interface DifferentClass : MyRootClass\n++ (id) myClass;\n+@end\n+\n+@implementation DifferentClass\n++ (id) myClass { return self; }\n+@end\n+\n+@interface MySubClass (MySelf)\n++ (id) mySelf;\n+@end\n+\n+int main(int argc, void **args)\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  /* Calling class_addIvar() with a meta class is not documented and\n+     (currently) of no use.  */\n+  /* printf (\"Testing class_addIvar ()...\\n\"); */\n+  \n+  printf (\"Testing class_addMethod () on a meta class...\\n\");\n+  {\n+    /* Here we test adding methods to meta classes, ie, adding class methods.  */\n+    Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass2\", 0);\n+    Method method1 = class_getInstanceMethod (objc_getMetaClass (\"MySubClass\"), @selector (setVariable:));\n+    Method method2 = class_getInstanceMethod (objc_getMetaClass (\"MySubClass\"), @selector (variable));\n+\n+    if (new_class == Nil)\n+      abort ();\n+    \n+    if (! class_addMethod (object_getClass (new_class), @selector (setVariable:), method_getImplementation (method1),\n+\t\t\t   method_getTypeEncoding (method1)))\n+      abort ();\n+\n+    if (! class_addMethod (object_getClass (new_class), @selector (variable), method_getImplementation (method2),\n+\t\t\t   method_getTypeEncoding (method2)))\n+      abort ();\n+    \n+    /* Test that if the method already exists in the class,\n+       class_addMethod() returns NO.  */\n+    if (class_addMethod (object_getClass (new_class), @selector (variable), method_getImplementation (method2),\n+\t\t\t method_getTypeEncoding (method2)))\n+      abort ();\n+    \n+    objc_registerClassPair (new_class);\n+    \n+    /* Now, MySubClass2 is basically the same as MySubClass!  We'll\n+       use the +variable and +setVariable: methods on it.  */\n+    {\n+      Class c = objc_getClass (\"MySubClass2\");\n+      id o = [[MyRootClass alloc] init];\n+\n+      [c setVariable: o];\n+      \n+      if ([c variable] != o)\n+\tabort ();\n+    }\n+    \n+    /* Now, try that if you take an existing class and try to add an\n+       already existing method, class_addMethod returns NO.  This is\n+       subtly different from before, when 'new_class' was still in\n+       construction.  Now it's a real class and the libobjc internals\n+       differ between the two cases.  */\n+    if (class_addMethod (object_getClass (new_class), @selector (variable), method_getImplementation (method2),\n+\t\t\t method_getTypeEncoding (method2)))\n+      abort ();\n+  }\n+\n+  /* Calling class_addProtocol() on a meta class is not documented and\n+     (currently) of no use.  */\n+  /* printf (\"Testing class_addProtocol () on a meta class...\\n\"); */\n+\n+  /* Calling class_conformsToProtocol() on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_conformsToProtocol () on a meta class...\\n\"); */\n+  \n+  /* Calling class_copyIvarList() on a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_copyIvarList () on a meta class...\\n\"); */\n+\n+  printf (\"Testing class_copyMethodList () on a meta class...\\n\");\n+  {\n+    /* Test that you can copy the method list of a meta class.  They\n+       are the class methods of the class.  */\n+    unsigned int count;\n+    Method * list = class_copyMethodList (objc_getMetaClass (\"MySubClass\"), &count);\n+\n+    if (count != 2)\n+      abort ();\n+    \n+    if (! ((strcmp (sel_getName (method_getName (list[0])), \"variable\") == 0\n+\t    && strcmp (sel_getName (method_getName (list[1])), \"setVariable:\") == 0)\n+\t   || (strcmp (sel_getName (method_getName (list[0])), \"setVariable:\") == 0\n+\t       && strcmp (sel_getName (method_getName (list[1])), \"variable\") == 0)))\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n+  /* Calling class_copyPropertyList() on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_copyPropertyList () on a meta class...\\n\"); */\n+\n+  /* Calling class_copyProtocolList() on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_copyProtocolList () on a meta class...\\n\"); */\n+\n+  /* Calling class_createInstance() on a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_createInstance () on a meta class...\\n\"); */\n+\n+  /* Calling class_getClassMethod () on a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_getClassMethod () on a meta class...\\n\"); */\n+\n+  /* Calling class_getClassVariable () on a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_getClassVariable () on a meta class ...\\n\"); */\n+\n+  printf (\"Testing class_getInstanceMethod () on a meta class...\\n\");\n+  {\n+    /* The instance method of a meta class is the class method with\n+       the same name of the class. */\n+    Method method_1 = class_getInstanceMethod (objc_getMetaClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector(variable));\n+    Method method_2 = class_getClassMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t    @selector(variable));\n+    \n+    if (method_1 == NULL || method_2 == NULL)\n+      abort ();\n+\n+    if (method_1 != method_2)\n+      abort ();\n+\n+    if (strcmp (sel_getName (method_getName (method_1)), \"variable\") != 0)\n+      abort ();\n+  }\n+\n+  /* Calling class_getInstanceSize() with a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_getInstanceSize () on a meta class...\\n\"); */\n+\n+  /* Calling class_getInstanceVariable() with a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_getInstanceVariable () on a meta class...\\n\"); */\n+\n+  /* Calling class_getIvarLayout() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_getIvarLayout () on a meta class...\\n\"); */\n+\n+  printf (\"Testing class_getMethodImplementation () on a meta class...\\n\");\n+  {\n+    /* Getting the method implementation with a meta class returns a\n+       class method.  */\n+    MySubClass *object = [[MySubClass alloc] init];\n+    IMP imp = class_getMethodImplementation (objc_getMetaClass (\"MySubClass\"), \n+\t\t\t\t\t     @selector(variable));\n+\n+    if (imp == NULL)\n+      abort ();\n+\n+    [MySubClass setVariable: object];\n+\n+    if ((*imp)(objc_getClass (\"MySubClass\"), @selector(variable)) != object)\n+      abort ();\n+  }\n+\n+  /* This function does not exist with the GNU runtime.  */\n+  /* printf (\"Testing class_getMethodImplementation_stret () on a meta class...\\n\"); */\n+\n+  printf (\"Testing class_getName () on a meta class...\\n\");\n+  {\n+    /* Traditionally, a meta class has the same name as the class.  */\n+    if (strcmp (class_getName (objc_getMetaClass (\"MyRootClass\")),\n+\t\t\"MyRootClass\") != 0)\n+      abort ();\n+  }\n+\n+  /* Calling class_getProperty() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_getProperty ()...\\n\"); */\n+\n+  printf (\"Testing class_getSuperclass () on a meta class...\\n\");\n+  {\n+    /* The superclass of a meta class is the meta class of the superclass.  */\n+    if (class_getSuperclass (objc_getMetaClass (\"MySubClass\")) != objc_getMetaClass (\"MyRootClass\"))\n+      abort ();\n+\n+    /* Test that it works on a newly created, but not registered, class.  */\n+    {\n+      Class new_class = objc_allocateClassPair (objc_getClass (\"MyRootClass\"), \"MySubClass3\", 0);\n+\n+      if (class_getSuperclass (object_getClass (new_class)) != object_getClass (objc_getClass (\"MyRootClass\")))\n+\tabort ();\n+    }\n+  }\n+\n+  /* Calling class_getVersion() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_getVersion ()...\\n\"); */\n+\n+  /* Calling class_getWeakIvarLayout() with a meta class is not\n+     documented and (currently) of no use.  */\n+  /* printf (\"Testing class_getWeakIvarLayout () on a meta class...\\n\"); */\n+\n+  /* class_isMetaClass() is already tested in gnu-api-2-class.m  */\n+  /* printf (\"Testing class_isMetaClass ()...\\n\"); */\n+\n+  printf (\"Testing class_replaceMethod () on a meta class...\\n\");\n+  {\n+    /* We are going to replace the [MySubclass +variable] method with\n+       the [DifferentClass +myClass] one.  */\n+    Method new_method = class_getClassMethod (objc_getClass (\"DifferentClass\"),\n+\t\t\t\t\t      @selector (myClass));\n+    Method old_method = class_getClassMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t      @selector (variable));\n+    const char *new_types = method_getTypeEncoding (new_method);\n+    IMP new_imp = method_getImplementation (new_method);\n+    const char *old_types = method_getTypeEncoding (old_method);\n+    IMP old_imp = class_replaceMethod (objc_getMetaClass (\"MySubClass\"), @selector (variable),\n+\t\t\t\t       method_getImplementation (new_method),\n+\t\t\t\t       method_getTypeEncoding (new_method));\n+    id o = [[MyRootClass alloc] init];\n+\n+    [MySubClass setVariable: o];\n+\n+    /* Try the new method implementation.  */\n+    if ([MySubClass variable] != objc_getClass (\"MySubClass\"))\n+      abort ();\n+\n+    /* Put the original method back.  */\n+    class_replaceMethod (objc_getMetaClass (\"MySubClass\"), @selector (variable),\n+\t\t\t old_imp, old_types);\n+\n+    /* Test it's back to what it was.  */\n+    if ([MySubClass variable] != o)\n+      abort ();\n+\n+    {\n+      /* Finally, try adding a new method.  */\n+      class_replaceMethod (objc_getMetaClass (\"DifferentClass\"), @selector (mySelf),\n+\t\t\t   new_imp, new_types);\n+      \n+      if ([(Class)objc_getClass (\"DifferentClass\") mySelf] != objc_getClass (\"DifferentClass\"))\n+\tabort ();\n+    }\n+  }\n+\n+  printf (\"Testing class_respondsToSelector () on a meta class...\\n\");\n+  {\n+    /* A meta class responds to a selector if and only if the class\n+       responds to the corresponding class method.  */\n+    if (! class_respondsToSelector (objc_getMetaClass (\"MySubClass\"), @selector(setVariable:)))\n+      abort ();\n+\n+    if (class_respondsToSelector (objc_getMetaClass (\"MyRootClass\"), @selector(setVariable:)))\n+      abort ();\n+  }\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* printf (\"Testing class_setIvarLayout () on a meta class...\\n\"); */\n+\n+  /* Calling class_setVersion() with a meta class is not documented\n+     and (currently) of no use.  */\n+  /* printf (\"Testing class_setVersion () on a meta class...\\n\"); */\n+\n+  /* This is not really implemented with the GNU runtime.  */\n+  /* printf (\"Testing class_setWeakIvarLayout () on a meta class...\\n\"); */\n+\n+  return 0;\n+}"}, {"sha": "7f9cf861c8abd563e8c491d4531ce615bba4e8d4", "filename": "gcc/testsuite/objc.dg/gnu-api-2-class.m", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-class.m?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -1,6 +1,8 @@\n /* Test the Modern GNU Objective-C Runtime API.\n \n-  This is test 'class', covering all functions starting with 'class'.  */\n+  This is test 'class', covering all functions starting with 'class'.\n+  Tests calling the functions with a meta class as argument are covered\n+  in the separate file, gnu-api-2-class-meta.m.  */\n \n /* { dg-do run } */\n /* { dg-skip-if \"No API#2 pre-Darwin9\" { *-*-darwin[5-8]* } { \"-fnext-runtime\" } { \"\" } } */\n@@ -401,7 +403,7 @@ int main(int argc, void **args)\n \n       if (class_getSuperclass (new_class) != objc_getClass (\"MyRootClass\"))\n \tabort ();\n-    }    \n+    }\n   }\n \n   printf (\"Testing class_getVersion ()...\\n\");"}, {"sha": "b9f87fabec9ff4d2da24a80b48b37db17ea4492c", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -1,3 +1,15 @@\n+2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/50002\n+\t* class.c (__objc_update_classes_with_methods): Iterate over meta\n+\tclasses as well as normal classes when refreshing the method\n+\timplementations.  This fixes replacing class methods.\n+\n+2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* class.c (class_getSuperclass): Fixed to work with meta classes\n+\tstill in construction too.\n+\n 2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* class.c (class_getSuperclass): Fixed typo in comment."}, {"sha": "edc56aa9ec4d2679e7b8f8e53f6b67bd7785e797", "filename": "libobjc/class.c", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0677a2f0c08632e898722280bed7e842ab8f84/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0677a2f0c08632e898722280bed7e842ab8f84/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=0e0677a2f0c08632e898722280bed7e842ab8f84", "patch": "@@ -781,35 +781,57 @@ __objc_update_classes_with_methods (struct objc_method *method_a, struct objc_me\n       \n       while (node != NULL)\n \t{\n-\t  /* Iterate over all methods in the class.  */\n-\t  Class class = node->pointer;\n-\t  struct objc_method_list * method_list = class->methods;\n-\n-\t  while (method_list)\n+\t  /* We execute this loop twice: the first time, we iterate\n+\t     over all methods in the class (instance methods), while\n+\t     the second time we iterate over all methods in the meta\n+\t     class (class methods).  */\n+\t  Class class = Nil;\n+\t  BOOL done = NO;\n+\n+\t  while (done == NO)\n \t    {\n-\t      int i;\n+\t      struct objc_method_list * method_list;\n \n-\t      for (i = 0; i < method_list->method_count; ++i)\n+\t      if (class == Nil)\n+\t\t{\n+\t\t  /* The first time, we work on the class.  */\n+\t\t  class = node->pointer;\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  struct objc_method *method = &method_list->method_list[i];\n+\t\t  /* The second time, we work on the meta class.  */\n+\t\t  class = class->class_pointer;\n+\t\t  done = YES;\n+\t\t}\n \n-\t\t  /* If the method is one of the ones we are looking\n-\t\t     for, update the implementation.  */\n-\t\t  if (method == method_a)\n-\t\t    sarray_at_put_safe (class->dtable,\n-\t\t\t\t\t(sidx) method_a->method_name->sel_id,\n-\t\t\t\t\tmethod_a->method_imp);\n+\t      method_list = class->methods;\n \n-\t\t  if (method == method_b)\n+\t      while (method_list)\n+\t\t{\n+\t\t  int i;\n+\t\t  \n+\t\t  for (i = 0; i < method_list->method_count; ++i)\n \t\t    {\n-\t\t      if (method_b != NULL)\n+\t\t      struct objc_method *method = &method_list->method_list[i];\n+\t\t      \n+\t\t      /* If the method is one of the ones we are\n+\t\t\t looking for, update the implementation.  */\n+\t\t      if (method == method_a)\n \t\t\tsarray_at_put_safe (class->dtable,\n-\t\t\t\t\t    (sidx) method_b->method_name->sel_id,\n-\t\t\t\t\t    method_b->method_imp);\n+\t\t\t\t\t    (sidx) method_a->method_name->sel_id,\n+\t\t\t\t\t    method_a->method_imp);\n+\t\t      \n+\t\t      if (method == method_b)\n+\t\t\t{\n+\t\t\t  if (method_b != NULL)\n+\t\t\t    sarray_at_put_safe (class->dtable,\n+\t\t\t\t\t\t(sidx) method_b->method_name->sel_id,\n+\t\t\t\t\t\tmethod_b->method_imp);\n+\t\t\t}\n \t\t    }\n+\t\t  \n+\t\t  method_list = method_list->method_next;\n \t\t}\n-\t  \n-\t      method_list = method_list->method_next;\n \t    }\n \t  node = node->next;\n \t}\n@@ -929,7 +951,12 @@ class_getSuperclass (Class class_)\n      superclass name to return the superclass.  We can not resolve the\n      class until it is registered.  */\n   if (CLS_IS_IN_CONSTRUCTION (class_))\n-    return objc_lookUpClass ((const char *)(class_->super_class));\n+    {\n+      if (CLS_ISMETA (class_))\n+\treturn object_getClass ((id)objc_lookUpClass ((const char *)(class_->super_class)));\n+      else\n+\treturn objc_lookUpClass ((const char *)(class_->super_class));\n+    }\n \n   /* If the class is not resolved yet, super_class would point to a\n      string (the name of the super class) as opposed to the actual"}]}