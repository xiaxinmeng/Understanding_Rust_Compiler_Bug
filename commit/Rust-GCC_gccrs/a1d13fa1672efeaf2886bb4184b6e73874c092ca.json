{"sha": "a1d13fa1672efeaf2886bb4184b6e73874c092ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFkMTNmYTE2NzJlZmVhZjI4ODZiYjQxODRiNmU3Mzg3NGMwOTJjYQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-02-01T20:30:07Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-02-01T20:30:07Z"}, "message": "re PR tree-optimization/19633 (local address incorrectly thought to escape)\n\n\n\tPR tree-optimization/19633\n\t* tree-flow.h (struct ptr_info_def): Add field 'pt_null'.\n\t* tree-ssa-alias.c (init_alias_info): Initialize.\n\t(merge_pointed_to_info): Set.\n\t(add_pointed_to_expr): Set pt_null if EXPR is a NULL pointer.\n\t(dump_points_to_info_for): Show value of pt_null.\n\t(struct count_ptr_d): Declare.\n\t(find_ptr_dereference): Remove.\n\t(ptr_is_dereferenced_by): Remove.\n\t(count_ptr_derefs): New local function.\n\t(count_uses_and_derefs): New local function.\n\t(compute_points_to_and_addr_escape): Call it.  If the number\n\tof dereferences is greater than zero, mark the pointer as\n\tdereferenced.  If there are fewer dereferences than uses of\n\tthe pointer, the pointer's value escapes.\n\ntestsuite/ChangeLog\n\n\tPR tree-optimization/19633\n\t* testsuite/gcc.dg/pr19633-1.c: New test.\n\t* testsuite/gcc.dg/pr19633.c: Tweak to make pointer point\n\tto NULL or a symbol.\n\nFrom-SVN: r94558", "tree": {"sha": "87292513a1b836b5850299e91904214e71fb9556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87292513a1b836b5850299e91904214e71fb9556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1d13fa1672efeaf2886bb4184b6e73874c092ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d13fa1672efeaf2886bb4184b6e73874c092ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d13fa1672efeaf2886bb4184b6e73874c092ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d13fa1672efeaf2886bb4184b6e73874c092ca/comments", "author": null, "committer": null, "parents": [{"sha": "28a3618fb707d32cf24e2d63ed6812cbf4054d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28a3618fb707d32cf24e2d63ed6812cbf4054d14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28a3618fb707d32cf24e2d63ed6812cbf4054d14"}], "stats": {"total": 324, "additions": 236, "deletions": 88}, "files": [{"sha": "3ec28c7a24fd11b7f4bba2388675f710d73b66f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1d13fa1672efeaf2886bb4184b6e73874c092ca", "patch": "@@ -1,3 +1,21 @@\n+2005-02-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/19633\n+\t* tree-flow.h (struct ptr_info_def): Add field 'pt_null'.\n+\t* tree-ssa-alias.c (init_alias_info): Initialize.\n+\t(merge_pointed_to_info): Set.\n+\t(add_pointed_to_expr): Set pt_null if EXPR is a NULL pointer.\n+\t(dump_points_to_info_for): Show value of pt_null.\n+\t(struct count_ptr_d): Declare.\n+\t(find_ptr_dereference): Remove.\n+\t(ptr_is_dereferenced_by): Remove.\n+\t(count_ptr_derefs): New local function.\n+\t(count_uses_and_derefs): New local function.\n+\t(compute_points_to_and_addr_escape): Call it.  If the number\n+\tof dereferences is greater than zero, mark the pointer as\n+\tdereferenced.  If there are fewer dereferences than uses of\n+\tthe pointer, the pointer's value escapes.\n+\n 2005-02-01  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/19670"}, {"sha": "a6ff8329a1fe83c2966bd99188a6a0579e2461f5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1d13fa1672efeaf2886bb4184b6e73874c092ca", "patch": "@@ -1,3 +1,10 @@\n+2005-02-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/19633\n+\t* testsuite/gcc.dg/pr19633-1.c: New test.\n+\t* testsuite/gcc.dg/pr19633.c: Tweak to make pointer point\n+\tto NULL or a symbol.\n+\n 2005-02-01  Janis Johnson  <janis187@us.ibm.com>\n \n \t* lib/gcc-dg.exp (selector_opd, selector_list, selector_expression):"}, {"sha": "c05e46aef643a40125d9b3eadb49b0478bbebc4e", "filename": "gcc/testsuite/gcc.dg/pr19633-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19633-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19633-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19633-1.c?ref=a1d13fa1672efeaf2886bb4184b6e73874c092ca", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  int w, x, y, z;\n+};\n+\n+struct T\n+{\n+  int r;\n+  struct S s;\n+};\n+\n+struct S bar (struct S x, struct S *y)\n+{\n+  y->w = 4;\n+  return *y;\n+}\n+\n+void\n+foo (int a, struct T b)\n+{\n+  struct S x;\n+  struct S *c = &x;\n+  if (a)\n+    c = &b.s;\n+  b.s.w = 3;\n+  /* This call should be marked as clobbering 'x' and 'b'.  */\n+  *c = bar (*c, c);\n+  if (b.s.w == 3)\n+    abort ();\n+}\n+\n+float Y;\n+\n+struct S bar1 (struct S x, struct S y)\n+{\n+  Y = 4;\n+  return x;\n+}\n+\n+void\n+foo1 (int a, struct T b)\n+{\n+  struct S x;\n+  struct S *c = &x;\n+  float z, *k = &z;\n+  if (a)\n+    c = &b.s;\n+  b.s.w = 3;\n+  /* This call should NOT be marked as clobbering 'x' and 'b'.  */\n+  x = bar1 (*c, *c);\n+  if (b.s.w != 3)\n+    link_error ();\n+}\n+\n+int main ()\n+{\n+  struct T b;\n+  foo (3, b);\n+  foo1 (3, b);\n+  return 0;\n+}"}, {"sha": "fda0df6c5faacedc7c8a839793b5b3f7fd532655", "filename": "gcc/testsuite/gcc.dg/pr19633.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19633.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19633.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr19633.c?ref=a1d13fa1672efeaf2886bb4184b6e73874c092ca", "patch": "@@ -15,12 +15,21 @@ struct T\n void\n foo (int a, struct T b)\n {\n-  struct S x;\n-  struct S *c = &x;\n+  struct S *c = 0;\n+\n   if (a)\n     c = &b.s;\n+\n   b.s.w = 3;\n+\n+  /* Since 'c' may be pointing to NULL here, we used to flag it as\n+     pointing anywhere, which was forcing the aliaser to mark as\n+     call-clobbered every other variable pointed-to by 'c' ('b' in\n+     this case).  This, in turn, caused the insertion of V_MAY_DEFs\n+     for 'b' at this call-site, which prevented constant propagation\n+     from 'b.s.w = 3' to 'if (b.s.w != 3)'.  */\n   bar (*c, a);\n+\n   if (b.s.w != 3)\n     link_error ();\n }"}, {"sha": "d8d64fba1f1c1ff4912f00dd2a99f49ca93542c9", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a1d13fa1672efeaf2886bb4184b6e73874c092ca", "patch": "@@ -66,6 +66,9 @@ struct ptr_info_def GTY(())\n   /* Nonzero if this pointer points to a global variable.  */\n   unsigned int pt_global_mem : 1;\n \n+  /* Nonzero if this pointer points to NULL.  */\n+  unsigned int pt_null : 1;\n+\n   /* Set of variables that this pointer may point to.  */\n   bitmap pt_vars;\n "}, {"sha": "6a95bcd2a11ec471f9d79fe7db4fd2384e57315d", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 131, "deletions": 86, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d13fa1672efeaf2886bb4184b6e73874c092ca/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a1d13fa1672efeaf2886bb4184b6e73874c092ca", "patch": "@@ -149,7 +149,6 @@ static bool is_escape_site (tree, size_t *);\n static void add_pointed_to_var (struct alias_info *, tree, tree);\n static void create_global_var (void);\n static void collect_points_to_info_for (struct alias_info *, tree);\n-static bool ptr_is_dereferenced_by (tree, tree, bool *);\n static void maybe_create_global_var (struct alias_info *ai);\n static void group_aliases (struct alias_info *);\n static void set_pt_anything (tree ptr);\n@@ -359,6 +358,113 @@ struct tree_opt_pass pass_may_alias =\n   0\t\t\t\t\t/* letter */\n };\n \n+\n+/* Data structure used to count the number of dereferences to PTR\n+   inside an expression.  */\n+struct count_ptr_d\n+{\n+  tree ptr;\n+  unsigned count;\n+};\n+\n+\n+/* Helper for count_uses_and_derefs.  Called by walk_tree to look for\n+   (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n+\n+static tree\n+count_ptr_derefs (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n+{\n+  struct count_ptr_d *count_p = (struct count_ptr_d *) data;\n+\n+  if (INDIRECT_REF_P (*tp) && TREE_OPERAND (*tp, 0) == count_p->ptr)\n+    count_p->count++;\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Count the number of direct and indirect uses for pointer PTR in\n+   statement STMT.  The two counts are stored in *NUM_USES_P and\n+   *NUM_DEREFS_P respectively.  *IS_STORE_P is set to 'true' if at\n+   least one of those dereferences is a store operation.  */\n+\n+static void\n+count_uses_and_derefs (tree ptr, tree stmt, unsigned *num_uses_p,\n+\t\t       unsigned *num_derefs_p, bool *is_store)\n+{\n+  ssa_op_iter i;\n+  tree use;\n+\n+  *num_uses_p = 0;\n+  *num_derefs_p = 0;\n+  *is_store = false;\n+\n+  /* Find out the total number of uses of PTR in STMT.  */\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, i, SSA_OP_USE)\n+    if (use == ptr)\n+      (*num_uses_p)++;\n+\n+  /* Now count the number of indirect references to PTR.  This is\n+     truly awful, but we don't have much choice.  There are no parent\n+     pointers inside INDIRECT_REFs, so an expression like\n+     '*x_1 = foo (x_1, *x_1)' needs to be traversed piece by piece to\n+     find all the indirect and direct uses of x_1 inside.  The only\n+     shortcut we can take is the fact that GIMPLE only allows\n+     INDIRECT_REFs inside the expressions below.  */\n+  if (TREE_CODE (stmt) == MODIFY_EXPR\n+      || (TREE_CODE (stmt) == RETURN_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n+      || TREE_CODE (stmt) == ASM_EXPR\n+      || TREE_CODE (stmt) == CALL_EXPR)\n+    {\n+      tree lhs, rhs;\n+\n+      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t{\n+\t  lhs = TREE_OPERAND (stmt, 0);\n+\t  rhs = TREE_OPERAND (stmt, 1);\n+\t}\n+      else if (TREE_CODE (stmt) == RETURN_EXPR)\n+\t{\n+\t  tree e = TREE_OPERAND (stmt, 0);\n+\t  lhs = TREE_OPERAND (e, 0);\n+\t  rhs = TREE_OPERAND (e, 1);\n+\t}\n+      else if (TREE_CODE (stmt) == ASM_EXPR)\n+\t{\n+\t  lhs = ASM_OUTPUTS (stmt);\n+\t  rhs = ASM_INPUTS (stmt);\n+\t}\n+      else\n+\t{\n+\t  lhs = NULL_TREE;\n+\t  rhs = stmt;\n+\t}\n+\n+      if (lhs && EXPR_P (lhs))\n+\t{\n+\t  struct count_ptr_d count;\n+\t  count.ptr = ptr;\n+\t  count.count = 0;\n+\t  walk_tree (&lhs, count_ptr_derefs, &count, NULL);\n+\t  *is_store = true;\n+\t  *num_derefs_p = count.count;\n+\t}\n+\n+      if (rhs && EXPR_P (rhs))\n+\t{\n+\t  struct count_ptr_d count;\n+\t  count.ptr = ptr;\n+\t  count.count = 0;\n+\t  walk_tree (&rhs, count_ptr_derefs, &count, NULL);\n+\t  *num_derefs_p += count.count;\n+\t}\n+    }\n+\n+  gcc_assert (*num_uses_p >= *num_derefs_p);\n+}\n+\n+\n /* Count the number of calls in the function and conditionally\n    create GLOBAL_VAR.   This is performed before translation\n    into SSA (and thus before alias analysis) to avoid compile time\n@@ -495,6 +601,7 @@ init_alias_info (void)\n \t\t tag will need to be created in create_name_tags.  */\n \t      pi->pt_anything = 0;\n \t      pi->pt_malloc = 0;\n+\t      pi->pt_null = 0;\n \t      pi->value_escapes_p = 0;\n \t      pi->is_dereferenced = 0;\n \t      if (pi->pt_vars)\n@@ -561,81 +668,6 @@ collect_points_to_info_for (struct alias_info *ai, tree ptr)\n }\n \n \n-/* Helper for ptr_is_dereferenced_by.  Called by walk_tree to look for\n-   (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n-\n-static tree\n-find_ptr_dereference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n-{\n-  tree ptr = (tree) data;\n-\n-  if (INDIRECT_REF_P (*tp)\n-      && TREE_OPERAND (*tp, 0) == ptr)\n-    return *tp;\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* Return true if STMT contains (ALIGN/MISALIGNED_)INDIRECT_REF <PTR>.  \n-   *IS_STORE is set to 'true' if the dereference is on the LHS of an \n-   assignment.  */\n-\n-static bool\n-ptr_is_dereferenced_by (tree ptr, tree stmt, bool *is_store)\n-{\n-  *is_store = false;\n-\n-  if (TREE_CODE (stmt) == MODIFY_EXPR\n-      || (TREE_CODE (stmt) == RETURN_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR))\n-    {\n-      tree e, lhs, rhs;\n-\n-      e = (TREE_CODE (stmt) == RETURN_EXPR) ? TREE_OPERAND (stmt, 0) : stmt;\n-      lhs = TREE_OPERAND (e, 0);\n-      rhs = TREE_OPERAND (e, 1);\n-\n-      if (EXPR_P (lhs)\n-\t  && walk_tree (&lhs, find_ptr_dereference, ptr, NULL))\n-\t{\n-\t  *is_store = true;\n-\t  return true;\n-\t}\n-      else if (EXPR_P (rhs)\n-\t       && walk_tree (&rhs, find_ptr_dereference, ptr, NULL))\n-\t{\n-\t  return true;\n-\t}\n-    }\n-  else if (TREE_CODE (stmt) == ASM_EXPR)\n-    {\n-      if (walk_tree (&ASM_OUTPUTS (stmt), find_ptr_dereference, ptr, NULL)\n-\t  || walk_tree (&ASM_CLOBBERS (stmt), find_ptr_dereference, ptr, NULL))\n-\t{\n-\t  *is_store = true;\n-\t  return true;\n-\t}\n-      else if (walk_tree (&ASM_INPUTS (stmt), find_ptr_dereference, ptr, NULL))\n-\t{\n-\t  return true;\n-\t}\n-    }\n-  else\n-    {\n-      /* CALL_EXPRs may also contain pointer dereferences for types\n-\t that are not GIMPLE register types.  If the CALL_EXPR is on\n-\t the RHS of an assignment, it will be handled by the\n-\t MODIFY_EXPR handler above.  */\n-      tree call = get_call_expr_in (stmt);\n-      if (call && walk_tree (&call, find_ptr_dereference, ptr, NULL))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-\n /* Traverse use-def links for all the pointers in the program to collect\n    address escape and points-to information.\n    \n@@ -689,6 +721,7 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t      var_ann_t v_ann = var_ann (SSA_NAME_VAR (op));\n \t      struct ptr_info_def *pi;\n \t      bool is_store;\n+\t      unsigned num_uses, num_derefs;\n \n \t      /* If the operand's variable may be aliased, keep track\n \t\t of how many times we've referenced it.  This is used\n@@ -706,7 +739,10 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t      collect_points_to_info_for (ai, op);\n \n \t      pi = SSA_NAME_PTR_INFO (op);\n-\t      if (ptr_is_dereferenced_by (op, stmt, &is_store))\n+\t      count_uses_and_derefs (op, stmt, &num_uses, &num_derefs,\n+\t\t\t\t     &is_store);\n+\n+\t      if (num_derefs > 0)\n \t\t{\n \t\t  /* Mark OP as dereferenced.  In a subsequent pass,\n \t\t     dereferenced pointers that point to a set of\n@@ -728,12 +764,13 @@ compute_points_to_and_addr_escape (struct alias_info *ai)\n \t\t  else\n \t\t    bitmap_set_bit (ai->dereferenced_ptrs_load, v_ann->uid);\n \t\t}\n-\t      else if (stmt_escapes_p)\n+\n+\t      if (stmt_escapes_p && num_derefs < num_uses)\n \t\t{\n-\t\t  /* Note that even if STMT is an escape point, pointer OP\n-\t\t     will not escape if it is being dereferenced.  That's\n-\t\t     why we only check for escape points if OP is not\n-\t\t     dereferenced by STMT.  */\n+\t\t  /* If STMT is an escape point and STMT contains at\n+\t\t     least one direct use of OP, then the value of OP\n+\t\t     escapes and so the pointed-to variables need to\n+\t\t     be marked call-clobbered.  */\n \t\t  pi->value_escapes_p = 1;\n \n \t\t  /* If the statement makes a function call, assume\n@@ -1742,6 +1779,8 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \n   if (orig_pi)\n     {\n+      gcc_assert (orig_pi != dest_pi);\n+\n       /* Notice that we never merge PT_MALLOC.  This attribute is only\n \t true if the pointer is the result of a malloc() call.\n \t Otherwise, we can end up in this situation:\n@@ -1761,13 +1800,12 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \t create_name_tags is not smart enough to determine that the\n \t two come from the same malloc call.  Copy propagation before\n \t aliasing should cure this.  */\n-      gcc_assert (orig_pi != dest_pi);\n-      \n       dest_pi->pt_malloc = 0;\n-\n       if (orig_pi->pt_malloc || orig_pi->pt_anything)\n \tset_pt_anything (dest);\n \n+      dest_pi->pt_null |= orig_pi->pt_null;\n+\n       if (!dest_pi->pt_anything\n \t  && orig_pi->pt_vars\n \t  && !bitmap_empty_p (orig_pi->pt_vars))\n@@ -1853,6 +1891,11 @@ add_pointed_to_expr (struct alias_info *ai, tree ptr, tree expr)\n \t       && TREE_CODE (op1) != INTEGER_CST))\n \tset_pt_anything (ptr);\n     }\n+  else if (integer_zerop (expr))\n+    {\n+      /* EXPR is the NULL pointer.  Mark PTR as pointing to NULL.  */\n+      SSA_NAME_PTR_INFO (ptr)->pt_null = 1;\n+    }\n   else\n     {\n       /* If we can't recognize the expression, assume that PTR may\n@@ -2356,6 +2399,9 @@ dump_points_to_info_for (FILE *file, tree ptr)\n       if (pi->pt_malloc)\n \tfprintf (file, \", points-to malloc\");\n \n+      if (pi->pt_null)\n+\tfprintf (file, \", points-to NULL\");\n+\n       if (pi->pt_vars)\n \t{\n \t  unsigned ix;\n@@ -2511,4 +2557,3 @@ may_be_aliased (tree var)\n \n   return true;\n }\n-"}]}