{"sha": "501990bbfca586dd26a941f65fce7b7a5a9440ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAxOTkwYmJmY2E1ODZkZDI2YTk0MWY2NWZjZTdiN2E1YTk0NDBhZQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@cat.daikokuya.demon.co.uk", "date": "2001-06-27T06:55:29Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-06-27T06:55:29Z"}, "message": "system.h (TARGET_ESC): Move to ...\n\n\t* system.h (TARGET_ESC): Move to ...\n\t* defaults.h (TARGET_ESC): ... here.\n\t* target-def.h (TARGET_VALID_DECL_ATTRIBUTE,\n\tTARGET_VALID_TYPE_ATTRIBUTE): Default to a no-op handler.\n\t* tree.c (default_valid_attribute_p): New.\n\t(valid_machine_attribute): Handlers can not be NULL.\n\t* tree.h (default_valid_attribute_p): New.\n\t* doc/tm.texi: Document TARGET_ESC.\n\t* cp/decl2.c (import_export_class): Update.\n\nFrom-SVN: r43605", "tree": {"sha": "9362672ad53c9697b55642ba54ba293d0e394ede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9362672ad53c9697b55642ba54ba293d0e394ede"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/501990bbfca586dd26a941f65fce7b7a5a9440ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501990bbfca586dd26a941f65fce7b7a5a9440ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/501990bbfca586dd26a941f65fce7b7a5a9440ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501990bbfca586dd26a941f65fce7b7a5a9440ae/comments", "author": null, "committer": null, "parents": [{"sha": "84690a975d2dc7a0172c3686eb43e6ea2047b969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84690a975d2dc7a0172c3686eb43e6ea2047b969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84690a975d2dc7a0172c3686eb43e6ea2047b969"}], "stats": {"total": 224, "additions": 150, "deletions": 74}, "files": [{"sha": "2d087cd88abbdf7c8ca2e2b7d556c94beb5f9b3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -1,3 +1,15 @@\n+2001-06-27  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* system.h (TARGET_ESC): Move to ...\n+\t* defaults.h (TARGET_ESC): ... here.\n+\t* target-def.h (TARGET_VALID_DECL_ATTRIBUTE,\n+\tTARGET_VALID_TYPE_ATTRIBUTE): Default to a no-op handler.\n+\t* tree.c (default_valid_attribute_p): New.\n+\t(valid_machine_attribute): Handlers can not be NULL.\n+\t* tree.h (default_valid_attribute_p): New.\n+\t* doc/tm.texi: Document TARGET_ESC.\n+\t* cp/decl2.c (import_export_class): Update.\n+\n 2001-06-26  Bruce Korb  <bkorb@gnu.org>\n \n \t* gcc/fixinc/fixincl.c(initialize): In very strict ANSI, you cannot"}, {"sha": "4e1abdaccf21f75d4454b3f77d4125794ed7c1c4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -1,3 +1,7 @@\n+2001-06-27  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* decl2.c (import_export_class): Update.\n+\n 2001-06-26  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* error.c (init_error): Adjust settings."}, {"sha": "802ad49d867d60e24bc6a96ad8907c688d8f4704", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -2456,15 +2456,18 @@ import_export_class (ctype)\n   if (CLASSTYPE_INTERFACE_ONLY (ctype))\n     return;\n \n-  if (target.valid_type_attribute != NULL)\n-    {\n-      /* FIXME this should really use some sort of target-independent\n-         macro.  */\n-      if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (ctype)))\n-\timport_export = -1;\n-      else if (lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (ctype)))\n-\timport_export = 1;\n-    }\n+  if ((*target.valid_type_attribute) (ctype,\n+\t\t\t\t      TYPE_ATTRIBUTES (ctype),\n+\t\t\t\t      get_identifier (\"dllimport\"),\n+\t\t\t\t      NULL_TREE)\n+      && lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (ctype)))\n+    import_export = -1;\n+  else if ((*target.valid_type_attribute) (ctype,\n+\t\t\t\t\t   TYPE_ATTRIBUTES (ctype),\n+\t\t\t\t\t   get_identifier (\"dllexport\"),\n+\t\t\t\t\t   NULL_TREE)\n+\t   && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (ctype)))\n+    import_export = 1;\n \n   /* If we got -fno-implicit-templates, we import template classes that\n      weren't explicitly instantiated.  */"}, {"sha": "c22f9cd997f34125f510b1dac3d9802537ec4708", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #  define TARGET_VT 013\n #  define TARGET_FF 014\n #  define TARGET_CR 015\n+#  define TARGET_ESC 033\n #endif\n \n /* Store in OUTPUT a string (made with alloca) containing"}, {"sha": "e60a4eb55a2169f703712f2148d6be7ee9e9d466", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -12,6 +12,19 @@\n \n In addition to the file @file{@var{machine}.md}, a machine description\n includes a C header file conventionally given the name\n+<<<<<<< tm.texi\n+@file{@var{machine}.h} and a C source file named @file{@var{machine}.c}.\n+The header file defines numerous macros that convey the information\n+about the target machine that does not fit into the scheme of the\n+@file{.md} file.  The file @file{tm.h} should be a link to\n+@file{@var{machine}.h}.  The header file @file{config.h} includes\n+@file{tm.h} and most compiler source files include @file{config.h}.  The\n+source file defines a variable @code{target}, which is a structure\n+containing pointers to functions and data relating to the target\n+machine.  @file{@var{machine}.c} should also their definitions, if they\n+are not defined elsewhere in GCC, and other functions called through the\n+macros defined in the @file{.h} file.\n+=======\n @file{@var{machine}.h} and a C source file named @file{@var{machine}.c}.\n The header file defines numerous macros that convey the information\n about the target machine that does not fit into the scheme of the\n@@ -23,6 +36,7 @@ containing pointers to functions and data relating to the target\n machine.  @file{@var{machine}.c} should also contain their definitions,\n if they are not defined elsewhere in GCC, and other functions called\n through the macros defined in the @file{.h} file.\n+>>>>>>> 1.11\n \n @menu\n * Target Structure::    The @code{target} variable.\n@@ -1581,6 +1595,12 @@ explicitly define all of the macros below.\n A C constant expression for the integer value for escape sequence\n @samp{\\a}.\n \n+@findex TARGET_ESC\n+@item TARGET_ESC\n+A C constant expression for the integer value of the target escape\n+character.  As an extension, GCC evaluates the escape sequences\n+@samp{\\e} and @samp{\\E} to this.\n+\n @findex TARGET_TAB\n @findex TARGET_BS\n @findex TARGET_NEWLINE\n@@ -8300,6 +8320,33 @@ If defined, a C statement that assigns default attributes to\n newly defined @var{type}.\n @end table\n \n+<<<<<<< tm.texi\n+@deftypefn {Target Hook} tree TARGET_MERGE_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})\n+Define this target hook if the merging of type attributes needs special\n+handling.  If defined, the result is a list of the combined\n+@code{TYPE_ATTRIBUTES} of @var{type1} and @var{type2}.  It is assumed\n+that @code{comptypes} has already been called and returned 1.  This\n+function may call @code{merge_attributes} to handle machine-independent\n+merging.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_MERGE_DECL_ATTRIBUTES (tree @var{olddecl}, tree @var{newdecl})\n+Define this target hook if the merging of decl attributes needs special\n+handling.  If defined, the result is a list of the combined\n+@code{DECL_MACHINE_ATTRIBUTES} of @var{olddecl} and @var{newdecl}.\n+@var{newdecl} is a duplicate declaration of @var{olddecl}.  Examples of\n+when this is needed are when one attribute overrides another, or when an\n+attribute is nullified by a subsequent definition.  This function may\n+call @code{merge_attributes} to handle machine-independent merging.\n+\n+If the only target-specific handling you require is @samp{dllimport} for\n+Windows targets, you should define the macro\n+@code{TARGET_DLLIMPORT_DECL_ATTRIBUTES}.  This links in a function\n+called @code{merge_dllimport_decl_attributes} which you can then define\n+as the expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  This is done\n+in @file{i386/cygwin.h} and @file{i386/i386.c}, for example.\n+@end deftypefn\n+=======\n @deftypefn {Target Hook} tree TARGET_MERGE_TYPE_ATTRIBUTES (tree @var{type1}, tree @var{type2})\n Define this target hook if the merging of type attributes needs special\n handling.  If defined, the result is a list of the combined\n@@ -8326,6 +8373,7 @@ called @code{merge_dllimport_decl_attributes} which can then be defined\n as the expansion of @code{TARGET_MERGE_DECL_ATTRIBUTES}.  This is done\n in @file{i386/cygwin.h} and @file{i386/i386.c}, for example.\n @end deftypefn\n+>>>>>>> 1.11\n \n @table @code\n @findex INSERT_ATTRIBUTES"}, {"sha": "295c2870d970b77e455d6f4dfe6458c8ab808e0e", "filename": "gcc/system.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -84,11 +84,6 @@ extern int fputs_unlocked PARAMS ((const char *, FILE *));\n    replacement instead.  */\n #include <safe-ctype.h>\n \n-/* Define a default escape character; it's different for EBCDIC.  */\n-#ifndef TARGET_ESC\n-#define TARGET_ESC 033\n-#endif\n-\n #include <sys/types.h>\n \n #include <errno.h>"}, {"sha": "6860e06887ff0aeb3e53aeec82187c99eb6fbfa7", "filename": "gcc/tree.c", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -2707,6 +2707,19 @@ build_type_attribute_variant (ttype, attribute)\n   return ttype;\n }\n \n+/* Default value of target.valid_decl_attribute_p and\n+   target.valid_type_attribute_p that always returns false.  */\n+\n+int\n+default_valid_attribute_p PARAMS ((attr_name, attr_args, decl, type))\n+     tree attr_name ATTRIBUTE_UNUSED;\n+     tree attr_args ATTRIBUTE_UNUSED;\n+     tree decl ATTRIBUTE_UNUSED;\n+     tree type ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n /* Return 1 if ATTR_NAME and ATTR_ARGS is valid for either declaration\n    DECL or type TYPE and 0 otherwise.  Validity is determined the\n    target functions valid_decl_attribute and valid_machine_attribute.  */\n@@ -2718,10 +2731,12 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n      tree decl;\n      tree type;\n {\n+  tree type_attrs;\n+\n   if (TREE_CODE (attr_name) != IDENTIFIER_NODE)\n     abort ();\n \n-  if (decl && target.valid_decl_attribute != NULL)\n+  if (decl)\n     {\n       tree decl_attrs = DECL_MACHINE_ATTRIBUTES (decl);\n \n@@ -2748,75 +2763,70 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \t}\n     }\n \n-  if (target.valid_type_attribute != NULL)\n+  type_attrs = TYPE_ATTRIBUTES (type);\n+  if ((*target.valid_type_attribute) (type, type_attrs, attr_name,\n+\t\t\t\t      attr_args))\n     {\n-      tree type_attrs = TYPE_ATTRIBUTES (type);\n+      tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n+\t\t\t\t    type_attrs);\n \n-      if ((*target.valid_type_attribute) (type, type_attrs, attr_name,\n-\t\t\t\t\t  attr_args))\n+      if (attr != NULL_TREE)\n \t{\n-\t  tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n-\t\t\t\t\ttype_attrs);\n-\n-\t  if (attr != NULL_TREE)\n-\t    {\n-\t      /* Override existing arguments.  ??? This currently\n-\t\t works since attribute arguments are not included in\n-\t\t `attribute_hash_list'.  Something more complicated\n-\t\t may be needed in the future.  */\n-\t      TREE_VALUE (attr) = attr_args;\n-\t    }\n+\t  /* Override existing arguments.  ??? This currently\n+\t     works since attribute arguments are not included in\n+\t     `attribute_hash_list'.  Something more complicated\n+\t     may be needed in the future.  */\n+\t  TREE_VALUE (attr) = attr_args;\n+\t}\n+      else\n+\t{\n+\t  /* If this is part of a declaration, create a type variant,\n+\t     otherwise, this is part of a type definition, so add it\n+\t     to the base type.  */\n+\t  type_attrs = tree_cons (attr_name, attr_args, type_attrs);\n+\t  if (decl != 0)\n+\t    type = build_type_attribute_variant (type, type_attrs);\n \t  else\n-\t    {\n-\t      /* If this is part of a declaration, create a type variant,\n-\t\t otherwise, this is part of a type definition, so add it\n-\t\t to the base type.  */\n-\t      type_attrs = tree_cons (attr_name, attr_args, type_attrs);\n-\t      if (decl != 0)\n-\t\ttype = build_type_attribute_variant (type, type_attrs);\n-\t      else\n-\t\tTYPE_ATTRIBUTES (type) = type_attrs;\n-\t    }\n-\n-\t  if (decl)\n-\t    TREE_TYPE (decl) = type;\n-\n-\t  return 1;\n+\t    TYPE_ATTRIBUTES (type) = type_attrs;\n \t}\n \n-      /* Handle putting a type attribute on pointer-to-function-type\n-\t by putting the attribute on the function type.  */\n-      else if (POINTER_TYPE_P (type)\n-\t       && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-\t       && (*target.valid_type_attribute) (TREE_TYPE (type), type_attrs,\n-\t\t\t\t\t\t  attr_name, attr_args))\n-\t{\n-\t  tree inner_type = TREE_TYPE (type);\n-\t  tree inner_attrs = TYPE_ATTRIBUTES (inner_type);\n-\t  tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n-\t\t\t\t\ttype_attrs);\n+      if (decl)\n+\tTREE_TYPE (decl) = type;\n \n-\t  if (attr != NULL_TREE)\n-\t    TREE_VALUE (attr) = attr_args;\n-\t  else\n-\t    {\n-\t      inner_attrs = tree_cons (attr_name, attr_args, inner_attrs);\n-\t      inner_type = build_type_attribute_variant (inner_type,\n-\t\t\t\t\t\t\t inner_attrs);\n-\t    }\n+      return 1;\n+    }\n+  /* Handle putting a type attribute on pointer-to-function-type\n+     by putting the attribute on the function type.  */\n+  else if (POINTER_TYPE_P (type)\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n+\t   && (*target.valid_type_attribute) (TREE_TYPE (type), type_attrs,\n+\t\t\t\t\t      attr_name, attr_args))\n+    {\n+      tree inner_type = TREE_TYPE (type);\n+      tree inner_attrs = TYPE_ATTRIBUTES (inner_type);\n+      tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n+\t\t\t\t    type_attrs);\n \n-\t  if (decl)\n-\t    TREE_TYPE (decl) = build_pointer_type (inner_type);\n-\t  else\n-\t    {\n-\t      /* Clear TYPE_POINTER_TO for the old inner type, since\n-\t\t `type' won't be pointing to it anymore.  */\n-\t      TYPE_POINTER_TO (TREE_TYPE (type)) = NULL_TREE;\n-\t      TREE_TYPE (type) = inner_type;\n-\t    }\n+      if (attr != NULL_TREE)\n+\tTREE_VALUE (attr) = attr_args;\n+      else\n+\t{\n+\t  inner_attrs = tree_cons (attr_name, attr_args, inner_attrs);\n+\t  inner_type = build_type_attribute_variant (inner_type,\n+\t\t\t\t\t\t     inner_attrs);\n+\t}\n \n-\t  return 1;\n+      if (decl)\n+\tTREE_TYPE (decl) = build_pointer_type (inner_type);\n+      else\n+\t{\n+\t  /* Clear TYPE_POINTER_TO for the old inner type, since\n+\t     `type' won't be pointing to it anymore.  */\n+\t  TYPE_POINTER_TO (TREE_TYPE (type)) = NULL_TREE;\n+\t  TREE_TYPE (type) = inner_type;\n \t}\n+\n+      return 1;\n     }\n \n   return 0;"}, {"sha": "0d69d6bd199c664319fd93c5331e42ac1d6c7dd7", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501990bbfca586dd26a941f65fce7b7a5a9440ae/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=501990bbfca586dd26a941f65fce7b7a5a9440ae", "patch": "@@ -2039,8 +2039,11 @@ extern tree make_tree\t\t\tPARAMS ((tree, struct rtx_def *));\n extern tree build_type_attribute_variant PARAMS ((tree, tree));\n extern tree build_decl_attribute_variant PARAMS ((tree, tree));\n \n+/* Default versions of target-overridable functions.  */\n+\n extern tree merge_decl_attributes PARAMS ((tree, tree));\n extern tree merge_type_attributes PARAMS ((tree, tree));\n+extern int default_valid_attribute_p PARAMS ((tree, tree, tree, tree));\n \n /* Split a list of declspecs and attributes into two.  */\n "}]}