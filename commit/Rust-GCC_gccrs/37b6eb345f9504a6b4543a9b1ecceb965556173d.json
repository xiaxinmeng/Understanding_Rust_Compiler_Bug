{"sha": "37b6eb345f9504a6b4543a9b1ecceb965556173d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiNmViMzQ1Zjk1MDRhNmI0NTQzYTliMWVjY2ViOTY1NTU2MTczZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-11-24T02:33:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-24T02:33:48Z"}, "message": "class.c (add_method): Build up OVERLOADs properly for conversion ops.\n\n\t* class.c (add_method): Build up OVERLOADs properly for conversion ops.\n\t* search.c (lookup_conversions): Handle getting real OVERLOADs.\n\t(add_conversions): Likewise.  Revert last change.\n\t* call.c (add_conv_candidate): Pass totype to add_candidate instead\n\tof fn.  Don't add a new candidate if the last one was for the same\n\ttype.\n\t(print_z_candidates): Handle getting a type as a function.\n\t(joust): If we got two conversion candidates to the same type,\n\tjust pick one.\n\t(build_object_call): Lose 'templates'.\n\t(build_user_type_conversion_1): Handle getting real OVERLOADs.\nFixes g++.jason/overload7.C.\n\nFrom-SVN: r23822", "tree": {"sha": "affd988f12b804dac1f96dc76b3a1879701f5aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/affd988f12b804dac1f96dc76b3a1879701f5aeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37b6eb345f9504a6b4543a9b1ecceb965556173d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b6eb345f9504a6b4543a9b1ecceb965556173d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b6eb345f9504a6b4543a9b1ecceb965556173d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b6eb345f9504a6b4543a9b1ecceb965556173d/comments", "author": null, "committer": null, "parents": [{"sha": "52e1eb536c07b16813c1ed39e5bf40be0b8845b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e1eb536c07b16813c1ed39e5bf40be0b8845b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e1eb536c07b16813c1ed39e5bf40be0b8845b7"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "92fed9792e49ee2b7bb5aa016f71d2bbe5905bf2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37b6eb345f9504a6b4543a9b1ecceb965556173d", "patch": "@@ -1,3 +1,17 @@\n+1998-11-24  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (add_method): Build up OVERLOADs properly for conversion ops.\n+\t* search.c (lookup_conversions): Handle getting real OVERLOADs.\n+\t(add_conversions): Likewise.  Revert last change.\n+\t* call.c (add_conv_candidate): Pass totype to add_candidate instead\n+\tof fn.  Don't add a new candidate if the last one was for the same \n+\ttype.\n+\t(print_z_candidates): Handle getting a type as a function.\n+\t(joust): If we got two conversion candidates to the same type, \n+\tjust pick one.\n+\t(build_object_call): Lose 'templates'.\n+\t(build_user_type_conversion_1): Handle getting real OVERLOADs.\n+\n 1998-11-23  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck2.c (process_init_constructor): If there are elements"}, {"sha": "8904aa1ccc9de4988ec352350f7bf1a403fc5790", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=37b6eb345f9504a6b4543a9b1ecceb965556173d", "patch": "@@ -1217,7 +1217,13 @@ add_function_candidate (candidates, fn, arglist, flags)\n /* Create an overload candidate for the conversion function FN which will\n    be invoked for expression OBJ, producing a pointer-to-function which\n    will in turn be called with the argument list ARGLIST, and add it to\n-   CANDIDATES.  FLAGS is passed on to implicit_conversion.  */\n+   CANDIDATES.  FLAGS is passed on to implicit_conversion.\n+\n+   Actually, we don't really care about FN; we care about the type it\n+   converts to.  There may be multiple conversion functions that will\n+   convert to that type, and we rely on build_user_type_conversion_1 to\n+   choose the best one; so when we create our candidate, we record the type\n+   instead of the function.  */\n \n static struct z_candidate *\n add_conv_candidate (candidates, fn, obj, arglist)\n@@ -1233,6 +1239,10 @@ add_conv_candidate (candidates, fn, obj, arglist)\n   int viable = 1;\n   int flags = LOOKUP_NORMAL;\n \n+  /* Don't bother looking up the same type twice.  */\n+  if (candidates && candidates->fn == totype)\n+    return candidates;\n+\n   for (i = 0; i < len; ++i)\n     {\n       tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n@@ -1277,7 +1287,7 @@ add_conv_candidate (candidates, fn, obj, arglist)\n \tbreak;\n       }\n \n-  return add_candidate (candidates, fn, convs, viable);\n+  return add_candidate (candidates, totype, convs, viable);\n }\n \n static struct z_candidate *\n@@ -2058,6 +2068,8 @@ print_z_candidates (candidates)\n \t    cp_error (\"%s %D(%T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n \t}\n+      else if (TYPE_P (candidates->fn))\n+\tcp_error (\"%s %T <conversion>\", str, candidates->fn);\n       else\n \tcp_error_at (\"%s %+D%s\", str, candidates->fn,\n \t\t     candidates->viable == -1 ? \" <near match>\" : \"\");\n@@ -2143,7 +2155,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n       if (TREE_CODE (totype) == REFERENCE_TYPE)\n \tconvflags |= LOOKUP_NO_TEMP_BIND;\n \n-      if (TREE_CODE (fns) != TEMPLATE_DECL)\n+      if (TREE_CODE (OVL_CURRENT (fns)) != TEMPLATE_DECL)\n \tics = implicit_conversion\n \t  (totype, TREE_TYPE (TREE_TYPE (OVL_CURRENT (fns))), 0, convflags);\n       else\n@@ -2369,7 +2381,6 @@ build_object_call (obj, args)\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, mem_args = NULL_TREE;\n   tree type = TREE_TYPE (obj);\n-  tree templates = NULL_TREE;\n \n   if (TYPE_PTRMEMFUNC_P (type))\n     {\n@@ -2399,7 +2410,6 @@ build_object_call (obj, args)\n \t  tree fn = OVL_CURRENT (fns);\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n-\t      templates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  mem_args, NULL_TREE, \n@@ -2429,7 +2439,6 @@ build_object_call (obj, args)\n \t    tree fn = OVL_CURRENT (fns);\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL) \n \t      {\n-\t\ttemplates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = add_template_conv_candidate (candidates,\n \t\t\t\t\t\t\t  fn,\n \t\t\t\t\t\t\t  obj,\n@@ -4219,6 +4228,11 @@ joust (cand1, cand2, warn)\n   if (cand1->viable < cand2->viable)\n     return -1;\n \n+  /* If we have two pseudo-candidates for conversions to the same type,\n+     arbitrarily pick one.  */\n+  if (TYPE_P (cand1->fn) && cand1->fn == cand2->fn)\n+    return 1;\n+\n   /* a viable function F1\n      is defined to be a better function than another viable function F2  if\n      for  all arguments i, ICSi(F1) is not a worse conversion sequence than"}, {"sha": "de283eae2ddea8c5b6b35cbc6983e796f07a75e5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=37b6eb345f9504a6b4543a9b1ecceb965556173d", "patch": "@@ -1235,7 +1235,9 @@ add_method (type, fields, method)\n \t\t}\n \t    }\n \n-\t  if (DECL_CONV_FN_P (method))\n+\t  if (TREE_VEC_ELT (method_vec, i))\n+\t    /* We found a match.  */;\n+\t  else if (DECL_CONV_FN_P (method))\n \t    {\n \t      /* Type conversion operators have to come before\n \t\t ordinary methods; add_conversions depends on this to"}, {"sha": "d0ae536ea7aee03be65ff0a91eb73dbd189f96bd", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b6eb345f9504a6b4543a9b1ecceb965556173d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=37b6eb345f9504a6b4543a9b1ecceb965556173d", "patch": "@@ -3302,40 +3302,24 @@ add_conversions (binfo)\n {\n   int i;\n   tree method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n-  tree name = NULL_TREE;\n \n   for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n     {\n       tree tmp = TREE_VEC_ELT (method_vec, i);\n+      tree name;\n \n       if (!tmp || ! DECL_CONV_FN_P (OVL_CURRENT (tmp)))\n \tbreak;\n \n-      if (TREE_CODE (tmp) == OVERLOAD)\n-\t{\n-\t  my_friendly_assert (TREE_CHAIN (tmp) == NULL_TREE, 981121);\n-\t  tmp = OVL_FUNCTION (tmp);\n-\t}\n-\n-      /* We don't want to mark 'name' until we've seen all the overloads\n-\t in this class; we could be overloading on the quals of 'this'.  */\n-      if (name && name != DECL_NAME (tmp))\n-\t{\n-\t  IDENTIFIER_MARKED (name) = 1;\n-\t  name = NULL_TREE;\n-\t}\n+      name = DECL_NAME (OVL_CURRENT (tmp));\n \n       /* Make sure we don't already have this conversion.  */\n-      if (! IDENTIFIER_MARKED (DECL_NAME (tmp)))\n+      if (! IDENTIFIER_MARKED (name))\n \t{\n \t  conversions = scratch_tree_cons (binfo, tmp, conversions);\n-\t  name = DECL_NAME (tmp);\n+\t  IDENTIFIER_MARKED (name) = 1;\n \t}\n     }\n-\n-  if (name)\n-     IDENTIFIER_MARKED (name) = 1;\n-\n   return NULL_TREE;\n }\n \n@@ -3351,7 +3335,7 @@ lookup_conversions (type)\n     breadth_first_search (TYPE_BINFO (type), add_conversions, 0);\n \n   for (t = conversions; t; t = TREE_CHAIN (t))\n-    IDENTIFIER_MARKED (DECL_NAME (TREE_VALUE (t))) = 0;\n+    IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (t)))) = 0;\n \n   return conversions;\n }"}]}