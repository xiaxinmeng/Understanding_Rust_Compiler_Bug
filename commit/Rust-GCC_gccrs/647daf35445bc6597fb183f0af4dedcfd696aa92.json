{"sha": "647daf35445bc6597fb183f0af4dedcfd696aa92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ3ZGFmMzU0NDViYzY1OTdmYjE4M2YwYWY0ZGVkY2ZkNjk2YWE5Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-08T11:12:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-08T11:12:04Z"}, "message": "Initial revision\n\nFrom-SVN: r173", "tree": {"sha": "b2a32b91c9071065fd0ff8dfeef04b21ada76c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2a32b91c9071065fd0ff8dfeef04b21ada76c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/647daf35445bc6597fb183f0af4dedcfd696aa92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647daf35445bc6597fb183f0af4dedcfd696aa92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/647daf35445bc6597fb183f0af4dedcfd696aa92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647daf35445bc6597fb183f0af4dedcfd696aa92/comments", "author": null, "committer": null, "parents": [{"sha": "66954a387154c75fa317f495ab0f8917d157568d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66954a387154c75fa317f495ab0f8917d157568d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66954a387154c75fa317f495ab0f8917d157568d"}], "stats": {"total": 6306, "additions": 6306, "deletions": 0}, "files": [{"sha": "4e7ea5a99f0e2a5234be647b1f6bde8db566305a", "filename": "gcc/config/convex/convex.md", "status": "added", "additions": 1334, "deletions": 0, "changes": 1334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647daf35445bc6597fb183f0af4dedcfd696aa92/gcc%2Fconfig%2Fconvex%2Fconvex.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647daf35445bc6597fb183f0af4dedcfd696aa92/gcc%2Fconfig%2Fconvex%2Fconvex.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.md?ref=647daf35445bc6597fb183f0af4dedcfd696aa92", "patch": "@@ -0,0 +1,1334 @@\n+;;- Machine description for GNU compiler\n+;;- Convex Version\n+;;   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+;; Scheduling defs\n+;;\n+;; Insn scheduling is not used at present.  Scheduling increases\n+;; register pressure so much that many spills are generated\n+;; even for very small functions.\n+\n+;; Compares\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"* return set_cmp (operands[0], const0_rtx, 'w');\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"* return set_cmp (operands[0], const0_rtx, 'h');\")\n+\n+(define_expand \"tstqi\"\n+  [(set (match_dup 1)\n+\t(sign_extend:SI (match_operand:QI 0 \"register_operand\" \"r\")))\n+   (set (cc0)\n+\t(match_dup 1))]\n+  \"\"\n+  \"operands[1] = gen_reg_rtx (SImode);\")\n+\n+(define_expand \"tstdi\"\n+  [(parallel [(set (cc0) (match_operand:DI 0 \"register_operand\" \"d\"))\n+\t      (use (match_dup 1))])]\n+  \"\"\n+  \"operands[1] = force_reg (DImode, const0_rtx);\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (match_operand:DI 0 \"register_operand\" \"d\"))\n+   (use (match_operand:DI 1 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 'l');\")\n+\n+(define_expand \"tstdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"register_operand\" \"d\")\n+\t\t (match_dup 1)))]\n+  \"\"\n+  \"operands[1] = force_reg (DFmode, CONST0_RTX (DFmode));\")\n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"register_operand\" \"d\"))]\n+  \"\"\n+  \"* return set_cmp (operands[0], CONST0_RTX (SFmode), 's');\")\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"d,a,i,r\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"d,a,r,i\")))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 'w');\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"d,a,r,i\")\n+\t\t (match_operand:HI 1 \"nonmemory_operand\" \"d,a,i,r\")))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 'h');\")\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"register_operand\" \"d\")\n+\t\t (match_operand:QI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 'b');\")\n+\n+(define_insn \"cmpdi\"\n+  [(set (cc0)\n+\t(compare (match_operand:DI 0 \"register_operand\" \"d\")\n+\t\t (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 'l');\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"register_operand\" \"d\")\n+\t\t (match_operand:DF 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 'd');\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"nonmemory_operand\" \"dF,d\")\n+\t\t (match_operand:SF 1 \"nonmemory_operand\" \"d,F\")))]\n+  \"\"\n+  \"* return set_cmp (operands[0], operands[1], 's');\")\n+\f\n+;; Moves\n+\n+;(define_insn \"movtf\"\n+;  [(set (match_operand:TF 0 \"general_operand\" \"=g,d\")\n+;\t(match_operand:TF 1 \"general_operand\" \"d,g\"))]\n+;  \"\"\n+;  \"*\n+;{\n+;  rtx opaddr = 0;\n+;  rtx xoperands[4];\n+;  xoperands[0] = operands[0];\n+;  xoperands[2] = operands[1];\n+;\n+;  if (REG_P (operands[0]))\n+;    xoperands[1] = gen_rtx (REG, TFmode, REGNO (operands[0]) + 1);\n+;  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+;    xoperands[1] = 0;\n+;  else if (offsettable_memref_p (operands[0]))\n+;    xoperands[1] = adj_offsettable_operand (operands[0], 8);\n+;  else\n+;    {\n+;      opaddr = XEXP (operands[0], 0);\n+;      xoperands[0] = gen_rtx (MEM, TFmode, gen_rtx (REG, SImode, 13));\n+;      xoperands[1] = adj_offsettable_operand (xoperands[0], 8);\n+;    }\n+;\n+;  if (REG_P (operands[1]))\n+;    xoperands[3] = gen_rtx (REG, TFmode, REGNO (operands[1]) + 1);\n+;  else if (offsettable_memref_p (operands[1]))\n+;    xoperands[3] = adj_offsettable_operand (operands[1], 8);\n+;  else\n+;    {\n+;      opaddr = XEXP (operands[1], 0);\n+;      xoperands[2] = gen_rtx (MEM, TFmode, gen_rtx (REG, SImode, 13));\n+;      xoperands[3] = adj_offsettable_operand (xoperands[2], 8);\n+;    }\n+;\n+;  if (opaddr)\n+;    output_asm_insn (\\\"psh.w a5\\;ld.w %0,a5\\\", &opaddr);\n+;  if (push_operand (operands[0], TFmode))\n+;    output_asm_insn (\\\"psh.l %3\\;psh.l %2\\\", xoperands);\n+;  else if (GET_CODE (operands[0]) == MEM)\n+;    output_asm_insn (\\\"st.l %2,%0\\;st.l %3,%1\\\", xoperands);\n+;  else if (GET_CODE (operands[1]) == REG)\n+;    output_asm_insn (\\\"mov %2,%0\\;mov %3,%1\\\", xoperands);\n+;  else\n+;    output_asm_insn (\\\"ld.l %2,%0\\;ld.l %3,%1\\\", xoperands);\n+;  if (opaddr)\n+;    output_asm_insn (\\\"pop.w a5\\\");\n+;  return \\\"\\\";\n+;}\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=g,d\")\n+\t(match_operand:DF 1 \"general_operand\" \"d,dmG\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], DFmode))\n+    return \\\"psh.l %1\\\";\n+  else if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.l %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == REG)\n+    return \\\"mov %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE && LD_D_P (operands[1]))\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     const_double_high_int (operands[1]));\n+      return \\\"ld.d %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE && LD_L_P (operands[1]))\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     const_double_low_int (operands[1]));\n+      return \\\"ld.l %1,%0\\\";\n+    }\n+  else\n+    return \\\"ld.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=g,d\")\n+\t(match_operand:SF 1 \"general_operand\" \"d,gF\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], SFmode))\n+    return \\\"psh.w %1\\\";\n+  else if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.s %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == REG)\n+    return \\\"mov.s %1,%0\\\";\n+  else\n+    return \\\"ld.s %1,%0\\\";\n+}\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g,d\")\n+\t(match_operand:DI 1 \"general_operand\" \"d,dmiG\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], DImode))\n+    return \\\"psh.l %1\\\";\n+  else if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.l %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == REG)\n+    return \\\"mov %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE && LD_D_P (operands[1]))\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     const_double_high_int (operands[1]));\n+      return \\\"ld.d %1,%0\\\";\n+    }\n+  else\n+    return \\\"ld.l %1,%0\\\";\n+}\")\n+\n+;; Special case of movsi, needed to express A-reg preference.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"a\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"operands[1] != stack_pointer_rtx\"\n+  \"pshea %a2(%1)\")\n+\n+;; General movsi.  Constraints will be selected based on TARGET_INDIRECTS\n+;; to avoid indirect addressing on C3, where it is slow.\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,r,<\")\n+\t(match_operand:SI 1 \"general_operand\" \"r,g,io\"))]\n+  \"TARGET_INDIRECTS\"\n+  \"*\n+{ \n+  if (push_operand (operands[0], SImode))\n+    {\n+      if (GET_CODE (operands[1]) == REG)\n+\treturn \\\"psh.w %1\\\";\n+      else\n+        return \\\"pshea %a1\\\";\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.w %1,%0\\\";\n+  if (GET_CODE (operands[1]) != REG)\n+    return \\\"ld.w %1,%0\\\";\n+  if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n+    return \\\"mov.w %1,%0\\\";\n+  return \\\"mov %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,r,<\")\n+\t(match_operand:SI 1 \"general_operand\" \"r,g,i\"))]\n+  \"! TARGET_INDIRECTS\"\n+  \"*\n+{ \n+  if (push_operand (operands[0], SImode))\n+    {\n+      if (GET_CODE (operands[1]) == REG)\n+\treturn \\\"psh.w %1\\\";\n+      else\n+        return \\\"pshea %a1\\\";\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.w %1,%0\\\";\n+  if (GET_CODE (operands[1]) != REG)\n+    return \\\"ld.w %1,%0\\\";\n+  if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n+    return \\\"mov.w %1,%0\\\";\n+  return \\\"mov %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstrictsi\"\n+  [(set (strict_low_part (match_operand:SI 0 \"general_operand\" \"=g,r\"))\n+\t(match_operand:SI 1 \"general_operand\" \"r,g\"))]\n+  \"\"\n+  \"*\n+{ \n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.w %1,%0\\\";\n+  if (GET_CODE (operands[1]) != REG)\n+    return \\\"ld.w %1,%0\\\";\n+  if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n+    return \\\"mov.w %1,%0\\\";\n+  return \\\"mov %1,%0\\\";\n+}\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g,r\")\n+\t(match_operand:HI 1 \"general_operand\" \"r,g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], HImode))\n+    abort ();\n+  else if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.h %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == REG) \n+    {\n+      if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n+\treturn \\\"mov.w %1,%0\\\";\n+      else\n+        return \\\"mov %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_INT)\n+    return \\\"ld.w %1,%0\\\";\n+  else\n+    return \\\"ld.h %1,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g,r\")\n+\t(match_operand:QI 1 \"general_operand\" \"r,g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], QImode))\n+    abort ();\n+  else if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.b %1,%0\\\";\n+  else if (GET_CODE (operands[1]) == REG)\n+    {\n+      if (S_REG_P (operands[0]) && S_REG_P (operands[1]))\n+\treturn \\\"mov.w %1,%0\\\";\n+      else\n+        return \\\"mov %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[1]) == CONST_INT)\n+    return \\\"ld.w %1,%0\\\";\n+  else\n+    return \\\"ld.b %1,%0\\\";\n+}\")\n+\f\n+;; Extension and truncation insns.\n+;; Those for integer source operand\n+;; are ordered widest source type first.\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n+\t(truncate:QI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"cvtw.b %1,%0\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(truncate:HI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"cvtw.h %1,%0\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"truncdisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(truncate:SI (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvtl.w %1,%0\")\n+\n+(define_insn \"extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvtw.l %1,%0\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"cvth.w %1,%0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"cvtb.w %1,%0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"cvtb.w %1,%0\")\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvts.d %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvtd.s %1,%0\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"and #0xffff,%0\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"and #0xff,%0\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"and #0xff,%0\")\n+\n+(define_insn \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"ld.u #0,%0\")\n+\f\n+;; Fix-to-float conversion insns.\n+;; Note that the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvtw.s %1,%0\")\n+\n+(define_insn \"floatdisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(float:SF (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvtl.s %1,%0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_C2\"\n+  \"cvtw.d %1,%0\")\n+\n+(define_insn \"floatdidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(float:DF (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"cvtl.d %1,%0\")\n+\f\n+;; Float-to-fix conversion insns.\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"cvts.w %1,%0\")\n+\n+(define_insn \"fix_truncsfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"cvts.l %1,%0\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_C2)\n+    return \\\"cvtd.w %1,%0\\\";\n+  return \\\"cvtd.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"fix_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"cvtd.l %1,%0\")\n+\f\n+;;- All kinds of add instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"add.d %2,%0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n+  \"\"\n+  \"add.s %2,%0\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"add.l %2,%0\")\n+\n+;; special case of addsi3, needed to specify an A reg for the destination \n+;; when the source is a sum involving FP or AP.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%a\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"operands[1] == frame_pointer_rtx || operands[1] == arg_pointer_rtx\"\n+  \"ldea %a2(%1),%0\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%0,0,a\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ri,i\")))]\n+  \"\"\n+  \"* switch (which_alternative) \n+{\n+ case 0:\n+ case 1: \n+   return \\\"add.w %2,%0\\\";\n+ case 2:\n+   if ((TARGET_C2 || A_REG_P (operands[0]))\n+       && operands[1] != stack_pointer_rtx)\n+     return \\\"ldea %a2(%1),%0\\\";\n+   else\n+     return \\\"mov %1,%0\\;add.w %2,%0\\\";\n+}\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"add.h %2,%0\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"add.b %2,%0\")\n+\f\n+;;- All kinds of subtract instructions.\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sub.d %2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n+  \"\"\n+  \"sub.s %2,%0\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sub.l %2,%0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"sub.w %2,%0\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"sub.h %2,%0\")\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n+\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:QI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"sub.b %2,%0\")\n+\f\n+;;- Multiply instructions.\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"mul.d %2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n+  \"\"\n+  \"mul.s %2,%0\")\n+\n+(define_insn \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"mul.l %2,%0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"mul.w %2,%0\")\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"mul.h %2,%0\")\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n+\t(mult:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"mul.b %2,%0\")\n+\f\n+;;- Divide instructions.\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"div.d %2,%0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"nonmemory_operand\" \"dF\")))]\n+  \"\"\n+  \"div.s %2,%0\")\n+\n+(define_insn \"divdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"div.l %2,%0\")\n+\n+(define_insn \"udivdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"psh.l %2\\;psh.l %1\\;callq udiv64\\;pop.l %0\\;add.w #8,sp\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"div.w %2,%0\")\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(div:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"div.h %2,%0\")\n+\n+(define_insn \"divqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n+\t(div:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"div.b %2,%0\")\n+\f\n+;; - and, or, xor\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"immediate_operand\" \"Fn\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\n+   || (GET_CODE (operands[2]) == CONST_DOUBLE\n+       && CONST_DOUBLE_HIGH (operands[2]) == -1)\"\n+  \"and %2,%0\")\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(and:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"and %2,%0\")\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"and %2,%0\")\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"and %2,%0\")\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n+\t(and:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"and %2,%0\")\n+\n+;;- Bit set instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"immediate_operand\" \"Fn\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\n+   || (GET_CODE (operands[2]) == CONST_DOUBLE\n+       && CONST_DOUBLE_HIGH (operands[2]) == 0)\"\n+  \"or %2,%0\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"or %2,%0\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"or %2,%0\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"or %2,%0\")\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n+\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"or %2,%0\")\n+\n+;;- xor instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"immediate_operand\" \"Fn\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\n+   || (GET_CODE (operands[2]) == CONST_DOUBLE\n+       && CONST_DOUBLE_HIGH (operands[2]) == 0)\"\n+  \"xor %2,%0\")\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"xor %2,%0\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"xor %2,%0\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(xor:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"xor %2,%0\")\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n+\t(xor:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"xor %2,%0\")\n+\f\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"neg.d %1,%0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"neg.s %1,%0\")\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"neg.l %1,%0\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"neg.w %1,%0\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(neg:HI (match_operand:HI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"neg.h %1,%0\")\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n+\t(neg:QI (match_operand:QI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"neg.b %1,%0\")\n+\f\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"not %1,%0\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"not %1,%0\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,a\")\n+\t(not:HI (match_operand:HI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"not %1,%0\")\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d,a\")\n+\t(not:QI (match_operand:QI 1 \"register_operand\" \"d,a\")))]\n+  \"\"\n+  \"not %1,%0\")\n+\f\n+;;- shifts\n+;;\n+;; Convex shift instructions are logical shifts.\n+;; To make signed right shifts:\n+;; for SImode, sign extend to DImode and shift, works for 0..32\n+;; for DImode, shift and then extend the sign, works for 0..63 -- but not 64\n+\n+(define_insn \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(lshift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[2] == const1_rtx)\n+    return \\\"add.w %0,%0\\\";\n+  else if (TARGET_C2 && S_REG_P (operands[0]))\n+    return \\\"shf.w %2,%0\\\";\n+  else\n+    return \\\"shf %2,%0\\\";\n+}\")\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\")))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[2] == const1_rtx)\n+    return \\\"add.w %0,%0\\\";\n+  else if (TARGET_C2 && S_REG_P (operands[0]))\n+    return \\\"shf.w %2,%0\\\";\n+  else\n+    return \\\"shf %2,%0\\\";\n+}\")\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"\"))))]\n+  \"\"\n+  \"operands[2] = negate_rtx (SImode, operands[2]);\")\n+\n+(define_insn \"\"\n+  [(set\n+    (match_operand:SI 0 \"register_operand\" \"=d,a\")\n+    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di,ai\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (A_REG_P (operands[0]))\n+    return \\\"shf %2,%0\\\";\n+  else if (TARGET_C2)\n+    return \\\"shf.w %2,%0\\\";\n+  else\n+    return \\\"ld.u #0,%0\\;shf %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set\n+    (match_operand:SI 0 \"register_operand\" \"=r\")\n+    (lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"*\n+{\n+  if (A_REG_P (operands[0]))\n+    return \\\"shf #%n2,%0\\\";\n+  else if (TARGET_C2)\n+    return \\\"shf.w #%n2,%0\\\";\n+  else\n+    return \\\"ld.u #0,%0\\;shf #%n2,%0\\\";\n+}\")\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+  \"\"\n+  \"operands[2] = negate_rtx (SImode, operands[2]);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+  \"\"\n+  \"cvtw.l %1,%0\\;shf %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"cvtw.l %1,%0\\;shf #%n2,%0\")\n+\n+(define_insn \"lshldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"shf %2,%0\")\n+\n+(define_insn \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+  \"\"\n+  \"shf %2,%0\")\n+\n+(define_expand \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+  \"\"\n+  \"operands[2] = negate_rtx (SImode, operands[2]);\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"di\"))))]\n+  \"\"\n+  \"shf %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"shf #%n2,%0\")\n+\n+;; signed  a >> b  is\n+;;     ((a >> b) ^ signbit) - signbit\n+;; where signbit is (1 << 63) >> b\n+\n+(define_expand \"ashrdi3\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"nonmemory_operand\" \"\")\n+   (match_dup 3)]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int rshift = INTVAL (operands[2]);\n+      operands[3] =\n+\tforce_reg (DImode, immed_double_const (1 << (63 - rshift),\n+\t\t\t\t\t       1 << (31 - rshift), DImode));\n+    }\n+  else\n+    {\n+      operands[3] =\n+\t  force_reg (DImode, immed_double_const (0, 1 << 31, DImode));\n+      emit_insn (gen_lshrdi3 (operands[3], operands[3], operands[2]));\n+    }\n+\n+  emit_insn (gen_lshrdi3 (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t      gen_rtx (XOR, DImode, operands[0], operands[3])));\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t      gen_rtx (MINUS, DImode, operands[0], operands[3])));\n+  DONE;\n+}\")\n+\f\n+;; __builtin instructions\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_C2\"\n+  \"sqrt.d %0\")\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_C2\"\n+  \"sqrt.s %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t  (const_int 1)))]\n+  \"\"\n+  \"tzc %1,%0\\;le.w #32,%0\\;jbrs.f .+6\\;ld.w #-1,%0\")\n+\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(minus:SI (ffs:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t  (const_int 1)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"and #0x7fffffff,%0\")\n+\n+(define_expand \"absdf2\"\n+  [(set (subreg:DI (match_operand:DF 0 \"register_operand\" \"=d\") 0)\n+\t(and:DI (subreg:DI (match_operand:DF 1 \"register_operand\" \"d\") 0)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"operands[2] = force_reg (DImode,\n+\t\t\t    immed_double_const (-1, 0x7fffffff, DImode));\")\n+\f\n+;; Jumps\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jbr %l0\")\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"eq\\\", 't'); \")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"eq\\\", 'f'); \")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"le\\\", 'f'); \")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"leu\\\", 'f'); \")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"lt\\\", 't'); \")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"ltu\\\", 't'); \")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"lt\\\", 'f'); \")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"ltu\\\", 'f'); \")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"le\\\", 't'); \")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"leu\\\", 't'); \")\n+\f\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"eq\\\", 'f'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"eq\\\", 't'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"le\\\", 't'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"leu\\\", 't'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"lt\\\", 'f'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"ltu\\\", 'f'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"lt\\\", 't'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"ltu\\\", 't'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"le\\\", 'f'); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return gen_cmp (operands[0], \\\"leu\\\", 'f'); \")\n+\f\n+;;  - Calls\n+;;\n+;; arg count word may be omitted to save a push and let gcc try to\n+;; combine the arg list pop.  RETURN_POPS_ARGS from tm.h decides this.\n+\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"* return output_call (insn, operands[0], operands[1]);\")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"* return output_call (insn, operands[1], operands[2]);\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"\"\n+  \"rtn\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp %a0\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"jmp %a0\")\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}, {"sha": "8b4ab420db8cad8fa5a4ae89ddebda2d590f870e", "filename": "gcc/config/i860/i860.md", "status": "added", "additions": 2441, "deletions": 0, "changes": 2441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647daf35445bc6597fb183f0af4dedcfd696aa92/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647daf35445bc6597fb183f0af4dedcfd696aa92/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=647daf35445bc6597fb183f0af4dedcfd696aa92", "patch": "@@ -0,0 +1,2441 @@\n+;;- Machine description for Intel 860 chip for GNU C compiler\n+;;   Copyright (C) 1989, 1990 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;;- Operand classes for the register allocator:\n+\f\n+/* Bit-test instructions.  */\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"logic_operand\" \"rL\"))\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and %1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"logic_operand\" \"rL\"))\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"and %1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t\t  (const_int 0)))]\n+  \"GET_CODE (operands[1]) == CONST_INT && (INTVAL (operands[1]) & 0xffff) == 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"andh %H1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t\t  (const_int 0)))]\n+  \"GET_CODE (operands[1]) == CONST_INT && (INTVAL (operands[1]) & 0xffff) == 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"andh %H1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (ashiftrt:SI\n+\t\t   (sign_extend:SI\n+\t\t    (ashift:QI (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t\t       (match_operand:QI 1 \"logic_int\" \"n\")))\n+\t\t   (match_operand:SI 2 \"logic_int\" \"n\"))\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  int width = 8 - INTVAL (operands[2]);\n+  int pos = 8 - width - INTVAL (operands[1]);\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t ~((-1) << width) << pos);\n+  return \\\"and %2,%0,%?r0\\\";\n+}\")\n+\f\n+;; -------------------------------------------------------------------------\n+;; SImode signed integer comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpeqsi\"\n+  [(set (cc0) (eq (match_operand:SI 0 \"logic_operand\" \"r,rL\")\n+\t\t  (match_operand:SI 1 \"logic_operand\" \"L,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[0]))\n+    return \\\"xor %1,%0,%?r0\\\";\n+  else\n+    return \\\"xor %0,%1,%?r0\\\";\n+}\")\n+\n+(define_insn \"cmpnesi\"\n+  [(set (cc0) (ne (match_operand:SI 0 \"logic_operand\" \"r,rL\")\n+\t\t  (match_operand:SI 1 \"logic_operand\" \"L,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  if (REG_P (operands[0]))\n+    return \\\"xor %1,%0,%?r0\\\";\n+  else\n+    return \\\"xor %0,%1,%?r0\\\";\n+}\")\n+\n+(define_insn \"cmpltsi\"\n+  [(set (cc0) (lt (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[1]))\n+    return \\\"subs %0,%1,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[1]));\n+      return \\\"adds %1,%0,%?r0\\\";\n+    }\n+}\")\n+\n+(define_insn \"cmpgtsi\"\n+  [(set (cc0) (gt (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[0]))\n+    return \\\"subs %1,%0,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[0] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[0]));\n+      return \\\"adds %0,%1,%?r0\\\";\n+    }\n+}\")\n+\n+(define_insn \"cmplesi\"\n+  [(set (cc0) (le (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  if (REG_P (operands[0]))\n+    return \\\"subs %1,%0,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[0] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[0]));\n+      return \\\"adds %0,%1,%?r0\\\";\n+    }\n+}\")\n+\n+(define_insn \"cmpgesi\"\n+  [(set (cc0) (ge (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  if (REG_P (operands[1]))\n+    return \\\"subs %0,%1,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[1]));\n+      return \\\"adds %1,%0,%?r0\\\";\n+    }\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; SImode unsigned integer comparisons\n+;; -------------------------------------------------------------------------\n+\n+;; WARNING!  There is a small i860 hardware limitation (bug?) which we\n+;; may run up against (if we are not careful) when we are trying to do\n+;; unsigned comparisons like (x >= 0), (x < 0), (0 <= x), and (0 > x).\n+;; Specifically, we must avoid using an `addu' instruction to perform\n+;; such comparisons because the result (in the CC bit register) will\n+;; come out wrong.  (This fact is documented in a footnote on page 7-10\n+;; of the 1991 version of the i860 Microprocessor Family Programmer's\n+;; Reference Manual).  Note that unsigned comparisons of this sort are\n+;; always redundant anyway, because an unsigned quantity can never be\n+;; less than zero.  When we see cases like this, we generate an\n+;; `or K,%r0,%r0' instruction instead (where K is a constant 0 or -1)\n+;; so as to get the CC bit register set properly for any subsequent\n+;; conditional jump instruction.\n+\n+(define_insn \"cmpgeusi\"\n+  [(set (cc0) (geu (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t   (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[1]))\n+    return \\\"subu %0,%1,%?r0\\\";\n+  else\n+    {\n+      if (INTVAL (operands[1]) == 0)\n+\treturn \\\"or 0,%?r0,%?r0\\\";\n+      else\n+\t{\n+\t  cc_status.flags |= CC_REVERSED;\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[1]));\n+\t  return \\\"addu %1,%0,%?r0\\\";\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"cmpleusi\"\n+  [(set (cc0) (leu (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t   (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[0]))\n+    return \\\"subu %1,%0,%?r0\\\";\n+  else\n+    {\n+      if (INTVAL (operands[0]) == 0)\n+\treturn \\\"or 0,%?r0,%?r0\\\";\n+      else\n+\t{\n+\t  cc_status.flags |= CC_REVERSED;\n+\t  operands[0] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[0]));\n+\t  return \\\"addu %0,%1,%?r0\\\";\n+\t}\n+    }\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; SFmode floating-point comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpeqsf\"\n+  [(set (cc0) (eq (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfeq.ss %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpnesf\"\n+  [(set (cc0) (ne (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfeq.ss %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The i860 Programmer's Reference Manual says that when we are\n+;; doing (A < B) or (A > B) comparisons, we have to use pfgt for these\n+;; in order to be IEEE compliant (in case a trap occurs during these\n+;; operations).  Conversely, for (A <= B) or (A >= B) comparisons, we\n+;; must use pfle to be IEEE compliant.\n+\n+(define_insn \"cmpltsf\"\n+  [(set (cc0) (lt (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.ss %r1,%r0,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgtsf\"\n+  [(set (cc0) (gt (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.ss %r0,%r1,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The pfle opcode doesn't do what you think it does.  It is\n+;; bass-ackwards.  It *clears* the CC flag if the first operand is\n+;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n+;; for the following two patterns.\n+\n+(define_insn \"cmplesf\"\n+  [(set (cc0) (le (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.ss %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgesf\"\n+  [(set (cc0) (ge (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.ss %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; DFmode floating-point comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpeqdf\"\n+  [(set (cc0) (eq (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfeq.dd %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpnedf\"\n+  [(set (cc0) (ne (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfeq.dd %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The i860 Programmer's Reference Manual says that when we are\n+;; doing (A < B) or (A > B) comparisons, we have to use pfgt for these\n+;; in order to be IEEE compliant (in case a trap occurs during these\n+;; operations).  Conversely, for (A <= B) or (A >= B) comparisons, we\n+;; must use pfle to be IEEE compliant.\n+\n+(define_insn \"cmpltdf\"\n+  [(set (cc0) (lt (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.dd %r1,%r0,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgtdf\"\n+  [(set (cc0) (gt (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.dd %r0,%r1,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The pfle opcode doesn't do what you think it does.  It is\n+;; bass-ackwards.  It *clears* the CC flag if the first operand is\n+;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n+;; for the following two patterns.\n+\n+(define_insn \"cmpledf\"\n+  [(set (cc0) (le (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.dd %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgedf\"\n+  [(set (cc0) (ge (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.dd %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; ------------------------------------------------------------------------\n+;; Integer EQ/NE comparisons against constant values which will fit in the\n+;; 16-bit immediate field of an instruction.  These are made by combining.\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (zero_extend:SI (match_operand:HI 0 \"load_operand\" \"m\"))\n+\t          (match_operand:SI 1 \"small_int\" \"I\")))]\n+  \"INTVAL (operands[1]) >= 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"ld.s %0,%?r31\\;xor %1,%?r31,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (match_operand:SI 0 \"small_int\" \"I\")\n+\t          (zero_extend:SI (match_operand:HI 1 \"load_operand\" \"m\"))))]\n+  \"INTVAL (operands[0]) >= 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"ld.s %1,%?r31\\;xor %0,%?r31,%?r0\\\";\n+}\")\n+\f\n+;; ------------------------------------------------------------------------\n+;; Define the real conditional branch instructions.\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"cbranch\"\n+  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bnc %l0\\\";\n+  else\n+    return \\\"bc %l0\\\";\n+}\")\n+\n+(define_insn \"flipped_cbranch\"\n+  [(set (pc) (if_then_else (ne (cc0)\n+\t\t\t       (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bnc %l0\\\";\n+  else\n+    return \\\"bc %l0\\\";\n+}\")\n+\n+(define_insn \"inverse_cbranch\"\n+  [(set (pc) (if_then_else (eq (cc0)\n+\t\t\t       (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bc %l0\\\";\n+  else\n+    return \\\"bnc %l0\\\";\n+}\")\n+\n+\n+(define_insn \"flipped_inverse_cbranch\"\n+  [(set (pc) (if_then_else (ne (cc0)\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bc %l0\\\";\n+  else\n+    return \\\"bnc %l0\\\";\n+}\")\n+\n+;; Simple BTE/BTNE compare-and-branch insns made by combining.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:QI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:QI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:QI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:QI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:HI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:HI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:HI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:HI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:HI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+;; Load byte/halfword, zero-extend, & compare-and-branch insns.\n+;; These are made by combining.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;bte %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;bte %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;bte %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;bte %1,%3,%2\")\n+\n+\f\n+;; Generation of conditionals.\n+\n+;; The first step is the emission of a standard-looking compare insn.\n+;; Then a standard-named conditional branch pattern is run.\n+;; That branch pattern looks back at the compare insn and deletes it.\n+;; It then emits a machine-specific compare insn and a branch-if-true\n+;; or a branch-if-false.\n+\n+;; These patterns have `abort' because they are supposed to be deleted\n+;; in that fashion.\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 1 \"compare_operand\" \"\")))]\n+  \"\"\n+  \"* abort ();\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0) (compare (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"* abort ();\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0) (compare (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t       (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"* abort ();\")\n+\n+;; These are the standard-named conditional branch patterns.\n+;; Detailed comments are found in the first one only.\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  /* Get out of the sequence just started for us.  */\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  /* Examine the preceding compare insn, and get rid of it.  */\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+\n+  /* Now once again start a sequence for our new instructions.  */\n+\n+  start_sequence ();\n+\n+  /* Emit a single-condition compare insn according to\n+     the type of operands and the condition to be tested.  */\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpeqsi (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpsf)\n+    emit_insn (gen_cmpeqsf (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpdf)\n+    emit_insn (gen_cmpeqdf (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+\n+  /* Emit branch-if-true.  */\n+\n+  emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpeqsi (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpsf)\n+    emit_insn (gen_cmpeqsf (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpdf)\n+    emit_insn (gen_cmpeqdf (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_cbranch (label));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpgtsi (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpsf)\n+    emit_insn (gen_cmpgtsf (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpdf)\n+    emit_insn (gen_cmpgtdf (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+  DONE;\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpltsi (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpsf)\n+    emit_insn (gen_cmpltsf (recog_operand[0], recog_operand[1]));\n+  else if (code == CODE_FOR_cmpdf)\n+    emit_insn (gen_cmpltdf (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+  DONE;\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    {\n+      emit_insn (gen_cmpgtsi (recog_operand[0], recog_operand[1]));\n+      emit_jump_insn (gen_flipped_cbranch (label));\n+    }\n+  else\n+    {\n+      if (code == CODE_FOR_cmpsf)\n+\temit_insn (gen_cmplesf (recog_operand[0], recog_operand[1]));\n+      else if (code == CODE_FOR_cmpdf)\n+\temit_insn (gen_cmpledf (recog_operand[0], recog_operand[1]));\n+      else\n+\tabort ();\n+      emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+    }\n+  DONE;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    {\n+      emit_insn (gen_cmpltsi (recog_operand[0], recog_operand[1]));\n+      emit_jump_insn (gen_flipped_cbranch (label));\n+    }\n+  else\n+    {\n+      if (code == CODE_FOR_cmpsf)\n+\temit_insn (gen_cmpgesf (recog_operand[0], recog_operand[1]));\n+      else if (code == CODE_FOR_cmpdf)\n+\temit_insn (gen_cmpgedf (recog_operand[0], recog_operand[1]));\n+      else\n+        abort ();\n+      emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+    }\n+  DONE;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpleusi (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_cbranch (label));\n+  DONE;\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpgeusi (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_cbranch (label));\n+  DONE;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpgeusi (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+  DONE;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  rtx label = operands[0];\n+  enum insn_code code;\n+  rtx prev;\n+\n+  end_sequence ();\n+  prev = get_last_insn ();\n+\n+  code = recog_memoized (prev);\n+  insn_extract (prev);\n+  NEXT_INSN (PREV_INSN (prev)) = 0;\n+  set_last_insn (PREV_INSN (prev));\n+  start_sequence ();\n+\n+  if (code == CODE_FOR_cmpsi)\n+    emit_insn (gen_cmpleusi (recog_operand[0], recog_operand[1]));\n+  else\n+    abort ();\n+  emit_jump_insn (gen_flipped_inverse_cbranch (label));\n+  DONE;\n+}\")\n+\f\n+;; Move instructions\n+\n+;; Note that source operands for `mov' pseudo-instructions are no longer\n+;; allowed (by the svr4 assembler) to be \"big\" things, i.e. constants that\n+;; won't fit in 16-bits.  (This includes any sort of a relocatable address\n+;; also.)  Thus, we must use an explicit orh/or pair of instructions if\n+;; the source operand is something \"big\".\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,m,f\")\n+\t(match_operand:SI 1 \"general_operand\" \"rmif,rfJ,rmfJ\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\treturn output_store (operands);\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fst.l %1,%0\\\";\n+      return \\\"st.l %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn output_load (operands);\n+      if (FP_REG_P (operands[0]))\n+\treturn \\\"fld.l %1,%0\\\";\n+      return \\\"ld.l %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n+    return \\\"fmov.ss %1,%0\\\";\n+  if (FP_REG_P (operands[1]))\n+    return \\\"fxfr %1,%0\\\";\n+  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n+    return \\\"fmov.ss %?f0,%0\\\";\n+  if (FP_REG_P (operands[0]))\n+    return \\\"ixfr %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"shl %?r0,%1,%0\\\";\n+\n+  CC_STATUS_PARTIAL_INIT;\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if((INTVAL (operands[1]) & 0xffff0000) == 0)\n+        return \\\"or %L1,%?r0,%0\\\";\n+      if((INTVAL (operands[1]) & 0x0000ffff) == 0)\n+        return \\\"orh %H1,%?r0,%0\\\";\n+    }\n+  return \\\"orh %H1,%?r0,%0\\;or %L1,%0,%0\\\";\n+}\")\n+ \n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,m,!*f,!r\")\n+\t(match_operand:HI 1 \"general_operand\" \"rmi,rJ,rJ*f,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\treturn output_store (operands);\n+      return \\\"st.s %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn output_load (operands);\n+      return \\\"ld.s %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n+    return \\\"fmov.ss %1,%0\\\";\n+  if (FP_REG_P (operands[1]))\n+    return \\\"fxfr %1,%0\\\";\n+  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n+    return \\\"fmov.ss %?f0,%0\\\";\n+  if (FP_REG_P (operands[0]))\n+    return \\\"ixfr %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"shl %?r0,%1,%0\\\";\n+\n+  CC_STATUS_PARTIAL_INIT;\n+\n+  return \\\"or %L1,%?r0,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,!*f,!r\")\n+\t(match_operand:QI 1 \"general_operand\" \"rmi,rJ,rJ*f,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\treturn output_store (operands);\n+      return \\\"st.b %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn output_load (operands);\n+      return \\\"ld.b %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n+    return \\\"fmov.ss %1,%0\\\";\n+  if (FP_REG_P (operands[1]))\n+    return \\\"fxfr %1,%0\\\";\n+  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n+    return \\\"fmov.ss %?f0,%0\\\";\n+  if (FP_REG_P (operands[0]))\n+    return \\\"ixfr %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"shl %?r0,%1,%0\\\";\n+\n+  CC_STATUS_PARTIAL_INIT;\n+\n+  return \\\"or %L1,%?r0,%0\\\";\n+}\")\n+\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it won't successfully combine with anything.\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t      (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (match_dup 6))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))])]\n+  \"\"\n+  \"\n+{\n+  operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (SImode);\n+  operands[6] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (use (match_operand:SI 2 \"general_operand\" \"rn\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n+   (clobber (match_operand:SI 4 \"register_operand\" \"=r\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))\n+   (clobber (match_operand:SI 6 \"register_operand\" \"=r\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"* return output_block_move (operands);\")\n+\f\n+;; Floating point move insns\n+\n+;; This pattern forces (set (reg:DF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movdf pattern.\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,f,o\")\n+\t(match_operand:DF 1 \"\" \"mG,m,G\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || operands[1] == CONST0_RTX (DFmode))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=*rm,&*r,?f,?*rm\")\n+\t(match_operand:DF 1 \"general_operand\" \"*r,m,*rfmG,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    return output_store (operands);\n+  if (GET_CODE (operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    return output_load (operands);\n+\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&r,?f,?rm\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,miF,rfmG,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    return output_store (operands);\n+  if (GET_CODE (operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    return output_load (operands);\n+\n+  /* ??? How can we have a DFmode arg here with DImode above? */\n+  if (FP_REG_P (operands[0]) && operands[1] == CONST0_RTX (DFmode))\n+    return \\\"fmov.dd %?f0,%0\\\";\n+\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+;; The alternative m/r is separate from m/f\n+;; The first alternative is separate from the second for the same reason.\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=*rf,*rf,*r,m,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"*r,fmG,F,*r,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    return output_store (operands);\n+  if (GET_CODE (operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    return output_load (operands);\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmov.ss %1,%0\\\";\n+      if (GET_CODE (operands[1]) == REG)\n+\treturn \\\"ixfr %1,%0\\\";\n+      if (operands[1] == CONST0_RTX (SFmode))\n+        return \\\"fmov.ss %?f0,%0\\\";\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP(operands[1],0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t      cc_status.mdep = XEXP (operands[1], 0);\n+\t      return \\\"orh %h1,%?r0,%?r31\\;fld.l %L1(%?r31),%0\\\";\n+\t    }\n+\t  return \\\"fld.l %L1(%?r31),%0\\\";\n+\t}\n+      return \\\"fld.l %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      if (GET_CODE (operands[0]) == REG && FP_REG_P (operands[1]))\n+\treturn \\\"fxfr %1,%0\\\";\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  CC_STATUS_PARTIAL_INIT;\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    {\n+\t      register unsigned long ul;\n+\n+              ul = sfmode_constant_to_ulong (operands[1]);\n+\t      if ((ul & 0x0000ffff) == 0)\n+\t\treturn \\\"orh %H1,%?r0,%0\\\";\n+\t      if ((ul & 0xffff0000) == 0)\n+\t\treturn \\\"or %L1,%?r0,%0\\\";\n+\t    }\n+          return \\\"orh %H1,%?r0,%0\\;or %L1,%0,%0\\\";\n+\t}\n+      /* Now operand 0 must be memory.\n+         If operand 1 is CONST_DOUBLE, its value must be 0.  */\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t      cc_status.mdep = XEXP (operands[0], 0);\n+\t      output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t    }\n+\t  return \\\"fst.l %r1,%L0(%?r31)\\\";\n+\t}\n+      return \\\"fst.l %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.l %r1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld.l %1,%0\\\";\n+  if (operands[1] == CONST0_RTX (SFmode))\n+    return \\\"shl %?r0,%?r0,%0\\\";\n+  return \\\"mov %1,%0\\\";\n+}\")\n+\f\n+;; Special load insns for REG+REG addresses.\n+;; Such addresses are not \"legitimate\" because st rejects them.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=rf\")\n+\t(match_operand:DF 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SF 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return \\\"fld.l %1,%0\\\";\n+  return \\\"ld.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SI 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return \\\"fld.l %1,%0\\\";\n+  return \\\"ld.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"ld.s %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"ld.b %1,%0\")\n+\n+;; Likewise for floating-point store insns.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"indexed_operand\" \"=m\")\n+\t(match_operand:DF 1 \"register_operand\" \"f\"))]\n+  \"\"\n+  \"fst.d %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"indexed_operand\" \"=m\")\n+\t(match_operand:SF 1 \"register_operand\" \"f\"))]\n+  \"\"\n+  \"fst.l %1,%0\")\n+\f\n+;;- truncation instructions\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI\n+\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+      {\n+\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t  }\n+\treturn \\\"st.b %1,%L0(%?r31)\\\";\n+      }\n+    else\n+      return \\\"st.b %1,%0\\\";\n+  return \\\"shl %?r0,%1,%0\\\";\n+}\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI\n+\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+      {\n+\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t  }\n+\treturn \\\"st.b %1,%L0(%?r31)\\\";\n+      }\n+    else\n+      return \\\"st.b %1,%0\\\";\n+  return \\\"shl %?r0,%1,%0\\\";\n+}\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(truncate:HI\n+\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+      {\n+\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t  }\n+\treturn \\\"st.s %1,%L0(%?r31)\\\";\n+      }\n+    else\n+      return \\\"st.s %1,%0\\\";\n+  return \\\"shl %?r0,%1,%0\\\";\n+}\")\n+\f\n+;;- zero extension instructions\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 0xffff,%1,%0\\\";\n+}\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 0xff,%1,%0\\\";\n+}\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 0xff,%1,%0\\\";\n+}\")\n+\f\n+;; Sign extension instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"indexed_operand\" \"m\")))]\n+  \"\"\n+  \"ld.s %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"indexed_operand\" \"m\")))]\n+  \"\"\n+  \"ld.b %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"indexed_operand\" \"m\")))]\n+  \"\"\n+  \"ld.b %1,%0\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"mr\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    return \\\"shl 16,%1,%0\\;shra 16,%0,%0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    abort ();\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.s %L1(%?r31),%0\\\";\n+    }\n+  else\n+    return \\\"ld.s %1,%0\\\";\n+}\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"mr\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    return \\\"shl 24,%1,%0\\;shra 24,%0,%0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    abort ();\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n+    }\n+  else\n+    return \\\"ld.b %1,%0\\\";\n+}\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"mr\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    return \\\"shl 24,%1,%0\\;shra 24,%0,%0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    abort ();\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n+    }\n+  else\n+    return \\\"ld.b %1,%0\\\";\n+}\")\n+\n+;; Signed bitfield extractions come out looking like\n+;;\t(shiftrt (sign_extend (shift <Y> <C1>)) <C2>)\n+;; which we expand poorly as four shift insns.\n+;; These patters yeild two shifts:\n+;;\t(shiftrt (shift <Y> <C3>) <C4>)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI\n+\t (sign_extend:SI\n+\t  (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t (match_operand:SI 2 \"logic_int\" \"n\")))]\n+  \"INTVAL (operands[2]) < 8\"\n+  \"*\n+{\n+  return \\\"shl 24,%1,%0\\;shra 24+%2,%0,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI\n+\t (sign_extend:SI\n+\t  (subreg:QI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(match_operand:SI 2 \"logic_int\" \"n\")) 0))\n+\t (match_operand:SI 3 \"logic_int\" \"n\")))]\n+  \"INTVAL (operands[3]) < 8\"\n+  \"*\n+{\n+  return \\\"shl 0x18+%2,%1,%0\\;shra 0x18+%3,%0,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI\n+\t (sign_extend:SI\n+\t  (ashift:QI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:QI 2 \"logic_int\" \"n\")))\n+\t (match_operand:SI 3 \"logic_int\" \"n\")))]\n+  \"INTVAL (operands[3]) < 8\"\n+  \"*\n+{\n+  return \\\"shl 0x18+%2,%1,%0\\;shra 0x18+%3,%0,%0\\\";\n+}\")\n+\f\n+;; Special patterns for optimizing bit-field instructions.\n+\n+;; First two patterns are for bitfields that came from memory\n+;; testing only the high bit.  They work with old combiner.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq (zero_extend:SI (subreg:QI (lshiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t\t\t    (const_int 7)) 0))\n+\t    (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 128,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq (sign_extend:SI (subreg:QI (ashiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t\t\t    (const_int 7)) 0))\n+\t    (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 128,%0,%?r0\\\";\n+}\")\n+\n+;; next two patterns are good for bitfields coming from memory\n+;; (via pseudo-register) or from a register, though this optimization\n+;; is only good for values contained wholly within the bottom 13 bits\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq \n+\t (and:SI (lshiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 1 \"logic_int\" \"n\"))\n+\t\t (match_operand:SI 2 \"logic_int\" \"n\"))\n+\t (const_int 0)))]\n+  \"LOGIC_INTVAL (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t (INTVAL (operands[2]) << INTVAL (operands[1])));\n+  return \\\"and %2,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq \n+\t (and:SI (ashiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 1 \"logic_int\" \"n\"))\n+\t\t (match_operand:SI 2 \"logic_int\" \"n\"))\n+\t (const_int 0)))]\n+  \"LOGIC_INTVAL (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t (INTVAL (operands[2]) << INTVAL (operands[1])));\n+  return \\\"and %2,%0,%?r0\\\";\n+}\")\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:DF\n+\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmov.sd %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF\n+\t (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmov.ds %1,%0\")\n+\f\n+;; Conversion between fixed point and floating point.\n+;; Note that among the fix-to-float insns\n+;; the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+;; This pattern forces (set (reg:SF ...) (float:SF (const_int ...)))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general floatsisf2 pattern.\n+(define_expand \"floatsidf2\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (const_int -2147483648)))\n+   (set (subreg:SI (match_dup 5) 0) (match_dup 4))\n+   (set (subreg:SI (match_dup 5) 1) (subreg:SI (match_dup 2) 1))\n+   (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(minus:DF (match_dup 5) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  REAL_VALUE_TYPE d;\n+  /* 4503601774854144 is  (1 << 30) * ((1 << 22) + (1 << 1)).  */\n+  d = REAL_VALUE_ATOF (\\\"4503601774854144\\\");\n+  operands[2] = gen_reg_rtx (DFmode);\n+  operands[3] = CONST_DOUBLE_FROM_REAL_VALUE (d, DFmode);\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (DFmode);\n+}\")\n+\f\n+;; Floating to fixed conversion.\n+\n+(define_expand \"fix_truncdfsi2\"\n+  ;; This first insn produces a double-word value\n+  ;; in which only the low word is valid.\n+  [(set (match_dup 2)\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(subreg:SI (match_dup 2) 0))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+}\")\n+\n+;; Recognize the first insn generated above.\n+;; This RTL looks like a fix_truncdfdi2 insn,\n+;; but we dont call it that, because only 32 bits\n+;; of the result are valid.\n+;; This pattern will work for the intended purposes \n+;; as long as we do not have any fixdfdi2 or fix_truncdfdi2.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n+  \"\"\n+  \"ftrunc.dd %1,%0\")\n+\n+(define_expand \"fix_truncsfsi2\"\n+  ;; This first insn produces a double-word value\n+  ;; in which only the low word is valid.\n+  [(set (match_dup 2)\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(subreg:SI (match_dup 2) 0))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+}\")\n+\n+;; Recognize the first insn generated above.\n+;; This RTL looks like a fix_truncsfdi2 insn,\n+;; but we dont call it that, because only 32 bits\n+;; of the result are valid.\n+;; This pattern will work for the intended purposes \n+;; as long as we do not have any fixsfdi2 or fix_truncsfdi2.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n+  \"\"\n+  \"ftrunc.sd %1,%0\")\n+\f\n+;;- arithmetic instructions\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,*f\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r,!*f\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI,!*f\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    return \\\"fiadd.ss %2,%1,%0\\\";\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"addu %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%f\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fiadd.dd %1,%2,%0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,*f\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r,I,!*f\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rI,r,!*f\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 2)\n+    return \\\"fisub.ss %1,%2,%0\\\";\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]))\n+    return \\\"subu %1,%2,%0\\\";\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, - INTVAL (operands[2]));\n+  return \\\"addu %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"%f\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fisub.dd %1,%2,%0\")\n+\n+(define_expand \"mulsi3\"\n+  [(set (subreg:SI (match_dup 4) 0) (match_operand:SI 1 \"general_operand\" \"\"))\n+   (set (subreg:SI (match_dup 5) 0) (match_operand:SI 2 \"general_operand\" \"\"))\n+   (clobber (match_dup 3))\n+   (set (subreg:SI (match_dup 3) 0)\n+\t(mult:SI (subreg:SI (match_dup 4) 0) (subreg:SI (match_dup 5) 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 0))]\n+  \"\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = gen_reg_rtx (DImode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 0)\n+\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 0)\n+\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 0)))]\n+  \"\"\n+  \"fmlow.dd %2,%1,%0\")\n+\f\n+;;- and instructions (with compliment also)\t\t\t   \n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n+    return \\\"and %2,%1,%0\\\";\n+  if ((INTVAL (operands[2]) & 0xffff) == 0)\n+    {\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t     (unsigned) INTVAL (operands[2]) >> 16);\n+      return \\\"andh %2,%1,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[2]) & 0xffff);\n+  output_asm_insn (\\\"andnot %2,%1,%0\\\", xop);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t ~(unsigned) INTVAL (operands[2]) >> 16);\n+  return \\\"andnoth %2,%0,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"rn\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[1]) || LOGIC_INT (operands[1]))\n+    return \\\"andnot %1,%2,%0\\\";\n+  if ((INTVAL (operands[1]) & 0xffff) == 0)\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t     (unsigned) INTVAL (operands[1]) >> 16);\n+      return \\\"andnoth %1,%2,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[1]) & 0xffff));\n+  xop[2] = operands[2];\n+  output_asm_insn (\\\"andnot %1,%2,%0\\\", xop);\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t (unsigned) INTVAL (operands[1]) >> 16);\n+  return \\\"andnoth %1,%0,%0\\\";\n+}\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n+    return \\\"or %2,%1,%0\\\";\n+  if ((INTVAL (operands[2]) & 0xffff) == 0)\n+    {\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t     (unsigned) INTVAL (operands[2]) >> 16);\n+      return \\\"orh %2,%1,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[2]) & 0xffff));\n+  output_asm_insn (\\\"or %2,%1,%0\\\", xop);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t (unsigned) INTVAL (operands[2]) >> 16);\n+  return \\\"orh %2,%0,%0\\\";\n+}\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n+    return \\\"xor %2,%1,%0\\\";\n+  if ((INTVAL (operands[2]) & 0xffff) == 0)\n+    {\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t     (unsigned) INTVAL (operands[2]) >> 16);\n+      return \\\"xorh %2,%1,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = gen_rtx (CONST_INT, VOIDmode, (INTVAL (operands[2]) & 0xffff));\n+  output_asm_insn (\\\"xor %2,%1,%0\\\", xop);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t (unsigned) INTVAL (operands[2]) >> 16);\n+  return \\\"xorh %2,%0,%0\\\";\n+}\")\n+\n+;(The i860 instruction set doesn't allow an immediate second operand in\n+; a subtraction.)\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"subu %?r0,%1,%0\\\";\n+}\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"subu -1,%1,%0\\\";\n+}\")\n+\f\n+;; Floating point arithmetic instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fadd.dd %1,%2,%0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fadd.ss %1,%2,%0\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.dd %1,%2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.ss %1,%2,%0\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmul.dd %1,%2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmul.ss %1,%2,%0\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.dd %?f0,%1,%0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.ss %?f0,%1,%0\")\n+\f\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:DF 3 \"=&f\"))\n+   (clobber (match_scratch:DF 4 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (((cc_prev_status.flags & CC_KNOW_HI_R31) == 0)\n+      || (cc_prev_status.flags & CC_HI_R31_ADJ)\n+      || (cc_prev_status.mdep != CONST2_RTX (SFmode)))\n+    {\n+      cc_status.flags |= CC_KNOW_HI_R31;\n+      cc_status.flags &= ~CC_HI_R31_ADJ;\n+      cc_status.mdep = CONST2_RTX (SFmode); \n+      return \\\"frcp.dd %2,%3\\;fmul.dd %2,%3,%0\\;fmov.dd %?f0,%4\\;\\\\\\\n+orh 0x4000,%?r0,%?r31\\;ixfr %?r31,%R4\\;fsub.dd %4,%0,%0\\;\\\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\\\n+fmul.dd %3,%1,%3\\;fmul.dd %0,%3,%0\\\";\n+    }\n+  else\n+    return \\\"frcp.dd %2,%3\\;fmul.dd %2,%3,%0\\;fmov.dd %?f0,%4\\;\\\\\\\n+ixfr %?r31,%R4\\;fsub.dd %4,%0,%0\\;\\\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\\\n+fmul.dd %3,%1,%3\\;fmul.dd %0,%3,%0\\\";\n+}\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:SF 3 \"=&f\"))\n+   (clobber (match_scratch:SF 4 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (((cc_prev_status.flags & CC_KNOW_HI_R31) == 0)\n+      || (cc_prev_status.flags & CC_HI_R31_ADJ)\n+      || (cc_prev_status.mdep != CONST2_RTX (SFmode)))\n+    {\n+      cc_status.flags |= CC_KNOW_HI_R31;\n+      cc_status.flags &= ~CC_HI_R31_ADJ;\n+      cc_status.mdep = CONST2_RTX (SFmode);\n+      output_asm_insn (\\\"orh 0x4000,%?r0,%?r31\\\", operands);\n+    }\n+  return \\\"ixfr %?r31,%4\\;frcp.ss %2,%0\\;\\\\\\\n+fmul.ss %2,%0,%3\\;fsub.ss %4,%3,%3\\;fmul.ss %0,%3,%0\\;\\\\\\\n+fmul.ss %2,%0,%3\\;fsub.ss %4,%3,%3\\;\\\\\\\n+fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n+}\")\n+\f\n+;; Shift instructions\n+\n+;; Optimized special case of shifting.\n+;; Must precede the general case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"*\n+{\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n+    }\n+  return \\\"ld.b %1,%0\\\";\n+}\")\n+\n+\f\n+;;- arithmetic shift instructions\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shl %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:HI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shl %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:QI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shl %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shra %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shr %2,%1,%0\\\";\n+}\")\n+\f\n+;; Unconditional and other jump instructions\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"br %l0\\;nop\\\";\n+}\")\n+\n+;; Here are two simple peepholes which fill the delay slot of\n+;; an unconditional branch.\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"bri %0\\;nop\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 3 \"\" \"\")))]\n+  \"\"\n+  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n+\n+;;- jump to subroutine\n+(define_expand \"call\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t (match_operand 1 \"\" \"i\"))]\n+  ;; operand[2] is next_arg_register\n+  \"\"\n+  \"\n+{\n+  if (INTVAL (operands[1]) > 0)\n+    {\n+      emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n+      emit_insn (gen_rtx (USE, VOIDmode, arg_pointer_rtx));\n+    }\n+}\")\n+\n+;;- jump to subroutine\n+(define_insn \"\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t (match_operand 1 \"\" \"i\"))]\n+  ;; operand[2] is next_arg_register\n+  \"\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[0] = XEXP (operands[0], 0);\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[0]) == REG)\n+    return \\\"calli %0\\;nop\\\";\n+  return \\\"call %0\\;nop\\\";\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+   (call (match_operand:SI 2 \"memory_operand\" \"m\")\n+\t (match_operand 3 \"\" \"i\"))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"! reg_mentioned_p (operands[0], operands[2])\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[2] = XEXP (operands[2], 0);\n+  if (GET_CODE (operands[2]) == REG)\n+    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n+  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+   (call (match_operand:SI 2 \"memory_operand\" \"m\")\n+\t (match_operand 3 \"\" \"i\"))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[2] = XEXP (operands[2], 0);\n+  if (GET_CODE (operands[2]) == REG)\n+    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n+  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n+}\")\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf\")\n+\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t      (match_operand 2 \"\" \"i\")))]\n+  ;; operand 3 is next_arg_register\n+  \"\"\n+  \"\n+{\n+  if (INTVAL (operands[2]) > 0)\n+    {\n+      emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n+      emit_insn (gen_rtx (USE, VOIDmode, arg_pointer_rtx));\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf\")\n+\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t      (match_operand 2 \"\" \"i\")))]\n+  ;; operand 3 is next_arg_register\n+  \"\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[1] = XEXP (operands[1], 0);\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"calli %1\\;nop\\\";\n+  return \\\"call %1\\;nop\\\";\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+   (set (match_operand 2 \"\" \"=rf\")\n+\t(call (match_operand:SI 3 \"memory_operand\" \"m\")\n+\t      (match_operand 4 \"\" \"i\")))]\n+  ;;- Don't use operand 4 for most machines.\n+  \"! reg_mentioned_p (operands[0], operands[3])\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[3] = XEXP (operands[3], 0);\n+  if (GET_CODE (operands[3]) == REG)\n+    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n+  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n+}\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"reg_or_0_operand\" \"rJf\"))\n+   (set (match_operand 2 \"\" \"=rf\")\n+\t(call (match_operand:SI 3 \"memory_operand\" \"m\")\n+\t      (match_operand 4 \"\" \"i\")))]\n+  ;;- Don't use operand 4 for most machines.\n+  \"\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[3] = XEXP (operands[3], 0);\n+  if (GET_CODE (operands[3]) == REG)\n+    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n+  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n+}\")\n+\f\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"bri %0\")\n+\f\n+;;\n+;; A special insn that does the work to get setup just\n+;; before a table jump.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (label_ref (match_operand 2 \"\" \"\")))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"orh %H2,%?r0,%?r31\\;or %L2,%?r31,%?r31\\;ld.l %?r31(%1),%0\\\";\n+}\")\n+  \n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 3 \"\" \"\")))]\n+  \"REGNO (operands[0]) != REGNO (operands[2])\"\n+  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:\n+"}, {"sha": "f94312c9d78e2a253b940a42a454eb59e7ff0e7a", "filename": "gcc/config/ns32k/ns32k.md", "status": "added", "additions": 2531, "deletions": 0, "changes": 2531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647daf35445bc6597fb183f0af4dedcfd696aa92/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647daf35445bc6597fb183f0af4dedcfd696aa92/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=647daf35445bc6597fb183f0af4dedcfd696aa92", "patch": "@@ -0,0 +1,2531 @@\n+; BUGS:\n+;; Insert no-op between an insn with memory read-write operands\n+;;   following by a scale-indexing operation.\n+;; The Sequent assembler does not allow addresses to be used\n+;;   except in insns which explicitly compute an effective address.\n+;;   I.e., one cannot say \"cmpd _p,@_x\"\n+;; Implement unsigned multiplication??\n+\n+;;- Machine descrption for GNU compiler\n+;;- ns32000 Version\n+;;   Copyright (C) 1988 Free Software Foundation, Inc.\n+;;   Contributed by Michael Tiemann (tiemann@mcc.com)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- Instruction patterns.  When multiple patterns apply,\n+;;- the first one in the file is chosen.\n+;;-\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+;;-\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"\"\n+  \"*\n+{ cc_status.flags |= CC_REVERSED;\n+  operands[1] = const0_rtx;\n+  return \\\"cmpqd %1,%0\\\"; }\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{ cc_status.flags |= CC_REVERSED;\n+  operands[1] = const0_rtx;\n+  return \\\"cmpqw %1,%0\\\"; }\")\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"nonimmediate_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{ cc_status.flags |= CC_REVERSED;\n+  operands[1] = const0_rtx;\n+  return \\\"cmpqb %1,%0\\\"; }\")\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"general_operand\" \"fmF\"))]\n+  \"TARGET_32081\"\n+  \"*\n+{ cc_status.flags |= CC_REVERSED;\n+  operands[1] = CONST0_RTX (DFmode);\n+  return \\\"cmpl %1,%0\\\"; }\")\n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"general_operand\" \"fmF\"))]\n+  \"TARGET_32081\"\n+  \"*\n+{ cc_status.flags |= CC_REVERSED;\n+  operands[1] = CONST0_RTX (SFmode);\n+  return \\\"cmpf %1,%0\\\"; }\")\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"rmn\")\n+\t\t (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if (i <= 7 && i >= -8)\n+\t{\n+\t  cc_status.flags |= CC_REVERSED;\n+\t  return \\\"cmpqd %1,%0\\\";\n+\t}\n+    }\n+  cc_status.flags &= ~CC_REVERSED;\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[0]);\n+      if (i <= 7 && i >= -8)\n+\treturn \\\"cmpqd %0,%1\\\";\n+    }\n+  return \\\"cmpd %0,%1\\\";\n+}\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"g\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      short i = INTVAL (operands[1]);\n+    if (i <= 7 && i >= -8)\n+      {\n+\tcc_status.flags |= CC_REVERSED;\n+\tif (INTVAL (operands[1]) > 7)\n+\t  operands[1] = gen_rtx(CONST_INT, VOIDmode, i);\n+\treturn \\\"cmpqw %1,%0\\\";\n+      }\n+    }\n+  cc_status.flags &= ~CC_REVERSED;\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    {\n+      short i = INTVAL (operands[0]);\n+      if (i <= 7 && i >= -8)\n+\t{\n+\t  if (INTVAL (operands[0]) > 7)\n+\t    operands[0] = gen_rtx(CONST_INT, VOIDmode, i);\n+\t  return \\\"cmpqw %0,%1\\\";\n+\t}\n+    }\n+  return \\\"cmpw %0,%1\\\";\n+}\")\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"g\")\n+\t\t (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      char i = INTVAL (operands[1]);\n+      if (i <= 7 && i >= -8)\n+\t{\n+\t  cc_status.flags |= CC_REVERSED;\n+\t  if (INTVAL (operands[1]) > 7)\n+\t    operands[1] = gen_rtx(CONST_INT, VOIDmode, i);\n+\t  return \\\"cmpqb %1,%0\\\";\n+\t}\n+    }\n+  cc_status.flags &= ~CC_REVERSED;\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    {\n+      char i = INTVAL (operands[0]);\n+      if (i <= 7 && i >= -8)\n+\t{\n+\t  if (INTVAL (operands[0]) > 7)\n+\t    operands[0] = gen_rtx(CONST_INT, VOIDmode, i);\n+\t  return \\\"cmpqb %0,%1\\\";\n+\t}\n+    }\n+  return \\\"cmpb %0,%1\\\";\n+}\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"general_operand\" \"fmF\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"cmpl %0,%1\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"general_operand\" \"fmF\")\n+\t\t (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"cmpf %0,%1\")\n+\f\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=&fg<\")\n+\t(match_operand:DF 1 \"general_operand\" \"fFg\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn \\\"movl %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"movd %1,tos\\\", xoperands);\n+\t  output_asm_insn (\\\"movd %1,tos\\\", operands);\n+\t  return \\\"movl tos,%0\\\";\n+\t}\n+      return \\\"movl %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\\\"movl %1,tos\\;movd tos,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"movd tos,%0\\\";\n+\t}\n+      else\n+        return \\\"movl %1,%0\\\";\n+    }\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fg<\")\n+\t(match_operand:SF 1 \"general_operand\" \"fFg\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+\treturn \\\"movd %1,tos\\;movf tos,%0\\\";\n+      else\n+\treturn \\\"movf %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\treturn \\\"movf %1,tos\\;movd tos,%0\\\";\n+      return \\\"movf %1,%0\\\";\n+    }\n+#if 0\n+#ifndef GAS_SYNTAX\n+  /* GAS understands floating constants in ordinary movd instructions\n+     but other assemblers might object.  */\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      union {int i[2]; float f; double d;} convrt;\n+      convrt.i[0] = CONST_DOUBLE_LOW (operands[1]);\n+      convrt.i[1] = CONST_DOUBLE_HIGH (operands[1]);\n+      convrt.f = convrt.d;\n+\n+      /* Is there a better machine-independent way to to this?  */\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, convrt.i[0]);\n+      return \\\"movd %1,%0\\\";\n+    }\n+#endif\n+#endif\n+  else return \\\"movd %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:TI 1 \"memory_operand\" \"m\"))]\n+  \"\"\n+  \"movmd %1,%0,4\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&g<,*f,g\")\n+\t(match_operand:DI 1 \"general_operand\" \"gF,g,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn \\\"movl %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"movd %1,tos\\\", xoperands);\n+\t  output_asm_insn (\\\"movd %1,tos\\\", operands);\n+\t  return \\\"movl tos,%0\\\";\n+\t}\n+      return \\\"movl %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\\\"movl %1,tos\\;movd tos,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"movd tos,%0\\\";\n+\t}\n+      else\n+        return \\\"movl %1,%0\\\";\n+    }\n+  return output_move_double (operands);\n+}\")\n+\n+;; This special case must precede movsi.\n+(define_insn \"\"\n+  [(set (reg:SI 17)\n+\t(match_operand:SI 0 \"general_operand\" \"rmn\"))]\n+  \"\"\n+  \"lprd sp,%0\")\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<,*f,g\")\n+\t(match_operand:SI 1 \"general_operand\" \"gxy,g,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+\treturn \\\"movd %1,tos\\;movf tos,%0\\\";\n+      else\n+\treturn \\\"movf %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\treturn \\\"movf %1,tos\\;movd tos,%0\\\";\n+      return \\\"movf %1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[1]);\n+      if (i <= 7 && i >= -8)\n+\treturn \\\"movqd %1,%0\\\";\n+      if (i < 0x4000 && i >= -0x4000 && ! TARGET_32532)\n+#if defined (GNX_V3) || defined (UTEK_ASM)\n+\treturn \\\"addr %c1,%0\\\";\n+#else\n+\treturn \\\"addr @%c1,%0\\\";\n+#endif\n+      return \\\"movd %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[1]) == REG)\n+    {\n+      if (REGNO (operands[1]) < 16)\n+        return \\\"movd %1,%0\\\";\n+      else if (REGNO (operands[1]) == FRAME_POINTER_REGNUM)\n+\t{\n+\t  if (GET_CODE(operands[0]) == REG)\n+\t    return \\\"sprd fp,%0\\\";\n+\t  else\n+\t    return \\\"addr 0(fp),%0\\\" ;\n+\t}\n+      else if (REGNO (operands[1]) == STACK_POINTER_REGNUM)\n+\t{\n+\t  if (GET_CODE(operands[0]) == REG)\n+\t    return \\\"sprd sp,%0\\\";\n+\t  else\n+\t    return \\\"addr 0(sp),%0\\\" ;\n+\t}\n+      else abort ();\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    return \\\"movd %1,%0\\\";\n+  /* Check if this effective address can be\n+     calculated faster by pulling it apart.  */\n+  if (REG_P (operands[0])\n+      && GET_CODE (operands[1]) == MULT\n+      && GET_CODE (XEXP (operands[1], 1)) == CONST_INT\n+      && (INTVAL (XEXP (operands[1], 1)) == 2\n+\t  || INTVAL (XEXP (operands[1], 1)) == 4))\n+    {\n+      rtx xoperands[3];\n+      xoperands[0] = operands[0];\n+      xoperands[1] = XEXP (operands[1], 0);\n+      xoperands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (XEXP (operands[1], 1)) >> 1);\n+      return output_shift_insn (xoperands);\n+    }\n+  return \\\"addr %a1,%0\\\";\n+}\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<,*f,g\")\n+\t(match_operand:HI 1 \"general_operand\" \"g,g,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      short i = INTVAL (operands[1]);\n+      if (i <= 7 && i >= -8)\n+\t{\n+\t  if (INTVAL (operands[1]) > 7)\n+\t    operands[1] =\n+\t      gen_rtx (CONST_INT, VOIDmode, i);\n+\t  return \\\"movqw %1,%0\\\";\n+\t}\n+\treturn \\\"movw %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+\treturn \\\"movwf %1,tos\\;movf tos,%0\\\";\n+      else\n+\treturn \\\"movwf %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\treturn \\\"movf %1,tos\\;movd tos,%0\\\";\n+      return \\\"movf %1,%0\\\";\n+    }\n+  else\n+     return \\\"movw %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+r\"))\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL(operands[1]) <= 7 && INTVAL(operands[1]) >= -8)\n+    return \\\"movqw %1,%0\\\";\n+  return \\\"movw %1,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<,*f,g\")\n+\t(match_operand:QI 1 \"general_operand\" \"g,g,*f\"))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      char char_val = (char)INTVAL (operands[1]);\n+      if (char_val <= 7 && char_val >= -8)\n+\t{\n+\t  if (INTVAL (operands[1]) > 7)\n+\t    operands[1] =\n+\t      gen_rtx (CONST_INT, VOIDmode, char_val);\n+\t  return \\\"movqb %1,%0\\\";\n+\t}\n+\treturn \\\"movb %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+\treturn \\\"movbf %1,tos\\;movf tos,%0\\\";\n+      else\n+\treturn \\\"movbf %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\treturn \\\"movf %1,tos\\;movd tos,%0\\\";\n+      return \\\"movf %1,%0\\\";\n+    }\n+  else\n+     return \\\"movb %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+r\"))\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL(operands[1]) < 8 && INTVAL(operands[1]) > -9)\n+    return \\\"movqb %1,%0\\\";\n+  return \\\"movb %1,%0\\\";\n+}\")\n+\f\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it won't successfully combine with anything.\n+(define_insn \"movstrsi\"\n+  [(set (match_operand:BLK 0 \"general_operand\" \"=g\")\n+\t(match_operand:BLK 1 \"general_operand\" \"g\"))\n+   (use (match_operand:SI 2 \"general_operand\" \"rmn\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+    abort ();\n+  operands[0] = XEXP (operands[0], 0);\n+  operands[1] = XEXP (operands[1], 0);\n+  if (GET_CODE (operands[0]) == MEM)\n+    if (GET_CODE (operands[1]) == MEM)\n+      output_asm_insn (\\\"movd %0,r2\\;movd %1,r1\\\", operands);\n+    else\n+      output_asm_insn (\\\"movd %0,r2\\;addr %a1,r1\\\", operands);\n+  else if (GET_CODE (operands[1]) == MEM)\n+    output_asm_insn (\\\"addr %a0,r2\\;movd %1,r1\\\", operands);\n+  else\n+    output_asm_insn (\\\"addr %a0,r2\\;addr %a1,r1\\\", operands);\n+\n+#ifdef UTEK_ASM\n+  if (GET_CODE (operands[2]) == CONST_INT && (INTVAL (operands[2]) & 0x3) == 0)\n+    {\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) >> 2);\n+      if ((unsigned) INTVAL (operands[2]) <= 7)\n+\treturn \\\"movqd %2,r0\\;movsd $0\\\";\n+      else \n+\treturn \\\"movd %2,r0\\;movsd $0\\\";\n+    }\n+  else\n+    {\n+      return \\\"movd %2,r0\\;movsb $0\\\";\n+    }\n+#else\n+  if (GET_CODE (operands[2]) == CONST_INT && (INTVAL (operands[2]) & 0x3) == 0)\n+    {\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) >> 2);\n+      if ((unsigned) INTVAL (operands[2]) <= 7)\n+\treturn \\\"movqd %2,r0\\;movsd\\\";\n+      else \n+\treturn \\\"movd %2,r0\\;movsd\\\";\n+    }\n+  else\n+    {\n+      return \\\"movd %2,r0\\;movsb\\\";\n+    }\n+#endif\n+}\")\n+\f\n+;; Extension and truncation insns.\n+;; Those for integer source operand\n+;; are ordered widest source type first.\n+\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"rmn\")))]\n+  \"\"\n+  \"movb %1,%0\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"rmn\")))]\n+  \"\"\n+  \"movw %1,%0\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(truncate:QI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movb %1,%0\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movxwd %1,%0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movxbw %1,%0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movxbd %1,%0\")\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+\t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"movfl %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n+\t(float_truncate:SF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"movlf %1,%0\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movzwd %1,%0\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movzbw %1,%0\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n+  \"\"\n+  \"movzbd %1,%0\")\n+\f\n+;; Fix-to-float conversion insns.\n+;; Note that the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+;; Rumor has it that the National part does not correctly convert\n+;; constant ints to floats.  This conversion is therefore disabled.\n+;; A register must be used to perform the conversion.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n+\t(float:SF (match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_32081\"\n+  \"movdf %1,%0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+\t(float:DF (match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_32081\"\n+  \"movdl %1,%0\")\n+\n+(define_insn \"floathisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n+\t(float:SF (match_operand:HI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_32081\"\n+  \"movwf %1,%0\")\n+\n+(define_insn \"floathidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+\t(float:DF (match_operand:HI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_32081\"\n+  \"movwl %1,%0\")\n+\n+(define_insn \"floatqisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n+\t(float:SF (match_operand:QI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_32081\"\n+  \"movbf %1,%0\")\n+\n+; Some assemblers warn that this insn doesn't work.\n+; Maybe they know something we don't.\n+;(define_insn \"floatqidf2\"\n+;  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+;\t(float:DF (match_operand:QI 1 \"general_operand\" \"rm\")))]\n+;  \"TARGET_32081\"\n+;  \"movbl %1,%0\")\n+\f\n+;; Float-to-fix conversion insns.\n+;; The sequent compiler always generates \"trunc\" insns.\n+\n+(define_insn \"fixsfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(fix:QI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncfb %1,%0\")\n+\n+(define_insn \"fixsfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(fix:HI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncfw %1,%0\")\n+\n+(define_insn \"fixsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncfd %1,%0\")\n+\n+(define_insn \"fixdfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"trunclb %1,%0\")\n+\n+(define_insn \"fixdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"trunclw %1,%0\")\n+\n+(define_insn \"fixdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncld %1,%0\")\n+\n+;; Unsigned\n+\n+(define_insn \"fixunssfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(unsigned_fix:QI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncfb %1,%0\")\n+\n+(define_insn \"fixunssfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(unsigned_fix:HI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncfw %1,%0\")\n+\n+(define_insn \"fixunssfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncfd %1,%0\")\n+\n+(define_insn \"fixunsdfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(unsigned_fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"trunclb %1,%0\")\n+\n+(define_insn \"fixunsdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(unsigned_fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"trunclw %1,%0\")\n+\n+(define_insn \"fixunsdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+  \"TARGET_32081\"\n+  \"truncld %1,%0\")\n+\n+;;; These are not yet used by GCC\n+(define_insn \"fix_truncsfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(fix:QI (match_operand:SF 1 \"general_operand\" \"fm\")))]\n+  \"TARGET_32081\"\n+  \"truncfb %1,%0\")\n+\n+(define_insn \"fix_truncsfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(fix:HI (match_operand:SF 1 \"general_operand\" \"fm\")))]\n+  \"TARGET_32081\"\n+  \"truncfw %1,%0\")\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(fix:SI (match_operand:SF 1 \"general_operand\" \"fm\")))]\n+  \"TARGET_32081\"\n+  \"truncfd %1,%0\")\n+\n+(define_insn \"fix_truncdfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(fix:QI (match_operand:DF 1 \"general_operand\" \"fm\")))]\n+  \"TARGET_32081\"\n+  \"trunclb %1,%0\")\n+\n+(define_insn \"fix_truncdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(fix:HI (match_operand:DF 1 \"general_operand\" \"fm\")))]\n+  \"TARGET_32081\"\n+  \"trunclw %1,%0\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(fix:SI (match_operand:DF 1 \"general_operand\" \"fm\")))]\n+  \"TARGET_32081\"\n+  \"truncld %1,%0\")\n+\f\n+;;- All kinds of add instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"addl %2,%0\")\n+\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm\")\n+\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"addf %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 17)\n+\t(plus:SI (reg:SI 17)\n+\t\t (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n+  \"GET_CODE (operands[0]) == CONST_INT\"\n+  \"*\n+{\n+#ifndef SEQUENT_ADJUST_STACK\n+  if (TARGET_32532)\n+    if (INTVAL (operands[0]) == 8)\n+      return \\\"cmpd tos,tos\\\";\n+  if (TARGET_32532 || TARGET_32332)\n+    if (INTVAL (operands[0]) == 4)\n+      return \\\"cmpqd %$0,tos\\\";\n+#endif\n+  if (! TARGET_32532)\n+    {\n+      if (INTVAL (operands[0]) < 64 && INTVAL (operands[0]) > -64)\n+        return \\\"adjspb %$%n0\\\";\n+      else if (INTVAL (operands[0]) < 8192 && INTVAL (operands[0]) >= -8192)\n+        return \\\"adjspw %$%n0\\\";\n+    }\n+  return \\\"adjspd %$%n0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(plus:SI (reg:SI 16)\n+\t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"GET_CODE (operands[1]) == CONST_INT\"\n+  \"addr %c1(fp),%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(plus:SI (reg:SI 17)\n+\t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n+  \"GET_CODE (operands[1]) == CONST_INT\"\n+  \"addr %c1(sp),%0\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,=g<\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,%r\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmn,n\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    {\n+      int i = INTVAL (operands[2]);\n+      if ( i < 0x40000000 && i >= -0x40000000 )\n+\t  return \\\"addr %c2(%1),%0\\\";\n+      else\n+\t  return \\\"movd %1,%0\\;addd %2,%0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+\n+      if (i <= 7 && i >= -8)\n+\treturn \\\"addqd %2,%0\\\";\n+      else if (GET_CODE (operands[0]) == REG\n+\t       && i < 0x4000 && i >= -0x4000 && ! TARGET_32532)\n+\treturn \\\"addr %c2(%0),%0\\\";\n+    }\n+  return \\\"addd %2,%0\\\";\n+}\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+      if (i <= 7 && i >= -8)\n+\treturn \\\"addqw %2,%0\\\";\n+    }\n+  return \\\"addw %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"=r\"))\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) >-9 && INTVAL(operands[1]) < 8)\n+    return \\\"addqw %1,%0\\\";\n+  return \\\"addw %1,%0\\\";\n+}\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+      if (i <= 7 && i >= -8)\n+\treturn \\\"addqb %2,%0\\\";\n+    }\n+  return \\\"addb %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"=r\"))\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) >-9 && INTVAL(operands[1]) < 8)\n+    return \\\"addqb %1,%0\\\";\n+  return \\\"addb %1,%0\\\";\n+}\")\n+\f\n+;;- All kinds of subtract instructions.\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"subl %2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm\")\n+\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:SF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"subf %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 17)\n+\t(minus:SI (reg:SI 17)\n+\t\t  (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n+  \"GET_CODE (operands[0]) == CONST_INT\"\n+  \"*\n+{\n+  if (GET_CODE(operands[0]) == CONST_INT && INTVAL(operands[0]) < 64\n+      && INTVAL(operands[0]) > -64 && ! TARGET_32532)\n+    return \\\"adjspb %0\\\";\n+  return \\\"adjspd %0\\\";\n+}\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+\n+      if (i <= 8 && i >= -7)\n+        return \\\"addqd %$%n2,%0\\\";\n+    }\n+  return \\\"subd %2,%0\\\";\n+}\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+\n+      if (i <= 8 && i >= -7)\n+        return \\\"addqw %$%n2,%0\\\";\n+    }\n+  return \\\"subw %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"=r\"))\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) >-8 && INTVAL(operands[1]) < 9)\n+    return \\\"addqw %$%n1,%0\\\";\n+  return \\\"subw %1,%0\\\";\n+}\")\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int i = INTVAL (operands[2]);\n+\n+      if (i <= 8 && i >= -7)\n+\treturn \\\"addqb %$%n2,%0\\\";\n+    }\n+  return \\\"subb %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"=r\"))\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) >-8 && INTVAL(operands[1]) < 9)\n+    return \\\"addqb %$%n1,%0\\\";\n+  return \\\"subb %1,%0\\\";\n+}\")\n+\f\n+;;- Multiply instructions.\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"mull %2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm\")\n+\t(mult:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"mulf %2,%0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"muld %2,%0\")\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mulw %2,%0\")\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(mult:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mulb %2,%0\")\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=g\")\n+\t(mult:DI (zero_extend:DI\n+\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"0\"))\n+\t\t (zero_extend:DI\n+\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"rmn\"))))]\n+  \"\"\n+  \"meid %2,%0\")\n+\f\n+;;- Divide instructions.\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"divl %2,%0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm\")\n+\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"divf %2,%0\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"quod %2,%0\")\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"quow %2,%0\")\n+\n+(define_insn \"divqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(div:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"quob %2,%0\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(udiv:SI (subreg:SI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  return \\\"deid %2,%0\\;movd %1,%0\\\";\n+}\")\n+\n+(define_insn \"udivhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(udiv:HI (subreg:HI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (REG, HImode, REGNO (operands[0]) + 1);\n+  return \\\"deiw %2,%0\\;movw %1,%0\\\";\n+}\")\n+\n+(define_insn \"udivqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(udiv:QI (subreg:QI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (REG, QImode, REGNO (operands[0]) + 1);\n+  return \\\"deib %2,%0\\;movb %1,%0\\\";\n+}\")\n+\n+;; Remainder instructions.\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(mod:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"remd %2,%0\")\n+\n+(define_insn \"modhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(mod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"remw %2,%0\")\n+\n+(define_insn \"modqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(mod:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"remb %2,%0\")\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(umod:SI (subreg:SI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"deid %2,%0\")\n+\n+(define_insn \"umodhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(umod:HI (subreg:HI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n+\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"deiw %2,%0\")\n+\n+(define_insn \"umodqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(umod:QI (subreg:QI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n+\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"deib %2,%0\")\n+\n+; This isn't be usable in its current form.\n+;(define_insn \"udivmoddisi4\"\n+;  [(set (subreg:SI (match_operand:DI 0 \"general_operand\" \"=r\") 1)\n+;\t(udiv:SI (match_operand:DI 1 \"general_operand\" \"0\")\n+;\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))\n+;   (set (subreg:SI (match_dup 0) 0)\n+;\t(umod:SI (match_dup 1) (match_dup 2)))]\n+;  \"\"\n+;  \"deid %2,%0\")\n+\f\n+;;- Logical Instructions: AND\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if ((INTVAL (operands[2]) | 0xff) == 0xffffffff)\n+\t{\n+\t  if (INTVAL (operands[2]) == 0xffffff00)\n+\t    return \\\"movqb %$0,%0\\\";\n+\t  else\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     INTVAL (operands[2]) & 0xff);\n+\t      return \\\"andb %2,%0\\\";\n+\t    }\n+\t}\n+      if ((INTVAL (operands[2]) | 0xffff) == 0xffffffff)\n+        {\n+\t  if (INTVAL (operands[2]) == 0xffff0000)\n+\t    return \\\"movqw %$0,%0\\\";\n+\t  else\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     INTVAL (operands[2]) & 0xffff);\n+\t      return \\\"andw %2,%0\\\";\n+\t    }\n+\t}\n+    }\n+  return \\\"andd %2,%0\\\";\n+}\")\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (INTVAL (operands[2]) | 0xff) == 0xffffffff)\n+    {\n+      if (INTVAL (operands[2]) == 0xffffff00)\n+\treturn \\\"movqb %$0,%0\\\";\n+      else\n+\t{\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t INTVAL (operands[2]) & 0xff);\n+\t  return \\\"andb %2,%0\\\";\n+\t}\n+    }\n+  return \\\"andw %2,%0\\\";\n+}\")\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"andb %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"bicd %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"g\"))\n+\t\t(match_operand:HI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"bicw %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"g\"))\n+\t\t(match_operand:QI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"bicb %1,%0\")\n+\f\n+;;- Bit set instructions.\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT) {\n+    if ((INTVAL (operands[2]) & 0xffffff00) == 0)\n+      return \\\"orb %2,%0\\\";\n+    if ((INTVAL (operands[2]) & 0xffff0000) == 0)\n+      return \\\"orw %2,%0\\\";\n+  }\n+  return \\\"ord %2,%0\\\";\n+}\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE(operands[2]) == CONST_INT &&\n+      (INTVAL(operands[2]) & 0xffffff00) == 0)\n+    return \\\"orb %2,%0\\\";\n+  return \\\"orw %2,%0\\\";\n+}\")\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"orb %2,%0\")\n+\n+;;- xor instructions.\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT) {\n+    if ((INTVAL (operands[2]) & 0xffffff00) == 0)\n+      return \\\"xorb %2,%0\\\";\n+    if ((INTVAL (operands[2]) & 0xffff0000) == 0)\n+      return \\\"xorw %2,%0\\\";\n+  }\n+  return \\\"xord %2,%0\\\";\n+}\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE(operands[2]) == CONST_INT &&\n+      (INTVAL(operands[2]) & 0xffffff00) == 0)\n+    return \\\"xorb %2,%0\\\";\n+  return \\\"xorw %2,%0\\\";\n+}\")\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"xorb %2,%0\")\n+\f\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+\t(neg:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"negl %1,%0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n+\t(neg:SF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"negf %1,%0\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"negd %1,%0\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"negw %1,%0\")\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"negb %1,%0\")\n+\f\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"comd %1,%0\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"comw %1,%0\")\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(not:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"comb %1,%0\")\n+\f\n+;; arithmetic left and right shift operations\n+;; on the 32532 we will always use lshd for arithmetic left shifts,\n+;; because it is three times faster.  Broken programs which\n+;; use negative shift counts are probably broken differently\n+;; than elsewhere.\n+\n+;; alternative 0 never matches on the 32532\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,g\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"r,0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"I,rmn\")))]\n+  \"\"\n+  \"*\n+{ if (TARGET_32532)\n+    return \\\"lshd %2,%0\\\";\n+  else\n+    return output_shift_insn (operands);\n+}\")\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[2]) == 1)\n+\treturn \\\"addw %0,%0\\\";\n+      else if (INTVAL (operands[2]) == 2 && !TARGET_32532)\n+\treturn \\\"addw %0,%0\\;addw %0,%0\\\";\n+    }\n+  if (TARGET_32532)\n+    return \\\"lshw %2,%0\\\";\n+  else\n+    return \\\"ashw %2,%0\\\";\n+}\")\n+\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[2]) == 1)\n+\treturn \\\"addb %0,%0\\\";\n+      else if (INTVAL (operands[2]) == 2 && !TARGET_32532)\n+\treturn \\\"addb %0,%0\\;addb %0,%0\\\";\n+    }\n+  if (TARGET_32532)\n+    return \\\"lshb %2,%0\\\";\n+  else\n+    return \\\"ashb %2,%0\\\";\n+}\")\n+\n+;; Arithmetic right shift on the 32k works by negating the shift count.\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"ashd %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"ashd %2,%0\")\n+\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"ashw %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"ashw %2,%0\")\n+\n+(define_expand \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"ashb %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"ashb %2,%0\")\n+\n+;; logical shift instructions\n+\n+(define_insn \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(lshift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"lshd %2,%0\")\n+\n+(define_insn \"lshlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(lshift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"lshw %2,%0\")\n+\n+(define_insn \"lshlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(lshift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"lshb %2,%0\")\n+\n+;; Logical right shift on the 32k works by negating the shift count.\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"lshd %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"lshd %2,%0\")\n+\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"lshw %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"lshw %2,%0\")\n+\n+(define_expand \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"lshb %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"lshb %2,%0\")\n+\n+;; Rotate instructions\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"rotd %2,%0\")\n+\n+(define_insn \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"rotw %2,%0\")\n+\n+(define_insn \"rotlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"rotb %2,%0\")\n+\n+;; Right rotate on the 32k works by negating the shift count.\n+(define_expand \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"rotd %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"rotd %2,%0\")\n+\n+(define_expand \"rotrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"rotw %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"rotw %2,%0\")\n+\n+(define_expand \"rotrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"rotb %$%n2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"\"\n+  \"rotb %2,%0\")\n+\f\n+;;- load or push effective address \n+;; These come after the move, add, and multiply patterns\n+;; because we don't want pushl $1 turned into pushad 1.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[0])\n+      && GET_CODE (operands[1]) == MULT\n+      && GET_CODE (XEXP (operands[1], 1)) == CONST_INT\n+      && (INTVAL (XEXP (operands[1], 1)) == 2\n+\t  || INTVAL (XEXP (operands[1], 1)) == 4))\n+    {\n+      rtx xoperands[3];\n+      xoperands[0] = operands[0];\n+      xoperands[1] = XEXP (operands[1], 0);\n+      xoperands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (XEXP (operands[1], 1)) >> 1);\n+      return output_shift_insn (xoperands);\n+    }\n+  return \\\"addr %a1,%0\\\";\n+}\")\n+\f\n+;;; Index insns.  These are about the same speed as multiply-add counterparts.\n+;;; but slower then using power-of-2 shifts if we can use them\n+;\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;\t(plus:SI (match_operand:SI 1 \"general_operand\" \"rmn\")\n+;\t\t (mult:SI (match_operand:SI 2 \"register_operand\" \"0\")\n+;\t\t\t  (plus:SI (match_operand:SI 3 \"general_operand\" \"rmn\") (const_int 1)))))]\n+;  \"GET_CODE (operands[3]) != CONST_INT || INTVAL (operands[3]) > 8\"\n+;  \"indexd %0,%3,%1\")\n+;\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+;\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+;\t\t\t  (plus:SI (match_operand:SI 2 \"general_operand\" \"rmn\") (const_int 1)))\n+;\t\t (match_operand:SI 3 \"general_operand\" \"rmn\")))]\n+;  \"GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) > 8\"\n+;  \"indexd %0,%2,%3\")\n+\f\n+;; Set, Clear, and Invert bit\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t(const_int 1))]\n+  \"\"\n+  \"sbitd %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t(const_int 0))]\n+  \"\"\n+  \"cbitd %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t(xor:SI (ashift:SI (const_int 1)\n+\t\t\t   (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t\t(match_dup 0)))]\n+  \"\"\n+  \"ibitd %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(xor:QI (subreg:QI\n+\t\t (ashift:SI (const_int 1)\n+\t\t\t    (match_operand:QI 1 \"general_operand\" \"rmn\")) 0)\n+\t\t(match_dup 0)))]\n+  \"\"\n+  \"ibitb %1,%0\")\n+\n+;; Recognize jbs and jbc instructions.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extract (match_operand:SI 0 \"general_operand\" \"rm\")\n+\t\t      (const_int 1)\n+\t\t      (match_operand:SI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{ cc_status.flags = CC_Z_IN_F;\n+  return \\\"tbitd %1,%0\\\";\n+}\")\n+\n+;; extract(base, width, offset)\n+;; Signed bitfield extraction is not supported in hardware on the\n+;; NS 32032.  It is therefore better to let GCC figure out a\n+;; good strategy for generating the proper instruction sequence\n+;; and represent it as rtl.\n+\n+;; Optimize the case of extracting a byte or word from a register.\n+;; Otherwise we must load a register with the offset of the\n+;; chunk we want, and perform an extract insn (each of which\n+;; is very expensive).  Since we use the stack to do our bit-twiddling\n+;; we cannot use it for a destination.  Perhaps things are fast\n+;; enough on the 32532 that such hacks are not needed.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=ro\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && (INTVAL (operands[3]) == 8 || INTVAL (operands[3]) == 16 || INTVAL (operands[3]) == 24)\"\n+  \"*\n+{\n+  output_asm_insn (\\\"movd %1,tos\\\", operands);\n+  if (INTVAL (operands[2]) == 16)\n+    {\n+      if (INTVAL (operands[3]) == 8)\n+\toutput_asm_insn (\\\"movzwd 1(sp),%0\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"movzwd 2(sp),%0\\\", operands);\n+    }\n+  else\n+    {\n+      if (INTVAL (operands[3]) == 8)\n+\toutput_asm_insn (\\\"movzbd 1(sp),%0\\\", operands);\n+      else if (INTVAL (operands[3]) == 16)\n+\toutput_asm_insn (\\\"movzbd 2(sp),%0\\\", operands);\n+      else\n+\toutput_asm_insn (\\\"movzbd 3(sp),%0\\\", operands);\n+    }\n+  if (TARGET_32532 || TARGET_32332)\n+    return \\\"cmpqd %$0,tos\\\";\n+  else\n+    return \\\"adjspb %$-4\\\";\n+}\")\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(zero_extract:SI (match_operand:QI 1 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"rK\")))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[3]) == CONST_INT)\n+    return \\\"extsd %1,%0,%3,%2\\\";\n+  else return \\\"extd %3,%1,%0,%2\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"memory_operand\" \"+o\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rn\"))\n+\t(match_operand:SI 3 \"general_operand\" \"rm\"))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[2]) >= 8)\n+\t{\n+\t  operands[0] = adj_offsettable_operand (operands[0],\n+\t\t\t\t\t        INTVAL (operands[2]) / 8);\n+          operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) % 8);\n+\t}\n+      if (INTVAL (operands[1]) <= 8)\n+        return \\\"inssb %3,%0,%2,%1\\\";\n+      else if (INTVAL (operands[1]) <= 16)\n+\treturn \\\"inssw %3,%0,%2,%1\\\";\n+      else\n+\treturn \\\"inssd %3,%0,%2,%1\\\";\n+    }\n+  return \\\"insd %2,%3,%0,%1\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rK\"))\n+\t(match_operand:SI 3 \"general_operand\" \"rm\"))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    if (INTVAL (operands[1]) <= 8)\n+      return \\\"inssb %3,%0,%2,%1\\\";\n+    else if (INTVAL (operands[1]) <= 16)\n+      return \\\"inssw %3,%0,%2,%1\\\";\n+    else\n+      return \\\"inssd %3,%0,%2,%1\\\";\n+  return \\\"insd %2,%3,%0,%1\\\";\n+}\")\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"+g\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rK\"))\n+\t(match_operand:SI 3 \"general_operand\" \"rm\"))]\n+  \"\"\n+  \"*\n+{ if (GET_CODE (operands[2]) == CONST_INT)\n+    if (INTVAL (operands[1]) <= 8)\n+      return \\\"inssb %3,%0,%2,%1\\\";\n+    else if (INTVAL (operands[1]) <= 16)\n+      return \\\"inssw %3,%0,%2,%1\\\";\n+    else\n+      return \\\"inssd %3,%0,%2,%1\\\";\n+  return \\\"insd %2,%3,%0,%1\\\";\n+}\")\n+\n+\f\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"br %l0\")\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"bfc %l0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"bfs %l0\\\";\n+  else return \\\"beq %l0\\\";\n+}\")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"bfs %l0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"bfc %l0\\\";\n+  else return \\\"bne %l0\\\";\n+}\")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bgt %l0\")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bhi %l0\")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"blt %l0\")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"blo %l0\")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bge %l0\")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bhs %l0\")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"ble %l0\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bls %l0\")\n+\f\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"bfs %l0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"bfc %l0\\\";\n+  else return \\\"bne %l0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"bfc %l0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"bfs %l0\\\";\n+  else return \\\"beq %l0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"ble %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bls %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bge %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bhs %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"blt %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"blo %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bgt %l0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bhi %l0\")\n+\f\n+;; Subtract-and-jump and Add-and-jump insns.\n+;; These can actually be used for adding numbers in the range -8 to 7\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+  (set (match_dup 0)\n+       (minus:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"INTVAL (operands[1]) > -8 && INTVAL (operands[1]) <= 8\"\n+  \"acbd %$%n1,%0,%l2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:SI 0 \"general_operand\" \"+g\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+  (set (match_dup 0)\n+       (plus:SI (match_dup 0)\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"INTVAL (operands[1]) == - INTVAL (operands[3])\n+   && INTVAL (operands[3]) >= -8 && INTVAL (operands[3]) < 8\"\n+  \"acbd %3,%0,%l2\")\n+\f\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t (match_operand:QI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+#ifndef JSR_ALWAYS\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      rtx temp = XEXP (operands[0], 0);\n+      if (CONSTANT_ADDRESS_P (temp))\n+\t{\n+\t  operands[0] = temp;\n+\t  return \\\"bsr %0\\\";\n+#if 0\n+#ifdef GNX_V3\n+\t  return \\\"bsr %0\\\";\n+#else\n+\t  return \\\"bsr %?%a0\\\";\n+#endif\n+#endif\n+\t}\n+      if (GET_CODE (XEXP (operands[0], 0)) == REG)\n+\treturn \\\"jsr %0\\\";\n+#if 0\n+        return \\\"jsr %a0\\\";\n+#endif\n+    }\n+#endif /* not JSR_ALWAYS */\n+  return \\\"jsr %0\\\";\n+}\")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+#ifndef JSR_ALWAYS\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx temp = XEXP (operands[1], 0);\n+      if (CONSTANT_ADDRESS_P (temp))\n+\t{\n+\t  operands[1] = temp;\n+\t  return \\\"bsr %1\\\";\n+#if 0\n+#ifdef GNX_V3\n+\t  return \\\"bsr %1\\\";\n+#else\n+\t  return \\\"bsr %?%a1\\\";\n+#endif\n+#endif\n+\t}\n+      if (GET_CODE (XEXP (operands[1], 0)) == REG)\n+\treturn \\\"jsr %1\\\";\n+#if 0\n+        return \\\"jsr %a1\\\";\n+#endif\n+    }\n+#endif /* not JSR_ALWAYS */\n+  return \\\"jsr %1\\\";\n+}\")\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"0\"\n+  \"ret 0\")\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n+\t(abs:SF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"absf %1,%0\")\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+\t(abs:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_32081\"\n+  \"absl %1,%0\")\n+\n+(define_insn \"abssi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(abs:SI (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+  \"\"\n+  \"absd %1,%0\")\n+\n+(define_insn \"abshi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(abs:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"absw %1,%0\")\n+\n+(define_insn \"absqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(abs:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"absb %1,%0\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jump %0\")\n+\f\n+;;(define_insn \"tablejump\"\n+;;  [(set (pc)\n+;;\t(plus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+;;\t\t (pc)))]\n+;;  \"\"\n+;;  \"cased %0\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(plus:SI (pc) (match_operand:HI 0 \"general_operand\" \"g\")))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LI\\\",\n+\t\t\t     CODE_LABEL_NUMBER (operands[1]));\n+  return \\\"casew %0\\\";\n+}\")\n+\n+;;(define_insn \"\"\n+;;  [(set (pc)\n+;;\t(plus:SI (match_operand:QI 0 \"general_operand\" \"g\")\n+;;\t\t (pc)))]\n+;;  \"\"\n+;;  \"caseb %0\")\n+\f\n+;; Scondi instructions\n+(define_insn \"seq\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(eq:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"sfcd %0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"sfsd %0\\\";\n+  else return \\\"seqd %0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(eq:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"sfcw %0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"sfsw %0\\\";\n+  else return \\\"seqw %0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(eq:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"sfcb %0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"sfsb %0\\\";\n+  else return \\\"seqb %0\\\";\n+}\")\n+\n+(define_insn \"sne\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(ne:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"sfsd %0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"sfcd %0\\\";\n+  else return \\\"sned %0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(ne:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"sfsw %0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"sfcw %0\\\";\n+  else return \\\"snew %0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(ne:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+{ if (cc_prev_status.flags & CC_Z_IN_F)\n+    return \\\"sfsb %0\\\";\n+  else if (cc_prev_status.flags & CC_Z_IN_NOT_F)\n+    return \\\"sfcb %0\\\";\n+  else return \\\"sneb %0\\\";\n+}\")\n+\n+(define_insn \"sgt\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(gt:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sgtd %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(gt:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sgtw %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(gt:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sgtb %0\")\n+\n+(define_insn \"sgtu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(gtu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"shid %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(gtu:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"shiw %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(gtu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"shib %0\")\n+\n+(define_insn \"slt\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(lt:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sltd %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(lt:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sltw %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(lt:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sltb %0\")\n+\n+(define_insn \"sltu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(ltu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slod %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(ltu:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slow %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(ltu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slob %0\")\n+\n+(define_insn \"sge\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(ge:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sged %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(ge:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sgew %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(ge:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sgeb %0\")\n+\n+(define_insn \"sgeu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(geu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"shsd %0\")  \n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(geu:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"shsw %0\")  \n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(geu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"shsb %0\")  \n+\n+(define_insn \"sle\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(le:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sled %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(le:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slew %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(le:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"sleb %0\")\n+\n+(define_insn \"sleu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n+\t(leu:SI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slsd %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n+\t(leu:HI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slsw %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n+\t(leu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"slsb %0\")\n+\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}