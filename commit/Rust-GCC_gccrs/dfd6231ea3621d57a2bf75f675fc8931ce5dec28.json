{"sha": "dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZkNjIzMWVhMzYyMWQ1N2EyYmY3NWY2NzVmYzg5MzFjZTVkZWMyOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-23T18:09:14Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-23T18:09:14Z"}, "message": "re PR fortran/69834 ([OOP] Collision in derived type hashes)\n\n2016-10-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/69834\n\t* class.c (gfc_find_derived_vtab): Obtain the gsymbol for the\n\tderived type's module. If the gsymbol is present and the top\n\tlevel namespace corresponds to a module, use the gsymbol name\n\tspace. In the search to see if the vtable exists, try the gsym\n\tnamespace first.\n\t* dump-parse-tree (show_code_node): Modify select case dump to\n\tshow select type construct.\n\t* resolve.c (build_loc_call): New function.\n\t(resolve_select_type): Add check for repeated type is cases.\n\tRetain selector expression and use it later instead of expr1.\n\tExclude deferred length TYPE IS cases and emit error message.\n\tStore the address for the vtable in the 'low' expression and\n\tthe hash value in the 'high' expression, for each case. Do not\n\tcall resolve_select.\n\t* trans.c(trans_code) : Call gfc_trans_select_type.\n\t* trans-stmt.c (gfc_trans_select_type_cases): New function.\n\t(gfc_trans_select_type): New function.\n\t* trans-stmt.h : Add prototype for gfc_trans_select_type.\n\n2016-10-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/69834\n\t* gfortran.dg/select_type_1.f03: Change error for overlapping\n\tTYPE IS cases.\n\t* gfortran.dg/select_type_36.f03: New test.\n\nFrom-SVN: r241450", "tree": {"sha": "fbc0891231c59b5f11319981f233231b8a38dc77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbc0891231c59b5f11319981f233231b8a38dc77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/comments", "author": null, "committer": null, "parents": [{"sha": "fb4ab5f0057f3a43636956efb5304a4c030bc449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4ab5f0057f3a43636956efb5304a4c030bc449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4ab5f0057f3a43636956efb5304a4c030bc449"}], "stats": {"total": 394, "additions": 360, "deletions": 34}, "files": [{"sha": "d057d0fade08ce0efe28b2a009091bed5ad016ff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -1,3 +1,25 @@\n+2016-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/69834\n+\t* class.c (gfc_find_derived_vtab): Obtain the gsymbol for the\n+\tderived type's module. If the gsymbol is present and the top\n+\tlevel namespace corresponds to a module, use the gsymbol name\n+\tspace. In the search to see if the vtable exists, try the gsym\n+\tnamespace first.\n+\t* dump-parse-tree (show_code_node): Modify select case dump to\n+\tshow select type construct.\n+\t* resolve.c (build_loc_call): New function.\n+\t(resolve_select_type): Add check for repeated type is cases.\n+\tRetain selector expression and use it later instead of expr1.\n+\tExclude deferred length TYPE IS cases and emit error message.\n+\tStore the address for the vtable in the 'low' expression and\n+\tthe hash value in the 'high' expression, for each case. Do not\n+\tcall resolve_select.\n+\t* trans.c(trans_code) : Call gfc_trans_select_type.\n+\t* trans-stmt.c (gfc_trans_select_type_cases): New function.\n+\t(gfc_trans_select_type): New function.\n+\t* trans-stmt.h : Add prototype for gfc_trans_select_type.\n+\n 2016-10-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/78021"}, {"sha": "6ac543cbd614448146e51f485f28637d615e1267", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -2190,6 +2190,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   gfc_namespace *ns;\n   gfc_symbol *vtab = NULL, *vtype = NULL, *found_sym = NULL, *def_init = NULL;\n   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n+  gfc_gsymbol *gsym = NULL;\n \n   /* Find the top-level namespace.  */\n   for (ns = gfc_current_ns; ns; ns = ns->parent)\n@@ -2200,6 +2201,20 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   if (!derived->attr.unlimited_polymorphic && derived->attr.is_class)\n     derived = gfc_get_derived_super_type (derived);\n \n+  /* Find the gsymbol for the module of use associated derived types.  */\n+  if ((derived->attr.use_assoc || derived->attr.used_in_submodule)\n+       && !derived->attr.vtype && !derived->attr.is_class)\n+    gsym =  gfc_find_gsymbol (gfc_gsym_root, derived->module);\n+  else\n+    gsym = NULL;\n+\n+  /* Work in the gsymbol namespace if the top-level namespace is a module.\n+     This ensures that the vtable is unique, which is required since we use\n+     its address in SELECT TYPE.  */\n+  if (gsym && gsym->ns && ns && ns->proc_name\n+      && ns->proc_name->attr.flavor == FL_MODULE)\n+    ns = gsym->ns;\n+\n   if (ns)\n     {\n       char name[GFC_MAX_SYMBOL_LEN+1], tname[GFC_MAX_SYMBOL_LEN+1];\n@@ -2208,7 +2223,14 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n       sprintf (name, \"__vtab_%s\", tname);\n \n       /* Look for the vtab symbol in various namespaces.  */\n-      gfc_find_symbol (name, gfc_current_ns, 0, &vtab);\n+      if (gsym && gsym->ns)\n+\t{\n+\t  gfc_find_symbol (name, gsym->ns, 0, &vtab);\n+\t  if (vtab)\n+\t    ns = gsym->ns;\n+\t}\n+      if (vtab == NULL)\n+\tgfc_find_symbol (name, gfc_current_ns, 0, &vtab);\n       if (vtab == NULL)\n \tgfc_find_symbol (name, ns, 0, &vtab);\n       if (vtab == NULL)"}, {"sha": "33a28424244acc8cbb0734a3b0fce7fb85eecf07", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -227,7 +227,7 @@ show_array_ref (gfc_array_ref * ar)\n \t     print the start expression which contains the vector, in\n \t     the latter case we have to print any of lower and upper\n \t     bound and the stride, if they're present.  */\n-  \n+\n \t  if (ar->start[i] != NULL)\n \t    show_expr (ar->start[i]);\n \n@@ -429,7 +429,7 @@ show_expr (gfc_expr *p)\n \t  break;\n \n \tcase BT_CHARACTER:\n-\t  show_char_const (p->value.character.string, \n+\t  show_char_const (p->value.character.string,\n \t\t\t   p->value.character.length);\n \t  break;\n \n@@ -982,7 +982,7 @@ show_common (gfc_symtree *st)\n \tfputs (\", \", dumpfile);\n     }\n   fputc ('\\n', dumpfile);\n-}    \n+}\n \n \n /* Worker function to display the symbol tree.  */\n@@ -1238,7 +1238,7 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       for (list = omp_clauses->tile_list; list; list = list->next)\n \t{\n \t  show_expr (list->expr);\n-\t  if (list->next) \n+\t  if (list->next)\n \t    fputs (\", \", dumpfile);\n \t}\n       fputc (')', dumpfile);\n@@ -1250,7 +1250,7 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       for (list = omp_clauses->wait_list; list; list = list->next)\n \t{\n \t  show_expr (list->expr);\n-\t  if (list->next) \n+\t  if (list->next)\n \t    fputs (\", \", dumpfile);\n \t}\n       fputc (')', dumpfile);\n@@ -1815,8 +1815,12 @@ show_code_node (int level, gfc_code *c)\n       break;\n \n     case EXEC_SELECT:\n+    case EXEC_SELECT_TYPE:\n       d = c->block;\n-      fputs (\"SELECT CASE \", dumpfile);\n+      if (c->op == EXEC_SELECT_TYPE)\n+\tfputs (\"SELECT TYPE\", dumpfile);\n+      else\n+\tfputs (\"SELECT CASE \", dumpfile);\n       show_expr (c->expr1);\n       fputc ('\\n', dumpfile);\n \n@@ -2628,7 +2632,7 @@ show_namespace (gfc_namespace *ns)\n       fputs (\"User operators:\\n\", dumpfile);\n       gfc_traverse_user_op (ns, show_uop);\n     }\n-  \n+\n   for (eq = ns->equiv; eq; eq = eq->next)\n     show_equiv (eq);\n "}, {"sha": "2a64ab7adf1d6a71328b5c7e6b080138fa8950b2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -8369,6 +8369,25 @@ fixup_array_ref (gfc_expr **expr1, gfc_expr *expr2,\n }\n \n \n+static gfc_expr *\n+build_loc_call (gfc_expr *sym_expr)\n+{\n+  gfc_expr *loc_call;\n+  loc_call = gfc_get_expr ();\n+  loc_call->expr_type = EXPR_FUNCTION;\n+  gfc_get_sym_tree (\"loc\", gfc_current_ns, &loc_call->symtree, false);\n+  loc_call->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  loc_call->symtree->n.sym->attr.intrinsic = 1;\n+  loc_call->symtree->n.sym->result = loc_call->symtree->n.sym;\n+  gfc_commit_symbol (loc_call->symtree->n.sym);\n+  loc_call->ts.type = BT_INTEGER;\n+  loc_call->ts.kind = gfc_index_integer_kind;\n+  loc_call->value.function.isym = gfc_intrinsic_function_by_id (GFC_ISYM_LOC);\n+  loc_call->value.function.actual = gfc_get_actual_arglist ();\n+  loc_call->value.function.actual->expr = sym_expr;\n+  return loc_call;\n+}\n+\n /* Resolve a SELECT TYPE statement.  */\n \n static void\n@@ -8385,6 +8404,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   int charlen = 0;\n   int rank = 0;\n   gfc_ref* ref = NULL;\n+  gfc_expr *selector_expr = NULL;\n \n   ns = code->ext.block.ns;\n   gfc_resolve (ns);\n@@ -8433,6 +8453,31 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n     {\n       c = body->ext.block.case_list;\n \n+      if (!error)\n+\t{\n+\t  /* Check for repeated cases.  */\n+\t  for (tail = code->block; tail; tail = tail->block)\n+\t    {\n+\t      gfc_case *d = tail->ext.block.case_list;\n+\t      if (tail == body)\n+\t\tbreak;\n+\n+\t      if (c->ts.type == d->ts.type\n+\t\t  && ((c->ts.type == BT_DERIVED\n+\t\t       && c->ts.u.derived && d->ts.u.derived\n+\t\t       && !strcmp (c->ts.u.derived->name,\n+\t\t\t\t   d->ts.u.derived->name))\n+\t\t      || c->ts.type == BT_UNKNOWN\n+\t\t      || (!(c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t\t\t  && c->ts.kind == d->ts.kind)))\n+\t\t{\n+\t\t  gfc_error (\"TYPE IS at %L overlaps with TYPE IS at %L\",\n+\t\t\t     &c->where, &d->where);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+\n       /* Check F03:C815.  */\n       if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n \t  && !selector_type->attr.unlimited_polymorphic\n@@ -8460,7 +8505,8 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t}\n \n       /* Check F03:C814.  */\n-      if (c->ts.type == BT_CHARACTER && c->ts.u.cl->length != NULL)\n+      if (c->ts.type == BT_CHARACTER\n+\t  && (c->ts.u.cl->length != NULL || c->ts.deferred))\n \t{\n \t  gfc_error (\"The type-spec at %L shall specify that each length \"\n \t\t     \"type parameter is assumed\", &c->where);\n@@ -8549,31 +8595,47 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   else\n     ns->code->next = new_st;\n   code = new_st;\n-  code->op = EXEC_SELECT;\n+  code->op = EXEC_SELECT_TYPE;\n \n+  /* Use the intrinsic LOC function to generate an integer expression\n+     for the vtable of the selector.  Note that the rank of the selector\n+     expression has to be set to zero.  */\n   gfc_add_vptr_component (code->expr1);\n-  gfc_add_hash_component (code->expr1);\n+  code->expr1->rank = 0;\n+  code->expr1 = build_loc_call (code->expr1);\n+  selector_expr = code->expr1->value.function.actual->expr;\n \n   /* Loop over TYPE IS / CLASS IS cases.  */\n   for (body = code->block; body; body = body->block)\n     {\n+      gfc_symbol *vtab;\n+      gfc_expr *e;\n       c = body->ext.block.case_list;\n \n-      if (c->ts.type == BT_DERIVED)\n-\tc->low = c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n-\t\t\t\t\t     c->ts.u.derived->hash_value);\n-      else if (c->ts.type != BT_CLASS && c->ts.type != BT_UNKNOWN)\n+      /* Generate an index integer expression for address of the\n+\t TYPE/CLASS vtable and store it in c->low.  The hash expression\n+\t is stored in c->high and is used to resolve intrinsic cases.  */\n+      if (c->ts.type != BT_UNKNOWN)\n \t{\n-\t  gfc_symbol *ivtab;\n-\t  gfc_expr *e;\n+\t  if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+\t    {\n+\t      vtab = gfc_find_derived_vtab (c->ts.u.derived);\n+\t      gcc_assert (vtab);\n+\t      c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t\t  c->ts.u.derived->hash_value);\n+\t    }\n+\t  else\n+\t    {\n+\t      vtab = gfc_find_vtab (&c->ts);\n+\t      gcc_assert (vtab && CLASS_DATA (vtab)->initializer);\n+\t      e = CLASS_DATA (vtab)->initializer;\n+\t      c->high = gfc_copy_expr (e);\n+\t    }\n \n-\t  ivtab = gfc_find_vtab (&c->ts);\n-\t  gcc_assert (ivtab && CLASS_DATA (ivtab)->initializer);\n-\t  e = CLASS_DATA (ivtab)->initializer;\n-\t  c->low = c->high = gfc_copy_expr (e);\n+\t  e = gfc_lval_expr_from_sym (vtab);\n+\t  c->low = build_loc_call (e);\n \t}\n-\n-      else if (c->ts.type == BT_UNKNOWN)\n+      else\n \tcontinue;\n \n       /* Associate temporary to selector.  This should only be done\n@@ -8599,8 +8661,8 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n       st = gfc_find_symtree (ns->sym_root, name);\n       gcc_assert (st->n.sym->assoc);\n-      st->n.sym->assoc->target = gfc_get_variable_expr (code->expr1->symtree);\n-      st->n.sym->assoc->target->where = code->expr1->where;\n+      st->n.sym->assoc->target = gfc_get_variable_expr (selector_expr->symtree);\n+      st->n.sym->assoc->target->where = selector_expr->where;\n       if (c->ts.type != BT_CLASS && c->ts.type != BT_UNKNOWN)\n \t{\n \t  gfc_add_data_component (st->n.sym->assoc->target);\n@@ -8720,7 +8782,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t  new_st->expr1->value.function.isym->id = GFC_ISYM_EXTENDS_TYPE_OF;\n \t  /* Set up arguments.  */\n \t  new_st->expr1->value.function.actual = gfc_get_actual_arglist ();\n-\t  new_st->expr1->value.function.actual->expr = gfc_get_variable_expr (code->expr1->symtree);\n+\t  new_st->expr1->value.function.actual->expr = gfc_get_variable_expr (selector_expr->symtree);\n \t  new_st->expr1->value.function.actual->expr->where = code->loc;\n \t  gfc_add_vptr_component (new_st->expr1->value.function.actual->expr);\n \t  vtab = gfc_find_derived_vtab (body->ext.block.case_list->ts.u.derived);\n@@ -8748,8 +8810,6 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n   if (ref)\n     free (ref);\n-\n-  resolve_select (code, true);\n }\n \n "}, {"sha": "f1849f5e091ca7b989e986df4c27a7b47ba79394", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -1508,6 +1508,27 @@ gfc_trans_class_init_assign (gfc_code *code)\n }\n \n \n+/* Return the backend_decl for the vtable of an arbitrary typespec\n+   and the vtable symbol.  */\n+\n+tree\n+gfc_get_vtable_decl (gfc_typespec *ts, gfc_symbol **vtab)\n+{\n+  gfc_symbol *vtable = gfc_find_vtab (ts);\n+  gcc_assert (vtable != NULL);\n+  if (vtab != NULL)\n+    *vtab = vtable;\n+  if (vtable->backend_decl == NULL_TREE)\n+    return gfc_get_symbol_decl (vtable);\n+  else\n+    return vtable->backend_decl;\n+}\n+\n+\n+  /* Translate an assignment to a CLASS object\n+     (pointer or ordinary assignment).  */\n+\n+\n /* End of prototype trans-class.c  */\n \n "}, {"sha": "c52066ffd2028b328de53d0106009093a7c3845b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -2331,6 +2331,125 @@ gfc_trans_do_while (gfc_code * code)\n }\n \n \n+/* Deal with the particular case of SELECT_TYPE, where the vtable\n+   addresses are used for the selection. Since these are not sorted,\n+   the selection has to be made by a series of if statements.  */\n+\n+static tree\n+gfc_trans_select_type_cases (gfc_code * code)\n+{\n+  gfc_code *c;\n+  gfc_case *cp;\n+  tree tmp;\n+  tree cond;\n+  tree low;\n+  tree high;\n+  gfc_se se;\n+  gfc_se cse;\n+  stmtblock_t block;\n+  stmtblock_t body;\n+  bool def = false;\n+  gfc_expr *e;\n+  gfc_start_block (&block);\n+\n+  /* Calculate the switch expression.  */\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr_val (&se, code->expr1);\n+  gfc_add_block_to_block (&block, &se.pre);\n+\n+  /* Generate an expression for the selector hash value, for\n+     use to resolve character cases.  */\n+  e = gfc_copy_expr (code->expr1->value.function.actual->expr);\n+  gfc_add_hash_component (e);\n+\n+  TREE_USED (code->exit_label) = 0;\n+\n+repeat:\n+  for (c = code->block; c; c = c->block)\n+    {\n+      cp = c->ext.block.case_list;\n+\n+      /* Assume it's the default case.  */\n+      low = NULL_TREE;\n+      high = NULL_TREE;\n+      tmp = NULL_TREE;\n+\n+      /* Put the default case at the end.  */\n+      if ((!def && !cp->low) || (def && cp->low))\n+\tcontinue;\n+\n+      if (cp->low && (cp->ts.type == BT_CLASS\n+\t\t      || cp->ts.type == BT_DERIVED))\n+\t{\n+\t  gfc_init_se (&cse, NULL);\n+\t  gfc_conv_expr_val (&cse, cp->low);\n+\t  gfc_add_block_to_block (&block, &cse.pre);\n+\t  low = cse.expr;\n+\t}\n+      else if (cp->ts.type != BT_UNKNOWN)\n+\t{\n+\t  gcc_assert (cp->high);\n+\t  gfc_init_se (&cse, NULL);\n+\t  gfc_conv_expr_val (&cse, cp->high);\n+\t  gfc_add_block_to_block (&block, &cse.pre);\n+\t  high = cse.expr;\n+\t}\n+\n+      gfc_init_block (&body);\n+\n+      /* Add the statements for this case.  */\n+      tmp = gfc_trans_code (c->next);\n+      gfc_add_expr_to_block (&body, tmp);\n+\n+      /* Break to the end of the SELECT TYPE construct.  The default\n+\t case just falls through.  */\n+      if (!def)\n+\t{\n+\t  TREE_USED (code->exit_label) = 1;\n+\t  tmp = build1_v (GOTO_EXPR, code->exit_label);\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\t}\n+\n+      tmp = gfc_finish_block (&body);\n+\n+      if (low != NULL_TREE)\n+\t{\n+\t  /* Compare vtable pointers.  */\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t  TREE_TYPE (se.expr), se.expr, low);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t cond, tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\t}\n+      else if (high != NULL_TREE)\n+\t{\n+\t  /* Compare hash values for character cases.  */\n+\t  gfc_init_se (&cse, NULL);\n+\t  gfc_conv_expr_val (&cse, e);\n+\t  gfc_add_block_to_block (&block, &cse.pre);\n+\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t  TREE_TYPE (se.expr), high, cse.expr);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t cond, tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\t}\n+\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n+  if (!def)\n+    {\n+      def = true;\n+      goto repeat;\n+    }\n+\n+  gfc_free_expr (e);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Translate the SELECT CASE construct for INTEGER case expressions,\n    without killing all potential optimizations.  The problem is that\n    Fortran allows unbounded cases, but the back-end does not, so we\n@@ -2972,6 +3091,35 @@ gfc_trans_select (gfc_code * code)\n   return gfc_finish_block (&block);\n }\n \n+tree\n+gfc_trans_select_type (gfc_code * code)\n+{\n+  stmtblock_t block;\n+  tree body;\n+  tree exit_label;\n+\n+  gcc_assert (code && code->expr1);\n+  gfc_init_block (&block);\n+\n+  /* Build the exit label and hang it in.  */\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+  code->exit_label = exit_label;\n+\n+  /* Empty SELECT constructs are legal.  */\n+  if (code->block == NULL)\n+    body = build_empty_stmt (input_location);\n+  else\n+    body = gfc_trans_select_type_cases (code);\n+\n+  /* Build everything together.  */\n+  gfc_add_expr_to_block (&block, body);\n+\n+  if (TREE_USED (exit_label))\n+    gfc_add_expr_to_block (&block, build1_v (LABEL_EXPR, exit_label));\n+\n+  return gfc_finish_block (&block);\n+}\n+\n \n /* Traversal function to substitute a replacement symtree if the symbol\n    in the expression is the same as that passed.  f == 2 signals that"}, {"sha": "0b4f71357f65fb9584b050d0b816b0a5331d00fc", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -52,6 +52,7 @@ tree gfc_trans_do (gfc_code *, tree);\n tree gfc_trans_do_concurrent (gfc_code *);\n tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);\n+tree gfc_trans_select_type (gfc_code *);\n tree gfc_trans_sync (gfc_code *, gfc_exec_op);\n tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);\n tree gfc_trans_event_post_wait (gfc_code *, gfc_exec_op);"}, {"sha": "df77fc9b540fefa8f3e6c9d987d6d7e3f92bb869", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -1820,10 +1820,7 @@ trans_code (gfc_code * code, tree cond)\n \t  break;\n \n \tcase EXEC_SELECT_TYPE:\n-\t  /* Do nothing. SELECT TYPE statements should be transformed into\n-\t  an ordinary SELECT CASE at resolution stage.\n-\t  TODO: Add an error message here once this is done.  */\n-\t  res = NULL_TREE;\n+\t  res = gfc_trans_select_type (code);\n \t  break;\n \n \tcase EXEC_FLUSH:"}, {"sha": "8178f8dc727c4b363aa2cc89f8eac3202f1a059b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -1,3 +1,10 @@\n+2016-10-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/69834\n+\t* gfortran.dg/select_type_1.f03: Change error for overlapping\n+\tTYPE IS cases.\n+\t* gfortran.dg/select_type_36.f03: New test.\n+\n 2016-10-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/tree-ssa/pr71347.c: Remove XFAIL on SPARC."}, {"sha": "b92366db704629160785e964a673e0a0a086cae3", "filename": "gcc/testsuite/gfortran.dg/select_type_1.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -60,9 +60,9 @@\n label: select type (a)\n   type is (t1) label\n     print *,\"a is TYPE(t1)\"\n-  type is (t2)  ! { dg-error \"overlaps with CASE label\" }\n+  type is (t2)  ! { dg-error \"overlaps with TYPE IS\" }\n     print *,\"a is TYPE(t2)\"\n-  type is (t2)  ! { dg-error \"overlaps with CASE label\" }\n+  type is (t2)  ! { dg-error \"overlaps with TYPE IS\" }\n     print *,\"a is still TYPE(t2)\"\n   class is (t1) labe   ! { dg-error \"Expected block name\" }\n     print *,\"a is CLASS(t1)\""}, {"sha": "a667ece3326063b4b16c0894f88accbb76f77df2", "filename": "gcc/testsuite/gfortran.dg/select_type_36.f03", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_36.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfd6231ea3621d57a2bf75f675fc8931ce5dec28/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_36.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_36.f03?ref=dfd6231ea3621d57a2bf75f675fc8931ce5dec28", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR69834 in which the two derived types below\n+! had the same hash value and so generated an error in the resolution\n+! of SELECT TYPE.\n+!\n+! Reported by James van Buskirk on clf:\n+! https://groups.google.com/forum/#!topic/comp.lang.fortran/0bm3E5xJpkM\n+!\n+module types\n+   implicit none\n+   type CS5SS\n+      integer x\n+      real y\n+   end type CS5SS\n+   type SQS3C\n+      logical u\n+      character(7) v\n+   end type SQS3C\n+   contains\n+      subroutine sub(x, switch)\n+         class(*), allocatable :: x\n+         integer :: switch\n+         select type(x)\n+            type is(CS5SS)\n+               if (switch .ne. 1) call abort\n+            type is(SQS3C)\n+               if (switch .ne. 2) call abort\n+            class default\n+               call abort\n+         end select\n+      end subroutine sub\n+end module types\n+\n+program test\n+   use types\n+   implicit none\n+   class(*), allocatable :: u1, u2\n+\n+   allocate(u1,source = CS5SS(2,1.414))\n+   allocate(u2,source = SQS3C(.TRUE.,'Message'))\n+   call sub(u1, 1)\n+   call sub(u2, 2)\n+end program test"}]}