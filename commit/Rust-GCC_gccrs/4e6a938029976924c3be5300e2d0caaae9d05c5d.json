{"sha": "4e6a938029976924c3be5300e2d0caaae9d05c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2YTkzODAyOTk3NjkyNGMzYmU1MzAwZTJkMGNhYWFlOWQwNWM1ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-08-30T15:50:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-08-30T15:50:39Z"}, "message": "re PR lto/86517 (relocation R_X86_64_32 against `.rodata.str1.1' can not be used when making a shared object with LTO)\n\n\n\n\tPR lto/86517\n\t* lto-opts.c (lto_write_options): Always stream PIC/PIE mode.\n\t* lto-wrapper.c (merge_and_complain): Fix merging of PIC/PIE.\n\nFrom-SVN: r263988", "tree": {"sha": "f482b9338950b03acf1d43ad637a602bd05f03ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f482b9338950b03acf1d43ad637a602bd05f03ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e6a938029976924c3be5300e2d0caaae9d05c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6a938029976924c3be5300e2d0caaae9d05c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e6a938029976924c3be5300e2d0caaae9d05c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6a938029976924c3be5300e2d0caaae9d05c5d/comments", "author": null, "committer": null, "parents": [{"sha": "24c35f687a2d1e95c45086f5a13a3624cf21f32a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c35f687a2d1e95c45086f5a13a3624cf21f32a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c35f687a2d1e95c45086f5a13a3624cf21f32a"}], "stats": {"total": 104, "additions": 94, "deletions": 10}, "files": [{"sha": "cce66bc3cdcdf674cd49e06b4e334d3a40c8ff06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6a938029976924c3be5300e2d0caaae9d05c5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6a938029976924c3be5300e2d0caaae9d05c5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e6a938029976924c3be5300e2d0caaae9d05c5d", "patch": "@@ -1,3 +1,9 @@\n+2018-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/86517\n+\t* lto-opts.c (lto_write_options): Always stream PIC/PIE mode.\n+\t* lto-wrapper.c (merge_and_complain): Fix merging of PIC/PIE.\n+\n 2018-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-streamer-out.c (DFS::DFS_write_tree_body): Do not follow"}, {"sha": "dbb41f6c8b30a83fdee37aad2677681e5c377cc2", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6a938029976924c3be5300e2d0caaae9d05c5d/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6a938029976924c3be5300e2d0caaae9d05c5d/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=4e6a938029976924c3be5300e2d0caaae9d05c5d", "patch": "@@ -78,6 +78,21 @@ lto_write_options (void)\n       && !global_options.x_flag_openacc)\n     append_to_collect_gcc_options (&temporary_obstack, &first_p,\n \t\t\t\t   \"-fno-openacc\");\n+  /* Append PIC/PIE mode because its default depends on target and it is\n+     subject of merging in lto-wrapper.  */\n+  if (!global_options_set.x_flag_pic && !global_options_set.x_flag_pie)\n+    {\n+       append_to_collect_gcc_options (&temporary_obstack, &first_p,\n+\t\t\t\t      global_options.x_flag_pic == 2\n+\t\t\t\t      ? \"-fPIC\"\n+\t\t\t\t      : global_options.x_flag_pic == 1\n+\t\t\t\t      ? \"-fpic\"\n+\t\t\t\t      : global_options.x_flag_pie == 2\n+\t\t\t\t      ? \"-fPIE\"\n+\t\t\t\t      : global_options.x_flag_pie == 1\n+\t\t\t\t      ? \"-fpie\"\n+\t\t\t\t      : \"-fno-pie\");\n+    }\n \n   /* Append options from target hook and store them to offload_lto section.  */\n   if (lto_stream_offload_p)"}, {"sha": "2b9d47e514333cb2472592ddfc21418242dd1dbd", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6a938029976924c3be5300e2d0caaae9d05c5d/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6a938029976924c3be5300e2d0caaae9d05c5d/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=4e6a938029976924c3be5300e2d0caaae9d05c5d", "patch": "@@ -409,18 +409,50 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n      It is a common mistake to mix few -fPIC compiled objects into otherwise\n      non-PIC code.  We do not want to build everything with PIC then.\n \n+     Similarly we merge PIE options, however in addition we keep\n+      -fPIC + -fPIE = -fPIE\n+      -fpic + -fPIE = -fpie\n+      -fPIC/-fpic + -fpie = -fpie\n+\n      It would be good to warn on mismatches, but it is bit hard to do as\n      we do not know what nothing translates to.  */\n     \n   for (unsigned int j = 0; j < *decoded_options_count;)\n     if ((*decoded_options)[j].opt_index == OPT_fPIC\n         || (*decoded_options)[j].opt_index == OPT_fpic)\n       {\n-\tif (!pic_option\n-\t    || (pic_option->value > 0) != ((*decoded_options)[j].value > 0))\n-\t  remove_option (decoded_options, j, decoded_options_count);\n-\telse if (pic_option->opt_index == OPT_fPIC\n-\t\t && (*decoded_options)[j].opt_index == OPT_fpic)\n+\t/* -fno-pic in one unit implies -fno-pic everywhere.  */\n+\tif ((*decoded_options)[j].value == 0)\n+\t  j++;\n+\t/* If we have no pic option or merge in -fno-pic, we still may turn\n+\t   existing pic/PIC mode into pie/PIE if -fpie/-fPIE is present.  */\n+\telse if ((pic_option && pic_option->value == 0)\n+\t\t || !pic_option)\n+\t  {\n+\t    if (pie_option)\n+\t      {\n+\t\tbool big = (*decoded_options)[j].opt_index == OPT_fPIC\n+\t\t\t   && pie_option->opt_index == OPT_fPIE;\n+\t        (*decoded_options)[j].opt_index = big ? OPT_fPIE : OPT_fpie;\n+\t\tif (pie_option->value)\n+\t          (*decoded_options)[j].canonical_option[0] = big ? \"-fPIE\" : \"-fpie\";\n+\t\telse\n+\t          (*decoded_options)[j].canonical_option[0] = big ? \"-fno-pie\" : \"-fno-pie\";\n+\t\t(*decoded_options)[j].value = pie_option->value;\n+\t        j++;\n+\t      }\n+\t    else if (pic_option)\n+\t      {\n+\t        (*decoded_options)[j] = *pic_option;\n+\t        j++;\n+\t      }\n+\t    /* We do not know if target defaults to pic or not, so just remove\n+\t       option if it is missing in one unit but enabled in other.  */\n+\t    else\n+\t      remove_option (decoded_options, j, decoded_options_count);\n+\t  }\n+\telse if (pic_option->opt_index == OPT_fpic\n+\t\t && (*decoded_options)[j].opt_index == OPT_fPIC)\n \t  {\n \t    (*decoded_options)[j] = *pic_option;\n \t    j++;\n@@ -431,11 +463,42 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n    else if ((*decoded_options)[j].opt_index == OPT_fPIE\n             || (*decoded_options)[j].opt_index == OPT_fpie)\n       {\n-\tif (!pie_option\n-\t    || pie_option->value != (*decoded_options)[j].value)\n-\t  remove_option (decoded_options, j, decoded_options_count);\n-\telse if (pie_option->opt_index == OPT_fPIE\n-\t\t && (*decoded_options)[j].opt_index == OPT_fpie)\n+\t/* -fno-pie in one unit implies -fno-pie everywhere.  */\n+\tif ((*decoded_options)[j].value == 0)\n+\t  j++;\n+\t/* If we have no pie option or merge in -fno-pie, we still preserve\n+\t   PIE/pie if pic/PIC is present.  */\n+\telse if ((pie_option && pie_option->value == 0)\n+\t\t || !pie_option)\n+\t  {\n+\t    /* If -fPIC/-fpic is given, merge it with -fPIE/-fpie.  */\n+\t    if (pic_option)\n+\t      {\n+\t\tif (pic_option->opt_index == OPT_fpic\n+\t\t    && (*decoded_options)[j].opt_index == OPT_fPIE)\n+\t\t  {\n+\t            (*decoded_options)[j].opt_index = OPT_fpie;\n+\t            (*decoded_options)[j].canonical_option[0]\n+\t\t\t = pic_option->value ? \"-fpie\" : \"-fno-pie\";\n+\t\t  }\n+\t\telse if (!pic_option->value)\n+\t\t  (*decoded_options)[j].canonical_option[0] = \"-fno-pie\";\n+\t\t(*decoded_options)[j].value = pic_option->value;\n+\t\tj++;\n+\t      }\n+\t    else if (pie_option)\n+\t      {\n+\t        (*decoded_options)[j] = *pie_option;\n+\t\tj++;\n+\t      }\n+\t    /* Because we always append pic/PIE options this code path should\n+\t       not happen unless the LTO object was built by old lto1 which\n+\t       did not contain that logic yet.  */\n+\t    else\n+\t      remove_option (decoded_options, j, decoded_options_count);\n+\t  }\n+\telse if (pie_option->opt_index == OPT_fpie\n+\t\t && (*decoded_options)[j].opt_index == OPT_fPIE)\n \t  {\n \t    (*decoded_options)[j] = *pie_option;\n \t    j++;"}]}