{"sha": "50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA3MTRmNDVlZWFmMzE1YTBiNTVkM2RiM2RlM2JmOGRmOGU5NGIwNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2020-04-23T05:19:55Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2020-04-28T22:13:32Z"}, "message": "[rs6000] fix mffsl emulation\n\nThe emulation of mffsl with mffs, used when !TARGET_P9_MISC, is going\nthrough the motions, but not storing the result in the given\noperands[0]; it rather modifies operands[0] without effect.  It also\ncreates a DImode pseudo that it doesn't use, overwriting subregs\ninstead.\n\nThe patch below fixes all of these, the indentation and a typo.\n\n\nI'm concerned about several issues in the mffsl testcase.  First, I\ndon't see that comparing the values as doubles rather than as long\nlongs is desirable.  These are FPSCR bitfields, not FP numbers.  I\nunderstand mffs et al use double because they output to FP registers,\nand the bit patterns are subnormal FP numbers, so it works, but given\nthe need for bit masking of at least one side, I'm changing the\ncompare to long longs.\n\nAnother issue with the test is that, if the compare fails, it calls\nmffsl again to print the value, as if it would yield the same result.\nBut part of the FPSCR that mffsl (emulated with mffs or not) copies to\nthe output FP register is the FPCC, so the fcmpu used to compare the\nresult of the first mffsl will modify FPSCR and thus the result of the\nsecond mffsl call.  After changing the compare, this is no longer the\ncase, but I still think it's better to make absolutely sure what we\nprint is what we compared.\n\nYet another issue is that the test assumed the mffs bits that are not\nto be extracted by mffsl to be already zero, instead of masking them\nout explicitly.  This is not about the mffs emulation in the mffsl\nimplementation, but about the mffs use in the test proper.  The bits\nappear to be zero indeed, as the bits left out are for sticky\nexceptions, but there are reserved parts of FPSCR that might turn out\nto be set in the future, so we're better off masking them out\nexplicitly, otherwise those bits could cause the compare to fail.\n\nIf some future mffsl is changed so that it copies additional nonzero\nbits, the test will fail, and then we'll have a chance to adjust it\nand the emulation.\n\n\nfor  gcc/ChangeLog\n\n\tPR target/94812\n\t* gcc/config/rs6000/rs6000.md (rs6000_mffsl): Copy result to\n\toutput operand in emulation.  Don't overwrite pseudos.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR target/94812\n\t* gcc.target/powerpc/test_mffsl.c: Call mffsl only once.\n\tReinterpret the doubles as long longs for compares.  Mask out\n\tmffs bits that are not expected from mffsl.", "tree": {"sha": "6d95036aaa3f59795838123c44858701d30e2315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d95036aaa3f59795838123c44858701d30e2315"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/comments", "author": null, "committer": null, "parents": [{"sha": "19667c82e479dc2bf8351588ed57aff90220b748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19667c82e479dc2bf8351588ed57aff90220b748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19667c82e479dc2bf8351588ed57aff90220b748"}], "stats": {"total": 50, "additions": 34, "deletions": 16}, "files": [{"sha": "b7ec1386740a8cbfb3fa086a3100aaf9e28a2023", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "patch": "@@ -1,3 +1,9 @@\n+2020-04-28  Alexandre Oliva <oliva@adacore.com>\n+\n+\tPR target/94812\n+\t* gcc/config/rs6000/rs6000.md (rs6000_mffsl): Copy result to\n+\toutput operand in emulation.  Don't overwrite pseudos.\n+\n 2020-04-28  Jeff Law  <law@redhat.com>\n \n \t* config/h8300/h8300.md (H8/SX mult patterns): All H8/SX specific"}, {"sha": "6173994797c524674088eefac689fc8f98bb73d6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "patch": "@@ -13620,18 +13620,19 @@\n \n   if (!TARGET_P9_MISC)\n     {\n-       rtx tmp_di = gen_reg_rtx (DImode);\n-       rtx tmp_df = gen_reg_rtx (DFmode);\n-\n-       /* The mffs instruction reads the entire FPSCR.  Emulate the mffsl\n-          instruction using the mffs instruction and masking off the bits\n-          the mmsl instruciton actually reads.  */\n-       emit_insn (gen_rs6000_mffs (tmp_df));\n-       tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);\n-       emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (0x70007f0ffLL)));\n-\n-       operands[0] = simplify_gen_subreg (DFmode, tmp_di, DImode, 0);\n-       DONE;\n+      rtx tmp1 = gen_reg_rtx (DFmode);\n+\n+      /* The mffs instruction reads the entire FPSCR.  Emulate the mffsl\n+\t instruction using the mffs instruction and masking the result.  */\n+      emit_insn (gen_rs6000_mffs (tmp1));\n+\n+      rtx tmp1di = simplify_gen_subreg (DImode, tmp1, DFmode, 0);\n+      rtx tmp2 = gen_reg_rtx (DImode);\n+      emit_insn (gen_anddi3 (tmp2, tmp1di, GEN_INT (0x70007f0ffLL)));\n+\n+      rtx tmp2df = simplify_gen_subreg (DFmode, tmp2, DImode, 0);\n+      emit_move_insn (operands[0], tmp2df);\n+      DONE;\n     }\n \n     emit_insn (gen_rs6000_mffsl_hw (operands[0]));"}, {"sha": "d20308b376c4a5c6202c00ce87489521909c4e29", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "patch": "@@ -1,3 +1,10 @@\n+2020-04-28  Alexandre Oliva <oliva@adacore.com>\n+\n+\tPR target/94812\n+\t* gcc.target/powerpc/test_mffsl.c: Call mffsl only once.\n+\tReinterpret the doubles as long longs for compares.  Mask out\n+\tmffs bits that are not expected from mffsl.\n+\n 2020-04-28  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/94816"}, {"sha": "41377efba1a7167fda4f066fa08cf77347492125", "filename": "gcc/testsuite/gcc.target/powerpc/test_mffsl.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_mffsl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50714f45eeaf315a0b55d3db3de3bf8df8e94b04/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_mffsl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_mffsl.c?ref=50714f45eeaf315a0b55d3db3de3bf8df8e94b04", "patch": "@@ -14,17 +14,21 @@ int main ()\n   union blah {\n     double d;\n     unsigned long long ll;\n-  } conv_val;\n+  } mffs_val, mffsl_val;\n \n   /* Test reading the FPSCR register.  */\n   __asm __volatile (\"mffs %0\" : \"=f\"(f14));\n-  conv_val.d = f14;\n+  mffs_val.d = f14;\n+  /* Select the same bits as mffsl.  */\n+  mffs_val.ll &= 0x70007f0ffLL;\n \n-  if (conv_val.d != __builtin_mffsl())\n+  mffsl_val.d = __builtin_mffsl ();\n+\n+  if (mffs_val.ll != mffsl_val.ll)\n     {\n #ifdef DEBUG\n       printf(\"ERROR, __builtin_mffsl() returned 0x%llx, not the expecected value 0x%llx\\n\",\n-\t     __builtin_mffsl(), conv_val.d);\n+\t     mffsl_val.ll, mffs_val.ll);\n #else\n       abort();\n #endif"}]}