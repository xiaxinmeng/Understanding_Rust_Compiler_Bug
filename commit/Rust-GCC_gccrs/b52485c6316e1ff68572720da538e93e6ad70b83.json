{"sha": "b52485c6316e1ff68572720da538e93e6ad70b83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyNDg1YzYzMTZlMWZmNjg1NzI3MjBkYTUzOGU5M2U2YWQ3MGI4Mw==", "commit": {"author": {"name": "Devang Patel", "email": "dpatel@apple.com", "date": "2005-04-12T01:35:54Z"}, "committer": {"name": "Devang Patel", "email": "dpatel@gcc.gnu.org", "date": "2005-04-12T01:35:54Z"}, "message": "tree-data-ref.c (build_classic_dist_vector, [...]): Make externally visible.\n\n         * tree-data-ref.c (build_classic_dist_vector,\n         compute_subscript_distance): Make externally visible.\n         * tree-data-ref.h (build_classic_dist_vector,\n         compute_subscript_distance): Same.\n         * tree-vect-analyze.c (vect_analyze_data_ref_dependence):\n         Check distance vector against vectorization factor.\n         (vect_analyze_loop): Determine vectorizaion factor before\n         analyzing data dependences.\n         * tree-vectorizer.c (loops_num): Make it externally visible and\n         rename ...\n         * tree-vectorizer.c (vect_loops_num): ... new name.\n         * tree-vectorizer.h  (vect_loops_num): New.\n\n         * tree-vect-analyze.c (vect_analyze_operations): Check\n         vectorizable codition.\n         * tree-vect-transform.c (vect_is_simple_cond): New function.\n         (vectorizable_condition): New function.\n         (vect_transform_stmt): Handle condition_vec_info_type.\n         * tree-vectorizer.h (enum stmt_vec_info_type): Add\n         condition_vec_info_type.\n         (vectorizable_condition): New.\n\n         * lib/target-supports.exp (check_effective_target_vect_condition): New.\n         * gcc.dg/vect/vect-ifcvt-1.c: New test.\n         * gcc.dg/vect/vect-ifcvt-2.c: New test.\n         * gcc.dg/vect/vect-ifcvt-3.c: New test.\n         * gcc.dg/vect/vect-ifcvt-4.c: New test.\n         * gcc.dg/vect/vect-ifcvt-5.c: New test.\n         * gcc.dg/vect/vect-ifcvt-6.c: New test.\n         * gcc.dg/vect/vect-ifcvt-7.c: New test.\n         * gcc.dg/vect/vect-none.c: Now one loop is vectorized.\n\n         * gcc.dg/vect/vect-dv-1.c: New test.\n         * gcc.dg/vect/vect-dv-2.c: New test.\n\nFrom-SVN: r97999", "tree": {"sha": "f188986dd14899759aa5d472d21666c8b4c61591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f188986dd14899759aa5d472d21666c8b4c61591"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52485c6316e1ff68572720da538e93e6ad70b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52485c6316e1ff68572720da538e93e6ad70b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52485c6316e1ff68572720da538e93e6ad70b83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52485c6316e1ff68572720da538e93e6ad70b83/comments", "author": null, "committer": null, "parents": [{"sha": "45f27db0d4536c72cb09e6ef15af0d0b3698e4b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f27db0d4536c72cb09e6ef15af0d0b3698e4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f27db0d4536c72cb09e6ef15af0d0b3698e4b1"}], "stats": {"total": 717, "additions": 693, "deletions": 24}, "files": [{"sha": "bc5f1a31c7ef994924ebafe3dafed5eee013ac72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -1,3 +1,29 @@\n+2005-04-11  Devang Patel  <dpatel@apple.com>\n+\n+        * tree-data-ref.c (build_classic_dist_vector,\n+        compute_subscript_distance): Make externally visible.\n+        * tree-data-ref.h (build_classic_dist_vector,\n+        compute_subscript_distance): Same.\n+        * tree-vect-analyze.c (vect_analyze_data_ref_dependence):\n+        Check distance vector against vectorization factor.\n+        (vect_analyze_loop): Determine vectorizaion factor before\n+        analyzing data dependences.\n+        * tree-vectorizer.c (loops_num): Make it externally visible and\n+        rename ...\n+        * tree-vectorizer.c (vect_loops_num): ... new name.\n+        * tree-vectorizer.h  (vect_loops_num): New.\n+\n+2005-04-11  Devang Patel  <dpatel@apple.com>\n+\n+        * tree-vect-analyze.c (vect_analyze_operations): Check\n+        vectorizable codition.\n+        * tree-vect-transform.c (vect_is_simple_cond): New function.\n+        (vectorizable_condition): New function.\n+        (vect_transform_stmt): Handle condition_vec_info_type.\n+        * tree-vectorizer.h (enum stmt_vec_info_type): Add\n+        condition_vec_info_type.\n+        (vectorizable_condition): New.\n+\t\n 2005-04-11  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/t-slibgcc-darwin: Don't put shared libraries in"}, {"sha": "e7d40f87f03e9abcc0ba597c7e0ef3d98f387181", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -1,3 +1,20 @@\n+2004-04-11  Devang Patel  <dpatel@apple.com>\n+\n+        * lib/target-supports.exp (check_effective_target_vect_condition): New.\n+        * gcc.dg/vect/vect-ifcvt-1.c: New test.\n+        * gcc.dg/vect/vect-ifcvt-2.c: New test.\n+        * gcc.dg/vect/vect-ifcvt-3.c: New test.\n+        * gcc.dg/vect/vect-ifcvt-4.c: New test.\n+        * gcc.dg/vect/vect-ifcvt-5.c: New test.\n+        * gcc.dg/vect/vect-ifcvt-6.c: New test.\n+        * gcc.dg/vect/vect-ifcvt-7.c: New test.\n+        * gcc.dg/vect/vect-none.c: Now one loop is vectorized.\n+\t\n+2004-04-11  Devang Patel  <dpatel@apple.com>\n+\n+        * gcc.dg/vect/vect-dv-1.c: New test.\n+        * gcc.dg/vect/vect-dv-2.c: New test.\n+\t\n 2005-04-11  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/20933"}, {"sha": "20fe1beb28ac8fb5bb51305b0ee1e788ac793e7e", "filename": "gcc/testsuite/gcc.dg/vect/vect-dv-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-1.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,22 @@\n+/* Test compiler crash when dependence analyzer can not represent\n+   dependence relation by distance vector.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+int x[199];\n+\n+void foo()\n+  \n+{\n+  int t,j;\n+\n+  for (j=99;j>0;j--) \n+    x [j+j]=x[j];\n+\n+  for (j=198;j>=100;j--) \n+    if(x[j]) \n+      {\n+\tx[j-63]=x[j-3]-x[j];\n+      }\n+}\n+"}, {"sha": "dfcfc64862c35108140b79a5fff33badb6bd5acb", "filename": "gcc/testsuite/gcc.dg/vect/vect-dv-2.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 64\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N];\n+  int B[N];\n+  int C[N];\n+  int D[N];\n+\n+  int i, j;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      A[i] = i;\n+      B[i] = i;\n+      C[i] = i;\n+      D[i] = i;\n+    }\n+\n+  /* Vectorizable */\n+  for (i = 0; i < 16; i++)\n+    {\n+      A[i] = A[i+20];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (A[i] != A[i+20])\n+\tabort ();\n+    }\n+\n+  /* Vectorizable */\n+  for (i = 0; i < 16; i++)\n+    {\n+      B[i] = B[i] + 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (B[i] != C[i] + 5)\n+\tabort ();\n+    }\n+\n+  /* Not vectorizable */\n+  for (i = 0; i < 4; i++)\n+    {\n+      C[i] = C[i+3];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (C[i] != D[i+3])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */"}, {"sha": "385e2d1b78076db1ee83b669c18d26415a4f7cf2", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-1.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 64\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N];\n+  int B[N];\n+  int C[N];\n+  int D[N];\n+\n+  int i, j;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      A[i] = i;\n+      B[i] = i;\n+      C[i] = i;\n+      D[i] = i;\n+    }\n+\n+  /* Vectorizable */\n+  for (i = 0; i < 16; i++)\n+    {\n+      A[i] = A[i+20];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (A[i] != A[i+20])\n+\tabort ();\n+    }\n+\n+  /* Vectorizable */\n+  for (i = 0; i < 16; i++)\n+    {\n+      B[i] = B[i] + 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (B[i] != C[i] + 5)\n+\tabort ();\n+    }\n+\n+  /* Not vectorizable */\n+  for (i = 0; i < 4; i++)\n+    {\n+      C[i] = C[i+3];\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (C[i] != D[i+3])\n+\tabort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */"}, {"sha": "d2701540aea815b242430c8a5607a9070312fd5e", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-2.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  int B[N] = {0,0,42,42,42,0,0,0,0,0,42,42,42,42,42,0};\n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] >= MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "46dafa50cabf7dce573fdf45ee73b0eb6bd332d2", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-3.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  int B[N] = {0,0,0,42,42,0,0,0,0,0,42,42,42,42,42,0};\n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] > MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "2fc5b217205e18c2d69aea4edf1143ece2446225", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-4.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  int B[N] = {42,42,42,0,0,42,42,42,42,42,0,0,0,0,0,42};\n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] <= MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "e7210902982bf44830da078706831a1b52947c05", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-5.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+  int B[N] = {42,42,0,0,0,42,42,42,42,42,0,0,0,0,0,42};\n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] < MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "80aa3d222bd5859c2b0b6ab59e12ac024f639530", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-6.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-6.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,42,23,34,45,56,67,42,89,11};\n+  int B[N] = {42,42,0,42,42,42,42,0,42,42,42,42,42,0,42,42};\n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] != MAX ? MAX : 0); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "ef22119dac5b44ade7e8e71da3caa63a9ab315d0", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-7.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-7.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int main ()\n+{  \n+  int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,42,78,89,11};\n+  int B[N] = {42,42,0,42,42,42,42,42,42,42,42,42,0,42,42,42};\n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] == MAX ? 0 : MAX); \n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "cb0dc808718c10b5ea633c2d28fd07d40ca9a01c", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-9.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-9.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+#include <signal.h>\n+\n+#define N 16\n+#define MAX 42\n+\n+extern void abort(void); \n+\n+int A[N] = {36,39,42,45,43,32,21,12,23,34,45,56,67,78,89,11};\n+int B[N] = {0,0,42,42,42,0,0,0,0,0,42,42,42,42,42,0};\n+void foo ()  __attribute__((always_inline));\n+void foo ()\n+{  \n+  int i, j;\n+\n+  for (i = 0; i < 16; i++)\n+    A[i] = ( A[i] >= MAX ? MAX : 0); \n+}\n+\n+int main ()\n+{\n+\n+  int i, j;\n+  foo ();\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */"}, {"sha": "924c421bcae321afb900940a1c377e9c5702d9d7", "filename": "gcc/testsuite/gcc.dg/vect/vect-none.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-none.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -181,5 +181,6 @@ foo (int n)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized \" 3 \"vect\"} } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 3 \"vect\"} } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"} } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\"} } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "52200e9128fd7a8a1451e14cc1ac2aa55df65672", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -835,6 +835,25 @@ proc check_effective_target_vect_no_align { } {\n     return $et_vect_no_align_saved\n }\n \n+# Return 1 if the target supports vector conditional operations, 0 otherwise.\n+\n+proc check_effective_target_vect_condition { } {\n+    global et_vect_cond_saved\n+\n+    if [info exists et_vect_int_cond] {\n+\tverbose \"check_effective_target_vect_cond: using cached result\" 2\n+    } else {\n+\tset et_vect_cond_saved 0\n+\tif { [istarget powerpc*-*-*] } {\n+\t   set et_vect_cond_saved 1\n+\t}\n+    }\n+\n+    verbose \"check_effective_target_vect_cond: returning $et_vect_cond_saved\" 2\n+    return $et_vect_cond_saved\n+}\n+\n+\n # Return 1 if the target matches the effective target 'arg', 0 otherwise.\n # This can be used with any check_* proc that takes no argument and\n # returns only 1 or 0.  It could be used with check_* procs that take"}, {"sha": "b984c04d07af17dea39336eefaccac039b136a36", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -646,7 +646,7 @@ all_chrecs_equal_p (tree chrec)\n /* Determine for each subscript in the data dependence relation DDR\n    the distance.  */\n \n-static void\n+void\n compute_subscript_distance (struct data_dependence_relation *ddr)\n {\n   if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n@@ -1769,7 +1769,7 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n    starting at FIRST_LOOP_DEPTH. \n    Return TRUE otherwise.  */\n \n-static bool\n+bool\n build_classic_dist_vector (struct data_dependence_relation *ddr, \n \t\t\t   int nb_loops, int first_loop_depth)\n {"}, {"sha": "03c0736d469692979d8e9039d3467f1dc46bb09b", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -176,6 +176,8 @@ extern bool array_base_name_differ_p (struct data_reference *,\n extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (varray_type);\n extern void free_data_refs (varray_type);\n+extern void compute_subscript_distance (struct data_dependence_relation *);\n+extern bool build_classic_dist_vector (struct data_dependence_relation *, int, int);\n \n \n \f"}, {"sha": "6ece91d1eff5b4e27ef8a256cdab1f821e42c593", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 77, "deletions": 15, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -494,7 +494,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  ok = (vectorizable_operation (stmt, NULL, NULL)\n \t\t|| vectorizable_assignment (stmt, NULL, NULL)\n \t\t|| vectorizable_load (stmt, NULL, NULL)\n-\t\t|| vectorizable_store (stmt, NULL, NULL));\n+\t\t|| vectorizable_store (stmt, NULL, NULL)\n+\t\t|| vectorizable_condition (stmt, NULL, NULL));\n \n \t  if (!ok)\n \t    {\n@@ -774,6 +775,12 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n {\n   bool differ_p; \n   struct data_dependence_relation *ddr;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int dist = 0;\n+  unsigned int loop_depth = 0;\n+  struct loop *loop_nest = loop;  \n+\n   \n   if (!vect_base_addr_differ_p (dra, drb, &differ_p))\n     {\n@@ -797,7 +804,65 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return false;\n-  \n+\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+                                LOOP_LOC (loop_vinfo)))\n+        {\n+          fprintf (vect_dump, \n+                   \"not vectorized: can't determine dependence between \"); \n+          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+          fprintf (vect_dump, \" and \");\n+          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+        }\n+      return true;\n+    }\n+\n+  /* Find loop depth.  */\n+  while (loop_nest)\n+    {\n+      if (loop_nest->outer && loop_nest->outer->outer)\n+\t{\n+\t  loop_nest = loop_nest->outer;\n+\t  loop_depth++;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  /* Compute distance vector.  */\n+  compute_subscript_distance (ddr);\n+  build_classic_dist_vector (ddr, vect_loops_num, loop_nest->depth);\n+\n+  if (!DDR_DIST_VECT (ddr))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n+\t\t\t\tLOOP_LOC (loop_vinfo)))\n+\t{\n+\t  fprintf (vect_dump, \"not vectorized: bad dist vector for \");\n+\t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+\t  fprintf (vect_dump, \" and \");\n+\t  print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t}      \n+      return true;\n+    }\n+\n+  dist = DDR_DIST_VECT (ddr)[loop_depth];\n+\n+  /* Same loop iteration.  */\n+  if (dist == 0)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"dependence distance 0.\");\n+      return false;\n+    }\n+\n+  if (dist >= vectorization_factor)\n+    /* Dependence distance does not create dependence, as far as vectorization\n+       is concerned, in this case.  */\n+    return false;\n+    \n   if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n \t\t\t    LOOP_LOC (loop_vinfo)))\n     {\n@@ -815,10 +880,7 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n /* Function vect_analyze_data_ref_dependences.\n \n    Examine all the data references in the loop, and make sure there do not\n-   exist any data dependences between them.\n-\n-   TODO: dependences which distance is greater than the vectorization factor\n-         can be ignored.  */\n+   exist any data dependences between them.  */\n \n static bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n@@ -2567,6 +2629,15 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n+  ok = vect_determine_vectorization_factor (loop_vinfo);\n+  if (!ok)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n+        fprintf (vect_dump, \"can't determine vectorization factor.\");\n+      destroy_loop_vec_info (loop_vinfo);\n+      return NULL;\n+    }\n+\n   /* Analyze data dependences between the data-refs in the loop. \n      FORNOW: fail at the first data dependence that we encounter.  */\n \n@@ -2591,15 +2662,6 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-  ok = vect_determine_vectorization_factor (loop_vinfo);\n-  if (!ok)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n-        fprintf (vect_dump, \"can't determine vectorization factor.\");\n-      destroy_loop_vec_info (loop_vinfo);\n-      return NULL;\n-    }\n-\n   /* Analyze the alignment of the data-refs in the loop.\n      FORNOW: Only aligned accesses are handled.  */\n "}, {"sha": "69d532f894f1ef0a9417be3456487d1b0e13e86b", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -57,6 +57,7 @@ static tree vect_get_vec_def_for_operand (tree, tree);\n static tree vect_init_vector (tree, tree);\n static void vect_finish_stmt_generation \n   (tree stmt, tree vec_stmt, block_stmt_iterator *bsi);\n+static bool vect_is_simple_cond (tree, loop_vec_info); \n static void update_vuses_to_preheader (tree, struct loop*);\n \n /* Utility function dealing with loop peeling (not peeling itself).  */\n@@ -1141,6 +1142,145 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   return true;\n }\n \n+/* Function vect_is_simple_cond.\n+  \n+   Input:\n+   LOOP - the loop that is being vectorized.\n+   COND - Condition that is checked for simple use.\n+\n+   Returns whether a COND can be vectorized. Checkes whether\n+   condition operands are supportable using vec_is_simple_use.  */\n+\n+static bool\n+vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n+{\n+  tree lhs, rhs;\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (cond)) != tcc_comparison)\n+    return false;\n+\n+  lhs = TREE_OPERAND (cond, 0);\n+  rhs = TREE_OPERAND (cond, 1);\n+\n+  if (TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      tree lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n+      if (!vect_is_simple_use (lhs, loop_vinfo, &lhs_def_stmt))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST)\n+    return false;\n+\n+  if (TREE_CODE (rhs) == SSA_NAME)\n+    {\n+      tree rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n+      if (!vect_is_simple_use (rhs, loop_vinfo, &rhs_def_stmt))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (rhs) != INTEGER_CST  && TREE_CODE (rhs) != REAL_CST)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* vectorizable_condition.\n+\n+   Check if STMT is conditional modify expression that can be vectorized. \n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized \n+   stmt using VEC_COND_EXPR  to replace it, put it in VEC_STMT, and insert it \n+   at BSI.\n+\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n+{\n+  tree scalar_dest = NULL_TREE;\n+  tree vec_dest = NULL_TREE;\n+  tree op = NULL_TREE;\n+  tree cond_expr, then_clause, else_clause;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vec_cond_lhs, vec_cond_rhs, vec_then_clause, vec_else_clause;\n+  tree vec_compare, vec_cond_expr;\n+  tree new_temp;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  enum machine_mode vec_mode;\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return false;\n+\n+  op = TREE_OPERAND (stmt, 1);\n+\n+  if (TREE_CODE (op) != COND_EXPR)\n+    return false;\n+\n+  cond_expr = TREE_OPERAND (op, 0);\n+  then_clause = TREE_OPERAND (op, 1);\n+  else_clause = TREE_OPERAND (op, 2);\n+\n+  if (!vect_is_simple_cond (cond_expr, loop_vinfo))\n+    return false;\n+\n+  if (TREE_CODE (then_clause) == SSA_NAME)\n+    {\n+      tree then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n+      if (!vect_is_simple_use (then_clause, loop_vinfo, &then_def_stmt))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (then_clause) != INTEGER_CST \n+\t   && TREE_CODE (then_clause) != REAL_CST)\n+    return false;\n+\n+  if (TREE_CODE (else_clause) == SSA_NAME)\n+    {\n+      tree else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n+      if (!vect_is_simple_use (else_clause, loop_vinfo, &else_def_stmt))\n+\treturn false;\n+    }\n+  else if (TREE_CODE (else_clause) != INTEGER_CST \n+\t   && TREE_CODE (else_clause) != REAL_CST)\n+    return false;\n+\n+\n+  vec_mode = TYPE_MODE (vectype);\n+\n+  if (!vec_stmt) \n+    {\n+      STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n+      return expand_vec_cond_expr_p (op, vec_mode);\n+    }\n+\n+  /* Transform */\n+\n+  /* Handle def.  */\n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\n+  /* Handle cond expr.  */\n+  vec_cond_lhs = \n+    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0), stmt);\n+  vec_cond_rhs = \n+    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1), stmt);\n+  vec_then_clause = vect_get_vec_def_for_operand (then_clause, stmt);\n+  vec_else_clause = vect_get_vec_def_for_operand (else_clause, stmt);\n+\n+  /* Arguments are ready. create the new vector stmt.  */\n+  vec_compare = build2 (TREE_CODE (cond_expr), vectype, \n+\t\t\tvec_cond_lhs, vec_cond_rhs);\n+  vec_cond_expr = build (VEC_COND_EXPR, vectype, \n+\t\t\t vec_compare, vec_then_clause, vec_else_clause);\n+\n+  *vec_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, vec_cond_expr);\n+  new_temp = make_ssa_name (vec_dest, *vec_stmt);\n+  TREE_OPERAND (*vec_stmt, 0) = new_temp;\n+  vect_finish_stmt_generation (stmt, *vec_stmt, bsi);\n+  \n+  return true;\n+}\n \n /* Function vect_transform_stmt.\n \n@@ -1176,6 +1316,12 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n       gcc_assert (done);\n       is_store = true;\n       break;\n+\n+    case condition_vec_info_type:\n+      done = vectorizable_condition (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n     default:\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"stmt not supported.\");"}, {"sha": "c264ee0c4f8b232da34cab78bca0d6a30f4d13a0", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -178,7 +178,8 @@ FILE *vect_dump;\n    to mark that it's uninitialized.  */\n enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n \n-\n+/* Number of loops, at the beginning of vectorization.  */\n+unsigned int vect_loops_num;\n \f\n /*************************************************************************\n   Simple Loop Peeling Utilities\n@@ -1821,7 +1822,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n void\n vectorize_loops (struct loops *loops)\n {\n-  unsigned int i, loops_num;\n+  unsigned int i;\n   unsigned int num_vectorized_loops = 0;\n \n   /* Fix the verbosity level if not defined explicitly by the user.  */\n@@ -1841,8 +1842,8 @@ vectorize_loops (struct loops *loops)\n   /* If some loop was duplicated, it gets bigger number \n      than all previously defined loops. This fact allows us to run \n      only over initial loops skipping newly generated ones.  */\n-  loops_num = loops->num;\n-  for (i = 1; i < loops_num; i++)\n+  vect_loops_num = loops->num;\n+  for (i = 1; i < vect_loops_num; i++)\n     {\n       loop_vec_info loop_vinfo;\n       struct loop *loop = loops->parray[i];\n@@ -1866,7 +1867,7 @@ vectorize_loops (struct loops *loops)\n \n   /*  ----------- Finalize. -----------  */\n \n-  for (i = 1; i < loops_num; i++)\n+  for (i = 1; i < vect_loops_num; i++)\n     {\n       struct loop *loop = loops->parray[i];\n       loop_vec_info loop_vinfo;"}, {"sha": "3620b2bf16d9631a1ec05a61aa06b97be6b51bac", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52485c6316e1ff68572720da538e93e6ad70b83/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b52485c6316e1ff68572720da538e93e6ad70b83", "patch": "@@ -144,7 +144,8 @@ enum stmt_vec_info_type {\n   load_vec_info_type,\n   store_vec_info_type,\n   op_vec_info_type,\n-  assignment_vec_info_type\n+  assignment_vec_info_type,\n+  condition_vec_info_type\n };\n \n typedef struct _stmt_vec_info {\n@@ -277,6 +278,8 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n extern FILE *vect_dump;\n extern enum verbosity_levels vect_verbosity_level;\n \n+/* Number of loops, at the beginning of vectorization.  */\n+extern unsigned int vect_loops_num;\n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */\n /*-----------------------------------------------------------------*/\n@@ -327,6 +330,7 @@ extern bool vectorizable_load (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_store (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_assignment (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info, struct loops *);\n "}]}