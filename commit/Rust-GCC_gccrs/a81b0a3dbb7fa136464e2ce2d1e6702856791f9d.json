{"sha": "a81b0a3dbb7fa136464e2ce2d1e6702856791f9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxYjBhM2RiYjdmYTEzNjQ2NGUyY2UyZDFlNjcwMjg1Njc5MWY5ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-06T15:02:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-06T15:02:03Z"}, "message": "re PR middle-end/58094 (IPA devirt testsuite errors)\n\n\n\tPR middle-end/58094\n\t* ipa-inline.c (has_caller_p): New function.\n\t(want_inline_function_to_all_callers_p): Use it.\n\t(sum_callers, inline_to_all_callers): Break out from ...\n\t(ipa_inline): ... here.\n\nFrom-SVN: r202337", "tree": {"sha": "2aa9d9f0740c50c4ce621530f1171f0ea5625b08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aa9d9f0740c50c4ce621530f1171f0ea5625b08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d/comments", "author": null, "committer": null, "parents": [{"sha": "68e4ca7e493804a8426d78094ca4e146e0b8828e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e4ca7e493804a8426d78094ca4e146e0b8828e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e4ca7e493804a8426d78094ca4e146e0b8828e"}], "stats": {"total": 111, "additions": 77, "deletions": 34}, "files": [{"sha": "21c36b6f7815659fef5bb6f211c3d6577cdd2a40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a81b0a3dbb7fa136464e2ce2d1e6702856791f9d", "patch": "@@ -1,3 +1,11 @@\n+2013-09-06  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/58094\n+\t* ipa-inline.c (has_caller_p): New function.\n+\t(want_inline_function_to_all_callers_p): Use it.\n+\t(sum_callers, inline_to_all_callers): Break out from ...\n+\t(ipa_inline): ... here.\n+\n 2013-09-06  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (ix86_hard_regno_mode_ok): AVX modes are valid only when\t"}, {"sha": "1e22d6eb87b74928881de6119dd7cc7db06268a4", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81b0a3dbb7fa136464e2ce2d1e6702856791f9d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=a81b0a3dbb7fa136464e2ce2d1e6702856791f9d", "patch": "@@ -750,6 +750,15 @@ check_caller_edge (struct cgraph_node *node, void *edge)\n           && node->callers != edge);\n }\n \n+/* If NODE has a caller, return true.  */\n+\n+static bool\n+has_caller_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (node->callers)\n+    return true;\n+  return false;\n+}\n \n /* Decide if inlining NODE would reduce unit size by eliminating\n    the offline copy of function.  \n@@ -763,7 +772,7 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n    bool has_hot_call = false;\n \n    /* Does it have callers?  */\n-   if (!node->callers)\n+   if (!cgraph_for_node_and_aliases (node, has_caller_p, NULL, true))\n      return false;\n    /* Already inlined?  */\n    if (function->global.inlined_to)\n@@ -1892,6 +1901,60 @@ flatten_function (struct cgraph_node *node, bool early)\n     inline_update_overall_summary (node);\n }\n \n+/* Count number of callers of NODE and store it into DATA (that\n+   points to int.  Worker for cgraph_for_node_and_aliases.  */\n+\n+static bool\n+sum_callers (struct cgraph_node *node, void *data)\n+{\n+  struct cgraph_edge *e;\n+  int *num_calls = (int *)data;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    (*num_calls)++;\n+  return false;\n+}\n+\n+/* Inline NODE to all callers.  Worker for cgraph_for_node_and_aliases.\n+   DATA points to number of calls originally found so we avoid infinite\n+   recursion.  */\n+\n+static bool\n+inline_to_all_callers (struct cgraph_node *node, void *data)\n+{\n+  int *num_calls = (int *)data;\n+  while (node->callers && !node->global.inlined_to)\n+    {\n+      struct cgraph_node *caller = node->callers->caller;\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"\\nInlining %s size %i.\\n\",\n+\t\t   cgraph_node_name (node),\n+\t\t   inline_summary (node)->size);\n+\t  fprintf (dump_file,\n+\t\t   \" Called once from %s %i insns.\\n\",\n+\t\t   cgraph_node_name (node->callers->caller),\n+\t\t   inline_summary (node->callers->caller)->size);\n+\t}\n+\n+      inline_call (node->callers, true, NULL, NULL, true);\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \" Inlined into %s which now has %i size\\n\",\n+\t\t cgraph_node_name (caller),\n+\t\t inline_summary (caller)->size);\n+      if (!(*num_calls)--)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"New calls found; giving up.\\n\");\n+\t  break;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  */\n \n@@ -2003,39 +2066,11 @@ ipa_inline (void)\n \t      && want_inline_function_to_all_callers_p (node, cold))\n \t    {\n \t      int num_calls = 0;\n-\t      struct cgraph_edge *e;\n-\t      for (e = node->callers; e; e = e->next_caller)\n-\t\tnum_calls++;\n-\t      while (node->callers && !node->global.inlined_to)\n-\t\t{\n-\t\t  struct cgraph_node *caller = node->callers->caller;\n-\n-\t\t  if (dump_file)\n-\t\t    {\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"\\nInlining %s size %i.\\n\",\n-\t\t\t       cgraph_node_name (node),\n-\t\t\t       inline_summary (node)->size);\n-\t\t      fprintf (dump_file,\n-\t\t\t       \" Called once from %s %i insns.\\n\",\n-\t\t\t       cgraph_node_name (node->callers->caller),\n-\t\t\t       inline_summary (node->callers->caller)->size);\n-\t\t    }\n-\n-\t\t  inline_call (node->callers, true, NULL, NULL, true);\n-\t\t  remove_functions = true;\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \" Inlined into %s which now has %i size\\n\",\n-\t\t\t     cgraph_node_name (caller),\n-\t\t\t     inline_summary (caller)->size);\n-\t\t  if (!num_calls--)\n-\t\t    {\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"New calls found; giving up.\\n\");\n-\t\t      break;\n-\t\t    }\n-\t\t}\n+\t      cgraph_for_node_and_aliases (node, sum_callers,\n+\t\t\t\t\t   &num_calls, true);\n+\t      cgraph_for_node_and_aliases (node, inline_to_all_callers,\n+\t\t\t\t\t   &num_calls, true);\n+\t      remove_functions = true;\n \t    }\n \t}\n     }"}]}