{"sha": "6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3YTQ2MmNiZmU5NzYzOGZjZmU3NGE4YzVlNGI4NDdkNzFmNmU5ZA==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2008-09-19T00:18:42Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2008-09-19T00:18:42Z"}, "message": "configure.ac: Add HAVE_AS_TLS check for Xtensa.\n\n\t* configure.ac: Add HAVE_AS_TLS check for Xtensa.\n\t* config/xtensa/predicates.md (tls_symbol_operand): New.\n\t* config/xtensa/xtensa.c (TARGET_HAVE_TLS): Define.\n\t(TARGET_CANNOT_FORCE_MEM): Define.\n\t(xtensa_tls_symbol_p): New.\n\t(xtensa_emit_move_sequence): Check for and legitimize TLS addresses.\n\t(xtensa_legitimate_address_p): Disallow constant pool TLS references.\n\t(xtensa_tls_module_base): New.\n\t(xtensa_call_tls_desc): New.\n\t(xtensa_legitimize_tls_address): New.\n\t(xtensa_legitimize_address): Handle TLS symbols.\n\t(xtensa_tls_referenced_p_1): New.\n\t(xtensa_tls_referenced_p): New.\n\t(xtensa_output_addr_const_extra): Handle UNSPEC_TPOFF and UNSPEC_DTPOFF.\n\t(XTENSA_BUILTIN_THREAD_POINTER): New.\n\t(XTENSA_BUILTIN_SET_THREAD_POINTER): New.\n\t(xtensa_init_builtins): Set NOTHROW and READONLY for umulsidi3 builtin.\n\tAdd declarations for __builtin_thread_pointer and\n\t__builtin_set_thread_pointer.\n\t(xtensa_fold_builtin): Recognize new builtins.\n\t(xtensa_expand_builtin): Expand new builtins.\n\t* config/xtensa/xtensa.h (XCHAL_HAVE_THREADPTR): Define default value.\n\t(TARGET_THREADPTR): Define.\n\t(HAVE_AS_TLS): Define default value.\n\t(LEGITIMATE_CONSTANT_P): Disallow TLS references.\n\t* config/xtensa/xtensa.md (UNSPEC_TPOFF, UNSPEC_DTPOFF): New.\n\t(UNSPEC_TLS_FUNC, UNSPEC_TLS_ARG, UNSPEC_TLS_CALL, UNSPEC_TP): New.\n\t(UNSPECV_SET_TP): New.\n\t(sym_TPOFF, sym_DTPOFF): New.\n\t(load_tp, set_tp, tls_func, tls_arg, tls_call): New.\n\t* config/xtensa/xtensa-protos.h (xtensa_tls_referenced_p): Declare.\n\t* configure: Regenerated.\n\nFrom-SVN: r140482", "tree": {"sha": "a196eef4130a81ffbab10ca6a0aa591ab52731ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a196eef4130a81ffbab10ca6a0aa591ab52731ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/comments", "author": null, "committer": null, "parents": [{"sha": "342f11d55aa131b7ad21e20eb3b6f2b421cdffa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/342f11d55aa131b7ad21e20eb3b6f2b421cdffa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/342f11d55aa131b7ad21e20eb3b6f2b421cdffa9"}], "stats": {"total": 428, "additions": 397, "deletions": 31}, "files": [{"sha": "ac957740e4c4a4e3b5712ddd859c1ffe4e6ea05f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -1,3 +1,38 @@\n+2008-09-18  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* configure.ac: Add HAVE_AS_TLS check for Xtensa.\n+\t* config/xtensa/predicates.md (tls_symbol_operand): New.\n+\t* config/xtensa/xtensa.c (TARGET_HAVE_TLS): Define.\n+\t(TARGET_CANNOT_FORCE_MEM): Define.\n+\t(xtensa_tls_symbol_p): New.\n+\t(xtensa_emit_move_sequence): Check for and legitimize TLS addresses.\n+\t(xtensa_legitimate_address_p): Disallow constant pool TLS references.\n+\t(xtensa_tls_module_base): New.\n+\t(xtensa_call_tls_desc): New.\n+\t(xtensa_legitimize_tls_address): New.\n+\t(xtensa_legitimize_address): Handle TLS symbols.\n+\t(xtensa_tls_referenced_p_1): New.\n+\t(xtensa_tls_referenced_p): New.\n+\t(xtensa_output_addr_const_extra): Handle UNSPEC_TPOFF and UNSPEC_DTPOFF.\n+\t(XTENSA_BUILTIN_THREAD_POINTER): New.\n+\t(XTENSA_BUILTIN_SET_THREAD_POINTER): New.\n+\t(xtensa_init_builtins): Set NOTHROW and READONLY for umulsidi3 builtin.\n+\tAdd declarations for __builtin_thread_pointer and\n+\t__builtin_set_thread_pointer.\n+\t(xtensa_fold_builtin): Recognize new builtins.\n+\t(xtensa_expand_builtin): Expand new builtins.\n+\t* config/xtensa/xtensa.h (XCHAL_HAVE_THREADPTR): Define default value.\n+\t(TARGET_THREADPTR): Define.\n+\t(HAVE_AS_TLS): Define default value.\n+\t(LEGITIMATE_CONSTANT_P): Disallow TLS references.\n+\t* config/xtensa/xtensa.md (UNSPEC_TPOFF, UNSPEC_DTPOFF): New.\n+\t(UNSPEC_TLS_FUNC, UNSPEC_TLS_ARG, UNSPEC_TLS_CALL, UNSPEC_TP): New.\n+\t(UNSPECV_SET_TP): New.\n+\t(sym_TPOFF, sym_DTPOFF): New.\n+\t(load_tp, set_tp, tls_func, tls_arg, tls_call): New.\n+\t* config/xtensa/xtensa-protos.h (xtensa_tls_referenced_p): Declare.\n+\t* configure: Regenerated.\n+\t\n 2008-09-18  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/37394"}, {"sha": "2cb2a7d175761aef45da77af6ab0312aa8e59bfc", "filename": "gcc/config/xtensa/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fpredicates.md?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -166,3 +166,7 @@\n \n (define_predicate \"boolean_operator\"\n   (match_code \"eq,ne\"))\n+\n+(define_predicate \"tls_symbol_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_TLS_MODEL (op) != 0\")))"}, {"sha": "0447fae0a2ed9223178cd531d286890b26bf0924", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -56,6 +56,7 @@ extern char *xtensa_emit_movcc (bool, bool, bool, rtx *);\n extern char *xtensa_emit_call (int, rtx *);\n extern bool xtensa_legitimate_address_p (enum machine_mode, rtx, bool);\n extern rtx xtensa_legitimize_address (rtx, rtx, enum machine_mode);\n+extern bool xtensa_tls_referenced_p (rtx);\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, int);"}, {"sha": "4e7edef75a2e51e5c0c1dcb72adb18c738af0c31", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 251, "deletions": 25, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -131,6 +131,7 @@ static rtx gen_float_relational (enum rtx_code, rtx, rtx);\n static rtx gen_conditional_move (rtx);\n static rtx fixup_subreg_mem (rtx);\n static struct machine_function * xtensa_init_machine_status (void);\n+static rtx xtensa_legitimize_tls_address (rtx);\n static bool xtensa_return_in_msb (const_tree);\n static void printx (FILE *, signed int);\n static void xtensa_function_epilogue (FILE *, HOST_WIDE_INT);\n@@ -219,6 +220,12 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD xtensa_secondary_reload\n \n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS (TARGET_THREADPTR && HAVE_AS_TLS)\n+\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM xtensa_tls_referenced_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -469,6 +476,18 @@ constantpool_mem_p (rtx op)\n }\n \n \n+/* Return TRUE if X is a thread-local symbol.  */\n+\n+static bool\n+xtensa_tls_symbol_p (rtx x)\n+{\n+  if (! TARGET_HAVE_TLS)\n+    return false;\n+\n+  return GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x) != 0;\n+}\n+\n+\n void\n xtensa_extend_reg (rtx dst, rtx src)\n {\n@@ -910,29 +929,55 @@ xtensa_split_operand_pair (rtx operands[4], enum machine_mode mode)\n int\n xtensa_emit_move_sequence (rtx *operands, enum machine_mode mode)\n {\n-  if (CONSTANT_P (operands[1])\n-      && (GET_CODE (operands[1]) != CONST_INT\n-\t  || !xtensa_simm12b (INTVAL (operands[1]))))\n+  rtx src = operands[1];\n+\n+  if (CONSTANT_P (src)\n+      && (GET_CODE (src) != CONST_INT || ! xtensa_simm12b (INTVAL (src))))\n     {\n-      if (!TARGET_CONST16)\n-\toperands[1] = force_const_mem (SImode, operands[1]);\n+      rtx dst = operands[0];\n+\n+      if (xtensa_tls_referenced_p (src))\n+\t{\n+\t  rtx addend = NULL;\n+\n+\t  if (GET_CODE (src) == CONST && GET_CODE (XEXP (src, 0)) == PLUS)\n+\t    {\n+\t      addend = XEXP (XEXP (src, 0), 1);\n+\t      src = XEXP (XEXP (src, 0), 0);\n+\t    }\n+\n+\t  src = xtensa_legitimize_tls_address (src);\n+\t  if (addend)\n+\t    {\n+\t      src = gen_rtx_PLUS (mode, src, addend);\n+\t      src = force_operand (src, dst);\n+\t    }\n+\t  emit_move_insn (dst, src);\n+\t  return 1;\n+\t}\n+\n+      if (! TARGET_CONST16)\n+\t{\n+\t  src = force_const_mem (SImode, src);\n+\t  operands[1] = src;\n+\t}\n \n       /* PC-relative loads are always SImode, and CONST16 is only\n \t supported in the movsi pattern, so add a SUBREG for any other\n \t (smaller) mode.  */\n \n       if (mode != SImode)\n \t{\n-\t  if (register_operand (operands[0], mode))\n+\t  if (register_operand (dst, mode))\n \t    {\n-\t      operands[0] = simplify_gen_subreg (SImode, operands[0], mode, 0);\n-\t      emit_move_insn (operands[0], operands[1]);\n+\t      emit_move_insn (simplify_gen_subreg (SImode, dst, mode, 0), src);\n \t      return 1;\n \t    }\n \t  else\n \t    {\n-\t      operands[1] = force_reg (SImode, operands[1]);\n-\t      operands[1] = gen_lowpart_SUBREG (mode, operands[1]);\n+\t      src = force_reg (SImode, src);\n+\t      src = gen_lowpart_SUBREG (mode, src);\n+\t      operands[1] = src;\n \t    }\n \t}\n     }\n@@ -1664,7 +1709,8 @@ xtensa_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n {\n   /* Allow constant pool addresses.  */\n   if (mode != BLKmode && GET_MODE_SIZE (mode) >= UNITS_PER_WORD\n-      && ! TARGET_CONST16 && constantpool_address_p (addr))\n+      && ! TARGET_CONST16 && constantpool_address_p (addr)\n+      && ! xtensa_tls_referenced_p (addr))\n     return true;\n \n   while (GET_CODE (addr) == SUBREG)\n@@ -1709,11 +1755,97 @@ xtensa_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n }\n \n \n+/* Construct the SYMBOL_REF for the _TLS_MODULE_BASE_ symbol.  */\n+\n+static GTY(()) rtx xtensa_tls_module_base_symbol;\n+\n+static rtx\n+xtensa_tls_module_base (void)\n+{\n+  if (! xtensa_tls_module_base_symbol)\n+    {\n+      xtensa_tls_module_base_symbol =\n+\tgen_rtx_SYMBOL_REF (Pmode, \"_TLS_MODULE_BASE_\");\n+      SYMBOL_REF_FLAGS (xtensa_tls_module_base_symbol)\n+        |= TLS_MODEL_GLOBAL_DYNAMIC << SYMBOL_FLAG_TLS_SHIFT;\n+    }\n+\n+  return xtensa_tls_module_base_symbol;\n+}\n+\n+\n+static rtx\n+xtensa_call_tls_desc (rtx sym, rtx *retp)\n+{\n+  rtx fn, arg, a10, call_insn, insns;\n+\n+  start_sequence ();\n+  fn = gen_reg_rtx (Pmode);\n+  arg = gen_reg_rtx (Pmode);\n+  a10 = gen_rtx_REG (Pmode, 10);\n+\n+  emit_insn (gen_tls_func (fn, sym));\n+  emit_insn (gen_tls_arg (arg, sym));\n+  emit_move_insn (a10, arg);\n+  call_insn = emit_call_insn (gen_tls_call (a10, fn, sym, const1_rtx));\n+  CALL_INSN_FUNCTION_USAGE (call_insn)\n+    = gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, a10),\n+\t\t\t CALL_INSN_FUNCTION_USAGE (call_insn));\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  *retp = a10;\n+  return insns;\n+}\n+\n+\n+static rtx\n+xtensa_legitimize_tls_address (rtx x)\n+{\n+  unsigned int model = SYMBOL_REF_TLS_MODEL (x);\n+  rtx dest, tp, ret, modbase, base, addend, insns;\n+\n+  dest = gen_reg_rtx (Pmode);\n+  switch (model)\n+    {\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      insns = xtensa_call_tls_desc (x, &ret);\n+      emit_libcall_block (insns, dest, ret, x);\n+      break;\n+\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      base = gen_reg_rtx (Pmode);\n+      modbase = xtensa_tls_module_base ();\n+      insns = xtensa_call_tls_desc (modbase, &ret);\n+      emit_libcall_block (insns, base, ret, modbase);\n+      addend = force_reg (SImode, gen_sym_DTPOFF (x));\n+      emit_insn (gen_addsi3 (dest, base, addend));\n+      break;\n+\n+    case TLS_MODEL_INITIAL_EXEC:\n+    case TLS_MODEL_LOCAL_EXEC:\n+      tp = gen_reg_rtx (SImode);\n+      emit_insn (gen_load_tp (tp));\n+      addend = force_reg (SImode, gen_sym_TPOFF (x));\n+      emit_insn (gen_addsi3 (dest, tp, addend));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return dest;\n+}\n+\n+\n rtx\n xtensa_legitimize_address (rtx x,\n \t\t\t   rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t   enum machine_mode mode)\n {\n+  if (xtensa_tls_symbol_p (x))\n+    return xtensa_legitimize_tls_address (x);\n+\n   if (GET_CODE (x) == PLUS)\n     {\n       rtx plus0 = XEXP (x, 0);\n@@ -1745,6 +1877,46 @@ xtensa_legitimize_address (rtx x,\n }\n \n \n+/* Helper for xtensa_tls_referenced_p.  */\n+\n+static int\n+xtensa_tls_referenced_p_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (*x) == SYMBOL_REF)\n+    return SYMBOL_REF_TLS_MODEL (*x) != 0;\n+\n+  /* Ignore TLS references that have already been legitimized.  */\n+  if (GET_CODE (*x) == UNSPEC)\n+    {\n+      switch (XINT (*x, 1))\n+\t{\n+\tcase UNSPEC_TPOFF:\n+\tcase UNSPEC_DTPOFF:\n+\tcase UNSPEC_TLS_FUNC:\n+\tcase UNSPEC_TLS_ARG:\n+\tcase UNSPEC_TLS_CALL:\n+\t  return -1;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Return TRUE if X contains any TLS symbol references.  */\n+\n+bool\n+xtensa_tls_referenced_p (rtx x)\n+{\n+  if (! TARGET_HAVE_TLS)\n+    return false;\n+\n+  return for_each_rtx (&x, xtensa_tls_referenced_p_1, NULL);\n+}\n+\n+\n /* Return the debugger register number to use for 'regno'.  */\n \n int\n@@ -2204,6 +2376,14 @@ xtensa_output_addr_const_extra (FILE *fp, rtx x)\n     {\n       switch (XINT (x, 1))\n \t{\n+\tcase UNSPEC_TPOFF:\n+\t  output_addr_const (fp, XVECEXP (x, 0, 0));\n+\t  fputs (\"@TPOFF\", fp);\n+\t  return true;\n+\tcase UNSPEC_DTPOFF:\n+\t  output_addr_const (fp, XVECEXP (x, 0, 0));\n+\t  fputs (\"@DTPOFF\", fp);\n+\t  return true;\n \tcase UNSPEC_PLT:\n \t  if (flag_pic)\n \t    {\n@@ -2760,22 +2940,43 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n enum xtensa_builtin\n {\n   XTENSA_BUILTIN_UMULSIDI3,\n+  XTENSA_BUILTIN_THREAD_POINTER,\n+  XTENSA_BUILTIN_SET_THREAD_POINTER,\n   XTENSA_BUILTIN_max\n };\n \n \n static void\n xtensa_init_builtins (void)\n {\n-  tree ftype;\n+  tree ftype, decl;\n \n   ftype = build_function_type_list (unsigned_intDI_type_node,\n \t\t\t\t    unsigned_intSI_type_node,\n \t\t\t\t    unsigned_intSI_type_node, NULL_TREE);\n \n-  add_builtin_function (\"__builtin_umulsidi3\", ftype,\n-\t\t\tXTENSA_BUILTIN_UMULSIDI3, BUILT_IN_MD,\n-\t\t\t\"__umulsidi3\", NULL_TREE);\n+  decl = add_builtin_function (\"__builtin_umulsidi3\", ftype,\n+\t\t\t       XTENSA_BUILTIN_UMULSIDI3, BUILT_IN_MD,\n+\t\t\t       \"__umulsidi3\", NULL_TREE);\n+  TREE_NOTHROW (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+\n+  if (TARGET_THREADPTR)\n+    {\n+      ftype = build_function_type (ptr_type_node, void_list_node);\n+      decl = add_builtin_function (\"__builtin_thread_pointer\", ftype,\n+\t\t\t\t   XTENSA_BUILTIN_THREAD_POINTER, BUILT_IN_MD,\n+\t\t\t\t   NULL, NULL_TREE);\n+      TREE_READONLY (decl) = 1;\n+      TREE_NOTHROW (decl) = 1;\n+\n+      ftype = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\t\tNULL_TREE);\n+      decl = add_builtin_function (\"__builtin_set_thread_pointer\", ftype,\n+\t\t\t\t   XTENSA_BUILTIN_SET_THREAD_POINTER,\n+\t\t\t\t   BUILT_IN_MD, NULL, NULL_TREE);\n+      TREE_NOTHROW (decl) = 1;\n+    }\n }\n \n \n@@ -2785,20 +2986,27 @@ xtensa_fold_builtin (tree fndecl, tree arglist, bool ignore ATTRIBUTE_UNUSED)\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   tree arg0, arg1;\n \n-  if (fcode == XTENSA_BUILTIN_UMULSIDI3)\n+  switch (fcode)\n     {\n+    case XTENSA_BUILTIN_UMULSIDI3:\n       arg0 = TREE_VALUE (arglist);\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       if ((TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n \t  || TARGET_MUL32_HIGH)\n \treturn fold_build2 (MULT_EXPR, unsigned_intDI_type_node,\n \t\t\t    fold_convert (unsigned_intDI_type_node, arg0),\n \t\t\t    fold_convert (unsigned_intDI_type_node, arg1));\n-      else\n-\treturn NULL;\n+      break;\n+\n+    case XTENSA_BUILTIN_THREAD_POINTER:\n+    case XTENSA_BUILTIN_SET_THREAD_POINTER:\n+      break;\n+\n+    default:\n+      internal_error (\"bad builtin code\");\n+      break;\n     }\n \n-  internal_error (\"bad builtin code\");\n   return NULL;\n }\n \n@@ -2811,14 +3019,32 @@ xtensa_expand_builtin (tree exp, rtx target,\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  rtx arg;\n+\n+  switch (fcode)\n+    {\n+    case XTENSA_BUILTIN_UMULSIDI3:\n+      /* The umulsidi3 builtin is just a mechanism to avoid calling the real\n+\t __umulsidi3 function when the Xtensa configuration can directly\n+\t implement it.  If not, just call the function.  */\n+      return expand_call (exp, target, ignore);\n \n-  /* The umulsidi3 builtin is just a mechanism to avoid calling the real\n-     __umulsidi3 function when the Xtensa configuration can directly\n-     implement it.  If not, just call the function.  */\n-  if (fcode == XTENSA_BUILTIN_UMULSIDI3)\n-    return expand_call (exp, target, ignore);\n+    case XTENSA_BUILTIN_THREAD_POINTER:\n+      if (!target || !register_operand (target, Pmode))\n+\ttarget = gen_reg_rtx (Pmode);\n+      emit_insn (gen_load_tp (target));\n+      return target;\n \n-  internal_error (\"bad builtin code\");\n+    case XTENSA_BUILTIN_SET_THREAD_POINTER:\n+      arg = expand_normal (CALL_EXPR_ARG (exp, 0));\n+      if (!register_operand (arg, Pmode))\n+\targ = copy_to_mode_reg (Pmode, arg);\n+      emit_insn (gen_set_tp (arg));\n+      return const0_rtx;\n+\n+    default:\n+      internal_error (\"bad builtin code\");\n+    }\n   return NULL_RTX;\n }\n "}, {"sha": "1427fd0e3da8df6b6f23157f5810c9f19961a7b8", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -51,6 +51,9 @@ extern unsigned xtensa_current_frame_size;\n #ifndef XCHAL_HAVE_S32C1I\n #define XCHAL_HAVE_S32C1I 0\n #endif\n+#ifndef XCHAL_HAVE_THREADPTR\n+#define XCHAL_HAVE_THREADPTR 0\n+#endif\n #define TARGET_BIG_ENDIAN\tXCHAL_HAVE_BE\n #define TARGET_DENSITY\t\tXCHAL_HAVE_DENSITY\n #define TARGET_MAC16\t\tXCHAL_HAVE_MAC16\n@@ -72,11 +75,16 @@ extern unsigned xtensa_current_frame_size;\n #define TARGET_RELEASE_SYNC\tXCHAL_HAVE_RELEASE_SYNC\n #define TARGET_S32C1I\t\tXCHAL_HAVE_S32C1I\n #define TARGET_ABSOLUTE_LITERALS XSHAL_USE_ABSOLUTE_LITERALS\n+#define TARGET_THREADPTR\tXCHAL_HAVE_THREADPTR\n \n #define TARGET_DEFAULT \\\n   ((XCHAL_HAVE_L32R\t? 0 : MASK_CONST16) |\t\t\t\t\\\n    MASK_SERIALIZE_VOLATILE)\n \n+#ifndef HAVE_AS_TLS\n+#define HAVE_AS_TLS 0\n+#endif\n+\n #define OVERRIDE_OPTIONS override_options ()\n \n /* Reordering blocks for Xtensa is not a good idea unless the compiler\n@@ -791,7 +799,7 @@ typedef struct xtensa_args\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-#define LEGITIMATE_CONSTANT_P(X) 1\n+#define LEGITIMATE_CONSTANT_P(X) (! xtensa_tls_referenced_p (X))\n \n /* A C expression that is nonzero if X is a legitimate immediate\n    operand on the target machine when generating position independent"}, {"sha": "29119ed16bb796498ceaf34eaad3b8c046a017e5", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 73, "deletions": 3, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -29,13 +29,20 @@\n   (UNSPEC_NOP\t\t2)\n   (UNSPEC_PLT\t\t3)\n   (UNSPEC_RET_ADDR\t4)\n+  (UNSPEC_TPOFF\t\t5)\n+  (UNSPEC_DTPOFF\t6)\n+  (UNSPEC_TLS_FUNC\t7)\n+  (UNSPEC_TLS_ARG\t8)\n+  (UNSPEC_TLS_CALL\t9)\n+  (UNSPEC_TP\t\t10)\n \n   (UNSPECV_SET_FP\t1)\n   (UNSPECV_ENTRY\t2)\n   (UNSPECV_MEMW\t\t3)\n   (UNSPECV_S32RI\t4)\n   (UNSPECV_S32C1I\t5)\n   (UNSPECV_EH_RETURN\t6)\n+  (UNSPECV_SET_TP\t7)\n ])\n \n ;; This code iterator allows signed and unsigned widening multiplications\n@@ -1560,9 +1567,9 @@\n })\n \n (define_insn \"call_value_internal\"\n-   [(set (match_operand 0 \"register_operand\" \"=a\")\n-         (call (mem (match_operand:SI 1 \"call_insn_operand\" \"nir\"))\n-               (match_operand 2 \"\" \"i\")))]\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (call (mem (match_operand:SI 1 \"call_insn_operand\" \"nir\"))\n+              (match_operand 2 \"\" \"i\")))]\n   \"\"\n {\n   return xtensa_emit_call (1, operands);\n@@ -1697,6 +1704,69 @@\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"0\")])\n \n+\f\n+;; TLS support\n+\n+(define_expand \"sym_TPOFF\"\n+  [(const (unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_TPOFF))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"sym_DTPOFF\"\n+  [(const (unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_DTPOFF))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"load_tp\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_TP))]\n+  \"TARGET_THREADPTR\"\n+  \"rur\\t%0, THREADPTR\"\n+  [(set_attr \"type\"\t\"rsr\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"set_tp\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t    UNSPECV_SET_TP)]\n+  \"TARGET_THREADPTR\"\n+  \"wur\\t%0, THREADPTR\"\n+  [(set_attr \"type\"\t\"wsr\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"tls_func\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"tls_symbol_operand\" \"\")]\n+\t\t   UNSPEC_TLS_FUNC))]\n+  \"TARGET_THREADPTR && HAVE_AS_TLS\"\n+  \"movi\\t%0, %1@TLSFUNC\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"tls_arg\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"tls_symbol_operand\" \"\")]\n+\t\t   UNSPEC_TLS_ARG))]\n+  \"TARGET_THREADPTR && HAVE_AS_TLS\"\n+  \"movi\\t%0, %1@TLSARG\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"tls_call\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(call (mem:SI (unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t  (match_operand:SI 2 \"tls_symbol_operand\" \"\")]\n+\t\t\t\t  UNSPEC_TLS_CALL))\n+\t      (match_operand 3 \"\" \"i\")))]\n+  \"TARGET_THREADPTR && HAVE_AS_TLS\"\n+  \"callx8.tls %1, %2@TLSCALL\"\n+  [(set_attr \"type\"\t\"call\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n \f\n ;; Instructions for the Xtensa \"boolean\" option.\n "}, {"sha": "0dbf86acfe46ca70ba7c1fcb65af9d39479285d5", "filename": "gcc/configure", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -21194,7 +21194,7 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n-# Thread-local storage - the check is heavily parametrized.\n+# Thread-local storage - the check is heavily parameterized.\n conftest_s=\n tls_first_major=\n tls_first_minor=\n@@ -21526,6 +21526,17 @@ foo:\t.long\t25\n \ttls_as_opt=\"-32 --fatal-warnings\"\n       fi\n \t;;\n+  xtensa*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tmovi\ta8, foo@TLSFUNC\n+\tmovi\ta10, foo@TLSARG\n+\tcallx8.tls a8, foo@TLSCALL'\n+\ttls_first_major=2\n+\ttls_first_minor=19\n+\t;;\n esac\n set_have_as_tls=no\n if test \"x$enable_tls\" = xno ; then"}, {"sha": "b6bc311b728bc1703f8c7828ca1323a8c344c9ec", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=6a7a462cbfe97638fcfe74a8c5e4b847d71f6e9d", "patch": "@@ -2322,7 +2322,7 @@ AC_DEFINE_UNQUOTED(HAVE_COMDAT_GROUP,\n   [`if test $gcc_cv_as_comdat_group = yes || test $gcc_cv_as_comdat_group_percent = yes; then echo 1; else echo 0; fi`],\n [Define 0/1 if your assembler and linker support COMDAT groups.])\n \n-# Thread-local storage - the check is heavily parametrized.\n+# Thread-local storage - the check is heavily parameterized.\n conftest_s=\n tls_first_major=\n tls_first_minor=\n@@ -2655,6 +2655,17 @@ foo:\t.long\t25\n \ttls_as_opt=\"-32 --fatal-warnings\"\n       fi\n \t;;\n+  xtensa*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tmovi\ta8, foo@TLSFUNC\n+\tmovi\ta10, foo@TLSARG\n+\tcallx8.tls a8, foo@TLSCALL'\n+\ttls_first_major=2\n+\ttls_first_minor=19\n+\t;;\n changequote([,])dnl\n esac\n set_have_as_tls=no"}]}