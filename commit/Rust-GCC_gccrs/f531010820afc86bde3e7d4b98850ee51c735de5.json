{"sha": "f531010820afc86bde3e7d4b98850ee51c735de5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUzMTAxMDgyMGFmYzg2YmRlM2U3ZDRiOTg4NTBlZTUxYzczNWRlNQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-04-20T01:38:46Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-04-20T01:38:46Z"}, "message": "class.c (make_class_data): Add new field aux_info.\n\n2004-04-19  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* class.c (make_class_data): Add new field aux_info.\n\t* decl.c (java_init_decl_processing): Push type and decl for\n\t`aux_info'.\n\n2004-04-19  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* gcj/cni.h (JvAllocObject): Remove these obsolete,\n\tundocumented CNI calls.\n\t* include/java-interp.h (_Jv_InterpClass): No longer\n\textends java.lang.Class.\n\t* java/lang/Class.h (Class): Add new field `aux_info'.\n\t* boehm.cc (_Jv_MarkObj): Update java.lang.Class marking.\n\t* defineclass.cc: Remove Class<->_Jv_InterpClass casts.\n\tUse Class->aux_info instead.\n\t* jni.cc (_Jv_JNI_AllocObject): Use _Jv_AllocObject.\n\t* resolve.cc: Remove Class<->_Jv_InterpClass casts.\n\tUse Class->aux_info instead.\n\t* java/io/natObjectInputStream.cc (allocateObject): Use\n\t_Jv_AllocObject.\n\t* java/lang/natClass.cc (newInstance): Likewise.\n\t* java/lang/natClassLoader.cc (_Jv_NewClass): Likewise.\n\t* java/lang/natObject.cc (clone): Likewise.\n\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Likewise.\n\t* java/lang/natVMClassLoader.cc (defineClass): Don't use\n\tJvAllocObject. Allocate klass->aux_info here for interpreted\n\tclass.\n\nFrom-SVN: r80875", "tree": {"sha": "de88ceabf2ba85e265495894813895ad9f7f43cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de88ceabf2ba85e265495894813895ad9f7f43cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f531010820afc86bde3e7d4b98850ee51c735de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f531010820afc86bde3e7d4b98850ee51c735de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f531010820afc86bde3e7d4b98850ee51c735de5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f531010820afc86bde3e7d4b98850ee51c735de5/comments", "author": null, "committer": null, "parents": [{"sha": "712faa50dd829c2e813a7169ef71ec20a6465666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712faa50dd829c2e813a7169ef71ec20a6465666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712faa50dd829c2e813a7169ef71ec20a6465666"}], "stats": {"total": 195, "additions": 113, "deletions": 82}, "files": [{"sha": "e2933a8dcb438d733370426f3b9fd2226ec9994e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -1,3 +1,9 @@\n+2004-04-19  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* class.c (make_class_data): Add new field aux_info.\n+\t* decl.c (java_init_decl_processing): Push type and decl for \n+\t`aux_info'.\n+\n 2004-04-15  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* expr.c (expand_java_NEW): Don't use size argument for "}, {"sha": "4ac4a4f0311336e0c13ef996ecf31e4910f78d80", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -1723,6 +1723,7 @@ make_class_data (tree type)\n   PUSH_FIELD_VALUE (cons, \"protectionDomain\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"hack_signers\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"chain\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"aux_info\", null_pointer_node);\n \n   FINISH_RECORD_CONSTRUCTOR (cons);\n "}, {"sha": "872042353f46bae1803dafe6c647fccf45c64b05", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -690,6 +690,7 @@ java_init_decl_processing (void)\n   PUSH_FIELD (class_type_node, field, \"protectionDomain\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"hack_signers\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"chain\", ptr_type_node);\n+  PUSH_FIELD (class_type_node, field, \"aux_info\", ptr_type_node);\n   for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);"}, {"sha": "70e4f8c3a22d80dd0b59832817f5505f79702038", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -1,3 +1,26 @@\n+2004-04-19  Bryce McKinlay  <mckinlay@redhat.com>\n+ \n+\t* gcj/cni.h (JvAllocObject): Remove these obsolete, \n+\tundocumented CNI calls.\n+\t* include/java-interp.h (_Jv_InterpClass): No longer\n+\textends java.lang.Class.\n+\t* java/lang/Class.h (Class): Add new field `aux_info'.\n+\t* boehm.cc (_Jv_MarkObj): Update java.lang.Class marking.\n+\t* defineclass.cc: Remove Class<->_Jv_InterpClass casts.\n+\tUse Class->aux_info instead.\n+\t* jni.cc (_Jv_JNI_AllocObject): Use _Jv_AllocObject.\n+\t* resolve.cc: Remove Class<->_Jv_InterpClass casts.\n+\tUse Class->aux_info instead.\n+\t* java/io/natObjectInputStream.cc (allocateObject): Use\n+\t_Jv_AllocObject.\n+\t* java/lang/natClass.cc (newInstance): Likewise.\n+\t* java/lang/natClassLoader.cc (_Jv_NewClass): Likewise.\n+\t* java/lang/natObject.cc (clone): Likewise.\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Likewise.\n+\t* java/lang/natVMClassLoader.cc (defineClass): Don't use\n+\tJvAllocObject. Allocate klass->aux_info here for interpreted\n+\tclass.\n+\t\n 2004-04-17  Mark Wielaard  <mark@klomp.org>\n \n \t* javax/swing/JToggleButton.java (ToggleButtonModel):"}, {"sha": "cf84918617e215c62cbef5d745aef11303c8c60d", "filename": "libjava/boehm.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -208,11 +208,13 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /* env */)\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cPlabel);\n       p = (ptr_t) c->hack_signers;\n       MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cSlabel);\n+      p = (ptr_t) c->aux_info;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cTlabel);\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n-\t  _Jv_InterpClass* ic = (_Jv_InterpClass*) c;\n+\t  _Jv_InterpClass* ic = (_Jv_InterpClass*) c->aux_info;\n \n \t  p = (ptr_t) ic->interpreted_methods;\n \t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cElabel);"}, {"sha": "156efb5b1d72f467c853c0df1afd75226bb3ac1b", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -96,7 +96,10 @@ struct _Jv_ClassReader {\n   unsigned int      *offsets;\n \n   // the class to define (see java-interp.h)\n-  _Jv_InterpClass   *def;\n+  jclass\t   def;\n+  \n+  // the classes associated interpreter data.\n+  _Jv_InterpClass  *def_interp;\n \n   /* check that the given number of input bytes are available */\n   inline void check (int num)\n@@ -221,7 +224,8 @@ struct _Jv_ClassReader {\n     bytes  = (unsigned char*) (elements (data)+offset);\n     len    = length;\n     pos    = 0;\n-    def    = (_Jv_InterpClass*) klass;\n+    def    = klass;\n+    def_interp = (_Jv_InterpClass *) def->aux_info;\n   }\n \n   /** and here goes the parser members defined out-of-line */\n@@ -1047,10 +1051,10 @@ void _Jv_ClassReader::handleFieldsBegin (int count)\n   def->fields = (_Jv_Field*) \n     _Jv_AllocBytes (count * sizeof (_Jv_Field));\n   def->field_count = count;\n-  def->field_initializers = (_Jv_ushort*)\n+  def_interp->field_initializers = (_Jv_ushort*)\n     _Jv_AllocBytes (count * sizeof (_Jv_ushort));\n   for (int i = 0; i < count; i++)\n-    def->field_initializers[i] = (_Jv_ushort) 0;\n+    def_interp->field_initializers[i] = (_Jv_ushort) 0;\n }\n \n void _Jv_ClassReader::handleField (int field_no,\n@@ -1133,7 +1137,7 @@ void _Jv_ClassReader::handleConstantValueAttribute (int field_index,\n     throw_class_format_error (\"field has multiple ConstantValue attributes\");\n \n   field->flags |= _Jv_FIELD_CONSTANT_VALUE;\n-  def->field_initializers[field_index] = value;\n+  def_interp->field_initializers[field_index] = value;\n \n   /* type check the initializer */\n   \n@@ -1153,7 +1157,7 @@ void _Jv_ClassReader::handleFieldsEnd ()\n   int low            = 0;\n   int high           = def->field_count-1;\n   _Jv_Field  *fields = def->fields;\n-  _Jv_ushort *inits  = def->field_initializers;\n+  _Jv_ushort *inits  = def_interp->field_initializers;\n \n   // this is kind of a raw version of quicksort.\n   while (low < high)\n@@ -1195,13 +1199,13 @@ _Jv_ClassReader::handleMethodsBegin (int count)\n {\n   def->methods = (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method) * count);\n \n-  def->interpreted_methods\n+  def_interp->interpreted_methods\n     = (_Jv_MethodBase **) _Jv_AllocBytes (sizeof (_Jv_MethodBase *)\n \t\t\t\t\t  * count);\n \n   for (int i = 0; i < count; i++)\n     {\n-      def->interpreted_methods[i] = 0;\n+      def_interp->interpreted_methods[i] = 0;\n       def->methods[i].index = (_Jv_ushort) -1;\n     }\n \n@@ -1284,7 +1288,7 @@ void _Jv_ClassReader::handleCodeAttribute\n \t  (void*) (bytes+code_start),\n \t  code_length);\n \n-  def->interpreted_methods[method_index] = method;\n+  def_interp->interpreted_methods[method_index] = method;\n \n   if ((method->self->accflags & java::lang::reflect::Modifier::STATIC))\n     {\n@@ -1301,7 +1305,7 @@ void _Jv_ClassReader::handleExceptionTableEntry\n    int start_pc, int end_pc, int handler_pc, int catch_type)\n {\n   _Jv_InterpMethod *method = reinterpret_cast<_Jv_InterpMethod *>\n-    (def->interpreted_methods[method_index]);\n+    (def_interp->interpreted_methods[method_index]);\n   _Jv_InterpException *exc = method->exceptions ();\n \n   exc[exc_index].start_pc.i     = start_pc;\n@@ -1319,7 +1323,7 @@ void _Jv_ClassReader::handleMethodsEnd ()\n       _Jv_Method *method = &def->methods[i];\n       if ((method->accflags & Modifier::NATIVE) != 0)\n \t{\n-\t  if (def->interpreted_methods[i] != 0)\n+\t  if (def_interp->interpreted_methods[i] != 0)\n \t    throw_class_format_error (\"code provided for native method\");\n \t  else\n \t    {\n@@ -1328,7 +1332,7 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t      m->defining_class = def;\n \t      m->self = method;\n \t      m->function = NULL;\n-\t      def->interpreted_methods[i] = m;\n+\t      def_interp->interpreted_methods[i] = m;\n \t      m->deferred = NULL;\n \n \t      if ((method->accflags & Modifier::STATIC))\n@@ -1344,12 +1348,12 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t}\n       else if ((method->accflags & Modifier::ABSTRACT) != 0)\n \t{\n-\t  if (def->interpreted_methods[i] != 0)\n+\t  if (def_interp->interpreted_methods[i] != 0)\n \t    throw_class_format_error (\"code provided for abstract method\");\n \t}\n       else\n \t{\n-\t  if (def->interpreted_methods[i] == 0)\n+\t  if (def_interp->interpreted_methods[i] == 0)\n \t    throw_class_format_error (\"method with no code\");\n \t}\n     }"}, {"sha": "59cf673b09273748979e363720a3863a77f6e3ff", "filename": "libjava/gcj/cni.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fgcj%2Fcni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fgcj%2Fcni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fcni.h?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -20,18 +20,6 @@ details.  */\n \n #include <string.h>\n \n-extern inline jobject\n-JvAllocObject (jclass cls)\n-{\n-  return _Jv_AllocObject (cls);\n-}\n-\n-extern inline jobject\n-JvAllocObject (jclass cls, jsize sz)\n-{\n-  return _Jv_AllocObject (cls);\n-}\n-\n extern \"C\" jstring _Jv_NewStringUTF (const char *bytes);\n extern \"C\" void _Jv_InitClass (jclass);\n "}, {"sha": "c57c146dacbbcd429574d652772daffe85fa3ffc", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -22,7 +22,6 @@ details.  */\n #include <java/lang/Class.h>\n #include <java/lang/ClassLoader.h>\n #include <java/lang/reflect/Modifier.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n \n extern \"C\" {\n #include <ffi.h>\n@@ -80,7 +79,7 @@ class _Jv_MethodBase\n {\n protected:\n   // The class which defined this method.\n-  _Jv_InterpClass *defining_class;\n+  jclass defining_class;\n \n   // The method description.\n   _Jv_Method *self;\n@@ -150,6 +149,7 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   friend class _Jv_BytecodeVerifier;\n   friend class gnu::gcj::runtime::NameFinder;\n   friend class gnu::gcj::runtime::StackTrace;\n+  \n \n   friend void _Jv_PrepareClass(jclass);\n \n@@ -158,7 +158,7 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n #endif\n };\n \n-class _Jv_InterpClass : public java::lang::Class\n+class _Jv_InterpClass\n {\n   _Jv_MethodBase **interpreted_methods;\n   _Jv_ushort        *field_initializers;\n@@ -185,13 +185,15 @@ extern inline void\n _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **address)\n {\n   int i;\n-  _Jv_InterpClass *self = (_Jv_InterpClass *)cl;\n+  jclass self = (jclass) cl;\n+  _Jv_InterpClass *interp_cl = (_Jv_InterpClass*) self->aux_info;\n+\n   for (i = 0; i < self->method_count; i++)\n     {\n       _Jv_Method *m = &self->methods[i];\n       if (m == meth)\n \t{\n-\t  _Jv_MethodBase *imeth = self->interpreted_methods[i];\n+\t  _Jv_MethodBase *imeth = interp_cl->interpreted_methods[i];\n \t  *address = imeth->deferred;\n \t  imeth->deferred = address;\n \t  return;"}, {"sha": "bb3796ff4fac505732d3e94ab238889cb2da4e31", "filename": "libjava/java/io/natObjectInputStream.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatObjectInputStream.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -38,7 +38,7 @@ java::io::ObjectInputStream::allocateObject (jclass klass)\n \tobj = NULL;\t\n       else\n \t{\n-\t  obj = JvAllocObject (klass);\n+\t  obj = _Jv_AllocObject (klass);\n \t}\n     }\n   catch (jthrowable t)"}, {"sha": "86dc6a079db68b131a5162aa9b3a9ad97d68819c", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -384,6 +384,7 @@ class java::lang::Class : public java::lang::Object\n #endif\n \n   friend class _Jv_BytecodeVerifier;\n+  friend class _Jv_StackTrace;\n   friend class gnu::gcj::runtime::StackTrace;\n   friend class java::io::VMObjectStreamClass;\n \n@@ -449,6 +450,9 @@ class java::lang::Class : public java::lang::Object\n   JArray<jobject> *hack_signers;\n   // Used by Jv_PopClass and _Jv_PushClass to communicate with StackTrace.\n   jclass chain;\n+  // Additional data, specific to the generator (JIT, native, interpreter) of this \n+  // class.\n+  void *aux_info;\n };\n \n #endif /* __JAVA_LANG_CLASS_H__ */"}, {"sha": "419ed7d9d293131187971d7b0ceb0a1611572233", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -691,7 +691,7 @@ java::lang::Class::newInstance (void)\n   if (! meth)\n     throw new java::lang::InstantiationException (getName());\n \n-  jobject r = JvAllocObject (this);\n+  jobject r = _Jv_AllocObject (this);\n   ((void (*) (jobject)) meth->ncode) (r);\n   return r;\n }\n@@ -1901,7 +1901,7 @@ _Jv_MakeVTable (jclass klass)\n       || (klass->accflags & Modifier::ABSTRACT))\n     return;\n \n-  //  out before we can create a vtable. \n+  // Class must be laid out before we can create a vtable. \n   if (klass->vtable_method_count == -1)\n     _Jv_LayoutVTableMethods (klass);\n "}, {"sha": "9921d1d10e37603beaef3e66125fcc44f520c0e8", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -419,7 +419,7 @@ jclass\n _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n \t      java::lang::ClassLoader *loader)\n {\n-  jclass ret = (jclass) JvAllocObject (&java::lang::Class::class$);\n+  jclass ret = (jclass) _Jv_AllocObject (&java::lang::Class::class$);\n   ret->name = name;\n   ret->superclass = superclass;\n   ret->loader = loader;"}, {"sha": "5855fc18934d64372b868116e6efe71ee156faa0", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -98,7 +98,7 @@ java::lang::Object::clone (void)\n \tthrow new CloneNotSupportedException;\n \n       size = klass->size();\n-      r = JvAllocObject (klass, size);\n+      r = _Jv_AllocObject (klass);\n     }\n \n   memcpy ((void *) r, (void *) this, size);"}, {"sha": "1ed3851fbb353312d074ec59f8fc5fe679acc79d", "filename": "libjava/java/lang/natVMClassLoader.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -39,8 +39,8 @@ java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *loader,\n {\n #ifdef INTERPRETER\n   jclass klass;\n-  klass = (jclass) JvAllocObject (&java::lang::Class::class$,\n-\t\t\t\t  sizeof (_Jv_InterpClass));\n+  klass = new java::lang::Class ();\n+  klass->aux_info = (void *) _Jv_AllocBytes (sizeof (_Jv_InterpClass));\n \n   // Synchronize on the class, so that it is not attempted initialized\n   // until we're done loading."}, {"sha": "8f9efdbb53b31599478394395d7217cf51e4e9a2", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -379,7 +379,7 @@ _Jv_CallAnyMethodA (jobject obj,\n   // the JDK 1.2 docs specify that the new object must be allocated\n   // before argument conversions are done.\n   if (is_constructor)\n-    obj = JvAllocObject (return_type);\n+    obj = _Jv_AllocObject (return_type);\n \n   const int size_per_arg = sizeof(jvalue);\n   ffi_cif cif;"}, {"sha": "680e0c758df591efa0ad044dbf1966775ac0e328", "filename": "libjava/jni.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -633,7 +633,7 @@ static jobject\n       if (clazz->isInterface() || Modifier::isAbstract(clazz->getModifiers()))\n \tenv->ex = new java::lang::InstantiationException ();\n       else\n-\tobj = JvAllocObject (clazz);\n+\tobj = _Jv_AllocObject (clazz);\n     }\n   catch (jthrowable t)\n     {"}, {"sha": "85c988f6758bd182fd4e1846a50d4e9201430e3f", "filename": "libjava/resolve.cc", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f531010820afc86bde3e7d4b98850ee51c735de5/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=f531010820afc86bde3e7d4b98850ee51c735de5", "patch": "@@ -367,9 +367,9 @@ _Jv_SearchMethodInClass (jclass cls, jclass klass,\n // A helper for _Jv_PrepareClass.  This adds missing `Miranda methods'\n // to a class.\n void\n-_Jv_PrepareMissingMethods (jclass base2, jclass iface_class)\n+_Jv_PrepareMissingMethods (jclass base, jclass iface_class)\n {\n-  _Jv_InterpClass *base = reinterpret_cast<_Jv_InterpClass *> (base2);\n+  _Jv_InterpClass *interp_base = (_Jv_InterpClass *) base->aux_info;\n   for (int i = 0; i < iface_class->interface_count; ++i)\n     {\n       for (int j = 0; j < iface_class->interfaces[i]->method_count; ++j)\n@@ -403,11 +403,11 @@ _Jv_PrepareMissingMethods (jclass base2, jclass iface_class)\n \t      _Jv_MethodBase **new_im\n \t\t= (_Jv_MethodBase **) _Jv_AllocBytes (sizeof (_Jv_MethodBase *)\n \t\t\t\t\t\t      * new_count);\n-\t      memcpy (new_im, base->interpreted_methods,\n+\t      memcpy (new_im, interp_base->interpreted_methods,\n \t\t      sizeof (_Jv_MethodBase *) * base->method_count);\n \n \t      base->methods = new_m;\n-\t      base->interpreted_methods = new_im;\n+\t      interp_base->interpreted_methods = new_im;\n \t      base->method_count = new_count;\n \t    }\n \t}\n@@ -454,15 +454,15 @@ _Jv_PrepareClass(jclass klass)\n   if (klass->superclass)\n     java::lang::VMClassLoader::resolveClass (klass->superclass);\n \n-  _Jv_InterpClass *clz = (_Jv_InterpClass*)klass;\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass*)klass->aux_info;\n \n   /************ PART ONE: OBJECT LAYOUT ***************/\n \n   // Compute the alignment for this type by searching through the\n   // superclasses and finding the maximum required alignment.  We\n   // could consider caching this in the Class.\n   int max_align = __alignof__ (java::lang::Object);\n-  jclass super = clz->superclass;\n+  jclass super = klass->superclass;\n   while (super != NULL)\n     {\n       int num = JvNumInstanceFields (super);\n@@ -484,23 +484,23 @@ _Jv_PrepareClass(jclass klass)\n   // Although java.lang.Object is never interpreted, an interface can\n   // have a null superclass.  Note that we have to lay out an\n   // interface because it might have static fields.\n-  if (clz->superclass)\n-    instance_size = clz->superclass->size();\n+  if (klass->superclass)\n+    instance_size = klass->superclass->size();\n   else\n     instance_size = java::lang::Object::class$.size();\n \n-  for (int i = 0; i < clz->field_count; i++)\n+  for (int i = 0; i < klass->field_count; i++)\n     {\n       int field_size;\n       int field_align;\n \n-      _Jv_Field *field = &clz->fields[i];\n+      _Jv_Field *field = &klass->fields[i];\n \n       if (! field->isRef ())\n \t{\n \t  // it's safe to resolve the field here, since it's \n \t  // a primitive class, which does not cause loading to happen.\n-\t  _Jv_ResolveField (field, clz->loader);\n+\t  _Jv_ResolveField (field, klass->loader);\n \n \t  field_size = field->type->size ();\n \t  field_align = get_alignment_from_class (field->type);\n@@ -538,7 +538,7 @@ _Jv_PrepareClass(jclass klass)\n   // to the alignment required for this object; this keeps us in sync\n   // with our current ABI.\n   instance_size = ROUND (instance_size, max_align);\n-  clz->size_in_bytes = instance_size;\n+  klass->size_in_bytes = instance_size;\n \n   // allocate static memory\n   if (static_size != 0)\n@@ -547,67 +547,67 @@ _Jv_PrepareClass(jclass klass)\n \n       memset (static_data, 0, static_size);\n \n-      for (int i = 0; i < clz->field_count; i++)\n+      for (int i = 0; i < klass->field_count; i++)\n \t{\n-\t  _Jv_Field *field = &clz->fields[i];\n+\t  _Jv_Field *field = &klass->fields[i];\n \n \t  if ((field->flags & Modifier::STATIC) != 0)\n \t    {\n \t      field->u.addr  = static_data + field->u.boffset;\n-\t\t\t    \n-\t      if (clz->field_initializers[i] != 0)\n+\t      \n+\t      if (iclass->field_initializers[i] != 0)\n \t\t{\n-\t\t  _Jv_ResolveField (field, clz->loader);\n-\t\t  _Jv_InitField (0, clz, i);\n+\t\t  _Jv_ResolveField (field, klass->loader);\n+\t\t  _Jv_InitField (0, klass, i);\n \t\t}\n \t    }\n \t}\n \n       // now we don't need the field_initializers anymore, so let the\n       // collector get rid of it!\n \n-      clz->field_initializers = 0;\n+      iclass->field_initializers = 0;\n     }\n \n   /************ PART TWO: VTABLE LAYOUT ***************/\n \n   /* preparation: build the vtable stubs (even interfaces can)\n      have code -- for static constructors. */\n-  for (int i = 0; i < clz->method_count; i++)\n+  for (int i = 0; i < klass->method_count; i++)\n     {\n-      _Jv_MethodBase *imeth = clz->interpreted_methods[i];\n+      _Jv_MethodBase *imeth = iclass->interpreted_methods[i];\n \n-      if ((clz->methods[i].accflags & Modifier::NATIVE) != 0)\n+      if ((klass->methods[i].accflags & Modifier::NATIVE) != 0)\n \t{\n \t  // You might think we could use a virtual `ncode' method in\n \t  // the _Jv_MethodBase and unify the native and non-native\n \t  // cases.  Well, we can't, because we don't allocate these\n \t  // objects using `new', and thus they don't get a vtable.\n \t  _Jv_JNIMethod *jnim = reinterpret_cast<_Jv_JNIMethod *> (imeth);\n-\t  clz->methods[i].ncode = jnim->ncode ();\n+\t  klass->methods[i].ncode = jnim->ncode ();\n \t}\n       else if (imeth != 0)\t\t// it could be abstract\n \t{\n \t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n \t  _Jv_VerifyMethod (im);\n-\t  clz->methods[i].ncode = im->ncode ();\n+\t  klass->methods[i].ncode = im->ncode ();\n \n \t  // Resolve ctable entries pointing to this method.  See\n \t  // _Jv_Defer_Resolution.\n \t  void **code = (void **)imeth->deferred;\n \t  while (code)\n \t    {\n \t      void **target = (void **)*code;\n-\t      *code = clz->methods[i].ncode;\n+\t      *code = klass->methods[i].ncode;\n \t      code = target;\n \t    }\n \t}\n     }\n \n-  if ((clz->accflags & Modifier::INTERFACE))\n+  if ((klass->accflags & Modifier::INTERFACE))\n     {\n-      clz->state = JV_STATE_PREPARED;\n-      clz->notifyAll ();\n+      klass->state = JV_STATE_PREPARED;\n+      klass->notifyAll ();\n       return;\n     }\n \n@@ -619,15 +619,15 @@ _Jv_PrepareClass(jclass klass)\n   // this here by searching for such methods and constructing new\n   // internal declarations for them.  We only need to do this for\n   // abstract classes.\n-  if ((clz->accflags & Modifier::ABSTRACT))\n-    _Jv_PrepareMissingMethods (clz, clz);\n+  if ((klass->accflags & Modifier::ABSTRACT))\n+    _Jv_PrepareMissingMethods (klass, klass);\n \n-  clz->vtable_method_count = -1;\n-  _Jv_MakeVTable (clz);\n+  klass->vtable_method_count = -1;\n+  _Jv_MakeVTable (klass);\n \n   /* wooha! we're done. */\n-  clz->state = JV_STATE_PREPARED;\n-  clz->notifyAll ();\n+  klass->state = JV_STATE_PREPARED;\n+  klass->notifyAll ();\n }\n \n /** Do static initialization for fields with a constant initializer */\n@@ -642,18 +642,18 @@ _Jv_InitField (jobject obj, jclass klass, int index)\n   if (!_Jv_IsInterpretedClass (klass))\n     return;\n \n-  _Jv_InterpClass *clz = (_Jv_InterpClass*)klass;\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass*)klass->aux_info;\n \n-  _Jv_Field * field = (&clz->fields[0]) + index;\n+  _Jv_Field * field = (&klass->fields[0]) + index;\n \n-  if (index > clz->field_count)\n+  if (index > klass->field_count)\n     throw_internal_error (\"field out of range\");\n \n-  int init = clz->field_initializers[index];\n+  int init = iclass->field_initializers[index];\n   if (init == 0)\n     return;\n \n-  _Jv_Constants *pool = &clz->constants;\n+  _Jv_Constants *pool = &klass->constants;\n   int tag = pool->tags[init];\n \n   if (! field->isResolved ())\n@@ -673,12 +673,12 @@ _Jv_InitField (jobject obj, jclass klass, int index)\n     {\n     case JV_CONSTANT_String:\n       {\n-\t_Jv_MonitorEnter (clz);\n+\t_Jv_MonitorEnter (klass);\n \tjstring str;\n \tstr = _Jv_NewStringUtf8Const (pool->data[init].utf8);\n \tpool->data[init].string = str;\n \tpool->tags[init] = JV_CONSTANT_ResolvedString;\n-\t_Jv_MonitorExit (clz);\n+\t_Jv_MonitorExit (klass);\n       }\n       /* fall through */\n "}]}