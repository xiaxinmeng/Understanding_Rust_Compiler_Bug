{"sha": "ee908516796887afcaa1d9fabac80eae5a16c047", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MDg1MTY3OTY4ODdhZmNhYTFkOWZhYmFjODBlYWU1YTE2YzA0Nw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-08-26T21:25:41Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-08-26T21:25:41Z"}, "message": "Add validation and consolidation of fix-it hints\n\nThe first aspect of this patch is to add some checking of fix-it hints.\nThe idea is to put this checking within the rich_location machinery,\nrather than requiring every diagnostic to implement it for itself.\n\nThe fixits within a rich_location are \"atomic\": all must be valid for\nany to be applicable.\n\nWe reject any fixits involving locations above\nLINE_MAP_MAX_LOCATION_WITH_COLS.\n\nThere's no guarantee that it's sane to modify a macro, so we reject\nany fix-its that touch them.\n\nFor example, note the attempt to provide a fix-it for the definition\nof the macro FIELD:\n\nspellcheck-fields-2.c: In function \u2018test_macro\u2019:\nspellcheck-fields-2.c:26:15: error: \u2018union u\u2019 has no member named \u2018colour\u2019; did you mean \u2018color\u2019?\n #define FIELD colour\n               ^\n               color\nspellcheck-fields-2.c:27:15: note: in expansion of macro \u2018FIELD\u2019\n   return ptr->FIELD;\n               ^~~~~\n\nAfter this patch, the fixit is not displayed:\n\nspellcheck-fields-2.c: In function \u2018test_macro\u2019:\nspellcheck-fields-2.c:26:15: error: \u2018union u\u2019 has no member named \u2018colour\u2019; did you mean \u2018color\u2019?\n #define FIELD colour\n               ^\nspellcheck-fields-2.c:27:15: note: in expansion of macro \u2018FIELD\u2019\n   return ptr->FIELD;\n               ^~~~~\n\nWe might want some way for a diagnostic to opt-in to fix-its that\naffect macros, but for now it's simplest to reject them.\n\nThe other aspect of this patch is fix-it consolidation: in some cases\nneighboring fix-its can be merged.  For example, in a diagnostic to\nmodernize old-style struct initializers from:\n\n struct s example = {\n- foo: 1,\n+ .foo = 1,\n };\n\none approach would be to replace the \"foo\" with \".foo\" and the \":\"\nwith \" =\".  This would give two \"replace\" fix-its:\n\n  foo: 1,\n  --- FIXIT 1\n  .foo\n     - FIXIT 2\n     =\n\nThis patch allows them to be consolidated into a single \"replace\" fix-it:\n\n  foo: 1,\n  ----\n  .foo =\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c\n\t(selftest::test_fixit_consolidation): New function.\n\t(selftest::diagnostic_show_locus_c_tests): Call it.\n\t* gcc-rich-location.h (gcc_rich_location): Eliminate unused\n\tconstructor based on source_range.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/spellcheck-fields-2.c (test): Move\n\tdg-begin/end-multiline-output within function body.\n\t(test_macro): New function.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (rich_location): Eliminate unimplemented\n\tconstructor based on source_range.\n\t(rich_location::get_last_fixit_hint): New method.\n\t(rich_location::reject_impossible_fixit): New method.\n\t(rich_location): Add fields m_line_table and\n\tm_seen_impossible_fixit.\n\t(fixit_hint::maybe_append_replace): New pure virtual function.\n\t(fixit_insert::maybe_append_replace): New function.\n\t(fixit_replace::maybe_append_replace): New function.\n\t* line-map.c (rich_location::rich_location): Initialize\n\tm_line_table and m_seen_impossible_fixit.\n\t(rich_location::add_fixit_insert): Call\n\treject_impossible_fixit and bail out if true.\n\t(column_before_p): New function.\n\t(rich_location::add_fixit_replace): Call reject_impossible_fixit\n\tand bail out if true.  Attempt to consolidate with neighboring\n\tfixits.\n\t(rich_location::get_last_fixit_hint): New method.\n\t(rich_location::reject_impossible_fixit): New method.\n\t(fixit_insert::maybe_append_replace): New method.\n\t(fixit_replace::maybe_append_replace): New method.\n\nFrom-SVN: r239789", "tree": {"sha": "77fb77c9ded3f70308261ebece5812de940a0cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77fb77c9ded3f70308261ebece5812de940a0cbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee908516796887afcaa1d9fabac80eae5a16c047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee908516796887afcaa1d9fabac80eae5a16c047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee908516796887afcaa1d9fabac80eae5a16c047", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee908516796887afcaa1d9fabac80eae5a16c047/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d41e76cf758505ba1bc22ca88cf6d1f626298def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d41e76cf758505ba1bc22ca88cf6d1f626298def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d41e76cf758505ba1bc22ca88cf6d1f626298def"}], "stats": {"total": 376, "additions": 365, "deletions": 11}, "files": [{"sha": "cfa9c3de7cbea261ea792788eb089bc68355ae50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -1,3 +1,11 @@\n+2016-08-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c\n+\t(selftest::test_fixit_consolidation): New function.\n+\t(selftest::diagnostic_show_locus_c_tests): Call it.\n+\t* gcc-rich-location.h (gcc_rich_location): Eliminate unused\n+\tconstructor based on source_range.\n+\n 2016-08-26  David Malcolm  <dmalcolm@redhat.com>\n \n \t* diagnostic-color.c (color_dict): Add \"fixit-insert\" and"}, {"sha": "f3f661ee6926afc986c6903375a7b5fbfc8d3370", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -1628,6 +1628,160 @@ test_diagnostic_show_locus_one_liner (const line_table_case &case_)\n   test_one_liner_fixit_replace_equal_secondary_range ();\n }\n \n+/* Verify that fix-it hints are appropriately consolidated.\n+\n+   If any fix-it hints in a rich_location involve locations beyond\n+   LINE_MAP_MAX_LOCATION_WITH_COLS, then we can't reliably apply\n+   the fix-it as a whole, so there should be none.\n+\n+   Otherwise, verify that consecutive \"replace\" and \"remove\" fix-its\n+   are merged, and that other fix-its remain separate.   */\n+\n+static void\n+test_fixit_consolidation (const line_table_case &case_)\n+{\n+  line_table_test ltt (case_);\n+\n+  linemap_add (line_table, LC_ENTER, false, \"test.c\", 1);\n+\n+  const location_t c10 = linemap_position_for_column (line_table, 10);\n+  const location_t c15 = linemap_position_for_column (line_table, 15);\n+  const location_t c16 = linemap_position_for_column (line_table, 16);\n+  const location_t c17 = linemap_position_for_column (line_table, 17);\n+  const location_t c20 = linemap_position_for_column (line_table, 20);\n+  const location_t caret = c10;\n+\n+  /* Insert + insert. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_insert (c10, \"foo\");\n+    richloc.add_fixit_insert (c15, \"bar\");\n+\n+    if (c15 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      /* They should not have been merged.  */\n+      ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+  }\n+\n+  /* Insert + replace. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_insert (c10, \"foo\");\n+    richloc.add_fixit_replace (source_range::from_locations (c15, c17),\n+\t\t\t       \"bar\");\n+\n+    if (c17 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      /* They should not have been merged.  */\n+      ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+  }\n+\n+  /* Replace + non-consecutive insert. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_replace (source_range::from_locations (c10, c15),\n+\t\t\t       \"bar\");\n+    richloc.add_fixit_insert (c17, \"foo\");\n+\n+    if (c17 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      /* They should not have been merged.  */\n+      ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+  }\n+\n+  /* Replace + non-consecutive replace. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_replace (source_range::from_locations (c10, c15),\n+\t\t\t       \"foo\");\n+    richloc.add_fixit_replace (source_range::from_locations (c17, c20),\n+\t\t\t       \"bar\");\n+\n+    if (c20 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      /* They should not have been merged.  */\n+      ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+  }\n+\n+  /* Replace + consecutive replace. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_replace (source_range::from_locations (c10, c15),\n+\t\t\t       \"foo\");\n+    richloc.add_fixit_replace (source_range::from_locations (c16, c20),\n+\t\t\t       \"bar\");\n+\n+    if (c20 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      {\n+\t/* They should have been merged into a single \"replace\".  */\n+\tASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\tconst fixit_hint *hint = richloc.get_fixit_hint (0);\n+\tASSERT_EQ (fixit_hint::REPLACE, hint->get_kind ());\n+\tconst fixit_replace *replace = (const fixit_replace *)hint;\n+\tASSERT_STREQ (\"foobar\", replace->get_string ());\n+\tASSERT_EQ (c10, replace->get_range ().m_start);\n+\tASSERT_EQ (c20, replace->get_range ().m_finish);\n+      }\n+  }\n+\n+  /* Replace + consecutive removal. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_replace (source_range::from_locations (c10, c15),\n+\t\t\t       \"foo\");\n+    richloc.add_fixit_remove (source_range::from_locations (c16, c20));\n+\n+    if (c20 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      {\n+\t/* They should have been merged into a single replace, with the\n+\t   range extended to cover that of the removal.  */\n+\tASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\tconst fixit_hint *hint = richloc.get_fixit_hint (0);\n+\tASSERT_EQ (fixit_hint::REPLACE, hint->get_kind ());\n+\tconst fixit_replace *replace = (const fixit_replace *)hint;\n+\tASSERT_STREQ (\"foo\", replace->get_string ());\n+\tASSERT_EQ (c10, replace->get_range ().m_start);\n+\tASSERT_EQ (c20, replace->get_range ().m_finish);\n+      }\n+  }\n+\n+  /* Consecutive removals. */\n+  {\n+    rich_location richloc (line_table, caret);\n+    richloc.add_fixit_remove (source_range::from_locations (c10, c15));\n+    richloc.add_fixit_remove (source_range::from_locations (c16, c20));\n+\n+    if (c20 > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+      /* Bogus column info for 2nd fixit, so no fixits.  */\n+      ASSERT_EQ (0, richloc.get_num_fixit_hints ());\n+    else\n+      {\n+\t/* They should have been merged into a single \"replace-with-empty\".  */\n+\tASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\tconst fixit_hint *hint = richloc.get_fixit_hint (0);\n+\tASSERT_EQ (fixit_hint::REPLACE, hint->get_kind ());\n+\tconst fixit_replace *replace = (const fixit_replace *)hint;\n+\tASSERT_STREQ (\"\", replace->get_string ());\n+\tASSERT_EQ (c10, replace->get_range ().m_start);\n+\tASSERT_EQ (c20, replace->get_range ().m_finish);\n+      }\n+  }\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n@@ -1642,6 +1796,7 @@ diagnostic_show_locus_c_tests ()\n   test_diagnostic_show_locus_unknown_location ();\n \n   for_each_line_table_case (test_diagnostic_show_locus_one_liner);\n+  for_each_line_table_case (test_fixit_consolidation);\n }\n \n } // namespace selftest"}, {"sha": "cc5987f37eb2d7c7d9ab8d623471b9e5c2e2540b", "filename": "gcc/gcc-rich-location.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -31,11 +31,6 @@ class gcc_rich_location : public rich_location\n   gcc_rich_location (source_location loc) :\n     rich_location (line_table, loc) {}\n \n-  /* Constructing from a source_range.  */\n-  gcc_rich_location (source_range src_range) :\n-    rich_location (src_range) {}\n-\n-\n   /* Methods for adding ranges via gcc entities.  */\n   void\n   add_expr (tree expr);"}, {"sha": "952380f43c26973c96ef5efa5ea49c09c742e513", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -1,3 +1,9 @@\n+2016-08-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/spellcheck-fields-2.c (test): Move\n+\tdg-begin/end-multiline-output within function body.\n+\t(test_macro): New function.\n+\n 2016-08-26  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/diagnostic-test-show-locus-color.c"}, {"sha": "7c542145b07b238a948e3a42cc09e50e725b10c2", "filename": "gcc/testsuite/gcc.dg/spellcheck-fields-2.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-fields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-fields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-fields-2.c?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -9,11 +9,32 @@ union u\n int test (union u *ptr)\n {\n   return ptr->colour; /* { dg-error \"did you mean .color.?\" } */\n-}\n \n /* Verify that we get an underline and a fixit hint.  */\n /* { dg-begin-multiline-output \"\" }\n    return ptr->colour;\n                ^~~~~~\n                color\n    { dg-end-multiline-output \"\" } */\n+}\n+\n+\n+/* Verify that we don't offer a fixit hint in the presence of\n+   a macro.  */\n+int test_macro (union u *ptr)\n+{\n+#define FIELD colour /* { dg-error \"did you mean .color.?\" } */\n+  return ptr->FIELD;\n+\n+/* { dg-begin-multiline-output \"\" }\n+ #define FIELD colour\n+               ^\n+   { dg-end-multiline-output \"\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   return ptr->FIELD;\n+               ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+#undef FIELD\n+}"}, {"sha": "56971ad8e0cda00e6482dd26de96ae88ccd5b343", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -1,3 +1,27 @@\n+2016-08-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (rich_location): Eliminate unimplemented\n+\tconstructor based on source_range.\n+\t(rich_location::get_last_fixit_hint): New method.\n+\t(rich_location::reject_impossible_fixit): New method.\n+\t(rich_location): Add fields m_line_table and\n+\tm_seen_impossible_fixit.\n+\t(fixit_hint::maybe_append_replace): New pure virtual function.\n+\t(fixit_insert::maybe_append_replace): New function.\n+\t(fixit_replace::maybe_append_replace): New function.\n+\t* line-map.c (rich_location::rich_location): Initialize\n+\tm_line_table and m_seen_impossible_fixit.\n+\t(rich_location::add_fixit_insert): Call\n+\treject_impossible_fixit and bail out if true.\n+\t(column_before_p): New function.\n+\t(rich_location::add_fixit_replace): Call reject_impossible_fixit\n+\tand bail out if true.  Attempt to consolidate with neighboring\n+\tfixits.\n+\t(rich_location::get_last_fixit_hint): New method.\n+\t(rich_location::reject_impossible_fixit): New method.\n+\t(fixit_insert::maybe_append_replace): New method.\n+\t(fixit_replace::maybe_append_replace): New method.\n+\n 2016-08-23  David Malcolm  <dmalcolm@redhat.com>\n \n \t* include/line-map.h (source_range::from_locations): New method."}, {"sha": "0fc4848bf5b0ed2e89785af3100f1273ac9b3a0e", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -1367,9 +1367,6 @@ class rich_location\n   /* Constructing from a location.  */\n   rich_location (line_maps *set, source_location loc);\n \n-  /* Constructing from a source_range.  */\n-  rich_location (source_range src_range);\n-\n   /* Destructor.  */\n   ~rich_location ();\n \n@@ -1411,12 +1408,17 @@ class rich_location\n \n   unsigned int get_num_fixit_hints () const { return m_num_fixit_hints; }\n   fixit_hint *get_fixit_hint (int idx) const { return m_fixit_hints[idx]; }\n+  fixit_hint *get_last_fixit_hint () const;\n+\n+private:\n+  bool reject_impossible_fixit (source_location where);\n \n public:\n   static const int MAX_RANGES = 3;\n   static const int MAX_FIXIT_HINTS = 2;\n \n protected:\n+  line_maps *m_line_table;\n   unsigned int m_num_ranges;\n   location_range m_ranges[MAX_RANGES];\n \n@@ -1427,6 +1429,7 @@ class rich_location\n \n   unsigned int m_num_fixit_hints;\n   fixit_hint *m_fixit_hints[MAX_FIXIT_HINTS];\n+  bool m_seen_impossible_fixit;\n };\n \n class fixit_hint\n@@ -1440,6 +1443,10 @@ class fixit_hint\n   virtual bool affects_line_p (const char *file, int line) = 0;\n   virtual source_location get_start_loc () const = 0;\n   virtual bool maybe_get_end_loc (source_location *out) const = 0;\n+  /* Vfunc for consolidating successor fixits.  */\n+  virtual bool maybe_append_replace (line_maps *set,\n+\t\t\t\t     source_range src_range,\n+\t\t\t\t     const char *new_content) = 0;\n };\n \n class fixit_insert : public fixit_hint\n@@ -1452,6 +1459,9 @@ class fixit_insert : public fixit_hint\n   bool affects_line_p (const char *file, int line);\n   source_location get_start_loc () const { return m_where; }\n   bool maybe_get_end_loc (source_location *) const { return false; }\n+  bool maybe_append_replace (line_maps *set,\n+\t\t\t     source_range src_range,\n+\t\t\t     const char *new_content);\n \n   source_location get_location () const { return m_where; }\n   const char *get_string () const { return m_bytes; }\n@@ -1478,6 +1488,9 @@ class fixit_replace : public fixit_hint\n     *out = m_src_range.m_finish;\n     return true;\n   }\n+  bool maybe_append_replace (line_maps *set,\n+\t\t\t     source_range src_range,\n+\t\t\t     const char *new_content);\n \n   source_range get_range () const { return m_src_range; }\n   const char *get_string () const { return m_bytes; }"}, {"sha": "8fe48bdbf63a63ff57faec5da298c828ebb1761f", "filename": "libcpp/line-map.c", "status": "modified", "additions": 134, "deletions": 2, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee908516796887afcaa1d9fabac80eae5a16c047/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee908516796887afcaa1d9fabac80eae5a16c047/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=ee908516796887afcaa1d9fabac80eae5a16c047", "patch": "@@ -1959,11 +1959,13 @@ source_range::intersects_line_p (const char *file, int line) const\n \n /* Construct a rich_location with location LOC as its initial range.  */\n \n-rich_location::rich_location (line_maps */*set*/, source_location loc) :\n+rich_location::rich_location (line_maps *set, source_location loc) :\n+  m_line_table (set),\n   m_num_ranges (0),\n   m_column_override (0),\n   m_have_expanded_location (false),\n-  m_num_fixit_hints (0)\n+  m_num_fixit_hints (0),\n+  m_seen_impossible_fixit (false)\n {\n   add_range (loc, true);\n }\n@@ -2075,6 +2077,9 @@ void\n rich_location::add_fixit_insert (source_location where,\n \t\t\t\t const char *new_content)\n {\n+  if (reject_impossible_fixit (where))\n+    return;\n+\n   linemap_assert (m_num_fixit_hints < MAX_FIXIT_HINTS);\n   m_fixit_hints[m_num_fixit_hints++]\n     = new fixit_insert (where, new_content);\n@@ -2089,6 +2094,44 @@ rich_location::add_fixit_remove (source_range src_range)\n   add_fixit_replace (src_range, \"\");\n }\n \n+/* Return true iff A is in the column directly before B, on the\n+   same line of the same source file.  */\n+\n+static bool\n+column_before_p (line_maps *set, source_location a, source_location b)\n+{\n+  if (IS_ADHOC_LOC (a))\n+    a = get_location_from_adhoc_loc (set, a);\n+  if (IS_ADHOC_LOC (b))\n+    b = get_location_from_adhoc_loc (set, b);\n+\n+  /* They must both be in ordinary maps.  */\n+  const struct line_map *linemap_a = linemap_lookup (set, a);\n+  if (linemap_macro_expansion_map_p (linemap_a))\n+    return false;\n+  const struct line_map *linemap_b = linemap_lookup (set, b);\n+  if (linemap_macro_expansion_map_p (linemap_b))\n+    return false;\n+\n+  /* To be on the same line, they must be in the same ordinary map.  */\n+  if (linemap_a != linemap_b)\n+    return false;\n+\n+  linenum_type line_a\n+    = SOURCE_LINE (linemap_check_ordinary (linemap_a), a);\n+  linenum_type line_b\n+    = SOURCE_LINE (linemap_check_ordinary (linemap_b), b);\n+  if (line_a != line_b)\n+    return false;\n+\n+  linenum_type column_a\n+    = SOURCE_COLUMN (linemap_check_ordinary (linemap_a), a);\n+  linenum_type column_b\n+    = SOURCE_COLUMN (linemap_check_ordinary (linemap_b), b);\n+\n+  return column_b == column_a + 1;\n+}\n+\n /* Add a fixit-hint, suggesting replacement of the content at\n    SRC_RANGE with NEW_CONTENT.  */\n \n@@ -2097,10 +2140,67 @@ rich_location::add_fixit_replace (source_range src_range,\n \t\t\t\t  const char *new_content)\n {\n   linemap_assert (m_num_fixit_hints < MAX_FIXIT_HINTS);\n+\n+  if (reject_impossible_fixit (src_range.m_start))\n+    return;\n+  if (reject_impossible_fixit (src_range.m_finish))\n+    return;\n+\n+  /* Consolidate neighboring fixits.  */\n+  fixit_hint *prev = get_last_fixit_hint ();\n+  if (m_num_fixit_hints > 0)\n+    {\n+      if (prev->maybe_append_replace (m_line_table, src_range, new_content))\n+\treturn;\n+    }\n+\n   m_fixit_hints[m_num_fixit_hints++]\n     = new fixit_replace (src_range, new_content);\n }\n \n+/* Get the last fix-it hint within this rich_location, or NULL if none.  */\n+\n+fixit_hint *\n+rich_location::get_last_fixit_hint () const\n+{\n+  if (m_num_fixit_hints > 0)\n+    return m_fixit_hints[m_num_fixit_hints - 1];\n+  else\n+    return NULL;\n+}\n+\n+/* If WHERE is an \"awkward\" location, then mark this rich_location as not\n+   supporting fixits, purging any thay were already added, and return true.\n+\n+   Otherwise (the common case), return false.  */\n+\n+bool\n+rich_location::reject_impossible_fixit (source_location where)\n+{\n+  /* Fix-its within a rich_location should either all be suggested, or\n+     none of them should be suggested.\n+     Once we've rejected a fixit, we reject any more, even those\n+     with reasonable locations.  */\n+  if (m_seen_impossible_fixit)\n+    return true;\n+\n+  if (where <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    /* WHERE is a reasonable location for a fix-it; don't reject it.  */\n+    return false;\n+\n+  /* Otherwise we have an attempt to add a fix-it with an \"awkward\"\n+     location: either one that we can't obtain column information\n+     for (within an ordinary map), or one within a macro expansion.  */\n+  m_seen_impossible_fixit = true;\n+\n+  /* Purge the rich_location of any fix-its that were already added. */\n+  for (unsigned int i = 0; i < m_num_fixit_hints; i++)\n+    delete m_fixit_hints[i];\n+  m_num_fixit_hints = 0;\n+\n+  return true;\n+}\n+\n /* class fixit_insert.  */\n \n fixit_insert::fixit_insert (source_location where,\n@@ -2129,6 +2229,15 @@ fixit_insert::affects_line_p (const char *file, int line)\n   return false;\n }\n \n+/* Implementation of maybe_append_replace for fixit_insert.  Reject\n+   the attempt to consolidate fix-its.  */\n+\n+bool\n+fixit_insert::maybe_append_replace (line_maps *, source_range, const char *)\n+{\n+  return false;\n+}\n+\n /* class fixit_replace.  */\n \n fixit_replace::fixit_replace (source_range src_range,\n@@ -2151,3 +2260,26 @@ fixit_replace::affects_line_p (const char *file, int line)\n {\n   return m_src_range.intersects_line_p (file, line);\n }\n+\n+/* Implementation of maybe_append_replace for fixit_replace.  If\n+   possible, merge the new replacement into this one and return true.\n+   Otherwise return false.  */\n+\n+bool\n+fixit_replace::maybe_append_replace (line_maps *set,\n+\t\t\t\t     source_range src_range,\n+\t\t\t\t     const char *new_content)\n+{\n+  /* Does SRC_RANGE start immediately after this one finishes?  */\n+  if (!column_before_p (set, m_src_range.m_finish, src_range.m_start))\n+    return false;\n+\n+  /* We have neighboring replacements; merge them.  */\n+  m_src_range.m_finish = src_range.m_finish;\n+  size_t extra_len = strlen (new_content);\n+  m_bytes = (char *)xrealloc (m_bytes, m_len + extra_len + 1);\n+  memcpy (m_bytes + m_len, new_content, extra_len);\n+  m_len += extra_len;\n+  m_bytes[m_len] = '\\0';\n+  return true;\n+}"}]}