{"sha": "23f6f34fca525e2a1ad98377fb08c7a80977bce1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNmNmYzNGZjYTUyNWUyYTFhZDk4Mzc3ZmIwOGM3YTgwOTc3YmNlMQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-12-24T03:10:48Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-12-24T03:10:48Z"}, "message": "(Several places): Declare values from INTVAL(x) as HOST_WIDE_INT.\n\n(uint32_operand): New function.\n(output_block_move): Change unroll threshold from 64 to 32.\n(compute_movstrsi_length): Corresponding change.\n(print_operand): Don't call debug_rtx, just abort.\n(initialize_pic): Delete.\n(finalize_pic): Use PIC_OFFSET_TABLE_REGNUM rather than 19.\n\nFrom-SVN: r6292", "tree": {"sha": "41826817a2b53194d56fee32e0487cf0e641c2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41826817a2b53194d56fee32e0487cf0e641c2bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23f6f34fca525e2a1ad98377fb08c7a80977bce1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f6f34fca525e2a1ad98377fb08c7a80977bce1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23f6f34fca525e2a1ad98377fb08c7a80977bce1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23f6f34fca525e2a1ad98377fb08c7a80977bce1/comments", "author": null, "committer": null, "parents": [{"sha": "2d19a71c10fd27e6bd565150104a81541b039945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d19a71c10fd27e6bd565150104a81541b039945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d19a71c10fd27e6bd565150104a81541b039945"}], "stats": {"total": 319, "additions": 157, "deletions": 162}, "files": [{"sha": "6003dec8d6907dfcedb7b0e3dc7fbfc90e431d11", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 157, "deletions": 162, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23f6f34fca525e2a1ad98377fb08c7a80977bce1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23f6f34fca525e2a1ad98377fb08c7a80977bce1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=23f6f34fca525e2a1ad98377fb08c7a80977bce1", "patch": "@@ -65,7 +65,7 @@ reg_or_0_operand (op, mode)\n /* Return non-zero if OP is suitable for use in a call to a named\n    function.\n \n-   (???) For 2.5 try to eliminate either call_operand_address or \n+   (???) For 2.5 try to eliminate either call_operand_address or\n    function_label_operand, they perform very similar functions.  */\n int\n call_operand_address (op, mode)\n@@ -75,15 +75,15 @@ call_operand_address (op, mode)\n   return (CONSTANT_P (op) && ! TARGET_LONG_CALLS);\n }\n \n-/* Return 1 if X contains a symbolic expression.  We know these \n-   expressions will have one of a few well defined forms, so \n+/* Return 1 if X contains a symbolic expression.  We know these\n+   expressions will have one of a few well defined forms, so\n    we need only check those forms.  */\n int\n symbolic_expression_p (x)\n      register rtx x;\n {\n \n-  /* Strip off any HIGH. */ \n+  /* Strip off any HIGH. */\n   if (GET_CODE (x) == HIGH)\n     x = XEXP (x, 0);\n \n@@ -144,7 +144,7 @@ reg_or_nonsymb_mem_operand (op, mode)\n   return 0;\n }\n \n-/* Return 1 if the operand is either a register, zero,  or a memory operand \n+/* Return 1 if the operand is either a register, zero, or a memory operand\n    that is not symbolic.  */\n \n int\n@@ -164,11 +164,11 @@ reg_or_0_or_nonsymb_mem_operand (op, mode)\n   return 0;\n }\n \n-/* Accept any constant that can be moved in one instructions into a \n+/* Accept any constant that can be moved in one instructions into a\n    general register.  */\n-int \n+int\n cint_ok_for_move (intval)\n-     int intval;\n+     HOST_WIDE_INT intval;\n {\n   /* OK if ldo, ldil, or zdepi, can be used.  */\n   return (VAL_14_BITS_P (intval) || (intval & 0x7ff) == 0\n@@ -286,7 +286,7 @@ arith11_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n }\n \n-/* A constant integer suitable for use in a PRE_MODIFY memory \n+/* A constant integer suitable for use in a PRE_MODIFY memory\n    reference.  */\n int\n pre_cint_operand (op, mode)\n@@ -297,7 +297,7 @@ pre_cint_operand (op, mode)\n \t  && INTVAL (op) >= -0x2000 && INTVAL (op) < 0x10);\n }\n \n-/* A constant integer suitable for use in a POST_MODIFY memory \n+/* A constant integer suitable for use in a POST_MODIFY memory\n    reference.  */\n int\n post_cint_operand (op, mode)\n@@ -340,13 +340,28 @@ uint5_operand (op, mode)\n   return (GET_CODE (op) == CONST_INT && INT_U5_BITS (op));\n }\n \n-  \n int\n int11_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-    return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n+  return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n+}\n+\n+int\n+uint32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  /* All allowed constants will fit a CONST_INT.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) >= 0 && INTVAL (op) < 0x100000000L));\n+#else\n+  return (GET_CODE (op) == CONST_INT\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && CONST_DOUBLE_HIGH (op) == 0));\n+#endif\n }\n \n int\n@@ -360,7 +375,7 @@ arith5_operand (op, mode)\n /* True iff zdepi can be used to generate this CONST_INT.  */\n int\n zdepi_cint_p (x)\n-     unsigned x;\n+     unsigned HOST_WIDE_INT x;\n {\n   unsigned lsb_mask, t;\n \n@@ -372,10 +387,14 @@ zdepi_cint_p (x)\n   return ((t & (t - 1)) == 0);\n }\n \n-/* True iff depi or extru can be used to compute (reg & mask).  */\n+/* True iff depi or extru can be used to compute (reg & mask).\n+   Accept bit pattern like these:\n+   0....01....1\n+   1....10....0\n+   1..10..01..1  */\n int\n and_mask_p (mask)\n-     unsigned mask;\n+     unsigned HOST_WIDE_INT mask;\n {\n   mask = ~mask;\n   mask += mask & -mask;\n@@ -395,7 +414,7 @@ and_operand (op, mode)\n /* True iff depi can be used to compute (reg | MASK).  */\n int\n ior_mask_p (mask)\n-     unsigned mask;\n+     unsigned HOST_WIDE_INT mask;\n {\n   mask += mask & -mask;\n   return (mask & (mask - 1)) == 0;\n@@ -512,14 +531,6 @@ legitimize_pic_address (orig, mode, reg)\n   return pic_ref;\n }\n \n-/* Set up PIC-specific rtl.  This should not cause any insns\n-   to be emitted.  */\n-\n-void\n-initialize_pic ()\n-{\n-}\n-\n /* Emit special PIC prologues and epilogues.  */\n \n void\n@@ -529,14 +540,13 @@ finalize_pic ()\n     {\n       emit_insn_after (gen_rtx (SET, VOIDmode,\n \t\t\t\thppa_save_pic_table_rtx,\n-\t\t\t\tgen_rtx (REG, Pmode, 19)),\n+\t\t\t\tgen_rtx (REG, Pmode, PIC_OFFSET_TABLE_REGNUM)),\n \t\t       get_insns ());\n       /* Need to emit this whether or not we obey regdecls,\n \t since setjmp/longjmp can cause life info to screw up.  */\n       hppa_save_pic_table_rtx = 0;\n     }\n   emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n-\n }\n \n /* Try machine-dependent ways of modifying an illegitimate address\n@@ -550,7 +560,7 @@ finalize_pic ()\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output. \n+   opportunities to optimize the output.\n \n    For the PA, transform:\n \n@@ -565,17 +575,17 @@ finalize_pic ()\n \tZ = X + Y\n \tmemory (Z + (<large int> - Y));\n \n-   This is for CSE to find several similar references, and only use one Z. \n+   This is for CSE to find several similar references, and only use one Z.\n \n    X can either be a SYMBOL_REF or REG, but because combine can not\n    perform a 4->2 combination we do nothing for SYMBOL_REF + D where\n    D will not fit in 14 bits.\n \n    MODE_FLOAT references allow displacements which fit in 5 bits, so use\n-   0x1f as the mask.  \n+   0x1f as the mask.\n \n    MODE_INT references allow displacements which fit in 14 bits, so use\n-   0x3fff as the mask. \n+   0x3fff as the mask.\n \n    This relies on the fact that most mode MODE_FLOAT references will use FP\n    registers and most mode MODE_INT references will use integer registers.\n@@ -595,7 +605,6 @@ hppa_legitimize_address (x, oldx, mode)\n      rtx x, oldx;\n      enum machine_mode mode;\n {\n-  \n   rtx orig = x;\n \n   /* Strip off CONST. */\n@@ -612,7 +621,7 @@ hppa_legitimize_address (x, oldx, mode)\n       int offset = INTVAL (XEXP (x, 1));\n       int mask = GET_MODE_CLASS (mode) == MODE_FLOAT ? 0x1f : 0x3fff;\n \n-      /* Choose which way to round the offset.  Round up if we \n+      /* Choose which way to round the offset.  Round up if we\n \t are >= halfway to the next boundary.  */\n       if ((offset & mask) >= ((mask + 1) / 2))\n \tnewoffset = (offset & ~ mask) + mask + 1;\n@@ -656,12 +665,12 @@ hppa_legitimize_address (x, oldx, mode)\n     }\n \n   /* Try to arrange things so that indexing modes can be used, but\n-     only do so if indexing is safe.  \n+     only do so if indexing is safe.\n \n      Indexing is safe when the second operand for the outer PLUS\n-     is a REG, SUBREG, SYMBOL_REF or the like.  \n+     is a REG, SUBREG, SYMBOL_REF or the like.\n \n-     For 2.5, indexing is also safe for (plus (symbol_ref) (const_int)) \n+     For 2.5, indexing is also safe for (plus (symbol_ref) (const_int))\n      if the integer is > 0.  */\n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n@@ -682,7 +691,7 @@ hppa_legitimize_address (x, oldx, mode)\n \t\t\t\t reg1));\n     }\n \n-  /* Uh-oh.  We might have an address for x[n-100000].  This needs \n+  /* Uh-oh.  We might have an address for x[n-100000].  This needs\n      special handling.  */\n \n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n@@ -715,7 +724,7 @@ hppa_legitimize_address (x, oldx, mode)\n \t}\n     }\n \n-  if (flag_pic) \n+  if (flag_pic)\n     return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n \n   return orig;\n@@ -765,7 +774,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n       && ! memory_address_p (DFmode, XEXP (operand1, 0))\n       && scratch_reg)\n     {\n-      emit_move_insn (scratch_reg, XEXP (operand1 , 0));\n+      emit_move_insn (scratch_reg, XEXP (operand1, 0));\n       emit_insn (gen_rtx (SET, VOIDmode, operand0, gen_rtx (MEM, mode,\n \t\t\t\t\t\t\t    scratch_reg)));\n       return 1;\n@@ -777,18 +786,18 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t   && ! memory_address_p (DFmode, XEXP (operand0, 0))\n \t   && scratch_reg)\n     {\n-      emit_move_insn (scratch_reg, XEXP (operand0 , 0));\n-      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (MEM, mode,  scratch_reg),\n+      emit_move_insn (scratch_reg, XEXP (operand0, 0));\n+      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (MEM, mode, scratch_reg),\n \t\t\t  operand1));\n       return 1;\n     }\n   /* Handle secondary reloads for loads of FP registers from constant\n      expressions by forcing the constant into memory.\n \n-     use scratch_reg to hold the address of the memory location. \n+     use scratch_reg to hold the address of the memory location.\n \n-     ??? The proper fix is to change PREFERRED_RELOAD_CLASS to return \n-     NO_REGS when presented with a const_int and an register class \n+     ??? The proper fix is to change PREFERRED_RELOAD_CLASS to return\n+     NO_REGS when presented with a const_int and an register class\n      containing only FP registers.  Doing so unfortunately creates\n      more problems than it solves.   Fix this for 2.5.  */\n   else if (fp_reg_operand (operand0, mode)\n@@ -874,18 +883,18 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\ttemp = operand0;\n \t      else\n \t\ttemp = gen_reg_rtx (Pmode);\n-\t\t\n+\n \t      operands[1] = legitimize_pic_address (operand1, mode, temp);\n               emit_insn (gen_rtx (SET, VOIDmode, operand0, operands[1]));\n \t    }\n \t  /* On the HPPA, references to data space are supposed to */\n \t  /* use dp, register 27, but showing it in the RTL inhibits various\n \t     cse and loop optimizations.  */\n-\t  else \n+\t  else\n \t    {\n \t      rtx temp, set;\n \n-\t      if (reload_in_progress || reload_completed) \n+\t      if (reload_in_progress || reload_completed)\n \t\ttemp = scratch_reg ? scratch_reg : operand0;\n \t      else\n \t\ttemp = gen_reg_rtx (mode);\n@@ -896,7 +905,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\tset = gen_rtx (SET, VOIDmode,\n \t\t\t       operand0,\n \t\t\t       gen_rtx (LO_SUM, mode, temp, operand1));\n-\t\t\t\t \n+\n \t      emit_insn (gen_rtx (SET, VOIDmode,\n \t\t\t\t  temp,\n \t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n@@ -937,7 +946,7 @@ read_only_operand (operand)\n     return SYMBOL_REF_FLAG (operand) || CONSTANT_POOL_ADDRESS_P (operand);\n   return 1;\n }\n-     \n+\n \f\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.   */\n@@ -965,7 +974,7 @@ singlemove_string (operands)\n       /* See if we can handle this constant in a single instruction.  */\n       if (cint_ok_for_move (INTVAL (operands[1])))\n \t{\n-\t   int intval = INTVAL (operands[1]);\n+\t   HOST_WIDE_INT intval = INTVAL (operands[1]);\n \n \t   if (intval == 0)\n \t     return \"copy 0,%0\";\n@@ -1008,7 +1017,7 @@ singlemove_string (operands)\n    instructions.  Store the immediate value to insert in OP[0].  */\n void\n compute_zdepi_operands (imm, op)\n-     unsigned imm;\n+     unsigned HOST_WIDE_INT imm;\n      unsigned *op;\n {\n   int lsb, len;\n@@ -1289,10 +1298,10 @@ output_fp_move_double (operands)\n {\n   if (FP_REG_P (operands[0]))\n     {\n-      if (FP_REG_P (operands[1]) \n+      if (FP_REG_P (operands[1])\n \t  || operands[1] == CONST0_RTX (GET_MODE (operands[0])))\n \toutput_asm_insn (\"fcpy,dbl %r1,%0\", operands);\n-      else \n+      else\n \toutput_asm_insn (\"fldds%F1 %1,%0\", operands);\n     }\n   else if (FP_REG_P (operands[1]))\n@@ -1308,7 +1317,7 @@ output_fp_move_double (operands)\n \t  xoperands[0] = operands[0];\n \t  output_asm_insn (\"copy %%r0,%0\\n\\tcopy %%r0,%1\", xoperands);\n \t}\n-      /* This is a pain.  You have to be prepared to deal with an \n+      /* This is a pain.  You have to be prepared to deal with an\n \t arbritary address here including pre/post increment/decrement.\n \n \t so avoid this in the MD.  */\n@@ -1384,7 +1393,7 @@ output_block_move (operands, size_is_constant)\n       if (align >= 4)\n \t{\n \t  /* Don't unroll too large blocks.  */\n-\t  if (n_bytes > 64)\n+\t  if (n_bytes > 32)\n \t    goto copy_with_loop;\n \n \t  /* Read and store using two registers, and hide latency\n@@ -1459,7 +1468,7 @@ output_block_move (operands, size_is_constant)\n \n   if (align != 4)\n     abort();\n-     \n+\n  copy_with_loop:\n \n   if (size_is_constant)\n@@ -1555,7 +1564,7 @@ compute_movstrsi_length (insn)\n       if (align >= 4)\n \t{\n \t  /* Don't unroll too large blocks.  */\n-\t  if (n_bytes > 64)\n+\t  if (n_bytes > 32)\n \t    goto copy_with_loop;\n \n \t  /* first load */\n@@ -1604,7 +1613,7 @@ compute_movstrsi_length (insn)\n \n   if (align != 4)\n     abort();\n-     \n+\n  copy_with_loop:\n \n   /* setup for constant and non-constant case.  */\n@@ -1684,7 +1693,7 @@ output_ior (operands)\n {\n   unsigned mask = INTVAL (operands[2]);\n   int bs0, bs1, p, len;\n- \n+\n   if (INTVAL (operands[2]) == 0)\n     return \"copy %1,%0\";\n \n@@ -1826,7 +1835,7 @@ output_ascii (file, p, size)\n        .\n        .\n        SP + p (SP')\tpoints to next available address.\n-       \n+\n */\n \n /* Emit RTL to store REG at the memory location specified by BASE+DISP.\n@@ -1840,19 +1849,19 @@ store_reg (reg, disp, base)\n {\n   if (VAL_14_BITS_P (disp))\n     {\n-      emit_move_insn (gen_rtx (MEM, SImode, \n-\t\t\t       gen_rtx (PLUS, SImode, \n+      emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t       gen_rtx (PLUS, SImode,\n \t\t\t\t        gen_rtx (REG, SImode, base),\n \t\t\t\t        GEN_INT (disp))),\n \t\t      gen_rtx (REG, SImode, reg));\n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1), \n-\t\t\t\t     gen_rtx (REG, SImode, base), \n+      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1),\n+\t\t\t\t     gen_rtx (REG, SImode, base),\n \t\t\t\t     GEN_INT (disp)));\n       emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (LO_SUM, SImode, \n+\t\t\t       gen_rtx (LO_SUM, SImode,\n \t\t\t\t\tgen_rtx (REG, SImode, 1),\n \t\t\t\t\tGEN_INT (disp))),\n \t\t      gen_rtx (REG, SImode, reg));\n@@ -1871,21 +1880,20 @@ load_reg (reg, disp, base)\n   if (VAL_14_BITS_P (disp))\n     {\n       emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (MEM, SImode, \n-\t\t\t       gen_rtx (PLUS, SImode, \n+\t\t      gen_rtx (MEM, SImode,\n+\t\t\t       gen_rtx (PLUS, SImode,\n \t\t\t\t        gen_rtx (REG, SImode, base),\n \t\t\t\t        GEN_INT (disp))));\n-\t\t      \n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1), \n+      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1),\n \t\t\t\t     gen_rtx (REG, SImode, base),\n \t\t\t\t     GEN_INT (disp)));\n       emit_move_insn (gen_rtx (REG, SImode, reg),\n \t\t      gen_rtx (MEM, SImode,\n-\t\t\t       gen_rtx (LO_SUM, SImode, \n-\t\t\t\t\tgen_rtx (REG, SImode, 1), \n+\t\t\t       gen_rtx (LO_SUM, SImode,\n+\t\t\t\t\tgen_rtx (REG, SImode, 1),\n \t\t\t\t\tGEN_INT (disp))));\n     }\n }\n@@ -1902,18 +1910,17 @@ set_reg_plus_d(reg, base, disp)\n   if (VAL_14_BITS_P (disp))\n     {\n       emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (PLUS, SImode, \n+\t\t      gen_rtx (PLUS, SImode,\n \t\t\t       gen_rtx (REG, SImode, base),\n \t\t\t       GEN_INT (disp)));\n-      \n     }\n   else\n     {\n-      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1), \n+      emit_insn (gen_add_high_const (gen_rtx (REG, SImode, 1),\n \t\t\t\t     gen_rtx (REG, SImode, base),\n \t\t\t\t     GEN_INT (disp)));\n       emit_move_insn (gen_rtx (REG, SImode, reg),\n-\t\t      gen_rtx (LO_SUM, SImode, \n+\t\t      gen_rtx (LO_SUM, SImode,\n \t\t\t\t\tgen_rtx (REG, SImode, 1),\n \t\t\t\t\tGEN_INT (disp)));\n     }\n@@ -1933,7 +1940,7 @@ compute_frame_size (size, fregs_live)\n   extern int current_function_outgoing_args_size;\n   int i, fsize;\n \n-  /* 8 is space for frame pointer + filler. If any frame is allocated \n+  /* 8 is space for frame pointer + filler. If any frame is allocated\n      we need to add this in because of STARTING_FRAME_OFFSET. */\n   fsize = size + (size || frame_pointer_needed ? 8 : 0);\n \n@@ -1971,7 +1978,7 @@ compute_frame_size (size, fregs_live)\n     fsize += 32;\n   return (fsize + 63) & ~63;\n }\n-     \n+\n rtx hp_profile_label_rtx;\n static char hp_profile_label_name[8];\n void\n@@ -2001,9 +2008,9 @@ output_function_prologue (file, size)\n      performed in the prologue.\n \n      The compiler is supposed to pass the highest register number\n-     saved, the assembler then has to adjust that number before \n+     saved, the assembler then has to adjust that number before\n      entering it into the unwind descriptor (to account for any\n-     caller saved registers with lower register numbers than the \n+     caller saved registers with lower register numbers than the\n      first callee saved register).  */\n   if (gr_saved)\n     fprintf (file, \",ENTRY_GR=%d\", gr_saved + 2);\n@@ -2041,11 +2048,11 @@ hppa_expand_prologue()\n   tmpreg = gen_rtx (REG, SImode, 1);\n   size_rtx = GEN_INT (actual_fsize);\n \n-  /* Save RP first.  The calling conventions manual states RP will \n+  /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp-20.  */\n   if (regs_ever_live[2] || profile_flag)\n-    store_reg (2, -20, STACK_POINTER_REGNUM);  \n-    \n+    store_reg (2, -20, STACK_POINTER_REGNUM);\n+\n   /* Allocate the local frame and set up the frame pointer if needed.  */\n   if (actual_fsize)\n     if (frame_pointer_needed)\n@@ -2077,8 +2084,8 @@ hppa_expand_prologue()\n \t   and allocating the stack frame at the same time.   If so, just\n \t   make a note of it and defer allocating the frame until saving\n \t   the callee registers.  */\n-\tif (VAL_14_BITS_P (-actual_fsize) \n-\t    && local_fsize == 0 \n+\tif (VAL_14_BITS_P (-actual_fsize)\n+\t    && local_fsize == 0\n \t    && ! profile_flag\n \t    && ! flag_pic)\n \t  merge_sp_adjust_with_store = 1;\n@@ -2092,14 +2099,14 @@ hppa_expand_prologue()\n      register, is saved at sp - 32 (in this function's frame)  when\n      generating PIC code.  */\n   if (flag_pic)\n-    store_reg (19, -32, STACK_POINTER_REGNUM);  \n+    store_reg (PIC_OFFSET_TABLE_REGNUM, -32, STACK_POINTER_REGNUM);\n \n   /* Profiling code.\n \n      Instead of taking one argument, the counter label, as most normal\n      mcounts do, _mcount appears to behave differently on the HPPA.  It\n-     takes the return address of the caller, the address of this routine,\t\n-     and the address of the label.  Also, it isn't magic, so \n+     takes the return address of the caller, the address of this routine,\n+     and the address of the label.  Also, it isn't magic, so\n      argument registre hsave to be preserved.  */\n   if (profile_flag)\n     {\n@@ -2152,7 +2159,7 @@ hppa_expand_prologue()\n \n     }\n \n-  /* Normal register save. \n+  /* Normal register save.\n \n      Do not save the frame pointer in the frame_pointer_needed case.  It\n      was done earlier.  */\n@@ -2162,7 +2169,7 @@ hppa_expand_prologue()\n \tif (regs_ever_live[i] && ! call_used_regs[i]\n \t    && i != FRAME_POINTER_REGNUM)\n \t  {\n-\t    store_reg (i, offset, FRAME_POINTER_REGNUM);  \n+\t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += 4;\n \t    gr_saved++;\n \t  }\n@@ -2175,7 +2182,7 @@ hppa_expand_prologue()\n       for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n       \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n-\t    /* If merge_sp_adjust_with_store is nonzero, then we can \n+\t    /* If merge_sp_adjust_with_store is nonzero, then we can\n \t       optimize the first GR save.  */\n \t    if (merge_sp_adjust_with_store)\n \t      {\n@@ -2198,7 +2205,7 @@ hppa_expand_prologue()\n \t\t\tSTACK_POINTER_REGNUM,\n \t\t\tactual_fsize);\n     }\n-      \n+\n   /* Align pointer properly (doubleword boundary).  */\n   offset = (offset + 7) & ~7;\n \n@@ -2219,7 +2226,7 @@ hppa_expand_prologue()\n \t  for (i = 43; i >= 40; i--)\n \t    if (regs_ever_live[i])\n \t      {\n-\t\temit_move_insn (gen_rtx (MEM, DFmode, \n+\t\temit_move_insn (gen_rtx (MEM, DFmode,\n \t\t\t\t\t gen_rtx (POST_INC, DFmode, tmpreg)),\n \t\t\t\tgen_rtx (REG, DFmode, i));\n \t\tfr_saved++;\n@@ -2230,7 +2237,7 @@ hppa_expand_prologue()\n \t  for (i = 78; i >= 60; i -= 2)\n \t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t      {\n-\t\temit_move_insn (gen_rtx (MEM, DFmode, \n+\t\temit_move_insn (gen_rtx (MEM, DFmode,\n \t\t\t\t\t gen_rtx (POST_INC, DFmode, tmpreg)),\n \t\t\t\tgen_rtx (REG, DFmode, i));\n \t\tfr_saved++;\n@@ -2254,7 +2261,7 @@ output_function_epilogue (file, size)\n \n      To make debuggers happy, emit a nop if the epilogue was completely\n      eliminated due to a volatile call as the last insn in the\n-     current function.  That way the return address (in %r2) will \n+     current function.  That way the return address (in %r2) will\n      always point to a valid instruction in the current function.  */\n \n   /* Get the last real insn.  */\n@@ -2265,18 +2272,18 @@ output_function_epilogue (file, size)\n   if (insn && GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n-  /* If insn is a CALL_INSN, then it must be a call to a volatile \n+  /* If insn is a CALL_INSN, then it must be a call to a volatile\n      function (otherwise there would be epilogue insns).  */\n   if (insn && GET_CODE (insn) == CALL_INSN)\n     fprintf (file, \"\\tnop\\n\");\n-  \n+\n   fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n }\n \n void\n hppa_expand_epilogue ()\n {\n-  rtx tmpreg; \n+  rtx tmpreg;\n   int offset,i;\n   int merge_sp_adjust_with_load  = 0;\n \n@@ -2343,16 +2350,15 @@ hppa_expand_epilogue ()\n \t  for (i = 43; i >= 40; i--)\n \t    if (regs_ever_live[i])\n \t      emit_move_insn (gen_rtx (REG, DFmode, i),\n-\t\t\t      gen_rtx (MEM, DFmode, \n+\t\t\t      gen_rtx (MEM, DFmode,\n \t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n-\t      \n \t}\n       else\n \t{\n \t  for (i = 78; i >= 60; i -= 2)\n \t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n \t      emit_move_insn (gen_rtx (REG, DFmode, i),\n-\t\t\t      gen_rtx (MEM, DFmode, \n+\t\t\t      gen_rtx (MEM, DFmode,\n \t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n \t}\n     }\n@@ -2389,7 +2395,7 @@ hppa_expand_epilogue ()\n     emit_insn (gen_pre_ldwm (stack_pointer_rtx,\n \t\t\t     stack_pointer_rtx,\n \t\t\t     GEN_INT (- actual_fsize),\n-\t\t\t     gen_rtx (REG, SImode, \n+\t\t\t     gen_rtx (REG, SImode,\n \t\t\t     merge_sp_adjust_with_load)));\n   else if (actual_fsize != 0)\n     set_reg_plus_d (STACK_POINTER_REGNUM,\n@@ -2421,7 +2427,7 @@ emit_bcond_fp (code, operand0)\n {\n   emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n \t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n-\t\t\t\t    gen_rtx (code, VOIDmode, \n+\t\t\t\t    gen_rtx (code, VOIDmode,\n \t\t\t\t\t     gen_rtx (REG, CCFPmode, 0),\n \t\t\t\t\t     const0_rtx),\n \t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, operand0),\n@@ -2554,10 +2560,10 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n }\n \n /* Return any length adjustment needed by INSN which already has its length\n-   computed as LENGTH.   Return zero if no adjustment is necessary. \n+   computed as LENGTH.   Return zero if no adjustment is necessary.\n \n    For the PA: function calls, millicode calls, and backwards short\n-   conditional branches with unfilled delay slots need an adjustment by +1 \n+   conditional branches with unfilled delay slots need an adjustment by +1\n    (to account for the NOP which will be inserted into the instruction stream).\n \n    Also compute the length of an inline block move here as it is too\n@@ -2607,12 +2613,12 @@ pa_adjust_insn_length (insn, length)\n \t  && ! forward_branch_p (insn))\n \treturn 4;\n       /* Adjust dbra insn with short backwards conditional branch with\n-\t unfilled delay slot -- only for case where counter is in a \n+\t unfilled delay slot -- only for case where counter is in a\n \t general register register. */\n       else if (GET_CODE (pat) == PARALLEL\n \t       && GET_CODE (XVECEXP (pat, 0, 1)) == SET\n \t       && GET_CODE (XEXP (XVECEXP (pat, 0, 1), 0)) == REG\n- \t       && ! FP_REG_P (XEXP (XVECEXP (pat, 0, 1), 0)) \n+ \t       && ! FP_REG_P (XEXP (XVECEXP (pat, 0, 1), 0))\n \t       && length == 4\n \t       && ! forward_branch_p (insn))\n \treturn 4;\n@@ -2642,7 +2648,7 @@ print_operand (file, x, code)\n       return;\n     case '*':\n       /* Output an nullification completer if there's nothing for the */\n-      /* delay slot or nullification is requested.  */ \n+      /* delay slot or nullification is requested.  */\n       if (dbr_sequence_length () == 0 ||\n \t  (final_sequence &&\n \t   INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))))\n@@ -2667,7 +2673,7 @@ print_operand (file, x, code)\n     case 'C':\t\t\t/* Plain (C)ondition */\n     case 'X':\n       switch (GET_CODE (x))\n-\t{\t\n+\t{\n \tcase EQ:\n \t  fprintf (file, \"=\");  break;\n \tcase NE:\n@@ -2689,8 +2695,6 @@ print_operand (file, x, code)\n \tcase LTU:\n \t  fprintf (file, \"<<\");  break;\n \tdefault:\n-\t  printf (\"Can't grok '%c' operator:\\n\", code);\n-\t  debug_rtx (x);\n \t  abort ();\n \t}\n       return;\n@@ -2718,8 +2722,6 @@ print_operand (file, x, code)\n \tcase LTU:\n \t  fprintf (file, \">>=\");  break;\n \tdefault:\n-\t  printf (\"Can't grok '%c' operator:\\n\", code);\n-\t  debug_rtx (x);\n \t  abort ();\n \t}\n       return;\n@@ -2741,8 +2743,6 @@ print_operand (file, x, code)\n \tcase LE:\n \t  fprintf (file, \"!<=\");  break;\n \tdefault:\n-\t  printf (\"Can't grok '%c' operator:\\n\", code);\n-\t  debug_rtx (x);\n \t  abort ();\n \t}\n       return;\n@@ -2770,10 +2770,8 @@ print_operand (file, x, code)\n \tcase LTU:\n \t  fprintf (file, \">>\");  break;\n \tdefault:\n-\t  printf (\"Can't grok '%c' operator:\\n\", code);\n-\t  debug_rtx (x);\n \t  abort ();\n-\t}\t  \n+\t}\n       return;\n     case 'B':\t\t\t/* Condition, (B)oth swapped and negate.  */\n       switch (GET_CODE (x))\n@@ -2799,10 +2797,8 @@ print_operand (file, x, code)\n \tcase LTU:\n \t  fprintf (file, \"<<=\");  break;\n \tdefault:\n-\t  printf (\"Can't grok '%c' operator:\\n\", code);\n-\t  debug_rtx (x);\n \t  abort ();\n-\t}\t  \n+\t}\n       return;\n     case 'k':\n       if (GET_CODE (x) == CONST_INT)\n@@ -2947,7 +2943,7 @@ output_global_address (file, x)\n       char *sep = \"\";\n       int offset = 0;\t\t/* assembler wants -$global$ at end */\n       rtx base;\n-\t  \n+\n       if (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF)\n \t{\n \t  base = XEXP (XEXP (x, 0), 0);\n@@ -3004,7 +3000,7 @@ import_milli (code)\n      enum millicodes code;\n {\n   char str[sizeof (import_string)];\n-  \n+\n   if (!imported[(int)code])\n     {\n       imported[(int)code] = 1;\n@@ -3014,7 +3010,7 @@ import_milli (code)\n     }\n }\n \n-/* The register constraints have put the operands and return value in \n+/* The register constraints have put the operands and return value in\n    the proper registers. */\n \n char *\n@@ -3048,7 +3044,7 @@ output_mul_insn (unsignedp, insn)\n static int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0,\n \t\t\t     1, 1};\n \n-/* We'll use an array to keep track of the magic millicodes and \n+/* We'll use an array to keep track of the magic millicodes and\n    whether or not we've used them already. [n][0] is signed, [n][1] is\n    unsigned. */\n \n@@ -3100,8 +3096,8 @@ output_div_insn (operands, unsignedp, insn)\n      rtx insn;\n {\n   int divisor;\n-  \n-  /* If the divisor is a constant, try to use one of the special \n+\n+  /* If the divisor is a constant, try to use one of the special\n      opcodes .*/\n   if (GET_CODE (operands[0]) == CONST_INT)\n     {\n@@ -3176,7 +3172,7 @@ output_arg_descriptor (insn)\n   rtx prev_insn;\n   int i, output_flag = 0;\n   int regno;\n-  \n+\n   for (i = 0; i < 4; i++)\n     arg_regs[i] = 0;\n \n@@ -3265,8 +3261,8 @@ secondary_reload_class (class, mode, in)\n   int regno = true_regnum (in);\n \n   if (((regno >= FIRST_PSEUDO_REGISTER || regno == -1)\n-\t  && GET_MODE_CLASS (mode) == MODE_INT\n-\t  && FP_REG_CLASS_P (class))\n+       && GET_MODE_CLASS (mode) == MODE_INT\n+       && FP_REG_CLASS_P (class))\n       || (class == SHIFT_REGS && (regno <= 0 || regno >= 32)))\n     return GENERAL_REGS;\n \n@@ -3331,17 +3327,17 @@ hppa_builtin_saveregs (arglist)\n \t\t       gen_rtx (MEM, BLKmode,\n \t\t\t\tplus_constant\n \t\t\t\t(current_function_internal_arg_pointer, -16)),\n-\t\t       4, 4 * UNITS_PER_WORD); \n+\t\t       4, 4 * UNITS_PER_WORD);\n   return copy_to_reg (expand_binop (Pmode, add_optab,\n \t\t\t\t    current_function_internal_arg_pointer,\n \t\t\t\t    offset, 0, 0, OPTAB_LIB_WIDEN));\n }\n \n-/* This routine handles all the normal conditional branch sequences we \n-   might need to generate.  It handles compare immediate vs compare \n-   register, nullification of delay slots, varying length branches, \n+/* This routine handles all the normal conditional branch sequences we\n+   might need to generate.  It handles compare immediate vs compare\n+   register, nullification of delay slots, varying length branches,\n    negated branches, and all combinations of the above.  It returns the\n-   output appropriate to emit the branch corresponding to all given \n+   output appropriate to emit the branch corresponding to all given\n    parameters.  */\n \n char *\n@@ -3360,7 +3356,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n \n   if (JUMP_LABEL (insn) == next_nonnote_insn (insn))\n     return \"\";\n-  \n+\n   /* If this is a long branch with its delay slot unfilled, set `nullify'\n      as it can nullify the delay slot and save a nop.  */\n   if (length == 8 && dbr_sequence_length () == 0)\n@@ -3371,7 +3367,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n   if (! nullify && length == 4 && dbr_sequence_length () == 0)\n     nullify = forward_branch_p (insn);\n \n-  /* A forward branch over a single nullified insn can be done with a \n+  /* A forward branch over a single nullified insn can be done with a\n      comclr instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n   if (length == 4\n@@ -3398,11 +3394,11 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  strcat (buf, \" %2,%1,0\");\n \telse if (nullify)\n \t  strcat (buf, \",n %2,%1,%0\");\n-\telse \n+\telse\n \t  strcat (buf, \" %2,%1,%0\");\n \tbreak;\n \n-     /* All long conditionals.  Note an short backward branch with an \n+     /* All long conditionals.  Note an short backward branch with an\n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n       case 8:\n@@ -3439,7 +3435,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n   return buf;\n }\n \n-/* This routine handles all the branch-on-bit conditional branch sequences we \n+/* This routine handles all the branch-on-bit conditional branch sequences we\n    might need to generate.  It handles nullification of delay slots,\n    varying length branches, negated branches and all combinations of the\n    above.  it returns the appropriate output template to emit the branch.  */\n@@ -3456,12 +3452,12 @@ output_bb (operands, nullify, length, negated, insn, which)\n \n   /* A conditional branch to the following instruction (eg the delay slot) is\n      asking for a disaster.  I do not think this can happen as this pattern\n-     is only used when optimizing; jump optimization should eliminate the \n+     is only used when optimizing; jump optimization should eliminate the\n      jump.  But be prepared just in case.  */\n-     \n+\n   if (JUMP_LABEL (insn) == next_nonnote_insn (insn))\n     return \"\";\n-  \n+\n   /* If this is a long branch with its delay slot unfilled, set `nullify'\n      as it can nullify the delay slot and save a nop.  */\n   if (length == 8 && dbr_sequence_length () == 0)\n@@ -3472,7 +3468,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n   if (! nullify && length == 4 && dbr_sequence_length () == 0)\n     nullify = forward_branch_p (insn);\n \n-  /* A forward branch over a single nullified insn can be done with a \n+  /* A forward branch over a single nullified insn can be done with a\n      extrs instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n \n@@ -3491,7 +3487,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n       case 4:\n \tif (useskip)\n \t  strcpy (buf, \"extrs,\");\n-\telse \n+\telse\n \t  strcpy (buf, \"bb,\");\n \tif ((which == 0 && negated)\n \t     || (which == 1 && ! negated))\n@@ -3510,7 +3506,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t  strcat (buf, \" %0,%1,%2\");\n \tbreak;\n \n-     /* All long conditionals.  Note an short backward branch with an \n+     /* All long conditionals.  Note an short backward branch with an\n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n       case 8:\n@@ -3545,7 +3541,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t      strcat (buf, \" %0,%1,1,0\\n\\tbl,n %2,0\");\n \t    else if (negated)\n \t      strcat (buf, \" %0,%1,1,0\\n\\tbl %3,0\");\n-\t    else \n+\t    else\n \t      strcat (buf, \" %0,%1,1,0\\n\\tbl %2,0\");\n \t  }\n \tbreak;\n@@ -3610,14 +3606,14 @@ output_dbra (operands, insn, which_alternative)\n \treturn \"addib,%C2 %1,%0,%3\";\n       else if (length == 8)\n \t{\n-\t  /* Handle weird backwards branch with a fulled delay slot \n+\t  /* Handle weird backwards branch with a fulled delay slot\n \t     which is nullified.  */\n \t  if (dbr_sequence_length () != 0\n \t      && ! forward_branch_p (insn)\n \t      && nullify)\n \t    return \"addib,%N2,n %1,%0,.+12\\n\\tbl %3,0\";\n-\t  \n-\t  /* Handle normal cases.  */  \n+\n+\t  /* Handle normal cases.  */\n \t  if (nullify)\n \t    return \"addi,%N2 %1,%0,%0\\n\\tbl,n %3,0\";\n \t  else\n@@ -3631,7 +3627,7 @@ output_dbra (operands, insn, which_alternative)\n     {\n       /* Move loop counter from FP register to MEM then into a GR,\n \t increment the GR, store the GR into MEM, and finally reload\n-\t the FP register from MEM from within the branch's delay slot.  */ \n+\t the FP register from MEM from within the branch's delay slot.  */\n       output_asm_insn (\"fstws %0,-16(0,%%r30)\\n\\tldw -16(0,%%r30),%4\",operands);\n       output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(0,%%r30)\", operands);\n       if (get_attr_length (insn) == 24)\n@@ -3706,14 +3702,14 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \treturn \"movb,%C2 %1,%0,%3\";\n       else if (length == 8)\n \t{\n-\t  /* Handle weird backwards branch with a fulled delay slot \n+\t  /* Handle weird backwards branch with a filled delay slot\n \t     which is nullified.  */\n \t  if (dbr_sequence_length () != 0\n \t      && ! forward_branch_p (insn)\n \t      && nullify)\n \t    return \"movb,%N2,n %1,%0,.+12\\n\\ttbl %3,0\";\n-\t  \n-\t  /* Handle normal cases.  */  \n+\n+\t  /* Handle normal cases.  */\n \t  if (nullify)\n \t    return \"or,%N2 %1,%%r0,%0\\n\\tbl,n %3,0\";\n \t  else\n@@ -3727,7 +3723,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n     {\n       /* Move loop counter from FP register to MEM then into a GR,\n \t increment the GR, store the GR into MEM, and finally reload\n-\t the FP register from MEM from within the branch's delay slot.  */ \n+\t the FP register from MEM from within the branch's delay slot.  */\n       output_asm_insn (\"stw %1,-16(0,%%r30)\",operands);\n       if (get_attr_length (insn) == 12)\n \treturn \"comb,%S2 0,%1,%3\\n\\tfldws -16(0,%%r30),%0\";\n@@ -3748,7 +3744,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \n \n /* INSN is either a function call or a millicode call.  It may have an\n-   unconditional jump in its delay slot.  \n+   unconditional jump in its delay slot.\n \n    CALL_DEST is the routine we are calling.\n \n@@ -3767,27 +3763,27 @@ output_call (insn, call_dest, return_pointer)\n \n   /* Handle common case -- empty delay slot or no jump in the delay slot.  */\n   if (dbr_sequence_length () == 0\n-      || (dbr_sequence_length () != 0 \n+      || (dbr_sequence_length () != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN))\n     {\n       xoperands[0] = call_dest;\n       xoperands[1] = return_pointer;\n       output_asm_insn (\"bl %0,%r1%#\", xoperands);\n       return \"\";\n     }\n-    \n+\n   /* This call has an unconditional jump in its delay slot.  */\n \n   /* Use the containing sequence insn's address.  */\n   seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n \n-  distance = insn_addresses[INSN_UID (JUMP_LABEL (NEXT_INSN (insn)))] \n+  distance = insn_addresses[INSN_UID (JUMP_LABEL (NEXT_INSN (insn)))]\n \t       - insn_addresses[INSN_UID (seq_insn)] - 8;\n \n   /* If the branch was too far away, emit a normal call followed\n      by a nop, followed by the unconditional branch.\n \n-     If the branch is close, then adjust %r2 from within the \n+     If the branch is close, then adjust %r2 from within the\n      call's delay slot.  */\n \n   xoperands[0] = call_dest;\n@@ -3799,7 +3795,7 @@ output_call (insn, call_dest, return_pointer)\n     {\n       xoperands[3] = gen_label_rtx ();\n       output_asm_insn (\"\\n\\tbl %0,%r2\\n\\tldo %1-%3(%r2),%r2\", xoperands);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", \n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t CODE_LABEL_NUMBER (xoperands[3]));\n     }\n \n@@ -3813,7 +3809,7 @@ output_call (insn, call_dest, return_pointer)\n extern struct obstack *saveable_obstack;\n \n /* In HPUX 8.0's shared library scheme, special relocations are needed\n-   for function labels if they might be passed to a function \n+   for function labels if they might be passed to a function\n    in a shared library (because shared libraries don't live in code\n    space), and special magic is needed to construct their address. */\n \n@@ -3831,7 +3827,7 @@ hppa_encode_label (sym)\n   *newstr = '@';\n   XSTR (sym,0) = newstr;\n }\n-  \n+\n int\n function_label_operand  (op, mode)\n      rtx op;\n@@ -4013,4 +4009,3 @@ jump_in_call_delay (insn)\n   else\n     return 0;\n }\n-"}]}