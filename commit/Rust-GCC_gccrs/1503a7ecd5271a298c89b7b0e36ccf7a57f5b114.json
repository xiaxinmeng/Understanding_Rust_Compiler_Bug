{"sha": "1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwM2E3ZWNkNTI3MWEyOThjODliN2IwZTM2Y2NmN2E1N2Y1YjExNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-01T00:09:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-01T00:09:22Z"}, "message": "builtins.c (expand_builtin_apply): Pass proper parameters to allocate_dynamic_stack_space.\n\n\t* builtins.c  (expand_builtin_apply):  Pass proper parameters to\n\tallocate_dynamic_stack_space.\n\t* calls.c (emit_call_1):  Do not adjust stack pointer for SIB,\n\tupdate stack_pointer_delta; do not update arg_size_so_far.\n\t(compute_argument_block_size): Use stack_delta instead of\n\tstack_pointer_pending and arg_size_so_far.\n\t(expand_call): Add sanity checking for stack_pointer_delta;\n\tsave and restore stack_pointer_delta for SIB, use\n\tstack_pointer_delta for alignment; do not update arg_space_so_far.\n\t(emit_library_call_value): Use stack_pointer_delta for alignment.\n\t(store_one_arg): Do not update arg_space_so_far.\n\t* explow.c (adjust_stack, anti_adjust_stack): Update\n\tstack_pointer_delta.\n\t(allocate_dynamic_stack_space): Add sanity checking for\n\tstack_pointer_delta.\n\t* expr.c (init_expr, clear_pending_stack_adjust): Clear\n\tstack_pointer_delta.\n\t(emit_push_insn): Update stack_pointer_delta.\n\t* function.h (struct expr_status): Add x_stack_pointer_delta;\n\tremove x_arg_space_so_far.\n\t(arg_space_so_far): Remove.\n\t(stack_pointer_delta): New macro.\n\nFrom-SVN: r32851", "tree": {"sha": "5d6a0fb689b150ce72e10a360f5434117542502c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d6a0fb689b150ce72e10a360f5434117542502c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/comments", "author": null, "committer": null, "parents": [{"sha": "ae79697b721b607964d32468c87d1881c3a39974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae79697b721b607964d32468c87d1881c3a39974", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae79697b721b607964d32468c87d1881c3a39974"}], "stats": {"total": 129, "additions": 96, "deletions": 33}, "files": [{"sha": "9d55846489c4b5c5ae28eee203b90028f3db674f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "patch": "@@ -1,3 +1,28 @@\n+Sat Apr  1 02:05:29 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* builtins.c  (expand_builtin_apply):  Pass proper parameters to\n+\tallocate_dynamic_stack_space.\n+\t* calls.c (emit_call_1):  Do not adjust stack pointer for SIB,\n+\tupdate stack_pointer_delta; do not update arg_size_so_far.\n+\t(compute_argument_block_size): Use stack_delta instead of\n+\tstack_pointer_pending and arg_size_so_far.\n+\t(expand_call): Add sanity checking for stack_pointer_delta;\n+\tsave and restore stack_pointer_delta for SIB, use\n+\tstack_pointer_delta for alignment; do not update arg_space_so_far.\n+\t(emit_library_call_value): Use stack_pointer_delta for alignment.\n+\t(store_one_arg): Do not update arg_space_so_far.\n+\t* explow.c (adjust_stack, anti_adjust_stack): Update\n+\tstack_pointer_delta.\n+\t(allocate_dynamic_stack_space): Add sanity checking for\n+\tstack_pointer_delta.\n+\t* expr.c (init_expr, clear_pending_stack_adjust): Clear\n+\tstack_pointer_delta.\n+\t(emit_push_insn): Update stack_pointer_delta.\n+\t* function.h (struct expr_status): Add x_stack_pointer_delta;\n+\tremove x_arg_space_so_far.\n+\t(arg_space_so_far): Remove.\n+\t(stack_pointer_delta): New macro.\n+\n 2000-03-31  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplib.h: Merge struct cpp_options into struct cpp_reader."}, {"sha": "3540fccda121647c360c78323c3c8b1ddf040778", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "patch": "@@ -871,8 +871,6 @@ expand_builtin_apply (function, arguments, argsize)\n   /* Create a block where the return registers can be saved.  */\n   result = assign_stack_local (BLKmode, apply_result_size (), -1);\n \n-  /* ??? The argsize value should be adjusted here.  */\n-\n   /* Fetch the arg pointer from the ARGUMENTS block.  */\n   incoming_args = gen_reg_rtx (Pmode);\n   emit_move_insn (incoming_args,\n@@ -901,7 +899,7 @@ expand_builtin_apply (function, arguments, argsize)\n      haven't figured out how the calling convention macros effect this,\n      but it's likely that the source and/or destination addresses in\n      the block copy will need updating in machine specific ways.  */\n-  dest = allocate_dynamic_stack_space (argsize, 0, 0);\n+  dest = allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT);\n   emit_block_move (gen_rtx_MEM (BLKmode, dest),\n \t\t   gen_rtx_MEM (BLKmode, incoming_args),\n \t\t   argsize, PARM_BOUNDARY);"}, {"sha": "ca4affddada9c827e6aabb8fe5f1395ef3cccbfc", "filename": "gcc/calls.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "patch": "@@ -577,6 +577,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \t\t\t       CALL_INSN_FUNCTION_USAGE (call_insn));\n       rounded_stack_size -= n_popped;\n       rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n+      stack_pointer_delta -= n_popped;\n     }\n \n   if (!ACCUMULATE_OUTGOING_ARGS)\n@@ -588,10 +589,6 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \t If returning from the subroutine does pop the args, indicate that the\n \t stack pointer will be changed.  */\n \n-      /* The space for the args is no longer waiting for the call; either it\n-\t was popped by the call, or it'll be popped below.  */\n-      arg_space_so_far -= rounded_stack_size - n_popped;\n-\n       if (rounded_stack_size != 0)\n \t{\n \t  if (flag_defer_pop && inhibit_defer_pop == 0\n@@ -1305,7 +1302,14 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n #ifdef PREFERRED_STACK_BOUNDARY\n       preferred_stack_boundary /= BITS_PER_UNIT;\n       if (preferred_stack_boundary > 1)\n-\targs_size->var = round_up (args_size->var, preferred_stack_boundary);\n+\t{\n+\t  /* We don't handle this case yet.  To handle it correctly we have\n+\t     to add the delta, round and substract the delta.  \n+\t     Currently no machine description requires this support.  */\n+\t  if (stack_pointer_delta & (preferred_stack_boundary - 1))\n+\t    abort();\n+\t  args_size->var = round_up (args_size->var, preferred_stack_boundary);\n+\t}\n #endif\n \n       if (reg_parm_stack_space > 0)\n@@ -1330,13 +1334,11 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n       if (preferred_stack_boundary < 1)\n \tpreferred_stack_boundary = 1;\n       args_size->constant = (((args_size->constant\n-\t\t\t       + arg_space_so_far\n-\t\t\t       + pending_stack_adjust\n+\t\t\t       + stack_pointer_delta\n \t\t\t       + preferred_stack_boundary - 1)\n \t\t\t      / preferred_stack_boundary\n \t\t\t      * preferred_stack_boundary)\n-\t\t\t     - arg_space_so_far\n-\t\t\t     - pending_stack_adjust);\n+\t\t\t     - stack_pointer_delta);\n #endif\n \n       args_size->constant = MAX (args_size->constant,\n@@ -1813,6 +1815,7 @@ expand_call (exp, target, ignore)\n   rtx old_stack_level = 0;\n   int old_pending_adj = 0;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n+  int old_stack_allocated;\n   rtx call_fusage;\n   register tree p;\n   register int i;\n@@ -2118,6 +2121,7 @@ expand_call (exp, target, ignore)\n \t recursion call can be ignored if we indeed use the tail recursion\n \t call expansion.  */\n       int save_pending_stack_adjust = pending_stack_adjust;\n+      int save_stack_pointer_delta = stack_pointer_delta;\n \n       /* Use a new sequence to hold any RTL we generate.  We do not even\n \t know if we will use this RTL yet.  The final decision can not be\n@@ -2135,6 +2139,7 @@ expand_call (exp, target, ignore)\n       /* Restore the original pending stack adjustment for the sibling and\n \t normal call cases below.  */\n       pending_stack_adjust = save_pending_stack_adjust;\n+      stack_pointer_delta = save_stack_pointer_delta;\n     }\n \n   function_call_count++;\n@@ -2180,6 +2185,7 @@ expand_call (exp, target, ignore)\n \t recursion call can be ignored if we indeed use the tail recursion\n \t call expansion.  */\n       int save_pending_stack_adjust;\n+      int save_stack_pointer_delta;\n       rtx insns;\n       rtx before_call, next_arg_reg;\n \n@@ -2217,6 +2223,7 @@ expand_call (exp, target, ignore)\n \t  /* State variables we need to save and restore between\n \t     iterations.  */\n \t  save_pending_stack_adjust = pending_stack_adjust;\n+\t  save_stack_pointer_delta = stack_pointer_delta;\n \t}\n \n       /* Other state variables that we must reinitialize each time\n@@ -2411,6 +2418,8 @@ expand_call (exp, target, ignore)\n       if (is_const || is_malloc)\n \tstart_sequence ();\n \n+      old_stack_allocated =  stack_pointer_delta - pending_stack_adjust;\n+\n       /* If we have no actual push instructions, or shouldn't use them,\n \t make space for all args right now.  */\n \n@@ -2592,22 +2601,21 @@ expand_call (exp, target, ignore)\n \t  if (pending_stack_adjust && ! is_const\n \t      && ! inhibit_defer_pop)\n \t    {\n+\t      int adjust;\n \t      args_size.constant = (unadjusted_args_size\n \t\t\t\t    + ((pending_stack_adjust\n \t\t\t\t\t+ args_size.constant\n-\t\t\t\t\t+ arg_space_so_far\n \t\t\t\t\t- unadjusted_args_size)\n \t\t\t\t       % (preferred_stack_boundary\n \t\t\t\t\t  / BITS_PER_UNIT)));\n-\t      pending_stack_adjust -= (args_size.constant\n-\t\t\t\t       - unadjusted_args_size);\n-\t      do_pending_stack_adjust ();\n+\t      adjust = (pending_stack_adjust - args_size.constant\n+\t\t        + unadjusted_args_size);\n+\t      adjust_stack (GEN_INT (adjust));\n+\t      pending_stack_adjust = 0;\n \t    }\n \t  else if (argblock == 0)\n \t    anti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t\t- unadjusted_args_size));\n-\t  arg_space_so_far += args_size.constant - unadjusted_args_size;\n-\n \t  /* Now that the stack is properly aligned, pops can't safely\n \t     be deferred during the evaluation of the arguments.  */\n \t  NO_DEFER_POP;\n@@ -2674,7 +2682,6 @@ expand_call (exp, target, ignore)\n #ifdef PREFERRED_STACK_BOUNDARY\n       /* If we pushed args in forward order, perform stack alignment\n \t after pushing the last arg.  */\n-      /* ??? Fix for arg_space_so_far.  */\n       if (!PUSH_ARGS_REVERSED && argblock == 0)\n \tanti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t    - unadjusted_args_size));\n@@ -2746,6 +2753,11 @@ expand_call (exp, target, ignore)\n \t\t    | (nothrow ? ECF_NOTHROW : 0)\n \t\t    | (pass == 0 ? ECF_SIBCALL : 0)));\n \n+      /* Verify that we've deallocated all the stack we used.  */\n+      if (pass\n+          && old_stack_allocated != stack_pointer_delta - pending_stack_adjust)\n+\tabort();\n+\n       /* If call is cse'able, make appropriate pair of reg-notes around it.\n \t Test valreg so we don't crash; may safely ignore `const'\n \t if return type is void.  Disable for PARALLEL return values, because\n@@ -3025,10 +3037,11 @@ expand_call (exp, target, ignore)\n \t     zero out the sequence.  */\n \t  if (sibcall_failure)\n \t    tail_call_insns = NULL_RTX;\n-\n \t  /* Restore the pending stack adjustment now that we have\n \t     finished generating the sibling call sequence.  */\n+\n \t  pending_stack_adjust = save_pending_stack_adjust;\n+\t  stack_pointer_delta = save_stack_pointer_delta;\n \t}\n       else\n \tnormal_call_insns = insns;\n@@ -3327,8 +3340,12 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \n   original_args_size = args_size;\n #ifdef PREFERRED_STACK_BOUNDARY\n-  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n-\t\t\t / STACK_BYTES) * STACK_BYTES);\n+  args_size.constant = (((args_size.constant\n+\t\t\t  + stack_pointer_delta\n+\t\t\t  + STACK_BYTES - 1)\n+\t\t\t  / STACK_BYTES\n+\t\t\t  * STACK_BYTES)\n+\t\t\t - stack_pointer_delta);\n #endif\n \n   args_size.constant = MAX (args_size.constant,\n@@ -4043,8 +4060,6 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \t\t      partial, reg, used - size, argblock,\n \t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n-\n-      arg_space_so_far += used;\n     }\n   else\n     {\n@@ -4072,7 +4087,6 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \t  excess = (arg->size.constant - int_size_in_bytes (TREE_TYPE (pval))\n \t\t    + partial * UNITS_PER_WORD);\n \t  size_rtx = expr_size (pval);\n-\t  arg_space_so_far += excess + INTVAL (size_rtx);\n \t}\n \n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,"}, {"sha": "0f067caf215f0ca74bf776742c036c877b618c39", "filename": "gcc/explow.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "patch": "@@ -852,6 +852,11 @@ adjust_stack (adjust)\n   if (adjust == const0_rtx)\n     return;\n \n+  /* We expect all variable sized adjustments to be multiple of\n+     PREFERRED_STACK_BOUNDARY.  */\n+  if (GET_CODE (adjust) == CONST_INT)\n+    stack_pointer_delta -= INTVAL (adjust);\n+\n   temp = expand_binop (Pmode,\n #ifdef STACK_GROWS_DOWNWARD\n \t\t       add_optab,\n@@ -878,6 +883,11 @@ anti_adjust_stack (adjust)\n   if (adjust == const0_rtx)\n     return;\n \n+  /* We expect all variable sized adjustments to be multiple of\n+     PREFERRED_STACK_BOUNDARY.  */\n+  if (GET_CODE (adjust) == CONST_INT)\n+    stack_pointer_delta += INTVAL (adjust);\n+\n   temp = expand_binop (Pmode,\n #ifdef STACK_GROWS_DOWNWARD\n \t\t       sub_optab,\n@@ -1295,6 +1305,13 @@ allocate_dynamic_stack_space (size, target, known_align)\n \n   do_pending_stack_adjust ();\n \n+ /* We ought to be called always on the toplevel and stack ought to be aligned\n+    propertly.  */\n+#ifdef PREFERRED_STACK_BOUNDARY\n+  if (stack_pointer_delta % (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT))\n+    abort ();\n+#endif\n+\n   /* If needed, check that we have the required amount of stack.  Take into\n      account what has already been checked.  */\n   if (flag_stack_check && ! STACK_CHECK_BUILTIN)"}, {"sha": "0302d959459031acadb85fed9a95990e323c4410", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "patch": "@@ -306,7 +306,7 @@ init_expr ()\n \n   pending_chain = 0;\n   pending_stack_adjust = 0;\n-  arg_space_so_far = 0;\n+  stack_pointer_delta = 0;\n   inhibit_defer_pop = 0;\n   saveregs_value = 0;\n   apply_args_value = 0;\n@@ -2996,6 +2996,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && where_pad != none && where_pad != stack_direction)\n \t    anti_adjust_stack (GEN_INT (extra));\n \n+\t  stack_pointer_delta += INTVAL (size) - used;\n \t  move_by_pieces (gen_rtx_MEM (BLKmode, gen_push_operand ()), xinner,\n \t\t\t  INTVAL (size) - used, align);\n \n@@ -3236,7 +3237,10 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n #ifdef PUSH_ROUNDING\n       if (args_addr == 0 && PUSH_ARGS)\n-\taddr = gen_push_operand ();\n+\t{\n+\t  addr = gen_push_operand ();\n+\t  stack_pointer_delta += PUSH_ROUNDING (GET_MODE_SIZE (mode));\n+\t}\n       else\n #endif\n \t{\n@@ -9121,7 +9125,10 @@ clear_pending_stack_adjust ()\n       && EXIT_IGNORE_STACK\n       && ! (DECL_INLINE (current_function_decl) && ! flag_no_inline)\n       && ! flag_inline_functions)\n-    pending_stack_adjust = 0;\n+    {\n+      stack_pointer_delta -= pending_stack_adjust,\n+      pending_stack_adjust = 0;\n+    }\n #endif\n }\n "}, {"sha": "08d438ab67e880f9ccf73a94e49bf79819d2a97d", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1503a7ecd5271a298c89b7b0e36ccf7a57f5b114/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=1503a7ecd5271a298c89b7b0e36ccf7a57f5b114", "patch": "@@ -130,10 +130,6 @@ struct expr_status\n      These are the arguments to function calls that have already returned.  */\n   int x_pending_stack_adjust;\n \n-  /* Number of units that we should eventually pop off the stack.\n-     These are the arguments to function calls that have not happened yet.  */\n-  int x_arg_space_so_far;\n-\n   /* Under some ABIs, it is the caller's responsibility to pop arguments\n      pushed for function calls.  A naive implementation would simply pop\n      the arguments immediately after each call.  However, if several\n@@ -151,6 +147,12 @@ struct expr_status\n      NO_DEFER_POP and OK_DEFER_POP.  */\n   int x_inhibit_defer_pop;\n \n+  /* If PREFERRED_STACK_BOUNDARY and PUSH_ROUNDING are defined, the stack\n+     boundary can be momentairly unaligned while pushing the arguments.\n+     Record the delta since last aligned boundary here in order to get\n+     stack alignment in the nested function calls working right.  */\n+  int x_stack_pointer_delta;\n+\n   /* Nonzero means __builtin_saveregs has already been done in this function.\n      The value is the pseudoreg containing the value __builtin_saveregs\n      returned.  */\n@@ -167,12 +169,12 @@ struct expr_status\n };\n \n #define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n-#define arg_space_so_far (cfun->expr->x_arg_space_so_far)\n #define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n #define saveregs_value (cfun->expr->x_saveregs_value)\n #define apply_args_value (cfun->expr->x_apply_args_value)\n #define forced_labels (cfun->expr->x_forced_labels)\n #define pending_chain (cfun->expr->x_pending_chain)\n+#define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)\n \n /* This structure can save all the important global and static variables\n    describing the status of the current function.  */"}]}