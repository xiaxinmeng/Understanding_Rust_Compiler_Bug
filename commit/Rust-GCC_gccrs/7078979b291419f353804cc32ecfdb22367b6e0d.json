{"sha": "7078979b291419f353804cc32ecfdb22367b6e0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA3ODk3OWIyOTE0MTlmMzUzODA0Y2MzMmVjZmRiMjIzNjdiNmUwZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-06-07T10:53:02Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-06-07T10:53:02Z"}, "message": "tree-vectorizer.h (vect_build_loop_niters): New parameter.\n\n\t* tree-vectorizer.h (vect_build_loop_niters): New parameter.\n\t* tree-vect-loop-manip.c (vect_build_loop_niters): New parameter.\n\tSet true to new parameter if new ssa variable is defined.\n\t(vect_gen_vector_loop_niters): Refactor.  Set range information\n\tfor the new vector loop bound variable.\n\t(vect_do_peeling): Ditto.\n\nFrom-SVN: r248958", "tree": {"sha": "cf5b821d23cf540d0e7289e381d0a618ffcb1225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf5b821d23cf540d0e7289e381d0a618ffcb1225"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7078979b291419f353804cc32ecfdb22367b6e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7078979b291419f353804cc32ecfdb22367b6e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7078979b291419f353804cc32ecfdb22367b6e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7078979b291419f353804cc32ecfdb22367b6e0d/comments", "author": null, "committer": null, "parents": [{"sha": "ba00284cedbcb0b980af4e5e41f427581af64462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba00284cedbcb0b980af4e5e41f427581af64462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba00284cedbcb0b980af4e5e41f427581af64462"}], "stats": {"total": 66, "additions": 44, "deletions": 22}, "files": [{"sha": "f83e059e05fd84002eb265a015161baf77cd763e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7078979b291419f353804cc32ecfdb22367b6e0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7078979b291419f353804cc32ecfdb22367b6e0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7078979b291419f353804cc32ecfdb22367b6e0d", "patch": "@@ -1,3 +1,12 @@\n+2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vectorizer.h (vect_build_loop_niters): New parameter.\n+\t* tree-vect-loop-manip.c (vect_build_loop_niters): New parameter.\n+\tSet true to new parameter if new ssa variable is defined.\n+\t(vect_gen_vector_loop_niters): Refactor.  Set range information\n+\tfor the new vector loop bound variable.\n+\t(vect_do_peeling): Ditto.\n+\n 2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-affine.c (ssa.h): Include header file."}, {"sha": "0156c97be5c50ea1a7d9a7b3cde94d560c1b2fe9", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7078979b291419f353804cc32ecfdb22367b6e0d/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7078979b291419f353804cc32ecfdb22367b6e0d/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=7078979b291419f353804cc32ecfdb22367b6e0d", "patch": "@@ -1095,10 +1095,11 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n \n \n /* This function builds ni_name = number of iterations.  Statements\n-   are emitted on the loop preheader edge.  */\n+   are emitted on the loop preheader edge.  If NEW_VAR_P is not NULL, set\n+   it to TRUE if new ssa_var is generated.  */\n \n tree\n-vect_build_loop_niters (loop_vec_info loop_vinfo)\n+vect_build_loop_niters (loop_vec_info loop_vinfo, bool *new_var_p)\n {\n   tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n   if (TREE_CODE (ni) == INTEGER_CST)\n@@ -1112,7 +1113,11 @@ vect_build_loop_niters (loop_vec_info loop_vinfo)\n       var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n       ni_name = force_gimple_operand (ni, &stmts, false, var);\n       if (stmts)\n-\tgsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t{\n+\t  gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  if (new_var_p != NULL)\n+\t    *new_var_p = true;\n+\t}\n \n       return ni_name;\n     }\n@@ -1177,22 +1182,21 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n \t\t\t     tree *niters_vector_ptr, bool niters_no_overflow)\n {\n   tree ni_minus_gap, var;\n-  tree niters_vector;\n+  tree niters_vector, type = TREE_TYPE (niters);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n-  tree log_vf = build_int_cst (TREE_TYPE (niters), exact_log2 (vf));\n+  tree log_vf = build_int_cst (type, exact_log2 (vf));\n \n   /* If epilogue loop is required because of data accesses with gaps, we\n      subtract one iteration from the total number of iterations here for\n      correct calculation of RATIO.  */\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     {\n-      ni_minus_gap = fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n-\t\t\t\t  niters,\n-\t\t\t\t  build_one_cst (TREE_TYPE (niters)));\n+      ni_minus_gap = fold_build2 (MINUS_EXPR, type, niters,\n+\t\t\t\t  build_one_cst (type));\n       if (!is_gimple_val (ni_minus_gap))\n \t{\n-\t  var = create_tmp_var (TREE_TYPE (niters), \"ni_gap\");\n+\t  var = create_tmp_var (type, \"ni_gap\");\n \t  gimple *stmts = NULL;\n \t  ni_minus_gap = force_gimple_operand (ni_minus_gap, &stmts,\n \t\t\t\t\t       true, var);\n@@ -1208,25 +1212,28 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n      (niters - vf) >> log2(vf) + 1 by using the fact that we know ratio\n      will be at least one.  */\n   if (niters_no_overflow)\n-    niters_vector = fold_build2 (RSHIFT_EXPR, TREE_TYPE (niters),\n-\t\t\t\t ni_minus_gap, log_vf);\n+    niters_vector = fold_build2 (RSHIFT_EXPR, type, ni_minus_gap, log_vf);\n   else\n     niters_vector\n-      = fold_build2 (PLUS_EXPR, TREE_TYPE (niters),\n-\t\t     fold_build2 (RSHIFT_EXPR, TREE_TYPE (niters),\n-\t\t\t\t  fold_build2 (MINUS_EXPR, TREE_TYPE (niters),\n-\t\t\t\t\t       ni_minus_gap,\n-\t\t\t\t\t       build_int_cst\n-\t\t\t\t\t\t (TREE_TYPE (niters), vf)),\n+      = fold_build2 (PLUS_EXPR, type,\n+\t\t     fold_build2 (RSHIFT_EXPR, type,\n+\t\t\t\t  fold_build2 (MINUS_EXPR, type, ni_minus_gap,\n+\t\t\t\t\t       build_int_cst (type, vf)),\n \t\t\t\t  log_vf),\n-\t\t     build_int_cst (TREE_TYPE (niters), 1));\n+\t\t     build_int_cst (type, 1));\n \n   if (!is_gimple_val (niters_vector))\n     {\n-      var = create_tmp_var (TREE_TYPE (niters), \"bnd\");\n-      gimple *stmts = NULL;\n+      var = create_tmp_var (type, \"bnd\");\n+      gimple_seq stmts = NULL;\n       niters_vector = force_gimple_operand (niters_vector, &stmts, true, var);\n       gsi_insert_seq_on_edge_immediate (pe, stmts);\n+      /* Peeling algorithm guarantees that vector loop bound is at least ONE,\n+\t we set range information to make niters analyzer's life easier.  */\n+      if (stmts != NULL)\n+\tset_range_info (niters_vector, VR_RANGE, build_int_cst (type, 1),\n+\t\t\tfold_build2 (RSHIFT_EXPR, type,\n+\t\t\t\t     TYPE_MAX_VALUE (type), log_vf));\n     }\n   *niters_vector_ptr = niters_vector;\n \n@@ -1771,7 +1778,13 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       LOOP_VINFO_NITERSM1 (loop_vinfo)\n \t= fold_build2 (MINUS_EXPR, type,\n \t\t       LOOP_VINFO_NITERSM1 (loop_vinfo), niters_prolog);\n-      niters = vect_build_loop_niters (loop_vinfo);\n+      bool new_var_p = false;\n+      niters = vect_build_loop_niters (loop_vinfo, &new_var_p);\n+      /* It's guaranteed that vector loop bound before vectorization is at\n+\t least VF, so set range information for newly generated var.  */\n+      if (new_var_p)\n+\tset_range_info (niters, VR_RANGE,\n+\t\t\tbuild_int_cst (type, vf), TYPE_MAX_VALUE (type));\n \n       /* Prolog iterates at most bound_prolog times, latch iterates at\n \t most bound_prolog - 1 times.  */"}, {"sha": "2e46467ee3730920476e86490b0d6e7c8a188442", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7078979b291419f353804cc32ecfdb22367b6e0d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7078979b291419f353804cc32ecfdb22367b6e0d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7078979b291419f353804cc32ecfdb22367b6e0d", "patch": "@@ -1150,7 +1150,7 @@ extern gimple *vect_force_simple_reduction (loop_vec_info, gimple *,\n \t\t\t\t\t    bool *, bool);\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info);\n-extern tree vect_build_loop_niters (loop_vec_info);\n+extern tree vect_build_loop_niters (loop_vec_info, bool * = NULL);\n extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *, bool);\n /* Drive for loop transformation stage.  */\n extern struct loop *vect_transform_loop (loop_vec_info);"}]}