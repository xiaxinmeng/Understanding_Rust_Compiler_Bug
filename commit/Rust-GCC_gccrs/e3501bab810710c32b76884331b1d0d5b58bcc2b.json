{"sha": "e3501bab810710c32b76884331b1d0d5b58bcc2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM1MDFiYWI4MTA3MTBjMzJiNzY4ODQzMzFiMWQwZDViNThiY2MyYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-12-12T17:52:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-12-12T17:52:21Z"}, "message": "cp-tree.h (NAMESPACE_ABI_TAG): New.\n\n\t* cp-tree.h (NAMESPACE_ABI_TAG): New.\n\t* name-lookup.c (handle_namespace_attrs): Set it.\n\t* class.c (check_tag): Split out from find_abi_tags_r.\n\t(find_abi_tags_r): Also check namespace tags.\n\t(mark_type_abi_tags): Also mark namespace tags.\n\nFrom-SVN: r218684", "tree": {"sha": "2902cfa4c51e8279ef89316007498b892ece6285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2902cfa4c51e8279ef89316007498b892ece6285"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3501bab810710c32b76884331b1d0d5b58bcc2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3501bab810710c32b76884331b1d0d5b58bcc2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3501bab810710c32b76884331b1d0d5b58bcc2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3501bab810710c32b76884331b1d0d5b58bcc2b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c89d52a8d2e0ceba8e26a25f4d2fc6612a5fcda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c89d52a8d2e0ceba8e26a25f4d2fc6612a5fcda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c89d52a8d2e0ceba8e26a25f4d2fc6612a5fcda"}], "stats": {"total": 155, "additions": 108, "deletions": 47}, "files": [{"sha": "828848164ed4b5d60695db293ba9327e88772116", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e3501bab810710c32b76884331b1d0d5b58bcc2b", "patch": "@@ -1,3 +1,11 @@\n+2014-12-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-tree.h (NAMESPACE_ABI_TAG): New.\n+\t* name-lookup.c (handle_namespace_attrs): Set it.\n+\t* class.c (check_tag): Split out from find_abi_tags_r.\n+\t(find_abi_tags_r): Also check namespace tags.\n+\t(mark_type_abi_tags): Also mark namespace tags.\n+\n 2014-12-12  Kai Tietz  <ktietz@redhat.com>\n \n \tPR c++/63996"}, {"sha": "07bbc69806cd4b13850055c6dd8e4f6cd1694018", "filename": "gcc/cp/class.c", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e3501bab810710c32b76884331b1d0d5b58bcc2b", "patch": "@@ -1352,18 +1352,73 @@ handle_using_decl (tree using_decl, tree t)\n     alter_access (t, decl, access);\n }\n \f\n-/* walk_tree callback for check_abi_tags: if the type at *TP involves any\n-   types with abi tags, add the corresponding identifiers to the VEC in\n-   *DATA and set IDENTIFIER_MARKED.  */\n+/* Data structure for find_abi_tags_r, below.  */\n \n struct abi_tag_data\n {\n-  tree t;\n-  tree subob;\n-  // error_mark_node to get diagnostics; otherwise collect missing tags here\n-  tree tags;\n+  tree t;\t\t// The type that we're checking for missing tags.\n+  tree subob;\t\t// The subobject of T that we're getting tags from.\n+  tree tags; // error_mark_node for diagnostics, or a list of missing tags.\n };\n \n+/* Subroutine of find_abi_tags_r. Handle a single TAG found on the class TP\n+   in the context of P.  TAG can be either an identifier (the DECL_NAME of\n+   a tag NAMESPACE_DECL) or a STRING_CST (a tag attribute).  */\n+\n+static void\n+check_tag (tree tag, tree *tp, abi_tag_data *p)\n+{\n+  tree id;\n+\n+  if (TREE_CODE (tag) == STRING_CST)\n+    id = get_identifier (TREE_STRING_POINTER (tag));\n+  else\n+    {\n+      id = tag;\n+      tag = NULL_TREE;\n+    }\n+\n+  if (!IDENTIFIER_MARKED (id))\n+    {\n+      if (!tag)\n+\ttag = build_string (IDENTIFIER_LENGTH (id) + 1,\n+\t\t\t    IDENTIFIER_POINTER (id));\n+      if (p->tags != error_mark_node)\n+\t{\n+\t  /* We're collecting tags from template arguments.  */\n+\t  p->tags = tree_cons (NULL_TREE, tag, p->tags);\n+\t  ABI_TAG_IMPLICIT (p->tags) = true;\n+\n+\t  /* Don't inherit this tag multiple times.  */\n+\t  IDENTIFIER_MARKED (id) = true;\n+\t}\n+\n+      /* Otherwise we're diagnosing missing tags.  */\n+      else if (TYPE_P (p->subob))\n+\t{\n+\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n+\t\t       \"that base %qT has\", p->t, tag, p->subob))\n+\t    inform (location_of (p->subob), \"%qT declared here\",\n+\t\t    p->subob);\n+\t}\n+      else\n+\t{\n+\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n+\t\t       \"that %qT (used in the type of %qD) has\",\n+\t\t       p->t, tag, *tp, p->subob))\n+\t    {\n+\t      inform (location_of (p->subob), \"%qD declared here\",\n+\t\t      p->subob);\n+\t      inform (location_of (*tp), \"%qT declared here\", *tp);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* walk_tree callback for check_abi_tags: if the type at *TP involves any\n+   types with abi tags, add the corresponding identifiers to the VEC in\n+   *DATA and set IDENTIFIER_MARKED.  */\n+\n static tree\n find_abi_tags_r (tree *tp, int *walk_subtrees, void *data)\n {\n@@ -1374,48 +1429,21 @@ find_abi_tags_r (tree *tp, int *walk_subtrees, void *data)\n      anyway, but let's make sure of it.  */\n   *walk_subtrees = false;\n \n+  abi_tag_data *p = static_cast<struct abi_tag_data*>(data);\n+\n+  for (tree ns = decl_namespace_context (*tp);\n+       ns != global_namespace;\n+       ns = CP_DECL_CONTEXT (ns))\n+    if (NAMESPACE_ABI_TAG (ns))\n+      check_tag (DECL_NAME (ns), tp, p);\n+\n   if (tree attributes = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (*tp)))\n     {\n-      struct abi_tag_data *p = static_cast<struct abi_tag_data*>(data);\n       for (tree list = TREE_VALUE (attributes); list;\n \t   list = TREE_CHAIN (list))\n \t{\n \t  tree tag = TREE_VALUE (list);\n-\t  tree id = get_identifier (TREE_STRING_POINTER (tag));\n-\t  if (!IDENTIFIER_MARKED (id))\n-\t    {\n-\t      if (p->tags != error_mark_node)\n-\t\t{\n-\t\t  /* We're collecting tags from template arguments.  */\n-\t\t  tree str = build_string (IDENTIFIER_LENGTH (id),\n-\t\t\t\t\t   IDENTIFIER_POINTER (id));\n-\t\t  p->tags = tree_cons (NULL_TREE, str, p->tags);\n-\t\t  ABI_TAG_IMPLICIT (p->tags) = true;\n-\n-\t\t  /* Don't inherit this tag multiple times.  */\n-\t\t  IDENTIFIER_MARKED (id) = true;\n-\t\t}\n-\n-\t      /* Otherwise we're diagnosing missing tags.  */\n-\t      else if (TYPE_P (p->subob))\n-\t\t{\n-\t\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n-\t\t\t       \"that base %qT has\", p->t, tag, p->subob))\n-\t\t    inform (location_of (p->subob), \"%qT declared here\",\n-\t\t\t    p->subob);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (warning (OPT_Wabi_tag, \"%qT does not have the %E abi tag \"\n-\t\t\t       \"that %qT (used in the type of %qD) has\",\n-\t\t\t       p->t, tag, *tp, p->subob))\n-\t\t    {\n-\t\t      inform (location_of (p->subob), \"%qD declared here\",\n-\t\t\t      p->subob);\n-\t\t      inform (location_of (*tp), \"%qT declared here\", *tp);\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  check_tag (tag, tp, p);\n \t}\n     }\n   return NULL_TREE;\n@@ -1427,6 +1455,12 @@ find_abi_tags_r (tree *tp, int *walk_subtrees, void *data)\n static void\n mark_type_abi_tags (tree t, bool val)\n {\n+  for (tree ns = decl_namespace_context (t);\n+       ns != global_namespace;\n+       ns = CP_DECL_CONTEXT (ns))\n+    if (NAMESPACE_ABI_TAG (ns))\n+      IDENTIFIER_MARKED (DECL_NAME (ns)) = val;\n+\n   tree attributes = lookup_attribute (\"abi_tag\", TYPE_ATTRIBUTES (t));\n   if (attributes)\n     {"}, {"sha": "e8516606184fb43a7bdb5db22d697a3d38cd3f97", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e3501bab810710c32b76884331b1d0d5b58bcc2b", "patch": "@@ -151,6 +151,7 @@ c-common.h, not after.\n       DECL_MUTABLE_P (in FIELD_DECL)\n       DECL_DEPENDENT_P (in USING_DECL)\n       LABEL_DECL_BREAK (in LABEL_DECL)\n+      NAMESPACE_ABI_TAG (in NAMESPACE_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n       DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n@@ -2642,6 +2643,11 @@ struct GTY(()) lang_decl {\n #define LOCAL_CLASS_P(NODE)\t\t\t\t\\\n   (decl_function_context (TYPE_MAIN_DECL (NODE)) != NULL_TREE)\n \n+/* 1 iff this NAMESPACE_DECL should also be treated as an ABI tag for\n+   -Wabi-tag.  */\n+#define NAMESPACE_ABI_TAG(NODE)\t\t\t\t\\\n+  DECL_LANG_FLAG_0 (NAMESPACE_DECL_CHECK (NODE))\n+\n /* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n    that is the common ancestor.  */"}, {"sha": "b982451caf67fa0529ee1935a5bc68dff260a9fa", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e3501bab810710c32b76884331b1d0d5b58bcc2b", "patch": "@@ -3610,10 +3610,8 @@ current_decl_namespace (void)\n   return result;\n }\n \n-/* Process any ATTRIBUTES on a namespace definition.  Currently only\n-   attribute visibility is meaningful, which is a property of the syntactic\n-   block rather than the namespace as a whole, so we don't touch the\n-   NAMESPACE_DECL at all.  Returns true if attribute visibility is seen.  */\n+/* Process any ATTRIBUTES on a namespace definition.  Returns true if\n+   attribute visibility is seen.  */\n \n bool\n handle_namespace_attrs (tree ns, tree attributes)\n@@ -3628,6 +3626,9 @@ handle_namespace_attrs (tree ns, tree attributes)\n \n       if (is_attribute_p (\"visibility\", name))\n \t{\n+\t  /* attribute visibility is a property of the syntactic block\n+\t     rather than the namespace as a whole, so we don't touch the\n+\t     NAMESPACE_DECL at all.  */\n \t  tree x = args ? TREE_VALUE (args) : NULL_TREE;\n \t  if (x == NULL_TREE || TREE_CODE (x) != STRING_CST || TREE_CHAIN (args))\n \t    {\n@@ -3645,6 +3646,10 @@ handle_namespace_attrs (tree ns, tree attributes)\n \t  push_visibility (TREE_STRING_POINTER (x), 1);\n \t  saw_vis = true;\n \t}\n+      else if (is_attribute_p (\"abi_tag\", name))\n+\t{\n+\t  NAMESPACE_ABI_TAG (ns) = true;\n+\t}\n       else\n \t{\n \t  warning (OPT_Wattributes, \"%qD attribute directive ignored\","}, {"sha": "74dffa0efaa1376226751dfddefe973a802c2198", "filename": "gcc/testsuite/g++.dg/abi/abi-tag12.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3501bab810710c32b76884331b1d0d5b58bcc2b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag12.C?ref=e3501bab810710c32b76884331b1d0d5b58bcc2b", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"-Wabi-tag\" }\n+\n+inline namespace A __attribute ((abi_tag)) {\n+  struct Foo { };\t\t// { dg-message \"declared here\" }\n+  struct Baz: Foo { };\n+}\n+\n+struct Bar: Foo { };\t\t// { dg-warning \"tag\" }"}]}