{"sha": "abc2d8074ae190486e3f620075e25498c1b2791c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJjMmQ4MDc0YWUxOTA0ODZlM2Y2MjAwNzVlMjU0OThjMWIyNzkxYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-07-15T08:25:48Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-07-15T08:25:48Z"}, "message": "trans-array.h (gfc_deallocate_alloc_comp_no_caf, [...]): New prototype.\n\n2013-07-15  Tobias Burnus  <burnus@net-b.de>\n\n        * trans-array.h (gfc_deallocate_alloc_comp_no_caf,\n        gfc_reassign_alloc_comp_caf): New prototype.\n        * trans-array.c (enum): Add DEALLOCATE_ALLOC_COMP_NO_CAF\n        and COPY_ALLOC_COMP_CAF.\n        (structure_alloc_comps): Handle it.\n        (gfc_reassign_alloc_comp_caf,\n        gfc_deallocate_alloc_comp_no_caf): New function.\n        (gfc_alloc_allocatable_for_assignment): Call it.\n        * trans-expr.c (gfc_trans_scalar_assign,\n        gfc_trans_arrayfunc_assign, gfc_trans_assignment_1): Ditto.\n        * parse.c (parse_derived): Correctly set coarray_comp.\n        * resolve.c (resolve_symbol): Improve error wording.\n\n2013-07-15  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_lib_realloc_1.f90: New.\n        * gfortran.dg/coarray/lib_realloc_1.f90: New.\n        * gfortran.dg/coarray_6.f90: Add dg-error.\n\nFrom-SVN: r200955", "tree": {"sha": "af43e59575bb2a233dfe1487ef6186279511baed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af43e59575bb2a233dfe1487ef6186279511baed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abc2d8074ae190486e3f620075e25498c1b2791c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc2d8074ae190486e3f620075e25498c1b2791c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc2d8074ae190486e3f620075e25498c1b2791c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc2d8074ae190486e3f620075e25498c1b2791c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "895a0c2df3542769fb381f0792cb543da01229ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895a0c2df3542769fb381f0792cb543da01229ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/895a0c2df3542769fb381f0792cb543da01229ec"}], "stats": {"total": 226, "additions": 193, "deletions": 33}, "files": [{"sha": "ef0da9a29e0f7f685897565a6e843f87dc7d37ff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -1,3 +1,18 @@\n+2013-07-15  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-array.h (gfc_deallocate_alloc_comp_no_caf,\n+\tgfc_reassign_alloc_comp_caf): New prototype.\n+\t* trans-array.c (enum): Add DEALLOCATE_ALLOC_COMP_NO_CAF\n+\tand COPY_ALLOC_COMP_CAF.\n+\t(structure_alloc_comps): Handle it.\n+\t(gfc_reassign_alloc_comp_caf,\n+\tgfc_deallocate_alloc_comp_no_caf): New function.\n+\t(gfc_alloc_allocatable_for_assignment): Call it.\n+\t* trans-expr.c (gfc_trans_scalar_assign,\n+\tgfc_trans_arrayfunc_assign, gfc_trans_assignment_1): Ditto.\n+\t* parse.c (parse_derived): Correctly set coarray_comp.\n+\t* resolve.c (resolve_symbol): Improve error wording.\n+\n 2013-07-15  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37336"}, {"sha": "737f3d61889fd9f0d31239e12bf29c9e0055f40f", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -2228,11 +2228,11 @@ parse_derived (void)\n \t  sym->attr.coarray_comp = 1;\n \t}\n      \n-      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp)\n+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n+\t  && !c->attr.pointer)\n \t{\n \t  coarray = true;\n-\t  if (!pointer && !allocatable)\n-\t    sym->attr.coarray_comp = 1;\n+\t  sym->attr.coarray_comp = 1;\n \t}\n \n       /* Looking for lock_type components.  */"}, {"sha": "08e197b7c729a7e39bdad9ce1f1e13a0ac022be4", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -13125,8 +13125,8 @@ resolve_symbol (gfc_symbol *sym)\n       && (class_attr.codimension || class_attr.pointer || class_attr.dimension\n \t  || class_attr.allocatable))\n     {\n-      gfc_error (\"Variable '%s' at %L with coarray component \"\n-\t\t \"shall be a nonpointer, nonallocatable scalar\",\n+      gfc_error (\"Variable '%s' at %L with coarray component shall be a \"\n+\t\t \"nonpointer, nonallocatable scalar, which is not a coarray\",\n \t\t sym->name, &sym->declared_at);\n       return;\n     }"}, {"sha": "5cc174fa7ca6dd84061dc66327f37c228d8da521", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 83, "deletions": 22, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -7445,8 +7445,9 @@ gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank)\n    deallocate, nullify or copy allocatable components.  This is the work horse\n    function for the functions named in this enum.  */\n \n-enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP, COPY_ALLOC_COMP,\n-      COPY_ONLY_ALLOC_COMP};\n+enum {DEALLOCATE_ALLOC_COMP = 1, DEALLOCATE_ALLOC_COMP_NO_CAF,\n+      NULLIFY_ALLOC_COMP, COPY_ALLOC_COMP, COPY_ONLY_ALLOC_COMP,\n+      COPY_ALLOC_COMP_CAF};\n \n static tree\n structure_alloc_comps (gfc_symbol * der_type, tree decl,\n@@ -7577,6 +7578,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       switch (purpose)\n \t{\n \tcase DEALLOCATE_ALLOC_COMP:\n+\tcase DEALLOCATE_ALLOC_COMP_NO_CAF:\n \n \t  /* gfc_deallocate_scalar_with_status calls gfc_deallocate_alloc_comp\n \t     (i.e. this function) so generate all the calls and suppress the\n@@ -7586,27 +7588,30 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  if ((c->ts.type == BT_DERIVED && !c->attr.pointer)\n \t      || (c->ts.type == BT_CLASS && !CLASS_DATA (c)->attr.class_pointer))\n-\t    {\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t      decl, cdecl, NULL_TREE);\n+ \t    {\n+ \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+ \t\t\t\t      decl, cdecl, NULL_TREE);\n \n \t      /* The finalizer frees allocatable components.  */\n \t      called_dealloc_with_status\n-\t\t= gfc_add_comp_finalizer_call (&tmpblock, comp, c, true);\n+\t\t= gfc_add_comp_finalizer_call (&tmpblock, comp, c,\n+\t\t\t\t\t       purpose == DEALLOCATE_ALLOC_COMP);\n \t    }\n \t  else\n \t    comp = NULL_TREE;\n \n-\t  if (c->attr.allocatable && (c->attr.dimension || c->attr.codimension)\n-\t      && !c->attr.proc_pointer)\n+\t  if (c->attr.allocatable && !c->attr.proc_pointer\n+\t      && (c->attr.dimension\n+\t\t  || (c->attr.codimension\n+\t\t      && purpose != DEALLOCATE_ALLOC_COMP_NO_CAF)))\n \t    {\n \t      if (comp == NULL_TREE)\n \t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t\tdecl, cdecl, NULL_TREE);\n \t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension, NULL);\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n-\t  else if (c->attr.allocatable)\n+\t  else if (c->attr.allocatable && !c->attr.codimension)\n \t    {\n \t      /* Allocatable scalar components.  */\n \t      if (comp == NULL_TREE)\n@@ -7623,14 +7628,13 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n-\t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n+\t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable\n+\t\t   && (!CLASS_DATA (c)->attr.codimension\n+\t\t       || purpose != DEALLOCATE_ALLOC_COMP_NO_CAF))\n \t    {\n \t      /* Allocatable CLASS components.  */\n \n \t      /* Add reference to '_data' component.  */\n-\t      if (comp == NULL_TREE)\n-\t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t\tdecl, cdecl, NULL_TREE);\n \t      tmp = CLASS_DATA (c)->backend_decl;\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n@@ -7721,6 +7725,28 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    }\n \t  break;\n \n+\tcase COPY_ALLOC_COMP_CAF:\n+\t  if (!c->attr.codimension\n+\t      && (c->ts.type != BT_CLASS || CLASS_DATA (c)->attr.coarray_comp)\n+\t      && (c->ts.type != BT_DERIVED\n+\t\t  || !c->ts.u.derived->attr.coarray_comp))\n+\t    continue;\n+\n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype, decl,\n+\t\t\t\t  cdecl, NULL_TREE);\n+\t  dcmp = fold_build3_loc (input_location, COMPONENT_REF, ctype, dest,\n+\t\t\t\t  cdecl, NULL_TREE);\n+\t  if (c->attr.codimension)\n+\t    gfc_add_modify (&fnblock, dcmp, comp);\n+\t  else\n+\t    {\n+\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n+\t\t\t\t\t   rank, purpose);\n+\t      gfc_add_expr_to_block (&fnblock, tmp);\n+\n+\t    }\n+\t  break;\n+\n \tcase COPY_ALLOC_COMP:\n \t  if (c->attr.pointer)\n \t    continue;\n@@ -7752,18 +7778,30 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t  size_type_node, size,\n \t\t\t\t\t  fold_convert (size_type_node,\n \t\t\t\t\t\t\tnelems));\n-\t\t  src_data = gfc_conv_descriptor_data_get (src_data);\n-\t\t  dst_data = gfc_conv_descriptor_data_get (dst_data);\n \t\t}\n \t      else\n \t\tnelems = build_int_cst (size_type_node, 1);\n \n+\t      if (CLASS_DATA (c)->attr.dimension\n+\t\t  || CLASS_DATA (c)->attr.codimension)\n+\t\t{\n+\t\t  src_data = gfc_conv_descriptor_data_get (src_data);\n+\t\t  dst_data = gfc_conv_descriptor_data_get (dst_data);\n+\t\t}\n+\n \t      gfc_init_block (&tmpblock);\n \n-\t      ftn_tree = builtin_decl_explicit (BUILT_IN_MALLOC);\n-\t      tmp = build_call_expr_loc (input_location, ftn_tree, 1, size);\n-\t      gfc_add_modify (&tmpblock, dst_data,\n-\t\t\t      fold_convert (TREE_TYPE (dst_data), tmp));\n+\t      /* Coarray component have to have the same allocation status and\n+\t\t shape/type-parameter/effective-type on the LHS and RHS of an\n+\t\t intrinsic assignment. Hence, we did not deallocated them - and\n+\t\t do not allocate them here.  */\n+\t      if (!CLASS_DATA (c)->attr.codimension)\n+\t\t{\n+\t\t  ftn_tree = builtin_decl_explicit (BUILT_IN_MALLOC);\n+\t\t  tmp = build_call_expr_loc (input_location, ftn_tree, 1, size);\n+\t\t  gfc_add_modify (&tmpblock, dst_data,\n+\t\t\t\t  fold_convert (TREE_TYPE (dst_data), tmp));\n+\t\t}\n \n \t      tmp = gfc_copy_class_to_class (comp, dcmp, nelems);\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n@@ -7788,7 +7826,10 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      && !cmp_has_alloc_comps)\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank);\n+\t      if (c->attr.codimension)\n+\t\ttmp = gfc_copy_allocatable_data (dcmp, comp, ctype, rank);\n+\t      else\n+\t\ttmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \n@@ -7834,6 +7875,26 @@ gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n }\n \n \n+/* Recursively traverse an object of derived type, generating code to\n+   deallocate allocatable components.  But do not deallocate coarrays.\n+   To be used for intrinsic assignment, which may not change the allocation\n+   status of coarrays.  */\n+\n+tree\n+gfc_deallocate_alloc_comp_no_caf (gfc_symbol * der_type, tree decl, int rank)\n+{\n+  return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n+\t\t\t\tDEALLOCATE_ALLOC_COMP_NO_CAF);\n+}\n+\n+\n+tree\n+gfc_reassign_alloc_comp_caf (gfc_symbol *der_type, tree decl, tree dest)\n+{\n+  return structure_alloc_comps (der_type, decl, dest, 0, COPY_ALLOC_COMP_CAF);\n+}\n+\n+\n /* Recursively traverse an object of derived type, generating code to\n    copy it and its allocatable components.  */\n \n@@ -8267,8 +8328,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   if ((expr1->ts.type == BT_DERIVED)\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n     {\n-      tmp = gfc_deallocate_alloc_comp (expr1->ts.u.derived, old_desc,\n-\t\t\t\t       expr1->rank);\n+      tmp = gfc_deallocate_alloc_comp_no_caf (expr1->ts.u.derived, old_desc,\n+\t\t\t\t\t      expr1->rank);\n       gfc_add_expr_to_block (&realloc_block, tmp);\n     }\n "}, {"sha": "e8f207e2fb2e6dbf941fc4c3575ba70c0e043673", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -51,6 +51,8 @@ tree gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank);\n tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int);\n \n tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int);\n+tree gfc_deallocate_alloc_comp_no_caf (gfc_symbol *, tree, int);\n+tree gfc_reassign_alloc_comp_caf (gfc_symbol *, tree, tree);\n \n tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int);\n "}, {"sha": "e1ed9d95b4308de13b6b82f59d74655ba1d02f07", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -6824,6 +6824,7 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n     }\n   else if (ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n+      tree tmp_var = NULL_TREE;\n       cond = NULL_TREE;\n \n       /* Are the rhs and the lhs the same?  */\n@@ -6841,8 +6842,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t expression.  */\n       if (!l_is_temp && dealloc)\n \t{\n-\t  tmp = gfc_evaluate_now (lse->expr, &lse->pre);\n-\t  tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);\n+\t  tmp_var = gfc_evaluate_now (lse->expr, &lse->pre);\n+\t  tmp = gfc_deallocate_alloc_comp_no_caf (ts.u.derived, tmp_var, 0);\n \t  if (deep_copy)\n \t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n \t\t\t    tmp);\n@@ -6855,6 +6856,16 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_add_modify (&block, lse->expr,\n \t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n \n+      /* Restore pointer address of coarray components.  */\n+      if (ts.u.derived->attr.coarray_comp && deep_copy)\n+\t{\n+\t  gcc_assert (tmp_var != NULL_TREE);\n+\t  tmp = gfc_reassign_alloc_comp_caf (ts.u.derived, tmp_var, lse->expr);\n+\t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n+\t\t\t  tmp);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+\n       /* Do a deep copy if the rhs is a variable, if it is not the\n \t same as the lhs.  */\n       if (deep_copy)\n@@ -7196,8 +7207,8 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n     {\n       tree tmp;\n-      tmp = gfc_deallocate_alloc_comp (expr1->ts.u.derived, se.expr,\n-\t\t\t\t       expr1->rank);\n+      tmp = gfc_deallocate_alloc_comp_no_caf (expr1->ts.u.derived, se.expr,\n+\t\t\t\t\t      expr1->rank);\n       gfc_add_expr_to_block (&se.pre, tmp);\n     }\n \n@@ -7762,7 +7773,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t       && expr1->rank && !expr2->rank);\n   if (scalar_to_array && dealloc)\n     {\n-      tmp = gfc_deallocate_alloc_comp (expr2->ts.u.derived, rse.expr, 0);\n+      tmp = gfc_deallocate_alloc_comp_no_caf (expr2->ts.u.derived, rse.expr, 0);\n       gfc_add_expr_to_block (&loop.post, tmp);\n     }\n "}, {"sha": "3ec449ade4197933ea46b5006721d4e8b5829899", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -1,3 +1,9 @@\n+2013-07-15  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_lib_realloc_1.f90: New.\n+\t* gfortran.dg/coarray/lib_realloc_1.f90: New.\n+\t* gfortran.dg/coarray_6.f90: Add dg-error.\n+\n 2013-07-15  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/37336"}, {"sha": "ed906f5a13412eead1936eb8c05f767e95eed888", "filename": "gcc/testsuite/gfortran.dg/coarray/lib_realloc_1.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flib_realloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flib_realloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flib_realloc_1.f90?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+! { dg-options \"-O0\" }\n+!\n+! Test that for CAF components _gfortran_caf_deregister is called\n+! Test that norealloc happens for CAF components during assignment\n+!\n+module m\n+type t\n+  integer, allocatable :: CAF[:]\n+end type t\n+end module m\n+\n+program main\n+use m\n+type(t), target :: x,y\n+integer, pointer :: ptr\n+allocate(x%caf[*], y%caf[*])\n+ptr => y%caf\n+ptr = 6\n+if (.not.allocated(x%caf)) call abort()\n+if (.not.allocated(y%caf)) call abort()\n+if (y%caf /= 6) call abort ()\n+x = y\n+if (x%caf /= 6) call abort ()\n+if (.not. associated (ptr,y%caf)) call abort()\n+if (associated (ptr,x%caf)) call abort()\n+ptr = 123\n+if (y%caf /= 123) call abort ()\n+if (x%caf /= 6) call abort ()\n+end program main"}, {"sha": "f44ac01597a3dd5b167be153f481e7dbdea506e2", "filename": "gcc/testsuite/gfortran.dg/coarray_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_6.f90?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -75,7 +75,7 @@ subroutine valid(a)\n   type t2\n     type(t) :: b\n   end type t2\n-  type(t2), save :: xt2[*]\n+  type(t2), save :: xt2[*] ! { dg-error \"nonpointer, nonallocatable scalar, which is not a coarray\" }\n end subroutine valid\n \n program main"}, {"sha": "60d4456323f202d038ee112096f597a16b0166ef", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_realloc_1.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_realloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abc2d8074ae190486e3f620075e25498c1b2791c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_realloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_realloc_1.f90?ref=abc2d8074ae190486e3f620075e25498c1b2791c", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib\" }\n+!\n+! PR fortran/52052\n+!\n+! Test that for CAF components _gfortran_caf_deregister is called\n+! Test that norealloc happens for CAF components during assignment\n+!\n+module m\n+type t\n+  integer, allocatable :: CAF[:]\n+  integer, allocatable :: ii\n+end type t\n+end module m\n+\n+subroutine foo()\n+use m\n+type(t) :: x,y\n+if (allocated(x%caf)) call abort()\n+x = y\n+end\n+\n+! For comp%ii: End of scope of x + y (2x) and for the LHS of the assignment (1x)\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 3 \"original\" } }\n+\n+! For comp%CAF:  End of scope of x + y (2x); no LHS freeing for the CAF in assignment\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister\" 2 \"original\" } }\n+\n+! Only malloc \"ii\":\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 1 \"original\" } }\n+\n+! But copy \"ii\" and \"CAF\":\n+! { dg-final { scan-tree-dump-times \"__builtin_memcpy\" 2 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}