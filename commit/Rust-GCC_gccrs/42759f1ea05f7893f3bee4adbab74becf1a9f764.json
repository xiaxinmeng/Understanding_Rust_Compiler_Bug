{"sha": "42759f1ea05f7893f3bee4adbab74becf1a9f764", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI3NTlmMWVhMDVmNzg5M2YzYmVlNGFkYmFiNzRiZWNmMWE5Zjc2NA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-16T21:29:43Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-16T21:29:43Z"}, "message": "Makefile.in (tree-cfg.o): Add CFGLAYOUT_H dependency.\n\n\t* Makefile.in (tree-cfg.o): Add CFGLAYOUT_H dependency.\n\t* basic-block.h (get_dominated_by_region): Declare.\n\t* dominance.c (get_dominated_by_region): New function.\n\t* tree-cfg.c: Include cfglayout.h.\n\t(tree_duplicate_bb): Duplicate also phi nodes.\n\t(struct ssa_name_map_entry): New type.\n\t(add_phi_args_after_copy_bb, add_phi_args_after_copy,\n\tssa_name_map_entry_hash, ssa_name_map_entry_eq,\n\tallocate_ssa_names, rewrite_to_new_ssa_names_def,\n\trewrite_to_new_ssa_names_use, rewrite_to_new_ssa_names_bb,\n\trewrite_to_new_ssa_names, tree_duplicate_sese_region): New functions.\n\t* tree-flow.h (tree_duplicate_sese_region, add_phi_args_after_copy_bb,\n\tadd_phi_args_after_copy, rewrite_to_new_ssa_names_bb,\n\trewrite_to_new_ssa_names, allocate_ssa_names,\n\trewrite_into_loop_closed_ssa, verify_loop_closed_ssa): Declare.\n\t* tree-ssa-loop-ch.c (duplicate_blocks): Removed.\n\t(copy_loop_headers): Use tree_duplicate_sese_region.\n\n\t* gcc.dg/tree-ssa/copy-headers.c: Update outcome.\n\nFrom-SVN: r87614", "tree": {"sha": "5d0332daba22aa87d85d5e5174a5bd80e35b53fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d0332daba22aa87d85d5e5174a5bd80e35b53fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42759f1ea05f7893f3bee4adbab74becf1a9f764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42759f1ea05f7893f3bee4adbab74becf1a9f764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42759f1ea05f7893f3bee4adbab74becf1a9f764", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42759f1ea05f7893f3bee4adbab74becf1a9f764/comments", "author": null, "committer": null, "parents": [{"sha": "2731cf24d22fbc55453b74a5498f72ce5c41a52b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2731cf24d22fbc55453b74a5498f72ce5c41a52b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2731cf24d22fbc55453b74a5498f72ce5c41a52b"}], "stats": {"total": 593, "additions": 504, "deletions": 89}, "files": [{"sha": "3d6a38c931603d9b3498b7096990f6396d5ad2d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -1,3 +1,23 @@\n+2004-09-16  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (tree-cfg.o): Add CFGLAYOUT_H dependency.\n+\t* basic-block.h (get_dominated_by_region): Declare.\n+\t* dominance.c (get_dominated_by_region): New function.\n+\t* tree-cfg.c: Include cfglayout.h.\n+\t(tree_duplicate_bb): Duplicate also phi nodes.\n+\t(struct ssa_name_map_entry): New type.\n+\t(add_phi_args_after_copy_bb, add_phi_args_after_copy,\n+\tssa_name_map_entry_hash, ssa_name_map_entry_eq,\n+\tallocate_ssa_names, rewrite_to_new_ssa_names_def,\n+\trewrite_to_new_ssa_names_use, rewrite_to_new_ssa_names_bb,\n+\trewrite_to_new_ssa_names, tree_duplicate_sese_region): New functions.\n+\t* tree-flow.h (tree_duplicate_sese_region, add_phi_args_after_copy_bb,\n+\tadd_phi_args_after_copy, rewrite_to_new_ssa_names_bb,\n+\trewrite_to_new_ssa_names, allocate_ssa_names,\n+\trewrite_into_loop_closed_ssa, verify_loop_closed_ssa): Declare.\n+\t* tree-ssa-loop-ch.c (duplicate_blocks): Removed.\n+\t(copy_loop_headers): Use tree_duplicate_sese_region.\n+\n 2004-09-16  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* profile.c (branch_prob): Restore support for USE_MAPPED_LOCATION."}, {"sha": "44d714061f38e4c527797058e8b77a3b2220d8c7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -1667,7 +1667,8 @@ tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n-   $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) gt-tree-cfg.h tree-pass.h\n+   $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) gt-tree-cfg.h tree-pass.h \\\n+   $(CFGLAYOUT_H)\n tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) function.h $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) diagnostic.h except.h tree-pass.h $(FLAGS_H) langhooks.h"}, {"sha": "05baeba75a29da2182201574a827806d49000233", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -732,6 +732,8 @@ extern void set_immediate_dominator (enum cdi_direction, basic_block,\n extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n extern bool dominated_by_p (enum cdi_direction, basic_block, basic_block);\n extern int get_dominated_by (enum cdi_direction, basic_block, basic_block **);\n+extern unsigned get_dominated_by_region (enum cdi_direction, basic_block *,\n+\t\t\t\t\t unsigned, basic_block *);\n extern void add_to_dominance_info (enum cdi_direction, basic_block);\n extern void delete_from_dominance_info (enum cdi_direction, basic_block);\n basic_block recount_dominator (enum cdi_direction, basic_block);"}, {"sha": "278254719af907232cebda09c588e8fccf3ee258", "filename": "gcc/dominance.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -738,6 +738,32 @@ get_dominated_by (enum cdi_direction dir, basic_block bb, basic_block **bbs)\n   return n;\n }\n \n+/* Find all basic blocks that are immediately dominated (in direction DIR)\n+   by some block between N_REGION ones stored in REGION, except for blocks\n+   in the REGION itself.  The found blocks are stored to DOMS and their number\n+   is returned.  */\n+\n+unsigned\n+get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n+\t\t\t unsigned n_region, basic_block *doms)\n+{\n+  unsigned n_doms = 0, i;\n+  basic_block dom;\n+\n+  for (i = 0; i < n_region; i++)\n+    region[i]->rbi->duplicated = 1;\n+  for (i = 0; i < n_region; i++)\n+    for (dom = first_dom_son (dir, region[i]);\n+\t dom;\n+\t dom = next_dom_son (dir, dom))\n+      if (!dom->rbi->duplicated)\n+\tdoms[n_doms++] = dom;\n+  for (i = 0; i < n_region; i++)\n+    region[i]->rbi->duplicated = 0;\n+\n+  return n_doms;\n+}\n+\n /* Redirect all edges pointing to BB to TO.  */\n void\n redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,"}, {"sha": "88ebcdc0c5248c7167615709a153c683922f2dba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -1,3 +1,7 @@\n+2004-09-16  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcc.dg/tree-ssa/copy-headers.c: Update outcome.\n+\n 2004-09-16  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* gcc.misc-tests/bprob.exp, g++.dg/bprob/bprob.exp: Iterate tests"}, {"sha": "4241b40835eeb342568aabbe1ab6be3626855fba", "filename": "gcc/testsuite/gcc.dg/tree-ssa/copy-headers.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcopy-headers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcopy-headers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcopy-headers.c?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -11,5 +11,5 @@ void bla (void)\n     foo (i);\n }\n \n-/* There should be a header scheduled for duplication.  */\n-/* { dg-final { scan-tree-dump-times \"Scheduled\" 1 \"ch\"} } */\n+/* There should be a header duplicated.  */\n+/* { dg-final { scan-tree-dump-times \"Duplicating header\" 1 \"ch\"} } */"}, {"sha": "f7c5155b6b7e6702c74d974db4c4a059bbbf76f9", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 394, "deletions": 1, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"cfgloop.h\"\n+#include \"cfglayout.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -4237,7 +4238,6 @@ tree_can_duplicate_bb_p (basic_block bb ATTRIBUTE_UNUSED)\n   return true;\n }\n \n-\n /* Create a duplicate of the basic block BB.  NOTE: This does not\n    preserve SSA form.  */\n \n@@ -4251,10 +4251,15 @@ tree_duplicate_bb (basic_block bb)\n \n   new_bb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n \n+  /* First copy the phi nodes.  We do not copy phi node arguments here,\n+     since the edges are not ready yet.  Keep the chain of phi nodes in\n+     the same order, so that we can add them later.  */\n   for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n     {\n       mark_for_rewrite (PHI_RESULT (phi));\n+      create_phi_node (PHI_RESULT (phi), new_bb);\n     }\n+  set_phi_nodes (new_bb, nreverse (phi_nodes (new_bb)));\n \n   bsi_tgt = bsi_start (new_bb);\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n@@ -4283,6 +4288,394 @@ tree_duplicate_bb (basic_block bb)\n   return new_bb;\n }\n \n+/* Basic block BB_COPY was created by code duplication.  Add phi node\n+   arguments for edges going out of BB_COPY.  The blocks that were\n+   duplicated have rbi->duplicated set to one.  */\n+\n+void\n+add_phi_args_after_copy_bb (basic_block bb_copy)\n+{\n+  basic_block bb, dest;\n+  edge e, e_copy;\n+  tree phi, phi_copy, phi_next, def;\n+      \n+  bb = bb_copy->rbi->original;\n+\n+  for (e_copy = bb_copy->succ; e_copy; e_copy = e_copy->succ_next)\n+    {\n+      if (!phi_nodes (e_copy->dest))\n+\tcontinue;\n+\n+      if (e_copy->dest->rbi->duplicated)\n+\tdest = e_copy->dest->rbi->original;\n+      else\n+\tdest = e_copy->dest;\n+\n+      e = find_edge (bb, dest);\n+      if (!e)\n+\t{\n+\t  /* During loop unrolling the target of the latch edge is copied.\n+\t     In this case we are not looking for edge to dest, but to\n+\t     duplicated block whose original was dest.  */\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (e->dest->rbi->duplicated\n+\t\t&& e->dest->rbi->original == dest)\n+\t      break;\n+\n+\t  gcc_assert (e != NULL);\n+\t}\n+\n+      for (phi = phi_nodes (e->dest), phi_copy = phi_nodes (e_copy->dest);\n+\t   phi;\n+\t   phi = phi_next, phi_copy = TREE_CHAIN (phi_copy))\n+\t{\n+\t  phi_next = TREE_CHAIN (phi);\n+\n+\t  gcc_assert (PHI_RESULT (phi) == PHI_RESULT (phi_copy));\n+\t  def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t  add_phi_arg (&phi_copy, def, e_copy);\n+\t}\n+    }\n+}\n+\n+/* Blocks in REGION_COPY array of length N_REGION were created by\n+   duplication of basic blocks.  Add phi node arguments for edges\n+   going from these blocks.  */\n+\n+void\n+add_phi_args_after_copy (basic_block *region_copy, unsigned n_region)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < n_region; i++)\n+    region_copy[i]->rbi->duplicated = 1;\n+\n+  for (i = 0; i < n_region; i++)\n+    add_phi_args_after_copy_bb (region_copy[i]);\n+\n+  for (i = 0; i < n_region; i++)\n+    region_copy[i]->rbi->duplicated = 0;\n+}\n+\n+/* Maps the old ssa name FROM_NAME to TO_NAME.  */\n+\n+struct ssa_name_map_entry\n+{\n+  tree from_name;\n+  tree to_name;\n+};\n+\n+/* Hash function for ssa_name_map_entry.  */\n+\n+static hashval_t\n+ssa_name_map_entry_hash (const void *entry)\n+{\n+  const struct ssa_name_map_entry *en = entry;\n+  return SSA_NAME_VERSION (en->from_name);\n+}\n+\n+/* Equality function for ssa_name_map_entry.  */\n+\n+static int\n+ssa_name_map_entry_eq (const void *in_table, const void *ssa_name)\n+{\n+  const struct ssa_name_map_entry *en = in_table;\n+\n+  return en->from_name == ssa_name;\n+}\n+\n+/* Allocate duplicates of ssa names in list DEFINITIONS and store the mapping\n+   to MAP.  */\n+\n+void\n+allocate_ssa_names (bitmap definitions, htab_t *map)\n+{\n+  tree name;\n+  struct ssa_name_map_entry *entry;\n+  PTR *slot;\n+  unsigned ver;\n+\n+  if (!*map)\n+    *map = htab_create (10, ssa_name_map_entry_hash,\n+\t\t\tssa_name_map_entry_eq, free);\n+  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver,\n+    {\n+      name = ssa_name (ver);\n+      slot = htab_find_slot_with_hash (*map, name, SSA_NAME_VERSION (name),\n+\t\t\t\t       INSERT);\n+      if (*slot)\n+\tentry = *slot;\n+      else\n+\t{\n+\t  entry = xmalloc (sizeof (struct ssa_name_map_entry));\n+\t  entry->from_name = name;\n+\t  *slot = entry;\n+\t}\n+      entry->to_name = duplicate_ssa_name (name, SSA_NAME_DEF_STMT (name));\n+    });\n+}\n+\n+/* Rewrite the definition DEF in statement STMT to new ssa name as specified\n+   by the mapping MAP.  */\n+\n+static void\n+rewrite_to_new_ssa_names_def (def_operand_p def, tree stmt, htab_t map)\n+{\n+  tree name = DEF_FROM_PTR (def);\n+  struct ssa_name_map_entry *entry;\n+\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  entry = htab_find_with_hash (map, name, SSA_NAME_VERSION (name));\n+  if (!entry)\n+    return;\n+\n+  SET_DEF (def, entry->to_name);\n+  SSA_NAME_DEF_STMT (entry->to_name) = stmt;\n+}\n+\n+/* Rewrite the USE to new ssa name as specified by the mapping MAP.  */\n+\n+static void\n+rewrite_to_new_ssa_names_use (use_operand_p use, htab_t map)\n+{\n+  tree name = USE_FROM_PTR (use);\n+  struct ssa_name_map_entry *entry;\n+\n+  if (TREE_CODE (name) != SSA_NAME)\n+    return;\n+\n+  entry = htab_find_with_hash (map, name, SSA_NAME_VERSION (name));\n+  if (!entry)\n+    return;\n+\n+  SET_USE (use, entry->to_name);\n+}\n+\n+/* Rewrite the ssa names in basic block BB to new ones as specified by the\n+   mapping MAP.  */\n+\n+void\n+rewrite_to_new_ssa_names_bb (basic_block bb, htab_t map)\n+{\n+  unsigned i;\n+  edge e;\n+  tree phi, stmt;\n+  block_stmt_iterator bsi;\n+  use_optype uses;\n+  vuse_optype vuses;\n+  def_optype defs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  stmt_ann_t ann;\n+\n+  for (e = bb->pred; e; e = e->pred_next)\n+    if (e->flags & EDGE_ABNORMAL)\n+      break;\n+\n+  for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+    {\n+      rewrite_to_new_ssa_names_def (PHI_RESULT_PTR (phi), phi, map);\n+      if (e)\n+\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)) = 1;\n+    }\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+      get_stmt_operands (stmt);\n+      ann = stmt_ann (stmt);\n+\n+      uses = USE_OPS (ann);\n+      for (i = 0; i < NUM_USES (uses); i++)\n+\trewrite_to_new_ssa_names_use (USE_OP_PTR (uses, i), map);\n+\n+      defs = DEF_OPS (ann);\n+      for (i = 0; i < NUM_DEFS (defs); i++)\n+\trewrite_to_new_ssa_names_def (DEF_OP_PTR (defs, i), stmt, map);\n+\n+      vuses = VUSE_OPS (ann);\n+      for (i = 0; i < NUM_VUSES (vuses); i++)\n+\trewrite_to_new_ssa_names_use (VUSE_OP_PTR (vuses, i), map);\n+\n+      v_may_defs = V_MAY_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t{\n+\t  rewrite_to_new_ssa_names_use\n+\t\t  (V_MAY_DEF_OP_PTR (v_may_defs, i), map);\n+\t  rewrite_to_new_ssa_names_def\n+\t\t  (V_MAY_DEF_RESULT_PTR (v_may_defs, i), stmt, map);\n+\t}\n+\n+      v_must_defs = V_MUST_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\trewrite_to_new_ssa_names_def\n+\t\t(V_MUST_DEF_OP_PTR (v_must_defs, i), stmt, map);\n+    }\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n+      {\n+\trewrite_to_new_ssa_names_use\n+\t\t(PHI_ARG_DEF_PTR_FROM_EDGE (phi, e), map);\n+\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    tree op = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op) = 1;\n+\t  }\n+      }\n+}\n+\n+/* Rewrite the ssa names in N_REGION blocks REGION to the new ones as specified\n+   by the mapping MAP.  */\n+\n+void\n+rewrite_to_new_ssa_names (basic_block *region, unsigned n_region, htab_t map)\n+{\n+  unsigned r;\n+\n+  for (r = 0; r < n_region; r++)\n+    rewrite_to_new_ssa_names_bb (region[r], map);\n+}\n+\n+/* Duplicates a REGION (set of N_REGION basic blocks) with just a single\n+   important exit edge EXIT.  By important we mean that no SSA name defined\n+   inside region is live over the other exit edges of the region.  All entry\n+   edges to the region must go to ENTRY->dest.  The edge ENTRY is redirected\n+   to the duplicate of the region.  SSA form, dominance and loop information\n+   is updated.  The new basic blocks are stored to REGION_COPY in the same\n+   order as they had in REGION, provided that REGION_COPY is not NULL.\n+   The function returns false if it is unable to copy the region,\n+   true otherwise.  */\n+\n+bool\n+tree_duplicate_sese_region (edge entry, edge exit,\n+\t\t\t    basic_block *region, unsigned n_region,\n+\t\t\t    basic_block *region_copy)\n+{\n+  unsigned i, n_doms, ver;\n+  bool free_region_copy = false, copying_header = false;\n+  struct loop *loop = entry->dest->loop_father;\n+  edge exit_copy;\n+  bitmap definitions;\n+  tree phi, var;\n+  basic_block *doms;\n+  htab_t ssa_name_map = NULL;\n+  edge redirected;\n+\n+  if (!can_copy_bbs_p (region, n_region))\n+    return false;\n+\n+  /* Some sanity checking.  Note that we do not check for all possible\n+     missuses of the functions.  I.e. if you ask to copy something weird,\n+     it will work, but the state of structures probably will not be\n+     correct.  */\n+\n+  for (i = 0; i < n_region; i++)\n+    {\n+      /* We do not handle subloops, i.e. all the blocks must belong to the\n+\t same loop.  */\n+      if (region[i]->loop_father != loop)\n+\treturn false;\n+\n+      if (region[i] != entry->dest\n+\t  && region[i] == loop->header)\n+\treturn false;\n+    }\n+\n+  loop->copy = loop;\n+\n+  /* In case the function is used for loop header copying (which is the primary\n+     use), ensure that EXIT and its copy will be new latch and entry edges.  */\n+  if (loop->header == entry->dest)\n+    {\n+      copying_header = true;\n+      loop->copy = loop->outer;\n+\n+      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, exit->src))\n+\treturn false;\n+\n+      for (i = 0; i < n_region; i++)\n+\tif (region[i] != exit->src\n+\t    && dominated_by_p (CDI_DOMINATORS, region[i], exit->src))\n+\t  return false;\n+    }\n+\n+  if (!region_copy)\n+    {\n+      region_copy = xmalloc (sizeof (basic_block) * n_region);\n+      free_region_copy = true;\n+    }\n+\n+  gcc_assert (!any_marked_for_rewrite_p ());\n+\n+  /* Record blocks outside the region that are duplicated by something\n+     inside.  */\n+  doms = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  n_doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region, doms);\n+\n+  copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop);\n+  definitions = marked_ssa_names ();\n+\n+  if (copying_header)\n+    {\n+      loop->header = exit->dest;\n+      loop->latch = exit->src;\n+    }\n+\n+  /* Redirect the entry and add the phi node arguments.  */\n+  redirected = redirect_edge_and_branch (entry, entry->dest->rbi->copy);\n+  gcc_assert (redirected != NULL);\n+  for (phi = phi_nodes (entry->dest), var = PENDING_STMT (entry);\n+       phi;\n+       phi = TREE_CHAIN (phi), var = TREE_CHAIN (var))\n+    add_phi_arg (&phi, TREE_VALUE (var), entry);\n+  PENDING_STMT (entry) = NULL;\n+\n+  /* Concerning updating of dominators:  We must recount dominators\n+     for entry block and its copy.  Anything that is outside of the region, but\n+     was dominated by something inside needs recounting as well.  */\n+  set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n+  doms[n_doms++] = entry->dest->rbi->original;\n+  iterate_fix_dominators (CDI_DOMINATORS, doms, n_doms);\n+  free (doms);\n+\n+  /* Add the other phi node arguments.  */\n+  add_phi_args_after_copy (region_copy, n_region);\n+\n+  /* Add phi nodes for definitions at exit.  TODO -- once we have immediate\n+     uses, it should be possible to emit phi nodes just for definitions that\n+     are used outside region.  */\n+  EXECUTE_IF_SET_IN_BITMAP (definitions, 0, ver,\n+    {\n+      tree name = ssa_name (ver);\n+\n+      phi = create_phi_node (name, exit->dest);\n+      add_phi_arg (&phi, name, exit);\n+      add_phi_arg (&phi, name, exit_copy);\n+\n+      SSA_NAME_DEF_STMT (name) = phi;\n+    });\n+\n+  /* And create new definitions inside region and its copy.  TODO -- once we\n+     have immediate uses, it might be better to leave definitions in region\n+     unchanged, create new ssa names for phi nodes on exit, and rewrite\n+     the uses, to avoid changing the copied region.  */\n+  allocate_ssa_names (definitions, &ssa_name_map);\n+  rewrite_to_new_ssa_names (region, n_region, ssa_name_map);\n+  allocate_ssa_names (definitions, &ssa_name_map);\n+  rewrite_to_new_ssa_names (region_copy, n_region, ssa_name_map);\n+  htab_delete (ssa_name_map);\n+\n+  if (free_region_copy)\n+    free (region_copy);\n+\n+  unmark_all_for_rewrite ();\n+  BITMAP_XFREE (definitions);\n+\n+  return true;\n+}\n \n /* Dump FUNCTION_DECL FN to file FILE using FLAGS (see TDF_* in tree.h)  */\n "}, {"sha": "bdcd4aa6879da2f3d13a635a1cc0b1c0bf3c012c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -495,6 +495,13 @@ extern void clear_special_calls (void);\n extern void verify_stmts (void);\n extern tree tree_block_label (basic_block bb);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n+extern bool tree_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n+\t\t\t\t\tbasic_block *);\n+extern void add_phi_args_after_copy_bb (basic_block);\n+extern void add_phi_args_after_copy (basic_block *, unsigned);\n+extern void rewrite_to_new_ssa_names_bb (basic_block, struct htab *);\n+extern void rewrite_to_new_ssa_names (basic_block *, unsigned, htab_t);\n+extern void allocate_ssa_names (bitmap, struct htab **);\n extern bool tree_purge_dead_eh_edges (basic_block);\n extern bool tree_purge_all_dead_eh_edges (bitmap);\n extern tree gimplify_val (block_stmt_iterator *, tree, tree);"}, {"sha": "6ba77daf2b1e47d50883c49074c5d5c269485083", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 47, "deletions": 85, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42759f1ea05f7893f3bee4adbab74becf1a9f764/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=42759f1ea05f7893f3bee4adbab74becf1a9f764", "patch": "@@ -98,59 +98,6 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n   return true;\n }\n \n-/* Duplicates destinations of edges in BBS_TO_DUPLICATE.  */\n-\n-static void\n-duplicate_blocks (varray_type bbs_to_duplicate)\n-{\n-  unsigned i;\n-  edge preheader_edge, e, e1;\n-  basic_block header, new_header;\n-  tree phi, new_phi, var;\n-\n-  /* TODO: It should be quite easy to keep the dominance information\n-     up-to-date.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (bbs_to_duplicate); i++)\n-    {\n-      preheader_edge = VARRAY_GENERIC_PTR_NOGC (bbs_to_duplicate, i);\n-      header = preheader_edge->dest;\n-\n-      gcc_assert (header->aux);\n-      header->aux = NULL;\n-\n-      new_header = duplicate_block (header, preheader_edge);\n-\n-      /* Create the phi nodes on on entry to new_header.  */\n-      for (phi = phi_nodes (header), var = PENDING_STMT (preheader_edge);\n-\t   phi;\n-\t   phi = TREE_CHAIN (phi), var = TREE_CHAIN (var))\n-\t{\n-\t  new_phi = create_phi_node (PHI_RESULT (phi), new_header);\n-\t  add_phi_arg (&new_phi, TREE_VALUE (var), preheader_edge);\n-\t}\n-      PENDING_STMT (preheader_edge) = NULL;\n-\n-      /* Add the phi arguments to the outgoing edges.  */\n-      for (e = header->succ; e; e = e->succ_next)\n-\t{\n-\t  for (e1 = new_header->succ; e1->dest != e->dest; e1 = e1->succ_next)\n-\t    continue;\n-\n-\t  for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n-\t    {\n-\t      tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-\t      add_phi_arg (&phi, def, e1);\n-\t    }\n-\t}\n-    }\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  rewrite_ssa_into_ssa ();\n-}\n-\n /* Checks whether LOOP is a do-while style loop.  */\n \n static bool\n@@ -183,12 +130,14 @@ copy_loop_headers (void)\n   unsigned i;\n   struct loop *loop;\n   basic_block header;\n-  edge preheader_edge;\n-  varray_type bbs_to_duplicate = NULL;\n+  edge exit;\n+  basic_block *bbs;\n+  unsigned n_bbs;\n \n   loops = loop_optimizer_init (dump_file);\n   if (!loops)\n     return;\n+  rewrite_into_loop_closed_ssa ();\n   \n   /* We do not try to keep the information about irreducible regions\n      up-to-date.  */\n@@ -198,14 +147,15 @@ copy_loop_headers (void)\n   verify_loop_structure (loops);\n #endif\n \n+  bbs = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+\n   for (i = 1; i < loops->num; i++)\n     {\n       /* Copy at most 20 insns.  */\n       int limit = 20;\n \n       loop = loops->parray[i];\n-      preheader_edge = loop_preheader_edge (loop);\n-      header = preheader_edge->dest;\n+      header = loop->header;\n \n       /* If the loop is already a do-while style one (either because it was\n \t written as such, or because jump threading transformed it into one),\n@@ -218,44 +168,56 @@ copy_loop_headers (void)\n \t like while (a && b) {...}, where we want to have both of the conditions\n \t copied.  TODO -- handle while (a || b) - like cases, by not requiring\n \t the header to have just a single successor and copying up to\n-\t postdominator. \n-\t \n-\t We do not really copy the blocks immediately, so that we do not have\n-\t to worry about updating loop structures, and also so that we do not\n-\t have to rewrite variables out of and into ssa form for each block.\n-\t Instead we just record the block into worklist and duplicate all of\n-\t them at once.  */\n+\t postdominator.  */\n+\n+      exit = NULL;\n+      n_bbs = 0;\n       while (should_duplicate_loop_header_p (header, loop, &limit))\n \t{\n-\t  if (!bbs_to_duplicate)\n-\t    VARRAY_GENERIC_PTR_NOGC_INIT (bbs_to_duplicate, 10,\n-\t\t\t\t\t  \"bbs_to_duplicate\");\n-\t  VARRAY_PUSH_GENERIC_PTR_NOGC (bbs_to_duplicate, preheader_edge);\n-\t  header->aux = &header->aux;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"Scheduled basic block %d for duplication.\\n\",\n-\t\t     header->index);\n-\n \t  /* Find a successor of header that is inside a loop; i.e. the new\n \t     header after the condition is copied.  */\n \t  if (flow_bb_inside_loop_p (loop, header->succ->dest))\n-\t    preheader_edge = header->succ;\n+\t    exit = header->succ;\n \t  else\n-\t    preheader_edge = header->succ->succ_next;\n-\t  header = preheader_edge->dest;\n+\t    exit = header->succ->succ_next;\n+\t  bbs[n_bbs++] = header;\n+\t  header = exit->dest;\n \t}\n-    }\n \n-  loop_optimizer_finalize (loops, NULL);\n+      if (!exit)\n+\tcontinue;\n \n-  if (bbs_to_duplicate)\n-    {\n-      duplicate_blocks (bbs_to_duplicate);\n-      VARRAY_FREE (bbs_to_duplicate);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Duplicating header of the loop %d up to edge %d->%d.\\n\",\n+\t\t loop->num, exit->src->index, exit->dest->index);\n+\n+      /* Ensure that the header will have just the latch as a predecessor\n+\t inside the loop.  */\n+      if (exit->dest->pred->pred_next)\n+\texit = loop_split_edge_with (exit, NULL)->succ;\n+\n+      if (!tree_duplicate_sese_region (loop_preheader_edge (loop), exit,\n+\t\t\t\t       bbs, n_bbs, NULL))\n+\t{\n+\t  fprintf (dump_file, \"Duplication failed.\\n\");\n+\t  continue;\n+\t}\n+\n+      /* Ensure that the latch and the preheader is simple (we know that they\n+\t are not now, since there was the loop exit condition.  */\n+      loop_split_edge_with (loop_preheader_edge (loop), NULL);\n+      loop_split_edge_with (loop_latch_edge (loop), NULL);\n     }\n \n+  free (bbs);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n+\n+  loop_optimizer_finalize (loops, NULL);\n+\n   /* Run cleanup_tree_cfg here regardless of whether we have done anything, so\n      that we cleanup the blocks created in order to get the loops into a\n      canonical shape.  */\n@@ -277,7 +239,7 @@ struct tree_opt_pass pass_ch =\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   TV_TREE_CH,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */"}]}