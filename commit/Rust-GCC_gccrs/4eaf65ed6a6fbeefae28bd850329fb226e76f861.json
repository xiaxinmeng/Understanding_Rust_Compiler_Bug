{"sha": "4eaf65ed6a6fbeefae28bd850329fb226e76f861", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVhZjY1ZWQ2YTZmYmVlZmFlMjhiZDg1MDMyOWZiMjI2ZTc2Zjg2MQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-03-11T11:08:49Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-05-24T13:38:09Z"}, "message": "arm: Auto-vectorization for MVE: vld4/vst4\n\nThis patch enables MVE vld4/vst4 instructions for auto-vectorization.\nWe move the existing expanders from neon.md and enable them for MVE,\ncalling the respective emitter.\n\n2021-03-12  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/neon.md (vec_load_lanesxi<mode>)\n\t(vec_store_lanexoi<mode>): Move ...\n\t* config/arm/vec-common.md: here.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/simd/mve-vld4.c: New test, derived from\n\tslp-perm-3.c", "tree": {"sha": "b71bee81bc4ba41043bad313727715559ea3b6c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b71bee81bc4ba41043bad313727715559ea3b6c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eaf65ed6a6fbeefae28bd850329fb226e76f861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eaf65ed6a6fbeefae28bd850329fb226e76f861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eaf65ed6a6fbeefae28bd850329fb226e76f861", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eaf65ed6a6fbeefae28bd850329fb226e76f861/comments", "author": null, "committer": null, "parents": [{"sha": "5ba5e856f327b1d6b69d51a11ef63ce89bfbc868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ba5e856f327b1d6b69d51a11ef63ce89bfbc868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ba5e856f327b1d6b69d51a11ef63ce89bfbc868"}], "stats": {"total": 186, "additions": 166, "deletions": 20}, "files": [{"sha": "977adef5490f565ed2fd111a3217b2e9d8e33216", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eaf65ed6a6fbeefae28bd850329fb226e76f861/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eaf65ed6a6fbeefae28bd850329fb226e76f861/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=4eaf65ed6a6fbeefae28bd850329fb226e76f861", "patch": "@@ -5620,16 +5620,6 @@ if (BYTES_BIG_ENDIAN)\n                     (const_string \"neon_load4_4reg<q>\")))]\n )\n \n-(define_expand \"vec_load_lanesxi<mode>\"\n-  [(match_operand:XI 0 \"s_register_operand\")\n-   (match_operand:XI 1 \"neon_struct_operand\")\n-   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n-  \"TARGET_NEON\"\n-{\n-  emit_insn (gen_neon_vld4<mode> (operands[0], operands[1]));\n-  DONE;\n-})\n-\n (define_expand \"neon_vld4<mode>\"\n   [(match_operand:XI 0 \"s_register_operand\")\n    (match_operand:XI 1 \"neon_struct_operand\")\n@@ -5821,16 +5811,6 @@ if (BYTES_BIG_ENDIAN)\n                     (const_string \"neon_store4_4reg<q>\")))]\n )\n \n-(define_expand \"vec_store_lanesxi<mode>\"\n-  [(match_operand:XI 0 \"neon_struct_operand\")\n-   (match_operand:XI 1 \"s_register_operand\")\n-   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n-  \"TARGET_NEON\"\n-{\n-  emit_insn (gen_neon_vst4<mode> (operands[0], operands[1]));\n-  DONE;\n-})\n-\n (define_expand \"neon_vst4<mode>\"\n   [(match_operand:XI 0 \"neon_struct_operand\")\n    (match_operand:XI 1 \"s_register_operand\")"}, {"sha": "e8b2901b0069c29260f5e9d3e8ff0c8ba1cf9316", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eaf65ed6a6fbeefae28bd850329fb226e76f861/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eaf65ed6a6fbeefae28bd850329fb226e76f861/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=4eaf65ed6a6fbeefae28bd850329fb226e76f861", "patch": "@@ -513,3 +513,29 @@\n     emit_insn (gen_mve_vst2q<mode> (operands[0], operands[1]));\n   DONE;\n })\n+\n+(define_expand \"vec_load_lanesxi<mode>\"\n+  [(match_operand:XI 0 \"s_register_operand\")\n+   (match_operand:XI 1 \"neon_struct_operand\")\n+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n+  \"TARGET_NEON || TARGET_HAVE_MVE\"\n+{\n+  if (TARGET_NEON)\n+    emit_insn (gen_neon_vld4<mode> (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_mve_vld4q<mode> (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_store_lanesxi<mode>\"\n+  [(match_operand:XI 0 \"neon_struct_operand\")\n+   (match_operand:XI 1 \"s_register_operand\")\n+   (unspec:VQ2 [(const_int 0)] UNSPEC_VSTRUCTDUMMY)]\n+  \"TARGET_NEON || TARGET_HAVE_MVE\"\n+{\n+  if (TARGET_NEON)\n+    emit_insn (gen_neon_vst4<mode> (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_mve_vst4q<mode> (operands[0], operands[1]));\n+  DONE;\n+})"}, {"sha": "ce3e7559ceae6752f7b122856121837b418e2391", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vld4.c", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eaf65ed6a6fbeefae28bd850329fb226e76f861/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vld4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eaf65ed6a6fbeefae28bd850329fb226e76f861/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vld4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vld4.c?ref=4eaf65ed6a6fbeefae28bd850329fb226e76f861", "patch": "@@ -0,0 +1,140 @@\n+/* { dg-do assemble } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define M00 100\n+#define M10 216\n+#define M20 23\n+#define M30 237\n+#define M01 1322\n+#define M11 13\n+#define M21 27271\n+#define M31 2280\n+#define M02 74\n+#define M12 191\n+#define M22 500\n+#define M32 111\n+#define M03 134\n+#define M13 117\n+#define M23 11\n+#define M33 771\n+\n+#define N 128\n+\n+/* Integer tests.  */\n+#define FUNC(SIGN, TYPE, BITS)\t\t\t\t\t\t\\\n+  void foo_##SIGN##BITS##x (TYPE##BITS##_t *__restrict__ pInput,\t\\\n+\t\t\t    TYPE##BITS##_t *__restrict__ pOutput)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int i;\t\t\t\t\t\t\t\\\n+    TYPE##BITS##_t  a, b, c, d;\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i < N / BITS; i++)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta = *pInput++;\t\t\t\t\t\t\t\\\n+\tb = *pInput++;\t\t\t\t\t\t\t\\\n+\tc = *pInput++;\t\t\t\t\t\t\t\\\n+\td = *pInput++;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t*pOutput++ = M00 * a + M01 * b + M02 * c + M03 * d;\t\t\\\n+\t*pOutput++ = M10 * a + M11 * b + M12 * c + M13 * d;\t\t\\\n+\t*pOutput++ = M20 * a + M21 * b + M22 * c + M23 * d;\t\t\\\n+\t*pOutput++ = M30 * a + M31 * b + M32 * c + M33 * d;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FUNC(s, int, 8)\n+FUNC(u, uint, 8)\n+FUNC(s, int, 16)\n+FUNC(u, uint, 16)\n+FUNC(s, int, 32)\n+FUNC(u, uint, 32)\n+\n+/* float test, keep the macro because it's similar to the above, but does not\n+   need the ##BITS##_t.  */\n+#define FUNC_FLOAT(SIGN, TYPE, BITS)\t\t\t\t\t\t\\\n+  void foo_##SIGN##BITS##x (TYPE *__restrict__ pInput,\t\t\t\\\n+\t\t\t    TYPE *__restrict__ pOutput)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int i;\t\t\t\t\t\t\t\\\n+    TYPE a, b, c, d;\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i < N / BITS; i++)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta = *pInput++;\t\t\t\t\t\t\t\\\n+\tb = *pInput++;\t\t\t\t\t\t\t\\\n+\tc = *pInput++;\t\t\t\t\t\t\t\\\n+\td = *pInput++;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t*pOutput++ = M00 * a + M01 * b + M02 * c + M03 * d;\t\t\\\n+\t*pOutput++ = M10 * a + M11 * b + M12 * c + M13 * d;\t\t\\\n+\t*pOutput++ = M20 * a + M21 * b + M22 * c + M23 * d;\t\t\\\n+\t*pOutput++ = M30 * a + M31 * b + M32 * c + M33 * d;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FUNC_FLOAT(f, float, 32)\n+\n+/* __fp16 test, needs explicit casts to avoid conversions to floating-point and\n+   failure to vectorize.  */\n+__fp16 M00_fp16 = 100.0f16;\n+__fp16 M10_fp16 = 216.0f16;\n+__fp16 M20_fp16 = 23.0f16;\n+__fp16 M30_fp16 = 237.0f16;\n+__fp16 M01_fp16 = 1322.0f16;\n+__fp16 M11_fp16 = 13.0f16;\n+__fp16 M21_fp16 = 27271.0f16;\n+__fp16 M31_fp16 = 2280.0f16;\n+__fp16 M02_fp16 = 74.0f16;\n+__fp16 M12_fp16 = 191.0f16;\n+__fp16 M22_fp16 = 500.0f16;\n+__fp16 M32_fp16 = 111.0f16;\n+__fp16 M03_fp16 = 134.0f16;\n+__fp16 M13_fp16 = 117.0f16;\n+__fp16 M23_fp16 = 11.0f16;\n+__fp16 M33_fp16 = 771.0f16;\n+\n+#define FUNC_FLOAT_FP16(SIGN, TYPE, BITS)\t\t\t\t\\\n+  void foo_##SIGN##BITS##x (TYPE *__restrict__ pInput,\t\t\t\\\n+\t\t\t    TYPE *__restrict__ pOutput)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int i;\t\t\t\t\t\t\t\\\n+    TYPE a, b, c, d;\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    for (i = 0; i < N / BITS; i++)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta = *pInput++;\t\t\t\t\t\t\t\\\n+\tb = *pInput++;\t\t\t\t\t\t\t\\\n+\tc = *pInput++;\t\t\t\t\t\t\t\\\n+\td = *pInput++;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tTYPE ab, cd;\t\t\t\t\t\t\t\\\n+\tab = (__fp16)(M00_fp16 * a) + (__fp16)(M01_fp16 * b);\t\t\\\n+\tcd = (__fp16)(M02_fp16 * c) + (__fp16)(M03_fp16 * d);\t\t\\\n+\t*pOutput++ = ab + cd;\t\t\t\t\t\t\\\n+\tab = (__fp16)(M10_fp16 * a) + (__fp16)(M11_fp16 * b);\t\t\\\n+\tcd = (__fp16)(M12_fp16 * c) + (__fp16)(M13_fp16 * d);\t\t\\\n+\t*pOutput++ = ab + cd;\t\t\t\t\t\t\\\n+\tab = (__fp16)(M20_fp16 * a) + (__fp16)(M21_fp16 * b);\t\t\\\n+\tcd = (__fp16)(M22_fp16 * c) + (__fp16)(M23_fp16 * d);\t\t\\\n+\t*pOutput++ = ab + cd;\t\t\t\t\t\t\\\n+\tab = (__fp16)(M30_fp16 * a) + (__fp16)(M31_fp16 * b);\t\t\\\n+\tcd = (__fp16)(M32_fp16 * c) + (__fp16)(M33_fp16 * d);\t\t\\\n+\t*pOutput++ = ab + cd;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FUNC_FLOAT_FP16(f, __fp16, 16)\n+\n+/* vld4X.8 is used for signed and unsigned chars: 2 * 4.  */\n+/* vld4X.16 is used for signed and unsigned shorts and __fp16: 3 * 4.  */\n+/* vld4X.32 is used for signed and unsigned ints and float: 3 * 4.  */\n+/* { dg-final { scan-assembler-times {vld4[0123].8\\t.q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+., } 8 } } */\n+/* { dg-final { scan-assembler-times {vld4[0123].16\\t.q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+., } 12 } } */\n+/* { dg-final { scan-assembler-times {vld4[0123].32\\t.q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+., } 12 } } */\n+/* { dg-final { scan-assembler-times {vst4[0123].8\\t.q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+., } 8 } } */\n+/* { dg-final { scan-assembler-times {vst4[0123].16\\t.q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+., } 12 } } */\n+/* { dg-final { scan-assembler-times {vst4[0123].32\\t.q[0-9]+, q[0-9]+, q[0-9]+, q[0-9]+., } 12 } } */"}]}