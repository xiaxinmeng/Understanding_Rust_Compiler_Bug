{"sha": "c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRlNjRmMzlkOWY4Y2U0YWY2MDIyMjQxNWI1MjJhNGIwN2Y4Yjg2Yw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-05-14T20:47:39Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-05-14T20:47:39Z"}, "message": "re PR middle-end/44103 (New Java test failures)\n\n\tPR 44103\n\t* java-tree.h (START_RECORD_CONSTRUCTOR): Change first argument to a\n\tvector.  Move call to build_constructor...\n\t(FINISH_RECORD_CONSTRUCTOR): ...here.  Add necessary arguments.  Clear\n\tTREE_CONSTANT on the constructor.\n\t(PUSH_SUPER_VALUE): Change first argument to a vector.\n\t(PUSH_FIELD_VALUE): Likewise.\n\t* resource.c (compile_resource_data): Update calls to above macros.\n\t* constants.c (build_constants_constructor): Likewise.\n\t* class.c (build_utf8_ref): Likewise.\n\t(make_field_value): Likewise.\n\t(make_method_value): Likewise.\n\t(add_table_and_syms): New function.\n\t(make_class_data): Call it.  Update calls to above macros.\n\t(build_symbol_table_entry): New function.\n\t(build_symbol_entry): Call it.  Update calls to above macros.\n\t(emit_symbol_table): Likewise.\n\t(make_catch_class_record): Update calls to above macros.\n\t(build_assertion_table_entry): New function.\n\t(add_assertion_table_entry): Call it.\n\t(emit_assertion_table): Likewise.\n\nFrom-SVN: r159414", "tree": {"sha": "7d7e5aff53f6511668480301f6544e42fe904baa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d7e5aff53f6511668480301f6544e42fe904baa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/comments", "author": null, "committer": null, "parents": [{"sha": "bc8ddfe63536d01d70f9dac63b8e47241cccdea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8ddfe63536d01d70f9dac63b8e47241cccdea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8ddfe63536d01d70f9dac63b8e47241cccdea5"}], "stats": {"total": 385, "additions": 213, "deletions": 172}, "files": [{"sha": "b2de8bc885579533cf1aeddbfd67f7b067193b55", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "patch": "@@ -1,3 +1,27 @@\n+2010-05-14  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\tPR 44103\n+\t* java-tree.h (START_RECORD_CONSTRUCTOR): Change first argument to a\n+\tvector.  Move call to build_constructor...\n+\t(FINISH_RECORD_CONSTRUCTOR): ...here.  Add necessary arguments.  Clear\n+\tTREE_CONSTANT on the constructor.\n+\t(PUSH_SUPER_VALUE): Change first argument to a vector.\n+\t(PUSH_FIELD_VALUE): Likewise.\n+\t* resource.c (compile_resource_data): Update calls to above macros.\n+\t* constants.c (build_constants_constructor): Likewise.\n+\t* class.c (build_utf8_ref): Likewise.\n+\t(make_field_value): Likewise.\n+\t(make_method_value): Likewise.\n+\t(add_table_and_syms): New function.\n+\t(make_class_data): Call it.  Update calls to above macros.\n+\t(build_symbol_table_entry): New function.\n+\t(build_symbol_entry): Call it.  Update calls to above macros.\n+\t(emit_symbol_table): Likewise.\n+\t(make_catch_class_record): Update calls to above macros.\n+\t(build_assertion_table_entry): New function.\n+\t(add_assertion_table_entry): Call it.\n+\t(emit_assertion_table): Likewise.\n+\n 2010-05-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 40989"}, {"sha": "7e9659b1598cd9ffdd0007ef86fbcadb2a453f5f", "filename": "gcc/java/class.c", "status": "modified", "additions": 155, "deletions": 144, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "patch": "@@ -942,6 +942,7 @@ build_utf8_ref (tree name)\n   int name_hash;\n   tree ref = IDENTIFIER_UTF8_REF (name);\n   tree decl;\n+  VEC(constructor_elt,gc) *v = NULL;\n   if (ref != NULL_TREE)\n     return ref;\n \n@@ -956,14 +957,14 @@ build_utf8_ref (tree name)\n \t      ctype, field, \"length\", unsigned_short_type_node);\n   PUSH_FIELD (input_location, ctype, field, \"data\", str_type);\n   FINISH_RECORD (ctype);\n-  START_RECORD_CONSTRUCTOR (cinit, ctype);\n+  START_RECORD_CONSTRUCTOR (v, ctype);\n   name_hash = hashUtf8String (name_ptr, name_len) & 0xFFFF;\n-  PUSH_FIELD_VALUE (cinit, \"hash\", build_int_cst (NULL_TREE, name_hash));\n-  PUSH_FIELD_VALUE (cinit, \"length\", build_int_cst (NULL_TREE, name_len));\n+  PUSH_FIELD_VALUE (v, \"hash\", build_int_cst (NULL_TREE, name_hash));\n+  PUSH_FIELD_VALUE (v, \"length\", build_int_cst (NULL_TREE, name_len));\n   string = build_string (name_len, name_ptr);\n   TREE_TYPE (string) = str_type;\n-  PUSH_FIELD_VALUE (cinit, \"data\", string);\n-  FINISH_RECORD_CONSTRUCTOR (cinit);\n+  PUSH_FIELD_VALUE (v, \"data\", string);\n+  FINISH_RECORD_CONSTRUCTOR (cinit, v, ctype);\n   TREE_CONSTANT (cinit) = 1;\n \n   /* Generate a unique-enough identifier.  */\n@@ -1425,9 +1426,10 @@ make_field_value (tree fdecl)\n   int flags;\n   tree type = TREE_TYPE (fdecl);\n   int resolved = is_compiled_class (type) && ! flag_indirect_dispatch;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n-  START_RECORD_CONSTRUCTOR (finit, field_type_node);\n-  PUSH_FIELD_VALUE (finit, \"name\", build_utf8_ref (DECL_NAME (fdecl)));\n+  START_RECORD_CONSTRUCTOR (v, field_type_node);\n+  PUSH_FIELD_VALUE (v, \"name\", build_utf8_ref (DECL_NAME (fdecl)));\n   if (resolved)\n     type = build_class_ref (type);\n   else\n@@ -1438,14 +1440,14 @@ make_field_value (tree fdecl)\n \t\t\t     (IDENTIFIER_POINTER (signature),\n \t\t\t      IDENTIFIER_LENGTH (signature)));\n     }\n-  PUSH_FIELD_VALUE (finit, \"type\", type);\n+  PUSH_FIELD_VALUE (v, \"type\", type);\n \n   flags = get_access_flags_from_decl (fdecl);\n   if (! resolved)\n     flags |= 0x8000 /* FIELD_UNRESOLVED_FLAG */;\n \n-  PUSH_FIELD_VALUE (finit, \"accflags\", build_int_cst (NULL_TREE, flags));\n-  PUSH_FIELD_VALUE (finit, \"bsize\", TYPE_SIZE_UNIT (TREE_TYPE (fdecl)));\n+  PUSH_FIELD_VALUE (v, \"accflags\", build_int_cst (NULL_TREE, flags));\n+  PUSH_FIELD_VALUE (v, \"bsize\", TYPE_SIZE_UNIT (TREE_TYPE (fdecl)));\n \n   {\n     tree field_address = integer_zero_node;\n@@ -1454,7 +1456,7 @@ make_field_value (tree fdecl)\n       field_address = build_address_of (fdecl);\n \n     PUSH_FIELD_VALUE\n-      (finit, \"info\",\n+      (v, \"info\",\n        build_constructor_from_list (field_info_union_node,\n \t build_tree_list\n \t   ((FIELD_STATIC (fdecl)\n@@ -1465,7 +1467,7 @@ make_field_value (tree fdecl)\n \t     : byte_position (fdecl)))));\n   }\n \n-  FINISH_RECORD_CONSTRUCTOR (finit);\n+  FINISH_RECORD_CONSTRUCTOR (finit, v, field_type_node);\n   return finit;\n }\n \n@@ -1481,6 +1483,7 @@ make_method_value (tree mdecl)\n   tree class_decl;\n #define ACC_TRANSLATED          0x4000\n   int accflags = get_access_flags_from_decl (mdecl) | ACC_TRANSLATED;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   class_decl = DECL_CONTEXT (mdecl);\n   /* For interfaces, the index field contains the dispatch index. */\n@@ -1499,22 +1502,22 @@ make_method_value (tree mdecl)\n   else\n     code = build1 (ADDR_EXPR, nativecode_ptr_type_node, \n \t\t   make_local_function_alias (mdecl));\n-  START_RECORD_CONSTRUCTOR (minit, method_type_node);\n-  PUSH_FIELD_VALUE (minit, \"name\",\n+  START_RECORD_CONSTRUCTOR (v, method_type_node);\n+  PUSH_FIELD_VALUE (v, \"name\",\n \t\t    build_utf8_ref (DECL_CONSTRUCTOR_P (mdecl) ?\n \t\t\t\t    init_identifier_node\n \t\t\t\t    : DECL_NAME (mdecl)));\n   {\n     tree signature = build_java_signature (TREE_TYPE (mdecl));\n-    PUSH_FIELD_VALUE (minit, \"signature\", \n+    PUSH_FIELD_VALUE (v, \"signature\", \n \t\t      (build_utf8_ref \n \t\t       (unmangle_classname \n \t\t\t(IDENTIFIER_POINTER(signature),\n \t\t\t IDENTIFIER_LENGTH(signature)))));\n   }\n-  PUSH_FIELD_VALUE (minit, \"accflags\", build_int_cst (NULL_TREE, accflags));\n-  PUSH_FIELD_VALUE (minit, \"index\", index);\n-  PUSH_FIELD_VALUE (minit, \"ncode\", code);\n+  PUSH_FIELD_VALUE (v, \"accflags\", build_int_cst (NULL_TREE, accflags));\n+  PUSH_FIELD_VALUE (v, \"index\", index);\n+  PUSH_FIELD_VALUE (v, \"ncode\", code);\n \n   {\n     /* Compute the `throws' information for the method.  */\n@@ -1551,10 +1554,10 @@ make_method_value (tree mdecl)\n \ttable = build1 (ADDR_EXPR, ptr_type_node, array);\n       }\n \n-    PUSH_FIELD_VALUE (minit, \"throws\", table);\n+    PUSH_FIELD_VALUE (v, \"throws\", table);\n   }\n \n-  FINISH_RECORD_CONSTRUCTOR (minit);\n+  FINISH_RECORD_CONSTRUCTOR (minit, v, method_type_node);\n   return minit;\n }\n \n@@ -1717,6 +1720,29 @@ supers_all_compiled (tree type)\n   return 1;\n }\n \n+static void\n+add_table_and_syms (VEC(constructor_elt,gc) **v,\n+                    tree method_slot,\n+                    const char *table_name, tree table_slot, tree table_type,\n+                    const char *syms_name, tree syms_slot)\n+{\n+  if (method_slot == NULL_TREE)\n+    {\n+      PUSH_FIELD_VALUE (*v, table_name, null_pointer_node);\n+      PUSH_FIELD_VALUE (*v, syms_name, null_pointer_node);\n+    }\n+  else\n+    {\n+      pushdecl_top_level (syms_slot);\n+      PUSH_FIELD_VALUE (*v, table_name,\n+                        build1 (ADDR_EXPR, table_type, table_slot));\n+      PUSH_FIELD_VALUE (*v, syms_name,\n+                        build1 (ADDR_EXPR, symbols_array_ptr_type,\n+                                syms_slot));\n+      TREE_CONSTANT (table_slot) = 1;\n+    }\n+}\n+                    \n void\n make_class_data (tree type)\n {\n@@ -1748,6 +1774,8 @@ make_class_data (tree type)\n   tree dtable_start_offset = size_int (2 * POINTER_SIZE / BITS_PER_UNIT);\n   VEC(int, heap) *field_indexes;\n   tree first_real_field;\n+  VEC(constructor_elt,gc) *v1 = NULL, *v2 = NULL;\n+  tree reflection_data;\n \n   this_class_addr = build_static_class_ref (type);\n   decl = TREE_OPERAND (this_class_addr, 0);\n@@ -2032,124 +2060,86 @@ make_class_data (tree type)\n   \n   TYPE_CTABLE_DECL (type) = emit_catch_table (type);\n \n-  START_RECORD_CONSTRUCTOR (temp, object_type_node);\n-  PUSH_FIELD_VALUE (temp, \"vtable\",\n+  START_RECORD_CONSTRUCTOR (v1, object_type_node);\n+  PUSH_FIELD_VALUE (v1, \"vtable\",\n \t\t    (flag_indirect_classes \n \t\t     ? null_pointer_node\n \t\t     : build2 (POINTER_PLUS_EXPR, dtable_ptr_type,\n \t\t\t       build1 (ADDR_EXPR, dtable_ptr_type,\n \t\t\t\t       class_dtable_decl),\n \t\t\t       dtable_start_offset)));\n   if (! flag_hash_synchronization)\n-    PUSH_FIELD_VALUE (temp, \"sync_info\", null_pointer_node);\n-  FINISH_RECORD_CONSTRUCTOR (temp);\n-  START_RECORD_CONSTRUCTOR (cons, class_type_node);\n-  PUSH_SUPER_VALUE (cons, temp);\n-  PUSH_FIELD_VALUE (cons, \"next_or_version\", gcj_abi_version);\n-  PUSH_FIELD_VALUE (cons, \"name\", build_utf8_ref (DECL_NAME (type_decl)));\n-  PUSH_FIELD_VALUE (cons, \"accflags\",\n+    PUSH_FIELD_VALUE (v1, \"sync_info\", null_pointer_node);\n+  FINISH_RECORD_CONSTRUCTOR (temp, v1, object_type_node);\n+  START_RECORD_CONSTRUCTOR (v2, class_type_node);\n+  PUSH_SUPER_VALUE (v2, temp);\n+  PUSH_FIELD_VALUE (v2, \"next_or_version\", gcj_abi_version);\n+  PUSH_FIELD_VALUE (v2, \"name\", build_utf8_ref (DECL_NAME (type_decl)));\n+  PUSH_FIELD_VALUE (v2, \"accflags\",\n \t\t    build_int_cst (NULL_TREE,\n \t\t\t\t   get_access_flags_from_decl (type_decl)));\n \n-  PUSH_FIELD_VALUE (cons, \"superclass\", \n+  PUSH_FIELD_VALUE (v2, \"superclass\", \n \t\t    CLASS_INTERFACE (type_decl) ? null_pointer_node : super);\n-  PUSH_FIELD_VALUE (cons, \"constants\", constant_pool_constructor);\n-  PUSH_FIELD_VALUE (cons, \"methods\",\n+  PUSH_FIELD_VALUE (v2, \"constants\", constant_pool_constructor);\n+  PUSH_FIELD_VALUE (v2, \"methods\",\n                     methods_decl == NULL_TREE ? null_pointer_node\n \t\t    : build1 (ADDR_EXPR, method_ptr_type_node, methods_decl));\n-  PUSH_FIELD_VALUE (cons, \"method_count\",\n+  PUSH_FIELD_VALUE (v2, \"method_count\",\n \t\t    build_int_cst (NULL_TREE, method_count));\n \n-  if (flag_indirect_dispatch)\n-    PUSH_FIELD_VALUE (cons, \"vtable_method_count\", integer_minus_one_node);\n-  else\n-    PUSH_FIELD_VALUE (cons, \"vtable_method_count\", TYPE_NVIRTUALS (type));\n+  PUSH_FIELD_VALUE (v2, \"vtable_method_count\",\n+                    (flag_indirect_dispatch\n+                     ? integer_minus_one_node\n+                     : TYPE_NVIRTUALS (type)));\n     \n-  PUSH_FIELD_VALUE (cons, \"fields\",\n+  PUSH_FIELD_VALUE (v2, \"fields\",\n \t\t    fields_decl == NULL_TREE ? null_pointer_node\n \t\t    : build1 (ADDR_EXPR, field_ptr_type_node, fields_decl));\n   /* If we're using the binary compatibility ABI we don't know the\n      size until load time.  */\n-  PUSH_FIELD_VALUE (cons, \"size_in_bytes\", \n+  PUSH_FIELD_VALUE (v2, \"size_in_bytes\", \n \t\t    (flag_indirect_dispatch \n \t\t     ? integer_minus_one_node \n \t\t     : size_in_bytes (type)));\n-  PUSH_FIELD_VALUE (cons, \"field_count\", \n+  PUSH_FIELD_VALUE (v2, \"field_count\", \n \t\t    build_int_cst (NULL_TREE, field_count));\n-  PUSH_FIELD_VALUE (cons, \"static_field_count\",\n+  PUSH_FIELD_VALUE (v2, \"static_field_count\",\n \t\t    build_int_cst (NULL_TREE, static_field_count));\n \n-  if (flag_indirect_dispatch)\n-    PUSH_FIELD_VALUE (cons, \"vtable\", null_pointer_node);\n-  else\n-    PUSH_FIELD_VALUE (cons, \"vtable\",\n-\t\t      dtable_decl == NULL_TREE ? null_pointer_node\n-\t\t      : build2 (POINTER_PLUS_EXPR, dtable_ptr_type,\n+  PUSH_FIELD_VALUE (v2, \"vtable\",\n+                    (flag_indirect_dispatch || dtable_decl == NULL_TREE\n+                     ? null_pointer_node\n+                     : build2 (POINTER_PLUS_EXPR, dtable_ptr_type,\n \t\t\t\tbuild1 (ADDR_EXPR, dtable_ptr_type,\n \t\t\t\t\tdtable_decl),\n-\t\t\t\tdtable_start_offset));\n-  if (TYPE_OTABLE_METHODS (type) == NULL_TREE)\n-    {\n-      PUSH_FIELD_VALUE (cons, \"otable\", null_pointer_node);\n-      PUSH_FIELD_VALUE (cons, \"otable_syms\", null_pointer_node);\n-    }\n-  else\n-    {\n-      pushdecl_top_level (TYPE_OTABLE_SYMS_DECL (type));\n-      PUSH_FIELD_VALUE (cons, \"otable\",\n-\t\t\tbuild1 (ADDR_EXPR, otable_ptr_type, TYPE_OTABLE_DECL (type)));\n-      PUSH_FIELD_VALUE (cons, \"otable_syms\",\n-\t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n-\t\t\t\tTYPE_OTABLE_SYMS_DECL (type)));\n-      TREE_CONSTANT (TYPE_OTABLE_DECL (type)) = 1;\n-    }\n-  if (TYPE_ATABLE_METHODS(type) == NULL_TREE)\n-    {\n-      PUSH_FIELD_VALUE (cons, \"atable\", null_pointer_node);\n-      PUSH_FIELD_VALUE (cons, \"atable_syms\", null_pointer_node);\n-    }\n-  else\n-    {\n-      pushdecl_top_level (TYPE_ATABLE_SYMS_DECL (type));\n-      PUSH_FIELD_VALUE (cons, \"atable\",\n-\t\t\tbuild1 (ADDR_EXPR, atable_ptr_type, TYPE_ATABLE_DECL (type)));\n-      PUSH_FIELD_VALUE (cons, \"atable_syms\",\n-\t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n-\t\t\t\tTYPE_ATABLE_SYMS_DECL (type)));\n-      TREE_CONSTANT (TYPE_ATABLE_DECL (type)) = 1;\n-    }\n-   if (TYPE_ITABLE_METHODS(type) == NULL_TREE)\n-    {\n-      PUSH_FIELD_VALUE (cons, \"itable\", null_pointer_node);\n-      PUSH_FIELD_VALUE (cons, \"itable_syms\", null_pointer_node);\n-    }\n-  else\n-    {\n-      pushdecl_top_level (TYPE_ITABLE_SYMS_DECL (type));\n-      PUSH_FIELD_VALUE (cons, \"itable\",\n-\t\t\tbuild1 (ADDR_EXPR, itable_ptr_type, TYPE_ITABLE_DECL (type)));\n-      PUSH_FIELD_VALUE (cons, \"itable_syms\",\n-\t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n-\t\t\t\tTYPE_ITABLE_SYMS_DECL (type)));\n-      TREE_CONSTANT (TYPE_ITABLE_DECL (type)) = 1;\n-    }\n+                               dtable_start_offset)));\n+  add_table_and_syms (&v2, TYPE_OTABLE_METHODS (type),\n+                      \"otable\", TYPE_OTABLE_DECL (type), otable_ptr_type,\n+                      \"otable_syms\", TYPE_OTABLE_SYMS_DECL (type));\n+  add_table_and_syms (&v2, TYPE_ATABLE_METHODS (type),\n+                      \"atable\", TYPE_ATABLE_DECL (type), atable_ptr_type,\n+                      \"atable_syms\", TYPE_ATABLE_SYMS_DECL (type));\n+  add_table_and_syms (&v2, TYPE_ITABLE_METHODS (type),\n+                      \"itable\", TYPE_ITABLE_DECL (type), itable_ptr_type,\n+                      \"itable_syms\", TYPE_ITABLE_SYMS_DECL (type));\n  \n-  PUSH_FIELD_VALUE (cons, \"catch_classes\",\n+  PUSH_FIELD_VALUE (v2, \"catch_classes\",\n \t\t    build1 (ADDR_EXPR, ptr_type_node, TYPE_CTABLE_DECL (type))); \n-  PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n-  PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"interface_count\",\n+  PUSH_FIELD_VALUE (v2, \"interfaces\", interfaces);\n+  PUSH_FIELD_VALUE (v2, \"loader\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"interface_count\",\n \t\t    build_int_cst (NULL_TREE, interface_len));\n-  PUSH_FIELD_VALUE (cons, \"state\",\n+  PUSH_FIELD_VALUE (v2, \"state\",\n \t\t    convert (byte_type_node,\n \t\t\t     build_int_cst (NULL_TREE, JV_STATE_PRELOADING)));\n \n-  PUSH_FIELD_VALUE (cons, \"thread\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"depth\", integer_zero_node);\n-  PUSH_FIELD_VALUE (cons, \"ancestors\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"idt\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"arrayclass\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"protectionDomain\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"thread\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"depth\", integer_zero_node);\n+  PUSH_FIELD_VALUE (v2, \"ancestors\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"idt\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"arrayclass\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"protectionDomain\", null_pointer_node);\n \n   {\n     tree assertion_table_ref;\n@@ -2160,13 +2150,13 @@ make_class_data (tree type)\n \t\t\t\t    build_pointer_type (assertion_table_type),\n \t\t\t\t    emit_assertion_table (type));\n     \n-    PUSH_FIELD_VALUE (cons, \"assertion_table\", assertion_table_ref);\n+    PUSH_FIELD_VALUE (v2, \"assertion_table\", assertion_table_ref);\n   }\n \n-  PUSH_FIELD_VALUE (cons, \"hack_signers\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"chain\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"aux_info\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"engine\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"hack_signers\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"chain\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"aux_info\", null_pointer_node);\n+  PUSH_FIELD_VALUE (v2, \"engine\", null_pointer_node);\n \n   if (TYPE_REFLECTION_DATA (current_class))\n     {\n@@ -2202,16 +2192,17 @@ make_class_data (tree type)\n       TREE_READONLY (array) = 1;\n       TREE_CONSTANT (DECL_INITIAL (array)) = 1;\n       rest_of_decl_compilation (array, 1, 0);\n-      \n-      PUSH_FIELD_VALUE (cons, \"reflection_data\", build_address_of (array));\n+\n+      reflection_data = build_address_of (array);\n \n       free (data);\n       TYPE_REFLECTION_DATA (current_class) = NULL;\n     }\n   else\n-    PUSH_FIELD_VALUE (cons, \"reflection_data\", null_pointer_node);\n+    reflection_data = null_pointer_node;\n \n-  FINISH_RECORD_CONSTRUCTOR (cons);\n+  PUSH_FIELD_VALUE (v2, \"reflection_data\", reflection_data);\n+  FINISH_RECORD_CONSTRUCTOR (cons, v2, class_type_node);\n \n   DECL_INITIAL (decl) = cons;\n   \n@@ -2846,12 +2837,30 @@ emit_register_classes (tree *list_p)\n     }\n }\n \n+/* Build a constructor for an entry in the symbol table.  */\n+\n+static tree\n+build_symbol_table_entry (tree clname, tree name, tree signature)\n+{\n+  tree symbol;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  START_RECORD_CONSTRUCTOR (v, symbol_type);\n+  PUSH_FIELD_VALUE (v, \"clname\", clname);\n+  PUSH_FIELD_VALUE (v, \"name\", name);\n+  PUSH_FIELD_VALUE (v, \"signature\", signature);\n+  FINISH_RECORD_CONSTRUCTOR (symbol, v, symbol_type);\n+  TREE_CONSTANT (symbol) = 1;\n+\n+  return symbol;\n+}\n+\n /* Make a symbol_type (_Jv_MethodSymbol) node for DECL. */\n \n static tree\n build_symbol_entry (tree decl, tree special)\n {\n-  tree clname, name, signature, sym;\n+  tree clname, name, signature;\n   clname = build_utf8_ref (DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))));\n   /* ???  Constructors are given the name foo.foo all the way through\n      the compiler, but in the method table they're all renamed\n@@ -2872,15 +2881,8 @@ build_symbol_entry (tree decl, tree special)\n   if (special != NULL_TREE)\n     signature = build2 (POINTER_PLUS_EXPR, TREE_TYPE (signature), signature,\n \t\t\tfold_convert (sizetype, special));\n-      \n-  START_RECORD_CONSTRUCTOR (sym, symbol_type);\n-  PUSH_FIELD_VALUE (sym, \"clname\", clname);\n-  PUSH_FIELD_VALUE (sym, \"name\", name);\n-  PUSH_FIELD_VALUE (sym, \"signature\", signature);\n-  FINISH_RECORD_CONSTRUCTOR (sym);\n-  TREE_CONSTANT (sym) = 1;\n-\n-  return sym;\n+\n+  return build_symbol_table_entry (clname, name, signature);\n } \n \n /* Emit a symbol table: used by -findirect-dispatch.  */\n@@ -2913,12 +2915,9 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n     }\n \n   /* Terminate the list with a \"null\" entry. */\n-  START_RECORD_CONSTRUCTOR (null_symbol, symbol_type);\n-  PUSH_FIELD_VALUE (null_symbol, \"clname\", null_pointer_node);\n-  PUSH_FIELD_VALUE (null_symbol, \"name\", null_pointer_node);\n-  PUSH_FIELD_VALUE (null_symbol, \"signature\", null_pointer_node);\n-  FINISH_RECORD_CONSTRUCTOR (null_symbol);\n-  TREE_CONSTANT (null_symbol) = 1;  \n+  null_symbol = build_symbol_table_entry (null_pointer_node,\n+                                          null_pointer_node,\n+                                          null_pointer_node);\n   list = tree_cons (NULL_TREE, null_symbol, list);\n \n   /* Put the list in the right order and make it a constructor. */\n@@ -2953,10 +2952,11 @@ make_catch_class_record (tree catch_class, tree classname)\n {\n   tree entry;\n   tree type = TREE_TYPE (TREE_TYPE (TYPE_CTABLE_DECL (output_class)));\n-  START_RECORD_CONSTRUCTOR (entry, type);\n-  PUSH_FIELD_VALUE (entry, \"address\", catch_class);\n-  PUSH_FIELD_VALUE (entry, \"classname\", classname);\n-  FINISH_RECORD_CONSTRUCTOR (entry);\n+  VEC(constructor_elt,gc) *v = NULL;\n+  START_RECORD_CONSTRUCTOR (v, type);\n+  PUSH_FIELD_VALUE (v, \"address\", catch_class);\n+  PUSH_FIELD_VALUE (v, \"classname\", classname);\n+  FINISH_RECORD_CONSTRUCTOR (entry, v, type);\n   return entry;\n }\n \n@@ -3010,6 +3010,23 @@ build_signature_for_libgcj (tree type)\n   return ref;\n }\n \n+/* Build an entry in the type assertion table.  */\n+\n+static tree\n+build_assertion_table_entry (tree code, tree op1, tree op2)\n+{\n+  VEC(constructor_elt,gc) *v = NULL;\n+  tree entry;\n+\n+  START_RECORD_CONSTRUCTOR (v, assertion_entry_type);\n+  PUSH_FIELD_VALUE (v, \"assertion_code\", code);\n+  PUSH_FIELD_VALUE (v, \"op1\", op1);\n+  PUSH_FIELD_VALUE (v, \"op2\", op2);\n+  FINISH_RECORD_CONSTRUCTOR (entry, v, assertion_entry_type);\n+\n+  return entry;\n+}\n+\n /* Add an entry to the type assertion table. Callback used during hashtable\n    traversal.  */\n \n@@ -3032,12 +3049,8 @@ add_assertion_table_entry (void **htab_entry, void *ptr)\n     op2_utf8 = null_pointer_node;\n   else\n     op2_utf8 = build_signature_for_libgcj (as->op2);\n-  \n-  START_RECORD_CONSTRUCTOR (entry, assertion_entry_type);\n-  PUSH_FIELD_VALUE (entry, \"assertion_code\", code_val);\n-  PUSH_FIELD_VALUE (entry, \"op1\", op1_utf8);\n-  PUSH_FIELD_VALUE (entry, \"op2\", op2_utf8);\n-  FINISH_RECORD_CONSTRUCTOR (entry);\n+\n+  entry = build_assertion_table_entry (code_val, op1_utf8, op2_utf8);\n   \n   *list = tree_cons (NULL_TREE, entry, *list);\n   return true;\n@@ -3056,11 +3069,9 @@ emit_assertion_table (tree klass)\n   htab_traverse (assertions_htab, add_assertion_table_entry, &list);\n \n   /* Finish with a null entry.  */\n-  START_RECORD_CONSTRUCTOR (null_entry, assertion_entry_type);\n-  PUSH_FIELD_VALUE (null_entry, \"assertion_code\", integer_zero_node);\n-  PUSH_FIELD_VALUE (null_entry, \"op1\", null_pointer_node);\n-  PUSH_FIELD_VALUE (null_entry, \"op2\", null_pointer_node);\n-  FINISH_RECORD_CONSTRUCTOR (null_entry);\n+  null_entry = build_assertion_table_entry (integer_zero_node,\n+                                            null_pointer_node,\n+                                            null_pointer_node);\n   \n   list = tree_cons (NULL_TREE, null_entry, list);\n   "}, {"sha": "ca5eb77ce30cc2fba648e5ceb1741100768ec131", "filename": "gcc/java/constants.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "patch": "@@ -500,6 +500,7 @@ build_constants_constructor (void)\n   tree cons;\n   tree tags_list = NULL_TREE;\n   tree data_list = NULL_TREE;\n+  VEC(constructor_elt,gc) *v = NULL;\n   int i;\n \n   for (i = outgoing_cpool->count;  --i > 0; )\n@@ -596,12 +597,12 @@ build_constants_constructor (void)\n       data_value = null_pointer_node;\n       tags_value = null_pointer_node;\n     }\n-  START_RECORD_CONSTRUCTOR (cons, constants_type_node);\n-  PUSH_FIELD_VALUE (cons, \"size\",\n+  START_RECORD_CONSTRUCTOR (v, constants_type_node);\n+  PUSH_FIELD_VALUE (v, \"size\",\n \t\t    build_int_cst (NULL_TREE, outgoing_cpool->count));\n-  PUSH_FIELD_VALUE (cons, \"tags\", tags_value);\n-  PUSH_FIELD_VALUE (cons, \"data\", data_value);\n-  FINISH_RECORD_CONSTRUCTOR (cons);\n+  PUSH_FIELD_VALUE (v, \"tags\", tags_value);\n+  PUSH_FIELD_VALUE (v, \"data\", data_value);\n+  FINISH_RECORD_CONSTRUCTOR (cons, v, constants_type_node);\n   return cons;\n }\n "}, {"sha": "c60298ba4d36dbaa9b097f434e4a13f20a6bf7e6", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "patch": "@@ -1461,50 +1461,54 @@ extern tree *type_map;\n \n #define FINISH_RECORD(RTYPE) layout_type (RTYPE)\n \n-/* Start building a RECORD_TYPE constructor with a given TYPE in CONS. */\n-#define START_RECORD_CONSTRUCTOR(CONS, CTYPE) \\\n+/* Start building a RECORD_TYPE constructor's elements in V.  The\n+   constructor will have type CTYPE.  */\n+#define START_RECORD_CONSTRUCTOR(V, CTYPE) \\\n   do \\\n     { \\\n-      CONS = build_constructor ((CTYPE), VEC_alloc (constructor_elt, gc, 0)); \\\n-      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (CONS), TYPE_FIELDS (CTYPE), \\\n-\t\t\t      NULL); \\\n+      V = VEC_alloc (constructor_elt, gc, 0); \\\n+      CONSTRUCTOR_APPEND_ELT (V, TYPE_FIELDS (CTYPE), NULL); \\\n     } \\\n   while (0)\n \n-/* Append a field initializer to CONS for the dummy field for the inherited\n+/* Append a field initializer to V for the dummy field for the inherited\n    fields.  The dummy field has the given VALUE, and the same type as the\n    super-class.   Must be specified before calls to PUSH_FIELD_VALUE. */\n-#define PUSH_SUPER_VALUE(CONS, VALUE) \\\n+#define PUSH_SUPER_VALUE(V, VALUE) \\\n   do \\\n     { \\\n-      constructor_elt *_elt___ = VEC_last (constructor_elt, \\\n-\t\t\t\t\t   CONSTRUCTOR_ELTS (CONS)); \\\n+      constructor_elt *_elt___ = VEC_last (constructor_elt, V); \\\n       tree _next___ = TREE_CHAIN (_elt___->index); \\\n       gcc_assert (!DECL_NAME (_elt___->index)); \\\n       _elt___->value = VALUE; \\\n-      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (CONS), _next___, NULL); \\\n+      CONSTRUCTOR_APPEND_ELT (V, _next___, NULL); \\\n     } \\\n   while (0)\n \n-/* Append a field initializer to CONS for a field with the given VALUE.\n+/* Append a field initializer to V for a field with the given VALUE.\n    NAME is a char* string used for error checking;\n    the initializer must be specified in order. */\n-#define PUSH_FIELD_VALUE(CONS, NAME, VALUE) \t\t\t\t\\\n+#define PUSH_FIELD_VALUE(V, NAME, VALUE) \t\t\t\t\\\n   do \\\n     { \\\n-      constructor_elt *_elt___ = VEC_last (constructor_elt, \\\n-\t\t\t\t\t   CONSTRUCTOR_ELTS (CONS)); \\\n+      constructor_elt *_elt___ = VEC_last (constructor_elt, V); \\\n       tree _next___ = TREE_CHAIN (_elt___->index); \\\n       gcc_assert (strcmp (IDENTIFIER_POINTER (DECL_NAME (_elt___->index)), \\\n \t\t\t  NAME) == 0); \\\n       _elt___->value = VALUE; \\\n-      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (CONS), _next___, NULL); \\\n+      CONSTRUCTOR_APPEND_ELT (V, _next___, NULL); \\\n     } \\\n   while (0)\n \n-/* Finish creating a record CONSTRUCTOR CONS. */\n-#define FINISH_RECORD_CONSTRUCTOR(CONS) \\\n-  VEC_pop (constructor_elt, CONSTRUCTOR_ELTS (CONS))\n+/* Finish creating a record CONSTRUCTOR CONS with type CTYPE and elements V.  */\n+#define FINISH_RECORD_CONSTRUCTOR(CONS, V, CTYPE)        \\\n+  do \\\n+    { \\\n+      VEC_pop (constructor_elt, V); \\\n+      CONS = build_constructor (CTYPE, V); \\\n+      TREE_CONSTANT (CONS) = 0; \\\n+    } \\\n+  while (0)\n \n #define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n #define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)"}, {"sha": "401e6342f0b0165fe5231e04eafc03ba5ec64c58", "filename": "gcc/java/resource.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e64f39d9f8ce4af60222415b522a4b07f8b86c/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=c4e64f39d9f8ce4af60222415b522a4b07f8b86c", "patch": "@@ -55,6 +55,7 @@ void\n compile_resource_data (const char *name, const char *buffer, int length)\n {\n   tree rtype, field = NULL_TREE, data_type, rinit, data, decl;\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   data_type = build_prim_array_type (unsigned_byte_type_node,\n \t\t\t\t     strlen (name) + length);\n@@ -65,15 +66,15 @@ compile_resource_data (const char *name, const char *buffer, int length)\n \t      rtype, field, \"resource_length\", unsigned_int_type_node);\n   PUSH_FIELD (input_location, rtype, field, \"data\", data_type);\n   FINISH_RECORD (rtype);\n-  START_RECORD_CONSTRUCTOR (rinit, rtype);\n-  PUSH_FIELD_VALUE (rinit, \"name_length\", \n+  START_RECORD_CONSTRUCTOR (v, rtype);\n+  PUSH_FIELD_VALUE (v, \"name_length\", \n \t\t    build_int_cst (NULL_TREE, strlen (name)));\n-  PUSH_FIELD_VALUE (rinit, \"resource_length\", \n+  PUSH_FIELD_VALUE (v, \"resource_length\", \n \t\t    build_int_cst (NULL_TREE, length));\n   data = build_string (strlen(name) + length, buffer);\n   TREE_TYPE (data) = data_type;\n-  PUSH_FIELD_VALUE (rinit, \"data\", data);\n-  FINISH_RECORD_CONSTRUCTOR (rinit);\n+  PUSH_FIELD_VALUE (v, \"data\", data);\n+  FINISH_RECORD_CONSTRUCTOR (rinit, v, rtype);\n   TREE_CONSTANT (rinit) = 1;\n \n   decl = build_decl (input_location,"}]}