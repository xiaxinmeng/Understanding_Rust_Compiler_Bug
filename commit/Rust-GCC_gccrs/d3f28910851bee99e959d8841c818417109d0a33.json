{"sha": "d3f28910851bee99e959d8841c818417109d0a33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNmMjg5MTA4NTFiZWU5OWU5NTlkODg0MWM4MTg0MTcxMDlkMGEzMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-21T19:32:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-21T19:32:29Z"}, "message": "tree-eh.c (cleanup_is_dead_in): New.\n\n\t* tree-eh.c (cleanup_is_dead_in): New.\n\t(lower_try_finally): Don't generate a dead cleanup region.\n\t(lower_cleanup): Likewise.\n\nFrom-SVN: r159682", "tree": {"sha": "910f63348f513f24157b7b8f6b170ad11a410c48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/910f63348f513f24157b7b8f6b170ad11a410c48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3f28910851bee99e959d8841c818417109d0a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f28910851bee99e959d8841c818417109d0a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f28910851bee99e959d8841c818417109d0a33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f28910851bee99e959d8841c818417109d0a33/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14db98d4a6349271ab34e894c9b0780cb985666b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14db98d4a6349271ab34e894c9b0780cb985666b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14db98d4a6349271ab34e894c9b0780cb985666b"}], "stats": {"total": 83, "additions": 69, "deletions": 14}, "files": [{"sha": "06529f51a05b8380ec3f2a073e519c845e4efacd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f28910851bee99e959d8841c818417109d0a33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f28910851bee99e959d8841c818417109d0a33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3f28910851bee99e959d8841c818417109d0a33", "patch": "@@ -1,3 +1,9 @@\n+2010-05-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree-eh.c (cleanup_is_dead_in): New.\n+\t(lower_try_finally): Don't generate a dead cleanup region.\n+\t(lower_cleanup): Likewise.\n+\n 2010-05-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/44223"}, {"sha": "1de25361cfc5c6a561f45cc3f484694202fcd8c8", "filename": "gcc/doc/implement-cxx.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Fdoc%2Fimplement-cxx.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Fdoc%2Fimplement-cxx.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fimplement-cxx.texi?ref=d3f28910851bee99e959d8841c818417109d0a33", "patch": "@@ -28,6 +28,7 @@ environment); refer to their documentation for details.\n \n @menu\n * Conditionally-supported behavior::\n+* Exception handling::\n @end menu\n \n @node Conditionally-supported behavior\n@@ -45,3 +46,16 @@ constructor or destructor can be passed to ... (C++0x 5.2.2).}\n Such argument passing is not supported.\n \n @end itemize\n+\n+@node Exception handling\n+@section Exception handling\n+\n+@itemize @bullet\n+@item\n+@cite{In the situation where no matching handler is found, it is\n+implementation-defined whether or not the stack is unwound before\n+std::terminate() is called (C++98 15.5.1).}\n+\n+The stack is not unwound before std::terminate is called.\n+\n+@end itemize"}, {"sha": "c3e2d37c7e82c8c62412eb851daa79b5b37b3a8a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d3f28910851bee99e959d8841c818417109d0a33", "patch": "@@ -187,7 +187,7 @@ in the following sections.\n -fno-implicit-templates @gol\n -fno-implicit-inline-templates @gol\n -fno-implement-inlines  -fms-extensions @gol\n--fno-nonansi-builtins  -fno-operator-names @gol\n+-fno-nonansi-builtins  -fnothrow-opt  -fno-operator-names @gol\n -fno-optional-diags  -fpermissive @gol\n -fno-pretty-templates @gol\n -frepo  -fno-rtti  -fstats  -ftemplate-depth=@var{n} @gol\n@@ -1933,10 +1933,13 @@ ANSI/ISO C@.  These include @code{ffs}, @code{alloca}, @code{_exit},\n @opindex fnothrow-opt\n Treat a @code{throw()} exception specification as though it were a\n @code{noexcept} specification to reduce or eliminate the text size\n-overhead relative to a function with no exception specification.  The\n-semantic effect is that an exception thrown out of a function with\n-such an exception specification will result in a call to\n-@code{terminate} rather than @code{unexpected}.\n+overhead relative to a function with no exception specification.  If\n+the function has local variables of types with non-trivial\n+destructors, the exception specification will actually make the\n+function smaller because the EH cleanups for those variables can be\n+optimized away.  The semantic effect is that an exception thrown out of\n+a function with such an exception specification will result in a call\n+to @code{terminate} rather than @code{unexpected}.\n \n @item -fno-operator-names\n @opindex fno-operator-names"}, {"sha": "227a77c73a8527cd34e2d2b9223a32e75eb39fd5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3f28910851bee99e959d8841c818417109d0a33", "patch": "@@ -1,3 +1,7 @@\n+2010-05-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/eh/spec11.C: Test cleanup optimization.\n+\n 2010-05-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/44223"}, {"sha": "4615a640519b9abeef17e518a45356917d400950", "filename": "gcc/testsuite/g++.dg/eh/spec11.C", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fspec11.C?ref=d3f28910851bee99e959d8841c818417109d0a33", "patch": "@@ -1,11 +1,19 @@\n // Make sure that we force an LSDA for a throw() spec with -fnothrow-opt so\n-// that the personality routine will call terminate.\n+// that the personality routine will call terminate.  Also check that we\n+// optimize away the EH cleanup for var because the personality routine\n+// will call terminate before unwinding: there should not be an EH region\n+// (i.e. LEHB/LEHE labels) around the call to g().\n \n // { dg-final { scan-assembler-not \"_ZSt9terminatev\" } }\n // { dg-final { scan-assembler-not \"EHB\" } }\n // { dg-final { scan-assembler \"LSDA\" } }\n \n // { dg-options \"-fnothrow-opt\" }\n \n+struct A { ~A(); };\n void g();\n-void f() throw() { g(); }\n+void f() throw()\n+{\n+  A var;\n+  g();\n+}"}, {"sha": "e5d76c8b8bab63c9fc564861b54bc29b8d2abd33", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3f28910851bee99e959d8841c818417109d0a33/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=d3f28910851bee99e959d8841c818417109d0a33", "patch": "@@ -1517,6 +1517,20 @@ decide_copy_try_finally (int ndests, gimple_seq finally)\n     return f_estimate < 40 || f_estimate * 2 < sw_estimate * 3;\n }\n \n+/* REG is the enclosing region for a possible cleanup region, or the region\n+   itself.  Returns TRUE if such a region would be unreachable.\n+\n+   Cleanup regions within a must-not-throw region aren't actually reachable\n+   even if there are throwing stmts within them, because the personality\n+   routine will call terminate before unwinding.  */\n+\n+static bool\n+cleanup_is_dead_in (eh_region reg)\n+{\n+  while (reg && reg->type == ERT_CLEANUP)\n+    reg = reg->outer;\n+  return (reg && reg->type == ERT_MUST_NOT_THROW);\n+}\n \n /* A subroutine of lower_eh_constructs_1.  Lower a GIMPLE_TRY_FINALLY nodes\n    to a sequence of labels and blocks, plus the exception region trees\n@@ -1537,12 +1551,17 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   this_tf.try_finally_expr = tp;\n   this_tf.top_p = tp;\n   this_tf.outer = state;\n-  if (using_eh_for_cleanups_p)\n-    this_tf.region = gen_eh_region_cleanup (state->cur_region);\n+  if (using_eh_for_cleanups_p && !cleanup_is_dead_in (state->cur_region))\n+    {\n+      this_tf.region = gen_eh_region_cleanup (state->cur_region);\n+      this_state.cur_region = this_tf.region;\n+    }\n   else\n-    this_tf.region = NULL;\n+    {\n+      this_tf.region = NULL;\n+      this_state.cur_region = state->cur_region;\n+    }\n \n-  this_state.cur_region = this_tf.region;\n   this_state.ehp_region = state->ehp_region;\n   this_state.tf = &this_tf;\n \n@@ -1555,7 +1574,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   this_tf.may_fallthru = gimple_seq_may_fallthru (gimple_try_eval (tp));\n \n   /* Determine if any exceptions are possible within the try block.  */\n-  if (using_eh_for_cleanups_p)\n+  if (this_tf.region)\n     this_tf.may_throw = eh_region_may_contain_throw (this_tf.region);\n   if (this_tf.may_throw)\n     honor_protect_cleanup_actions (state, &this_state, &this_tf);\n@@ -1779,16 +1798,17 @@ lower_cleanup (struct leh_state *state, gimple tp)\n   eh_region this_region = NULL;\n   struct leh_tf_state fake_tf;\n   gimple_seq result;\n+  bool cleanup_dead = cleanup_is_dead_in (state->cur_region);\n \n-  if (flag_exceptions)\n+  if (flag_exceptions && !cleanup_dead)\n     {\n       this_region = gen_eh_region_cleanup (state->cur_region);\n       this_state.cur_region = this_region;\n     }\n \n   lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n \n-  if (!eh_region_may_contain_throw (this_region))\n+  if (cleanup_dead || !eh_region_may_contain_throw (this_region))\n     return gimple_try_eval (tp);\n \n   /* Build enough of a try-finally state so that we can reuse"}]}