{"sha": "d52f529517da6e1143714a274d71dcfd64b7a2f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUyZjUyOTUxN2RhNmUxMTQzNzE0YTI3NGQ3MWRjZmQ2NGI3YTJmMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-07-24T12:07:13Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-07-24T12:07:13Z"}, "message": "IPA C++ refactoring 1/N\n\n  * cgraph.h (symtab_node):\n  (void register_symbol (void)): created from symtab_register_node\n  (void remove (void)): created from symtab_remove_node\n  (void dump (FILE *f)): created from dump_symtab_node\n  (void DEBUG_FUNCTION debug (void)): created from debug_symtab_node\n  (void DEBUG_FUNCTION verify (void)): created from verify_symtab_node\n  (struct ipa_ref *add_reference (symtab_node *referred_node,\n    enum ipa_ref_use use_type)): created from add_reference \n  (struct ipa_ref *add_reference (symtab_node *referred_node,\n    enum ipa_ref_use use_type, gimple stmt)): created from add_reference\n  (struct ipa_ref *maybe_add_reference (tree val, enum ipa_ref_use use_type,\n    gimple stmt)): created from maybe_add_reference\n  (bool semantically_equivalent_p (symtab_node *target)): created from\n    symtab_semantically_equivalent_p\n  (void remove_from_same_comdat_group (void)): created from\n    remove_from_same_comdat_group\n  (void add_to_same_comdat_group (symtab_node *old_node)): created from\n    symtab_add_to_same_comdat_group\n  (void dissolve_same_comdat_group_list (void)): created from\n    symtab_dissolve_same_comdat_group_list\n  (bool used_from_object_file_p (void)): created from symtab_used_from_object_file_p\n  (symtab_node *ultimate_alias_target (enum availability *avail = NULL)):\n    created from symtab_alias_ultimate_target\n  (inline symtab_node *next_defined_symbol (void)): created from\n    symtab_next_defined_symbol\n  (bool resolve_alias (symtab_node *target)): created from\n    symtab_resolve_alias\n  (bool call_for_symbol_and_aliases (bool (*callback) (symtab_node *, void *),\n    void *data, bool include_overwrite)): created from symtab_for_node_and_aliases\n  (symtab_node *noninterposable_alias (void)): created from symtab_nonoverwritable_alias\n  (inline symtab_node *get_alias_target (void)): created from symtab_alias_target\n  (void set_section (const char *section)): created from set_section_1 \n  (enum availability get_availability (void)): created from symtab_node_availability\n  (void make_decl_local (void)): created from symtab_make_decl_local\n  (bool real_symbol_p (void)): created from symtab_read_node\n  (can_be_discarded_p (void)): created from symtab_can_be_discarded\n  (inline bool comdat_local_p (void)): created from symtab_comdat_local_p\n  (inline bool in_same_comdat_group_p (symtab_node *target)): created from\n    symtab_in_same_comdat_p;\n  (bool address_taken_from_non_vtable_p (void)): created from\n    address_taken_from_non_vtable_p\n  (static inline symtab_node *get (const_tree decl)): created from symtab_get_node\n  (static void dump_table (FILE *)): created from dump_symtab\n  (static inline DEBUG_FUNCTION void debug_symtab (void)): created from debug_symtab\n  (static DEBUG_FUNCTION void verify_symtab_nodes (void)): created from verify_symtab\n  (static bool used_from_object_file_p_worker (symtab_node *node)): created from\n    symtab_used_from_object_file_p \n  (void dump_base (FILE *)): created from dump_symtab_base\n  (bool DEBUG_FUNCTION verify_base (void)): created from verify_symtab_base\n  (void unregister (void)): created from symtab_unregister_node\n  (struct symbol_priority_map *priority_info (void)): created from symtab_priority_info\n  (static bool set_implicit_section (symtab_node *n, void *)): created from set_implicit_section\n  (static bool noninterposable_alias (symtab_node *node, void *data)): created from\n    symtab_nonoverwritable_alias_1\n  * cgraph.h (cgraph_node):\n  (bool remove_symbol_and_inline_clones (cgraph_node *forbidden_node = NULL)):\n    created from cgraph_remove_node_and_inline_clones\n  (void record_stmt_references (gimple stmt)): created from ipa_record_stmt_references\n  (void set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n    bool update_speculative = true)): created from cgraph_set_call_stmt_including_clones\n  (cgraph_node *function_symbol (enum availability *avail = NULL)):\n    created from cgraph_function_node\n  (cgraph_node *create_clone (tree decl, gcov_type count, int freq, bool update_original,\n    vec<cgraph_edge *> redirect_callers, bool call_duplication_hook,\n    struct cgraph_node *new_inlined_to, bitmap args_to_skip)):\n    created from cgraph_create_clone \n  (cgraph_node *create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip, const char * suffix)):\n    created from cgraph_create_virtual_clone\n  (cgraph_node *find_replacement (void)): created from cgraph_find_replacement_node\n  (cgraph_node *create_version_clone (tree new_decl, vec<cgraph_edge *> redirect_callers,\n    bitmap bbs_to_copy)): created from cgraph_copy_node_for_versioning\n  (cgraph_node *create_version_clone_with_body (vec<cgraph_edge *> redirect_callers,\n    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip, bool skip_return,\n    bitmap bbs_to_copy, basic_block new_entry_block, const char *clone_name)):\n    created from cgraph_function_version_info\n  (struct cgraph_function_version_info *insert_new_function_version (void)):\n    created from insert_new_cgraph_node_version\n  (struct cgraph_function_version_info *function_version (void)): created from\n    get_cgraph_node_version\n  (void analyze (void)): created from analyze_function\n  (cgraph_node * create_thunk (tree alias, tree, bool this_adjusting,\n    HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value, tree virtual_offset,\n    tree real_alias) cgraph_add_thunk\n  (inline cgraph_node *get_alias_target (void)): created from cgraph_alias_target\n  (cgraph_node *ultimate_alias_target (availability *availability = NULL)):\n    created from cgraph_function_or_thunk_node\n  (bool expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)):\n    created from expand_thunk\n  (void reset (void)): created from cgraph_reset_node\n  (void create_wrapper (cgraph_node *target)): created from cgraph_make_wrapper\n  (void DEBUG_FUNCTION verify_node (void)): created from verify_cgraph_node\n  (void remove (void)): created from cgraph_remove_node\n  (void dump (FILE *f)): created from dump_cgraph_node\n  (void DEBUG_FUNCTION debug (void)): created from debug_cgraph_node\n  (bool get_body (void)): created from cgraph_get_body\n  (void release_body (void)): created from cgraph_release_function_body\n  (void unnest (void)): created from cgraph_unnest_node\n  (void make_local (void)): created from cgraph_make_node_local\n  (void mark_address_taken (void)): created from cgraph_mark_address_taken_node\n  (struct cgraph_edge *create_edge (cgraph_node *callee, gimple call_stmt,\n    gcov_type count, int freq)): created from cgraph_create_edge\n  (struct cgraph_edge *create_indirect_edge (gimple call_stmt, int ecf_flags,\n    gcov_type count, int freq)): created from cgraph_create_indirect_edge\n  (void create_edge_including_clones (struct cgraph_node *callee, gimple old_stmt,\n    gimple stmt, gcov_type count, int freq, cgraph_inline_failed_t reason)):\n    created from cgraph_create_edge_including_clones\n  (cgraph_edge *get_edge (gimple call_stmt)): created from cgraph_edge\n  (vec<cgraph_edge *> collect_callers (void)): created from collect_callers_of_node\n  (void remove_callers (void)): created from cgraph_node_remove_callers\n  (void remove_callees (void)): created from cgraph_node_remove_callees\n  (enum availability get_availability (void)): created from cgraph_function_body_availability\n  (void set_nothrow_flag (bool nothrow)): created from cgraph_set_nothrow_flag\n  (void set_const_flag (bool readonly, bool looping)): created from cgraph_set_const_flag\n  (void set_pure_flag (bool pure, bool looping)): created from cgraph_set_pure_flag\n  (void call_duplication_hooks (cgraph_node *node2)): created from\n    cgraph_call_node_duplication_hooks\n  (bool call_for_symbol_and_aliases (bool (*callback) (cgraph_node *, void *),\n    void *data, bool include_overwritable)): created from cgraph_for_node_and_aliases\n  (bool call_for_symbol_thunks_and_aliases (bool (*callback) (cgraph_node *node, void *data),\n    void *data, bool include_overwritable)): created from cgraph_for_node_thunks_and_aliases\n  (void call_function_insertion_hooks (void)):\n    created from cgraph_call_function_insertion_hooks\n  (inline void mark_force_output (void)): created from cgraph_mark_force_output_node\n  (bool local_p (void)): created from cgraph_local_node\n  (bool can_be_local_p (void)): created from cgraph_node_can_be_local_p\n  (bool cannot_return_p (void)): created from cgraph_node_cannot_return\n  (bool only_called_directly_p (void)): created from cgraph_only_called_directly_p\n  (inline bool only_called_directly_or_aliased_p (void)):\n    created from cgraph_only_called_directly_or_aliased_p\n  (bool will_be_removed_from_program_if_no_direct_calls_p (void)):\n    created from cgraph_will_be_removed_from_program_if_no_direct_calls\n  (bool can_remove_if_no_direct_calls_and_refs_p (void)):\n    created from cgraph_can_remove_if_no_direct_calls_and_refs_p\n  (bool can_remove_if_no_direct_calls_p (void)):\n    created from cgraph_can_remove_if_no_direct_calls_p\n  (inline bool has_gimple_body_p (void)):\n    created from cgraph_function_with_gimple_body_p\n  (bool optimize_for_size_p (void)): created from cgraph_optimize_for_size_p\n  (static void dump_cgraph (FILE *f)): created from dump_cgraph\n  (static inline void debug_cgraph (void)): created from debug_cgraph\n  (static void record_function_versions (tree decl1, tree decl2)):\n    created from record_function_versions\n  (static void delete_function_version (tree decl)):\n    created from delete_function_version\n  (static void add_new_function (tree fndecl, bool lowered)):\n    created from cgraph_add_new_function\n  (static inline cgraph_node *get (const_tree decl)): created from cgraph_get_node\n  (static cgraph_node * create (tree decl)): created from cgraph_create_node\n  (static cgraph_node * create_empty (void)): created from cgraph_create_empty_node\n  (static cgraph_node * get_create (tree)): created from cgraph_get_create_node\n  (static cgraph_node *get_for_asmname (tree asmname)):\n    created from cgraph_node_for_asm\n  (static cgraph_node * create_same_body_alias (tree alias, tree decl)):\n    created from cgraph_same_body_alias \n  (static bool used_from_object_file_p_worker (cgraph_node *node,\n    void *): new function\n  (static bool non_local_p (cgraph_node *node, void *)):\n    created from cgraph_non_local_node_p_1\n  (static void DEBUG_FUNCTION verify_cgraph_nodes (void)):\n    created from verify_cgraph\n  (static bool make_local (cgraph_node *node, void *)):\n    created from cgraph_make_node_local\n  (static cgraph_node *create_alias (tree alias, tree target)):\n    created from cgraph_create_function_alias\n  (static cgraph_edge * create_edge (cgraph_node *caller, cgraph_node *callee,\n    gimple call_stmt, gcov_type count, int freq, bool indir_unknown_callee)):\n    created from cgraph_create_edge_1\n  * cgraph.h (varpool_node):\n  (void remove (void)): created from varpool_remove_node\n  (void dump (FILE *f)): created from dump_varpool_node\n\nFrom-SVN: r212982", "tree": {"sha": "4dd09f8eb18392a620ad92b028d01fbda5d27ee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dd09f8eb18392a620ad92b028d01fbda5d27ee7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d52f529517da6e1143714a274d71dcfd64b7a2f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d52f529517da6e1143714a274d71dcfd64b7a2f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d52f529517da6e1143714a274d71dcfd64b7a2f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d52f529517da6e1143714a274d71dcfd64b7a2f0/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "785129aa1660f4210ff4c58dfb1df3a4506aa6d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785129aa1660f4210ff4c58dfb1df3a4506aa6d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/785129aa1660f4210ff4c58dfb1df3a4506aa6d4"}], "stats": {"total": 5325, "additions": 2894, "deletions": 2431}, "files": [{"sha": "ad9f46dfb372e66d7fe68be7f70e45d0f4cb8805", "filename": "gcc/ChangeLog", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1,3 +1,177 @@\n+2014-07-24  Martin Liska  <mliska@suse.cz>\n+\n+  * cgraph.h (symtab_node):\n+  (void register_symbol (void)): created from symtab_register_node\n+  (void remove (void)): created from symtab_remove_node\n+  (void dump (FILE *f)): created from dump_symtab_node\n+  (void DEBUG_FUNCTION debug (void)): created from debug_symtab_node\n+  (void DEBUG_FUNCTION verify (void)): created from verify_symtab_node\n+  (struct ipa_ref *add_reference (symtab_node *referred_node,\n+    enum ipa_ref_use use_type)): created from add_reference \n+  (struct ipa_ref *add_reference (symtab_node *referred_node,\n+    enum ipa_ref_use use_type, gimple stmt)): created from add_reference\n+  (struct ipa_ref *maybe_add_reference (tree val, enum ipa_ref_use use_type,\n+    gimple stmt)): created from maybe_add_reference\n+  (bool semantically_equivalent_p (symtab_node *target)): created from\n+    symtab_semantically_equivalent_p\n+  (void remove_from_same_comdat_group (void)): created from\n+    remove_from_same_comdat_group\n+  (void add_to_same_comdat_group (symtab_node *old_node)): created from\n+    symtab_add_to_same_comdat_group\n+  (void dissolve_same_comdat_group_list (void)): created from\n+    symtab_dissolve_same_comdat_group_list\n+  (bool used_from_object_file_p (void)): created from symtab_used_from_object_file_p\n+  (symtab_node *ultimate_alias_target (enum availability *avail = NULL)):\n+    created from symtab_alias_ultimate_target\n+  (inline symtab_node *next_defined_symbol (void)): created from\n+    symtab_next_defined_symbol\n+  (bool resolve_alias (symtab_node *target)): created from\n+    symtab_resolve_alias\n+  (bool call_for_symbol_and_aliases (bool (*callback) (symtab_node *, void *),\n+    void *data, bool include_overwrite)): created from symtab_for_node_and_aliases\n+  (symtab_node *noninterposable_alias (void)): created from symtab_nonoverwritable_alias\n+  (inline symtab_node *get_alias_target (void)): created from symtab_alias_target\n+  (void set_section (const char *section)): created from set_section_1 \n+  (enum availability get_availability (void)): created from symtab_node_availability\n+  (void make_decl_local (void)): created from symtab_make_decl_local\n+  (bool real_symbol_p (void)): created from symtab_read_node\n+  (can_be_discarded_p (void)): created from symtab_can_be_discarded\n+  (inline bool comdat_local_p (void)): created from symtab_comdat_local_p\n+  (inline bool in_same_comdat_group_p (symtab_node *target)): created from\n+    symtab_in_same_comdat_p;\n+  (bool address_taken_from_non_vtable_p (void)): created from\n+    address_taken_from_non_vtable_p\n+  (static inline symtab_node *get (const_tree decl)): created from symtab_get_node\n+  (static void dump_table (FILE *)): created from dump_symtab\n+  (static inline DEBUG_FUNCTION void debug_symtab (void)): created from debug_symtab\n+  (static DEBUG_FUNCTION void verify_symtab_nodes (void)): created from verify_symtab\n+  (static bool used_from_object_file_p_worker (symtab_node *node)): created from\n+    symtab_used_from_object_file_p \n+  (void dump_base (FILE *)): created from dump_symtab_base\n+  (bool DEBUG_FUNCTION verify_base (void)): created from verify_symtab_base\n+  (void unregister (void)): created from symtab_unregister_node\n+  (struct symbol_priority_map *priority_info (void)): created from symtab_priority_info\n+  (static bool set_implicit_section (symtab_node *n, void *)): created from set_implicit_section\n+  (static bool noninterposable_alias (symtab_node *node, void *data)): created from\n+    symtab_nonoverwritable_alias_1\n+  * cgraph.h (cgraph_node):\n+  (bool remove_symbol_and_inline_clones (cgraph_node *forbidden_node = NULL)):\n+    created from cgraph_remove_node_and_inline_clones\n+  (void record_stmt_references (gimple stmt)): created from ipa_record_stmt_references\n+  (void set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n+    bool update_speculative = true)): created from cgraph_set_call_stmt_including_clones\n+  (cgraph_node *function_symbol (enum availability *avail = NULL)):\n+    created from cgraph_function_node\n+  (cgraph_node *create_clone (tree decl, gcov_type count, int freq, bool update_original,\n+    vec<cgraph_edge *> redirect_callers, bool call_duplication_hook,\n+    struct cgraph_node *new_inlined_to, bitmap args_to_skip)):\n+    created from cgraph_create_clone \n+  (cgraph_node *create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n+    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip, const char * suffix)):\n+    created from cgraph_create_virtual_clone\n+  (cgraph_node *find_replacement (void)): created from cgraph_find_replacement_node\n+  (cgraph_node *create_version_clone (tree new_decl, vec<cgraph_edge *> redirect_callers,\n+    bitmap bbs_to_copy)): created from cgraph_copy_node_for_versioning\n+  (cgraph_node *create_version_clone_with_body (vec<cgraph_edge *> redirect_callers,\n+    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip, bool skip_return,\n+    bitmap bbs_to_copy, basic_block new_entry_block, const char *clone_name)):\n+    created from cgraph_function_version_info\n+  (struct cgraph_function_version_info *insert_new_function_version (void)):\n+    created from insert_new_cgraph_node_version\n+  (struct cgraph_function_version_info *function_version (void)): created from\n+    get_cgraph_node_version\n+  (void analyze (void)): created from analyze_function\n+  (cgraph_node * create_thunk (tree alias, tree, bool this_adjusting,\n+    HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value, tree virtual_offset,\n+    tree real_alias) cgraph_add_thunk\n+  (inline cgraph_node *get_alias_target (void)): created from cgraph_alias_target\n+  (cgraph_node *ultimate_alias_target (availability *availability = NULL)):\n+    created from cgraph_function_or_thunk_node\n+  (bool expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)):\n+    created from expand_thunk\n+  (void reset (void)): created from cgraph_reset_node\n+  (void create_wrapper (cgraph_node *target)): created from cgraph_make_wrapper\n+  (void DEBUG_FUNCTION verify_node (void)): created from verify_cgraph_node\n+  (void remove (void)): created from cgraph_remove_node\n+  (void dump (FILE *f)): created from dump_cgraph_node\n+  (void DEBUG_FUNCTION debug (void)): created from debug_cgraph_node\n+  (bool get_body (void)): created from cgraph_get_body\n+  (void release_body (void)): created from cgraph_release_function_body\n+  (void unnest (void)): created from cgraph_unnest_node\n+  (void make_local (void)): created from cgraph_make_node_local\n+  (void mark_address_taken (void)): created from cgraph_mark_address_taken_node\n+  (struct cgraph_edge *create_edge (cgraph_node *callee, gimple call_stmt,\n+    gcov_type count, int freq)): created from cgraph_create_edge\n+  (struct cgraph_edge *create_indirect_edge (gimple call_stmt, int ecf_flags,\n+    gcov_type count, int freq)): created from cgraph_create_indirect_edge\n+  (void create_edge_including_clones (struct cgraph_node *callee, gimple old_stmt,\n+    gimple stmt, gcov_type count, int freq, cgraph_inline_failed_t reason)):\n+    created from cgraph_create_edge_including_clones\n+  (cgraph_edge *get_edge (gimple call_stmt)): created from cgraph_edge\n+  (vec<cgraph_edge *> collect_callers (void)): created from collect_callers_of_node\n+  (void remove_callers (void)): created from cgraph_node_remove_callers\n+  (void remove_callees (void)): created from cgraph_node_remove_callees\n+  (enum availability get_availability (void)): created from cgraph_function_body_availability\n+  (void set_nothrow_flag (bool nothrow)): created from cgraph_set_nothrow_flag\n+  (void set_const_flag (bool readonly, bool looping)): created from cgraph_set_const_flag\n+  (void set_pure_flag (bool pure, bool looping)): created from cgraph_set_pure_flag\n+  (void call_duplication_hooks (cgraph_node *node2)): created from\n+    cgraph_call_node_duplication_hooks\n+  (bool call_for_symbol_and_aliases (bool (*callback) (cgraph_node *, void *),\n+    void *data, bool include_overwritable)): created from cgraph_for_node_and_aliases\n+  (bool call_for_symbol_thunks_and_aliases (bool (*callback) (cgraph_node *node, void *data),\n+    void *data, bool include_overwritable)): created from cgraph_for_node_thunks_and_aliases\n+  (void call_function_insertion_hooks (void)):\n+    created from cgraph_call_function_insertion_hooks\n+  (inline void mark_force_output (void)): created from cgraph_mark_force_output_node\n+  (bool local_p (void)): created from cgraph_local_node\n+  (bool can_be_local_p (void)): created from cgraph_node_can_be_local_p\n+  (bool cannot_return_p (void)): created from cgraph_node_cannot_return\n+  (bool only_called_directly_p (void)): created from cgraph_only_called_directly_p\n+  (inline bool only_called_directly_or_aliased_p (void)):\n+    created from cgraph_only_called_directly_or_aliased_p\n+  (bool will_be_removed_from_program_if_no_direct_calls_p (void)):\n+    created from cgraph_will_be_removed_from_program_if_no_direct_calls\n+  (bool can_remove_if_no_direct_calls_and_refs_p (void)):\n+    created from cgraph_can_remove_if_no_direct_calls_and_refs_p\n+  (bool can_remove_if_no_direct_calls_p (void)):\n+    created from cgraph_can_remove_if_no_direct_calls_p\n+  (inline bool has_gimple_body_p (void)):\n+    created from cgraph_function_with_gimple_body_p\n+  (bool optimize_for_size_p (void)): created from cgraph_optimize_for_size_p\n+  (static void dump_cgraph (FILE *f)): created from dump_cgraph\n+  (static inline void debug_cgraph (void)): created from debug_cgraph\n+  (static void record_function_versions (tree decl1, tree decl2)):\n+    created from record_function_versions\n+  (static void delete_function_version (tree decl)):\n+    created from delete_function_version\n+  (static void add_new_function (tree fndecl, bool lowered)):\n+    created from cgraph_add_new_function\n+  (static inline cgraph_node *get (const_tree decl)): created from cgraph_get_node\n+  (static cgraph_node * create (tree decl)): created from cgraph_create_node\n+  (static cgraph_node * create_empty (void)): created from cgraph_create_empty_node\n+  (static cgraph_node * get_create (tree)): created from cgraph_get_create_node\n+  (static cgraph_node *get_for_asmname (tree asmname)):\n+    created from cgraph_node_for_asm\n+  (static cgraph_node * create_same_body_alias (tree alias, tree decl)):\n+    created from cgraph_same_body_alias \n+  (static bool used_from_object_file_p_worker (cgraph_node *node,\n+    void *): new function\n+  (static bool non_local_p (cgraph_node *node, void *)):\n+    created from cgraph_non_local_node_p_1\n+  (static void DEBUG_FUNCTION verify_cgraph_nodes (void)):\n+    created from verify_cgraph\n+  (static bool make_local (cgraph_node *node, void *)):\n+    created from cgraph_make_node_local\n+  (static cgraph_node *create_alias (tree alias, tree target)):\n+    created from cgraph_create_function_alias\n+  (static cgraph_edge * create_edge (cgraph_node *caller, cgraph_node *callee,\n+    gimple call_stmt, gcov_type count, int freq, bool indir_unknown_callee)):\n+    created from cgraph_create_edge_1\n+  * cgraph.h (varpool_node):\n+  (void remove (void)): created from varpool_remove_node\n+  (void dump (FILE *f)): created from dump_varpool_node\n+\n 2014-07-24  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/61823"}, {"sha": "920f72e978fb3c2a5583a324e7d7f359cad16e53", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1302,7 +1302,7 @@ asan_protect_global (tree decl)\n \t to be an array of such vars, putting padding in there\n \t breaks this assumption.  */\n       || (DECL_SECTION_NAME (decl) != NULL\n-\t  && !symtab_get_node (decl)->implicit_section)\n+\t  && !symtab_node::get (decl)->implicit_section)\n       || DECL_SIZE (decl) == 0\n       || ASAN_RED_ZONE_SIZE * BITS_PER_UNIT > MAX_OFILE_ALIGNMENT\n       || !valid_constant_size_p (DECL_SIZE_UNIT (decl))"}, {"sha": "2b5ce5ba86f998f84ac4d4fd34dc671ac17eac60", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -143,7 +143,7 @@ c_genericize (tree fndecl)\n     }\n \n   /* Dump all nested functions now.  */\n-  cgn = cgraph_get_create_node (fndecl);\n+  cgn = cgraph_node::get_create (fndecl);\n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     c_genericize (cgn->decl);\n }"}, {"sha": "b864bb1eb63a610bfc65ba77db29f0efd04c7f53", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -171,7 +171,7 @@ call_graph_add_fn (tree fndecl)\n   gcc_assert (cfun->decl == outer);\n \n   push_cfun (f);\n-  cgraph_create_node (fndecl);\n+  cgraph_node::create (fndecl);\n   pop_cfun_to (outer);\n }\n "}, {"sha": "2a4b439836ac60ada49a26e692ce55ff2f3142cc", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -2586,9 +2586,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n   if (TREE_CODE (newdecl) == FUNCTION_DECL\n       || TREE_CODE (newdecl) == VAR_DECL)\n     {\n-      struct symtab_node *snode = symtab_get_node (newdecl);\n+      struct symtab_node *snode = symtab_node::get (newdecl);\n       if (snode)\n-\tsymtab_remove_node (snode);\n+\tsnode->remove ();\n     }\n   ggc_free (newdecl);\n   return true;\n@@ -8699,7 +8699,7 @@ finish_function (void)\n \t     This should be cleaned up later and this conditional removed.  */\n \t  if (cgraph_global_info_ready)\n \t    {\n-\t      cgraph_add_new_function (fndecl, false);\n+\t      cgraph_node::add_new_function (fndecl, false);\n \t      return;\n \t    }\n \t  cgraph_finalize_function (fndecl, false);\n@@ -8709,7 +8709,7 @@ finish_function (void)\n \t  /* Register this function with cgraph just far enough to get it\n \t    added to our parent's nested function list.  Handy, since the\n \t    C front end doesn't have such a list.  */\n-\t  (void) cgraph_get_create_node (fndecl);\n+\t  (void) cgraph_node::get_create (fndecl);\n \t}\n     }\n "}, {"sha": "a5d07496f0a7a6fb7ec574cc7c2a94d760570db7", "filename": "gcc/cgraph.c", "status": "modified", "additions": 418, "deletions": 439, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -67,7 +67,6 @@ along with GCC; see the file COPYING3.  If not see\n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n \n-static void cgraph_node_remove_callers (struct cgraph_node *node);\n static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n \n@@ -175,11 +174,11 @@ static GTY(()) struct cgraph_function_version_info *\n \n /* Get the cgraph_function_version_info node corresponding to node.  */\n struct cgraph_function_version_info *\n-get_cgraph_node_version (struct cgraph_node *node)\n+cgraph_node::function_version (void)\n {\n   struct cgraph_function_version_info *ret;\n   struct cgraph_function_version_info key;\n-  key.this_node = node;\n+  key.this_node = this;\n \n   if (cgraph_fnver_htab == NULL)\n     return NULL;\n@@ -193,13 +192,13 @@ get_cgraph_node_version (struct cgraph_node *node)\n /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n    corresponding to cgraph_node NODE.  */\n struct cgraph_function_version_info *\n-insert_new_cgraph_node_version (struct cgraph_node *node)\n+cgraph_node::insert_new_function_version (void)\n {\n   void **slot;\n   \n   version_info_node = NULL;\n   version_info_node = ggc_cleared_alloc<cgraph_function_version_info> ();\n-  version_info_node->this_node = node;\n+  version_info_node->this_node = this;\n \n   if (cgraph_fnver_htab == NULL)\n     cgraph_fnver_htab = htab_create_ggc (2, cgraph_fnver_htab_hash,\n@@ -214,15 +213,15 @@ insert_new_cgraph_node_version (struct cgraph_node *node)\n /* Remove the cgraph_function_version_info and cgraph_node for DECL.  This\n    DECL is a duplicate declaration.  */\n void\n-delete_function_version (tree decl)\n+cgraph_node::delete_function_version (tree decl)\n {\n-  struct cgraph_node *decl_node = cgraph_get_node (decl);\n+  struct cgraph_node *decl_node = cgraph_node::get (decl);\n   struct cgraph_function_version_info *decl_v = NULL;\n \n   if (decl_node == NULL)\n     return;\n \n-  decl_v = get_cgraph_node_version (decl_node);\n+  decl_v = decl_node->function_version ();\n \n   if (decl_v == NULL)\n     return;\n@@ -236,33 +235,33 @@ delete_function_version (tree decl)\n   if (cgraph_fnver_htab != NULL)\n     htab_remove_elt (cgraph_fnver_htab, decl_v);\n \n-  cgraph_remove_node (decl_node);\n+  decl_node->remove ();\n }\n \n /* Record that DECL1 and DECL2 are semantically identical function\n    versions.  */\n void\n-record_function_versions (tree decl1, tree decl2)\n+cgraph_node::record_function_versions (tree decl1, tree decl2)\n {\n-  struct cgraph_node *decl1_node = cgraph_get_create_node (decl1);\n-  struct cgraph_node *decl2_node = cgraph_get_create_node (decl2);\n+  struct cgraph_node *decl1_node = cgraph_node::get_create (decl1);\n+  struct cgraph_node *decl2_node = cgraph_node::get_create (decl2);\n   struct cgraph_function_version_info *decl1_v = NULL;\n   struct cgraph_function_version_info *decl2_v = NULL;\n   struct cgraph_function_version_info *before;\n   struct cgraph_function_version_info *after;\n \n   gcc_assert (decl1_node != NULL && decl2_node != NULL);\n-  decl1_v = get_cgraph_node_version (decl1_node);\n-  decl2_v = get_cgraph_node_version (decl2_node);\n+  decl1_v = decl1_node->function_version ();\n+  decl2_v = decl2_node->function_version ();\n \n   if (decl1_v != NULL && decl2_v != NULL)\n     return;\n \n   if (decl1_v == NULL)\n-    decl1_v = insert_new_cgraph_node_version (decl1_node);\n+    decl1_v = decl1_node->insert_new_function_version ();\n \n   if (decl2_v == NULL)\n-    decl2_v = insert_new_cgraph_node_version (decl2_node);\n+    decl2_v = decl2_node->insert_new_function_version ();\n \n   /* Chain decl2_v and decl1_v.  All semantically identical versions\n      will be chained together.  */\n@@ -282,7 +281,7 @@ record_function_versions (tree decl1, tree decl2)\n \n /* Macros to access the next item in the list of free cgraph nodes and\n    edges. */\n-#define NEXT_FREE_NODE(NODE) cgraph ((NODE)->next)\n+#define NEXT_FREE_NODE(NODE) dyn_cast<cgraph_node *> ((NODE)->next)\n #define SET_NEXT_FREE_NODE(NODE,NODE2) ((NODE))->next = NODE2\n #define NEXT_FREE_EDGE(EDGE) (EDGE)->prev_caller\n \n@@ -399,12 +398,12 @@ cgraph_remove_function_insertion_hook (struct cgraph_node_hook_list *entry)\n \n /* Call all node insertion hooks.  */\n void\n-cgraph_call_function_insertion_hooks (struct cgraph_node *node)\n+cgraph_node::call_function_insertion_hooks (void)\n {\n   struct cgraph_node_hook_list *entry = first_cgraph_function_insertion_hook;\n   while (entry)\n   {\n-    entry->hook (node, entry->data);\n+    entry->hook (this, entry->data);\n     entry = entry->next;\n   }\n }\n@@ -482,13 +481,12 @@ cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *entry)\n \n /* Call all node duplication hooks.  */\n void\n-cgraph_call_node_duplication_hooks (struct cgraph_node *node1,\n-\t\t\t\t    struct cgraph_node *node2)\n+cgraph_node::call_duplication_hooks (struct cgraph_node *node2)\n {\n   struct cgraph_2node_hook_list *entry = first_cgraph_node_duplicated_hook;\n   while (entry)\n   {\n-    entry->hook (node1, node2, entry->data);\n+    entry->hook (this, node2, entry->data);\n     entry = entry->next;\n   }\n }\n@@ -516,8 +514,8 @@ cgraph_allocate_node (void)\n \n /* Allocate new callgraph node and insert it into basic data structures.  */\n \n-struct cgraph_node *\n-cgraph_create_empty_node (void)\n+cgraph_node *\n+cgraph_node::create_empty (void)\n {\n   struct cgraph_node *node = cgraph_allocate_node ();\n \n@@ -530,18 +528,18 @@ cgraph_create_empty_node (void)\n \n /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n \n-struct cgraph_node *\n-cgraph_create_node (tree decl)\n+cgraph_node *\n+cgraph_node::create (tree decl)\n {\n-  struct cgraph_node *node = cgraph_create_empty_node ();\n+  struct cgraph_node *node = cgraph_node::create_empty ();\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   node->decl = decl;\n-  symtab_register_node (node);\n+  node->register_symbol ();\n \n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n-      node->origin = cgraph_get_create_node (DECL_CONTEXT (decl));\n+      node->origin = cgraph_node::get_create (DECL_CONTEXT (decl));\n       node->next_nested = node->origin->nested;\n       node->origin->nested = node;\n     }\n@@ -551,15 +549,15 @@ cgraph_create_node (tree decl)\n /* Try to find a call graph node for declaration DECL and if it does not exist\n    or if it corresponds to an inline clone, create a new one.  */\n \n-struct cgraph_node *\n-cgraph_get_create_node (tree decl)\n+cgraph_node *\n+cgraph_node::get_create (tree decl)\n {\n-  struct cgraph_node *first_clone = cgraph_get_node (decl);\n+  struct cgraph_node *first_clone = cgraph_node::get (decl);\n \n   if (first_clone && !first_clone->global.inlined_to)\n     return first_clone;\n \n-  struct cgraph_node *node = cgraph_create_node (decl);\n+  struct cgraph_node *node = cgraph_node::create (decl);\n   if (first_clone)\n     {\n       first_clone->clone_of = node;\n@@ -581,15 +579,15 @@ cgraph_get_create_node (tree decl)\n /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n    the function body is associated with (not necessarily cgraph_node (DECL).  */\n \n-struct cgraph_node *\n-cgraph_create_function_alias (tree alias, tree target)\n+cgraph_node *\n+cgraph_node::create_alias (tree alias, tree target)\n {\n-  struct cgraph_node *alias_node;\n+  cgraph_node *alias_node;\n \n   gcc_assert (TREE_CODE (target) == FUNCTION_DECL\n \t      || TREE_CODE (target) == IDENTIFIER_NODE);\n   gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n-  alias_node = cgraph_get_create_node (alias);\n+  alias_node = cgraph_node::get_create (alias);\n   gcc_assert (!alias_node->definition);\n   alias_node->alias_target = target;\n   alias_node->definition = true;\n@@ -602,10 +600,11 @@ cgraph_create_function_alias (tree alias, tree target)\n /* Attempt to mark ALIAS as an alias to DECL.  Return alias node if successful\n    and NULL otherwise.\n    Same body aliases are output whenever the body of DECL is output,\n-   and cgraph_get_node (ALIAS) transparently returns cgraph_get_node (DECL).  */\n+   and cgraph_node::get (ALIAS) transparently returns\n+   cgraph_node::get (DECL).  */\n \n struct cgraph_node *\n-cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree alias, tree decl)\n+cgraph_node::create_same_body_alias (tree alias, tree decl)\n {\n   struct cgraph_node *n;\n #ifndef ASM_OUTPUT_DEF\n@@ -617,11 +616,10 @@ cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree ali\n   if (cgraph_global_info_ready)\n     return NULL;\n \n-  n = cgraph_create_function_alias (alias, decl);\n+  n = cgraph_node::create_alias (alias, decl);\n   n->cpp_implicit_alias = true;\n   if (cpp_implicit_aliases_done)\n-    symtab_resolve_alias (n,\n-\t\t\t  cgraph_get_node (decl));\n+    n->resolve_alias (cgraph_node::get (decl));\n   return n;\n }\n \n@@ -630,20 +628,19 @@ cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree ali\n    See comments in thunk_adjust for detail on the parameters.  */\n \n struct cgraph_node *\n-cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n-\t\t  tree alias, tree decl ATTRIBUTE_UNUSED,\n-\t\t  bool this_adjusting,\n-\t\t  HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value,\n-\t\t  tree virtual_offset,\n-\t\t  tree real_alias)\n+cgraph_node::create_thunk (tree alias, tree, bool this_adjusting,\n+\t\t\t   HOST_WIDE_INT fixed_offset,\n+\t\t\t   HOST_WIDE_INT virtual_value,\n+\t\t\t   tree virtual_offset,\n+\t\t\t   tree real_alias)\n {\n   struct cgraph_node *node;\n \n-  node = cgraph_get_node (alias);\n+  node = cgraph_node::get (alias);\n   if (node)\n-    cgraph_reset_node (node);\n+    node->reset ();\n   else\n-    node = cgraph_create_node (alias);\n+    node = cgraph_node::create (alias);\n   gcc_checking_assert (!virtual_offset\n \t\t       || wi::eq_p (virtual_offset, virtual_value));\n   node->thunk.fixed_offset = fixed_offset;\n@@ -660,8 +657,8 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n    Return NULL if there's no such node.  */\n \n-struct cgraph_node *\n-cgraph_node_for_asm (tree asmname)\n+cgraph_node *\n+cgraph_node::get_for_asmname (tree asmname)\n {\n   /* We do not want to look at inline clones.  */\n   for (symtab_node *node = symtab_node_for_asm (asmname);\n@@ -732,31 +729,31 @@ cgraph_add_edge_to_call_site_hash (struct cgraph_edge *e)\n /* Return the callgraph edge representing the GIMPLE_CALL statement\n    CALL_STMT.  */\n \n-struct cgraph_edge *\n-cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n+cgraph_edge *\n+cgraph_node::get_edge (gimple call_stmt)\n {\n   struct cgraph_edge *e, *e2;\n   int n = 0;\n \n-  if (node->call_site_hash)\n+  if (call_site_hash)\n     return (struct cgraph_edge *)\n-      htab_find_with_hash (node->call_site_hash, call_stmt,\n+      htab_find_with_hash (call_site_hash, call_stmt,\n       \t                   htab_hash_pointer (call_stmt));\n \n   /* This loop may turn out to be performance problem.  In such case adding\n      hashtables into call nodes with very many edges is probably best\n      solution.  It is not good idea to add pointer into CALL_EXPR itself\n      because we want to make possible having multiple cgraph nodes representing\n      different clones of the same body before the body is actually cloned.  */\n-  for (e = node->callees; e; e = e->next_callee)\n+  for (e = callees; e; e = e->next_callee)\n     {\n       if (e->call_stmt == call_stmt)\n \tbreak;\n       n++;\n     }\n \n   if (!e)\n-    for (e = node->indirect_calls; e; e = e->next_callee)\n+    for (e = indirect_calls; e; e = e->next_callee)\n       {\n \tif (e->call_stmt == call_stmt)\n \t  break;\n@@ -765,10 +762,10 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)\n \n   if (n > 100)\n     {\n-      node->call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);\n-      for (e2 = node->callees; e2; e2 = e2->next_callee)\n+      call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);\n+      for (e2 = callees; e2; e2 = e2->next_callee)\n \tcgraph_add_edge_to_call_site_hash (e2);\n-      for (e2 = node->indirect_calls; e2; e2 = e2->next_callee)\n+      for (e2 = indirect_calls; e2; e2 = e2->next_callee)\n \tcgraph_add_edge_to_call_site_hash (e2);\n     }\n \n@@ -815,7 +812,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt,\n     {\n       /* Constant propagation (and possibly also inlining?) can turn an\n \t indirect call into a direct one.  */\n-      struct cgraph_node *new_callee = cgraph_get_node (decl);\n+      struct cgraph_node *new_callee = cgraph_node::get (decl);\n \n       gcc_checking_assert (new_callee);\n       e = cgraph_make_edge_direct (e, new_callee);\n@@ -832,12 +829,12 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt,\n    parameters of which only CALLEE can be NULL (when creating an indirect call\n    edge).  */\n \n-static struct cgraph_edge *\n-cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t       gimple call_stmt, gcov_type count, int freq,\n-\t\t       bool indir_unknown_callee)\n+cgraph_edge *\n+cgraph_node::create_edge (cgraph_node *caller, cgraph_node *callee,\n+\t\t\t  gimple call_stmt, gcov_type count, int freq,\n+\t\t\t  bool indir_unknown_callee)\n {\n-  struct cgraph_edge *edge;\n+  cgraph_edge *edge;\n \n   /* LTO does not actually have access to the call_stmt since these\n      have not been loaded yet.  */\n@@ -847,7 +844,8 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n \t construction of call stmt hashtable.  */\n #ifdef ENABLE_CHECKING\n       struct cgraph_edge *e;\n-      gcc_checking_assert (!(e=cgraph_edge (caller, call_stmt)) || e->speculative);\n+      gcc_checking_assert (\n+\t!(e = caller->get_edge (call_stmt)) || e->speculative);\n #endif\n \n       gcc_assert (is_gimple_call (call_stmt));\n@@ -902,24 +900,24 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n   return edge;\n }\n \n-/* Create edge from CALLER to CALLEE in the cgraph.  */\n+/* Create edge from a given function to CALLEE in the cgraph.  */\n \n struct cgraph_edge *\n-cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    gimple call_stmt, gcov_type count, int freq)\n+cgraph_node::create_edge (struct cgraph_node *callee,\n+\t\t\t  gimple call_stmt, gcov_type count, int freq)\n {\n-  struct cgraph_edge *edge = cgraph_create_edge_1 (caller, callee, call_stmt,\n-\t\t\t\t\t\t   count, freq, false);\n+  cgraph_edge *edge = cgraph_node::create_edge (this, callee, call_stmt,\n+\t\t\t\t\t\tcount, freq, false);\n \n   initialize_inline_failed (edge);\n \n   edge->next_caller = callee->callers;\n   if (callee->callers)\n     callee->callers->prev_caller = edge;\n-  edge->next_callee = caller->callees;\n-  if (caller->callees)\n-    caller->callees->prev_callee = edge;\n-  caller->callees = edge;\n+  edge->next_callee = callees;\n+  if (callees)\n+    callees->prev_callee = edge;\n+  callees = edge;\n   callee->callers = edge;\n \n   return edge;\n@@ -942,12 +940,11 @@ cgraph_allocate_init_indirect_info (void)\n    PARAM_INDEX. */\n \n struct cgraph_edge *\n-cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n-\t\t\t     int ecf_flags,\n-\t\t\t     gcov_type count, int freq)\n+cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n+\t\t\t\t   gcov_type count, int freq)\n {\n-  struct cgraph_edge *edge = cgraph_create_edge_1 (caller, NULL, call_stmt,\n-\t\t\t\t\t\t   count, freq, true);\n+  struct cgraph_edge *edge = cgraph_node::create_edge (this, NULL, call_stmt,\n+\t\t\t\t\t\t       count, freq, true);\n   tree target;\n \n   initialize_inline_failed (edge);\n@@ -964,7 +961,7 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n       HOST_WIDE_INT otr_token;\n       ipa_polymorphic_call_context context;\n \n-      get_polymorphic_call_info (caller->decl,\n+      get_polymorphic_call_info (decl,\n \t\t\t\t target,\n \t\t\t\t &otr_type, &otr_token,\n \t\t\t\t &context, call_stmt);\n@@ -982,10 +979,10 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n       edge->indirect_info->maybe_derived_type = context.maybe_derived_type;\n     }\n \n-  edge->next_callee = caller->indirect_calls;\n-  if (caller->indirect_calls)\n-    caller->indirect_calls->prev_callee = edge;\n-  caller->indirect_calls = edge;\n+  edge->next_callee = indirect_calls;\n+  if (indirect_calls)\n+    indirect_calls->prev_callee = edge;\n+  indirect_calls = edge;\n \n   return edge;\n }\n@@ -1112,7 +1109,7 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n \t       xstrdup (n2->name ()), n2->order);\n     }\n   e->speculative = true;\n-  e2 = cgraph_create_edge (n, n2, e->call_stmt, direct_count, direct_frequency);\n+  e2 = n->create_edge (n2, e->call_stmt, direct_count, direct_frequency);\n   initialize_inline_failed (e2);\n   e2->speculative = true;\n   if (TREE_NOTHROW (n2->decl))\n@@ -1126,7 +1123,7 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n   ref = n->add_reference (n2, IPA_REF_ADDR, e->call_stmt);\n   ref->lto_stmt_uid = e->lto_stmt_uid;\n   ref->speculative = e->speculative;\n-  cgraph_mark_address_taken_node (n2);\n+  n2->mark_address_taken ();\n   return e2;\n }\n \n@@ -1161,7 +1158,7 @@ cgraph_speculative_call_info (struct cgraph_edge *e,\n       /* We can take advantage of the call stmt hash.  */\n       if (e2->call_stmt)\n \t{\n-\t  e = cgraph_edge (e->caller, e2->call_stmt);\n+\t  e = e->caller->get_edge (e2->call_stmt);\n \t  gcc_assert (e->speculative && !e->indirect_unknown_callee);\n \t}\n       else\n@@ -1217,8 +1214,8 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n   gcc_assert (edge->speculative);\n   cgraph_speculative_call_info (edge, e2, edge, ref);\n   if (!callee_decl\n-      || !symtab_semantically_equivalent_p (ref->referred,\n-\t\t\t\t\t    symtab_get_node (callee_decl)))\n+      || !ref->referred->semantically_equivalent_p\n+\t   (symtab_node::get (callee_decl)))\n     {\n       if (dump_file)\n \t{\n@@ -1259,7 +1256,7 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n     cgraph_remove_edge (e2);\n   else\n-    cgraph_remove_node_and_inline_clones (e2->callee, NULL);\n+    e2->callee->remove_symbol_and_inline_clones ();\n   if (edge->caller->call_site_hash)\n     cgraph_update_edge_in_call_site_hash (edge);\n   return edge;\n@@ -1378,7 +1375,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t\t     (int64_t)e->count);\n \t  gcc_assert (e2->speculative);\n \t  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n-\t  new_stmt = gimple_ic (e->call_stmt, cgraph (ref->referred),\n+\t  new_stmt = gimple_ic (e->call_stmt, dyn_cast<cgraph_node *> (ref->referred),\n \t\t\t\te->count || e2->count\n \t\t\t\t?  RDIV (e->count * REG_BR_PROB_BASE,\n \t\t\t\t\t e->count + e2->count)\n@@ -1388,8 +1385,8 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t\t\t\t: REG_BR_PROB_BASE / 2,\n \t\t\t\te->count, e->count + e2->count);\n \t  e->speculative = false;\n-\t  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt,\n-\t\t\t\t\t\t new_stmt, false);\n+\t  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt,\n+\t\t\t\t\t\t     false);\n \t  e->frequency = compute_call_stmt_bb_frequency\n \t\t\t   (e->caller->decl, gimple_bb (e->call_stmt));\n \t  e2->frequency = compute_call_stmt_bb_frequency\n@@ -1413,7 +1410,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n #ifdef ENABLE_CHECKING\n   if (decl)\n     {\n-      node = cgraph_get_node (decl);\n+      node = cgraph_node::get (decl);\n       gcc_assert (!node || !node->clone.combined_args_to_skip);\n     }\n #endif\n@@ -1491,7 +1488,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), new_stmt);\n     }\n \n-  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt, false);\n+  e->caller->set_call_stmt_including_clones (e->call_stmt, new_stmt, false);\n \n   if (cgraph_dump_file)\n     {\n@@ -1522,7 +1519,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n      into different builtin.  */\n   if (old_call != new_call)\n     {\n-      struct cgraph_edge *e = cgraph_edge (node, old_stmt);\n+      struct cgraph_edge *e = node->get_edge (old_stmt);\n       struct cgraph_edge *ne = NULL;\n       gcov_type count;\n       int frequency;\n@@ -1555,7 +1552,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n  \t  if (e->indirect_unknown_callee || e->inline_failed)\n \t    cgraph_remove_edge (e);\n \t  else\n-\t    cgraph_remove_node_and_inline_clones (e->callee, NULL);\n+\t    e->callee->remove_symbol_and_inline_clones ();\n \t}\n       else if (new_call)\n \t{\n@@ -1568,14 +1565,14 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \n       if (new_call)\n \t{\n-\t  ne = cgraph_create_edge (node, cgraph_get_create_node (new_call),\n-\t\t\t\t   new_stmt, count, frequency);\n+\t  ne = node->create_edge (cgraph_node::get_create (new_call),\n+\t\t\t\t  new_stmt, count, frequency);\n \t  gcc_assert (ne->inline_failed);\n \t}\n     }\n   /* We only updated the call stmt; update pointer in cgraph edge..  */\n   else if (old_stmt != new_stmt)\n-    cgraph_set_call_stmt (cgraph_edge (node, old_stmt), new_stmt);\n+    cgraph_set_call_stmt (node->get_edge (old_stmt), new_stmt);\n }\n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n@@ -1585,7 +1582,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n void\n cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_stmt)\n {\n-  struct cgraph_node *orig = cgraph_get_node (cfun->decl);\n+  struct cgraph_node *orig = cgraph_node::get (cfun->decl);\n   struct cgraph_node *node;\n \n   gcc_checking_assert (orig);\n@@ -1612,56 +1609,56 @@ cgraph_update_edges_for_call_stmt (gimple old_stmt, tree old_decl, gimple new_st\n /* Remove all callees from the node.  */\n \n void\n-cgraph_node_remove_callees (struct cgraph_node *node)\n+cgraph_node::remove_callees (void)\n {\n   struct cgraph_edge *e, *f;\n \n   /* It is sufficient to remove the edges from the lists of callers of\n      the callees.  The callee list of the node can be zapped with one\n      assignment.  */\n-  for (e = node->callees; e; e = f)\n+  for (e = callees; e; e = f)\n     {\n       f = e->next_callee;\n       cgraph_call_edge_removal_hooks (e);\n       if (!e->indirect_unknown_callee)\n \tcgraph_edge_remove_callee (e);\n       cgraph_free_edge (e);\n     }\n-  for (e = node->indirect_calls; e; e = f)\n+  for (e = indirect_calls; e; e = f)\n     {\n       f = e->next_callee;\n       cgraph_call_edge_removal_hooks (e);\n       if (!e->indirect_unknown_callee)\n \tcgraph_edge_remove_callee (e);\n       cgraph_free_edge (e);\n     }\n-  node->indirect_calls = NULL;\n-  node->callees = NULL;\n-  if (node->call_site_hash)\n+  indirect_calls = NULL;\n+  callees = NULL;\n+  if (call_site_hash)\n     {\n-      htab_delete (node->call_site_hash);\n-      node->call_site_hash = NULL;\n+      htab_delete (call_site_hash);\n+      call_site_hash = NULL;\n     }\n }\n \n /* Remove all callers from the node.  */\n \n-static void\n-cgraph_node_remove_callers (struct cgraph_node *node)\n+void\n+cgraph_node::remove_callers (void)\n {\n   struct cgraph_edge *e, *f;\n \n   /* It is sufficient to remove the edges from the lists of callees of\n      the callers.  The caller list of the node can be zapped with one\n      assignment.  */\n-  for (e = node->callers; e; e = f)\n+  for (e = callers; e; e = f)\n     {\n       f = e->next_caller;\n       cgraph_call_edge_removal_hooks (e);\n       cgraph_edge_remove_caller (e);\n       cgraph_free_edge (e);\n     }\n-  node->callers = NULL;\n+  callers = NULL;\n }\n \n /* Helper function for cgraph_release_function_body and free_lang_data.\n@@ -1705,78 +1702,78 @@ release_function_body (tree decl)\n   DECL_SAVED_TREE (decl) = NULL;\n }\n \n-/* Release memory used to represent body of function NODE.\n+/* Release memory used to represent body of function.\n    Use this only for functions that are released before being translated to\n    target code (i.e. RTL).  Functions that are compiled to RTL and beyond\n    are free'd in final.c via free_after_compilation().  */\n \n void\n-cgraph_release_function_body (struct cgraph_node *node)\n+cgraph_node::release_body (void)\n {\n-  node->ipa_transforms_to_apply.release ();\n-  if (!node->used_as_abstract_origin && cgraph_state != CGRAPH_STATE_PARSING)\n+  ipa_transforms_to_apply.release ();\n+  if (!used_as_abstract_origin && cgraph_state != CGRAPH_STATE_PARSING)\n     {\n-      DECL_RESULT (node->decl) = NULL;\n-      DECL_ARGUMENTS (node->decl) = NULL;\n+      DECL_RESULT (decl) = NULL;\n+      DECL_ARGUMENTS (decl) = NULL;\n     }\n   /* If the node is abstract and needed, then do not clear DECL_INITIAL\n      of its associated function function declaration because it's\n      needed to emit debug info later.  */\n-  if (!node->used_as_abstract_origin && DECL_INITIAL (node->decl))\n-    DECL_INITIAL (node->decl) = error_mark_node;\n-  release_function_body (node->decl);\n-  if (node->lto_file_data)\n-    lto_free_function_in_decl_state_for_node (node);\n+  if (!used_as_abstract_origin && DECL_INITIAL (decl))\n+    DECL_INITIAL (decl) = error_mark_node;\n+  release_function_body (decl);\n+  if (lto_file_data)\n+    lto_free_function_in_decl_state_for_node (this);\n }\n \n-/* Remove the node from cgraph.  */\n+/* Remove function from symbol table.  */\n \n void\n-cgraph_remove_node (struct cgraph_node *node)\n+cgraph_node::remove (void)\n {\n   struct cgraph_node *n;\n-  int uid = node->uid;\n+  int uid = this->uid;\n \n-  cgraph_call_node_removal_hooks (node);\n-  cgraph_node_remove_callers (node);\n-  cgraph_node_remove_callees (node);\n-  node->ipa_transforms_to_apply.release ();\n+  cgraph_call_node_removal_hooks (this);\n+  remove_callers ();\n+  remove_callees ();\n+  ipa_transforms_to_apply.release ();\n \n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n-  node->force_output = false;\n-  node->forced_by_abi = false;\n-  for (n = node->nested; n; n = n->next_nested)\n+  force_output = false;\n+  forced_by_abi = false;\n+  for (n = nested; n; n = n->next_nested)\n     n->origin = NULL;\n-  node->nested = NULL;\n-  if (node->origin)\n+  nested = NULL;\n+  if (origin)\n     {\n-      struct cgraph_node **node2 = &node->origin->nested;\n+      struct cgraph_node **node2 = &origin->nested;\n \n-      while (*node2 != node)\n+      while (*node2 != this)\n \tnode2 = &(*node2)->next_nested;\n-      *node2 = node->next_nested;\n+      *node2 = next_nested;\n     }\n-  symtab_unregister_node (node);\n-  if (node->prev_sibling_clone)\n-    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n-  else if (node->clone_of)\n-    node->clone_of->clones = node->next_sibling_clone;\n-  if (node->next_sibling_clone)\n-    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n-  if (node->clones)\n+  unregister ();\n+  if (prev_sibling_clone)\n+    prev_sibling_clone->next_sibling_clone = next_sibling_clone;\n+  else if (clone_of)\n+    clone_of->clones = next_sibling_clone;\n+  if (next_sibling_clone)\n+    next_sibling_clone->prev_sibling_clone = prev_sibling_clone;\n+  if (clones)\n     {\n       struct cgraph_node *n, *next;\n \n-      if (node->clone_of)\n+      if (clone_of)\n         {\n-\t  for (n = node->clones; n->next_sibling_clone; n = n->next_sibling_clone)\n-\t    n->clone_of = node->clone_of;\n-\t  n->clone_of = node->clone_of;\n-\t  n->next_sibling_clone = node->clone_of->clones;\n-\t  if (node->clone_of->clones)\n-\t    node->clone_of->clones->prev_sibling_clone = n;\n-\t  node->clone_of->clones = node->clones;\n+\t  for (n = clones; n->next_sibling_clone; n = n->next_sibling_clone)\n+\t    n->clone_of = clone_of;\n+\t  n->clone_of = clone_of;\n+\t  n->next_sibling_clone = clone_of->clones;\n+\t  if (clone_of->clones)\n+\t    clone_of->clones->prev_sibling_clone = n;\n+\t  clone_of->clones = clones;\n \t}\n       else\n         {\n@@ -1785,7 +1782,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \t     tree intact.  This can happen in unreachable function removal since\n \t     we remove unreachable functions in random order, not by bottom-up\n \t     walk of clone trees.  */\n-\t  for (n = node->clones; n; n = next)\n+\t  for (n = clones; n; n = next)\n \t    {\n \t       next = n->next_sibling_clone;\n \t       n->next_sibling_clone = NULL;\n@@ -1801,45 +1798,45 @@ cgraph_remove_node (struct cgraph_node *node)\n      */\n   if (cgraph_state != CGRAPH_LTO_STREAMING)\n     {\n-      n = cgraph_get_node (node->decl);\n+      n = cgraph_node::get (decl);\n       if (!n\n \t  || (!n->clones && !n->clone_of && !n->global.inlined_to\n \t      && (cgraph_global_info_ready\n \t\t  && (TREE_ASM_WRITTEN (n->decl)\n \t\t      || DECL_EXTERNAL (n->decl)\n \t\t      || !n->analyzed\n \t\t      || (!flag_wpa && n->in_other_partition)))))\n-\tcgraph_release_function_body (node);\n+\trelease_body ();\n     }\n \n-  node->decl = NULL;\n-  if (node->call_site_hash)\n+  decl = NULL;\n+  if (call_site_hash)\n     {\n-      htab_delete (node->call_site_hash);\n-      node->call_site_hash = NULL;\n+      htab_delete (call_site_hash);\n+      call_site_hash = NULL;\n     }\n   cgraph_n_nodes--;\n \n   /* Clear out the node to NULL all pointers and add the node to the free\n      list.  */\n-  memset (node, 0, sizeof (*node));\n-  node->type = SYMTAB_FUNCTION;\n-  node->uid = uid;\n-  SET_NEXT_FREE_NODE (node, free_nodes);\n-  free_nodes = node;\n+  memset (this, 0, sizeof (*this));\n+  type = SYMTAB_FUNCTION;\n+  this->uid = uid;\n+  SET_NEXT_FREE_NODE (this, free_nodes);\n+  free_nodes = this;\n }\n \n /* Likewise indicate that a node is having address taken.  */\n \n void\n-cgraph_mark_address_taken_node (struct cgraph_node *node)\n+cgraph_node::mark_address_taken (void)\n {\n   /* Indirect inlining can figure out that all uses of the address are\n      inlined.  */\n-  if (node->global.inlined_to)\n+  if (global.inlined_to)\n     {\n       gcc_assert (cfun->after_inlining);\n-      gcc_assert (node->callers->indirect_inlining_edge);\n+      gcc_assert (callers->indirect_inlining_edge);\n       return;\n     }\n   /* FIXME: address_taken flag is used both as a shortcut for testing whether\n@@ -1848,8 +1845,8 @@ cgraph_mark_address_taken_node (struct cgraph_node *node)\n      of the object was taken (and thus it should be set on node alias is\n      referring to).  We should remove the first use and the remove the\n      following set.  */\n-  node->address_taken = 1;\n-  node = cgraph_function_or_thunk_node (node, NULL);\n+  address_taken = 1;\n+  cgraph_node *node = ultimate_alias_target ();\n   node->address_taken = 1;\n }\n \n@@ -1861,7 +1858,7 @@ cgraph_local_info (tree decl)\n   struct cgraph_node *node;\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  node = cgraph_get_node (decl);\n+  node = cgraph_node::get (decl);\n   if (!node)\n     return NULL;\n   return &node->local;\n@@ -1875,7 +1872,7 @@ cgraph_global_info (tree decl)\n   struct cgraph_node *node;\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL && cgraph_global_info_ready);\n-  node = cgraph_get_node (decl);\n+  node = cgraph_node::get (decl);\n   if (!node)\n     return NULL;\n   return &node->global;\n@@ -1889,7 +1886,7 @@ cgraph_rtl_info (tree decl)\n   struct cgraph_node *node;\n \n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  node = cgraph_get_node (decl);\n+  node = cgraph_node::get (decl);\n   if (!node\n       || (decl != current_function_decl\n \t  && !TREE_ASM_WRITTEN (node->decl)))\n@@ -1938,88 +1935,88 @@ const char * const cgraph_availability_names[] =\n   {\"unset\", \"not_available\", \"overwritable\", \"available\", \"local\"};\n \n \n-/* Dump call graph node NODE to file F.  */\n+/* Dump call graph node to file F.  */\n \n void\n-dump_cgraph_node (FILE *f, struct cgraph_node *node)\n+cgraph_node::dump (FILE *f)\n {\n   struct cgraph_edge *edge;\n   int indirect_calls_count = 0;\n \n-  dump_symtab_base (f, node);\n+  dump_base (f);\n \n-  if (node->global.inlined_to)\n+  if (global.inlined_to)\n     fprintf (f, \"  Function %s/%i is inline copy in %s/%i\\n\",\n-\t     xstrdup (node->name ()),\n-\t     node->order,\n-\t     xstrdup (node->global.inlined_to->name ()),\n-\t     node->global.inlined_to->order);\n-  if (node->clone_of)\n+\t     xstrdup (name ()),\n+\t     order,\n+\t     xstrdup (global.inlined_to->name ()),\n+\t     global.inlined_to->order);\n+  if (clone_of)\n     fprintf (f, \"  Clone of %s/%i\\n\",\n-\t     node->clone_of->asm_name (),\n-\t     node->clone_of->order);\n+\t     clone_of->asm_name (),\n+\t     clone_of->order);\n   if (cgraph_function_flags_ready)\n     fprintf (f, \"  Availability: %s\\n\",\n-\t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n+\t     cgraph_availability_names [get_availability ()]);\n \n-  if (node->profile_id)\n+  if (profile_id)\n     fprintf (f, \"  Profile id: %i\\n\",\n-\t     node->profile_id);\n-  fprintf (f, \"  First run: %i\\n\", node->tp_first_run);\n+\t     profile_id);\n+  fprintf (f, \"  First run: %i\\n\", tp_first_run);\n   fprintf (f, \"  Function flags:\");\n-  if (node->count)\n+  if (count)\n     fprintf (f, \" executed %\"PRId64\"x\",\n-\t     (int64_t)node->count);\n-  if (node->origin)\n-    fprintf (f, \" nested in: %s\", node->origin->asm_name ());\n-  if (gimple_has_body_p (node->decl))\n+\t     (int64_t)count);\n+  if (origin)\n+    fprintf (f, \" nested in: %s\", origin->asm_name ());\n+  if (gimple_has_body_p (decl))\n     fprintf (f, \" body\");\n-  if (node->process)\n+  if (process)\n     fprintf (f, \" process\");\n-  if (node->local.local)\n+  if (local.local)\n     fprintf (f, \" local\");\n-  if (node->local.redefined_extern_inline)\n+  if (local.redefined_extern_inline)\n     fprintf (f, \" redefined_extern_inline\");\n-  if (node->only_called_at_startup)\n+  if (only_called_at_startup)\n     fprintf (f, \" only_called_at_startup\");\n-  if (node->only_called_at_exit)\n+  if (only_called_at_exit)\n     fprintf (f, \" only_called_at_exit\");\n-  if (node->tm_clone)\n+  if (tm_clone)\n     fprintf (f, \" tm_clone\");\n-  if (DECL_STATIC_CONSTRUCTOR (node->decl))\n-    fprintf (f,\" static_constructor (priority:%i)\", node->get_init_priority ());\n-  if (DECL_STATIC_DESTRUCTOR (node->decl))\n-    fprintf (f,\" static_destructor (priority:%i)\", node->get_fini_priority ());\n+  if (DECL_STATIC_CONSTRUCTOR (decl))\n+    fprintf (f,\" static_constructor (priority:%i)\", get_init_priority ());\n+  if (DECL_STATIC_DESTRUCTOR (decl))\n+    fprintf (f,\" static_destructor (priority:%i)\", get_fini_priority ());\n \n   fprintf (f, \"\\n\");\n \n-  if (node->thunk.thunk_p)\n+  if (thunk.thunk_p)\n     {\n       fprintf (f, \"  Thunk\");\n-      if (node->thunk.alias)\n+      if (thunk.alias)\n         fprintf (f, \"  of %s (asm: %s)\",\n-\t         lang_hooks.decl_printable_name (node->thunk.alias, 2),\n-\t         IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->thunk.alias)));\n+\t\t lang_hooks.decl_printable_name (thunk.alias, 2),\n+\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk.alias)));\n       fprintf (f, \" fixed offset %i virtual value %i has \"\n \t       \"virtual offset %i)\\n\",\n-\t       (int)node->thunk.fixed_offset,\n-\t       (int)node->thunk.virtual_value,\n-\t       (int)node->thunk.virtual_offset_p);\n+\t       (int)thunk.fixed_offset,\n+\t       (int)thunk.virtual_value,\n+\t       (int)thunk.virtual_offset_p);\n     }\n-  if (node->alias && node->thunk.alias\n-      && DECL_P (node->thunk.alias))\n+  if (alias && thunk.alias\n+      && DECL_P (thunk.alias))\n     {\n       fprintf (f, \"  Alias of %s\",\n-\t       lang_hooks.decl_printable_name (node->thunk.alias, 2));\n-      if (DECL_ASSEMBLER_NAME_SET_P (node->thunk.alias))\n+\t       lang_hooks.decl_printable_name (thunk.alias, 2));\n+      if (DECL_ASSEMBLER_NAME_SET_P (thunk.alias))\n         fprintf (f, \" (asm: %s)\",\n-\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->thunk.alias)));\n+\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk.alias)));\n       fprintf (f, \"\\n\");\n     }\n   \n   fprintf (f, \"  Called by: \");\n \n-  for (edge = node->callers; edge; edge = edge->next_caller)\n+  for (edge = callers; edge; edge = edge->next_caller)\n     {\n       fprintf (f, \"%s/%i \", edge->caller->asm_name (),\n \t       edge->caller->order);\n@@ -2040,7 +2037,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     }\n \n   fprintf (f, \"\\n  Calls: \");\n-  for (edge = node->callees; edge; edge = edge->next_callee)\n+  for (edge = callees; edge; edge = edge->next_callee)\n     {\n       fprintf (f, \"%s/%i \", edge->callee->asm_name (),\n \t       edge->callee->order);\n@@ -2061,45 +2058,35 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     }\n   fprintf (f, \"\\n\");\n \n-  for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n+  for (edge = indirect_calls; edge; edge = edge->next_callee)\n     indirect_calls_count++;\n   if (indirect_calls_count)\n     fprintf (f, \"  Has %i outgoing edges for indirect calls.\\n\",\n \t     indirect_calls_count);\n }\n \n-\n /* Dump call graph node NODE to stderr.  */\n \n DEBUG_FUNCTION void\n-debug_cgraph_node (struct cgraph_node *node)\n+cgraph_node::debug (void)\n {\n-  dump_cgraph_node (stderr, node);\n+  dump (stderr);\n }\n \n-\n /* Dump the callgraph to file F.  */\n \n void\n-dump_cgraph (FILE *f)\n+cgraph_node::dump_cgraph (FILE *f)\n {\n   struct cgraph_node *node;\n \n   fprintf (f, \"callgraph:\\n\\n\");\n   FOR_EACH_FUNCTION (node)\n-    dump_cgraph_node (f, node);\n-}\n-\n-\n-/* Dump the call graph to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_cgraph (void)\n-{\n-  dump_cgraph (stderr);\n+    node->dump (f);\n }\n \n /* Return true when the DECL can possibly be inlined.  */\n+\n bool\n cgraph_function_possibly_inlined_p (tree decl)\n {\n@@ -2108,39 +2095,39 @@ cgraph_function_possibly_inlined_p (tree decl)\n   return DECL_POSSIBLY_INLINED (decl);\n }\n \n-/* NODE is no longer nested function; update cgraph accordingly.  */\n+/* cgraph_node is no longer nested function; update cgraph accordingly.  */\n void\n-cgraph_unnest_node (struct cgraph_node *node)\n+cgraph_node::unnest (void)\n {\n-  struct cgraph_node **node2 = &node->origin->nested;\n-  gcc_assert (node->origin);\n+  struct cgraph_node **node2 = &origin->nested;\n+  gcc_assert (origin);\n \n-  while (*node2 != node)\n+  while (*node2 != this)\n     node2 = &(*node2)->next_nested;\n-  *node2 = node->next_nested;\n-  node->origin = NULL;\n+  *node2 = next_nested;\n+  origin = NULL;\n }\n \n /* Return function availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability\n-cgraph_function_body_availability (struct cgraph_node *node)\n+cgraph_node::get_availability (void)\n {\n   enum availability avail;\n-  if (!node->analyzed)\n+  if (!analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n-  else if (node->local.local)\n+  else if (local.local)\n     avail = AVAIL_LOCAL;\n-  else if (node->alias && node->weakref)\n-    cgraph_function_or_thunk_node (node, &avail);\n-  else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (node->decl)))\n-    avail = AVAIL_OVERWRITABLE;\n-  else if (!node->externally_visible)\n+  else if (alias && weakref)\n+    ultimate_alias_target (&avail);\n+  else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n+    avail = AVAIL_INTERPOSABLE;\n+  else if (!externally_visible)\n     avail = AVAIL_AVAILABLE;\n   /* Inline functions are safe to be analyzed even if their symbol can\n      be overwritten at runtime.  It is not meaningful to enforce any sane\n      behaviour on replacing inline function by different body.  */\n-  else if (DECL_DECLARED_INLINE_P (node->decl))\n+  else if (DECL_DECLARED_INLINE_P (decl))\n     avail = AVAIL_AVAILABLE;\n \n   /* If the function can be overwritten, return OVERWRITABLE.  Take\n@@ -2153,112 +2140,108 @@ cgraph_function_body_availability (struct cgraph_node *node)\n      AVAIL_AVAILABLE here?  That would be good reason to preserve this\n      bit.  */\n \n-  else if (decl_replaceable_p (node->decl)\n-\t   && !DECL_EXTERNAL (node->decl))\n-    avail = AVAIL_OVERWRITABLE;\n+  else if (decl_replaceable_p (decl) && !DECL_EXTERNAL (decl))\n+    avail = AVAIL_INTERPOSABLE;\n   else avail = AVAIL_AVAILABLE;\n \n   return avail;\n }\n \n /* Worker for cgraph_node_can_be_local_p.  */\n static bool\n-cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n-\t\t\t\t void *data ATTRIBUTE_UNUSED)\n+cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node, void *)\n {\n   return !(!node->force_output\n \t   && ((DECL_COMDAT (node->decl)\n \t\t&& !node->forced_by_abi\n-\t        && !symtab_used_from_object_file_p (node)\n+\t\t&& !node->used_from_object_file_p ()\n \t\t&& !node->same_comdat_group)\n \t       || !node->externally_visible));\n }\n \n-/* Return true if NODE can be made local for API change.\n+/* Return true if cgraph_node can be made local for API change.\n    Extern inline functions and C++ COMDAT functions can be made local\n    at the expense of possible code size growth if function is used in multiple\n    compilation units.  */\n bool\n-cgraph_node_can_be_local_p (struct cgraph_node *node)\n+cgraph_node::can_be_local_p (void)\n {\n-  return (!node->address_taken\n-\t  && !cgraph_for_node_and_aliases (node,\n-\t\t\t\t\t   cgraph_node_cannot_be_local_p_1,\n-\t\t\t\t\t   NULL, true));\n+  return (!address_taken\n+\t  && !call_for_symbol_thunks_and_aliases (cgraph_node_cannot_be_local_p_1,\n+\t\t\t\t\t\tNULL, true));\n }\n \n-/* Call calback on NODE, thunks and aliases associated to NODE. \n+/* Call calback on cgraph_node, thunks and aliases associated to cgraph_node.\n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n \n bool\n-cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n-\t\t\t            bool (*callback) (struct cgraph_node *, void *),\n-\t\t\t            void *data,\n-\t\t\t\t    bool include_overwritable)\n+cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n+\t\t\t\t\t\t   (cgraph_node *, void *),\n+\t\t\t\t\t\t void *data,\n+\t\t\t\t\t\t bool include_overwritable)\n {\n   struct cgraph_edge *e;\n   struct ipa_ref *ref;\n \n-  if (callback (node, data))\n+  if (callback (this, data))\n     return true;\n-  for (e = node->callers; e; e = e->next_caller)\n+  for (e = callers; e; e = e->next_caller)\n     if (e->caller->thunk.thunk_p\n \t&& (include_overwritable\n-\t    || cgraph_function_body_availability (e->caller) > AVAIL_OVERWRITABLE))\n-      if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n-\t\t\t\t\t      include_overwritable))\n+\t    || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n+      if (e->caller->call_for_symbol_thunks_and_aliases (callback, data,\n+\t\t\t\t\t\t       include_overwritable))\n \treturn true;\n \n-  FOR_EACH_ALIAS (node, ref)\n+  FOR_EACH_ALIAS (this, ref)\n     {\n       struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n       if (include_overwritable\n-\t  || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n-\tif (cgraph_for_node_thunks_and_aliases (alias, callback, data,\n-\t\t\t\t\t\tinclude_overwritable))\n+\t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tif (alias->call_for_symbol_thunks_and_aliases (callback, data,\n+\t\t\t\t\t\t     include_overwritable))\n \t  return true;\n     }\n   return false;\n }\n \n-/* Call calback on NODE and aliases associated to NODE. \n+/* Call calback on function and aliases associated to the function.\n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n \n bool\n-cgraph_for_node_and_aliases (struct cgraph_node *node,\n-\t\t\t     bool (*callback) (struct cgraph_node *, void *),\n-\t\t\t     void *data,\n-\t\t\t     bool include_overwritable)\n+cgraph_node::call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n+\t\t\t\t\t\t\t    void *),\n+\t\t\t\t\t  void *data,\n+\t\t\t\t\t  bool include_overwritable)\n {\n   struct ipa_ref *ref;\n \n-  if (callback (node, data))\n+  if (callback (this, data))\n     return true;\n \n-  FOR_EACH_ALIAS (node, ref)\n+  FOR_EACH_ALIAS (this, ref)\n     {\n       struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n       if (include_overwritable\n-\t  || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n-\tif (cgraph_for_node_and_aliases (alias, callback, data,\n-\t\t\t\t\t include_overwritable))\n+\t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tif (alias->call_for_symbol_and_aliases (callback, data,\n+\t\t\t\t\t\tinclude_overwritable))\n \t  return true;\n     }\n   return false;\n }\n \n /* Worker to bring NODE local.  */\n \n-static bool\n-cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+bool\n+cgraph_node::make_local (struct cgraph_node *node, void *)\n {\n-  gcc_checking_assert (cgraph_node_can_be_local_p (node));\n+  gcc_checking_assert (node->can_be_local_p ());\n   if (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n     {\n-      symtab_make_decl_local (node->decl);\n-\n+      node->make_decl_local ();\n       node->set_section (NULL);\n       node->set_comdat_group (NULL);\n       node->externally_visible = false;\n@@ -2268,18 +2251,17 @@ cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n       node->unique_name = (node->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t  || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP);\n       node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-      gcc_assert (cgraph_function_body_availability (node) == AVAIL_LOCAL);\n+      gcc_assert (node->get_availability () == AVAIL_LOCAL);\n     }\n   return false;\n }\n \n-/* Bring NODE local.  */\n+/* Bring cgraph node local.  */\n \n void\n-cgraph_make_node_local (struct cgraph_node *node)\n+cgraph_node::make_local (void)\n {\n-  cgraph_for_node_thunks_and_aliases (node, cgraph_make_node_local_1,\n-\t\t\t\t      NULL, true);\n+  call_for_symbol_thunks_and_aliases (cgraph_node::make_local, NULL, true);\n }\n \n /* Worker to set nothrow flag.  */\n@@ -2301,10 +2283,10 @@ cgraph_set_nothrow_flag_1 (struct cgraph_node *node, void *data)\n    if any to NOTHROW.  */\n \n void\n-cgraph_set_nothrow_flag (struct cgraph_node *node, bool nothrow)\n+cgraph_node::set_nothrow_flag (bool nothrow)\n {\n-  cgraph_for_node_thunks_and_aliases (node, cgraph_set_nothrow_flag_1,\n-\t\t\t              (void *)(size_t)nothrow, false);\n+  call_for_symbol_thunks_and_aliases (cgraph_set_nothrow_flag_1,\n+\t\t\t\t    (void *)(size_t)nothrow, false);\n }\n \n /* Worker to set const flag.  */\n@@ -2326,14 +2308,14 @@ cgraph_set_const_flag_1 (struct cgraph_node *node, void *data)\n   return false;\n }\n \n-/* Set TREE_READONLY on NODE's decl and on aliases of NODE\n+/* Set TREE_READONLY on cgraph_node's decl and on aliases of the node\n    if any to READONLY.  */\n \n void\n-cgraph_set_const_flag (struct cgraph_node *node, bool readonly, bool looping)\n+cgraph_node::set_const_flag (bool readonly, bool looping)\n {\n-  cgraph_for_node_thunks_and_aliases (node, cgraph_set_const_flag_1,\n-\t\t\t              (void *)(size_t)(readonly + (int)looping * 2),\n+  call_for_symbol_thunks_and_aliases (cgraph_set_const_flag_1,\n+\t\t\t\t    (void *)(size_t)(readonly + (int)looping * 2),\n \t\t\t\t      false);\n }\n \n@@ -2356,24 +2338,24 @@ cgraph_set_pure_flag_1 (struct cgraph_node *node, void *data)\n   return false;\n }\n \n-/* Set DECL_PURE_P on NODE's decl and on aliases of NODE\n+/* Set DECL_PURE_P on cgraph_node's decl and on aliases of the node\n    if any to PURE.  */\n \n void\n-cgraph_set_pure_flag (struct cgraph_node *node, bool pure, bool looping)\n+cgraph_node::set_pure_flag (bool pure, bool looping)\n {\n-  cgraph_for_node_thunks_and_aliases (node, cgraph_set_pure_flag_1,\n-\t\t\t              (void *)(size_t)(pure + (int)looping * 2),\n-\t\t\t\t      false);\n+  call_for_symbol_thunks_and_aliases (cgraph_set_pure_flag_1,\n+\t\t\t\t    (void *)(size_t)(pure + (int)looping * 2),\n+\t\t\t\t    false);\n }\n \n-/* Return true when NODE can not return or throw and thus\n+/* Return true when cgraph_node can not return or throw and thus\n    it is safe to ignore its side effects for IPA analysis.  */\n \n bool\n-cgraph_node_cannot_return (struct cgraph_node *node)\n+cgraph_node::cannot_return_p (void)\n {\n-  int flags = flags_from_decl_or_type (node->decl);\n+  int flags = flags_from_decl_or_type (decl);\n   if (!flag_exceptions)\n     return (flags & ECF_NORETURN) != 0;\n   else\n@@ -2389,7 +2371,7 @@ cgraph_node_cannot_return (struct cgraph_node *node)\n bool\n cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n {\n-  if (cgraph_node_cannot_return (e->caller))\n+  if (e->caller->cannot_return_p ())\n     return true;\n   if (e->indirect_unknown_callee)\n     {\n@@ -2401,65 +2383,57 @@ cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n \t\t == (ECF_NORETURN | ECF_NOTHROW));\n     }\n   else\n-    return cgraph_node_cannot_return (e->callee);\n+    return e->callee->cannot_return_p ();\n }\n \n-/* Return true when function NODE can be removed from callgraph\n+/* Return true when function can be removed from callgraph\n    if all direct calls are eliminated.  */\n \n bool\n-cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n+cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n {\n-  gcc_assert (!node->global.inlined_to);\n+  gcc_assert (!global.inlined_to);\n   /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (decl))\n     return true;\n   /* When function is needed, we can not remove it.  */\n-  if (node->force_output || node->used_from_other_partition)\n+  if (force_output || used_from_other_partition)\n     return false;\n-  if (DECL_STATIC_CONSTRUCTOR (node->decl)\n-      || DECL_STATIC_DESTRUCTOR (node->decl))\n+  if (DECL_STATIC_CONSTRUCTOR (decl)\n+      || DECL_STATIC_DESTRUCTOR (decl))\n     return false;\n   /* Only COMDAT functions can be removed if externally visible.  */\n-  if (node->externally_visible\n-      && (!DECL_COMDAT (node->decl)\n-\t  || node->forced_by_abi\n-\t  || symtab_used_from_object_file_p (node)))\n+  if (externally_visible\n+      && (!DECL_COMDAT (decl)\n+\t  || forced_by_abi\n+\t  || used_from_object_file_p ()))\n     return false;\n   return true;\n }\n \n /* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n \n static bool\n-nonremovable_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+nonremovable_p (struct cgraph_node *node, void *)\n {\n-  return !cgraph_can_remove_if_no_direct_calls_and_refs_p (node);\n+  return !node->can_remove_if_no_direct_calls_and_refs_p ();\n }\n \n-/* Return true when function NODE and its aliases can be removed from callgraph\n-   if all direct calls are eliminated.  */\n+/* Return true when function cgraph_node and its aliases can be removed from\n+   callgraph if all direct calls are eliminated.  */\n \n bool\n-cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n+cgraph_node::can_remove_if_no_direct_calls_p (void)\n {\n   /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (decl))\n     return true;\n-  if (node->address_taken)\n+  if (address_taken)\n     return false;\n-  return !cgraph_for_node_and_aliases (node, nonremovable_p, NULL, true);\n+  return !call_for_symbol_and_aliases (nonremovable_p, NULL, true);\n }\n \n-/* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n-\n-static bool\n-used_from_object_file_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n-{\n-  return symtab_used_from_object_file_p (node);\n-}\n-\n-/* Return true when function NODE can be expected to be removed\n+/* Return true when function cgraph_node can be expected to be removed\n    from program when direct calls in this compilation unit are removed.\n \n    As a special case COMDAT functions are\n@@ -2474,40 +2448,42 @@ used_from_object_file_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n    linkonce section.  */\n \n bool\n-cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node)\n+cgraph_node::will_be_removed_from_program_if_no_direct_calls_p (void)\n {\n-  gcc_assert (!node->global.inlined_to);\n-  if (cgraph_for_node_and_aliases (node, used_from_object_file_p, NULL, true))\n+  gcc_assert (!global.inlined_to);\n+\n+  if (call_for_symbol_and_aliases (used_from_object_file_p_worker,\n+\t\t\t\t   NULL, true))\n     return false;\n   if (!in_lto_p && !flag_whole_program)\n-    return cgraph_only_called_directly_p (node);\n+    return only_called_directly_p ();\n   else\n     {\n-       if (DECL_EXTERNAL (node->decl))\n+       if (DECL_EXTERNAL (decl))\n          return true;\n-      return cgraph_can_remove_if_no_direct_calls_p (node);\n+      return can_remove_if_no_direct_calls_p ();\n     }\n }\n \n \n /* Worker for cgraph_only_called_directly_p.  */\n \n static bool\n-cgraph_not_only_called_directly_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+cgraph_not_only_called_directly_p_1 (struct cgraph_node *node, void *)\n {\n-  return !cgraph_only_called_directly_or_aliased_p (node);\n+  return !node->only_called_directly_or_aliased_p ();\n }\n \n-/* Return true when function NODE and all its aliases are only called\n+/* Return true when function cgraph_node and all its aliases are only called\n    directly.\n    i.e. it is not externally visible, address was not taken and\n    it is not used in any other non-standard way.  */\n \n bool\n-cgraph_only_called_directly_p (struct cgraph_node *node)\n+cgraph_node::only_called_directly_p (void)\n {\n-  gcc_assert (cgraph_function_or_thunk_node (node, NULL) == node);\n-  return !cgraph_for_node_and_aliases (node, cgraph_not_only_called_directly_p_1,\n+  gcc_assert (ultimate_alias_target () == this);\n+  return !call_for_symbol_and_aliases (cgraph_not_only_called_directly_p_1,\n \t\t\t\t       NULL, true);\n }\n \n@@ -2517,27 +2493,27 @@ cgraph_only_called_directly_p (struct cgraph_node *node)\n static bool\n collect_callers_of_node_1 (struct cgraph_node *node, void *data)\n {\n-  vec<cgraph_edge_p> *redirect_callers = (vec<cgraph_edge_p> *)data;\n+  vec<cgraph_edge *> *redirect_callers = (vec<cgraph_edge *> *)data;\n   struct cgraph_edge *cs;\n   enum availability avail;\n-  cgraph_function_or_thunk_node (node, &avail);\n+  node->ultimate_alias_target (&avail);\n \n-  if (avail > AVAIL_OVERWRITABLE)\n+  if (avail > AVAIL_INTERPOSABLE)\n     for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n       if (!cs->indirect_inlining_edge)\n         redirect_callers->safe_push (cs);\n   return false;\n }\n \n-/* Collect all callers of NODE and its aliases that are known to lead to NODE\n-   (i.e. are not overwritable).  */\n+/* Collect all callers of cgraph_node and its aliases that are known to lead to\n+   cgraph_node (i.e. are not overwritable).  */\n \n-vec<cgraph_edge_p> \n-collect_callers_of_node (struct cgraph_node *node)\n+vec<cgraph_edge *>\n+cgraph_node::collect_callers (void)\n {\n-  vec<cgraph_edge_p> redirect_callers = vNULL;\n-  cgraph_for_node_and_aliases (node, collect_callers_of_node_1,\n-\t\t\t       &redirect_callers, false);\n+  vec<cgraph_edge *> redirect_callers = vNULL;\n+  call_for_symbol_thunks_and_aliases (collect_callers_of_node_1,\n+\t\t\t\t    &redirect_callers, false);\n   return redirect_callers;\n }\n \n@@ -2547,8 +2523,8 @@ static bool\n clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n {\n   bool skipped_thunk = false;\n-  node = cgraph_function_or_thunk_node (node, NULL);\n-  node2 = cgraph_function_or_thunk_node (node2, NULL);\n+  node = node->ultimate_alias_target ();\n+  node2 = node2->ultimate_alias_target ();\n \n   /* There are no virtual clones of thunks so check former_clone_of or if we\n      might have skipped thunks because this adjustments are no longer\n@@ -2559,7 +2535,7 @@ clone_of_p (struct cgraph_node *node, struct cgraph_node *node2)\n \treturn true;\n       if (!node->thunk.this_adjusting)\n \treturn false;\n-      node = cgraph_function_or_thunk_node (node->callees->callee, NULL);\n+      node = node->callees->callee->ultimate_alias_target ();\n       skipped_thunk = true;\n     }\n \n@@ -2653,7 +2629,7 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n     return false;\n   if (cgraph_state == CGRAPH_LTO_STREAMING)\n     return false;\n-  node = cgraph_get_node (decl);\n+  node = cgraph_node::get (decl);\n \n   /* We do not know if a node from a different partition is an alias or what it\n      aliases and therefore cannot do the former_clone_of check reliably.  When\n@@ -2665,15 +2641,16 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n       || e->callee->in_other_partition)\n     return false;\n \n+  node = node->ultimate_alias_target ();\n+\n   /* Optimizers can redirect unreachable calls or calls triggering undefined\n      behaviour to builtin_unreachable.  */\n   if (DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n       && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_UNREACHABLE)\n     return false;\n-  node = cgraph_function_or_thunk_node (node, NULL);\n \n   if (e->callee->former_clone_of != node->decl\n-      && (node != cgraph_function_or_thunk_node (e->callee, NULL))\n+      && (node != e->callee->ultimate_alias_target ())\n       && !clone_of_p (node, e->callee))\n     return true;\n   else\n@@ -2682,10 +2659,10 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n \n /* Verify cgraph nodes of given cgraph node.  */\n DEBUG_FUNCTION void\n-verify_cgraph_node (struct cgraph_node *node)\n+cgraph_node::verify_node (void)\n {\n   struct cgraph_edge *e;\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n   basic_block this_block;\n   gimple_stmt_iterator gsi;\n   bool error_found = false;\n@@ -2694,46 +2671,46 @@ verify_cgraph_node (struct cgraph_node *node)\n     return;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n-  error_found |= verify_symtab_base (node);\n-  for (e = node->callees; e; e = e->next_callee)\n+  error_found |= verify_base ();\n+  for (e = callees; e; e = e->next_callee)\n     if (e->aux)\n       {\n \terror (\"aux field set for edge %s->%s\",\n \t       identifier_to_locale (e->caller->name ()),\n \t       identifier_to_locale (e->callee->name ()));\n \terror_found = true;\n       }\n-  if (node->count < 0)\n+  if (count < 0)\n     {\n       error (\"execution count is negative\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->same_comdat_group)\n+  if (global.inlined_to && same_comdat_group)\n     {\n       error (\"inline clone in same comdat group list\");\n       error_found = true;\n     }\n-  if (!node->definition && !node->in_other_partition && node->local.local)\n+  if (!definition && !in_other_partition && local.local)\n     {\n       error (\"local symbols must be defined\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->externally_visible)\n+  if (global.inlined_to && externally_visible)\n     {\n       error (\"externally visible inline clone\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->address_taken)\n+  if (global.inlined_to && address_taken)\n     {\n       error (\"inline clone with address taken\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->force_output)\n+  if (global.inlined_to && force_output)\n     {\n       error (\"inline clone is forced to output\");\n       error_found = true;\n     }\n-  for (e = node->indirect_calls; e; e = e->next_callee)\n+  for (e = indirect_calls; e; e = e->next_callee)\n     {\n       if (e->aux)\n \t{\n@@ -2751,106 +2728,106 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error_found = true;\n \t}\n     }\n-  bool check_comdat = symtab_comdat_local_p (node);\n-  for (e = node->callers; e; e = e->next_caller)\n+  bool check_comdat = comdat_local_p ();\n+  for (e = callers; e; e = e->next_caller)\n     {\n       if (verify_edge_count_and_frequency (e))\n \terror_found = true;\n       if (check_comdat\n-\t  && !symtab_in_same_comdat_p (e->caller, node))\n+\t  && !in_same_comdat_group_p (e->caller))\n \t{\n \t  error (\"comdat-local function called by %s outside its comdat\",\n \t\t identifier_to_locale (e->caller->name ()));\n \t  error_found = true;\n \t}\n       if (!e->inline_failed)\n \t{\n-\t  if (node->global.inlined_to\n+\t  if (global.inlined_to\n \t      != (e->caller->global.inlined_to\n \t\t  ? e->caller->global.inlined_to : e->caller))\n \t    {\n \t      error (\"inlined_to pointer is wrong\");\n \t      error_found = true;\n \t    }\n-\t  if (node->callers->next_caller)\n+\t  if (callers->next_caller)\n \t    {\n \t      error (\"multiple inline callers\");\n \t      error_found = true;\n \t    }\n \t}\n       else\n-\tif (node->global.inlined_to)\n+\tif (global.inlined_to)\n \t  {\n \t    error (\"inlined_to pointer set for noninline callers\");\n \t    error_found = true;\n \t  }\n     }\n-  for (e = node->indirect_calls; e; e = e->next_callee)\n+  for (e = indirect_calls; e; e = e->next_callee)\n     if (verify_edge_count_and_frequency (e))\n       error_found = true;\n-  if (!node->callers && node->global.inlined_to)\n+  if (!callers && global.inlined_to)\n     {\n       error (\"inlined_to pointer is set but no predecessors found\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to == node)\n+  if (global.inlined_to == this)\n     {\n       error (\"inlined_to pointer refers to itself\");\n       error_found = true;\n     }\n \n-  if (node->clone_of)\n+  if (clone_of)\n     {\n       struct cgraph_node *n;\n-      for (n = node->clone_of->clones; n; n = n->next_sibling_clone)\n-        if (n == node)\n+      for (n = clone_of->clones; n; n = n->next_sibling_clone)\n+\tif (n == this)\n \t  break;\n       if (!n)\n \t{\n-\t  error (\"node has wrong clone_of\");\n+\t  error (\"cgraph_node has wrong clone_of\");\n \t  error_found = true;\n \t}\n     }\n-  if (node->clones)\n+  if (clones)\n     {\n       struct cgraph_node *n;\n-      for (n = node->clones; n; n = n->next_sibling_clone)\n-        if (n->clone_of != node)\n+      for (n = clones; n; n = n->next_sibling_clone)\n+\tif (n->clone_of != this)\n \t  break;\n       if (n)\n \t{\n-\t  error (\"node has wrong clone list\");\n+\t  error (\"cgraph_node has wrong clone list\");\n \t  error_found = true;\n \t}\n     }\n-  if ((node->prev_sibling_clone || node->next_sibling_clone) && !node->clone_of)\n+  if ((prev_sibling_clone || next_sibling_clone) && !clone_of)\n     {\n-       error (\"node is in clone list but it is not clone\");\n+       error (\"cgraph_node is in clone list but it is not clone\");\n        error_found = true;\n     }\n-  if (!node->prev_sibling_clone && node->clone_of && node->clone_of->clones != node)\n+  if (!prev_sibling_clone && clone_of && clone_of->clones != this)\n     {\n-      error (\"node has wrong prev_clone pointer\");\n+      error (\"cgraph_node has wrong prev_clone pointer\");\n       error_found = true;\n     }\n-  if (node->prev_sibling_clone && node->prev_sibling_clone->next_sibling_clone != node)\n+  if (prev_sibling_clone && prev_sibling_clone->next_sibling_clone != this)\n     {\n       error (\"double linked list of clones corrupted\");\n       error_found = true;\n     }\n \n-  if (node->analyzed && node->alias)\n+  if (analyzed && alias)\n     {\n       bool ref_found = false;\n       int i;\n       struct ipa_ref *ref = NULL;\n \n-      if (node->callees)\n+      if (callees)\n \t{\n \t  error (\"Alias has call edges\");\n           error_found = true;\n \t}\n-      for (i = 0; node->iterate_reference (i, ref); i++)\n+      for (i = 0; iterate_reference (i, ref); i++)\n \tif (ref->use != IPA_REF_ALIAS)\n \t  {\n \t    error (\"Alias has non-alias reference\");\n@@ -2869,28 +2846,28 @@ verify_cgraph_node (struct cgraph_node *node)\n \t    error_found = true;\n \t  }\n     }\n-  if (node->analyzed && node->thunk.thunk_p)\n+  if (analyzed && thunk.thunk_p)\n     {\n-      if (!node->callees)\n+      if (!callees)\n \t{\n \t  error (\"No edge out of thunk node\");\n           error_found = true;\n \t}\n-      else if (node->callees->next_callee)\n+      else if (callees->next_callee)\n \t{\n \t  error (\"More than one edge out of thunk node\");\n           error_found = true;\n \t}\n-      if (gimple_has_body_p (node->decl))\n+      if (gimple_has_body_p (decl))\n         {\n \t  error (\"Thunk is not supposed to have body\");\n           error_found = true;\n         }\n     }\n-  else if (node->analyzed && gimple_has_body_p (node->decl)\n-           && !TREE_ASM_WRITTEN (node->decl)\n-           && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to)\n-           && !flag_wpa)\n+  else if (analyzed && gimple_has_body_p (decl)\n+\t   && !TREE_ASM_WRITTEN (decl)\n+\t   && (!DECL_EXTERNAL (decl) || global.inlined_to)\n+\t   && !flag_wpa)\n     {\n       if (this_cfun->cfg)\n \t{\n@@ -2913,7 +2890,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t  pointer_set_insert (stmts, stmt);\n \t\t  if (is_gimple_call (stmt))\n \t\t    {\n-\t\t      struct cgraph_edge *e = cgraph_edge (node, stmt);\n+\t\t      struct cgraph_edge *e = get_edge (stmt);\n \t\t      tree decl = gimple_call_fndecl (stmt);\n \t\t      if (e)\n \t\t\t{\n@@ -2953,8 +2930,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t    }\n \t\t}\n \t      }\n-\t    for (i = 0;\n-\t\t node->iterate_reference (i, ref); i++)\n+\t    for (i = 0; iterate_reference (i, ref); i++)\n \t      if (ref->stmt && !pointer_set_contains (stmts, ref->stmt))\n \t\t{\n \t\t  error (\"reference to dead statement\");\n@@ -2967,7 +2943,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t/* No CFG available?!  */\n \tgcc_unreachable ();\n \n-      for (e = node->callees; e; e = e->next_callee)\n+      for (e = callees; e; e = e->next_callee)\n \t{\n \t  if (!e->aux)\n \t    {\n@@ -2979,7 +2955,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t    }\n \t  e->aux = 0;\n \t}\n-      for (e = node->indirect_calls; e; e = e->next_callee)\n+      for (e = indirect_calls; e; e = e->next_callee)\n \t{\n \t  if (!e->aux && !e->speculative)\n \t    {\n@@ -2993,60 +2969,63 @@ verify_cgraph_node (struct cgraph_node *node)\n     }\n   if (error_found)\n     {\n-      dump_cgraph_node (stderr, node);\n+      dump (stderr);\n       internal_error (\"verify_cgraph_node failed\");\n     }\n   timevar_pop (TV_CGRAPH_VERIFY);\n }\n \n /* Verify whole cgraph structure.  */\n DEBUG_FUNCTION void\n-verify_cgraph (void)\n+cgraph_node::verify_cgraph_nodes (void)\n {\n   struct cgraph_node *node;\n \n   if (seen_error ())\n     return;\n \n   FOR_EACH_FUNCTION (node)\n-    verify_cgraph_node (node);\n+    node->verify ();\n }\n \n-/* Given NODE, walk the alias chain to return the function NODE is alias of.\n+/* Walk the alias chain to return the function cgraph_node is alias of.\n    Walk through thunk, too.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n-struct cgraph_node *\n-cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n+cgraph_node *\n+cgraph_node::function_symbol (enum availability *availability)\n {\n+  cgraph_node *node = NULL;\n+\n   do\n     {\n-      node = cgraph_function_or_thunk_node (node, availability);\n+      node = ultimate_alias_target (availability);\n       if (node->thunk.thunk_p)\n \t{\n \t  node = node->callees->callee;\n \t  if (availability)\n \t    {\n \t      enum availability a;\n-\t      a = cgraph_function_body_availability (node);\n+\t      a = node->get_availability ();\n \t      if (a < *availability)\n \t\t*availability = a;\n \t    }\n-\t  node = cgraph_function_or_thunk_node (node, availability);\n+\t  node = node->ultimate_alias_target (availability);\n \t}\n     } while (node && node->thunk.thunk_p);\n   return node;\n }\n \n-/* When doing LTO, read NODE's body from disk if it is not already present.  */\n+/* When doing LTO, read cgraph_node's body from disk if it is not already\n+   present.  */\n \n bool\n-cgraph_get_body (struct cgraph_node *node)\n+cgraph_node::get_body (void)\n {\n   struct lto_file_decl_data *file_data;\n   const char *data, *name;\n   size_t len;\n-  tree decl = node->decl;\n+  tree decl = this->decl;\n \n   if (DECL_RESULT (decl))\n     return false;\n@@ -3055,7 +3034,7 @@ cgraph_get_body (struct cgraph_node *node)\n \n   timevar_push (TV_IPA_LTO_GIMPLE_IN);\n \n-  file_data = node->lto_file_data;\n+  file_data = lto_file_data;\n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n   /* We may have renamed the declaration, e.g., a static function.  */\n@@ -3065,19 +3044,19 @@ cgraph_get_body (struct cgraph_node *node)\n \t\t\t       name, &len);\n   if (!data)\n     {\n-\tdump_cgraph_node (stderr, node);\n+\tdebug ();\n     fatal_error (\"%s: section %s is missing\",\n \t\t file_data->file_name,\n \t\t name);\n     }\n \n   gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n \n-  lto_input_function_body (file_data, node, data);\n+  lto_input_function_body (file_data, this, data);\n   lto_stats.num_function_bodies++;\n   lto_free_section_data (file_data, LTO_section_function_body, name,\n \t\t\t data, len);\n-  lto_free_function_in_decl_state_for_node (node);\n+  lto_free_function_in_decl_state_for_node (this);\n \n   timevar_pop (TV_IPA_LTO_GIMPLE_IN);\n "}, {"sha": "eb80f990241c2c06ef0fbe4d5cacbabdbc755273", "filename": "gcc/cgraph.h", "status": "modified", "additions": 895, "deletions": 544, "changes": 1439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -50,6 +50,40 @@ struct GTY(()) section_hash_entry_d\n \n typedef struct section_hash_entry_d section_hash_entry;\n \n+enum availability\n+{\n+  /* Not yet set by cgraph_function_body_availability.  */\n+  AVAIL_UNSET,\n+  /* Function body/variable initializer is unknown.  */\n+  AVAIL_NOT_AVAILABLE,\n+  /* Function body/variable initializer is known but might be replaced\n+     by a different one from other compilation unit and thus needs to\n+     be dealt with a care.  Like AVAIL_NOT_AVAILABLE it can have\n+     arbitrary side effects on escaping variables and functions, while\n+     like AVAILABLE it might access static variables.  */\n+  AVAIL_INTERPOSABLE,\n+  /* Function body/variable initializer is known and will be used in final\n+     program.  */\n+  AVAIL_AVAILABLE,\n+  /* Function body/variable initializer is known and all it's uses are\n+     explicitly visible within current unit (ie it's address is never taken and\n+     it is not exported to other units). Currently used only for functions.  */\n+  AVAIL_LOCAL\n+};\n+\n+/* Classification of symbols WRT partitioning.  */\n+enum symbol_partitioning_class\n+{\n+   /* External declarations are ignored by partitioning algorithms and they are\n+      added into the boundary later via compute_ltrans_boundary.  */\n+   SYMBOL_EXTERNAL,\n+   /* Partitioned symbols are pur into one of partitions.  */\n+   SYMBOL_PARTITION,\n+   /* Duplicated symbols (such as comdat or constant pool references) are\n+      copied into every node needing them via add_symbol_to_partition.  */\n+   SYMBOL_DUPLICATE\n+};\n+\n /* Base of all entries in the symbol table.\n    The symtab_node is inherited by cgraph and varpol nodes.  */\n class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n@@ -63,6 +97,261 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Return asm name.  */\n   const char * asm_name () const;\n \n+  /* Add node into symbol table.  This function is not used directly, but via\n+     cgraph/varpool node creation routines.  */\n+  void register_symbol (void);\n+\n+  /* Remove symbol from symbol table.  */\n+  void remove (void);\n+\n+  /* Dump symtab node to F.  */\n+  void dump (FILE *f);\n+\n+  /* Dump symtab node to stderr.  */\n+  void DEBUG_FUNCTION debug (void);\n+\n+  /* Verify consistency of node.  */\n+  void DEBUG_FUNCTION verify (void);\n+\n+  /* Return ipa reference from this symtab_node to\n+     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+     of the use and STMT the statement (if it exists).  */\n+  struct ipa_ref *add_reference (symtab_node *referred_node,\n+\t\t\t\t enum ipa_ref_use use_type);\n+\n+  /* Return ipa reference from this symtab_node to\n+     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+     of the use and STMT the statement (if it exists).  */\n+  struct ipa_ref *add_reference (symtab_node *referred_node,\n+\t\t\t\t enum ipa_ref_use use_type, gimple stmt);\n+\n+  /* If VAL is a reference to a function or a variable, add a reference from\n+     this symtab_node to the corresponding symbol table node.  USE_TYPE specify\n+     type of the use and STMT the statement (if it exists).  Return the new\n+     reference or NULL if none was created.  */\n+  struct ipa_ref *maybe_add_reference (tree val, enum ipa_ref_use use_type,\n+\t\t\t\t       gimple stmt);\n+\n+  /* Clone all references from symtab NODE to this symtab_node.  */\n+  void clone_references (symtab_node *node);\n+\n+  /* Remove all stmt references in non-speculative references.\n+     Those are not maintained during inlining & clonning.\n+     The exception are speculative references that are updated along\n+     with callgraph edges associated with them.  */\n+  void clone_referring (symtab_node *node);\n+\n+  /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n+  struct ipa_ref *clone_reference (struct ipa_ref *ref, gimple stmt);\n+\n+  /* Find the structure describing a reference to REFERRED_NODE\n+     and associated with statement STMT.  */\n+  struct ipa_ref *find_reference (symtab_node *referred_node, gimple stmt,\n+\t\t\t\t  unsigned int lto_stmt_uid);\n+\n+  /* Remove all references that are associated with statement STMT.  */\n+  void remove_stmt_references (gimple stmt);\n+\n+  /* Remove all stmt references in non-speculative references.\n+     Those are not maintained during inlining & clonning.\n+     The exception are speculative references that are updated along\n+     with callgraph edges associated with them.  */\n+  void clear_stmts_in_references (void);\n+\n+  /* Remove all references in ref list.  */\n+  void remove_all_references (void);\n+\n+  /* Remove all referring items in ref list.  */\n+  void remove_all_referring (void);\n+\n+  /* Dump references in ref list to FILE.  */\n+  void dump_references (FILE *file);\n+\n+  /* Dump referring in list to FILE.  */\n+  void dump_referring (FILE *);\n+\n+  /* Iterates I-th reference in the list, REF is also set.  */\n+  struct ipa_ref *iterate_reference (unsigned i, struct ipa_ref *&ref);\n+\n+  /* Iterates I-th referring item in the list, REF is also set.  */\n+  struct ipa_ref *iterate_referring (unsigned i, struct ipa_ref *&ref);\n+\n+  /* Iterates I-th referring alias item in the list, REF is also set.  */\n+  struct ipa_ref *iterate_direct_aliases (unsigned i, struct ipa_ref *&ref);\n+\n+  /* Return true if symtab node and TARGET represents\n+     semantically equivalent symbols.  */\n+  bool semantically_equivalent_p (symtab_node *target);\n+\n+  /* Classify symbol symtab node for partitioning.  */\n+  enum symbol_partitioning_class get_partitioning_class (void);\n+\n+  /* Return comdat group.  */\n+  tree get_comdat_group ()\n+    {\n+      return x_comdat_group;\n+    }\n+\n+  /* Return comdat group as identifier_node.  */\n+  tree get_comdat_group_id ()\n+    {\n+      if (x_comdat_group && TREE_CODE (x_comdat_group) != IDENTIFIER_NODE)\n+\tx_comdat_group = DECL_ASSEMBLER_NAME (x_comdat_group);\n+      return x_comdat_group;\n+    }\n+\n+  /* Set comdat group.  */\n+  void set_comdat_group (tree group)\n+    {\n+      gcc_checking_assert (!group || TREE_CODE (group) == IDENTIFIER_NODE\n+\t\t\t   || DECL_P (group));\n+      x_comdat_group = group;\n+    }\n+\n+  /* Return section as string.  */\n+  const char * get_section ()\n+    {\n+      if (!x_section)\n+\treturn NULL;\n+      return x_section->name;\n+    }\n+\n+  /* Remove node from same comdat group.   */\n+  void remove_from_same_comdat_group (void);\n+\n+  /* Add this symtab_node to the same comdat group that OLD is in.  */\n+  void add_to_same_comdat_group (symtab_node *old_node);\n+\n+  /* Dissolve the same_comdat_group list in which NODE resides.  */\n+  void dissolve_same_comdat_group_list (void);\n+\n+  /* Return true when symtab_node is known to be used from other (non-LTO)\n+     object file. Known only when doing LTO via linker plugin.  */\n+  bool used_from_object_file_p (void);\n+\n+  /* Walk the alias chain to return the symbol NODE is alias of.\n+     If NODE is not an alias, return NODE.\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+  symtab_node *ultimate_alias_target (enum availability *avail = NULL);\n+\n+  /* Return next reachable static symbol with initializer after NODE.  */\n+  inline symtab_node *next_defined_symbol (void);\n+\n+  /* Add reference recording that symtab node is alias of TARGET.\n+     The function can fail in the case of aliasing cycles; in this case\n+     it returns false.  */\n+  bool resolve_alias (symtab_node *target);\n+\n+  /* C++ FE sometimes change linkage flags after producing same\n+     body aliases.  */\n+  void fixup_same_cpp_alias_visibility (symtab_node *target);\n+\n+  /* Call calback on symtab node and aliases associated to this node.\n+     When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+     skipped. */\n+  bool call_for_symbol_and_aliases (bool (*callback) (symtab_node *, void *),\n+\t\t\t\t  void *data,\n+\t\t\t\t  bool include_overwrite);\n+\n+  /* If node can not be interposable by static or dynamic linker to point to\n+     different definition, return this symbol. Otherwise look for alias with\n+     such property and if none exists, introduce new one.  */\n+  symtab_node *noninterposable_alias (void);\n+\n+  /* Return node that alias is aliasing.  */\n+  inline symtab_node *get_alias_target (void);\n+\n+  /* Set section for symbol and its aliases.  */\n+  void set_section (const char *section);\n+\n+  /* Set section, do not recurse into aliases.\n+     When one wants to change section of symbol and its aliases,\n+     use set_section.  */\n+  void set_section_for_node (const char *section);\n+\n+  /* Set initialization priority to PRIORITY.  */\n+  void set_init_priority (priority_type priority);\n+\n+  /* Return the initialization priority.  */\n+  priority_type get_init_priority ();\n+\n+  /* Return availability of NODE.  */\n+  enum availability get_availability (void);\n+\n+  /* Make DECL local.  */\n+  void make_decl_local (void);\n+\n+  /* Return true if list contains an alias.  */\n+  bool has_aliases_p (void);\n+\n+  /* Return true when the symbol is real symbol, i.e. it is not inline clone\n+     or abstract function kept for debug info purposes only.  */\n+  bool real_symbol_p (void);\n+\n+  /* Return true if NODE can be discarded by linker from the binary.  */\n+  inline bool\n+  can_be_discarded_p (void)\n+  {\n+    return (DECL_EXTERNAL (decl)\n+\t    || (get_comdat_group ()\n+\t\t&& resolution != LDPR_PREVAILING_DEF\n+\t\t&& resolution != LDPR_PREVAILING_DEF_IRONLY\n+\t\t&& resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n+  }\n+\n+  /* Return true if NODE is local to a particular COMDAT group, and must not\n+     be named from outside the COMDAT.  This is used for C++ decloned\n+     constructors.  */\n+  inline bool comdat_local_p (void)\n+  {\n+    return (same_comdat_group && !TREE_PUBLIC (decl));\n+  }\n+\n+  /* Return true if ONE and TWO are part of the same COMDAT group.  */\n+  inline bool in_same_comdat_group_p (symtab_node *target);\n+\n+  /* Return true when there is a reference to node and it is not vtable.  */\n+  bool address_taken_from_non_vtable_p (void);\n+\n+  /* Return true if symbol is known to be nonzero.  */\n+  bool nonzero_address ();\n+\n+  /* Return symbol table node associated with DECL, if any,\n+     and NULL otherwise.  */\n+  static inline symtab_node *get (const_tree decl)\n+  {\n+#ifdef ENABLE_CHECKING\n+    /* Check that we are called for sane type of object - functions\n+       and static or external variables.  */\n+    gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t\t || (TREE_CODE (decl) == VAR_DECL\n+\t\t\t     && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n+\t\t\t\t || in_lto_p)));\n+    /* Check that the mapping is sane - perhaps this check can go away,\n+       but at the moment frontends tends to corrupt the mapping by calling\n+       memcpy/memset on the tree nodes.  */\n+    gcc_checking_assert (!decl->decl_with_vis.symtab_node\n+\t\t\t || decl->decl_with_vis.symtab_node->decl == decl);\n+#endif\n+    return decl->decl_with_vis.symtab_node;\n+  }\n+\n+  /* Dump symbol table to F.  */\n+  static void dump_table (FILE *);\n+\n+  /* Dump symbol table to stderr.  */\n+  static inline DEBUG_FUNCTION void debug_symtab (void)\n+  {\n+    dump_table (stderr);\n+  }\n+\n+  /* Verify symbol table for internal consistency.  */\n+  static DEBUG_FUNCTION void verify_symtab_nodes (void);\n+\n+  /* Return true when NODE is known to be used from other (non-LTO)\n+     object file. Known only when doing LTO via linker plugin.  */\n+  static bool used_from_object_file_p_worker (symtab_node *node);\n+\n   /* Type of the symbol.  */\n   ENUM_BITFIELD (symtab_type) type : 8;\n \n@@ -156,106 +445,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   symtab_node *next_sharing_asm_name;\n   symtab_node *previous_sharing_asm_name;\n \n-  /* Circular list of nodes in the same comdat group if non-NULL.  */\n-  symtab_node *same_comdat_group;\n-\n-  /* Return comdat group.  */\n-  tree get_comdat_group ()\n-    {\n-      return x_comdat_group;\n-    }\n-\n-  /* Return comdat group as identifier_node.  */\n-  tree get_comdat_group_id ()\n-    {\n-      if (x_comdat_group && TREE_CODE (x_comdat_group) != IDENTIFIER_NODE)\n-\tx_comdat_group = DECL_ASSEMBLER_NAME (x_comdat_group);\n-      return x_comdat_group;\n-    }\n-\n-  /* Set comdat group.  */\n-  void set_comdat_group (tree group)\n-    {\n-      gcc_checking_assert (!group || TREE_CODE (group) == IDENTIFIER_NODE\n-\t\t\t   || DECL_P (group));\n-      x_comdat_group = group;\n-    }\n-\n-  /* Return section as string.  */\n-  const char * get_section ()\n-    {\n-      if (!x_section)\n-\treturn NULL;\n-      return x_section->name;\n-    }\n-\n-  /* Return ipa reference from this symtab_node to\n-     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n-     of the use and STMT the statement (if it exists).  */\n-  struct ipa_ref *add_reference (symtab_node *referred_node,\n-\t\t\t\tenum ipa_ref_use use_type);\n-\n-  /* Return ipa reference from this symtab_node to\n-     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n-     of the use and STMT the statement (if it exists).  */\n-  struct ipa_ref *add_reference (symtab_node *referred_node,\n-\t\t\t\t enum ipa_ref_use use_type, gimple stmt);\n-\n-  /* If VAL is a reference to a function or a variable, add a reference from\n-     this symtab_node to the corresponding symbol table node.  USE_TYPE specify\n-     type of the use and STMT the statement (if it exists).  Return the new\n-     reference or NULL if none was created.  */\n-  struct ipa_ref *maybe_add_reference (tree val, enum ipa_ref_use use_type,\n-\t\t\t\t       gimple stmt);\n-\n-  /* Clone all references from symtab NODE to this symtab_node.  */\n-  void clone_references (symtab_node *node);\n-\n-  /* Remove all stmt references in non-speculative references.\n-     Those are not maintained during inlining & clonning.\n-     The exception are speculative references that are updated along\n-     with callgraph edges associated with them.  */\n-  void clone_referring (symtab_node *node);\n-\n-  /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n-  struct ipa_ref *clone_reference (struct ipa_ref *ref, gimple stmt);\n-\n-  /* Find the structure describing a reference to REFERRED_NODE\n-     and associated with statement STMT.  */\n-  struct ipa_ref *find_reference (symtab_node *, gimple, unsigned int);\n-\n-  /* Remove all references that are associated with statement STMT.  */\n-  void remove_stmt_references (gimple stmt);\n-\n-  /* Remove all stmt references in non-speculative references.\n-     Those are not maintained during inlining & clonning.\n-     The exception are speculative references that are updated along\n-     with callgraph edges associated with them.  */\n-  void clear_stmts_in_references (void);\n-\n-  /* Remove all references in ref list.  */\n-  void remove_all_references (void);\n-\n-  /* Remove all referring items in ref list.  */\n-  void remove_all_referring (void);\n-\n-  /* Dump references in ref list to FILE.  */\n-  void dump_references (FILE *file);\n-\n-  /* Dump referring in list to FILE.  */\n-  void dump_referring (FILE *);\n-\n-  /* Return true if list contains an alias.  */\n-  bool has_aliases_p (void);\n-\n-  /* Iterates I-th reference in the list, REF is also set.  */\n-  struct ipa_ref *iterate_reference (unsigned i, struct ipa_ref *&ref);\n-\n-  /* Iterates I-th referring item in the list, REF is also set.  */\n-  struct ipa_ref *iterate_referring (unsigned i, struct ipa_ref *&ref);\n-\n-  /* Iterates I-th referring alias item in the list, REF is also set.  */\n-  struct ipa_ref *iterate_direct_aliases (unsigned i, struct ipa_ref *&ref);\n+  /* Circular list of nodes in the same comdat group if non-NULL.  */\n+  symtab_node *same_comdat_group;\n \n   /* Vectors of referring and referenced entities.  */\n   struct ipa_ref_list ref_list;\n@@ -276,42 +467,36 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Section name. Again can be private, if allowed.  */\n   section_hash_entry *x_section;\n \n-  /* Set section for symbol and its aliases.  */\n-  void set_section (const char *section);\n-  void set_section_for_node (const char *section);\n+protected:\n+  /* Dump base fields of symtab nodes to F.  Not to be used directly.  */\n+  void dump_base (FILE *);\n \n-  void set_init_priority (priority_type priority);\n-  priority_type get_init_priority ();\n+  /* Verify common part of symtab node.  */\n+  bool DEBUG_FUNCTION verify_base (void);\n \n-  /* Return true if symbol is known to be nonzero.  */\n-  bool nonzero_address ();\n+  /* Remove node from symbol table.  This function is not used directly, but via\n+     cgraph/varpool node removal routines.  */\n+  void unregister (void);\n+\n+  /* Return the initialization and finalization priority information for\n+     DECL.  If there is no previous priority information, a freshly\n+     allocated structure is returned.  */\n+  struct symbol_priority_map *priority_info (void);\n+\n+private:\n+  /* Worker for set_section.  */\n+  static bool set_section (symtab_node *n, void *s);\n+\n+  /* Worker for symtab_resolve_alias.  */\n+  static bool set_implicit_section (symtab_node *n, void *);\n+\n+  /* Worker searching noninterposable alias.  */\n+  static bool noninterposable_alias (symtab_node *node, void *data);\n };\n \n /* Walk all aliases for NODE.  */\n #define FOR_EACH_ALIAS(node, alias) \\\n-   for (unsigned x_i = 0; node->iterate_direct_aliases (x_i, alias); x_i++)\n-\n-enum availability\n-{\n-  /* Not yet set by cgraph_function_body_availability.  */\n-  AVAIL_UNSET,\n-  /* Function body/variable initializer is unknown.  */\n-  AVAIL_NOT_AVAILABLE,\n-  /* Function body/variable initializer is known but might be replaced\n-     by a different one from other compilation unit and thus needs to\n-     be dealt with a care.  Like AVAIL_NOT_AVAILABLE it can have\n-     arbitrary side effects on escaping variables and functions, while\n-     like AVAILABLE it might access static variables.  */\n-  AVAIL_OVERWRITABLE,\n-  /* Function body/variable initializer is known and will be used in final\n-     program.  */\n-  AVAIL_AVAILABLE,\n-  /* Function body/variable initializer is known and all it's uses are explicitly\n-     visible within current unit (ie it's address is never taken and it is not\n-     exported to other units).\n-     Currently used only for functions.  */\n-  AVAIL_LOCAL\n-};\n+  for (unsigned x_i = 0; node->iterate_direct_aliases (x_i, alias); x_i++)\n \n /* This is the information that is put into the cgraph local structure\n    to recover a function.  */\n@@ -363,7 +548,7 @@ struct GTY(()) cgraph_local_info {\n struct GTY(()) cgraph_global_info {\n   /* For inline clones this points to the function they will be\n      inlined into.  */\n-  struct cgraph_node *inlined_to;\n+  cgraph_node *inlined_to;\n };\n \n /* Information about the function that is propagated by the RTL backend.\n@@ -395,11 +580,10 @@ struct GTY(()) ipa_replace_map\n   /* True when we replace a reference to old_tree.  */\n   bool ref_p;\n };\n-typedef struct ipa_replace_map *ipa_replace_map_p;\n \n struct GTY(()) cgraph_clone_info\n {\n-  vec<ipa_replace_map_p, va_gc> *tree_map;\n+  vec<ipa_replace_map *, va_gc> *tree_map;\n   bitmap args_to_skip;\n   bitmap combined_args_to_skip;\n };\n@@ -488,37 +672,472 @@ struct GTY(()) cgraph_simd_clone {\n   unsigned int cilk_elemental : 1;\n \n   /* Doubly linked list of SIMD clones.  */\n-  struct cgraph_node *prev_clone, *next_clone;\n+  cgraph_node *prev_clone, *next_clone;\n \n   /* Original cgraph node the SIMD clones were created for.  */\n-  struct cgraph_node *origin;\n+  cgraph_node *origin;\n \n   /* Annotated function arguments for the original function.  */\n   struct cgraph_simd_clone_arg GTY((length (\"%h.nargs\"))) args[1];\n };\n \n+/* Function Multiversioning info.  */\n+struct GTY(()) cgraph_function_version_info {\n+  /* The cgraph_node for which the function version info is stored.  */\n+  cgraph_node *this_node;\n+  /* Chains all the semantically identical function versions.  The\n+     first function in this chain is the version_info node of the\n+     default function.  */\n+  struct cgraph_function_version_info *prev;\n+  /* If this version node corresponds to a dispatcher for function\n+     versions, this points to the version info node of the default\n+     function, the first node in the chain.  */\n+  struct cgraph_function_version_info *next;\n+  /* If this node corresponds to a function version, this points\n+     to the dispatcher function decl, which is the function that must\n+     be called to execute the right function version at run-time.\n+\n+     If this cgraph node is a dispatcher (if dispatcher_function is\n+     true, in the cgraph_node struct) for function versions, this\n+     points to resolver function, which holds the function body of the\n+     dispatcher. The dispatcher decl is an alias to the resolver\n+     function decl.  */\n+  tree dispatcher_resolver;\n+};\n+\n+#define DEFCIFCODE(code, type, string)\tCIF_ ## code,\n+/* Reasons for inlining failures.  */\n+\n+enum cgraph_inline_failed_t {\n+#include \"cif-code.def\"\n+  CIF_N_REASONS\n+};\n+\n+enum cgraph_inline_failed_type_t\n+{\n+  CIF_FINAL_NORMAL = 0,\n+  CIF_FINAL_ERROR\n+};\n+\n+struct cgraph_edge;\n \n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n public:\n+  /* Remove the node from cgraph and all inline clones inlined into it.\n+     Skip however removal of FORBIDDEN_NODE and return true if it needs to be\n+     removed.  This allows to call the function from outer loop walking clone\n+     tree.  */\n+  bool remove_symbol_and_inline_clones (cgraph_node *forbidden_node = NULL);\n+\n+  /* Record all references from cgraph_node that are taken\n+     in statement STMT.  */\n+  void record_stmt_references (gimple stmt);\n+\n+  /* Like cgraph_set_call_stmt but walk the clone tree and update all\n+     clones sharing the same function body.\n+     When WHOLE_SPECULATIVE_EDGES is true, all three components of\n+     speculative edge gets updated.  Otherwise we update only direct\n+     call.  */\n+  void set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n+\t\t\t\t       bool update_speculative = true);\n+\n+  /* Walk the alias chain to return the function cgraph_node is alias of.\n+     Walk through thunk, too.\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+  cgraph_node *function_symbol (enum availability *avail = NULL);\n+\n+  /* Create node representing clone of N executed COUNT times.  Decrease\n+     the execution counts from original node too.\n+     The new clone will have decl set to DECL that may or may not be the same\n+     as decl of N.\n+\n+     When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n+     function's profile to reflect the fact that part of execution is handled\n+     by node.\n+     When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n+     the new clone. Otherwise the caller is responsible for doing so later.\n+\n+     If the new node is being inlined into another one, NEW_INLINED_TO should be\n+     the outline function the new one is (even indirectly) inlined to.\n+     All hooks will see this in node's global.inlined_to, when invoked.\n+     Can be NULL if the node is not inlined.  */\n+  cgraph_node *create_clone (tree decl, gcov_type count, int freq,\n+\t\t\t     bool update_original,\n+\t\t\t     vec<cgraph_edge *> redirect_callers,\n+\t\t\t     bool call_duplication_hook,\n+\t\t\t     struct cgraph_node *new_inlined_to,\n+\t\t\t     bitmap args_to_skip);\n+\n+  /* Create callgraph node clone with new declaration.  The actual body will\n+     be copied later at compilation stage.  */\n+  cgraph_node *create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n+\t\t\t\t     vec<ipa_replace_map *, va_gc> *tree_map,\n+\t\t\t\t     bitmap args_to_skip, const char * suffix);\n+\n+  /* cgraph node being removed from symbol table; see if its entry can be\n+   replaced by other inline clone.  */\n+  cgraph_node *find_replacement (void);\n+\n+  /* Create a new cgraph node which is the new version of\n+     callgraph node.  REDIRECT_CALLERS holds the callers\n+     edges which should be redirected to point to\n+     NEW_VERSION.  ALL the callees edges of the node\n+     are cloned to the new version node.  Return the new\n+     version node.\n+\n+     If non-NULL BLOCK_TO_COPY determine what basic blocks\n+     was copied to prevent duplications of calls that are dead\n+     in the clone.  */\n+\n+  cgraph_node *create_version_clone (tree new_decl,\n+\t\t\t\t    vec<cgraph_edge *> redirect_callers,\n+\t\t\t\t    bitmap bbs_to_copy);\n+\n+  /* Perform function versioning.\n+     Function versioning includes copying of the tree and\n+     a callgraph update (creating a new cgraph node and updating\n+     its callees and callers).\n+\n+     REDIRECT_CALLERS varray includes the edges to be redirected\n+     to the new version.\n+\n+     TREE_MAP is a mapping of tree nodes we want to replace with\n+     new ones (according to results of prior analysis).\n+\n+     If non-NULL ARGS_TO_SKIP determine function parameters to remove\n+     from new version.\n+     If SKIP_RETURN is true, the new version will return void.\n+     If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.\n+     If non_NULL NEW_ENTRY determine new entry BB of the clone.\n+\n+     Return the new version's cgraph node.  */\n+  cgraph_node *create_version_clone_with_body\n+    (vec<cgraph_edge *> redirect_callers,\n+     vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,\n+     bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,\n+     const char *clone_name);\n+\n+  /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n+     corresponding to cgraph_node.  */\n+  struct cgraph_function_version_info *insert_new_function_version (void);\n+\n+  /* Get the cgraph_function_version_info node corresponding to node.  */\n+  struct cgraph_function_version_info *function_version (void);\n+\n+  /* Discover all functions and variables that are trivially needed, analyze\n+     them as well as all functions and variables referred by them  */\n+  void analyze (void);\n+\n+  /* Add thunk alias into callgraph.  The alias declaration is ALIAS and it\n+     aliases DECL with an adjustments made into the first parameter.\n+     See comments in thunk_adjust for detail on the parameters.  */\n+  cgraph_node * create_thunk (tree alias, tree, bool this_adjusting,\n+\t\t\t      HOST_WIDE_INT fixed_offset,\n+\t\t\t      HOST_WIDE_INT virtual_value,\n+\t\t\t      tree virtual_offset,\n+\t\t\t      tree real_alias);\n+\n+\n+  /* Return node that alias is aliasing.  */\n+  inline cgraph_node *get_alias_target (void);\n+\n+  /* Given function symbol, walk the alias chain to return the function node\n+     is alias of. Do not walk through thunks.\n+     When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+\n+  cgraph_node *ultimate_alias_target (availability *availability = NULL);\n+\n+  /* Expand thunk NODE to gimple if possible.\n+     When FORCE_GIMPLE_THUNK is true, gimple thunk is created and\n+     no assembler is produced.\n+     When OUTPUT_ASM_THUNK is true, also produce assembler for\n+     thunks that are not lowered.  */\n+  bool expand_thunk (bool output_asm_thunks, bool force_gimple_thunk);\n+\n+  /* As an GCC extension we allow redefinition of the function.  The\n+     semantics when both copies of bodies differ is not well defined.\n+     We replace the old body with new body so in unit at a time mode\n+     we always use new body, while in normal mode we may end up with\n+     old body inlined into some functions and new body expanded and\n+     inlined in others.  */\n+  void reset (void);\n+\n+  /* Creates a wrapper from cgraph_node to TARGET node. Thunk is used for this\n+     kind of wrapper method.  */\n+  void create_wrapper (cgraph_node *target);\n+\n+  /* Verify cgraph nodes of the cgraph node.  */\n+  void DEBUG_FUNCTION verify_node (void);\n+\n+  /* Remove function from symbol table.  */\n+  void remove (void);\n+\n+  /* Dump call graph node to file F.  */\n+  void dump (FILE *f);\n+\n+  /* Dump call graph node to stderr.  */\n+  void DEBUG_FUNCTION debug (void);\n+\n+  /* When doing LTO, read cgraph_node's body from disk if it is not already\n+     present.  */\n+  bool get_body (void);\n+\n+  /* Release memory used to represent body of function.\n+     Use this only for functions that are released before being translated to\n+     target code (i.e. RTL).  Functions that are compiled to RTL and beyond\n+     are free'd in final.c via free_after_compilation().  */\n+  void release_body (void);\n+\n+  /* cgraph_node is no longer nested function; update cgraph accordingly.  */\n+  void unnest (void);\n+\n+  /* Bring cgraph node local.  */\n+  void make_local (void);\n+\n+  /* Likewise indicate that a node is having address taken.  */\n+  void mark_address_taken (void);\n+\n+  /* Set fialization priority to PRIORITY.  */\n+  void set_fini_priority (priority_type priority);\n+\n+  /* Return the finalization priority.  */\n+  priority_type get_fini_priority (void);\n+\n+  /* Create edge from a given function to CALLEE in the cgraph.  */\n+  struct cgraph_edge *create_edge (cgraph_node *callee,\n+\t\t\t\t   gimple call_stmt, gcov_type count,\n+\t\t\t\t   int freq);\n+  /* Create an indirect edge with a yet-undetermined callee where the call\n+     statement destination is a formal parameter of the caller with index\n+     PARAM_INDEX. */\n+  struct cgraph_edge *create_indirect_edge (gimple call_stmt, int ecf_flags,\n+\t\t\t\t\t    gcov_type count, int freq);\n+\n+  /* Like cgraph_create_edge walk the clone tree and update all clones sharing\n+   same function body.  If clones already have edge for OLD_STMT; only\n+   update the edge same way as cgraph_set_call_stmt_including_clones does.  */\n+  void create_edge_including_clones (struct cgraph_node *callee,\n+\t\t\t\t     gimple old_stmt, gimple stmt,\n+\t\t\t\t     gcov_type count,\n+\t\t\t\t     int freq,\n+\t\t\t\t     cgraph_inline_failed_t reason);\n+\n+  /* Return the callgraph edge representing the GIMPLE_CALL statement\n+     CALL_STMT.  */\n+  cgraph_edge *get_edge (gimple call_stmt);\n+\n+  /* Collect all callers of cgraph_node and its aliases that are known to lead\n+     to NODE (i.e. are not overwritable).  */\n+  vec<cgraph_edge *> collect_callers (void);\n+\n+  /* Remove all callers from the node.  */\n+  void remove_callers (void);\n+\n+  /* Remove all callees from the node.  */\n+  void remove_callees (void);\n+\n+  /* Return function availability.  See cgraph.h for description of individual\n+     return values.  */\n+  enum availability get_availability (void);\n+\n+  /* Set TREE_NOTHROW on cgraph_node's decl and on aliases of the node\n+     if any to NOTHROW.  */\n+  void set_nothrow_flag (bool nothrow);\n+\n+  /* Set TREE_READONLY on cgraph_node's decl and on aliases of the node\n+     if any to READONLY.  */\n+  void set_const_flag (bool readonly, bool looping);\n+\n+  /* Set DECL_PURE_P on cgraph_node's decl and on aliases of the node\n+     if any to PURE.  */\n+  void set_pure_flag (bool pure, bool looping);\n+\n+  /* Call all node duplication hooks.  */\n+  void call_duplication_hooks (cgraph_node *node2);\n+\n+  /* Call calback on function and aliases associated to the function.\n+     When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+     skipped. */\n+\n+  bool call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n+\t\t\t\t\t\t      void *),\n+\t\t\t\t    void *data, bool include_overwritable);\n+\n+  /* Call calback on cgraph_node, thunks and aliases associated to NODE.\n+     When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+     skipped.  */\n+  bool call_for_symbol_thunks_and_aliases (bool (*callback) (cgraph_node *node,\n+\t\t\t\t\t\t\t   void *data),\n+\t\t\t\t\t void *data,\n+\t\t\t\t\t bool include_overwritable);\n+\n+  /* Call all node insertion hooks.  */\n+  void call_function_insertion_hooks (void);\n+\n+  /* Likewise indicate that a node is needed, i.e. reachable via some\n+     external means.  */\n+  inline void mark_force_output (void);\n+\n+  /* Return true when function can be marked local.  */\n+  bool local_p (void);\n+\n+  /* Return true if cgraph_node can be made local for API change.\n+     Extern inline functions and C++ COMDAT functions can be made local\n+     at the expense of possible code size growth if function is used in multiple\n+     compilation units.  */\n+  bool can_be_local_p (void);\n+\n+  /* Return true when cgraph_node can not return or throw and thus\n+     it is safe to ignore its side effects for IPA analysis.  */\n+  bool cannot_return_p (void);\n+\n+  /* Return true when function cgraph_node and all its aliases are only called\n+     directly.\n+     i.e. it is not externally visible, address was not taken and\n+     it is not used in any other non-standard way.  */\n+  bool only_called_directly_p (void);\n+\n+  /* Return true when function is only called directly or it has alias.\n+     i.e. it is not externally visible, address was not taken and\n+     it is not used in any other non-standard way.  */\n+  inline bool only_called_directly_or_aliased_p (void);\n+\n+  /* Return true when function cgraph_node can be expected to be removed\n+     from program when direct calls in this compilation unit are removed.\n+\n+     As a special case COMDAT functions are\n+     cgraph_can_remove_if_no_direct_calls_p while the are not\n+     cgraph_only_called_directly_p (it is possible they are called from other\n+     unit)\n+\n+     This function behaves as cgraph_only_called_directly_p because eliminating\n+     all uses of COMDAT function does not make it necessarily disappear from\n+     the program unless we are compiling whole program or we do LTO.  In this\n+     case we know we win since dynamic linking will not really discard the\n+     linkonce section.  */\n+  bool will_be_removed_from_program_if_no_direct_calls_p (void);\n+\n+  /* Return true when function can be removed from callgraph\n+     if all direct calls are eliminated.  */\n+  bool can_remove_if_no_direct_calls_and_refs_p (void);\n+\n+  /* Return true when function cgraph_node and its aliases can be removed from\n+     callgraph if all direct calls are eliminated.  */\n+  bool can_remove_if_no_direct_calls_p (void);\n+\n+  /* Return true when callgraph node is a function with Gimple body defined\n+     in current unit.  Functions can also be define externally or they\n+     can be thunks with no Gimple representation.\n+\n+     Note that at WPA stage, the function body may not be present in memory.  */\n+  inline bool has_gimple_body_p (void);\n+\n+  /* Return true if function should be optimized for size.  */\n+  bool optimize_for_size_p (void);\n+\n+  /* Dump the callgraph to file F.  */\n+  static void dump_cgraph (FILE *f);\n+\n+  /* Dump the call graph to stderr.  */\n+  static inline void debug_cgraph (void)\n+  {\n+    dump_cgraph (stderr);\n+  }\n+\n+  /* Record that DECL1 and DECL2 are semantically identical function\n+     versions.  */\n+  static void record_function_versions (tree decl1, tree decl2);\n+\n+  /* Remove the cgraph_function_version_info and cgraph_node for DECL.  This\n+     DECL is a duplicate declaration.  */\n+  static void delete_function_version (tree decl);\n+\n+  /* Add the function FNDECL to the call graph.\n+     Unlike cgraph_finalize_function, this function is intended to be used\n+     by middle end and allows insertion of new function at arbitrary point\n+     of compilation.  The function can be either in high, low or SSA form\n+     GIMPLE.\n+\n+     The function is assumed to be reachable and have address taken (so no\n+     API breaking optimizations are performed on it).\n+\n+     Main work done by this function is to enqueue the function for later\n+     processing to avoid need the passes to be re-entrant.  */\n+  static void add_new_function (tree fndecl, bool lowered);\n+\n+  /* Return callgraph node for given symbol and check it is a function. */\n+  static inline cgraph_node *get (const_tree decl)\n+  {\n+    gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+    return dyn_cast <cgraph_node *> (symtab_node::get (decl));\n+  }\n+\n+  /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n+  static cgraph_node * create (tree decl);\n+\n+  /* Allocate new callgraph node and insert it into basic data structures.  */\n+  static cgraph_node * create_empty (void);\n+\n+  /* Try to find a call graph node for declaration DECL and if it does not\n+     exist or if it corresponds to an inline clone, create a new one.  */\n+  static cgraph_node * get_create (tree);\n+\n+  /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n+     Return NULL if there's no such node.  */\n+  static cgraph_node *get_for_asmname (tree asmname);\n+\n+  /* Attempt to mark ALIAS as an alias to DECL.  Return alias node if\n+     successful and NULL otherwise.\n+     Same body aliases are output whenever the body of DECL is output,\n+     and cgraph_node::get (ALIAS) transparently\n+     returns cgraph_node::get (DECL).  */\n+  static cgraph_node * create_same_body_alias (tree alias, tree decl);\n+\n+  /* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n+  static bool used_from_object_file_p_worker (cgraph_node *node, void *)\n+  {\n+    return node->used_from_object_file_p ();\n+  }\n+\n+  /* Return true when cgraph_node can not be local.\n+     Worker for cgraph_local_node_p.  */\n+  static bool non_local_p (cgraph_node *node, void *);\n+\n+  /* Verify whole cgraph structure.  */\n+  static void DEBUG_FUNCTION verify_cgraph_nodes (void);\n+\n+  /* Worker to bring NODE local.  */\n+  static bool make_local (cgraph_node *node, void *);\n+\n+  /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n+     the function body is associated\n+     with (not necessarily cgraph_node (DECL).  */\n+  static cgraph_node *create_alias (tree alias, tree target);\n+\n+  static cgraph_edge * create_edge (cgraph_node *caller, cgraph_node *callee,\n+\t\t\t\t    gimple call_stmt, gcov_type count,\n+\t\t\t\t    int freq,\n+\t\t\t\t    bool indir_unknown_callee);\n+\n   struct cgraph_edge *callees;\n   struct cgraph_edge *callers;\n   /* List of edges representing indirect calls with a yet undetermined\n      callee.  */\n   struct cgraph_edge *indirect_calls;\n   /* For nested functions points to function the node is nested in.  */\n-  struct cgraph_node *origin;\n+  cgraph_node *origin;\n   /* Points to first nested function, if any.  */\n-  struct cgraph_node *nested;\n+  cgraph_node *nested;\n   /* Pointer to the next function with same origin, if any.  */\n-  struct cgraph_node *next_nested;\n+  cgraph_node *next_nested;\n   /* Pointer to the next clone.  */\n-  struct cgraph_node *next_sibling_clone;\n-  struct cgraph_node *prev_sibling_clone;\n-  struct cgraph_node *clones;\n-  struct cgraph_node *clone_of;\n+  cgraph_node *next_sibling_clone;\n+  cgraph_node *prev_sibling_clone;\n+  cgraph_node *clones;\n+  cgraph_node *clone_of;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n@@ -529,7 +1148,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      information for it.  */\n   struct cgraph_simd_clone *simdclone;\n   /* If this function has SIMD clones, this points to the first clone.  */\n-  struct cgraph_node *simd_clones;\n+  cgraph_node *simd_clones;\n \n   /* Interprocedural passes scheduled to have their transform functions\n      applied next time we execute local pass on them.  We maintain it\n@@ -579,82 +1198,29 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* True if this decl calls a COMDAT-local function.  This is set up in\n      compute_inline_parameters and inline_call.  */\n   unsigned calls_comdat_local : 1;\n-\n-  void set_fini_priority (priority_type priority);\n-  priority_type get_fini_priority ();\n-};\n-\n-\n-typedef struct cgraph_node *cgraph_node_ptr;\n-\n-\n-/* Function Multiversioning info.  */\n-struct GTY(()) cgraph_function_version_info {\n-  /* The cgraph_node for which the function version info is stored.  */\n-  struct cgraph_node *this_node;\n-  /* Chains all the semantically identical function versions.  The\n-     first function in this chain is the version_info node of the\n-     default function.  */\n-  struct cgraph_function_version_info *prev;\n-  /* If this version node corresponds to a dispatcher for function\n-     versions, this points to the version info node of the default\n-     function, the first node in the chain.  */\n-  struct cgraph_function_version_info *next;\n-  /* If this node corresponds to a function version, this points\n-     to the dispatcher function decl, which is the function that must\n-     be called to execute the right function version at run-time.\n-\n-     If this cgraph node is a dispatcher (if dispatcher_function is\n-     true, in the cgraph_node struct) for function versions, this\n-     points to resolver function, which holds the function body of the\n-     dispatcher. The dispatcher decl is an alias to the resolver\n-     function decl.  */\n-  tree dispatcher_resolver;\n };\n \n-/* Get the cgraph_function_version_info node corresponding to node.  */\n-struct cgraph_function_version_info *\n-  get_cgraph_node_version (struct cgraph_node *node);\n-\n-/* Insert a new cgraph_function_version_info node into cgraph_fnver_htab\n-   corresponding to cgraph_node NODE.  */\n-struct cgraph_function_version_info *\n-  insert_new_cgraph_node_version (struct cgraph_node *node);\n-\n-/* Record that DECL1 and DECL2 are semantically identical function\n-   versions.  */\n-void record_function_versions (tree decl1, tree decl2);\n-\n-/* Remove the cgraph_function_version_info and cgraph_node for DECL.  This\n-   DECL is a duplicate declaration.  */\n-void delete_function_version (tree decl);\n-\n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node\n    can appear in multiple sets.  */\n struct cgraph_node_set_def\n {\n   struct pointer_map_t *map;\n-  vec<cgraph_node_ptr> nodes;\n+  vec<cgraph_node *> nodes;\n };\n \n-class varpool_node;\n-typedef varpool_node *varpool_node_ptr;\n+typedef cgraph_node_set_def *cgraph_node_set;\n+typedef struct varpool_node_set_def *varpool_node_set;\n \n+class varpool_node;\n \n /* A varpool node set is a collection of varpool nodes.  A varpool node\n    can appear in multiple sets.  */\n struct varpool_node_set_def\n {\n   struct pointer_map_t * map;\n-  vec<varpool_node_ptr> nodes;\n+  vec<varpool_node *> nodes;\n };\n \n-typedef struct cgraph_node_set_def *cgraph_node_set;\n-\n-\n-typedef struct varpool_node_set_def *varpool_node_set;\n-\n-\n /* Iterator structure for cgraph node sets.  */\n struct cgraph_node_set_iterator\n {\n@@ -669,19 +1235,6 @@ struct varpool_node_set_iterator\n   unsigned index;\n };\n \n-#define DEFCIFCODE(code, type, string)\tCIF_ ## code,\n-/* Reasons for inlining failures.  */\n-enum cgraph_inline_failed_t {\n-#include \"cif-code.def\"\n-  CIF_N_REASONS\n-};\n-\n-enum cgraph_inline_failed_type_t\n-{\n-  CIF_FINAL_NORMAL = 0,\n-  CIF_FINAL_ERROR\n-};\n-\n /* Structure containing additional information about an indirect call.  */\n \n struct GTY(()) cgraph_indirect_call_info\n@@ -722,8 +1275,8 @@ struct GTY(()) cgraph_indirect_call_info\n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n-  struct cgraph_node *caller;\n-  struct cgraph_node *callee;\n+  cgraph_node *caller;\n+  cgraph_node *callee;\n   struct cgraph_edge *prev_caller;\n   struct cgraph_edge *next_caller;\n   struct cgraph_edge *prev_callee;\n@@ -778,9 +1331,6 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n #define CGRAPH_FREQ_BASE 1000\n #define CGRAPH_FREQ_MAX 100000\n \n-typedef struct cgraph_edge *cgraph_edge_p;\n-\n-\n /* The varpool data structure.\n    Each static variable decl has assigned varpool_node.  */\n \n@@ -800,6 +1350,12 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n      in places where optimization would be valid for local static variable\n      if we did not do any inter-procedural code movement.  */\n   unsigned used_by_single_function : 1;\n+\n+  /* Dump given cgraph node to F.  */\n+  void dump (FILE *f);\n+\n+  /* Remove variable from symbol table.  */\n+  void remove (void);\n };\n \n /* Every top level asm statement is put into a asm_node.  */\n@@ -820,7 +1376,7 @@ template <>\n inline bool\n is_a_helper <cgraph_node *>::test (symtab_node *p)\n {\n-  return p->type == SYMTAB_FUNCTION;\n+  return p && p->type == SYMTAB_FUNCTION;\n }\n \n /* Report whether or not THIS symtab node is a vriable, aka varpool_node.  */\n@@ -830,7 +1386,7 @@ template <>\n inline bool\n is_a_helper <varpool_node *>::test (symtab_node *p)\n {\n-  return p->type == SYMTAB_VARIABLE;\n+  return p && p->type == SYMTAB_VARIABLE;\n }\n \n extern GTY(()) symtab_node *symtab_nodes;\n@@ -863,127 +1419,38 @@ extern GTY(()) struct asm_node *asm_nodes;\n extern GTY(()) int symtab_order;\n extern bool cpp_implicit_aliases_done;\n \n-/* Classifcation of symbols WRT partitioning.  */\n-enum symbol_partitioning_class\n-{\n-   /* External declarations are ignored by partitioning algorithms and they are\n-      added into the boundary later via compute_ltrans_boundary.  */\n-   SYMBOL_EXTERNAL,\n-   /* Partitioned symbols are pur into one of partitions.  */\n-   SYMBOL_PARTITION,\n-   /* Duplicated symbols (such as comdat or constant pool references) are\n-      copied into every node needing them via add_symbol_to_partition.  */\n-   SYMBOL_DUPLICATE\n-};\n-\n-\n /* In symtab.c  */\n-void symtab_register_node (symtab_node *);\n-void symtab_unregister_node (symtab_node *);\n-void symtab_remove_from_same_comdat_group (symtab_node *);\n-void symtab_remove_node (symtab_node *);\n symtab_node *symtab_node_for_asm (const_tree asmname);\n-void symtab_add_to_same_comdat_group (symtab_node *, symtab_node *);\n-void symtab_dissolve_same_comdat_group_list (symtab_node *node);\n-void dump_symtab (FILE *);\n-void debug_symtab (void);\n-void dump_symtab_node (FILE *, symtab_node *);\n-void debug_symtab_node (symtab_node *);\n-void dump_symtab_base (FILE *, symtab_node *);\n-void verify_symtab (void);\n-void verify_symtab_node (symtab_node *);\n-bool verify_symtab_base (symtab_node *);\n-bool symtab_used_from_object_file_p (symtab_node *);\n-void symtab_make_decl_local (tree);\n-symtab_node *symtab_alias_ultimate_target (symtab_node *,\n-\t\t\t\t\t  enum availability *avail = NULL);\n-bool symtab_resolve_alias (symtab_node *node, symtab_node *target);\n-void fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target);\n-bool symtab_for_node_and_aliases (symtab_node *,\n-\t\t\t\t  bool (*) (symtab_node *, void *),\n-\t\t\t\t  void *,\n-\t\t\t\t  bool);\n-symtab_node *symtab_nonoverwritable_alias (symtab_node *);\n-enum availability symtab_node_availability (symtab_node *);\n-bool symtab_semantically_equivalent_p (symtab_node *, symtab_node *);\n-enum symbol_partitioning_class symtab_get_symbol_partitioning_class (symtab_node *);\n \n /* In cgraph.c  */\n-void dump_cgraph (FILE *);\n-void debug_cgraph (void);\n-void dump_cgraph_node (FILE *, struct cgraph_node *);\n-void debug_cgraph_node (struct cgraph_node *);\n-void cgraph_remove_edge (struct cgraph_edge *);\n-void cgraph_remove_node (struct cgraph_node *);\n-void cgraph_release_function_body (struct cgraph_node *);\n void release_function_body (tree);\n-void cgraph_node_remove_callees (struct cgraph_node *node);\n-struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n-\t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\tgimple, gcov_type, int);\n-struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n-\t\t\t\t\t\t int, gcov_type, int);\n struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n-struct cgraph_node * cgraph_create_node (tree);\n-struct cgraph_node * cgraph_create_empty_node (void);\n-struct cgraph_node * cgraph_get_create_node (tree);\n-struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n-struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,\n-\t\t\t\t       HOST_WIDE_INT, tree, tree);\n-struct cgraph_node *cgraph_node_for_asm (tree);\n-struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n+void cgraph_remove_edge (struct cgraph_edge *);\n+\n void cgraph_set_call_stmt (struct cgraph_edge *, gimple, bool update_speculative = true);\n void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n-struct cgraph_node *cgraph_create_function_alias (tree, tree);\n-void cgraph_call_node_duplication_hooks (struct cgraph_node *,\n-\t\t\t\t\t struct cgraph_node *);\n void cgraph_call_edge_duplication_hooks (struct cgraph_edge *,\n \t\t\t\t         struct cgraph_edge *);\n \n-void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n-struct cgraph_edge *cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n-bool cgraph_only_called_directly_p (struct cgraph_node *);\n-\n bool cgraph_function_possibly_inlined_p (tree);\n-void cgraph_unnest_node (struct cgraph_node *);\n+bool cgraph_edge_cannot_lead_to_return (struct cgraph_edge *);\n+void cgraph_redirect_edge_callee (struct cgraph_edge *, cgraph_node *);\n+struct cgraph_edge *cgraph_make_edge_direct (struct cgraph_edge *,\n+\t\t\t\t\t     cgraph_node *);\n \n-enum availability cgraph_function_body_availability (struct cgraph_node *);\n-void cgraph_add_new_function (tree, bool);\n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n \n-void cgraph_set_nothrow_flag (struct cgraph_node *, bool);\n-void cgraph_set_const_flag (struct cgraph_node *, bool, bool);\n-void cgraph_set_pure_flag (struct cgraph_node *, bool, bool);\n-bool cgraph_node_cannot_return (struct cgraph_node *);\n-bool cgraph_edge_cannot_lead_to_return (struct cgraph_edge *);\n-bool cgraph_will_be_removed_from_program_if_no_direct_calls\n-  (struct cgraph_node *node);\n-bool cgraph_can_remove_if_no_direct_calls_and_refs_p\n-  (struct cgraph_node *node);\n-bool cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node);\n bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n-bool cgraph_for_node_thunks_and_aliases (struct cgraph_node *,\n-\t\t\t                 bool (*) (struct cgraph_node *, void *),\n-\t\t\t                 void *,\n-\t\t\t\t\t bool);\n-bool cgraph_for_node_and_aliases (struct cgraph_node *,\n-\t\t                  bool (*) (struct cgraph_node *, void *),\n-\t\t\t          void *, bool);\n-vec<cgraph_edge_p>  collect_callers_of_node (struct cgraph_node *node);\n-void verify_cgraph (void);\n-void verify_cgraph_node (struct cgraph_node *);\n-void cgraph_mark_address_taken_node (struct cgraph_node *);\n-\n typedef void (*cgraph_edge_hook)(struct cgraph_edge *, void *);\n-typedef void (*cgraph_node_hook)(struct cgraph_node *, void *);\n+typedef void (*cgraph_node_hook)(cgraph_node *, void *);\n typedef void (*varpool_node_hook)(varpool_node *, void *);\n typedef void (*cgraph_2edge_hook)(struct cgraph_edge *, struct cgraph_edge *,\n \t\t\t\t  void *);\n-typedef void (*cgraph_2node_hook)(struct cgraph_node *, struct cgraph_node *,\n+typedef void (*cgraph_2node_hook)(cgraph_node *, cgraph_node *,\n \t\t\t\t  void *);\n struct cgraph_edge_hook_list;\n struct cgraph_node_hook_list;\n@@ -992,30 +1459,26 @@ struct cgraph_2edge_hook_list;\n struct cgraph_2node_hook_list;\n struct cgraph_edge_hook_list *cgraph_add_edge_removal_hook (cgraph_edge_hook, void *);\n void cgraph_remove_edge_removal_hook (struct cgraph_edge_hook_list *);\n-struct cgraph_node_hook_list *cgraph_add_node_removal_hook (cgraph_node_hook,\n+cgraph_node_hook_list *cgraph_add_node_removal_hook (cgraph_node_hook,\n \t\t\t\t\t\t\t    void *);\n-void cgraph_remove_node_removal_hook (struct cgraph_node_hook_list *);\n+void cgraph_remove_node_removal_hook (cgraph_node_hook_list *);\n struct varpool_node_hook_list *varpool_add_node_removal_hook (varpool_node_hook,\n \t\t\t\t\t\t\t      void *);\n void varpool_remove_node_removal_hook (struct varpool_node_hook_list *);\n-struct cgraph_node_hook_list *cgraph_add_function_insertion_hook (cgraph_node_hook,\n+cgraph_node_hook_list *cgraph_add_function_insertion_hook (cgraph_node_hook,\n \t\t\t\t\t\t\t          void *);\n-void cgraph_remove_function_insertion_hook (struct cgraph_node_hook_list *);\n+void cgraph_remove_function_insertion_hook (cgraph_node_hook_list *);\n struct varpool_node_hook_list *varpool_add_variable_insertion_hook (varpool_node_hook,\n \t\t\t\t\t\t\t            void *);\n void varpool_remove_variable_insertion_hook (struct varpool_node_hook_list *);\n-void cgraph_call_function_insertion_hooks (struct cgraph_node *node);\n struct cgraph_2edge_hook_list *cgraph_add_edge_duplication_hook (cgraph_2edge_hook, void *);\n void cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *);\n struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_hook, void *);\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n-struct cgraph_node * cgraph_function_node (struct cgraph_node *,\n-\t\t\t\t\t   enum availability *avail = NULL);\n-bool cgraph_get_body (struct cgraph_node *node);\n struct cgraph_edge *\n cgraph_turn_edge_to_speculative (struct cgraph_edge *,\n-\t\t\t\t struct cgraph_node *,\n+\t\t\t\t cgraph_node *,\n \t\t\t\t gcov_type, int);\n void cgraph_speculative_call_info (struct cgraph_edge *,\n \t\t\t\t   struct cgraph_edge *&,\n@@ -1032,46 +1495,19 @@ void compile (void);\n void init_cgraph (void);\n void cgraph_process_new_functions (void);\n void cgraph_process_same_body_aliases (void);\n-void fixup_same_cpp_alias_visibility (symtab_node *, symtab_node *target, tree);\n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool);\n-void cgraph_reset_node (struct cgraph_node *);\n-bool expand_thunk (struct cgraph_node *, bool, bool);\n-void cgraph_make_wrapper (struct cgraph_node *source,\n-\t\t\t  struct cgraph_node *target);\n \n /* In cgraphclones.c  */\n \n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n-\t\t\t\t\tstruct cgraph_node *, gimple,\n+\t\t\t\t\tcgraph_node *, gimple,\n \t\t\t\t\tunsigned, gcov_type, int, bool);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n-\t\t\t\t\tint, bool, vec<cgraph_edge_p>,\n-\t\t\t\t\tbool, struct cgraph_node *, bitmap);\n tree clone_function_name (tree decl, const char *);\n-struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n-\t\t\t                          vec<cgraph_edge_p>,\n-\t\t\t                          vec<ipa_replace_map_p, va_gc> *tree_map,\n-\t\t\t                          bitmap args_to_skip,\n-\t\t\t\t\t\t  const char *clone_name);\n-struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n-bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);\n-void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple,\n-\t\t\t\t\t    bool update_speculative = true);\n-void cgraph_create_edge_including_clones (struct cgraph_node *,\n-\t\t\t\t\t  struct cgraph_node *,\n-\t\t\t\t\t  gimple, gimple, gcov_type, int,\n-\t\t\t\t\t  cgraph_inline_failed_t);\n+\n void cgraph_materialize_all_clones (void);\n-struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n-\t\ttree, vec<cgraph_edge_p>, bitmap);\n-struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n-\t\t\t\t\t\tvec<cgraph_edge_p>,\n-\t\t\t\t\t\tvec<ipa_replace_map_p, va_gc> *,\n-\t\t\t\t\t\tbitmap, bool, bitmap,\n-\t\t\t\t\t\tbasic_block, const char *);\n-void tree_function_versioning (tree, tree, vec<ipa_replace_map_p, va_gc> *,\n+void tree_function_versioning (tree, tree, vec<ipa_replace_map *, va_gc> *,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n struct cgraph_edge *cgraph_resolve_speculation (struct cgraph_edge *, tree);\n \n@@ -1080,15 +1516,14 @@ unsigned int rebuild_cgraph_edges (void);\n void cgraph_rebuild_references (void);\n int compute_call_stmt_bb_frequency (tree, basic_block bb);\n void record_references_in_initializer (tree, bool);\n-void ipa_record_stmt_references (struct cgraph_node *, gimple);\n \n /* In ipa.c  */\n bool symtab_remove_unreachable_nodes (bool, FILE *);\n cgraph_node_set cgraph_node_set_new (void);\n cgraph_node_set_iterator cgraph_node_set_find (cgraph_node_set,\n-\t\t\t\t\t       struct cgraph_node *);\n-void cgraph_node_set_add (cgraph_node_set, struct cgraph_node *);\n-void cgraph_node_set_remove (cgraph_node_set, struct cgraph_node *);\n+\t\t\t\t\t       cgraph_node *);\n+void cgraph_node_set_add (cgraph_node_set, cgraph_node *);\n+void cgraph_node_set_remove (cgraph_node_set, cgraph_node *);\n void dump_cgraph_node_set (FILE *, cgraph_node_set);\n void debug_cgraph_node_set (cgraph_node_set);\n void free_cgraph_node_set (cgraph_node_set);\n@@ -1105,14 +1540,8 @@ void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n bool varpool_externally_visible_p (varpool_node *);\n \n-/* In ipa-visibility.c */\n-bool cgraph_local_node_p (struct cgraph_node *);\n-bool address_taken_from_non_vtable_p (symtab_node *node);\n-\n-\n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n-bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n varpool_node *varpool_create_empty_node (void);\n@@ -1121,15 +1550,10 @@ varpool_node *varpool_node_for_asm (tree asmname);\n void varpool_mark_needed_node (varpool_node *);\n void debug_varpool (void);\n void dump_varpool (FILE *);\n-void dump_varpool_node (FILE *, varpool_node *);\n \n void varpool_finalize_decl (tree);\n enum availability cgraph_variable_initializer_availability (varpool_node *);\n-void cgraph_make_node_local (struct cgraph_node *);\n-bool cgraph_node_can_be_local_p (struct cgraph_node *);\n \n-\n-void varpool_remove_node (varpool_node *node);\n void varpool_finalize_named_section_flags (varpool_node *node);\n bool varpool_output_variables (void);\n bool varpool_assemble_decl (varpool_node *node);\n@@ -1151,6 +1575,23 @@ tree varpool_get_constructor (struct varpool_node *node);\n /* In cgraph.c */\n extern void change_decl_assembler_name (tree, tree);\n \n+/* Return true when the symbol is real symbol, i.e. it is not inline clone\n+   or abstract function kept for debug info purposes only.  */\n+inline bool\n+symtab_node::real_symbol_p (void)\n+{\n+  cgraph_node *cnode;\n+\n+  if (DECL_ABSTRACT (decl))\n+    return false;\n+  if (!is_a <cgraph_node *> (this))\n+    return true;\n+  cnode = dyn_cast <cgraph_node *> (this);\n+  if (cnode->global.inlined_to)\n+    return false;\n+  return true;\n+}\n+\n /* Return true if DECL should have entry in symbol table if used.\n    Those are functions and static & external veriables*/\n \n@@ -1162,53 +1603,55 @@ decl_in_symtab_p (const_tree decl)\n \t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))));\n }\n \n-/* Return symbol table node associated with DECL, if any,\n-   and NULL otherwise.  */\n-\n-static inline symtab_node *\n-symtab_get_node (const_tree decl)\n+inline bool\n+symtab_node::in_same_comdat_group_p (symtab_node *target)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_checking_assert (decl_in_symtab_p (decl));\n-  /* Check that the mapping is sane - perhaps this check can go away,\n-     but at the moment frontends tends to corrupt the mapping by calling\n-     memcpy/memset on the tree nodes.  */\n-  gcc_checking_assert (!decl->decl_with_vis.symtab_node\n-\t\t       || decl->decl_with_vis.symtab_node->decl == decl);\n-#endif\n-  return decl->decl_with_vis.symtab_node;\n-}\n+  symtab_node *source = this;\n \n-/* Return callgraph node for given symbol and check it is a function. */\n-static inline struct cgraph_node *\n-cgraph (symtab_node *node)\n-{\n-  gcc_checking_assert (!node || node->type == SYMTAB_FUNCTION);\n-  return (struct cgraph_node *)node;\n+  if (cgraph_node *cn = dyn_cast <cgraph_node *> (target))\n+    {\n+      if (cn->global.inlined_to)\n+\tsource = cn->global.inlined_to;\n+    }\n+  if (cgraph_node *cn = dyn_cast <cgraph_node *> (target))\n+    {\n+      if (cn->global.inlined_to)\n+\ttarget = cn->global.inlined_to;\n+    }\n+\n+  return source->get_comdat_group () == target->get_comdat_group ();\n }\n \n-/* Return varpool node for given symbol and check it is a variable.  */\n-static inline varpool_node *\n-varpool (symtab_node *node)\n+/* Return node that alias is aliasing.  */\n+\n+inline symtab_node *\n+symtab_node::get_alias_target (void)\n {\n-  gcc_checking_assert (!node || node->type == SYMTAB_VARIABLE);\n-  return (varpool_node *)node;\n+  struct ipa_ref *ref = NULL;\n+  iterate_reference (0, ref);\n+  gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n+  return ref->referred;\n }\n \n-/* Return callgraph node for given symbol and check it is a function. */\n-static inline struct cgraph_node *\n-cgraph_get_node (const_tree decl)\n+/* Return next reachable static symbol with initializer after the node.  */\n+inline symtab_node *\n+symtab_node::next_defined_symbol (void)\n {\n-  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-  return cgraph (symtab_get_node (decl));\n+  symtab_node *node1 = next;\n+\n+  for (; node1; node1 = node1->next)\n+    if (node1->definition)\n+      return node1;\n+\n+  return NULL;\n }\n \n /* Return varpool node for given symbol and check it is a function. */\n static inline varpool_node *\n varpool_get_node (const_tree decl)\n {\n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n-  return varpool (symtab_get_node (decl));\n+  return dyn_cast<varpool_node *> (symtab_node::get (decl));\n }\n \n /* Walk all symbols.  */\n@@ -1228,22 +1671,10 @@ symtab_first_defined_symbol (void)\n   return NULL;\n }\n \n-/* Return next reachable static symbol with initializer after NODE.  */\n-static inline symtab_node *\n-symtab_next_defined_symbol (symtab_node *node)\n-{\n-  symtab_node *node1 = node->next;\n-\n-  for (; node1; node1 = node1->next)\n-    if (node1->definition)\n-      return node1;\n-\n-  return NULL;\n-}\n /* Walk all symbols with definitions in current unit.  */\n #define FOR_EACH_DEFINED_SYMBOL(node) \\\n    for ((node) = symtab_first_defined_symbol (); (node); \\\n-        (node) = symtab_next_defined_symbol (node))\n+\t(node) = node->next_defined_symbol ())\n \n /* Return first variable.  */\n static inline varpool_node *\n@@ -1338,7 +1769,7 @@ varpool_next_defined_variable (varpool_node *node)\n         (node) = varpool_next_defined_variable (node))\n \n /* Return first function with body defined.  */\n-static inline struct cgraph_node *\n+static inline cgraph_node *\n cgraph_first_defined_function (void)\n {\n   symtab_node *node;\n@@ -1352,8 +1783,8 @@ cgraph_first_defined_function (void)\n }\n \n /* Return next function with body defined after NODE.  */\n-static inline struct cgraph_node *\n-cgraph_next_defined_function (struct cgraph_node *node)\n+static inline cgraph_node *\n+cgraph_next_defined_function (cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1371,7 +1802,7 @@ cgraph_next_defined_function (struct cgraph_node *node)\n         (node) = cgraph_next_defined_function ((node)))\n \n /* Return first function.  */\n-static inline struct cgraph_node *\n+static inline cgraph_node *\n cgraph_first_function (void)\n {\n   symtab_node *node;\n@@ -1382,8 +1813,8 @@ cgraph_first_function (void)\n }\n \n /* Return next function.  */\n-static inline struct cgraph_node *\n-cgraph_next_function (struct cgraph_node *node)\n+static inline cgraph_node *\n+cgraph_next_function (cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1396,41 +1827,41 @@ cgraph_next_function (struct cgraph_node *node)\n    for ((node) = cgraph_first_function (); (node); \\\n         (node) = cgraph_next_function ((node)))\n \n-/* Return true when NODE is a function with Gimple body defined\n+/* Return true when callgraph node is a function with Gimple body defined\n    in current unit.  Functions can also be define externally or they\n    can be thunks with no Gimple representation.\n \n    Note that at WPA stage, the function body may not be present in memory.  */\n \n-static inline bool\n-cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n+inline bool\n+cgraph_node::has_gimple_body_p (void)\n {\n-  return node->definition && !node->thunk.thunk_p && !node->alias;\n+  return definition && !thunk.thunk_p && !alias;\n }\n \n /* Return first function with body defined.  */\n-static inline struct cgraph_node *\n+static inline cgraph_node *\n cgraph_first_function_with_gimple_body (void)\n {\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n       cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n-      if (cn && cgraph_function_with_gimple_body_p (cn))\n+      if (cn && cn->has_gimple_body_p ())\n \treturn cn;\n     }\n   return NULL;\n }\n \n /* Return next reachable static variable with initializer after NODE.  */\n-static inline struct cgraph_node *\n-cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n+static inline cgraph_node *\n+cgraph_next_function_with_gimple_body (cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n       cgraph_node *cn1 = dyn_cast <cgraph_node *> (node1);\n-      if (cn1 && cgraph_function_with_gimple_body_p (cn1))\n+      if (cn1 && cn1->has_gimple_body_p ())\n \treturn cn1;\n     }\n   return NULL;\n@@ -1459,7 +1890,7 @@ csi_next (cgraph_node_set_iterator *csi)\n }\n \n /* Return the node pointed to by CSI.  */\n-static inline struct cgraph_node *\n+static inline cgraph_node *\n csi_node (cgraph_node_set_iterator csi)\n {\n   return csi.set->nodes[csi.index];\n@@ -1478,7 +1909,7 @@ csi_start (cgraph_node_set set)\n \n /* Return true if SET contains NODE.  */\n static inline bool\n-cgraph_node_in_set_p (struct cgraph_node *node, cgraph_node_set set)\n+cgraph_node_in_set_p (cgraph_node *node, cgraph_node_set set)\n {\n   cgraph_node_set_iterator csi;\n   csi = cgraph_node_set_find (set, node);\n@@ -1524,15 +1955,6 @@ vsi_start (varpool_node_set set)\n   return vsi;\n }\n \n-/* Return true if SET contains NODE.  */\n-static inline bool\n-varpool_node_in_set_p (varpool_node *node, varpool_node_set set)\n-{\n-  varpool_node_set_iterator vsi;\n-  vsi = varpool_node_set_find (set, node);\n-  return !vsi_end_p (vsi);\n-}\n-\n /* Return number of nodes in SET.  */\n static inline size_t\n varpool_node_set_size (varpool_node_set set)\n@@ -1571,20 +1993,20 @@ varpool_node_set_nonempty_p (varpool_node_set set)\n   return !set->nodes.is_empty ();\n }\n \n-/* Return true when function NODE is only called directly or it has alias.\n+/* Return true when function is only called directly or it has alias.\n    i.e. it is not externally visible, address was not taken and\n    it is not used in any other non-standard way.  */\n \n-static inline bool\n-cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n-{\n-  gcc_assert (!node->global.inlined_to);\n-  return (!node->force_output && !node->address_taken\n-\t  && !node->used_from_other_partition\n-\t  && !DECL_VIRTUAL_P (node->decl)\n-\t  && !DECL_STATIC_CONSTRUCTOR (node->decl)\n-\t  && !DECL_STATIC_DESTRUCTOR (node->decl)\n-\t  && !node->externally_visible);\n+inline bool\n+cgraph_node::only_called_directly_or_aliased_p (void)\n+{\n+  gcc_assert (!global.inlined_to);\n+  return (!force_output && !address_taken\n+\t  && !used_from_other_partition\n+\t  && !DECL_VIRTUAL_P (decl)\n+\t  && !DECL_STATIC_CONSTRUCTOR (decl)\n+\t  && !DECL_STATIC_DESTRUCTOR (decl)\n+\t  && !externally_visible);\n }\n \n /* Return true when function NODE can be removed from callgraph\n@@ -1598,7 +2020,7 @@ varpool_can_remove_if_no_refs (varpool_node *node)\n   return (!node->force_output && !node->used_from_other_partition\n   \t  && ((DECL_COMDAT (node->decl)\n \t       && !node->forced_by_abi\n-\t       && !symtab_used_from_object_file_p (node))\n+\t       && !node->used_from_object_file_p ())\n \t      || !node->externally_visible\n \t      || DECL_HAS_VALUE_EXPR_P (node->decl)));\n }\n@@ -1620,41 +2042,29 @@ varpool_all_refs_explicit_p (varpool_node *vnode)\n /* Constant pool accessor function.  */\n htab_t constant_pool_htab (void);\n \n-/* Return node that alias N is aliasing.  */\n-\n-static inline symtab_node *\n-symtab_alias_target (symtab_node *n)\n-{\n-  struct ipa_ref *ref = NULL;\n-  n->iterate_reference (0, ref);\n-  gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  return ref->referred;\n-}\n+/* Return node that alias is aliasing.  */\n \n-static inline struct cgraph_node *\n-cgraph_alias_target (struct cgraph_node *n)\n+inline cgraph_node *\n+cgraph_node::get_alias_target (void)\n {\n-  return dyn_cast <cgraph_node *> (symtab_alias_target (n));\n+  return dyn_cast <cgraph_node *> (symtab_node::get_alias_target ());\n }\n \n static inline varpool_node *\n varpool_alias_target (varpool_node *n)\n {\n-  return dyn_cast <varpool_node *> (symtab_alias_target (n));\n+  return dyn_cast <varpool_node *> (n->get_alias_target ());\n }\n \n-/* Given NODE, walk the alias chain to return the function NODE is alias of.\n-   Do not walk through thunks.\n+/* Given function symbol, walk the alias chain to return the function node\n+   is alias of. Do not walk through thunks.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n-static inline struct cgraph_node *\n-cgraph_function_or_thunk_node (struct cgraph_node *node,\n-\t\t\t       enum availability *availability = NULL)\n+inline cgraph_node *\n+cgraph_node::ultimate_alias_target (enum availability *availability)\n {\n-  struct cgraph_node *n;\n-\n-  n = dyn_cast <cgraph_node *> (symtab_alias_ultimate_target (node,\n-\t\t\t\t\t\t\t      availability));\n+  cgraph_node *n = dyn_cast <cgraph_node *> (symtab_node::ultimate_alias_target\n+    (availability));\n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n@@ -1670,8 +2080,7 @@ varpool_variable_node (varpool_node *node,\n   varpool_node *n;\n \n   if (node)\n-    n = dyn_cast <varpool_node *> (symtab_alias_ultimate_target (node,\n-\t\t\t\t\t\t\t\t availability));\n+    n = dyn_cast <varpool_node *> (node->ultimate_alias_target (availability));\n   else\n     n = NULL;\n \n@@ -1684,7 +2093,7 @@ varpool_variable_node (varpool_node *node,\n static inline bool\n cgraph_edge_recursive_p (struct cgraph_edge *e)\n {\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  cgraph_node *callee = e->callee->ultimate_alias_target ();\n   if (e->caller->global.inlined_to)\n     return e->caller->global.inlined_to->decl == callee->decl;\n   else\n@@ -1695,7 +2104,7 @@ cgraph_edge_recursive_p (struct cgraph_edge *e)\n static inline bool\n decl_is_tm_clone (const_tree fndecl)\n {\n-  struct cgraph_node *n = cgraph_get_node (fndecl);\n+  cgraph_node *n = cgraph_node::get (fndecl);\n   if (n)\n     return n->tm_clone;\n   return false;\n@@ -1704,69 +2113,11 @@ decl_is_tm_clone (const_tree fndecl)\n /* Likewise indicate that a node is needed, i.e. reachable via some\n    external means.  */\n \n-static inline void\n-cgraph_mark_force_output_node (struct cgraph_node *node)\n-{\n-  node->force_output = 1;\n-  gcc_checking_assert (!node->global.inlined_to);\n-}\n-\n-/* Return true when the symbol is real symbol, i.e. it is not inline clone\n-   or abstract function kept for debug info purposes only.  */\n-\n-static inline bool\n-symtab_real_symbol_p (symtab_node *node)\n-{\n-  struct cgraph_node *cnode;\n-\n-  if (DECL_ABSTRACT (node->decl))\n-    return false;\n-  if (!is_a <cgraph_node *> (node))\n-    return true;\n-  cnode = cgraph (node);\n-  if (cnode->global.inlined_to)\n-    return false;\n-  return true;\n-}\n-\n-/* Return true if NODE can be discarded by linker from the binary.  */\n-\n-static inline bool\n-symtab_can_be_discarded (symtab_node *node)\n-{\n-  return (DECL_EXTERNAL (node->decl)\n-\t  || (node->get_comdat_group ()\n-\t      && node->resolution != LDPR_PREVAILING_DEF\n-\t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY\n-\t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n-}\n-\n-/* Return true if NODE is local to a particular COMDAT group, and must not\n-   be named from outside the COMDAT.  This is used for C++ decloned\n-   constructors.  */\n-\n-static inline bool\n-symtab_comdat_local_p (symtab_node *node)\n+inline void\n+cgraph_node::mark_force_output (void)\n {\n-  return (node->same_comdat_group && !TREE_PUBLIC (node->decl));\n+  force_output = 1;\n+  gcc_checking_assert (!global.inlined_to);\n }\n \n-/* Return true if ONE and TWO are part of the same COMDAT group.  */\n-\n-static inline bool\n-symtab_in_same_comdat_p (symtab_node *one, symtab_node *two)\n-{\n-  if (cgraph_node *cn = dyn_cast <cgraph_node *> (one))\n-    {\n-      if (cn->global.inlined_to)\n-\tone = cn->global.inlined_to;\n-    }\n-  if (cgraph_node *cn = dyn_cast <cgraph_node *> (two))\n-    {\n-      if (cn->global.inlined_to)\n-\ttwo = cn->global.inlined_to;\n-    }\n-\n-  return one->get_comdat_group () == two->get_comdat_group ();\n-}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "9f1f244c2a26cf5abdf825d227fdfc2919a175ed", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -79,9 +79,9 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       decl = get_base_var (*tp);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n-\t  struct cgraph_node *node = cgraph_get_create_node (decl);\n+\t  struct cgraph_node *node = cgraph_node::get_create (decl);\n \t  if (!ctx->only_vars)\n-\t    cgraph_mark_address_taken_node (node);\n+\t    node->mark_address_taken ();\n \t  ctx->varpool_node->add_reference (node, IPA_REF_ADDR);\n \t}\n \n@@ -142,10 +142,10 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n   if (DECL_FUNCTION_PERSONALITY (node->decl))\n     {\n       tree per_decl = DECL_FUNCTION_PERSONALITY (node->decl);\n-      struct cgraph_node *per_node = cgraph_get_create_node (per_decl);\n+      struct cgraph_node *per_node = cgraph_node::get_create (per_decl);\n \n       node->add_reference (per_node, IPA_REF_ADDR);\n-      cgraph_mark_address_taken_node (per_node);\n+      per_node->mark_address_taken ();\n     }\n \n   i = fun->eh->region_tree;\n@@ -223,8 +223,8 @@ mark_address (gimple stmt, tree addr, tree, void *data)\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_get_create_node (addr);\n-      cgraph_mark_address_taken_node (node);\n+      struct cgraph_node *node = cgraph_node::get_create (addr);\n+      node->mark_address_taken ();\n       ((symtab_node *)data)->add_reference (node, IPA_REF_ADDR, stmt);\n     }\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n@@ -248,8 +248,8 @@ mark_load (gimple stmt, tree t, tree, void *data)\n     {\n       /* ??? This can happen on platforms with descriptors when these are\n \t directly manipulated in the code.  Pretend that it's an address.  */\n-      struct cgraph_node *node = cgraph_get_create_node (t);\n-      cgraph_mark_address_taken_node (node);\n+      struct cgraph_node *node = cgraph_node::get_create (t);\n+      node->mark_address_taken ();\n       ((symtab_node *)data)->add_reference (node, IPA_REF_ADDR, stmt);\n     }\n   else if (t && TREE_CODE (t) == VAR_DECL\n@@ -278,11 +278,12 @@ mark_store (gimple stmt, tree t, tree, void *data)\n   return false;\n }\n \n-/* Record all references from NODE that are taken in statement STMT.  */\n+/* Record all references from cgraph_node that are taken in statement STMT.  */\n+\n void\n-ipa_record_stmt_references (struct cgraph_node *node, gimple stmt)\n+cgraph_node::record_stmt_references (gimple stmt)\n {\n-  walk_stmt_load_store_addr_ops (stmt, node, mark_load, mark_store,\n+  walk_stmt_load_store_addr_ops (stmt, this, mark_load, mark_store,\n \t\t\t\t mark_address);\n }\n \n@@ -320,7 +321,7 @@ unsigned int\n pass_build_cgraph_edges::execute (function *fun)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n   gimple_stmt_iterator gsi;\n   tree decl;\n@@ -344,37 +345,37 @@ pass_build_cgraph_edges::execute (function *fun)\n \t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n-\t\tcgraph_create_edge (node, cgraph_get_create_node (decl),\n-\t\t\t\t    stmt, bb->count, freq);\n+\t\tnode->create_edge (cgraph_node::get_create (decl),\n+\t\t\t\t   stmt, bb->count, freq);\n \t      else if (gimple_call_internal_p (stmt))\n \t\t;\n \t      else\n-\t\tcgraph_create_indirect_edge (node, stmt,\n-\t\t\t\t\t     gimple_call_flags (stmt),\n-\t\t\t\t\t     bb->count, freq);\n+\t\tnode->create_indirect_edge (stmt,\n+\t\t\t\t\t    gimple_call_flags (stmt),\n+\t\t\t\t\t    bb->count, freq);\n \t    }\n-\t  ipa_record_stmt_references (node, stmt);\n+\t  node->record_stmt_references (stmt);\n \t  if (gimple_code (stmt) == GIMPLE_OMP_PARALLEL\n \t      && gimple_omp_parallel_child_fn (stmt))\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n-\t      node->add_reference (cgraph_get_create_node (fn),\n+\t      node->add_reference (cgraph_node::get_create (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n-\t\tnode->add_reference (cgraph_get_create_node (fn),\n+\t\tnode->add_reference (cgraph_node::get_create (fn),\n \t\t\t\t\tIPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n-\t\tnode->add_reference (cgraph_get_create_node (fn),\n+\t\tnode->add_reference (cgraph_node::get_create (fn),\n \t\t\t\t\tIPA_REF_ADDR, stmt);\n \t    }\n \t}\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tipa_record_stmt_references (node, gsi_stmt (gsi));\n+\tnode->record_stmt_references (gsi_stmt (gsi));\n    }\n \n   /* Look for initializers of constant variables and private statics.  */\n@@ -422,10 +423,10 @@ unsigned int\n rebuild_cgraph_edges (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n \n-  cgraph_node_remove_callees (node);\n+  node->remove_callees ();\n   node->remove_all_references ();\n \n   node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n@@ -443,19 +444,19 @@ rebuild_cgraph_edges (void)\n \t\t\t\t\t\t\t bb);\n \t      decl = gimple_call_fndecl (stmt);\n \t      if (decl)\n-\t\tcgraph_create_edge (node, cgraph_get_create_node (decl), stmt,\n-\t\t\t\t    bb->count, freq);\n+\t\tnode->create_edge (cgraph_node::get_create (decl), stmt,\n+\t\t\t\t   bb->count, freq);\n \t      else if (gimple_call_internal_p (stmt))\n \t\t;\n \t      else\n-\t\tcgraph_create_indirect_edge (node, stmt,\n-\t\t\t\t\t     gimple_call_flags (stmt),\n-\t\t\t\t\t     bb->count, freq);\n+\t\tnode->create_indirect_edge (stmt,\n+\t\t\t\t\t    gimple_call_flags (stmt),\n+\t\t\t\t\t    bb->count, freq);\n \t    }\n-\t  ipa_record_stmt_references (node, stmt);\n+\t  node->record_stmt_references (stmt);\n \t}\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tipa_record_stmt_references (node, gsi_stmt (gsi));\n+\tnode->record_stmt_references (gsi_stmt (gsi));\n     }\n   record_eh_tables (node, cfun);\n   gcc_assert (!node->global.inlined_to);\n@@ -470,7 +471,7 @@ void\n cgraph_rebuild_references (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n   struct ipa_ref *ref = NULL;\n   int i;\n@@ -487,9 +488,9 @@ cgraph_rebuild_references (void)\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tipa_record_stmt_references (node, gsi_stmt (gsi));\n+\tnode->record_stmt_references (gsi_stmt (gsi));\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tipa_record_stmt_references (node, gsi_stmt (gsi));\n+\tnode->record_stmt_references (gsi_stmt (gsi));\n     }\n   record_eh_tables (node, cfun);\n }\n@@ -564,8 +565,8 @@ class pass_remove_cgraph_callee_edges : public gimple_opt_pass\n unsigned int\n pass_remove_cgraph_callee_edges::execute (function *)\n {\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n-  cgraph_node_remove_callees (node);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n+  node->remove_callees ();\n   node->remove_all_references ();\n   return 0;\n }"}, {"sha": "f097da8b22d847a0fb3ca95916de970b6877a7b0", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 143, "deletions": 157, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -128,21 +128,21 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t     via cgraph_resolve_speculation and not here.  */\n \t  && !e->speculative)\n \t{\n-\t  struct cgraph_node *callee = cgraph_get_node (decl);\n+\t  struct cgraph_node *callee = cgraph_node::get (decl);\n \t  gcc_checking_assert (callee);\n-\t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq);\n+\t  new_edge = n->create_edge (callee, call_stmt, count, freq);\n \t}\n       else\n \t{\n-\t  new_edge = cgraph_create_indirect_edge (n, call_stmt,\n-\t\t\t\t\t\t  e->indirect_info->ecf_flags,\n-\t\t\t\t\t\t  count, freq);\n+\t  new_edge = n->create_indirect_edge (call_stmt,\n+\t\t\t\t\t      e->indirect_info->ecf_flags,\n+\t\t\t\t\t      count, freq);\n \t  *new_edge->indirect_info = *e->indirect_info;\n \t}\n     }\n   else\n     {\n-      new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq);\n+      new_edge = n->create_edge (e->callee, call_stmt, count, freq);\n       if (e->indirect_info)\n \t{\n \t  new_edge->indirect_info\n@@ -304,7 +304,7 @@ static cgraph_node *\n duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n {\n   cgraph_node *new_thunk, *thunk_of;\n-  thunk_of = cgraph_function_or_thunk_node (thunk->callees->callee);\n+  thunk_of = thunk->callees->callee->ultimate_alias_target ();\n \n   if (thunk_of->thunk.thunk_p)\n     node = duplicate_thunk_for_node (thunk_of, node);\n@@ -341,7 +341,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   DECL_NAME (new_decl) = clone_function_name (thunk->decl, \"artificial_thunk\");\n   SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n \n-  new_thunk = cgraph_create_node (new_decl);\n+  new_thunk = cgraph_node::create (new_decl);\n   set_new_clone_decl_and_node_flags (new_thunk);\n   new_thunk->definition = true;\n   new_thunk->thunk = thunk->thunk;\n@@ -350,13 +350,13 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk->clone.args_to_skip = node->clone.args_to_skip;\n   new_thunk->clone.combined_args_to_skip = node->clone.combined_args_to_skip;\n \n-  struct cgraph_edge *e = cgraph_create_edge (new_thunk, node, NULL, 0,\n-\t\t\t\t\t      CGRAPH_FREQ_BASE);\n+  struct cgraph_edge *e = new_thunk->create_edge (node, NULL, 0,\n+\t\t\t\t\t\t  CGRAPH_FREQ_BASE);\n   e->call_stmt_cannot_inline_p = true;\n   cgraph_call_edge_duplication_hooks (thunk->callees, e);\n-  if (!expand_thunk (new_thunk, false, false))\n+  if (!new_thunk->expand_thunk (false, false))\n     new_thunk->analyzed = true;\n-  cgraph_call_node_duplication_hooks (thunk, new_thunk);\n+  thunk->call_duplication_hooks (new_thunk);\n   return new_thunk;\n }\n \n@@ -367,7 +367,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n void\n redirect_edge_duplicating_thunks (struct cgraph_edge *e, struct cgraph_node *n)\n {\n-  cgraph_node *orig_to = cgraph_function_or_thunk_node (e->callee);\n+  cgraph_node *orig_to = e->callee->ultimate_alias_target ();\n   if (orig_to->thunk.thunk_p)\n     n = duplicate_thunk_for_node (orig_to, n);\n \n@@ -390,67 +390,67 @@ redirect_edge_duplicating_thunks (struct cgraph_edge *e, struct cgraph_node *n)\n    will see this in node's global.inlined_to, when invoked.  Can be NULL if the\n    node is not inlined.  */\n \n-struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n-\t\t   bool update_original,\n-\t\t   vec<cgraph_edge_p> redirect_callers,\n-\t\t   bool call_duplication_hook,\n-\t\t   struct cgraph_node *new_inlined_to,\n-\t\t   bitmap args_to_skip)\n+cgraph_node *\n+cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n+\t\t\t   bool update_original,\n+\t\t\t   vec<cgraph_edge *> redirect_callers,\n+\t\t\t   bool call_duplication_hook,\n+\t\t\t   struct cgraph_node *new_inlined_to,\n+\t\t\t   bitmap args_to_skip)\n {\n-  struct cgraph_node *new_node = cgraph_create_empty_node ();\n+  struct cgraph_node *new_node = cgraph_node::create_empty ();\n   struct cgraph_edge *e;\n   gcov_type count_scale;\n   unsigned i;\n \n   new_node->decl = decl;\n-  symtab_register_node (new_node);\n-  new_node->origin = n->origin;\n-  new_node->lto_file_data = n->lto_file_data;\n+  new_node->register_symbol ();\n+  new_node->origin = origin;\n+  new_node->lto_file_data = lto_file_data;\n   if (new_node->origin)\n     {\n       new_node->next_nested = new_node->origin->nested;\n       new_node->origin->nested = new_node;\n     }\n-  new_node->analyzed = n->analyzed;\n-  new_node->definition = n->definition;\n-  new_node->local = n->local;\n+  new_node->analyzed = analyzed;\n+  new_node->definition = definition;\n+  new_node->local = local;\n   new_node->externally_visible = false;\n   new_node->local.local = true;\n-  new_node->global = n->global;\n+  new_node->global = global;\n   new_node->global.inlined_to = new_inlined_to;\n-  new_node->rtl = n->rtl;\n+  new_node->rtl = rtl;\n   new_node->count = count;\n-  new_node->frequency = n->frequency;\n-  new_node->tp_first_run = n->tp_first_run;\n+  new_node->frequency = frequency;\n+  new_node->tp_first_run = tp_first_run;\n \n   new_node->clone.tree_map = NULL;\n   new_node->clone.args_to_skip = args_to_skip;\n   if (!args_to_skip)\n-    new_node->clone.combined_args_to_skip = n->clone.combined_args_to_skip;\n-  else if (n->clone.combined_args_to_skip)\n+    new_node->clone.combined_args_to_skip = clone.combined_args_to_skip;\n+  else if (clone.combined_args_to_skip)\n     {\n       new_node->clone.combined_args_to_skip = BITMAP_GGC_ALLOC ();\n       bitmap_ior (new_node->clone.combined_args_to_skip,\n-\t\t  n->clone.combined_args_to_skip, args_to_skip);\n+\t\t  clone.combined_args_to_skip, args_to_skip);\n     }\n   else\n     new_node->clone.combined_args_to_skip = args_to_skip;\n \n-  if (n->count)\n+  if (count)\n     {\n-      if (new_node->count > n->count)\n+      if (new_node->count > count)\n         count_scale = REG_BR_PROB_BASE;\n       else\n-        count_scale = GCOV_COMPUTE_SCALE (new_node->count, n->count);\n+\tcount_scale = GCOV_COMPUTE_SCALE (new_node->count, count);\n     }\n   else\n     count_scale = 0;\n   if (update_original)\n     {\n-      n->count -= count;\n-      if (n->count < 0)\n-\tn->count = 0;\n+      count -= gcov_count;\n+      if (count < 0)\n+\tcount = 0;\n     }\n \n   FOR_EACH_VEC_ELT (redirect_callers, i, e)\n@@ -464,23 +464,23 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n         redirect_edge_duplicating_thunks (e, new_node);\n     }\n \n-  for (e = n->callees;e; e=e->next_callee)\n+  for (e = callees;e; e=e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, update_original);\n \n-  for (e = n->indirect_calls; e; e = e->next_callee)\n+  for (e = indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, update_original);\n-  new_node->clone_references (n);\n+  new_node->clone_references (this);\n \n-  new_node->next_sibling_clone = n->clones;\n-  if (n->clones)\n-    n->clones->prev_sibling_clone = new_node;\n-  n->clones = new_node;\n-  new_node->clone_of = n;\n+  new_node->next_sibling_clone = clones;\n+  if (clones)\n+    clones->prev_sibling_clone = new_node;\n+  clones = new_node;\n+  new_node->clone_of = this;\n \n   if (call_duplication_hook)\n-    cgraph_call_node_duplication_hooks (n, new_node);\n+    call_duplication_hooks (new_node);\n   return new_node;\n }\n \n@@ -516,13 +516,11 @@ clone_function_name (tree decl, const char *suffix)\n    bitmap interface.\n    */\n struct cgraph_node *\n-cgraph_create_virtual_clone (struct cgraph_node *old_node,\n-\t\t\t     vec<cgraph_edge_p> redirect_callers,\n-\t\t\t     vec<ipa_replace_map_p, va_gc> *tree_map,\n-\t\t\t     bitmap args_to_skip,\n-\t\t\t     const char * suffix)\n+cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n+\t\t\t\t   vec<ipa_replace_map *, va_gc> *tree_map,\n+\t\t\t\t   bitmap args_to_skip, const char * suffix)\n {\n-  tree old_decl = old_node->decl;\n+  tree old_decl = decl;\n   struct cgraph_node *new_node = NULL;\n   tree new_decl;\n   size_t len, i;\n@@ -532,7 +530,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   if (!in_lto_p)\n     gcc_checking_assert  (tree_versionable_function_p (old_decl));\n \n-  gcc_assert (old_node->local.can_change_signature || !args_to_skip);\n+  gcc_assert (local.can_change_signature || !args_to_skip);\n \n   /* Make a new FUNCTION_DECL tree node */\n   if (!args_to_skip)\n@@ -560,9 +558,9 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   SET_DECL_ASSEMBLER_NAME (new_decl, clone_function_name (old_decl, suffix));\n   SET_DECL_RTL (new_decl, NULL);\n \n-  new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n-\t\t\t\tCGRAPH_FREQ_BASE, false,\n-\t\t\t\tredirect_callers, false, NULL, args_to_skip);\n+  new_node = create_clone (new_decl, count, CGRAPH_FREQ_BASE, false,\n+\t\t\t   redirect_callers, false, NULL, args_to_skip);\n+\n   /* Update the properties.\n      Make clone visible only within this translation unit.  Make sure\n      that is not weak also.\n@@ -581,26 +579,25 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   FOR_EACH_VEC_SAFE_ELT (tree_map, i, map)\n     new_node->maybe_add_reference (map->new_tree, IPA_REF_ADDR, NULL);\n \n-  if (old_node->ipa_transforms_to_apply.exists ())\n+  if (ipa_transforms_to_apply.exists ())\n     new_node->ipa_transforms_to_apply\n-      = old_node->ipa_transforms_to_apply.copy ();\n-\n-  cgraph_call_node_duplication_hooks (old_node, new_node);\n+      = ipa_transforms_to_apply.copy ();\n \n+  call_duplication_hooks (new_node);\n \n   return new_node;\n }\n \n-/* NODE is being removed from symbol table; see if its entry can be replaced by\n-   other inline clone.  */\n-struct cgraph_node *\n-cgraph_find_replacement_node (struct cgraph_node *node)\n+/* callgraph node being removed from symbol table; see if its entry can be\n+   replaced by other inline clone.  */\n+cgraph_node *\n+cgraph_node::find_replacement (void)\n {\n   struct cgraph_node *next_inline_clone, *replacement;\n \n-  for (next_inline_clone = node->clones;\n+  for (next_inline_clone = clones;\n        next_inline_clone\n-       && next_inline_clone->decl != node->decl;\n+       && next_inline_clone->decl != decl;\n        next_inline_clone = next_inline_clone->next_sibling_clone)\n     ;\n \n@@ -620,32 +617,32 @@ cgraph_find_replacement_node (struct cgraph_node *node)\n \t  = next_inline_clone->prev_sibling_clone;\n       if (next_inline_clone->prev_sibling_clone)\n \t{\n-\t  gcc_assert (node->clones != next_inline_clone);\n+\t  gcc_assert (clones != next_inline_clone);\n \t  next_inline_clone->prev_sibling_clone->next_sibling_clone\n \t    = next_inline_clone->next_sibling_clone;\n \t}\n       else\n \t{\n-\t  gcc_assert (node->clones == next_inline_clone);\n-\t  node->clones = next_inline_clone->next_sibling_clone;\n+\t  gcc_assert (clones == next_inline_clone);\n+\t  clones = next_inline_clone->next_sibling_clone;\n \t}\n \n-      new_clones = node->clones;\n-      node->clones = NULL;\n+      new_clones = clones;\n+      clones = NULL;\n \n       /* Copy clone info.  */\n-      next_inline_clone->clone = node->clone;\n+      next_inline_clone->clone = clone;\n \n       /* Now place it into clone tree at same level at NODE.  */\n-      next_inline_clone->clone_of = node->clone_of;\n+      next_inline_clone->clone_of = clone_of;\n       next_inline_clone->prev_sibling_clone = NULL;\n       next_inline_clone->next_sibling_clone = NULL;\n-      if (node->clone_of)\n+      if (clone_of)\n \t{\n-\t  if (node->clone_of->clones)\n-\t    node->clone_of->clones->prev_sibling_clone = next_inline_clone;\n-\t  next_inline_clone->next_sibling_clone = node->clone_of->clones;\n-\t  node->clone_of->clones = next_inline_clone;\n+\t  if (clone_of->clones)\n+\t    clone_of->clones->prev_sibling_clone = next_inline_clone;\n+\t  next_inline_clone->next_sibling_clone = clone_of->clones;\n+\t  clone_of->clones = next_inline_clone;\n \t}\n \n       /* Merge the clone list.  */\n@@ -657,7 +654,7 @@ cgraph_find_replacement_node (struct cgraph_node *node)\n \t    {\n \t      n = next_inline_clone->clones;\n \t      while (n->next_sibling_clone)\n-\t\tn =  n->next_sibling_clone;\n+\t\tn = n->next_sibling_clone;\n \t      n->next_sibling_clone = new_clones;\n \t      new_clones->prev_sibling_clone = n;\n \t    }\n@@ -683,21 +680,20 @@ cgraph_find_replacement_node (struct cgraph_node *node)\n    call.  */\n \n void\n-cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n-\t\t\t\t       gimple old_stmt, gimple new_stmt,\n-\t\t\t\t       bool update_speculative)\n+cgraph_node::set_call_stmt_including_clones (gimple old_stmt, gimple new_stmt,\n+\t\t\t\t\t     bool update_speculative)\n {\n   struct cgraph_node *node;\n-  struct cgraph_edge *edge = cgraph_edge (orig, old_stmt);\n+  struct cgraph_edge *edge = get_edge (old_stmt);\n \n   if (edge)\n     cgraph_set_call_stmt (edge, new_stmt, update_speculative);\n \n-  node = orig->clones;\n+  node = clones;\n   if (node)\n-    while (node != orig)\n+    while (node != this)\n       {\n-\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n+\tstruct cgraph_edge *edge = node->get_edge (old_stmt);\n \tif (edge)\n \t  {\n \t    cgraph_set_call_stmt (edge, new_stmt, update_speculative);\n@@ -722,9 +718,9 @@ cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n \t  node = node->next_sibling_clone;\n \telse\n \t  {\n-\t    while (node != orig && !node->next_sibling_clone)\n+\t    while (node != this && !node->next_sibling_clone)\n \t      node = node->clone_of;\n-\t    if (node != orig)\n+\t    if (node != this)\n \t      node = node->next_sibling_clone;\n \t  }\n       }\n@@ -738,38 +734,36 @@ cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n    frequencies of the clones.  */\n \n void\n-cgraph_create_edge_including_clones (struct cgraph_node *orig,\n-\t\t\t\t     struct cgraph_node *callee,\n-\t\t\t\t     gimple old_stmt,\n-\t\t\t\t     gimple stmt, gcov_type count,\n-\t\t\t\t     int freq,\n-\t\t\t\t     cgraph_inline_failed_t reason)\n+cgraph_node::create_edge_including_clones (struct cgraph_node *callee,\n+\t\t\t\t\t   gimple old_stmt, gimple stmt,\n+\t\t\t\t\t   gcov_type count,\n+\t\t\t\t\t   int freq,\n+\t\t\t\t\t   cgraph_inline_failed_t reason)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n \n-  if (!cgraph_edge (orig, stmt))\n+  if (!get_edge (stmt))\n     {\n-      edge = cgraph_create_edge (orig, callee, stmt, count, freq);\n+      edge = create_edge (callee, stmt, count, freq);\n       edge->inline_failed = reason;\n     }\n \n-  node = orig->clones;\n+  node = clones;\n   if (node)\n-    while (node != orig)\n+    while (node != this)\n       {\n-\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n+\tstruct cgraph_edge *edge = node->get_edge (old_stmt);\n \n         /* It is possible that clones already contain the edge while\n \t   master didn't.  Either we promoted indirect call into direct\n \t   call in the clone or we are processing clones of unreachable\n \t   master where edges has been removed.  */\n \tif (edge)\n \t  cgraph_set_call_stmt (edge, stmt);\n-\telse if (!cgraph_edge (node, stmt))\n+\telse if (! node->get_edge (stmt))\n \t  {\n-\t    edge = cgraph_create_edge (node, callee, stmt, count,\n-\t\t\t\t       freq);\n+\t    edge = node->create_edge (callee, stmt, count, freq);\n \t    edge->inline_failed = reason;\n \t  }\n \n@@ -779,9 +773,9 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n \t  node = node->next_sibling_clone;\n \telse\n \t  {\n-\t    while (node != orig && !node->next_sibling_clone)\n+\t    while (node != this && !node->next_sibling_clone)\n \t      node = node->clone_of;\n-\t    if (node != orig)\n+\t    if (node != this)\n \t      node = node->next_sibling_clone;\n \t  }\n       }\n@@ -793,23 +787,23 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n    tree.  */\n \n bool\n-cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_node *forbidden_node)\n+cgraph_node::remove_symbol_and_inline_clones (cgraph_node *forbidden_node)\n {\n   struct cgraph_edge *e, *next;\n   bool found = false;\n \n-  if (node == forbidden_node)\n+  if (this == forbidden_node)\n     {\n-      cgraph_remove_edge (node->callers);\n+      cgraph_remove_edge (callers);\n       return true;\n     }\n-  for (e = node->callees; e; e = next)\n+  for (e = callees; e; e = next)\n     {\n       next = e->next_callee;\n       if (!e->inline_failed)\n-        found |= cgraph_remove_node_and_inline_clones (e->callee, forbidden_node);\n+\tfound |= e->callee->remove_symbol_and_inline_clones (forbidden_node);\n     }\n-  cgraph_remove_node (node);\n+  remove ();\n   return found;\n }\n \n@@ -835,47 +829,44 @@ update_call_expr (struct cgraph_node *new_version)\n \n \n /* Create a new cgraph node which is the new version of\n-   OLD_VERSION node.  REDIRECT_CALLERS holds the callers\n+   callgraph node.  REDIRECT_CALLERS holds the callers\n    edges which should be redirected to point to\n-   NEW_VERSION.  ALL the callees edges of OLD_VERSION\n+   NEW_VERSION.  ALL the callees edges of the node\n    are cloned to the new version node.  Return the new\n    version node. \n \n    If non-NULL BLOCK_TO_COPY determine what basic blocks \n    was copied to prevent duplications of calls that are dead\n    in the clone.  */\n \n-struct cgraph_node *\n-cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n-\t\t\t\t tree new_decl,\n-\t\t\t\t vec<cgraph_edge_p> redirect_callers,\n-\t\t\t\t bitmap bbs_to_copy)\n+cgraph_node *\n+cgraph_node::create_version_clone (tree new_decl,\n+\t\t\t\t  vec<cgraph_edge *> redirect_callers,\n+\t\t\t\t  bitmap bbs_to_copy)\n  {\n    struct cgraph_node *new_version;\n    struct cgraph_edge *e;\n    unsigned i;\n \n-   gcc_assert (old_version);\n-\n-   new_version = cgraph_create_node (new_decl);\n+   new_version = cgraph_node::create (new_decl);\n \n-   new_version->analyzed = old_version->analyzed;\n-   new_version->definition = old_version->definition;\n-   new_version->local = old_version->local;\n+   new_version->analyzed = analyzed;\n+   new_version->definition = definition;\n+   new_version->local = local;\n    new_version->externally_visible = false;\n    new_version->local.local = new_version->definition;\n-   new_version->global = old_version->global;\n-   new_version->rtl = old_version->rtl;\n-   new_version->count = old_version->count;\n+   new_version->global = global;\n+   new_version->rtl = rtl;\n+   new_version->count = count;\n \n-   for (e = old_version->callees; e; e=e->next_callee)\n+   for (e = callees; e; e=e->next_callee)\n      if (!bbs_to_copy\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n        cgraph_clone_edge (e, new_version, e->call_stmt,\n \t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n \t\t\t  CGRAPH_FREQ_BASE,\n \t\t\t  true);\n-   for (e = old_version->indirect_calls; e; e=e->next_callee)\n+   for (e = indirect_calls; e; e=e->next_callee)\n      if (!bbs_to_copy\n \t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n        cgraph_clone_edge (e, new_version, e->call_stmt,\n@@ -889,7 +880,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n        cgraph_redirect_edge_callee (e, new_version);\n      }\n \n-   cgraph_call_node_duplication_hooks (old_version, new_version);\n+   call_duplication_hooks (new_version);\n \n    return new_version;\n  }\n@@ -904,7 +895,6 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    TREE_MAP is a mapping of tree nodes we want to replace with\n    new ones (according to results of prior analysis).\n-   OLD_VERSION_NODE is the node that is versioned.\n \n    If non-NULL ARGS_TO_SKIP determine function parameters to remove\n    from new version.\n@@ -914,24 +904,21 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    Return the new version's cgraph node.  */\n \n-struct cgraph_node *\n-cgraph_function_versioning (struct cgraph_node *old_version_node,\n-\t\t\t    vec<cgraph_edge_p> redirect_callers,\n-\t\t\t    vec<ipa_replace_map_p, va_gc> *tree_map,\n-\t\t\t    bitmap args_to_skip,\n-\t\t\t    bool skip_return,\n-\t\t\t    bitmap bbs_to_copy,\n-\t\t\t    basic_block new_entry_block,\n-\t\t\t    const char *clone_name)\n+cgraph_node *\n+cgraph_node::create_version_clone_with_body\n+  (vec<cgraph_edge *> redirect_callers,\n+   vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,\n+   bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,\n+   const char *clone_name)\n {\n-  tree old_decl = old_version_node->decl;\n+  tree old_decl = decl;\n   struct cgraph_node *new_version_node = NULL;\n   tree new_decl;\n \n   if (!tree_versionable_function_p (old_decl))\n     return NULL;\n \n-  gcc_assert (old_version_node->local.can_change_signature || !args_to_skip);\n+  gcc_assert (local.can_change_signature || !args_to_skip);\n \n   /* Make a new FUNCTION_DECL tree node for the new version. */\n   if (!args_to_skip && !skip_return)\n@@ -951,13 +938,12 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \n   /* Create the new version's call-graph node.\n      and update the edges of the new node. */\n-  new_version_node =\n-    cgraph_copy_node_for_versioning (old_version_node, new_decl,\n-\t\t\t\t     redirect_callers, bbs_to_copy);\n+  new_version_node = create_version_clone (new_decl, redirect_callers,\n+\t\t\t\t\t  bbs_to_copy);\n \n-  if (old_version_node->ipa_transforms_to_apply.exists ())\n+  if (ipa_transforms_to_apply.exists ())\n     new_version_node->ipa_transforms_to_apply\n-      = old_version_node->ipa_transforms_to_apply.copy ();\n+      = ipa_transforms_to_apply.copy ();\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip,\n \t\t\t    skip_return, bbs_to_copy, new_entry_block);\n@@ -967,7 +953,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  symtab_make_decl_local (new_version_node->decl);\n+  new_version_node->make_decl_local ();\n   DECL_VIRTUAL_P (new_version_node->decl) = 0;\n   new_version_node->externally_visible = 0;\n   new_version_node->local.local = 1;\n@@ -983,7 +969,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n \n-  cgraph_call_function_insertion_hooks (new_version_node);\n+  new_version_node->call_function_insertion_hooks ();\n   return new_version_node;\n }\n \n@@ -1018,8 +1004,8 @@ cgraph_materialize_clone (struct cgraph_node *node)\n   node->prev_sibling_clone = NULL;\n   if (!node->clone_of->analyzed && !node->clone_of->clones)\n     {\n-      cgraph_release_function_body (node->clone_of);\n-      cgraph_node_remove_callees (node->clone_of);\n+      node->clone_of->release_body ();\n+      node->clone_of->remove_callees ();\n       node->clone_of->remove_all_references ();\n     }\n   node->clone_of = NULL;\n@@ -1042,7 +1028,7 @@ cgraph_materialize_all_clones (void)\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materializing clones\\n\");\n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  cgraph_node::verify_cgraph_nodes ();\n #endif\n \n   /* We can also do topological order, but number of iterations should be\n@@ -1057,7 +1043,7 @@ cgraph_materialize_all_clones (void)\n \t      && !gimple_has_body_p (node->decl))\n \t    {\n \t      if (!node->clone_of->clone_of)\n-\t\tcgraph_get_body (node->clone_of);\n+\t\tnode->clone_of->get_body ();\n \t      if (gimple_has_body_p (node->clone_of->decl))\n \t        {\n \t\t  if (cgraph_dump_file)\n@@ -1104,15 +1090,15 @@ cgraph_materialize_all_clones (void)\n   FOR_EACH_FUNCTION (node)\n     if (!node->analyzed && node->callees)\n       {\n-        cgraph_node_remove_callees (node);\n+\tnode->remove_callees ();\n \tnode->remove_all_references ();\n       }\n     else\n       node->clear_stmts_in_references ();\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  cgraph_node::verify_cgraph_nodes ();\n #endif\n   symtab_remove_unreachable_nodes (false, cgraph_dump_file);\n }"}, {"sha": "47828d752a9619b34860f2eadff45915f87e3b11", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 114, "deletions": 119, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -220,7 +220,6 @@ cgraph_node_set cgraph_new_nodes;\n static void expand_all_functions (void);\n static void mark_functions_to_output (void);\n static void expand_function (struct cgraph_node *);\n-static void analyze_function (struct cgraph_node *);\n static void handle_alias_pairs (void);\n \n FILE *cgraph_dump_file;\n@@ -320,7 +319,7 @@ cgraph_process_new_functions (void)\n \t     it into reachable functions list.  */\n \n \t  cgraph_finalize_function (fndecl, false);\n-          cgraph_call_function_insertion_hooks (node);\n+\t  node->call_function_insertion_hooks ();\n \t  enqueue_node (node);\n \t  break;\n \n@@ -332,7 +331,7 @@ cgraph_process_new_functions (void)\n \n \t  gimple_register_cfg_hooks ();\n \t  if (!node->analyzed)\n-\t    analyze_function (node);\n+\t    node->analyze ();\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \t  if (cgraph_state == CGRAPH_STATE_IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n@@ -342,14 +341,14 @@ cgraph_process_new_functions (void)\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  pop_cfun ();\n-          cgraph_call_function_insertion_hooks (node);\n+\t  node->call_function_insertion_hooks ();\n \t  break;\n \n \tcase CGRAPH_STATE_EXPANSION:\n \t  /* Functions created during expansion shall be compiled\n \t     directly.  */\n \t  node->process = 0;\n-          cgraph_call_function_insertion_hooks (node);\n+\t  node->call_function_insertion_hooks ();\n \t  expand_function (node);\n \t  break;\n \n@@ -373,27 +372,27 @@ cgraph_process_new_functions (void)\n    body for expanding the function but this is difficult to do.  */\n \n void\n-cgraph_reset_node (struct cgraph_node *node)\n+cgraph_node::reset (void)\n {\n-  /* If node->process is set, then we have already begun whole-unit analysis.\n+  /* If process is set, then we have already begun whole-unit analysis.\n      This is *not* testing for whether we've already emitted the function.\n      That case can be sort-of legitimately seen with real function redefinition\n      errors.  I would argue that the front end should never present us with\n      such a case, but don't enforce that for now.  */\n-  gcc_assert (!node->process);\n+  gcc_assert (!process);\n \n   /* Reset our data structures so we can analyze the function again.  */\n-  memset (&node->local, 0, sizeof (node->local));\n-  memset (&node->global, 0, sizeof (node->global));\n-  memset (&node->rtl, 0, sizeof (node->rtl));\n-  node->analyzed = false;\n-  node->definition = false;\n-  node->alias = false;\n-  node->weakref = false;\n-  node->cpp_implicit_alias = false;\n-\n-  cgraph_node_remove_callees (node);\n-  node->remove_all_references ();\n+  memset (&local, 0, sizeof (local));\n+  memset (&global, 0, sizeof (global));\n+  memset (&rtl, 0, sizeof (rtl));\n+  analyzed = false;\n+  definition = false;\n+  alias = false;\n+  weakref = false;\n+  cpp_implicit_alias = false;\n+\n+  remove_callees ();\n+  remove_all_references ();\n }\n \n /* Return true when there are references to NODE.  */\n@@ -421,14 +420,14 @@ referred_to_p (symtab_node *node)\n void\n cgraph_finalize_function (tree decl, bool no_collect)\n {\n-  struct cgraph_node *node = cgraph_get_create_node (decl);\n+  struct cgraph_node *node = cgraph_node::get_create (decl);\n \n   if (node->definition)\n     {\n       /* Nested functions should only be defined once.  */\n       gcc_assert (!DECL_CONTEXT (decl)\n \t\t  || TREE_CODE (DECL_CONTEXT (decl)) !=\tFUNCTION_DECL);\n-      cgraph_reset_node (node);\n+      node->reset ();\n       node->local.redefined_extern_inline = true;\n     }\n \n@@ -488,7 +487,7 @@ cgraph_finalize_function (tree decl, bool no_collect)\n    processing to avoid need the passes to be re-entrant.  */\n \n void\n-cgraph_add_new_function (tree fndecl, bool lowered)\n+cgraph_node::add_new_function (tree fndecl, bool lowered)\n {\n   gcc::pass_manager *passes = g->get_passes ();\n   struct cgraph_node *node;\n@@ -499,7 +498,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n \tbreak;\n       case CGRAPH_STATE_CONSTRUCTION:\n \t/* Just enqueue function to be processed at nearest occurrence.  */\n-\tnode = cgraph_get_create_node (fndecl);\n+\tnode = cgraph_node::get_create (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n \tif (!cgraph_new_nodes)\n@@ -512,7 +511,7 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n       case CGRAPH_STATE_EXPANSION:\n \t/* Bring the function into finalized state and enqueue for later\n \t   analyzing and compilation.  */\n-\tnode = cgraph_get_create_node (fndecl);\n+\tnode = cgraph_node::get_create (fndecl);\n \tnode->local.local = false;\n \tnode->definition = true;\n \tnode->force_output = true;\n@@ -538,11 +537,11 @@ cgraph_add_new_function (tree fndecl, bool lowered)\n       case CGRAPH_STATE_FINISHED:\n \t/* At the very end of compilation we have to do all the work up\n \t   to expansion.  */\n-\tnode = cgraph_create_node (fndecl);\n+\tnode = cgraph_node::create (fndecl);\n \tif (lowered)\n \t  node->lowered = true;\n \tnode->definition = true;\n-\tanalyze_function (node);\n+\tnode->analyze ();\n \tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \tgimple_register_cfg_hooks ();\n \tbitmap_obstack_initialize (NULL);\n@@ -599,48 +598,47 @@ output_asm_statements (void)\n }\n \n /* Analyze the function scheduled to be output.  */\n-static void\n-analyze_function (struct cgraph_node *node)\n+void\n+cgraph_node::analyze (void)\n {\n-  tree decl = node->decl;\n+  tree decl = this->decl;\n   location_t saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (decl);\n \n-  if (node->thunk.thunk_p)\n+  if (thunk.thunk_p)\n     {\n-      cgraph_create_edge (node, cgraph_get_node (node->thunk.alias),\n-\t\t          NULL, 0, CGRAPH_FREQ_BASE);\n-      if (!expand_thunk (node, false, false))\n+      create_edge (cgraph_node::get (thunk.alias),\n+\t\t   NULL, 0, CGRAPH_FREQ_BASE);\n+      if (!expand_thunk (false, false))\n \t{\n-\t  node->thunk.alias = NULL;\n-\t  node->analyzed = true;\n+\t  thunk.alias = NULL;\n+\t  analyzed = true;\n \t  return;\n \t}\n-      node->thunk.alias = NULL;\n+      thunk.alias = NULL;\n     }\n-  if (node->alias)\n-    symtab_resolve_alias\n-       (node, cgraph_get_node (node->alias_target));\n-  else if (node->dispatcher_function)\n+  if (alias)\n+    resolve_alias (cgraph_node::get (alias_target));\n+  else if (dispatcher_function)\n     {\n       /* Generate the dispatcher body of multi-versioned functions.  */\n       struct cgraph_function_version_info *dispatcher_version_info\n-\t= get_cgraph_node_version (node);\n+\t= function_version ();\n       if (dispatcher_version_info != NULL\n           && (dispatcher_version_info->dispatcher_resolver\n \t      == NULL_TREE))\n \t{\n \t  tree resolver = NULL_TREE;\n \t  gcc_assert (targetm.generate_version_dispatcher_body);\n-\t  resolver = targetm.generate_version_dispatcher_body (node);\n+\t  resolver = targetm.generate_version_dispatcher_body (this);\n \t  gcc_assert (resolver != NULL_TREE);\n \t}\n     }\n   else\n     {\n       push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n-      assign_assembler_name_if_neeeded (node->decl);\n+      assign_assembler_name_if_neeeded (decl);\n \n       /* Make sure to gimplify bodies only once.  During analyzing a\n \t function we lower it, which will require gimplified nested\n@@ -651,11 +649,11 @@ analyze_function (struct cgraph_node *node)\n       dump_function (TDI_generic, decl);\n \n       /* Lower the function.  */\n-      if (!node->lowered)\n+      if (!lowered)\n \t{\n-\t  if (node->nested)\n-\t    lower_nested_functions (node->decl);\n-\t  gcc_assert (!node->nested);\n+\t  if (nested)\n+\t    lower_nested_functions (decl);\n+\t  gcc_assert (!nested);\n \n \t  gimple_register_cfg_hooks ();\n \t  bitmap_obstack_initialize (NULL);\n@@ -664,12 +662,12 @@ analyze_function (struct cgraph_node *node)\n \t  free_dominance_info (CDI_DOMINATORS);\n \t  compact_blocks ();\n \t  bitmap_obstack_release (NULL);\n-\t  node->lowered = true;\n+\t  lowered = true;\n \t}\n \n       pop_cfun ();\n     }\n-  node->analyzed = true;\n+  analyzed = true;\n \n   input_location = saved_loc;\n }\n@@ -686,11 +684,10 @@ cgraph_process_same_body_aliases (void)\n   symtab_node *node;\n   FOR_EACH_SYMBOL (node)\n     if (node->cpp_implicit_alias && !node->analyzed)\n-      symtab_resolve_alias\n-        (node,\n-\t TREE_CODE (node->alias_target) == VAR_DECL\n+      node->resolve_alias\n+\t(TREE_CODE (node->alias_target) == VAR_DECL\n \t ? (symtab_node *)varpool_node_for_decl (node->alias_target)\n-\t : (symtab_node *)cgraph_get_create_node (node->alias_target));\n+\t : (symtab_node *)cgraph_node::get_create (node->alias_target));\n   cpp_implicit_aliases_done = true;\n }\n \n@@ -748,7 +745,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n     {\n       tree decl = node->decl;\n       if (DECL_PRESERVE_P (decl))\n-\tcgraph_mark_force_output_node (node);\n+\tnode->mark_force_output ();\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n \t  if (! TREE_PUBLIC (node->decl))\n@@ -893,8 +890,8 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t  if (targets.length () == 1)\n \t    target = targets[0];\n \t  else\n-\t    target = cgraph_get_create_node\n-\t\t       (builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n+\t    target = cgraph_node::create\n+\t\t\t(builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n \n \t  if (cgraph_dump_file)\n \t    {\n@@ -957,7 +954,7 @@ analyze_functions (void)\n   if (cpp_implicit_aliases_done)\n     FOR_EACH_SYMBOL (node)\n       if (node->cpp_implicit_alias)\n-\t  fixup_same_cpp_alias_visibility (node, symtab_alias_target (node));\n+\t  node->fixup_same_cpp_alias_visibility (node->get_alias_target ());\n   if (optimize && flag_devirtualize)\n     build_type_inheritance_graph ();\n \n@@ -1019,13 +1016,13 @@ analyze_functions (void)\n \t\t  && !cnode->thunk.thunk_p\n \t\t  && !cnode->dispatcher_function)\n \t\t{\n-\t\t  cgraph_reset_node (cnode);\n+\t\t  cnode->reset ();\n \t\t  cnode->local.redefined_extern_inline = true;\n \t\t  continue;\n \t\t}\n \n \t      if (!cnode->analyzed)\n-\t\tanalyze_function (cnode);\n+\t\tcnode->analyze ();\n \n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t\tif (edge->callee->definition)\n@@ -1050,7 +1047,7 @@ analyze_functions (void)\n \t      if (DECL_ABSTRACT_ORIGIN (decl))\n \t\t{\n \t\t  struct cgraph_node *origin_node\n-\t    \t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n+\t    \t  = cgraph_node::get (DECL_ABSTRACT_ORIGIN (decl));\n \t\t  origin_node->used_as_abstract_origin = true;\n \t\t}\n \t    }\n@@ -1082,7 +1079,7 @@ analyze_functions (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n-      dump_symtab (cgraph_dump_file);\n+      symtab_node::dump_table (cgraph_dump_file);\n     }\n \n   if (cgraph_dump_file)\n@@ -1097,7 +1094,7 @@ analyze_functions (void)\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", node->name ());\n-\t  symtab_remove_node (node);\n+\t  node->remove ();\n \t  continue;\n \t}\n       if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n@@ -1107,7 +1104,7 @@ analyze_functions (void)\n \t  if (cnode->definition && !gimple_has_body_p (decl)\n \t      && !cnode->alias\n \t      && !cnode->thunk.thunk_p)\n-\t    cgraph_reset_node (cnode);\n+\t    cnode->reset ();\n \n \t  gcc_assert (!cnode->definition || cnode->thunk.thunk_p\n \t\t      || cnode->alias\n@@ -1123,7 +1120,7 @@ analyze_functions (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\n\\nReclaimed \");\n-      dump_symtab (cgraph_dump_file);\n+      symtab_node::dump_table (cgraph_dump_file);\n     }\n   bitmap_obstack_release (NULL);\n   pointer_set_destroy (reachable_call_targets);\n@@ -1157,7 +1154,7 @@ handle_alias_pairs (void)\n       if (!target_node\n \t  && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)) != NULL)\n \t{\n-\t  symtab_node *node = symtab_get_node (p->decl);\n+\t  symtab_node *node = symtab_node::get (p->decl);\n \t  if (node)\n \t    {\n \t      node->alias_target = p->target;\n@@ -1170,7 +1167,7 @@ handle_alias_pairs (void)\n       else if (!target_node)\n \t{\n \t  error (\"%q+D aliased to undefined symbol %qE\", p->decl, p->target);\n-\t  symtab_node *node = symtab_get_node (p->decl);\n+\t  symtab_node *node = symtab_node::get (p->decl);\n \t  if (node)\n \t    node->alias = false;\n \t  alias_pairs->unordered_remove (i);\n@@ -1192,10 +1189,10 @@ handle_alias_pairs (void)\n       if (TREE_CODE (p->decl) == FUNCTION_DECL\n           && target_node && is_a <cgraph_node *> (target_node))\n \t{\n-\t  struct cgraph_node *src_node = cgraph_get_node (p->decl);\n+\t  struct cgraph_node *src_node = cgraph_node::get (p->decl);\n \t  if (src_node && src_node->definition)\n-            cgraph_reset_node (src_node);\n-\t  cgraph_create_function_alias (p->decl, target_node->decl);\n+\t    src_node->reset ();\n+\t  cgraph_node::create_alias (p->decl, target_node->decl);\n \t  alias_pairs->unordered_remove (i);\n \t}\n       else if (TREE_CODE (p->decl) == VAR_DECL\n@@ -1252,11 +1249,11 @@ mark_functions_to_output (void)\n \t  if (node->same_comdat_group)\n \t    {\n \t      struct cgraph_node *next;\n-\t      for (next = cgraph (node->same_comdat_group);\n+\t      for (next = dyn_cast<cgraph_node *> (node->same_comdat_group);\n \t\t   next != node;\n-\t\t   next = cgraph (next->same_comdat_group))\n+\t\t   next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n \t\tif (!next->thunk.thunk_p && !next->alias\n-\t\t    && !symtab_comdat_local_p (next))\n+\t\t    && !next->comdat_local_p ())\n \t\t  next->process = 1;\n \t    }\n \t}\n@@ -1280,7 +1277,7 @@ mark_functions_to_output (void)\n \t      && !node->clones\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n-\t      dump_cgraph_node (stderr, node);\n+\t      node->debug ();\n \t      internal_error (\"failed to reclaim unneeded function\");\n \t    }\n #endif\n@@ -1310,7 +1307,7 @@ mark_functions_to_output (void)\n \t      && !node->clones\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n-\t      dump_cgraph_node (stderr, node);\n+\t      node->debug ();\n \t      internal_error (\"failed to reclaim unneeded function in same \"\n \t\t\t      \"comdat group\");\n \t    }\n@@ -1472,14 +1469,14 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n    thunks that are not lowered.  */\n \n bool\n-expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimple_thunk)\n+cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n {\n-  bool this_adjusting = node->thunk.this_adjusting;\n-  HOST_WIDE_INT fixed_offset = node->thunk.fixed_offset;\n-  HOST_WIDE_INT virtual_value = node->thunk.virtual_value;\n+  bool this_adjusting = thunk.this_adjusting;\n+  HOST_WIDE_INT fixed_offset = thunk.fixed_offset;\n+  HOST_WIDE_INT virtual_value = thunk.virtual_value;\n   tree virtual_offset = NULL;\n-  tree alias = node->callees->callee->decl;\n-  tree thunk_fndecl = node->decl;\n+  tree alias = callees->callee->decl;\n+  tree thunk_fndecl = decl;\n   tree a;\n \n \n@@ -1495,7 +1492,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimpl\n \treturn false;\n \n       if (in_lto_p)\n-\tcgraph_get_body (node);\n+\tget_body ();\n       a = DECL_ARGUMENTS (thunk_fndecl);\n       \n       current_function_decl = thunk_fndecl;\n@@ -1530,8 +1527,8 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimpl\n       free_after_compilation (cfun);\n       set_cfun (NULL);\n       TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-      node->thunk.thunk_p = false;\n-      node->analyzed = false;\n+      thunk.thunk_p = false;\n+      analyzed = false;\n     }\n   else\n     {\n@@ -1548,7 +1545,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimpl\n       gimple ret;\n \n       if (in_lto_p)\n-\tcgraph_get_body (node);\n+\tget_body ();\n       a = DECL_ARGUMENTS (thunk_fndecl);\n       \n       current_function_decl = thunk_fndecl;\n@@ -1559,7 +1556,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimpl\n       DECL_IGNORED_P (thunk_fndecl) = 1;\n       bitmap_obstack_initialize (NULL);\n \n-      if (node->thunk.virtual_offset_p)\n+      if (thunk.virtual_offset_p)\n         virtual_offset = size_int (virtual_value);\n \n       /* Build the return declaration for the function.  */\n@@ -1617,7 +1614,7 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimpl\n \t    vargs.quick_push (tmp);\n \t  }\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n-      node->callees->call_stmt = call;\n+      callees->call_stmt = call;\n       gimple_call_set_from_thunk (call, true);\n       if (restmp)\n \t{\n@@ -1697,8 +1694,8 @@ expand_thunk (struct cgraph_node *node, bool output_asm_thunks, bool force_gimpl\n \n       /* Since we want to emit the thunk, we explicitly mark its name as\n \t referenced.  */\n-      node->thunk.thunk_p = false;\n-      node->lowered = true;\n+      thunk.thunk_p = false;\n+      lowered = true;\n       bitmap_obstack_release (NULL);\n     }\n   current_function_decl = NULL;\n@@ -1720,7 +1717,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n \tstruct cgraph_node *thunk = e->caller;\n \n \te = e->next_caller;\n-        expand_thunk (thunk, true, false);\n+\tthunk->expand_thunk (true, false);\n \tassemble_thunks_and_aliases (thunk);\n       }\n     else\n@@ -1755,7 +1752,7 @@ expand_function (struct cgraph_node *node)\n   announce_function (decl);\n   node->process = 0;\n   gcc_assert (node->lowered);\n-  cgraph_get_body (node);\n+  node->get_body ();\n \n   /* Generate RTL for the body of DECL.  */\n \n@@ -1819,7 +1816,7 @@ expand_function (struct cgraph_node *node)\n \n   gimple_set_body (decl, NULL);\n   if (DECL_STRUCT_FUNCTION (decl) == 0\n-      && !cgraph_get_node (decl)->origin)\n+      && !cgraph_node::get (decl)->origin)\n     {\n       /* Stop pointing to the local nodes about to be freed.\n \t But DECL_INITIAL must remain nonzero so we know this\n@@ -1847,10 +1844,10 @@ expand_function (struct cgraph_node *node)\n      FIXME: Perhaps thunks should be move before function IFF they are not in comdat\n      groups.  */\n   assemble_thunks_and_aliases (node);\n-  cgraph_release_function_body (node);\n+  node->release_body ();\n   /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n      points to the dead function body.  */\n-  cgraph_node_remove_callees (node);\n+  node->remove_callees ();\n   node->remove_all_references ();\n }\n \n@@ -2135,7 +2132,7 @@ output_weakrefs (void)\n \t\t    ? DECL_ASSEMBLER_NAME (node->alias_target)\n \t\t    : node->alias_target);\n \telse if (node->analyzed)\n-\t  target = DECL_ASSEMBLER_NAME (symtab_alias_target (node)->decl);\n+\t  target = DECL_ASSEMBLER_NAME (node->get_alias_target ()->decl);\n \telse\n \t  {\n \t    gcc_unreachable ();\n@@ -2164,7 +2161,7 @@ compile (void)\n     return;\n \n #ifdef ENABLE_CHECKING\n-  verify_symtab ();\n+  symtab_node::verify_symtab_nodes ();\n #endif\n \n   timevar_push (TV_CGRAPHOPT);\n@@ -2200,7 +2197,7 @@ compile (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Optimized \");\n-      dump_symtab (cgraph_dump_file);\n+      symtab_node:: dump_table (cgraph_dump_file);\n     }\n   if (post_ipa_mem_report)\n     {\n@@ -2214,15 +2211,15 @@ compile (void)\n   if (!quiet_flag)\n     fprintf (stderr, \"Assembling functions:\\n\");\n #ifdef ENABLE_CHECKING\n-  verify_symtab ();\n+  symtab_node::verify_symtab_nodes ();\n #endif\n \n   cgraph_materialize_all_clones ();\n   bitmap_obstack_initialize (NULL);\n   execute_ipa_pass_list (g->get_passes ()->all_late_ipa_passes);\n   symtab_remove_unreachable_nodes (true, dump_file);\n #ifdef ENABLE_CHECKING\n-  verify_symtab ();\n+  symtab_node::verify_symtab_nodes ();\n #endif\n   bitmap_obstack_release (NULL);\n   mark_functions_to_output ();\n@@ -2272,10 +2269,10 @@ compile (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"\\nFinal \");\n-      dump_symtab (cgraph_dump_file);\n+      symtab_node::dump_table (cgraph_dump_file);\n     }\n #ifdef ENABLE_CHECKING\n-  verify_symtab ();\n+  symtab_node::verify_symtab_nodes ();\n   /* Double check that all inline clones are gone and that all\n      function bodies have been released from memory.  */\n   if (!seen_error ())\n@@ -2288,7 +2285,7 @@ compile (void)\n \t    || gimple_has_body_p (node->decl))\n \t  {\n \t    error_found = true;\n-\t    dump_cgraph_node (stderr, node);\n+\t    node->debug ();\n \t  }\n       if (error_found)\n \tinternal_error (\"nodes with unreleased memory found\");\n@@ -2343,41 +2340,39 @@ finalize_compilation_unit (void)\n   timevar_pop (TV_CGRAPH);\n }\n \n-/* Creates a wrapper from SOURCE node to TARGET node. Thunk is used for this\n+/* Creates a wrapper from cgraph_node to TARGET node. Thunk is used for this\n    kind of wrapper method.  */\n \n void\n-cgraph_make_wrapper (struct cgraph_node *source, struct cgraph_node *target)\n+cgraph_node::create_wrapper (struct cgraph_node *target)\n {\n     /* Preserve DECL_RESULT so we get right by reference flag.  */\n-    tree decl_result = DECL_RESULT (source->decl);\n+    tree decl_result = DECL_RESULT (decl);\n \n     /* Remove the function's body.  */\n-    cgraph_release_function_body (source);\n-    cgraph_reset_node (source);\n+    release_body ();\n+    reset ();\n \n-    DECL_RESULT (source->decl) = decl_result;\n-    DECL_INITIAL (source->decl) = NULL;\n-    allocate_struct_function (source->decl, false);\n+    DECL_RESULT (decl) = decl_result;\n+    DECL_INITIAL (decl) = NULL;\n+    allocate_struct_function (decl, false);\n     set_cfun (NULL);\n \n     /* Turn alias into thunk and expand it into GIMPLE representation.  */\n-    source->definition = true;\n-    source->thunk.thunk_p = true;\n-    source->thunk.this_adjusting = false;\n+    definition = true;\n+    thunk.thunk_p = true;\n+    thunk.this_adjusting = false;\n \n-    struct cgraph_edge *e = cgraph_create_edge (source, target, NULL, 0,\n-\t\t\t\t\t\tCGRAPH_FREQ_BASE);\n+    struct cgraph_edge *e = create_edge (target, NULL, 0, CGRAPH_FREQ_BASE);\n \n-    if (!expand_thunk (source, false, true))\n-      source->analyzed = true;\n+    if (!expand_thunk (false, true))\n+      analyzed = true;\n \n     e->call_stmt_cannot_inline_p = true;\n \n     /* Inline summary set-up.  */\n-\n-    analyze_function (source);\n-    inline_analyze_function (source);\n+    analyze ();\n+    inline_analyze_function (this);\n }\n \n #include \"gt-cgraphunit.h\""}, {"sha": "bc0c42ef3b314b09b3fb3828309cb8f245b424bb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -9188,7 +9188,7 @@ ix86_code_end (void)\n #endif\n       if (USE_HIDDEN_LINKONCE)\n \t{\n-\t  cgraph_create_node (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n+\t  cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n \n \t  targetm.asm_out.unique_section (decl, 0);\n \t  switch_to_section (get_named_section (decl, NULL, 0));\n@@ -9554,7 +9554,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n            && cfun->machine->use_fast_prologue_epilogue_nregs != frame->nregs)\n     {\n       int count = frame->nregs;\n-      struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+      struct cgraph_node *node = cgraph_node::get (current_function_decl);\n \n       cfun->machine->use_fast_prologue_epilogue_nregs = count;\n \n@@ -32028,10 +32028,10 @@ ix86_get_function_versions_dispatcher (void *decl)\n  \n   gcc_assert (fn != NULL && DECL_FUNCTION_VERSIONED (fn));\n \n-  node = cgraph_get_node (fn);\n+  node = cgraph_node::get (fn);\n   gcc_assert (node != NULL);\n \n-  node_v = get_cgraph_node_version (node);\n+  node_v = node->function_version ();\n   gcc_assert (node_v != NULL);\n  \n   if (node_v->dispatcher_resolver != NULL)\n@@ -32078,11 +32078,11 @@ ix86_get_function_versions_dispatcher (void *decl)\n       /* Right now, the dispatching is done via ifunc.  */\n       dispatch_decl = make_dispatcher_decl (default_node->decl);\n \n-      dispatcher_node = cgraph_get_create_node (dispatch_decl);\n+      dispatcher_node = cgraph_node::get_create (dispatch_decl);\n       gcc_assert (dispatcher_node != NULL);\n       dispatcher_node->dispatcher_function = 1;\n       dispatcher_version_info\n-\t= insert_new_cgraph_node_version (dispatcher_node);\n+\t= dispatcher_node->insert_new_function_version ();\n       dispatcher_version_info->next = default_version_info;\n       dispatcher_node->definition = 1;\n \n@@ -32191,8 +32191,8 @@ make_resolver_func (const tree default_decl,\n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n   *empty_bb = init_lowered_empty_function (decl, false);\n \n-  cgraph_add_new_function (decl, true);\n-  cgraph_call_function_insertion_hooks (cgraph_get_create_node (decl));\n+  cgraph_node::add_new_function (decl, true);\n+  cgraph_node::get_create (decl)->call_function_insertion_hooks ();\n \n   pop_cfun ();\n \n@@ -32203,7 +32203,7 @@ make_resolver_func (const tree default_decl,\n \n   /* Create the alias for dispatch to resolver here.  */\n   /*cgraph_create_function_alias (dispatch_decl, decl);*/\n-  cgraph_same_body_alias (NULL, dispatch_decl, decl);\n+  cgraph_node::create_same_body_alias (dispatch_decl, decl);\n   XDELETEVEC (resolver_name);\n   return decl;\n }\n@@ -32227,7 +32227,7 @@ ix86_generate_version_dispatcher_body (void *node_p)\n \n   node = (cgraph_node *)node_p;\n \n-  node_version_info = get_cgraph_node_version (node);\n+  node_version_info = node->function_version ();\n   gcc_assert (node->dispatcher_function\n \t      && node_version_info != NULL);\n "}, {"sha": "4d37c65209febef405477e1452cc6958bac2cf68", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -6848,13 +6848,13 @@ mark_versions_used (tree fn)\n \n   gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n \n-  node = cgraph_get_node (fn);\n+  node = cgraph_node::get (fn);\n   if (node == NULL)\n     return;\n \n   gcc_assert (node->dispatcher_function);\n \n-  node_v = get_cgraph_node_version (node);\n+  node_v = node->function_version ();\n   if (node_v == NULL)\n     return;\n "}, {"sha": "0f611e10a6f83ce12efbad9bb983ecf3847187f3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1147,7 +1147,7 @@ add_method (tree type, tree method, tree using_decl)\n \t\t  if (DECL_ASSEMBLER_NAME_SET_P (method))\n \t\t    mangle_decl (method);\n \t\t}\n-\t      record_function_versions (fn, method);\n+\t      cgraph_node::record_function_versions (fn, method);\n \t      continue;\n \t    }\n \t  if (DECL_INHERITED_CTOR_BASE (method))"}, {"sha": "150c74e2ef775d3fdaef74b49337d55a48cf099d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1072,7 +1072,7 @@ decls_match (tree newdecl, tree olddecl)\n \t      if (DECL_ASSEMBLER_NAME_SET_P (olddecl))\n \t       mangle_decl (olddecl);\n \t    }\n-\t  record_function_versions (olddecl, newdecl);\n+\t  cgraph_node::record_function_versions (olddecl, newdecl);\n \t  return 0;\n \t}\n     }\n@@ -2074,10 +2074,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n     {\n       struct symtab_node *symbol;\n       if (TREE_CODE (olddecl) == FUNCTION_DECL)\n-\tsymbol = cgraph_get_create_node (newdecl);\n+\tsymbol = cgraph_node::get_create (newdecl);\n       else\n \tsymbol = varpool_node_for_decl (newdecl);\n-      symbol->set_comdat_group (symtab_get_node (olddecl)->get_comdat_group ());\n+      symbol->set_comdat_group (symtab_node::get\n+\t(olddecl)->get_comdat_group ());\n     }\n \n   DECL_DEFER_OUTPUT (newdecl) |= DECL_DEFER_OUTPUT (olddecl);\n@@ -2382,13 +2383,13 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       DECL_FUNCTION_VERSIONED (newdecl) = 1;\n       /* newdecl will be purged after copying to olddecl and is no longer\n          a version.  */\n-      delete_function_version (newdecl);\n+      cgraph_node::delete_function_version (newdecl);\n     }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       int function_size;\n-      struct symtab_node *snode = symtab_get_node (olddecl);\n+      struct symtab_node *snode = symtab_node::get (olddecl);\n \n       function_size = sizeof (struct tree_decl_common);\n \n@@ -2450,7 +2451,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n             if (TREE_CODE (olddecl) == VAR_DECL\n \t\t&& (TREE_STATIC (olddecl) || TREE_PUBLIC (olddecl) || DECL_EXTERNAL (olddecl)))\n-\t      snode = symtab_get_node (olddecl);\n+\t      snode = symtab_node::get (olddecl);\n \t    memcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n \t\t    (char *) newdecl + sizeof (struct tree_decl_common),\n \t\t    size - sizeof (struct tree_decl_common)\n@@ -2502,9 +2503,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n   if (TREE_CODE (newdecl) == FUNCTION_DECL\n       || TREE_CODE (newdecl) == VAR_DECL)\n     {\n-      struct symtab_node *snode = symtab_get_node (newdecl);\n+      struct symtab_node *snode = symtab_node::get (newdecl);\n       if (snode)\n-\tsymtab_remove_node (snode);\n+\tsnode->remove ();\n     }\n   ggc_free (newdecl);\n "}, {"sha": "90244efab45ed257dab9479a2a73d9919703e8bc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1928,7 +1928,7 @@ mark_needed (tree decl)\n \t If we know a method will be emitted in other TU and no new\n \t functions can be marked reachable, just use the external\n \t definition.  */\n-      struct cgraph_node *node = cgraph_get_create_node (decl);\n+      struct cgraph_node *node = cgraph_node::get_create (decl);\n       node->forced_by_abi = true;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n@@ -2055,7 +2055,7 @@ maybe_emit_vtables (tree ctype)\n \t{\n \t  current = varpool_node_for_decl (vtbl);\n \t  if (last)\n-\t    symtab_add_to_same_comdat_group (current, last);\n+\t    current->add_to_same_comdat_group (last);\n \t  last = current;\n \t}\n     }\n@@ -2125,7 +2125,7 @@ constrain_visibility (tree decl, int visibility, bool tmpl)\n \t  if (TREE_CODE (decl) == FUNCTION_DECL\n \t      || TREE_CODE (decl) == VAR_DECL)\n \t    {\n-\t      struct symtab_node *snode = symtab_get_node (decl);\n+\t      struct symtab_node *snode = symtab_node::get (decl);\n \n \t      if (snode)\n \t        snode->set_comdat_group (NULL);\n@@ -4252,8 +4252,8 @@ handle_tls_init (void)\n \t  if (single_init_fn == NULL_TREE)\n \t    continue;\n \t  cgraph_node *alias\n-\t    = cgraph_same_body_alias (cgraph_get_create_node (fn),\n-\t\t\t\t      single_init_fn, fn);\n+\t    = cgraph_node::get_create (fn)->create_same_body_alias\n+\t\t(single_init_fn, fn);\n \t  gcc_assert (alias != NULL);\n \t}\n #endif\n@@ -4521,21 +4521,21 @@ cp_write_global_declarations (void)\n \t    {\n \t      struct cgraph_node *node, *next;\n \n-\t      node = cgraph_get_node (decl);\n+\t      node = cgraph_node::get (decl);\n \t      if (node->cpp_implicit_alias)\n-\t\tnode = cgraph_alias_target (node);\n+\t\tnode = node->get_alias_target ();\n \n-\t      cgraph_for_node_and_aliases (node, clear_decl_external,\n-\t\t\t\t\t   NULL, true);\n+\t      node->call_for_symbol_thunks_and_aliases (clear_decl_external,\n+\t\t\t\t\t\t      NULL, true);\n \t      /* If we mark !DECL_EXTERNAL one of the symbols in some comdat\n \t\t group, we need to mark all symbols in the same comdat group\n \t\t that way.  */\n \t      if (node->same_comdat_group)\n-\t\tfor (next = cgraph (node->same_comdat_group);\n+\t\tfor (next = dyn_cast<cgraph_node *> (node->same_comdat_group);\n \t\t     next != node;\n-\t\t     next = cgraph (next->same_comdat_group))\n-\t          cgraph_for_node_and_aliases (next, clear_decl_external,\n-\t\t\t\t\t       NULL, true);\n+\t\t     next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n+\t\t  next->call_for_symbol_thunks_and_aliases (clear_decl_external,\n+\t\t\t\t\t\t\t  NULL, true);\n \t    }\n \n \t  /* If we're going to need to write this function out, and\n@@ -4545,7 +4545,7 @@ cp_write_global_declarations (void)\n \t  if (!DECL_EXTERNAL (decl)\n \t      && decl_needed_p (decl)\n \t      && !TREE_ASM_WRITTEN (decl)\n-\t      && !cgraph_get_node (decl)->definition)\n+\t      && !cgraph_node::get (decl)->definition)\n \t    {\n \t      /* We will output the function; no longer consider it in this\n \t\t loop.  */"}, {"sha": "169f438e56294d8139afc99da515d600939ece79", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1038,9 +1038,8 @@ maybe_add_lambda_conv_op (tree type)\n   if (DECL_ONE_ONLY (statfn))\n     {\n       /* Put the thunk in the same comdat group as the call op.  */\n-      symtab_add_to_same_comdat_group\n-\t (cgraph_get_create_node (statfn),\n-          cgraph_get_create_node (callop));\n+      cgraph_node::get_create (statfn)->add_to_same_comdat_group\n+\t(cgraph_node::get_create (callop));\n     }\n   tree body = begin_function_body ();\n   tree compound_stmt = begin_compound_stmt (0);"}, {"sha": "8983e0dfa69fceff73c314cba1518f665a03b9b5", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -3487,8 +3487,8 @@ mangle_decl (const tree decl)\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n \t  /* Don't create an alias to an unreferenced function.  */\n-\t  if (struct cgraph_node *n = cgraph_get_node (decl))\n-\t    cgraph_same_body_alias (n, alias, decl);\n+\t  if (struct cgraph_node *n = cgraph_node::get (decl))\n+\t    n->create_same_body_alias (alias, decl);\n \t}\n       else\n \tvarpool_extra_name_alias (alias, decl);"}, {"sha": "e5fa0c1b9da04e25d5ae742b12d5529b8e420a95", "filename": "gcc/cp/method.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -260,9 +260,9 @@ make_alias_for_thunk (tree function)\n   if (!flag_syntax_only)\n     {\n       struct cgraph_node *funcn, *aliasn;\n-      funcn = cgraph_get_node (function);\n+      funcn = cgraph_node::get (function);\n       gcc_checking_assert (funcn);\n-      aliasn = cgraph_same_body_alias (funcn, alias, function);\n+      aliasn = cgraph_node::create_same_body_alias (alias, function);\n       DECL_ASSEMBLER_NAME (function);\n       gcc_assert (aliasn != NULL);\n     }\n@@ -359,13 +359,13 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       tree fn = function;\n       struct symtab_node *symbol;\n \n-      if ((symbol = symtab_get_node (function))\n+      if ((symbol = symtab_node::get (function))\n \t  && symbol->alias)\n \t{\n \t  if (symbol->analyzed)\n-\t    fn = symtab_alias_ultimate_target (symtab_get_node (function))->decl;\n+\t    fn = symtab_node::get (function)->ultimate_alias_target ()->decl;\n \t  else\n-\t    fn = symtab_get_node (function)->alias_target;\n+\t    fn = symtab_node::get (function)->alias_target;\n \t}\n       resolve_unique_section (fn, 0, flag_function_sections);\n \n@@ -375,8 +375,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n \t  /* Output the thunk into the same section as function.  */\n \t  set_decl_section_name (thunk_fndecl, DECL_SECTION_NAME (fn));\n-\t  symtab_get_node (thunk_fndecl)->implicit_section\n-\t    = symtab_get_node (fn)->implicit_section;\n+\t  symtab_node::get (thunk_fndecl)->implicit_section\n+\t    = symtab_node::get (fn)->implicit_section;\n \t}\n     }\n \n@@ -395,14 +395,13 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   a = nreverse (t);\n   DECL_ARGUMENTS (thunk_fndecl) = a;\n   TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n-  funcn = cgraph_get_node (function);\n+  funcn = cgraph_node::get (function);\n   gcc_checking_assert (funcn);\n-  thunk_node = cgraph_add_thunk (funcn, thunk_fndecl, function,\n-\t\t\t\t this_adjusting, fixed_offset, virtual_value,\n-\t\t\t\t virtual_offset, alias);\n+  thunk_node = funcn->create_thunk (thunk_fndecl, function,\n+\t\t\t\t    this_adjusting, fixed_offset, virtual_value,\n+\t\t\t\t    virtual_offset, alias);\n   if (DECL_ONE_ONLY (function))\n-    symtab_add_to_same_comdat_group (thunk_node,\n-\t\t\t\t     funcn);\n+    thunk_node->add_to_same_comdat_group (funcn);\n \n   if (!this_adjusting\n       || !targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,"}, {"sha": "3cd804780ebe6c19653cbeea5b4fa530075fb301", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -191,7 +191,7 @@ cdtor_comdat_group (tree complete, tree base)\n \tdiff_seen = true;\n       }\n   grp_name[idx] = '\\0';\n-  gcc_assert (diff_seen || symtab_get_node (complete)->alias);\n+  gcc_assert (diff_seen || symtab_node::get (complete)->alias);\n   return get_identifier (grp_name);\n }\n \n@@ -287,16 +287,16 @@ maybe_thunk_body (tree fn, bool force)\n   else if (HAVE_COMDAT_GROUP)\n     {\n       tree comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n-      cgraph_get_create_node (fns[0])->set_comdat_group (comdat_group);\n-      symtab_add_to_same_comdat_group (cgraph_get_create_node (fns[1]),\n-\t\t\t\t       cgraph_get_create_node (fns[0]));\n-      symtab_add_to_same_comdat_group (symtab_get_node (fn),\n-\t\t\t\t       symtab_get_node (fns[0]));\n+      cgraph_node::get_create (fns[0])->set_comdat_group (comdat_group);\n+      cgraph_node::get_create (fns[1])->add_to_same_comdat_group\n+\t(cgraph_node::get_create (fns[0]));\n+      symtab_node::get (fn)->add_to_same_comdat_group\n+\t(symtab_node::get (fns[0]));\n       if (fns[2])\n \t/* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n \t   virtual, it goes into the same comdat group as well.  */\n-\tsymtab_add_to_same_comdat_group (cgraph_get_create_node (fns[2]),\n-\t\t\t\t\t symtab_get_node (fns[0]));\n+\tcgraph_node::get_create (fns[2])->add_to_same_comdat_group\n+\t  (symtab_node::get (fns[0]));\n       TREE_PUBLIC (fn) = false;\n       DECL_EXTERNAL (fn) = false;\n       DECL_INTERFACE_KNOWN (fn) = true;\n@@ -475,7 +475,7 @@ maybe_clone_body (tree fn)\n \t name of fn was corrupted by write_mangled_name by adding *INTERNAL*\n \t to it. By doing so, it also corrupted the comdat group. */\n       if (DECL_ONE_ONLY (fn))\n-\tcgraph_get_create_node (clone)->set_comdat_group (cxx_comdat_group (clone));\n+\tcgraph_node::get_create (clone)->set_comdat_group (cxx_comdat_group (clone));\n       DECL_USE_TEMPLATE (clone) = DECL_USE_TEMPLATE (fn);\n       DECL_EXTERNAL (clone) = DECL_EXTERNAL (fn);\n       DECL_INTERFACE_KNOWN (clone) = DECL_INTERFACE_KNOWN (fn);\n@@ -542,8 +542,8 @@ maybe_clone_body (tree fn)\n       if (can_alias\n \t  && fns[0]\n \t  && idx == 1\n-\t  && cgraph_same_body_alias (cgraph_get_create_node (fns[0]),\n-\t\t\t\t     clone, fns[0]))\n+\t  && cgraph_node::get_create (fns[0])->create_same_body_alias\n+\t       (clone, fns[0]))\n \t{\n \t  alias = true;\n \t  if (DECL_ONE_ONLY (fns[0]))\n@@ -552,11 +552,11 @@ maybe_clone_body (tree fn)\n \t\t into the same, *[CD]5* comdat group instead of\n \t\t *[CD][12]*.  */\n \t      comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n-\t      cgraph_get_create_node (fns[0])->set_comdat_group (comdat_group);\n-\t      if (symtab_get_node (clone)->same_comdat_group)\n-\t\tsymtab_remove_from_same_comdat_group (symtab_get_node (clone));\n-\t      symtab_add_to_same_comdat_group (symtab_get_node (clone),\n-\t\t\t\t\t       symtab_get_node (fns[0]));\n+\t      cgraph_node::get_create (fns[0])->set_comdat_group (comdat_group);\n+\t      if (symtab_node::get (clone)->same_comdat_group)\n+\t\tsymtab_node::get (clone)->remove_from_same_comdat_group ();\n+\t      symtab_node::get (clone)->add_to_same_comdat_group\n+\t\t(symtab_node::get (fns[0]));\n \t    }\n \t}\n \n@@ -568,9 +568,8 @@ maybe_clone_body (tree fn)\n \t  /* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n \t     virtual, it goes into the same comdat group as well.  */\n \t  if (comdat_group)\n-\t    symtab_add_to_same_comdat_group\n-\t       (cgraph_get_create_node (clone),\n-\t        symtab_get_node (fns[0]));\n+\t    cgraph_node::get_create (clone)->add_to_same_comdat_group\n+\t      (symtab_node::get (fns[0]));\n \t}\n       else if (alias)\n \t/* No need to populate body.  */ ;"}, {"sha": "f6c5693df5ff6b1e7928aa043896be1c6ade67c2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -4031,7 +4031,7 @@ cp_fix_function_decl_p (tree decl)\n       && !DECL_THUNK_P (decl)\n       && !DECL_EXTERNAL (decl))\n     {\n-      struct cgraph_node *node = cgraph_get_node (decl);\n+      struct cgraph_node *node = cgraph_node::get (decl);\n \n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */"}, {"sha": "09e6730b37c3464e229526bc13ce1b5250393e9a", "filename": "gcc/cp/vtable-class-hierarchy.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fvtable-class-hierarchy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fcp%2Fvtable-class-hierarchy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fvtable-class-hierarchy.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1186,7 +1186,7 @@ vtv_generate_init_routine (void)\n         DECL_STATIC_CONSTRUCTOR (vtv_fndecl) = 0;\n \n       gimplify_function_tree (vtv_fndecl);\n-      cgraph_add_new_function (vtv_fndecl, false);\n+      cgraph_node::add_new_function (vtv_fndecl, false);\n \n       cgraph_process_new_functions ();\n \n@@ -1248,7 +1248,7 @@ vtable_find_or_create_map_decl (tree base_type)\n          we can find and protect them.  */\n \n       set_decl_section_name (var_decl, \".vtable_map_vars\");\n-      symtab_get_node (var_decl)->implicit_section = true;\n+      symtab_node::get (var_decl)->implicit_section = true;\n       DECL_INITIAL (var_decl) = initial_value;\n \n       comdat_linkage (var_decl);"}, {"sha": "6fa2a7068c6569c12b7ceaf214573150bca1864c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -15371,7 +15371,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n          optimizing and gimplifying the CU by now.\n \t So if *TP has no call graph node associated\n \t to it, it means *TP will not be emitted.  */\n-      if (!cgraph_get_node (*tp))\n+      if (!cgraph_node::get (*tp))\n \treturn *tp;\n     }\n   else if (TREE_CODE (*tp) == STRING_CST && !TREE_ASM_WRITTEN (*tp))"}, {"sha": "c8dbc50141c6f6357ae0f60e614f8afd79452315", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1990,15 +1990,14 @@ set_nothrow_function_flags (void)\n       }\n \n   if (crtl->nothrow\n-      && (cgraph_function_body_availability (cgraph_get_node\n-\t\t\t\t\t     (current_function_decl))\n+      && (cgraph_node::get (current_function_decl)->get_availability ()\n           >= AVAIL_AVAILABLE))\n     {\n-      struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+      struct cgraph_node *node = cgraph_node::get (current_function_decl);\n       struct cgraph_edge *e;\n       for (e = node->callers; e; e = e->next_caller)\n         e->can_throw_external = false;\n-      cgraph_set_nothrow_flag (node, true);\n+      node->set_nothrow_flag (true);\n \n       if (dump_file)\n \tfprintf (dump_file, \"Marking function nothrow: %s\\n\\n\","}, {"sha": "ff9e4048b6c86328bf1c0cbcd9dad3dd1faba9b8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -16037,7 +16037,7 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \t  {\n \t    struct symtab_node *symbol;\n \n-\t    symbol = symtab_get_node (base);\n+\t    symbol = symtab_node::get (base);\n \t    if (symbol)\n \t      return symbol->nonzero_address ();\n \t    else"}, {"sha": "8b56151ca69e580a4b381c8bc78936ad15983cf4", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -4800,7 +4800,7 @@ generate_coarray_init (gfc_namespace * ns __attribute((unused)))\n   set_cfun (NULL);\n \n   if (decl_function_context (fndecl))\n-    (void) cgraph_create_node (fndecl);\n+    (void) cgraph_node::create (fndecl);\n   else\n     cgraph_finalize_function (fndecl, true);\n \n@@ -5893,7 +5893,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t function has already called cgraph_create_node, which also created\n \t the cgraph node for this function.  */\n       if (!has_coarray_vars || gfc_option.coarray != GFC_FCOARRAY_LIB)\n-\t(void) cgraph_create_node (fndecl);\n+\t(void) cgraph_node::create (fndecl);\n     }\n   else\n     cgraph_finalize_function (fndecl, true);"}, {"sha": "5e2cbdaf0c5c49008c2cb4db94fd353ac6a81b04", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -99,7 +99,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n \t static objects are defined.  */\n       if (cgraph_function_flags_ready)\n \treturn true;\n-      snode = symtab_get_node (decl);\n+      snode = symtab_node::get (decl);\n       if (!snode || !snode->definition)\n \treturn false;\n       node = dyn_cast <cgraph_node *> (snode);\n@@ -124,7 +124,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   if (DECL_VISIBILITY_SPECIFIED (decl)\n       && DECL_EXTERNAL (decl)\n       && DECL_VISIBILITY (decl) != VISIBILITY_DEFAULT\n-      && (!(snode = symtab_get_node (decl)) || !snode->in_other_partition))\n+      && (!(snode = symtab_node::get (decl)) || !snode->in_other_partition))\n     return false;\n   /* When function is public, we always can introduce new reference.\n      Exception are the COMDAT functions where introducing a direct\n@@ -145,7 +145,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   if (!cgraph_function_flags_ready)\n     return true;\n \n-  snode = symtab_get_node (decl);\n+  snode = symtab_node::get (decl);\n   if (!snode\n       || ((!snode->definition || DECL_EXTERNAL (decl))\n \t  && (!snode->in_other_partition\n@@ -201,7 +201,7 @@ canonicalize_constructor_val (tree cval, tree from_decl)\n \t  /* Make sure we create a cgraph node for functions we'll reference.\n \t     They can be non-existent if the reference comes from an entry\n \t     of an external vtable for example.  */\n-\t  cgraph_get_create_node (base);\n+\t  cgraph_node::get_create (base);\n \t}\n       /* Fixup types in global initializers.  */\n       if (TREE_TYPE (TREE_TYPE (cval)) != TREE_TYPE (TREE_OPERAND (cval, 0)))\n@@ -1107,8 +1107,8 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t{\n           if (dump_file && virtual_method_call_p (callee)\n \t      && !possible_polymorphic_call_target_p\n-\t\t    (callee, cgraph_get_node (gimple_call_addr_fndecl\n-                                                 (OBJ_TYPE_REF_EXPR (callee)))))\n+\t\t    (callee, cgraph_node::get (gimple_call_addr_fndecl\n+\t\t\t\t\t       (OBJ_TYPE_REF_EXPR (callee)))))\n \t    {\n \t      fprintf (dump_file,\n \t\t       \"Type inheritance inconsistent devirtualization of \");\n@@ -3354,7 +3354,7 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n   /* Make sure we create a cgraph node for functions we'll reference.\n      They can be non-existent if the reference comes from an entry\n      of an external vtable for example.  */\n-  cgraph_get_create_node (fn);\n+  cgraph_node::get_create (fn);\n \n   return fn;\n }"}, {"sha": "ad9bb06dcfd9fa63b359912d8fc3a0d16a7858d8", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -101,12 +101,12 @@ update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n \t   to avoid calling them if we never see any calls.  */\n \tif (cfun_node == NULL)\n \t  {\n-\t    cfun_node = cgraph_get_node (current_function_decl);\n+\t    cfun_node = cgraph_node::get (current_function_decl);\n \t    bb_freq = (compute_call_stmt_bb_frequency\n \t\t       (current_function_decl, bb));\n \t  }\n \n-\te = cgraph_edge (cfun_node, n);\n+\te = cfun_node->get_edge (n);\n \tif (e != NULL)\n \t  e->frequency = bb_freq;\n       }"}, {"sha": "4ab36d0a4cfef500b6ab0190a685d4cf90667fd5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -826,7 +826,7 @@ copy_if_shared (tree *tp, void *data)\n static void\n unshare_body (tree fndecl)\n {\n-  struct cgraph_node *cgn = cgraph_get_node (fndecl);\n+  struct cgraph_node *cgn = cgraph_node::get (fndecl);\n   /* If the language requires deep unsharing, we need a pointer set to make\n      sure we don't repeatedly unshare subtrees of unshareable nodes.  */\n   struct pointer_set_t *visited\n@@ -876,7 +876,7 @@ unmark_visited (tree *tp)\n static void\n unvisit_body (tree fndecl)\n {\n-  struct cgraph_node *cgn = cgraph_get_node (fndecl);\n+  struct cgraph_node *cgn = cgraph_node::get (fndecl);\n \n   unmark_visited (&DECL_SAVED_TREE (fndecl));\n   unmark_visited (&DECL_SIZE (DECL_RESULT (fndecl)));\n@@ -8764,7 +8764,7 @@ gimplify_body (tree fndecl, bool do_parms)\n   unshare_body (fndecl);\n   unvisit_body (fndecl);\n \n-  cgn = cgraph_get_node (fndecl);\n+  cgn = cgraph_node::get (fndecl);\n   if (cgn && cgn->origin)\n     nonlocal_vlas = pointer_set_create ();\n "}, {"sha": "b270d9717b27caac6c04292da58456880ac6eaf9", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -165,7 +165,7 @@ enqueue_references (symtab_node **first,\n \n   for (i = 0; symbol->iterate_reference (i, ref); i++)\n     {\n-      symtab_node *node = symtab_alias_ultimate_target (ref->referred, NULL);\n+      symtab_node *node = ref->referred->ultimate_alias_target ();\n       if (!node->aux && node->definition)\n \t{\n \t   node->aux = *first;\n@@ -182,8 +182,7 @@ enqueue_references (symtab_node **first,\n \t  enqueue_references (first, edge->callee);\n \telse\n \t  {\n-\t    symtab_node *node = symtab_alias_ultimate_target (edge->callee,\n-\t\t\t\t\t\t\t      NULL);\n+\t    symtab_node *node = edge->callee->ultimate_alias_target ();\n \t    if (!node->aux && node->definition)\n \t      {\n \t\t node->aux = *first;\n@@ -204,7 +203,7 @@ set_comdat_group (symtab_node *symbol,\n \n   gcc_assert (!symbol->get_comdat_group ());\n   symbol->set_comdat_group (head->get_comdat_group ());\n-  symtab_add_to_same_comdat_group (symbol, head);\n+  symbol->add_to_same_comdat_group (head);\n   return false;\n }\n \n@@ -225,7 +224,7 @@ ipa_comdats (void)\n      ERROR_MARK_NODE as bottom for the propagation.  */\n \n   FOR_EACH_DEFINED_SYMBOL (symbol)\n-    if (!symtab_real_symbol_p (symbol))\n+    if (!symbol->real_symbol_p ())\n       ;\n     else if ((group = symbol->get_comdat_group ()) != NULL)\n       {\n@@ -248,7 +247,7 @@ ipa_comdats (void)\n \t\t && (DECL_STATIC_CONSTRUCTOR (symbol->decl)\n \t\t     || DECL_STATIC_DESTRUCTOR (symbol->decl))))\n       {\n-\tmap.put (symtab_alias_ultimate_target (symbol, NULL), error_mark_node);\n+\tmap.put (symbol->ultimate_alias_target (), error_mark_node);\n \n \t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n \tsymbol->aux = (symtab_node *) (void *) 1;\n@@ -316,7 +315,7 @@ ipa_comdats (void)\n       symbol->aux = NULL; \n       if (!symbol->get_comdat_group ()\n \t  && !symbol->alias\n-\t  && symtab_real_symbol_p (symbol))\n+\t  && symbol->real_symbol_p ())\n \t{\n \t  tree group = *map.get (symbol);\n \n@@ -325,11 +324,12 @@ ipa_comdats (void)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Localizing symbol\\n\");\n-\t      dump_symtab_node (dump_file, symbol);\n+\t      symbol->dump (dump_file);\n \t      fprintf (dump_file, \"To group: %s\\n\", IDENTIFIER_POINTER (group));\n \t    }\n-\t  symtab_for_node_and_aliases (symbol, set_comdat_group,\n-\t\t\t\t       *comdat_head_map.get (group), true);\n+\t  symbol->call_for_symbol_and_aliases (set_comdat_group,\n+\t\t\t\t\t     *comdat_head_map.get (group),\n+\t\t\t\t\t     true);\n \t}\n     }\n   return 0;"}, {"sha": "8d3d6ed1c4b87f4d808db56a38887d0017287d1c", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -428,7 +428,7 @@ determine_versionability (struct cgraph_node *node)\n     reason = \"alias or thunk\";\n   else if (!node->local.versionable)\n     reason = \"not a tree_versionable_function\";\n-  else if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+  else if (node->get_availability () <= AVAIL_INTERPOSABLE)\n     reason = \"insufficient body availability\";\n   else if (!opt_for_fn (node->decl, optimize)\n \t   || !opt_for_fn (node->decl, flag_ipa_cp))\n@@ -442,7 +442,7 @@ determine_versionability (struct cgraph_node *node)\n     }\n   /* Don't clone decls local to a comdat group; it breaks and for C++\n      decloned constructors, inlining is always better anyway.  */\n-  else if (symtab_comdat_local_p (node))\n+  else if (node->comdat_local_p ())\n     reason = \"comdat-local function\";\n \n   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n@@ -491,8 +491,8 @@ gather_caller_stats (struct cgraph_node *node, void *data)\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (cs->caller->thunk.thunk_p)\n-      cgraph_for_node_and_aliases (cs->caller, gather_caller_stats,\n-\t\t\t\t   stats, false);\n+      cs->caller->call_for_symbol_thunks_and_aliases (gather_caller_stats,\n+\t\t\t\t\t\t    stats, false);\n     else\n       {\n \tstats->count_sum += cs->count;\n@@ -512,7 +512,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n {\n   struct caller_statistics stats;\n \n-  gcc_checking_assert (cgraph_function_with_gimple_body_p (node));\n+  gcc_checking_assert (node->has_gimple_body_p ());\n \n   if (!flag_ipa_cp_clone)\n     {\n@@ -533,7 +533,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n     }\n \n   init_caller_stats (&stats);\n-  cgraph_for_node_and_aliases (node, gather_caller_stats, &stats, false);\n+  node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats, false);\n \n   if (inline_summary (node)->self_size < stats.n_calls)\n     {\n@@ -698,7 +698,7 @@ initialize_node_lattices (struct cgraph_node *node)\n   bool disable = false, variable = false;\n   int i;\n \n-  gcc_checking_assert (cgraph_function_with_gimple_body_p (node));\n+  gcc_checking_assert (node->has_gimple_body_p ());\n   if (!node->local.local)\n     {\n       /* When cloning is allowed, we can assume that externally visible\n@@ -897,7 +897,7 @@ ipcp_verify_propagated_values (void)\n \t    {\n \t      if (dump_file)\n \t\t{\n-\t\t  dump_symtab (dump_file);\n+\t\t  symtab_node::dump_table (dump_file);\n \t\t  fprintf (dump_file, \"\\nIPA lattices after constant \"\n \t\t\t   \"propagation, before gcc_unreachable:\\n\");\n \t\t  print_all_lattices (dump_file, true, false);\n@@ -1435,10 +1435,10 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n   bool ret = false;\n   int i, args_count, parms_count;\n \n-  callee = cgraph_function_node (cs->callee, &availability);\n+  callee = cs->callee->function_symbol (&availability);\n   if (!callee->definition)\n     return false;\n-  gcc_checking_assert (cgraph_function_with_gimple_body_p (callee));\n+  gcc_checking_assert (callee->has_gimple_body_p ());\n   callee_info = IPA_NODE_REF (callee);\n \n   args = IPA_EDGE_REF (cs);\n@@ -1452,7 +1452,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n      of aliases first.  */\n   alias_or_thunk = cs->callee;\n   while (alias_or_thunk->alias)\n-    alias_or_thunk = cgraph_alias_target (alias_or_thunk);\n+    alias_or_thunk = alias_or_thunk->get_alias_target ();\n   if (alias_or_thunk->thunk.thunk_p)\n     {\n       ret |= set_all_contains_variable (ipa_get_parm_lattices (callee_info,\n@@ -1468,7 +1468,7 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n       struct ipcp_param_lattices *dest_plats;\n \n       dest_plats = ipa_get_parm_lattices (callee_info, i);\n-      if (availability == AVAIL_OVERWRITABLE)\n+      if (availability == AVAIL_INTERPOSABLE)\n \tret |= set_all_contains_variable (dest_plats);\n       else\n \t{\n@@ -1599,7 +1599,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \t      if ((TREE_CODE (TREE_TYPE (target)) == FUNCTION_TYPE\n \t\t   && DECL_FUNCTION_CODE (target) == BUILT_IN_UNREACHABLE)\n \t\t  || !possible_polymorphic_call_target_p\n-\t\t       (ie, cgraph_get_node (target)))\n+\t\t       (ie, cgraph_node::get (target)))\n \t\ttarget = ipa_impossible_devirt_target (ie, target);\n \t      return target;\n \t    }\n@@ -1647,7 +1647,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n     }\n \n   if (target && !possible_polymorphic_call_target_p (ie,\n-\t\t\t\t\t\t     cgraph_get_node (target)))\n+\t\t\t\t\t\t     cgraph_node::get (target)))\n     target = ipa_impossible_devirt_target (ie, target);\n \n   return target;\n@@ -1694,10 +1694,10 @@ devirtualization_time_bonus (struct cgraph_node *node,\n \n       /* Only bare minimum benefit for clearly un-inlineable targets.  */\n       res += 1;\n-      callee = cgraph_get_node (target);\n+      callee = cgraph_node::get (target);\n       if (!callee || !callee->definition)\n \tcontinue;\n-      callee = cgraph_function_node (callee, &avail);\n+      callee = callee->function_symbol (&avail);\n       if (avail < AVAIL_AVAILABLE)\n \tcontinue;\n       isummary = inline_summary (callee);\n@@ -1931,7 +1931,8 @@ estimate_local_effects (struct cgraph_node *node)\n       int time, size;\n \n       init_caller_stats (&stats);\n-      cgraph_for_node_and_aliases (node, gather_caller_stats, &stats, false);\n+      node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n+\t\t\t\t\t      false);\n       estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n \t\t\t\t\t known_aggs_ptrs, &size, &time, &hints);\n       time -= devirtualization_time_bonus (node, known_csts, known_binfos,\n@@ -1945,7 +1946,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t \"time_benefit: %i\\n\", size, base_time - time);\n \n       if (size <= 0\n-\t  || cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+\t  || node->will_be_removed_from_program_if_no_direct_calls_p ())\n \t{\n \t  info->do_clone_for_all_contexts = true;\n \t  base_time = time;\n@@ -2207,12 +2208,12 @@ propagate_constants_topo (struct topo_info *topo)\n     {\n       unsigned j;\n       struct cgraph_node *v, *node = topo->order[i];\n-      vec<cgraph_node_ptr> cycle_nodes = ipa_get_nodes_in_cycle (node);\n+      vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (node);\n \n       /* First, iteratively propagate within the strongly connected component\n \t until all lattices stabilize.  */\n       FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n-\tif (cgraph_function_with_gimple_body_p (v))\n+\tif (v->has_gimple_body_p ())\n \t  push_node_to_stack (topo, v);\n \n       v = pop_node_from_stack (topo);\n@@ -2231,7 +2232,7 @@ propagate_constants_topo (struct topo_info *topo)\n \t the local effects of the discovered constants and all valid values to\n \t their topological sort.  */\n       FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n-\tif (cgraph_function_with_gimple_body_p (v))\n+\tif (v->has_gimple_body_p ())\n \t  {\n \t    struct cgraph_edge *cs;\n \n@@ -2314,7 +2315,7 @@ ipcp_propagate_stage (struct topo_info *topo)\n     struct ipa_node_params *info = IPA_NODE_REF (node);\n \n     determine_versionability (node);\n-    if (cgraph_function_with_gimple_body_p (node))\n+    if (node->has_gimple_body_p ())\n       {\n \tinfo->lattices = XCNEWVEC (struct ipcp_param_lattices,\n \t\t\t\t   ipa_get_param_count (info));\n@@ -2407,8 +2408,8 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n /* Vector of pointers which for linked lists of clones of an original crgaph\n    edge. */\n \n-static vec<cgraph_edge_p> next_edge_clone;\n-static vec<cgraph_edge_p> prev_edge_clone;\n+static vec<cgraph_edge *> next_edge_clone;\n+static vec<cgraph_edge *> prev_edge_clone;\n \n static inline void\n grow_edge_clone_vectors (void)\n@@ -2481,7 +2482,7 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n \t\t\t    struct ipcp_value_source *src)\n {\n   struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-  cgraph_node *real_dest = cgraph_function_node (cs->callee);\n+  cgraph_node *real_dest = cs->callee->function_symbol ();\n   struct ipa_node_params *dst_info = IPA_NODE_REF (real_dest);\n \n   if ((dst_info->ipcp_orig_node && !dst_info->is_all_contexts_clone)\n@@ -2569,11 +2570,11 @@ get_info_about_necessary_edges (struct ipcp_value *val, int *freq_sum,\n /* Return a vector of incoming edges that do bring value VAL.  It is assumed\n    their number is known and equal to CALLER_COUNT.  */\n \n-static vec<cgraph_edge_p> \n+static vec<cgraph_edge *>\n gather_edges_for_value (struct ipcp_value *val, int caller_count)\n {\n   struct ipcp_value_source *src;\n-  vec<cgraph_edge_p> ret;\n+  vec<cgraph_edge *> ret;\n \n   ret.create (caller_count);\n   for (src = val->sources; src; src = src->next)\n@@ -2657,10 +2658,12 @@ update_profiling_info (struct cgraph_node *orig_node,\n     return;\n \n   init_caller_stats (&stats);\n-  cgraph_for_node_and_aliases (orig_node, gather_caller_stats, &stats, false);\n+  orig_node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n+\t\t\t\t\t       false);\n   orig_sum = stats.count_sum;\n   init_caller_stats (&stats);\n-  cgraph_for_node_and_aliases (new_node, gather_caller_stats, &stats, false);\n+  new_node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n+\t\t\t\t\t      false);\n   new_sum = stats.count_sum;\n \n   if (orig_node_count < orig_sum + new_sum)\n@@ -2755,10 +2758,10 @@ static struct cgraph_node *\n create_specialized_node (struct cgraph_node *node,\n \t\t\t vec<tree> known_vals,\n \t\t\t struct ipa_agg_replacement_value *aggvals,\n-\t\t\t vec<cgraph_edge_p> callers)\n+\t\t\t vec<cgraph_edge *> callers)\n {\n   struct ipa_node_params *new_info, *info = IPA_NODE_REF (node);\n-  vec<ipa_replace_map_p, va_gc> *replace_trees = NULL;\n+  vec<ipa_replace_map *, va_gc> *replace_trees = NULL;\n   struct ipa_agg_replacement_value *av;\n   struct cgraph_node *new_node;\n   int i, count = ipa_get_param_count (info);\n@@ -2798,8 +2801,8 @@ create_specialized_node (struct cgraph_node *node,\n \t}\n     }\n \n-  new_node = cgraph_create_virtual_clone (node, callers, replace_trees,\n-\t\t\t\t\t  args_to_skip, \"constprop\");\n+  new_node = node->create_virtual_clone (callers, replace_trees,\n+\t\t\t\t\t args_to_skip, \"constprop\");\n   ipa_set_node_agg_value_chain (new_node, aggvals);\n   for (av = aggvals; av; av = av->next)\n     new_node->maybe_add_reference (av->value, IPA_REF_ADDR, NULL);\n@@ -2830,7 +2833,7 @@ create_specialized_node (struct cgraph_node *node,\n static void\n find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t\t\t\t\t    vec<tree> known_vals,\n-\t\t\t\t\t    vec<cgraph_edge_p> callers)\n+\t\t\t\t\t    vec<cgraph_edge *> callers)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n@@ -3139,7 +3142,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \n static struct ipa_agg_replacement_value *\n find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n-\t\t\t\t\t  vec<cgraph_edge_p> callers)\n+\t\t\t\t\t  vec<cgraph_edge *> callers)\n {\n   struct ipa_node_params *dest_info = IPA_NODE_REF (node);\n   struct ipa_agg_replacement_value *res = NULL;\n@@ -3346,10 +3349,9 @@ perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n       while (cs)\n \t{\n \t  enum availability availability;\n-\t  struct cgraph_node *dst = cgraph_function_node (cs->callee,\n-\t\t\t\t\t\t\t  &availability);\n+\t  struct cgraph_node *dst = cs->callee->function_symbol (&availability);\n \t  if ((dst == node || IPA_NODE_REF (dst)->is_all_contexts_clone)\n-\t      && availability > AVAIL_OVERWRITABLE\n+\t      && availability > AVAIL_INTERPOSABLE\n \t      && cgraph_edge_brings_value_p (cs, src))\n \t    {\n \t      if (cgraph_edge_brings_all_scalars_for_node (cs, val->spec_node)\n@@ -3422,7 +3424,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n   struct ipa_agg_replacement_value *aggvals;\n   int freq_sum, caller_count;\n   gcov_type count_sum;\n-  vec<cgraph_edge_p> callers;\n+  vec<cgraph_edge *> callers;\n   vec<tree> kv;\n \n   if (val->spec_node)\n@@ -3542,14 +3544,14 @@ decide_whether_version_node (struct cgraph_node *node)\n   if (info->do_clone_for_all_contexts)\n     {\n       struct cgraph_node *clone;\n-      vec<cgraph_edge_p> callers;\n+      vec<cgraph_edge *> callers;\n \n       if (dump_file)\n \tfprintf (dump_file, \" - Creating a specialized node of %s/%i \"\n \t\t \"for all known contexts.\\n\", node->name (),\n \t\t node->order);\n \n-      callers = collect_callers_of_node (node);\n+      callers = node->collect_callers ();\n       move_binfos_to_values (known_csts, known_binfos);\n       clone = create_specialized_node (node, known_csts,\n \t\t\t       known_aggs_to_agg_replacement_list (known_aggs),\n@@ -3582,7 +3584,7 @@ spread_undeadness (struct cgraph_node *node)\n \tstruct cgraph_node *callee;\n \tstruct ipa_node_params *info;\n \n-\tcallee = cgraph_function_node (cs->callee, NULL);\n+\tcallee = cs->callee->function_symbol (NULL);\n \tinfo = IPA_NODE_REF (callee);\n \n \tif (info->node_dead)\n@@ -3604,9 +3606,8 @@ has_undead_caller_from_outside_scc_p (struct cgraph_node *node,\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (cs->caller->thunk.thunk_p\n-\t&& cgraph_for_node_and_aliases (cs->caller,\n-\t\t\t\t\thas_undead_caller_from_outside_scc_p,\n-\t\t\t\t\tNULL, true))\n+\t&& cs->caller->call_for_symbol_thunks_and_aliases\n+\t  (has_undead_caller_from_outside_scc_p, NULL, true))\n       return true;\n     else if (!ipa_edge_within_scc (cs)\n \t     && !IPA_NODE_REF (cs->caller)->node_dead)\n@@ -3623,10 +3624,9 @@ identify_dead_nodes (struct cgraph_node *node)\n {\n   struct cgraph_node *v;\n   for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n-    if (cgraph_will_be_removed_from_program_if_no_direct_calls (v)\n-\t&& !cgraph_for_node_and_aliases (v,\n-\t\t\t\t\t has_undead_caller_from_outside_scc_p,\n-\t\t\t\t\t NULL, true))\n+    if (v->will_be_removed_from_program_if_no_direct_calls_p ()\n+\t&& !v->call_for_symbol_thunks_and_aliases\n+\t     (has_undead_caller_from_outside_scc_p, NULL, true))\n       IPA_NODE_REF (v)->node_dead = 1;\n \n   for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n@@ -3663,7 +3663,7 @@ ipcp_decision_stage (struct topo_info *topo)\n \t  struct cgraph_node *v;\n \t  iterate = false;\n \t  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n-\t    if (cgraph_function_with_gimple_body_p (v)\n+\t    if (v->has_gimple_body_p ()\n \t\t&& ipcp_versionable_function_p (v))\n \t      iterate |= decide_whether_version_node (v);\n "}, {"sha": "1bfcfa11ed082a24747c66f4c1a608726b172131", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1269,7 +1269,7 @@ build_type_inheritance_graph (void)\n   FOR_EACH_SYMBOL (n)\n     if (is_a <cgraph_node *> (n)\n \t&& DECL_VIRTUAL_P (n->decl)\n-\t&& symtab_real_symbol_p (n))\n+\t&& n->real_symbol_p ())\n       get_odr_type (TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (n->decl))),\n \t\t    true);\n \n@@ -1336,7 +1336,7 @@ referenced_from_vtable_p (struct cgraph_node *node)\n   for (i = 0; node->iterate_referring (i, ref); i++)\n \t\n     if ((ref->use == IPA_REF_ALIAS\n-\t && referenced_from_vtable_p (cgraph (ref->referring)))\n+\t && referenced_from_vtable_p (dyn_cast<cgraph_node *> (ref->referring)))\n \t|| (ref->use == IPA_REF_ADDR\n \t    && TREE_CODE (ref->referring->decl) == VAR_DECL\n \t    && DECL_VIRTUAL_P (ref->referring->decl)))\n@@ -1382,16 +1382,16 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n   if (!target)\n     return;\n \n-  target_node = cgraph_get_node (target);\n+  target_node = cgraph_node::get (target);\n \n   /* Preffer alias target over aliases, so we do not get confused by\n      fake duplicates.  */\n   if (target_node)\n     {\n-      alias_target = cgraph_function_or_thunk_node (target_node, &avail);\n+      alias_target = target_node->ultimate_alias_target (&avail);\n       if (target_node != alias_target\n \t  && avail >= AVAIL_AVAILABLE\n-\t  && cgraph_function_body_availability (target_node))\n+\t  && target_node->get_availability ())\n \ttarget_node = alias_target;\n     }\n \n@@ -1417,10 +1417,10 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \t   && (TREE_PUBLIC (target)\n \t       || DECL_EXTERNAL (target)\n \t       || target_node->definition)\n-\t   && symtab_real_symbol_p (target_node))\n+\t   && target_node->real_symbol_p ())\n     {\n       gcc_assert (!target_node->global.inlined_to);\n-      gcc_assert (symtab_real_symbol_p (target_node));\n+      gcc_assert (target_node->real_symbol_p ());\n       if (!pointer_set_insert (inserted, target_node->decl))\n \t{\n \t  pointer_set_insert (cached_polymorphic_call_targets,\n@@ -2672,7 +2672,7 @@ possible_polymorphic_call_target_p (tree otr_type,\n     return true;\n   targets = possible_polymorphic_call_targets (otr_type, otr_token, ctx, &final);\n   for (i = 0; i < targets.length (); i++)\n-    if (symtab_semantically_equivalent_p (n, targets[i]))\n+    if (n->semantically_equivalent_p (targets[i]))\n       return true;\n \n   /* At a moment we allow middle end to dig out new external declarations\n@@ -2700,7 +2700,7 @@ update_type_inheritance_graph (void)\n   FOR_EACH_FUNCTION (n)\n     if (DECL_VIRTUAL_P (n->decl)\n \t&& !n->definition\n-\t&& symtab_real_symbol_p (n))\n+\t&& n->real_symbol_p ())\n       get_odr_type (method_class_type (TYPE_MAIN_VARIANT (TREE_TYPE (n->decl))),\n \t\t\t\t       true);\n   timevar_pop (TV_IPA_INHERITANCE);\n@@ -2827,8 +2827,8 @@ ipa_devirt (void)\n \t\tstruct cgraph_edge *e2;\n \t\tstruct ipa_ref *ref;\n \t\tcgraph_speculative_call_info (e, e2, e, ref);\n-\t\tif (cgraph_function_or_thunk_node (e2->callee, NULL)\n-\t\t    == cgraph_function_or_thunk_node (likely_target, NULL))\n+\t\tif (e2->callee->ultimate_alias_target ()\n+\t\t    == likely_target->ultimate_alias_target ())\n \t\t  {\n \t\t    fprintf (dump_file, \"We agree with speculation\\n\\n\");\n \t\t    nok++;\n@@ -2860,7 +2860,7 @@ ipa_devirt (void)\n \t      }\n \t    /* Don't use an implicitly-declared destructor (c++/58678).  */\n \t    struct cgraph_node *non_thunk_target\n-\t      = cgraph_function_node (likely_target);\n+\t      = likely_target->function_symbol ();\n \t    if (DECL_ARTIFICIAL (non_thunk_target->decl)\n \t\t&& DECL_COMDAT (non_thunk_target->decl))\n \t      {\n@@ -2869,9 +2869,8 @@ ipa_devirt (void)\n \t\tnartificial++;\n \t\tcontinue;\n \t      }\n-\t    if (cgraph_function_body_availability (likely_target)\n-\t\t<= AVAIL_OVERWRITABLE\n-\t\t&& symtab_can_be_discarded (likely_target))\n+\t    if (likely_target->get_availability () <= AVAIL_INTERPOSABLE\n+\t\t&& likely_target->can_be_discarded_p ())\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Target is overwritable\\n\\n\");\n@@ -2889,11 +2888,10 @@ ipa_devirt (void)\n                                      likely_target->name (),\n                                      likely_target->order);\n                   }\n-\t\tif (!symtab_can_be_discarded (likely_target))\n+\t\tif (!likely_target->can_be_discarded_p ())\n \t\t  {\n \t\t    cgraph_node *alias;\n-\t\t    alias = cgraph (symtab_nonoverwritable_alias\n-\t\t\t\t     (likely_target));\n+\t\t    alias = dyn_cast<cgraph_node *> (likely_target->noninterposable_alias ());\n \t\t    if (alias)\n \t\t      likely_target = alias;\n \t\t  }"}, {"sha": "0df3beacbf2a8c0c625d0cb8d9f37613af9c841e", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -759,11 +759,11 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n       struct cgraph_node *callee = !e->inline_failed ? e->callee : NULL;\n \n       cgraph_redirect_edge_callee (e,\n-\t\t\t\t   cgraph_get_create_node\n+\t\t\t\t   cgraph_node::get_create\n \t\t\t\t     (builtin_decl_implicit (BUILT_IN_UNREACHABLE)));\n       e->inline_failed = CIF_UNREACHABLE;\n       if (callee)\n-\tcgraph_remove_node_and_inline_clones (callee, NULL);\n+\tcallee->remove_symbol_and_inline_clones ();\n     }\n   if (predicate && !true_predicate_p (predicate))\n     {\n@@ -884,8 +884,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      vec<tree> *known_binfos_ptr,\n \t\t\t      vec<ipa_agg_jump_function_p> *known_aggs_ptr)\n {\n-  struct cgraph_node *callee =\n-    cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   struct inline_summary *info = inline_summary (callee);\n   vec<tree> known_vals = vNULL;\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n@@ -1320,8 +1319,7 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (edge);\n-      struct cgraph_node *callee =\n-\tcgraph_function_or_thunk_node (edge->callee, NULL);\n+      struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n       int i;\n \n       fprintf (f,\n@@ -2598,7 +2596,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  if (is_gimple_call (stmt)\n \t      && !gimple_call_internal_p (stmt))\n \t    {\n-\t      struct cgraph_edge *edge = cgraph_edge (node, stmt);\n+\t      struct cgraph_edge *edge = node->get_edge (stmt);\n \t      struct inline_edge_summary *es = inline_edge_summary (edge);\n \n \t      /* Special case: results of BUILT_IN_CONSTANT_P will be always\n@@ -2890,7 +2888,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   estimate_function_body_sizes (node, early);\n \n   for (e = node->callees; e; e = e->next_callee)\n-    if (symtab_comdat_local_p (e->callee))\n+    if (e->callee->comdat_local_p ())\n       break;\n   node->calls_comdat_local = (e != NULL);\n \n@@ -2914,7 +2912,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n static unsigned int\n compute_inline_parameters_for_current (void)\n {\n-  compute_inline_parameters (cgraph_get_node (current_function_decl), true);\n+  compute_inline_parameters (cgraph_node::get (current_function_decl), true);\n   return 0;\n }\n \n@@ -2989,10 +2987,10 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n   gcc_checking_assert (*time >= 0);\n   gcc_checking_assert (*size >= 0);\n \n-  callee = cgraph_get_node (target);\n+  callee = cgraph_node::get (target);\n   if (!callee || !callee->definition)\n     return false;\n-  callee = cgraph_function_node (callee, &avail);\n+  callee = callee->function_symbol (&avail);\n   if (avail < AVAIL_AVAILABLE)\n     return false;\n   isummary = inline_summary (callee);\n@@ -3666,7 +3664,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n   int min_size;\n \n-  callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+  callee = edge->callee->ultimate_alias_target ();\n \n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n@@ -3730,7 +3728,7 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n       return size - (size > 0);\n     }\n \n-  callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+  callee = edge->callee->ultimate_alias_target ();\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n@@ -3769,7 +3767,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n       return hints - 1;\n     }\n \n-  callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+  callee = edge->callee->ultimate_alias_target ();\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n@@ -3863,7 +3861,7 @@ do_estimate_growth (struct cgraph_node *node)\n   struct growth_data d = { node, 0, false };\n   struct inline_summary *info = inline_summary (node);\n \n-  cgraph_for_node_and_aliases (node, do_estimate_growth_1, &d, true);\n+  node->call_for_symbol_thunks_and_aliases (do_estimate_growth_1, &d, true);\n \n   /* For self recursive functions the growth estimation really should be\n      infinity.  We don't want to return very large values because the growth\n@@ -3875,13 +3873,13 @@ do_estimate_growth (struct cgraph_node *node)\n     ;\n   else\n     {\n-      if (cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+      if (node->will_be_removed_from_program_if_no_direct_calls_p ())\n \td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units\n          since they come from various template instantiations.\n          Take this into account.  */\n       else if (DECL_COMDAT (node->decl)\n-\t       && cgraph_can_remove_if_no_direct_calls_p (node))\n+\t       && node->can_remove_if_no_direct_calls_p ())\n \td.growth -= (info->size\n \t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n \t\t     + 50) / 100;\n@@ -3923,16 +3921,16 @@ growth_likely_positive (struct cgraph_node *node, int edge_growth ATTRIBUTE_UNUS\n      instead of\n      cgraph_will_be_removed_from_program_if_no_direct_calls  */\n   if (DECL_EXTERNAL (node->decl)\n-      || !cgraph_can_remove_if_no_direct_calls_p (node))\n+      || !node->can_remove_if_no_direct_calls_p ())\n     return true;\n \n   /* If there is cached value, just go ahead.  */\n   if ((int)node_growth_cache.length () > node->uid\n       && (ret = node_growth_cache[node->uid]))\n     return ret > 0;\n-  if (!cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n+  if (!node->will_be_removed_from_program_if_no_direct_calls_p ()\n       && (!DECL_COMDAT (node->decl)\n-\t  || !cgraph_can_remove_if_no_direct_calls_p (node)))\n+\t  || !node->can_remove_if_no_direct_calls_p ()))\n     return true;\n   max_callers = inline_summary (node)->size * 4 / edge_growth + 2;\n \n@@ -4111,7 +4109,8 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n       index = streamer_read_uhwi (&ib);\n       encoder = file_data->symtab_node_encoder;\n-      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n+      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n+\t\t\t\t\t\t\t\tindex));\n       info = inline_summary (node);\n \n       info->estimated_stack_size"}, {"sha": "59241403a877296e4e2755064b016ba7e1f8148c", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -88,7 +88,7 @@ can_remove_node_now_p_1 (struct cgraph_node *node)\n   return (!node->address_taken\n \t  && !node->has_aliases_p ()\n \t  && !node->used_as_abstract_origin\n-\t  && cgraph_can_remove_if_no_direct_calls_p (node)\n+\t  && node->can_remove_if_no_direct_calls_p ()\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n \t     Lacking may edges in callgraph we just preserve them post\n@@ -114,8 +114,8 @@ can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n      items can be removed.  */\n   if (!node->same_comdat_group)\n     return true;\n-  for (next = cgraph (node->same_comdat_group);\n-       next != node; next = cgraph (next->same_comdat_group))\n+  for (next = dyn_cast<cgraph_node *> (node->same_comdat_group);\n+       next != node; next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n     if ((next->callers && next->callers != e)\n \t|| !can_remove_node_now_p_1 (next))\n       return false;\n@@ -165,7 +165,7 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     For now we keep the ohter functions in the group in program until\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n-          symtab_dissolve_same_comdat_group_list (e->callee);\n+\t  e->callee->dissolve_same_comdat_group_list ();\n \t  if (e->callee->definition && !DECL_EXTERNAL (e->callee->decl))\n \t    {\n \t      if (overall_size)\n@@ -182,15 +182,17 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \n \t  if (freq_scale == -1)\n \t    freq_scale = e->frequency;\n-\t  n = cgraph_clone_node (e->callee, e->callee->decl,\n-\t\t\t\t MIN (e->count, e->callee->count), freq_scale,\n-\t\t\t\t update_original, vNULL, true, inlining_into,\n-\t\t\t\t NULL);\n+\t  n = e->callee->create_clone (e->callee->decl,\n+\t\t\t\t       MIN (e->count, e->callee->count),\n+\t\t\t\t       freq_scale,\n+\t\t\t\t       update_original, vNULL, true,\n+\t\t\t\t       inlining_into,\n+\t\t\t\t       NULL);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n     }\n   else\n-    symtab_dissolve_same_comdat_group_list (e->callee);\n+    e->callee->dissolve_same_comdat_group_list ();\n \n   e->callee->global.inlined_to = inlining_into;\n \n@@ -222,14 +224,14 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \n bool\n inline_call (struct cgraph_edge *e, bool update_original,\n-\t     vec<cgraph_edge_p> *new_edges,\n+\t     vec<cgraph_edge *> *new_edges,\n \t     int *overall_size, bool update_overall_summary,\n \t     bool *callee_removed)\n {\n   int old_size = 0, new_size = 0;\n   struct cgraph_node *to = NULL;\n   struct cgraph_edge *curr = e;\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   bool new_edges_found = false;\n \n #ifdef ENABLE_CHECKING\n@@ -261,8 +263,8 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \t  if (!alias->callers\n \t      && can_remove_node_now_p (alias, e))\n \t    {\n-\t      next_alias = cgraph_alias_target (alias);\n-\t      cgraph_remove_node (alias);\n+\t      next_alias = alias->get_alias_target ();\n+\t      alias->remove ();\n \t      if (callee_removed)\n \t\t*callee_removed = true;\n \t      alias = next_alias;\n@@ -286,11 +288,11 @@ inline_call (struct cgraph_edge *e, bool update_original,\n \n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;\n-  else if (to->calls_comdat_local && symtab_comdat_local_p (callee))\n+  else if (to->calls_comdat_local && callee->comdat_local_p ())\n     {\n       struct cgraph_edge *se = to->callees;\n       for (; se; se = se->next_callee)\n-\tif (se->inline_failed && symtab_comdat_local_p (se->callee))\n+\tif (se->inline_failed && se->callee->comdat_local_p ())\n \t  break;\n       if (se == NULL)\n \tto->calls_comdat_local = false;\n@@ -336,13 +338,13 @@ save_inline_function_body (struct cgraph_node *node)\n     fprintf (dump_file, \"\\nSaving body of %s for later reuse\\n\",\n \t     node->name ());\n  \n-  gcc_assert (node == cgraph_get_node (node->decl));\n+  gcc_assert (node == cgraph_node::get (node->decl));\n \n   /* first_clone will be turned into real function.  */\n   first_clone = node->clones;\n   first_clone->decl = copy_node (node->decl);\n   first_clone->decl->decl_with_vis.symtab_node = first_clone;\n-  gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n+  gcc_assert (first_clone == cgraph_node::get (first_clone->decl));\n \n   /* Now reshape the clone tree, so all other clones descends from\n      first_clone.  */\n@@ -404,12 +406,12 @@ save_inline_function_body (struct cgraph_node *node)\n      Remove it now.  */\n   if (!first_clone->callers)\n     {\n-      cgraph_remove_node_and_inline_clones (first_clone, NULL);\n+      first_clone->remove_symbol_and_inline_clones ();\n       first_clone = NULL;\n     }\n #ifdef ENABLE_CHECKING\n   else\n-    verify_cgraph_node (first_clone);\n+    first_clone->verify ();\n #endif\n   return first_clone;\n }"}, {"sha": "5f1c9b04c6a282c440e626a3ecf3d1c563680b1a", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -147,7 +147,7 @@ static bool\n caller_growth_limits (struct cgraph_edge *e)\n {\n   struct cgraph_node *to = e->caller;\n-  struct cgraph_node *what = cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct cgraph_node *what = e->callee->ultimate_alias_target ();\n   int newsize;\n   int limit = 0;\n   HOST_WIDE_INT stack_size_limit = 0, inlined_stack;\n@@ -269,8 +269,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n {\n   bool inlinable = true;\n   enum availability avail;\n-  struct cgraph_node *callee\n-    = cgraph_function_or_thunk_node (e->callee, &avail);\n+  cgraph_node *callee = e->callee->ultimate_alias_target (&avail);\n   tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->decl);\n   tree callee_tree\n     = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->decl) : NULL;\n@@ -302,7 +301,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       inlinable = false;\n     }\n-  else if (avail <= AVAIL_OVERWRITABLE)\n+  else if (avail <= AVAIL_INTERPOSABLE)\n     {\n       e->inline_failed = CIF_OVERWRITABLE;\n       inlinable = false;\n@@ -399,8 +398,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n static bool\n can_early_inline_edge_p (struct cgraph_edge *e)\n {\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee,\n-\t\t\t\t\t\t\t      NULL);\n+  struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   /* Early inliner might get called at WPA stage when IPA pass adds new\n      function.  In this case we can not really do any of early inlining\n      because function bodies are missing.  */\n@@ -447,7 +445,7 @@ static bool\n want_early_inline_function_p (struct cgraph_edge *e)\n {\n   bool want_inline = true;\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n@@ -565,7 +563,7 @@ static bool\n want_inline_small_function_p (struct cgraph_edge *e, bool report)\n {\n   bool want_inline = true;\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+  struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n \n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n@@ -822,22 +820,23 @@ has_caller_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n static bool\n want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)\n {\n-   struct cgraph_node *function = cgraph_function_or_thunk_node (node, NULL);\n+   struct cgraph_node *function = node->ultimate_alias_target ();\n    bool has_hot_call = false;\n \n    /* Does it have callers?  */\n-   if (!cgraph_for_node_and_aliases (node, has_caller_p, NULL, true))\n+   if (!node->call_for_symbol_thunks_and_aliases (has_caller_p, NULL, true))\n      return false;\n    /* Already inlined?  */\n    if (function->global.inlined_to)\n      return false;\n-   if (cgraph_function_or_thunk_node (node, NULL) != node)\n+   if (node->ultimate_alias_target () != node)\n      return false;\n    /* Inlining into all callers would increase size?  */\n    if (estimate_growth (node) > 0)\n      return false;\n    /* All inlines must be possible.  */\n-   if (cgraph_for_node_and_aliases (node, check_callers, &has_hot_call, true))\n+   if (node->call_for_symbol_thunks_and_aliases\n+     (check_callers, &has_hot_call, true))\n      return false;\n    if (!cold && !has_hot_call)\n      return false;\n@@ -895,8 +894,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n   int growth, edge_time;\n-  struct cgraph_node *callee = cgraph_function_or_thunk_node (edge->callee,\n-\t\t\t\t\t\t\t      NULL);\n+  struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n   struct inline_summary *callee_info = inline_summary (callee);\n   inline_hints hints;\n \n@@ -1230,7 +1228,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t   growth chould have just increased and consequentely badness metric\n            don't need updating.  */\n \tif (e->inline_failed\n-\t    && (callee = cgraph_function_or_thunk_node (e->callee, &avail))\n+\t    && (callee = e->callee->ultimate_alias_target (&avail))\n \t    && inline_summary (callee)->inlinable\n \t    && avail >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, callee->uid))\n@@ -1273,8 +1271,8 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n \n   for (e = where->callees; e; e = e->next_callee)\n     if (e->callee == node\n-\t|| (cgraph_function_or_thunk_node (e->callee, &avail) == node\n-\t    && avail > AVAIL_OVERWRITABLE))\n+\t|| (e->callee->ultimate_alias_target (&avail) == node\n+\t    && avail > AVAIL_INTERPOSABLE))\n       {\n \t/* When profile feedback is available, prioritize by expected number\n \t   of calls.  */\n@@ -1295,7 +1293,7 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n \n static bool\n recursive_inlining (struct cgraph_edge *edge,\n-\t\t    vec<cgraph_edge_p> *new_edges)\n+\t\t    vec<cgraph_edge *> *new_edges)\n {\n   int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n   fibheap_t heap;\n@@ -1359,7 +1357,7 @@ recursive_inlining (struct cgraph_edge *edge,\n       for (cnode = curr->caller;\n \t   cnode->global.inlined_to; cnode = cnode->callers->caller)\n \tif (node->decl\n-\t    == cgraph_function_or_thunk_node (curr->callee, NULL)->decl)\n+\t    == curr->callee->ultimate_alias_target ()->decl)\n           depth++;\n \n       if (!want_inline_self_recursive_call_p (curr, node, false, depth))\n@@ -1383,9 +1381,9 @@ recursive_inlining (struct cgraph_edge *edge,\n       if (!master_clone)\n \t{\n \t  /* We need original clone to copy around.  */\n-\t  master_clone = cgraph_clone_node (node, node->decl,\n-\t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n-\t\t\t\t\t    false, vNULL, true, NULL, NULL);\n+\t  master_clone = node->create_clone (node->decl, node->count,\n+\t    CGRAPH_FREQ_BASE, false, vNULL,\n+\t    true, NULL, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n \t      clone_inlined_nodes (e, true, false, NULL, CGRAPH_FREQ_BASE);\n@@ -1420,9 +1418,9 @@ recursive_inlining (struct cgraph_edge *edge,\n     {\n       next = cgraph_next_function (node);\n       if (node->global.inlined_to == master_clone)\n-\tcgraph_remove_node (node);\n+\tnode->remove ();\n     }\n-  cgraph_remove_node (master_clone);\n+  master_clone->remove ();\n   return true;\n }\n \n@@ -1445,7 +1443,7 @@ compute_max_insns (int insns)\n /* Compute badness of all edges in NEW_EDGES and add them to the HEAP.  */\n \n static void\n-add_new_edges_to_heap (fibheap_t heap, vec<cgraph_edge_p> new_edges)\n+add_new_edges_to_heap (fibheap_t heap, vec<cgraph_edge *> new_edges)\n {\n   while (new_edges.length () > 0)\n     {\n@@ -1481,7 +1479,7 @@ bool\n speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n {\n   enum availability avail;\n-  struct cgraph_node *target = cgraph_function_or_thunk_node (e->callee, &avail);\n+  struct cgraph_node *target = e->callee->ultimate_alias_target (&avail);\n   struct cgraph_edge *direct, *indirect;\n   struct ipa_ref *ref;\n \n@@ -1561,7 +1559,7 @@ inline_small_functions (void)\n   fibheap_t edge_heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_size, max_size;\n-  auto_vec<cgraph_edge_p> new_indirect_edges;\n+  auto_vec<cgraph_edge *> new_indirect_edges;\n   int initial_size = 0;\n   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   struct cgraph_edge_hook_list *edge_removal_hook_holder;\n@@ -1582,7 +1580,7 @@ inline_small_functions (void)\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to)\n       {\n-\tif (cgraph_function_with_gimple_body_p (node)\n+\tif (node->has_gimple_body_p ()\n \t    || node->thunk.thunk_p)\n \t  {\n \t    struct inline_summary *info = inline_summary (node);\n@@ -1714,7 +1712,7 @@ inline_small_functions (void)\n \t  continue;\n \t}\n       \n-      callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+      callee = edge->callee->ultimate_alias_target ();\n       growth = estimate_edge_growth (edge);\n       if (dump_file)\n \t{\n@@ -1880,7 +1878,7 @@ flatten_function (struct cgraph_node *node, bool early)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *orig_callee;\n-      struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+      struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n \n       /* We've hit cycle?  It is time to give up.  */\n       if (callee->aux)\n@@ -2242,10 +2240,10 @@ ipa_inline (void)\n \t      && want_inline_function_to_all_callers_p (node, cold))\n \t    {\n \t      int num_calls = 0;\n-\t      cgraph_for_node_and_aliases (node, sum_callers,\n-\t\t\t\t\t   &num_calls, true);\n-\t      while (cgraph_for_node_and_aliases (node, inline_to_all_callers,\n-\t\t\t\t\t          &num_calls, true))\n+\t      node->call_for_symbol_thunks_and_aliases (sum_callers, &num_calls,\n+\t\t\t\t\t\t      true);\n+\t      while (node->call_for_symbol_thunks_and_aliases (inline_to_all_callers,\n+\t\t\t\t\t\t\t     &num_calls, true))\n \t\t;\n \t      remove_functions = true;\n \t    }\n@@ -2282,7 +2280,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+      struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n       if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \tcontinue;\n \n@@ -2330,7 +2328,7 @@ early_inline_small_functions (struct cgraph_node *node)\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n+      struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n       if (!inline_summary (callee)->inlinable\n \t  || !e->inline_failed)\n \tcontinue;\n@@ -2403,7 +2401,7 @@ class pass_early_inline : public gimple_opt_pass\n unsigned int\n pass_early_inline::execute (function *fun)\n {\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   struct cgraph_edge *edge;\n   unsigned int todo = 0;\n   int iterations = 0;\n@@ -2422,7 +2420,7 @@ pass_early_inline::execute (function *fun)\n     return 0;\n \n #ifdef ENABLE_CHECKING\n-  verify_cgraph_node (node);\n+  node->verify ();\n #endif\n   node->remove_all_references ();\n "}, {"sha": "8cbb39fd6332d727ee8ff40fb1d01d6a308d25fe", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -237,7 +237,7 @@ void compute_inline_parameters (struct cgraph_node *, bool);\n bool speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining);\n \n /* In ipa-inline-transform.c  */\n-bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge_p> *, int *, bool,\n+bool inline_call (struct cgraph_edge *, bool, vec<cgraph_edge *> *, int *, bool,\n \t\t  bool *callee_removed = NULL);\n unsigned int inline_transform (struct cgraph_node *);\n void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *,"}, {"sha": "b059696a1c8b5bfacea64025a0e7291b935ea598", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -208,7 +208,7 @@ ipa_profile_generate_summary (void)\n \t\t       counter 2 is total number of executions.  */\n \t\t    if (h->hvalue.counters[2])\n \t\t      {\n-\t\t\tstruct cgraph_edge * e = cgraph_edge (node, stmt);\n+\t\t\tstruct cgraph_edge * e = node->get_edge (stmt);\n \t\t\tif (e && !e->indirect_unknown_callee)\n \t\t\t  continue;\n \t\t\te->indirect_info->common_target_id\n@@ -408,7 +408,8 @@ ipa_propagate_frequency (struct cgraph_node *node)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Processing frequency %s\\n\", node->name ());\n \n-  cgraph_for_node_and_aliases (node, ipa_propagate_frequency_1, &d, true);\n+  node->call_for_symbol_thunks_and_aliases (ipa_propagate_frequency_1, &d,\n+\t\t\t\t\t    true);\n \n   if ((d.only_called_at_startup && !d.only_called_at_exit)\n       && !node->only_called_at_startup)\n@@ -609,9 +610,8 @@ ipa_profile (void)\n \t\t\tfprintf (dump_file,\n \t\t\t\t \"Not speculating: call is cold.\\n\");\n \t\t    }\n-\t\t  else if (cgraph_function_body_availability (n2)\n-\t\t\t   <= AVAIL_OVERWRITABLE\n-\t\t\t   && symtab_can_be_discarded (n2))\n+\t\t  else if (n2->get_availability () <= AVAIL_INTERPOSABLE\n+\t\t\t   && n2->can_be_discarded_p ())\n \t\t    {\n \t\t      nuseless++;\n \t\t      if (dump_file)\n@@ -625,11 +625,10 @@ ipa_profile (void)\n \t\t\t control flow goes to this particular implementation\n \t\t\t of N2.  Speculate on the local alias to allow inlining.\n \t\t       */\n-\t\t      if (!symtab_can_be_discarded (n2))\n+\t\t      if (!n2->can_be_discarded_p ())\n \t\t\t{\n \t\t\t  cgraph_node *alias;\n-\t\t\t  alias = cgraph (symtab_nonoverwritable_alias\n-\t\t\t\t\t   (n2));\n+\t\t\t  alias = dyn_cast<cgraph_node *> (n2->noninterposable_alias ());\n \t\t\t  if (alias)\n \t\t\t    n2 = alias;\n \t\t\t}"}, {"sha": "9c65076440b7d8c9462f41262ddca0e28b7380e4", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -89,7 +89,7 @@ struct param_aa_status\n struct ipa_bb_info\n {\n   /* Call graph edges going out of this BB.  */\n-  vec<cgraph_edge_p> cg_edges;\n+  vec<cgraph_edge *> cg_edges;\n   /* Alias analysis statuses of each formal parameter at this bb.  */\n   vec<param_aa_status> param_aa_statuses;\n };\n@@ -1979,7 +1979,7 @@ ipa_compute_jump_functions_for_bb (struct func_body_info *fbi, basic_block bb)\n \n       if (callee)\n \t{\n-\t  cgraph_function_or_thunk_node (callee, NULL);\n+\t  callee->ultimate_alias_target ();\n \t  /* We do not need to bother analyzing calls to unknown functions\n \t     unless they may become known during lto/whopr.  */\n \t  if (!callee->definition && !flag_lto)\n@@ -2062,7 +2062,7 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n {\n   struct cgraph_edge *cs;\n \n-  cs = cgraph_edge (node, stmt);\n+  cs = node->get_edge (stmt);\n   cs->indirect_info->param_index = param_index;\n   cs->indirect_info->agg_contents = 0;\n   cs->indirect_info->member_ptr = 0;\n@@ -2339,7 +2339,7 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n \n   /* If we previously turned the call into a direct call, there is\n      no need to analyze.  */\n-  struct cgraph_edge *cs = cgraph_edge (fbi->node, call);\n+  struct cgraph_edge *cs = fbi->node->get_edge (call);\n   if (cs && !cs->indirect_unknown_callee)\n     return;\n   if (TREE_CODE (target) == SSA_NAME)\n@@ -2574,7 +2574,7 @@ ipa_intraprocedural_devirtualization (gimple call)\n #ifdef ENABLE_CHECKING\n   if (fndecl)\n     gcc_assert (possible_polymorphic_call_target_p\n-\t\t  (otr, cgraph_get_node (fndecl)));\n+\t\t  (otr, cgraph_node::get (fndecl)));\n #endif\n   return fndecl;\n }\n@@ -2798,14 +2798,14 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t    }\n \n \t  target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n-\t  callee = cgraph_get_create_node (target);\n+\t  callee = cgraph_node::get_create (target);\n \t  unreachable = true;\n \t}\n       else\n-\tcallee = cgraph_get_node (target);\n+\tcallee = cgraph_node::get (target);\n     }\n   else\n-    callee = cgraph_get_node (target);\n+    callee = cgraph_node::get (target);\n \n   /* Because may-edges are not explicitely represented and vtable may be external,\n      we may create the first reference to the object in the unit.  */\n@@ -2828,7 +2828,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t\t     ie->callee->order);\n \t  return NULL;\n \t}\n-      callee = cgraph_get_create_node (target);\n+      callee = cgraph_node::get_create (target);\n     }\n \n   if (!dbg_cnt (devirt))\n@@ -2950,7 +2950,7 @@ cgraph_node_for_jfunc (struct ipa_jump_func *jfunc)\n       || TREE_CODE (TREE_OPERAND (cst, 0)) != FUNCTION_DECL)\n     return NULL;\n \n-  return cgraph_get_node (TREE_OPERAND (cst, 0));\n+  return cgraph_node::get (TREE_OPERAND (cst, 0));\n }\n \n \n@@ -3035,7 +3035,7 @@ ipa_impossible_devirt_target (struct cgraph_edge *ie, tree target)\n \t\t ie->caller->name (), ie->caller->order);\n     }\n   tree new_target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n-  cgraph_get_create_node (new_target);\n+  cgraph_node::get_create (new_target);\n   return new_target;\n }\n \n@@ -3072,7 +3072,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t      if ((TREE_CODE (TREE_TYPE (target)) == FUNCTION_TYPE\n \t\t   && DECL_FUNCTION_CODE (target) == BUILT_IN_UNREACHABLE)\n \t\t  || !possible_polymorphic_call_target_p\n-\t\t       (ie, cgraph_get_node (target)))\n+\t\t       (ie, cgraph_node::get (target)))\n \t\ttarget = ipa_impossible_devirt_target (ie, target);\n \t      return ipa_make_edge_direct_to_target (ie, target);\n \t    }\n@@ -3118,7 +3118,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n   if (target)\n     {\n-      if (!possible_polymorphic_call_target_p (ie, cgraph_get_node (target)))\n+      if (!possible_polymorphic_call_target_p (ie, cgraph_node::get (target)))\n \ttarget = ipa_impossible_devirt_target (ie, target);\n       return ipa_make_edge_direct_to_target (ie, target);\n     }\n@@ -3135,7 +3135,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n static bool\n update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      struct cgraph_node *node,\n-\t\t\t\t      vec<cgraph_edge_p> *new_edges)\n+\t\t\t\t      vec<cgraph_edge *> *new_edges)\n {\n   struct ipa_edge_args *top;\n   struct cgraph_edge *ie, *next_ie, *new_direct_edge;\n@@ -3244,7 +3244,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n static bool\n propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n \t\t\t\t   struct cgraph_node *node,\n-\t\t\t\t   vec<cgraph_edge_p> *new_edges)\n+\t\t\t\t   vec<cgraph_edge *> *new_edges)\n {\n   struct cgraph_edge *e;\n   bool res;\n@@ -3312,7 +3312,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \n \t      if (t && TREE_CODE (t) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n-\t\t  && (n = cgraph_get_node (TREE_OPERAND (t, 0)))\n+\t\t  && (n = cgraph_node::get (TREE_OPERAND (t, 0)))\n \t\t  && (ref = new_root->find_reference (n, NULL, 0)))\n \t\t{\n \t\t  if (dump_file)\n@@ -3338,7 +3338,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t      gcc_checking_assert (TREE_CODE (cst) == ADDR_EXPR\n \t\t\t\t   && TREE_CODE (TREE_OPERAND (cst, 0))\n \t\t\t\t   == FUNCTION_DECL);\n-\t      n = cgraph_get_node (TREE_OPERAND (cst, 0));\n+\t      n = cgraph_node::get (TREE_OPERAND (cst, 0));\n \t      if (n)\n \t\t{\n \t\t  struct cgraph_node *clone;\n@@ -3399,7 +3399,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \n bool\n ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n-\t\t\t\t   vec<cgraph_edge_p> *new_edges)\n+\t\t\t\t   vec<cgraph_edge *> *new_edges)\n {\n   bool changed;\n   /* Do nothing if the preparation phase has not been carried out yet\n@@ -3653,7 +3653,7 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n static void\n ipa_add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  if (cgraph_function_with_gimple_body_p (node))\n+  if (node->has_gimple_body_p ())\n     ipa_analyze_node (node);\n }\n \n@@ -3990,7 +3990,7 @@ void\n ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t\t\t   ipa_parm_adjustment_vec adjustments)\n {\n-  struct cgraph_node *current_node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *current_node = cgraph_node::get (current_function_decl);\n   vec<tree> vargs;\n   vec<tree, va_gc> **debug_args = NULL;\n   gimple new_stmt;\n@@ -4224,7 +4224,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n     cgraph_set_call_stmt (cs, new_stmt);\n   do\n     {\n-      ipa_record_stmt_references (current_node, gsi_stmt (gsi));\n+      current_node->record_stmt_references (gsi_stmt (gsi));\n       gsi_prev (&gsi);\n     }\n   while (gsi_stmt (gsi) != gsi_stmt (prev_gsi));\n@@ -4854,7 +4854,7 @@ ipa_prop_write_jump_functions (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (cgraph_function_with_gimple_body_p (node)\n+      if (node->has_gimple_body_p ()\n \t  && IPA_NODE_REF (node) != NULL)\n \tcount++;\n     }\n@@ -4866,7 +4866,7 @@ ipa_prop_write_jump_functions (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (cgraph_function_with_gimple_body_p (node)\n+      if (node->has_gimple_body_p ()\n \t  && IPA_NODE_REF (node) != NULL)\n         ipa_write_node_info (ob, node);\n     }\n@@ -4907,7 +4907,8 @@ ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n       index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->symtab_node_encoder;\n-      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n+      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n+\t\t\t\t\t\t\t\tindex));\n       gcc_assert (node->definition);\n       ipa_read_node_info (&ib_main, node, data_in);\n     }\n@@ -5030,7 +5031,7 @@ ipa_prop_write_all_agg_replacement (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (cgraph_function_with_gimple_body_p (node)\n+      if (node->has_gimple_body_p ()\n \t  && ipa_get_agg_replacements_for_node (node) != NULL)\n \tcount++;\n     }\n@@ -5041,7 +5042,7 @@ ipa_prop_write_all_agg_replacement (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (cgraph_function_with_gimple_body_p (node)\n+      if (node->has_gimple_body_p ()\n \t  && ipa_get_agg_replacements_for_node (node) != NULL)\n \twrite_agg_replacement_chain (ob, node);\n     }\n@@ -5083,7 +5084,8 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n \n       index = streamer_read_uhwi (&ib_main);\n       encoder = file_data->symtab_node_encoder;\n-      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n+      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n+\t\t\t\t\t\t\t\tindex));\n       gcc_assert (node->definition);\n       read_agg_replacement_chain (&ib_main, node, data_in);\n     }"}, {"sha": "3717394eb46126c6a0cc61478afba8e28ca0c7fc", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -576,7 +576,7 @@ ipa_get_agg_replacements_for_node (struct cgraph_node *node)\n /* Function formal parameters related computations.  */\n void ipa_initialize_node_params (struct cgraph_node *node);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n-\t\t\t\t\tvec<cgraph_edge_p> *new_edges);\n+\t\t\t\t\tvec<cgraph_edge *> *new_edges);\n \n /* Indirect edge and binfo processing.  */\n tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,"}, {"sha": "2c281be0acb2ba50805f77e02a95aa1e92a1349d", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -737,7 +737,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   l->can_throw = false;\n   state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n \t\t    flags_from_decl_or_type (fn->decl),\n-\t\t    cgraph_node_cannot_return (fn));\n+\t\t    fn->cannot_return_p ());\n \n   if (fn->thunk.thunk_p || fn->alias)\n     {\n@@ -840,14 +840,14 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n static void\n add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n- if (cgraph_function_body_availability (node) < AVAIL_OVERWRITABLE)\n+ if (node->get_availability () < AVAIL_INTERPOSABLE)\n    return;\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n      operations.  */\n   visited_nodes = pointer_set_create ();\n-  if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n+  if (node->get_availability () > AVAIL_INTERPOSABLE)\n     set_function_state (node, analyze_function (node, true));\n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n@@ -920,12 +920,12 @@ pure_const_generate_summary (void)\n \n   /* Process all of the functions.\n \n-     We process AVAIL_OVERWRITABLE functions.  We can not use the results\n+     We process AVAIL_INTERPOSABLE functions.  We can not use the results\n      by default, but the info can be used at LTO with -fwhole-program or\n      when function got cloned and the clone is AVAILABLE.  */\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+    if (node->get_availability () >= AVAIL_INTERPOSABLE)\n       set_function_state (node, analyze_function (node, true));\n \n   pointer_set_destroy (visited_nodes);\n@@ -1025,7 +1025,8 @@ pure_const_read_summary (void)\n \t      fs = XCNEW (struct funct_state_d);\n \t      index = streamer_read_uhwi (ib);\n \t      encoder = file_data->symtab_node_encoder;\n-\t      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n+\t      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n+\t\t\t\t\t\t\t\t\tindex));\n \t      set_function_state (node, fs);\n \n \t      /* Note that the flags must be read in the opposite\n@@ -1088,7 +1089,7 @@ self_recursive_p (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n-    if (cgraph_function_node (e->callee, NULL) == node)\n+    if (e->callee->function_symbol () == node)\n       return true;\n   return false;\n }\n@@ -1110,7 +1111,7 @@ propagate_pure_const (void)\n   order_pos = ipa_reduced_postorder (order, true, false, NULL);\n   if (dump_file)\n     {\n-      dump_cgraph (dump_file);\n+      cgraph_node::dump_cgraph (dump_file);\n       ipa_print_order (dump_file, \"reduced\", order, order_pos);\n     }\n \n@@ -1155,7 +1156,7 @@ propagate_pure_const (void)\n \t    break;\n \n \t  /* For overwritable nodes we can not assume anything.  */\n-\t  if (cgraph_function_body_availability (w) == AVAIL_OVERWRITABLE)\n+\t  if (w->get_availability () == AVAIL_INTERPOSABLE)\n \t    {\n \t      worse_state (&pure_const_state, &looping,\n \t\t\t   w_l->state_previously_known,\n@@ -1182,7 +1183,7 @@ propagate_pure_const (void)\n \t  for (e = w->callees; e; e = e->next_callee)\n \t    {\n \t      enum availability avail;\n-\t      struct cgraph_node *y = cgraph_function_node (e->callee, &avail);\n+\t      struct cgraph_node *y = e->callee->function_symbol (&avail);\n \t      enum pure_const_state_e edge_state = IPA_CONST;\n \t      bool edge_looping = false;\n \n@@ -1193,7 +1194,7 @@ propagate_pure_const (void)\n \t\t\t   e->callee->name (),\n \t\t\t   e->callee->order);\n \t\t}\n-\t      if (avail > AVAIL_OVERWRITABLE)\n+\t      if (avail > AVAIL_INTERPOSABLE)\n \t\t{\n \t\t  funct_state y_l = get_function_state (y);\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1344,7 +1345,7 @@ propagate_pure_const (void)\n \t\t\t       this_looping ? \"looping \" : \"\",\n \t\t\t       w->name ());\n \t\t  }\n-\t\tcgraph_set_const_flag (w, true, this_looping);\n+\t\tw->set_const_flag (true, this_looping);\n \t\tbreak;\n \n \t      case IPA_PURE:\n@@ -1356,7 +1357,7 @@ propagate_pure_const (void)\n \t\t\t       this_looping ? \"looping \" : \"\",\n \t\t\t       w->name ());\n \t\t  }\n-\t\tcgraph_set_pure_flag (w, true, this_looping);\n+\t\tw->set_pure_flag (true, this_looping);\n \t\tbreak;\n \n \t      default:\n@@ -1388,7 +1389,7 @@ propagate_nothrow (void)\n   order_pos = ipa_reduced_postorder (order, true, false, ignore_edge);\n   if (dump_file)\n     {\n-      dump_cgraph (dump_file);\n+      cgraph_node::dump_cgraph (dump_file);\n       ipa_print_order (dump_file, \"reduced for nothrow\", order, order_pos);\n     }\n \n@@ -1412,7 +1413,7 @@ propagate_nothrow (void)\n \t  funct_state w_l = get_function_state (w);\n \n \t  if (w_l->can_throw\n-\t      || cgraph_function_body_availability (w) == AVAIL_OVERWRITABLE)\n+\t      || w->get_availability () == AVAIL_INTERPOSABLE)\n \t    can_throw = true;\n \n \t  if (can_throw)\n@@ -1421,9 +1422,9 @@ propagate_nothrow (void)\n \t  for (e = w->callees; e; e = e->next_callee)\n \t    {\n \t      enum availability avail;\n-\t      struct cgraph_node *y = cgraph_function_node (e->callee, &avail);\n+\t      struct cgraph_node *y = e->callee->function_symbol (&avail);\n \n-\t      if (avail > AVAIL_OVERWRITABLE)\n+\t      if (avail > AVAIL_INTERPOSABLE)\n \t\t{\n \t\t  funct_state y_l = get_function_state (y);\n \n@@ -1459,7 +1460,7 @@ propagate_nothrow (void)\n \t\t be different.  */\n \t      if (!w->global.inlined_to)\n \t\t{\n-\t\t  cgraph_set_nothrow_flag (w, true);\n+\t\t  w->set_nothrow_flag (true);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n \t\t\t     w->name ());\n@@ -1569,7 +1570,7 @@ skip_function_for_local_pure_const (struct cgraph_node *node)\n         fprintf (dump_file, \"Function called in recursive cycle; ignoring\\n\");\n       return true;\n     }\n-  if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+  if (node->get_availability () <= AVAIL_INTERPOSABLE)\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Function is not available or overwritable; not analyzing.\\n\");\n@@ -1619,7 +1620,7 @@ pass_local_pure_const::execute (function *fun)\n   bool skip;\n   struct cgraph_node *node;\n \n-  node = cgraph_get_node (current_function_decl);\n+  node = cgraph_node::get (current_function_decl);\n   skip = skip_function_for_local_pure_const (node);\n   if (!warn_suggest_attribute_const\n       && !warn_suggest_attribute_pure\n@@ -1653,7 +1654,7 @@ pass_local_pure_const::execute (function *fun)\n \t  warn_function_const (current_function_decl, !l->looping);\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_const_flag (node, true, l->looping);\n+\t      node->set_const_flag (true, l->looping);\n \t      changed = true;\n \t    }\n \t  if (dump_file)\n@@ -1666,7 +1667,7 @@ pass_local_pure_const::execute (function *fun)\n \t{\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_const_flag (node, true, false);\n+\t      node->set_const_flag (true, false);\n \t      changed = true;\n \t    }\n \t  if (dump_file)\n@@ -1680,7 +1681,7 @@ pass_local_pure_const::execute (function *fun)\n \t{\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_pure_flag (node, true, l->looping);\n+\t      node->set_pure_flag (true, l->looping);\n \t      changed = true;\n \t    }\n \t  warn_function_pure (current_function_decl, !l->looping);\n@@ -1694,7 +1695,7 @@ pass_local_pure_const::execute (function *fun)\n \t{\n \t  if (!skip)\n \t    {\n-\t      cgraph_set_pure_flag (node, true, false);\n+\t      node->set_pure_flag (true, false);\n \t      changed = true;\n \t    }\n \t  if (dump_file)\n@@ -1708,7 +1709,7 @@ pass_local_pure_const::execute (function *fun)\n     }\n   if (!l->can_throw && !TREE_NOTHROW (current_function_decl))\n     {\n-      cgraph_set_nothrow_flag (node, true);\n+      node->set_nothrow_flag (true);\n       changed = true;\n       if (dump_file)\n \tfprintf (dump_file, \"Function found to be nothrow: %s\\n\","}, {"sha": "4b23f5fe574449f985bc311e3fc23b5ebee74ff1", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -87,7 +87,7 @@ ipa_ref::remove_reference ()\n bool\n ipa_ref::cannot_lead_to_return ()\n {\n-  return cgraph_node_cannot_return (dyn_cast <cgraph_node *> (referring));\n+  return dyn_cast <cgraph_node *> (referring)->cannot_return_p ();\n }\n \n /* Return reference list this reference is in.  */"}, {"sha": "d999cb1a6b2a1895ea04dd6359bb39c713b45699", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -179,7 +179,7 @@ bitmap\n ipa_reference_get_not_read_global (struct cgraph_node *fn)\n {\n   ipa_reference_optimization_summary_t info =\n-    get_reference_optimization_summary (cgraph_function_node (fn, NULL));\n+    get_reference_optimization_summary (fn->function_symbol (NULL));\n   if (info)\n     return info->statics_not_read;\n   else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n@@ -355,14 +355,14 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n        e = e->next_callee)\n     {\n       enum availability avail;\n-      struct cgraph_node *y = cgraph_function_node (e->callee, &avail);\n+      struct cgraph_node *y = e->callee->function_symbol (&avail);\n       if (!y)\n \tcontinue;\n \n       /* Only look into nodes we can propagate something.  */\n       int flags = flags_from_decl_or_type (y->decl);\n-      if (avail > AVAIL_OVERWRITABLE\n-\t  || (avail == AVAIL_OVERWRITABLE && (flags & ECF_LEAF)))\n+      if (avail > AVAIL_INTERPOSABLE\n+\t  || (avail == AVAIL_INTERPOSABLE && (flags & ECF_LEAF)))\n \t{\n \t  if (get_reference_vars_info (y))\n \t    {\n@@ -479,7 +479,7 @@ analyze_function (struct cgraph_node *fn)\n \t}\n     }\n \n-  if (cgraph_node_cannot_return (fn))\n+  if (fn->cannot_return_p ())\n     bitmap_clear (local->statics_written);\n }\n \n@@ -550,7 +550,7 @@ generate_summary (void)\n \n   if (dump_file)\n     FOR_EACH_DEFINED_FUNCTION (node)\n-      if (cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+      if (node->get_availability () >= AVAIL_INTERPOSABLE)\n \t{\n \t  ipa_reference_local_vars_info_t l;\n \t  unsigned int index;\n@@ -587,12 +587,11 @@ read_write_all_from_decl (struct cgraph_node *node,\n   tree decl = node->decl;\n   int flags = flags_from_decl_or_type (decl);\n   if ((flags & ECF_LEAF)\n-      && cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+      && node->get_availability () <= AVAIL_INTERPOSABLE)\n     ;\n   else if (flags & ECF_CONST)\n     ;\n-  else if ((flags & ECF_PURE)\n-\t   || cgraph_node_cannot_return (node))\n+  else if ((flags & ECF_PURE) || node->cannot_return_p ())\n     {\n       read_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -621,17 +620,17 @@ get_read_write_all_from_node (struct cgraph_node *node,\n   struct cgraph_edge *e, *ie;\n \n   /* When function is overwritable, we can not assume anything.  */\n-  if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n+  if (node->get_availability () <= AVAIL_INTERPOSABLE)\n     read_write_all_from_decl (node, read_all, write_all);\n \n   for (e = node->callees;\n        e && !(read_all && write_all);\n        e = e->next_callee)\n     {\n       enum availability avail;\n-      struct cgraph_node *callee = cgraph_function_node (e->callee, &avail);\n+      struct cgraph_node *callee = e->callee->function_symbol (&avail);\n       gcc_checking_assert (callee);\n-      if (avail <= AVAIL_OVERWRITABLE)\n+      if (avail <= AVAIL_INTERPOSABLE)\n \tread_write_all_from_decl (callee, read_all, write_all);\n     }\n \n@@ -666,7 +665,7 @@ propagate (void)\n   int i;\n \n   if (dump_file)\n-    dump_cgraph (dump_file);\n+    cgraph_node::dump_cgraph (dump_file);\n \n   ipa_discover_readonly_nonaddressable_vars ();\n   generate_summary ();\n@@ -702,7 +701,7 @@ propagate (void)\n \tfprintf (dump_file, \"Starting cycle with %s/%i\\n\",\n \t\t  node->asm_name (), node->order);\n \n-      vec<cgraph_node_ptr> cycle_nodes = ipa_get_nodes_in_cycle (node);\n+      vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (node);\n \n       /* If any node in a cycle is read_all or write_all, they all are.  */\n       FOR_EACH_VEC_ELT (cycle_nodes, x, w)\n@@ -742,7 +741,7 @@ propagate (void)\n \t\tread_all = union_static_var_sets (node_g->statics_read,\n \t\t\t\t\t\t  w_l->statics_read);\n \t      if (!(flags & ECF_PURE)\n-\t\t  && !cgraph_node_cannot_return (w))\n+\t\t  && !w->cannot_return_p ())\n \t\twrite_all = union_static_var_sets (node_g->statics_written,\n \t\t\t\t\t\t   w_l->statics_written);\n \t    }\n@@ -778,7 +777,7 @@ propagate (void)\n \t  ipa_reference_vars_info_t node_info = get_reference_vars_info (node);\n \t  ipa_reference_global_vars_info_t node_g = &node_info->global;\n \n-\t  vec<cgraph_node_ptr> cycle_nodes = ipa_get_nodes_in_cycle (node);\n+\t  vec<cgraph_node *> cycle_nodes = ipa_get_nodes_in_cycle (node);\n \t  FOR_EACH_VEC_ELT (cycle_nodes, x, w)\n \t    {\n \t      ipa_reference_vars_info_t w_ri = get_reference_vars_info (w);\n@@ -810,7 +809,7 @@ propagate (void)\n \n       node_info = get_reference_vars_info (node);\n       if (!node->alias\n-\t  && (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE\n+\t  && (node->get_availability () > AVAIL_INTERPOSABLE\n \t      || (flags_from_decl_or_type (node->decl) & ECF_LEAF)))\n \t{\n \t  node_g = &node_info->global;\n@@ -1055,7 +1054,8 @@ ipa_reference_read_optimization_summary (void)\n \n \t      index = streamer_read_uhwi (ib);\n \t      encoder = file_data->symtab_node_encoder;\n-\t      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n+\t      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref\n+\t\t(encoder, index));\n \t      info = XCNEW (struct ipa_reference_optimization_summary_d);\n \t      set_reference_optimization_summary (node, info);\n \t      info->statics_not_read = BITMAP_ALLOC (&optimization_summary_obstack);"}, {"sha": "2af3a93973b68863ab2d64dd9c3fcef5c40885f3", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1088,7 +1088,7 @@ split_function (struct split_point *split_point)\n   bitmap args_to_skip;\n   tree parm;\n   int num = 0;\n-  struct cgraph_node *node, *cur_node = cgraph_get_node (current_function_decl);\n+  cgraph_node *node, *cur_node = cgraph_node::get (current_function_decl);\n   basic_block return_bb = find_return_bb ();\n   basic_block call_bb;\n   gimple_stmt_iterator gsi;\n@@ -1230,12 +1230,9 @@ split_function (struct split_point *split_point)\n \n   /* Now create the actual clone.  */\n   rebuild_cgraph_edges ();\n-  node = cgraph_function_versioning (cur_node, vNULL,\n-\t\t\t\t     NULL,\n-\t\t\t\t     args_to_skip,\n-\t\t\t\t     !split_part_return_p,\n-\t\t\t\t     split_point->split_bbs,\n-\t\t\t\t     split_point->entry_bb, \"part\");\n+  node = cur_node->create_version_clone_with_body\n+    (vNULL, NULL, args_to_skip, !split_part_return_p, split_point->split_bbs,\n+     split_point->entry_bb, \"part\");\n \n   /* Let's take a time profile for splitted function.  */\n   node->tp_first_run = cur_node->tp_first_run + 1;\n@@ -1251,7 +1248,7 @@ split_function (struct split_point *split_point)\n   /* If the original function is declared inline, there is no point in issuing\n      a warning for the non-inlinable part.  */\n   DECL_NO_INLINE_WARNING_P (node->decl) = 1;\n-  cgraph_node_remove_callees (cur_node);\n+  cur_node->remove_callees ();\n   cur_node->remove_all_references ();\n   if (!split_part_return_p)\n     TREE_THIS_VOLATILE (node->decl) = 1;\n@@ -1512,7 +1509,7 @@ execute_split_functions (void)\n   basic_block bb;\n   int overall_time = 0, overall_size = 0;\n   int todo = 0;\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n \n   if (flags_from_decl_or_type (current_function_decl)\n       & (ECF_NORETURN|ECF_MALLOC))"}, {"sha": "7810e55dcf812716e47efa3877753a4564c2105a", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -55,12 +55,12 @@ ipa_print_order (FILE* out,\n   fprintf (out, \"\\n\\n ordered call graph: %s\\n\", note);\n \n   for (i = count - 1; i >= 0; i--)\n-    dump_cgraph_node (out, order[i]);\n+    order[i]->dump (out);\n   fprintf (out, \"\\n\");\n   fflush (out);\n }\n \n-\f\n+\n struct searchc_env {\n   struct cgraph_node **stack;\n   int stack_size;\n@@ -103,14 +103,14 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n     {\n       struct ipa_dfs_info * w_info;\n       enum availability avail;\n-      struct cgraph_node *w = cgraph_function_or_thunk_node (edge->callee, &avail);\n+      struct cgraph_node *w = edge->callee->ultimate_alias_target (&avail);\n \n       if (!w || (ignore_edge && ignore_edge (edge)))\n         continue;\n \n       if (w->aux\n-\t  && (avail > AVAIL_OVERWRITABLE\n-\t      || (env->allow_overwritable && avail == AVAIL_OVERWRITABLE)))\n+\t  && (avail > AVAIL_INTERPOSABLE\n+\t      || (env->allow_overwritable && avail == AVAIL_INTERPOSABLE)))\n \t{\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  if (w_info->new_node)\n@@ -184,11 +184,11 @@ ipa_reduced_postorder (struct cgraph_node **order,\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      enum availability avail = cgraph_function_body_availability (node);\n+      enum availability avail = node->get_availability ();\n \n-      if (avail > AVAIL_OVERWRITABLE\n+      if (avail > AVAIL_INTERPOSABLE\n \t  || (allow_overwritable\n-\t      && (avail == AVAIL_OVERWRITABLE)))\n+\t      && (avail == AVAIL_INTERPOSABLE)))\n \t{\n \t  /* Reuse the info if it is already there.  */\n \t  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;\n@@ -240,10 +240,10 @@ ipa_free_postorder_info (void)\n /* Get the set of nodes for the cycle in the reduced call graph starting\n    from NODE.  */\n \n-vec<cgraph_node_ptr> \n+vec<cgraph_node *>\n ipa_get_nodes_in_cycle (struct cgraph_node *node)\n {\n-  vec<cgraph_node_ptr> v = vNULL;\n+  vec<cgraph_node *> v = vNULL;\n   struct ipa_dfs_info *node_dfs_info;\n   while (node)\n     {\n@@ -262,7 +262,7 @@ ipa_edge_within_scc (struct cgraph_edge *cs)\n {\n   struct ipa_dfs_info *caller_dfs = (struct ipa_dfs_info *) cs->caller->aux;\n   struct ipa_dfs_info *callee_dfs;\n-  struct cgraph_node *callee = cgraph_function_node (cs->callee, NULL);\n+  struct cgraph_node *callee = cs->callee->function_symbol ();\n \n   callee_dfs = (struct ipa_dfs_info *) callee->aux;\n   return (caller_dfs\n@@ -307,7 +307,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t      || (!node->address_taken\n \t\t  && !node->global.inlined_to\n \t\t  && !node->alias && !node->thunk.thunk_p\n-\t\t  && !cgraph_only_called_directly_p (node))))\n+\t\t  && !node->only_called_directly_p ())))\n \t{\n \t  stack_size = 0;\n           stack[stack_size].node = node;\n@@ -329,7 +329,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t\t functions to non-always-inline functions.  */\n \t\t      if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->decl)\n \t\t\t  && !DECL_DISREGARD_INLINE_LIMITS\n-\t\t\t    (cgraph_function_node (edge->callee, NULL)->decl))\n+\t\t\t    (edge->callee->function_symbol ()->decl))\n \t\t\tnode2 = NULL;\n \t\t    }\n \t\t  for (; stack[stack_size].node->iterate_referring (\n@@ -712,8 +712,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       gcc_assert (!*slot);\n       *slot = state;\n     }\n-  cgraph_get_body (src);\n-  cgraph_get_body (dst);\n+  src->get_body ();\n+  dst->get_body ();\n   srccfun = DECL_STRUCT_FUNCTION (src->decl);\n   dstcfun = DECL_STRUCT_FUNCTION (dst->decl);\n   if (n_basic_blocks_for_fn (srccfun)\n@@ -814,7 +814,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t\t     (dst->decl,\n \t\t\t      gimple_bb (e->call_stmt));\n \t}\n-      cgraph_release_function_body (src);\n+      src->release_body ();\n       inline_update_overall_summary (dst);\n     }\n   /* TODO: if there is no match, we can scale up.  */\n@@ -826,9 +826,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n bool\n recursive_call_p (tree func, tree dest)\n {\n-  struct cgraph_node *dest_node = cgraph_get_create_node (dest);\n-  struct cgraph_node *cnode = cgraph_get_create_node (func);\n+  struct cgraph_node *dest_node = cgraph_node::get_create (dest);\n+  struct cgraph_node *cnode = cgraph_node::get_create (func);\n \n-  return symtab_semantically_equivalent_p (dest_node,\n-\t\t\t\t\t   cnode);\n+  return dest_node->semantically_equivalent_p (cnode);\n }"}, {"sha": "bb2e0d50d6be0aa2a1bb382a800b34714b41c803", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -55,7 +55,7 @@ void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);\n int ipa_reduced_postorder (struct cgraph_node **, bool, bool,\n \t\t\t  bool (*ignore_edge) (struct cgraph_edge *));\n void ipa_free_postorder_info (void);\n-vec<cgraph_node_ptr> ipa_get_nodes_in_cycle (struct cgraph_node *);\n+vec<cgraph_node *> ipa_get_nodes_in_cycle (struct cgraph_node *);\n bool ipa_edge_within_scc (struct cgraph_edge *);\n int ipa_reverse_postorder (struct cgraph_node **);\n tree get_base_var (tree);"}, {"sha": "ddce77d09491dc8bd5dff8c64132e613bcd1ea31", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -86,11 +86,11 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Return true when NODE can not be local. Worker for cgraph_local_node_p.  */\n \n-static bool\n-cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+bool\n+cgraph_node::non_local_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n    /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n-   return !(cgraph_only_called_directly_or_aliased_p (node)\n+   return !(node->only_called_directly_or_aliased_p ()\n \t    && !node->has_aliases_p ()\n \t    && node->definition\n \t    && !DECL_EXTERNAL (node->decl)\n@@ -102,27 +102,28 @@ cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED\n /* Return true when function can be marked local.  */\n \n bool\n-cgraph_local_node_p (struct cgraph_node *node)\n+cgraph_node::local_p (void)\n {\n-   struct cgraph_node *n = cgraph_function_or_thunk_node (node, NULL);\n+   cgraph_node *n = ultimate_alias_target ();\n \n    /* FIXME: thunks can be considered local, but we need prevent i386\n       from attempting to change calling convention of them.  */\n    if (n->thunk.thunk_p)\n      return false;\n-   return !cgraph_for_node_and_aliases (n,\n-\t\t\t\t\tcgraph_non_local_node_p_1, NULL, true);\n+   return !n->call_for_symbol_thunks_and_aliases (cgraph_node::non_local_p,\n+\t\t\t\t\t\tNULL, true);\n \t\t\t\t\t\n }\n \n /* Return true when there is a reference to node and it is not vtable.  */\n+\n bool\n-address_taken_from_non_vtable_p (symtab_node *node)\n+symtab_node::address_taken_from_non_vtable_p (void)\n {\n   int i;\n   struct ipa_ref *ref = NULL;\n \n-  for (i = 0; node->iterate_referring (i, ref); i++)\n+  for (i = 0; iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tvarpool_node *node;\n@@ -150,7 +151,7 @@ comdat_can_be_unshared_p_1 (symtab_node *node)\n       && (TREE_CODE (node->decl) != FUNCTION_DECL\n \t  || (!DECL_CXX_CONSTRUCTOR_P (node->decl)\n \t      && !DECL_CXX_DESTRUCTOR_P (node->decl)))\n-      && address_taken_from_non_vtable_p (node))\n+      && node->address_taken_from_non_vtable_p ())\n     return false;\n \n   /* If the symbol is used in some weird way, better to not touch it.  */\n@@ -223,7 +224,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n     return true;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (symtab_used_from_object_file_p (node))\n+  if (node->used_from_object_file_p ())\n     return true;\n   if (DECL_PRESERVE_P (node->decl))\n     return true;\n@@ -274,7 +275,7 @@ varpool_externally_visible_p (varpool_node *vnode)\n     return false;\n \n   /* If linker counts on us, we must preserve the function.  */\n-  if (symtab_used_from_object_file_p (vnode))\n+  if (vnode->used_from_object_file_p ())\n     return true;\n \n   if (DECL_HARD_REGISTER (vnode->decl))\n@@ -295,7 +296,7 @@ varpool_externally_visible_p (varpool_node *vnode)\n      Even if the linker clams the symbol is unused, never bring internal\n      symbols that are declared by user as used or externally visible.\n      This is needed for i.e. references from asm statements.   */\n-  if (symtab_used_from_object_file_p (vnode))\n+  if (vnode->used_from_object_file_p ())\n     return true;\n   if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n@@ -340,9 +341,9 @@ varpool_externally_visible_p (varpool_node *vnode)\n bool\n can_replace_by_local_alias (symtab_node *node)\n {\n-  return (symtab_node_availability (node) > AVAIL_OVERWRITABLE\n+  return (node->get_availability () > AVAIL_INTERPOSABLE\n \t  && !decl_binds_to_current_def_p (node->decl)\n-\t  && !symtab_can_be_discarded (node));\n+\t  && !node->can_be_discarded_p ());\n }\n \n /* Return true if we can replace refernece to NODE by local alias\n@@ -366,8 +367,8 @@ update_vtable_references (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNU\n   if (TREE_CODE (*tp) == VAR_DECL\n       || TREE_CODE (*tp) == FUNCTION_DECL)\n     {\n-      if (can_replace_by_local_alias_in_vtable (symtab_get_node (*tp)))\n-\t*tp = symtab_nonoverwritable_alias (symtab_get_node (*tp))->decl;\n+      if (can_replace_by_local_alias_in_vtable (symtab_node::get (*tp)))\n+\t*tp = symtab_node::get (*tp)->noninterposable_alias ()->decl;\n       *walk_subtrees = 0;\n     }\n   else if (IS_TYPE_OR_DECL_P (*tp))\n@@ -416,7 +417,7 @@ update_visibility_by_resolution_info (symtab_node * node)\n   DECL_WEAK (node->decl) = false;\n   if (!define)\n     DECL_EXTERNAL (node->decl) = true;\n-  symtab_dissolve_same_comdat_group_list (node);\n+  node->dissolve_same_comdat_group_list ();\n }\n \n /* Decide on visibility of all symbols.  */\n@@ -473,7 +474,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t all of them have to be, otherwise it is a front-end bug.  */\n \t      gcc_assert (DECL_EXTERNAL (n->decl));\n #endif\n-\t  symtab_dissolve_same_comdat_group_list (node);\n+\t  node->dissolve_same_comdat_group_list ();\n \t}\n       gcc_assert ((!DECL_WEAK (node->decl)\n \t\t  && !DECL_COMDAT (node->decl))\n@@ -514,7 +515,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t  next->set_comdat_group (NULL);\n \t\t  if (!next->alias)\n \t\t    next->set_section (NULL);\n-\t\t  symtab_make_decl_local (next->decl);\n+\t\t  next->make_decl_local ();\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n \t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n@@ -524,29 +525,29 @@ function_and_variable_visibility (bool whole_program)\n \t         in the group and they will all be made local.  We need to\n \t         dissolve the group at once so that the predicate does not\n \t         segfault though. */\n-\t      symtab_dissolve_same_comdat_group_list (node);\n+\t      node->dissolve_same_comdat_group_list ();\n \t    }\n \t  if (TREE_PUBLIC (node->decl))\n \t    node->set_comdat_group (NULL);\n \t  if (DECL_COMDAT (node->decl) && !node->alias)\n \t    node->set_section (NULL);\n-\t  symtab_make_decl_local (node->decl);\n+\t  node->make_decl_local ();\n \t}\n \n       if (node->thunk.thunk_p\n \t  && TREE_PUBLIC (node->decl))\n \t{\n \t  struct cgraph_node *decl_node = node;\n \n-\t  decl_node = cgraph_function_node (decl_node->callees->callee, NULL);\n+\t  decl_node = decl_node->callees->callee->function_symbol ();\n \n \t  /* Thunks have the same visibility as function they are attached to.\n \t     Make sure the C++ front end set this up properly.  */\n \t  if (DECL_ONE_ONLY (decl_node->decl))\n \t    {\n \t      gcc_checking_assert (DECL_COMDAT (node->decl)\n \t\t\t\t   == DECL_COMDAT (decl_node->decl));\n-\t      gcc_checking_assert (symtab_in_same_comdat_p (node, decl_node));\n+\t      gcc_checking_assert (node->in_same_comdat_group_p (decl_node));\n \t      gcc_checking_assert (node->same_comdat_group);\n \t    }\n \t  node->forced_by_abi = decl_node->forced_by_abi;\n@@ -558,18 +559,19 @@ function_and_variable_visibility (bool whole_program)\n     }\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      node->local.local |= cgraph_local_node_p (node);\n+      node->local.local |= node->local_p ();\n \n       /* If we know that function can not be overwritten by a different semantics\n \t and moreover its section can not be discarded, replace all direct calls\n-\t by calls to an nonoverwritable alias.  This make dynamic linking\n+\t by calls to an noninterposable alias.  This make dynamic linking\n \t cheaper and enable more optimization.\n \n \t TODO: We can also update virtual tables.  */\n       if (node->callers \n \t  && can_replace_by_local_alias (node))\n \t{\n-\t  struct cgraph_node *alias = cgraph (symtab_nonoverwritable_alias (node));\n+\t  cgraph_node *alias = dyn_cast<cgraph_node *>\n+\t    (node->noninterposable_alias ());\n \n \t  if (alias && alias != node)\n \t    {\n@@ -650,19 +652,19 @@ function_and_variable_visibility (bool whole_program)\n \t\t  next->set_comdat_group (NULL);\n \t\t  if (!next->alias)\n \t\t    next->set_section (NULL);\n-\t\t  symtab_make_decl_local (next->decl);\n+\t\t  next->make_decl_local ();\n \t\t  next->unique_name = ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t|| next->unique_name\n \t\t\t\t\t|| next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n \t\t\t\t       && TREE_PUBLIC (next->decl));\n \t\t}\n-\t      symtab_dissolve_same_comdat_group_list (vnode);\n+\t      vnode->dissolve_same_comdat_group_list ();\n \t    }\n \t  if (TREE_PUBLIC (vnode->decl))\n \t    vnode->set_comdat_group (NULL);\n \t  if (DECL_COMDAT (vnode->decl) && !vnode->alias)\n \t    vnode->set_section (NULL);\n-\t  symtab_make_decl_local (vnode->decl);\n+\t  vnode->make_decl_local ();\n \t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n       update_visibility_by_resolution_info (vnode);"}, {"sha": "42dce671ab38f18e51e814093698526fb6bdd193", "filename": "gcc/ipa.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -193,13 +193,13 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t  if (targets.length () == 1)\n \t    target = targets[0];\n \t  else\n-\t    target = cgraph_get_create_node\n+\t    target = cgraph_node::get_create\n \t\t       (builtin_decl_implicit (BUILT_IN_UNREACHABLE));\n \n \t  if (dump_enabled_p ())\n             {\n-              location_t locus = gimple_location_safe (edge->call_stmt);\n-              dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n+\t      location_t locus = gimple_location (edge->call_stmt);\n+\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,\n                                \"devirtualizing call in %s/%i to %s/%i\\n\",\n                                edge->caller->name (), edge->caller->order,\n                                target->name (),\n@@ -301,7 +301,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       if (node->definition\n \t  && !node->global.inlined_to\n \t  && !node->in_other_partition\n-\t  && !cgraph_can_remove_if_no_direct_calls_and_refs_p (node))\n+\t  && !node->can_remove_if_no_direct_calls_and_refs_p ())\n \t{\n \t  gcc_assert (!node->global.inlined_to);\n \t  pointer_set_insert (reachable, node);\n@@ -338,7 +338,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      && DECL_ABSTRACT_ORIGIN (node->decl))\n \t    {\n \t      struct cgraph_node *origin_node\n-\t      = cgraph_get_create_node (DECL_ABSTRACT_ORIGIN (node->decl));\n+\t      = cgraph_node::get_create (DECL_ABSTRACT_ORIGIN (node->decl));\n \t      origin_node->used_as_abstract_origin = true;\n \t      enqueue_node (origin_node, &first, reachable);\n \t    }\n@@ -352,7 +352,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      for (next = node->same_comdat_group;\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n-\t\tif (!symtab_comdat_local_p (next)\n+\t\tif (!next->comdat_local_p ()\n \t\t    && !pointer_set_insert (reachable, next))\n \t\t  enqueue_node (next, &first, reachable);\n \t    }\n@@ -394,10 +394,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      if (DECL_EXTERNAL (e->callee->decl)\n \t\t\t  && e->callee->alias\n \t\t\t  && before_inlining_p)\n-\t\t\t{\n-\t\t          pointer_set_insert (reachable,\n-\t\t\t\t\t      cgraph_function_node (e->callee));\n-\t\t\t}\n+\t\t\tpointer_set_insert (reachable,\n+\t\t\t\t\t    e->callee->function_symbol ());\n \t\t      pointer_set_insert (reachable, e->callee);\n \t\t    }\n \t\t  enqueue_node (e->callee, &first, reachable);\n@@ -460,14 +458,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t{\n \t  if (file)\n \t    fprintf (file, \" %s/%i\", node->name (), node->order);\n-\t  cgraph_remove_node (node);\n+\t  node->remove ();\n \t  changed = true;\n \t}\n       /* If node is unreachable, remove its body.  */\n       else if (!pointer_set_contains (reachable, node))\n         {\n \t  if (!pointer_set_contains (body_needed_for_clonning, node->decl))\n-\t    cgraph_release_function_body (node);\n+\t    node->release_body ();\n \t  else if (!node->clone_of)\n \t    gcc_assert (in_lto_p || DECL_RESULT (node->decl));\n \t  if (node->definition)\n@@ -489,14 +487,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t\t\t    DECL_ATTRIBUTES (node->decl));\n \t      if (!node->in_other_partition)\n \t\tnode->local.local = false;\n-\t      cgraph_node_remove_callees (node);\n-\t      symtab_remove_from_same_comdat_group (node);\n+\t      node->remove_callees ();\n+\t      node->remove_from_same_comdat_group ();\n \t      node->remove_all_references ();\n \t      changed = true;\n \t    }\n \t}\n       else\n-\tgcc_assert (node->clone_of || !cgraph_function_with_gimple_body_p (node)\n+\tgcc_assert (node->clone_of || !node->has_gimple_body_p ()\n \t\t    || in_lto_p || DECL_RESULT (node->decl));\n     }\n \n@@ -529,7 +527,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t{\n \t  if (file)\n \t    fprintf (file, \" %s/%i\", vnode->name (), vnode->order);\n-\t  varpool_remove_node (vnode);\n+\t  vnode->remove ();\n \t  changed = true;\n \t}\n       else if (!pointer_set_contains (reachable, vnode))\n@@ -546,7 +544,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  vnode->analyzed = false;\n \t  vnode->aux = NULL;\n \n-\t  symtab_remove_from_same_comdat_group (vnode);\n+\t  vnode->remove_from_same_comdat_group ();\n \n \t  /* Keep body if it may be useful for constant folding.  */\n \t  if ((init = ctor_for_folding (vnode->decl)) == error_mark_node)\n@@ -570,13 +568,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     if (node->address_taken\n \t&& !node->used_from_other_partition)\n       {\n-\tif (!cgraph_for_node_and_aliases (node, has_addr_references_p, NULL, true))\n+\tif (!node->call_for_symbol_thunks_and_aliases\n+\t  (has_addr_references_p, NULL, true))\n \t  {\n \t    if (file)\n \t      fprintf (file, \" %s\", node->name ());\n \t    node->address_taken = false;\n \t    changed = true;\n-\t    if (cgraph_local_node_p (node))\n+\t    if (node->local_p ())\n \t      {\n \t\tnode->local.local = true;\n \t\tif (file)\n@@ -588,7 +587,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     fprintf (file, \"\\n\");\n \n #ifdef ENABLE_CHECKING\n-  verify_symtab ();\n+  symtab_node::verify_symtab_nodes ();\n #endif\n \n   /* If we removed something, perhaps profile could be improved.  */\n@@ -630,8 +629,8 @@ process_references (varpool_node *vnode,\n \t*written = true;\n \tbreak;\n       case IPA_REF_ALIAS:\n-\tprocess_references (varpool (ref->referring), written, address_taken,\n-\t\t\t    read, explicit_refs);\n+\tprocess_references (dyn_cast<varpool_node *> (ref->referring), written,\n+\t\t\t    address_taken, read, explicit_refs);\n \tbreak;\n       }\n }\n@@ -839,7 +838,7 @@ cgraph_build_static_cdtor_1 (char which, tree body, int priority, bool final)\n \n   gimplify_function_tree (decl);\n \n-  cgraph_add_new_function (decl, false);\n+  cgraph_node::add_new_function (decl, false);\n \n   set_cfun (NULL);\n   current_function_decl = NULL;\n@@ -875,7 +874,7 @@ record_cdtor_fn (struct cgraph_node *node)\n     static_ctors.safe_push (node->decl);\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     static_dtors.safe_push (node->decl);\n-  node = cgraph_get_node (node->decl);\n+  node = cgraph_node::get (node->decl);\n   DECL_DISREGARD_INLINE_LIMITS (node->decl) = 1;\n }\n \n@@ -1147,9 +1146,7 @@ propagate_single_user (varpool_node *vnode, cgraph_node *function,\n     function = meet (function, varpool_alias_target (vnode), single_user_map);\n \n   /* Check all users and see if they correspond to a single function.  */\n-  for (i = 0;\n-       vnode->iterate_referring (i, ref)\n-       && function != BOTTOM; i++)\n+  for (i = 0; vnode->iterate_referring (i, ref) && function != BOTTOM; i++)\n     {\n       struct cgraph_node *cnode = dyn_cast <cgraph_node *> (ref->referring);\n       if (cnode)\n@@ -1215,17 +1212,15 @@ ipa_single_use (void)\n \t  single_user_map.put (var, user);\n \n \t  /* Enqueue all aliases for re-processing.  */\n-\t  for (i = 0;\n-\t       var->iterate_referring (i, ref); i++)\n+\t  for (i = 0; var->iterate_referring (i, ref); i++)\n \t    if (ref->use == IPA_REF_ALIAS\n \t\t&& !ref->referring->aux)\n \t      {\n \t\tref->referring->aux = first;\n \t\tfirst = dyn_cast <varpool_node *> (ref->referring);\n \t      }\n \t  /* Enqueue all users for re-processing.  */\n-\t  for (i = 0;\n-\t       var->iterate_reference (i, ref); i++)\n+\t  for (i = 0; var->iterate_reference (i, ref); i++)\n \t    if (!ref->referred->aux\n \t        && ref->referred->definition\n \t\t&& is_a <varpool_node *> (ref->referred))"}, {"sha": "38c5a9d5729665174f77f8c8502657c3fab3a690", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1906,7 +1906,7 @@ java_mark_decl_local (tree decl)\n   /* Double check that we didn't pass the function to the callgraph early.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_get_node (decl);\n+      struct cgraph_node *node = cgraph_node::get (decl);\n       gcc_assert (!node || !node->definition);\n     }\n #endif"}, {"sha": "223334928a6a9b06157a922bf858e3a9669c1b46", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -423,7 +423,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      translation units into SET during IPA-inlining.  We make them as\n      local static nodes to prevent clashes with other local statics.  */\n   if (boundary_p && node->analyzed\n-      && symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION)\n+      && node->get_partitioning_class () == SYMBOL_PARTITION)\n     {\n       /* Inline clones can not be part of boundary.  \n          gcc_assert (!node->global.inlined_to);  \n@@ -523,7 +523,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->implicit_section, 1);\n   bp_pack_value (&bp, node->address_taken, 1);\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n-\t\t && symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION\n+\t\t && node->get_partitioning_class () == SYMBOL_PARTITION\n \t\t && (reachable_from_other_partition_p (node, encoder)\n \t\t     || referenced_from_other_partition_p (node, encoder)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n@@ -600,7 +600,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n-  if (symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION)\n+  if (node->get_partitioning_class () != SYMBOL_PARTITION)\n     {\n       bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n       bp_pack_value (&bp, 0, 1);  /* in_other_partition.  */\n@@ -837,7 +837,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       if (DECL_ABSTRACT_ORIGIN (node->decl))\n \t{\n \t  struct cgraph_node *origin_node\n-\t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (node->decl));\n+\t  = cgraph_node::get (DECL_ABSTRACT_ORIGIN (node->decl));\n \t  add_node_to (encoder, origin_node, true);\n \t}\n     }\n@@ -960,8 +960,7 @@ output_symtab (void)\n       if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n         lto_output_node (ob, cnode, encoder);\n       else\n-        lto_output_varpool_node (ob, varpool (node), encoder);\n-\t\n+\tlto_output_varpool_node (ob, dyn_cast<varpool_node *> (node), encoder);\n     }\n \n   /* Go over the nodes in SET again to write edges.  */\n@@ -1130,18 +1129,18 @@ input_node (struct lto_file_decl_data *file_data,\n \n   if (clone_ref != LCC_NOT_FOUND)\n     {\n-      node = cgraph_clone_node (cgraph (nodes[clone_ref]), fn_decl,\n-\t\t\t\t0, CGRAPH_FREQ_BASE, false,\n-\t\t\t\tvNULL, false, NULL, NULL);\n+      node = dyn_cast<cgraph_node *> (nodes[clone_ref])->create_clone (fn_decl,\n+\t0, CGRAPH_FREQ_BASE, false,\n+\tvNULL, false, NULL, NULL);\n     }\n   else\n     {\n       /* Declaration of functions can be already merged with a declaration\n \t from other input file.  We keep cgraph unmerged until after streaming\n \t of ipa passes is done.  Alays forcingly create a fresh node.  */\n-      node = cgraph_create_empty_node ();\n+      node = cgraph_node::create_empty ();\n       node->decl = fn_decl;\n-      symtab_register_node (node);\n+      node->register_symbol ();\n     }\n \n   node->order = order;\n@@ -1185,7 +1184,7 @@ input_node (struct lto_file_decl_data *file_data,\n   input_overwrite_node (file_data, node, tag, &bp);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n+  node->global.inlined_to = (cgraph_node *) (intptr_t) ref;\n \n   if (group)\n     {\n@@ -1245,7 +1244,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n      of ipa passes is done.  Alays forcingly create a fresh node.  */\n   node = varpool_create_empty_node ();\n   node->decl = var_decl;\n-  symtab_register_node (node);\n+  node->register_symbol ();\n \n   node->order = order;\n   if (order >= symtab_order)\n@@ -1339,13 +1338,13 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   struct bitpack_d bp;\n   int ecf_flags = 0;\n \n-  caller = cgraph (nodes[streamer_read_hwi (ib)]);\n+  caller = dyn_cast<cgraph_node *> (nodes[streamer_read_hwi (ib)]);\n   if (caller == NULL || caller->decl == NULL_TREE)\n     internal_error (\"bytecode stream: no caller found while reading edge\");\n \n   if (!indirect)\n     {\n-      callee = cgraph (nodes[streamer_read_hwi (ib)]);\n+      callee = dyn_cast<cgraph_node *> (nodes[streamer_read_hwi (ib)]);\n       if (callee == NULL || callee->decl == NULL_TREE)\n \tinternal_error (\"bytecode stream: no callee found while reading edge\");\n     }\n@@ -1360,9 +1359,9 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   freq = (int) bp_unpack_var_len_unsigned (&bp);\n \n   if (indirect)\n-    edge = cgraph_create_indirect_edge (caller, NULL, 0, count, freq);\n+    edge = caller->create_indirect_edge (NULL, 0, count, freq);\n   else\n-    edge = cgraph_create_edge (caller, callee, NULL, count, freq);\n+    edge = caller->create_edge (callee, NULL, count, freq);\n \n   edge->indirect_inlining_edge = bp_unpack_value (&bp, 1);\n   edge->speculative = bp_unpack_value (&bp, 1);\n@@ -1450,7 +1449,8 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \n \t  /* Fixup inlined_to from reference to pointer.  */\n \t  if (ref != LCC_NOT_FOUND)\n-\t    cgraph (node)->global.inlined_to = cgraph (nodes[ref]);\n+\t    dyn_cast<cgraph_node *> (node)->global.inlined_to\n+\t      = dyn_cast<cgraph_node *> (nodes[ref]);\n \t  else\n \t    cnode->global.inlined_to = NULL;\n \t}\n@@ -1917,7 +1917,7 @@ input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n   for (i = 0; i < count; i++)\n     {\n       int ref = streamer_read_uhwi (&ib_main);\n-      input_node_opt_summary (cgraph (nodes[ref]),\n+      input_node_opt_summary (dyn_cast<cgraph_node *> (nodes[ref]),\n \t\t\t      &ib_main, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_cgraph_opt_sum, NULL, data,"}, {"sha": "3ece457c15b1f39041da60d7abac2a84cc0a71b0", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -936,9 +936,9 @@ input_function (tree fn_decl, struct data_in *data_in,\n \n   gimple_register_cfg_hooks ();\n \n-  node = cgraph_get_node (fn_decl);\n+  node = cgraph_node::get (fn_decl);\n   if (!node)\n-    node = cgraph_create_node (fn_decl);\n+    node = cgraph_node::create (fn_decl);\n   input_struct_function_base (fn, data_in, ib);\n   input_cfg (ib_cfg, data_in, fn, node->count_materialization_scale);\n "}, {"sha": "001df9b96869782c2c37a0a4bd678fa33ef22067", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -2318,8 +2318,8 @@ write_symbol (struct streamer_tree_cache_d *cache,\n       gcc_assert (alias || TREE_CODE (t) != VAR_DECL\n \t\t  || varpool_get_node (t)->definition);\n       gcc_assert (alias || TREE_CODE (t) != FUNCTION_DECL\n-\t\t  || (cgraph_get_node (t)\n-\t\t      && cgraph_get_node (t)->definition));\n+\t\t  || (cgraph_node::get (t)\n+\t\t      && cgraph_node::get (t)->definition));\n     }\n \n   /* Imitate what default_elf_asm_output_external do.\n@@ -2377,7 +2377,7 @@ bool\n output_symbol_p (symtab_node *node)\n {\n   struct cgraph_node *cnode;\n-  if (!symtab_real_symbol_p (node))\n+  if (!node->real_symbol_p ())\n     return false;\n   /* We keep external functions in symtab for sake of inlining\n      and devirtualization.  We do not want to see them in symbol table as"}, {"sha": "d350ad9cedb9a06837934d1bedd88d8f78837490", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1075,14 +1075,14 @@ lsei_node (lto_symtab_encoder_iterator lsei)\n static inline struct cgraph_node *\n lsei_cgraph_node (lto_symtab_encoder_iterator lsei)\n {\n-  return cgraph (lsei.encoder->nodes[lsei.index].node);\n+  return dyn_cast<cgraph_node *> (lsei.encoder->nodes[lsei.index].node);\n }\n \n /* Return the node pointed to by LSI.  */\n static inline varpool_node *\n lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n {\n-  return varpool (lsei.encoder->nodes[lsei.index].node);\n+  return dyn_cast<varpool_node *> (lsei.encoder->nodes[lsei.index].node);\n }\n \n /* Return the cgraph node corresponding to REF using ENCODER.  */"}, {"sha": "8f2e236beb1ce4936d9555e7dc59cdc4368ef063", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -90,13 +90,14 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n \n   /* Add all duplicated references to the partition.  */\n   for (i = 0; node->iterate_reference (i, ref); i++)\n-    if (symtab_get_symbol_partitioning_class (ref->referred) == SYMBOL_DUPLICATE)\n+    if (ref->referred->get_partitioning_class () == SYMBOL_DUPLICATE)\n       add_symbol_to_partition (part, ref->referred);\n     /* References to a readonly variable may be constant foled into its value.\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n     else if (is_a <varpool_node *> (ref->referred)\n-\t     && varpool_ctor_useable_for_folding_p (varpool (ref->referred))\n+\t     && varpool_ctor_useable_for_folding_p\n+\t       (dyn_cast <varpool_node *> (ref->referred))\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)\n@@ -112,7 +113,7 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n static bool\n add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n {\n-  enum symbol_partitioning_class c = symtab_get_symbol_partitioning_class (node);\n+  enum symbol_partitioning_class c = node->get_partitioning_class ();\n   struct ipa_ref *ref;\n   symtab_node *node1;\n \n@@ -155,7 +156,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n       for (e = cnode->callees; e; e = e->next_callee)\n \tif (!e->inline_failed)\n \t  add_symbol_to_partition_1 (part, e->callee);\n-\telse if (symtab_get_symbol_partitioning_class (e->callee) == SYMBOL_DUPLICATE)\n+\telse if (e->callee->get_partitioning_class () == SYMBOL_DUPLICATE)\n \t  add_symbol_to_partition (part, e->callee);\n \n       /* Add all thunks associated with the function.  */\n@@ -196,7 +197,7 @@ contained_in_symbol (symtab_node *node)\n     return node;\n   if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     {\n-      cnode = cgraph_function_node (cnode, NULL);\n+      cnode = cnode->function_symbol ();\n       if (cnode->global.inlined_to)\n \tcnode = cnode->global.inlined_to;\n       return cnode;\n@@ -215,7 +216,7 @@ add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n   symtab_node *node1;\n \n   /* Verify that we do not try to duplicate something that can not be.  */\n-  gcc_checking_assert (symtab_get_symbol_partitioning_class (node) == SYMBOL_DUPLICATE\n+  gcc_checking_assert (node->get_partitioning_class () == SYMBOL_DUPLICATE\n \t\t       || !symbol_partitioned_p (node));\n \n   while ((node1 = contained_in_symbol (node)) != node)\n@@ -228,7 +229,7 @@ add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n      Be lax about comdats; they may or may not be duplicated and we may\n      end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n \n-  gcc_assert (symtab_get_symbol_partitioning_class (node) == SYMBOL_DUPLICATE\n+  gcc_assert (node->get_partitioning_class () == SYMBOL_DUPLICATE\n \t      || DECL_COMDAT (node->decl)\n \t      || !symbol_partitioned_p (node));\n \n@@ -276,7 +277,7 @@ lto_1_to_1_map (void)\n \n   FOR_EACH_SYMBOL (node)\n     {\n-      if (symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION\n+      if (node->get_partitioning_class () != SYMBOL_PARTITION\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n \n@@ -328,7 +329,7 @@ lto_max_map (void)\n \n   FOR_EACH_SYMBOL (node)\n     {\n-      if (symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION\n+      if (node->get_partitioning_class () != SYMBOL_PARTITION\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n       partition = new_partition (node->asm_name ());\n@@ -438,7 +439,7 @@ lto_balanced_map (int n_lto_partitions)\n     gcc_assert (!vnode->aux);\n     \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION)\n+    if (node->get_partitioning_class () == SYMBOL_PARTITION)\n       {\n \torder[n_nodes++] = node;\n \tif (!node->alias)\n@@ -459,13 +460,13 @@ lto_balanced_map (int n_lto_partitions)\n   if (!flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n-\tif (symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n+\tif (vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t  n_varpool_nodes++;\n       varpool_order = XNEWVEC (varpool_node *, n_varpool_nodes);\n \n       n_varpool_nodes = 0;\n       FOR_EACH_VARIABLE (vnode)\n-\tif (symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n+\tif (vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t  varpool_order[n_varpool_nodes++] = vnode;\n       qsort (varpool_order, n_varpool_nodes, sizeof (varpool_node *),\n \t     varpool_node_cmp);\n@@ -585,7 +586,7 @@ lto_balanced_map (int n_lto_partitions)\n \t\tif (!vnode->definition)\n \t\t  continue;\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n-\t\t    && symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n+\t\t    && vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   vnode);\n@@ -622,7 +623,7 @@ lto_balanced_map (int n_lto_partitions)\n \t\t   number of symbols promoted to hidden.  */\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n \t\t    && !varpool_can_remove_if_no_refs (vnode)\n-\t\t    && symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION)\n+\t\t    && vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   vnode);\n@@ -714,7 +715,7 @@ lto_balanced_map (int n_lto_partitions)\n   if (flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n-        if (symtab_get_symbol_partitioning_class (vnode) == SYMBOL_PARTITION\n+\tif (vnode->get_partitioning_class () == SYMBOL_PARTITION\n \t    && !symbol_partitioned_p (vnode))\n \t  add_symbol_to_partition (partition, vnode);\n     }\n@@ -814,7 +815,7 @@ may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node *node)\n   struct cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n   if (!cnode)\n     return false;\n-  if (symtab_real_symbol_p (node))\n+  if (node->real_symbol_p ())\n     return false;\n   return (!encoder\n \t  || (lto_symtab_encoder_lookup (encoder, node) != LCC_NOT_FOUND\n@@ -841,7 +842,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n \t external symbols (i.e. those not defined).  Remove this test\n \t once this is fixed.  */\n         || DECL_EXTERNAL (node->decl)\n-        || !symtab_real_symbol_p (node))\n+\t|| !node->real_symbol_p ())\n        && !may_need_named_section_p (encoder, node))\n     return;\n \n@@ -850,7 +851,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n      same name as external or public symbol.)  */\n   for (s = symtab_node_for_asm (name);\n        s; s = s->next_sharing_asm_name)\n-    if ((symtab_real_symbol_p (s) || may_need_named_section_p (encoder, s))\n+    if ((s->real_symbol_p () || may_need_named_section_p (encoder, s))\n \t&& s->decl != node->decl\n \t&& (!encoder\n \t    || lto_symtab_encoder_lookup (encoder, s) != LCC_NOT_FOUND))\n@@ -868,7 +869,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n      mangled name.  */\n   for (s = symtab_node_for_asm (name); s;)\n     if (!s->externally_visible\n-\t&& ((symtab_real_symbol_p (s)\n+\t&& ((s->real_symbol_p ()\n              && !DECL_EXTERNAL (node->decl)\n \t     && !TREE_PUBLIC (node->decl))\n  \t    || may_need_named_section_p (encoder, s))\n@@ -924,7 +925,7 @@ lto_promote_cross_file_statics (void)\n \t      || lto_symtab_encoder_in_partition_p (encoder, node)\n \t      /* ... or if we do not partition it. This mean that it will\n \t\t appear in every partition refernecing it.  */\n-\t      || symtab_get_symbol_partitioning_class (node) != SYMBOL_PARTITION)\n+\t      || node->get_partitioning_class () != SYMBOL_PARTITION)\n \t    continue;\n \n           promote_symbol (node);"}, {"sha": "2332225afd4760c8d8f64857f404e32f74df8ed5", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -59,13 +59,13 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \n   /* Merge node flags.  */\n   if (node->force_output)\n-    cgraph_mark_force_output_node (prevailing_node);\n+    prevailing_node->mark_force_output ();\n   if (node->forced_by_abi)\n     prevailing_node->forced_by_abi = true;\n   if (node->address_taken)\n     {\n       gcc_assert (!prevailing_node->global.inlined_to);\n-      cgraph_mark_address_taken_node (prevailing_node);\n+      prevailing_node->mark_address_taken ();\n     }\n \n   /* Redirect all incoming edges.  */\n@@ -90,10 +90,10 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   lto_free_function_in_decl_state_for_node (node);\n \n   if (node->decl != prevailing_node->decl)\n-    cgraph_release_function_body (node);\n+    node->release_body ();\n \n   /* Finally remove the replaced node.  */\n-  cgraph_remove_node (node);\n+  node->remove ();\n }\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n@@ -126,7 +126,7 @@ lto_varpool_replace_node (varpool_node *vnode,\n \t      tls_model_names [prevailing_node->tls_model]);\n     }\n   /* Finally remove the replaced node.  */\n-  varpool_remove_node (vnode);\n+  vnode->remove ();\n }\n \n /* Merge two variable or function symbol table entries PREVAILING and ENTRY.\n@@ -261,7 +261,7 @@ lto_symtab_symbol_p (symtab_node *e)\n {\n   if (!TREE_PUBLIC (e->decl) && !DECL_EXTERNAL (e->decl))\n     return false;\n-  return symtab_real_symbol_p (e);\n+  return e->real_symbol_p ();\n }\n \n /* Return true if the symtab entry E can be the prevailing one.  */\n@@ -445,7 +445,7 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n \t       first->asm_name ());\n       for (e = first; e; e = e->next_sharing_asm_name)\n \tif (TREE_PUBLIC (e->decl))\n-\t  dump_symtab_node (cgraph_dump_file, e);\n+\t  e->dump (cgraph_dump_file);\n     }\n \n   /* Compute the symbol resolutions.  This is a no-op when using the\n@@ -539,7 +539,7 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n     {\n       fprintf (cgraph_dump_file, \"After resolution:\\n\");\n       for (e = prevailing; e; e = e->next_sharing_asm_name)\n-\tdump_symtab_node (cgraph_dump_file, e);\n+\te->dump (cgraph_dump_file);\n     }\n }\n \n@@ -577,9 +577,9 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n \tcontinue;\n       cgraph_node *ce = dyn_cast <cgraph_node *> (e);\n       if (ce && !DECL_BUILT_IN (e->decl))\n-\tlto_cgraph_replace_node (ce, cgraph (prevailing));\n+\tlto_cgraph_replace_node (ce, dyn_cast<cgraph_node *> (prevailing));\n       if (varpool_node *ve = dyn_cast <varpool_node *> (e))\n-\tlto_varpool_replace_node (ve, varpool (prevailing));\n+\tlto_varpool_replace_node (ve, dyn_cast<varpool_node *> (prevailing));\n     }\n \n   return;\n@@ -620,7 +620,7 @@ lto_symtab_merge_symbols (void)\n \t      symtab_node *tgt = symtab_node_for_asm (node->alias_target);\n \t      gcc_assert (node->weakref);\n \t      if (tgt)\n-\t\tsymtab_resolve_alias (node, tgt);\n+\t\tnode->resolve_alias (tgt);\n \t    }\n \t  node->aux = NULL;\n \n@@ -632,7 +632,7 @@ lto_symtab_merge_symbols (void)\n \t\t possible that tree merging unified the declaration.  We\n \t\t do not want duplicate entries in symbol table.  */\n \t      if (cnode && DECL_BUILT_IN (node->decl)\n-\t\t  && (cnode2 = cgraph_get_node (node->decl))\n+\t\t  && (cnode2 = cgraph_node::get (node->decl))\n \t\t  && cnode2 != cnode)\n \t\tlto_cgraph_replace_node (cnode2, cnode);\n \n@@ -641,7 +641,7 @@ lto_symtab_merge_symbols (void)\n \t\t nodes if tree merging occured.  */\n \t      if ((vnode = dyn_cast <varpool_node *> (node))\n \t\t  && DECL_HARD_REGISTER (vnode->decl)\n-\t\t  && (node2 = symtab_get_node (vnode->decl))\n+\t\t  && (node2 = symtab_node::get (vnode->decl))\n \t\t  && node2 != node)\n \t\tlto_varpool_replace_node (dyn_cast <varpool_node *> (node2),\n \t\t\t\t\t  vnode);\n@@ -650,9 +650,9 @@ lto_symtab_merge_symbols (void)\n \t      /* Abstract functions may have duplicated cgraph nodes attached;\n \t\t remove them.  */\n \t      else if (cnode && DECL_ABSTRACT (cnode->decl)\n-\t\t       && (cnode2 = cgraph_get_node (node->decl))\n+\t\t       && (cnode2 = cgraph_node::get (node->decl))\n \t\t       && cnode2 != cnode)\n-\t\tcgraph_remove_node (cnode2);\n+\t\tcnode2->remove ();\n \n \t      node->decl->decl_with_vis.symtab_node = node;\n \t    }"}, {"sha": "683120c0081aa0f33ba5ac8a3046d09912f66045", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -205,7 +205,7 @@ lto_materialize_function (struct cgraph_node *node)\n   decl = node->decl;\n   /* Read in functions with body (analyzed nodes)\n      and also functions that are needed to produce virtual clones.  */\n-  if ((cgraph_function_with_gimple_body_p (node) && node->analyzed)\n+  if ((node->has_gimple_body_p () && node->analyzed)\n       || node->used_as_abstract_origin\n       || has_analyzed_clone_p (node))\n     {\n@@ -3014,7 +3014,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Store resolutions into the symbol table.  */\n \n   FOR_EACH_SYMBOL (snode)\n-    if (symtab_real_symbol_p (snode)\n+    if (snode->real_symbol_p ()\n \t&& snode->lto_file_data\n \t&& snode->lto_file_data->resolution_map\n \t&& (res = pointer_map_contains (snode->lto_file_data->resolution_map,\n@@ -3082,7 +3082,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Before merging:\\n\");\n-      dump_symtab (cgraph_dump_file);\n+      symtab_node::dump_table (cgraph_dump_file);\n     }\n   lto_symtab_merge_symbols ();\n   /* Removal of unreacable symbols is needed to make verify_symtab to pass;\n@@ -3240,7 +3240,7 @@ do_whole_program_analysis (void)\n   cgraph_function_flags_ready = true;\n \n   if (cgraph_dump_file)\n-    dump_symtab (cgraph_dump_file);\n+    symtab_node::dump_table (cgraph_dump_file);\n   bitmap_obstack_initialize (NULL);\n   cgraph_state = CGRAPH_STATE_IPA_SSA;\n \n@@ -3250,10 +3250,10 @@ do_whole_program_analysis (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Optimized \");\n-      dump_symtab (cgraph_dump_file);\n+      symtab_node::dump_table (cgraph_dump_file);\n     }\n #ifdef ENABLE_CHECKING\n-  verify_symtab ();\n+  symtab_node::verify_symtab_nodes ();\n #endif\n   bitmap_obstack_release (NULL);\n "}, {"sha": "df599810fa91b7e6a1029631073c4d5246142c88", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -4650,16 +4650,14 @@ mark_referenced_methods (void)\n       chain = CLASS_CLS_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_force_output_node (\n-\t\t\t   cgraph_get_create_node (METHOD_DEFINITION (chain)));\n+\t  cgraph_node::get_create (METHOD_DEFINITION (chain))->mark_force_output ();\n \t  chain = DECL_CHAIN (chain);\n \t}\n \n       chain = CLASS_NST_METHODS (impent->imp_context);\n       while (chain)\n \t{\n-\t  cgraph_mark_force_output_node (\n-\t\t\t   cgraph_get_create_node (METHOD_DEFINITION (chain)));\n+\t  cgraph_node::get_create (METHOD_DEFINITION (chain))->mark_force_output ();\n \t  chain = DECL_CHAIN (chain);\n \t}\n     }"}, {"sha": "ab515cf59f20759bef48c8b1efb7f49d20735377", "filename": "gcc/omp-low.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1349,7 +1349,7 @@ new_omp_context (gimple stmt, omp_context *outer_ctx)\n     {\n       ctx->cb.src_fn = current_function_decl;\n       ctx->cb.dst_fn = current_function_decl;\n-      ctx->cb.src_node = cgraph_get_node (current_function_decl);\n+      ctx->cb.src_node = cgraph_node::get (current_function_decl);\n       gcc_checking_assert (ctx->cb.src_node);\n       ctx->cb.dst_node = ctx->cb.src_node;\n       ctx->cb.src_cfun = cfun;\n@@ -1397,7 +1397,7 @@ finalize_task_copyfn (gimple task_stmt)\n   pop_cfun ();\n \n   /* Inform the callgraph about the new function.  */\n-  cgraph_add_new_function (child_fn, false);\n+  cgraph_node::add_new_function (child_fn, false);\n }\n \n /* Destroy a omp_context data structures.  Called through the splay tree\n@@ -4903,7 +4903,7 @@ expand_omp_taskreg (struct omp_region *region)\n \n       /* Inform the callgraph about the new function.  */\n       DECL_STRUCT_FUNCTION (child_fn)->curr_properties = cfun->curr_properties;\n-      cgraph_add_new_function (child_fn, true);\n+      cgraph_node::add_new_function (child_fn, true);\n \n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n@@ -8021,7 +8021,7 @@ expand_omp_target (struct omp_region *region)\n \n       /* Inform the callgraph about the new function.  */\n       DECL_STRUCT_FUNCTION (child_fn)->curr_properties = cfun->curr_properties;\n-      cgraph_add_new_function (child_fn, true);\n+      cgraph_node::add_new_function (child_fn, true);\n \n       /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n \t fixed in a following pass.  */\n@@ -9279,7 +9279,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n       memset (&tcctx, '\\0', sizeof (tcctx));\n       tcctx.cb.src_fn = ctx->cb.src_fn;\n       tcctx.cb.dst_fn = child_fn;\n-      tcctx.cb.src_node = cgraph_get_node (tcctx.cb.src_fn);\n+      tcctx.cb.src_node = cgraph_node::get (tcctx.cb.src_fn);\n       gcc_checking_assert (tcctx.cb.src_node);\n       tcctx.cb.dst_node = tcctx.cb.src_node;\n       tcctx.cb.src_cfun = ctx->cb.src_cfun;\n@@ -11038,11 +11038,12 @@ simd_clone_create (struct cgraph_node *old_node)\n   struct cgraph_node *new_node;\n   if (old_node->definition)\n     {\n-      if (!cgraph_function_with_gimple_body_p (old_node))\n+      if (!old_node->has_gimple_body_p ())\n \treturn NULL;\n-      cgraph_get_body (old_node);\n-      new_node = cgraph_function_versioning (old_node, vNULL, NULL, NULL,\n-\t\t\t\t\t     false, NULL, NULL, \"simdclone\");\n+      old_node->get_body ();\n+      new_node = old_node->create_version_clone_with_body (vNULL, NULL, NULL,\n+\t\t\t\t\t\t\t   false, NULL, NULL,\n+\t\t\t\t\t\t\t   \"simdclone\");\n     }\n   else\n     {\n@@ -11053,9 +11054,8 @@ simd_clone_create (struct cgraph_node *old_node)\n       SET_DECL_RTL (new_decl, NULL);\n       DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n       DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n-      new_node\n-\t= cgraph_copy_node_for_versioning (old_node, new_decl, vNULL, NULL);\n-      cgraph_call_function_insertion_hooks (new_node);\n+      new_node = old_node->create_version_clone (new_decl, vNULL, NULL);\n+      new_node->call_function_insertion_hooks ();\n     }\n   if (new_node == NULL)\n     return new_node;\n@@ -11734,8 +11734,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    entry_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \t    int freq = compute_call_stmt_bb_frequency (current_function_decl,\n \t\t\t\t\t\t       entry_bb);\n-\t    cgraph_create_edge (node, cgraph_get_create_node (fn),\n-\t\t\t\tcall, entry_bb->count, freq);\n+\t    node->create_edge (cgraph_node::get_create (fn),\n+\t\t\t       call, entry_bb->count, freq);\n \n \t    imm_use_iterator iter;\n \t    use_operand_p use_p;"}, {"sha": "96d95ac605a65464197231db0671aeae403e8ad7", "filename": "gcc/passes.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1080,7 +1080,7 @@ is_pass_explicitly_enabled_or_disabled (opt_pass *pass,\n   if (!slot)\n     return false;\n \n-  cgraph_uid = func ? cgraph_get_node (func)->uid : 0;\n+  cgraph_uid = func ? cgraph_node::get (func)->uid : 0;\n   if (func && DECL_ASSEMBLER_NAME_SET_P (func))\n     aname = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (func));\n \n@@ -1488,7 +1488,7 @@ do_per_function (void (*callback) (function *, void *data), void *data)\n    keep the array visible to garbage collector to avoid reading collected\n    out nodes.  */\n static int nnodes;\n-static GTY ((length (\"nnodes\"))) cgraph_node_ptr *order;\n+static GTY ((length (\"nnodes\"))) cgraph_node **order;\n \n /* If we are in IPA mode (i.e., current_function_decl is NULL), call\n    function CALLBACK for every function in the call graph.  Otherwise,\n@@ -1504,7 +1504,7 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)\n   else\n     {\n       gcc_assert (!order);\n-      order = ggc_vec_alloc<cgraph_node_ptr> (cgraph_n_nodes);\n+      order = ggc_vec_alloc<cgraph_node *> (cgraph_n_nodes);\n       nnodes = ipa_reverse_postorder (order);\n       for (i = nnodes - 1; i >= 0; i--)\n         order[i]->process = 1;\n@@ -1515,7 +1515,7 @@ do_per_function_toporder (void (*callback) (function *, void *data), void *data)\n \t  /* Allow possibly removed nodes to be garbage collected.  */\n \t  order[i] = NULL;\n \t  node->process = 0;\n-\t  if (cgraph_function_with_gimple_body_p (node))\n+\t  if (node->has_gimple_body_p ())\n \t    callback (DECL_STRUCT_FUNCTION (node->decl), data);\n \t}\n     }\n@@ -1818,7 +1818,7 @@ execute_todo (unsigned int flags)\n   if ((flags & TODO_dump_symtab) && dump_file && !current_function_decl)\n     {\n       gcc_assert (!cfun);\n-      dump_symtab (dump_file);\n+      symtab_node::dump_table (dump_file);\n       /* Flush the file.  If verification fails, we won't be able to\n \t close the file before aborting.  */\n       fflush (dump_file);\n@@ -2015,7 +2015,7 @@ execute_all_ipa_transforms (void)\n   struct cgraph_node *node;\n   if (!cfun)\n     return;\n-  node = cgraph_get_node (current_function_decl);\n+  node = cgraph_node::get (current_function_decl);\n \n   if (node->ipa_transforms_to_apply.exists ())\n     {\n@@ -2102,13 +2102,13 @@ execute_one_pass (opt_pass *pass)\n       bool applied = false;\n       FOR_EACH_DEFINED_FUNCTION (node)\n \tif (node->analyzed\n-\t    && cgraph_function_with_gimple_body_p (node)\n+\t    && node->has_gimple_body_p ()\n \t    && (!node->clone_of || node->decl != node->clone_of->decl))\n \t  {\n \t    if (!node->global.inlined_to\n \t\t&& node->ipa_transforms_to_apply.exists ())\n \t      {\n-\t\tcgraph_get_body (node);\n+\t\tnode->get_body ();\n \t\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t\texecute_all_ipa_transforms ();\n \t\trebuild_cgraph_edges ();\n@@ -2320,7 +2320,7 @@ ipa_write_summaries (void)\n     {\n       struct cgraph_node *node = order[i];\n \n-      if (cgraph_function_with_gimple_body_p (node))\n+      if (node->has_gimple_body_p ())\n \t{\n \t  /* When streaming out references to statements as part of some IPA\n \t     pass summary, the statements need to have uids assigned and the\n@@ -2648,13 +2648,13 @@ bool\n function_called_by_processed_nodes_p (void)\n {\n   struct cgraph_edge *e;\n-  for (e = cgraph_get_node (current_function_decl)->callers;\n+  for (e = cgraph_node::get (current_function_decl)->callers;\n        e;\n        e = e->next_caller)\n     {\n       if (e->caller->decl == current_function_decl)\n         continue;\n-      if (!cgraph_function_with_gimple_body_p (e->caller))\n+      if (!e->caller->has_gimple_body_p ())\n         continue;\n       if (TREE_ASM_WRITTEN (e->caller->decl))\n         continue;\n@@ -2664,7 +2664,7 @@ function_called_by_processed_nodes_p (void)\n   if (dump_file && e)\n     {\n       fprintf (dump_file, \"Already processed call to:\\n\");\n-      dump_cgraph_node (dump_file, e->caller);\n+      e->caller->dump (dump_file);\n     }\n   return e != NULL;\n }"}, {"sha": "72a3b53bd71038a6736afc4d88836d4b9ba57bd0", "filename": "gcc/predict.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -113,7 +113,7 @@ static const struct predictor_info predictor_info[]= {\n static inline bool\n maybe_hot_frequency_p (struct function *fun, int freq)\n {\n-  struct cgraph_node *node = cgraph_get_node (fun->decl);\n+  struct cgraph_node *node = cgraph_node::get (fun->decl);\n   if (!profile_info || !flag_branch_probabilities)\n     {\n       if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n@@ -275,7 +275,7 @@ probably_never_executed (struct function *fun,\n       return true;\n     }\n   if ((!profile_info || !flag_branch_probabilities)\n-      && (cgraph_get_node (fun->decl)->frequency\n+      && (cgraph_node::get (fun->decl)->frequency\n \t  == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n     return true;\n   return false;\n@@ -299,14 +299,14 @@ probably_never_executed_edge_p (struct function *fun, edge e)\n   return probably_never_executed (fun, e->count, EDGE_FREQUENCY (e));\n }\n \n-/* Return true if NODE should be optimized for size.  */\n+/* Return true if function should be optimized for size.  */\n \n bool\n-cgraph_optimize_for_size_p (struct cgraph_node *node)\n+cgraph_node::optimize_for_size_p (void)\n {\n   if (optimize_size)\n     return true;\n-  if (node && (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n+  if (frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n     return true;\n   else\n     return false;\n@@ -321,7 +321,9 @@ optimize_function_for_size_p (struct function *fun)\n     return true;\n   if (!fun || !fun->decl)\n     return false;\n-  return cgraph_optimize_for_size_p (cgraph_get_node (fun->decl));\n+\n+  cgraph_node *n = cgraph_node::get (fun->decl);\n+  return n && n->optimize_for_size_p ();\n }\n \n /* Return true when current function should always be optimized for speed.  */\n@@ -2983,7 +2985,7 @@ void\n compute_function_frequency (void)\n {\n   basic_block bb;\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n \n   if (DECL_STATIC_CONSTRUCTOR (current_function_decl)\n       || MAIN_NAME_P (DECL_NAME (current_function_decl)))"}, {"sha": "3d8186f1b5f523f63ff159a6a2f7d8f6526ece2c", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -918,9 +918,8 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n          the corresponding call graph node.  */\n       if (hist->type == HIST_TYPE_TIME_PROFILE)\n         {\n-          node = cgraph_get_node (hist->fun->decl);\n-\n-          node->tp_first_run = hist->hvalue.counters[0];\n+\t  node = cgraph_node::get (hist->fun->decl);\n+\t  node->tp_first_run = hist->hvalue.counters[0];\n \n           if (dump_file)\n             fprintf (dump_file, \"Read tp_first_run: %d\\n\", node->tp_first_run);"}, {"sha": "8f04758da0a94144de2ffc4d4b5cf6145853463c", "filename": "gcc/symtab.c", "status": "modified", "additions": 411, "deletions": 420, "changes": 831, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -272,111 +272,6 @@ symtab_prevail_in_asm_name_hash (symtab_node *node)\n   insert_to_assembler_name_hash (node, false);\n }\n \n-\n-/* Add node into symbol table.  This function is not used directly, but via\n-   cgraph/varpool node creation routines.  */\n-\n-void\n-symtab_register_node (symtab_node *node)\n-{\n-  node->next = symtab_nodes;\n-  node->previous = NULL;\n-  if (symtab_nodes)\n-    symtab_nodes->previous = node;\n-  symtab_nodes = node;\n-\n-  if (!node->decl->decl_with_vis.symtab_node)\n-    node->decl->decl_with_vis.symtab_node = node;\n-\n-  node->ref_list.clear ();\n-\n-  node->order = symtab_order++;\n-\n-  /* Be sure to do this last; C++ FE might create new nodes via\n-     DECL_ASSEMBLER_NAME langhook!  */\n-  insert_to_assembler_name_hash (node, false);\n-}\n-\n-/* Remove NODE from same comdat group.   */\n-\n-void\n-symtab_remove_from_same_comdat_group (symtab_node *node)\n-{\n-  if (node->same_comdat_group)\n-    {\n-      symtab_node *prev;\n-      for (prev = node->same_comdat_group;\n-\t   prev->same_comdat_group != node;\n-\t   prev = prev->same_comdat_group)\n-\t;\n-      if (node->same_comdat_group == prev)\n-\tprev->same_comdat_group = NULL;\n-      else\n-\tprev->same_comdat_group = node->same_comdat_group;\n-      node->same_comdat_group = NULL;\n-      node->set_comdat_group (NULL_TREE);\n-    }\n-}\n-\n-/* Remove node from symbol table.  This function is not used directly, but via\n-   cgraph/varpool node removal routines.  */\n-\n-void\n-symtab_unregister_node (symtab_node *node)\n-{\n-  node->remove_all_references ();\n-  node->remove_all_referring ();\n-\n-  /* Remove reference to section.  */\n-  node->set_section_for_node (NULL);\n-\n-  symtab_remove_from_same_comdat_group (node);\n-\n-  if (node->previous)\n-    node->previous->next = node->next;\n-  else\n-    symtab_nodes = node->next;\n-  if (node->next)\n-    node->next->previous = node->previous;\n-  node->next = NULL;\n-  node->previous = NULL;\n-\n-  /* During LTO symtab merging we temporarily corrupt decl to symtab node\n-     hash.  */\n-  gcc_assert (node->decl->decl_with_vis.symtab_node || in_lto_p);\n-  if (node->decl->decl_with_vis.symtab_node == node)\n-    {\n-      symtab_node *replacement_node = NULL;\n-      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n-\treplacement_node = cgraph_find_replacement_node (cnode);\n-      node->decl->decl_with_vis.symtab_node = replacement_node;\n-    }\n-  if (!is_a <varpool_node *> (node) || !DECL_HARD_REGISTER (node->decl))\n-    unlink_from_assembler_name_hash (node, false);\n-  if (node->in_init_priority_hash)\n-    {\n-      struct symbol_priority_map in;\n-      void **slot;\n-      in.symbol = node;\n-\n-      slot = htab_find_slot (init_priority_hash, &in, NO_INSERT);\n-      if (slot)\n-\thtab_clear_slot (init_priority_hash, slot);\n-    }\n-}\n-\n-\n-/* Remove symtab NODE from the symbol table.  */\n-\n-void\n-symtab_remove_node (symtab_node *node)\n-{\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n-    cgraph_remove_node (cnode);\n-  else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n-    varpool_remove_node (vnode);\n-}\n-\n /* Initalize asm name hash unless.  */\n \n void\n@@ -427,7 +322,7 @@ change_decl_assembler_name (tree decl, tree name)\n   if ((TREE_CODE (decl) == VAR_DECL\n        && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n       || TREE_CODE (decl) == FUNCTION_DECL)\n-    node = symtab_get_node (decl);\n+    node = symtab_node::get (decl);\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n     {\n       SET_DECL_ASSEMBLER_NAME (decl, name);\n@@ -459,40 +354,174 @@ change_decl_assembler_name (tree decl, tree name)\n     }\n }\n \n+/* Return true when RESOLUTION indicate that linker will use\n+   the symbol from non-LTO object files.  */\n+\n+bool\n+resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n+{\n+  return (resolution == LDPR_PREVAILING_DEF\n+\t  || resolution == LDPR_PREEMPTED_REG\n+\t  || resolution == LDPR_RESOLVED_EXEC\n+\t  || resolution == LDPR_RESOLVED_DYN);\n+}\n+\n+/* Hash sections by their names.  */\n+\n+static hashval_t\n+hash_section_hash_entry (const void *p)\n+{\n+  const section_hash_entry *n = (const section_hash_entry *) p;\n+  return htab_hash_string (n->name);\n+}\n+\n+/* Return true if section P1 name equals to P2.  */\n+\n+static int\n+eq_sections (const void *p1, const void *p2)\n+{\n+  const section_hash_entry *n1 = (const section_hash_entry *) p1;\n+  const char *name = (const char *)p2;\n+  return n1->name == name || !strcmp (n1->name, name);\n+}\n+\n+/* Add node into symbol table.  This function is not used directly, but via\n+   cgraph/varpool node creation routines.  */\n+\n+void\n+symtab_node::register_symbol (void)\n+{\n+  next = symtab_nodes;\n+  previous = NULL;\n+  if (symtab_nodes)\n+    symtab_nodes->previous = this;\n+  symtab_nodes = this;\n+\n+  if (!decl->decl_with_vis.symtab_node)\n+    decl->decl_with_vis.symtab_node = this;\n+\n+  ref_list.clear ();\n+\n+  order = symtab_order++;\n+\n+  /* Be sure to do this last; C++ FE might create new nodes via\n+     DECL_ASSEMBLER_NAME langhook!  */\n+  insert_to_assembler_name_hash (this, false);\n+}\n+\n+/* Remove NODE from same comdat group.   */\n+\n+void\n+symtab_node::remove_from_same_comdat_group (void)\n+{\n+  if (same_comdat_group)\n+    {\n+      symtab_node *prev;\n+      for (prev = same_comdat_group;\n+\t   prev->same_comdat_group != this;\n+\t   prev = prev->same_comdat_group)\n+\t;\n+      if (same_comdat_group == prev)\n+\tprev->same_comdat_group = NULL;\n+      else\n+\tprev->same_comdat_group = same_comdat_group;\n+      same_comdat_group = NULL;\n+      set_comdat_group (NULL);\n+    }\n+}\n+\n+/* Remove node from symbol table.  This function is not used directly, but via\n+   cgraph/varpool node removal routines.  */\n+\n+void\n+symtab_node::unregister (void)\n+{\n+  remove_all_references ();\n+  remove_all_referring ();\n+\n+  /* Remove reference to section.  */\n+  set_section_for_node (NULL);\n+\n+  remove_from_same_comdat_group ();\n+\n+  if (previous)\n+    previous->next = next;\n+  else\n+    symtab_nodes = next;\n+  if (next)\n+    next->previous = previous;\n+  next = NULL;\n+  previous = NULL;\n+\n+  /* During LTO symtab merging we temporarily corrupt decl to symtab node\n+     hash.  */\n+  gcc_assert (decl->decl_with_vis.symtab_node || in_lto_p);\n+  if (decl->decl_with_vis.symtab_node == this)\n+    {\n+      symtab_node *replacement_node = NULL;\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (this))\n+\treplacement_node = cnode->find_replacement ();\n+      decl->decl_with_vis.symtab_node = replacement_node;\n+    }\n+  if (!is_a <varpool_node *> (this) || !DECL_HARD_REGISTER (decl))\n+    unlink_from_assembler_name_hash (this, false);\n+  if (in_init_priority_hash)\n+    {\n+      struct symbol_priority_map in;\n+      void **slot;\n+      in.symbol = this;\n+\n+      slot = htab_find_slot (init_priority_hash, &in, NO_INSERT);\n+      if (slot)\n+\thtab_clear_slot (init_priority_hash, slot);\n+    }\n+}\n+\n+\n+/* Remove symbol from symbol table.  */\n+\n+void\n+symtab_node::remove (void)\n+{\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (this))\n+    cnode->remove ();\n+  else if (varpool_node *vnode = dyn_cast <varpool_node *> (this))\n+    vnode->remove ();\n+}\n+\n /* Add NEW_ to the same comdat group that OLD is in.  */\n \n void\n-symtab_add_to_same_comdat_group (symtab_node *new_node,\n-\t\t\t\t symtab_node *old_node)\n+symtab_node::add_to_same_comdat_group (symtab_node *old_node)\n {\n   gcc_assert (old_node->get_comdat_group ());\n-  gcc_assert (!new_node->same_comdat_group);\n-  gcc_assert (new_node != old_node);\n+  gcc_assert (!same_comdat_group);\n+  gcc_assert (this != old_node);\n \n-  new_node->set_comdat_group (old_node->get_comdat_group ());\n-  new_node->same_comdat_group = old_node;\n+  set_comdat_group (old_node->get_comdat_group ());\n+  same_comdat_group = old_node;\n   if (!old_node->same_comdat_group)\n-    old_node->same_comdat_group = new_node;\n+    old_node->same_comdat_group = this;\n   else\n     {\n       symtab_node *n;\n       for (n = old_node->same_comdat_group;\n \t   n->same_comdat_group != old_node;\n \t   n = n->same_comdat_group)\n \t;\n-      n->same_comdat_group = new_node;\n+      n->same_comdat_group = this;\n     }\n }\n \n /* Dissolve the same_comdat_group list in which NODE resides.  */\n \n void\n-symtab_dissolve_same_comdat_group_list (symtab_node *node)\n+symtab_node::dissolve_same_comdat_group_list (void)\n {\n-  symtab_node *n = node;\n+  symtab_node *n = this;\n   symtab_node *next;\n \n-  if (!node->same_comdat_group)\n+  if (!same_comdat_group)\n     return;\n   do\n     {\n@@ -504,7 +533,7 @@ symtab_dissolve_same_comdat_group_list (symtab_node *node)\n \tn->set_comdat_group (NULL);\n       n = next;\n     }\n-  while (n != node);\n+  while (n != this);\n }\n \n /* Return printable assembler name of NODE.\n@@ -609,7 +638,7 @@ symtab_node::maybe_add_reference (tree val, enum ipa_ref_use use_type,\n   if (val && (TREE_CODE (val) == FUNCTION_DECL\n \t       || TREE_CODE (val) == VAR_DECL))\n     {\n-      symtab_node *referred = symtab_get_node (val);\n+      symtab_node *referred = symtab_node::get (val);\n       gcc_checking_assert (referred);\n       return add_reference (referred, use_type, stmt);\n     }\n@@ -825,184 +854,172 @@ symtab_node::iterate_direct_aliases (unsigned i, struct ipa_ref *&ref)\n   return ref;\n }\n \n-\n static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\"};\n \n-/* Dump base fields of symtab nodes.  Not to be used directly.  */\n+/* Dump base fields of symtab nodes to F.  Not to be used directly.  */\n \n void\n-dump_symtab_base (FILE *f, symtab_node *node)\n+symtab_node::dump_base (FILE *f)\n {\n   static const char * const visibility_types[] = {\n     \"default\", \"protected\", \"hidden\", \"internal\"\n   };\n \n-  fprintf (f, \"%s/%i (%s)\",\n-\t   node->asm_name (),\n-\t   node->order,\n-\t   node->name ());\n-  dump_addr (f, \" @\", (void *)node);\n-  fprintf (f, \"\\n  Type: %s\", symtab_type_names[node->type]);\n+  fprintf (f, \"%s/%i (%s)\", asm_name (), order, name ());\n+  dump_addr (f, \" @\", (void *)this);\n+  fprintf (f, \"\\n  Type: %s\", symtab_type_names[type]);\n \n-  if (node->definition)\n+  if (definition)\n     fprintf (f, \" definition\");\n-  if (node->analyzed)\n+  if (analyzed)\n     fprintf (f, \" analyzed\");\n-  if (node->alias)\n+  if (alias)\n     fprintf (f, \" alias\");\n-  if (node->weakref)\n+  if (weakref)\n     fprintf (f, \" weakref\");\n-  if (node->cpp_implicit_alias)\n+  if (cpp_implicit_alias)\n     fprintf (f, \" cpp_implicit_alias\");\n-  if (node->alias_target)\n+  if (alias_target)\n     fprintf (f, \" target:%s\",\n-\t     DECL_P (node->alias_target) \n+\t     DECL_P (alias_target)\n \t     ? IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME\n-\t\t\t\t     (node->alias_target))\n-\t     : IDENTIFIER_POINTER (node->alias_target));\n-  if (node->body_removed)\n+\t\t\t\t     (alias_target))\n+\t     : IDENTIFIER_POINTER (alias_target));\n+  if (body_removed)\n     fprintf (f, \"\\n  Body removed by symtab_remove_unreachable_nodes\");\n   fprintf (f, \"\\n  Visibility:\");\n-  if (node->in_other_partition)\n+  if (in_other_partition)\n     fprintf (f, \" in_other_partition\");\n-  if (node->used_from_other_partition)\n+  if (used_from_other_partition)\n     fprintf (f, \" used_from_other_partition\");\n-  if (node->force_output)\n+  if (force_output)\n     fprintf (f, \" force_output\");\n-  if (node->forced_by_abi)\n+  if (forced_by_abi)\n     fprintf (f, \" forced_by_abi\");\n-  if (node->externally_visible)\n+  if (externally_visible)\n     fprintf (f, \" externally_visible\");\n-  if (node->resolution != LDPR_UNKNOWN)\n+  if (resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n- \t     ld_plugin_symbol_resolution_names[(int)node->resolution]);\n-  if (TREE_ASM_WRITTEN (node->decl))\n+ \t     ld_plugin_symbol_resolution_names[(int)resolution]);\n+  if (TREE_ASM_WRITTEN (decl))\n     fprintf (f, \" asm_written\");\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (decl))\n     fprintf (f, \" external\");\n-  if (TREE_PUBLIC (node->decl))\n+  if (TREE_PUBLIC (decl))\n     fprintf (f, \" public\");\n-  if (DECL_COMMON (node->decl))\n+  if (DECL_COMMON (decl))\n     fprintf (f, \" common\");\n-  if (DECL_WEAK (node->decl))\n+  if (DECL_WEAK (decl))\n     fprintf (f, \" weak\");\n-  if (DECL_DLLIMPORT_P (node->decl))\n+  if (DECL_DLLIMPORT_P (decl))\n     fprintf (f, \" dll_import\");\n-  if (DECL_COMDAT (node->decl))\n+  if (DECL_COMDAT (decl))\n     fprintf (f, \" comdat\");\n-  if (node->get_comdat_group ())\n+  if (get_comdat_group ())\n     fprintf (f, \" comdat_group:%s\",\n-\t     IDENTIFIER_POINTER (node->get_comdat_group_id ()));\n-  if (DECL_ONE_ONLY (node->decl))\n+\t     IDENTIFIER_POINTER (get_comdat_group_id ()));\n+  if (DECL_ONE_ONLY (decl))\n     fprintf (f, \" one_only\");\n-  if (node->get_section ())\n+  if (get_section ())\n     fprintf (f, \" section:%s\",\n-\t     node->get_section ());\n-  if (node->implicit_section)\n+\t     get_section ());\n+  if (implicit_section)\n     fprintf (f,\" (implicit_section)\");\n-  if (DECL_VISIBILITY_SPECIFIED (node->decl))\n+  if (DECL_VISIBILITY_SPECIFIED (decl))\n     fprintf (f, \" visibility_specified\");\n-  if (DECL_VISIBILITY (node->decl))\n+  if (DECL_VISIBILITY (decl))\n     fprintf (f, \" visibility:%s\",\n-\t     visibility_types [DECL_VISIBILITY (node->decl)]);\n-  if (DECL_VIRTUAL_P (node->decl))\n+\t     visibility_types [DECL_VISIBILITY (decl)]);\n+  if (DECL_VIRTUAL_P (decl))\n     fprintf (f, \" virtual\");\n-  if (DECL_ARTIFICIAL (node->decl))\n+  if (DECL_ARTIFICIAL (decl))\n     fprintf (f, \" artificial\");\n-  if (TREE_CODE (node->decl) == FUNCTION_DECL)\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n+      if (DECL_STATIC_CONSTRUCTOR (decl))\n \tfprintf (f, \" constructor\");\n-      if (DECL_STATIC_DESTRUCTOR (node->decl))\n+      if (DECL_STATIC_DESTRUCTOR (decl))\n \tfprintf (f, \" destructor\");\n     }\n   fprintf (f, \"\\n\");\n   \n-  if (node->same_comdat_group)\n+  if (same_comdat_group)\n     fprintf (f, \"  Same comdat group as: %s/%i\\n\",\n-\t     node->same_comdat_group->asm_name (),\n-\t     node->same_comdat_group->order);\n-  if (node->next_sharing_asm_name)\n+\t     same_comdat_group->asm_name (),\n+\t     same_comdat_group->order);\n+  if (next_sharing_asm_name)\n     fprintf (f, \"  next sharing asm name: %i\\n\",\n-\t     node->next_sharing_asm_name->order);\n-  if (node->previous_sharing_asm_name)\n+\t     next_sharing_asm_name->order);\n+  if (previous_sharing_asm_name)\n     fprintf (f, \"  previous sharing asm name: %i\\n\",\n-\t     node->previous_sharing_asm_name->order);\n+\t     previous_sharing_asm_name->order);\n \n-  if (node->address_taken)\n+  if (address_taken)\n     fprintf (f, \"  Address is taken.\\n\");\n-  if (node->aux)\n+  if (aux)\n     {\n       fprintf (f, \"  Aux:\");\n-      dump_addr (f, \" @\", (void *)node->aux);\n+      dump_addr (f, \" @\", (void *)aux);\n     }\n \n   fprintf (f, \"  References: \");\n-  node->dump_references (f);\n+  dump_references (f);\n   fprintf (f, \"  Referring: \");\n-  node->dump_referring (f);\n-  if (node->lto_file_data)\n+  dump_referring (f);\n+  if (lto_file_data)\n     fprintf (f, \"  Read from file: %s\\n\",\n-\t     node->lto_file_data->file_name);\n+\t     lto_file_data->file_name);\n }\n \n-/* Dump symtab node.  */\n+/* Dump symtab node to F.  */\n \n void\n-dump_symtab_node (FILE *f, symtab_node *node)\n+symtab_node::dump (FILE *f)\n {\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n-    dump_cgraph_node (f, cnode);\n-  else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n-    dump_varpool_node (f, vnode);\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (this))\n+    cnode->dump (f);\n+  else if (varpool_node *vnode = dyn_cast <varpool_node *> (this))\n+    vnode->dump (f);\n }\n \n-/* Dump symbol table.  */\n+/* Dump symbol table to F.  */\n \n void\n-dump_symtab (FILE *f)\n+symtab_node::dump_table (FILE *f)\n {\n   symtab_node *node;\n   fprintf (f, \"Symbol table:\\n\\n\");\n   FOR_EACH_SYMBOL (node)\n-    dump_symtab_node (f, node);\n+    node->dump (f);\n }\n \n /* Dump symtab node NODE to stderr.  */\n \n DEBUG_FUNCTION void\n-debug_symtab_node (symtab_node *node)\n-{\n-  dump_symtab_node (stderr, node);\n-}\n-\n-/* Dump symbol table to stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_symtab (void)\n+symtab_node::debug (void)\n {\n-  dump_symtab (stderr);\n+  dump (stderr);\n }\n \n /* Verify common part of symtab nodes.  */\n \n DEBUG_FUNCTION bool\n-verify_symtab_base (symtab_node *node)\n+symtab_node::verify_base (void)\n {\n   bool error_found = false;\n   symtab_node *hashed_node;\n \n-  if (is_a <cgraph_node *> (node))\n+  if (is_a <cgraph_node *> (this))\n     {\n-      if (TREE_CODE (node->decl) != FUNCTION_DECL)\n+      if (TREE_CODE (decl) != FUNCTION_DECL)\n \t{\n           error (\"function symbol is not function\");\n           error_found = true;\n \t}\n     }\n-  else if (is_a <varpool_node *> (node))\n+  else if (is_a <varpool_node *> (this))\n     {\n-      if (TREE_CODE (node->decl) != VAR_DECL)\n+      if (TREE_CODE (decl) != VAR_DECL)\n \t{\n           error (\"variable symbol is not variable\");\n           error_found = true;\n@@ -1016,81 +1033,79 @@ verify_symtab_base (symtab_node *node)\n    \n   if (cgraph_state != CGRAPH_LTO_STREAMING)\n     {\n-      hashed_node = symtab_get_node (node->decl);\n+      hashed_node = symtab_node::get (decl);\n       if (!hashed_node)\n \t{\n \t  error (\"node not found node->decl->decl_with_vis.symtab_node\");\n \t  error_found = true;\n \t}\n-      if (hashed_node != node\n-\t  && (!is_a <cgraph_node *> (node)\n-\t      || !dyn_cast <cgraph_node *> (node)->clone_of\n-\t      || dyn_cast <cgraph_node *> (node)->clone_of->decl\n-\t\t != node->decl))\n+      if (hashed_node != this\n+\t  && (!is_a <cgraph_node *> (this)\n+\t      || !dyn_cast <cgraph_node *> (this)->clone_of\n+\t      || dyn_cast <cgraph_node *> (this)->clone_of->decl != decl))\n \t{\n \t  error (\"node differs from node->decl->decl_with_vis.symtab_node\");\n \t  error_found = true;\n \t}\n     }\n   if (assembler_name_hash)\n     {\n-      hashed_node = symtab_node_for_asm (DECL_ASSEMBLER_NAME (node->decl));\n+      hashed_node = symtab_node_for_asm (DECL_ASSEMBLER_NAME (decl));\n       if (hashed_node && hashed_node->previous_sharing_asm_name)\n \t{\n           error (\"assembler name hash list corrupted\");\n           error_found = true;\n \t}\n       while (hashed_node)\n \t{\n-\t  if (hashed_node == node)\n+\t  if (hashed_node == this)\n \t    break;\n \t  hashed_node = hashed_node->next_sharing_asm_name;\n \t}\n       if (!hashed_node\n-          && !(is_a <varpool_node *> (node)\n-\t       || DECL_HARD_REGISTER (node->decl)))\n+\t  && !(is_a <varpool_node *> (this)\n+\t       || DECL_HARD_REGISTER (decl)))\n \t{\n           error (\"node not found in symtab assembler name hash\");\n           error_found = true;\n \t}\n     }\n-  if (node->previous_sharing_asm_name\n-      && node->previous_sharing_asm_name->next_sharing_asm_name != node)\n+  if (previous_sharing_asm_name\n+      && previous_sharing_asm_name->next_sharing_asm_name != this)\n     {\n       error (\"double linked list of assembler names corrupted\");\n       error_found = true;\n     }\n-  if (node->analyzed && !node->definition)\n+  if (analyzed && !definition)\n     {\n       error (\"node is analyzed byt it is not a definition\");\n       error_found = true;\n     }\n-  if (node->cpp_implicit_alias && !node->alias)\n+  if (cpp_implicit_alias && !alias)\n     {\n       error (\"node is alias but not implicit alias\");\n       error_found = true;\n     }\n-  if (node->alias && !node->definition\n-      && !node->weakref)\n+  if (alias && !definition && !weakref)\n     {\n       error (\"node is alias but not definition\");\n       error_found = true;\n     }\n-  if (node->weakref && !node->alias)\n+  if (weakref && !alias)\n     {\n       error (\"node is weakref but not an alias\");\n       error_found = true;\n     }\n-  if (node->same_comdat_group)\n+  if (same_comdat_group)\n     {\n-      symtab_node *n = node->same_comdat_group;\n+      symtab_node *n = same_comdat_group;\n \n       if (!n->get_comdat_group ())\n \t{\n \t  error (\"node is in same_comdat_group list but has no comdat_group\");\n \t  error_found = true;\n \t}\n-      if (n->get_comdat_group () != node->get_comdat_group ())\n+      if (n->get_comdat_group () != get_comdat_group ())\n \t{\n \t  error (\"same_comdat_group list across different groups\");\n \t  error_found = true;\n@@ -1100,12 +1115,12 @@ verify_symtab_base (symtab_node *node)\n \t  error (\"Node has same_comdat_group but it is not a definition\");\n \t  error_found = true;\n \t}\n-      if (n->type != node->type)\n+      if (n->type != type)\n \t{\n \t  error (\"mixing different types of symbol in same comdat groups is not supported\");\n \t  error_found = true;\n \t}\n-      if (n == node)\n+      if (n == this)\n \t{\n \t  error (\"node is alone in a comdat group\");\n \t  error_found = true;\n@@ -1120,14 +1135,14 @@ verify_symtab_base (symtab_node *node)\n \t    }\n \t  n = n->same_comdat_group;\n \t}\n-      while (n != node);\n-      if (symtab_comdat_local_p (node))\n+      while (n != this);\n+      if (comdat_local_p ())\n \t{\n \t  struct ipa_ref *ref = NULL;\n \n-\t  for (int i = 0; node->iterate_referring (i, ref); ++i)\n+\t  for (int i = 0; iterate_referring (i, ref); ++i)\n \t    {\n-\t      if (!symtab_in_same_comdat_p (ref->referring, node))\n+\t      if (!in_same_comdat_group_p (ref->referring))\n \t\t{\n \t\t  error (\"comdat-local symbol referred to by %s outside its \"\n \t\t\t \"comdat\",\n@@ -1137,35 +1152,35 @@ verify_symtab_base (symtab_node *node)\n \t    }\n \t}\n     }\n-  if (node->implicit_section && !node->get_section ())\n+  if (implicit_section && !get_section ())\n     {\n       error (\"implicit_section flag is set but section isn't\");\n       error_found = true;\n     }\n-  if (node->get_section () && node->get_comdat_group ()\n-      && !node->implicit_section)\n+  if (get_section () && get_comdat_group ()\n+      && !implicit_section)\n     {\n       error (\"Both section and comdat group is set\");\n       error_found = true;\n     }\n   /* TODO: Add string table for sections, so we do not keep holding duplicated\n      strings.  */\n-  if (node->alias && node->definition\n-      && node->get_section () != symtab_alias_target (node)->get_section ()\n-      && (!node->get_section()\n-\t  || !symtab_alias_target (node)->get_section ()\n-\t  || strcmp (node->get_section(),\n-\t\t     symtab_alias_target (node)->get_section ())))\n+  if (alias && definition\n+      && get_section () != get_alias_target ()->get_section ()\n+      && (!get_section()\n+\t  || !get_alias_target ()->get_section ()\n+\t  || strcmp (get_section(),\n+\t\t     get_alias_target ()->get_section ())))\n     {\n       error (\"Alias and target's section differs\");\n-      dump_symtab_node (stderr, symtab_alias_target (node));\n+      get_alias_target ()->dump (stderr);\n       error_found = true;\n     }\n-  if (node->alias && node->definition\n-      && node->get_comdat_group () != symtab_alias_target (node)->get_comdat_group ())\n+  if (alias && definition\n+      && get_comdat_group () != get_alias_target ()->get_comdat_group ())\n     {\n       error (\"Alias and target's comdat groups differs\");\n-      dump_symtab_node (stderr, symtab_alias_target (node));\n+      get_alias_target ()->dump (stderr);\n       error_found = true;\n     }\n \n@@ -1175,34 +1190,34 @@ verify_symtab_base (symtab_node *node)\n /* Verify consistency of NODE.  */\n \n DEBUG_FUNCTION void\n-verify_symtab_node (symtab_node *node)\n+symtab_node::verify (void)\n {\n   if (seen_error ())\n     return;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n-    verify_cgraph_node (cnode);\n+  if (cgraph_node *node = dyn_cast <cgraph_node *> (this))\n+    node->verify_node ();\n   else\n-    if (verify_symtab_base (node))\n+    if (verify_base ())\n       {\n-        dump_symtab_node (stderr, node);\n-        internal_error (\"verify_symtab_node failed\");\n+\tdebug ();\n+\tinternal_error (\"symtab_node::verify failed\");\n       }\n   timevar_pop (TV_CGRAPH_VERIFY);\n }\n \n /* Verify symbol table for internal consistency.  */\n \n DEBUG_FUNCTION void\n-verify_symtab (void)\n+symtab_node::verify_symtab_nodes (void)\n {\n   symtab_node *node;\n   hash_map<tree, symtab_node *> comdat_head_map (251);\n \n   FOR_EACH_SYMBOL (node)\n     {\n-      verify_symtab_node (node);\n+      node->verify ();\n       if (node->get_comdat_group ())\n \t{\n \t  symtab_node **entry, *s;\n@@ -1217,31 +1232,19 @@ verify_symtab (void)\n \t      if (!s || s == *entry)\n \t\t{\n \t\t  error (\"Two symbols with same comdat_group are not linked by the same_comdat_group list.\");\n-\t\t  dump_symtab_node (stderr, *entry);\n-\t\t  dump_symtab_node (stderr, node);\n-\t\t  internal_error (\"verify_symtab failed\");\n+\t\t  (*entry)->debug ();\n+\t\t  node->debug ();\n+\t\t  internal_error (\"symtab_node::verify failed\");\n \t\t}\n \t}\n     }\n }\n \n-/* Return true when RESOLUTION indicate that linker will use\n-   the symbol from non-LTO object files.  */\n-\n-bool\n-resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n-{\n-  return (resolution == LDPR_PREVAILING_DEF\n-          || resolution == LDPR_PREEMPTED_REG\n-          || resolution == LDPR_RESOLVED_EXEC\n-          || resolution == LDPR_RESOLVED_DYN);\n-}\n-\n-/* Return true when NODE is known to be used from other (non-LTO) object file.\n-   Known only when doing LTO via linker plugin.  */\n+/* Return true when NODE is known to be used from other (non-LTO)\n+   object file. Known only when doing LTO via linker plugin.  */\n \n bool\n-symtab_used_from_object_file_p (symtab_node *node)\n+symtab_node::used_from_object_file_p_worker (symtab_node *node)\n {\n   if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n     return false;\n@@ -1250,11 +1253,21 @@ symtab_used_from_object_file_p (symtab_node *node)\n   return false;\n }\n \n+\n+/* Return true when symtab_node is known to be used from other (non-LTO)\n+   object file. Known only when doing LTO via linker plugin.  */\n+\n+bool\n+symtab_node::used_from_object_file_p (void)\n+{\n+  return symtab_node::used_from_object_file_p_worker (this);\n+}\n+\n /* Make DECL local.  FIXME: We shouldn't need to mess with rtl this early,\n    but other code such as notice_global_symbol generates rtl.  */\n \n void\n-symtab_make_decl_local (tree decl)\n+symtab_node::make_decl_local (void)\n {\n   rtx rtl, symbol;\n \n@@ -1289,31 +1302,20 @@ symtab_make_decl_local (tree decl)\n   SYMBOL_REF_WEAK (symbol) = DECL_WEAK (decl);\n }\n \n-/* Return availability of NODE.  */\n-\n-enum availability\n-symtab_node_availability (symtab_node *node)\n-{\n-  if (is_a <cgraph_node *> (node))\n-    return cgraph_function_body_availability (cgraph (node));\n-  else\n-    return cgraph_variable_initializer_availability (varpool (node));\n-}\n-\n-/* Given NODE, walk the alias chain to return the symbol NODE is alias of.\n+/* Walk the alias chain to return the symbol NODE is alias of.\n    If NODE is not an alias, return NODE.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n symtab_node *\n-symtab_alias_ultimate_target (symtab_node *node, enum availability *availability)\n+symtab_node::ultimate_alias_target (enum availability *availability)\n {\n   bool weakref_p = false;\n \n-  if (!node->alias)\n+  if (!alias)\n     {\n       if (availability)\n-        *availability = symtab_node_availability (node);\n-      return node;\n+\t*availability = get_availability ();\n+      return this;\n     }\n \n   /* To determine visibility of the target, we follow ELF semantic of aliases.\n@@ -1332,16 +1334,18 @@ symtab_alias_ultimate_target (symtab_node *node, enum availability *availability\n \n   if (availability)\n     {\n-      weakref_p = node->weakref;\n+      weakref_p = weakref;\n       if (!weakref_p)\n-        *availability = symtab_node_availability (node);\n+\t*availability = get_availability ();\n       else\n \t*availability = AVAIL_LOCAL;\n     }\n+\n+  symtab_node *node = this;\n   while (node)\n     {\n       if (node->alias && node->analyzed)\n-\tnode = symtab_alias_target (node);\n+\tnode = node->get_alias_target ();\n       else\n \t{\n \t  if (!availability)\n@@ -1350,7 +1354,7 @@ symtab_alias_ultimate_target (symtab_node *node, enum availability *availability\n \t    {\n \t      if (weakref_p)\n \t\t{\n-\t\t  enum availability a = symtab_node_availability (node);\n+\t\t  enum availability a = node->get_availability ();\n \t\t  if (a < *availability)\n \t\t    *availability = a;\n \t\t}\n@@ -1361,7 +1365,7 @@ symtab_alias_ultimate_target (symtab_node *node, enum availability *availability\n \t}\n       if (node && availability && weakref_p)\n \t{\n-\t  enum availability a = symtab_node_availability (node);\n+\t  enum availability a = node->get_availability ();\n \t  if (a < *availability)\n \t    *availability = a;\n           weakref_p = node->weakref;\n@@ -1380,61 +1384,41 @@ symtab_alias_ultimate_target (symtab_node *node, enum availability *availability\n    copy the visibility from the target to get things right.  */\n \n void\n-fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target)\n+symtab_node::fixup_same_cpp_alias_visibility (symtab_node *target)\n {\n-  if (is_a <cgraph_node *> (node))\n+  if (is_a <cgraph_node *> (this))\n     {\n-      DECL_DECLARED_INLINE_P (node->decl)\n+      DECL_DECLARED_INLINE_P (decl)\n \t = DECL_DECLARED_INLINE_P (target->decl);\n-      DECL_DISREGARD_INLINE_LIMITS (node->decl)\n+      DECL_DISREGARD_INLINE_LIMITS (decl)\n \t = DECL_DISREGARD_INLINE_LIMITS (target->decl);\n     }\n   /* FIXME: It is not really clear why those flags should not be copied for\n      functions, too.  */\n   else\n     {\n-      DECL_WEAK (node->decl) = DECL_WEAK (target->decl);\n-      DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (target->decl);\n-      DECL_VISIBILITY (node->decl) = DECL_VISIBILITY (target->decl);\n+      DECL_WEAK (decl) = DECL_WEAK (target->decl);\n+      DECL_EXTERNAL (decl) = DECL_EXTERNAL (target->decl);\n+      DECL_VISIBILITY (decl) = DECL_VISIBILITY (target->decl);\n     }\n-  DECL_VIRTUAL_P (node->decl) = DECL_VIRTUAL_P (target->decl);\n-  if (TREE_PUBLIC (node->decl))\n+  DECL_VIRTUAL_P (decl) = DECL_VIRTUAL_P (target->decl);\n+  if (TREE_PUBLIC (decl))\n     {\n       tree group;\n \n-      DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (target->decl);\n-      DECL_COMDAT (node->decl) = DECL_COMDAT (target->decl);\n+      DECL_EXTERNAL (decl) = DECL_EXTERNAL (target->decl);\n+      DECL_COMDAT (decl) = DECL_COMDAT (target->decl);\n       group = target->get_comdat_group ();\n-      node->set_comdat_group (group);\n-      if (group\n-\t  && !node->same_comdat_group)\n-\tsymtab_add_to_same_comdat_group (node, target);\n+      set_comdat_group (group);\n+      if (group && !same_comdat_group)\n+\tadd_to_same_comdat_group (target);\n     }\n-  node->externally_visible = target->externally_visible;\n-}\n-\n-/* Hash sections by their names.  */\n-\n-static hashval_t\n-hash_section_hash_entry (const void *p)\n-{\n-  const section_hash_entry *n = (const section_hash_entry *) p;\n-  return htab_hash_string (n->name);\n-}\n-\n-/* Return true if section P1 name equals to P2.  */\n-\n-static int\n-eq_sections (const void *p1, const void *p2)\n-{\n-  const section_hash_entry *n1 = (const section_hash_entry *) p1;\n-  const char *name = (const char *)p2;\n-  return n1->name == name || !strcmp (n1->name, name);\n+  externally_visible = target->externally_visible;\n }\n \n /* Set section, do not recurse into aliases.\n    When one wants to change section of symbol and its aliases,\n-   use set_section  */\n+   use set_section.  */\n \n void\n symtab_node::set_section_for_node (const char *section)\n@@ -1485,8 +1469,8 @@ symtab_node::set_section_for_node (const char *section)\n \n /* Worker for set_section.  */\n \n-static bool\n-set_section_1 (struct symtab_node *n, void *s)\n+bool\n+symtab_node::set_section (symtab_node *n, void *s)\n {\n   n->set_section_for_node ((char *)s);\n   return false;\n@@ -1498,7 +1482,8 @@ void\n symtab_node::set_section (const char *section)\n {\n   gcc_assert (!this->alias);\n-  symtab_for_node_and_aliases (this, set_section_1, const_cast<char *>(section), true);\n+  call_for_symbol_and_aliases\n+    (symtab_node::set_section, const_cast<char *>(section), true);\n }\n \n /* Return the initialization priority.  */\n@@ -1516,6 +1501,17 @@ symtab_node::get_init_priority ()\n   return h ? h->init : DEFAULT_INIT_PRIORITY;\n }\n \n+/* Return availability of NODE.  */\n+enum availability symtab_node::get_availability (void)\n+{\n+  if (is_a <cgraph_node *> (this))\n+    return dyn_cast <cgraph_node *> (this)->get_availability ();\n+  else\n+    return cgraph_variable_initializer_availability\n+      (dyn_cast <varpool_node *> (this));\n+}\n+\n+\n /* Return the finalization priority.  */\n \n priority_type\n@@ -1553,14 +1549,14 @@ symbol_priority_map_hash (const void *item)\n    DECL.  If there is no previous priority information, a freshly\n    allocated structure is returned.  */\n \n-static struct symbol_priority_map *\n-symbol_priority_info (struct symtab_node *symbol)\n+struct symbol_priority_map *\n+symtab_node::priority_info (void)\n {\n   struct symbol_priority_map in;\n   struct symbol_priority_map *h;\n   void **loc;\n \n-  in.symbol = symbol;\n+  in.symbol = this;\n   if (!init_priority_hash)\n     init_priority_hash = htab_create_ggc (512, symbol_priority_map_hash,\n                                           symbol_priority_map_eq, 0);\n@@ -1571,10 +1567,10 @@ symbol_priority_info (struct symtab_node *symbol)\n     {\n       h = ggc_cleared_alloc<symbol_priority_map> ();\n       *loc = h;\n-      h->symbol = symbol;\n+      h->symbol = this;\n       h->init = DEFAULT_INIT_PRIORITY;\n       h->fini = DEFAULT_INIT_PRIORITY;\n-      symbol->in_init_priority_hash = true;\n+      in_init_priority_hash = true;\n     }\n \n   return h;\n@@ -1595,7 +1591,7 @@ symtab_node::set_init_priority (priority_type priority)\n       gcc_assert (get_init_priority() == priority);\n       return;\n     }\n-  h = symbol_priority_info (this);\n+  h = priority_info ();\n   h->init = priority;\n }\n \n@@ -1613,123 +1609,119 @@ cgraph_node::set_fini_priority (priority_type priority)\n       gcc_assert (get_fini_priority() == priority);\n       return;\n     }\n-  h = symbol_priority_info (this);\n+  h = priority_info ();\n   h->fini = priority;\n }\n \n /* Worker for symtab_resolve_alias.  */\n \n-static bool\n-set_implicit_section (struct symtab_node *n, void *data ATTRIBUTE_UNUSED)\n+bool\n+symtab_node::set_implicit_section (symtab_node *n,\n+\t\t\t\t   void *data ATTRIBUTE_UNUSED)\n {\n   n->implicit_section = true;\n   return false;\n }\n \n-/* Add reference recording that NODE is alias of TARGET.\n+/* Add reference recording that symtab node is alias of TARGET.\n    The function can fail in the case of aliasing cycles; in this case\n    it returns false.  */\n \n bool\n-symtab_resolve_alias (symtab_node *node, symtab_node *target)\n+symtab_node::resolve_alias (symtab_node *target)\n {\n   symtab_node *n;\n \n-  gcc_assert (!node->analyzed\n-\t      && !vec_safe_length (node->ref_list.references));\n+  gcc_assert (!analyzed && !vec_safe_length (ref_list.references));\n \n   /* Never let cycles to creep into the symbol table alias references;\n      those will make alias walkers to be infinite.  */\n   for (n = target; n && n->alias;\n-       n = n->analyzed ? symtab_alias_target (n) : NULL)\n-    if (n == node)\n+       n = n->analyzed ? n->get_alias_target () : NULL)\n+    if (n == this)\n        {\n-\t if (is_a <cgraph_node *> (node))\n-           error (\"function %q+D part of alias cycle\", node->decl);\n-         else if (is_a <varpool_node *> (node))\n-           error (\"variable %q+D part of alias cycle\", node->decl);\n+\t if (is_a <cgraph_node *> (this))\n+\t   error (\"function %q+D part of alias cycle\", decl);\n+\t else if (is_a <varpool_node *> (this))\n+\t   error (\"variable %q+D part of alias cycle\", decl);\n \t else\n \t   gcc_unreachable ();\n-\t node->alias = false;\n+\t alias = false;\n \t return false;\n        }\n \n   /* \"analyze\" the node - i.e. mark the reference.  */\n-  node->definition = true;\n-  node->alias = true;\n-  node->analyzed = true;\n-  node->add_reference (target, IPA_REF_ALIAS, NULL);\n+  definition = true;\n+  alias = true;\n+  analyzed = true;\n+  add_reference (target, IPA_REF_ALIAS, NULL);\n \n   /* Add alias into the comdat group of its target unless it is already there.  */\n-  if (node->same_comdat_group)\n-    symtab_remove_from_same_comdat_group (node);\n-  node->set_comdat_group (NULL);\n+  if (same_comdat_group)\n+    remove_from_same_comdat_group ();\n+  set_comdat_group (NULL);\n   if (target->get_comdat_group ())\n-    symtab_add_to_same_comdat_group (node, target);\n+    add_to_same_comdat_group (target);\n \n-  if ((node->get_section () != target->get_section ()\n-       || target->get_comdat_group ())\n-      && node->get_section () && !node->implicit_section)\n+  if ((get_section () != target->get_section ()\n+       || target->get_comdat_group ()) && get_section () && !implicit_section)\n     {\n-      error (\"section of alias %q+D must match section of its target\",\n-\t     node->decl);\n+      error (\"section of alias %q+D must match section of its target\", decl);\n     }\n-  symtab_for_node_and_aliases (node, set_section_1,\n-\t\t\t       const_cast<char *>(target->get_section ()), true);\n+  call_for_symbol_and_aliases (symtab_node::set_section,\n+\t\t\t     const_cast<char *>(target->get_section ()), true);\n   if (target->implicit_section)\n-    symtab_for_node_and_aliases (node,\n-\t\t\t\t set_implicit_section, NULL, true);\n+    call_for_symbol_and_aliases (set_implicit_section, NULL, true);\n \n   /* Alias targets become redundant after alias is resolved into an reference.\n      We do not want to keep it around or we would have to mind updating them\n      when renaming symbols.  */\n-  node->alias_target = NULL;\n+  alias_target = NULL;\n \n-  if (node->cpp_implicit_alias && cgraph_state >= CGRAPH_STATE_CONSTRUCTION)\n-    fixup_same_cpp_alias_visibility (node, target);\n+  if (cpp_implicit_alias && cgraph_state >= CGRAPH_STATE_CONSTRUCTION)\n+    fixup_same_cpp_alias_visibility (target);\n \n   /* If alias has address taken, so does the target.  */\n-  if (node->address_taken)\n-    symtab_alias_ultimate_target (target, NULL)->address_taken = true;\n+  if (address_taken)\n+    target->ultimate_alias_target ()->address_taken = true;\n   return true;\n }\n \n-/* Call calback on NODE and aliases associated to NODE. \n+/* Call calback on symtab node and aliases associated to this node.\n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n \n bool\n-symtab_for_node_and_aliases (symtab_node *node,\n-\t\t\t     bool (*callback) (symtab_node *, void *),\n-\t\t\t     void *data,\n-\t\t\t     bool include_overwritable)\n+symtab_node::call_for_symbol_and_aliases (bool (*callback) (symtab_node *,\n+\t\t\t\t\t\t\t  void *),\n+\t\t\t\t\tvoid *data, bool include_overwritable)\n {\n   int i;\n   struct ipa_ref *ref;\n \n-  if (callback (node, data))\n+  if (callback (this, data))\n     return true;\n-  for (i = 0; node->iterate_referring (i, ref); i++)\n+  for (i = 0; iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tsymtab_node *alias = ref->referring;\n \tif (include_overwritable\n-\t    || symtab_node_availability (alias) > AVAIL_OVERWRITABLE)\n-          if (symtab_for_node_and_aliases (alias, callback, data,\n-\t\t\t\t\t   include_overwritable))\n+\t    || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\t  if (alias->call_for_symbol_and_aliases (callback, data,\n+\t\t\t\t\t\tinclude_overwritable))\n \t    return true;\n       }\n   return false;\n }\n \n-/* Worker searching nonoverwritable alias.  */\n+/* Worker searching noninterposable alias.  */\n \n-static bool\n-symtab_nonoverwritable_alias_1 (symtab_node *node, void *data)\n+bool\n+symtab_node::noninterposable_alias (symtab_node *node, void *data)\n {\n   if (decl_binds_to_current_def_p (node->decl))\n     {\n-      symtab_node *fn = symtab_alias_ultimate_target (node);\n+      symtab_node *fn = node->ultimate_alias_target ();\n \n       /* Ensure that the alias is well formed this may not be the case\n \t of user defined aliases and currently it is not always the case\n@@ -1748,22 +1740,22 @@ symtab_nonoverwritable_alias_1 (symtab_node *node, void *data)\n   return false;\n }\n \n-/* If NODE can not be overwriten by static or dynamic linker to point to different\n-   definition, return NODE. Otherwise look for alias with such property and if\n-   none exists, introduce new one.  */\n+/* If node can not be overwriten by static or dynamic linker to point to\n+   different definition, return NODE. Otherwise look for alias with such\n+   property and if none exists, introduce new one.  */\n \n symtab_node *\n-symtab_nonoverwritable_alias (symtab_node *node)\n+symtab_node::noninterposable_alias (void)\n {\n   tree new_decl;\n   symtab_node *new_node = NULL;\n \n   /* First try to look up existing alias or base object\n      (if that is already non-overwritable).  */\n-  node = symtab_alias_ultimate_target (node, NULL);\n+  symtab_node *node = ultimate_alias_target ();\n   gcc_assert (!node->alias && !node->weakref);\n-  symtab_for_node_and_aliases (node, symtab_nonoverwritable_alias_1,\n-\t\t               (void *)&new_node, true);\n+  node->call_for_symbol_and_aliases (symtab_node::noninterposable_alias,\n+\t\t\t\t   (void *)&new_node, true);\n   if (new_node)\n     return new_node;\n #ifndef ASM_OUTPUT_DEF\n@@ -1792,101 +1784,100 @@ symtab_nonoverwritable_alias (symtab_node *node)\n     {\n       DECL_STATIC_CONSTRUCTOR (new_decl) = 0;\n       DECL_STATIC_DESTRUCTOR (new_decl) = 0;\n-      new_node = cgraph_create_function_alias\n-\t\t\t\t (new_decl, node->decl);\n+      new_node = cgraph_node::create_alias (new_decl, node->decl);\n     }\n   else\n     {\n       TREE_READONLY (new_decl) = TREE_READONLY (node->decl);\n       DECL_INITIAL (new_decl) = error_mark_node;\n       new_node = varpool_create_variable_alias (new_decl, node->decl);\n     }\n-  symtab_resolve_alias (new_node, node);  \n+  new_node->resolve_alias (node);\n   gcc_assert (decl_binds_to_current_def_p (new_decl)\n \t      && targetm.binds_local_p (new_decl));\n   return new_node;\n }\n \n-/* Return true if A and B represents semantically equivalent symbols.  */\n+/* Return true if symtab node and TARGET represents\n+   semantically equivalent symbols.  */\n \n bool\n-symtab_semantically_equivalent_p (symtab_node *a,\n-\t\t\t\t  symtab_node *b)\n+symtab_node::semantically_equivalent_p (symtab_node *target)\n {\n   enum availability avail;\n   symtab_node *ba;\n   symtab_node *bb;\n \n   /* Equivalent functions are equivalent.  */\n-  if (a->decl == b->decl)\n+  if (decl == target->decl)\n     return true;\n \n   /* If symbol is not overwritable by different implementation,\n      walk to the base object it defines.  */\n-  ba = symtab_alias_ultimate_target (a, &avail);\n+  ba = ultimate_alias_target (&avail);\n   if (avail >= AVAIL_AVAILABLE)\n     {\n-      if (ba == b)\n+      if (target == ba)\n \treturn true;\n     }\n   else\n-    ba = a;\n-  bb = symtab_alias_ultimate_target (b, &avail);\n+    ba = this;\n+  bb = target->ultimate_alias_target (&avail);\n   if (avail >= AVAIL_AVAILABLE)\n     {\n-      if (a == bb)\n+      if (this == bb)\n \treturn true;\n     }\n   else\n-    bb = b;\n+    bb = target;\n   return bb == ba;\n }\n \n-/* Classify symbol NODE for partitioning.  */\n+/* Classify symbol symtab node for partitioning.  */\n \n enum symbol_partitioning_class\n-symtab_get_symbol_partitioning_class (symtab_node *node)\n+symtab_node::get_partitioning_class (void)\n {\n   /* Inline clones are always duplicated.\n      This include external delcarations.   */\n-  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);\n \n-  if (DECL_ABSTRACT (node->decl))\n+  if (DECL_ABSTRACT (decl))\n     return SYMBOL_EXTERNAL;\n \n   if (cnode && cnode->global.inlined_to)\n     return SYMBOL_DUPLICATE;\n \n   /* Weakref aliases are always duplicated.  */\n-  if (node->weakref)\n+  if (weakref)\n     return SYMBOL_DUPLICATE;\n \n   /* External declarations are external.  */\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (decl))\n     return SYMBOL_EXTERNAL;\n \n-  if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n+  if (varpool_node *vnode = dyn_cast <varpool_node *> (this))\n     {\n       /* Constant pool references use local symbol names that can not\n          be promoted global.  We should never put into a constant pool\n          objects that can not be duplicated across partitions.  */\n-      if (DECL_IN_CONSTANT_POOL (node->decl))\n+      if (DECL_IN_CONSTANT_POOL (decl))\n \treturn SYMBOL_DUPLICATE;\n       gcc_checking_assert (vnode->definition);\n     }\n   /* Functions that are cloned may stay in callgraph even if they are unused.\n      Handle them as external; compute_ltrans_boundary take care to make\n      proper things to happen (i.e. to make them appear in the boundary but\n      with body streamed, so clone can me materialized).  */\n-  else if (!cgraph (node)->definition)\n+  else if (!dyn_cast <cgraph_node *> (this)->definition)\n     return SYMBOL_EXTERNAL;\n \n   /* Linker discardable symbols are duplicated to every use unless they are\n      keyed.  */\n-  if (DECL_ONE_ONLY (node->decl)\n-      && !node->force_output\n-      && !node->forced_by_abi\n-      && !symtab_used_from_object_file_p (node))\n+  if (DECL_ONE_ONLY (decl)\n+      && !force_output\n+      && !forced_by_abi\n+      && !used_from_object_file_p ())\n     return SYMBOL_DUPLICATE;\n \n   return SYMBOL_PARTITION;\n@@ -1902,7 +1893,7 @@ symtab_node::nonzero_address ()\n     {\n       if (this->analyzed)\n \t{\n-\t  symtab_node *target = symtab_alias_ultimate_target (this);\n+\t  symtab_node *target = ultimate_alias_target ();\n \n \t  if (target->alias && target->weakref)\n \t    return false;"}, {"sha": "f33b52f530549e530a6efd222b9a8c8ac83b26c5", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -2369,7 +2369,7 @@ expand_call_tm (struct tm_region *region,\n       return false;\n     }\n \n-  node = cgraph_get_node (fn_decl);\n+  node = cgraph_node::get (fn_decl);\n   /* All calls should have cgraph here.  */\n   if (!node)\n     {\n@@ -2389,7 +2389,7 @@ expand_call_tm (struct tm_region *region,\n \t{\n \t  gimple_call_set_fndecl (stmt, repl);\n \t  update_stmt (stmt);\n-\t  node = cgraph_create_node (repl);\n+\t  node = cgraph_node::create (repl);\n \t  node->local.tm_may_enter_irr = false;\n \t  return expand_call_tm (region, gsi);\n \t}\n@@ -4032,7 +4032,7 @@ struct tm_ipa_cg_data\n   bool want_irr_scan_normal;\n };\n \n-typedef vec<cgraph_node_ptr> cgraph_node_queue;\n+typedef vec<cgraph_node *> cgraph_node_queue;\n \n /* Return the ipa data associated with NODE, allocating zeroed memory\n    if necessary.  TRAVERSE_ALIASES is true if we must traverse aliases\n@@ -4044,7 +4044,7 @@ get_cg_data (struct cgraph_node **node, bool traverse_aliases)\n   struct tm_ipa_cg_data *d;\n \n   if (traverse_aliases && (*node)->alias)\n-    *node = cgraph_alias_target (*node);\n+    *node = (*node)->get_alias_target ();\n \n   d = (struct tm_ipa_cg_data *) (*node)->aux;\n \n@@ -4128,7 +4128,7 @@ ipa_tm_scan_calls_block (cgraph_node_queue *callees_p,\n \t      if (find_tm_replacement_function (fndecl))\n \t\tcontinue;\n \n-\t      node = cgraph_get_node (fndecl);\n+\t      node = cgraph_node::get (fndecl);\n \t      gcc_assert (node != NULL);\n \t      d = get_cg_data (&node, true);\n \n@@ -4295,7 +4295,7 @@ ipa_tm_scan_irr_block (basic_block bb)\n \t\tif (find_tm_replacement_function (fn))\n \t\t  break;\n \n-\t\tnode = cgraph_get_node (fn);\n+\t\tnode = cgraph_node::get (fn);\n \t\td = get_cg_data (&node, true);\n \n \t\t/* Return true if irrevocable, but above all, believe\n@@ -4468,7 +4468,7 @@ ipa_tm_decrement_clone_counts (basic_block bb, bool for_clone)\n \t      if (find_tm_replacement_function (fndecl))\n \t\tcontinue;\n \n-\t      tnode = cgraph_get_node (fndecl);\n+\t      tnode = cgraph_node::get (fndecl);\n \t      d = get_cg_data (&tnode, true);\n \n \t      pcallers = (for_clone ? &d->tm_callers_clone\n@@ -4610,7 +4610,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n \n   /* If we aren't seeing the final version of the function we don't\n      know what it will contain at runtime.  */\n-  if (cgraph_function_body_availability (node) < AVAIL_AVAILABLE)\n+  if (node->get_availability () < AVAIL_AVAILABLE)\n     return true;\n \n   /* If the function must go irrevocable, then of course true.  */\n@@ -4631,7 +4631,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n      result in one of the bits above being set so that we will not\n      have to recurse next time.  */\n   if (node->alias)\n-    return ipa_tm_mayenterirr_function (cgraph_get_node (node->thunk.alias));\n+    return ipa_tm_mayenterirr_function (cgraph_node::get (node->thunk.alias));\n \n   /* What remains is unmarked local functions without items that force\n      the function to go irrevocable.  */\n@@ -4789,7 +4789,7 @@ tm_mangle (tree old_asm_id)\n static inline void\n ipa_tm_mark_force_output_node (struct cgraph_node *node)\n {\n-  cgraph_mark_force_output_node (node);\n+  node->mark_force_output ();\n   node->analyzed = true;\n }\n \n@@ -4845,7 +4845,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   if (DECL_ONE_ONLY (new_decl))\n     varpool_get_node (new_decl)->set_comdat_group (tm_mangle (decl_comdat_group_id (old_decl)));\n \n-  new_node = cgraph_same_body_alias (NULL, new_decl, info->new_decl);\n+  new_node = cgraph_node::create_same_body_alias (new_decl, info->new_decl);\n   new_node->tm_clone = true;\n   new_node->externally_visible = info->old_node->externally_visible;\n   /* ?? Do not traverse aliases here.  */\n@@ -4886,14 +4886,14 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n     varpool_get_node (new_decl)->set_comdat_group (tm_mangle (DECL_COMDAT_GROUP (old_decl)));\n \n   gcc_assert (!old_node->ipa_transforms_to_apply.exists ());\n-  new_node = cgraph_copy_node_for_versioning (old_node, new_decl, vNULL, NULL);\n+  new_node = old_node->create_version_clone (new_decl, vNULL, NULL);\n   new_node->local.local = false;\n   new_node->externally_visible = old_node->externally_visible;\n   new_node->lowered = true;\n   new_node->tm_clone = 1;\n   get_cg_data (&old_node, true)->clone = new_node;\n \n-  if (cgraph_function_body_availability (old_node) >= AVAIL_OVERWRITABLE)\n+  if (old_node->get_availability () >= AVAIL_INTERPOSABLE)\n     {\n       /* Remap extern inline to static inline.  */\n       /* ??? Is it worth trying to use make_decl_one_only?  */\n@@ -4911,7 +4911,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   record_tm_clone_pair (old_decl, new_decl);\n \n-  cgraph_call_function_insertion_hooks (new_node);\n+  new_node->call_function_insertion_hooks ();\n   if (old_node->force_output\n       || old_node->ref_list.first_referring ())\n     ipa_tm_mark_force_output_node (new_node);\n@@ -4923,8 +4923,8 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n     struct create_version_alias_info data;\n     data.old_node = old_node;\n     data.new_decl = new_decl;\n-    cgraph_for_node_and_aliases (old_node, ipa_tm_create_version_alias,\n-\t\t\t\t &data, true);\n+    old_node->call_for_symbol_thunks_and_aliases (ipa_tm_create_version_alias,\n+\t\t\t\t\t\t&data, true);\n   }\n }\n \n@@ -4946,12 +4946,11 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n   gsi = gsi_after_labels (bb);\n   gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n \n-  cgraph_create_edge (node,\n-\t       cgraph_get_create_node\n-\t\t  (builtin_decl_explicit (BUILT_IN_TM_IRREVOCABLE)),\n-\t\t      g, 0,\n-\t\t      compute_call_stmt_bb_frequency (node->decl,\n-\t\t\t\t\t\t      gimple_bb (g)));\n+  node->create_edge (cgraph_node::get_create\n+\t\t       (builtin_decl_explicit (BUILT_IN_TM_IRREVOCABLE)),\n+\t\t     g, 0,\n+\t\t     compute_call_stmt_bb_frequency (node->decl,\n+\t\t\t\t\t\t     gimple_bb (g)));\n }\n \n /* Construct a call to TM_GETTMCLONE and insert it before GSI.  */\n@@ -4976,9 +4975,9 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \t technically taking the address of the original function and\n \t its clone.  Explain this so inlining will know this function\n \t is needed.  */\n-      cgraph_mark_address_taken_node (cgraph_get_node (fndecl));\n+      cgraph_node::get (fndecl)->mark_address_taken () ;\n       if (clone)\n-\tcgraph_mark_address_taken_node (cgraph_get_node (clone));\n+\tcgraph_node::get (clone)->mark_address_taken ();\n     }\n \n   safe = is_tm_safe (TREE_TYPE (old_fn));\n@@ -4999,9 +4998,9 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n \n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n-  cgraph_create_edge (node, cgraph_get_create_node (gettm_fn), g, 0,\n-\t\t      compute_call_stmt_bb_frequency (node->decl,\n-\t\t\t\t\t\t      gimple_bb (g)));\n+  node->create_edge (cgraph_node::get_create (gettm_fn), g, 0,\n+\t\t     compute_call_stmt_bb_frequency (node->decl,\n+\t\t\t\t\t\t     gimple_bb (g)));\n \n   /* Cast return value from tm_gettmclone* into appropriate function\n      pointer.  */\n@@ -5057,7 +5056,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n {\n   gimple stmt = gsi_stmt (*gsi);\n   struct cgraph_node *new_node;\n-  struct cgraph_edge *e = cgraph_edge (node, stmt);\n+  struct cgraph_edge *e = node->get_edge (stmt);\n   tree fndecl = gimple_call_fndecl (stmt);\n \n   /* For indirect calls, pass the address through the runtime.  */\n@@ -5087,7 +5086,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n   fndecl = find_tm_replacement_function (fndecl);\n   if (fndecl)\n     {\n-      new_node = cgraph_get_create_node (fndecl);\n+      new_node = cgraph_node::get_create (fndecl);\n \n       /* ??? Mark all transaction_wrap functions tm_may_enter_irr.\n \n@@ -5292,7 +5291,7 @@ ipa_tm_execute (void)\n   unsigned int i;\n \n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  cgraph_node::verify_cgraph_nodes ();\n #endif\n \n   bitmap_obstack_initialize (&tm_obstack);\n@@ -5301,7 +5300,7 @@ ipa_tm_execute (void)\n   /* For all local functions marked tm_callable, queue them.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (is_tm_callable (node->decl)\n-\t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+\t&& node->get_availability () >= AVAIL_INTERPOSABLE)\n       {\n \td = get_cg_data (&node, true);\n \tmaybe_push_queue (node, &tm_callees, &d->in_callee_queue);\n@@ -5310,7 +5309,7 @@ ipa_tm_execute (void)\n   /* For all local reachable functions...  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->lowered\n-\t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+\t&& node->get_availability () >= AVAIL_INTERPOSABLE)\n       {\n \t/* ... marked tm_pure, record that fact for the runtime by\n \t   indicating that the pure function is its own tm_callable.\n@@ -5350,7 +5349,7 @@ ipa_tm_execute (void)\n   for (i = 0; i < tm_callees.length (); ++i)\n     {\n       node = tm_callees[i];\n-      a = cgraph_function_body_availability (node);\n+      a = node->get_availability ();\n       d = get_cg_data (&node, true);\n \n       /* Put it in the worklist so we can scan the function later\n@@ -5365,7 +5364,7 @@ ipa_tm_execute (void)\n       else if (a <= AVAIL_NOT_AVAILABLE\n \t       && !is_tm_safe_or_pure (node->decl))\n \tipa_tm_note_irrevocable (node, &irr_worklist);\n-      else if (a >= AVAIL_OVERWRITABLE)\n+      else if (a >= AVAIL_INTERPOSABLE)\n \t{\n \t  if (!tree_versionable_function_p (node->decl))\n \t    ipa_tm_note_irrevocable (node, &irr_worklist);\n@@ -5375,7 +5374,7 @@ ipa_tm_execute (void)\n \t\t we need not scan the callees now, as the base will do.  */\n \t      if (node->alias)\n \t\t{\n-\t\t  node = cgraph_get_node (node->thunk.alias);\n+\t\t  node = cgraph_node::get (node->thunk.alias);\n \t\t  d = get_cg_data (&node, true);\n \t\t  maybe_push_queue (node, &tm_callees, &d->in_callee_queue);\n \t\t  continue;\n@@ -5461,7 +5460,7 @@ ipa_tm_execute (void)\n       /* Propagate back to referring aliases as well.  */\n       FOR_EACH_ALIAS (node, ref)\n \t{\n-\t  caller = cgraph (ref->referring);\n+\t  caller = dyn_cast<cgraph_node *> (ref->referring);\n \t  if (!caller->local.tm_may_enter_irr)\n \t    {\n \t      /* ?? Do not traverse aliases here.  */\n@@ -5475,7 +5474,7 @@ ipa_tm_execute (void)\n      other functions.  */\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->lowered\n-\t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+\t&& node->get_availability () >= AVAIL_INTERPOSABLE)\n       {\n \td = get_cg_data (&node, true);\n \tif (is_tm_safe (node->decl))\n@@ -5495,7 +5494,7 @@ ipa_tm_execute (void)\n       if (node->cpp_implicit_alias)\n \tcontinue;\n \n-      a = cgraph_function_body_availability (node);\n+      a = node->get_availability ();\n       d = get_cg_data (&node, true);\n \n       if (a <= AVAIL_NOT_AVAILABLE)\n@@ -5523,7 +5522,7 @@ ipa_tm_execute (void)\n     }\n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->lowered\n-\t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n+\t&& node->get_availability () >= AVAIL_INTERPOSABLE)\n       {\n \td = get_cg_data (&node, true);\n \tif (d->all_tm_regions)\n@@ -5540,7 +5539,7 @@ ipa_tm_execute (void)\n     node->aux = NULL;\n \n #ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n+  cgraph_node::verify_cgraph_nodes ();\n #endif\n \n   return 0;"}, {"sha": "d2381384cf924b9db56540b1343d1deec90cc3a6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -8449,11 +8449,11 @@ execute_fixup_cfg (void)\n   edge_iterator ei;\n \n   count_scale\n-      = GCOV_COMPUTE_SCALE (cgraph_get_node (current_function_decl)->count,\n+      = GCOV_COMPUTE_SCALE (cgraph_node::get (current_function_decl)->count,\n \t\t\t    ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n \n   ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n-\t\t\t    cgraph_get_node (current_function_decl)->count;\n+\t\t\t    cgraph_node::get (current_function_decl)->count;\n   EXIT_BLOCK_PTR_FOR_FN (cfun)->count =\n \t\t\t    apply_scale (EXIT_BLOCK_PTR_FOR_FN (cfun)->count,\n                                        count_scale);"}, {"sha": "ee5c3b4c7b30b68618482795161b8aa61bee2a8d", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -2691,7 +2691,7 @@ tree_could_trap_p (tree expr)\n \t  struct cgraph_node *node;\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n-\t  node = cgraph_function_node (cgraph_get_node (expr), NULL);\n+\t  node = cgraph_node::get (expr)->function_symbol ();\n \t  if (node && node->in_other_partition)\n \t    return false;\n \t  return true;"}, {"sha": "3e2296de9aeb73e92c3b130a94fbb4639d349879", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -71,7 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n    the index of a TLS variable equals the index of its control variable in\n    the other vector.  */\n static varpool_node_set tls_vars;\n-static vec<varpool_node_ptr> control_vars;\n+static vec<varpool_node *> control_vars;\n \n /* For the current basic block, an SSA_NAME that has computed the address \n    of the TLS variable at the corresponding index.  */\n@@ -448,8 +448,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n \n       gimple_seq_add_stmt (&d->seq, x);\n \n-      cgraph_create_edge (d->cfun_node, d->builtin_node, x,\n-                          d->bb->count, d->bb_freq);\n+      d->cfun_node->create_edge (d->builtin_node, x, d->bb->count, d->bb_freq);\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */\n@@ -632,7 +631,7 @@ lower_emutls_function_body (struct cgraph_node *node)\n   d.builtin_decl = builtin_decl_explicit (BUILT_IN_EMUTLS_GET_ADDRESS);\n   /* This is where we introduce the declaration to the IL and so we have to\n      create a node for it.  */\n-  d.builtin_node = cgraph_get_create_node (d.builtin_decl);\n+  d.builtin_node = cgraph_node::get_create (d.builtin_decl);\n \n   FOR_EACH_BB_FN (d.bb, cfun)\n     {"}, {"sha": "3ded5ed764e5ed94fbe83cb7d832ad0b0c4b8e2a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1799,7 +1799,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t      switch (id->transform_call_graph_edges)\n \t\t{\n \t\tcase CB_CGE_DUPLICATE:\n-\t\t  edge = cgraph_edge (id->src_node, orig_stmt);\n+\t\t  edge = id->src_node->get_edge (orig_stmt);\n \t\t  if (edge)\n \t\t    {\n \t\t      int edge_freq = edge->frequency;\n@@ -1862,13 +1862,13 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  break;\n \n \t\tcase CB_CGE_MOVE_CLONES:\n-\t\t  cgraph_set_call_stmt_including_clones (id->dst_node,\n-\t\t\t\t\t\t\t orig_stmt, stmt);\n-\t\t  edge = cgraph_edge (id->dst_node, stmt);\n+\t\t  id->dst_node->set_call_stmt_including_clones (orig_stmt,\n+\t\t\t\t\t\t\t\tstmt);\n+\t\t  edge = id->dst_node->get_edge (stmt);\n \t\t  break;\n \n \t\tcase CB_CGE_MOVE:\n-\t\t  edge = cgraph_edge (id->dst_node, orig_stmt);\n+\t\t  edge = id->dst_node->get_edge (orig_stmt);\n \t\t  if (edge)\n \t\t    cgraph_set_call_stmt (edge, stmt);\n \t\t  break;\n@@ -1885,7 +1885,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  && id->dst_node->definition\n \t\t  && (fn = gimple_call_fndecl (stmt)) != NULL)\n \t\t{\n-\t\t  struct cgraph_node *dest = cgraph_get_node (fn);\n+\t\t  struct cgraph_node *dest = cgraph_node::get (fn);\n \n \t\t  /* We have missing edge in the callgraph.  This can happen\n \t\t     when previous inlining turned an indirect call into a\n@@ -1898,13 +1898,13 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  \t      || !id->src_node->definition\n \t\t\t      || !id->dst_node->definition);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n-\t\t    cgraph_create_edge_including_clones\n-\t\t      (id->dst_node, dest, orig_stmt, stmt, bb->count,\n+\t\t    id->dst_node->create_edge_including_clones\n+\t\t      (dest, orig_stmt, stmt, bb->count,\n \t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n \t\t       \t\t\t\t       copy_basic_block),\n \t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n-\t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n+\t\t    id->dst_node->create_edge (dest, stmt,\n \t\t\t\t\tbb->count,\n \t\t\t\t\tcompute_call_stmt_bb_frequency\n \t\t\t\t\t  (id->dst_node->decl,\n@@ -2430,7 +2430,7 @@ redirect_all_calls (copy_body_data * id, basic_block bb)\n     {\n       if (is_gimple_call (gsi_stmt (si)))\n \t{\n-\t  struct cgraph_edge *edge = cgraph_edge (id->dst_node, gsi_stmt (si));\n+\t  struct cgraph_edge *edge = id->dst_node->get_edge (gsi_stmt (si));\n \t  if (edge)\n \t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n \t}\n@@ -3889,7 +3889,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \t    /* Do not special case builtins where we see the body.\n \t       This just confuse inliner.  */\n \t    struct cgraph_node *node;\n-\t    if (!(node = cgraph_get_node (decl))\n+\t    if (!(node = cgraph_node::get (decl))\n \t\t|| node->definition)\n \t      ;\n \t    /* For buitins that are likely expanded to nothing or\n@@ -4159,7 +4159,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   if (gimple_code (stmt) != GIMPLE_CALL)\n     goto egress;\n \n-  cg_edge = cgraph_edge (id->dst_node, stmt);\n+  cg_edge = id->dst_node->get_edge (stmt);\n   gcc_checking_assert (cg_edge);\n   /* First, see if we can figure out what function is being called.\n      If we cannot, then there is no hope of inlining the function.  */\n@@ -4227,11 +4227,11 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       goto egress;\n     }\n   fn = cg_edge->callee->decl;\n-  cgraph_get_body (cg_edge->callee);\n+  cg_edge->callee->get_body ();\n \n #ifdef ENABLE_CHECKING\n   if (cg_edge->callee->decl != id->dst_node->decl)\n-    verify_cgraph_node (cg_edge->callee);\n+    cg_edge->callee->verify ();\n #endif\n \n   /* We will be inlining this callee.  */\n@@ -4494,7 +4494,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n     (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n \n   /* Update callgraph if needed.  */\n-  cgraph_remove_node (cg_edge->callee);\n+  cg_edge->callee->remove ();\n \n   id->block = NULL_TREE;\n   successfully_inlined = TRUE;\n@@ -4629,7 +4629,7 @@ optimize_inline_calls (tree fn)\n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n \n-  id.src_node = id.dst_node = cgraph_get_node (fn);\n+  id.src_node = id.dst_node = cgraph_node::get (fn);\n   gcc_assert (id.dst_node->definition);\n   id.dst_fn = fn;\n   /* Or any functions that aren't finished yet.  */\n@@ -4668,7 +4668,7 @@ optimize_inline_calls (tree fn)\n     {\n       struct cgraph_edge *e;\n \n-      verify_cgraph_node (id.dst_node);\n+      id.dst_node->verify ();\n \n       /* Double check that we inlined everything we are supposed to inline.  */\n       for (e = id.dst_node->callees; e; e = e->next_callee)\n@@ -4691,7 +4691,7 @@ optimize_inline_calls (tree fn)\n \n   delete_unreachable_blocks_update_callgraph (&id);\n #ifdef ENABLE_CHECKING\n-  verify_cgraph_node (id.dst_node);\n+  id.dst_node->verify ();\n #endif\n \n   /* It would be nice to check SSA/CFG/statement consistency here, but it is\n@@ -5221,10 +5221,10 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t      id->dst_node->remove_stmt_references (gsi_stmt (bsi));\n \n \t      if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n-\t\t  &&(e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)\n+\t\t  &&(e = id->dst_node->get_edge (gsi_stmt (bsi))) != NULL)\n \t\t{\n \t\t  if (!e->inline_failed)\n-\t\t    cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);\n+\t\t    e->callee->remove_symbol_and_inline_clones (id->dst_node);\n \t\t  else\n \t\t    cgraph_remove_edge (e);\n \t\t}\n@@ -5234,10 +5234,10 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t\t  {\n \t\t    node->remove_stmt_references (gsi_stmt (bsi));\n \t\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n-\t\t\t&& (e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)\n+\t\t\t&& (e = node->get_edge (gsi_stmt (bsi))) != NULL)\n \t\t      {\n \t\t\tif (!e->inline_failed)\n-\t\t\t  cgraph_remove_node_and_inline_clones (e->callee, id->dst_node);\n+\t\t\t  e->callee->remove_symbol_and_inline_clones (id->dst_node);\n \t\t\telse\n \t\t\t  cgraph_remove_edge (e);\n \t\t      }\n@@ -5316,7 +5316,7 @@ update_clone_info (copy_body_data * id)\n */\n void\n tree_function_versioning (tree old_decl, tree new_decl,\n-\t\t\t  vec<ipa_replace_map_p, va_gc> *tree_map,\n+\t\t\t  vec<ipa_replace_map *, va_gc> *tree_map,\n \t\t\t  bool update_clones, bitmap args_to_skip,\n \t\t\t  bool skip_return, bitmap blocks_to_copy,\n \t\t\t  basic_block new_entry)\n@@ -5335,9 +5335,9 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \t      && TREE_CODE (new_decl) == FUNCTION_DECL);\n   DECL_POSSIBLY_INLINED (old_decl) = 1;\n \n-  old_version_node = cgraph_get_node (old_decl);\n+  old_version_node = cgraph_node::get (old_decl);\n   gcc_checking_assert (old_version_node);\n-  new_version_node = cgraph_get_node (new_decl);\n+  new_version_node = cgraph_node::get (new_decl);\n   gcc_checking_assert (new_version_node);\n \n   /* Copy over debug args.  */"}, {"sha": "185d87c07fd6f956c6a8cfaa5df6bfd6cf53d2d8", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -706,7 +706,7 @@ walk_all_functions (walk_stmt_fn callback_stmt, walk_tree_fn callback_op,\n static bool\n check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n {\n-  struct cgraph_node *cgn = cgraph_get_node (fndecl);\n+  struct cgraph_node *cgn = cgraph_node::get (fndecl);\n   tree arg;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n@@ -2901,13 +2901,13 @@ finalize_nesting_tree (struct nesting_info *root)\n static void\n unnest_nesting_tree_1 (struct nesting_info *root)\n {\n-  struct cgraph_node *node = cgraph_get_node (root->context);\n+  struct cgraph_node *node = cgraph_node::get (root->context);\n \n   /* For nested functions update the cgraph to reflect unnesting.\n      We also delay finalizing of these functions up to this point.  */\n   if (node->origin)\n     {\n-       cgraph_unnest_node (node);\n+       node->unnest ();\n        cgraph_finalize_function (root->context, true);\n     }\n }\n@@ -2961,7 +2961,7 @@ lower_nested_functions (tree fndecl)\n   struct nesting_info *root;\n \n   /* If there are no nested functions, there's nothing to do.  */\n-  cgn = cgraph_get_node (fndecl);\n+  cgn = cgraph_node::get (fndecl);\n   if (!cgn->nested)\n     return;\n "}, {"sha": "ca6e014f96ef6188a829fead89eec26e59cf088b", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -3456,7 +3456,7 @@ void\n dump_function_header (FILE *dump_file, tree fdecl, int flags)\n {\n   const char *dname, *aname;\n-  struct cgraph_node *node = cgraph_get_node (fdecl);\n+  struct cgraph_node *node = cgraph_node::get (fdecl);\n   struct function *fun = DECL_STRUCT_FUNCTION (fdecl);\n \n   dname = lang_hooks.decl_printable_name (fdecl, 2);"}, {"sha": "d384e3dd018ac59ef9784c6d1f059fd451bd5e0e", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -427,12 +427,12 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n void\n gimple_gen_ic_func_profiler (void)\n {\n-  struct cgraph_node * c_node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node * c_node = cgraph_node::get (current_function_decl);\n   gimple_stmt_iterator gsi;\n   gimple stmt1, stmt2;\n   tree tree_uid, cur_func, void0;\n \n-  if (cgraph_only_called_directly_p (c_node))\n+  if (c_node->only_called_directly_p ())\n     return;\n \n   gimple_init_edge_profiler ();\n@@ -451,7 +451,7 @@ gimple_gen_ic_func_profiler (void)\n \t\t\t\t       true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n   tree_uid = build_int_cst\n-\t      (gcov_type_node, cgraph_get_node (current_function_decl)->profile_id);\n+\t      (gcov_type_node, cgraph_node::get (current_function_decl)->profile_id);\n   /* Workaround for binutils bug 14342.  Once it is fixed, remove lto path.  */\n   if (flag_lto)\n     {\n@@ -615,8 +615,8 @@ tree_profiling (void)\n       if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION)\n \tcontinue;\n \n-      cgraph_set_const_flag (node, false, false);\n-      cgraph_set_pure_flag (node, false, false);\n+      node->set_const_flag (false, false);\n+      node->set_pure_flag (false, false);\n     }\n \n   /* Update call statements and rebuild the cgraph.  */"}, {"sha": "f9d39acff202088578a6ee43c27f2fcd5ba62abb", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -4886,8 +4886,8 @@ convert_callers (struct cgraph_node *node, tree old_decl,\n {\n   basic_block this_block;\n \n-  cgraph_for_node_and_aliases (node, convert_callers_for_node,\n-\t\t\t       &adjustments, false);\n+  node->call_for_symbol_thunks_and_aliases (convert_callers_for_node,\n+\t\t\t\t\t  &adjustments, false);\n \n   if (!encountered_recursive_call)\n     return;\n@@ -4932,18 +4932,18 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n   /* This must be done after rebuilding cgraph edges for node above.\n      Otherwise any recursive calls to node that are recorded in\n      redirect_callers will be corrupted.  */\n-  vec<cgraph_edge_p> redirect_callers = collect_callers_of_node (node);\n-  new_node = cgraph_function_versioning (node, redirect_callers,\n-\t\t\t\t\t NULL,\n-\t\t\t\t\t NULL, false, NULL, NULL, \"isra\");\n+  vec<cgraph_edge *> redirect_callers = node->collect_callers ();\n+  new_node = node->create_version_clone_with_body (redirect_callers, NULL,\n+\t\t\t\t\t\t   NULL, false, NULL, NULL,\n+\t\t\t\t\t\t   \"isra\");\n   redirect_callers.release ();\n \n   push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n   ipa_modify_formal_parameters (current_function_decl, adjustments);\n   cfg_changed = ipa_sra_modify_function_body (adjustments);\n   sra_ipa_reset_debug_stmts (adjustments);\n   convert_callers (new_node, node->decl, adjustments);\n-  cgraph_make_node_local (new_node);\n+  new_node->make_local ();\n   return cfg_changed;\n }\n \n@@ -4964,7 +4964,7 @@ has_caller_p (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n static bool\n ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n {\n-  if (!cgraph_node_can_be_local_p (node))\n+  if (!node->can_be_local_p ())\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function not local to this compilation unit.\\n\");\n@@ -5008,7 +5008,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (!cgraph_for_node_and_aliases (node, has_caller_p, NULL, true))\n+  if (!node->call_for_symbol_thunks_and_aliases (has_caller_p, NULL, true))\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n@@ -5042,7 +5042,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n static unsigned int\n ipa_early_sra (void)\n {\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   ipa_parm_adjustment_vec adjustments;\n   int ret = 0;\n \n@@ -5059,9 +5059,8 @@ ipa_early_sra (void)\n       goto simple_out;\n     }\n \n-  if (cgraph_for_node_and_aliases (node,\n-\t\t\t\t   some_callers_have_mismatched_arguments_p,\n-\t\t\t\t   NULL, true))\n+  if (node->call_for_symbol_thunks_and_aliases\n+       (some_callers_have_mismatched_arguments_p, NULL, true))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"There are callers with insufficient number of \""}, {"sha": "2910374532a9f392880b7064d061b77f9e268bd9", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1710,7 +1710,7 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n       && TREE_CODE (base) == VAR_DECL\n       && TREE_STATIC (base))\n     {\n-      struct cgraph_node *node = cgraph_get_node (callee);\n+      struct cgraph_node *node = cgraph_node::get (callee);\n       bitmap not_read;\n \n       /* FIXME: Callee can be an OMP builtin that does not have a call graph\n@@ -2078,7 +2078,7 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n       && TREE_CODE (base) == VAR_DECL\n       && TREE_STATIC (base))\n     {\n-      struct cgraph_node *node = cgraph_get_node (callee);\n+      struct cgraph_node *node = cgraph_node::get (callee);\n       bitmap not_written;\n \n       if (node"}, {"sha": "3b4a6cdf24c9c8d05265a0a15b1045339920b6ec", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -2956,7 +2956,7 @@ computation_cost (tree expr, bool speed)\n   unsigned cost;\n   /* Avoid using hard regs in ways which may be unsupported.  */\n   int regno = LAST_VIRTUAL_REGISTER + 1;\n-  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  struct cgraph_node *node = cgraph_node::get (current_function_decl);\n   enum node_frequency real_frequency = node->frequency;\n \n   node->frequency = NODE_FREQUENCY_NORMAL;"}, {"sha": "128c215954c68480b53f3b72691b45ba5a39c6db", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -4371,7 +4371,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n \t\t\t\t       \"converting indirect call to \"\n \t\t\t\t       \"function %s\\n\",\n-\t\t\t\t       cgraph_get_node (fn)->name ());\n+\t\t\t\t       cgraph_node::get (fn)->name ());\n \t\t    }\n \t\t  gimple_call_set_fndecl (stmt, fn);\n \t\t  gimple_set_modified (stmt, true);"}, {"sha": "470a324a9f3e4edc70d56dbd043b2b49c8aea8a2", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -7115,7 +7115,7 @@ ipa_pta_execute (void)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      dump_symtab (dump_file);\n+      symtab_node::dump_table (dump_file);\n       fprintf (dump_file, \"\\n\");\n     }\n \n@@ -7126,15 +7126,16 @@ ipa_pta_execute (void)\n       /* Nodes without a body are not interesting.  Especially do not\n          visit clones at this point for now - we get duplicate decls\n \t there for inline clones at least.  */\n-      if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n+      if (!node->has_gimple_body_p () || node->clone_of)\n \tcontinue;\n-      cgraph_get_body (node);\n+      node->get_body ();\n \n       gcc_assert (!node->clone_of);\n \n       vi = create_function_info_for (node->decl,\n \t\t\t             alias_get_name (node->decl));\n-      cgraph_for_node_and_aliases (node, associate_varinfo_to_alias, vi, true);\n+      node->call_for_symbol_thunks_and_aliases\n+\t(associate_varinfo_to_alias, vi, true);\n     }\n \n   /* Create constraints for global variables and their initializers.  */\n@@ -7161,7 +7162,7 @@ ipa_pta_execute (void)\n       basic_block bb;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n+      if (!node->has_gimple_body_p () || node->clone_of)\n \tcontinue;\n \n       if (dump_file)\n@@ -7265,7 +7266,7 @@ ipa_pta_execute (void)\n       basic_block bb;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n+      if (!node->has_gimple_body_p () || node->clone_of)\n \tcontinue;\n \n       fn = DECL_STRUCT_FUNCTION (node->decl);"}, {"sha": "893ad5aa0d2ae71db0ebd606a50ee2390da045bc", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -3221,7 +3221,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t      tree fndecl = gimple_call_fndecl (stmt), op;\n \t\t      if (fndecl != NULL_TREE)\n \t\t\t{\n-\t\t\t  struct cgraph_node *node = cgraph_get_node (fndecl);\n+\t\t\t  struct cgraph_node *node = cgraph_node::get (fndecl);\n \t\t\t  if (node != NULL && node->simd_clones != NULL)\n \t\t\t    {\n \t\t\t      unsigned int j, n = gimple_call_num_args (stmt);\n@@ -5690,10 +5690,10 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n \n       /* When compiling partition, be sure the symbol is not output by other\n \t partition.  */\n-      snode = symtab_get_node (decl);\n+      snode = symtab_node::get (decl);\n       if (flag_ltrans\n \t  && (snode->in_other_partition\n-\t      || symtab_get_symbol_partitioning_class (snode) == SYMBOL_DUPLICATE))\n+\t      || snode->get_partitioning_class () == SYMBOL_DUPLICATE))\n \treturn false;\n     }\n \n@@ -5707,13 +5707,13 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n      software projects.  */\n   if (TREE_STATIC (decl) \n       && DECL_SECTION_NAME (decl) != NULL\n-      && !symtab_get_node (decl)->implicit_section)\n+      && !symtab_node::get (decl)->implicit_section)\n     return false;\n \n   /* If symbol is an alias, we need to check that target is OK.  */\n   if (TREE_STATIC (decl))\n     {\n-      tree target = symtab_alias_ultimate_target (symtab_get_node (decl))->decl;\n+      tree target = symtab_node::get (decl)->ultimate_alias_target ()->decl;\n       if (target != decl)\n \t{\n \t  if (DECL_PRESERVE_P (target))"}, {"sha": "26eb2d40979aa4d15d195dbe94400f3368060093", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -2643,7 +2643,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n   if (fndecl == NULL_TREE)\n     return false;\n \n-  struct cgraph_node *node = cgraph_get_node (fndecl);\n+  struct cgraph_node *node = cgraph_node::get (fndecl);\n   if (node == NULL || node->simd_clones == NULL)\n     return false;\n \n@@ -2726,7 +2726,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n   unsigned int badness = 0;\n   struct cgraph_node *bestn = NULL;\n   if (STMT_VINFO_SIMD_CLONE_FNDECL (stmt_info))\n-    bestn = cgraph_get_node (STMT_VINFO_SIMD_CLONE_FNDECL (stmt_info));\n+    bestn = cgraph_node::get (STMT_VINFO_SIMD_CLONE_FNDECL (stmt_info));\n   else\n     for (struct cgraph_node *n = node->simd_clones; n != NULL;\n \t n = n->simdclone->next_clone)"}, {"sha": "c02653748bff82d9ab7ec80b89a0afd7ff6fedd1", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -704,7 +704,7 @@ increase_alignment (void)\n           DECL_USER_ALIGN (decl) = 1;\n \t  if (TREE_STATIC (decl))\n \t    {\n-\t      tree target = symtab_alias_ultimate_target (symtab_get_node (decl))->decl;\n+\t      tree target = symtab_node::get (decl)->ultimate_alias_target ()->decl;\n               DECL_ALIGN (target) = TYPE_ALIGN (vectype);\n               DECL_USER_ALIGN (target) = 1;\n \t    }"}, {"sha": "4ae31f4efdf2e26ba76bd505007fb99df0b5f9e2", "filename": "gcc/tree.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -603,7 +603,7 @@ decl_assembler_name (tree decl)\n tree\n decl_comdat_group (const_tree node)\n {\n-  struct symtab_node *snode = symtab_get_node (node);\n+  struct symtab_node *snode = symtab_node::get (node);\n   if (!snode)\n     return NULL;\n   return snode->get_comdat_group ();\n@@ -613,7 +613,7 @@ decl_comdat_group (const_tree node)\n tree\n decl_comdat_group_id (const_tree node)\n {\n-  struct symtab_node *snode = symtab_get_node (node);\n+  struct symtab_node *snode = symtab_node::get (node);\n   if (!snode)\n     return NULL;\n   return snode->get_comdat_group_id ();\n@@ -624,7 +624,7 @@ decl_comdat_group_id (const_tree node)\n const char *\n decl_section_name (const_tree node)\n {\n-  struct symtab_node *snode = symtab_get_node (node);\n+  struct symtab_node *snode = symtab_node::get (node);\n   if (!snode)\n     return NULL;\n   return snode->get_section ();\n@@ -639,14 +639,14 @@ set_decl_section_name (tree node, const char *value)\n \n   if (value == NULL)\n     {\n-      snode = symtab_get_node (node);\n+      snode = symtab_node::get (node);\n       if (!snode)\n \treturn;\n     }\n   else if (TREE_CODE (node) == VAR_DECL)\n     snode = varpool_node_for_decl (node);\n   else\n-    snode = cgraph_get_create_node (node);\n+    snode = cgraph_node::get_create (node);\n   snode->set_section (value);\n }\n \n@@ -5062,7 +5062,7 @@ need_assembler_name_p (tree decl)\n \treturn false;\n \n       /* Functions represented in the callgraph need an assembler name.  */\n-      if (cgraph_get_node (decl) != NULL)\n+      if (cgraph_node::get (decl) != NULL)\n \treturn true;\n \n       /* Unused and not public functions don't need an assembler name.  */\n@@ -5105,11 +5105,11 @@ free_lang_data_in_decl (tree decl)\n  if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       struct cgraph_node *node;\n-      if (!(node = cgraph_get_node (decl))\n+      if (!(node = cgraph_node::get (decl))\n \t  || (!node->definition && !node->clones))\n \t{\n \t  if (node)\n-\t    cgraph_release_function_body (node);\n+\t    node->release_body ();\n \t  else\n \t    {\n \t      release_function_body (decl);\n@@ -6488,7 +6488,7 @@ tree_decl_map_hash (const void *item)\n priority_type\n decl_init_priority_lookup (tree decl)\n {\n-  symtab_node *snode = symtab_get_node (decl);\n+  symtab_node *snode = symtab_node::get (decl);\n \n   if (!snode)\n     return DEFAULT_INIT_PRIORITY;\n@@ -6501,7 +6501,7 @@ decl_init_priority_lookup (tree decl)\n priority_type\n decl_fini_priority_lookup (tree decl)\n {\n-  cgraph_node *node = cgraph_get_node (decl);\n+  cgraph_node *node = cgraph_node::get (decl);\n \n   if (!node)\n     return DEFAULT_INIT_PRIORITY;\n@@ -6518,14 +6518,14 @@ decl_init_priority_insert (tree decl, priority_type priority)\n \n   if (priority == DEFAULT_INIT_PRIORITY)\n     {\n-      snode = symtab_get_node (decl);\n+      snode = symtab_node::get (decl);\n       if (!snode)\n \treturn;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     snode = varpool_node_for_decl (decl);\n   else\n-    snode = cgraph_get_create_node (decl);\n+    snode = cgraph_node::get_create (decl);\n   snode->set_init_priority (priority);\n }\n \n@@ -6538,12 +6538,12 @@ decl_fini_priority_insert (tree decl, priority_type priority)\n \n   if (priority == DEFAULT_INIT_PRIORITY)\n     {\n-      node = cgraph_get_node (decl);\n+      node = cgraph_node::get (decl);\n       if (!node)\n \treturn;\n     }\n   else\n-    node = cgraph_get_create_node (decl);\n+    node = cgraph_node::get_create (decl);\n   node->set_fini_priority (priority);\n }\n "}, {"sha": "54a7feb442d0c5b2bcee475e0ccd876a7af47133", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -1223,8 +1223,8 @@ init_node_map (bool local)\n   cgraph_node_map = pointer_map_create ();\n \n   FOR_EACH_DEFINED_FUNCTION (n)\n-    if (cgraph_function_with_gimple_body_p (n)\n-\t&& !cgraph_only_called_directly_p (n))\n+    if (n->has_gimple_body_p ()\n+\t&& !n->only_called_directly_p ())\n       {\n \tvoid **val;\n \tif (local)"}, {"sha": "7757995f41f95f4c9c60cec731005d41856df1a9", "filename": "gcc/varasm.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -440,8 +440,8 @@ resolve_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED,\n     {\n       targetm.asm_out.unique_section (decl, reloc);\n       if (DECL_SECTION_NAME (decl))\n-        symtab_for_node_and_aliases (symtab_get_node (decl),\n-\t\t\t\t     set_implicit_section, NULL, true);\n+\tsymtab_node::get (decl)->call_for_symbol_and_aliases\n+\t  (set_implicit_section, NULL, true);\n     }\n }\n \n@@ -521,7 +521,7 @@ get_named_text_section (tree decl,\n \t  buffer = ACONCAT ((stripped_name, named_section_suffix, NULL));\n \t  return get_named_section (decl, buffer, 0);\n \t}\n-      else if (symtab_get_node (decl)->implicit_section)\n+      else if (symtab_node::get (decl)->implicit_section)\n \t{\n \t  const char *name;\n \n@@ -550,7 +550,7 @@ default_function_section (tree decl, enum node_frequency freq,\n   /* Old GNU linkers have buggy --gc-section support, which sometimes\n      results in .gcc_except_table* sections being garbage collected.  */\n   if (decl\n-      && symtab_get_node (decl)->implicit_section)\n+      && symtab_node::get (decl)->implicit_section)\n     return NULL;\n #endif\n \n@@ -606,7 +606,7 @@ function_section_1 (tree decl, bool force_cold)\n \n   if (decl)\n     {\n-      struct cgraph_node *node = cgraph_get_node (decl);\n+      struct cgraph_node *node = cgraph_node::get (decl);\n \n       if (node)\n \t{\n@@ -1092,9 +1092,9 @@ get_variable_section (tree decl, bool prefer_noswitch_p)\n {\n   addr_space_t as = ADDR_SPACE_GENERIC;\n   int reloc;\n-  symtab_node *snode = symtab_get_node (decl);\n+  symtab_node *snode = symtab_node::get (decl);\n   if (snode)\n-    decl = symtab_alias_ultimate_target (snode)->decl;\n+    decl = snode->ultimate_alias_target ()->decl;\n \n   if (TREE_TYPE (decl) != error_mark_node)\n     as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n@@ -1210,7 +1210,7 @@ use_blocks_for_decl_p (tree decl)\n   /* If this decl is an alias, then we don't want to emit a\n      definition.  */\n   if (TREE_CODE (decl) == VAR_DECL\n-      && (snode = symtab_get_node (decl)) != NULL\n+      && (snode = symtab_node::get (decl)) != NULL\n       && snode->alias)\n     return false;\n \n@@ -1600,7 +1600,7 @@ decide_function_section (tree decl)\n \n  if (DECL_SECTION_NAME (decl))\n     {\n-      struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+      struct cgraph_node *node = cgraph_node::get (current_function_decl);\n       /* Calls to function_section rely on first_function_block_is_cold\n \t being accurate.  */\n       first_function_block_is_cold = (node\n@@ -2387,10 +2387,10 @@ mark_decl_referenced (tree decl)\n \t If we know a method will be emitted in other TU and no new\n \t functions can be marked reachable, just use the external\n \t definition.  */\n-      struct cgraph_node *node = cgraph_get_create_node (decl);\n+      struct cgraph_node *node = cgraph_node::get_create (decl);\n       if (!DECL_EXTERNAL (decl)\n \t  && !node->definition)\n-\tcgraph_mark_force_output_node (node);\n+\tnode->mark_force_output ();\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n@@ -5632,7 +5632,7 @@ assemble_alias (tree decl, tree target)\n \n   /* Allow aliases to aliases.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    cgraph_get_create_node (decl)->alias = true;\n+    cgraph_node::get_create (decl)->alias = true;\n   else\n     varpool_node_for_decl (decl)->alias = true;\n \n@@ -5728,8 +5728,8 @@ dump_tm_clone_pairs (vec<tm_alias_pair> tm_alias_pairs)\n     {\n       tree src = p->from;\n       tree dst = p->to;\n-      struct cgraph_node *src_n = cgraph_get_node (src);\n-      struct cgraph_node *dst_n = cgraph_get_node (dst);\n+      struct cgraph_node *src_n = cgraph_node::get (src);\n+      struct cgraph_node *dst_n = cgraph_node::get (dst);\n \n       /* The function ipa_tm_create_version() marks the clone as needed if\n \t the original function was needed.  But we also mark the clone as\n@@ -5880,7 +5880,7 @@ make_decl_one_only (tree decl, tree comdat_group)\n   if (TREE_CODE (decl) == VAR_DECL)\n     symbol = varpool_node_for_decl (decl);\n   else\n-    symbol = cgraph_get_create_node (decl);\n+    symbol = cgraph_node::get_create (decl);\n \n   if (SUPPORTS_ONE_ONLY)\n     {\n@@ -6701,7 +6701,7 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n     }\n   else if (TREE_CODE (exp) == FUNCTION_DECL && TREE_PUBLIC (exp))\n     {\n-      struct cgraph_node *node = cgraph_get_node (exp);\n+      struct cgraph_node *node = cgraph_node::get (exp);\n       if (node\n \t  && (resolution_local_p (node->resolution) || node->in_other_partition))\n \tresolved_locally = true;\n@@ -6792,7 +6792,7 @@ decl_binds_to_current_def_p (const_tree decl)\n     }\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_get_node (decl);\n+      struct cgraph_node *node = cgraph_node::get (decl);\n       if (node\n \t  && node->resolution != LDPR_UNKNOWN)\n \treturn resolution_to_local_definition_p (node->resolution);\n@@ -7042,10 +7042,10 @@ place_block_symbol (rtx symbol)\n       struct symtab_node *snode;\n       decl = SYMBOL_REF_DECL (symbol);\n \n-      snode = symtab_get_node (decl);\n+      snode = symtab_node::get (decl);\n       if (snode->alias)\n \t{\n-\t  rtx target = DECL_RTL (symtab_alias_ultimate_target (snode)->decl);\n+\t  rtx target = DECL_RTL (snode->ultimate_alias_target ()->decl);\n \n \t  place_block_symbol (target);\n \t  SYMBOL_REF_BLOCK_OFFSET (symbol) = SYMBOL_REF_BLOCK_OFFSET (target);"}, {"sha": "6b31e73b072f105607f65b1c3fdb751c76bd3e17", "filename": "gcc/varpool.c", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52f529517da6e1143714a274d71dcfd64b7a2f0/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=d52f529517da6e1143714a274d71dcfd64b7a2f0", "patch": "@@ -158,26 +158,27 @@ varpool_node_for_decl (tree decl)\n \n   node = varpool_create_empty_node ();\n   node->decl = decl;\n-  symtab_register_node (node);\n+  node->register_symbol ();\n   return node;\n }\n \n-/* Remove node from the varpool.  */\n+/* Remove variable from symbol table.  */\n+\n void\n-varpool_remove_node (varpool_node *node)\n+varpool_node::remove (void)\n {\n-  varpool_call_node_removal_hooks (node);\n-  symtab_unregister_node (node);\n+  varpool_call_node_removal_hooks (this);\n+  unregister ();\n \n   /* When streaming we can have multiple nodes associated with decl.  */\n   if (cgraph_state == CGRAPH_LTO_STREAMING)\n     ;\n   /* Keep constructor when it may be used for folding. We remove\n      references to external variables before final compilation.  */\n-  else if (DECL_INITIAL (node->decl) && DECL_INITIAL (node->decl) != error_mark_node\n-\t   && !varpool_ctor_useable_for_folding_p (node))\n-    varpool_remove_initializer (node);\n-  ggc_free (node);\n+  else if (DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node\n+\t   && !varpool_ctor_useable_for_folding_p (this))\n+    varpool_remove_initializer (this);\n+  ggc_free (this);\n }\n \n /* Renove node initializer when it is no longer needed.  */\n@@ -200,40 +201,40 @@ varpool_remove_initializer (varpool_node *node)\n \n /* Dump given cgraph node.  */\n void\n-dump_varpool_node (FILE *f, varpool_node *node)\n+varpool_node::dump (FILE *f)\n {\n-  dump_symtab_base (f, node);\n+  dump_base (f);\n   fprintf (f, \"  Availability: %s\\n\",\n \t   cgraph_function_flags_ready\n-\t   ? cgraph_availability_names[cgraph_variable_initializer_availability (node)]\n+\t   ? cgraph_availability_names[cgraph_variable_initializer_availability (this)]\n \t   : \"not-ready\");\n   fprintf (f, \"  Varpool flags:\");\n-  if (DECL_INITIAL (node->decl))\n+  if (DECL_INITIAL (decl))\n     fprintf (f, \" initialized\");\n-  if (node->output)\n+  if (output)\n     fprintf (f, \" output\");\n-  if (node->used_by_single_function)\n+  if (used_by_single_function)\n     fprintf (f, \" used-by-single-function\");\n-  if (TREE_READONLY (node->decl))\n+  if (TREE_READONLY (decl))\n     fprintf (f, \" read-only\");\n-  if (varpool_ctor_useable_for_folding_p (node))\n+  if (varpool_ctor_useable_for_folding_p (this))\n     fprintf (f, \" const-value-known\");\n-  if (node->writeonly)\n+  if (writeonly)\n     fprintf (f, \" write-only\");\n-  if (node->tls_model)\n-    fprintf (f, \" %s\", tls_model_names [node->tls_model]);\n+  if (tls_model)\n+    fprintf (f, \" %s\", tls_model_names [tls_model]);\n   fprintf (f, \"\\n\");\n }\n \n-/* Dump the variable pool.  */\n+/* Dump the variable pool to F.  */\n void\n dump_varpool (FILE *f)\n {\n   varpool_node *node;\n \n   fprintf (f, \"variable pool:\\n\\n\");\n   FOR_EACH_VARIABLE (node)\n-    dump_varpool_node (f, node);\n+    node->dump (f);\n }\n \n /* Dump the variable pool to stderr.  */\n@@ -459,7 +460,7 @@ cgraph_variable_initializer_availability (varpool_node *node)\n      used to share template instantiations in C++.  */\n   if (decl_replaceable_p (node->decl)\n       || DECL_EXTERNAL (node->decl))\n-    return AVAIL_OVERWRITABLE;\n+    return AVAIL_INTERPOSABLE;\n   return AVAIL_AVAILABLE;\n }\n \n@@ -479,8 +480,7 @@ varpool_analyze_node (varpool_node *node)\n       align_variable (decl, 0);\n     }\n   if (node->alias)\n-    symtab_resolve_alias\n-       (node, varpool_get_node (node->alias_target));\n+    node->resolve_alias (varpool_get_node (node->alias_target));\n   else if (DECL_INITIAL (decl))\n     record_references_in_initializer (decl, node->analyzed);\n   node->analyzed = true;\n@@ -607,7 +607,7 @@ varpool_remove_unreferenced_decls (void)\n \t       next = next->same_comdat_group)\n \t    {\n \t      varpool_node *vnext = dyn_cast <varpool_node *> (next);\n-\t      if (vnext && vnext->analyzed && !symtab_comdat_local_p (next))\n+\t      if (vnext && vnext->analyzed && !next->comdat_local_p ())\n \t\tenqueue_node (vnext, &first);\n \t    }\n \t}\n@@ -636,7 +636,7 @@ varpool_remove_unreferenced_decls (void)\n \t  if (pointer_set_contains (referenced, node))\n \t    varpool_remove_initializer (node);\n \t  else\n-\t    varpool_remove_node (node);\n+\t    node->remove ();\n \t}\n     }\n   pointer_set_destroy (referenced);\n@@ -745,8 +745,7 @@ varpool_extra_name_alias (tree alias, tree decl)\n      This is unfortunate because they are not going through the\n      standard channels.  Ensure they get output.  */\n   if (cpp_implicit_aliases_done)\n-    symtab_resolve_alias (alias_node,\n-\t\t\t  varpool_node_for_decl (decl));\n+    alias_node->resolve_alias (varpool_node_for_decl (decl));\n   return alias_node;\n }\n \n@@ -769,7 +768,7 @@ varpool_for_node_and_aliases (varpool_node *node,\n     {\n       varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n       if (include_overwritable\n-\t  || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n+\t  || cgraph_variable_initializer_availability (alias) > AVAIL_INTERPOSABLE)\n \tif (varpool_for_node_and_aliases (alias, callback, data,\n \t\t\t\t\t include_overwritable))\n \t  return true;"}]}