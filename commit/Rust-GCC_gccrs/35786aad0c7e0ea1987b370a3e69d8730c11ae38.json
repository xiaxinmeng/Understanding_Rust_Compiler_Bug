{"sha": "35786aad0c7e0ea1987b370a3e69d8730c11ae38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU3ODZhYWQwYzdlMGVhMTk4N2IzNzBhM2U2OWQ4NzMwYzExYWUzOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-12-22T10:35:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-12-22T10:35:11Z"}, "message": "decl.c (gnat_to_gnu_field): Post the error message for parent overlapping on the position instead of on the...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_field): Post the error message\n\tfor parent overlapping on the position instead of on the first bit.\n\tFor a field that needs strict alignment, issue the error for the\n\tposition first and, for the size, issue an error if it is too large\n\tonly for the atomic and aliased cases.  Issue a specific error if\n\tthe size is not a multiple of a byte in the volatile and the stric\n\talignment cases.\n\nFrom-SVN: r219009", "tree": {"sha": "7ddf72bf92958ca92d659c5845982019b3cbb3c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ddf72bf92958ca92d659c5845982019b3cbb3c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35786aad0c7e0ea1987b370a3e69d8730c11ae38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35786aad0c7e0ea1987b370a3e69d8730c11ae38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35786aad0c7e0ea1987b370a3e69d8730c11ae38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35786aad0c7e0ea1987b370a3e69d8730c11ae38/comments", "author": null, "committer": null, "parents": [{"sha": "ae9f434509517d4c6671bc197d0d64ef7cf74cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9f434509517d4c6671bc197d0d64ef7cf74cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9f434509517d4c6671bc197d0d64ef7cf74cde"}], "stats": {"total": 198, "additions": 122, "deletions": 76}, "files": [{"sha": "c6364eb22d15b13ed89766646882d3f52be13c15", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=35786aad0c7e0ea1987b370a3e69d8730c11ae38", "patch": "@@ -1,3 +1,13 @@\n+2014-12-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_field): Post the error message\n+\tfor parent overlapping on the position instead of on the first bit.\n+\tFor a field that needs strict alignment, issue the error for the\n+\tposition first and, for the size, issue an error if it is too large\n+\tonly for the atomic and aliased cases.  Issue a specific error if\n+\tthe size is not a multiple of a byte in the volatile and the stric\n+\talignment cases.\n+\n 2014-12-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (check_ok_for_atomic): Rename into..."}, {"sha": "fda3f0cc63e4a3647c0b4e9cd2831ef379c87e4f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 74, "deletions": 67, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=35786aad0c7e0ea1987b370a3e69d8730c11ae38", "patch": "@@ -6414,12 +6414,14 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   tree gnu_field_type = gnat_to_gnu_type (gnat_field_type);\n   tree gnu_field_id = get_entity_name (gnat_field);\n   tree gnu_field, gnu_size, gnu_pos;\n+  bool is_aliased\n+    = Is_Aliased (gnat_field);\n+  bool is_atomic\n+    = (Is_Atomic (gnat_field) || Is_Atomic (gnat_field_type));\n   bool is_volatile\n     = (Treat_As_Volatile (gnat_field) || Treat_As_Volatile (gnat_field_type));\n   bool needs_strict_alignment\n-    = (is_volatile\n-       || Is_Aliased (gnat_field)\n-       || Strict_Alignment (gnat_field_type));\n+    = (is_aliased || is_volatile || Strict_Alignment (gnat_field_type));\n \n   /* If this field requires strict alignment, we cannot pack it because\n      it would very likely be under-aligned in the record.  */\n@@ -6488,6 +6490,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \n   if (Present (Component_Clause (gnat_field)))\n     {\n+      Node_Id gnat_clause = Component_Clause (gnat_field);\n       Entity_Id gnat_parent\n \t= Parent_Subtype (Underlying_Type (Scope (gnat_field)));\n \n@@ -6506,91 +6509,95 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \n \t  if (TREE_CODE (TYPE_SIZE (gnu_parent)) == INTEGER_CST\n \t      && tree_int_cst_lt (gnu_pos, TYPE_SIZE (gnu_parent)))\n-\t    {\n-\t      post_error_ne_tree\n-\t\t(\"offset of& must be beyond parent{, minimum allowed is ^}\",\n-\t\t First_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t TYPE_SIZE_UNIT (gnu_parent));\n-\t    }\n+\t    post_error_ne_tree\n+\t      (\"offset of& must be beyond parent{, minimum allowed is ^}\",\n+\t       Position (gnat_clause), gnat_field, TYPE_SIZE_UNIT (gnu_parent));\n \t}\n \n-      /* If this field needs strict alignment, check that the record is\n-\t sufficiently aligned and that position and size are consistent with\n-\t the alignment.  But don't do it if we are just annotating types and\n+      /* If this field needs strict alignment, make sure that the record is\n+\t sufficiently aligned and that the position and size are consistent\n+\t with the type.  But don't do it if we are just annotating types and\n \t the field's type is tagged, since tagged types aren't fully laid out\n \t in this mode.  Also, note that atomic implies volatile so the inner\n \t test sequences ordering is significant here.  */\n       if (needs_strict_alignment\n \t  && !(type_annotate_only && Is_Tagged_Type (gnat_field_type)))\n \t{\n-\t  TYPE_ALIGN (gnu_record_type)\n-\t    = MAX (TYPE_ALIGN (gnu_record_type), TYPE_ALIGN (gnu_field_type));\n+\t  const unsigned int type_align = TYPE_ALIGN (gnu_field_type);\n+\n+\t  if (TYPE_ALIGN (gnu_record_type) < type_align)\n+\t    TYPE_ALIGN (gnu_record_type) = type_align;\n \n-\t  if (gnu_size\n-\t      && !operand_equal_p (gnu_size, TYPE_SIZE (gnu_field_type), 0))\n+\t  /* If the position is not a multiple of the alignment of the type,\n+\t     then error out and reset the position.  */\n+\t  if (!integer_zerop (size_binop (TRUNC_MOD_EXPR, gnu_pos,\n+\t\t\t\t\t  bitsize_int (type_align))))\n \t    {\n-\t      if (Is_Atomic (gnat_field) || Is_Atomic (gnat_field_type))\n-\t\tpost_error_ne_tree\n-\t\t  (\"atomic field& must be natural size of type{ (^)}\",\n-\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_SIZE (gnu_field_type));\n+\t      const char *s;\n \n+\t      if (is_atomic)\n+\t\ts = \"position of atomic field& must be multiple of ^ bits\";\n+\t      else if (is_aliased)\n+\t\ts = \"position of aliased field& must be multiple of ^ bits\";\n \t      else if (is_volatile)\n-\t\tpost_error_ne_tree\n-\t\t  (\"volatile field& must be natural size of type{ (^)}\",\n-\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_SIZE (gnu_field_type));\n-\n-\t      else if (Is_Aliased (gnat_field))\n-\t\tpost_error_ne_tree\n-\t\t  (\"size of aliased field& must be ^ bits\",\n-\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_SIZE (gnu_field_type));\n-\n+\t\ts = \"position of volatile field& must be multiple of ^ bits\";\n \t      else if (Strict_Alignment (gnat_field_type))\n-\t\tpost_error_ne_tree\n-\t\t  (\"size of & with aliased or tagged components not ^ bits\",\n-\t\t   Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_SIZE (gnu_field_type));\n-\n-              else\n+\t\ts = \"position of & with aliased or tagged part must be\"\n+\t\t    \" multiple of ^ bits\";\n+\t      else\n \t\tgcc_unreachable ();\n \n-\t      gnu_size = NULL_TREE;\n+\t      post_error_ne_num (s, First_Bit (gnat_clause), gnat_field,\n+\t\t\t\t type_align);\n+\t      gnu_pos = NULL_TREE;\n \t    }\n \n-\t  if (!integer_zerop (size_binop\n-\t\t\t      (TRUNC_MOD_EXPR, gnu_pos,\n-\t\t\t       bitsize_int (TYPE_ALIGN (gnu_field_type)))))\n+\t  if (gnu_size)\n \t    {\n-\t      if (Is_Atomic (gnat_field) || Is_Atomic (gnat_field_type))\n-\t\tpost_error_ne_num\n-\t\t  (\"position of atomic field& must be multiple of ^ bits\",\n-\t\t   First_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_ALIGN (gnu_field_type));\n-\n-              else if (is_volatile)\n-\t\tpost_error_ne_num\n-\t\t  (\"position of volatile field& must be multiple of ^ bits\",\n-\t\t   First_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_ALIGN (gnu_field_type));\n-\n-\t      else if (Is_Aliased (gnat_field))\n-\t\tpost_error_ne_num\n-\t\t  (\"position of aliased field& must be multiple of ^ bits\",\n-\t\t   First_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t   TYPE_ALIGN (gnu_field_type));\n+\t      tree gnu_type_size = TYPE_SIZE (gnu_field_type);\n+\t      const int cmp = tree_int_cst_compare (gnu_size, gnu_type_size);\n \n-\t      else if (Strict_Alignment (gnat_field_type))\n-\t\tpost_error_ne\n-\t\t  (\"position of & is not compatible with alignment required \"\n-\t\t   \"by its components\",\n-\t\t    First_Bit (Component_Clause (gnat_field)), gnat_field);\n+\t      /* If the size is lower than that of the type, or greater for\n+\t\t atomic and aliased, then error out and reset the size.  */\n+\t      if (cmp < 0 || (cmp > 0 && (is_atomic || is_aliased)))\n+\t\t{\n+\t\t  const char *s;\n+\n+\t\t  if (is_atomic)\n+\t\t    s = \"size of atomic field& must be ^ bits\";\n+\t\t  else if (is_aliased)\n+\t\t    s = \"size of aliased field& must be ^ bits\";\n+\t\t  else if (is_volatile)\n+\t\t    s = \"size of volatile field& must be at least ^ bits\";\n+\t\t  else if (Strict_Alignment (gnat_field_type))\n+\t\t    s = \"size of & with aliased or tagged part must be\"\n+\t\t\t\" at least ^ bits\";\n+\t\t  else\n+\t\t    gcc_unreachable ();\n \n-\t      else\n-\t\tgcc_unreachable ();\n+\t\t  post_error_ne_tree (s, Last_Bit (gnat_clause), gnat_field,\n+\t\t\t\t      gnu_type_size);\n+\t\t  gnu_size = NULL_TREE;\n+\t\t}\n \n-\t      gnu_pos = NULL_TREE;\n+\t      /* Likewise if the size is not a multiple of a byte,  */\n+\t      else if (!integer_zerop (size_binop (TRUNC_MOD_EXPR, gnu_size,\n+\t\t\t\t\t\t   bitsize_unit_node)))\n+\t\t{\n+\t\t  const char *s;\n+\n+\t\t  if (is_volatile)\n+\t\t    s = \"size of volatile field& must be multiple of\"\n+\t\t\t\" Storage_Unit\";\n+\t\t  else if (Strict_Alignment (gnat_field_type))\n+\t\t    s = \"size of & with aliased or tagged part must be\"\n+\t\t\t\" multiple of Storage_Unit\";\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\n+\t\t  post_error_ne (s, Last_Bit (gnat_clause), gnat_field);\n+\t\t  gnu_size = NULL_TREE;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "9e17c5cd3fc73e3a7d5b3ccbc2b0fc4d627b2338", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35786aad0c7e0ea1987b370a3e69d8730c11ae38", "patch": "@@ -1,3 +1,9 @@\n+2014-12-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/volatile1.ads: New test.\n+\t* gnat.dg/specs/clause_on_volatile.ads: Adjust.\n+\t* gnat.dg/specs/size_clause3.ads: Likewise.\n+\n 2014-12-22  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR rtl-optimization/62151"}, {"sha": "68799a757a2b48f69d2440474052f420fb49abe9", "filename": "gcc/testsuite/gnat.dg/specs/clause_on_volatile.ads", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fclause_on_volatile.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fclause_on_volatile.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fclause_on_volatile.ads?ref=35786aad0c7e0ea1987b370a3e69d8730c11ae38", "patch": "@@ -21,15 +21,15 @@ package Clause_On_Volatile is\n      W : Word;\n   end record;\n   for R1 use record\n-     W at 0 range 0 .. 15; -- OK, packing regular\n+     W at 0 range 0 .. 15; -- OK\n   end record;\n \n   type A1 is record\n      AW : Aword;\n   end record;\n   For A1'Alignment use 4;\n   for A1 use record\n-     AW at 0 range 0 .. 15; -- { dg-error \"must be natural size\" }\n+     AW at 0 range 0 .. 15; -- { dg-error \"must be \\[0-9\\]*\" }\n   end record;\n \n   type A2 is record\n@@ -49,17 +49,15 @@ package Clause_On_Volatile is\n   For A3'Alignment use 4;\n   for A3 use record\n      B at 0 range 0 .. 7;\n-     AW at 1 range 0 .. 15; -- { dg-error \"must be (multiple|natural size)\" }\n+     AW at 1 range 0 .. 15; -- { dg-error \"must be (multiple||\\[0-9\\]*)\" }\n   end record;\n \n-  --\n-\n   type V1 is record\n      VW : Vword;\n   end record;\n   For V1'Alignment use 4;\n   for V1 use record\n-     VW at 0 range 0 .. 15; -- { dg-error \"must be natural size\" }\n+     VW at 0 range 0 .. 15; -- { dg-error \"must be at least\" }\n   end record;\n \n   type V2 is record\n@@ -79,7 +77,7 @@ package Clause_On_Volatile is\n   For V3'Alignment use 4;\n   for V3 use record\n      B at 0 range 0 .. 7;\n-     VW at 1 range 0 .. 15; -- { dg-error \"must be (multiple|natural size)\" }\n+     VW at 1 range 0 .. 15; -- { dg-error \"must be (multiple|at least)\" }\n   end record;\n \n end Clause_On_Volatile;"}, {"sha": "b7602d9527db636b50bb4b331b20c1bb2a719b91", "filename": "gcc/testsuite/gnat.dg/specs/size_clause3.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fsize_clause3.ads?ref=35786aad0c7e0ea1987b370a3e69d8730c11ae38", "patch": "@@ -14,7 +14,7 @@ package Size_Clause3 is\n     rr : R1; -- size must be 40\n   end record;\n   for S1 use record\n-    rr at 0 range 0 .. 39;  -- { dg-error \"size of .rr. with aliased or tagged component\" }\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size of .rr. with aliased or tagged\" }\n   end record;\n \n   -- The record is explicitly given alignment 1 so its real type is 40.\n@@ -44,7 +44,7 @@ package Size_Clause3 is\n     rr : R3; -- size must be 40\n   end record;\n   for S3 use record\n-    rr at 0 range 0 .. 39;  -- { dg-error \"size of .rr. with aliased or tagged component\" }\n+    rr at 0 range 0 .. 39;  -- { dg-error \"size of .rr. with aliased or tagged\" }\n   end record;\n \n end Size_Clause3;"}, {"sha": "40ad4806e479710c9c90f52d0b5176dce2ec52e7", "filename": "gcc/testsuite/gnat.dg/specs/volatile1.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fvolatile1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35786aad0c7e0ea1987b370a3e69d8730c11ae38/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fvolatile1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fvolatile1.ads?ref=35786aad0c7e0ea1987b370a3e69d8730c11ae38", "patch": "@@ -0,0 +1,25 @@\n+-- { dg-do compile }\n+\n+package Volatile1 is\n+\n+  C : Character;\n+  for C'Size use 32;\n+  pragma Volatile (C);\n+\n+  type R1 is record\n+    C: Character;\n+    pragma Volatile (C);\n+  end record;\n+  for R1 use record\n+    C at 0 range 0 .. 31;\n+  end record;\n+\n+  type R2 is record\n+    C: Character;\n+    pragma Volatile (C);\n+  end record;\n+  for R2 use record\n+    C at 0 range 0 .. 10; -- { dg-error \"size of volatile field\" }\n+  end record;\n+\n+end Volatile1;"}]}