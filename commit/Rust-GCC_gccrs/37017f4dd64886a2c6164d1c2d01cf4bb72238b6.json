{"sha": "37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcwMTdmNGRkNjQ4ODZhMmM2MTY0ZDFjMmQwMWNmNGJiNzIyMzhiNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-18T19:26:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-18T19:26:20Z"}, "message": "mips.h (STARTING_FRAME_OFFSET): Remove rtl profiling code.\n\ngcc/\n\t* config/mips/mips.h (STARTING_FRAME_OFFSET): Remove rtl\n\tprofiling code.\n\t* config/mips/mips.c (mips_frame_info): Give num_gp and num_fp type\n\t\"unsigned int\" rather than \"int\" and put them with the other\n\tregister-related fields.  Put expanded comments above fields\n\trather than to their right.\n\t(mips16e_mask_registers): Replace the GP_REG_SIZE_PTR argument\n\twith a NUM_REGS_PTR argument.\n\t(mips16e_save_restore_pattern_p): Update accordingly.\n\t(compute_frame_size): Clarify frame diagram.  Rewrite.\n\nFrom-SVN: r129456", "tree": {"sha": "5b7fed98ef926447bf38a572fae6f74a419bb675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b7fed98ef926447bf38a572fae6f74a419bb675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/comments", "author": null, "committer": null, "parents": [{"sha": "4103055723a43d6c6da84798e7152030a8675713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4103055723a43d6c6da84798e7152030a8675713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4103055723a43d6c6da84798e7152030a8675713"}], "stats": {"total": 393, "additions": 193, "deletions": 200}, "files": [{"sha": "c372a59db8db28c849a95e94729beece67c93ab6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "patch": "@@ -1,3 +1,16 @@\n+2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.h (STARTING_FRAME_OFFSET): Remove rtl\n+\tprofiling code.\n+\t* config/mips/mips.c (mips_frame_info): Give num_gp and num_fp type\n+\t\"unsigned int\" rather than \"int\" and put them with the other\n+\tregister-related fields.  Put expanded comments above fields\n+\trather than to their right.\n+\t(mips16e_mask_registers): Replace the GP_REG_SIZE_PTR argument\n+\twith a NUM_REGS_PTR argument.\n+\t(mips16e_save_restore_pattern_p): Update accordingly.\n+\t(compute_frame_size): Clarify frame diagram.  Rewrite.\n+\n 2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips-ftypes.def: New file."}, {"sha": "f25305bd618d0d25c0459017461e1beb038b2d21", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 178, "deletions": 187, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "patch": "@@ -239,21 +239,44 @@ static const char *const mips_fp_conditions[] = {\n \n struct mips_frame_info GTY(())\n {\n-  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up */\n-  HOST_WIDE_INT var_size;\t/* # bytes that variables take up */\n-  HOST_WIDE_INT args_size;\t/* # bytes that outgoing arguments take up */\n-  HOST_WIDE_INT cprestore_size;\t/* # bytes that the .cprestore slot takes up */\n-  HOST_WIDE_INT gp_reg_size;\t/* # bytes needed to store gp regs */\n-  HOST_WIDE_INT fp_reg_size;\t/* # bytes needed to store fp regs */\n-  unsigned int mask;\t\t/* mask of saved gp registers */\n-  unsigned int fmask;\t\t/* mask of saved fp registers */\n-  HOST_WIDE_INT gp_save_offset;\t/* offset from vfp to store gp registers */\n-  HOST_WIDE_INT fp_save_offset;\t/* offset from vfp to store fp registers */\n-  HOST_WIDE_INT gp_sp_offset;\t/* offset from new sp to store gp registers */\n-  HOST_WIDE_INT fp_sp_offset;\t/* offset from new sp to store fp registers */\n-  bool initialized;\t\t/* true if frame size already calculated */\n-  int num_gp;\t\t\t/* number of gp registers saved */\n-  int num_fp;\t\t\t/* number of fp registers saved */\n+  /* The size of the frame in bytes.  */\n+  HOST_WIDE_INT total_size;\n+\n+  /* The number of bytes allocated to variables.  */\n+  HOST_WIDE_INT var_size;\n+\n+  /* The number of bytes allocated to outgoing function arguments.  */\n+  HOST_WIDE_INT args_size;\n+\n+  /* The number of bytes allocated to the .cprestore slot, or 0 if there\n+     is no such slot.  */\n+  HOST_WIDE_INT cprestore_size;\n+\n+  /* The size in bytes of the GPR and FPR save areas.  */\n+  HOST_WIDE_INT gp_reg_size;\n+  HOST_WIDE_INT fp_reg_size;\n+\n+  /* Bit X is set if the function saves or restores GPR X.  */\n+  unsigned int mask;\n+\n+  /* Likewise FPR X.  */\n+  unsigned int fmask;\n+\n+  /* The number of GPRs and FPRs saved.  */\n+  unsigned int num_gp;\n+  unsigned int num_fp;\n+\n+  /* The offset of the topmost GPR and FPR save slots from the top of\n+     the frame, or zero if no such slots are needed.  */\n+  HOST_WIDE_INT gp_save_offset;\n+  HOST_WIDE_INT fp_save_offset;\n+\n+  /* Likewise, but giving offsets from the bottom of the frame.  */\n+  HOST_WIDE_INT gp_sp_offset;\n+  HOST_WIDE_INT fp_sp_offset;\n+\n+  /* True if this structure has been initialized after reload.  */\n+  bool initialized;\n };\n \n struct machine_function GTY(()) {\n@@ -7249,22 +7272,22 @@ mips16e_find_first_register (unsigned int mask, const unsigned char *regs,\n   return i;\n }\n \n-/* *MASK_PTR is a mask of general purpose registers and *GP_REG_SIZE_PTR\n-   is the number of bytes that they occupy.  If *MASK_PTR contains REGS[X]\n-   for some X in [0, SIZE), adjust *MASK_PTR and *GP_REG_SIZE_PTR so that\n-   the same is true for all indexes (X, SIZE).  */\n+/* *MASK_PTR is a mask of general-purpose registers and *NUM_REGS_PTR\n+   is the number of set bits.  If *MASK_PTR contains REGS[X] for some X\n+   in [0, SIZE), adjust *MASK_PTR and *NUM_REGS_PTR so that the same\n+   is true for all indexes (X, SIZE).  */\n \n static void\n mips16e_mask_registers (unsigned int *mask_ptr, const unsigned char *regs,\n-\t\t\tunsigned int size, HOST_WIDE_INT *gp_reg_size_ptr)\n+\t\t\tunsigned int size, unsigned int *num_regs_ptr)\n {\n   unsigned int i;\n \n   i = mips16e_find_first_register (*mask_ptr, regs, size);\n   for (i++; i < size; i++)\n     if (!BITSET_P (*mask_ptr, regs[i]))\n       {\n-\t*gp_reg_size_ptr += GET_MODE_SIZE (gpr_mode);\n+\t*num_regs_ptr += 1;\n \t*mask_ptr |= 1 << regs[i];\n       }\n }\n@@ -7507,8 +7530,8 @@ bool\n mips16e_save_restore_pattern_p (rtx pattern, HOST_WIDE_INT adjust,\n \t\t\t\tstruct mips16e_save_restore_info *info)\n {\n-  unsigned int i, nargs, mask;\n-  HOST_WIDE_INT top_offset, save_offset, offset, extra;\n+  unsigned int i, nargs, mask, extra;\n+  HOST_WIDE_INT top_offset, save_offset, offset;\n   rtx set, reg, mem, base;\n   int n;\n \n@@ -7816,203 +7839,171 @@ mips_save_reg_p (unsigned int regno)\n \n    MIPS stack frames look like:\n \n-             Before call\t\t        After call\n-   high +-----------------------+\t+-----------------------+\n-   mem. |\t\t\t|       |      \t\t\t|\n-\t|  caller's temps.    \t|       |  caller's temps.    \t|\n-\t|       \t\t|       |       \t        |\n-        +-----------------------+\t+-----------------------+\n- \t|       \t\t|\t|\t\t        |\n-        |  arguments on stack.  |\t|  arguments on stack.  |\n-\t|       \t\t|\t|\t\t\t|\n-        +-----------------------+\t+-----------------------+\n- \t|  4 words to save     \t|\t|  4 words to save\t|\n-\t|  arguments passed\t|\t|  arguments passed\t|\n-\t|  in registers, even\t|\t|  in registers, even\t|\n-        |  if not passed.       |       |  if not passed.\t|\n-    SP->+-----------------------+  VFP->+-----------------------+\n-\t        (VFP = SP+fp_sp_offset) |\t\t        |\\\n-\t\t\t\t\t|  fp register save     | | fp_reg_size\n-\t\t\t\t\t|\t\t\t|/\n-\t\t       SP+gp_sp_offset->+-----------------------+\n-\t\t\t\t       /|\t\t        |\\\n-\t\t\t\t      | |  gp register save     | | gp_reg_size\n-\t\t       gp_reg_rounded | |       \t\t|/\n-\t\t\t\t      |\t+-----------------------+\n-\t\t\t\t       \\|  alignment padding    |\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t        |\\\n-\t\t\t\t\t|  local variables\t| | var_size\n-\t\t\t\t\t|\t\t\t|/\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t|  alloca allocations   |\n-\t\t\t\t\t|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t       /|\t\t\t|\n-\t\t       cprestore_size | |  GP save for V.4 abi\t|\n-\t\t\t\t       \\|\t\t\t|\n-\t\t\t\t\t+-----------------------+\n-\t\t\t\t\t|\t\t\t|\\\n-\t\t\t\t\t|  arguments on stack   | |\n-\t\t\t\t\t|\t\t        | |\n-\t\t\t\t\t+-----------------------+ |\n-\t\t\t\t\t|  4 words to save      | | args_size\n-\t\t\t\t\t|  arguments passed     | |\n-\t\t\t\t\t|  in registers, even   | |\n-\t\t\t\t\t|  if not passed.       | |\n-   low\t\t\t\t\t|  (TARGET_OLDABI only) |/\n-   memory\t\t\t    SP->+-----------------------+\n-\n-*/\n+\t+-------------------------------+\n+\t|                               |\n+\t|  incoming stack arguments     |\n+\t|                               |\n+\t+-------------------------------+\n+\t|                               |\n+\t|  caller-allocated save area   |\n+      A |  for register arguments       |\n+\t|                               |\n+\t+-------------------------------+ <-- incoming stack pointer\n+\t|                               |\n+\t|  callee-allocated save area   |\n+      B |  for arguments that are       |\n+\t|  split between registers and  |\n+\t|  the stack                    |\n+\t|                               |\n+\t+-------------------------------+ <-- arg_pointer_rtx\n+\t|                               |\n+      C |  callee-allocated save area   |\n+\t|  for register varargs         |\n+\t|                               |\n+\t+-------------------------------+ <-- frame_pointer_rtx + fp_sp_offset\n+\t|                               |       + UNITS_PER_HWFPVALUE\n+\t|  FPR save area                |\n+\t|                               |\n+\t+-------------------------------+ <-- frame_pointer_rtx + gp_sp_offset\n+\t|                               |       + UNITS_PER_WORD\n+\t|  GPR save area                |\n+\t|                               |\n+\t+-------------------------------+\n+\t|                               | \\\n+\t|  local variables              |  | var_size\n+\t|                               | /\n+\t+-------------------------------+\n+\t|                               | \\\n+\t|  $gp save area                |  | cprestore_size\n+\t|                               | /\n+      P +-------------------------------+ <-- hard_frame_pointer_rtx for\n+\t|                               |       MIPS16 code\n+\t|  outgoing stack arguments     |\n+\t|                               |\n+\t+-------------------------------+\n+\t|                               |\n+\t|  caller-allocated save area   |\n+\t|  for register arguments       |\n+\t|                               |\n+\t+-------------------------------+ <-- stack_pointer_rtx\n+\t\t\t\t\t      frame_pointer_rtx\n+\t\t\t\t\t      hard_frame_pointer_rtx for\n+\t\t\t\t\t\tnon-MIPS16 code.\n+\n+   At least two of A, B and C will be empty.\n+\n+   Dynamic stack allocations such as alloca insert data at point P.\n+   They decrease stack_pointer_rtx but leave frame_pointer_rtx and\n+   hard_frame_pointer_rtx unchanged.  */\n \n HOST_WIDE_INT\n compute_frame_size (HOST_WIDE_INT size)\n {\n-  unsigned int regno;\n-  HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up */\n-  HOST_WIDE_INT var_size;\t/* # bytes that variables take up */\n-  HOST_WIDE_INT args_size;\t/* # bytes that outgoing arguments take up */\n-  HOST_WIDE_INT cprestore_size; /* # bytes that the cprestore slot takes up */\n-  HOST_WIDE_INT gp_reg_rounded;\t/* # bytes needed to store gp after rounding */\n-  HOST_WIDE_INT gp_reg_size;\t/* # bytes needed to store gp regs */\n-  HOST_WIDE_INT fp_reg_size;\t/* # bytes needed to store fp regs */\n-  unsigned int mask;\t\t/* mask of saved gp registers */\n-  unsigned int fmask;\t\t/* mask of saved fp registers */\n-\n-  cfun->machine->global_pointer = mips_global_pointer ();\n-\n-  gp_reg_size = 0;\n-  fp_reg_size = 0;\n-  mask = 0;\n-  fmask\t= 0;\n-  var_size = MIPS_STACK_ALIGN (size);\n-  args_size = current_function_outgoing_args_size;\n-  cprestore_size = MIPS_STACK_ALIGN (STARTING_FRAME_OFFSET) - args_size;\n+  struct mips_frame_info *frame;\n+  HOST_WIDE_INT offset;\n+  unsigned int regno, i;\n \n-  /* The space set aside by STARTING_FRAME_OFFSET isn't needed in leaf\n-     functions.  If the function has local variables, we're committed\n-     to allocating it anyway.  Otherwise reclaim it here.  */\n-  if (var_size == 0 && current_function_is_leaf)\n-    cprestore_size = args_size = 0;\n+  frame = &cfun->machine->frame;\n+  memset (frame, 0, sizeof (*frame));\n \n-  /* The MIPS 3.0 linker does not like functions that dynamically\n-     allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n-     looks like we are trying to create a second frame pointer to the\n-     function, so allocate some stack space to make it happy.  */\n+  cfun->machine->global_pointer = mips_global_pointer ();\n \n-  if (args_size == 0 && current_function_calls_alloca)\n-    args_size = 4 * UNITS_PER_WORD;\n+  /* The first STARTING_FRAME_OFFSET bytes contain the outgoing argument\n+     area and the $gp save slot.  This area isn't needed in leaf functions,\n+     but if the target-independent frame size is nonzero, we're committed\n+     to allocating it anyway.  */\n+  if (size == 0 && current_function_is_leaf)\n+    {\n+      /* The MIPS 3.0 linker does not like functions that dynamically\n+\t allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n+\t looks like we are trying to create a second frame pointer to the\n+\t function, so allocate some stack space to make it happy.  */\n+      if (current_function_calls_alloca)\n+\tframe->args_size = REG_PARM_STACK_SPACE (cfun->decl);\n+      else\n+\tframe->args_size = 0;\n+      frame->cprestore_size = 0;\n+    }\n+  else\n+    {\n+      frame->args_size = current_function_outgoing_args_size;\n+      frame->cprestore_size = STARTING_FRAME_OFFSET - frame->args_size;\n+    }\n+  offset = frame->args_size + frame->cprestore_size;\n \n-  total_size = var_size + args_size + cprestore_size;\n+  /* Move above the local variables.  */\n+  frame->var_size = MIPS_STACK_ALIGN (size);\n+  offset += frame->var_size;\n \n-  /* Calculate space needed for gp registers.  */\n+  /* Find out which GPRs we need to save.  */\n   for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n     if (mips_save_reg_p (regno))\n       {\n-\tgp_reg_size += GET_MODE_SIZE (gpr_mode);\n-\tmask |= 1 << (regno - GP_REG_FIRST);\n+\tframe->num_gp++;\n+\tframe->mask |= 1 << (regno - GP_REG_FIRST);\n       }\n \n-  /* We need to restore these for the handler.  */\n+  /* If this function calls eh_return, we must also save and restore the\n+     EH data registers.  */\n   if (current_function_calls_eh_return)\n-    {\n-      unsigned int i;\n-      for (i = 0; ; ++i)\n-\t{\n-\t  regno = EH_RETURN_DATA_REGNO (i);\n-\t  if (regno == INVALID_REGNUM)\n-\t    break;\n-\t  gp_reg_size += GET_MODE_SIZE (gpr_mode);\n-\t  mask |= 1 << (regno - GP_REG_FIRST);\n-\t}\n-    }\n+    for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; i++)\n+      {\n+\tframe->num_gp++;\n+\tframe->mask |= 1 << (EH_RETURN_DATA_REGNO (i) - GP_REG_FIRST);\n+      }\n \n   /* The MIPS16e SAVE and RESTORE instructions have two ranges of registers:\n      $a3-$a0 and $s2-$s8.  If we save one register in the range, we must\n      save all later registers too.  */\n   if (GENERATE_MIPS16E_SAVE_RESTORE)\n     {\n-      mips16e_mask_registers (&mask, mips16e_s2_s8_regs,\n- \t\t\t      ARRAY_SIZE (mips16e_s2_s8_regs), &gp_reg_size);\n-      mips16e_mask_registers (&mask, mips16e_a0_a3_regs,\n- \t\t\t      ARRAY_SIZE (mips16e_a0_a3_regs), &gp_reg_size);\n+      mips16e_mask_registers (&frame->mask, mips16e_s2_s8_regs,\n+ \t\t\t      ARRAY_SIZE (mips16e_s2_s8_regs), &frame->num_gp);\n+      mips16e_mask_registers (&frame->mask, mips16e_a0_a3_regs,\n+ \t\t\t      ARRAY_SIZE (mips16e_a0_a3_regs), &frame->num_gp);\n     }\n \n-  /* This loop must iterate over the same space as its companion in\n-     mips_for_each_saved_reg.  */\n+  /* Move above the GPR save area.  */\n+  if (frame->num_gp > 0)\n+    {\n+      frame->gp_reg_size = frame->num_gp * UNITS_PER_WORD;\n+      offset += MIPS_STACK_ALIGN (frame->gp_reg_size);\n+      frame->gp_sp_offset = offset - UNITS_PER_WORD;\n+    }\n+\n+  /* Find out which FPRs we need to save.  This loop must iterate over\n+     the same space as its companion in mips_for_each_saved_reg.  */\n   if (TARGET_HARD_FLOAT)\n-    for (regno = (FP_REG_LAST - MAX_FPRS_PER_FMT + 1);\n-\t regno >= FP_REG_FIRST;\n-\t regno -= MAX_FPRS_PER_FMT)\n+    for (regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno += MAX_FPRS_PER_FMT)\n       if (mips_save_reg_p (regno))\n \t{\n-\t  fp_reg_size += MAX_FPRS_PER_FMT * UNITS_PER_FPREG;\n-\t  fmask |= ((1 << MAX_FPRS_PER_FMT) - 1) << (regno - FP_REG_FIRST);\n+\t  frame->num_fp += MAX_FPRS_PER_FMT;\n+\t  frame->fmask |= ~(~0 << MAX_FPRS_PER_FMT) << (regno - FP_REG_FIRST);\n \t}\n \n-  gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n-  total_size += gp_reg_rounded + MIPS_STACK_ALIGN (fp_reg_size);\n-\n-  /* Add in the space required for saving incoming register arguments.  */\n-  total_size += current_function_pretend_args_size;\n-  total_size += MIPS_STACK_ALIGN (cfun->machine->varargs_size);\n-\n-  /* Save other computed information.  */\n-  cfun->machine->frame.total_size = total_size;\n-  cfun->machine->frame.var_size = var_size;\n-  cfun->machine->frame.args_size = args_size;\n-  cfun->machine->frame.cprestore_size = cprestore_size;\n-  cfun->machine->frame.gp_reg_size = gp_reg_size;\n-  cfun->machine->frame.fp_reg_size = fp_reg_size;\n-  cfun->machine->frame.mask = mask;\n-  cfun->machine->frame.fmask = fmask;\n-  cfun->machine->frame.initialized = reload_completed;\n-  cfun->machine->frame.num_gp = gp_reg_size / UNITS_PER_WORD;\n-  cfun->machine->frame.num_fp = (fp_reg_size\n-\t\t\t\t / (MAX_FPRS_PER_FMT * UNITS_PER_FPREG));\n-\n-  if (mask)\n-    {\n-      HOST_WIDE_INT offset;\n-\n-      if (GENERATE_MIPS16E_SAVE_RESTORE)\n-\t/* MIPS16e SAVE and RESTORE instructions require the GP save area\n-\t   to be aligned at the high end with any padding at the low end.\n-\t   It is only safe to use this calculation for o32, where we never\n-\t   have pretend arguments, and where any varargs will be saved in\n-\t   the caller-allocated area rather than at the top of the frame.  */\n-\toffset = (total_size - GET_MODE_SIZE (gpr_mode));\n-      else\n-\toffset = (args_size + cprestore_size + var_size\n-\t\t  + gp_reg_size - GET_MODE_SIZE (gpr_mode));\n-      cfun->machine->frame.gp_sp_offset = offset;\n-      cfun->machine->frame.gp_save_offset = offset - total_size;\n-    }\n-  else\n+  /* Move above the FPR save area.  */\n+  if (frame->num_fp > 0)\n     {\n-      cfun->machine->frame.gp_sp_offset = 0;\n-      cfun->machine->frame.gp_save_offset = 0;\n+      frame->fp_reg_size = frame->num_fp * UNITS_PER_FPREG;\n+      offset += MIPS_STACK_ALIGN (frame->fp_reg_size);\n+      frame->fp_sp_offset = offset - UNITS_PER_HWFPVALUE;\n     }\n \n-  if (fmask)\n-    {\n-      HOST_WIDE_INT offset;\n+  /* Move above the callee-allocated varargs save area.  */\n+  offset += MIPS_STACK_ALIGN (cfun->machine->varargs_size);\n \n-      offset = (args_size + cprestore_size + var_size\n-\t\t+ gp_reg_rounded + fp_reg_size\n-\t\t- MAX_FPRS_PER_FMT * UNITS_PER_FPREG);\n-      cfun->machine->frame.fp_sp_offset = offset;\n-      cfun->machine->frame.fp_save_offset = offset - total_size;\n-    }\n-  else\n-    {\n-      cfun->machine->frame.fp_sp_offset = 0;\n-      cfun->machine->frame.fp_save_offset = 0;\n-    }\n+  /* Move above the callee-allocated area for pretend stack arguments.  */\n+  offset += current_function_pretend_args_size;\n+  frame->total_size = offset;\n+\n+  /* Work out the offsets of the save areas from the top of the frame.  */\n+  if (frame->gp_sp_offset > 0)\n+    frame->gp_save_offset = frame->gp_sp_offset - offset;\n+  if (frame->fp_sp_offset > 0)\n+    frame->fp_save_offset = frame->fp_sp_offset - offset;\n \n-  /* Ok, we're done.  */\n-  return total_size;\n+  frame->initialized = reload_completed;\n+  return frame->total_size;\n }\n \n /* Return the style of GP load sequence that is being used for the"}, {"sha": "ac4320a763e4df021631b62a630e05ea75e4b0e9", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37017f4dd64886a2c6164d1c2d01cf4bb72238b6/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=37017f4dd64886a2c6164d1c2d01cf4bb72238b6", "patch": "@@ -1885,21 +1885,10 @@ enum reg_class\n #define STACK_GROWS_DOWNWARD\n \n /* The offset of the first local variable from the beginning of the frame.\n-   See compute_frame_size for details about the frame layout.\n-\n-   ??? If flag_profile_values is true, and we are generating 32-bit code, then\n-   we assume that we will need 16 bytes of argument space.  This is because\n-   the value profiling code may emit calls to cmpdi2 in leaf functions.\n-   Without this hack, the local variables will start at sp+8 and the gp save\n-   area will be at sp+16, and thus they will overlap.  compute_frame_size is\n-   OK because it uses STARTING_FRAME_OFFSET to compute cprestore_size, which\n-   will end up as 24 instead of 8.  This won't be needed if profiling code is\n-   inserted before virtual register instantiation.  */\n+   See compute_frame_size for details about the frame layout.  */\n \n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n-  ((flag_profile_values && ! TARGET_64BIT\t\t\t\t\\\n-    ? MAX (REG_PARM_STACK_SPACE(NULL), current_function_outgoing_args_size) \\\n-    : current_function_outgoing_args_size)\t\t\t\t\\\n+  (current_function_outgoing_args_size\t\t\t\t\t\\\n    + (TARGET_CALL_CLOBBERED_GP ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n \n #define RETURN_ADDR_RTX mips_return_addr"}]}