{"sha": "72d099cb27a5fedea22e2d69ce8d03e71120fddc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkMDk5Y2IyN2E1ZmVkZWEyMmUyZDY5Y2U4ZDAzZTcxMTIwZmRkYw==", "commit": {"author": {"name": "Olga Golovanevsky", "email": "olga@il.ibm.com", "date": "2009-12-08T09:41:13Z"}, "committer": {"name": "Olga Golovanevsky", "email": "olga@gcc.gnu.org", "date": "2009-12-08T09:41:13Z"}, "message": "[multiple changes]\n\n2009-12-07  Olga Golovanevsky  <olga@il.ibm.com>\n\n\tPR middle-end/41843\n\t* ipa-struct-reorg.c (compare_fields): New function.\n\t(find_field_in_struct_1): Use compare_fields function.\n\t(is_equal_types): Likewise.\n\n2009-12-04  Olga Golovanevsky  <olga@il.ibm.com>\n\t    Jakub Jelinek <jakub@redhat.com>\t\n\n\tPR midle-end/41843\n\t* gcc.dg/struct/wo_prof_empty_str.c: New testcase.\n\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r155084", "tree": {"sha": "a7fff87194d60ae9fc724724cf946d6b83ad9d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7fff87194d60ae9fc724724cf946d6b83ad9d24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d099cb27a5fedea22e2d69ce8d03e71120fddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d099cb27a5fedea22e2d69ce8d03e71120fddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d099cb27a5fedea22e2d69ce8d03e71120fddc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d099cb27a5fedea22e2d69ce8d03e71120fddc/comments", "author": null, "committer": null, "parents": [{"sha": "96c493240211f9103b0a19d0411b2e8e4d0da11c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c493240211f9103b0a19d0411b2e8e4d0da11c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96c493240211f9103b0a19d0411b2e8e4d0da11c"}], "stats": {"total": 125, "additions": 100, "deletions": 25}, "files": [{"sha": "22fd5cce7839eee73afe205958e86078a91afe23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72d099cb27a5fedea22e2d69ce8d03e71120fddc", "patch": "@@ -1,3 +1,10 @@\n+2009-12-08  Olga Golovanevsky  <olga@il.ibm.com>\n+\n+\tPR middle-end/41843\n+\t* ipa-struct-reorg.c (compare_fields): New function.\n+\t(find_field_in_struct_1): Use compare_fields function.\n+\t(is_equal_types): Likewise.\n+\n 2009-12-07  DJ Delorie  <dj@redhat.com>\n \n \tPR c/42312"}, {"sha": "bef303e288d6dd2da4d175a8c8a877f971a2839c", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=72d099cb27a5fedea22e2d69ce8d03e71120fddc", "patch": "@@ -248,6 +248,32 @@ finalize_stmt_and_append (gimple_seq *stmts, gimple stmt)\n   finalize_stmt (stmt);\n }\n \n+/* This function returns true if two fields FIELD1 and FIELD2 are \n+   semantically equal, and false otherwise.  */\n+\n+static bool\n+compare_fields (tree field1, tree field2)\n+{\n+  if (DECL_NAME (field1) && DECL_NAME (field2))\n+    {\n+      const char *name1 = IDENTIFIER_POINTER (DECL_NAME (field1));\n+      const char *name2 = IDENTIFIER_POINTER (DECL_NAME (field2));\n+\n+      gcc_assert (name1 && name2);\n+\n+      if (strcmp (name1, name2))\n+\treturn false;\n+\t\n+    }\n+  else if (DECL_NAME (field1) || DECL_NAME (field2))\n+    return false;\n+\n+  if (!is_equal_types (TREE_TYPE (field1), TREE_TYPE (field2)))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Given structure type SRT_TYPE and field FIELD,\n    this function is looking for a field with the same name\n    and type as FIELD in STR_TYPE. It returns it if found,\n@@ -264,24 +290,12 @@ find_field_in_struct_1 (tree str_type, tree field)\n   for (str_field = TYPE_FIELDS (str_type); str_field;\n        str_field = TREE_CHAIN (str_field))\n     {\n-      const char *str_field_name;\n-      const char *field_name;\n \n       if (!DECL_NAME (str_field))\n \tcontinue;\n \n-      str_field_name = IDENTIFIER_POINTER (DECL_NAME (str_field));\n-      field_name = IDENTIFIER_POINTER (DECL_NAME (field));\n-\n-      gcc_assert (str_field_name);\n-      gcc_assert (field_name);\n-\n-      if (!strcmp (str_field_name, field_name))\n-\t{\n-\t  /* Check field types.  */\n-\t  if (is_equal_types (TREE_TYPE (str_field), TREE_TYPE (field)))\n-\t    return str_field;\n-\t}\n+      if (compare_fields (field, str_field))\n+\treturn str_field;\n     }\n \n   return NULL_TREE;\n@@ -1596,11 +1610,8 @@ is_equal_types (tree type1, tree type2)\n   name1 = get_type_name (type1);\n   name2 = get_type_name (type2);\n \n-  if (name1 && name2 && !strcmp (name1, name2))\n-    return true;\n-\n-  if (name1 && name2 && strcmp (name1, name2))\n-    return false;\n+  if (name1 && name2)\n+    return strcmp (name1, name2) == 0;\n \n   switch (TREE_CODE (type1))\n     {\n@@ -1616,16 +1627,20 @@ is_equal_types (tree type1, tree type2)\n     case QUAL_UNION_TYPE:\n     case ENUMERAL_TYPE:\n       {\n-\ttree field1;\n+\ttree field1, field2;\n+\n \t/* Compare fields of structure.  */\n-\tfor (field1 = TYPE_FIELDS (type1); field1;\n-\t     field1 = TREE_CHAIN (field1))\n+\tfor (field1 = TYPE_FIELDS (type1), field2 = TYPE_FIELDS (type2);\n+\t     field1 && field2;\n+\t     field1 = TREE_CHAIN (field1), field2 = TREE_CHAIN (field2))\n \t  {\n-\t    tree field2 = find_field_in_struct_1 (type2, field1);\n-\t    if (!field2)\n+\t    if (!compare_fields (field1, field2))\n \t      return false;\n \t  }\n-\treturn true;\n+\tif (field1 || field2)\n+\t  return false;\n+\telse\n+\t  return true;\n       }\n       break;\n "}, {"sha": "3dce57079e7fed6ba0526f07b9299fbee036e464", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=72d099cb27a5fedea22e2d69ce8d03e71120fddc", "patch": "@@ -1,3 +1,9 @@\n+2009-12-08  Olga Golovanevsky  <olga@il.ibm.com>\n+\t    Jakub Jelinek <jakub@redhat.com>\t\n+\n+\tPR midle-end/41843\n+\t* gcc.dg/struct/wo_prof_empty_str.c: New testcase.\n+\n 2009-12-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/42244"}, {"sha": "8f9751d22bf8e8e577e7afd4adee9da064b0d546", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_empty_str.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d099cb27a5fedea22e2d69ce8d03e71120fddc/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c?ref=72d099cb27a5fedea22e2d69ce8d03e71120fddc", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-options \"-O3 -fno-inline -fipa-type-escape -fdump-ipa-all -fipa-struct-reorg -fwhole-program -combine\" } */\n+/* { dg-do compile } */\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+struct S { int a; struct V *b; };\n+typedef struct { int c; } T;\n+typedef struct { int d; int e; } U;\n+\n+void * \n+fn (void *x) \n+{\n+  return x;\n+}\n+\n+int\n+foo (struct S *s)\n+{\n+  T x;\n+  \n+  T y = *(T *)fn (&x);\n+  return y.c;\n+}\n+\n+int\n+bar (struct S *s)\n+{\n+  U x;\n+  \n+  U y = *(U *)fn (&x);\n+  return y.d + s->a;\n+}\n+\n+int \n+main ()\n+{\n+  struct S s;\n+\n+  foo(&s) + bar (&s);\n+\n+  return 0;\n+}\n+\n+/*--------------------------------------------------------------------------*/\n+/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { cleanup-ipa-dump \"*\" } } */"}]}