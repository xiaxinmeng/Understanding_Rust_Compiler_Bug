{"sha": "62442ab9cb306b379718f9ed797b7c60c40df6c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0NDJhYjljYjMwNmIzNzk3MThmOWVkNzk3YjdjNjBjNDBkZjZjOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-08-31T14:10:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-08-31T14:10:35Z"}, "message": "optabs.c (shift_optab_p, [...]): New functions, split out from expand_binop.\n\ngcc/\n\t* optabs.c (shift_optab_p, commutative_optab_p): New functions,\n\tsplit out from expand_binop.\n\t(avoid_expensive_constant): New function.\n\t(expand_binop_directly): Remove commutative_op argument and\n\tcall cummutative_optab_p instead.  Do not change op0 or op1\n\twhen swapping xop0 and xop1.  Apply avoid_expensive_constant\n\tto each argument after potential swapping.  Enforce the\n\tcanonical order of commutative operands.\n\t(expand_binop): Use shift_optab_p and commutative_optab_p.\n\tUpdate the calls to expand_binop_directly.  Only force constants\n\tinto registers when widening an operation.  Only swap operands\n\tonce a direct expansion has been rejected.\n\t(expand_twoval_binop): Only force constants into registers when\n\tusing a direct expansion.\n\nFrom-SVN: r127991", "tree": {"sha": "a3e7dbffe10f5bc993fb2609c29c08b9d3f44fbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3e7dbffe10f5bc993fb2609c29c08b9d3f44fbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62442ab9cb306b379718f9ed797b7c60c40df6c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62442ab9cb306b379718f9ed797b7c60c40df6c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62442ab9cb306b379718f9ed797b7c60c40df6c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62442ab9cb306b379718f9ed797b7c60c40df6c8/comments", "author": null, "committer": null, "parents": [{"sha": "36ae8a61ad8812fa1c177213a44b182e156f717a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ae8a61ad8812fa1c177213a44b182e156f717a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ae8a61ad8812fa1c177213a44b182e156f717a"}], "stats": {"total": 204, "additions": 128, "deletions": 76}, "files": [{"sha": "efbaba08c57dd79337be9ca223313acdf8396bf3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62442ab9cb306b379718f9ed797b7c60c40df6c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62442ab9cb306b379718f9ed797b7c60c40df6c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62442ab9cb306b379718f9ed797b7c60c40df6c8", "patch": "@@ -1,3 +1,20 @@\n+2007-08-31  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* optabs.c (shift_optab_p, commutative_optab_p): New functions,\n+\tsplit out from expand_binop.\n+\t(avoid_expensive_constant): New function.\n+\t(expand_binop_directly): Remove commutative_op argument and\n+\tcall cummutative_optab_p instead.  Do not change op0 or op1\n+\twhen swapping xop0 and xop1.  Apply avoid_expensive_constant\n+\tto each argument after potential swapping.  Enforce the\n+\tcanonical order of commutative operands.\n+\t(expand_binop): Use shift_optab_p and commutative_optab_p.\n+\tUpdate the calls to expand_binop_directly.  Only force constants\n+\tinto registers when widening an operation.  Only swap operands\n+\tonce a direct expansion has been rejected.\n+\t(expand_twoval_binop): Only force constants into registers when\n+\tusing a direct expansion.\n+\n 2007-08-31  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* sched-deps.c (update_dep): Mark arguments with ATTRIBUTE_UNUSED."}, {"sha": "6b292638c8967ad56e68fb12d743566e29489bfd", "filename": "gcc/optabs.c", "status": "modified", "additions": 111, "deletions": 76, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62442ab9cb306b379718f9ed797b7c60c40df6c8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62442ab9cb306b379718f9ed797b7c60c40df6c8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=62442ab9cb306b379718f9ed797b7c60c40df6c8", "patch": "@@ -1246,6 +1246,56 @@ swap_commutative_operands_with_target (rtx target, rtx op0, rtx op1)\n     return rtx_equal_p (op1, target);\n }\n \n+/* Return true if BINOPTAB implements a shift operation.  */\n+\n+static bool\n+shift_optab_p (optab binoptab)\n+{\n+  switch (binoptab->code)\n+    {\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ROTATE:\n+    case ROTATERT:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if BINOPTAB implements a commutatative binary operation.  */\n+\n+static bool\n+commutative_optab_p (optab binoptab)\n+{\n+  return (GET_RTX_CLASS (binoptab->code) == RTX_COMM_ARITH\n+\t  || binoptab == smul_widen_optab\n+\t  || binoptab == umul_widen_optab\n+\t  || binoptab == smul_highpart_optab\n+\t  || binoptab == umul_highpart_optab);\n+}\n+\n+/* X is to be used in mode MODE as an operand to BINOPTAB.  If we're\n+   optimizing, and if the operand is a constant that costs more than\n+   1 instruction, force the constant into a register and return that\n+   register.  Return X otherwise.  UNSIGNEDP says whether X is unsigned.  */\n+\n+static rtx\n+avoid_expensive_constant (enum machine_mode mode, optab binoptab,\n+\t\t\t  rtx x, bool unsignedp)\n+{\n+  if (optimize\n+      && CONSTANT_P (x)\n+      && rtx_cost (x, binoptab->code) > COSTS_N_INSNS (1))\n+    {\n+      if (GET_MODE (x) != VOIDmode)\n+\tx = convert_modes (mode, VOIDmode, x, unsignedp);\n+      x = force_reg (mode, x);\n+    }\n+  return x;\n+}\n \n /* Helper function for expand_binop: handle the case where there\n    is an insn that directly implements the indicated operation.\n@@ -1254,55 +1304,72 @@ static rtx\n expand_binop_directly (enum machine_mode mode, optab binoptab,\n \t\t       rtx op0, rtx op1,\n \t\t       rtx target, int unsignedp, enum optab_methods methods,\n-\t\t       int commutative_op, rtx last)\n+\t\t       rtx last)\n {\n   int icode = (int) optab_handler (binoptab, mode)->insn_code;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n   enum machine_mode tmp_mode;\n+  bool commutative_p;\n   rtx pat;\n   rtx xop0 = op0, xop1 = op1;\n   rtx temp;\n+  rtx swap;\n   \n   if (target)\n     temp = target;\n   else\n     temp = gen_reg_rtx (mode);\n-  \n+\n   /* If it is a commutative operator and the modes would match\n      if we would swap the operands, we can save the conversions.  */\n-  if (commutative_op)\n+  commutative_p = commutative_optab_p (binoptab);\n+  if (commutative_p\n+      && GET_MODE (xop0) != mode0 && GET_MODE (xop1) != mode1\n+      && GET_MODE (xop0) == mode1 && GET_MODE (xop1) == mode1)\n     {\n-      if (GET_MODE (op0) != mode0 && GET_MODE (op1) != mode1\n-\t  && GET_MODE (op0) == mode1 && GET_MODE (op1) == mode0)\n-\t{\n-\t  rtx tmp;\n-\t  \n-\t  tmp = op0; op0 = op1; op1 = tmp;\n-\t  tmp = xop0; xop0 = xop1; xop1 = tmp;\n-\t}\n+      swap = xop0;\n+      xop0 = xop1;\n+      xop1 = swap;\n     }\n   \n+  /* If we are optimizing, force expensive constants into a register.  */\n+  xop0 = avoid_expensive_constant (mode0, binoptab, xop0, unsignedp);\n+  if (!shift_optab_p (binoptab))\n+    xop1 = avoid_expensive_constant (mode1, binoptab, xop1, unsignedp);\n+\n   /* In case the insn wants input operands in modes different from\n      those of the actual operands, convert the operands.  It would\n      seem that we don't need to convert CONST_INTs, but we do, so\n      that they're properly zero-extended, sign-extended or truncated\n      for their mode.  */\n   \n-  if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n+  if (GET_MODE (xop0) != mode0 && mode0 != VOIDmode)\n     xop0 = convert_modes (mode0,\n-\t\t\t  GET_MODE (op0) != VOIDmode\n-\t\t\t  ? GET_MODE (op0)\n+\t\t\t  GET_MODE (xop0) != VOIDmode\n+\t\t\t  ? GET_MODE (xop0)\n \t\t\t  : mode,\n \t\t\t  xop0, unsignedp);\n   \n-  if (GET_MODE (op1) != mode1 && mode1 != VOIDmode)\n+  if (GET_MODE (xop1) != mode1 && mode1 != VOIDmode)\n     xop1 = convert_modes (mode1,\n-\t\t\t  GET_MODE (op1) != VOIDmode\n-\t\t\t  ? GET_MODE (op1)\n+\t\t\t  GET_MODE (xop1) != VOIDmode\n+\t\t\t  ? GET_MODE (xop1)\n \t\t\t  : mode,\n \t\t\t  xop1, unsignedp);\n   \n+  /* If operation is commutative,\n+     try to make the first operand a register.\n+     Even better, try to make it the same as the target.\n+     Also try to make the last operand a constant.  */\n+  if (commutative_p\n+      && swap_commutative_operands_with_target (target, xop0, xop1))\n+    {\n+      swap = xop1;\n+      xop1 = xop0;\n+      xop0 = swap;\n+    }\n+\n   /* Now, if insn's predicates don't allow our operands, put them into\n      pseudo regs.  */\n   \n@@ -1375,12 +1442,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   enum mode_class class;\n   enum machine_mode wider_mode;\n   rtx temp;\n-  int commutative_op = 0;\n-  int shift_op = (binoptab->code == ASHIFT\n-\t\t  || binoptab->code == ASHIFTRT\n-\t\t  || binoptab->code == LSHIFTRT\n-\t\t  || binoptab->code == ROTATE\n-\t\t  || binoptab->code == ROTATERT);\n   rtx entry_last = get_last_insn ();\n   rtx last;\n \n@@ -1395,54 +1456,16 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       binoptab = add_optab;\n     }\n \n-  /* If we are inside an appropriately-short loop and we are optimizing,\n-     force expensive constants into a register.  */\n-  if (CONSTANT_P (op0) && optimize\n-      && rtx_cost (op0, binoptab->code) > COSTS_N_INSNS (1))\n-    {\n-      if (GET_MODE (op0) != VOIDmode)\n-\top0 = convert_modes (mode, VOIDmode, op0, unsignedp);\n-      op0 = force_reg (mode, op0);\n-    }\n-\n-  if (CONSTANT_P (op1) && optimize\n-      && ! shift_op && rtx_cost (op1, binoptab->code) > COSTS_N_INSNS (1))\n-    {\n-      if (GET_MODE (op1) != VOIDmode)\n-\top1 = convert_modes (mode, VOIDmode, op1, unsignedp);\n-      op1 = force_reg (mode, op1);\n-    }\n-\n   /* Record where to delete back to if we backtrack.  */\n   last = get_last_insn ();\n \n-  /* If operation is commutative,\n-     try to make the first operand a register.\n-     Even better, try to make it the same as the target.\n-     Also try to make the last operand a constant.  */\n-  if (GET_RTX_CLASS (binoptab->code) == RTX_COMM_ARITH\n-      || binoptab == smul_widen_optab\n-      || binoptab == umul_widen_optab\n-      || binoptab == smul_highpart_optab\n-      || binoptab == umul_highpart_optab)\n-    {\n-      commutative_op = 1;\n-\n-      if (swap_commutative_operands_with_target (target, op0, op1))\n-\t{\n-\t  temp = op1;\n-\t  op1 = op0;\n-\t  op0 = temp;\n-\t}\n-    }\n-\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n       && optab_handler (binoptab, mode)->insn_code != CODE_FOR_nothing)\n     {\n       temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n-\t\t\t\t    unsignedp, methods, commutative_op, last);\n+\t\t\t\t    unsignedp, methods, last);\n       if (temp)\n \treturn temp;\n     }\n@@ -1469,8 +1492,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t\t       NULL_RTX, unsignedp, OPTAB_DIRECT);\n \t\t\t\t   \n       temp = expand_binop_directly (mode, otheroptab, op0, newop1,\n-\t\t\t\t    target, unsignedp, methods,\n-\t\t\t\t    commutative_op, last);\n+\t\t\t\t    target, unsignedp, methods, last);\n       if (temp)\n \treturn temp;\n     }\n@@ -1529,7 +1551,14 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t || binoptab == add_optab || binoptab == sub_optab\n \t\t || binoptab == smul_optab || binoptab == ashl_optab)\n \t\t&& class == MODE_INT)\n-\t      no_extend = 1;\n+\t      {\n+\t\tno_extend = 1;\n+\t\txop0 = avoid_expensive_constant (mode, binoptab,\n+\t\t\t\t\t\t xop0, unsignedp);\n+\t\tif (binoptab != ashl_optab)\n+\t\t  xop1 = avoid_expensive_constant (mode, binoptab,\n+\t\t\t\t\t\t   xop1, unsignedp);\n+\t      }\n \n \t    xop0 = widen_operand (xop0, wider_mode, mode, unsignedp, no_extend);\n \n@@ -1558,6 +1587,18 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  }\n       }\n \n+  /* If operation is commutative,\n+     try to make the first operand a register.\n+     Even better, try to make it the same as the target.\n+     Also try to make the last operand a constant.  */\n+  if (commutative_optab_p (binoptab)\n+      && swap_commutative_operands_with_target (target, op0, op1))\n+    {\n+      temp = op1;\n+      op1 = op0;\n+      op0 = temp;\n+    }\n+\n   /* These can be done a word at a time.  */\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n       && class == MODE_INT\n@@ -1980,7 +2021,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       start_sequence ();\n \n-      if (shift_op)\n+      if (shift_optab_p (binoptab))\n \t{\n \t  op1_mode = targetm.libgcc_shift_count_mode ();\n \t  /* Specify unsigned here,\n@@ -2256,16 +2297,6 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   class = GET_MODE_CLASS (mode);\n \n-  /* If we are inside an appropriately-short loop and we are optimizing,\n-     force expensive constants into a register.  */\n-  if (CONSTANT_P (op0) && optimize\n-      && rtx_cost (op0, binoptab->code) > COSTS_N_INSNS (1))\n-    op0 = force_reg (mode, op0);\n-\n-  if (CONSTANT_P (op1) && optimize\n-      && rtx_cost (op1, binoptab->code) > COSTS_N_INSNS (1))\n-    op1 = force_reg (mode, op1);\n-\n   if (!targ0)\n     targ0 = gen_reg_rtx (mode);\n   if (!targ1)\n@@ -2282,6 +2313,10 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n       rtx pat;\n       rtx xop0 = op0, xop1 = op1;\n \n+      /* If we are optimizing, force expensive constants into a register.  */\n+      xop0 = avoid_expensive_constant (mode0, binoptab, xop0, unsignedp);\n+      xop1 = avoid_expensive_constant (mode1, binoptab, xop1, unsignedp);\n+\n       /* In case the insn wants input operands in modes different from\n \t those of the actual operands, convert the operands.  It would\n \t seem that we don't need to convert CONST_INTs, but we do, so"}]}