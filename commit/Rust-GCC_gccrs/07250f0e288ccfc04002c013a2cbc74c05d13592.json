{"sha": "07250f0e288ccfc04002c013a2cbc74c05d13592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcyNTBmMGUyODhjY2ZjMDQwMDJjMDEzYTJjYmM3NGMwNWQxMzU5Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-24T09:44:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-24T09:44:48Z"}, "message": "tree.h (alias_diag_flags): Remove.\n\n\n\t* tree.h (alias_diag_flags): Remove.\n\t(alias_pair): Remove emitted_diags.\n\t(finish_aliases_1, finish_aliases_2, remove_unreachable_alias_pairs,\n\tsymbol_alias_set_t, symbol_alias_set_destroy,\n\tsymbol_alias_set_contains, propagate_aliases_backward): Remove.\n\t* toplev.c (compile_file): Do not call finish_aliases_2\n\t* cgraphunit.c (cgraph_process_new_functions): Do not call finish_aliases_1.\n\t(handle_alias_pairs): Output diagnostics about aliases to externals.\n\t(assemble_thunks_and_aliases): Use do_assemble_alias.\n\t(output_weakrefs): Likewise.\n\t(finalize_compilation_unit): Do not call finish_aliases_1.\n\t* ipa.c (symtab_remove_unreachable_nodes): De not call remove_unreachable_alias_pairs.\n\t* varasm.c (do_assemble_alias): Export.\n\t(symbol_alias_set_create, symbol_alias_set_destroy, symbol_alias_set_contains,\n\tsymbol_alias_set_insert, propagate_aliases_forward, propagate_aliases_backward,\n\tpropagate_aliases_backward, trivially_visible_alias, trivially_defined_alias,\n\tremove_unreachable_alias_pairs, finish_aliases_1, finish_aliases_2, \n\tassemble_alias): Remove.\n\t* output.h (do_assemble_alias): Declare.\n\t* varpool.c (varpool_remove_unreferenced_decls): Do not call finish_aliases_1.\n\nFrom-SVN: r187823", "tree": {"sha": "1304b7028d8d01c6f5272f44c33289a472a88e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1304b7028d8d01c6f5272f44c33289a472a88e49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07250f0e288ccfc04002c013a2cbc74c05d13592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07250f0e288ccfc04002c013a2cbc74c05d13592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07250f0e288ccfc04002c013a2cbc74c05d13592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07250f0e288ccfc04002c013a2cbc74c05d13592/comments", "author": null, "committer": null, "parents": [{"sha": "0f4fb41f6db3fb0e1279cabc3d5b0b2c4c159c48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4fb41f6db3fb0e1279cabc3d5b0b2c4c159c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4fb41f6db3fb0e1279cabc3d5b0b2c4c159c48"}], "stats": {"total": 357, "additions": 54, "deletions": 303}, "files": [{"sha": "c11b87c3d611309ef32aad11ef3bbca617e1d420", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -1,3 +1,26 @@\n+2012-05-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.h (alias_diag_flags): Remove.\n+\t(alias_pair): Remove emitted_diags.\n+\t(finish_aliases_1, finish_aliases_2, remove_unreachable_alias_pairs,\n+\tsymbol_alias_set_t, symbol_alias_set_destroy,\n+\tsymbol_alias_set_contains, propagate_aliases_backward): Remove.\n+\t* toplev.c (compile_file): Do not call finish_aliases_2\n+\t* cgraphunit.c (cgraph_process_new_functions): Do not call finish_aliases_1.\n+\t(handle_alias_pairs): Output diagnostics about aliases to externals.\n+\t(assemble_thunks_and_aliases): Use do_assemble_alias.\n+\t(output_weakrefs): Likewise.\n+\t(finalize_compilation_unit): Do not call finish_aliases_1.\n+\t* ipa.c (symtab_remove_unreachable_nodes): De not call remove_unreachable_alias_pairs.\n+\t* varasm.c (do_assemble_alias): Export.\n+\t(symbol_alias_set_create, symbol_alias_set_destroy, symbol_alias_set_contains,\n+\tsymbol_alias_set_insert, propagate_aliases_forward, propagate_aliases_backward,\n+\tpropagate_aliases_backward, trivially_visible_alias, trivially_defined_alias,\n+\tremove_unreachable_alias_pairs, finish_aliases_1, finish_aliases_2, \n+\tassemble_alias): Remove.\n+\t* output.h (do_assemble_alias): Declare.\n+\t* varpool.c (varpool_remove_unreferenced_decls): Do not call finish_aliases_1.\n+\n 2012-05-23  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-inline-analysis.c (inline_merge_summary): Free operand_map."}, {"sha": "8dd52234f420a49fc02978ce90d40ca36a8ab0e0", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -285,7 +285,6 @@ cgraph_process_new_functions (void)\n \n   if (!cgraph_new_nodes)\n     return false;\n-  finish_aliases_1 ();\n   handle_alias_pairs ();\n   /*  Note that this queue may grow as its being processed, as the new\n       functions may generate new ones.  */\n@@ -1068,6 +1067,18 @@ handle_alias_pairs (void)\n \t  = lookup_attribute (\"weakref\",\n \t\t\t      DECL_ATTRIBUTES (p->decl)) != NULL;\n \n+      if (DECL_EXTERNAL (target_node->symbol.decl)\n+\t  /* We use local aliases for C++ thunks to force the tailcall\n+\t     to bind locally.  This is a hack - to keep it working do\n+\t     the following (which is not strictly correct).  */\n+\t  && (! TREE_CODE (target_node->symbol.decl) == FUNCTION_DECL\n+\t      || ! DECL_VIRTUAL_P (target_node->symbol.decl))\n+\t  && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n+\t{\n+\t  error (\"%q+D aliased to external symbol %qE\",\n+\t\t p->decl, p->target);\n+\t}\n+\n       if (TREE_CODE (p->decl) == FUNCTION_DECL\n           && target_node && symtab_function_p (target_node))\n \t{\n@@ -1185,6 +1196,7 @@ mark_functions_to_output (void)\n \t\t end up not removing the body since we no longer have an\n \t\t analyzed node pointing to it.  */\n \t      && !node->symbol.in_other_partition\n+\t      && !node->clones\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n@@ -1552,8 +1564,8 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n \t/* Force assemble_alias to really output the alias this time instead\n \t   of buffering it in same alias pairs.  */\n \tTREE_ASM_WRITTEN (alias->thunk.alias) = 1;\n-\tassemble_alias (alias->symbol.decl,\n-\t\t\tDECL_ASSEMBLER_NAME (alias->thunk.alias));\n+\tdo_assemble_alias (alias->symbol.decl,\n+\t\t\t   DECL_ASSEMBLER_NAME (alias->thunk.alias));\n \tassemble_thunks_and_aliases (alias);\n \tTREE_ASM_WRITTEN (alias->thunk.alias) = saved_written;\n       }\n@@ -1902,16 +1914,16 @@ output_weakrefs (void)\n     if (node->alias && DECL_EXTERNAL (node->symbol.decl)\n         && !TREE_ASM_WRITTEN (node->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n-      assemble_alias (node->symbol.decl,\n-\t\t      node->thunk.alias ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n-\t\t      : get_alias_symbol (node->symbol.decl));\n+      do_assemble_alias (node->symbol.decl,\n+\t\t         node->thunk.alias ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n+\t\t         : get_alias_symbol (node->symbol.decl));\n   FOR_EACH_VARIABLE (vnode)\n     if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl)\n         && !TREE_ASM_WRITTEN (vnode->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n-      assemble_alias (vnode->symbol.decl,\n-\t\t      vnode->alias_of ? DECL_ASSEMBLER_NAME (vnode->alias_of)\n-\t\t      : get_alias_symbol (vnode->symbol.decl));\n+      do_assemble_alias (vnode->symbol.decl,\n+\t\t         vnode->alias_of ? DECL_ASSEMBLER_NAME (vnode->alias_of)\n+\t\t         : get_alias_symbol (vnode->symbol.decl));\n }\n \n /* Initialize callgraph dump file.  */\n@@ -1995,7 +2007,6 @@ compile (void)\n #endif\n   bitmap_obstack_release (NULL);\n   mark_functions_to_output ();\n-  output_weakrefs ();\n \n   cgraph_state = CGRAPH_STATE_EXPANSION;\n   if (!flag_toplevel_reorder)\n@@ -2010,6 +2021,7 @@ compile (void)\n \n   cgraph_process_new_functions ();\n   cgraph_state = CGRAPH_STATE_FINISHED;\n+  output_weakrefs ();\n \n   if (cgraph_dump_file)\n     {\n@@ -2058,7 +2070,6 @@ finalize_compilation_unit (void)\n   finalize_size_functions ();\n \n   /* Mark alias targets necessary and emit diagnostics.  */\n-  finish_aliases_1 ();\n   handle_alias_pairs ();\n \n   if (!quiet_flag)\n@@ -2075,7 +2086,6 @@ finalize_compilation_unit (void)\n   cgraph_analyze_functions ();\n \n   /* Mark alias targets necessary and emit diagnostics.  */\n-  finish_aliases_1 ();\n   handle_alias_pairs ();\n \n   /* Gimplify and lower thunks.  */"}, {"sha": "51c3dada1fac539a2dafe668c1f9b3b03802ef19", "filename": "gcc/ipa.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -454,10 +454,6 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     FOR_EACH_DEFINED_FUNCTION (node)\n       cgraph_propagate_frequency (node);\n \n-  /* Reclaim alias pairs for functions that have disappeared from the\n-     call graph.  */\n-  remove_unreachable_alias_pairs ();\n-\n   return changed;\n }\n "}, {"sha": "31978c5afdfe6739270276c4ccf2e3c7d481dfdc", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -187,6 +187,7 @@ extern int decode_reg_name (const char *);\n extern int decode_reg_name_and_count (const char *, int *);\n \n extern void assemble_alias (tree, tree);\n+extern void do_assemble_alias (tree, tree);\n \n extern void default_assemble_visibility (tree, int);\n "}, {"sha": "3ac69cd6374ad12af243b0ed845d630b80d26629", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -577,8 +577,6 @@ compile_file (void)\n      basically finished.  */\n   if (in_lto_p || !flag_lto || flag_fat_lto_objects)\n     {\n-      finish_aliases_2 ();\n-\n       /* Likewise for mudflap static object registrations.  */\n       if (flag_mudflap)\n \tmudflap_finish_file ();"}, {"sha": "5f2204b8e0689380b5ea61989bf16f24e6292740", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -239,25 +239,14 @@ extern const unsigned char tree_code_length[];\n \n extern const char *const tree_code_name[];\n \n-/* We have to be able to tell cgraph about the needed-ness of the target\n-   of an alias.  This requires that the decl have been defined.  Aliases\n-   that precede their definition have to be queued for later processing.  */\n-\n-/* The deferred processing proceeds in several passes.  We memorize the\n-   diagnostics emitted for a pair to prevent repeating messages when the\n-   queue gets re-scanned after possible updates.  */\n-\n-typedef enum {\n-  ALIAS_DIAG_NONE      = 0x0,\n-  ALIAS_DIAG_TO_UNDEF  = 0x1,\n-  ALIAS_DIAG_TO_EXTERN = 0x2\n-} alias_diag_flags;\n-  \n+/* When procesing aliases on symtab level, we need the declaration of target.\n+   For this reason we need to queue aliases and process them after all declarations\n+   has been produced.  */\n+\n typedef struct GTY(()) alias_pair\n {\n   tree decl;\n   tree target;  \n-  int  emitted_diags;  /* alias_diags already emitted for this pair.  */\n } alias_pair;\n \n /* Define gc'd vector type.  */\n@@ -5691,24 +5680,8 @@ extern void mark_decl_referenced (tree);\n extern void notice_global_symbol (tree);\n extern void set_user_assembler_name (tree, const char *);\n extern void process_pending_assemble_externals (void);\n-extern void finish_aliases_1 (void);\n-extern void finish_aliases_2 (void);\n-extern void remove_unreachable_alias_pairs (void);\n extern bool decl_replaceable_p (tree);\n extern bool decl_binds_to_current_def_p (tree);\n-\n-/* Derived type for use by compute_visible_aliases and callers.  A symbol\n-   alias set is a pointer set into which we enter IDENTIFIER_NODES bearing\n-   the canonicalised assembler-level symbol names corresponding to decls\n-   and their aliases.  */\n-typedef struct pointer_set_t symbol_alias_set_t;\n-\n-extern void symbol_alias_set_destroy (symbol_alias_set_t *);\n-extern int symbol_alias_set_contains (const symbol_alias_set_t *, tree);\n-extern symbol_alias_set_t * propagate_aliases_backward (bool (*)\n-\t\t\t\t\t\t\t (tree, tree, void *),\n-\t\t\t\t\t\t\tvoid *);\n-\n /* In stmt.c */\n extern void expand_computed_goto (tree);\n extern bool parse_output_constraint (const char **, int, int, int,"}, {"sha": "098421518b25f8cee5011ad92b04910c1ab8789d", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 252, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -5435,7 +5435,7 @@ VEC(alias_pair,gc) *alias_pairs;\n    or ASM_OUTPUT_DEF_FROM_DECLS.  The function defines the symbol whose\n    tree node is DECL to have the value of the tree node TARGET.  */\n \n-static void\n+void\n do_assemble_alias (tree decl, tree target)\n {\n   /* Emulated TLS had better not get this var.  */\n@@ -5535,255 +5535,6 @@ do_assemble_alias (tree decl, tree target)\n #endif\n }\n \n-\n-/* Allocate and construct a symbol alias set.  */\n-\n-static symbol_alias_set_t *\n-symbol_alias_set_create (void)\n-{\n-  return pointer_set_create ();\n-}\n-\n-/* Destruct and free a symbol alias set.  */\n-\n-void\n-symbol_alias_set_destroy (symbol_alias_set_t *aset)\n-{\n-  pointer_set_destroy (aset);\n-}\n-\n-/* Test if a symbol alias set contains a given name.  */\n-\n-int\n-symbol_alias_set_contains (const symbol_alias_set_t *aset, tree t)\n-{\n-  /* We accept either a DECL or an IDENTIFIER directly.  */\n-  if (TREE_CODE (t) != IDENTIFIER_NODE)\n-    t = DECL_ASSEMBLER_NAME (t);\n-  t = targetm.asm_out.mangle_assembler_name (IDENTIFIER_POINTER (t));\n-  return pointer_set_contains (aset, t);\n-}\n-\n-/* Enter a new name into a symbol alias set.  */\n-\n-static int\n-symbol_alias_set_insert (symbol_alias_set_t *aset, tree t)\n-{\n-  /* We accept either a DECL or an IDENTIFIER directly.  */\n-  if (TREE_CODE (t) != IDENTIFIER_NODE)\n-    t = DECL_ASSEMBLER_NAME (t);\n-  t = targetm.asm_out.mangle_assembler_name (IDENTIFIER_POINTER (t));\n-  return pointer_set_insert (aset, t);\n-}\n-\n-/* IN_SET_P is a predicate function assuming to be taken\n-   alias_pair->decl, alias_pair->target and DATA arguments.\n-\n-   Compute set of aliases by including everything where TRIVIALLY_VISIBLE\n-   predeicate is true and propagate across aliases such that when\n-   alias DECL is included, its TARGET is included too.  */\n-\n-static symbol_alias_set_t *\n-propagate_aliases_forward (bool (*in_set_p)\n-\t\t\t     (tree decl, tree target, void *data),\n-\t\t           void *data)\n-{\n-  symbol_alias_set_t *set;\n-  unsigned i;\n-  alias_pair *p;\n-  bool changed;\n-\n-  set = symbol_alias_set_create ();\n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n-    if (in_set_p (p->decl, p->target, data))\n-      symbol_alias_set_insert (set, p->decl);\n-  do\n-    {\n-      changed = false;\n-      for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n-\tif (symbol_alias_set_contains (set, p->decl)\n-\t    && !symbol_alias_set_insert (set, p->target))\n-\t  changed = true;\n-    }\n-  while (changed);\n-\n-  return set;\n-}\n-\n-/* Like propagate_aliases_forward but do backward propagation.  */\n-\n-symbol_alias_set_t *\n-propagate_aliases_backward (bool (*in_set_p)\n-\t\t\t     (tree decl, tree target, void *data),\n-\t\t           void *data)\n-{\n-  symbol_alias_set_t *set;\n-  unsigned i;\n-  alias_pair *p;\n-  bool changed;\n-\n-  /* We have to compute the set of set nodes including aliases\n-     themselves.  */\n-  set = symbol_alias_set_create ();\n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n-    if (in_set_p (p->decl, p->target, data))\n-      symbol_alias_set_insert (set, p->target);\n-  do\n-    {\n-      changed = false;\n-      for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n-\tif (symbol_alias_set_contains (set, p->target)\n-\t    && !symbol_alias_set_insert (set, p->decl))\n-\t  changed = true;\n-    }\n-  while (changed);\n-\n-  return set;\n-}\n-/* See if the alias is trivially visible.  This means\n-     1) alias is expoerted from the unit or\n-     2) alias is used in the code.\n-   We assume that unused cgraph/varpool nodes has been\n-   removed.\n-   Used as callback for propagate_aliases.  */\n-\n-static bool\n-trivially_visible_alias (tree decl, tree target ATTRIBUTE_UNUSED,\n-\t\t\t void *data ATTRIBUTE_UNUSED)\n-{\n-  struct cgraph_node *fnode = NULL;\n-  struct varpool_node *vnode = NULL;\n-\n-  if (!TREE_PUBLIC (decl))\n-    {\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tfnode = cgraph_get_node (decl);\n-      else\n-\tvnode = varpool_get_node (decl);\n-      return vnode || fnode;\n-    }\n-  else\n-    return true;\n-}\n-\n-/* See if the target of alias is defined in this unit.\n-   Used as callback for propagate_aliases.  */\n-\n-static bool\n-trivially_defined_alias (tree decl ATTRIBUTE_UNUSED,\n-\t\t\t tree target,\n-\t\t\t void *data ATTRIBUTE_UNUSED)\n-{\n-  struct cgraph_node *fnode = NULL;\n-  struct varpool_node *vnode = NULL;\n-\n-  fnode = cgraph_node_for_asm (target);\n-  vnode = (fnode == NULL) ? varpool_node_for_asm (target) : NULL;\n-  return (fnode && fnode->analyzed) || (vnode && vnode->finalized);\n-}\n-\n-/* Remove the alias pairing for functions that are no longer in the call\n-   graph.  */\n-\n-void\n-remove_unreachable_alias_pairs (void)\n-{\n-  symbol_alias_set_t *visible;\n-  unsigned i;\n-  alias_pair *p;\n-\n-  if (alias_pairs == NULL)\n-    return;\n-\n-  /* We have to compute the set of visible nodes including aliases\n-     themselves.  */\n-  visible = propagate_aliases_forward (trivially_visible_alias, NULL);\n-\n-  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); )\n-    {\n-      if (!DECL_EXTERNAL (p->decl)\n-\t  && !symbol_alias_set_contains (visible, p->decl))\n-\t{\n-\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n-\t  continue;\n-\t}\n-\n-      i++;\n-    }\n-\n-  symbol_alias_set_destroy (visible);\n-}\n-\n-\n-/* First pass of completing pending aliases.  Make sure that cgraph knows\n-   which symbols will be required.  */\n-\n-void\n-finish_aliases_1 (void)\n-{\n-  symbol_alias_set_t *defined;\n-  unsigned i;\n-  alias_pair *p;\n-\n-  if (alias_pairs == NULL)\n-    return;\n-\n-  /* We have to compute the set of defined nodes including aliases\n-     themselves.  */\n-  defined = propagate_aliases_backward (trivially_defined_alias, NULL);\n-\n-  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n-    {\n-      tree target_decl;\n-\n-      target_decl = find_decl (p->target);\n-      if (target_decl == NULL)\n-\t{\n-\t  if (symbol_alias_set_contains (defined, p->target))\n-\t    continue;\n-\n-\t  if (! (p->emitted_diags & ALIAS_DIAG_TO_UNDEF)\n-\t      && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n-\t    {\n-\t      error (\"%q+D aliased to undefined symbol %qE\",\n-\t\t     p->decl, p->target);\n-\t      p->emitted_diags |= ALIAS_DIAG_TO_UNDEF;\n-\t    }\n-\t}\n-      else if (! (p->emitted_diags & ALIAS_DIAG_TO_EXTERN)\n-\t       && DECL_EXTERNAL (target_decl)\n-\t       /* We use local aliases for C++ thunks to force the tailcall\n-\t\t  to bind locally.  This is a hack - to keep it working do\n-\t\t  the following (which is not strictly correct).  */\n-\t       && (! TREE_CODE (target_decl) == FUNCTION_DECL\n-\t\t   || ! DECL_VIRTUAL_P (target_decl))\n-\t       && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n-\t{\n-\t  error (\"%q+D aliased to external symbol %qE\",\n-\t\t p->decl, p->target);\n-\t  p->emitted_diags |= ALIAS_DIAG_TO_EXTERN;\n-\t}\n-    }\n-\n-  symbol_alias_set_destroy (defined);\n-}\n-\n-/* Second pass of completing pending aliases.  Emit the actual assembly.\n-   This happens at the end of compilation and thus it is assured that the\n-   target symbol has been emitted.  */\n-\n-void\n-finish_aliases_2 (void)\n-{\n-  unsigned i;\n-  alias_pair *p;\n-\n-  FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n-    do_assemble_alias (p->decl, p->target);\n-\n-  VEC_truncate (alias_pair, alias_pairs, 0);\n-}\n-\n /* Emit an assembler directive to make the symbol for DECL an alias to\n    the symbol for TARGET.  */\n \n@@ -5845,14 +5596,14 @@ assemble_alias (tree decl, tree target)\n     target_decl = find_decl (target);\n   else\n     target_decl= NULL;\n-  if (target_decl && TREE_ASM_WRITTEN (target_decl))\n+  if ((target_decl && TREE_ASM_WRITTEN (target_decl))\n+      || cgraph_state >= CGRAPH_STATE_EXPANSION)\n     do_assemble_alias (decl, target);\n   else\n     {\n       alias_pair *p = VEC_safe_push (alias_pair, gc, alias_pairs, NULL);\n       p->decl = decl;\n       p->target = target;\n-      p->emitted_diags = ALIAS_DIAG_NONE;\n     }\n }\n "}, {"sha": "a1a26908020e622f389d276de70f3caf3e6ccf5d", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07250f0e288ccfc04002c013a2cbc74c05d13592/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=07250f0e288ccfc04002c013a2cbc74c05d13592", "patch": "@@ -270,7 +270,7 @@ assemble_aliases (struct varpool_node *node)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n-\tassemble_alias (alias->symbol.decl,\n+\tdo_assemble_alias (alias->symbol.decl,\n \t\t\tDECL_ASSEMBLER_NAME (alias->alias_of));\n \tassemble_aliases (alias);\n       }\n@@ -349,7 +349,6 @@ varpool_remove_unreferenced_decls (void)\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Trivially needed variables:\");\n-  finish_aliases_1 ();\n   FOR_EACH_DEFINED_VARIABLE (node)\n     {\n       if (node->analyzed"}]}