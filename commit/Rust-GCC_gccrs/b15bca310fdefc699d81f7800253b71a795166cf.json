{"sha": "b15bca310fdefc699d81f7800253b71a795166cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE1YmNhMzEwZmRlZmM2OTlkODFmNzgwMDI1M2I3MWE3OTUxNjZjZg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2001-01-08T15:33:06Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2001-01-08T15:33:06Z"}, "message": "arm.c (arm_arch5e): New variable.\n\n* arm.c (arm_arch5e): New variable.\n(all_cores): XScale is a 5TE device.\n(arm_override_options): Set arm_arch5e.\n(arm_init_builtins): __builtin_prefetch is in arch5e.\n* arm.h (arm_arch5e): Declare it.\n\n* arm.h (PREDICATE_CODES): Add arm_hard_register_operand.\n\n* arm.md (define_constants): Add defines for UNSPEC and\nUNSPEC_VOLATILE insns.  Update all users.\n(define_constants): Add constants for IP_REGNUM, SP_REGNUM, PC_REGNUM.\n* arm.c (multi_register_push, note_invalid_constants)\n(emit_multi_reg_push, emit_sfm, expand_prologue): Use constants.\n* arm.h (SP_REGNUM, IP_REGNUM, PC_REGNUM): Delete defines.\n(STACK_POINTER_REGNUM): Define in terms of SP_REGNUM.\n\nFrom-SVN: r38803", "tree": {"sha": "8fdd1745cb42de0b76eac3ae4edfe74943f9c6f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fdd1745cb42de0b76eac3ae4edfe74943f9c6f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b15bca310fdefc699d81f7800253b71a795166cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15bca310fdefc699d81f7800253b71a795166cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15bca310fdefc699d81f7800253b71a795166cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15bca310fdefc699d81f7800253b71a795166cf/comments", "author": null, "committer": null, "parents": [{"sha": "261efdefd067fbb10979f662f9fe0a3da986d2b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261efdefd067fbb10979f662f9fe0a3da986d2b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261efdefd067fbb10979f662f9fe0a3da986d2b5"}], "stats": {"total": 257, "additions": 173, "deletions": 84}, "files": [{"sha": "363513ad6ba708196089e52d3a74178152f77621", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b15bca310fdefc699d81f7800253b71a795166cf", "patch": "@@ -1,3 +1,21 @@\n+2001-01-08  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_arch5e): New variable.\n+\t(all_cores): XScale is a 5TE device.\n+\t(arm_override_options): Set arm_arch5e.\n+\t(arm_init_builtins): __builtin_prefetch is in arch5e.\n+\t* arm.h (arm_arch5e): Declare it.\n+\n+\t* arm.h (PREDICATE_CODES): Add arm_hard_register_operand.\n+\n+\t* arm.md (define_constants): Add defines for UNSPEC and\n+\tUNSPEC_VOLATILE insns.  Update all users.\n+\t(define_constants): Add constants for IP_REGNUM, SP_REGNUM, PC_REGNUM.\n+\t* arm.c (multi_register_push, note_invalid_constants)\n+\t(emit_multi_reg_push, emit_sfm, expand_prologue): Use constants.\n+\t* arm.h (SP_REGNUM, IP_REGNUM, PC_REGNUM): Delete defines.\n+\t(STACK_POINTER_REGNUM): Define in terms of SP_REGNUM.\n+\t\n Mon Jan  8 16:14:56 MET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* jump.c (jump_optimize_1): Use reversed_comparison_code"}, {"sha": "5401773288998a879e0045848d67a49cdb0371d9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b15bca310fdefc699d81f7800253b71a795166cf", "patch": "@@ -151,7 +151,7 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n #define FL_THUMB      (1 << 6)        /* Thumb aware */\n #define FL_LDSCHED    (1 << 7)\t      /* Load scheduling necessary */\n #define FL_STRONG     (1 << 8)\t      /* StrongARM */\n-#define FL_ARCH5E     (1 << 9)        /* El Segundo extenstions to v5 */\n+#define FL_ARCH5E     (1 << 9)        /* DSP extenstions to v5 */\n #define FL_XSCALE     (1 << 10)\t      /* XScale */\n \n /* The bits in this mask specify which instructions we are\n@@ -176,6 +176,9 @@ int arm_arch4 = 0;\n /* Nonzero if this chip supports the ARM Architecture 5 extensions.  */\n int arm_arch5 = 0;\n \n+/* Nonzero if this chip supports the ARM Architecture 5E extensions.  */\n+int arm_arch5e = 0;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n int arm_ld_sched = 0;\n \n@@ -279,7 +282,7 @@ static struct processors all_cores[] =\n   {\"strongarm\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n   {\"strongarm110\",           FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n   {\"strongarm1100\",          FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n-  {\"xscale\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_ARCH5 },\n+  {\"xscale\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_ARCH5 | FL_ARCH5E },\n   \n   {NULL, 0}\n };\n@@ -586,6 +589,7 @@ arm_override_options ()\n   arm_fast_multiply = (insn_flags & FL_FAST_MULT) != 0;\n   arm_arch4         = (insn_flags & FL_ARCH4) != 0;\n   arm_arch5         = (insn_flags & FL_ARCH5) != 0;\n+  arm_arch5e        = (insn_flags & FL_ARCH5E) != 0;\n   arm_is_xscale     = (insn_flags & FL_XSCALE) != 0;\n \n   arm_ld_sched      = (tune_flags & FL_LDSCHED) != 0;\n@@ -4054,7 +4058,7 @@ multi_register_push (op, mode)\n   if (GET_CODE (op) != PARALLEL\n       || (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n       || (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC)\n-      || (XINT (SET_SRC (XVECEXP (op, 0, 0)), 1) != 2))\n+      || (XINT (SET_SRC (XVECEXP (op, 0, 0)), 1) != UNSPEC_PUSH_MULT))\n     return 0;\n \n   return 1;\n@@ -5888,7 +5892,7 @@ note_invalid_constants (insn, address)\n \t     this shouldn't be needed any more.  */\n #ifndef AOF_ASSEMBLER\n \t  /* XXX Is this still needed?  */\n-\t  else if (GET_CODE (op) == UNSPEC && XINT (op, 1) == 3)\n+\t  else if (GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_PIC_SYM)\n \t    push_minipool_fix (insn, address, recog_data.operand_loc[opno],\n \t\t\t       recog_data.operand_mode[opno],\n \t\t\t       XVECEXP (op, 0, 0));\n@@ -7593,7 +7597,8 @@ emit_multi_reg_push (mask)\n      something like this:\n \n        (parallel [ \n-           (set (mem:BLK (pre_dec:BLK (reg:SI sp))) (unspec:BLK [(reg:SI r4)] 2))\n+           (set (mem:BLK (pre_dec:BLK (reg:SI sp)))\n+\t        (unspec:BLK [(reg:SI r4)] UNSPEC_PUSH_MULT))\n            (use (reg:SI 11 fp))\n            (use (reg:SI 12 ip))\n            (use (reg:SI 14 lr))\n@@ -7708,7 +7713,7 @@ emit_sfm (base_reg, count)\n \t\t\t\tgen_rtx_PRE_DEC (BLKmode, stack_pointer_rtx)),\n \t\t   gen_rtx_UNSPEC (BLKmode,\n \t\t\t\t   gen_rtvec (1, reg),\n-\t\t\t\t   2));\n+\t\t\t\t   UNSPEC_PUSH_MULT));\n   tmp\n     = gen_rtx_SET (VOIDmode, \n \t\t   gen_rtx_MEM (XFmode,\n@@ -7941,7 +7946,8 @@ arm_expand_prologue ()\n \t{\n \t  rtx unspec = gen_rtx_UNSPEC (SImode,\n \t\t\t\t       gen_rtvec (2, stack_pointer_rtx,\n-\t\t\t\t\t\t  hard_frame_pointer_rtx), 4);\n+\t\t\t\t\t\t  hard_frame_pointer_rtx),\n+\t\t\t\t       UNSPEC_PRLG_STK);\n \n \t  insn = emit_insn (gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t      gen_rtx_MEM (BLKmode, unspec)));\n@@ -8801,6 +8807,11 @@ arm_init_builtins ()\n   if (arm_arch5)\n     {\n       def_builtin (\"__builtin_clz\", int_ftype_int, ARM_BUILTIN_CLZ);\n+    }\n+\n+  /* Initialize arm V5E builtins.  */\n+  if (arm_arch5e)\n+    {\n       def_builtin (\"__builtin_prefetch\", void_ftype_pchar,\n \t\t   ARM_BUILTIN_PREFETCH);\n     }"}, {"sha": "c1abdb2c31c0e57becbfd0e72e0eb1f2aa71a80a", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=b15bca310fdefc699d81f7800253b71a795166cf", "patch": "@@ -561,6 +561,9 @@ extern int arm_arch4;\n /* Nonzero if this chip supports the ARM Architecture 5 extensions */\n extern int arm_arch5;\n \n+/* Nonzero if this chip supports the ARM Architecture 5E extensions */\n+extern int arm_arch5e;\n+\n /* Nonzero if this chip can benefit from load scheduling.  */\n extern int arm_ld_sched;\n \n@@ -931,32 +934,21 @@ extern const char * structure_size_string;\n    pointer.  */\n #define ARM_HARD_FRAME_POINTER_REGNUM\t11\n #define THUMB_HARD_FRAME_POINTER_REGNUM\t 7\n-#define HARD_FRAME_POINTER_REGNUM       (TARGET_ARM ? ARM_HARD_FRAME_POINTER_REGNUM : THUMB_HARD_FRAME_POINTER_REGNUM)\n-#define FP_REGNUM\t                HARD_FRAME_POINTER_REGNUM\n-\n-/* Scratch register - used in all kinds of places, eg trampolines.  */\n-#define IP_REGNUM\t\t12\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM\t13\n-#define SP_REGNUM\t        STACK_POINTER_REGNUM\n \n-/* Register which holds return address from a subroutine call.  */\n-#define LR_REGNUM\t\t14\n+#define HARD_FRAME_POINTER_REGNUM\t\t\\\n+  (TARGET_ARM\t\t\t\t\t\\\n+   ? ARM_HARD_FRAME_POINTER_REGNUM\t\t\\\n+   : THUMB_HARD_FRAME_POINTER_REGNUM)\n \n-/* Define this if the program counter is overloaded on a register.  */\n-#define PC_REGNUM\t\t15\n+#define FP_REGNUM\t                HARD_FRAME_POINTER_REGNUM\n \n-/* The number of the last ARM (integer) register.  */\n-#define LAST_ARM_REGNUM \t15\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM\tSP_REGNUM\n \n /* ARM floating pointer registers.  */\n #define FIRST_ARM_FP_REGNUM \t16\n #define LAST_ARM_FP_REGNUM  \t23\n \n-/* Internal, so that we don't need to refer to a raw number */\n-#define CC_REGNUM\t\t24\n-\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM\t25\n \n@@ -2949,6 +2941,7 @@ extern int making_const_table;\n /* Define the codes that are matched by predicates in arm.c */\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"s_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"arm_hard_register_operand\", {REG}},\t\t\t\t\t\\\n   {\"f_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"arm_add_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"fpu_add_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\"}, {"sha": "139257c4276b86d9b53a76f0adb7dda541555786", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 126, "deletions": 59, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b15bca310fdefc699d81f7800253b71a795166cf/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=b15bca310fdefc699d81f7800253b71a795166cf", "patch": "@@ -28,31 +28,72 @@\n ;; Unfortunately RISC iX doesn't work well with these so they are disabled.\n ;; (See arm.h)\n \f\n+;;---------------------------------------------------------------------------\n+;; Constants\n+\n+;; Register numbers\n+(define_constants\n+  [(IP_REGNUM\t    12)\t\t; Scratch register\n+   (SP_REGNUM\t    13)\t\t; Stack pointer\n+   (LR_REGNUM       14)\t\t; Return address register\n+   (PC_REGNUM\t    15)\t\t; Program counter\n+   (CC_REGNUM       24)\t\t; Condition code pseudo register\n+   (LAST_ARM_REGNUM 15)\n+  ]\n+)\n+\n ;; UNSPEC Usage:\n-;; 0 `sin' operation: operand 0 is the result, operand 1 the parameter,\n-;;   the mode is MODE_FLOAT\n-;; 1 `cos' operation: operand 0 is the result, operand 1 the parameter,\n-;;   the mode is MODE_FLOAT\n-;; 2 `push multiple' operation: operand 0 is the first register.  Subsequent\n-;;   registers are in parallel (use...) expressions.\n-;; 3 A symbol that has been treated properly for pic usage, that is, we\n-;;   will add the pic_register value to it before trying to dereference it.\n ;; Note: sin and cos are no-longer used.\n-;;\n+\n+(define_constants\n+  [(UNSPEC_SIN       0)\t; `sin' operation (MODE_FLOAT):\n+\t\t\t;   operand 0 is the result,\n+\t\t\t;   operand 1 the parameter.\n+   (UNPSEC_COS\t     1)\t; `cos' operation (MODE_FLOAT):\n+\t\t\t;   operand 0 is the result,\n+\t\t\t;   operand 1 the parameter.\n+   (UNSPEC_PUSH_MULT 2)\t; `push multiple' operation:\n+\t\t\t;   operand 0 is the first register,\n+\t\t\t;   subsequent registers are in parallel (use ...)\n+\t\t\t;   expressions.\n+   (UNSPEC_PIC_SYM   3) ; A symbol that has been treated properly for pic\n+\t\t\t;   usage, that is, we will add the pic_register\n+\t\t\t;   value to it before trying to dereference it.\n+   (UNSPEC_PRLG_STK  4) ; A special barrier that prevents frame accesses \n+\t\t\t;   being scheduled before the stack adjustment insn.\n+   (UNSPEC_CLZ\t     5) ; `clz' instruction, count leading zeros (SImode):\n+\t\t\t;   operand 0 is the result,\n+\t\t\t;   operand 1 is the parameter.\n+  ]\n+)\n+\n ;; UNSPEC_VOLATILE Usage:\n-;; 0 `blockage' insn to prevent scheduling across an insn in the code.\n-;; 1 `epilogue' insn, used to represent any part of the instruction epilogue\n-;;   sequence that isn't expanded into normal RTL.  Used for both normal\n-;;   and sibcall epilogues.\n-;; 2 `align' insn.  Used at the head of a minipool table for inlined \n-;;   constants.\n-;; 3 `end-of-table'.  Used to mark the end of a minipool table.\n-;; 4 `pool-entry(1)'.  An entry in the constant pool for an 8-bit object.\n-;; 5 `pool-entry(2)'.  An entry in the constant pool for a 16-bit object.\n-;; 6 `pool-entry(4)'.  An entry in the constant pool for a 32-bit object.\n-;; 7 `pool-entry(8)'.  An entry in the constant pool for a 64-bit object.\n-;;\n+\n+(define_constants\n+  [(VUNSPEC_BLOCKAGE 0) ; `blockage' insn to prevent scheduling across an\n+\t\t\t;   insn in the code.\n+   (VUNSPEC_EPILOGUE 1) ; `epilogue' insn, used to represent any part of the\n+\t\t\t;   instruction epilogue sequence that isn't expanded\n+\t\t\t;   into normal RTL.  Used for both normal and sibcall\n+\t\t\t;   epilogues.\n+   (VUNSPEC_ALIGN    2) ; `align' insn.  Used at the head of a minipool table \n+\t\t\t;   for inlined constants.\n+   (VUNSPEC_POOL_END 3) ; `end-of-table'.  Used to mark the end of a minipool\n+\t\t\t;   table.\n+   (VUNSPEC_POOL_1   4) ; `pool-entry(1)'.  An entry in the constant pool for\n+\t\t\t;   an 8-bit object.\n+   (VUNSPEC_POOL_2   5) ; `pool-entry(2)'.  An entry in the constant pool for\n+\t\t\t;   a 16-bit object.\n+   (VUNSPEC_POOL_4   6) ; `pool-entry(4)'.  An entry in the constant pool for\n+\t\t\t;   a 32-bit object.\n+   (VUNSPEC_POOL_8   7) ; `pool-entry(8)'.  An entry in the constant pool for\n+\t\t\t;   a 64-bit object.\n+   (VUNSPEC_PREFETCH 8) ; `pld' insn to prefetch a cache line:\n+\t\t\t;   operand 0 is the address to fetch.\n+  ]\n+)\n \f\n+;;---------------------------------------------------------------------------\n ;; Attributes\n \n ; IS_THUMB is set to 'yes' when we are generating Thumb code, and 'no' when\n@@ -345,14 +386,8 @@\n        (eq_attr \"type\" \"!mult,load,store1,store2,store3,store4\")) 32 32)\n \f\n ;;---------------------------------------------------------------------------\n-;; Make code more maintainable by using names for fixed registers.\n-\n-(define_constants\n-  [(LR_REGNUM       14)\n-   (LAST_ARM_REGNUM 15)\n-   (CC_REGNUM       24)]\n-)\n-\n+;; Insn patterns\n+;;\n ;; Addition insns.\n \n ;; Note: For DImode insns, there is normally no reason why operands should\n@@ -2869,58 +2904,66 @@\n ;; to always call a library function.\n ;(define_insn \"sinsf2\"\n ;  [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n-;\t(unspec:SF [(match_operand:SF 1 \"s_register_operand\" \"f\")] 0))]\n+;\t(unspec:SF [(match_operand:SF 1 \"s_register_operand\" \"f\")]\n+;\t\t    UNSPEC_SIN))]\n ;  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n ;  \"sin%?s\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"sindf2\"\n ;  [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n-;\t(unspec:DF [(match_operand:DF 1 \"s_register_operand\" \"f\")] 0))]\n+;\t(unspec:DF [(match_operand:DF 1 \"s_register_operand\" \"f\")]\n+;\t\t    UNSPEC_SIN))]\n ;  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n ;  \"sin%?d\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"*sindf_esfdf\"\n ;  [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n ;\t(unspec:DF [(float_extend:DF\n-;\t\t     (match_operand:SF 1 \"s_register_operand\" \"f\"))] 0))]\n+;\t\t     (match_operand:SF 1 \"s_register_operand\" \"f\"))]\n+;\t\t    UNSPEC_SIN))]\n ;  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n ;  \"sin%?d\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"sinxf2\"\n ;  [(set (match_operand:XF 0 \"s_register_operand\" \"=f\")\n-;\t(unspec:XF [(match_operand:XF 1 \"s_register_operand\" \"f\")] 0))]\n+;\t(unspec:XF [(match_operand:XF 1 \"s_register_operand\" \"f\")]\n+;\t\t   UNSPEC_SIN))]\n ;  \"TARGET_ARM && ENABLE_XF_PATTERNS && TARGET_HARD_FLOAT\"\n ;  \"sin%?e\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"cossf2\"\n ;  [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n-;\t(unspec:SF [(match_operand:SF 1 \"s_register_operand\" \"f\")] 1))]\n+;\t(unspec:SF [(match_operand:SF 1 \"s_register_operand\" \"f\")]\n+;\t\t   UNSPEC_COS))]\n ;  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n ;  \"cos%?s\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"cosdf2\"\n ;  [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n-;\t(unspec:DF [(match_operand:DF 1 \"s_register_operand\" \"f\")] 1))]\n+;\t(unspec:DF [(match_operand:DF 1 \"s_register_operand\" \"f\")]\n+;\t\t   UNSPEC_COS))]\n ;  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n ;  \"cos%?d\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"*cosdf_esfdf\"\n ;  [(set (match_operand:DF 0 \"s_register_operand\" \"=f\")\n ;\t(unspec:DF [(float_extend:DF\n-;\t\t     (match_operand:SF 1 \"s_register_operand\" \"f\"))] 1))]\n+;\t\t     (match_operand:SF 1 \"s_register_operand\" \"f\"))]\n+;\t\t   UNSPEC_COS))]\n ;  \"TARGET_ARM && TARGET_HARD_FLOAT\"\n ;  \"cos%?d\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n ;\n ;(define_insn \"cosxf2\"\n ;  [(set (match_operand:XF 0 \"s_register_operand\" \"=f\")\n-;\t(unspec:XF [(match_operand:XF 1 \"s_register_operand\" \"f\")] 1))]\n+;\t(unspec:XF [(match_operand:XF 1 \"s_register_operand\" \"f\")]\n+;\t\t   UNSEPC_COS))]\n ;  \"TARGET_ARM && ENABLE_XF_PATTERNS && TARGET_HARD_FLOAT\"\n ;  \"cos%?e\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n@@ -4119,7 +4162,7 @@\n \n (define_insn \"pic_load_addr_arm\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] 3))]\n+\t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] UNSPEC_PIC_SYM))]\n   \"TARGET_ARM && flag_pic\"\n   \"ldr%?\\\\t%0, %1\"\n   [(set_attr \"type\" \"load\")\n@@ -4129,7 +4172,7 @@\n \n (define_insn \"pic_load_addr_thumb\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=l\")\n-\t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] 3))]\n+\t(unspec:SI [(match_operand:SI 1 \"\" \"mX\")] UNSPEC_PIC_SYM))]\n   \"TARGET_THUMB && flag_pic\"\n   \"ldr\\\\t%0, %1\"\n   [(set_attr \"type\" \"load\")\n@@ -4140,15 +4183,16 @@\n ;; pic register in the rtl.\n (define_expand \"pic_load_addr_based\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand 1 \"\" \"\") (match_dup 2)] 3))]\n+\t(unspec:SI [(match_operand 1 \"\" \"\") (match_dup 2)] UNSPEC_PIC_SYM))]\n   \"TARGET_ARM && flag_pic\"\n   \"operands[2] = pic_offset_table_rtx;\"\n )\n \n (define_insn \"*pic_load_addr_based_insn\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(unspec:SI [(match_operand 1 \"\" \"\")\n-\t\t    (match_operand 2 \"s_register_operand\" \"r\")] 3))]\n+\t\t    (match_operand 2 \"s_register_operand\" \"r\")]\n+\t\t   UNSPEC_PIC_SYM))]\n   \"TARGET_EITHER && flag_pic && operands[2] == pic_offset_table_rtx\"\n   \"*\n #ifdef AOF_ASSEMBLER\n@@ -6671,7 +6715,7 @@\n ;; all of memory.  This blocks insns from being moved across this point.\n \n (define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_BLOCKAGE)]\n   \"TARGET_EITHER\"\n   \"\"\n   [(set_attr \"length\" \"0\")\n@@ -8600,7 +8644,7 @@\n )\n \n (define_expand \"epilogue\"\n-  [(unspec_volatile [(return)] 1)]\n+  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]\n   \"TARGET_EITHER\"\n   \"\n   if (TARGET_THUMB)\n@@ -8613,13 +8657,13 @@\n   emit_jump_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,\n \tgen_rtvec (1,\n \t\tgen_rtx_RETURN (VOIDmode)),\n-\t1));\n+\tVUNSPEC_EPILOGUE));\n   DONE;\n   \"\n )\n \n (define_insn \"sibcall_epilogue\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_EPILOGUE)]\n   \"TARGET_ARM\"\n   \"*\n   output_asm_insn (\\\"%@ Sibcall epilogue\\\", operands);\n@@ -8633,7 +8677,7 @@\n )\n \n (define_insn \"*epilogue_insns\"\n-  [(unspec_volatile [(return)] 1)]\n+  [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]\n   \"TARGET_EITHER\"\n   \"*\n   if (TARGET_ARM)\n@@ -8838,7 +8882,8 @@\n (define_insn \"*push_multi\"\n   [(match_parallel 2 \"multi_register_push\"\n     [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n-\t  (unspec:BLK [(match_operand:SI 1 \"s_register_operand\" \"r\")] 2))])]\n+\t  (unspec:BLK [(match_operand:SI 1 \"s_register_operand\" \"r\")]\n+\t\t      UNSPEC_PUSH_MULT))])]\n   \"TARGET_ARM\"\n   \"*\n   {\n@@ -8875,7 +8920,8 @@\n (define_insn \"*push_fp_multi\"\n   [(match_parallel 2 \"multi_register_push\"\n     [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n-\t  (unspec:BLK [(match_operand:XF 1 \"f_register_operand\" \"f\")] 2))])]\n+\t  (unspec:BLK [(match_operand:XF 1 \"f_register_operand\" \"f\")]\n+\t\t      UNSPEC_PUSH_MULT))])]\n   \"TARGET_ARM\"\n   \"*\n   {\n@@ -8891,7 +8937,7 @@\n ;; Special patterns for dealing with the constant pool\n \n (define_insn \"align_4\"\n-  [(unspec_volatile [(const_int 0)] 2)]\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN)]\n   \"TARGET_EITHER\"\n   \"*\n   assemble_align (32);\n@@ -8900,7 +8946,7 @@\n )\n \n (define_insn \"consttable_end\"\n-  [(unspec_volatile [(const_int 0)] 3)]\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_END)]\n   \"TARGET_EITHER\"\n   \"*\n   making_const_table = FALSE;\n@@ -8909,7 +8955,7 @@\n )\n \n (define_insn \"consttable_1\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] 4)]\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_1)]\n   \"TARGET_THUMB\"\n   \"*\n   making_const_table = TRUE;\n@@ -8921,7 +8967,7 @@\n )\n \n (define_insn \"consttable_2\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] 5)]\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_2)]\n   \"TARGET_THUMB\"\n   \"*\n   making_const_table = TRUE;\n@@ -8933,7 +8979,7 @@\n )\n \n (define_insn \"consttable_4\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] 6)]\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_4)]\n   \"TARGET_EITHER\"\n   \"*\n   {\n@@ -8957,7 +9003,7 @@\n )\n \n (define_insn \"consttable_8\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"\")] 7)]\n+  [(unspec_volatile [(match_operand 0 \"\" \"\")] VUNSPEC_POOL_8)]\n   \"TARGET_EITHER\"\n   \"*\n   {\n@@ -8994,16 +9040,37 @@\n \n (define_insn \"clz\"\n   [(set (match_operand:SI             0 \"s_register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand:SI 1 \"s_register_operand\" \"r\")] 128))]\n-  \"TARGET_ARM\"\n+\t(unspec:SI [(match_operand:SI 1 \"s_register_operand\" \"r\")]\n+\t\t   UNSPEC_CLZ))]\n+  \"TARGET_ARM && arm_arch5\"\n   \"clz\\\\t%0, %1\")\n \n-;; XScale instructions.\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(ffs:SI (match_operand:SI 1 \"s_register_operand\" \"\")))]\n+  \"TARGET_ARM && arm_arch5\"\n+  \"\n+  {\n+    rtx t1, t2, t3;\n+\n+    t1 = gen_reg_rtx (SImode);\n+    t2 = gen_reg_rtx (SImode);\n+    t3 = gen_reg_rtx (SImode);\n+\n+    emit_insn (gen_negsi2 (t1, operands[1]));\n+    emit_insn (gen_andsi3 (t2, operands[1], t1));\n+    emit_insn (gen_clz (t3, t2));\n+    emit_insn (gen_subsi3 (operands[0], GEN_INT (32), t3));\n+    DONE;\n+  }\"\n+)\n+\n+;; V5E instructions.\n \n (define_insn \"prefetch\"\n   [(unspec_volatile\n-    [(match_operand:SI 0 \"offsettable_memory_operand\" \"o\")] 129)]\n-  \"TARGET_ARM\"\n+    [(match_operand:SI 0 \"offsettable_memory_operand\" \"o\")] VUNSPEC_PREFETCH)]\n+  \"TARGET_ARM && arm_arch5e\"\n   \"pld\\\\t%0\")\n \n ;; General predication pattern"}]}