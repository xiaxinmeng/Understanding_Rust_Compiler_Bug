{"sha": "c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFhYTRkZTc3Mjc1N2YwYzVhZmI2MWY4ZWJjZjU4NTUwZmM2MmE4Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-05-17T07:42:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-05-17T07:42:26Z"}, "message": "call.c (build_over_call): Don't throw away initializations/copies of empty classes...\n\n\t* call.c (build_over_call): Don't throw away\n\tinitializations/copies of empty classes; use MODIFY_EXPR and\n\tINIT_EXPR as for non-empty classes.\n\t* class.c (finish_struct_1): Put the padding byte for an empty\n\tclass on the TYPE_NONCOPIED_PARTS list for the class.\n\nFrom-SVN: r26970", "tree": {"sha": "b1c29c81f940d1d1cf394201e11ed95b079eafcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1c29c81f940d1d1cf394201e11ed95b079eafcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/comments", "author": null, "committer": null, "parents": [{"sha": "c15398de775ea6bb100d761e7ebad03d2daec8a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c15398de775ea6bb100d761e7ebad03d2daec8a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c15398de775ea6bb100d761e7ebad03d2daec8a4"}], "stats": {"total": 90, "additions": 71, "deletions": 19}, "files": [{"sha": "a43deddfdb1726f53da1459a4f3fabce626e7130", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "patch": "@@ -1,3 +1,11 @@\n+1999-05-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_over_call): Don't throw away\n+\tinitializations/copies of empty classes; use MODIFY_EXPR and\n+\tINIT_EXPR as for non-empty classes.\n+\t* class.c (finish_struct_1): Put the padding byte for an empty\n+\tclass on the TYPE_NONCOPIED_PARTS list for the class.\n+\n 1999-05-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (build_expr_from_tree): Handle COMPONENT_REFs that"}, {"sha": "496cf91e17efc233d3cf9ccb05e730a1e2fbc27e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "patch": "@@ -3426,20 +3426,34 @@ build_over_call (cand, args, flags)\n       else if (! real_lvalue_p (arg)\n \t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t{\n+\t  tree address;\n \t  tree to = stabilize_reference\n \t    (build_indirect_ref (TREE_VALUE (args), 0));\n \n-\t  /* Don't copy the padding byte; it might not have been allocated\n-\t     if to is a base subobject.  */\n-\t  if (is_empty_class (DECL_CLASS_CONTEXT (fn)))\n-\t    return build_unary_op\n-\t      (ADDR_EXPR, build (COMPOUND_EXPR, TREE_TYPE (to),\n-\t\t\t\t cp_convert (void_type_node, arg), to),\n-\t       0);\n-\n-\t  val = build (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n+\t  /* If we're initializing an empty class, then we actually\n+\t     have to use a MODIFY_EXPR rather than an INIT_EXPR.  The\n+\t     reason is that the dummy padding member in the target may\n+\t     not actually be allocated if TO is a base class\n+\t     subobject.  Since we've set TYPE_NONCOPIED_PARTS on the\n+\t     padding, a MODIFY_EXPR will preserve its value, which is\n+\t     the right thing to do if it's not really padding at all.\n+\t  \n+\t     It's not safe to just throw away the ARG if we're looking\n+\t     at an empty class because the ARG might contain a\n+\t     TARGET_EXPR which wants to be bound to TO.  If it is not,\n+\t     expand_expr will assign a dummy slot for the TARGET_EXPR,\n+\t     and we will call a destructor for it, which is wrong,\n+\t     because we will also destroy TO, but will never have\n+\t     constructed it.  */\n+\t  val = build (is_empty_class (DECL_CLASS_CONTEXT (fn))\n+\t\t       ? MODIFY_EXPR : INIT_EXPR, \n+\t\t       DECL_CONTEXT (fn), to, arg);\n \t  TREE_SIDE_EFFECTS (val) = 1;\n-\t  return build_unary_op (ADDR_EXPR, val, 0);\n+\t  address = build_unary_op (ADDR_EXPR, val, 0);\n+\t  /* Avoid a warning about this expression, if the address is\n+\t     never used.  */\n+\t  TREE_USED (address) = 1;\n+\t  return address;\n \t}\n     }\n   else if (DECL_NAME (fn) == ansi_opname[MODIFY_EXPR]\n@@ -3451,12 +3465,6 @@ build_over_call (cand, args, flags)\n \n       arg = build_indirect_ref (TREE_VALUE (TREE_CHAIN (converted_args)), 0);\n \n-      /* Don't copy the padding byte; it might not have been allocated\n-\t if to is a base subobject.  */\n-      if (is_empty_class (DECL_CLASS_CONTEXT (fn)))\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (to),\n-\t\t      cp_convert (void_type_node, arg), to);\n-\n       val = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n       TREE_SIDE_EFFECTS (val) = 1;\n       return val;"}, {"sha": "f7998c1c9769c188ae0dc8abb2b9fa967e85d0da", "filename": "gcc/cp/class.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "patch": "@@ -3133,6 +3133,7 @@ finish_struct_1 (t, warn_anon)\n   int aggregate = 1;\n   int empty = 1;\n   int has_pointers = 0;\n+  tree inline_friends;\n \n   if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n     pedwarn (\"anonymous class type not used to declare any objects\");\n@@ -3740,14 +3741,25 @@ finish_struct_1 (t, warn_anon)\n \tif (DECL_SIZE (x) != integer_zero_node)\n \t  empty = 0;\n     }\n+\n+  /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n+     we have to save this before we start modifying\n+     TYPE_NONCOPIED_PARTS.  */\n+  inline_friends = CLASSTYPE_INLINE_FRIENDS (t);\n+  CLASSTYPE_INLINE_FRIENDS (t) = NULL_TREE;\n+\n   if (empty)\n     {\n       /* C++: do not let empty structures exist.  */\n       tree decl = build_lang_field_decl\n \t(FIELD_DECL, NULL_TREE, char_type_node);\n       TREE_CHAIN (decl) = fields;\n       TYPE_FIELDS (t) = decl;\n+      TYPE_NONCOPIED_PARTS (t) \n+\t= tree_cons (NULL_TREE, decl, TYPE_NONCOPIED_PARTS (t));\n+      TREE_STATIC (TYPE_NONCOPIED_PARTS (t)) = 1;\n     }\n+\n   if (n_baseclasses)\n     TYPE_FIELDS (t) = chainon (last_x, TYPE_FIELDS (t));\n \n@@ -4021,8 +4033,7 @@ finish_struct_1 (t, warn_anon)\n     }\n \n   /* Write out inline function definitions.  */\n-  do_inline_function_hair (t, CLASSTYPE_INLINE_FRIENDS (t));\n-  CLASSTYPE_INLINE_FRIENDS (t) = 0;\n+  do_inline_function_hair (t, inline_friends);\n \n   if (CLASSTYPE_VSIZE (t) != 0)\n     {\n@@ -4049,7 +4060,9 @@ finish_struct_1 (t, warn_anon)\n       /* In addition to this one, all the other vfields should be listed.  */\n       /* Before that can be done, we have to have FIELD_DECLs for them, and\n \t a place to find them.  */\n-      TYPE_NONCOPIED_PARTS (t) = build_tree_list (default_conversion (TYPE_BINFO_VTABLE (t)), vfield);\n+      TYPE_NONCOPIED_PARTS (t) \n+\t= tree_cons (default_conversion (TYPE_BINFO_VTABLE (t)),\n+\t\t     vfield, TYPE_NONCOPIED_PARTS (t));\n \n       if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (t)\n \t  && DECL_VINDEX (TREE_VEC_ELT (method_vec, 1)) == NULL_TREE)"}, {"sha": "0789884079b972c6b99563535ee1197f6cd1d53a", "filename": "gcc/testsuite/g++.old-deja/g++.other/empty1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fempty1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1aa4de772757f0c5afb61f8ebcf58550fc62a83/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fempty1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fempty1.C?ref=c1aa4de772757f0c5afb61f8ebcf58550fc62a83", "patch": "@@ -0,0 +1,23 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+extern \"C\" void abort();\n+extern \"C\" void printf(const char*, ...);\n+\n+int i;\n+\n+struct A;\n+\n+struct A* as[10];\n+\n+struct A {\n+  A () { as[i++] = this; }\n+  A (const A&) { as[i++] = this; }\n+  ~A() { if (i == 0 || as[--i] != this) abort(); }\n+};\n+\n+A f() { return A(); }\n+\n+int main ()\n+{\n+  A a (f ());\n+}"}]}