{"sha": "fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiMmY1MmNmODQ0ZjIwZWMzYjU3NWQ0MWFkN2U1YzJkODE3MTkwZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-03-24T05:57:52Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-03-24T05:57:52Z"}, "message": "re PR rtl-optimization/20532 (Bad code for DImode left shifts by 31 and then 1)\n\ngcc/ChangeLog:\nPR rtl-optimization/20532\n* simplify-rtx.c (simplify_binary_operation_1): Protect from\noverflow when adding coefficients for PLUS or MINUS.\n(simplify_binary_operation_1): Handle CONST_DOUBLE exact power of\ntwo as multiplier.\ngcc/testsuite/ChangeLog:\nPR rtl-optimization/20532\n* gcc.target/i386/badshift.c: New.\n\nFrom-SVN: r96982", "tree": {"sha": "0505157da8df3cd049d8bef6cf9e8998c96a240f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0505157da8df3cd049d8bef6cf9e8998c96a240f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/comments", "author": null, "committer": null, "parents": [{"sha": "347669a079a7005bf211e57cba5db24d0b99f2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347669a079a7005bf211e57cba5db24d0b99f2f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347669a079a7005bf211e57cba5db24d0b99f2f3"}], "stats": {"total": 131, "additions": 113, "deletions": 18}, "files": [{"sha": "933e4e446eb8400fb3e1400df2429639c5f42bff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "patch": "@@ -1,3 +1,11 @@\n+2005-03-24  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/20532\n+\t* simplify-rtx.c (simplify_binary_operation_1): Protect from\n+\toverflow when adding coefficients for PLUS or MINUS.\n+\t(simplify_binary_operation_1): Handle CONST_DOUBLE exact power of\n+\ttwo as multiplier.\n+\n 2005-03-23  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* langhooks.h (truthvalue_conversion): Remove."}, {"sha": "865d6f933bb398c8c24a6f45fc4350671e026eac", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 72, "deletions": 18, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "patch": "@@ -1257,44 +1257,67 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       if (! FLOAT_MODE_P (mode))\n \t{\n-\t  HOST_WIDE_INT coeff0 = 1, coeff1 = 1;\n+\t  HOST_WIDE_INT coeff0h = 0, coeff1h = 0;\n+\t  unsigned HOST_WIDE_INT coeff0l = 1, coeff1l = 1;\n \t  rtx lhs = op0, rhs = op1;\n \n \t  if (GET_CODE (lhs) == NEG)\n-\t    coeff0 = -1, lhs = XEXP (lhs, 0);\n+\t    {\n+\t      coeff0l = -1;\n+\t      coeff0h = -1;\n+\t      lhs = XEXP (lhs, 0);\n+\t    }\n \t  else if (GET_CODE (lhs) == MULT\n \t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT)\n-\t    coeff0 = INTVAL (XEXP (lhs, 1)), lhs = XEXP (lhs, 0);\n+\t    {\n+\t      coeff0l = INTVAL (XEXP (lhs, 1));\n+\t      coeff0h = INTVAL (XEXP (lhs, 1)) < 0 ? -1 : 0;\n+\t      lhs = XEXP (lhs, 0);\n+\t    }\n \t  else if (GET_CODE (lhs) == ASHIFT\n \t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (lhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff0 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n+\t      coeff0l = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n+\t      coeff0h = 0;\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \n \t  if (GET_CODE (rhs) == NEG)\n-\t    coeff1 = -1, rhs = XEXP (rhs, 0);\n+\t    {\n+\t      coeff1l = -1;\n+\t      coeff1h = -1;\n+\t      rhs = XEXP (rhs, 0);\n+\t    }\n \t  else if (GET_CODE (rhs) == MULT\n \t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT)\n \t    {\n-\t      coeff1 = INTVAL (XEXP (rhs, 1)), rhs = XEXP (rhs, 0);\n+\t      coeff1l = INTVAL (XEXP (rhs, 1));\n+\t      coeff1h = INTVAL (XEXP (rhs, 1)) < 0 ? -1 : 0;\n+\t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == ASHIFT\n \t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (rhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff1 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1));\n+\t      coeff1l = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1));\n+\t      coeff1h = 0;\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \n \t  if (rtx_equal_p (lhs, rhs))\n \t    {\n \t      rtx orig = gen_rtx_PLUS (mode, op0, op1);\n-\t      tem = simplify_gen_binary (MULT, mode, lhs,\n-\t\t\t\t\t GEN_INT (coeff0 + coeff1));\n+\t      rtx coeff;\n+\t      unsigned HOST_WIDE_INT l;\n+\t      HOST_WIDE_INT h;\n+\n+\t      add_double (coeff0l, coeff0h, coeff1l, coeff1h, &l, &h);\n+\t      coeff = immed_double_const (l, h, mode);\n+\n+\t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n \t      return rtx_cost (tem, SET) <= rtx_cost (orig, SET)\n \t\t? tem : 0;\n \t    }\n@@ -1405,46 +1428,67 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       if (! FLOAT_MODE_P (mode))\n \t{\n-\t  HOST_WIDE_INT coeff0 = 1, coeff1 = 1;\n+\t  HOST_WIDE_INT coeff0h = 0, negcoeff1h = -1;\n+\t  unsigned HOST_WIDE_INT coeff0l = 1, negcoeff1l = -1;\n \t  rtx lhs = op0, rhs = op1;\n \n \t  if (GET_CODE (lhs) == NEG)\n-\t    coeff0 = -1, lhs = XEXP (lhs, 0);\n+\t    {\n+\t      coeff0l = -1;\n+\t      coeff0h = -1;\n+\t      lhs = XEXP (lhs, 0);\n+\t    }\n \t  else if (GET_CODE (lhs) == MULT\n \t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT)\n \t    {\n-\t      coeff0 = INTVAL (XEXP (lhs, 1)), lhs = XEXP (lhs, 0);\n+\t      coeff0l = INTVAL (XEXP (lhs, 1));\n+\t      coeff0h = INTVAL (XEXP (lhs, 1)) < 0 ? -1 : 0;\n+\t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == ASHIFT\n \t\t   && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (lhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff0 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n+\t      coeff0l = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n+\t      coeff0h = 0;\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \n \t  if (GET_CODE (rhs) == NEG)\n-\t    coeff1 = - 1, rhs = XEXP (rhs, 0);\n+\t    {\n+\t      negcoeff1l = 1;\n+\t      negcoeff1h = 0;\n+\t      rhs = XEXP (rhs, 0);\n+\t    }\n \t  else if (GET_CODE (rhs) == MULT\n \t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT)\n \t    {\n-\t      coeff1 = INTVAL (XEXP (rhs, 1)), rhs = XEXP (rhs, 0);\n+\t      negcoeff1l = -INTVAL (XEXP (rhs, 1));\n+\t      negcoeff1h = INTVAL (XEXP (rhs, 1)) <= 0 ? 0 : -1;\n+\t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == ASHIFT\n \t\t   && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (rhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff1 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1));\n+\t      negcoeff1l = -(((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1)));\n+\t      negcoeff1h = -1;\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \n \t  if (rtx_equal_p (lhs, rhs))\n \t    {\n \t      rtx orig = gen_rtx_MINUS (mode, op0, op1);\n-\t      tem = simplify_gen_binary (MULT, mode, lhs,\n-\t\t\t\t\t GEN_INT (coeff0 - coeff1));\n+\t      rtx coeff;\n+\t      unsigned HOST_WIDE_INT l;\n+\t      HOST_WIDE_INT h;\n+\n+\t      add_double (coeff0l, coeff0h, negcoeff1l, negcoeff1h, &l, &h);\n+\t      coeff = immed_double_const (l, h, mode);\n+\n+\t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n \t      return rtx_cost (tem, SET) <= rtx_cost (orig, SET)\n \t\t? tem : 0;\n \t    }\n@@ -1531,6 +1575,16 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      || val != HOST_BITS_PER_WIDE_INT - 1))\n \treturn simplify_gen_binary (ASHIFT, mode, op0, GEN_INT (val));\n \n+      /* Likewise for multipliers wider than a word.  */\n+      else if (GET_CODE (trueop1) == CONST_DOUBLE\n+\t       && (GET_MODE (trueop1) == VOIDmode\n+\t\t   || GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_INT)\n+\t       && GET_MODE (op0) == mode\n+\t       && CONST_DOUBLE_LOW (trueop1) == 0\n+\t       && (val = exact_log2 (CONST_DOUBLE_HIGH (trueop1))) >= 0)\n+\treturn simplify_gen_binary (ASHIFT, mode, op0,\n+\t\t\t\t    GEN_INT (val + HOST_BITS_PER_WIDE_INT));\n+\n       /* x*2 is x+x and x*(-1) is -x */\n       if (GET_CODE (trueop1) == CONST_DOUBLE\n \t  && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT"}, {"sha": "41fd479b52d209e5703a5f1bee1c4a5137eb3c5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "patch": "@@ -1,3 +1,8 @@\n+2005-03-24  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/20532\n+\t* gcc.target/i386/badshift.c: New.\n+\n 2005-03-23  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* pr18025.f90: New test."}, {"sha": "ddbf6130b8ea1a8652f40f28cc2513d7b3a315be", "filename": "gcc/testsuite/gcc.target/i386/badshift.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbadshift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fab2f52cf844f20ec3b575d41ad7e5c2d817190d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbadshift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbadshift.c?ref=fab2f52cf844f20ec3b575d41ad7e5c2d817190d", "patch": "@@ -0,0 +1,28 @@\n+/* PR rtl-optimization/20532 */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-m32 -march=i386 -O1\" } */\n+\n+/* We used to optimize the DImode shift-by-32 to zero because in combine\n+   we turned:\n+\n+     (v << 31) * (v << 31)\n+\n+   into:\n+\n+     (v * (((HOST_WIDE_INT)1 << 31) + ((HOST_WIDE_INT)1 << 31)))\n+\n+   With a 32-bit HOST_WIDE_INT, the coefficient overflowed to zero.  */\n+\n+unsigned long long int badshift(unsigned long long int v)\n+{\n+        return v << 31 << 1;\n+}\n+\n+extern void abort ();\n+\n+int main() {\n+  if (badshift (1) == 0)\n+    abort ();\n+  return 0;\n+}"}]}