{"sha": "e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJhZjY2NGMyZDZhZGQ2MTRmMWVmMDQ0Zjc4YjBjNmVmODljZjBkNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-10-01T10:50:15Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-10-01T10:50:15Z"}, "message": "Add support for #pragma pack(push,<n>) and #pragma pack(pop).\n\nFrom-SVN: r22710", "tree": {"sha": "f2a375a13ffbab6fc37885d69817a8914b50746e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2a375a13ffbab6fc37885d69817a8914b50746e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/comments", "author": null, "committer": null, "parents": [{"sha": "3a846e6e06590d0c593708b53a8aee20ac2fea32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a846e6e06590d0c593708b53a8aee20ac2fea32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a846e6e06590d0c593708b53a8aee20ac2fea32"}], "stats": {"total": 651, "additions": 503, "deletions": 148}, "files": [{"sha": "ce607e1509e462d9929b06c9a3e6981c7923b238", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -1,10 +1,45 @@\n Thu Oct  1 10:42:27 1998  Nick Clifton  <nickc@cygnus.com>\n \n+\t* c-pragma.c: Add support for HANDLE_PRAGMA_PACK and\n+\tHANDLE_PRAGMA_PACK_PUSH_POP.\n+\t(push_alignment): New function: Cache an alignment requested\n+\tby a #pragma pack(push,<n>).\n+\t(pop_alignment): New function: Pop an alignment from the\n+\talignment stack.\n+\t(insert_pack_attributes): New function: Generate __packed__\n+\tand __aligned__ attributes for new decls whilst a #pragma pack\n+\tis in effect. \n+\t(add_weak): New function: Cache a #pragma weak directive.\n+\t(handle_pragma_token): Document calling conventions.  Add\n+\tsupport for #pragma pack(push,<n>) and #pragma pack (pop).\n+\n+\t* c-pragma.h: If HANDLE_SYSV_PRAGMA or HANDLE_PRAGMA_PACK_PUSH_POP\n+\tare defined enable HANDLE_PRAGMA_PACK.\n+\tMove 'struct weak_syms' here (from varasm.c).\n+\tAdd pragma states for push and pop pragmas.\n+\n+\t* c-common.c (decl_attributes): Call PRAGMA_INSERT_ATTRIBUTES\n+\tif it is defined.\n+\n+\t* c-lex.c: Replace occurances of HANDLE_SYSV_PRAGMA with\n+\tHANDLE_GENERIC_PRAGMAS.\n+\t\n+\t* varasm.c: Move definition of 'struct weak_syms' into\n+\tc-pragma.h. \n+\t(handle_pragma_weak): Deleted.\n+\n+\t* config/i386/i386.h: Define HANDLE_PRAGMA_PACK_PUSH_POP.\n+\n+\t* config/winnt/win-nt.h: Define HANDLE_PRAGMA_PACK_PUSH_POP.\n+\n \t* c-decl.c (start_function): Add invocation of\n \tSET_DEFAULT_DECL_ATTRIBUTES, if defined.\n \n \t* tm.texi: Remove description of non-existant macro\n \tSET_DEFAULT_SECTION_NAME.\n+\t\n+\t(HANDLE_SYSV_PRAGMA): Document.\n+\t(HANDLE_PRAGMA_PACK_PUSH_POP): Document.\n \n Wed Sep 30 22:27:53 1998  Robert Lipe  <robertl@dgii.com>\n "}, {"sha": "5fcf1bc9a50734b0207b59c2e586b26396035698", "filename": "gcc/c-common.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"c-pragma.h\"\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -420,6 +421,14 @@ decl_attributes (node, attributes, prefix_attributes)\n   else if (TREE_CODE_CLASS (TREE_CODE (node)) == 't')\n     type = node, is_type = 1;\n \n+#ifdef PRAGMA_INSERT_ATTRIBUTES\n+  /* If the code in c-pragma.c wants to insert some attributes then\n+     allow it to do so.  Do this before allowing machine back ends to\n+     insert attributes, so that they have the opportunity to override\n+     anything done here.  */\n+  PRAGMA_INSERT_ATTRIBUTES (node, & attributes, & prefix_attributes);\n+#endif\n+  \n #ifdef INSERT_ATTRIBUTES\n   INSERT_ATTRIBUTES (node, & attributes, & prefix_attributes);\n #endif"}, {"sha": "af627cd5315904bc385d82442cccfb7ae9b35a34", "filename": "gcc/c-lex.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -110,9 +110,9 @@ static int end_of_file;\n static int nextchar = -1;\n #endif\n \n-#ifdef HANDLE_SYSV_PRAGMA\n-static int handle_sysv_pragma\t\tPROTO((int));\n-#endif /* HANDLE_SYSV_PRAGMA */\n+#ifdef HANDLE_GENERIC_PRAGMAS\n+static int handle_generic_pragma\tPROTO((int));\n+#endif /* HANDLE_GENERIC_PRAGMAS */\n static int whitespace_cr\t\tPROTO((int));\n static int skip_white_space\t\tPROTO((int));\n static int skip_white_space_on_line\tPROTO((void));\n@@ -543,34 +543,37 @@ check_newline ()\n \t      if (c == '\\n')\n \t\treturn c;\n \n-#if defined HANDLE_PRAGMA || defined HANDLE_SYSV_PRAGMA\t      \n+#if defined HANDLE_PRAGMA || defined HANDLE_GENERIC_PRAGMAS\n \t      UNGETC (c);\n \t      token = yylex ();\n \t      if (token != IDENTIFIER)\n \t\tgoto skipline;\n+#endif /* HANDLE_PRAGMA || HANDLE_GENERIC_PRAGMAS */\n \t      \n #ifdef HANDLE_PRAGMA\n-\t      /* We invoke HANDLE_PRAGMA before HANDLE_SYSV_PRAGMA\n-\t\t (if both are defined), in order to give the back\n-\t\t end a chance to override the interpretation of\n-\t\t SYSV style pragmas.  */\n+\t      /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS (if\n+\t\t both are defined), in order to give the back end a chance to\n+\t\t override the interpretation of generic style pragmas.  */\n #if !USE_CPPLIB\n \t      if (nextchar >= 0)\n \t\t{\n \t\t  c = nextchar, nextchar = -1;\n \t\t  UNGETC (c);\n \t\t}\n-#endif\n+#endif /* !USE_CPPLIB */\n+\t      \n+\t      if (TREE_CODE (yylval.ttype) != IDENTIFIER_NODE)\n+\t\tgoto skipline;\n+\n \t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n \t\t\t\t IDENTIFIER_POINTER (yylval.ttype)))\n \t\treturn GETC ();\n #endif /* HANDLE_PRAGMA */\n \t      \n-#ifdef HANDLE_SYSV_PRAGMA\n-\t      if (handle_sysv_pragma (token))\n+#ifdef HANDLE_GENERIC_PRAGMAS\n+\t      if (handle_generic_pragma (token))\n \t\treturn GETC ();\n-#endif /* !HANDLE_SYSV_PRAGMA */\n-#endif /* HANDLE_PRAGMA || HANDLE_SYSV_PRAGMA */\n+#endif /* HANDLE_GENERIC_PRAGMAS */\n \t      \n \t      /* Issue a warning message if we have been asked to do so.\n \t\t Ignoring unknown pragmas in system header file unless\n@@ -837,17 +840,17 @@ check_newline ()\n   return c;\n }\n \f\n-#ifdef HANDLE_SYSV_PRAGMA\n+#ifdef HANDLE_GENERIC_PRAGMAS\n \n /* Handle a #pragma directive.\n    TOKEN is the token we read after `#pragma'.  Processes the entire input\n-   line and returns a character for the caller to reread: either \\n or EOF.  */\n+   line and return non-zero iff the pragma has been successfully parsed.  */\n \n /* This function has to be in this file, in order to get at\n    the token types.  */\n \n static int\n-handle_sysv_pragma (token)\n+handle_generic_pragma (token)\n      register int token;\n {\n   register int c;\n@@ -883,7 +886,7 @@ handle_sysv_pragma (token)\n     }\n }\n \n-#endif /* HANDLE_SYSV_PRAGMA */\n+#endif /* HANDLE_GENERIC_PRAGMAS */\n \f\n #define ENDFILE -1  /* token that represents end-of-file */\n "}, {"sha": "90edeb744a116593532bd0ffd0037f9f3d900d12", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 334, "deletions": 71, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -29,50 +29,275 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"toplev.h\"\n \n-#ifdef HANDLE_SYSV_PRAGMA\n+#ifdef HANDLE_GENERIC_PRAGMAS\n \n+#ifdef HANDLE_PRAGMA_PACK\n /* When structure field packing is in effect, this variable is the\n    number of bits to use as the maximum alignment.  When packing is not\n    in effect, this is zero.  */\n \n extern int maximum_field_alignment;\n+#endif\n+\n+\n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+typedef struct align_stack\n+{\n+  int                  alignment;\n+  unsigned int         num_pushes;\n+  struct align_stack * prev;\n+} align_stack;\n+\n+static struct align_stack * alignment_stack = NULL;\n+\n+static int  push_alignment PROTO((int));\n+static int  pop_alignment  PROTO((void));\n+\n+/* Push an alignment value onto the stack.  */\n+static int\n+push_alignment (alignment)\n+     int alignment;\n+{\n+  switch (alignment)\n+    {\n+    case 0:\n+    case 1:\n+    case 2:\n+    case 4:\n+    case 8:\n+    case 16:\n+      break;\n+    default:\n+      warning (\"\\\n+Alignment must be a small power of two, not %d, in #pragma pack\",\n+\t       alignment);\n+      return 0;\n+    }\n+  \n+  if (alignment_stack == NULL\n+      || alignment_stack->alignment != alignment)\n+    {\n+      align_stack * entry;\n+\n+      entry = (align_stack *) xmalloc (sizeof (* entry));\n+\n+      if (entry == NULL)\n+\t{\n+\t  warning (\"Out of memory pushing #pragma pack\");\n+\t  return 0;\n+\t}\n+\n+      entry->alignment  = alignment;\n+      entry->num_pushes = 1;\n+      entry->prev       = alignment_stack;\n+      \n+      alignment_stack = entry;\n+\n+      if (alignment < 8)\n+\tmaximum_field_alignment = alignment * 8;\n+      else\n+\t/* MSVC ignores alignments > 4.  */\n+\tmaximum_field_alignment = 0;\n+    }\n+  else\n+    alignment_stack->num_pushes ++;\n+\n+  return 1;\n+}\n+\n+/* Undo a push of an alignment onto the stack.  */\n+static int\n+pop_alignment ()\n+{\n+  if (alignment_stack == NULL)\n+    {\n+      warning (\"\\\n+#pragma pack(pop) encountered without corresponding #pragma pack(push,<n>)\");\n+      return 0;\n+    }\n+\n+  if (-- alignment_stack->num_pushes == 0)\n+    {\n+      align_stack * entry;\n+      \n+      entry = alignment_stack->prev;\n+\n+      if (entry == NULL || entry->alignment > 4)\n+\tmaximum_field_alignment = 0;\n+      else\n+\tmaximum_field_alignment = entry->alignment * 8;\n+\n+      free (alignment_stack);\n+\n+      alignment_stack = entry;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Generate 'packed' and 'aligned' attributes for decls whilst a\n+   #pragma pack(push... is in effect.  */\n+void\n+insert_pack_attributes (node, attributes, prefix)\n+     tree node;\n+     tree * attributes;\n+     tree * prefix;\n+{\n+  tree a;\n+\n+  /* If we are not packing, then there is nothing to do.  */\n+  if (maximum_field_alignment == 0)\n+    return;\n+\n+  /* We are only interested in fields.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) != 'd'\n+      || TREE_CODE (node) != FIELD_DECL)\n+    return;\n+\n+  /* Add a 'packed' attribute.  */\n+  * attributes = tree_cons (get_identifier (\"packed\"), NULL, * attributes);\n+  \n+  /* If the alignment is > 8 then add an alignment attribute as well.  */\n+  if (maximum_field_alignment > 8)\n+    {\n+      /* If the aligned attribute is already present then do not override it.  */\n+      for (a = * attributes; a; a = TREE_CHAIN (a))\n+\t{\n+\t  tree name = TREE_PURPOSE (a);\n+\t  if (strcmp (IDENTIFIER_POINTER (name), \"aligned\") == 0)\n+\t    break;\n+\t}\n+      \n+      if (a == NULL)\n+\tfor (a = * prefix; a; a = TREE_CHAIN (a))\n+\t  {\n+\t    tree name = TREE_PURPOSE (a);\n+\t    if (strcmp (IDENTIFIER_POINTER (name), \"aligned\") == 0)\n+\t      break;\n+\t  }\n+  \n+      if (a == NULL)\n+\t{\n+\t  * attributes = tree_cons\n+\t      (get_identifier (\"aligned\"),\n+\t       tree_cons (NULL,\n+\t\t\t  build_int_2 (maximum_field_alignment / 8, 0),\n+\t\t\t  NULL),\n+\t       * attributes);\n+\t}\n+    }\n+\n+  return;\n+}\n+#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n+\f\n+#ifdef HANDLE_PRAGMA_WEAK\n+static int add_weak PROTO((char *, char *));\n+\n+static int\n+add_weak (name, value)\n+     char * name;\n+     char * value;\n+{\n+  struct weak_syms * weak;\n \n-/* Handle one token of a pragma directive.  TOKEN is the\n-   current token, and STRING is its printable form. \n-   Return zero if an entire pragma was parsed, but it was\n-   flawed in some way.  Return non-zero in all other cases.  */\n+  weak = (struct weak_syms *) permalloc (sizeof (struct weak_syms));\n+\n+  if (weak == NULL)\n+    return 0;\n+  \n+  weak->next  = weak_decls;\n+  weak->name  = name;\n+  weak->value = value;\n+  weak_decls  = weak;\n+\n+  return 1;\n+}\n+#endif /* HANDLE_PRAGMA_WEAK */\n+\f\n+/* Handle one token of a pragma directive.  TOKEN is the current token, and\n+   STRING is its printable form.  Some front ends do not support generating\n+   tokens, and will only pass in a STRING.  Also some front ends will reuse\n+   the buffer containing STRING, so it must be copied to a local buffer if\n+   it needs to be preserved.\n+\n+   If STRING is non-NULL, then the return value will be ignored, and there\n+   will be futher calls to handle_pragma_token() in order to handle the rest of\n+   the line containing the #pragma directive.  If STRING is NULL, the entire\n+   line has now been presented to handle_pragma_token() and the return value\n+   should be zero if the pragma flawed in some way, or if the pragma was not\n+   recognised, and non-zero if it was successfully handled.  */\n \n int\n handle_pragma_token (string, token)\n-     char *string;\n+     char * string;\n      tree token;\n {\n-  static enum pragma_state state = ps_start, type;\n-  static char *name;\n-  static char *value;\n+  static enum pragma_state state = ps_start;\n+  static enum pragma_state type;\n+  static char * name;\n+  static char * value;\n   static int align;\n \n+  /* If we have reached the end of the #pragma directive then\n+     determine what value we should return.  */\n+  \n   if (string == NULL)\n     {\n-      int ret_val = 1;\n-      \n-      if (type == ps_pack)\n+      int ret_val = 0;\n+\n+      switch (type)\n \t{\n+\tdefault:\n+\t  abort ();\n+\t  break;\n+\n+\tcase ps_done:\n+\t  /* The pragma was not recognised.  */\n+\t  break;\n+\t  \n+#ifdef HANDLE_PRAGMA_PACK\t  \n+\tcase ps_pack:\n \t  if (state == ps_right)\n-\t    maximum_field_alignment = align * 8;\n-\t  else\n \t    {\n-\t      warning (\"malformed `#pragma pack'\");\n-\t      ret_val = 0;\n+\t      maximum_field_alignment = align * 8;\n+\t      ret_val = 1;\n \t    }\n-\t}\n-      else if (type == ps_bad)\n-\tret_val = 0;\n-      else if (type == ps_weak)\n-\t{\n+\t  else\n+\t    warning (\"malformed `#pragma pack'\");\n+\t  break;\n+#endif /* HANDLE_PRAGMA_PACK */\n+\t  \n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+\tcase ps_push:\n+\t  if (state == ps_right)\n+\t    ret_val = push_alignment (align);\n+\t  else\n+\t    warning (\"incomplete '#pragma pack(push,<n>)'\");\n+\t  break;\n+\t  \n+\tcase ps_pop:\n+\t  if (state == ps_right)\n+\t    ret_val = pop_alignment ();\n+\t  else\n+\t    warning (\"missing closing parenthesis in '#pragma pack(pop)'\");\n+\t  break;\n+#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n+\t  \n #ifdef HANDLE_PRAGMA_WEAK\n+\tcase ps_weak:\n \t  if (HANDLE_PRAGMA_WEAK)\n-\t    handle_pragma_weak (state, name, value);\n+\t    {\n+\t      if (state == ps_name)\n+\t\tret_val = add_weak (name, NULL);\n+\t      else if (state == ps_value)\n+\t\tret_val = add_weak (name, value);\n+\t      else\n+\t\twarning (\"malformed `#pragma weak'\");\n+\t    }\n+\t  else\n+\t    ret_val = 1; /* Ignore the pragma.  */\n+\t  break;\n #endif /* HANDLE_PRAGMA_WEAK */\n \t}\n \n@@ -81,96 +306,134 @@ handle_pragma_token (string, token)\n       return ret_val;\n     }\n \n+  /* If we have been given a token, but it is not an identifier,\n+     or a small constant, then something has gone wrong.  */\n+  if (token)\n+    {\n+      switch (TREE_CODE (token))\n+\t{\n+\tcase IDENTIFIER_NODE:\n+\t  break;\n+\t  \n+\tcase INTEGER_CST:\n+\t  if (TREE_INT_CST_HIGH (token) != 0)\n+\t    return 0;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+      \n   switch (state)\n     {\n     case ps_start:\n-      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n-\t{\n-\t  if (strcmp (IDENTIFIER_POINTER (token), \"pack\") == 0)\n-\t    type = state = ps_pack;\n+      type = state = ps_done;\n+#ifdef HANDLE_PRAGMA_PACK\n+      if (strcmp (string, \"pack\") == 0)\n+\ttype = state = ps_pack;\n+#endif\n #ifdef HANDLE_PRAGMA_WEAK\n-\t  else if (strcmp (IDENTIFIER_POINTER (token), \"weak\") == 0)\n-\t    type = state = ps_weak;\n+      if (strcmp (string, \"weak\") == 0)\n+\ttype = state = ps_weak;\n #endif\t  \n-\t  else\n-\t    type = state = ps_done;\n-\t}\n-      else\n-\ttype = state = ps_done;\n       break;\n       \n #ifdef HANDLE_PRAGMA_WEAK\n     case ps_weak:\n-      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+      name = permalloc (strlen (string) + 1);\n+      if (name == NULL)\n \t{\n-\t  name = IDENTIFIER_POINTER (token);\n-\t  state = ps_name;\n+\t  warning (\"Out of memory parsing #pragma weak\");\n+\t  state = ps_bad;\n \t}\n       else\n-\tstate = ps_bad;\n+\t{\n+\t  strcpy (name, string);\n+\t  state = ps_name;\n+\t}\n       break;\n-#endif\n       \n     case ps_name:\n       state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n       break;\n \n     case ps_equals:\n-      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+      value = permalloc (strlen (string) + 1);\n+      if (value == NULL)\n \t{\n-\t  value = IDENTIFIER_POINTER (token);\n-\t  state = ps_value;\n+\t  warning (\"Out of memory parsing #pragma weak\");\n+\t  state = ps_bad;\n \t}\n       else\n-\tstate = ps_bad;\n+\t{\n+\t  strcpy (value, string);\n+\t  state = ps_value;\n+\t}\n       break;\n \n     case ps_value:\n       state = ps_bad;\n       break;\n-\n+#endif /* HANDLE_PRAGMA_WEAK */\n+      \n+#ifdef HANDLE_PRAGMA_PACK\n     case ps_pack:\n-      if (strcmp (string, \"(\") == 0)\n-\tstate = ps_left;\n-      else\n-\tstate = ps_bad;\n+      state = (strcmp (string, \"(\") ? ps_bad : ps_left);\n       break;\n \n     case ps_left:\n-      if (token && TREE_CODE (token) == INTEGER_CST\n-\t  && TREE_INT_CST_HIGH (token) == 0)\n-\tswitch (TREE_INT_CST_LOW (token))\n-\t  {\n-\t  case 1:\n-\t  case 2:\n-\t  case 4:\n-\t    align = TREE_INT_CST_LOW (token);\n-\t    state = ps_align;\n-\t    break;\n-\n-\t  default:\n-\t    state = ps_bad;\n-\t  }\n-      else if (! token && strcmp (string, \")\") == 0)\n+      align = atoi (string);\n+      switch (align)\n \t{\n-\t  align = 0;\n-\t  state = ps_right;\n+\tcase 1:\n+\tcase 2:\n+\tcase 4:\n+\t  state = ps_align;\n+\t  break;\n+\n+\tcase 0:\n+\t  state = (strcmp (string, \")\") ? ps_bad : ps_right);\n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+\t  if (state == ps_bad)\n+\t    {\n+\t      if (strcmp (string, \"push\") == 0)\n+\t\ttype = state = ps_push;\n+\t      else if (strcmp (string, \"pop\") == 0)\n+\t\ttype = state = ps_pop;\n+\t    }\n+#endif\n+\t  break;\n+\n+\tdefault:\n+\t  state = ps_bad;\n+\t  break;\n \t}\n-      else\n-\tstate = ps_bad;\n       break;\n \n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+    case ps_pop:\n+#endif\n     case ps_align:\n-      if (strcmp (string, \")\") == 0)\n-\tstate = ps_right;\n-      else\n-\tstate = ps_bad;\n+      state = (strcmp (string, \")\") ? ps_bad : ps_right);\n       break;\n \n     case ps_right:\n       state = ps_bad;\n       break;\n+#endif /* HANDLE_PRAGMA_PACK */\n \n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+    case ps_push:\n+      state = (strcmp (string, \",\") ? ps_bad : ps_comma);\n+      break;\n+\n+    case ps_comma:\n+      align = atoi (string);\n+      state = ps_align;\n+      break;\n+#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n+      \n     case ps_bad:\n     case ps_done:\n       break;\n@@ -181,4 +444,4 @@ handle_pragma_token (string, token)\n \n   return 1;\n }\n-#endif /* HANDLE_SYSV_PRAGMA */\n+#endif /* HANDLE_GENERIC_PRAGMAS */"}, {"sha": "d7a383df4a49cd703d1d8582fb1695f7f03a8dff", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -18,33 +18,83 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#ifdef HANDLE_SYSV_PRAGMA\n+#ifndef _C_PRAGMA_H\n+#define _C_PRAGMA_H\n \n+#ifdef HANDLE_SYSV_PRAGMA\n /* Support #pragma weak iff ASM_WEAKEN_LABEL and ASM_OUTPUT_DEF are\n    defined.  */\n #if defined (ASM_WEAKEN_LABEL) && defined (ASM_OUTPUT_DEF)\n #define HANDLE_PRAGMA_WEAK SUPPORTS_WEAK\n #endif\n \n+/* We always support #pragma pack for SYSV pragmas.  */\n+#ifndef HANDLE_PRAGMA_PACK\n+#define HANDLE_PRAGMA_PACK 1\n+#endif\n+#endif /* HANDLE_SYSV_PRAGMA */\n+\n+\n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+/* If we are supporting #pragma pack(push... then we automatically\n+   support #pragma pack(<n>)  */\n+#define HANDLE_PRAGMA_PACK 1\n+#define PRAGMA_INSERT_ATTRIBUTES(node, pattr, prefix_attr) \\\n+  insert_pack_attributes (node, pattr, prefix_attr)\n+extern void insert_pack_attributes PROTO((tree, tree *, tree *));\n+#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n+\n+\n+#ifdef HANDLE_PRAGMA_WEAK\n+/* This structure contains any weak symbol declarations waiting to be emitted.  */\n+struct weak_syms\n+{\n+  struct weak_syms * next;\n+  char * name;\n+  char * value;\n+};\n+\n+/* Declared in varasm.c */\n+extern struct weak_syms * weak_decls;\n+#endif /* HANDLE_PRAGMA_WEAK */\n+\n+\n+#if defined HANDLE_PRAGMA_PACK || defined HANDLE_PRAGMA_WEAK\n+/* Define HANDLE_GENERIC_PRAGMAS if any kind of front-end pragma\n+   parsing is to be done.  The code in GCC's generic C source files\n+   will only look for the definition of this constant.  They will\n+   ignore definitions of HANDLE_PRAGMA_PACk and so on.  */\n+#define HANDLE_GENERIC_PRAGMAS 1\n+#endif\n+\n+\n+#ifdef HANDLE_GENERIC_PRAGMAS\n enum pragma_state\n {\n   ps_start,\n   ps_done,\n-  ps_bad,\n+#ifdef HANDLE_PRAGMA_WEAK\n   ps_weak,\n   ps_name,\n   ps_equals,\n   ps_value,\n+#endif\n+#ifdef HANDLE_PRAGMA_PACK\n   ps_pack,\n   ps_left,\n   ps_align,\n-  ps_right\n+  ps_right,\n+#endif\n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+  ps_push,\n+  ps_pop,\n+  ps_comma,\n+#endif\n+  ps_bad\n };\n \n-/* Output asm to handle ``#pragma weak'' */\n-extern void handle_pragma_weak PROTO((enum pragma_state, char *, char *));\n-\n /* Handle a C style pragma */\n extern int handle_pragma_token PROTO((char *, tree));\n \n-#endif /* HANDLE_SYSV_PRAGMA */\n+#endif /* HANDLE_GENERIC_PRAGMAS */\n+#endif /* _C_PRAGMA_H */"}, {"sha": "12f5503322f74c67a7c1d4938900a38a3e487b82", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -2662,6 +2662,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n     FAIL;\t\t\t\t\t\t\t\t\\\n } while (0)\n \n+/* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */\n+#define HANDLE_PRAGMA_PACK_PUSH_POP 1\n+\n \f\n /* Functions in i386.c */\n extern void override_options ();"}, {"sha": "f123b0497fc9d19ab218442b3550073323f90cf4", "filename": "gcc/config/winnt/win-nt.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fconfig%2Fwinnt%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fconfig%2Fwinnt%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fwin-nt.h?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -1,6 +1,6 @@\n /* Operating system specific defines to be used when targeting GCC for\n    Windows NT 3.x.\n-   Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.\n    Contributed by Douglas B. Rupp (drupp@cs.washington.edu).\n \n This file is part of GNU CC.\n@@ -29,7 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #define LINK_SPEC \"-stack 5000000,5000000 -noinhibit-exec %{g}\"\n \n #undef CPP_SPEC\n-#define CPP_SPEC \"-lang-c-c++-comments\"\n+#define CPP_SPEC \"\"\n \n #undef STANDARD_EXEC_PREFIX\n #define STANDARD_EXEC_PREFIX \"\"\n@@ -51,8 +51,11 @@ Boston, MA 02111-1307, USA.  */\n #undef INCLUDE_DEFAULTS\n #define INCLUDE_DEFAULTS\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n-    { 0, 0, 0 }\t\t\t\t\t\t\\\n+    { 0, 0, 0, 0 }\t\t\t\t\t\t\\\n   }\n \n #undef STDC_VALUE\n #define STDC_VALUE 0\n+\n+/* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */\n+#define HANDLE_PRAGMA_PACK_PUSH_POP 1"}, {"sha": "d0dee150668b8b0f781ba4b1c639e168a157e3e7", "filename": "gcc/tm.texi", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -7345,19 +7345,19 @@ C++, which is to pretend that the file's contents are enclosed in\n @findex HANDLE_PRAGMA\n @findex #pragma\n @findex pragma\n-@item HANDLE_PRAGMA (@var{getc}, @var{ungetc}, @var{node})\n+@item HANDLE_PRAGMA (@var{getc}, @var{ungetc}, @var{name})\n Define this macro if you want to implement any pragmas.  If defined, it\n is a C expression whose value is 1 if the pragma was handled by the\n-function, zero otherwise.  The argument @var{getc} is a function of type\n+macro, zero otherwise.  The argument @var{getc} is a function of type\n @samp{int (*)(void)} which will return the next character in the input\n stream, or EOF if no characters are left.  The argument @var{ungetc} is\n a function of type @samp{void (*)(int)} which will push a character back\n into the input stream.  The argument @var{name} is the word following\n #pragma in the input stream.  The input stream pointer will be pointing\n just beyond the end of this word.  The input stream should be left\n undistrubed if the expression returns zero, otherwise it should be\n-pointing at the last character after the end of the pragma (newline or\n-end-of-file). \n+pointing at the next character after the end of the pragma.  Any\n+characters remaining on the line will be ignored.\n \n It is generally a bad idea to implement new uses of @code{#pragma}.  The\n only reason to define this macro is for compatibility with other\n@@ -7371,6 +7371,37 @@ Note: older versions of this macro only had two arguments: @var{stream}\n and @var{token}.  The macro was changed in order to allow it to work\n when gcc is built both with and without a cpp library.\n \n+@findex HANDLE_SYSV_PRAGMA\n+@findex #pragma\n+@findex pragma\n+@item HANDLE_SYSV_PRAGMA\n+Define this macro (to a value of 1) if you want the System V style\n+pragmas @samp{#pragma pack(<n>)} and @samp{#pragma weak <name>\n+[=<value>]} to be supported by gcc.\n+\n+The pack pragma specifies the maximum alignment (in bytes) of fields\n+within a structure, in much the same way as the @samp{__aligned__} and\n+@samp{__packed__} @code{__attribute__}s do.  A pack value of zero resets\n+the behaviour to the default.\n+\n+The weak pragma only works if @code{SUPPORTS_WEAK} and\n+@code{ASM_WEAKEN_LABEL} are defined.  If enabled it allows the creation\n+of specifically named weak labels, optionally with a value.\n+\n+@findex HANDLE_PRAGMA_PACK_PUSH_POP\n+@findex #pragma\n+@findex pragma\n+@item HANDLE_PRAGMA_PACK_PUSH_POP\n+Define this macro (to a value of 1) if you want to support the Win32\n+style pragmas @samp{#pragma pack(push,<n>)} and @samp{#pragma\n+pack(pop)}.  The pack(push,<n>) pragma specifies the maximum alignment\n+(in bytes) of fields within a structure, in much the same way as the\n+@samp{__aligned__} and @samp{__packed__} @code{__attribute__}s do.  A\n+pack value of zero resets the behaviour to the default.  Successive\n+invocations of this pragma cause the previous values to be stacked, so\n+that invocations of @samp{#pragma pack(pop)} will return to the previous\n+value.\n+\n @findex VALID_MACHINE_DECL_ATTRIBUTE\n @item VALID_MACHINE_DECL_ATTRIBUTE (@var{decl}, @var{attributes}, @var{identifier}, @var{args})\n If defined, a C expression whose value is nonzero if @var{identifier} with"}, {"sha": "d9e526132815e8b844609c7bb32b11678beb4ece", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 46, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2af664c2d6add614f1ef044f78b0c6ef89cf0d7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e2af664c2d6add614f1ef044f78b0c6ef89cf0d7", "patch": "@@ -116,20 +116,6 @@ int size_directive_output;\n \n tree last_assemble_variable_decl;\n \n-\n-#ifdef HANDLE_PRAGMA_WEAK\n-/* Any weak symbol declarations waiting to be emitted.  */\n-\n-struct weak_syms\n-{\n-  struct weak_syms *next;\n-  char *name;\n-  char *value;\n-};\n-\n-static struct weak_syms *weak_decls;\n-#endif\n-\n /* Nonzero if at least one function definition has been seen.  */\n \n static int function_defined;\n@@ -4246,38 +4232,6 @@ output_constructor (exp, size)\n     assemble_zeros (size - total_bytes);\n }\n \n-#ifdef HANDLE_PRAGMA_WEAK\n-/* Output asm to handle ``#pragma weak'' */\n-\n-void\n-handle_pragma_weak (what, name, value)\n-     enum pragma_state what;\n-     char *name, *value;\n-{\n-  if (what == ps_name || what == ps_value)\n-    {\n-      struct weak_syms *weak =\n-\t(struct weak_syms *)permalloc (sizeof (struct weak_syms));\n-      weak->next = weak_decls;\n-      weak->name = permalloc (strlen (name) + 1);\n-      strcpy (weak->name, name);\n-\n-      if (what != ps_value)\n-\tweak->value = NULL_PTR;\n-\n-      else\n-\t{\n-\t  weak->value = permalloc (strlen (value) + 1);\n-\t  strcpy (weak->value, value);\n-\t}\n-\n-      weak_decls = weak;\n-    }\n-  else if (! (what == ps_done || what == ps_start))\n-    warning (\"malformed `#pragma weak'\");\n-}\n-#endif /* HANDLE_PRAGMA_WEAK */\n-\n /* Declare DECL to be a weak symbol.  */\n \n void\n@@ -4294,6 +4248,10 @@ declare_weak (decl)\n \n /* Emit any pending weak declarations.  */\n \n+#ifdef HANDLE_PRAGMA_WEAK\n+struct weak_syms * weak_decls;\n+#endif\n+\n void\n weak_finish ()\n {"}]}