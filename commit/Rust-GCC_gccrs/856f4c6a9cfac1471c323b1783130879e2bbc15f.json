{"sha": "856f4c6a9cfac1471c323b1783130879e2bbc15f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU2ZjRjNmE5Y2ZhYzE0NzFjMzIzYjE3ODMxMzA4NzllMmJiYzE1Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-11-29T23:08:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-11-29T23:08:09Z"}, "message": "re PR target/87807 (passing float/double vectors as variadic args fails on-64bit SPARC)\n\n\tPR target/87807\n\t* config/sparc/sparc-modes.def: Minor tweak.\n\t* config/sparc/sparc.c: Minor reordering.\n\t(sparc_pass_by_reference): Move around.\n\t(traverse_record_type): Change offset from HOST_WIDE_INT to int.\n\t(classify_registers): Likewise for bitpos.\n\t(function_arg_slotno): Remove dead test and tweak comments.\n\t<MODE_RANDOM>: Remove useless assertion and test whether the\n\tparameter is named in order to pass it in FP registers.  Return\n\tthe regno for floating-point vector types.\n\t(compute_int_layout): Change bitpos from HOST_WIDE_INT to int.\n\t(compute_fp_layout): Likewise.\n\t(count_registers): Likewise.\n\t(assign_int_registers): Likewise.\n\t(assign_fp_registers): Likewise.\n\t(assign_registers): Likewise.\n\t(function_arg_record_value): Change size from HOST_WIDE_INT to int\n\tand use CEIL_NWORDS to compute the number of registers.\n\t(function_arg_union_value): Minor tweaks.\n\t(function_arg_vector_value): Add slotno and named parameters, use\n\tCEIL_NWORDS to compute the number of registers.\n\t(sparc_function_arg_1): Rework handling of vector types.  Change\n\tsize from HOST_WIDE_INT to int.\n\t(sparc_arg_partial_bytes): Rework handling of 32-bit ABI and deal\n\twith vector types for the 64-bt ABI.\n\t(sparc_function_arg_advance): Likewise.\n\t(sparc_return_in_memory): Add reference to -fpcc-struct-return.\n\t(sparc_struct_value_rtx): Return NULL_RTX instead of 0.\n\t(sparc_function_value_1): Rework handling of vector types.  Change\n\tsize from HOST_WIDE_INT to int.\n\nFrom-SVN: r266651", "tree": {"sha": "83a9b48c9e7e0043713d59e13544d39397a82a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83a9b48c9e7e0043713d59e13544d39397a82a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/856f4c6a9cfac1471c323b1783130879e2bbc15f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/856f4c6a9cfac1471c323b1783130879e2bbc15f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/856f4c6a9cfac1471c323b1783130879e2bbc15f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/856f4c6a9cfac1471c323b1783130879e2bbc15f/comments", "author": null, "committer": null, "parents": [{"sha": "0b1c4b83e44a89b2736671f968c07ca1aab634ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b1c4b83e44a89b2736671f968c07ca1aab634ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b1c4b83e44a89b2736671f968c07ca1aab634ae"}], "stats": {"total": 571, "additions": 331, "deletions": 240}, "files": [{"sha": "d2e8b1f2d3e52c4b7d193825d08fc43378270373", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=856f4c6a9cfac1471c323b1783130879e2bbc15f", "patch": "@@ -1,3 +1,36 @@\n+2018-11-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR target/87807\n+\t* config/sparc/sparc-modes.def: Minor tweak.\n+\t* config/sparc/sparc.c: Minor reordering.\n+\t(sparc_pass_by_reference): Move around.\n+\t(traverse_record_type): Change offset from HOST_WIDE_INT to int.\n+\t(classify_registers): Likewise for bitpos.\n+\t(function_arg_slotno): Remove dead test and tweak comments.\n+\t<MODE_RANDOM>: Remove useless assertion and test whether the\n+\tparameter is named in order to pass it in FP registers.  Return\n+\tthe regno for floating-point vector types.\n+\t(compute_int_layout): Change bitpos from HOST_WIDE_INT to int.\n+\t(compute_fp_layout): Likewise.\n+\t(count_registers): Likewise.\n+\t(assign_int_registers): Likewise.\n+\t(assign_fp_registers): Likewise.\n+\t(assign_registers): Likewise.\n+\t(function_arg_record_value): Change size from HOST_WIDE_INT to int\n+\tand use CEIL_NWORDS to compute the number of registers.\n+\t(function_arg_union_value): Minor tweaks.\n+\t(function_arg_vector_value): Add slotno and named parameters, use\n+\tCEIL_NWORDS to compute the number of registers.\n+\t(sparc_function_arg_1): Rework handling of vector types.  Change\n+\tsize from HOST_WIDE_INT to int.\n+\t(sparc_arg_partial_bytes): Rework handling of 32-bit ABI and deal\n+\twith vector types for the 64-bt ABI.\n+\t(sparc_function_arg_advance): Likewise.\n+\t(sparc_return_in_memory): Add reference to -fpcc-struct-return.\n+\t(sparc_struct_value_rtx): Return NULL_RTX instead of 0.\n+\t(sparc_function_value_1): Rework handling of vector types.  Change\n+\tsize from HOST_WIDE_INT to int.\n+\n 2018-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/88152"}, {"sha": "efc5c6c324c01eeb25a92a84b96de7804a9b0865", "filename": "gcc/config/sparc/sparc-modes.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def?ref=856f4c6a9cfac1471c323b1783130879e2bbc15f", "patch": "@@ -56,8 +56,8 @@ CC_MODE (CCFP);\n CC_MODE (CCFPE);\n \n /* Vector modes.  */\n-VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n-VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n-VECTOR_MODES (INT, 4);        /*       V4QI V2HI      */\n-VECTOR_MODE (INT, DI, 1);     /*                 V1DI */\n-VECTOR_MODE (INT, SI, 1);     /*                 V1SI */\n+VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI      */\n+VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI      */\n+VECTOR_MODES (INT, 4);        /*            V4QI V2HI      */\n+VECTOR_MODE (INT, DI, 1);     /*                      V1DI */\n+VECTOR_MODE (INT, SI, 1);     /*                      V1SI */"}, {"sha": "adbef1ab18f532739cf3c0ba1ac80ae5ee288076", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 232, "deletions": 235, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=856f4c6a9cfac1471c323b1783130879e2bbc15f", "patch": "@@ -642,13 +642,8 @@ static rtx sparc_tls_got (void);\n static int sparc_register_move_cost (machine_mode,\n \t\t\t\t     reg_class_t, reg_class_t);\n static bool sparc_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n-static rtx sparc_function_value (const_tree, const_tree, bool);\n-static rtx sparc_libcall_value (machine_mode, const_rtx);\n-static bool sparc_function_value_regno_p (const unsigned int);\n-static rtx sparc_struct_value_rtx (tree, int);\n static machine_mode sparc_promote_function_mode (const_tree, machine_mode,\n \t\t\t\t\t\t      int *, const_tree, int);\n-static bool sparc_return_in_memory (const_tree, const_tree);\n static bool sparc_strict_argument_naming (cumulative_args_t);\n static void sparc_va_start (tree, rtx);\n static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n@@ -674,6 +669,11 @@ static unsigned int sparc_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t const_tree);\n static int sparc_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t    machine_mode, tree, bool);\n+static bool sparc_return_in_memory (const_tree, const_tree);\n+static rtx sparc_struct_value_rtx (tree, int);\n+static rtx sparc_function_value (const_tree, const_tree, bool);\n+static rtx sparc_libcall_value (machine_mode, const_rtx);\n+static bool sparc_function_value_regno_p (const unsigned int);\n static unsigned HOST_WIDE_INT sparc_asan_shadow_offset (void);\n static void sparc_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void sparc_file_end (void);\n@@ -806,18 +806,9 @@ char sparc_hard_reg_printed[8];\n \n #undef TARGET_PROMOTE_FUNCTION_MODE\n #define TARGET_PROMOTE_FUNCTION_MODE sparc_promote_function_mode\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING sparc_strict_argument_naming\n \n-#undef TARGET_FUNCTION_VALUE\n-#define TARGET_FUNCTION_VALUE sparc_function_value\n-#undef TARGET_LIBCALL_VALUE\n-#define TARGET_LIBCALL_VALUE sparc_libcall_value\n-#undef TARGET_FUNCTION_VALUE_REGNO_P\n-#define TARGET_FUNCTION_VALUE_REGNO_P sparc_function_value_regno_p\n-\n-#undef TARGET_STRUCT_VALUE_RTX\n-#define TARGET_STRUCT_VALUE_RTX sparc_struct_value_rtx\n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY sparc_return_in_memory\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size\n #undef TARGET_PASS_BY_REFERENCE\n@@ -835,10 +826,19 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY sparc_function_arg_boundary\n \n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY sparc_return_in_memory\n+#undef TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX sparc_struct_value_rtx\n+#undef TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE sparc_function_value\n+#undef TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE sparc_libcall_value\n+#undef TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P sparc_function_value_regno_p\n+\n #undef TARGET_EXPAND_BUILTIN_SAVEREGS\n #define TARGET_EXPAND_BUILTIN_SAVEREGS sparc_builtin_saveregs\n-#undef TARGET_STRICT_ARGUMENT_NAMING\n-#define TARGET_STRICT_ARGUMENT_NAMING sparc_strict_argument_naming\n \n #undef TARGET_ASAN_SHADOW_OFFSET\n #define TARGET_ASAN_SHADOW_OFFSET sparc_asan_shadow_offset\n@@ -6676,7 +6676,7 @@ output_sibcall (rtx_insn *insn, rtx call_operand)\n Note #1: complex floating-point types follow the extended SPARC ABIs as\n implemented by the Sun compiler.\n \n-Note #2: integral vector types follow the scalar floating-point types\n+Note #2: integer vector types follow the scalar floating-point types\n conventions to match what is implemented by the Sun VIS SDK.\n \n Note #3: floating-point vector types follow the aggregate types\n@@ -6731,15 +6731,65 @@ sparc_strict_argument_naming (cumulative_args_t ca ATTRIBUTE_UNUSED)\n   return TARGET_ARCH64 ? true : false;\n }\n \n+/* Handle the TARGET_PASS_BY_REFERENCE target hook.\n+   Specify whether to pass the argument by reference.  */\n+\n+static bool\n+sparc_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n+\t\t\t machine_mode mode, const_tree type,\n+\t\t\t bool named ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_ARCH32)\n+    /* Original SPARC 32-bit ABI says that structures and unions,\n+       and quad-precision floats are passed by reference.\n+       All other base types are passed in registers.\n+\n+       Extended ABI (as implemented by the Sun compiler) says that all\n+       complex floats are passed by reference.  Pass complex integers\n+       in registers up to 8 bytes.  More generally, enforce the 2-word\n+       cap for passing arguments in registers.\n+\n+       Vector ABI (as implemented by the Sun VIS SDK) says that integer\n+       vectors are passed like floats of the same size, that is in\n+       registers up to 8 bytes.  Pass all vector floats by reference\n+       like structure and unions.  */\n+    return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))\n+\t    || mode == SCmode\n+\t    /* Catch CDImode, TFmode, DCmode and TCmode.  */\n+\t    || GET_MODE_SIZE (mode) > 8\n+\t    || (type\n+\t\t&& VECTOR_TYPE_P (type)\n+\t\t&& (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));\n+  else\n+    /* Original SPARC 64-bit ABI says that structures and unions\n+       smaller than 16 bytes are passed in registers, as well as\n+       all other base types.\n+\n+       Extended ABI (as implemented by the Sun compiler) says that\n+       complex floats are passed in registers up to 16 bytes.  Pass\n+       all complex integers in registers up to 16 bytes.  More generally,\n+       enforce the 2-word cap for passing arguments in registers.\n+\n+       Vector ABI (as implemented by the Sun VIS SDK) says that integer\n+       vectors are passed like floats of the same size, that is in\n+       registers (up to 16 bytes).  Pass all vector floats like structure\n+       and unions.  */\n+    return ((type\n+\t     && (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n+\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)\n+\t    /* Catch CTImode and TCmode.  */\n+\t    || GET_MODE_SIZE (mode) > 16);\n+}\n+\n /* Traverse the record TYPE recursively and call FUNC on its fields.\n    NAMED is true if this is for a named parameter.  DATA is passed\n    to FUNC for each field.  OFFSET is the starting position and\n    PACKED is true if we are inside a packed record.  */\n \n-template <typename T, void Func (const_tree, HOST_WIDE_INT, bool, T*)>\n+template <typename T, void Func (const_tree, int, bool, T*)>\n static void\n traverse_record_type (const_tree type, bool named, T *data,\n-\t\t      HOST_WIDE_INT offset = 0, bool packed = false)\n+\t\t      int offset = 0, bool packed = false)\n {\n   /* The ABI obviously doesn't specify how packed structures are passed.\n      These are passed in integer regs if possible, otherwise memory.  */\n@@ -6759,7 +6809,7 @@ traverse_record_type (const_tree type, bool named, T *data,\n \tif (!DECL_SIZE (field) || integer_zerop (DECL_SIZE (field)))\n \t  continue;\n \n-\tHOST_WIDE_INT bitpos = offset;\n+\tint bitpos = offset;\n \tif (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST)\n \t  bitpos += int_bit_position (field);\n \n@@ -6788,8 +6838,7 @@ typedef struct\n /* A subroutine of function_arg_slotno.  Classify the field.  */\n \n inline void\n-classify_registers (const_tree, HOST_WIDE_INT bitpos, bool fp,\n-\t\t    classify_data_t *data)\n+classify_registers (const_tree, int bitpos, bool fp, classify_data_t *data)\n {\n   if (fp)\n     {\n@@ -6819,50 +6868,43 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n \t\t     const_tree type, bool named, bool incoming,\n \t\t     int *pregno, int *ppadding)\n {\n-  int regbase = (incoming\n-\t\t ? SPARC_INCOMING_INT_ARG_FIRST\n-\t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n-  int slotno = cum->words;\n-  enum mode_class mclass;\n-  int regno;\n-\n-  *ppadding = 0;\n+  const int regbase\n+    = incoming ? SPARC_INCOMING_INT_ARG_FIRST : SPARC_OUTGOING_INT_ARG_FIRST;\n+  int slotno = cum->words, regno;\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n \n   if (type && TREE_ADDRESSABLE (type))\n     return -1;\n \n-  if (TARGET_ARCH32\n-      && mode == BLKmode\n-      && type\n-      && TYPE_ALIGN (type) % PARM_BOUNDARY != 0)\n-    return -1;\n-\n-  /* For SPARC64, objects requiring 16-byte alignment get it.  */\n+  /* In 64-bit mode, objects requiring 16-byte alignment get it.  */\n   if (TARGET_ARCH64\n       && (type ? TYPE_ALIGN (type) : GET_MODE_ALIGNMENT (mode)) >= 128\n       && (slotno & 1) != 0)\n-    slotno++, *ppadding = 1;\n+    {\n+      slotno++;\n+      *ppadding = 1;\n+    }\n+  else\n+    *ppadding = 0;\n \n-  mclass = GET_MODE_CLASS (mode);\n-  if (type && TREE_CODE (type) == VECTOR_TYPE)\n+  /* Vector types deserve special treatment because they are polymorphic wrt\n+     their mode, depending upon whether VIS instructions are enabled.  */\n+  if (type && VECTOR_TYPE_P (type))\n     {\n-      /* Vector types deserve special treatment because they are\n-\t polymorphic wrt their mode, depending upon whether VIS\n-\t instructions are enabled.  */\n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n \t  /* The SPARC port defines no floating-point vector modes.  */\n \t  gcc_assert (mode == BLKmode);\n \t}\n       else\n \t{\n-\t  /* Integral vector types should either have a vector\n+\t  /* Integer vector types should either have a vector\n \t     mode or an integral mode, because we are guaranteed\n \t     by pass_by_reference that their size is not greater\n \t     than 16 bytes and TImode is 16-byte wide.  */\n \t  gcc_assert (mode != BLKmode);\n \n-\t  /* Vector integers are handled like floats according to\n+\t  /* Integer vectors are handled like floats as per\n \t     the Sun VIS SDK.  */\n \t  mclass = MODE_FLOAT;\n \t}\n@@ -6898,24 +6940,13 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n       break;\n \n     case MODE_RANDOM:\n+      /* MODE is VOIDmode when generating the actual call.  */\n       if (mode == VOIDmode)\n-\t/* MODE is VOIDmode when generating the actual call.  */\n \treturn -1;\n \n-      gcc_assert (mode == BLKmode);\n-\n-      if (TARGET_ARCH32\n-\t  || !type\n-\t  || (TREE_CODE (type) != RECORD_TYPE\n-\t      && TREE_CODE (type) != VECTOR_TYPE))\n-\t{\n-\t  /* If all arg slots are filled, then must pass on stack.  */\n-\t  if (slotno >= SPARC_INT_ARG_MAX)\n-\t    return -1;\n-\n-\t  regno = regbase + slotno;\n-\t}\n-      else  /* TARGET_ARCH64 && type */\n+      if (TARGET_64BIT && TARGET_FPU && named\n+\t  && type\n+\t  && (TREE_CODE (type) == RECORD_TYPE || VECTOR_TYPE_P (type)))\n \t{\n \t  /* If all arg slots are filled, then must pass on stack.  */\n \t  if (slotno >= SPARC_FP_ARG_MAX)\n@@ -6942,10 +6973,20 @@ function_arg_slotno (const struct sparc_args *cum, machine_mode mode,\n \t\t  if (slotno >= SPARC_INT_ARG_MAX)\n \t\t    return -1;\n \t\t}\n+\n+\t      /* PREGNO isn't set since both int and FP regs can be used.  */\n+\t      return slotno;\n \t    }\n \n-\t  /* PREGNO isn't set since both int and FP regs can be used.  */\n-\t  return slotno;\n+\t  regno = SPARC_FP_ARG_FIRST + slotno * 2;\n+\t}\n+      else\n+\t{\n+\t  /* If all arg slots are filled, then must pass on stack.  */\n+\t  if (slotno >= SPARC_INT_ARG_MAX)\n+\t    return -1;\n+\n+\t  regno = regbase + slotno;\n \t}\n       break;\n \n@@ -6974,7 +7015,7 @@ typedef struct\n    true if at least one integer register is assigned or false otherwise.  */\n \n static bool\n-compute_int_layout (HOST_WIDE_INT bitpos, assign_data_t *data, int *pnregs)\n+compute_int_layout (int bitpos, assign_data_t *data, int *pnregs)\n {\n   if (data->intoffset < 0)\n     return false;\n@@ -7007,8 +7048,7 @@ compute_int_layout (HOST_WIDE_INT bitpos, assign_data_t *data, int *pnregs)\n    FP register is assigned or false otherwise.  */\n \n static bool\n-compute_fp_layout (const_tree field, HOST_WIDE_INT bitpos,\n-\t\t   assign_data_t *data,\n+compute_fp_layout (const_tree field, int bitpos, assign_data_t *data,\n \t\t   int *pnregs, machine_mode *pmode)\n {\n   const int this_slotno = data->slotno + bitpos / BITS_PER_WORD;\n@@ -7017,7 +7057,7 @@ compute_fp_layout (const_tree field, HOST_WIDE_INT bitpos,\n \n   /* Slots are counted as words while regs are counted as having the size of\n      the (inner) mode.  */\n-  if (TREE_CODE (TREE_TYPE (field)) == VECTOR_TYPE && mode == BLKmode)\n+  if (VECTOR_TYPE_P (TREE_TYPE (field)) && mode == BLKmode)\n     {\n       mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (field)));\n       nregs = TYPE_VECTOR_SUBPARTS (TREE_TYPE (field));\n@@ -7053,8 +7093,7 @@ compute_fp_layout (const_tree field, HOST_WIDE_INT bitpos,\n    to be assigned for FIELD and between PARMS->intoffset and BITPOS.  */\n \n inline void\n-count_registers (const_tree field, HOST_WIDE_INT bitpos, bool fp,\n-\t\t assign_data_t *data)\n+count_registers (const_tree field, int bitpos, bool fp, assign_data_t *data)\n {\n   if (fp)\n     {\n@@ -7078,7 +7117,7 @@ count_registers (const_tree field, HOST_WIDE_INT bitpos, bool fp,\n    structure between PARMS->intoffset and BITPOS to integer registers.  */\n \n static void\n-assign_int_registers (HOST_WIDE_INT bitpos, assign_data_t *data)\n+assign_int_registers (int bitpos, assign_data_t *data)\n {\n   int intoffset = data->intoffset;\n   machine_mode mode;\n@@ -7118,8 +7157,7 @@ assign_int_registers (HOST_WIDE_INT bitpos, assign_data_t *data)\n    BITPOS to FP registers.  */\n \n static void\n-assign_fp_registers (const_tree field, HOST_WIDE_INT bitpos,\n-\t\t\t     assign_data_t *data)\n+assign_fp_registers (const_tree field, int bitpos, assign_data_t *data)\n {\n   int nregs;\n   machine_mode mode;\n@@ -7149,8 +7187,7 @@ assign_fp_registers (const_tree field, HOST_WIDE_INT bitpos,\n    the structure between PARMS->intoffset and BITPOS to registers.  */\n \n inline void\n-assign_registers (const_tree field, HOST_WIDE_INT bitpos, bool fp,\n-\t\t  assign_data_t *data)\n+assign_registers (const_tree field, int bitpos, bool fp, assign_data_t *data)\n {\n   if (fp)\n     {\n@@ -7165,7 +7202,7 @@ assign_registers (const_tree field, HOST_WIDE_INT bitpos, bool fp,\n     }\n }\n \n-/* Used by function_arg and sparc_function_value_1 to implement the complex\n+/* Used by function_arg and function_value to implement the complex\n    conventions of the 64-bit ABI for passing and returning structures.\n    Return an expression valid as a return value for the FUNCTION_ARG\n    and TARGET_FUNCTION_VALUE.\n@@ -7183,7 +7220,7 @@ static rtx\n function_arg_record_value (const_tree type, machine_mode mode,\n \t\t\t   int slotno, bool named, int regbase)\n {\n-  HOST_WIDE_INT typesize = int_size_in_bytes (type);\n+  const int size = int_size_in_bytes (type);\n   assign_data_t data;\n   int nregs;\n \n@@ -7197,7 +7234,7 @@ function_arg_record_value (const_tree type, machine_mode mode,\n   traverse_record_type<assign_data_t, count_registers> (type, named, &data);\n \n   /* Take into account pending integer fields.  */\n-  if (compute_int_layout (typesize * BITS_PER_UNIT, &data, &nregs))\n+  if (compute_int_layout (size * BITS_PER_UNIT, &data, &nregs))\n     data.nregs += nregs;\n \n   /* Allocate the vector and handle some annoying special cases.  */\n@@ -7206,7 +7243,7 @@ function_arg_record_value (const_tree type, machine_mode mode,\n   if (nregs == 0)\n     {\n       /* ??? Empty structure has no value?  Duh?  */\n-      if (typesize <= 0)\n+      if (size <= 0)\n \t{\n \t  /* Though there's nothing really to store, return a word register\n \t     anyway so the rest of gcc doesn't go nuts.  Returning a PARALLEL\n@@ -7217,7 +7254,7 @@ function_arg_record_value (const_tree type, machine_mode mode,\n \n       /* ??? C++ has structures with no fields, and yet a size.  Give up\n \t for now and pass everything back in integer registers.  */\n-      nregs = (typesize + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      nregs = CEIL_NWORDS (size);\n       if (nregs + slotno > SPARC_INT_ARG_MAX)\n \tnregs = SPARC_INT_ARG_MAX - slotno;\n     }\n@@ -7242,76 +7279,84 @@ function_arg_record_value (const_tree type, machine_mode mode,\n   traverse_record_type<assign_data_t, assign_registers> (type, named, &data);\n \n   /* Assign pending integer fields.  */\n-  assign_int_registers (typesize * BITS_PER_UNIT, &data);\n+  assign_int_registers (size * BITS_PER_UNIT, &data);\n \n   gcc_assert (data.nregs == nregs);\n \n   return data.ret;\n }\n \n-/* Used by function_arg and sparc_function_value_1 to implement the conventions\n+/* Used by function_arg and function_value to implement the conventions\n    of the 64-bit ABI for passing and returning unions.\n    Return an expression valid as a return value for the FUNCTION_ARG\n    and TARGET_FUNCTION_VALUE.\n \n    SIZE is the size in bytes of the union.\n    MODE is the argument's machine mode.\n+   SLOTNO is the index number of the argument's slot in the parameter array.\n    REGNO is the hard register the union will be passed in.  */\n \n static rtx\n-function_arg_union_value (int size, machine_mode mode, int slotno,\n-\t\t\t  int regno)\n+function_arg_union_value (int size, machine_mode mode, int slotno, int regno)\n {\n-  int nwords = CEIL_NWORDS (size), i;\n-  rtx regs;\n+  unsigned int nwords;\n \n-  /* See comment in previous function for empty structures.  */\n-  if (nwords == 0)\n+  /* See comment in function_arg_record_value for empty structures.  */\n+  if (size <= 0)\n     return gen_rtx_REG (mode, regno);\n \n   if (slotno == SPARC_INT_ARG_MAX - 1)\n     nwords = 1;\n+  else\n+    nwords = CEIL_NWORDS (size);\n \n-  regs = gen_rtx_PARALLEL (mode, rtvec_alloc (nwords));\n+  rtx regs = gen_rtx_PARALLEL (mode, rtvec_alloc (nwords));\n \n-  for (i = 0; i < nwords; i++)\n-    {\n-      /* Unions are passed left-justified.  */\n-      XVECEXP (regs, 0, i)\n-\t= gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t     gen_rtx_REG (word_mode, regno),\n-\t\t\t     GEN_INT (UNITS_PER_WORD * i));\n-      regno++;\n-    }\n+  /* Unions are passed left-justified.  */\n+  for (unsigned int i = 0; i < nwords; i++)\n+    XVECEXP (regs, 0, i)\n+    = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t gen_rtx_REG (word_mode, regno + i),\n+\t\t\t GEN_INT (UNITS_PER_WORD * i));\n \n   return regs;\n }\n \n-/* Used by function_arg and sparc_function_value_1 to implement the conventions\n-   for passing and returning BLKmode vectors.\n+/* Used by function_arg and function_value to implement the conventions\n+   of the 64-bit ABI for passing and returning BLKmode vectors.\n    Return an expression valid as a return value for the FUNCTION_ARG\n    and TARGET_FUNCTION_VALUE.\n \n    SIZE is the size in bytes of the vector.\n-   REGNO is the FP hard register the vector will be passed in.  */\n+   SLOTNO is the index number of the argument's slot in the parameter array.\n+   NAMED is true if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+   REGNO is the hard register the vector will be passed in.  */\n \n static rtx\n-function_arg_vector_value (int size, int regno)\n+function_arg_vector_value (int size, int slotno, bool named, int regno)\n {\n-  const int nregs = MAX (1, size / 8);\n-  rtx regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));\n+  const int mult = (named ? 2 : 1);\n+  unsigned int nwords;\n+\n+  if (slotno == (named ? SPARC_FP_ARG_MAX : SPARC_INT_ARG_MAX) - 1)\n+    nwords = 1;\n+  else\n+    nwords = CEIL_NWORDS (size);\n+\n+  rtx regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nwords));\n \n-  if (size < 8)\n+  if (size < UNITS_PER_WORD)\n     XVECEXP (regs, 0, 0)\n       = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t   gen_rtx_REG (SImode, regno),\n \t\t\t   const0_rtx);\n   else\n-    for (int i = 0; i < nregs; i++)\n+    for (unsigned int i = 0; i < nwords; i++)\n       XVECEXP (regs, 0, i)\n \t= gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t     gen_rtx_REG (DImode, regno + 2*i),\n-\t\t\t     GEN_INT (i*8));\n+\t\t\t     gen_rtx_REG (word_mode, regno + i * mult),\n+\t\t\t     GEN_INT (i * UNITS_PER_WORD));\n \n   return regs;\n }\n@@ -7336,31 +7381,19 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n \t\t      const_tree type, bool named, bool incoming)\n {\n   const CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-\n-  int regbase = (incoming\n-\t\t ? SPARC_INCOMING_INT_ARG_FIRST\n-\t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n+  const int regbase\n+    = incoming ? SPARC_INCOMING_INT_ARG_FIRST : SPARC_OUTGOING_INT_ARG_FIRST;\n   int slotno, regno, padding;\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n \n-  slotno = function_arg_slotno (cum, mode, type, named, incoming,\n-\t\t\t\t&regno, &padding);\n+  slotno\n+    = function_arg_slotno (cum, mode, type, named, incoming, &regno, &padding);\n   if (slotno == -1)\n     return 0;\n \n-  /* Vector types deserve special treatment because they are polymorphic wrt\n-     their mode, depending upon whether VIS instructions are enabled.  */\n-  if (type && TREE_CODE (type) == VECTOR_TYPE)\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n-      gcc_assert ((TARGET_ARCH32 && size <= 8)\n-\t\t  || (TARGET_ARCH64 && size <= 16));\n-\n-      if (mode == BLKmode)\n-\treturn function_arg_vector_value (size, SPARC_FP_ARG_FIRST + 2*slotno);\n-\n-      mclass = MODE_FLOAT;\n-    }\n+  /* Integer vectors are handled like floats as per the Sun VIS SDK.  */\n+  if (type && VECTOR_INTEGER_TYPE_P (type))\n+    mclass = MODE_FLOAT;\n \n   if (TARGET_ARCH32)\n     return gen_rtx_REG (mode, regno);\n@@ -7369,7 +7402,7 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n      and are promoted to registers if possible.  */\n   if (type && TREE_CODE (type) == RECORD_TYPE)\n     {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      const int size = int_size_in_bytes (type);\n       gcc_assert (size <= 16);\n \n       return function_arg_record_value (type, mode, slotno, named, regbase);\n@@ -7378,12 +7411,21 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n   /* Unions up to 16 bytes in size are passed in integer registers.  */\n   else if (type && TREE_CODE (type) == UNION_TYPE)\n     {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      const int size = int_size_in_bytes (type);\n       gcc_assert (size <= 16);\n \n       return function_arg_union_value (size, mode, slotno, regno);\n     }\n \n+   /* Floating-point vectors up to 16 bytes are passed in registers.  */\n+  else if (type && VECTOR_TYPE_P (type) && mode == BLKmode)\n+    {\n+      const int size = int_size_in_bytes (type);\n+      gcc_assert (size <= 16);\n+\n+      return function_arg_vector_value (size, slotno, named, regno);\n+    }\n+\n   /* v9 fp args in reg slots beyond the int reg slots get passed in regs\n      but also have the slot allocated for them.\n      If no prototype is in scope fp values in register slots get passed\n@@ -7429,7 +7471,7 @@ sparc_function_arg_1 (cumulative_args_t cum_v, machine_mode mode,\n      corresponding to the size of the type.  */\n   else if (type && AGGREGATE_TYPE_P (type))\n     {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      const int size = int_size_in_bytes (type);\n       gcc_assert (size <= 16);\n \n       mode = int_mode_for_size (size * BITS_PER_UNIT, 0).else_blk ();\n@@ -7493,97 +7535,55 @@ sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n \n   if (TARGET_ARCH32)\n     {\n-      if ((slotno + (mode == BLKmode\n-\t\t     ? CEIL_NWORDS (int_size_in_bytes (type))\n-\t\t     : CEIL_NWORDS (GET_MODE_SIZE (mode))))\n-\t  > SPARC_INT_ARG_MAX)\n-\treturn (SPARC_INT_ARG_MAX - slotno) * UNITS_PER_WORD;\n+      /* We are guaranteed by pass_by_reference that the size of the\n+\t argument is not greater than 8 bytes, so we only need to return\n+\t one word if the argument is partially passed in registers.  */\n+      const int size = GET_MODE_SIZE (mode);\n+\n+      if (size > UNITS_PER_WORD && slotno == SPARC_INT_ARG_MAX - 1)\n+\treturn UNITS_PER_WORD;\n     }\n   else\n     {\n       /* We are guaranteed by pass_by_reference that the size of the\n \t argument is not greater than 16 bytes, so we only need to return\n \t one word if the argument is partially passed in registers.  */\n-\n       if (type && AGGREGATE_TYPE_P (type))\n \t{\n-\t  int size = int_size_in_bytes (type);\n+\t  const int size = int_size_in_bytes (type);\n \n \t  if (size > UNITS_PER_WORD\n \t      && (slotno == SPARC_INT_ARG_MAX - 1\n \t\t  || slotno == SPARC_FP_ARG_MAX - 1))\n \t    return UNITS_PER_WORD;\n \t}\n       else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n-\t       || (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t\t   && ! (TARGET_FPU && named)))\n+\t       || ((GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t\t    || (type && VECTOR_TYPE_P (type)))\n+\t\t   && !(TARGET_FPU && named)))\n \t{\n-\t  /* The complex types are passed as packed types.  */\n-\t  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-\t      && slotno == SPARC_INT_ARG_MAX - 1)\n+\t  const int size = (type && VECTOR_FLOAT_TYPE_P (type))\n+\t\t\t   ? int_size_in_bytes (type)\n+\t\t\t   : GET_MODE_SIZE (mode);\n+\n+\t  if (size > UNITS_PER_WORD && slotno == SPARC_INT_ARG_MAX - 1)\n \t    return UNITS_PER_WORD;\n \t}\n-      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t       || (type && VECTOR_TYPE_P (type)))\n \t{\n-\t  if ((slotno + GET_MODE_SIZE (mode) / UNITS_PER_WORD)\n-\t      > SPARC_FP_ARG_MAX)\n+\t  const int size = (type && VECTOR_FLOAT_TYPE_P (type))\n+\t\t\t   ? int_size_in_bytes (type)\n+\t\t\t   : GET_MODE_SIZE (mode);\n+\n+\t  if (size > UNITS_PER_WORD && slotno == SPARC_FP_ARG_MAX - 1)\n \t    return UNITS_PER_WORD;\n \t}\n     }\n \n   return 0;\n }\n \n-/* Handle the TARGET_PASS_BY_REFERENCE target hook.\n-   Specify whether to pass the argument by reference.  */\n-\n-static bool\n-sparc_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode, const_tree type,\n-\t\t\t bool named ATTRIBUTE_UNUSED)\n-{\n-  if (TARGET_ARCH32)\n-    /* Original SPARC 32-bit ABI says that structures and unions,\n-       and quad-precision floats are passed by reference.\n-       All base types are passed in registers.\n-\n-       Extended ABI (as implemented by the Sun compiler) says that all\n-       complex floats are passed by reference.  Pass complex integers\n-       in registers up to 8 bytes.  More generally, enforce the 2-word\n-       cap for passing arguments in registers.\n-\n-       Vector ABI (as implemented by the Sun VIS SDK) says that vector\n-       integers are passed like floats of the same size, that is in\n-       registers up to 8 bytes.  Pass all vector floats by reference\n-       like structure and unions.  */\n-    return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))\n-\t    || mode == SCmode\n-\t    /* Catch CDImode, TFmode, DCmode and TCmode.  */\n-\t    || GET_MODE_SIZE (mode) > 8\n-\t    || (type\n-\t\t&& TREE_CODE (type) == VECTOR_TYPE\n-\t\t&& (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));\n-  else\n-    /* Original SPARC 64-bit ABI says that structures and unions\n-       smaller than 16 bytes are passed in registers, as well as\n-       all other base types.\n-\n-       Extended ABI (as implemented by the Sun compiler) says that\n-       complex floats are passed in registers up to 16 bytes.  Pass\n-       all complex integers in registers up to 16 bytes.  More generally,\n-       enforce the 2-word cap for passing arguments in registers.\n-\n-       Vector ABI (as implemented by the Sun VIS SDK) says that vector\n-       integers are passed like floats of the same size, that is in\n-       registers (up to 16 bytes).  Pass all vector floats like structure\n-       and unions.  */\n-    return ((type\n-\t     && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE)\n-\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)\n-\t    /* Catch CTImode and TCmode.  */\n-\t    || GET_MODE_SIZE (mode) > 16);\n-}\n-\n /* Handle the TARGET_FUNCTION_ARG_ADVANCE hook.\n    Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n@@ -7603,26 +7603,22 @@ sparc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   cum->words += padding;\n \n   if (TARGET_ARCH32)\n-    cum->words += (mode == BLKmode\n-\t\t   ? CEIL_NWORDS (int_size_in_bytes (type))\n-\t\t   : CEIL_NWORDS (GET_MODE_SIZE (mode)));\n+    cum->words += CEIL_NWORDS (GET_MODE_SIZE (mode));\n   else\n     {\n-      if (type && AGGREGATE_TYPE_P (type))\n+      /* For types that can have BLKmode, get the size from the type.  */\n+      if (type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))\n \t{\n-\t  int size = int_size_in_bytes (type);\n+\t  const int size = int_size_in_bytes (type);\n \n-\t  if (size <= 8)\n-\t    ++cum->words;\n-\t  else if (size <= 16)\n-\t    cum->words += 2;\n-\t  else /* passed by reference */\n-\t    ++cum->words;\n+\t  /* See comment in function_arg_record_value for empty structures.  */\n+\t  if (size <= 0)\n+\t    cum->words++;\n+\t  else\n+\t    cum->words += CEIL_NWORDS (size);\n \t}\n       else\n-\tcum->words += (mode == BLKmode\n-\t\t       ? CEIL_NWORDS (int_size_in_bytes (type))\n-\t\t       : CEIL_NWORDS (GET_MODE_SIZE (mode)));\n+\tcum->words += CEIL_NWORDS (GET_MODE_SIZE (mode));\n     }\n }\n \n@@ -7646,9 +7642,11 @@ static bool\n sparc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n {\n   if (TARGET_ARCH32)\n-    /* Original SPARC 32-bit ABI says that structures and unions,\n-       and quad-precision floats are returned in memory.  All other\n-       base types are returned in registers.\n+    /* Original SPARC 32-bit ABI says that structures and unions, and\n+       quad-precision floats are returned in memory.  But note that the\n+       first part is implemented through -fpcc-struct-return being the\n+       default, so here we only implement -freg-struct-return instead.\n+       All other base types are returned in registers.\n \n        Extended ABI (as implemented by the Sun compiler) says that\n        all complex floats are returned in registers (8 FP registers\n@@ -7689,7 +7687,7 @@ static rtx\n sparc_struct_value_rtx (tree fndecl, int incoming)\n {\n   if (TARGET_ARCH64)\n-    return 0;\n+    return NULL_RTX;\n   else\n     {\n       rtx mem;\n@@ -7750,50 +7748,49 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n    except that up to 32 bytes may be returned in registers.  */\n \n static rtx\n-sparc_function_value_1 (const_tree type, machine_mode mode,\n-\t\t\tbool outgoing)\n+sparc_function_value_1 (const_tree type, machine_mode mode, bool outgoing)\n {\n   /* Beware that the two values are swapped here wrt function_arg.  */\n-  int regbase = (outgoing\n-\t\t ? SPARC_INCOMING_INT_ARG_FIRST\n-\t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n+  const int regbase\n+    = outgoing ? SPARC_INCOMING_INT_ARG_FIRST : SPARC_OUTGOING_INT_ARG_FIRST;\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n   int regno;\n \n-  /* Vector types deserve special treatment because they are polymorphic wrt\n-     their mode, depending upon whether VIS instructions are enabled.  */\n-  if (type && TREE_CODE (type) == VECTOR_TYPE)\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n-      gcc_assert ((TARGET_ARCH32 && size <= 8)\n-\t\t  || (TARGET_ARCH64 && size <= 32));\n-\n-      if (mode == BLKmode)\n-\treturn function_arg_vector_value (size, SPARC_FP_ARG_FIRST);\n-\n-      mclass = MODE_FLOAT;\n-    }\n+  /* Integer vectors are handled like floats as per the Sun VIS SDK.\n+     Note that integer vectors larger than 16 bytes have BLKmode so\n+     they need to be handled like floating-point vectors below.  */\n+  if (type && VECTOR_INTEGER_TYPE_P (type) && mode != BLKmode)\n+    mclass = MODE_FLOAT;\n \n   if (TARGET_ARCH64 && type)\n     {\n       /* Structures up to 32 bytes in size are returned in registers.  */\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n-\t  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t  const int size = int_size_in_bytes (type);\n \t  gcc_assert (size <= 32);\n \n-\t  return function_arg_record_value (type, mode, 0, 1, regbase);\n+\t  return function_arg_record_value (type, mode, 0, true, regbase);\n \t}\n \n       /* Unions up to 32 bytes in size are returned in integer registers.  */\n       else if (TREE_CODE (type) == UNION_TYPE)\n \t{\n-\t  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t  const int size = int_size_in_bytes (type);\n \t  gcc_assert (size <= 32);\n \n \t  return function_arg_union_value (size, mode, 0, regbase);\n \t}\n \n+      /* Vectors up to 32 bytes are returned in FP registers.  */\n+      else if (VECTOR_TYPE_P (type) && mode == BLKmode)\n+\t{\n+\t  const int size = int_size_in_bytes (type);\n+\t  gcc_assert (size <= 32);\n+\n+\t  return function_arg_vector_value (size, 0, true, SPARC_FP_ARG_FIRST);\n+\t}\n+\n       /* Objects that require it are returned in FP registers.  */\n       else if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n \t;\n@@ -7804,7 +7801,7 @@ sparc_function_value_1 (const_tree type, machine_mode mode,\n \t{\n \t  /* All other aggregate types are passed in an integer register\n \t     in a mode corresponding to the size of the type.  */\n-\t  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t  const int size = int_size_in_bytes (type);\n \t  gcc_assert (size <= 32);\n \n \t  mode = int_mode_for_size (size * BITS_PER_UNIT, 0).else_blk ();"}, {"sha": "d996dce7265aebbdc2c9dc3c3f8f61371c03816c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=856f4c6a9cfac1471c323b1783130879e2bbc15f", "patch": "@@ -1,3 +1,8 @@\n+2018-11-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/20181129-1.c: New test.\n+\t* gcc.target/sparc/20181129-2.c: Likewise.\n+\n 2018-11-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/88152"}, {"sha": "1ee567ac9a9e2893f6034a5e77fb8ccae82748a9", "filename": "gcc/testsuite/gcc.target/sparc/20181129-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20181129-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20181129-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20181129-1.c?ref=856f4c6a9cfac1471c323b1783130879e2bbc15f", "patch": "@@ -0,0 +1,28 @@\n+/* PR target/87807 */\n+/* Reported by Rainer Orth <ro@gcc.gnu.org> */\n+\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+\n+typedef float __attribute__ ((vector_size (8))) vector_float;\n+\n+vector_float v2sf = { 1.0f, 2.0f };\n+\n+void\n+f (vector_float a, ...)\n+{\n+  va_list argp;\n+  va_start (argp, a);\n+  vector_float x = va_arg (argp, vector_float);\n+  if (x[0] != a[0] || x[1] != a[1])\n+    __builtin_abort ();\n+  va_end (argp);\n+}\n+\n+int\n+main (void)\n+{\n+  f (v2sf, v2sf);\n+  return 0;\n+} "}, {"sha": "f293023918b16fc75c8cb1632753b02372e3352d", "filename": "gcc/testsuite/gcc.target/sparc/20181129-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20181129-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/856f4c6a9cfac1471c323b1783130879e2bbc15f/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20181129-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20181129-2.c?ref=856f4c6a9cfac1471c323b1783130879e2bbc15f", "patch": "@@ -0,0 +1,28 @@\n+/* PR target/87807 */\n+/* Reported by Rainer Orth <ro@gcc.gnu.org> */\n+\n+/* { dg-do run } */\n+\n+#include <stdarg.h>\n+\n+typedef double __attribute__ ((vector_size (16))) vector_double;\n+\n+vector_double v2df = { 1.0, 2.0 };\n+\n+void\n+f (vector_double a, ...)\n+{\n+  va_list argp;\n+  va_start (argp, a);\n+  vector_double x = va_arg (argp, vector_double);\n+  if (x[0] != a[0] || x[1] != a[1])\n+    __builtin_abort ();\n+  va_end (argp);\n+}\n+\n+int\n+main (void)\n+{\n+  f (v2df, v2df);\n+  return 0;\n+} "}]}