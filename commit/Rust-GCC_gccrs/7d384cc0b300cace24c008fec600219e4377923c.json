{"sha": "7d384cc0b300cace24c008fec600219e4377923c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzODRjYzBiMzAwY2FjZTI0YzAwOGZlYzYwMDIxOWU0Mzc3OTIzYw==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@cygnus.com", "date": "1998-10-11T02:21:54Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1998-10-11T02:21:54Z"}, "message": "Fine-grained control of -fcheck-memory-usage with new no_check_memory_usage attribute.\n\nFine-grained control of -fcheck-memory-usage with new no_check_memory_usage\nattribute.  Misc minor bugfixes and tests for it too.\n\nFrom-SVN: r22983", "tree": {"sha": "7d04180ff0e97d1e5bb80e16c8389a2a43d9e018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d04180ff0e97d1e5bb80e16c8389a2a43d9e018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d384cc0b300cace24c008fec600219e4377923c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d384cc0b300cace24c008fec600219e4377923c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d384cc0b300cace24c008fec600219e4377923c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d384cc0b300cace24c008fec600219e4377923c/comments", "author": null, "committer": null, "parents": [{"sha": "e41887f1fc521f4dde6c0a56ebe3fa1cc1c108aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41887f1fc521f4dde6c0a56ebe3fa1cc1c108aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e41887f1fc521f4dde6c0a56ebe3fa1cc1c108aa"}], "stats": {"total": 936, "additions": 881, "deletions": 55}, "files": [{"sha": "b1c44a00b861ea9ee1c5d3b8a7d5d5e7359049d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -1,3 +1,32 @@\n+Sun Oct 11 05:03:41 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* tree.h (DECL_NO_CHECK_MEMORY_USAGE): New macros.\n+\t(struct tree_decl): New fields no_check_memory_usage.\n+\t* c-common.c (enum attrs): Add A_NO_CHECK_MEMORY_USAGE.\n+\t(init_attributes): Register it as a new attribute.\n+\t(decl_attributes): Set flags on functions given that attribute.\n+\t* c-decl.c (duplicate_decls): Merge new attribute.\n+\t* expr.h (current_function_check_memory_usage): Declare new var.\n+\t* calls.c, expr.c, function.c, stmt.c, alpha.c, clipper.c, m88k.c,\n+\tpa.c, sparc.c: Replace uses of flag_check_memory_usage with\n+\tcurrent_function_check_memory_usage.\n+\t* function.h: Add field to struct function.\n+\t* function.c (current_function_check_memory_usage): Define it.\n+\t(push_function_context_to, pop_function_context_from): Save and\n+\trestore it.\n+\t(expand_function_start): Set it, based on global flag and function\n+\tattribute.\n+\n+\t* expr.c (expand_expr, case VAR_DECL): In memory-checking code, do\n+\tcheck non-automatic variables, to permit detection of writes to\n+\tread-only locations in embedded systems without memory management.\n+\t* calls.c (store_one_arg): Use ARGS_SIZE_RTX to get size of argument\n+\twhen emitting chkr_set_right_libfunc call, even if the argument is\n+\tBLKmode or variable-sized; don't abort.\n+\n+\t* optabs.c (init_optabs): Create Checker and __cyg_profile_*\n+\tsymbols in Pmode, not VOIDmode.\n+\n Sun Oct 11 01:03:05 1998  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \n \t* cppexp.c: When forcing unsigned comparisons, cast both sides"}, {"sha": "3157e1d0f7d4c92b69839078e329aebeca31cc92", "filename": "gcc/c-common.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -51,7 +51,7 @@ extern struct obstack permanent_obstack;\n int skip_evaluation;\n \n enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n-\t    A_NO_INSTRUMENT_FUNCTION,\n+\t    A_NO_CHECK_MEMORY_USAGE, A_NO_INSTRUMENT_FUNCTION,\n \t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS,\n \t    A_INIT_PRIORITY};\n@@ -394,6 +394,7 @@ init_attributes ()\n   add_attribute (A_ALIAS, \"alias\", 1, 1, 1);\n   add_attribute (A_INIT_PRIORITY, \"init_priority\", 0, 1, 0);\n   add_attribute (A_NO_INSTRUMENT_FUNCTION, \"no_instrument_function\", 0, 0, 1);\n+  add_attribute (A_NO_CHECK_MEMORY_USAGE, \"no_check_memory_usage\", 0, 0, 1);\n }\n \f\n /* Process the attributes listed in ATTRIBUTES and PREFIX_ATTRIBUTES\n@@ -889,6 +890,23 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n \t  break;\n \n+\tcase A_NO_CHECK_MEMORY_USAGE:\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"`%s' attribute applies only to functions\",\n+\t\t\t       IDENTIFIER_POINTER (name));\n+\t    }\n+\t  else if (DECL_INITIAL (decl))\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"can't set `%s' attribute after definition\",\n+\t\t\t       IDENTIFIER_POINTER (name));\n+\t    }\n+\t  else\n+\t    DECL_NO_CHECK_MEMORY_USAGE (decl) = 1;\n+\t  break;\n+\n \tcase A_INIT_PRIORITY:\n \t  {\n \t    tree initp_expr = (args ? TREE_VALUE (args): NULL_TREE);"}, {"sha": "399acb081481961e5551ae0d9a5fece575c2d9d5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -1938,6 +1938,8 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \n \t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n \t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n+\t  DECL_NO_CHECK_MEMORY_USAGE (newdecl)\n+\t    |= DECL_NO_CHECK_MEMORY_USAGE (olddecl);\n \t}\n \n       pop_obstacks ();"}, {"sha": "c44617e6bb4d2c5f6e3c9235ef0a6c3798d24e9c", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -595,7 +595,7 @@ expand_call (exp, target, ignore)\n      if -fcheck-memory-usage, code which invokes functions (and thus\n      damages some hard registers) can be inserted before using the value.\n      So, target is always a pseudo-register in that case.  */\n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     target = 0;\n \n   /* See if we can find a DECL-node for the actual function.\n@@ -1625,7 +1625,7 @@ expand_call (exp, target, ignore)\n       pop_temp_slots ();\t/* FUNEXP can't be BLKmode */\n \n       /* Check the function is executable.  */\n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \temit_library_call (chkr_check_exec_libfunc, 1,\n \t\t\t   VOIDmode, 1,\n \t\t\t   funexp, ptr_mode);\n@@ -1864,7 +1864,7 @@ expand_call (exp, target, ignore)\n \t\t\t\t\t\tNULL_RTX)));\n \n       /* Mark the memory for the aggregate as write-only.  */\n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \temit_library_call (chkr_set_right_libfunc, 1,\n \t\t\t   VOIDmode, 3,\n \t\t\t   structure_value_addr, ptr_mode, \n@@ -3508,15 +3508,13 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \n   if (arg->value == arg->stack)\n     {\n-      /* If the value is already in the stack slot, we are done.  */\n-      if (flag_check_memory_usage && GET_CODE (arg->stack) == MEM)\n+      /* If the value is already in the stack slot, we are done moving\n+\t data.  */\n+      if (current_function_check_memory_usage && GET_CODE (arg->stack) == MEM)\n \t{\n-\t  if (arg->mode == BLKmode)\n-\t    abort ();\n-\n \t  emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t     XEXP (arg->stack, 0), ptr_mode, \n-\t\t\t     GEN_INT (GET_MODE_SIZE (arg->mode)),\n+\t\t\t     ARGS_SIZE_RTX (arg->size),\n \t\t\t     TYPE_MODE (sizetype),\n \t\t\t     GEN_INT (MEMORY_USE_RW),\n \t\t\t     TYPE_MODE (integer_type_node));"}, {"sha": "dca15802a8f6c4303acc5458729e1913622a6e2d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -2975,7 +2975,7 @@ alpha_builtin_saveregs (arglist)\n       dest = change_address (block, ptr_mode, XEXP (block, 0));\n       emit_move_insn (dest, addr);\n \n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t   dest, ptr_mode,\n \t\t\t   GEN_INT (GET_MODE_SIZE (ptr_mode)),\n@@ -2989,7 +2989,7 @@ alpha_builtin_saveregs (arglist)\n \t\t\t\t\t    POINTER_SIZE/BITS_PER_UNIT));\n       emit_move_insn (dest, argsize);\n \n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t   dest, ptr_mode,\n \t\t\t   GEN_INT (GET_MODE_SIZE"}, {"sha": "d59d3f1671e13fb9f21badcb006debc5f86c5a4b", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -438,7 +438,7 @@ clipper_builtin_saveregs (arglist)\n \t\t  scratch);\n \n \n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     {\n       emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t addr, ptr_mode,"}, {"sha": "877ecf9b8fab9b8f575743d27fcf48ddb0b1286f", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -2644,7 +2644,7 @@ m88k_builtin_saveregs (arglist)\n \t\t\t   UNITS_PER_WORD * (8 - fixed));\n     }\n \n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     {\n       emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t block, ptr_mode,"}, {"sha": "91ada8e3aec7d9be79a3364fda3983e1428b2efe", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -4391,7 +4391,7 @@ hppa_builtin_saveregs (arglist)\n      last argument register store.  So we emit a blockage insn here.  */\n   emit_insn (gen_blockage ());\n \n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t       dest, ptr_mode,\n \t\t       GEN_INT (4 * UNITS_PER_WORD), TYPE_MODE (sizetype),"}, {"sha": "686350b8694b18ea4bf17dd8969b8d253d850cf7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -4279,7 +4279,7 @@ sparc_builtin_saveregs (arglist)\n \t\t     GEN_INT (STACK_POINTER_OFFSET\n \t\t\t      + UNITS_PER_WORD * first_reg));\n \n-  if (flag_check_memory_usage\n+  if (current_function_check_memory_usage\n       && first_reg < NPARM_REGS (word_mode))\n     emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t       address, ptr_mode,"}, {"sha": "53dce8fdb0e8c4a381dec4c0f8542985ca8549c7", "filename": "gcc/expr.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -110,8 +110,8 @@ static rtx apply_args_value;\n static int can_handle_constant_p;\n \n /* Don't check memory usage, since code is being emitted to check a memory\n-   usage.  Used when flag_check_memory_usage is true, to avoid infinite\n-   recursion.  */\n+   usage.  Used when current_function_check_memory_usage is true, to avoid\n+   infinite recursion.  */\n static int in_check_memory_usage;\n \n /* This structure is used by move_by_pieces to describe the move to\n@@ -2865,7 +2865,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t  move_by_pieces (gen_rtx_MEM (BLKmode, gen_push_operand ()), xinner,\n \t\t\t  INTVAL (size) - used, align);\n \n-\t  if (flag_check_memory_usage && ! in_check_memory_usage)\n+\t  if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t    {\n \t      rtx temp;\n \t      \n@@ -2922,7 +2922,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t\t\t\t\t\targs_addr,\n \t\t\t\t\t\t\t\targs_so_far),\n \t\t\t\t\t\t  skip));\n-\t  if (flag_check_memory_usage && ! in_check_memory_usage)\n+\t  if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t    {\n \t      rtx target;\n \t      \n@@ -3122,7 +3122,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \n       emit_move_insn (gen_rtx_MEM (mode, addr), x);\n \n-      if (flag_check_memory_usage && ! in_check_memory_usage)\n+      if (current_function_check_memory_usage && ! in_check_memory_usage)\n \t{\n \t  in_check_memory_usage = 1;\n \t  if (target == 0)\n@@ -3290,7 +3290,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t}\n \n       /* Check the access.  */\n-      if (flag_check_memory_usage && GET_CODE (to_rtx) == MEM)\n+      if (current_function_check_memory_usage && GET_CODE (to_rtx) == MEM)\n \t{\n \t  rtx to_addr;\n \t  int size;\n@@ -3416,7 +3416,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t\t      EXPAND_MEMORY_USE_DONT);\n \n       /* Copy the rights of the bitmap.  */\n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n \t\t\t   XEXP (to_rtx, 0), ptr_mode,\n \t\t\t   XEXP (from_rtx, 0), ptr_mode,\n@@ -3638,7 +3638,7 @@ store_expr (exp, target, want_value)\n     temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t  temp, TREE_UNSIGNED (TREE_TYPE (exp)));\n \n-  if (flag_check_memory_usage\n+  if (current_function_check_memory_usage\n       && GET_CODE (target) == MEM\n       && AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n     {\n@@ -3742,7 +3742,7 @@ store_expr (exp, target, want_value)\n \t      if (size != const0_rtx)\n \t\t{\n \t\t  /* Be sure we can write on ADDR.  */\n-\t\t  if (flag_check_memory_usage)\n+\t\t  if (current_function_check_memory_usage)\n \t\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n \t\t\t\t       addr, ptr_mode,\n \t\t\t\t       size, TYPE_MODE (sizetype),\n@@ -5584,13 +5584,16 @@ expand_expr (exp, target, tmode, modifier)\n \t  pop_obstacks ();\n \t}\n \n-      /* Only check automatic variables.  Currently, function arguments are\n-         not checked (this can be done at compile-time with prototypes).\n-         Aggregates are not checked.  */\n-      if (flag_check_memory_usage && code == VAR_DECL\n+      /* Although static-storage variables start off initialized, according to\n+\t ANSI C, a memcpy could overwrite them with uninitialized values.  So\n+\t we check them too.  This also lets us check for read-only variables\n+\t accessed via a non-const declaration, in case it won't be detected\n+\t any other way (e.g., in an embedded system or OS kernel without\n+\t memory protection).\n+\n+\t Aggregates are not checked here; they're handled elsewhere.  */\n+      if (current_function_check_memory_usage && code == VAR_DECL\n \t  && GET_CODE (DECL_RTL (exp)) == MEM\n-\t  && DECL_CONTEXT (exp) != NULL_TREE\n-\t  && ! TREE_STATIC (exp)\n \t  && ! AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n \t{\n \t  enum memory_use_mode memory_usage;\n@@ -6107,7 +6110,7 @@ expand_expr (exp, target, tmode, modifier)\n \top0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address (mode, op0);\n \n-\tif (flag_check_memory_usage && !AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n+\tif (current_function_check_memory_usage && !AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n \t  {\n \t    enum memory_use_mode memory_usage;\n \t    memory_usage = get_memory_usage_from_modifier (modifier);\n@@ -6411,7 +6414,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  }\n \n \t/* Check the access.  */\n-\tif (flag_check_memory_usage && GET_CODE (op0) == MEM)\n+\tif (current_function_check_memory_usage && GET_CODE (op0) == MEM)\n           {\n \t    enum memory_use_mode memory_usage;\n \t    memory_usage = get_memory_usage_from_modifier (modifier);\n@@ -9163,7 +9166,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    src_rtx = copy_to_mode_reg (Pmode, src_rtx);\n \n \t  /* Check the string is readable and has an end.  */\n-\t  if (flag_check_memory_usage)\n+\t  if (current_function_check_memory_usage)\n \t    emit_library_call (chkr_check_str_libfunc, 1, VOIDmode, 2,\n \t\t\t       src_rtx, ptr_mode,\n \t\t\t       GEN_INT (MEMORY_USE_RO),\n@@ -9256,7 +9259,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n \n \t  /* Just copy the rights of SRC to the rights of DEST.  */\n-\t  if (flag_check_memory_usage)\n+\t  if (current_function_check_memory_usage)\n \t    emit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n \t\t\t       XEXP (dest_mem, 0), ptr_mode,\n \t\t\t       XEXP (src_mem, 0), ptr_mode,\n@@ -9327,7 +9330,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  dest_mem = get_memory_rtx (dest);\n \t   \n \t  /* Just check DST is writable and mark it as readable.  */\n-\t  if (flag_check_memory_usage)\n+\t  if (current_function_check_memory_usage)\n \t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n \t\t\t       XEXP (dest_mem, 0), ptr_mode,\n \t\t\t       len_rtx, TYPE_MODE (sizetype),\n@@ -9353,7 +9356,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \tbreak;\n \n       /* If we need to check memory accesses, call the library function.  */\n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \tbreak;\n \n       if (arglist == 0\n@@ -9409,7 +9412,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \tbreak;\n \n       /* If we need to check memory accesses, call the library function.  */\n-      if (flag_check_memory_usage)\n+      if (current_function_check_memory_usage)\n \tbreak;\n \n       if (arglist == 0\n@@ -10238,7 +10241,7 @@ expand_increment (exp, post, ignore)\n \n   /* Increment however we can.  */\n   op1 = expand_binop (mode, this_optab, value, op1,\n-  \t\t      flag_check_memory_usage ? NULL_RTX : op0,\n+  \t\t      current_function_check_memory_usage ? NULL_RTX : op0,\n \t\t      TREE_UNSIGNED (TREE_TYPE (exp)), OPTAB_LIB_WIDEN);\n   /* Make sure the value is stored into OP0.  */\n   if (op1 != op0)"}, {"sha": "b1665aa7de914ad225020c16cc05041ecd7a78ef", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -91,6 +91,10 @@ extern int current_function_uses_pic_offset_table;\n /* The arg pointer hard register, or the pseudo into which it was copied.  */\n extern rtx current_function_internal_arg_pointer;\n \n+/* This is nonzero if memory access checking be enabled in the current\n+   function.  */\n+extern int current_function_check_memory_usage;\n+\n /* Nonzero means stack pops must not be deferred, and deferred stack\n    pops must not be output.  It is nonzero inside a function call,\n    inside a conditional expression, inside a statement expression,"}, {"sha": "a2c278b001c990f9868a4dad64d1c32bc60d591c", "filename": "gcc/extend.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -1518,6 +1518,19 @@ mangled name for the target must be used.\n \n Not all target machines support this attribute.\n \n+@item no_check_memory_usage\n+@cindex @code{no_check_memory_usage} function attribute\n+If @samp{-fcheck-memory-usage} is given, calls to support routines will\n+be generated before most memory accesses, to permit support code to\n+record usage and detect uses of uninitialized or unallocated storage.\n+Since the compiler cannot handle them properly, @code{asm} statements\n+are not allowed.  Declaring a function with this attribute disables the\n+memory checking code for that function, permitting the use of @code{asm}\n+statements without requiring separate compilation with different\n+options, and allowing you to write support routines of your own if you\n+wish, without getting infinite recursion if they get compiled with this\n+option.\n+\n @item regparm (@var{number})\n @cindex functions that are passed arguments in registers on the 386\n On the Intel 386, the @code{regparm} attribute causes the compiler to"}, {"sha": "4645f5af7cc658f9cbad0bf3736a7979512d439c", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -221,6 +221,9 @@ char *current_function_cannot_inline;\n    generated.  */\n int current_function_instrument_entry_exit;\n \n+/* Nonzero if memory access checking be enabled in the current function.  */\n+int current_function_check_memory_usage;\n+\n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n tree inline_function_decl;\n \n@@ -543,6 +546,7 @@ push_function_context_to (context)\n   p->fixup_var_refs_queue = 0;\n   p->epilogue_delay_list = current_function_epilogue_delay_list;\n   p->args_info = current_function_args_info;\n+  p->check_memory_usage = current_function_check_memory_usage;\n   p->instrument_entry_exit = current_function_instrument_entry_exit;\n \n   save_tree_status (p, context);\n@@ -626,6 +630,7 @@ pop_function_context_from (context)\n   current_function_epilogue_delay_list = p->epilogue_delay_list;\n   reg_renumber = 0;\n   current_function_args_info = p->args_info;\n+  current_function_check_memory_usage = p->check_memory_usage;\n   current_function_instrument_entry_exit = p->instrument_entry_exit;\n \n   restore_tree_status (p, context);\n@@ -1484,7 +1489,7 @@ put_var_into_stack (decl)\n   else\n     return;\n   \n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t       XEXP (reg, 0), ptr_mode,\n \t\t       GEN_INT (GET_MODE_SIZE (GET_MODE (reg))),\n@@ -4364,7 +4369,7 @@ assign_parms (fndecl, second_time)\n \n \t      store_expr (parm, copy, 0);\n \t      emit_move_insn (parmreg, XEXP (copy, 0));\n-\t      if (flag_check_memory_usage)\n+\t      if (current_function_check_memory_usage)\n \t\temit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t\t   XEXP (copy, 0), ptr_mode,\n \t\t\t\t   GEN_INT (int_size_in_bytes (type)),\n@@ -4529,7 +4534,7 @@ assign_parms (fndecl, second_time)\n \t\temit_move_insn (validize_mem (stack_parm),\n \t\t\t\tvalidize_mem (entry_parm));\n \t    }\n-\t  if (flag_check_memory_usage)\n+\t  if (current_function_check_memory_usage)\n \t    {\n \t      push_to_sequence (conversion_insns);\n \t      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n@@ -5550,6 +5555,11 @@ expand_function_start (subr, parms_have_cleanups)\n      valid operands of arithmetic insns.  */\n   init_recog_no_volatile ();\n \n+  /* Set this before generating any memory accesses.  */\n+  current_function_check_memory_usage\n+    = (flag_check_memory_usage\n+       && ! DECL_NO_CHECK_MEMORY_USAGE (current_function_decl));\n+\n   current_function_instrument_entry_exit\n     = (flag_instrument_function_entry_exit\n        && ! DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (subr));"}, {"sha": "014ed135b74401eeadb48f74e9d775f5cd3e340d", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -151,6 +151,7 @@ struct function\n   rtx saveregs_value;\n   rtx apply_args_value;\n   rtx forced_labels;\n+  int check_memory_usage;\n \n   /* For emit-rtl.c.  */\n   int reg_rtx_no;"}, {"sha": "cf461987208a8d98f63dc2d7a7082c801926a24d", "filename": "gcc/invoke.texi", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -5843,8 +5843,7 @@ the offsets of structure members won't agree with system libraries.\n @item -fcheck-memory-usage\n Generate extra code to check each memory access.  GNU CC will generate\n code that is suitable for a detector of bad memory accesses such as\n-@file{Checker}.  If you specify this option, you can not use the\n-@code{asm} or @code{__asm__} keywords.\n+@file{Checker}.\n \n You must also specify this option when you compile functions you call that\n have side effects.  If you do not, you may get erroneous messages from\n@@ -5859,6 +5858,24 @@ which are provided by the detector.  If you cannot find or build\n stubs for every function you call, you may have to specify\n @samp{-fcheck-memory-usage} without @samp{-fprefix-function-name}.\n \n+If you specify this option, you can not use the @code{asm} or\n+@code{__asm__} keywords in functions with memory checking enabled.  The\n+compiler cannot understand what the @code{asm} statement will do, and\n+therefore cannot generate the appropriate code, so it is rejected.\n+However, the function attribute @code{no_check_memory_usage} will\n+disable memory checking within a function, and @code{asm} statements can\n+be put inside such functions.  Inline expansion of a non-checked\n+function within a checked function is permitted; the inline function's\n+memory accesses won't be checked, but the rest will.\n+\n+If you move your @code{asm} statements to non-checked inline functions,\n+but they do access memory, you can add calls to the support code in your\n+inline function, to indicate any reads, writes, or copies being done.\n+These calls would be similar to those done in the stubs described above.\n+\n+@c FIXME: The support-routine interface is defined by the compiler and\n+@c        should be documented!\n+\n @item -fprefix-function-name\n Request GNU CC to add a prefix to the symbols generated for function names.\n GNU CC adds a prefix to the names of functions defined as well as"}, {"sha": "2a321690dc4e8f9254d24de2ec26e44375795b6e", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -4390,17 +4390,17 @@ init_optabs ()\n   fixunstfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfti\");\n \n   /* For check-memory-usage.  */\n-  chkr_check_addr_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_addr\");\n-  chkr_set_right_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_set_right\");\n-  chkr_copy_bitmap_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_copy_bitmap\");\n-  chkr_check_exec_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_exec\");\n-  chkr_check_str_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_str\");\n+  chkr_check_addr_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_check_addr\");\n+  chkr_set_right_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_set_right\");\n+  chkr_copy_bitmap_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_copy_bitmap\");\n+  chkr_check_exec_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_check_exec\");\n+  chkr_check_str_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"chkr_check_str\");\n \n   /* For function entry/exit instrumentation.  */\n   profile_function_entry_libfunc\n-    = gen_rtx_SYMBOL_REF (VOIDmode, \"__cyg_profile_func_enter\");\n+    = gen_rtx_SYMBOL_REF (Pmode, \"__cyg_profile_func_enter\");\n   profile_function_exit_libfunc\n-    = gen_rtx_SYMBOL_REF (VOIDmode, \"__cyg_profile_func_exit\");\n+    = gen_rtx_SYMBOL_REF (Pmode, \"__cyg_profile_func_exit\");\n \n #ifdef HAVE_conditional_trap\n   init_traps ();"}, {"sha": "b28df90c48f38b80738a7b39ad3d6473b5baee97", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -584,7 +584,7 @@ expand_computed_goto (exp)\n \n   emit_queue ();\n   /* Be sure the function is executable.  */\n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     emit_library_call (chkr_check_exec_libfunc, 1,\n \t\t       VOIDmode, 1, x, ptr_mode);\n \n@@ -1118,7 +1118,7 @@ void\n expand_asm (body)\n      tree body;\n {\n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     {\n       error (\"`asm' cannot be used with `-fcheck-memory-usage'\");\n       return;\n@@ -1174,7 +1174,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   if (noutputs == 0)\n     vol = 1;\n \n-  if (flag_check_memory_usage)\n+  if (current_function_check_memory_usage)\n     {\n       error (\"`asm' cannot be used with `-fcheck-memory-usage'\");\n       return;\n@@ -3291,7 +3291,7 @@ expand_decl (decl)\n \t   && ! TREE_ADDRESSABLE (decl)\n \t   && (DECL_REGISTER (decl) || ! obey_regdecls)\n \t   /* if -fcheck-memory-usage, check all variables.  */\n-\t   && ! flag_check_memory_usage)\n+\t   && ! current_function_check_memory_usage)\n     {\n       /* Automatic variable that can go in a register.  */\n       int unsignedp = TREE_UNSIGNED (type);"}, {"sha": "14cd57461468af0889f330917690b17ca1455eb2", "filename": "gcc/testsuite/gcc.c-torture/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2FChangeLog?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -1,3 +1,8 @@\n+Sun Oct 11 05:04:28 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* execute/memcheck: New directory of tests for\n+\t-fcheck-memory-usage.\n+\n 1998-10-06  Ken Raeburn  <raeburn@cygnus.com>\n \n \t* special/981006-1.c: New test.  Make sure gcc doesn't lose track"}, {"sha": "43c5b39498ac885d130002383e9ad38ebd9176cf", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/blkarg.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fblkarg.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,64 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+/* Test permissions of BLKmode arguments constructed purely on the\n+   stack.\n+\n+   Maybe we can't guarantee that we'll always wind up with stack args,\n+   but if we don't, they're in registers, and permissions should just\n+   always yield success.  So while this test may not be effective on\n+   all platforms, failure probably does indicate a real bug.\n+\n+   Note that because of the implementation, we do want to test BLKmode\n+   arguments that live purely on the stack and are constructed there.\n+   We want to test other situations of function arguments, of course,\n+   but don't assume this case would be covered by using one monster\n+   argument that is read from memory (including using constructor\n+   syntax but constant values), or may live partially in registers.  */\n+\n+int expect_error = 0;\n+\n+/* Must be BLKmode.  Using only two fields gets TImode on Alpha.  */\n+struct S {\n+  unsigned long long ll;\n+  long xx, yy;\n+};\n+\n+unsigned long long x = 0x12345689ULL;\n+#define I2\t42\n+\n+/* Leading six arguments force X into stack on both Alpha and MIPS.  */\n+\n+static int first_time = 1;\n+int foo (int a1, int a2, int a3, int a4, int a5, int a6, struct S s) {\n+  if (a1 != 1 || a2 != 2 || a3 != 3 || a4 != 4 || a5 != 5 || a6 != 6)\n+    abort ();\n+  if (first_time)\n+    {\n+      if (s.ll != x || s.xx != I2 || s.yy != 0)\n+\tabort ();\n+      first_time = 0;\n+    }\n+  else\n+    {\n+      if (s.ll != 0 || s.xx != 0 || s.yy != 0)\n+\tabort ();\n+    }\n+  return 0;\n+}\n+\n+void test ()\n+{\n+  foo (1, 2, 3, 4, 5, 6, (struct S) { x, I2 });\n+  foo (1, 2, 3, 4, 5, 6, (struct S) { 0 });\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&x, sizeof (x), ACCESS_RO);\n+  mark_region (&first_time, sizeof (first_time), ACCESS_RW);\n+}"}, {"sha": "9002a0b8d2410517f6481cf1d677728a9a0af4c9", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/driver.c", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,254 @@\n+/* GNU C dependencies:\n+   Checker support hooks\n+   ISO C 9x array element initialization\n+   void-pointer arithmetic */\n+\n+#include \"driver.h\"\n+\n+int verbose = 0;\n+int debug = 0;\n+int bad_accesses = 0;\n+\n+const char *const memory_use_strings[] = {\n+#define INIT(x)\t\t[x] = #x\n+  INIT (MEMORY_USE_BAD),\n+  INIT (MEMORY_USE_DONT),\n+  INIT (MEMORY_USE_RO),\n+  INIT (MEMORY_USE_RW),\n+  INIT (MEMORY_USE_TW),\n+  INIT (MEMORY_USE_WO),\n+#undef INIT\n+};\n+\n+/* This won't be used for any really huge test cases, so a simple\n+   linked list is adequate.  We won't even worry about overlapping\n+   regions; the matching entry that comes up first wins.  */\n+const char *const access_mode_strings[] = {\n+  \"none\", \"ro\", \"wo\", \"rw\",\n+};\n+struct access_node {\n+  struct access_node *next;\n+  const void *addr;\n+  size_t sz;\n+  enum access_mode mode;\n+};\n+\n+static struct access_node *access_list;\n+\n+void mark_region (const void *addr, size_t sz, enum access_mode mode)\n+{\n+  struct access_node *a;\n+  if (debug)\n+    printf (\"mark_region (%p, %ld, %s)\\n\", addr, (long) sz,\n+\t    access_mode_strings[mode]);\n+  a = malloc (sizeof (struct access_node));\n+  a->next = access_list;\n+  a->addr = addr;\n+  a->sz = sz;\n+  a->mode = mode;\n+  access_list = a;\n+}\n+\n+void report_bad_access (void *, size_t, enum memory_use_mode) NOCHECK;\n+void report_bad_access (void *addr, size_t sz, enum memory_use_mode mode)\n+{\n+  if (++bad_accesses > 100)\n+    bad_accesses = 100;\n+  if (verbose)\n+    {\n+      static char x[100];\n+      const char *mode_str;\n+      if (mode >= 0\n+\t  && mode < sizeof (memory_use_strings) / sizeof (*memory_use_strings)\n+\t  && memory_use_strings[mode] != 0)\n+\tmode_str = memory_use_strings[mode];\n+      else\n+\t{\n+\t  sprintf (x, \"<bad mode %d>\", mode);\n+\t  mode_str = x;\n+\t}\n+      printf (\"bad access (%p, %ld, %s)\\n\", addr, (long) sz, mode_str);\n+    }\n+}\n+\n+int verify1 (void *, size_t, enum access_mode, struct access_node *) NOCHECK;\n+int verify1 (void *addr, size_t sz, enum access_mode mode,\n+\t     struct access_node *a)\n+{\n+  while (a && (addr + sz <= a->addr || addr >= a->addr + a->sz))\n+    a = a->next;\n+  if (a == 0)\n+    return 0;\n+\n+  if (debug)\n+    printf (\"verify1 (%p, %ld, %s)\\n\", addr, (long) sz,\n+\t    access_mode_strings[mode]);\n+\n+  if (mode & ~a->mode)\n+    return 0;\n+\n+  if (addr < a->addr)\n+    if (verify1 (a, a->addr - addr, mode, a->next) == 0)\n+      return 0;\n+  if (addr + sz > a->addr + a->sz)\n+    if (verify1 (a->addr + a->sz, (addr + sz) - (a->addr + a->sz), mode, a->next) == 0)\n+      return 0;\n+\n+  /* All regions okay.  */\n+  return 1;\n+}\n+\n+int verify_range_permission (void *, size_t, enum access_mode) NOCHECK;\n+\n+int verify_range_permission (void *addr, size_t sz, enum access_mode mode)\n+{\n+  if (debug)\n+    printf (\"verify_range_permission (%p, %ld, %s)\\n\", addr, (long) sz,\n+\t    access_mode_strings[mode]);\n+  return verify1 (addr, sz, mode, access_list);\n+}\n+\n+void chkr_check_addr (void *, size_t, int) NOCHECK;\n+\n+void chkr_check_addr (void *addr, size_t sz, int mode)\n+{\n+  switch (mode)\n+    {\n+    case MEMORY_USE_BAD:\n+    case MEMORY_USE_DONT:\n+    default:\n+      report_bad_access (addr, sz, mode);\n+      return;\n+    case MEMORY_USE_RO:\n+      /* verify range readable */\n+      if (!verify_range_permission (addr, sz, ACCESS_RO))\n+\treport_bad_access (addr, sz, mode);\n+      return;\n+    case MEMORY_USE_WO:\n+      /* verify writeable, set writeable and readable */\n+      if (!verify_range_permission (addr, sz, ACCESS_WO))\n+\treport_bad_access (addr, sz, mode);\n+      mark_region (addr, sz, ACCESS_RW);\n+      return;\n+    case MEMORY_USE_RW:\n+      /* verify readable and writeable, no change */\n+      if (!verify_range_permission (addr, sz, ACCESS_RW))\n+\treport_bad_access (addr, sz, mode);\n+      return;\n+    case MEMORY_USE_TW:\n+      /* verify writeable, no change */\n+      if (!verify_range_permission (addr, sz, ACCESS_WO))\n+\treport_bad_access (addr, sz, mode);\n+      return;\n+    }\n+  /* All branches should return.  */\n+  abort ();\n+}\n+\n+void copy1 (void *, void *, size_t, struct access_node *) NOCHECK;\n+void copy1 (void *dest, void *src, size_t sz, struct access_node *a)\n+{\n+  while (a && (src + sz <= a->addr || src >= a->addr + a->sz))\n+    a = a->next;\n+  if (a == 0)\n+    {\n+      report_bad_access (src, sz, MEMORY_USE_RO);\n+      return;\n+    }\n+\n+  if (debug)\n+    printf (\"copy1 (%p, %p, %ld)\\n\", dest, src, (long) sz);\n+\n+  {\n+    void *start, *end;\n+    start = src;\n+    if (start < a->addr)\n+      start = a->addr;\n+    end = src + sz;\n+    if (end > a->addr + a->sz)\n+      end = a->addr + a->sz;\n+    mark_region (dest + (start - src), end - start, a->mode);\n+  }\n+\n+  if (src < a->addr)\n+    copy1 (dest, src, a->addr - src, a->next);\n+  if (src + sz > a->addr + a->sz)\n+    copy1 (dest + (a->addr + a->sz - src), a->addr + a->sz,\n+\t   (src + sz) - (a->addr + a->sz), a->next);\n+}\n+\n+void chkr_copy_bitmap (void *, void *, size_t) NOCHECK;\n+void chkr_copy_bitmap (void *dest, void *src, size_t sz)\n+{\n+  if (verify_range_permission (dest, sz, MEMORY_USE_WO) == 0)\n+    report_bad_access (dest, sz, MEMORY_USE_WO);\n+  copy1 (dest, src, sz, access_list);\n+}\n+\n+void chkr_set_right (void *, size_t, enum access_mode) NOCHECK;\n+void chkr_set_right (void *addr, size_t sz, enum access_mode mode)\n+{\n+  mark_region (addr, sz, mode);\n+}\n+\n+int main () NOCHECK;\n+int main ()\n+{\n+  setup ();\n+  test ();\n+  bad_accesses = !!bad_accesses; /* get 0 or 1 */\n+  /* Return 0 if got expected results, 1 otherwise.  */\n+  return !(bad_accesses == expect_error);\n+}\n+\n+struct malloc_node {\n+  struct malloc_node *next;\n+  void *addr;\n+  size_t sz;\n+  unsigned is_free : 1;\n+};\n+static struct malloc_node *malloc_list;\n+\n+void *c_malloc (size_t sz)\n+{\n+  void *p;\n+  struct malloc_node *m;\n+  if (sz == 0)\n+    return 0;\n+  p = malloc (sz);\n+  if (p == 0)\n+    {\n+      if (verbose)\n+\tprintf (\"malloc(%ld) failed\\n\", (long) sz);\n+      exit (1);\n+    }\n+  m = malloc (sizeof (struct malloc_node));\n+  if (m == 0)\n+    {\n+      if (verbose)\n+\tprintf (\"malloc(%ld) failed\\n\", (long) sizeof (struct malloc_node));\n+      exit (1);\n+    }\n+  mark_region (p, sz, ACCESS_WO);\n+  m->addr = p;\n+  m->sz = sz;\n+  m->is_free = 0;\n+  m->next = malloc_list;\n+  malloc_list = m;\n+  return p;\n+}\n+\n+void c_free (void *p)\n+{\n+  struct malloc_node *m;\n+  if (p == 0)\n+    return;\n+  for (m = malloc_list; m; m = m->next)\n+    if (m->addr == p)\n+      break;\n+  if (m == 0 || m->is_free)\n+    /* Test is broken.  */\n+    abort ();\n+  m->is_free = 1;\n+  free (p);\n+}"}, {"sha": "d8d22d2496a80aba42f11d6fafc8b4739ba31319", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/driver.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fdriver.h?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,28 @@\n+/* GNU C dependencies:\n+   Checker support hooks\n+   ISO C 9x array element initialization\n+   void-pointer arithmetic */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void *malloc (size_t);\n+extern int printf (const char *, ...);\n+\n+/* This comes from gcc internals.  Should be exported.  */\n+enum memory_use_mode {MEMORY_USE_BAD = 0, MEMORY_USE_RO = 1,\n+\t\t      MEMORY_USE_WO = 2, MEMORY_USE_RW = 3,\n+\t\t      MEMORY_USE_TW = 6, MEMORY_USE_DONT = 99};\n+\n+enum access_mode {\n+  ACCESS_NONE = 0, ACCESS_RO = 1, ACCESS_WO = 2, ACCESS_RW = 3\n+};\n+\n+#define NOCHECK __attribute__ ((no_check_memory_usage))\n+\n+void mark_region (const void *, size_t, enum access_mode) NOCHECK;\n+void setup () NOCHECK;\n+void test ();\n+extern int expect_error;\n+\n+void *c_malloc (size_t) NOCHECK;\n+void c_free (void *) NOCHECK;"}, {"sha": "7fb756b4f5cad0c463905bea9a1491bd7e81ac35", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/memcheck.exp", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fmemcheck.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fmemcheck.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Fmemcheck.exp?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,54 @@\n+# Copyright (C) 1991, 92-93, 95, 97, 1998 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. \n+\n+# Please email any bugs, comments, and/or additions to this file to:\n+# bug-gcc@prep.ai.mit.edu\n+\n+# This file was written by Rob Savoye. (rob@cygnus.com)\n+# Modified and maintained by Jeffrey Wheat (cassidy@cygnus.com)\n+\n+#\n+# These tests come from Torbjorn Granlund (tege@cygnus.com)\n+# C torture test suite.\n+#\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# load support procs\n+load_lib c-torture.exp\n+\n+#\n+# main test loop\n+#\n+\n+set tests [lsort [glob -nocomplain $srcdir/$subdir/*.c]]\n+set idx [lsearch $tests */driver.c]\n+if $idx>=0 {\n+    set tests [lreplace $tests $idx $idx]\n+} else {\n+    error \"list can't find driver.c in $srcdir/$subdir\"\n+}\n+gcc_target_compile $srcdir/$subdir/driver.c driver.o object {additional_flags=-w additional_flags=-g}\n+foreach src $tests {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+\n+    c-torture-execute $src \"-fcheck-memory-usage driver.o\"\n+}"}, {"sha": "03b6acc1335d04d52d8893eabb31da1277d15fe8", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft1.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,27 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup ();   -- NOCHECK */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 0;\n+\n+int *ip;\n+\n+void test ()\n+{\n+  ip = c_malloc (sizeof (int));\n+  *ip = 42;\n+  t2 ();\n+}\n+\n+int t2 ()\n+{\n+  return *ip;\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&ip, sizeof (ip), ACCESS_RW);\n+}"}, {"sha": "d386eb7ebb144f1b8463abee56709d5cce1ad57c", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft2.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,26 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 1;\n+\n+int *ip;\n+\n+void test ()\n+{\n+  ip = c_malloc (sizeof (int));\n+  t2 ();\n+}\n+\n+int t2 ()\n+{\n+  return *ip;\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&ip, sizeof (ip), ACCESS_RW);\n+}"}, {"sha": "5b6333d4e8efd0a35602f353d20cfd04122fdd2d", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft3.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,25 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 0;\n+\n+int *ip;\n+\n+void test ()\n+{\n+  ip = c_malloc (sizeof (int));\n+  t2 (ip);\n+}\n+\n+int t2 (int *ip)\n+{\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&ip, sizeof (ip), ACCESS_RW);\n+}"}, {"sha": "25010a068184fed0071e88b9d6143f56024ccf50", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t4.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft4.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,34 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 0;\n+\n+struct s {\n+  char c;\n+  int a, b;\n+};\n+\n+struct s *sp;\n+\n+void test ()\n+{\n+  sp = c_malloc (sizeof (struct s));\n+  sp->c = 0;\n+  sp->a = 12;\n+  sp->b = 47;\n+  foo (sp);\n+}\n+\n+int foo (struct s *sp)\n+{\n+  return sp->c + sp->a + sp->b;\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&sp, sizeof (sp), ACCESS_RW);\n+}"}, {"sha": "c3bbf640517d9870483bd05e92faadafd5ddd2f2", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t5.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft5.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,33 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 1;\n+\n+struct s {\n+  char c;\n+  int a, b;\n+};\n+\n+struct s *sp;\n+\n+void test ()\n+{\n+  sp = c_malloc (sizeof (struct s));\n+  sp->c = 0;\n+  sp->b = 47;\n+  foo (sp);\n+}\n+\n+int foo (struct s *sp)\n+{\n+  return sp->c + sp->a + sp->b;\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&sp, sizeof (sp), ACCESS_RW);\n+}"}, {"sha": "652d33d0f8c620e5f938403e7710c8d12d779440", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t6.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft6.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,39 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 1;\n+\n+struct s {\n+  char c;\n+  int a, b;\n+};\n+\n+struct s *sp;\n+\n+void test ()\n+{\n+  sp = c_malloc (sizeof (struct s) * 2);\n+  sp->c = 0;\n+  sp->b = 47;\n+  cp (sp);\n+  foo (sp);\n+}\n+\n+int foo (struct s *sp)\n+{\n+  return sp[1].c + sp[1].a + sp[1].b;\n+}\n+\n+int cp (struct s *sp)\n+{\n+  sp[1] = sp[0];\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&sp, sizeof (sp), ACCESS_RW);\n+}"}, {"sha": "a7c6f5127ed8584bcb7149aca0aba87e254159bd", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t7.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft7.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,40 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 0;\n+\n+struct s {\n+  char c;\n+  int a, b;\n+};\n+\n+struct s *sp;\n+\n+void test ()\n+{\n+  sp = c_malloc (sizeof (struct s) * 2);\n+  sp->c = 0;\n+  sp->a = 13;\n+  sp->b = 47;\n+  cp (sp);\n+  foo (sp);\n+}\n+\n+int foo (struct s *sp)\n+{\n+  return sp[1].c + sp[1].a + sp[1].b;\n+}\n+\n+int cp (struct s *sp)\n+{\n+  sp[1] = sp[0];\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&sp, sizeof (sp), ACCESS_RW);\n+}"}, {"sha": "01c167247f8606e660ab0e12e40c14c9bcb07da2", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t8.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft8.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,41 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 0;\n+\n+typedef struct {\n+  short a;\n+  char b;\n+} S1;\n+typedef struct {\n+  struct { int x; S1 *s1p; } *p;\n+} S2;\n+\n+S1 *s1;\n+S2 *s2;\n+\n+void test ()\n+{\n+  s1 = c_malloc (sizeof (S1));\n+  s2 = c_malloc (sizeof (S2));\n+  s2->p = c_malloc (sizeof (*s2->p));\n+  s2->p->s1p = s1;\n+  s1->a = 47;\n+  s1->b = 3;\n+  foo ();\n+}\n+\n+int foo ()\n+{\n+  return s2->p->s1p->b;\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&s1, sizeof (s1), ACCESS_RW);\n+  mark_region (&s2, sizeof (s2), ACCESS_RW);\n+}"}, {"sha": "f32ca011dd83412fb84242f956063a5948959670", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/t9.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ft9.c?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,40 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = 1;\n+\n+typedef struct {\n+  short a;\n+  char b;\n+} S1;\n+typedef struct {\n+  struct { int x; S1 *s1p; } *p;\n+} S2;\n+\n+S1 *s1;\n+S2 *s2;\n+\n+void test ()\n+{\n+  s1 = c_malloc (sizeof (S1));\n+  s2 = c_malloc (sizeof (S2));\n+  s2->p = c_malloc (sizeof (*s2->p));\n+  s2->p->s1p = s1;\n+  s1->a = 47;\n+  foo ();\n+}\n+\n+int foo ()\n+{\n+  return s2->p->s1p->b;\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+  mark_region (&s1, sizeof (s1), ACCESS_RW);\n+  mark_region (&s2, sizeof (s2), ACCESS_RW);\n+}"}, {"sha": "37ebb137c87fb9076ef880a4ec2b9ca122dddabc", "filename": "gcc/testsuite/gcc.c-torture/execute/memcheck/template", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ftemplate", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ftemplate", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemcheck%2Ftemplate?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -0,0 +1,16 @@\n+/* Must define:\n+   int expect_error;\n+   void test ();\n+   void setup () NOCHECK; */\n+\n+#include \"driver.h\"\n+\n+int expect_error = ;\n+\n+void test ()\n+{\n+}\n+\n+void setup () /* NOCHECK */\n+{\n+}"}, {"sha": "8bd8df3368f4f0794bea9cfddf952a2b643e76f6", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d384cc0b300cace24c008fec600219e4377923c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7d384cc0b300cace24c008fec600219e4377923c", "patch": "@@ -1226,6 +1226,10 @@ struct tree_type\n    be instrumented with calls to support routines.  */\n #define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) ((NODE)->decl.no_instrument_function_entry_exit)\n \n+/* Used in FUNCTION_DECLs to indicate that in this function,\n+   check-memory-usage should be disabled.  */\n+#define DECL_NO_CHECK_MEMORY_USAGE(NODE) ((NODE)->decl.no_check_memory_usage)\n+\n /* Additional flags for language-specific uses.  */\n #define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)\n #define DECL_LANG_FLAG_1(NODE) (DECL_CHECK (NODE)->decl.lang_flag_1)\n@@ -1282,6 +1286,7 @@ struct tree_decl\n \n   unsigned non_addr_const_p : 1;\n   unsigned no_instrument_function_entry_exit : 1;\n+  unsigned no_check_memory_usage : 1;\n \n   /* For a FUNCTION_DECL, if inline, this is the size of frame needed.\n      If built-in, this is the code for which built-in function."}]}