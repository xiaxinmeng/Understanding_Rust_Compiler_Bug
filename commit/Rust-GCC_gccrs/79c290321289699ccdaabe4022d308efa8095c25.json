{"sha": "79c290321289699ccdaabe4022d308efa8095c25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljMjkwMzIxMjg5Njk5Y2NkYWFiZTQwMjJkMzA4ZWZhODA5NWMyNQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2006-01-19T14:54:57Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2006-01-19T14:54:57Z"}, "message": "combine.c (try_combine): Do not worry about MEMs wrapped by USEs.\n\n2006-01-19  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* combine.c (try_combine): Do not worry about MEMs wrapped by USEs.\n\t(expand_compound_operation, expand_field_assignment): Fail if the\n\tbit lengths of an extract operation are out of range.\n\t(make_extraction): Compute wanted_inner_mode based on the position\n\tand length of the extraction.  Make it extraction_mode for non-constant\n\tpositions, and do not modify offset in that case.  When generating a\n\tnew MEM, use a mode that can hold the extraction while keeping correct\n\talignment.  Remove code that supported MEMs wrapped by USEs.\n\t(simplify_shift_const_1, force_to_mode) <case USE>: Remove.\n\nFrom-SVN: r109961", "tree": {"sha": "fdae5f15afbb7e5ca3e0698707a9875920236be4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdae5f15afbb7e5ca3e0698707a9875920236be4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79c290321289699ccdaabe4022d308efa8095c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c290321289699ccdaabe4022d308efa8095c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c290321289699ccdaabe4022d308efa8095c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c290321289699ccdaabe4022d308efa8095c25/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3298c037d43e41e16a018a9f7eb0348edd91cc66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3298c037d43e41e16a018a9f7eb0348edd91cc66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3298c037d43e41e16a018a9f7eb0348edd91cc66"}], "stats": {"total": 166, "additions": 62, "deletions": 104}, "files": [{"sha": "828f8abcdaac4e81cbc7649e63a02ad7b3cdcad4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c290321289699ccdaabe4022d308efa8095c25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c290321289699ccdaabe4022d308efa8095c25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79c290321289699ccdaabe4022d308efa8095c25", "patch": "@@ -1,3 +1,15 @@\n+2006-01-19  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* combine.c (try_combine): Do not worry about MEMs wrapped by USEs.\n+\t(expand_compound_operation, expand_field_assignment): Fail if the\n+\tbit lengths of an extract operation are out of range.\n+\t(make_extraction): Compute wanted_inner_mode based on the position\n+\tand length of the extraction.  Make it extraction_mode for non-constant\n+\tpositions, and do not modify offset in that case.  When generating a\n+\tnew MEM, use a mode that can hold the extraction while keeping correct\n+\talignment.  Remove code that supported MEMs wrapped by USEs.\n+\t(simplify_shift_const_1, force_to_mode) <case USE>: Remove.\n+\n 2006-01-19  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.md (\"Y\", \"y\"): New mode attribute."}, {"sha": "55f5723a3d7b1ed61b4d490bffd84653fe20f490", "filename": "gcc/combine.c", "status": "modified", "additions": 50, "deletions": 104, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c290321289699ccdaabe4022d308efa8095c25/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c290321289699ccdaabe4022d308efa8095c25/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=79c290321289699ccdaabe4022d308efa8095c25", "patch": "@@ -2896,9 +2896,6 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! use_crosses_set_p (SET_SRC (XVECEXP (newpat, 0, 1)),\n \t\t\t\t   INSN_CUID (i2))\n-\t   /* Don't pass sets with (USE (MEM ...)) dests to the following.  */\n-\t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != USE\n-\t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 0))) != USE\n \t   && ! reg_referenced_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t  XVECEXP (newpat, 0, 0))\n \t   && ! reg_referenced_p (SET_DEST (XVECEXP (newpat, 0, 0)),\n@@ -5643,11 +5640,8 @@ expand_compound_operation (rtx x)\n       len = INTVAL (XEXP (x, 1));\n       pos = INTVAL (XEXP (x, 2));\n \n-      /* If this goes outside the object being extracted, replace the object\n-\t with a (use (mem ...)) construct that only combine understands\n-\t and is used only for this purpose.  */\n-      if (len + pos > GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n-\tSUBST (XEXP (x, 0), gen_rtx_USE (GET_MODE (x), XEXP (x, 0)));\n+      /* This should stay within the object being extracted, fail.  */\n+      gcc_assert (len + pos <= GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))));\n \n       if (BITS_BIG_ENDIAN)\n \tpos = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - len - pos;\n@@ -5805,11 +5799,10 @@ expand_field_assignment (rtx x)\n \t  len = INTVAL (XEXP (SET_DEST (x), 1));\n \t  pos = XEXP (SET_DEST (x), 2);\n \n-\t  /* If the position is constant and spans the width of INNER,\n-\t     surround INNER  with a USE to indicate this.  */\n-\t  if (GET_CODE (pos) == CONST_INT\n-\t      && INTVAL (pos) + len > GET_MODE_BITSIZE (GET_MODE (inner)))\n-\t    inner = gen_rtx_USE (GET_MODE (SET_DEST (x)), inner);\n+\t  /* A constant position should stay within the width of INNER.  */\n+\t  if (GET_CODE (pos) == CONST_INT)\n+\t    gcc_assert (INTVAL (pos) + len\n+\t\t\t<= GET_MODE_BITSIZE (GET_MODE (inner)));\n \n \t  if (BITS_BIG_ENDIAN)\n \t    {\n@@ -5907,13 +5900,6 @@ expand_field_assignment (rtx x)\n    it is an RTX that represents a variable starting position; otherwise,\n    POS is the (constant) starting bit position (counted from the LSB).\n \n-   INNER may be a USE.  This will occur when we started with a bitfield\n-   that went outside the boundary of the object in memory, which is\n-   allowed on most machines.  To isolate this case, we produce a USE\n-   whose mode is wide enough and surround the MEM with it.  The only\n-   code that understands the USE is this routine.  If it is not removed,\n-   it will cause the resulting insn not to match.\n-\n    UNSIGNEDP is nonzero for an unsigned reference and zero for a\n    signed reference.\n \n@@ -5940,23 +5926,16 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      ignore the POS lowest bits, etc.  */\n   enum machine_mode is_mode = GET_MODE (inner);\n   enum machine_mode inner_mode;\n-  enum machine_mode wanted_inner_mode = byte_mode;\n+  enum machine_mode wanted_inner_mode;\n   enum machine_mode wanted_inner_reg_mode = word_mode;\n   enum machine_mode pos_mode = word_mode;\n   enum machine_mode extraction_mode = word_mode;\n   enum machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n-  int spans_byte = 0;\n   rtx new = 0;\n   rtx orig_pos_rtx = pos_rtx;\n   HOST_WIDE_INT orig_pos;\n \n-  /* Get some information about INNER and get the innermost object.  */\n-  if (GET_CODE (inner) == USE)\n-    /* (use:SI (mem:QI foo)) stands for (mem:SI foo).  */\n-    /* We don't need to adjust the position because we set up the USE\n-       to pretend that it was a full-word object.  */\n-    spans_byte = 1, inner = XEXP (inner, 0);\n-  else if (GET_CODE (inner) == SUBREG && subreg_lowpart_p (inner))\n+  if (GET_CODE (inner) == SUBREG && subreg_lowpart_p (inner))\n     {\n       /* If going from (subreg:SI (mem:QI ...)) to (mem:QI ...),\n \t consider just the QI as the memory to extract from.\n@@ -5995,14 +5974,9 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      appropriate STRICT_LOW_PART operation available.\n \n      For MEM, we can avoid an extract if the field starts on an appropriate\n-     boundary and we can change the mode of the memory reference.  However,\n-     we cannot directly access the MEM if we have a USE and the underlying\n-     MEM is not TMODE.  This combination means that MEM was being used in a\n-     context where bits outside its mode were being referenced; that is only\n-     valid in bit-field insns.  */\n+     boundary and we can change the mode of the memory reference.  */\n \n   if (tmode != BLKmode\n-      && ! (spans_byte && inner_mode != tmode)\n       && ((pos_rtx == 0 && (pos % BITS_PER_WORD) == 0\n \t   && !MEM_P (inner)\n \t   && (inner_mode == tmode\n@@ -6133,15 +6107,14 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      don't do anything with zero-extending field extracts starting at\n      the low-order bit since they are simple AND operations.  */\n   if (pos_rtx == 0 && pos == 0 && ! in_dest\n-      && ! in_compare && ! spans_byte && unsignedp)\n+      && ! in_compare && unsignedp)\n     return 0;\n \n-  /* Unless we are allowed to span bytes or INNER is not MEM, reject this if\n-     we would be spanning bytes or if the position is not a constant and the\n-     length is not 1.  In all other cases, we would only be going outside\n-     our object in cases when an original shift would have been\n-     undefined.  */\n-  if (! spans_byte && MEM_P (inner)\n+  /* Unless INNER is not MEM, reject this if we would be spanning bytes or\n+     if the position is not a constant and the length is not 1.  In all\n+     other cases, we would only be going outside our object in cases when\n+     an original shift would have been undefined.  */\n+  if (MEM_P (inner)\n       && ((pos_rtx == 0 && pos + len > GET_MODE_BITSIZE (is_mode))\n \t  || (pos_rtx != 0 && len != 1)))\n     return 0;\n@@ -6181,15 +6154,31 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       && GET_MODE_SIZE (pos_mode) < GET_MODE_SIZE (GET_MODE (pos_rtx)))\n     pos_mode = GET_MODE (pos_rtx);\n \n-  /* If this is not from memory, the desired mode is wanted_inner_reg_mode;\n-     if we have to change the mode of memory and cannot, the desired mode is\n-     EXTRACTION_MODE.  */\n+  /* If this is not from memory, the desired mode is the preferred mode\n+     for an extraction pattern's first input operand, or word_mode if there\n+     is none.  */\n   if (!MEM_P (inner))\n     wanted_inner_mode = wanted_inner_reg_mode;\n-  else if (inner_mode != wanted_inner_mode\n-\t   && (mode_dependent_address_p (XEXP (inner, 0))\n-\t       || MEM_VOLATILE_P (inner)))\n-    wanted_inner_mode = extraction_mode;\n+  else\n+    {\n+      /* Be careful not to go beyond the extracted object and maintain the\n+\t natural alignment of the memory.  */ \n+      wanted_inner_mode = smallest_mode_for_size (len, MODE_INT);\n+      while (pos % GET_MODE_BITSIZE (wanted_inner_mode) + len\n+\t     > GET_MODE_BITSIZE (wanted_inner_mode))\n+\t{\n+\t  wanted_inner_mode = GET_MODE_WIDER_MODE (wanted_inner_mode);\n+\t  gcc_assert (wanted_inner_mode != VOIDmode);\n+\t}\n+\n+      /* If we have to change the mode of memory and cannot, the desired mode\n+\t is EXTRACTION_MODE.  */\n+      if (inner_mode != wanted_inner_mode\n+\t  && (mode_dependent_address_p (XEXP (inner, 0))\n+\t      || MEM_VOLATILE_P (inner)\n+\t      || pos_rtx))\n+\twanted_inner_mode = extraction_mode;\n+    }\n \n   orig_pos = pos;\n \n@@ -6215,15 +6204,16 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t Note that it can only be less than 0 if !MEM_P (inner).  */\n     }\n \n-  /* If INNER has a wider mode, make it smaller.  If this is a constant\n-     extract, try to adjust the byte to point to the byte containing\n+  /* If INNER has a wider mode, and this is a constant extraction, try to\n+     make it smaller and adjust the byte to point to the byte containing\n      the value.  */\n   if (wanted_inner_mode != VOIDmode\n+      && inner_mode != wanted_inner_mode\n+      && ! pos_rtx\n       && GET_MODE_SIZE (wanted_inner_mode) < GET_MODE_SIZE (is_mode)\n-      && ((MEM_P (inner)\n-\t   && (inner_mode == wanted_inner_mode\n-\t       || (! mode_dependent_address_p (XEXP (inner, 0))\n-\t\t   && ! MEM_VOLATILE_P (inner))))))\n+      && MEM_P (inner)\n+      && ! mode_dependent_address_p (XEXP (inner, 0))\n+      && ! MEM_VOLATILE_P (inner))\n     {\n       int offset = 0;\n \n@@ -6234,28 +6224,20 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       /* If bytes are big endian and we had a paradoxical SUBREG, we must\n \t adjust OFFSET to compensate.  */\n       if (BYTES_BIG_ENDIAN\n-\t  && ! spans_byte\n \t  && GET_MODE_SIZE (inner_mode) < GET_MODE_SIZE (is_mode))\n \toffset -= GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (inner_mode);\n \n-      /* If this is a constant position, we can move to the desired byte.\n-\t Be careful not to go beyond the original object and maintain the\n-\t natural alignment of the memory.  */ \n-      if (pos_rtx == 0)\n-\t{\n-\t  enum machine_mode bfmode = smallest_mode_for_size (len, MODE_INT);\n-\t  offset += (pos / GET_MODE_BITSIZE (bfmode)) * GET_MODE_SIZE (bfmode);\n-\t  pos %= GET_MODE_BITSIZE (bfmode);\n-\t}\n+      /* We can now move to the desired byte.  */\n+      offset += (pos / GET_MODE_BITSIZE (wanted_inner_mode))\n+\t\t* GET_MODE_SIZE (wanted_inner_mode);\n+      pos %= GET_MODE_BITSIZE (wanted_inner_mode);\n \n       if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN\n-\t  && ! spans_byte\n \t  && is_mode != wanted_inner_mode)\n \toffset = (GET_MODE_SIZE (is_mode)\n \t\t  - GET_MODE_SIZE (wanted_inner_mode) - offset);\n \n-      if (offset != 0 || inner_mode != wanted_inner_mode)\n-\tinner = adjust_address_nv (inner, wanted_inner_mode, offset);\n+      inner = adjust_address_nv (inner, wanted_inner_mode, offset);\n     }\n \n   /* If INNER is not memory, we can always get it into the proper mode.  If we\n@@ -6886,15 +6868,6 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t generating something that won't match.  */\n       return x;\n \n-    case USE:\n-      /* X is a (use (mem ..)) that was made from a bit-field extraction that\n-\t spanned the boundary of the MEM.  If we are now masking so it is\n-\t within that boundary, we don't need the USE any more.  */\n-      if (! BITS_BIG_ENDIAN\n-\t  && (mask & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, next_select);\n-      break;\n-\n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n     case ZERO_EXTRACT:\n@@ -8688,33 +8661,6 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t    }\n \t  break;\n \n-\tcase USE:\n-\t  /* Similar to the case above, except that we can only do this if\n-\t     the resulting mode is the same as that of the underlying\n-\t     MEM and adjust the address depending on the *bits* endianness\n-\t     because of the way that bit-field extract insns are defined.  */\n-\t  if ((code == ASHIFTRT || code == LSHIFTRT)\n-\t      && (tmode = mode_for_size (GET_MODE_BITSIZE (mode) - count,\n-\t\t\t\t\t MODE_INT, 1)) != BLKmode\n-\t      && tmode == GET_MODE (XEXP (varop, 0)))\n-\t    {\n-\t      if (BITS_BIG_ENDIAN)\n-\t\tnew = XEXP (varop, 0);\n-\t      else\n-\t\t{\n-\t\t  new = copy_rtx (XEXP (varop, 0));\n-\t\t  SUBST (XEXP (new, 0),\n-\t\t\t plus_constant (XEXP (new, 0),\n-\t\t\t\t\tcount / BITS_PER_UNIT));\n-\t\t}\n-\n-\t      varop = gen_rtx_fmt_e (code == ASHIFTRT ? SIGN_EXTEND\n-\t\t\t\t     : ZERO_EXTEND, mode, new);\n-\t      count = 0;\n-\t      continue;\n-\t    }\n-\t  break;\n-\n \tcase SUBREG:\n \t  /* If VAROP is a SUBREG, strip it as long as the inner operand has\n \t     the same number of words as what we've seen so far.  Then store"}]}