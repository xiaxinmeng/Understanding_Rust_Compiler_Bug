{"sha": "7d2a98a7273c423842a3935de64b15a6d6cb33bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QyYTk4YTcyNzNjNDIzODQyYTM5MzVkZTY0YjE1YTZkNmNiMzNiYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-25T14:24:21Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-25T18:24:13Z"}, "message": "libstdc++: Encapsulate __gthread_cond_t as std::__condvar\n\nThis introduces a new internal utility, std::__condvar, which is a\nsimplified form of std::condition_variable. It has no dependency on\n<chrono> or std::unique_lock, which allows it to be used in\n<bits/atomic_wait.h>.\n\nThis avoids repeating the #ifdef __GTHREAD_COND_INIT preprocessor\nconditions and associated logic for initializing a __gthread_cond_t\ncorrectly. It also encapsulates most of the __gthread_cond_xxx functions\nas member functions of __condvar.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/atomic_timed_wait.h (__cond_wait_until_impl):\n\tDo not define when _GLIBCXX_HAVE_LINUX_FUTEX is defined. Use\n\t__condvar and mutex instead of __gthread_cond_t and\n\tunique_lock<mutex>.\n\t(__cond_wait_until): Likewise. Fix test for return value of\n\t__cond_wait_until_impl.\n\t(__timed_waiters::_M_do_wait_until): Use __condvar instead\n\tof __gthread_cond_t.\n\t* include/bits/atomic_wait.h: Remove <bits/unique_lock.h>\n\tinclude. Only include <bits/std_mutex.h> if not using futexes.\n\t(__platform_wait_max_value): Remove unused variable.\n\t(__waiters::lock_t): Use lock_guard instead of unique_lock.\n\t(__waiters::_M_cv): Use __condvar instead of __gthread_cond_t.\n\t(__waiters::_M_do_wait(__platform_wait_t)): Likewise.\n\t(__waiters::_M_notify()): Likewise. Use notify_one() if not\n\tasked to notify all.\n\t* include/bits/std_mutex.h (__condvar): New type.\n\t* include/std/condition_variable (condition_variable::_M_cond)\n\t(condition_variable::wait_until): Use __condvar instead of\n\t__gthread_cond_t.\n\t* src/c++11/condition_variable.cc (condition_variable): Define\n\tdefault constructor and destructor as defaulted.\n\t(condition_variable::wait, condition_variable::notify_one)\n\t(condition_variable::notify_all): Forward to corresponding\n\tmember function of __condvar.", "tree": {"sha": "eb05723431613f512c017bcaabb585d9855a8fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb05723431613f512c017bcaabb585d9855a8fd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d2a98a7273c423842a3935de64b15a6d6cb33bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2a98a7273c423842a3935de64b15a6d6cb33bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2a98a7273c423842a3935de64b15a6d6cb33bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2a98a7273c423842a3935de64b15a6d6cb33bc/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f76cad692a62d44ed32d010200bad74f36c73092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76cad692a62d44ed32d010200bad74f36c73092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f76cad692a62d44ed32d010200bad74f36c73092"}], "stats": {"total": 265, "additions": 144, "deletions": 121}, "files": [{"sha": "9e44114dd5b6f5200fa5ac381a136230e5d70720", "filename": "libstdc++-v3/include/bits/atomic_timed_wait.h", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h?ref=7d2a98a7273c423842a3935de64b15a6d6cb33bc", "patch": "@@ -40,6 +40,7 @@\n #include <chrono>\n \n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+#include <exception> // std::terminate\n #include <sys/time.h>\n #endif\n \n@@ -113,13 +114,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return __atomic_wait_status::timeout;\n \t  }\n       }\n-#endif\n+#else // ! FUTEX\n \n #ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n     template<typename _Duration>\n       __atomic_wait_status\n-      __cond_wait_until_impl(__gthread_cond_t* __cv,\n-\t  unique_lock<mutex>& __lock,\n+      __cond_wait_until_impl(__condvar& __cv, mutex& __mx,\n \t  const chrono::time_point<chrono::steady_clock, _Duration>& __atime)\n       {\n \tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n@@ -131,62 +131,61 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    static_cast<long>(__ns.count())\n \t  };\n \n-\tpthread_cond_clockwait(__cv, __lock.mutex()->native_handle(),\n-\t\t\t       CLOCK_MONOTONIC,\n-\t\t\t       &__ts);\n+\t__cv.wait_until(__mx, CLOCK_MONOTONIC, __ts);\n+\n \treturn (chrono::steady_clock::now() < __atime)\n \t       ? __atomic_wait_status::no_timeout\n \t       : __atomic_wait_status::timeout;\n       }\n #endif\n \n-      template<typename _Duration>\n-\t__atomic_wait_status\n-\t__cond_wait_until_impl(__gthread_cond_t* __cv,\n-\t    unique_lock<std::mutex>& __lock,\n-\t    const chrono::time_point<chrono::system_clock, _Duration>& __atime)\n+    template<typename _Duration>\n+      __atomic_wait_status\n+      __cond_wait_until_impl(__condvar& __cv, mutex& __mx,\n+\t  const chrono::time_point<chrono::system_clock, _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n \t{\n-\t  auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n-\t  auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\t  static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t  static_cast<long>(__ns.count())\n+\t};\n \n-\t  __gthread_time_t __ts =\n-\t  {\n-\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t    static_cast<long>(__ns.count())\n-\t  };\n+\t__cv.wait_until(__mx, __ts);\n \n-\t  __gthread_cond_timedwait(__cv, __lock.mutex()->native_handle(),\n-\t\t\t\t   &__ts);\n-\t  return (chrono::system_clock::now() < __atime)\n-\t\t ? __atomic_wait_status::no_timeout\n-\t\t : __atomic_wait_status::timeout;\n-\t}\n+\treturn (chrono::system_clock::now() < __atime)\n+\t       ? __atomic_wait_status::no_timeout\n+\t       : __atomic_wait_status::timeout;\n+      }\n \n-      // return true if timeout\n-      template<typename _Clock, typename _Duration>\n-\t__atomic_wait_status\n-\t__cond_wait_until(__gthread_cond_t* __cv,\n-\t    unique_lock<std::mutex>& __lock,\n-\t    const chrono::time_point<_Clock, _Duration>& __atime)\n-\t{\n+    // return true if timeout\n+    template<typename _Clock, typename _Duration>\n+      __atomic_wait_status\n+      __cond_wait_until(__condvar& __cv, mutex& __mx,\n+\t  const chrono::time_point<_Clock, _Duration>& __atime)\n+      {\n #ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n-\t  using __clock_t = chrono::steady_clock;\n+\tusing __clock_t = chrono::steady_clock;\n #else\n-\t  using __clock_t = chrono::system_clock;\n+\tusing __clock_t = chrono::system_clock;\n #endif\n-\t  const typename _Clock::time_point __c_entry = _Clock::now();\n-\t  const __clock_t::time_point __s_entry = __clock_t::now();\n-\t  const auto __delta = __atime - __c_entry;\n-\t  const auto __s_atime = __s_entry + __delta;\n-\t  if (std::__detail::__cond_wait_until_impl(__cv, __lock, __s_atime))\n-\t    return __atomic_wait_status::no_timeout;\n-\t  // We got a timeout when measured against __clock_t but\n-\t  // we need to check against the caller-supplied clock\n-\t  // to tell whether we should return a timeout.\n-\t  if (_Clock::now() < __atime)\n-\t    return __atomic_wait_status::no_timeout;\n-\t  return __atomic_wait_status::timeout;\n-\t}\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __clock_t::time_point __s_entry = __clock_t::now();\n+\tconst auto __delta = __atime - __c_entry;\n+\tconst auto __s_atime = __s_entry + __delta;\n+\tif (__detail::__cond_wait_until_impl(__cv, __mx, __s_atime)\n+\t    == __atomic_wait_status::no_timeout)\n+\t  return __atomic_wait_status::no_timeout;\n+\t// We got a timeout when measured against __clock_t but\n+\t// we need to check against the caller-supplied clock\n+\t// to tell whether we should return a timeout.\n+\tif (_Clock::now() < __atime)\n+\t  return __atomic_wait_status::no_timeout;\n+\treturn __atomic_wait_status::timeout;\n+      }\n+#endif // FUTEX\n \n     struct __timed_waiters : __waiters\n     {\n@@ -202,7 +201,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __waiters::__lock_t __l(_M_mtx);\n \t  while (__cur <= __version)\n \t    {\n-\t      if (__detail::__cond_wait_until(&_M_cv, __l, __atime)\n+\t      if (__detail::__cond_wait_until(_M_cv, _M_mtx, __atime)\n \t\t    == __atomic_wait_status::timeout)\n \t\treturn __atomic_wait_status::timeout;\n \n@@ -281,7 +280,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__reltime < __rtime)\n \t++__reltime;\n \n-\n       return __atomic_wait_until(__addr, __old, std::move(__pred),\n \t\t\t\t chrono::steady_clock::now() + __reltime);\n     }"}, {"sha": "3aaaa9aaec35b9fa7845547f43d7b7b9072cb997", "filename": "libstdc++-v3/include/bits/atomic_wait.h", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_wait.h?ref=7d2a98a7273c423842a3935de64b15a6d6cb33bc", "patch": "@@ -36,20 +36,21 @@\n #if defined _GLIBCXX_HAS_GTHREADS || _GLIBCXX_HAVE_LINUX_FUTEX\n #include <bits/functional_hash.h>\n #include <bits/gthr.h>\n-#include <bits/std_mutex.h>\n-#include <bits/unique_lock.h>\n #include <ext/numeric_traits.h>\n \n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n-#include <climits>\n-#include <unistd.h>\n-#include <syscall.h>\n+# include <cerrno>\n+# include <climits>\n+# include <unistd.h>\n+# include <syscall.h>\n+# include <bits/functexcept.h>\n+// TODO get this from Autoconf\n+# define _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE 1\n+#else\n+# include <bits/std_mutex.h>  // std::mutex, std::__condvar\n #endif\n \n \n-// TODO get this from Autoconf\n-#define _GLIBCXX_HAVE_LINUX_FUTEX_PRIVATE 1\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -60,10 +61,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     constexpr auto __atomic_spin_count_1 = 16;\n     constexpr auto __atomic_spin_count_2 = 12;\n \n-    inline constexpr\n-    auto __platform_wait_max_value =\n-\t\t__gnu_cxx::__int_traits<__platform_wait_t>::__max;\n-\n     template<typename _Tp>\n       inline constexpr bool __platform_wait_uses_type\n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n@@ -119,23 +116,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     struct __waiters\n     {\n-       alignas(64) __platform_wait_t _M_ver = 0;\n-       alignas(64) __platform_wait_t _M_wait = 0;\n+      alignas(64) __platform_wait_t _M_ver = 0;\n+      alignas(64) __platform_wait_t _M_wait = 0;\n \n #ifndef _GLIBCXX_HAVE_LINUX_FUTEX\n-      using __lock_t = std::unique_lock<std::mutex>;\n-      mutable __lock_t::mutex_type _M_mtx;\n+      using __lock_t = lock_guard<mutex>;\n+      mutex _M_mtx;\n+      __condvar _M_cv;\n \n-#  ifdef __GTHREAD_COND_INIT\n-      mutable __gthread_cond_t _M_cv = __GTHREAD_COND_INIT;\n       __waiters() noexcept = default;\n-#  else\n-      mutable __gthread_cond_t _M_cv;\n-      __waiters() noexcept\n-      {\n-\t__GTHREAD_COND_INIT_FUNCTION(&_M_cv);\n-      }\n-#  endif\n #endif\n \n       __platform_wait_t\n@@ -163,9 +152,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \twhile (__cur <= __version)\n \t  {\n \t    __waiters::__lock_t __l(_M_mtx);\n-\t    auto __e = __gthread_cond_wait(&_M_cv, __l.mutex()->native_handle());\n-\t    if (__e)\n-\t      __throw_system_error(__e);\n+\t    _M_cv.wait(_M_mtx);\n \t    __platform_wait_t __last = __cur;\n \t    __atomic_load(&_M_ver, &__cur, __ATOMIC_ACQUIRE);\n \t    if (__cur < __last)\n@@ -189,9 +176,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n \t__platform_notify(&_M_ver, __all);\n #else\n-\tauto __e = __gthread_cond_broadcast(&_M_cv);\n-\tif (__e)\n-\t  __throw_system_error(__e);\n+\tif (__all)\n+\t  _M_cv.notify_all();\n+\telse\n+\t  _M_cv.notify_one();\n #endif\n       }\n "}, {"sha": "f308bf35437ebe309efde5344b2384baf553b09b", "filename": "libstdc++-v3/include/bits/std_mutex.h", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_mutex.h?ref=7d2a98a7273c423842a3935de64b15a6d6cb33bc", "patch": "@@ -123,6 +123,76 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return &_M_mutex; }\n   };\n \n+  // Implementation details for std::condition_variable\n+  class __condvar\n+  {\n+    using timespec = __gthread_time_t;\n+\n+  public:\n+    __condvar() noexcept\n+    {\n+#ifndef __GTHREAD_COND_INIT\n+      __GTHREAD_COND_INIT_FUNCTION(&_M_cond);\n+#endif\n+    }\n+\n+    ~__condvar()\n+    {\n+      int __e __attribute__((__unused__)) = __gthread_cond_destroy(&_M_cond);\n+      __glibcxx_assert(__e != EBUSY); // threads are still blocked\n+    }\n+\n+    __condvar(const __condvar&) = delete;\n+    __condvar& operator=(const __condvar&) = delete;\n+\n+    __gthread_cond_t* native_handle() noexcept { return &_M_cond; }\n+\n+    // Expects: Calling thread has locked __m.\n+    void\n+    wait(mutex& __m) noexcept\n+    {\n+      int __e __attribute__((__unused__))\n+\t= __gthread_cond_wait(&_M_cond, __m.native_handle());\n+      __glibcxx_assert(__e == 0);\n+    }\n+\n+    void\n+    wait_until(mutex& __m, timespec& __abs_time) noexcept\n+    {\n+      __gthread_cond_timedwait(&_M_cond, __m.native_handle(), &__abs_time);\n+    }\n+\n+#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n+    void\n+    wait_until(mutex& __m, clockid_t __clock, timespec& __abs_time) noexcept\n+    {\n+      pthread_cond_clockwait(&_M_cond, __m.native_handle(), __clock,\n+\t\t\t     &__abs_time);\n+    }\n+#endif\n+\n+    void\n+    notify_one() noexcept\n+    {\n+      int __e __attribute__((__unused__)) = __gthread_cond_signal(&_M_cond);\n+      __glibcxx_assert(__e == 0);\n+    }\n+\n+    void\n+    notify_all() noexcept\n+    {\n+      int __e __attribute__((__unused__)) = __gthread_cond_broadcast(&_M_cond);\n+      __glibcxx_assert(__e == 0);\n+    }\n+\n+  protected:\n+#ifdef __GTHREAD_COND_INIT\n+    __gthread_cond_t _M_cond = __GTHREAD_COND_INIT;\n+#else\n+    __gthread_cond_t _M_cond;\n+#endif\n+  };\n+\n #endif // _GLIBCXX_HAS_GTHREADS\n \n   /// Do not acquire ownership of the mutex."}, {"sha": "5b7a9cb35a8636db38357572459363e5bb18f240", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=7d2a98a7273c423842a3935de64b15a6d6cb33bc", "patch": "@@ -74,16 +74,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #else\n     using __clock_t = system_clock;\n #endif\n-    typedef __gthread_cond_t\t\t__native_type;\n \n-#ifdef __GTHREAD_COND_INIT\n-    __native_type\t\t\t_M_cond = __GTHREAD_COND_INIT;\n-#else\n-    __native_type\t\t\t_M_cond;\n-#endif\n+    __condvar _M_cond;\n \n   public:\n-    typedef __native_type* \t\tnative_handle_type;\n+    typedef __gthread_cond_t* \t\tnative_handle_type;\n \n     condition_variable() noexcept;\n     ~condition_variable() noexcept;\n@@ -185,7 +180,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     native_handle_type\n     native_handle()\n-    { return &_M_cond; }\n+    { return _M_cond.native_handle(); }\n \n   private:\n #ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n@@ -203,9 +198,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    static_cast<long>(__ns.count())\n \t  };\n \n-\tpthread_cond_clockwait(&_M_cond, __lock.mutex()->native_handle(),\n-\t\t\t\t\t CLOCK_MONOTONIC,\n-\t\t\t\t\t &__ts);\n+\t_M_cond.wait_until(*__lock.mutex(), CLOCK_MONOTONIC, __ts);\n \n \treturn (steady_clock::now() < __atime\n \t\t? cv_status::no_timeout : cv_status::timeout);\n@@ -226,8 +219,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    static_cast<long>(__ns.count())\n \t  };\n \n-\t__gthread_cond_timedwait(&_M_cond, __lock.mutex()->native_handle(),\n-\t\t\t\t &__ts);\n+\t_M_cond.wait_until(*__lock.mutex(), __ts);\n \n \treturn (system_clock::now() < __atime\n \t\t? cv_status::no_timeout : cv_status::timeout);"}, {"sha": "92721bba3a97962c3343b10d36340341fe8be232", "filename": "libstdc++-v3/src/c++11/condition_variable.cc", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcondition_variable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d2a98a7273c423842a3935de64b15a6d6cb33bc/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcondition_variable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcondition_variable.cc?ref=7d2a98a7273c423842a3935de64b15a6d6cb33bc", "patch": "@@ -31,51 +31,26 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-#ifdef __GTHREAD_COND_INIT\n   condition_variable::condition_variable() noexcept = default;\n-#else\n-  condition_variable::condition_variable() noexcept\n-  {\n-    __GTHREAD_COND_INIT_FUNCTION(&_M_cond);\n-  }\n-#endif\n \n-  condition_variable::~condition_variable() noexcept\n-  {\n-    // XXX no thread blocked\n-    /* int __e = */ __gthread_cond_destroy(&_M_cond);\n-    // if __e == EBUSY then blocked\n-  }\n+  condition_variable::~condition_variable() noexcept = default;\n \n   void\n   condition_variable::wait(unique_lock<mutex>& __lock) noexcept\n   {\n-    int __e = __gthread_cond_wait(&_M_cond, __lock.mutex()->native_handle());\n-\n-    if (__e)\n-      std::terminate();\n+    _M_cond.wait(*__lock.mutex());\n   }\n \n   void\n   condition_variable::notify_one() noexcept\n   {\n-    int __e = __gthread_cond_signal(&_M_cond);\n-\n-    // XXX not in spec\n-    // EINVAL\n-    if (__e)\n-      __throw_system_error(__e);\n+    _M_cond.notify_one();\n   }\n \n   void\n   condition_variable::notify_all() noexcept\n   {\n-    int __e = __gthread_cond_broadcast(&_M_cond);\n-\n-    // XXX not in spec\n-    // EINVAL\n-    if (__e)\n-      __throw_system_error(__e);\n+    _M_cond.notify_all();\n   }\n \n   extern void"}]}