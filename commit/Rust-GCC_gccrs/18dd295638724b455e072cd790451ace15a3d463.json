{"sha": "18dd295638724b455e072cd790451ace15a3d463", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThkZDI5NTYzODcyNGI0NTVlMDcyY2Q3OTA0NTFhY2UxNWEzZDQ2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-17T14:38:13Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-17T14:38:13Z"}, "message": "Make ltrans type canonicals compatible with WPA ones\n\nThis patch fixes profiledbootstrap failure with LTO enabled.\nNot refining alias sets from WPA to ltrans time is a good invariant to\nmaintain and the canonical type hash behaves this way.  However I broke\nthis with the ODR logic.\n\nNormally we define canonical types for C++ ODR types according to their\ntype names.  However to make ODR types compatible with C types we check\nif structurally equivalent C type exists and if so, we ignore ODR\nnames giving up on the precision.\n\nThis however is not stable between WPA and ltrans since at ltrans the\ntype merging does not see as many types as WPA does.  To make this\nconsistent the patch makes WPA ODR_TYPE_P == 0 for ODR types that\nconflicted with non-ODR type.\n\nI had to drop one sanity check in ipa-utils.h (that I think is not very\nimportant - I added it while introducing CXX_ODR_P machinery) and also\nit now may happen that we query odr_based_tbaa_p before registering\nfirst ODR type so we do not want to ICE here.\nODR type registration happens early to produce ODR violation warings.\nThose are not done at ltrans, so dropping the registration is safe. The\ntype will still be added while computing the type inheritance graph if\nneeded for devirtualization (and late devirtualization is not very\nuseful anyway since it won't enable inlining).\n\ngcc/ChangeLog:\n\tPR bootstrap/97857\n\t* ipa-devirt.c (odr_based_tbaa_p): Do not ICE when\n\todr_hash is not initialized\n\t* ipa-utils.h (type_with_linkage_p): Do not sanity check\n\tCXX_ODR_P.\n\t* tree-streamer-out.c (pack_ts_type_common_value_fields): Set\n\tCXX_ODR_P according to the canonical type.\n\ngcc/lto/ChangeLog:\n\tPR bootstrap/97857\n\t* lto-common.c (gimple_register_canonical_type_1): Only\n\tregister types with TYPE_CXX_ODR_P flag; sanity check that no\n\tconflict happens at ltrans time.", "tree": {"sha": "a90291ffbe7e8484221855d44018859a24644880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a90291ffbe7e8484221855d44018859a24644880"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18dd295638724b455e072cd790451ace15a3d463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dd295638724b455e072cd790451ace15a3d463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18dd295638724b455e072cd790451ace15a3d463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dd295638724b455e072cd790451ace15a3d463/comments", "author": null, "committer": null, "parents": [{"sha": "8a97aed0d290bc12b91091703444546d9b3edba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a97aed0d290bc12b91091703444546d9b3edba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a97aed0d290bc12b91091703444546d9b3edba7"}], "stats": {"total": 15, "additions": 10, "deletions": 5}, "files": [{"sha": "6e6df0b2af5afe8245171427aaf4b9476e85aa0b", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dd295638724b455e072cd790451ace15a3d463/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dd295638724b455e072cd790451ace15a3d463/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=18dd295638724b455e072cd790451ace15a3d463", "patch": "@@ -2032,6 +2032,8 @@ odr_based_tbaa_p (const_tree type)\n {\n   if (!RECORD_OR_UNION_TYPE_P (type))\n     return false;\n+  if (!odr_hash)\n+    return false;\n   odr_type t = get_odr_type (const_cast <tree> (type), false);\n   if (!t || !t->tbaa_enabled)\n     return false;"}, {"sha": "91571d8e82a232aab7b04e9491cb87334bbcf9d3", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dd295638724b455e072cd790451ace15a3d463/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dd295638724b455e072cd790451ace15a3d463/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=18dd295638724b455e072cd790451ace15a3d463", "patch": "@@ -211,8 +211,6 @@ type_with_linkage_p (const_tree t)\n   if (!TYPE_CONTEXT (t))\n     return false;\n \n-  gcc_checking_assert (TREE_CODE (t) == ENUMERAL_TYPE || TYPE_CXX_ODR_P (t));\n-\n   return true;\n }\n "}, {"sha": "0a3033c369535d595aed3c34fa35d4120c808650", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dd295638724b455e072cd790451ace15a3d463/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dd295638724b455e072cd790451ace15a3d463/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=18dd295638724b455e072cd790451ace15a3d463", "patch": "@@ -415,8 +415,8 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n      that we can use to lookup structurally equivalent non-ODR type.\n      In case we decide to treat type as unique ODR type we recompute hash based\n      on name and let TBAA machinery know about our decision.  */\n-  if (RECORD_OR_UNION_TYPE_P (t)\n-      && odr_type_p (t) && !odr_type_violation_reported_p (t))\n+  if (RECORD_OR_UNION_TYPE_P (t) && odr_type_p (t)\n+      && TYPE_CXX_ODR_P (t) && !odr_type_violation_reported_p (t))\n     {\n       /* Anonymous namespace types never conflict with non-C++ types.  */\n       if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n@@ -434,6 +434,7 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n       if (slot && !TYPE_CXX_ODR_P (*(tree *)slot))\n \t{\n \t  tree nonodr = *(tree *)slot;\n+\t  gcc_checking_assert (!flag_ltrans);\n \t  if (symtab->dump_file)\n \t    {\n \t      fprintf (symtab->dump_file,"}, {"sha": "9383cc4b903cae9753b6175796655dcda8e66c9b", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dd295638724b455e072cd790451ace15a3d463/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dd295638724b455e072cd790451ace15a3d463/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=18dd295638724b455e072cd790451ace15a3d463", "patch": "@@ -343,7 +343,11 @@ pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n     {\n       bp_pack_value (bp, TYPE_TRANSPARENT_AGGR (expr), 1);\n       bp_pack_value (bp, TYPE_FINAL_P (expr), 1);\n-      bp_pack_value (bp, TYPE_CXX_ODR_P (expr), 1);\n+      /* alias_ptr_types_compatible_p relies on fact that during LTO\n+         types do not get refined from WPA time to ltrans.  */\n+      bp_pack_value (bp, flag_wpa && TYPE_CANONICAL (expr)\n+\t\t\t ? TYPE_CXX_ODR_P (TYPE_CANONICAL (expr))\n+\t\t\t : TYPE_CXX_ODR_P (expr), 1);\n     }\n   else if (TREE_CODE (expr) == ARRAY_TYPE)\n     bp_pack_value (bp, TYPE_NONALIASED_COMPONENT (expr), 1);"}]}