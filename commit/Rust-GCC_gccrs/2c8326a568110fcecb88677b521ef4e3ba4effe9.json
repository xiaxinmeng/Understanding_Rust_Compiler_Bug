{"sha": "2c8326a568110fcecb88677b521ef4e3ba4effe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4MzI2YTU2ODExMGZjZWNiODg2NzdiNTIxZWY0ZTNiYTRlZmZlOQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-12-06T10:40:53Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-12-06T10:40:53Z"}, "message": "asan.c: Remove struct tags when referring to class varpool_node.\n\n\t* asan.c: Remove struct tags when referring to class varpool_node.\n\t* cgraph.h: Likewise.\n\t* cgraphbuild.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* dbxout.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* gimple-fold.c: Likewise.\n\t* ipa-devirt.c: Likewise.\n\t* ipa-ref-inline.h: Likewise.\n\t* ipa-ref.h: Likewise.\n\t* ipa-reference.c: Likewise.\n\t* ipa-utils.c: Likewise.\n\t* ipa.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* lto-streamer.h: Likewise.\n\t* passes.c: Likewise.\n\t* toplev.c: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-emutls.c: Likewise.\n\t* tree-pass.h: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* tree-vectorizer.c: Likewise.\n\t* tree.c: Likewise.\n\t* varasm.c: Likewise.\n\t* varpool.c: Likewise.\n\n\t* cp/decl2.c: Remove struct tags when referring to class varpool_node.\n\n\t* lto/lto.c: Remove struct tags when referring to class varpool_node.\n\t* lto/lto-partition.c: Likewise.\n\t* lto/lto-symtab.c: Likewise.\n\nFrom-SVN: r205733", "tree": {"sha": "c0e9759f8814e01c08b304350c8e577840c81f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0e9759f8814e01c08b304350c8e577840c81f77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c8326a568110fcecb88677b521ef4e3ba4effe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8326a568110fcecb88677b521ef4e3ba4effe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8326a568110fcecb88677b521ef4e3ba4effe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8326a568110fcecb88677b521ef4e3ba4effe9/comments", "author": null, "committer": null, "parents": [{"sha": "6a5ac314de999025863ed86335d57dd640597577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a5ac314de999025863ed86335d57dd640597577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a5ac314de999025863ed86335d57dd640597577"}], "stats": {"total": 350, "additions": 195, "deletions": 155}, "files": [{"sha": "2bb33efab5d64c2f4ce474b98b1833560b36412e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -1,3 +1,32 @@\n+2013-12-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* asan.c: Remove struct tags when referring to class varpool_node.\n+\t* cgraph.h: Likewise.\n+\t* cgraphbuild.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* gimple-fold.c: Likewise.\n+\t* ipa-devirt.c: Likewise.\n+\t* ipa-ref-inline.h: Likewise.\n+\t* ipa-ref.h: Likewise.\n+\t* ipa-reference.c: Likewise.\n+\t* ipa-utils.c: Likewise.\n+\t* ipa.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* lto-streamer.h: Likewise.\n+\t* passes.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-emutls.c: Likewise.\n+\t* tree-pass.h: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* tree-vectorizer.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* varpool.c: Likewise.\n+\n 2013-12-06  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* cgraphunit.c: Remove struct tags when referring to class"}, {"sha": "b767782cf11d1517560f0664b774e4b3d89f9f58", "filename": "gcc/asan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -1632,7 +1632,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t{\n \t  /* For static vars if they are known not to be dynamically\n \t     initialized, they will be always accessible.  */\n-\t  struct varpool_node *vnode = varpool_get_node (inner);\n+\t  varpool_node *vnode = varpool_get_node (inner);\n \t  if (vnode && !vnode->dynamically_initialized)\n \t    return;\n \t}\n@@ -2212,7 +2212,7 @@ asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n \t\t\t  fold_convert (const_ptr_type_node, str_cst));\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  fold_convert (const_ptr_type_node, module_name_cst));\n-  struct varpool_node *vnode = varpool_get_node (decl);\n+  varpool_node *vnode = varpool_get_node (decl);\n   int has_dynamic_init = vnode ? vnode->dynamically_initialized : 0;\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  build_int_cst (uptr, has_dynamic_init));\n@@ -2378,7 +2378,7 @@ static GTY(()) tree asan_ctor_statements;\n void\n asan_finish_file (void)\n {\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n   unsigned HOST_WIDE_INT gcount = 0;\n \n   if (shadow_ptr_types[0] == NULL_TREE)"}, {"sha": "d9071f28070eb50e7ab2d4d96f41e8a713903bbb", "filename": "gcc/cgraph.h", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -483,7 +483,8 @@ struct cgraph_node_set_def\n   vec<cgraph_node_ptr> nodes;\n };\n \n-typedef struct varpool_node *varpool_node_ptr;\n+class varpool_node;\n+typedef varpool_node *varpool_node_ptr;\n \n \n /* A varpool node set is a collection of varpool nodes.  A varpool node\n@@ -796,7 +797,7 @@ void cgraph_mark_address_taken_node (struct cgraph_node *);\n \n typedef void (*cgraph_edge_hook)(struct cgraph_edge *, void *);\n typedef void (*cgraph_node_hook)(struct cgraph_node *, void *);\n-typedef void (*varpool_node_hook)(struct varpool_node *, void *);\n+typedef void (*varpool_node_hook)(varpool_node *, void *);\n typedef void (*cgraph_2edge_hook)(struct cgraph_edge *, struct cgraph_edge *,\n \t\t\t\t  void *);\n typedef void (*cgraph_2node_hook)(struct cgraph_node *, struct cgraph_node *,\n@@ -910,50 +911,50 @@ void cgraph_build_static_cdtor (char which, tree body, int priority);\n \n varpool_node_set varpool_node_set_new (void);\n varpool_node_set_iterator varpool_node_set_find (varpool_node_set,\n-\t\t\t\t\t       struct varpool_node *);\n-void varpool_node_set_add (varpool_node_set, struct varpool_node *);\n-void varpool_node_set_remove (varpool_node_set, struct varpool_node *);\n+\t\t\t\t\t\t varpool_node *);\n+void varpool_node_set_add (varpool_node_set, varpool_node *);\n+void varpool_node_set_remove (varpool_node_set, varpool_node *);\n void dump_varpool_node_set (FILE *, varpool_node_set);\n void debug_varpool_node_set (varpool_node_set);\n void free_varpool_node_set (varpool_node_set);\n void ipa_discover_readonly_nonaddressable_vars (void);\n-bool varpool_externally_visible_p (struct varpool_node *);\n+bool varpool_externally_visible_p (varpool_node *);\n \n /* In predict.c  */\n bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n-struct varpool_node *varpool_create_empty_node (void);\n-struct varpool_node *varpool_node_for_decl (tree);\n-struct varpool_node *varpool_node_for_asm (tree asmname);\n-void varpool_mark_needed_node (struct varpool_node *);\n+varpool_node *varpool_create_empty_node (void);\n+varpool_node *varpool_node_for_decl (tree);\n+varpool_node *varpool_node_for_asm (tree asmname);\n+void varpool_mark_needed_node (varpool_node *);\n void debug_varpool (void);\n void dump_varpool (FILE *);\n-void dump_varpool_node (FILE *, struct varpool_node *);\n+void dump_varpool_node (FILE *, varpool_node *);\n \n void varpool_finalize_decl (tree);\n-enum availability cgraph_variable_initializer_availability (struct varpool_node *);\n+enum availability cgraph_variable_initializer_availability (varpool_node *);\n void cgraph_make_node_local (struct cgraph_node *);\n bool cgraph_node_can_be_local_p (struct cgraph_node *);\n \n \n-void varpool_remove_node (struct varpool_node *node);\n-void varpool_finalize_named_section_flags (struct varpool_node *node);\n+void varpool_remove_node (varpool_node *node);\n+void varpool_finalize_named_section_flags (varpool_node *node);\n bool varpool_output_variables (void);\n-bool varpool_assemble_decl (struct varpool_node *node);\n-void varpool_analyze_node (struct varpool_node *);\n-struct varpool_node * varpool_extra_name_alias (tree, tree);\n-struct varpool_node * varpool_create_variable_alias (tree, tree);\n+bool varpool_assemble_decl (varpool_node *node);\n+void varpool_analyze_node (varpool_node *);\n+varpool_node * varpool_extra_name_alias (tree, tree);\n+varpool_node * varpool_create_variable_alias (tree, tree);\n void varpool_reset_queue (void);\n tree ctor_for_folding (tree);\n-bool varpool_for_node_and_aliases (struct varpool_node *,\n-\t\t                   bool (*) (struct varpool_node *, void *),\n+bool varpool_for_node_and_aliases (varpool_node *,\n+\t\t                   bool (*) (varpool_node *, void *),\n \t\t\t           void *, bool);\n void varpool_add_new_variable (tree);\n void symtab_initialize_asm_name_hash (void);\n void symtab_prevail_in_asm_name_hash (symtab_node *node);\n-void varpool_remove_initializer (struct varpool_node *);\n+void varpool_remove_initializer (varpool_node *);\n \n /* In cgraph.c */\n extern void change_decl_assembler_name (tree, tree);\n@@ -967,11 +968,11 @@ cgraph (symtab_node *node)\n }\n \n /* Return varpool node for given symbol and check it is a variable.  */\n-static inline struct varpool_node *\n+static inline varpool_node *\n varpool (symtab_node *node)\n {\n   gcc_checking_assert (!node || node->type == SYMTAB_VARIABLE);\n-  return (struct varpool_node *)node;\n+  return (varpool_node *)node;\n }\n \n /* Return callgraph node for given symbol and check it is a function. */\n@@ -983,7 +984,7 @@ cgraph_get_node (const_tree decl)\n }\n \n /* Return varpool node for given symbol and check it is a function. */\n-static inline struct varpool_node *\n+static inline varpool_node *\n varpool_get_node (const_tree decl)\n {\n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n@@ -996,7 +997,7 @@ varpool_get_node (const_tree decl)\n \n \n /* Return first variable.  */\n-static inline struct varpool_node *\n+static inline varpool_node *\n varpool_first_variable (void)\n {\n   symtab_node *node;\n@@ -1007,8 +1008,8 @@ varpool_first_variable (void)\n }\n \n /* Return next variable after NODE.  */\n-static inline struct varpool_node *\n-varpool_next_variable (struct varpool_node *node)\n+static inline varpool_node *\n+varpool_next_variable (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1023,7 +1024,7 @@ varpool_next_variable (struct varpool_node *node)\n \t(node) = varpool_next_variable ((node)))\n \n /* Return first reachable static variable with initializer.  */\n-static inline struct varpool_node *\n+static inline varpool_node *\n varpool_first_static_initializer (void)\n {\n   symtab_node *node;\n@@ -1037,8 +1038,8 @@ varpool_first_static_initializer (void)\n }\n \n /* Return next reachable static variable with initializer after NODE.  */\n-static inline struct varpool_node *\n-varpool_next_static_initializer (struct varpool_node *node)\n+static inline varpool_node *\n+varpool_next_static_initializer (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1056,7 +1057,7 @@ varpool_next_static_initializer (struct varpool_node *node)\n         (node) = varpool_next_static_initializer (node))\n \n /* Return first reachable static variable with initializer.  */\n-static inline struct varpool_node *\n+static inline varpool_node *\n varpool_first_defined_variable (void)\n {\n   symtab_node *node;\n@@ -1070,8 +1071,8 @@ varpool_first_defined_variable (void)\n }\n \n /* Return next reachable static variable with initializer after NODE.  */\n-static inline struct varpool_node *\n-varpool_next_defined_variable (struct varpool_node *node)\n+static inline varpool_node *\n+varpool_next_defined_variable (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n@@ -1257,7 +1258,7 @@ vsi_next (varpool_node_set_iterator *vsi)\n }\n \n /* Return the node pointed to by VSI.  */\n-static inline struct varpool_node *\n+static inline varpool_node *\n vsi_node (varpool_node_set_iterator vsi)\n {\n   return vsi.set->nodes[vsi.index];\n@@ -1276,7 +1277,7 @@ vsi_start (varpool_node_set set)\n \n /* Return true if SET contains NODE.  */\n static inline bool\n-varpool_node_in_set_p (struct varpool_node *node, varpool_node_set set)\n+varpool_node_in_set_p (varpool_node *node, varpool_node_set set)\n {\n   varpool_node_set_iterator vsi;\n   vsi = varpool_node_set_find (set, node);\n@@ -1341,7 +1342,7 @@ cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n    if all direct calls are eliminated.  */\n \n static inline bool\n-varpool_can_remove_if_no_refs (struct varpool_node *node)\n+varpool_can_remove_if_no_refs (varpool_node *node)\n {\n   if (DECL_EXTERNAL (node->decl))\n     return true;\n@@ -1359,7 +1360,7 @@ varpool_can_remove_if_no_refs (struct varpool_node *node)\n    The magic uses are all summarized in force_output flag.  */\n \n static inline bool\n-varpool_all_refs_explicit_p (struct varpool_node *vnode)\n+varpool_all_refs_explicit_p (varpool_node *vnode)\n {\n   return (vnode->definition\n \t  && !vnode->externally_visible\n@@ -1390,8 +1391,8 @@ cgraph_alias_target (struct cgraph_node *n)\n   return dyn_cast <cgraph_node> (symtab_alias_target (n));\n }\n \n-static inline struct varpool_node *\n-varpool_alias_target (struct varpool_node *n)\n+static inline varpool_node *\n+varpool_alias_target (varpool_node *n)\n {\n   return dyn_cast <varpool_node> (symtab_alias_target (n));\n }\n@@ -1416,11 +1417,11 @@ cgraph_function_or_thunk_node (struct cgraph_node *node,\n    Do not walk through thunks.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n-static inline struct varpool_node *\n-varpool_variable_node (struct varpool_node *node,\n+static inline varpool_node *\n+varpool_variable_node (varpool_node *node,\n \t\t       enum availability *availability = NULL)\n {\n-  struct varpool_node *n;\n+  varpool_node *n;\n \n   n = dyn_cast <varpool_node> (symtab_alias_ultimate_target (node,\n \t\t\t\t\t\t\t     availability));"}, {"sha": "bd5a78dee2a908e72e0d4265d86e9a7246b06845", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n struct record_reference_ctx\n {\n   bool only_vars;\n-  struct varpool_node *varpool_node;\n+  class varpool_node *varpool_node;\n };\n \n /* Walk tree and record all calls and references to functions/variables.\n@@ -89,7 +89,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n-\t  struct varpool_node *vnode = varpool_node_for_decl (decl);\n+\t  varpool_node *vnode = varpool_node_for_decl (decl);\n \t  ipa_record_reference (ctx->varpool_node,\n \t\t\t\tvnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n@@ -128,7 +128,7 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  type = TREE_OPERAND (type, 0);\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n-\t      struct varpool_node *vnode = varpool_node_for_decl (type);\n+\t      varpool_node *vnode = varpool_node_for_decl (type);\n \t      ipa_record_reference (node,\n \t\t\t\t    vnode,\n \t\t\t\t    IPA_REF_ADDR, NULL);\n@@ -238,7 +238,7 @@ mark_address (gimple stmt, tree addr, void *data)\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n-      struct varpool_node *vnode = varpool_node_for_decl (addr);\n+      varpool_node *vnode = varpool_node_for_decl (addr);\n \n       ipa_record_reference ((symtab_node *)data,\n \t\t\t    vnode,\n@@ -267,7 +267,7 @@ mark_load (gimple stmt, tree t, void *data)\n   else if (t && TREE_CODE (t) == VAR_DECL\n \t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      struct varpool_node *vnode = varpool_node_for_decl (t);\n+      varpool_node *vnode = varpool_node_for_decl (t);\n \n       ipa_record_reference ((symtab_node *)data,\n \t\t\t    vnode,\n@@ -285,7 +285,7 @@ mark_store (gimple stmt, tree t, void *data)\n   if (t && TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      struct varpool_node *vnode = varpool_node_for_decl (t);\n+      varpool_node *vnode = varpool_node_for_decl (t);\n \n       ipa_record_reference ((symtab_node *)data,\n \t\t\t    vnode,\n@@ -426,7 +426,7 @@ void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n-  struct varpool_node *node = varpool_node_for_decl (decl);\n+  varpool_node *node = varpool_node_for_decl (decl);\n   struct record_reference_ctx ctx = {false, NULL};\n \n   ctx.varpool_node = node;"}, {"sha": "44f3afd6e4a71ca3efdbf805abcf3abcad3399f3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -737,10 +737,10 @@ process_common_attributes (tree decl)\n \n static void\n process_function_and_variable_attributes (struct cgraph_node *first,\n-                                          struct varpool_node *first_var)\n+                                          varpool_node *first_var)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n \n   for (node = cgraph_first_function (); node != first;\n        node = cgraph_next_function (node))\n@@ -813,7 +813,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n void\n varpool_finalize_decl (tree decl)\n {\n-  struct varpool_node *node = varpool_node_for_decl (decl);\n+  varpool_node *node = varpool_node_for_decl (decl);\n \n   gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n \n@@ -928,8 +928,8 @@ analyze_functions (void)\n      intermodule optimization.  */\n   static struct cgraph_node *first_analyzed;\n   struct cgraph_node *first_handled = first_analyzed;\n-  static struct varpool_node *first_analyzed_var;\n-  struct varpool_node *first_handled_var = first_analyzed_var;\n+  static varpool_node *first_analyzed_var;\n+  varpool_node *first_handled_var = first_analyzed_var;\n   struct pointer_set_t *reachable_call_targets = pointer_set_create ();\n \n   symtab_node *node;\n@@ -1891,7 +1891,7 @@ struct cgraph_order_sort\n   union\n   {\n     struct cgraph_node *f;\n-    struct varpool_node *v;\n+    varpool_node *v;\n     struct asm_node *a;\n   } u;\n };\n@@ -1909,7 +1909,7 @@ output_in_order (void)\n   struct cgraph_order_sort *nodes;\n   int i;\n   struct cgraph_node *pf;\n-  struct varpool_node *pv;\n+  varpool_node *pv;\n   struct asm_node *pa;\n \n   max = symtab_order;"}, {"sha": "e6828716e0dcd422e1d56fcb96a84f83f7affcd8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -1,3 +1,7 @@\n+2013-12-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* decl2.c: Remove struct tags when referring to class varpool_node.\n+\n 2013-12-05  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/59044"}, {"sha": "e5b98b13a363ba263120482b683b142051fefdae", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -1749,7 +1749,7 @@ maybe_make_one_only (tree decl)\n \n       if (VAR_P (decl))\n \t{\n-          struct varpool_node *node = varpool_node_for_decl (decl);\n+          varpool_node *node = varpool_node_for_decl (decl);\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n           node->forced_by_abi = true;\n@@ -1871,7 +1871,7 @@ mark_needed (tree decl)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      struct varpool_node *node = varpool_node_for_decl (decl);\n+      varpool_node *node = varpool_node_for_decl (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->forced_by_abi = true;\n@@ -1920,7 +1920,7 @@ maybe_emit_vtables (tree ctype)\n   tree vtbl;\n   tree primary_vtbl;\n   int needed = 0;\n-  struct varpool_node *current = NULL, *last = NULL;\n+  varpool_node *current = NULL, *last = NULL;\n \n   /* If the vtables for this class have already been emitted there is\n      nothing more to do.  */\n@@ -3466,7 +3466,7 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n \t  finish_expr_stmt (init);\n \t  if (flag_sanitize & SANITIZE_ADDRESS)\n \t    {\n-\t      struct varpool_node *vnode = varpool_get_node (decl);\n+\t      varpool_node *vnode = varpool_get_node (decl);\n \t      if (vnode)\n \t\tvnode->dynamically_initialized = 1;\n \t    }"}, {"sha": "6205472d7ebabf4beff6b72456dc399d6bf11305", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -2481,7 +2481,7 @@ dbxout_expand_expr (tree expr)\n \t  /* If this is a var that might not be actually output,\n \t     return NULL, otherwise stabs might reference an undefined\n \t     symbol.  */\n-\t  struct varpool_node *node = varpool_get_node (expr);\n+\t  varpool_node *node = varpool_get_node (expr);\n \t  if (!node || !node->definition)\n \t    return NULL;\n \t}"}, {"sha": "7a499ae545ec1aaaa028483fd1be6415782d81ca", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -15148,7 +15148,7 @@ reference_to_unused (tree * tp, int * walk_subtrees,\n     return *tp;\n   else if (TREE_CODE (*tp) == VAR_DECL)\n     {\n-      struct varpool_node *node = varpool_get_node (*tp);\n+      varpool_node *node = varpool_get_node (*tp);\n       if (!node || !node->definition)\n \treturn *tp;\n     }\n@@ -17828,7 +17828,7 @@ premark_types_used_by_global_vars_helper (void **slot,\n     {\n       /* Ask cgraph if the global variable really is to be emitted.\n          If yes, then we'll keep the DIE of ENTRY->TYPE.  */\n-      struct varpool_node *node = varpool_get_node (entry->var_decl);\n+      varpool_node *node = varpool_get_node (entry->var_decl);\n       if (node && node->definition)\n \t{\n \t  die->die_perennial_p = 1;"}, {"sha": "1705394951126c3f9fd46c2299afe1d556126c88", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -77,7 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n static bool\n can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n {\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n   struct cgraph_node *node;\n   symtab_node *snode;\n "}, {"sha": "c1f8d8792259543899c81371d76d0b4f7b426b92", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -653,7 +653,7 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n       if (!flag_ltrans && anonymous)\n \t{\n \t  tree vtable = BINFO_VTABLE (inner_binfo);\n-\t  struct varpool_node *vnode;\n+\t  varpool_node *vnode;\n \n \t  if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n \t    vtable = TREE_OPERAND (TREE_OPERAND (vtable, 0), 0);\n@@ -1144,7 +1144,7 @@ record_targets_from_bases (tree otr_type,\n /* When virtual table is removed, we may need to flush the cache.  */\n \n static void\n-devirt_variable_node_removal_hook (struct varpool_node *n,\n+devirt_variable_node_removal_hook (varpool_node *n,\n \t\t\t\t   void *d ATTRIBUTE_UNUSED)\n {\n   if (cached_polymorphic_call_targets"}, {"sha": "83901518e53aadee36c5507d5ae79d33a8a3fefb", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -27,7 +27,7 @@ ipa_ref_node (struct ipa_ref *ref)\n \n /* Return varpool node REF is referring.  */\n \n-static inline struct varpool_node *\n+static inline varpool_node *\n ipa_ref_varpool_node (struct ipa_ref *ref)\n {\n   return varpool (ref->referred);\n@@ -43,7 +43,7 @@ ipa_ref_referring_node (struct ipa_ref *ref)\n \n /* Return varpool node REF is in.  */\n \n-static inline struct varpool_node *\n+static inline varpool_node *\n ipa_ref_referring_varpool_node (struct ipa_ref *ref)\n {\n   return varpool (ref->referring);"}, {"sha": "3daede2d6b8713277d074094cb457c7217eb4adc", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n struct cgraph_node;\n-struct varpool_node;\n+class varpool_node;\n class symtab_node;\n \n "}, {"sha": "9f3626a14c36bb333500ef99f32c4d2c1b341d07", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -667,7 +667,7 @@ static unsigned int\n propagate (void)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   int order_pos;"}, {"sha": "8f2c727a80d50ea7fab32d28ca96453a90bd301e", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -527,7 +527,7 @@ varpool_node_set_new (void)\n /* Add varpool_node NODE to varpool_node_set SET.  */\n \n void\n-varpool_node_set_add (varpool_node_set set, struct varpool_node *node)\n+varpool_node_set_add (varpool_node_set set, varpool_node *node)\n {\n   void **slot;\n \n@@ -551,11 +551,11 @@ varpool_node_set_add (varpool_node_set set, struct varpool_node *node)\n /* Remove varpool_node NODE from varpool_node_set SET.  */\n \n void\n-varpool_node_set_remove (varpool_node_set set, struct varpool_node *node)\n+varpool_node_set_remove (varpool_node_set set, varpool_node *node)\n {\n   void **slot, **last_slot;\n   int index;\n-  struct varpool_node *last_node;\n+  varpool_node *last_node;\n \n   slot = pointer_map_contains (set->map, node);\n   if (slot == NULL || !*slot)\n@@ -587,7 +587,7 @@ varpool_node_set_remove (varpool_node_set set, struct varpool_node *node)\n    is returned if NODE is not in SET.  */\n \n varpool_node_set_iterator\n-varpool_node_set_find (varpool_node_set set, struct varpool_node *node)\n+varpool_node_set_find (varpool_node_set set, varpool_node *node)\n {\n   void **slot;\n   varpool_node_set_iterator vsi;\n@@ -612,7 +612,7 @@ dump_varpool_node_set (FILE *f, varpool_node_set set)\n \n   for (iter = vsi_start (set); !vsi_end_p (iter); vsi_next (&iter))\n     {\n-      struct varpool_node *node = vsi_node (iter);\n+      varpool_node *node = vsi_node (iter);\n       fprintf (f, \" %s\", node->name ());\n     }\n   fprintf (f, \"\\n\");"}, {"sha": "1ec4b5fc3b7e62cf61e241c1a55610384dc92ee7", "filename": "gcc/ipa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -291,7 +291,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n {\n   symtab_node *first = (symtab_node *) (void *) 1;\n   struct cgraph_node *node, *next;\n-  struct varpool_node *vnode, *vnext;\n+  varpool_node *vnode, *vnext;\n   bool changed = false;\n   struct pointer_set_t *reachable = pointer_set_create ();\n   struct pointer_set_t *body_needed_for_clonning = pointer_set_create ();\n@@ -606,7 +606,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n void\n ipa_discover_readonly_nonaddressable_vars (void)\n {\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n   if (dump_file)\n     fprintf (dump_file, \"Clearing variable flags:\");\n   FOR_EACH_VARIABLE (vnode)\n@@ -663,7 +663,7 @@ address_taken_from_non_vtable_p (symtab_node *node)\n \t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       {\n-\tstruct varpool_node *node;\n+\tvarpool_node *node;\n \tif (is_a <cgraph_node> (ref->referring))\n \t  return true;\n \tnode = ipa_ref_referring_varpool_node (ref);\n@@ -801,7 +801,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n /* Return true when variable VNODE should be considered externally visible.  */\n \n bool\n-varpool_externally_visible_p (struct varpool_node *vnode)\n+varpool_externally_visible_p (varpool_node *vnode)\n {\n   if (DECL_EXTERNAL (vnode->decl))\n     return true;\n@@ -895,7 +895,7 @@ static unsigned int\n function_and_variable_visibility (bool whole_program)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n \n   /* All aliases should be procssed at this point.  */\n   gcc_checking_assert (!alias_pairs || !alias_pairs->length ());"}, {"sha": "8a2a5c8a3c9d3f1bd0f48bb377c783eb58c22bf7", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -204,7 +204,7 @@ lto_set_symtab_encoder_encode_body (lto_symtab_encoder_t encoder,\n \n bool\n lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t encoder,\n-\t\t\t\t\t struct varpool_node *node)\n+\t\t\t\t\t varpool_node *node)\n {\n   int index = lto_symtab_encoder_lookup (encoder, node);\n   if (index == LCC_NOT_FOUND)\n@@ -216,7 +216,7 @@ lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t encoder,\n \n static void\n lto_set_symtab_encoder_encode_initializer (lto_symtab_encoder_t encoder,\n-\t\t\t\t\t   struct varpool_node *node)\n+\t\t\t\t\t   varpool_node *node)\n {\n   int index = lto_symtab_encoder_lookup (encoder, node);\n   encoder->nodes[index].initializer = true;\n@@ -539,7 +539,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n    If NODE is not in SET, then NODE is a boundary.  */\n \n static void\n-lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n+lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n \t\t\t lto_symtab_encoder_t encoder)\n {\n   bool boundary_p = !lto_symtab_encoder_in_partition_p (encoder, node);\n@@ -796,15 +796,15 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n   for (lsei = lsei_start_variable_in_partition (in_encoder);\n        !lsei_end_p (lsei); lsei_next_variable_in_partition (&lsei))\n     {\n-      struct varpool_node *vnode = lsei_varpool_node (lsei);\n+      varpool_node *vnode = lsei_varpool_node (lsei);\n \n       lto_set_symtab_encoder_in_partition (encoder, vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n       add_references (encoder, &vnode->ref_list);\n       /* For proper debug info, we need to ship the origins, too.  */\n       if (DECL_ABSTRACT_ORIGIN (vnode->decl))\n \t{\n-\t  struct varpool_node *origin_node\n+\t  varpool_node *origin_node\n \t  = varpool_get_node (DECL_ABSTRACT_ORIGIN (node->decl));\n \t  lto_set_symtab_encoder_in_partition (encoder, origin_node);\n \t}\n@@ -1113,13 +1113,13 @@ input_node (struct lto_file_decl_data *file_data,\n /* Read a node from input_block IB.  TAG is the node's tag just read.\n    Return the node read or overwriten.  */\n \n-static struct varpool_node *\n+static varpool_node *\n input_varpool_node (struct lto_file_decl_data *file_data,\n \t\t    struct lto_input_block *ib)\n {\n   int decl_index;\n   tree var_decl;\n-  struct varpool_node *node;\n+  varpool_node *node;\n   struct bitpack_d bp;\n   int ref = LCC_NOT_FOUND;\n   int order;"}, {"sha": "03e7c615c14626f39183f554930a774efeeacb19", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -339,7 +339,7 @@ get_symbol_initial_value (struct output_block *ob, tree expr)\n       && initial)\n     {\n       lto_symtab_encoder_t encoder;\n-      struct varpool_node *vnode;\n+      varpool_node *vnode;\n \n       encoder = ob->decl_state->symtab_node_encoder;\n       vnode = varpool_get_node (expr);"}, {"sha": "6261eb74c4a16745dd6f85fac485809a08919166", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -886,7 +886,7 @@ void lto_set_symtab_encoder_in_partition (lto_symtab_encoder_t,\n \t\t\t\t\t  symtab_node *);\n \n bool lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t,\n-\t\t\t\t\t      struct varpool_node *);\n+\t\t\t\t\t      varpool_node *);\n void output_symtab (void);\n void input_symtab (void);\n bool referenced_from_other_partition_p (struct ipa_ref_list *,\n@@ -1081,7 +1081,7 @@ lsei_cgraph_node (lto_symtab_encoder_iterator lsei)\n }\n \n /* Return the node pointed to by LSI.  */\n-static inline struct varpool_node *\n+static inline varpool_node *\n lsei_varpool_node (lto_symtab_encoder_iterator lsei)\n {\n   return varpool (lsei.encoder->nodes[lsei.index].node);"}, {"sha": "a191fec01c2a388e9a88084a53d6b83fa7b97f8f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -1,3 +1,9 @@\n+2013-12-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* lto.c: Remove struct tags when referring to class varpool_node.\n+\t* lto-partition.c: Likewise.\n+\t* lto-symtab.c: Likewise.\n+\n 2013-11-29  Jakub Jelinek  <jakub@redhat.com>\n \t    Richard Biener  <rguenther@suse.de>\n "}, {"sha": "5b46af9d9074234207447d6c245eb26d1c48f3bb", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -408,8 +408,8 @@ node_cmp (const void *pa, const void *pb)\n static int\n varpool_node_cmp (const void *pa, const void *pb)\n {\n-  const struct varpool_node *a = *(const struct varpool_node * const *) pa;\n-  const struct varpool_node *b = *(const struct varpool_node * const *) pb;\n+  const varpool_node *a = *(const varpool_node * const *) pa;\n+  const varpool_node *b = *(const varpool_node * const *) pb;\n   return b->order - a->order;\n }\n \n@@ -457,14 +457,14 @@ lto_balanced_map (void)\n   int n_nodes = 0;\n   int n_varpool_nodes = 0, varpool_pos = 0, best_varpool_pos = 0;\n   struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n-  struct varpool_node **varpool_order = NULL;\n+  varpool_node **varpool_order = NULL;\n   int i;\n   struct cgraph_node *node;\n   int total_size = 0, best_total_size = 0;\n   int partition_size;\n   ltrans_partition partition;\n   int last_visited_node = 0;\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n   int cost = 0, internal = 0;\n   int best_n_nodes = 0, best_i = 0, best_cost =\n     INT_MAX, best_internal = 0;\n@@ -494,13 +494,13 @@ lto_balanced_map (void)\n       FOR_EACH_VARIABLE (vnode)\n \tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n \t  n_varpool_nodes++;\n-      varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n+      varpool_order = XNEWVEC (varpool_node *, n_varpool_nodes);\n \n       n_varpool_nodes = 0;\n       FOR_EACH_VARIABLE (vnode)\n \tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n \t  varpool_order[n_varpool_nodes++] = vnode;\n-      qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n+      qsort (varpool_order, n_varpool_nodes, sizeof (varpool_node *),\n \t     varpool_node_cmp);\n     }\n "}, {"sha": "ad0a37ca75c645d8f367a306d9eb9a8470fddd57", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -103,8 +103,8 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n    all edges and removing the old node.  */\n \n static void\n-lto_varpool_replace_node (struct varpool_node *vnode,\n-\t\t\t  struct varpool_node *prevailing_node)\n+lto_varpool_replace_node (varpool_node *vnode,\n+\t\t\t  varpool_node *prevailing_node)\n {\n   gcc_assert (!vnode->definition || prevailing_node->definition);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);"}, {"sha": "f322a0071d2e050529963521bbecee570424cef2", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -3314,7 +3314,7 @@ lto_main (void)\n \tdo_whole_program_analysis ();\n       else\n \t{\n-\t  struct varpool_node *vnode;\n+\t  varpool_node *vnode;\n \n \t  timevar_start (TV_PHASE_OPT_GEN);\n "}, {"sha": "f30f159813e26caf6272cd183da0ba70aac89d0b", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -2351,7 +2351,7 @@ ipa_write_summaries (void)\n {\n   lto_symtab_encoder_t encoder;\n   int i, order_pos;\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n   struct cgraph_node *node;\n   struct cgraph_node **order;\n "}, {"sha": "042da3bcc396eb90089eef17c9bf2bad3df1b795", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -390,7 +390,7 @@ wrapup_global_declaration_2 (tree decl)\n \n   if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n     {\n-      struct varpool_node *node;\n+      varpool_node *node;\n       bool needed = true;\n       node = varpool_get_node (decl);\n "}, {"sha": "67964fbab85d754c3cd22ab255b29a8bd8a31d80", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -2685,7 +2685,7 @@ tree_could_trap_p (tree expr)\n \t LTO partition.  */\n       if (DECL_WEAK (expr) && !DECL_COMDAT (expr))\n \t{\n-\t  struct varpool_node *node;\n+\t  varpool_node *node;\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n \t  node = varpool_variable_node (varpool_get_node (expr), NULL);"}, {"sha": "f0d7182254a5ddf0e07866b671be4b2c1e0c35fb", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -373,7 +373,7 @@ emutls_index (tree decl)\n static tree\n emutls_decl (tree decl)\n {\n-  struct varpool_node *var;\n+  varpool_node *var;\n   unsigned int i;\n \n   i = emutls_index (decl);\n@@ -435,7 +435,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n   addr = access_vars[index];\n   if (addr == NULL)\n     {\n-      struct varpool_node *cvar;\n+      varpool_node *cvar;\n       tree cdecl;\n       gimple x;\n \n@@ -707,10 +707,10 @@ lower_emutls_function_body (struct cgraph_node *node)\n    Callback for varpool_for_variable_and_aliases.  */\n \n static bool\n-create_emultls_var (struct varpool_node *var, void *data)\n+create_emultls_var (varpool_node *var, void *data)\n {\n   tree cdecl;\n-  struct varpool_node *cvar;\n+  varpool_node *cvar;\n \n   cdecl = new_emutls_decl (var->decl,\n \t\t\t   var->alias && var->analyzed\n@@ -743,7 +743,7 @@ create_emultls_var (struct varpool_node *var, void *data)\n static unsigned int\n ipa_lower_emutls (void)\n {\n-  struct varpool_node *var;\n+  varpool_node *var;\n   struct cgraph_node *func;\n   bool any_aliases = false;\n   tree ctor_body = NULL;"}, {"sha": "b7b43de4423db90dde7e10d296397e60c12b76ce", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -138,7 +138,7 @@ class rtl_opt_pass : public opt_pass\n   }\n };\n \n-struct varpool_node;\n+class varpool_node;\n struct cgraph_node;\n struct lto_symtab_encoder_d;\n \n@@ -171,7 +171,7 @@ class ipa_opt_pass_d : public opt_pass\n      function body via this hook.  */\n   unsigned int function_transform_todo_flags_start;\n   unsigned int (*function_transform) (struct cgraph_node *);\n-  void (*variable_transform) (struct varpool_node *);\n+  void (*variable_transform) (varpool_node *);\n \n protected:\n   ipa_opt_pass_d (const pass_data& data, gcc::context *ctxt,\n@@ -183,7 +183,7 @@ class ipa_opt_pass_d : public opt_pass\n \t\t  void (*stmt_fixup) (struct cgraph_node *, gimple *),\n \t\t  unsigned int function_transform_todo_flags_start,\n \t\t  unsigned int (*function_transform) (struct cgraph_node *),\n-\t\t  void (*variable_transform) (struct varpool_node *))\n+\t\t  void (*variable_transform) (varpool_node *))\n     : opt_pass (data, ctxt),\n       generate_summary (generate_summary),\n       write_summary (write_summary),"}, {"sha": "f2199092026e7dc6337578be772c873e4b6fc1a3", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -2913,7 +2913,7 @@ get_constraint_for_ssa_var (tree t, vec<ce_s> *results, bool address_p)\n   if (TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      struct varpool_node *node = varpool_get_node (t);\n+      varpool_node *node = varpool_get_node (t);\n       if (node && node->alias && node->analyzed)\n \t{\n \t  node = varpool_variable_node (node, NULL);\n@@ -5746,7 +5746,7 @@ create_variable_info_for (tree decl, const char *name)\n \t for it.  */\n       else\n \t{\n-\t  struct varpool_node *vnode = varpool_get_node (decl);\n+\t  varpool_node *vnode = varpool_get_node (decl);\n \n \t  /* For escaped variables initialize them from nonlocal.  */\n \t  if (!varpool_all_refs_explicit_p (vnode))\n@@ -7079,7 +7079,7 @@ static unsigned int\n ipa_pta_execute (void)\n {\n   struct cgraph_node *node;\n-  struct varpool_node *var;\n+  varpool_node *var;\n   int from;\n \n   in_ipa_mode = 1;"}, {"sha": "8eff9fd1de21a8e8e160ab48eb838092a64f8cf1", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -551,7 +551,7 @@ make_pass_slp_vectorize (gcc::context *ctxt)\n static unsigned int\n increase_alignment (void)\n {\n-  struct varpool_node *vnode;\n+  varpool_node *vnode;\n \n   vect_location = UNKNOWN_LOCATION;\n "}, {"sha": "4f9a1ea487cb1668ce832c7779ec4f12065e8ebc", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -5476,7 +5476,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n    NAMESPACE_DECLs, etc).  */\n \n static void\n-find_decls_types_in_var (struct varpool_node *v, struct free_lang_data_d *fld)\n+find_decls_types_in_var (varpool_node *v, struct free_lang_data_d *fld)\n {\n   find_decls_types (v->decl, fld);\n }\n@@ -5530,7 +5530,7 @@ static void\n free_lang_data_in_cgraph (void)\n {\n   struct cgraph_node *n;\n-  struct varpool_node *v;\n+  varpool_node *v;\n   struct free_lang_data_d fld;\n   tree t;\n   unsigned i;"}, {"sha": "5c5025ac5e64f5af615831f2c7e4a17e88dff558", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -2366,7 +2366,7 @@ mark_decl_referenced (tree decl)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      struct varpool_node *node = varpool_node_for_decl (decl);\n+      varpool_node *node = varpool_node_for_decl (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->force_output = true;\n@@ -6727,7 +6727,7 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n   if (TREE_CODE (exp) == VAR_DECL && TREE_PUBLIC (exp)\n       && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n     {\n-      struct varpool_node *vnode = varpool_get_node (exp);\n+      varpool_node *vnode = varpool_get_node (exp);\n       if (vnode && resolution_local_p (vnode->resolution))\n \tresolved_locally = true;\n       if (vnode\n@@ -6820,7 +6820,7 @@ decl_binds_to_current_def_p (tree decl)\n   if (TREE_CODE (decl) == VAR_DECL\n       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n     {\n-      struct varpool_node *vnode = varpool_get_node (decl);\n+      varpool_node *vnode = varpool_get_node (decl);\n       if (vnode\n \t  && vnode->resolution != LDPR_UNKNOWN)\n \treturn resolution_to_local_definition_p (vnode->resolution);"}, {"sha": "0f36cd139aa050f59b174dc55f4d20ac15ef5ba0", "filename": "gcc/varpool.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8326a568110fcecb88677b521ef4e3ba4effe9/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=2c8326a568110fcecb88677b521ef4e3ba4effe9", "patch": "@@ -78,7 +78,7 @@ varpool_remove_node_removal_hook (struct varpool_node_hook_list *entry)\n \n /* Call all node removal hooks.  */\n static void\n-varpool_call_node_removal_hooks (struct varpool_node *node)\n+varpool_call_node_removal_hooks (varpool_node *node)\n {\n   struct varpool_node_hook_list *entry = first_varpool_node_removal_hook;\n   while (entry)\n@@ -119,7 +119,7 @@ varpool_remove_variable_insertion_hook (struct varpool_node_hook_list *entry)\n \n /* Call all node insertion hooks.  */\n void\n-varpool_call_variable_insertion_hooks (struct varpool_node *node)\n+varpool_call_variable_insertion_hooks (varpool_node *node)\n {\n   struct varpool_node_hook_list *entry = first_varpool_variable_insertion_hook;\n   while (entry)\n@@ -131,19 +131,19 @@ varpool_call_variable_insertion_hooks (struct varpool_node *node)\n \n /* Allocate new callgraph node and insert it into basic data structures.  */\n \n-struct varpool_node *\n+varpool_node *\n varpool_create_empty_node (void)\n {   \n-  struct varpool_node *node = ggc_alloc_cleared_varpool_node ();\n+  varpool_node *node = ggc_alloc_cleared_varpool_node ();\n   node->type = SYMTAB_VARIABLE;\n   return node;\n }   \n \n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n-struct varpool_node *\n+varpool_node *\n varpool_node_for_decl (tree decl)\n {\n-  struct varpool_node *node = varpool_get_node (decl);\n+  varpool_node *node = varpool_get_node (decl);\n   gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n   if (node)\n     return node;\n@@ -156,7 +156,7 @@ varpool_node_for_decl (tree decl)\n \n /* Remove node from the varpool.  */\n void\n-varpool_remove_node (struct varpool_node *node)\n+varpool_remove_node (varpool_node *node)\n {\n   tree init;\n   varpool_call_node_removal_hooks (node);\n@@ -174,7 +174,7 @@ varpool_remove_node (struct varpool_node *node)\n \n /* Renove node initializer when it is no longer needed.  */\n void\n-varpool_remove_initializer (struct varpool_node *node)\n+varpool_remove_initializer (varpool_node *node)\n {\n   if (DECL_INITIAL (node->decl)\n       && !DECL_IN_CONSTANT_POOL (node->decl)\n@@ -192,7 +192,7 @@ varpool_remove_initializer (struct varpool_node *node)\n \n /* Dump given cgraph node.  */\n void\n-dump_varpool_node (FILE *f, struct varpool_node *node)\n+dump_varpool_node (FILE *f, varpool_node *node)\n {\n   dump_symtab_base (f, node);\n   fprintf (f, \"  Availability: %s\\n\",\n@@ -215,7 +215,7 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n void\n dump_varpool (FILE *f)\n {\n-  struct varpool_node *node;\n+  varpool_node *node;\n \n   fprintf (f, \"variable pool:\\n\\n\");\n   FOR_EACH_VARIABLE (node)\n@@ -231,7 +231,7 @@ debug_varpool (void)\n }\n \n /* Given an assembler name, lookup node.  */\n-struct varpool_node *\n+varpool_node *\n varpool_node_for_asm (tree asmname)\n {\n   if (symtab_node *node = symtab_node_for_asm (asmname))\n@@ -247,7 +247,7 @@ varpool_node_for_asm (tree asmname)\n tree\n ctor_for_folding (tree decl)\n {\n-  struct varpool_node *node, *real_node;\n+  varpool_node *node, *real_node;\n   tree real_decl;\n \n   if (TREE_CODE (decl) != VAR_DECL\n@@ -337,7 +337,7 @@ ctor_for_folding (tree decl)\n void\n varpool_add_new_variable (tree decl)\n {\n-  struct varpool_node *node;\n+  varpool_node *node;\n   varpool_finalize_decl (decl);\n   node = varpool_node_for_decl (decl);\n   varpool_call_variable_insertion_hooks (node);\n@@ -348,7 +348,7 @@ varpool_add_new_variable (tree decl)\n /* Return variable availability.  See cgraph.h for description of individual\n    return values.  */\n enum availability\n-cgraph_variable_initializer_availability (struct varpool_node *node)\n+cgraph_variable_initializer_availability (varpool_node *node)\n {\n   gcc_assert (cgraph_function_flags_ready);\n   if (!node->definition)\n@@ -376,7 +376,7 @@ cgraph_variable_initializer_availability (struct varpool_node *node)\n }\n \n void\n-varpool_analyze_node (struct varpool_node *node)\n+varpool_analyze_node (varpool_node *node)\n {\n   tree decl = node->decl;\n \n@@ -401,14 +401,14 @@ varpool_analyze_node (struct varpool_node *node)\n /* Assemble thunks and aliases associated to NODE.  */\n \n static void\n-assemble_aliases (struct varpool_node *node)\n+assemble_aliases (varpool_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n+\tvarpool_node *alias = ipa_ref_referring_varpool_node (ref);\n \tdo_assemble_alias (alias->decl,\n \t\t\t   DECL_ASSEMBLER_NAME (node->decl));\n \tassemble_aliases (alias);\n@@ -418,7 +418,7 @@ assemble_aliases (struct varpool_node *node)\n /* Output one variable, if necessary.  Return whether we output it.  */\n \n bool\n-varpool_assemble_decl (struct varpool_node *node)\n+varpool_assemble_decl (varpool_node *node)\n {\n   tree decl = node->decl;\n \n@@ -465,7 +465,7 @@ varpool_assemble_decl (struct varpool_node *node)\n    The queue is linked via AUX pointers and terminated by pointer to 1.  */\n \n static void\n-enqueue_node (struct varpool_node *node, struct varpool_node **first)\n+enqueue_node (varpool_node *node, varpool_node **first)\n {\n   if (node->aux)\n     return;\n@@ -482,8 +482,8 @@ enqueue_node (struct varpool_node *node, struct varpool_node **first)\n static void\n varpool_remove_unreferenced_decls (void)\n {\n-  struct varpool_node *next, *node;\n-  struct varpool_node *first = (struct varpool_node *)(void *)1;\n+  varpool_node *next, *node;\n+  varpool_node *first = (varpool_node *)(void *)1;\n   int i;\n   struct ipa_ref *ref;\n \n@@ -505,10 +505,10 @@ varpool_remove_unreferenced_decls (void)\n \t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n \t}\n     }\n-  while (first != (struct varpool_node *)(void *)1)\n+  while (first != (varpool_node *)(void *)1)\n     {\n       node = first;\n-      first = (struct varpool_node *)first->aux;\n+      first = (varpool_node *)first->aux;\n \n       if (node->same_comdat_group)\n \t{\n@@ -553,7 +553,7 @@ varpool_remove_unreferenced_decls (void)\n    conflicts between read-only and read-only requiring relocations\n    sections can be resolved.  */\n void\n-varpool_finalize_named_section_flags (struct varpool_node *node)\n+varpool_finalize_named_section_flags (varpool_node *node)\n {\n   if (!TREE_ASM_WRITTEN (node->decl)\n       && !node->alias\n@@ -570,7 +570,7 @@ bool\n varpool_output_variables (void)\n {\n   bool changed = false;\n-  struct varpool_node *node;\n+  varpool_node *node;\n \n   if (seen_error ())\n     return false;\n@@ -594,7 +594,7 @@ tree\n add_new_static_var (tree type)\n {\n   tree new_decl;\n-  struct varpool_node *new_node;\n+  varpool_node *new_node;\n \n   new_decl = create_tmp_var_raw (type, NULL);\n   DECL_NAME (new_decl) = create_tmp_var_name (NULL);\n@@ -613,10 +613,10 @@ add_new_static_var (tree type)\n /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n    Extra name aliases are output whenever DECL is output.  */\n \n-struct varpool_node *\n+varpool_node *\n varpool_create_variable_alias (tree alias, tree decl)\n {\n-  struct varpool_node *alias_node;\n+  varpool_node *alias_node;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n@@ -632,10 +632,10 @@ varpool_create_variable_alias (tree alias, tree decl)\n /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n    Extra name aliases are output whenever DECL is output.  */\n \n-struct varpool_node *\n+varpool_node *\n varpool_extra_name_alias (tree alias, tree decl)\n {\n-  struct varpool_node *alias_node;\n+  varpool_node *alias_node;\n \n #ifndef ASM_OUTPUT_DEF\n   /* If aliases aren't supported by the assembler, fail.  */\n@@ -659,8 +659,8 @@ varpool_extra_name_alias (tree alias, tree decl)\n    skipped. */\n \n bool\n-varpool_for_node_and_aliases (struct varpool_node *node,\n-\t\t\t      bool (*callback) (struct varpool_node *, void *),\n+varpool_for_node_and_aliases (varpool_node *node,\n+\t\t\t      bool (*callback) (varpool_node *, void *),\n \t\t\t      void *data,\n \t\t\t      bool include_overwritable)\n {\n@@ -672,7 +672,7 @@ varpool_for_node_and_aliases (struct varpool_node *node,\n   for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n+\tvarpool_node *alias = ipa_ref_referring_varpool_node (ref);\n \tif (include_overwritable\n \t    || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n           if (varpool_for_node_and_aliases (alias, callback, data,"}]}