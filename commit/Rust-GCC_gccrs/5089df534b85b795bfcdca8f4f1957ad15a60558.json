{"sha": "5089df534b85b795bfcdca8f4f1957ad15a60558", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA4OWRmNTM0Yjg1Yjc5NWJmY2RjYThmNGYxOTU3YWQxNWE2MDU1OA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-01-22T10:27:16Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-01-25T12:30:34Z"}, "message": "Restore profile reproducibility.\n\ngcc/ChangeLog:\n\n\tPR gcov-profile/98739\n\t* common.opt: Add missing sign symbol.\n\t* value-prof.c (get_nth_most_common_value): Restore handling\n\tof PROFILE_REPRODUCIBILITY_PARALLEL_RUNS and\n\tPROFILE_REPRODUCIBILITY_MULTITHREADED.\n\nlibgcc/ChangeLog:\n\n\tPR gcov-profile/98739\n\t* libgcov-merge.c (__gcov_merge_topn): Mark when merging\n\tends with a dropped counter.\n\t* libgcov.h (gcov_topn_add_value): Add return value.", "tree": {"sha": "f21b8220b0cd8cbcba3210bd32e229a3b62cacce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f21b8220b0cd8cbcba3210bd32e229a3b62cacce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5089df534b85b795bfcdca8f4f1957ad15a60558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5089df534b85b795bfcdca8f4f1957ad15a60558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5089df534b85b795bfcdca8f4f1957ad15a60558", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5089df534b85b795bfcdca8f4f1957ad15a60558/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "defc40db9e09ecceb2d71727031fe9579bce1b11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defc40db9e09ecceb2d71727031fe9579bce1b11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/defc40db9e09ecceb2d71727031fe9579bce1b11"}], "stats": {"total": 55, "additions": 41, "deletions": 14}, "files": [{"sha": "a8a2b67a99dd40cad89678344b3f92de8176c77e", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5089df534b85b795bfcdca8f4f1957ad15a60558/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5089df534b85b795bfcdca8f4f1957ad15a60558/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5089df534b85b795bfcdca8f4f1957ad15a60558", "patch": "@@ -2248,7 +2248,7 @@ Enum(profile_reproducibility) String(parallel-runs) Value(PROFILE_REPRODUCIBILIT\n EnumValue\n Enum(profile_reproducibility) String(multithreaded) Value(PROFILE_REPRODUCIBILITY_MULTITHREADED)\n \n-fprofile-reproducible\n+fprofile-reproducible=\n Common Joined RejectNegative Var(flag_profile_reproducible) Enum(profile_reproducibility) Init(PROFILE_REPRODUCIBILITY_SERIAL)\n -fprofile-reproducible=[serial|parallel-runs|multithreaded]\tControl level of reproducibility of profile gathered by -fprofile-generate.\n "}, {"sha": "3e899a39b84e4aa84579b65f2ca52c14215d1ff8", "filename": "gcc/value-prof.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5089df534b85b795bfcdca8f4f1957ad15a60558/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5089df534b85b795bfcdca8f4f1957ad15a60558/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=5089df534b85b795bfcdca8f4f1957ad15a60558", "patch": "@@ -747,8 +747,8 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, profile_probability prob,\n \n    abs (counters[0]) is the number of executions\n    for i in 0 ... TOPN-1\n-     counters[2 * i + 1] is target\n-     abs (counters[2 * i + 2]) is corresponding hitrate counter.\n+     counters[2 * i + 2] is target\n+     counters[2 * i + 3] is corresponding hitrate counter.\n \n    Value of counters[0] negative when counter became\n    full during merging and some values are lost.  */\n@@ -766,15 +766,29 @@ get_nth_most_common_value (gimple *stmt, const char *counter_type,\n   *value = 0;\n \n   gcov_type read_all = abs_hwi (hist->hvalue.counters[0]);\n+  gcov_type covered = 0;\n+  for (unsigned i = 0; i < counters; ++i)\n+    covered += hist->hvalue.counters[2 * i + 3];\n \n   gcov_type v = hist->hvalue.counters[2 * n + 2];\n   gcov_type c = hist->hvalue.counters[2 * n + 3];\n \n   if (hist->hvalue.counters[0] < 0\n-      && (flag_profile_reproducible == PROFILE_REPRODUCIBILITY_PARALLEL_RUNS\n-\t  || (flag_profile_reproducible\n-\t      == PROFILE_REPRODUCIBILITY_MULTITHREADED)))\n-    return false;\n+      && flag_profile_reproducible == PROFILE_REPRODUCIBILITY_PARALLEL_RUNS)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Histogram value dropped in %qs mode\",\n+\t\t \"-fprofile-reproducible=parallel-runs\");\n+      return false;\n+    }\n+  else if (covered != read_all\n+\t   && flag_profile_reproducible == PROFILE_REPRODUCIBILITY_MULTITHREADED)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Histogram value dropped in %qs mode\",\n+\t\t \"-fprofile-reproducible=multithreaded\");\n+      return false;\n+    }\n \n   /* Indirect calls can't be verified.  */\n   if (stmt"}, {"sha": "7db188a4f4c3c9b9d0cdde979df3f997ecca0a9c", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5089df534b85b795bfcdca8f4f1957ad15a60558/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5089df534b85b795bfcdca8f4f1957ad15a60558/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=5089df534b85b795bfcdca8f4f1957ad15a60558", "patch": "@@ -94,6 +94,9 @@ __gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n \n    -- the stored candidate on the most common value of the measured entity\n    -- counter\n+\n+   We use -TOTAL for situation when merging dropped some values.\n+   The information is used for -fprofile-reproducible flag.\n    */\n \n void\n@@ -107,17 +110,22 @@ __gcov_merge_topn (gcov_type *counters, unsigned n_counters)\n       gcov_type all = gcov_get_counter_ignore_scaling (-1);\n       gcov_type n = gcov_get_counter_ignore_scaling (-1);\n \n-      counters[GCOV_TOPN_MEM_COUNTERS * i] += all;\n+      unsigned full = all < 0;\n+      gcov_type *total = &counters[GCOV_TOPN_MEM_COUNTERS * i];\n+      *total += full ? -all : all;\n \n       for (unsigned j = 0; j < n; j++)\n \t{\n \t  gcov_type value = gcov_get_counter_target ();\n \t  gcov_type count = gcov_get_counter_ignore_scaling (-1);\n \n \t  // TODO: we should use atomic here\n-\t  gcov_topn_add_value (counters + GCOV_TOPN_MEM_COUNTERS * i, value,\n-\t\t\t       count, 0, 0);\n+\t  full |= gcov_topn_add_value (counters + GCOV_TOPN_MEM_COUNTERS * i,\n+\t\t\t\t       value, count, 0, 0);\n \t}\n+\n+      if (full)\n+\t*total = -(*total);\n     }\n }\n #endif /* L_gcov_merge_topn */"}, {"sha": "df08e882dd7db7754b9872b311fd7f9b4db92c27", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5089df534b85b795bfcdca8f4f1957ad15a60558/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5089df534b85b795bfcdca8f4f1957ad15a60558/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=5089df534b85b795bfcdca8f4f1957ad15a60558", "patch": "@@ -435,9 +435,10 @@ allocate_gcov_kvp (void)\n \n /* Add key value pair VALUE:COUNT to a top N COUNTERS.  When INCREMENT_TOTAL\n    is true, add COUNT to total of the TOP counter.  If USE_ATOMIC is true,\n-   do it in atomic way.  */\n+   do it in atomic way.  Return true when the counter is full, otherwise\n+   return false.  */\n \n-static inline void\n+static inline unsigned\n gcov_topn_add_value (gcov_type *counters, gcov_type value, gcov_type count,\n \t\t     int use_atomic, int increment_total)\n {\n@@ -453,7 +454,7 @@ gcov_topn_add_value (gcov_type *counters, gcov_type value, gcov_type count,\n       if (current_node->value == value)\n \t{\n \t  gcov_counter_add (&current_node->count, count, use_atomic);\n-\t  return;\n+\t  return 0;\n \t}\n \n       if (minimal_node == NULL\n@@ -471,12 +472,14 @@ gcov_topn_add_value (gcov_type *counters, gcov_type value, gcov_type count,\n \t  minimal_node->value = value;\n \t  minimal_node->count = count;\n \t}\n+\n+      return 1;\n     }\n   else\n     {\n       struct gcov_kvp *new_node = allocate_gcov_kvp ();\n       if (new_node == NULL)\n-\treturn;\n+\treturn 0;\n \n       new_node->value = value;\n       new_node->count = count;\n@@ -515,6 +518,8 @@ gcov_topn_add_value (gcov_type *counters, gcov_type value, gcov_type count,\n       if (success)\n \tgcov_counter_add (&counters[1], 1, use_atomic);\n     }\n+\n+  return 0;\n }\n \n #endif /* !inhibit_libc */"}]}