{"sha": "647a156710dcd42a2bccce3fcc0322f2be835cae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ3YTE1NjcxMGRjZDQyYTJiY2NjZTNmY2MwMzIyZjJiZTgzNWNhZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-07T23:35:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-07T23:35:22Z"}, "message": "dwarf2out: Split CFI construction routines into a new file.\n\nExcepting changing some functions from static to extern, this\npatch contains code motion only.  The split is not very clean\nat this point, but will be refined as CFI construction is turned\ninto its own proper pass.\n\n        * dwarf2cfi.c: New file.\n        * Makefile.in (OBJS): Add it.\n        (GTFILES): Add dwarf2cfi.c and dwarf2out.h.\n        * gengtype.c (open_base_files): Include dwarf2out.h.\n        * coretypes.h (enum var_init_status): Move from ...\n        * rtl.h: ... here.\n        * dwarf2out.c (saved_do_cfi_asm, dwarf2out_do_frame,\n        dwarf2out_do_cfi_asm, cie_cfi_vec, dwarf2out_cfi_label_num,\n        expand_builtin_dwarf_sp_column, init_return_column_size,\n        expand_builtin_init_dwarf_reg_sizes, new_cfi, add_cfi,\n        dwarf2out_cfi_label, emit_cfa_remember, any_cfis_emitted, add_fde_cfi,\n        lookup_cfa_1, lookup_cfa, cfa, cfa_store, cfa_remember, args_size,\n        old_args_size, cfa_equal_p, def_cfa_1, reg_save, initial_return_save,\n        stack_adjust_offset, barrier_args_size, compute_barrier_args_size_1,\n        compute_barrier_args_size, dwarf2out_args_size,\n        dwarf2out_stack_adjust, dwarf2out_notice_stack_adjust,\n        queued_reg_saves, reg_saved_in_data, regs_saved_in_regs,\n        compare_reg_or_pc, record_reg_saved_in_reg, last_reg_save_label,\n        queue_reg_save, dwarf2out_flush_queued_reg_saves,\n        clobbers_queued_reg_save, reg_saved_in, cfa_temp,\n        dwarf2out_frame_debug_def_cfa, dwarf2out_frame_debug_adjust_cfa,\n        dwarf2out_frame_debug_cfa_offset, dwarf2out_frame_debug_cfa_register,\n        dwarf2out_frame_debug_cfa_expression,\n        dwarf2out_frame_debug_cfa_restore,\n        dwarf2out_frame_debug_cfa_window_save, dwarf2out_frame_debug_expr,\n        dwarf2out_frame_debug, dwarf2out_frame_debug_init,\n        dwarf2out_cfi_begin_epilogue, dwarf2out_frame_debug_restore_state,\n        get_cfa_from_loc_descr): Move to dwarf2cfi.c.\n        (dw_cfi_ref, dw_fde_ref, dw_cfi_oprnd_ref, enum dw_cfi_oprnd_type,\n        dw_cfi_oprnd, dw_cfi_node, cfi_vec, dw_cfa_location, dw_fde_node,\n        dw_val_ref, dw_die_ref, const_dw_die_ref, dw_loc_descr_ref,\n        dw_loc_list_ref, enum dw_val_class, dw_vec_const, dw_val_node,\n        dw_loc_descr_node): Move to dwarf2out.h.\n        (current_fde, output_cfi_directive, build_cfa_loc, get_address_mode,\n        mem_loc_descriptor): Export.\n        (build_cfa_aligned_loc): Export.  Take CFA as a parameter.\n        (dwarf2out_frame_init): Extract CIE generation code to\n        dwarf2cfi_frame_init.\n\nFrom-SVN: r176015", "tree": {"sha": "3bcf51d09993347b70d1772680cae6220b23407b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bcf51d09993347b70d1772680cae6220b23407b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/647a156710dcd42a2bccce3fcc0322f2be835cae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647a156710dcd42a2bccce3fcc0322f2be835cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/647a156710dcd42a2bccce3fcc0322f2be835cae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647a156710dcd42a2bccce3fcc0322f2be835cae/comments", "author": null, "committer": null, "parents": [{"sha": "0771d9d750576cd36a710a1a99cdd4163efa0164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0771d9d750576cd36a710a1a99cdd4163efa0164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0771d9d750576cd36a710a1a99cdd4163efa0164"}], "stats": {"total": 6003, "additions": 3121, "deletions": 2882}, "files": [{"sha": "45836c2271e5b45f5caff292c54122c810583194", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -1,3 +1,44 @@\n+2011-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c: New file.\n+\t* Makefile.in (OBJS): Add it.\n+\t(GTFILES): Add dwarf2cfi.c and dwarf2out.h.\n+\t* gengtype.c (open_base_files): Include dwarf2out.h.\n+\t* coretypes.h (enum var_init_status): Move from ...\n+\t* rtl.h: ... here.\n+\t* dwarf2out.c (saved_do_cfi_asm, dwarf2out_do_frame,\n+\tdwarf2out_do_cfi_asm, cie_cfi_vec, dwarf2out_cfi_label_num,\n+\texpand_builtin_dwarf_sp_column, init_return_column_size,\n+\texpand_builtin_init_dwarf_reg_sizes, new_cfi, add_cfi,\n+\tdwarf2out_cfi_label, emit_cfa_remember, any_cfis_emitted, add_fde_cfi,\n+\tlookup_cfa_1, lookup_cfa, cfa, cfa_store, cfa_remember, args_size,\n+\told_args_size, cfa_equal_p, def_cfa_1, reg_save, initial_return_save,\n+\tstack_adjust_offset, barrier_args_size, compute_barrier_args_size_1,\n+\tcompute_barrier_args_size, dwarf2out_args_size,\n+\tdwarf2out_stack_adjust, dwarf2out_notice_stack_adjust,\n+\tqueued_reg_saves, reg_saved_in_data, regs_saved_in_regs,\n+\tcompare_reg_or_pc, record_reg_saved_in_reg, last_reg_save_label,\n+\tqueue_reg_save, dwarf2out_flush_queued_reg_saves,\n+\tclobbers_queued_reg_save, reg_saved_in, cfa_temp,\n+\tdwarf2out_frame_debug_def_cfa, dwarf2out_frame_debug_adjust_cfa,\n+\tdwarf2out_frame_debug_cfa_offset, dwarf2out_frame_debug_cfa_register,\n+\tdwarf2out_frame_debug_cfa_expression,\n+\tdwarf2out_frame_debug_cfa_restore,\n+\tdwarf2out_frame_debug_cfa_window_save, dwarf2out_frame_debug_expr,\n+\tdwarf2out_frame_debug, dwarf2out_frame_debug_init,\n+\tdwarf2out_cfi_begin_epilogue, dwarf2out_frame_debug_restore_state,\n+\tget_cfa_from_loc_descr): Move to dwarf2cfi.c.\n+\t(dw_cfi_ref, dw_fde_ref, dw_cfi_oprnd_ref, enum dw_cfi_oprnd_type,\n+\tdw_cfi_oprnd, dw_cfi_node, cfi_vec, dw_cfa_location, dw_fde_node,\n+\tdw_val_ref, dw_die_ref, const_dw_die_ref, dw_loc_descr_ref,\n+\tdw_loc_list_ref, enum dw_val_class, dw_vec_const, dw_val_node,\n+\tdw_loc_descr_node): Move to dwarf2out.h.\n+\t(current_fde, output_cfi_directive, build_cfa_loc, get_address_mode,\n+\tmem_loc_descriptor): Export.\n+\t(build_cfa_aligned_loc): Export.  Take CFA as a parameter.\n+\t(dwarf2out_frame_init): Extract CIE generation code to\n+\tdwarf2cfi_frame_init.\n+\n 2011-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/49660"}, {"sha": "8b4a44e7028388c3c8ce0fc5361bed4f8b821688", "filename": "gcc/Makefile.in", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -1263,6 +1263,7 @@ OBJS = \\\n \tdouble-int.o \\\n \tdse.o \\\n \tdwarf2asm.o \\\n+\tdwarf2cfi.o \\\n \tdwarf2out.o \\\n \tebitmap.o \\\n \temit-rtl.o \\\n@@ -3008,6 +3009,9 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) $(MD5_H) $(INPUT_H) $(FUNCTION_H) \\\n    $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) $(CFGLAYOUT_H) \\\n    tree-pretty-print.h $(COMMON_TARGET_H)\n+dwarf2cfi.o : dwarf2cfi.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   version.h $(RTL_H) $(FUNCTION_H) $(DWARF2_H) dwarf2asm.h dwarf2out.h \\\n+   $(GGC_H) $(TM_P_H) $(TARGET_H) $(TREE_PASS_H)\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \\\n    gt-dwarf2asm.h $(DWARF2_H) $(SPLAY_TREE_H) $(TARGET_H)\n@@ -3828,7 +3832,11 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/matrix-reorg.c \\\n-  $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n+  $(srcdir)/dbxout.c \\\n+  $(srcdir)/dwarf2out.h \\\n+  $(srcdir)/dwarf2asm.c \\\n+  $(srcdir)/dwarf2cfi.c \\\n+  $(srcdir)/dwarf2out.c \\\n   $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/dojump.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \\"}, {"sha": "45cdbbd6fd6d0eec403570f21521d41252e7f94a", "filename": "gcc/coretypes.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -136,6 +136,16 @@ enum node_frequency {\n   NODE_FREQUENCY_HOT\n };\n \n+/* Possible initialization status of a variable.   When requested\n+   by the user, this information is tracked and recorded in the DWARF\n+   debug information, along with the variable's location.  */\n+enum var_init_status\n+{\n+  VAR_INIT_STATUS_UNKNOWN,\n+  VAR_INIT_STATUS_UNINITIALIZED,\n+  VAR_INIT_STATUS_INITIALIZED\n+};\n+\n \n struct edge_def;\n typedef struct edge_def *edge;"}, {"sha": "8de13e52c0ca95dde3cf62ea5f29c7823276276d", "filename": "gcc/dwarf2cfi.c", "status": "added", "additions": 2656, "deletions": 0, "changes": 2656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -0,0 +1,2656 @@\n+/* Dwarf2 Call Frame Information helper routines.\n+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"version.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"function.h\"\n+#include \"dwarf2.h\"\n+#include \"dwarf2out.h\"\n+#include \"dwarf2asm.h\"\n+#include \"ggc.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+#include \"common/common-target.h\"\n+#include \"tree-pass.h\"\n+\n+#include \"except.h\"\t\t/* expand_builtin_dwarf_sp_column */\n+#include \"expr.h\"\t\t/* init_return_column_size */\n+#include \"regs.h\"\t\t/* expand_builtin_init_dwarf_reg_sizes */\n+#include \"output.h\"\t\t/* asm_out_file */\n+#include \"debug.h\"\t\t/* dwarf2out_do_frame, dwarf2out_do_cfi_asm */\n+\n+\n+/* ??? Poison these here until it can be done generically.  They've been\n+   totally replaced in this file; make sure it stays that way.  */\n+#undef DWARF2_UNWIND_INFO\n+#undef DWARF2_FRAME_INFO\n+#if (GCC_VERSION >= 3000)\n+ #pragma GCC poison DWARF2_UNWIND_INFO DWARF2_FRAME_INFO\n+#endif\n+\n+#ifndef INCOMING_RETURN_ADDR_RTX\n+#define INCOMING_RETURN_ADDR_RTX  (gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+/* The size of the target's pointer type.  */\n+#ifndef PTR_SIZE\n+#define PTR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n+#endif\n+\n+/* Maximum size (in bytes) of an artificially generated label.  */\n+#define MAX_ARTIFICIAL_LABEL_BYTES\t30\n+\n+/* The size of addresses as they appear in the Dwarf 2 data.\n+   Some architectures use word addresses to refer to code locations,\n+   but Dwarf 2 info always uses byte addresses.  On such machines,\n+   Dwarf 2 addresses need to be larger than the architecture's\n+   pointers.  */\n+#ifndef DWARF2_ADDR_SIZE\n+#define DWARF2_ADDR_SIZE (POINTER_SIZE / BITS_PER_UNIT)\n+#endif\n+\n+/* The size in bytes of a DWARF field indicating an offset or length\n+   relative to a debug info section, specified to be 4 bytes in the\n+   DWARF-2 specification.  The SGI/MIPS ABI defines it to be the same\n+   as PTR_SIZE.  */\n+\n+#ifndef DWARF_OFFSET_SIZE\n+#define DWARF_OFFSET_SIZE 4\n+#endif\n+\n+/* According to the (draft) DWARF 3 specification, the initial length\n+   should either be 4 or 12 bytes.  When it's 12 bytes, the first 4\n+   bytes are 0xffffffff, followed by the length stored in the next 8\n+   bytes.\n+\n+   However, the SGI/MIPS ABI uses an initial length which is equal to\n+   DWARF_OFFSET_SIZE.  It is defined (elsewhere) accordingly.  */\n+\n+#ifndef DWARF_INITIAL_LENGTH_SIZE\n+#define DWARF_INITIAL_LENGTH_SIZE (DWARF_OFFSET_SIZE == 4 ? 4 : 12)\n+#endif\n+\n+/* Round SIZE up to the nearest BOUNDARY.  */\n+#define DWARF_ROUND(SIZE,BOUNDARY) \\\n+  ((((SIZE) + (BOUNDARY) - 1) / (BOUNDARY)) * (BOUNDARY))\n+\n+/* Offsets recorded in opcodes are a multiple of this alignment factor.  */\n+#ifndef DWARF_CIE_DATA_ALIGNMENT\n+#ifdef STACK_GROWS_DOWNWARD\n+#define DWARF_CIE_DATA_ALIGNMENT (-((int) UNITS_PER_WORD))\n+#else\n+#define DWARF_CIE_DATA_ALIGNMENT ((int) UNITS_PER_WORD)\n+#endif\n+#endif\n+\n+/* CIE identifier.  */\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+#define DWARF_CIE_ID \\\n+  (unsigned HOST_WIDE_INT) (DWARF_OFFSET_SIZE == 4 ? DW_CIE_ID : DW64_CIE_ID)\n+#else\n+#define DWARF_CIE_ID DW_CIE_ID\n+#endif\n+\n+/* The DWARF 2 CFA column which tracks the return address.  Normally this\n+   is the column for PC, or the first column after all of the hard\n+   registers.  */\n+#ifndef DWARF_FRAME_RETURN_COLUMN\n+#ifdef PC_REGNUM\n+#define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGNUM (PC_REGNUM)\n+#else\n+#define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGISTERS\n+#endif\n+#endif\n+\n+/* The mapping from gcc register number to DWARF 2 CFA column number.  By\n+   default, we just provide columns for all registers.  */\n+#ifndef DWARF_FRAME_REGNUM\n+#define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)\n+#endif\n+\n+/* Map register numbers held in the call frame info that gcc has\n+   collected using DWARF_FRAME_REGNUM to those that should be output in\n+   .debug_frame and .eh_frame.  */\n+#ifndef DWARF2_FRAME_REG_OUT\n+#define DWARF2_FRAME_REG_OUT(REGNO, FOR_EH) (REGNO)\n+#endif\n+\f\n+/* A vector of call frame insns for the CIE.  */\n+cfi_vec cie_cfi_vec;\n+\n+static GTY(()) unsigned long dwarf2out_cfi_label_num;\n+\n+\f\n+/* Hook used by __throw.  */\n+\n+rtx\n+expand_builtin_dwarf_sp_column (void)\n+{\n+  unsigned int dwarf_regnum = DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM);\n+  return GEN_INT (DWARF2_FRAME_REG_OUT (dwarf_regnum, 1));\n+}\n+\n+/* MEM is a memory reference for the register size table, each element of\n+   which has mode MODE.  Initialize column C as a return address column.  */\n+\n+static void\n+init_return_column_size (enum machine_mode mode, rtx mem, unsigned int c)\n+{\n+  HOST_WIDE_INT offset = c * GET_MODE_SIZE (mode);\n+  HOST_WIDE_INT size = GET_MODE_SIZE (Pmode);\n+  emit_move_insn (adjust_address (mem, mode, offset), GEN_INT (size));\n+}\n+\n+/* Generate code to initialize the register size table.  */\n+\n+void\n+expand_builtin_init_dwarf_reg_sizes (tree address)\n+{\n+  unsigned int i;\n+  enum machine_mode mode = TYPE_MODE (char_type_node);\n+  rtx addr = expand_normal (address);\n+  rtx mem = gen_rtx_MEM (BLKmode, addr);\n+  bool wrote_return_column = false;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int rnum = DWARF2_FRAME_REG_OUT (DWARF_FRAME_REGNUM (i), 1);\n+\n+      if (rnum < DWARF_FRAME_REGISTERS)\n+\t{\n+\t  HOST_WIDE_INT offset = rnum * GET_MODE_SIZE (mode);\n+\t  enum machine_mode save_mode = reg_raw_mode[i];\n+\t  HOST_WIDE_INT size;\n+\n+\t  if (HARD_REGNO_CALL_PART_CLOBBERED (i, save_mode))\n+\t    save_mode = choose_hard_reg_mode (i, 1, true);\n+\t  if (DWARF_FRAME_REGNUM (i) == DWARF_FRAME_RETURN_COLUMN)\n+\t    {\n+\t      if (save_mode == VOIDmode)\n+\t\tcontinue;\n+\t      wrote_return_column = true;\n+\t    }\n+\t  size = GET_MODE_SIZE (save_mode);\n+\t  if (offset < 0)\n+\t    continue;\n+\n+\t  emit_move_insn (adjust_address (mem, mode, offset),\n+\t\t\t  gen_int_mode (size, mode));\n+\t}\n+    }\n+\n+  if (!wrote_return_column)\n+    init_return_column_size (mode, mem, DWARF_FRAME_RETURN_COLUMN);\n+\n+#ifdef DWARF_ALT_FRAME_RETURN_COLUMN\n+  init_return_column_size (mode, mem, DWARF_ALT_FRAME_RETURN_COLUMN);\n+#endif\n+\n+  targetm.init_dwarf_reg_sizes_extra (address);\n+}\n+\n+/* Divide OFF by DWARF_CIE_DATA_ALIGNMENT, asserting no remainder.  */\n+\n+static inline HOST_WIDE_INT\n+div_data_align (HOST_WIDE_INT off)\n+{\n+  HOST_WIDE_INT r = off / DWARF_CIE_DATA_ALIGNMENT;\n+  gcc_assert (r * DWARF_CIE_DATA_ALIGNMENT == off);\n+  return r;\n+}\n+\n+/* Return true if we need a signed version of a given opcode\n+   (e.g. DW_CFA_offset_extended_sf vs DW_CFA_offset_extended).  */\n+\n+static inline bool\n+need_data_align_sf_opcode (HOST_WIDE_INT off)\n+{\n+  return DWARF_CIE_DATA_ALIGNMENT < 0 ? off > 0 : off < 0;\n+}\n+\n+/* Return a pointer to a newly allocated Call Frame Instruction.  */\n+\n+static inline dw_cfi_ref\n+new_cfi (void)\n+{\n+  dw_cfi_ref cfi = ggc_alloc_dw_cfi_node ();\n+\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n+  cfi->dw_cfi_oprnd2.dw_cfi_reg_num = 0;\n+\n+  return cfi;\n+}\n+\n+/* Add a Call Frame Instruction to list of instructions.  */\n+\n+static inline void\n+add_cfi (cfi_vec *vec, dw_cfi_ref cfi)\n+{\n+  dw_fde_ref fde = current_fde ();\n+\n+  /* When DRAP is used, CFA is defined with an expression.  Redefine\n+     CFA may lead to a different CFA value.   */\n+  /* ??? Of course, this heuristic fails when we're annotating epilogues,\n+     because of course we'll always want to redefine the CFA back to the\n+     stack pointer on the way out.  Where should we move this check?  */\n+  if (0 && fde && fde->drap_reg != INVALID_REGNUM)\n+    switch (cfi->dw_cfi_opc)\n+      {\n+      case DW_CFA_def_cfa_register:\n+      case DW_CFA_def_cfa_offset:\n+      case DW_CFA_def_cfa_offset_sf:\n+      case DW_CFA_def_cfa:\n+      case DW_CFA_def_cfa_sf:\n+\tgcc_unreachable ();\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  VEC_safe_push (dw_cfi_ref, gc, *vec, cfi);\n+}\n+\n+/* Generate a new label for the CFI info to refer to.  FORCE is true\n+   if a label needs to be output even when using .cfi_* directives.  */\n+\n+static char *\n+dwarf2out_cfi_label (bool force)\n+{\n+  static char label[20];\n+\n+  if (!force && dwarf2out_do_cfi_asm ())\n+    {\n+      /* In this case, we will be emitting the asm directive instead of\n+\t the label, so just return a placeholder to keep the rest of the\n+\t interfaces happy.  */\n+      strcpy (label, \"<do not output>\");\n+    }\n+  else\n+    {\n+      int num = dwarf2out_cfi_label_num++;\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", num);\n+      ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LCFI\", num);\n+    }\n+\n+  return label;\n+}\n+\n+/* True if remember_state should be emitted before following CFI directive.  */\n+static bool emit_cfa_remember;\n+\n+/* True if any CFI directives were emitted at the current insn.  */\n+static bool any_cfis_emitted;\n+\n+/* Add CFI to the current fde at the PC value indicated by LABEL if specified,\n+   or to the CIE if LABEL is NULL.  */\n+\n+static void\n+add_fde_cfi (const char *label, dw_cfi_ref cfi)\n+{\n+  cfi_vec *vec;\n+\n+  if (cie_cfi_vec == NULL)\n+    cie_cfi_vec = VEC_alloc (dw_cfi_ref, gc, 20);\n+\n+  vec = &cie_cfi_vec;\n+\n+  if (emit_cfa_remember)\n+    {\n+      dw_cfi_ref cfi_remember;\n+\n+      /* Emit the state save.  */\n+      emit_cfa_remember = false;\n+      cfi_remember = new_cfi ();\n+      cfi_remember->dw_cfi_opc = DW_CFA_remember_state;\n+      add_fde_cfi (label, cfi_remember);\n+    }\n+\n+  if (dwarf2out_do_cfi_asm ())\n+    {\n+      if (label)\n+\t{\n+\t  dw_fde_ref fde = current_fde ();\n+\n+\t  gcc_assert (fde != NULL);\n+\n+\t  /* We still have to add the cfi to the list so that lookup_cfa\n+\t     works later on.  When -g2 and above we even need to force\n+\t     emitting of CFI labels and add to list a DW_CFA_set_loc for\n+\t     convert_cfa_to_fb_loc_list purposes.  If we're generating\n+\t     DWARF3 output we use DW_OP_call_frame_cfa and so don't use\n+\t     convert_cfa_to_fb_loc_list.  */\n+\t  if (dwarf_version == 2\n+\t      && debug_info_level > DINFO_LEVEL_TERSE\n+\t      && (write_symbols == DWARF2_DEBUG\n+\t\t  || write_symbols == VMS_AND_DWARF2_DEBUG))\n+\t    {\n+\t      switch (cfi->dw_cfi_opc)\n+\t\t{\n+\t\tcase DW_CFA_def_cfa_offset:\n+\t\tcase DW_CFA_def_cfa_offset_sf:\n+\t\tcase DW_CFA_def_cfa_register:\n+\t\tcase DW_CFA_def_cfa:\n+\t\tcase DW_CFA_def_cfa_sf:\n+\t\tcase DW_CFA_def_cfa_expression:\n+\t\tcase DW_CFA_restore_state:\n+\t\t  if (*label == 0 || strcmp (label, \"<do not output>\") == 0)\n+\t\t    label = dwarf2out_cfi_label (true);\n+\n+\t\t  if (fde->dw_fde_current_label == NULL\n+\t\t      || strcmp (label, fde->dw_fde_current_label) != 0)\n+\t\t    {\n+\t\t      dw_cfi_ref xcfi;\n+\n+\t\t      label = xstrdup (label);\n+\n+\t\t      /* Set the location counter to the new label.  */\n+\t\t      xcfi = new_cfi ();\n+\t\t      /* It doesn't metter whether DW_CFA_set_loc\n+\t\t         or DW_CFA_advance_loc4 is added here, those aren't\n+\t\t         emitted into assembly, only looked up by\n+\t\t         convert_cfa_to_fb_loc_list.  */\n+\t\t      xcfi->dw_cfi_opc = DW_CFA_set_loc;\n+\t\t      xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n+\t\t      add_cfi (&fde->dw_fde_cfi, xcfi);\n+\t\t      fde->dw_fde_current_label = label;\n+\t\t    }\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t        }\n+\t    }\n+\n+\t  output_cfi_directive (cfi);\n+\n+\t  vec = &fde->dw_fde_cfi;\n+\t  any_cfis_emitted = true;\n+\t}\n+      /* ??? If this is a CFI for the CIE, we don't emit.  This\n+\t assumes that the standard CIE contents that the assembler\n+\t uses matches the standard CIE contents that the compiler\n+\t uses.  This is probably a bad assumption.  I'm not quite\n+\t sure how to address this for now.  */\n+    }\n+  else if (label)\n+    {\n+      dw_fde_ref fde = current_fde ();\n+\n+      gcc_assert (fde != NULL);\n+\n+      if (*label == 0)\n+\tlabel = dwarf2out_cfi_label (false);\n+\n+      if (fde->dw_fde_current_label == NULL\n+\t  || strcmp (label, fde->dw_fde_current_label) != 0)\n+\t{\n+\t  dw_cfi_ref xcfi;\n+\n+\t  label = xstrdup (label);\n+\n+\t  /* Set the location counter to the new label.  */\n+\t  xcfi = new_cfi ();\n+\t  /* If we have a current label, advance from there, otherwise\n+\t     set the location directly using set_loc.  */\n+\t  xcfi->dw_cfi_opc = fde->dw_fde_current_label\n+\t\t\t     ? DW_CFA_advance_loc4\n+\t\t\t     : DW_CFA_set_loc;\n+\t  xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n+\t  add_cfi (&fde->dw_fde_cfi, xcfi);\n+\n+\t  fde->dw_fde_current_label = label;\n+\t}\n+\n+      vec = &fde->dw_fde_cfi;\n+      any_cfis_emitted = true;\n+    }\n+\n+  add_cfi (vec, cfi);\n+}\n+\n+/* This function fills in aa dw_cfa_location structure from a dwarf location\n+   descriptor sequence.  */\n+\n+static void\n+get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_struct *loc)\n+{\n+  struct dw_loc_descr_struct *ptr;\n+  cfa->offset = 0;\n+  cfa->base_offset = 0;\n+  cfa->indirect = 0;\n+  cfa->reg = -1;\n+\n+  for (ptr = loc; ptr != NULL; ptr = ptr->dw_loc_next)\n+    {\n+      enum dwarf_location_atom op = ptr->dw_loc_opc;\n+\n+      switch (op)\n+\t{\n+\tcase DW_OP_reg0:\n+\tcase DW_OP_reg1:\n+\tcase DW_OP_reg2:\n+\tcase DW_OP_reg3:\n+\tcase DW_OP_reg4:\n+\tcase DW_OP_reg5:\n+\tcase DW_OP_reg6:\n+\tcase DW_OP_reg7:\n+\tcase DW_OP_reg8:\n+\tcase DW_OP_reg9:\n+\tcase DW_OP_reg10:\n+\tcase DW_OP_reg11:\n+\tcase DW_OP_reg12:\n+\tcase DW_OP_reg13:\n+\tcase DW_OP_reg14:\n+\tcase DW_OP_reg15:\n+\tcase DW_OP_reg16:\n+\tcase DW_OP_reg17:\n+\tcase DW_OP_reg18:\n+\tcase DW_OP_reg19:\n+\tcase DW_OP_reg20:\n+\tcase DW_OP_reg21:\n+\tcase DW_OP_reg22:\n+\tcase DW_OP_reg23:\n+\tcase DW_OP_reg24:\n+\tcase DW_OP_reg25:\n+\tcase DW_OP_reg26:\n+\tcase DW_OP_reg27:\n+\tcase DW_OP_reg28:\n+\tcase DW_OP_reg29:\n+\tcase DW_OP_reg30:\n+\tcase DW_OP_reg31:\n+\t  cfa->reg = op - DW_OP_reg0;\n+\t  break;\n+\tcase DW_OP_regx:\n+\t  cfa->reg = ptr->dw_loc_oprnd1.v.val_int;\n+\t  break;\n+\tcase DW_OP_breg0:\n+\tcase DW_OP_breg1:\n+\tcase DW_OP_breg2:\n+\tcase DW_OP_breg3:\n+\tcase DW_OP_breg4:\n+\tcase DW_OP_breg5:\n+\tcase DW_OP_breg6:\n+\tcase DW_OP_breg7:\n+\tcase DW_OP_breg8:\n+\tcase DW_OP_breg9:\n+\tcase DW_OP_breg10:\n+\tcase DW_OP_breg11:\n+\tcase DW_OP_breg12:\n+\tcase DW_OP_breg13:\n+\tcase DW_OP_breg14:\n+\tcase DW_OP_breg15:\n+\tcase DW_OP_breg16:\n+\tcase DW_OP_breg17:\n+\tcase DW_OP_breg18:\n+\tcase DW_OP_breg19:\n+\tcase DW_OP_breg20:\n+\tcase DW_OP_breg21:\n+\tcase DW_OP_breg22:\n+\tcase DW_OP_breg23:\n+\tcase DW_OP_breg24:\n+\tcase DW_OP_breg25:\n+\tcase DW_OP_breg26:\n+\tcase DW_OP_breg27:\n+\tcase DW_OP_breg28:\n+\tcase DW_OP_breg29:\n+\tcase DW_OP_breg30:\n+\tcase DW_OP_breg31:\n+\t  cfa->reg = op - DW_OP_breg0;\n+\t  cfa->base_offset = ptr->dw_loc_oprnd1.v.val_int;\n+\t  break;\n+\tcase DW_OP_bregx:\n+\t  cfa->reg = ptr->dw_loc_oprnd1.v.val_int;\n+\t  cfa->base_offset = ptr->dw_loc_oprnd2.v.val_int;\n+\t  break;\n+\tcase DW_OP_deref:\n+\t  cfa->indirect = 1;\n+\t  break;\n+\tcase DW_OP_plus_uconst:\n+\t  cfa->offset = ptr->dw_loc_oprnd1.v.val_unsigned;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+/* Subroutine of lookup_cfa.  */\n+\n+void\n+lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n+{\n+  switch (cfi->dw_cfi_opc)\n+    {\n+    case DW_CFA_def_cfa_offset:\n+    case DW_CFA_def_cfa_offset_sf:\n+      loc->offset = cfi->dw_cfi_oprnd1.dw_cfi_offset;\n+      break;\n+    case DW_CFA_def_cfa_register:\n+      loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      break;\n+    case DW_CFA_def_cfa:\n+    case DW_CFA_def_cfa_sf:\n+      loc->reg = cfi->dw_cfi_oprnd1.dw_cfi_reg_num;\n+      loc->offset = cfi->dw_cfi_oprnd2.dw_cfi_offset;\n+      break;\n+    case DW_CFA_def_cfa_expression:\n+      get_cfa_from_loc_descr (loc, cfi->dw_cfi_oprnd1.dw_cfi_loc);\n+      break;\n+\n+    case DW_CFA_remember_state:\n+      gcc_assert (!remember->in_use);\n+      *remember = *loc;\n+      remember->in_use = 1;\n+      break;\n+    case DW_CFA_restore_state:\n+      gcc_assert (remember->in_use);\n+      *loc = *remember;\n+      remember->in_use = 0;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Find the previous value for the CFA.  */\n+\n+static void\n+lookup_cfa (dw_cfa_location *loc)\n+{\n+  int ix;\n+  dw_cfi_ref cfi;\n+  dw_fde_ref fde;\n+  dw_cfa_location remember;\n+\n+  memset (loc, 0, sizeof (*loc));\n+  loc->reg = INVALID_REGNUM;\n+  remember = *loc;\n+\n+  FOR_EACH_VEC_ELT (dw_cfi_ref, cie_cfi_vec, ix, cfi)\n+    lookup_cfa_1 (cfi, loc, &remember);\n+\n+  fde = current_fde ();\n+  if (fde)\n+    FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n+      lookup_cfa_1 (cfi, loc, &remember);\n+}\n+\n+/* The current rule for calculating the DWARF2 canonical frame address.  */\n+static dw_cfa_location cfa;\n+\n+/* The register used for saving registers to the stack, and its offset\n+   from the CFA.  */\n+static dw_cfa_location cfa_store;\n+\n+/* The current save location around an epilogue.  */\n+static dw_cfa_location cfa_remember;\n+\n+/* The running total of the size of arguments pushed onto the stack.  */\n+static HOST_WIDE_INT args_size;\n+\n+/* The last args_size we actually output.  */\n+static HOST_WIDE_INT old_args_size;\n+\n+/* Determine if two dw_cfa_location structures define the same data.  */\n+\n+bool\n+cfa_equal_p (const dw_cfa_location *loc1, const dw_cfa_location *loc2)\n+{\n+  return (loc1->reg == loc2->reg\n+\t  && loc1->offset == loc2->offset\n+\t  && loc1->indirect == loc2->indirect\n+\t  && (loc1->indirect == 0\n+\t      || loc1->base_offset == loc2->base_offset));\n+}\n+\n+/* This routine does the actual work.  The CFA is now calculated from\n+   the dw_cfa_location structure.  */\n+\n+static void\n+def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n+{\n+  dw_cfi_ref cfi;\n+  dw_cfa_location old_cfa, loc;\n+\n+  cfa = *loc_p;\n+  loc = *loc_p;\n+\n+  if (cfa_store.reg == loc.reg && loc.indirect == 0)\n+    cfa_store.offset = loc.offset;\n+\n+  loc.reg = DWARF_FRAME_REGNUM (loc.reg);\n+  lookup_cfa (&old_cfa);\n+\n+  /* If nothing changed, no need to issue any call frame instructions.  */\n+  if (cfa_equal_p (&loc, &old_cfa))\n+    return;\n+\n+  cfi = new_cfi ();\n+\n+  if (loc.reg == old_cfa.reg && !loc.indirect && !old_cfa.indirect)\n+    {\n+      /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction, indicating\n+\t the CFA register did not change but the offset did.  The data\n+\t factoring for DW_CFA_def_cfa_offset_sf happens in output_cfi, or\n+\t in the assembler via the .cfi_def_cfa_offset directive.  */\n+      if (loc.offset < 0)\n+\tcfi->dw_cfi_opc = DW_CFA_def_cfa_offset_sf;\n+      else\n+\tcfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n+      cfi->dw_cfi_oprnd1.dw_cfi_offset = loc.offset;\n+    }\n+\n+#ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n+  else if (loc.offset == old_cfa.offset\n+\t   && old_cfa.reg != INVALID_REGNUM\n+\t   && !loc.indirect\n+\t   && !old_cfa.indirect)\n+    {\n+      /* Construct a \"DW_CFA_def_cfa_register <register>\" instruction,\n+\t indicating the CFA register has changed to <register> but the\n+\t offset has not changed.  */\n+      cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n+    }\n+#endif\n+\n+  else if (loc.indirect == 0)\n+    {\n+      /* Construct a \"DW_CFA_def_cfa <register> <offset>\" instruction,\n+\t indicating the CFA register has changed to <register> with\n+\t the specified offset.  The data factoring for DW_CFA_def_cfa_sf\n+\t happens in output_cfi, or in the assembler via the .cfi_def_cfa\n+\t directive.  */\n+      if (loc.offset < 0)\n+\tcfi->dw_cfi_opc = DW_CFA_def_cfa_sf;\n+      else\n+\tcfi->dw_cfi_opc = DW_CFA_def_cfa;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n+      cfi->dw_cfi_oprnd2.dw_cfi_offset = loc.offset;\n+    }\n+  else\n+    {\n+      /* Construct a DW_CFA_def_cfa_expression instruction to\n+\t calculate the CFA using a full location expression since no\n+\t register-offset pair is available.  */\n+      struct dw_loc_descr_struct *loc_list;\n+\n+      cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n+      loc_list = build_cfa_loc (&loc, 0);\n+      cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n+    }\n+\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Add the CFI for saving a register.  REG is the CFA column number.\n+   LABEL is passed to add_fde_cfi.\n+   If SREG is -1, the register is saved at OFFSET from the CFA;\n+   otherwise it is saved in SREG.  */\n+\n+static void\n+reg_save (const char *label, unsigned int reg, unsigned int sreg,\n+          HOST_WIDE_INT offset)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+  dw_fde_ref fde = current_fde ();\n+\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+\n+  /* When stack is aligned, store REG using DW_CFA_expression with FP.  */\n+  if (fde\n+      && fde->stack_realign\n+      && sreg == INVALID_REGNUM)\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_expression;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+      cfi->dw_cfi_oprnd2.dw_cfi_loc\n+\t= build_cfa_aligned_loc (&cfa, offset, fde->stack_realignment);\n+    }\n+  else if (sreg == INVALID_REGNUM)\n+    {\n+      if (need_data_align_sf_opcode (offset))\n+\tcfi->dw_cfi_opc = DW_CFA_offset_extended_sf;\n+      else if (reg & ~0x3f)\n+\tcfi->dw_cfi_opc = DW_CFA_offset_extended;\n+      else\n+\tcfi->dw_cfi_opc = DW_CFA_offset;\n+      cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n+    }\n+  else if (sreg == reg)\n+    cfi->dw_cfi_opc = DW_CFA_same_value;\n+  else\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_register;\n+      cfi->dw_cfi_oprnd2.dw_cfi_reg_num = sreg;\n+    }\n+\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Record the initial position of the return address.  RTL is\n+   INCOMING_RETURN_ADDR_RTX.  */\n+\n+static void\n+initial_return_save (rtx rtl)\n+{\n+  unsigned int reg = INVALID_REGNUM;\n+  HOST_WIDE_INT offset = 0;\n+\n+  switch (GET_CODE (rtl))\n+    {\n+    case REG:\n+      /* RA is in a register.  */\n+      reg = DWARF_FRAME_REGNUM (REGNO (rtl));\n+      break;\n+\n+    case MEM:\n+      /* RA is on the stack.  */\n+      rtl = XEXP (rtl, 0);\n+      switch (GET_CODE (rtl))\n+\t{\n+\tcase REG:\n+\t  gcc_assert (REGNO (rtl) == STACK_POINTER_REGNUM);\n+\t  offset = 0;\n+\t  break;\n+\n+\tcase PLUS:\n+\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  offset = INTVAL (XEXP (rtl, 1));\n+\t  break;\n+\n+\tcase MINUS:\n+\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  offset = -INTVAL (XEXP (rtl, 1));\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      break;\n+\n+    case PLUS:\n+      /* The return address is at some offset from any value we can\n+\t actually load.  For instance, on the SPARC it is in %i7+8. Just\n+\t ignore the offset for now; it doesn't matter for unwinding frames.  */\n+      gcc_assert (CONST_INT_P (XEXP (rtl, 1)));\n+      initial_return_save (XEXP (rtl, 0));\n+      return;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (reg != DWARF_FRAME_RETURN_COLUMN)\n+    reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n+}\n+\n+/* Given a SET, calculate the amount of stack adjustment it\n+   contains.  */\n+\n+static HOST_WIDE_INT\n+stack_adjust_offset (const_rtx pattern, HOST_WIDE_INT cur_args_size,\n+\t\t     HOST_WIDE_INT cur_offset)\n+{\n+  const_rtx src = SET_SRC (pattern);\n+  const_rtx dest = SET_DEST (pattern);\n+  HOST_WIDE_INT offset = 0;\n+  enum rtx_code code;\n+\n+  if (dest == stack_pointer_rtx)\n+    {\n+      code = GET_CODE (src);\n+\n+      /* Assume (set (reg sp) (reg whatever)) sets args_size\n+\t level to 0.  */\n+      if (code == REG && src != stack_pointer_rtx)\n+\t{\n+\t  offset = -cur_args_size;\n+#ifndef STACK_GROWS_DOWNWARD\n+\t  offset = -offset;\n+#endif\n+\t  return offset - cur_offset;\n+\t}\n+\n+      if (! (code == PLUS || code == MINUS)\n+\t  || XEXP (src, 0) != stack_pointer_rtx\n+\t  || !CONST_INT_P (XEXP (src, 1)))\n+\treturn 0;\n+\n+      /* (set (reg sp) (plus (reg sp) (const_int))) */\n+      offset = INTVAL (XEXP (src, 1));\n+      if (code == PLUS)\n+\toffset = -offset;\n+      return offset;\n+    }\n+\n+  if (MEM_P (src) && !MEM_P (dest))\n+    dest = src;\n+  if (MEM_P (dest))\n+    {\n+      /* (set (mem (pre_dec (reg sp))) (foo)) */\n+      src = XEXP (dest, 0);\n+      code = GET_CODE (src);\n+\n+      switch (code)\n+\t{\n+\tcase PRE_MODIFY:\n+\tcase POST_MODIFY:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      rtx val = XEXP (XEXP (src, 1), 1);\n+\t      /* We handle only adjustments by constant amount.  */\n+\t      gcc_assert (GET_CODE (XEXP (src, 1)) == PLUS\n+\t\t\t  && CONST_INT_P (val));\n+\t      offset = -INTVAL (val);\n+\t      break;\n+\t    }\n+\t  return 0;\n+\n+\tcase PRE_DEC:\n+\tcase POST_DEC:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      offset = GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    }\n+\t  return 0;\n+\n+\tcase PRE_INC:\n+\tcase POST_INC:\n+\t  if (XEXP (src, 0) == stack_pointer_rtx)\n+\t    {\n+\t      offset = -GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    }\n+\t  return 0;\n+\n+\tdefault:\n+\t  return 0;\n+\t}\n+    }\n+  else\n+    return 0;\n+\n+  return offset;\n+}\n+\n+/* Precomputed args_size for CODE_LABELs and BARRIERs preceeding them,\n+   indexed by INSN_UID.  */\n+\n+static HOST_WIDE_INT *barrier_args_size;\n+\n+/* Helper function for compute_barrier_args_size.  Handle one insn.  */\n+\n+static HOST_WIDE_INT\n+compute_barrier_args_size_1 (rtx insn, HOST_WIDE_INT cur_args_size,\n+\t\t\t     VEC (rtx, heap) **next)\n+{\n+  HOST_WIDE_INT offset = 0;\n+  int i;\n+\n+  if (! RTX_FRAME_RELATED_P (insn))\n+    {\n+      if (prologue_epilogue_contains (insn))\n+\t/* Nothing */;\n+      else if (GET_CODE (PATTERN (insn)) == SET)\n+\toffset = stack_adjust_offset (PATTERN (insn), cur_args_size, 0);\n+      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t{\n+\t  /* There may be stack adjustments inside compound insns.  Search\n+\t     for them.  */\n+\t  for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n+\t      offset += stack_adjust_offset (XVECEXP (PATTERN (insn), 0, i),\n+\t\t\t\t\t     cur_args_size, offset);\n+\t}\n+    }\n+  else\n+    {\n+      rtx expr = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n+\n+      if (expr)\n+\t{\n+\t  expr = XEXP (expr, 0);\n+\t  if (GET_CODE (expr) == PARALLEL\n+\t      || GET_CODE (expr) == SEQUENCE)\n+\t    for (i = 1; i < XVECLEN (expr, 0); i++)\n+\t      {\n+\t\trtx elem = XVECEXP (expr, 0, i);\n+\n+\t\tif (GET_CODE (elem) == SET && !RTX_FRAME_RELATED_P (elem))\n+\t\t  offset += stack_adjust_offset (elem, cur_args_size, offset);\n+\t      }\n+\t}\n+    }\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  offset = -offset;\n+#endif\n+\n+  cur_args_size += offset;\n+  if (cur_args_size < 0)\n+    cur_args_size = 0;\n+\n+  if (JUMP_P (insn))\n+    {\n+      rtx dest = JUMP_LABEL (insn);\n+\n+      if (dest)\n+\t{\n+\t  if (barrier_args_size [INSN_UID (dest)] < 0)\n+\t    {\n+\t      barrier_args_size [INSN_UID (dest)] = cur_args_size;\n+\t      VEC_safe_push (rtx, heap, *next, dest);\n+\t    }\n+\t}\n+    }\n+\n+  return cur_args_size;\n+}\n+\n+/* Walk the whole function and compute args_size on BARRIERs.  */\n+\n+static void\n+compute_barrier_args_size (void)\n+{\n+  int max_uid = get_max_uid (), i;\n+  rtx insn;\n+  VEC (rtx, heap) *worklist, *next, *tmp;\n+\n+  barrier_args_size = XNEWVEC (HOST_WIDE_INT, max_uid);\n+  for (i = 0; i < max_uid; i++)\n+    barrier_args_size[i] = -1;\n+\n+  worklist = VEC_alloc (rtx, heap, 20);\n+  next = VEC_alloc (rtx, heap, 20);\n+  insn = get_insns ();\n+  barrier_args_size[INSN_UID (insn)] = 0;\n+  VEC_quick_push (rtx, worklist, insn);\n+  for (;;)\n+    {\n+      while (!VEC_empty (rtx, worklist))\n+\t{\n+\t  rtx prev, body, first_insn;\n+\t  HOST_WIDE_INT cur_args_size;\n+\n+\t  first_insn = insn = VEC_pop (rtx, worklist);\n+\t  cur_args_size = barrier_args_size[INSN_UID (insn)];\n+\t  prev = prev_nonnote_insn (insn);\n+\t  if (prev && BARRIER_P (prev))\n+\t    barrier_args_size[INSN_UID (prev)] = cur_args_size;\n+\n+\t  for (; insn; insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (INSN_DELETED_P (insn) || NOTE_P (insn))\n+\t\tcontinue;\n+\t      if (BARRIER_P (insn))\n+\t\tbreak;\n+\n+\t      if (LABEL_P (insn))\n+\t\t{\n+\t\t  if (insn == first_insn)\n+\t\t    continue;\n+\t\t  else if (barrier_args_size[INSN_UID (insn)] < 0)\n+\t\t    {\n+\t\t      barrier_args_size[INSN_UID (insn)] = cur_args_size;\n+\t\t      continue;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* The insns starting with this label have been\n+\t\t\t already scanned or are in the worklist.  */\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      body = PATTERN (insn);\n+\t      if (GET_CODE (body) == SEQUENCE)\n+\t\t{\n+\t\t  HOST_WIDE_INT dest_args_size = cur_args_size;\n+\t\t  for (i = 1; i < XVECLEN (body, 0); i++)\n+\t\t    if (INSN_ANNULLED_BRANCH_P (XVECEXP (body, 0, 0))\n+\t\t\t&& INSN_FROM_TARGET_P (XVECEXP (body, 0, i)))\n+\t\t      dest_args_size\n+\t\t\t= compute_barrier_args_size_1 (XVECEXP (body, 0, i),\n+\t\t\t\t\t\t       dest_args_size, &next);\n+\t\t    else\n+\t\t      cur_args_size\n+\t\t\t= compute_barrier_args_size_1 (XVECEXP (body, 0, i),\n+\t\t\t\t\t\t       cur_args_size, &next);\n+\n+\t\t  if (INSN_ANNULLED_BRANCH_P (XVECEXP (body, 0, 0)))\n+\t\t    compute_barrier_args_size_1 (XVECEXP (body, 0, 0),\n+\t\t\t\t\t\t dest_args_size, &next);\n+\t\t  else\n+\t\t    cur_args_size\n+\t\t      = compute_barrier_args_size_1 (XVECEXP (body, 0, 0),\n+\t\t\t\t\t\t     cur_args_size, &next);\n+\t\t}\n+\t      else\n+\t\tcur_args_size\n+\t\t  = compute_barrier_args_size_1 (insn, cur_args_size, &next);\n+\t    }\n+\t}\n+\n+      if (VEC_empty (rtx, next))\n+\tbreak;\n+\n+      /* Swap WORKLIST with NEXT and truncate NEXT for next iteration.  */\n+      tmp = next;\n+      next = worklist;\n+      worklist = tmp;\n+      VEC_truncate (rtx, next, 0);\n+    }\n+\n+  VEC_free (rtx, heap, worklist);\n+  VEC_free (rtx, heap, next);\n+}\n+\n+/* Add a CFI to update the running total of the size of arguments\n+   pushed onto the stack.  */\n+\n+static void\n+dwarf2out_args_size (const char *label, HOST_WIDE_INT size)\n+{\n+  dw_cfi_ref cfi;\n+\n+  if (size == old_args_size)\n+    return;\n+\n+  old_args_size = size;\n+\n+  cfi = new_cfi ();\n+  cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n+  cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Record a stack adjustment of OFFSET bytes.  */\n+\n+static void\n+dwarf2out_stack_adjust (HOST_WIDE_INT offset, const char *label)\n+{\n+  if (cfa.reg == STACK_POINTER_REGNUM)\n+    cfa.offset += offset;\n+\n+  if (cfa_store.reg == STACK_POINTER_REGNUM)\n+    cfa_store.offset += offset;\n+\n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    return;\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  offset = -offset;\n+#endif\n+\n+  args_size += offset;\n+  if (args_size < 0)\n+    args_size = 0;\n+\n+  def_cfa_1 (label, &cfa);\n+  if (flag_asynchronous_unwind_tables)\n+    dwarf2out_args_size (label, args_size);\n+}\n+\n+/* Check INSN to see if it looks like a push or a stack adjustment, and\n+   make a note of it if it does.  EH uses this information to find out\n+   how much extra space it needs to pop off the stack.  */\n+\n+static void\n+dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n+{\n+  HOST_WIDE_INT offset;\n+  const char *label;\n+  int i;\n+\n+  /* Don't handle epilogues at all.  Certainly it would be wrong to do so\n+     with this function.  Proper support would require all frame-related\n+     insns to be marked, and to be able to handle saving state around\n+     epilogues textually in the middle of the function.  */\n+  if (prologue_epilogue_contains (insn))\n+    return;\n+\n+  /* If INSN is an instruction from target of an annulled branch, the\n+     effects are for the target only and so current argument size\n+     shouldn't change at all.  */\n+  if (final_sequence\n+      && INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))\n+      && INSN_FROM_TARGET_P (insn))\n+    return;\n+\n+  /* If only calls can throw, and we have a frame pointer,\n+     save up adjustments until we see the CALL_INSN.  */\n+  if (!flag_asynchronous_unwind_tables && cfa.reg != STACK_POINTER_REGNUM)\n+    {\n+      if (CALL_P (insn) && !after_p)\n+\t{\n+\t  /* Extract the size of the args from the CALL rtx itself.  */\n+\t  insn = PATTERN (insn);\n+\t  if (GET_CODE (insn) == PARALLEL)\n+\t    insn = XVECEXP (insn, 0, 0);\n+\t  if (GET_CODE (insn) == SET)\n+\t    insn = SET_SRC (insn);\n+\t  gcc_assert (GET_CODE (insn) == CALL);\n+\t  dwarf2out_args_size (\"\", INTVAL (XEXP (insn, 1)));\n+\t}\n+      return;\n+    }\n+\n+  if (CALL_P (insn) && !after_p)\n+    {\n+      if (!flag_asynchronous_unwind_tables)\n+\tdwarf2out_args_size (\"\", args_size);\n+      return;\n+    }\n+  else if (BARRIER_P (insn))\n+    {\n+      /* Don't call compute_barrier_args_size () if the only\n+\t BARRIER is at the end of function.  */\n+      if (barrier_args_size == NULL && next_nonnote_insn (insn))\n+\tcompute_barrier_args_size ();\n+      if (barrier_args_size == NULL)\n+\toffset = 0;\n+      else\n+\t{\n+\t  offset = barrier_args_size[INSN_UID (insn)];\n+\t  if (offset < 0)\n+\t    offset = 0;\n+\t}\n+\n+      offset -= args_size;\n+#ifndef STACK_GROWS_DOWNWARD\n+      offset = -offset;\n+#endif\n+    }\n+  else if (GET_CODE (PATTERN (insn)) == SET)\n+    offset = stack_adjust_offset (PATTERN (insn), args_size, 0);\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    {\n+      /* There may be stack adjustments inside compound insns.  Search\n+\t for them.  */\n+      for (offset = 0, i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n+\t  offset += stack_adjust_offset (XVECEXP (PATTERN (insn), 0, i),\n+\t\t\t\t\t args_size, offset);\n+    }\n+  else\n+    return;\n+\n+  if (offset == 0)\n+    return;\n+\n+  label = dwarf2out_cfi_label (false);\n+  dwarf2out_stack_adjust (offset, label);\n+}\n+\n+/* We delay emitting a register save until either (a) we reach the end\n+   of the prologue or (b) the register is clobbered.  This clusters\n+   register saves so that there are fewer pc advances.  */\n+\n+struct GTY(()) queued_reg_save {\n+  struct queued_reg_save *next;\n+  rtx reg;\n+  HOST_WIDE_INT cfa_offset;\n+  rtx saved_reg;\n+};\n+\n+static GTY(()) struct queued_reg_save *queued_reg_saves;\n+\n+/* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n+typedef struct GTY(()) reg_saved_in_data {\n+  rtx orig_reg;\n+  rtx saved_in_reg;\n+} reg_saved_in_data;\n+\n+DEF_VEC_O (reg_saved_in_data);\n+DEF_VEC_ALLOC_O (reg_saved_in_data, gc);\n+\n+/* A set of registers saved in other registers.  This is implemented as\n+   a flat array because it normally contains zero or 1 entry, depending\n+   on the target.  IA-64 is the big spender here, using a maximum of\n+   5 entries.  */\n+static GTY(()) VEC(reg_saved_in_data, gc) *regs_saved_in_regs;\n+\n+/* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n+\n+static bool\n+compare_reg_or_pc (rtx x, rtx y)\n+{\n+  if (REG_P (x) && REG_P (y))\n+    return REGNO (x) == REGNO (y);\n+  return x == y;\n+}\n+\n+/* Record SRC as being saved in DEST.  DEST may be null to delete an\n+   existing entry.  SRC may be a register or PC_RTX.  */\n+\n+static void\n+record_reg_saved_in_reg (rtx dest, rtx src)\n+{\n+  reg_saved_in_data *elt;\n+  size_t i;\n+\n+  FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, elt)\n+    if (compare_reg_or_pc (elt->orig_reg, src))\n+      {\n+\tif (dest == NULL)\n+\t  VEC_unordered_remove(reg_saved_in_data, regs_saved_in_regs, i);\n+\telse\n+\t  elt->saved_in_reg = dest;\n+\treturn;\n+      }\n+\n+  if (dest == NULL)\n+    return;\n+\n+  elt = VEC_safe_push(reg_saved_in_data, gc, regs_saved_in_regs, NULL);\n+  elt->orig_reg = src;\n+  elt->saved_in_reg = dest;\n+}\n+\n+static const char *last_reg_save_label;\n+\n+/* Add an entry to QUEUED_REG_SAVES saying that REG is now saved at\n+   SREG, or if SREG is NULL then it is saved at OFFSET to the CFA.  */\n+\n+static void\n+queue_reg_save (const char *label, rtx reg, rtx sreg, HOST_WIDE_INT offset)\n+{\n+  struct queued_reg_save *q;\n+\n+  /* Duplicates waste space, but it's also necessary to remove them\n+     for correctness, since the queue gets output in reverse\n+     order.  */\n+  for (q = queued_reg_saves; q != NULL; q = q->next)\n+    if (REGNO (q->reg) == REGNO (reg))\n+      break;\n+\n+  if (q == NULL)\n+    {\n+      q = ggc_alloc_queued_reg_save ();\n+      q->next = queued_reg_saves;\n+      queued_reg_saves = q;\n+    }\n+\n+  q->reg = reg;\n+  q->cfa_offset = offset;\n+  q->saved_reg = sreg;\n+\n+  last_reg_save_label = label;\n+}\n+\n+/* Output all the entries in QUEUED_REG_SAVES.  */\n+\n+static void\n+dwarf2out_flush_queued_reg_saves (void)\n+{\n+  struct queued_reg_save *q;\n+\n+  for (q = queued_reg_saves; q; q = q->next)\n+    {\n+      unsigned int reg, sreg;\n+\n+      record_reg_saved_in_reg (q->saved_reg, q->reg);\n+\n+      reg = DWARF_FRAME_REGNUM (REGNO (q->reg));\n+      if (q->saved_reg)\n+\tsreg = DWARF_FRAME_REGNUM (REGNO (q->saved_reg));\n+      else\n+\tsreg = INVALID_REGNUM;\n+      reg_save (last_reg_save_label, reg, sreg, q->cfa_offset);\n+    }\n+\n+  queued_reg_saves = NULL;\n+  last_reg_save_label = NULL;\n+}\n+\n+/* Does INSN clobber any register which QUEUED_REG_SAVES lists a saved\n+   location for?  Or, does it clobber a register which we've previously\n+   said that some other register is saved in, and for which we now\n+   have a new location for?  */\n+\n+static bool\n+clobbers_queued_reg_save (const_rtx insn)\n+{\n+  struct queued_reg_save *q;\n+\n+  for (q = queued_reg_saves; q; q = q->next)\n+    {\n+      size_t i;\n+      reg_saved_in_data *rir;\n+\n+      if (modified_in_p (q->reg, insn))\n+\treturn true;\n+\n+      FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, rir)\n+\tif (compare_reg_or_pc (q->reg, rir->orig_reg)\n+\t    && modified_in_p (rir->saved_in_reg, insn))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* What register, if any, is currently saved in REG?  */\n+\n+static rtx\n+reg_saved_in (rtx reg)\n+{\n+  unsigned int regn = REGNO (reg);\n+  struct queued_reg_save *q;\n+  reg_saved_in_data *rir;\n+  size_t i;\n+\n+  for (q = queued_reg_saves; q; q = q->next)\n+    if (q->saved_reg && regn == REGNO (q->saved_reg))\n+      return q->reg;\n+\n+  FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, rir)\n+    if (regn == REGNO (rir->saved_in_reg))\n+      return rir->orig_reg;\n+\n+  return NULL_RTX;\n+}\n+\n+\n+/* A temporary register holding an integral value used in adjusting SP\n+   or setting up the store_reg.  The \"offset\" field holds the integer\n+   value, not an offset.  */\n+static dw_cfa_location cfa_temp;\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_DEF_CFA note.  */\n+\n+static void\n+dwarf2out_frame_debug_def_cfa (rtx pat, const char *label)\n+{\n+  memset (&cfa, 0, sizeof (cfa));\n+\n+  switch (GET_CODE (pat))\n+    {\n+    case PLUS:\n+      cfa.reg = REGNO (XEXP (pat, 0));\n+      cfa.offset = INTVAL (XEXP (pat, 1));\n+      break;\n+\n+    case REG:\n+      cfa.reg = REGNO (pat);\n+      break;\n+\n+    case MEM:\n+      cfa.indirect = 1;\n+      pat = XEXP (pat, 0);\n+      if (GET_CODE (pat) == PLUS)\n+\t{\n+\t  cfa.base_offset = INTVAL (XEXP (pat, 1));\n+\t  pat = XEXP (pat, 0);\n+\t}\n+      cfa.reg = REGNO (pat);\n+      break;\n+\n+    default:\n+      /* Recurse and define an expression.  */\n+      gcc_unreachable ();\n+    }\n+\n+  def_cfa_1 (label, &cfa);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n+\n+static void\n+dwarf2out_frame_debug_adjust_cfa (rtx pat, const char *label)\n+{\n+  rtx src, dest;\n+\n+  gcc_assert (GET_CODE (pat) == SET);\n+  dest = XEXP (pat, 0);\n+  src = XEXP (pat, 1);\n+\n+  switch (GET_CODE (src))\n+    {\n+    case PLUS:\n+      gcc_assert (REGNO (XEXP (src, 0)) == cfa.reg);\n+      cfa.offset -= INTVAL (XEXP (src, 1));\n+      break;\n+\n+    case REG:\n+\tbreak;\n+\n+    default:\n+\tgcc_unreachable ();\n+    }\n+\n+  cfa.reg = REGNO (dest);\n+  gcc_assert (cfa.indirect == 0);\n+\n+  def_cfa_1 (label, &cfa);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_OFFSET note.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n+{\n+  HOST_WIDE_INT offset;\n+  rtx src, addr, span;\n+  unsigned int sregno;\n+\n+  src = XEXP (set, 1);\n+  addr = XEXP (set, 0);\n+  gcc_assert (MEM_P (addr));\n+  addr = XEXP (addr, 0);\n+\n+  /* As documented, only consider extremely simple addresses.  */\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      gcc_assert (REGNO (addr) == cfa.reg);\n+      offset = -cfa.offset;\n+      break;\n+    case PLUS:\n+      gcc_assert (REGNO (XEXP (addr, 0)) == cfa.reg);\n+      offset = INTVAL (XEXP (addr, 1)) - cfa.offset;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (src == pc_rtx)\n+    {\n+      span = NULL;\n+      sregno = DWARF_FRAME_RETURN_COLUMN;\n+    }\n+  else \n+    {\n+      span = targetm.dwarf_register_span (src);\n+      sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+    }\n+\n+  /* ??? We'd like to use queue_reg_save, but we need to come up with\n+     a different flushing heuristic for epilogues.  */\n+  if (!span)\n+    reg_save (label, sregno, INVALID_REGNUM, offset);\n+  else\n+    {\n+      /* We have a PARALLEL describing where the contents of SRC live.\n+   \t Queue register saves for each piece of the PARALLEL.  */\n+      int par_index;\n+      int limit;\n+      HOST_WIDE_INT span_offset = offset;\n+\n+      gcc_assert (GET_CODE (span) == PARALLEL);\n+\n+      limit = XVECLEN (span, 0);\n+      for (par_index = 0; par_index < limit; par_index++)\n+\t{\n+\t  rtx elem = XVECEXP (span, 0, par_index);\n+\n+\t  sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+\t  reg_save (label, sregno, INVALID_REGNUM, span_offset);\n+\t  span_offset += GET_MODE_SIZE (GET_MODE (elem));\n+\t}\n+    }\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_REGISTER note.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n+{\n+  rtx src, dest;\n+  unsigned sregno, dregno;\n+\n+  src = XEXP (set, 1);\n+  dest = XEXP (set, 0);\n+\n+  if (src == pc_rtx)\n+    sregno = DWARF_FRAME_RETURN_COLUMN;\n+  else\n+    {\n+      record_reg_saved_in_reg (dest, src);\n+      sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+    }\n+\n+  dregno = DWARF_FRAME_REGNUM (REGNO (dest));\n+\n+  /* ??? We'd like to use queue_reg_save, but we need to come up with\n+     a different flushing heuristic for epilogues.  */\n+  reg_save (label, sregno, dregno, 0);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_EXPRESSION note. */\n+\n+static void\n+dwarf2out_frame_debug_cfa_expression (rtx set, const char *label)\n+{\n+  rtx src, dest, span;\n+  dw_cfi_ref cfi = new_cfi ();\n+\n+  dest = SET_DEST (set);\n+  src = SET_SRC (set);\n+\n+  gcc_assert (REG_P (src));\n+  gcc_assert (MEM_P (dest));\n+\n+  span = targetm.dwarf_register_span (src);\n+  gcc_assert (!span);\n+\n+  cfi->dw_cfi_opc = DW_CFA_expression;\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = DWARF_FRAME_REGNUM (REGNO (src));\n+  cfi->dw_cfi_oprnd2.dw_cfi_loc\n+    = mem_loc_descriptor (XEXP (dest, 0), get_address_mode (dest),\n+\t\t\t  GET_MODE (dest), VAR_INIT_STATUS_INITIALIZED);\n+\n+  /* ??? We'd like to use queue_reg_save, were the interface different,\n+     and, as above, we could manage flushing for epilogues.  */\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE note.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_restore (rtx reg, const char *label)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+  unsigned int regno = DWARF_FRAME_REGNUM (REGNO (reg));\n+\n+  cfi->dw_cfi_opc = (regno & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = regno;\n+\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_WINDOW_SAVE.\n+   ??? Perhaps we should note in the CIE where windows are saved (instead of\n+   assuming 0(cfa)) and what registers are in the window.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_window_save (const char *label)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+\n+  cfi->dw_cfi_opc = DW_CFA_GNU_window_save;\n+  add_fde_cfi (label, cfi);\n+}\n+\n+/* Record call frame debugging information for an expression EXPR,\n+   which either sets SP or FP (adjusting how we calculate the frame\n+   address) or saves a register to the stack or another register.\n+   LABEL indicates the address of EXPR.\n+\n+   This function encodes a state machine mapping rtxes to actions on\n+   cfa, cfa_store, and cfa_temp.reg.  We describe these rules so\n+   users need not read the source code.\n+\n+  The High-Level Picture\n+\n+  Changes in the register we use to calculate the CFA: Currently we\n+  assume that if you copy the CFA register into another register, we\n+  should take the other one as the new CFA register; this seems to\n+  work pretty well.  If it's wrong for some target, it's simple\n+  enough not to set RTX_FRAME_RELATED_P on the insn in question.\n+\n+  Changes in the register we use for saving registers to the stack:\n+  This is usually SP, but not always.  Again, we deduce that if you\n+  copy SP into another register (and SP is not the CFA register),\n+  then the new register is the one we will be using for register\n+  saves.  This also seems to work.\n+\n+  Register saves: There's not much guesswork about this one; if\n+  RTX_FRAME_RELATED_P is set on an insn which modifies memory, it's a\n+  register save, and the register used to calculate the destination\n+  had better be the one we think we're using for this purpose.\n+  It's also assumed that a copy from a call-saved register to another\n+  register is saving that register if RTX_FRAME_RELATED_P is set on\n+  that instruction.  If the copy is from a call-saved register to\n+  the *same* register, that means that the register is now the same\n+  value as in the caller.\n+\n+  Except: If the register being saved is the CFA register, and the\n+  offset is nonzero, we are saving the CFA, so we assume we have to\n+  use DW_CFA_def_cfa_expression.  If the offset is 0, we assume that\n+  the intent is to save the value of SP from the previous frame.\n+\n+  In addition, if a register has previously been saved to a different\n+  register,\n+\n+  Invariants / Summaries of Rules\n+\n+  cfa\t       current rule for calculating the CFA.  It usually\n+\t       consists of a register and an offset.\n+  cfa_store    register used by prologue code to save things to the stack\n+\t       cfa_store.offset is the offset from the value of\n+\t       cfa_store.reg to the actual CFA\n+  cfa_temp     register holding an integral value.  cfa_temp.offset\n+\t       stores the value, which will be used to adjust the\n+\t       stack pointer.  cfa_temp is also used like cfa_store,\n+\t       to track stores to the stack via fp or a temp reg.\n+\n+  Rules  1- 4: Setting a register's value to cfa.reg or an expression\n+\t       with cfa.reg as the first operand changes the cfa.reg and its\n+\t       cfa.offset.  Rule 1 and 4 also set cfa_temp.reg and\n+\t       cfa_temp.offset.\n+\n+  Rules  6- 9: Set a non-cfa.reg register value to a constant or an\n+\t       expression yielding a constant.  This sets cfa_temp.reg\n+\t       and cfa_temp.offset.\n+\n+  Rule 5:      Create a new register cfa_store used to save items to the\n+\t       stack.\n+\n+  Rules 10-14: Save a register to the stack.  Define offset as the\n+\t       difference of the original location and cfa_store's\n+\t       location (or cfa_temp's location if cfa_temp is used).\n+\n+  Rules 16-20: If AND operation happens on sp in prologue, we assume\n+\t       stack is realigned.  We will use a group of DW_OP_XXX\n+\t       expressions to represent the location of the stored\n+\t       register instead of CFA+offset.\n+\n+  The Rules\n+\n+  \"{a,b}\" indicates a choice of a xor b.\n+  \"<reg>:cfa.reg\" indicates that <reg> must equal cfa.reg.\n+\n+  Rule 1:\n+  (set <reg1> <reg2>:cfa.reg)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.offset unchanged\n+\t   cfa_temp.reg = <reg1>\n+\t   cfa_temp.offset = cfa.offset\n+\n+  Rule 2:\n+  (set sp ({minus,plus,losum} {sp,fp}:cfa.reg\n+\t\t\t      {<const_int>,<reg>:cfa_temp.reg}))\n+  effects: cfa.reg = sp if fp used\n+\t   cfa.offset += {+/- <const_int>, cfa_temp.offset} if cfa.reg==sp\n+\t   cfa_store.offset += {+/- <const_int>, cfa_temp.offset}\n+\t     if cfa_store.reg==sp\n+\n+  Rule 3:\n+  (set fp ({minus,plus,losum} <reg>:cfa.reg <const_int>))\n+  effects: cfa.reg = fp\n+\t   cfa_offset += +/- <const_int>\n+\n+  Rule 4:\n+  (set <reg1> ({plus,losum} <reg2>:cfa.reg <const_int>))\n+  constraints: <reg1> != fp\n+\t       <reg1> != sp\n+  effects: cfa.reg = <reg1>\n+\t   cfa_temp.reg = <reg1>\n+\t   cfa_temp.offset = cfa.offset\n+\n+  Rule 5:\n+  (set <reg1> (plus <reg2>:cfa_temp.reg sp:cfa.reg))\n+  constraints: <reg1> != fp\n+\t       <reg1> != sp\n+  effects: cfa_store.reg = <reg1>\n+\t   cfa_store.offset = cfa.offset - cfa_temp.offset\n+\n+  Rule 6:\n+  (set <reg> <const_int>)\n+  effects: cfa_temp.reg = <reg>\n+\t   cfa_temp.offset = <const_int>\n+\n+  Rule 7:\n+  (set <reg1>:cfa_temp.reg (ior <reg2>:cfa_temp.reg <const_int>))\n+  effects: cfa_temp.reg = <reg1>\n+\t   cfa_temp.offset |= <const_int>\n+\n+  Rule 8:\n+  (set <reg> (high <exp>))\n+  effects: none\n+\n+  Rule 9:\n+  (set <reg> (lo_sum <exp> <const_int>))\n+  effects: cfa_temp.reg = <reg>\n+\t   cfa_temp.offset = <const_int>\n+\n+  Rule 10:\n+  (set (mem ({pre,post}_modify sp:cfa_store (???? <reg1> <const_int>))) <reg2>)\n+  effects: cfa_store.offset -= <const_int>\n+\t   cfa.offset = cfa_store.offset if cfa.reg == sp\n+\t   cfa.reg = sp\n+\t   cfa.base_offset = -cfa_store.offset\n+\n+  Rule 11:\n+  (set (mem ({pre_inc,pre_dec,post_dec} sp:cfa_store.reg)) <reg>)\n+  effects: cfa_store.offset += -/+ mode_size(mem)\n+\t   cfa.offset = cfa_store.offset if cfa.reg == sp\n+\t   cfa.reg = sp\n+\t   cfa.base_offset = -cfa_store.offset\n+\n+  Rule 12:\n+  (set (mem ({minus,plus,losum} <reg1>:{cfa_store,cfa_temp} <const_int>))\n+\n+       <reg2>)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.base_offset = -/+ <const_int> - {cfa_store,cfa_temp}.offset\n+\n+  Rule 13:\n+  (set (mem <reg1>:{cfa_store,cfa_temp}) <reg2>)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.base_offset = -{cfa_store,cfa_temp}.offset\n+\n+  Rule 14:\n+  (set (mem (post_inc <reg1>:cfa_temp <const_int>)) <reg2>)\n+  effects: cfa.reg = <reg1>\n+\t   cfa.base_offset = -cfa_temp.offset\n+\t   cfa_temp.offset -= mode_size(mem)\n+\n+  Rule 15:\n+  (set <reg> {unspec, unspec_volatile})\n+  effects: target-dependent\n+\n+  Rule 16:\n+  (set sp (and: sp <const_int>))\n+  constraints: cfa_store.reg == sp\n+  effects: current_fde.stack_realign = 1\n+           cfa_store.offset = 0\n+\t   fde->drap_reg = cfa.reg if cfa.reg != sp and cfa.reg != fp\n+\n+  Rule 17:\n+  (set (mem ({pre_inc, pre_dec} sp)) (mem (plus (cfa.reg) (const_int))))\n+  effects: cfa_store.offset += -/+ mode_size(mem)\n+\n+  Rule 18:\n+  (set (mem ({pre_inc, pre_dec} sp)) fp)\n+  constraints: fde->stack_realign == 1\n+  effects: cfa_store.offset = 0\n+\t   cfa.reg != HARD_FRAME_POINTER_REGNUM\n+\n+  Rule 19:\n+  (set (mem ({pre_inc, pre_dec} sp)) cfa.reg)\n+  constraints: fde->stack_realign == 1\n+               && cfa.offset == 0\n+               && cfa.indirect == 0\n+               && cfa.reg != HARD_FRAME_POINTER_REGNUM\n+  effects: Use DW_CFA_def_cfa_expression to define cfa\n+  \t   cfa.reg == fde->drap_reg  */\n+\n+static void\n+dwarf2out_frame_debug_expr (rtx expr, const char *label)\n+{\n+  rtx src, dest, span;\n+  HOST_WIDE_INT offset;\n+  dw_fde_ref fde;\n+\n+  /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of\n+     the PARALLEL independently. The first element is always processed if\n+     it is a SET. This is for backward compatibility.   Other elements\n+     are processed only if they are SETs and the RTX_FRAME_RELATED_P\n+     flag is set in them.  */\n+  if (GET_CODE (expr) == PARALLEL || GET_CODE (expr) == SEQUENCE)\n+    {\n+      int par_index;\n+      int limit = XVECLEN (expr, 0);\n+      rtx elem;\n+\n+      /* PARALLELs have strict read-modify-write semantics, so we\n+\t ought to evaluate every rvalue before changing any lvalue.\n+\t It's cumbersome to do that in general, but there's an\n+\t easy approximation that is enough for all current users:\n+\t handle register saves before register assignments.  */\n+      if (GET_CODE (expr) == PARALLEL)\n+\tfor (par_index = 0; par_index < limit; par_index++)\n+\t  {\n+\t    elem = XVECEXP (expr, 0, par_index);\n+\t    if (GET_CODE (elem) == SET\n+\t\t&& MEM_P (SET_DEST (elem))\n+\t\t&& (RTX_FRAME_RELATED_P (elem) || par_index == 0))\n+\t      dwarf2out_frame_debug_expr (elem, label);\n+\t  }\n+\n+      for (par_index = 0; par_index < limit; par_index++)\n+\t{\n+\t  elem = XVECEXP (expr, 0, par_index);\n+\t  if (GET_CODE (elem) == SET\n+\t      && (!MEM_P (SET_DEST (elem)) || GET_CODE (expr) == SEQUENCE)\n+\t      && (RTX_FRAME_RELATED_P (elem) || par_index == 0))\n+\t    dwarf2out_frame_debug_expr (elem, label);\n+\t  else if (GET_CODE (elem) == SET\n+\t\t   && par_index != 0\n+\t\t   && !RTX_FRAME_RELATED_P (elem))\n+\t    {\n+\t      /* Stack adjustment combining might combine some post-prologue\n+\t\t stack adjustment into a prologue stack adjustment.  */\n+\t      HOST_WIDE_INT offset = stack_adjust_offset (elem, args_size, 0);\n+\n+\t      if (offset != 0)\n+\t\tdwarf2out_stack_adjust (offset, label);\n+\t    }\n+\t}\n+      return;\n+    }\n+\n+  gcc_assert (GET_CODE (expr) == SET);\n+\n+  src = SET_SRC (expr);\n+  dest = SET_DEST (expr);\n+\n+  if (REG_P (src))\n+    {\n+      rtx rsi = reg_saved_in (src);\n+      if (rsi)\n+\tsrc = rsi;\n+    }\n+\n+  fde = current_fde ();\n+\n+  switch (GET_CODE (dest))\n+    {\n+    case REG:\n+      switch (GET_CODE (src))\n+\t{\n+\t  /* Setting FP from SP.  */\n+\tcase REG:\n+\t  if (cfa.reg == (unsigned) REGNO (src))\n+\t    {\n+\t      /* Rule 1 */\n+\t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n+\t\t relative to the current CFA register.\n+\n+\t\t We used to require that dest be either SP or FP, but the\n+\t\t ARM copies SP to a temporary register, and from there to\n+\t\t FP.  So we just rely on the backends to only set\n+\t\t RTX_FRAME_RELATED_P on appropriate insns.  */\n+\t      cfa.reg = REGNO (dest);\n+\t      cfa_temp.reg = cfa.reg;\n+\t      cfa_temp.offset = cfa.offset;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Saving a register in a register.  */\n+\t      gcc_assert (!fixed_regs [REGNO (dest)]\n+\t\t\t  /* For the SPARC and its register window.  */\n+\t\t\t  || (DWARF_FRAME_REGNUM (REGNO (src))\n+\t\t\t      == DWARF_FRAME_RETURN_COLUMN));\n+\n+              /* After stack is aligned, we can only save SP in FP\n+\t\t if drap register is used.  In this case, we have\n+\t\t to restore stack pointer with the CFA value and we\n+\t\t don't generate this DWARF information.  */\n+\t      if (fde\n+\t\t  && fde->stack_realign\n+\t\t  && REGNO (src) == STACK_POINTER_REGNUM)\n+\t\tgcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n+\t\t\t    && fde->drap_reg != INVALID_REGNUM\n+\t\t\t    && cfa.reg != REGNO (src));\n+\t      else\n+\t\tqueue_reg_save (label, src, dest, 0);\n+\t    }\n+\t  break;\n+\n+\tcase PLUS:\n+\tcase MINUS:\n+\tcase LO_SUM:\n+\t  if (dest == stack_pointer_rtx)\n+\t    {\n+\t      /* Rule 2 */\n+\t      /* Adjusting SP.  */\n+\t      switch (GET_CODE (XEXP (src, 1)))\n+\t\t{\n+\t\tcase CONST_INT:\n+\t\t  offset = INTVAL (XEXP (src, 1));\n+\t\t  break;\n+\t\tcase REG:\n+\t\t  gcc_assert ((unsigned) REGNO (XEXP (src, 1))\n+\t\t\t      == cfa_temp.reg);\n+\t\t  offset = cfa_temp.offset;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\n+\t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n+\t\t{\n+\t\t  /* Restoring SP from FP in the epilogue.  */\n+\t\t  gcc_assert (cfa.reg == (unsigned) HARD_FRAME_POINTER_REGNUM);\n+\t\t  cfa.reg = STACK_POINTER_REGNUM;\n+\t\t}\n+\t      else if (GET_CODE (src) == LO_SUM)\n+\t\t/* Assume we've set the source reg of the LO_SUM from sp.  */\n+\t\t;\n+\t      else\n+\t\tgcc_assert (XEXP (src, 0) == stack_pointer_rtx);\n+\n+\t      if (GET_CODE (src) != MINUS)\n+\t\toffset = -offset;\n+\t      if (cfa.reg == STACK_POINTER_REGNUM)\n+\t\tcfa.offset += offset;\n+\t      if (cfa_store.reg == STACK_POINTER_REGNUM)\n+\t\tcfa_store.offset += offset;\n+\t    }\n+\t  else if (dest == hard_frame_pointer_rtx)\n+\t    {\n+\t      /* Rule 3 */\n+\t      /* Either setting the FP from an offset of the SP,\n+\t\t or adjusting the FP */\n+\t      gcc_assert (frame_pointer_needed);\n+\n+\t      gcc_assert (REG_P (XEXP (src, 0))\n+\t\t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa.reg\n+\t\t\t  && CONST_INT_P (XEXP (src, 1)));\n+\t      offset = INTVAL (XEXP (src, 1));\n+\t      if (GET_CODE (src) != MINUS)\n+\t\toffset = -offset;\n+\t      cfa.offset += offset;\n+\t      cfa.reg = HARD_FRAME_POINTER_REGNUM;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (GET_CODE (src) != MINUS);\n+\n+\t      /* Rule 4 */\n+\t      if (REG_P (XEXP (src, 0))\n+\t\t  && REGNO (XEXP (src, 0)) == cfa.reg\n+\t\t  && CONST_INT_P (XEXP (src, 1)))\n+\t\t{\n+\t\t  /* Setting a temporary CFA register that will be copied\n+\t\t     into the FP later on.  */\n+\t\t  offset = - INTVAL (XEXP (src, 1));\n+\t\t  cfa.offset += offset;\n+\t\t  cfa.reg = REGNO (dest);\n+\t\t  /* Or used to save regs to the stack.  */\n+\t\t  cfa_temp.reg = cfa.reg;\n+\t\t  cfa_temp.offset = cfa.offset;\n+\t\t}\n+\n+\t      /* Rule 5 */\n+\t      else if (REG_P (XEXP (src, 0))\n+\t\t       && REGNO (XEXP (src, 0)) == cfa_temp.reg\n+\t\t       && XEXP (src, 1) == stack_pointer_rtx)\n+\t\t{\n+\t\t  /* Setting a scratch register that we will use instead\n+\t\t     of SP for saving registers to the stack.  */\n+\t\t  gcc_assert (cfa.reg == STACK_POINTER_REGNUM);\n+\t\t  cfa_store.reg = REGNO (dest);\n+\t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n+\t\t}\n+\n+\t      /* Rule 9 */\n+\t      else if (GET_CODE (src) == LO_SUM\n+\t\t       && CONST_INT_P (XEXP (src, 1)))\n+\t\t{\n+\t\t  cfa_temp.reg = REGNO (dest);\n+\t\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  break;\n+\n+\t  /* Rule 6 */\n+\tcase CONST_INT:\n+\t  cfa_temp.reg = REGNO (dest);\n+\t  cfa_temp.offset = INTVAL (src);\n+\t  break;\n+\n+\t  /* Rule 7 */\n+\tcase IOR:\n+\t  gcc_assert (REG_P (XEXP (src, 0))\n+\t\t      && (unsigned) REGNO (XEXP (src, 0)) == cfa_temp.reg\n+\t\t      && CONST_INT_P (XEXP (src, 1)));\n+\n+\t  if ((unsigned) REGNO (dest) != cfa_temp.reg)\n+\t    cfa_temp.reg = REGNO (dest);\n+\t  cfa_temp.offset |= INTVAL (XEXP (src, 1));\n+\t  break;\n+\n+\t  /* Skip over HIGH, assuming it will be followed by a LO_SUM,\n+\t     which will fill in all of the bits.  */\n+\t  /* Rule 8 */\n+\tcase HIGH:\n+\t  break;\n+\n+\t  /* Rule 15 */\n+\tcase UNSPEC:\n+\tcase UNSPEC_VOLATILE:\n+\t  gcc_assert (targetm.dwarf_handle_frame_unspec);\n+\t  targetm.dwarf_handle_frame_unspec (label, expr, XINT (src, 1));\n+\t  return;\n+\n+\t  /* Rule 16 */\n+\tcase AND:\n+          /* If this AND operation happens on stack pointer in prologue,\n+\t     we assume the stack is realigned and we extract the\n+\t     alignment.  */\n+          if (fde && XEXP (src, 0) == stack_pointer_rtx)\n+            {\n+\t      /* We interpret reg_save differently with stack_realign set.\n+\t\t Thus we must flush whatever we have queued first.  */\n+\t      dwarf2out_flush_queued_reg_saves ();\n+\n+              gcc_assert (cfa_store.reg == REGNO (XEXP (src, 0)));\n+              fde->stack_realign = 1;\n+              fde->stack_realignment = INTVAL (XEXP (src, 1));\n+              cfa_store.offset = 0;\n+\n+\t      if (cfa.reg != STACK_POINTER_REGNUM\n+\t\t  && cfa.reg != HARD_FRAME_POINTER_REGNUM)\n+\t\tfde->drap_reg = cfa.reg;\n+            }\n+          return;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      def_cfa_1 (label, &cfa);\n+      break;\n+\n+    case MEM:\n+\n+      /* Saving a register to the stack.  Make sure dest is relative to the\n+\t CFA register.  */\n+      switch (GET_CODE (XEXP (dest, 0)))\n+\t{\n+\t  /* Rule 10 */\n+\t  /* With a push.  */\n+\tcase PRE_MODIFY:\n+\tcase POST_MODIFY:\n+\t  /* We can't handle variable size modifications.  */\n+\t  gcc_assert (GET_CODE (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n+\t\t      == CONST_INT);\n+\t  offset = -INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n+\n+\t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n+\t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n+\n+\t  cfa_store.offset += offset;\n+\t  if (cfa.reg == STACK_POINTER_REGNUM)\n+\t    cfa.offset = cfa_store.offset;\n+\n+\t  if (GET_CODE (XEXP (dest, 0)) == POST_MODIFY)\n+\t    offset -= cfa_store.offset;\n+\t  else\n+\t    offset = -cfa_store.offset;\n+\t  break;\n+\n+\t  /* Rule 11 */\n+\tcase PRE_INC:\n+\tcase PRE_DEC:\n+\tcase POST_DEC:\n+\t  offset = GET_MODE_SIZE (GET_MODE (dest));\n+\t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n+\t    offset = -offset;\n+\n+\t  gcc_assert ((REGNO (XEXP (XEXP (dest, 0), 0))\n+\t\t       == STACK_POINTER_REGNUM)\n+\t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n+\n+\t  cfa_store.offset += offset;\n+\n+          /* Rule 18: If stack is aligned, we will use FP as a\n+\t     reference to represent the address of the stored\n+\t     regiser.  */\n+          if (fde\n+              && fde->stack_realign\n+              && src == hard_frame_pointer_rtx)\n+\t    {\n+\t      gcc_assert (cfa.reg != HARD_FRAME_POINTER_REGNUM);\n+\t      cfa_store.offset = 0;\n+\t    }\n+\n+\t  if (cfa.reg == STACK_POINTER_REGNUM)\n+\t    cfa.offset = cfa_store.offset;\n+\n+\t  if (GET_CODE (XEXP (dest, 0)) == POST_DEC)\n+\t    offset += -cfa_store.offset;\n+\t  else\n+\t    offset = -cfa_store.offset;\n+\t  break;\n+\n+\t  /* Rule 12 */\n+\t  /* With an offset.  */\n+\tcase PLUS:\n+\tcase MINUS:\n+\tcase LO_SUM:\n+\t  {\n+\t    int regno;\n+\n+\t    gcc_assert (CONST_INT_P (XEXP (XEXP (dest, 0), 1))\n+\t\t\t&& REG_P (XEXP (XEXP (dest, 0), 0)));\n+\t    offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+\t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n+\t      offset = -offset;\n+\n+\t    regno = REGNO (XEXP (XEXP (dest, 0), 0));\n+\n+\t    if (cfa.reg == (unsigned) regno)\n+\t      offset -= cfa.offset;\n+\t    else if (cfa_store.reg == (unsigned) regno)\n+\t      offset -= cfa_store.offset;\n+\t    else\n+\t      {\n+\t\tgcc_assert (cfa_temp.reg == (unsigned) regno);\n+\t\toffset -= cfa_temp.offset;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\t  /* Rule 13 */\n+\t  /* Without an offset.  */\n+\tcase REG:\n+\t  {\n+\t    int regno = REGNO (XEXP (dest, 0));\n+\n+\t    if (cfa.reg == (unsigned) regno)\n+\t      offset = -cfa.offset;\n+\t    else if (cfa_store.reg == (unsigned) regno)\n+\t      offset = -cfa_store.offset;\n+\t    else\n+\t      {\n+\t\tgcc_assert (cfa_temp.reg == (unsigned) regno);\n+\t\toffset = -cfa_temp.offset;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\t  /* Rule 14 */\n+\tcase POST_INC:\n+\t  gcc_assert (cfa_temp.reg\n+\t\t      == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)));\n+\t  offset = -cfa_temp.offset;\n+\t  cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+        /* Rule 17 */\n+        /* If the source operand of this MEM operation is not a\n+\t   register, basically the source is return address.  Here\n+\t   we only care how much stack grew and we don't save it.  */\n+      if (!REG_P (src))\n+        break;\n+\n+      if (REGNO (src) != STACK_POINTER_REGNUM\n+\t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n+\t  && (unsigned) REGNO (src) == cfa.reg)\n+\t{\n+\t  /* We're storing the current CFA reg into the stack.  */\n+\n+\t  if (cfa.offset == 0)\n+\t    {\n+              /* Rule 19 */\n+              /* If stack is aligned, putting CFA reg into stack means\n+\t\t we can no longer use reg + offset to represent CFA.\n+\t\t Here we use DW_CFA_def_cfa_expression instead.  The\n+\t\t result of this expression equals to the original CFA\n+\t\t value.  */\n+              if (fde\n+                  && fde->stack_realign\n+                  && cfa.indirect == 0\n+                  && cfa.reg != HARD_FRAME_POINTER_REGNUM)\n+                {\n+\t\t  dw_cfa_location cfa_exp;\n+\n+\t\t  gcc_assert (fde->drap_reg == cfa.reg);\n+\n+\t\t  cfa_exp.indirect = 1;\n+\t\t  cfa_exp.reg = HARD_FRAME_POINTER_REGNUM;\n+\t\t  cfa_exp.base_offset = offset;\n+\t\t  cfa_exp.offset = 0;\n+\n+\t\t  fde->drap_reg_saved = 1;\n+\n+\t\t  def_cfa_1 (label, &cfa_exp);\n+\t\t  break;\n+                }\n+\n+\t      /* If the source register is exactly the CFA, assume\n+\t\t we're saving SP like any other register; this happens\n+\t\t on the ARM.  */\n+\t      def_cfa_1 (label, &cfa);\n+\t      queue_reg_save (label, stack_pointer_rtx, NULL_RTX, offset);\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, we'll need to look in the stack to\n+\t\t calculate the CFA.  */\n+\t      rtx x = XEXP (dest, 0);\n+\n+\t      if (!REG_P (x))\n+\t\tx = XEXP (x, 0);\n+\t      gcc_assert (REG_P (x));\n+\n+\t      cfa.reg = REGNO (x);\n+\t      cfa.base_offset = offset;\n+\t      cfa.indirect = 1;\n+\t      def_cfa_1 (label, &cfa);\n+\t      break;\n+\t    }\n+\t}\n+\n+      def_cfa_1 (label, &cfa);\n+      {\n+\tspan = targetm.dwarf_register_span (src);\n+\n+\tif (!span)\n+\t  queue_reg_save (label, src, NULL_RTX, offset);\n+\telse\n+\t  {\n+\t    /* We have a PARALLEL describing where the contents of SRC\n+\t       live.  Queue register saves for each piece of the\n+\t       PARALLEL.  */\n+\t    int par_index;\n+\t    int limit;\n+\t    HOST_WIDE_INT span_offset = offset;\n+\n+\t    gcc_assert (GET_CODE (span) == PARALLEL);\n+\n+\t    limit = XVECLEN (span, 0);\n+\t    for (par_index = 0; par_index < limit; par_index++)\n+\t      {\n+\t\trtx elem = XVECEXP (span, 0, par_index);\n+\n+\t\tqueue_reg_save (label, elem, NULL_RTX, span_offset);\n+\t\tspan_offset += GET_MODE_SIZE (GET_MODE (elem));\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Record call frame debugging information for INSN, which either\n+   sets SP or FP (adjusting how we calculate the frame address) or saves a\n+   register to the stack.  If INSN is NULL_RTX, initialize our state.\n+\n+   If AFTER_P is false, we're being called before the insn is emitted,\n+   otherwise after.  Call instructions get invoked twice.  */\n+\n+void\n+dwarf2out_frame_debug (rtx insn, bool after_p)\n+{\n+  const char *label;\n+  rtx note, n;\n+  bool handled_one = false;\n+  bool need_flush = false;\n+\n+  if (!NONJUMP_INSN_P (insn) || clobbers_queued_reg_save (insn))\n+    dwarf2out_flush_queued_reg_saves ();\n+\n+  if (!RTX_FRAME_RELATED_P (insn))\n+    {\n+      /* ??? This should be done unconditionally since stack adjustments\n+\t matter if the stack pointer is not the CFA register anymore but\n+\t is still used to save registers.  */\n+      if (!ACCUMULATE_OUTGOING_ARGS)\n+\tdwarf2out_notice_stack_adjust (insn, after_p);\n+      return;\n+    }\n+\n+  label = dwarf2out_cfi_label (false);\n+  any_cfis_emitted = false;\n+\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    switch (REG_NOTE_KIND (note))\n+      {\n+      case REG_FRAME_RELATED_EXPR:\n+\tinsn = XEXP (note, 0);\n+\tgoto do_frame_expr;\n+\n+      case REG_CFA_DEF_CFA:\n+\tdwarf2out_frame_debug_def_cfa (XEXP (note, 0), label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_ADJUST_CFA:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  {\n+\t    n = PATTERN (insn);\n+\t    if (GET_CODE (n) == PARALLEL)\n+\t      n = XVECEXP (n, 0, 0);\n+\t  }\n+\tdwarf2out_frame_debug_adjust_cfa (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_OFFSET:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  n = single_set (insn);\n+\tdwarf2out_frame_debug_cfa_offset (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_REGISTER:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  {\n+\t    n = PATTERN (insn);\n+\t    if (GET_CODE (n) == PARALLEL)\n+\t      n = XVECEXP (n, 0, 0);\n+\t  }\n+\tdwarf2out_frame_debug_cfa_register (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_EXPRESSION:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  n = single_set (insn);\n+\tdwarf2out_frame_debug_cfa_expression (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_RESTORE:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  {\n+\t    n = PATTERN (insn);\n+\t    if (GET_CODE (n) == PARALLEL)\n+\t      n = XVECEXP (n, 0, 0);\n+\t    n = XEXP (n, 0);\n+\t  }\n+\tdwarf2out_frame_debug_cfa_restore (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_SET_VDRAP:\n+\tn = XEXP (note, 0);\n+\tif (REG_P (n))\n+\t  {\n+\t    dw_fde_ref fde = current_fde ();\n+\t    if (fde)\n+\t      {\n+\t\tgcc_assert (fde->vdrap_reg == INVALID_REGNUM);\n+\t\tif (REG_P (n))\n+\t\t  fde->vdrap_reg = REGNO (n);\n+\t      }\n+\t  }\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_WINDOW_SAVE:\n+\tdwarf2out_frame_debug_cfa_window_save (label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_FLUSH_QUEUE:\n+\t/* The actual flush happens below.  */\n+\tneed_flush = true;\n+\thandled_one = true;\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  if (handled_one)\n+    {\n+      /* Minimize the number of advances by emitting the entire queue\n+\t once anything is emitted.  */\n+      need_flush |= any_cfis_emitted;\n+    }\n+  else\n+    {\n+      insn = PATTERN (insn);\n+    do_frame_expr:\n+      dwarf2out_frame_debug_expr (insn, label);\n+\n+      /* Check again.  A parallel can save and update the same register.\n+         We could probably check just once, here, but this is safer than\n+         removing the check at the start of the function.  */\n+      if (any_cfis_emitted || clobbers_queued_reg_save (insn))\n+\tneed_flush = true;\n+    }\n+\n+  if (need_flush)\n+    dwarf2out_flush_queued_reg_saves ();\n+}\n+\n+/* Called once at the start of final to initialize some data for the\n+   current function.  */\n+void\n+dwarf2out_frame_debug_init (void)\n+{\n+  /* Flush any queued register saves.  */\n+  dwarf2out_flush_queued_reg_saves ();\n+\n+  /* Set up state for generating call frame debug info.  */\n+  lookup_cfa (&cfa);\n+  gcc_assert (cfa.reg\n+\t      == (unsigned long)DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n+\n+  cfa.reg = STACK_POINTER_REGNUM;\n+  cfa_store = cfa;\n+  cfa_temp.reg = -1;\n+  cfa_temp.offset = 0;\n+\n+  regs_saved_in_regs = NULL;\n+\n+  if (barrier_args_size)\n+    {\n+      XDELETEVEC (barrier_args_size);\n+      barrier_args_size = NULL;\n+    }\n+}\n+\n+/* Determine if we need to save and restore CFI information around this\n+   epilogue.  If SIBCALL is true, then this is a sibcall epilogue.  If\n+   we do need to save/restore, then emit the save now, and insert a\n+   NOTE_INSN_CFA_RESTORE_STATE at the appropriate place in the stream.  */\n+\n+void\n+dwarf2out_cfi_begin_epilogue (rtx insn)\n+{\n+  bool saw_frp = false;\n+  rtx i;\n+\n+  /* Scan forward to the return insn, noticing if there are possible\n+     frame related insns.  */\n+  for (i = NEXT_INSN (insn); i ; i = NEXT_INSN (i))\n+    {\n+      if (!INSN_P (i))\n+\tcontinue;\n+\n+      /* Look for both regular and sibcalls to end the block.  */\n+      if (returnjump_p (i))\n+\tbreak;\n+      if (CALL_P (i) && SIBLING_CALL_P (i))\n+\tbreak;\n+\n+      if (GET_CODE (PATTERN (i)) == SEQUENCE)\n+\t{\n+\t  int idx;\n+\t  rtx seq = PATTERN (i);\n+\n+\t  if (returnjump_p (XVECEXP (seq, 0, 0)))\n+\t    break;\n+\t  if (CALL_P (XVECEXP (seq, 0, 0))\n+\t      && SIBLING_CALL_P (XVECEXP (seq, 0, 0)))\n+\t    break;\n+\n+\t  for (idx = 0; idx < XVECLEN (seq, 0); idx++)\n+\t    if (RTX_FRAME_RELATED_P (XVECEXP (seq, 0, idx)))\n+\t      saw_frp = true;\n+\t}\n+\n+      if (RTX_FRAME_RELATED_P (i))\n+\tsaw_frp = true;\n+    }\n+\n+  /* If the port doesn't emit epilogue unwind info, we don't need a\n+     save/restore pair.  */\n+  if (!saw_frp)\n+    return;\n+\n+  /* Otherwise, search forward to see if the return insn was the last\n+     basic block of the function.  If so, we don't need save/restore.  */\n+  gcc_assert (i != NULL);\n+  i = next_real_insn (i);\n+  if (i == NULL)\n+    return;\n+\n+  /* Insert the restore before that next real insn in the stream, and before\n+     a potential NOTE_INSN_EPILOGUE_BEG -- we do need these notes to be\n+     properly nested.  This should be after any label or alignment.  This\n+     will be pushed into the CFI stream by the function below.  */\n+  while (1)\n+    {\n+      rtx p = PREV_INSN (i);\n+      if (!NOTE_P (p))\n+\tbreak;\n+      if (NOTE_KIND (p) == NOTE_INSN_BASIC_BLOCK)\n+\tbreak;\n+      i = p;\n+    }\n+  emit_note_before (NOTE_INSN_CFA_RESTORE_STATE, i);\n+\n+  emit_cfa_remember = true;\n+\n+  /* And emulate the state save.  */\n+  gcc_assert (!cfa_remember.in_use);\n+  cfa_remember = cfa;\n+  cfa_remember.in_use = 1;\n+}\n+\n+/* A \"subroutine\" of dwarf2out_cfi_begin_epilogue.  Emit the restore\n+   required.  */\n+\n+void\n+dwarf2out_frame_debug_restore_state (void)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+  const char *label = dwarf2out_cfi_label (false);\n+\n+  cfi->dw_cfi_opc = DW_CFA_restore_state;\n+  add_fde_cfi (label, cfi);\n+\n+  gcc_assert (cfa_remember.in_use);\n+  cfa = cfa_remember;\n+  cfa_remember.in_use = 0;\n+}\n+\n+/* Run once per function.  */\n+\n+void\n+dwarf2cfi_function_init (void)\n+{\n+  args_size = old_args_size = 0;\n+}\n+\n+/* Run once.  */\n+\n+void\n+dwarf2cfi_frame_init (void)\n+{\n+  dw_cfa_location loc;\n+\n+  /* Generate the CFA instructions common to all FDE's.  Do it now for the\n+     sake of lookup_cfa.  */\n+\n+  /* On entry, the Canonical Frame Address is at SP.  */\n+  memset(&loc, 0, sizeof (loc));\n+  loc.reg = STACK_POINTER_REGNUM;\n+  loc.offset = INCOMING_FRAME_SP_OFFSET;\n+  def_cfa_1 (NULL, &loc);\n+\n+  if (targetm.debug_unwind_info () == UI_DWARF2\n+      || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n+    initial_return_save (INCOMING_RETURN_ADDR_RTX);\n+}\n+\f\n+\n+/* Save the result of dwarf2out_do_frame across PCH.  */\n+static GTY(()) bool saved_do_cfi_asm = 0;\n+\n+/* Decide whether we want to emit frame unwind information for the current\n+   translation unit.  */\n+\n+int\n+dwarf2out_do_frame (void)\n+{\n+  /* We want to emit correct CFA location expressions or lists, so we\n+     have to return true if we're going to output debug info, even if\n+     we're not going to output frame or unwind info.  */\n+  if (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+    return true;\n+\n+  if (saved_do_cfi_asm)\n+    return true;\n+\n+  if (targetm.debug_unwind_info () == UI_DWARF2)\n+    return true;\n+\n+  if ((flag_unwind_tables || flag_exceptions)\n+      && targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Decide whether to emit frame unwind via assembler directives.  */\n+\n+int\n+dwarf2out_do_cfi_asm (void)\n+{\n+  int enc;\n+\n+#ifdef MIPS_DEBUGGING_INFO\n+  return false;\n+#endif\n+  if (saved_do_cfi_asm)\n+    return true;\n+  if (!flag_dwarf2_cfi_asm || !dwarf2out_do_frame ())\n+    return false;\n+  if (!HAVE_GAS_CFI_PERSONALITY_DIRECTIVE)\n+    return false;\n+\n+  /* Make sure the personality encoding is one the assembler can support.\n+     In particular, aligned addresses can't be handled.  */\n+  enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2,/*global=*/1);\n+  if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel)\n+    return false;\n+  enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0,/*global=*/0);\n+  if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel)\n+    return false;\n+\n+  /* If we can't get the assembler to emit only .debug_frame, and we don't need\n+     dwarf2 unwind info for exceptions, then emit .debug_frame by hand.  */\n+  if (!HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n+      && !flag_unwind_tables && !flag_exceptions\n+      && targetm_common.except_unwind_info (&global_options) != UI_DWARF2)\n+    return false;\n+\n+  saved_do_cfi_asm = true;\n+  return true;\n+}\n+\n+#include \"gt-dwarf2cfi.h\""}, {"sha": "0f6918d0e9f542e39c88c2f80e1818ef009242c0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 179, "deletions": 2870, "changes": 3049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=647a156710dcd42a2bccce3fcc0322f2be835cae"}, {"sha": "40cd848c5afcc5f82f63860ea87168f324ad78f3", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -18,6 +18,229 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#ifndef GCC_DWARF2OUT_H\n+#define GCC_DWARF2OUT_H 1\n+\n+#include \"dwarf2.h\"\t/* ??? Remove this once only used by dwarf2foo.c.  */\n+\n+typedef struct die_struct *dw_die_ref;\n+typedef const struct die_struct *const_dw_die_ref;\n+\n+typedef struct dw_val_struct *dw_val_ref;\n+typedef struct dw_cfi_struct *dw_cfi_ref;\n+typedef struct dw_loc_descr_struct *dw_loc_descr_ref;\n+typedef struct dw_loc_list_struct *dw_loc_list_ref;\n+\n+\n+/* Call frames are described using a sequence of Call Frame\n+   Information instructions.  The register number, offset\n+   and address fields are provided as possible operands;\n+   their use is selected by the opcode field.  */\n+\n+enum dw_cfi_oprnd_type {\n+  dw_cfi_oprnd_unused,\n+  dw_cfi_oprnd_reg_num,\n+  dw_cfi_oprnd_offset,\n+  dw_cfi_oprnd_addr,\n+  dw_cfi_oprnd_loc\n+};\n+\n+typedef union GTY(()) dw_cfi_oprnd_struct {\n+  unsigned int GTY ((tag (\"dw_cfi_oprnd_reg_num\"))) dw_cfi_reg_num;\n+  HOST_WIDE_INT GTY ((tag (\"dw_cfi_oprnd_offset\"))) dw_cfi_offset;\n+  const char * GTY ((tag (\"dw_cfi_oprnd_addr\"))) dw_cfi_addr;\n+  struct dw_loc_descr_struct * GTY ((tag (\"dw_cfi_oprnd_loc\"))) dw_cfi_loc;\n+}\n+dw_cfi_oprnd;\n+\n+typedef struct GTY(()) dw_cfi_struct {\n+  enum dwarf_call_frame_info dw_cfi_opc;\n+  dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd1_desc (%1.dw_cfi_opc)\")))\n+    dw_cfi_oprnd1;\n+  dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd2_desc (%1.dw_cfi_opc)\")))\n+    dw_cfi_oprnd2;\n+}\n+dw_cfi_node;\n+\n+DEF_VEC_P (dw_cfi_ref);\n+DEF_VEC_ALLOC_P (dw_cfi_ref, heap);\n+DEF_VEC_ALLOC_P (dw_cfi_ref, gc);\n+\n+typedef VEC(dw_cfi_ref, gc) *cfi_vec;\n+\n+typedef struct dw_fde_struct *dw_fde_ref;\n+\n+/* All call frame descriptions (FDE's) in the GCC generated DWARF\n+   refer to a single Common Information Entry (CIE), defined at\n+   the beginning of the .debug_frame section.  This use of a single\n+   CIE obviates the need to keep track of multiple CIE's\n+   in the DWARF generation routines below.  */\n+\n+typedef struct GTY(()) dw_fde_struct {\n+  tree decl;\n+  const char *dw_fde_begin;\n+  const char *dw_fde_current_label;\n+  const char *dw_fde_end;\n+  const char *dw_fde_vms_end_prologue;\n+  const char *dw_fde_vms_begin_epilogue;\n+  const char *dw_fde_second_begin;\n+  const char *dw_fde_second_end;\n+  cfi_vec dw_fde_cfi;\n+  int dw_fde_switch_cfi_index; /* Last CFI before switching sections.  */\n+  HOST_WIDE_INT stack_realignment;\n+  unsigned funcdef_number;\n+  /* Dynamic realign argument pointer register.  */\n+  unsigned int drap_reg;\n+  /* Virtual dynamic realign argument pointer register.  */\n+  unsigned int vdrap_reg;\n+  /* These 3 flags are copied from rtl_data in function.h.  */\n+  unsigned all_throwers_are_sibcalls : 1;\n+  unsigned uses_eh_lsda : 1;\n+  unsigned nothrow : 1;\n+  /* Whether we did stack realign in this call frame.  */\n+  unsigned stack_realign : 1;\n+  /* Whether dynamic realign argument pointer register has been saved.  */\n+  unsigned drap_reg_saved: 1;\n+  /* True iff dw_fde_begin label is in text_section or cold_text_section.  */\n+  unsigned in_std_section : 1;\n+  /* True iff dw_fde_second_begin label is in text_section or\n+     cold_text_section.  */\n+  unsigned second_in_std_section : 1;\n+}\n+dw_fde_node;\n+\n+\n+/* This is how we define the location of the CFA. We use to handle it\n+   as REG + OFFSET all the time,  but now it can be more complex.\n+   It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n+   Instead of passing around REG and OFFSET, we pass a copy\n+   of this structure.  */\n+typedef struct cfa_loc {\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT base_offset;\n+  unsigned int reg;\n+  BOOL_BITFIELD indirect : 1;  /* 1 if CFA is accessed via a dereference.  */\n+  BOOL_BITFIELD in_use : 1;    /* 1 if a saved cfa is stored here.  */\n+} dw_cfa_location;\n+\n+\n+/* Each DIE may have a series of attribute/value pairs.  Values\n+   can take on several forms.  The forms that are used in this\n+   implementation are listed below.  */\n+\n+enum dw_val_class\n+{\n+  dw_val_class_addr,\n+  dw_val_class_offset,\n+  dw_val_class_loc,\n+  dw_val_class_loc_list,\n+  dw_val_class_range_list,\n+  dw_val_class_const,\n+  dw_val_class_unsigned_const,\n+  dw_val_class_const_double,\n+  dw_val_class_vec,\n+  dw_val_class_flag,\n+  dw_val_class_die_ref,\n+  dw_val_class_fde_ref,\n+  dw_val_class_lbl_id,\n+  dw_val_class_lineptr,\n+  dw_val_class_str,\n+  dw_val_class_macptr,\n+  dw_val_class_file,\n+  dw_val_class_data8,\n+  dw_val_class_decl_ref,\n+  dw_val_class_vms_delta\n+};\n+\n+/* Describe a floating point constant value, or a vector constant value.  */\n+\n+typedef struct GTY(()) dw_vec_struct {\n+  unsigned char * GTY((length (\"%h.length\"))) array;\n+  unsigned length;\n+  unsigned elt_size;\n+}\n+dw_vec_const;\n+\n+/* The dw_val_node describes an attribute's value, as it is\n+   represented internally.  */\n+\n+typedef struct GTY(()) dw_val_struct {\n+  enum dw_val_class val_class;\n+  union dw_val_struct_union\n+    {\n+      rtx GTY ((tag (\"dw_val_class_addr\"))) val_addr;\n+      unsigned HOST_WIDE_INT GTY ((tag (\"dw_val_class_offset\"))) val_offset;\n+      dw_loc_list_ref GTY ((tag (\"dw_val_class_loc_list\"))) val_loc_list;\n+      dw_loc_descr_ref GTY ((tag (\"dw_val_class_loc\"))) val_loc;\n+      HOST_WIDE_INT GTY ((default)) val_int;\n+      unsigned HOST_WIDE_INT GTY ((tag (\"dw_val_class_unsigned_const\"))) val_unsigned;\n+      double_int GTY ((tag (\"dw_val_class_const_double\"))) val_double;\n+      dw_vec_const GTY ((tag (\"dw_val_class_vec\"))) val_vec;\n+      struct dw_val_die_union\n+\t{\n+\t  dw_die_ref die;\n+\t  int external;\n+\t} GTY ((tag (\"dw_val_class_die_ref\"))) val_die_ref;\n+      unsigned GTY ((tag (\"dw_val_class_fde_ref\"))) val_fde_index;\n+      struct indirect_string_node * GTY ((tag (\"dw_val_class_str\"))) val_str;\n+      char * GTY ((tag (\"dw_val_class_lbl_id\"))) val_lbl_id;\n+      unsigned char GTY ((tag (\"dw_val_class_flag\"))) val_flag;\n+      struct dwarf_file_data * GTY ((tag (\"dw_val_class_file\"))) val_file;\n+      unsigned char GTY ((tag (\"dw_val_class_data8\"))) val_data8[8];\n+      tree GTY ((tag (\"dw_val_class_decl_ref\"))) val_decl_ref;\n+      struct dw_val_vms_delta_union\n+\t{\n+\t  char * lbl1;\n+\t  char * lbl2;\n+\t} GTY ((tag (\"dw_val_class_vms_delta\"))) val_vms_delta;\n+    }\n+  GTY ((desc (\"%1.val_class\"))) v;\n+}\n+dw_val_node;\n+\n+/* Locations in memory are described using a sequence of stack machine\n+   operations.  */\n+\n+typedef struct GTY(()) dw_loc_descr_struct {\n+  dw_loc_descr_ref dw_loc_next;\n+  ENUM_BITFIELD (dwarf_location_atom) dw_loc_opc : 8;\n+  /* Used to distinguish DW_OP_addr with a direct symbol relocation\n+     from DW_OP_addr with a dtp-relative symbol relocation.  */\n+  unsigned int dtprel : 1;\n+  int dw_loc_addr;\n+  dw_val_node dw_loc_oprnd1;\n+  dw_val_node dw_loc_oprnd2;\n+}\n+dw_loc_descr_node;\n+\n+\n+/* Interface from dwarf2out.c to dwarf2cfi.c.  */\n+extern dw_fde_ref current_fde (void);\n+extern void output_cfi_directive (dw_cfi_ref);\n+extern struct dw_loc_descr_struct *build_cfa_loc\n+  (dw_cfa_location *, HOST_WIDE_INT);\n+extern struct dw_loc_descr_struct *build_cfa_aligned_loc\n+  (dw_cfa_location *, HOST_WIDE_INT offset, HOST_WIDE_INT alignment);\n+extern struct dw_loc_descr_struct *mem_loc_descriptor\n+  (rtx, enum machine_mode mode, enum machine_mode mem_mode,\n+   enum var_init_status);\n+extern enum machine_mode get_address_mode (rtx mem);\n+\n+/* Interface from dwarf2cfi.c to dwarf2out.c.  */\n+extern void dwarf2cfi_frame_init (void);\n+extern void dwarf2cfi_function_init (void);\n+extern void lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc,\n+\t\t\t  dw_cfa_location *remember);\n+extern bool cfa_equal_p (const dw_cfa_location *, const dw_cfa_location *);\n+\n+extern GTY(()) cfi_vec cie_cfi_vec;\n+\n+/* Interface from dwarf2*.c to the rest of the compiler.  */\n+extern enum dw_cfi_oprnd_type dw_cfi_oprnd1_desc\n+  (enum dwarf_call_frame_info cfi);\n+extern enum dw_cfi_oprnd_type dw_cfi_oprnd2_desc\n+  (enum dwarf_call_frame_info cfi);\n+\n extern void dwarf2out_decl (tree);\n extern void dwarf2out_frame_debug (rtx, bool);\n extern void dwarf2out_frame_debug_init (void);\n@@ -47,3 +270,5 @@ struct array_descr_info\n       tree stride;\n     } dimen[10];\n };\n+\n+#endif /* GCC_DWARF2OUT_H */"}, {"sha": "9537791c20b6ad1f211d8b45e54b2b8e33f29bdd", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -1560,7 +1560,7 @@ open_base_files (void)\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n       \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n       \"target.h\", \"ipa-prop.h\", \"lto-streamer.h\", \"target-globals.h\",\n-      \"ipa-inline.h\", NULL\n+      \"ipa-inline.h\", \"dwarf2out.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "5e009c0b871ce421838217347e22004f02de7a14", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/647a156710dcd42a2bccce3fcc0322f2be835cae/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=647a156710dcd42a2bccce3fcc0322f2be835cae", "patch": "@@ -944,16 +944,6 @@ extern const char * const reg_note_name[];\n /* PARM_DECL DEBUG_PARAMETER_REF references.  */\n #define DEBUG_PARAMETER_REF_DECL(RTX) XCTREE (RTX, 0, DEBUG_PARAMETER_REF)\n \n-/* Possible initialization status of a variable.   When requested\n-   by the user, this information is tracked and recorded in the DWARF\n-   debug information, along with the variable's location.  */\n-enum var_init_status\n-{\n-  VAR_INIT_STATUS_UNKNOWN,\n-  VAR_INIT_STATUS_UNINITIALIZED,\n-  VAR_INIT_STATUS_INITIALIZED\n-};\n-\n /* Codes that appear in the NOTE_KIND field for kinds of notes\n    that are not line numbers.  These codes are all negative.\n "}]}