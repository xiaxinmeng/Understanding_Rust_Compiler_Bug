{"sha": "c35cce41daad1894587834b71c9342669ecf3fa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM1Y2NlNDFkYWFkMTg5NDU4NzgzNGI3MWM5MzQyNjY5ZWNmM2ZhNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-04T18:13:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-04T18:13:22Z"}, "message": "Correct many new ABI issues regarding vbase and vcall offset layout.\n\n\tCorrect many new ABI issues regarding vbase and vcall offset\n\tlayout.\n\t* cp-tree.h (BINFO_VTABLE): Document.\n\t(struct lang_type): Tweak formatting.\n\t(BINFO_PRIMARY_BINFO): Add to documentation.\n\t(CLASSTYPE_VSIZE): Fix typo in comment.\n\t(CLASSTYPE_VBASECLASSES): Update documentation.\n\t(BINFO_VBASE_MARKED): Remove.\n\t(SET_BINFO_VBASE_MARKED): Likewise.\n\t(CLEAR_BINFO_VBASE_MARKED): Likewise.\n\t(BINFO_FIELDS_MARKED): Remove.\n\t(SET_BINFO_FIELDS_MARKED): Likewise.\n\t(CLEAR_BINFO_FIELDS_MARKED): Likewise.\n\t(enum access_kind): New enumeration.\n\t(num_extra_vtbl_entries): Remove declaration.\n\t(size_extra_vtbl_entries): Likewise.\n\t(get_vtbl_decl_for_binfo): New function.\n\t(dfs_vbase_unmark): Remove declaration.\n\t(mark_primary_bases): Likewise.\n\t* class.c (SAME_FN): Remove.\n\t(struct vcall_offset_data_s): Move definition.\n\t(build_vbase_pointer): Use `build', not `build_binary_op', to\n\taccess the vbase pointer under the new ABI.\n\t(build_vtable_entry_ref): Use get_vtbl_decl_for_binfo.\n\t(build_primary_vtable): Likewise.\n\t(dfs_mark_primary_bases): Move here from search.c.\n\t(mark_primary_bases): Likewise.\n\t(determine_primary_bases): Under the new ABI, don't make a base\n\tclass a primary base just because we don't yet have any virtual\n\tfunctions.\n\t(layout_vtable_decl): Use get_vtbl_decl_for_binfo.\n\t(num_vfun_entries): Remove.\n\t(dfs_count_virtuals): Likewise.\n\t(num_extra_vtbl_entries): Likewise.\n\t(size_extra_vtbl_entries): Likewise.\n\t(layout_virtual_bases): Iterate in inheritance graph order under\n\tthe new ABI.\n\t(finish_struct_1): Use TYPE_VFIELD, not CLASSTYPE_VSIZE, to\n\tindicate that a vfield is present.\n\t(init_class_processing): Initialize access_public_node, etc., from\n\tak_public, etc.\n\t(get_vtbl_decl_for_binfo): New function.\n\t(dump_class_hierarchy_r): Likewise.\n\t(dump_class_hierarchy): Use it.\n\t(finish_vtbls): Build the vtbls in inheritance graph order.\n\t(dfs_finish_vtbls): Adjust call to build_vtbl_initializer.\n\t(initialize_vtable): Use get_vtbl_decl_for_binfo.\n\t(accumulate_vtbl_inits): Add comments explaining why a pre-order\n\twalk is required.\n\t(dfs_accumulate_vtbl_inits): Set BINFO_VTABLE to the location\n\twhere the vptr points, even for primary vtables.\n\t(build_vtbl_initializer): Adjust handling of vbase and vcall\n\toffsets.\n\t(build_vcall_and_vbase_vtable_entries): New function.\n\t(dfs_build_vbase_offset_vtbl_entries): Remove.\n\t(build_vbase_offset_vtbl_entries): Reimplement.\n\t(dfs_build_vcall_offset_vtbl_entries): Don't include virtuals that\n\twere already handled in a primary base class vtable.\n\t(build_vcall_offset_vtbl_entries): Adjust.\n\t(build_rtti_vtbl_entries): Adjust.\n\t* decl2.c (output_vtable_inherit): Use get_vtbl_decl_for_binfo.\n\t* init.c (expand_virtual_init): Simplify.\n\t* repo.c (repo_get_id): Use get_vtbl_decl_for_binfo.\n\t* rtti.c (create_pseudo_type_info): Adjust calculation of vptr.\n\t* search.c (BINFO_ACCESS): New macro.\n\t(SET_BINFO_ACCESS): Likewise.\n\t(dfs_access_in_type): Manipulate access_kinds, not access nodes.\n\t(access_in_type): Likewise.\n\t(dfs_accessible_p): Likewise.\n\t(protected_accessible_p): Likewise.\n\t(lookup_fnfields_1): Adjust documentation.\n\t(dfs_mark_primary_bases): Move to class.c\n\t(mark_primary_bases): Likewise.\n\t(dfs_vbase_unmark): Remove.\n\t(virtual_context): Use BINFO_FOR_VBASE.\n\t(dfs_get_vbase_types): Simplify.\n\t(dfs_build_inheritance_graph_order): New function.\n\t(get_vbase_types): Use it.\n\t* tree.c (debug_binfo): Use get_vtbl_decl_for_binfo.\n\n\t* tinfo.cc (get_vbase_offset): New function.\n\t(__vmi_class_type_info::do_find_public_src): Use it.\n\t(__vmi_class_type_info::do_dyncast): Likewise.\n\t(__vmi_class_type_info::do_upcast): Likewise.\n\nFrom-SVN: r32905", "tree": {"sha": "7f6d12b8e8dc1ec65000844a7421f72c20af3673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f6d12b8e8dc1ec65000844a7421f72c20af3673"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c35cce41daad1894587834b71c9342669ecf3fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c35cce41daad1894587834b71c9342669ecf3fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c35cce41daad1894587834b71c9342669ecf3fa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c35cce41daad1894587834b71c9342669ecf3fa7/comments", "author": null, "committer": null, "parents": [{"sha": "f2d33f132186edfa44a48552027100705264b06c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d33f132186edfa44a48552027100705264b06c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d33f132186edfa44a48552027100705264b06c"}], "stats": {"total": 1565, "additions": 979, "deletions": 586}, "files": [{"sha": "8fcacd2720eea021dd250afe4e24c77fd24094f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -1,3 +1,90 @@\n+2000-04-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tCorrect many new ABI issues regarding vbase and vcall offset\n+\tlayout.\n+\t* cp-tree.h (BINFO_VTABLE): Document.\n+\t(struct lang_type): Tweak formatting.\n+\t(BINFO_PRIMARY_BINFO): Add to documentation.\n+\t(CLASSTYPE_VSIZE): Fix typo in comment.\n+\t(CLASSTYPE_VBASECLASSES): Update documentation.\n+\t(BINFO_VBASE_MARKED): Remove.\n+\t(SET_BINFO_VBASE_MARKED): Likewise.\n+\t(CLEAR_BINFO_VBASE_MARKED): Likewise.\n+\t(BINFO_FIELDS_MARKED): Remove.\n+\t(SET_BINFO_FIELDS_MARKED): Likewise.\n+\t(CLEAR_BINFO_FIELDS_MARKED): Likewise.\n+\t(enum access_kind): New enumeration.\n+\t(num_extra_vtbl_entries): Remove declaration.\n+\t(size_extra_vtbl_entries): Likewise.\n+\t(get_vtbl_decl_for_binfo): New function.\n+\t(dfs_vbase_unmark): Remove declaration.\n+\t(mark_primary_bases): Likewise.\n+\t* class.c (SAME_FN): Remove.\n+\t(struct vcall_offset_data_s): Move definition.\n+\t(build_vbase_pointer): Use `build', not `build_binary_op', to\n+\taccess the vbase pointer under the new ABI.\n+\t(build_vtable_entry_ref): Use get_vtbl_decl_for_binfo.\n+\t(build_primary_vtable): Likewise.\n+\t(dfs_mark_primary_bases): Move here from search.c.\n+\t(mark_primary_bases): Likewise.\n+\t(determine_primary_bases): Under the new ABI, don't make a base\n+\tclass a primary base just because we don't yet have any virtual\n+\tfunctions.\n+\t(layout_vtable_decl): Use get_vtbl_decl_for_binfo.\n+\t(num_vfun_entries): Remove.\n+\t(dfs_count_virtuals): Likewise.\n+\t(num_extra_vtbl_entries): Likewise.\n+\t(size_extra_vtbl_entries): Likewise.\n+\t(layout_virtual_bases): Iterate in inheritance graph order under\n+\tthe new ABI.\n+\t(finish_struct_1): Use TYPE_VFIELD, not CLASSTYPE_VSIZE, to\n+\tindicate that a vfield is present.\n+\t(init_class_processing): Initialize access_public_node, etc., from\n+\tak_public, etc.\n+\t(get_vtbl_decl_for_binfo): New function.\n+\t(dump_class_hierarchy_r): Likewise.\n+\t(dump_class_hierarchy): Use it.\n+\t(finish_vtbls): Build the vtbls in inheritance graph order.\n+\t(dfs_finish_vtbls): Adjust call to build_vtbl_initializer.\n+\t(initialize_vtable): Use get_vtbl_decl_for_binfo.\n+\t(accumulate_vtbl_inits): Add comments explaining why a pre-order\n+\twalk is required.\n+\t(dfs_accumulate_vtbl_inits): Set BINFO_VTABLE to the location\n+\twhere the vptr points, even for primary vtables.\n+\t(build_vtbl_initializer): Adjust handling of vbase and vcall\n+\toffsets.\n+\t(build_vcall_and_vbase_vtable_entries): New function.\n+\t(dfs_build_vbase_offset_vtbl_entries): Remove.\n+\t(build_vbase_offset_vtbl_entries): Reimplement.\n+\t(dfs_build_vcall_offset_vtbl_entries): Don't include virtuals that\n+\twere already handled in a primary base class vtable.\n+\t(build_vcall_offset_vtbl_entries): Adjust.\n+\t(build_rtti_vtbl_entries): Adjust.\n+\t* decl2.c (output_vtable_inherit): Use get_vtbl_decl_for_binfo.\n+\t* init.c (expand_virtual_init): Simplify.\n+\t* repo.c (repo_get_id): Use get_vtbl_decl_for_binfo.\n+\t* rtti.c (create_pseudo_type_info): Adjust calculation of vptr.\n+\t* search.c (BINFO_ACCESS): New macro.\n+\t(SET_BINFO_ACCESS): Likewise.\n+\t(dfs_access_in_type): Manipulate access_kinds, not access nodes.\n+\t(access_in_type): Likewise.\n+\t(dfs_accessible_p): Likewise.\n+\t(protected_accessible_p): Likewise.\n+\t(lookup_fnfields_1): Adjust documentation.\n+\t(dfs_mark_primary_bases): Move to class.c\n+\t(mark_primary_bases): Likewise.\n+\t(dfs_vbase_unmark): Remove.\n+\t(virtual_context): Use BINFO_FOR_VBASE.\n+\t(dfs_get_vbase_types): Simplify.\n+\t(dfs_build_inheritance_graph_order): New function.\n+\t(get_vbase_types): Use it.\n+\t* tree.c (debug_binfo): Use get_vtbl_decl_for_binfo.\n+\n+\t* tinfo.cc (get_vbase_offset): New function.\n+\t(__vmi_class_type_info::do_find_public_src): Use it.\n+\t(__vmi_class_type_info::do_dyncast): Likewise.\n+\t(__vmi_class_type_info::do_upcast): Likewise.\n+\t\n 2000-04-03  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* lang-specs.h: Pass -fno-show-column to the preprocessor."}, {"sha": "a9f35951375ab9664289a0597dfa0bb9df92125b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 506, "deletions": 359, "changes": 865, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -38,12 +38,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* This is how we tell when two virtual member functions are really the\n-   same.  */\n-#define SAME_FN(FN1DECL, FN2DECL) (DECL_ASSEMBLER_NAME (FN1DECL) == DECL_ASSEMBLER_NAME (FN2DECL))\n-\n-extern void set_class_shadows PARAMS ((tree));\n-\n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */\n \n@@ -68,6 +62,22 @@ typedef struct class_stack_node {\n   splay_tree names_used;\n }* class_stack_node_t;\n \n+typedef struct vcall_offset_data_s\n+{\n+  /* The binfo for the most-derived type.  */\n+  tree derived;\n+  /* The binfo for the virtual base for which we're building\n+     initializers.  */\n+  tree vbase;\n+  /* The vcall offset initializers built up so far.  */\n+  tree inits;\n+  /* The vtable index of the next vcall or vbase offset.  */\n+  tree index;\n+  /* Nonzero if we are building the initializer for the primary\n+     vtable.  */\n+  int primary_p;\n+} vcall_offset_data;\n+\n /* The stack itself.  This is an dynamically resized array.  The\n    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */\n static int current_class_stack_size;\n@@ -108,7 +118,7 @@ static tree fixed_type_or_null PARAMS ((tree, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n \t\t\t\t\t\t\t  int, tree));\n static void build_vtable_entry_ref PARAMS ((tree, tree, tree));\n-static tree build_vtbl_initializer PARAMS ((tree, tree));\n+static tree build_vtbl_initializer PARAMS ((tree, tree, int *));\n static int count_fields PARAMS ((tree));\n static int add_fields_to_vec PARAMS ((tree, tree, int));\n static void check_bitfield_decl PARAMS ((tree));\n@@ -135,19 +145,17 @@ static void propagate_binfo_offsets PARAMS ((tree, tree));\n static void layout_virtual_bases PARAMS ((tree, varray_type *));\n static tree dfs_set_offset_for_shared_vbases PARAMS ((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n-static tree dfs_build_vbase_offset_vtbl_entries PARAMS ((tree, void *));\n-static tree build_vbase_offset_vtbl_entries PARAMS ((tree, tree));\n+static void build_vbase_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *));\n static tree dfs_vcall_offset_queue_p PARAMS ((tree, void *));\n static tree dfs_build_vcall_offset_vtbl_entries PARAMS ((tree, void *));\n-static tree build_vcall_offset_vtbl_entries PARAMS ((tree, tree));\n-static tree dfs_count_virtuals PARAMS ((tree, void *));\n+static void build_vcall_offset_vtbl_entries PARAMS ((tree, vcall_offset_data *));\n static void layout_vtable_decl PARAMS ((tree, int));\n-static int num_vfun_entries PARAMS ((tree));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n static tree find_final_overrider PARAMS ((tree, tree, tree));\n static tree dfs_find_base PARAMS ((tree, void *));\n static int make_new_vtable PARAMS ((tree, tree));\n-extern void dump_class_hierarchy PARAMS ((tree, int));\n+static void dump_class_hierarchy_r PARAMS ((tree, tree, int));\n+extern void dump_class_hierarchy PARAMS ((tree));\n static tree build_vtable PARAMS ((tree, tree, tree));\n static void initialize_vtable PARAMS ((tree, tree));\n static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n@@ -162,6 +170,10 @@ static void layout_empty_base PARAMS ((tree, tree, varray_type));\n static void accumulate_vtbl_inits PARAMS ((tree, tree));\n static void set_vindex PARAMS ((tree, tree, int *));\n static tree build_rtti_vtbl_entries PARAMS ((tree, tree));\n+static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n+\t\t\t\t\t\t\tvcall_offset_data *));\n+static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n+static void mark_primary_bases PARAMS ((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -274,9 +286,10 @@ build_vbase_pointer (exp, type)\n       /* Find the virtual function table pointer.  */\n       vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n       /* Compute the location where the offset will lie.  */\n-      vbase_ptr = build_binary_op (PLUS_EXPR, \n-\t\t\t\t   vbase_ptr,\n-\t\t\t\t   BINFO_VPTR_FIELD (vbase));\n+      vbase_ptr = build (PLUS_EXPR, \n+\t\t\t TREE_TYPE (vbase_ptr),\n+\t\t\t vbase_ptr,\n+\t\t\t BINFO_VPTR_FIELD (vbase));\n       vbase_ptr = build1 (NOP_EXPR, \n \t\t\t  build_pointer_type (ptrdiff_type_node),\n \t\t\t  vbase_ptr);\n@@ -462,7 +475,7 @@ build_vtable_entry_ref (basetype, vtbl, idx)\n   static char asm_stmt[] = \".vtable_entry %c0, %c1\";\n   tree s, i, i2;\n \n-  s = build_unary_op (ADDR_EXPR, TYPE_BINFO_VTABLE (basetype), 0);\n+  s = build_unary_op (ADDR_EXPR, get_vtbl_decl_for_binfo (basetype), 0);\n   s = build_tree_list (build_string (1, \"s\"), s);\n \n   i = build_array_ref (vtbl, idx);\n@@ -533,7 +546,23 @@ build_vtbl_ref (instance, idx)\n \t  && (TREE_CODE (instance) == RESULT_DECL\n \t      || TREE_CODE (instance) == PARM_DECL\n \t      || TREE_CODE (instance) == VAR_DECL))\n-\tvtbl = TYPE_BINFO_VTABLE (basetype);\n+\t{\n+\t  vtbl = TYPE_BINFO_VTABLE (basetype);\n+\t  /* Knowing the dynamic type of INSTANCE we can easily obtain\n+\t     the correct vtable entry.  In the new ABI, we resolve\n+\t     this back to be in terms of the primary vtable.  */\n+\t  if (TREE_CODE (vtbl) == PLUS_EXPR)\n+\t    {\n+\t      idx = fold (build (PLUS_EXPR,\n+\t\t\t\t TREE_TYPE (idx),\n+\t\t\t\t idx,\n+\t\t\t\t build (EXACT_DIV_EXPR,\n+\t\t\t\t\tTREE_TYPE (idx),\n+\t\t\t\t\tTREE_OPERAND (vtbl, 1),\n+\t\t\t\t\tTYPE_SIZE_UNIT (vtable_entry_type))));\n+\t      vtbl = get_vtbl_decl_for_binfo (TYPE_BINFO (basetype));\n+\t    }\n+\t}\n       else\n \tvtbl = build_vfield_ref (instance, basetype);\n     }\n@@ -733,10 +762,9 @@ build_primary_vtable (binfo, type)\n \treturn 0;\n       \n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n-      TREE_TYPE (decl) = TREE_TYPE (BINFO_VTABLE (binfo));\n-      DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (BINFO_VTABLE (binfo)));\n-      DECL_SIZE_UNIT (decl)\n-\t= TYPE_SIZE_UNIT (TREE_TYPE (BINFO_VTABLE (binfo)));\n+      TREE_TYPE (decl) = TREE_TYPE (get_vtbl_decl_for_binfo (binfo));\n+      DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (decl));\n+      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n     }\n   else\n     {\n@@ -1623,6 +1651,97 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n     }\n }\n \n+/* Called via dfs_walk from mark_primary_bases.  Sets\n+   BINFO_PRIMARY_MARKED_P for BINFO, if appropriate.  */\n+\n+static tree\n+dfs_mark_primary_bases (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  int i;\n+  tree base_binfo;\n+\n+  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+    return NULL_TREE;\n+\n+  i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+  base_binfo = BINFO_BASETYPE (binfo, i);\n+\n+  if (!TREE_VIA_VIRTUAL (base_binfo))\n+    /* Non-virtual base classes are easy.  */\n+    BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n+  else\n+    {\n+      tree shared_binfo;\n+\n+      shared_binfo \n+\t= BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), (tree) data);\n+\n+      /* If this virtual base is not already primary somewhere else in\n+\t the hiearchy, then we'll be using this copy.  */\n+      if (!BINFO_VBASE_PRIMARY_P (shared_binfo))\n+\t{\n+\t  BINFO_VBASE_PRIMARY_P (shared_binfo) = 1;\n+\t  BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Set BINFO_PRIMARY_MARKED_P for all binfos in the hierarchy\n+   dominated by BINFO that are primary bases.  */\n+\n+static void\n+mark_primary_bases (type)\n+     tree type;\n+{\n+  tree vbases;\n+\n+  /* Mark the TYPE_BINFO hierarchy.  We need to mark primary bases in\n+     pre-order to deal with primary virtual bases.  (The virtual base\n+     would be skipped if it were not marked as primary, and that\n+     requires getting to dfs_mark_primary_bases before\n+     dfs_skip_nonprimary_vbases_unmarkedp has a chance to skip the\n+     virtual base.)  */\n+  dfs_walk_real (TYPE_BINFO (type), dfs_mark_primary_bases, NULL,\n+\t\t dfs_skip_nonprimary_vbases_unmarkedp, type);\n+\n+  /* Now go through the virtual base classes in inheritance graph\n+     order.  Any that are not already primary will need to be\n+     allocated in TYPE, and so we need to mark their primary bases.  */\n+  for (vbases = TYPE_BINFO (type); vbases; vbases = TREE_CHAIN (vbases))\n+    {\n+      tree vbase;\n+\n+      /* Make sure that only BINFOs appear on this list.\n+\t Historically, the TREE_CHAIN was used for other purposes, and\n+\t we want to make sure that none of those uses remain.  */\n+      my_friendly_assert (TREE_CODE (vbases) == TREE_VEC, 20000402);\n+\n+      if (!TREE_VIA_VIRTUAL (vbases))\n+\tcontinue;\n+\n+      vbase = BINFO_FOR_VBASE (BINFO_TYPE (vbases), type);\n+      if (BINFO_VBASE_PRIMARY_P (vbase))\n+\t/* This virtual base was already included in the hierarchy, so\n+\t   there's nothing to do here.  */\n+\tcontinue;\n+\n+      /* Temporarily pretend that VBASE is primary so that its bases\n+\t will be walked; this is the real copy of VBASE.  */\n+      BINFO_PRIMARY_MARKED_P (vbase) = 1;\n+\n+      /* Now, walk its bases.  */\n+      dfs_walk_real (vbase, dfs_mark_primary_bases, NULL,\n+\t\t     dfs_skip_nonprimary_vbases_unmarkedp, type);\n+\n+      /* VBASE wasn't really primary.  */\n+      BINFO_PRIMARY_MARKED_P (vbase) = 0;\n+    }\n+}\n+\n /* Make the Ith baseclass of T its primary base.  */\n \n static void\n@@ -1696,7 +1815,7 @@ determine_primary_base (t, vfuns_p)\n \t\t\t\t VF_BASETYPE_VALUE (vfields),\n \t\t\t\t CLASSTYPE_VFIELDS (t));\n \n-\t      if (*vfuns_p == 0)\n+\t      if (!flag_new_abi && *vfuns_p == 0)\n \t\tset_primary_base (t, i, vfuns_p);\n \t    }\n \t}\n@@ -2184,19 +2303,19 @@ layout_vtable_decl (binfo, n)\n {\n   tree itype;\n   tree atype;\n+  tree vtable;\n \n   itype = size_int (n);\n   atype = build_cplus_array_type (vtable_entry_type, \n \t\t\t\t  build_index_type (itype));\n   layout_type (atype);\n \n   /* We may have to grow the vtable.  */\n-  if (!same_type_p (TREE_TYPE (BINFO_VTABLE (binfo)), atype))\n+  vtable = get_vtbl_decl_for_binfo (binfo);\n+  if (!same_type_p (TREE_TYPE (vtable), atype))\n     {\n-      tree vtable = BINFO_VTABLE (binfo);\n-\n       TREE_TYPE (vtable) = atype;\n-      DECL_SIZE (vtable) = DECL_SIZE_UNIT (vtable) = 0;\n+      DECL_SIZE (vtable) = DECL_SIZE_UNIT (vtable) = NULL_TREE;\n       layout_decl (vtable, 0);\n \n       /* At one time the vtable info was grabbed 2 words at a time.  This\n@@ -2206,104 +2325,6 @@ layout_vtable_decl (binfo, n)\n     }\n }\n \n-/* Returns the number of virtual function table entries (excluding\n-   RTTI information, vbase and vcall offests, etc.) in the vtable for\n-   BINFO.  */\n-\n-static int\n-num_vfun_entries (binfo)\n-     tree binfo;\n-{\n-  return list_length (BINFO_VIRTUALS (binfo));\n-}\n-\n-typedef struct vcall_offset_data_s\n-{\n-  /* The binfo for the most-derived type.  */\n-  tree derived;\n-  /* The binfo for the virtual base for which we're building\n-     initializers.  */\n-  tree vbase;\n-  /* The vcall offset initializers built up so far.  */\n-  tree inits;\n-  /* The number of vcall offsets accumulated.  */\n-  int offsets;\n-} vcall_offset_data;\n-\n-/* Called from num_extra_vtbl_entries via dfs_walk.  */\n-\n-static tree\n-dfs_count_virtuals (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  /* Non-primary bases are not interesting; all of the virtual\n-     function table entries have been overridden.  */\n-  if (!BINFO_PRIMARY_MARKED_P (binfo))\n-    ((vcall_offset_data *) data)->offsets += num_vfun_entries (binfo);\n-  \n-  return NULL_TREE;\n-}\n-\n-/* Returns the number of extra entries (at negative indices) required\n-   for BINFO's vtable.  */\n-\n-tree\n-num_extra_vtbl_entries (binfo)\n-     tree binfo;\n-{\n-  tree type;\n-  int entries;\n-\n-  type = BINFO_TYPE (binfo);\n-  entries = 0;\n-\n-  /* There is an entry for the offset to each virtual base.  */\n-  if (vbase_offsets_in_vtable_p ())\n-    entries += list_length (CLASSTYPE_VBASECLASSES (type));\n-\n-  /* If this is a virtual base, there are entries for each virtual\n-     function defined in this class or its bases.  */\n-  if (vcall_offsets_in_vtable_p () && TREE_VIA_VIRTUAL (binfo))\n-    {\n-      vcall_offset_data vod;\n-\n-      vod.vbase = binfo;\n-      vod.offsets = 0;\n-      dfs_walk (binfo,\n-\t\tdfs_count_virtuals,\n-\t\tdfs_vcall_offset_queue_p,\n-\t\t&vod);\n-      entries += vod.offsets;\n-    }\n-      \n-  /* When laying out COM-compatible classes, there are no RTTI\n-     entries.  */\n-  if (CLASSTYPE_COM_INTERFACE (type))\n-    ;\n-  /* When using vtable thunks, there are two RTTI entries: the \"offset\n-     to top\" value and the RTTI entry itself.  */\n-  else if (flag_vtable_thunks)\n-    entries += 2;\n-  /* When not using vtable thunks there is only a single entry.  */\n-  else\n-    entries += 1;\n-\n-  return size_int (entries);\n-}\n-\n-/* Returns the offset (in bytes) from the beginning of BINFO's vtable\n-   where the vptr should actually point.  */\n-\n-tree\n-size_extra_vtbl_entries (binfo)\n-     tree binfo;\n-{\n-  tree offset = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (vtable_entry_type),\n-\t\t\t    num_extra_vtbl_entries (binfo));\n-  return fold (offset);\n-}\n-\n /* True if we should override the given BASE_FNDECL with the given\n    FNDECL.  */\n \n@@ -3989,7 +4010,7 @@ check_bases_and_members (t, empty_p)\n /* If T needs a pointer to its virtual function table, set TYPE_VFIELD\n    accordingly.  If a new vfield was created (because T doesn't have a\n    primary base class), then the newly created field is returned.  It\n-   is not added to the TYPE_FIELDS list; it is the callers\n+   is not added to the TYPE_FIELDS list; it is the caller's\n    responsibility to do that.  */\n \n static tree\n@@ -4205,7 +4226,7 @@ layout_virtual_bases (t, base_offsets)\n      tree t;\n      varray_type *base_offsets;\n {\n-  tree vbase;\n+  tree vbases;\n   unsigned HOST_WIDE_INT dsize;\n   unsigned HOST_WIDE_INT eoc;\n \n@@ -4225,53 +4246,70 @@ layout_virtual_bases (t, base_offsets)\n   TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), BITS_PER_UNIT);\n \n   /* Go through the virtual bases, allocating space for each virtual\n-     base that is not already a primary base class.  */\n-  for (vbase = CLASSTYPE_VBASECLASSES (t); \n-       vbase; \n-       vbase = TREE_CHAIN (vbase))\n-    if (!BINFO_VBASE_PRIMARY_P (vbase))\n-      {\n-\t/* This virtual base is not a primary base of any class in the\n-\t   hierarchy, so we have to add space for it.  */\n-\ttree basetype;\n-\tunsigned int desired_align;\n+     base that is not already a primary base class.  Under the new\n+     ABI, these are allocated according to a depth-first left-to-right\n+     postorder traversal; in the new ABI, inheritance graph order is\n+     used instead.  */\n+  for (vbases = (flag_new_abi \n+\t\t ? TYPE_BINFO (t) \n+\t\t : CLASSTYPE_VBASECLASSES (t));\n+       vbases; \n+       vbases = TREE_CHAIN (vbases))\n+    {\n+      tree vbase;\n+\n+      if (!TREE_VIA_VIRTUAL (vbases))\n+\tcontinue;\n+\n+      if (flag_new_abi)\n+\tvbase = BINFO_FOR_VBASE (BINFO_TYPE (vbases), t);\n+      else\n+\tvbase = vbases;\n+\n+      if (!BINFO_VBASE_PRIMARY_P (vbase))\n+\t{\n+\t  /* This virtual base is not a primary base of any class in the\n+\t     hierarchy, so we have to add space for it.  */\n+\t  tree basetype;\n+\t  unsigned int desired_align;\n \n-\tbasetype = BINFO_TYPE (vbase);\n+\t  basetype = BINFO_TYPE (vbase);\n \n-\tif (flag_new_abi)\n-\t  desired_align = CLASSTYPE_ALIGN (basetype);\n-\telse\n-\t  /* Under the old ABI, virtual bases were aligned as for the\n+\t  if (flag_new_abi)\n+\t    desired_align = CLASSTYPE_ALIGN (basetype);\n+\t  else\n+\t    /* Under the old ABI, virtual bases were aligned as for the\n \t     entire base object (including its virtual bases).  That's\n \t     wasteful, in general.  */\n-\t  desired_align = TYPE_ALIGN (basetype);\n-\tTYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n-\n-\t/* Add padding so that we can put the virtual base class at an\n-\t   appropriately aligned offset.  */\n-\tdsize = CEIL (dsize, desired_align) * desired_align;\n-\n-\t/* Under the new ABI, we try to squish empty virtual bases in\n-\t   just like ordinary empty bases.  */\n-\tif (flag_new_abi && is_empty_class (basetype))\n-\t  layout_empty_base (vbase,\n-\t\t\t     size_int (CEIL (dsize, BITS_PER_UNIT)),\n-\t\t\t     *base_offsets);\n-\telse\n-\t  {\n-\t    /* And compute the offset of the virtual base.  */\n-\t    propagate_binfo_offsets (vbase, \n-\t\t\t\t     ssize_int (CEIL (dsize, BITS_PER_UNIT)));\n-\t    /* Every virtual baseclass takes a least a UNIT, so that\n-\t       we can take it's address and get something different\n-\t       for each base.  */\n-\t    dsize += MAX (BITS_PER_UNIT,\n-\t\t\t  tree_low_cst (CLASSTYPE_SIZE (basetype), 0));\n-\t  }\n+\t    desired_align = TYPE_ALIGN (basetype);\n+\t  TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n+\n+\t  /* Add padding so that we can put the virtual base class at an\n+\t     appropriately aligned offset.  */\n+\t  dsize = CEIL (dsize, desired_align) * desired_align;\n+\n+\t  /* Under the new ABI, we try to squish empty virtual bases in\n+\t     just like ordinary empty bases.  */\n+\t  if (flag_new_abi && is_empty_class (basetype))\n+\t    layout_empty_base (vbase,\n+\t\t\t       size_int (CEIL (dsize, BITS_PER_UNIT)),\n+\t\t\t       *base_offsets);\n+\t  else\n+\t    {\n+\t      /* And compute the offset of the virtual base.  */\n+\t      propagate_binfo_offsets (vbase, \n+\t\t\t\t       ssize_int (CEIL (dsize, BITS_PER_UNIT)));\n+\t      /* Every virtual baseclass takes a least a UNIT, so that\n+\t\t we can take it's address and get something different\n+\t\t for each base.  */\n+\t      dsize += MAX (BITS_PER_UNIT,\n+\t\t\t    tree_low_cst (CLASSTYPE_SIZE (basetype), 0));\n+\t    }\n \n-\t/* Keep track of the offsets assigned to this virtual base.  */\n-\trecord_base_offsets (vbase, base_offsets);\n-      }\n+\t  /* Keep track of the offsets assigned to this virtual base.  */\n+\t  record_base_offsets (vbase, base_offsets);\n+\t}\n+    }\n \n   /* Make sure that all of the CLASSTYPE_VBASECLASSES have their\n      BINFO_OFFSET set correctly.  Those we just allocated certainly\n@@ -4288,10 +4326,10 @@ layout_virtual_bases (t, base_offsets)\n      in get_base_distance depend on the BINFO_OFFSETs being set\n      correctly.  */\n   dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n-  for (vbase = CLASSTYPE_VBASECLASSES (t);\n-       vbase;\n-       vbase = TREE_CHAIN (vbase))\n-    dfs_walk (vbase, dfs_set_offset_for_unshared_vbases, NULL, t);\n+  for (vbases = CLASSTYPE_VBASECLASSES (t);\n+       vbases;\n+       vbases = TREE_CHAIN (vbases))\n+    dfs_walk (vbases, dfs_set_offset_for_unshared_vbases, NULL, t);\n \n   /* If we had empty base classes that protruded beyond the end of the\n      class, we didn't update DSIZE above; we were hoping to overlay\n@@ -4310,11 +4348,11 @@ layout_virtual_bases (t, base_offsets)\n \n   /* Check for ambiguous virtual bases.  */\n   if (extra_warnings)\n-    for (vbase = CLASSTYPE_VBASECLASSES (t); \n-\t vbase; \n-\t vbase = TREE_CHAIN (vbase))\n+    for (vbases = CLASSTYPE_VBASECLASSES (t); \n+\t vbases; \n+\t vbases = TREE_CHAIN (vbases))\n       {\n-\ttree basetype = BINFO_TYPE (vbase);\n+\ttree basetype = BINFO_TYPE (vbases);\n \tif (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n \t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t      basetype, t);\n@@ -4572,7 +4610,7 @@ layout_class_type (t, empty_p, vfuns_p,\n   /* Clean up.  */\n   VARRAY_FREE (v);\n }\n-     \n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -4791,7 +4829,7 @@ finish_struct_1 (t)\n      the base types we marked.  */\n   finish_vtbls (t);\n \n-  if (CLASSTYPE_VSIZE (t) != 0)\n+  if (TYPE_VFIELD (t))\n     {\n       /* In addition to this one, all the other vfields should be listed.  */\n       /* Before that can be done, we have to have FIELD_DECLs for them, and\n@@ -5030,13 +5068,13 @@ init_class_processing ()\n \t\t\t\t    * sizeof (struct class_stack_node));\n \n   access_default_node = build_int_2 (0, 0);\n-  access_public_node = build_int_2 (1, 0);\n-  access_protected_node = build_int_2 (2, 0);\n-  access_private_node = build_int_2 (3, 0);\n+  access_public_node = build_int_2 (ak_public, 0);\n+  access_protected_node = build_int_2 (ak_protected, 0);\n+  access_private_node = build_int_2 (ak_private, 0);\n   access_default_virtual_node = build_int_2 (4, 0);\n-  access_public_virtual_node = build_int_2 (5, 0);\n-  access_protected_virtual_node = build_int_2 (6, 0);\n-  access_private_virtual_node = build_int_2 (7, 0);\n+  access_public_virtual_node = build_int_2 (4 | ak_public, 0);\n+  access_protected_virtual_node = build_int_2 (4 | ak_protected, 0);\n+  access_private_virtual_node = build_int_2 (4 | ak_private, 0);\n }\n \n /* Set current scope to NAME. CODE tells us if this is a\n@@ -6047,12 +6085,36 @@ note_name_declared_in_class (name, decl)\n     }\n }\n \n-/* Dump the offsets of all the bases rooted at BINFO to stderr.\n-   INDENT should be zero when called from the top level; it is\n-   incremented recursively.  */\n+/* Returns the VAR_DECL for the complete vtable associated with\n+   BINFO.  (Under the new ABI, secondary vtables are merged with\n+   primary vtables; this function will return the VAR_DECL for the\n+   primary vtable.)  */\n \n-void\n-dump_class_hierarchy (binfo, indent)\n+tree\n+get_vtbl_decl_for_binfo (binfo)\n+     tree binfo;\n+{\n+  tree decl;\n+\n+  decl = BINFO_VTABLE (binfo);\n+  if (decl && TREE_CODE (decl) == PLUS_EXPR)\n+    {\n+      my_friendly_assert (TREE_CODE (TREE_OPERAND (decl, 0)) == ADDR_EXPR,\n+\t\t\t  2000403);\n+      decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n+    }\n+  if (decl)\n+    my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 20000403);\n+  return decl;\n+}\n+\n+/* Dump the offsets of all the bases rooted at BINFO (in the hierarchy\n+   dominated by T) to stderr.  INDENT should be zero when called from\n+   the top level; it is incremented recursively.  */\n+\n+static void\n+dump_class_hierarchy_r (t, binfo, indent)\n+     tree t;\n      tree binfo;\n      int indent;\n {\n@@ -6063,11 +6125,31 @@ dump_class_hierarchy (binfo, indent)\n \t   type_as_string (binfo, TS_PLAIN));\n   fprintf (stderr, HOST_WIDE_INT_PRINT_DEC,\n \t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n-  fprintf (stderr, \" %s\\n\",\n-\t   BINFO_PRIMARY_MARKED_P (binfo) ? \"primary\" : \"\");\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    fprintf (stderr, \" virtual\");\n+  if (BINFO_PRIMARY_MARKED_P (binfo)\n+      || (TREE_VIA_VIRTUAL (binfo) \n+\t  && BINFO_VBASE_PRIMARY_P (BINFO_FOR_VBASE (BINFO_TYPE (binfo), \n+\t\t\t\t\t\t     t))))\n+    fprintf (stderr, \" primary\");\n+  fprintf (stderr, \"\\n\");\n \n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-    dump_class_hierarchy (BINFO_BASETYPE (binfo, i), indent + 2);\n+    dump_class_hierarchy_r (t, BINFO_BASETYPE (binfo, i), indent + 2);\n+}\n+\n+/* Dump the BINFO hierarchy for T.  */\n+\n+void\n+dump_class_hierarchy (t)\n+     tree t;\n+{\n+  tree vbase;\n+\n+  dump_class_hierarchy_r (t, TYPE_BINFO (t), 0);\n+  fprintf (stderr, \"virtual bases\\n\");\n+  for (vbase = CLASSTYPE_VBASECLASSES (t); vbase; vbase = TREE_CHAIN (vbase))\n+    dump_class_hierarchy_r (t, vbase, 0);\n }\n \n /* Virtual function table initialization.  */\n@@ -6087,14 +6169,18 @@ finish_vtbls (t)\n \t vtables in one contiguous vtable.  The primary vtable is\n \t first, followed by the non-virtual secondary vtables in\n \t inheritance graph order.  */\n-      list = build_tree_list (t, NULL_TREE);\n+      list = build_tree_list (TYPE_BINFO_VTABLE (t), NULL_TREE);\n+      TREE_TYPE (list) = t;\n       accumulate_vtbl_inits (TYPE_BINFO (t), list);\n       /* Then come the virtual bases, also in inheritance graph\n \t order.  */\n-      for (vbase = CLASSTYPE_VBASECLASSES (t);\n-\t   vbase;\n-\t   vbase = TREE_CHAIN (vbase))\n-\taccumulate_vtbl_inits (vbase, list);\n+      for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n+\t{\n+\t  if (!TREE_VIA_VIRTUAL (vbase))\n+\t    continue;\n+\t  accumulate_vtbl_inits (BINFO_FOR_VBASE (BINFO_TYPE (vbase), t),\n+\t\t\t\t list);\n+\t}\n \n       if (TYPE_BINFO_VTABLE (t))\n \tinitialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n@@ -6121,7 +6207,7 @@ dfs_finish_vtbls (binfo, data)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n       && BINFO_NEW_VTABLE_MARKED (binfo, t))\n     initialize_vtable (binfo, \n-\t\t       build_vtbl_initializer (binfo, t));\n+\t\t       build_vtbl_initializer (binfo, t, NULL));\n \n   CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n   SET_BINFO_MARKED (binfo);\n@@ -6140,7 +6226,7 @@ initialize_vtable (binfo, inits)\n   tree decl;\n \n   layout_vtable_decl (binfo, list_length (inits));\n-  decl = BINFO_VTABLE (binfo);\n+  decl = get_vtbl_decl_for_binfo (binfo);\n   context = DECL_CONTEXT (decl);\n   DECL_CONTEXT (decl) = 0;\n   DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE, inits);\n@@ -6156,10 +6242,12 @@ accumulate_vtbl_inits (binfo, inits)\n      tree binfo;\n      tree inits;\n {\n-  /* Walk the BINFO and its bases.  */\n+  /* Walk the BINFO and its bases.  We walk in preorder so that as we\n+     initialize each vtable we can figure out at what offset the\n+     secondary vtable lies from the primary vtable.  */\n   dfs_walk_real (binfo,\n \t\t dfs_accumulate_vtbl_inits,\n-\t\t NULL, \n+\t\t NULL,\n \t\t dfs_skip_vbases,\n \t\t inits);\n }\n@@ -6177,33 +6265,37 @@ dfs_accumulate_vtbl_inits (binfo, data)\n   tree t;\n \n   l = (tree) data;\n-  t = TREE_PURPOSE (l);\n+  t = TREE_TYPE (l);\n \n   if (!BINFO_PRIMARY_MARKED_P (binfo)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n       && BINFO_NEW_VTABLE_MARKED (binfo, t))\n     {\n-      /* If this is a secondary vtable, record its location.  */\n-      if (binfo != TYPE_BINFO (t))\n-\t{\n-\t  tree vtbl;\n-\n-\t  vtbl = TYPE_BINFO_VTABLE (t);\n-\t  vtbl = build1 (ADDR_EXPR, \n-\t\t\t build_pointer_type (TREE_TYPE (vtbl)),\n-\t\t\t vtbl);\n-\t  BINFO_VTABLE (binfo)\n-\t    = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n-\t\t     size_binop (MULT_EXPR,\n-\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (vtbl)),\n-\t\t\t\t size_int (list_length (TREE_VALUE (l)))));\n-\t}\n+      tree inits;\n+      tree vtbl;\n+      tree index;\n+      int non_fn_entries;\n+\n+      /* Compute the initializer for this vtable.  */\n+      inits = build_vtbl_initializer (binfo, t, &non_fn_entries);\n+\n+      /* Set BINFO_VTABLE to the address where the VPTR should point.  */\n+      vtbl = TREE_PURPOSE (l);\n+      vtbl = build1 (ADDR_EXPR, \n+\t\t     build_pointer_type (TREE_TYPE (vtbl)),\n+\t\t     vtbl);\n+      index = size_binop (PLUS_EXPR,\n+\t\t\t  size_int (non_fn_entries),\n+\t\t\t  size_int (list_length (TREE_VALUE (l))));\n+      BINFO_VTABLE (binfo)\n+\t= build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n+\t\t size_binop (MULT_EXPR,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (vtbl)),\n+\t\t\t     index));\n \n       /* Add the initializers for this vtable to the initializers for\n \t the other vtables we've already got.  */\n-      TREE_VALUE (l) \n-\t= chainon (TREE_VALUE (l),\n-\t\t   build_vtbl_initializer (binfo, t));\n+      TREE_VALUE (l) = chainon (TREE_VALUE (l), inits);\n     }\n \n   CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n@@ -6214,29 +6306,48 @@ dfs_accumulate_vtbl_inits (binfo, data)\n /* Construct the initializer for BINFOs virtual function table.  BINFO\n    is part of the hierarchy dominated by T.  The value returned is a\n    TREE_LIST suitable for wrapping in a CONSTRUCTOR to use as the\n-   DECL_INITIAL for a vtable.  */\n+   DECL_INITIAL for a vtable.  If NON_FN_ENTRIES_P is not NULL,\n+   *NON_FN_ENTRIES_P is set to the number of non-function entries in\n+   the vtable.  */\n \n static tree\n-build_vtbl_initializer (binfo, t)\n+build_vtbl_initializer (binfo, t, non_fn_entries_p)\n      tree binfo;\n      tree t;\n+     int *non_fn_entries_p;\n {\n   tree v = BINFO_VIRTUALS (binfo);\n   tree inits = NULL_TREE;\n+  tree vfun_inits;\n+  tree vbase;\n+  vcall_offset_data vod;\n \n-  /* Add entries to the vtable that indicate how to adjust the this\n-     pointer when calling a virtual function in this class.  */\n-  inits = build_vcall_offset_vtbl_entries (binfo, t);\n-\n-  /* Add entries to the vtable for offsets to our virtual bases.  */\n-  inits = chainon (build_vbase_offset_vtbl_entries (binfo, t),\n-\t\t   inits);\n+  /* Initialize those parts of VOD that matter.  */\n+  vod.derived = t;\n+  vod.inits = NULL_TREE;\n+  vod.primary_p = (binfo == TYPE_BINFO (t));\n+  /* The first vbase or vcall offset is at index -3 in the vtable.  */\n+  vod.index = build_int_2 (-3, -1);\n+\n+  /* Add the vcall and vbase offset entries.  */\n+  build_vcall_and_vbase_vtbl_entries (binfo, &vod);\n+  inits = vod.inits;\n+  /* Clear BINFO_VTABLE_PAATH_MARKED; it's set by\n+     build_vbase_offset_vtbl_entries.  */\n+  for (vbase = CLASSTYPE_VBASECLASSES (t); \n+       vbase; \n+       vbase = TREE_CHAIN (vbase))\n+    CLEAR_BINFO_VTABLE_PATH_MARKED (vbase);\n \n   /* Add entries to the vtable for RTTI.  */\n-  inits = chainon (build_rtti_vtbl_entries (binfo, t), inits);\n+  inits = chainon (inits, build_rtti_vtbl_entries (binfo, t));\n+\n+  if (non_fn_entries_p)\n+    *non_fn_entries_p = list_length (inits);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n+  vfun_inits = NULL_TREE;\n   while (v)\n     {\n       tree delta;\n@@ -6266,118 +6377,133 @@ build_vtbl_initializer (binfo, t)\n       /* Enter it in the vtable.  */\n       init = build_vtable_entry (delta, vcall_index, pfn);\n       /* And add it to the chain of initializers.  */\n-      inits = tree_cons (NULL_TREE, init, inits);\n+      vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n \n       /* Keep going.  */\n       v = TREE_CHAIN (v);\n     }\n \n-  /* The initializers were built up in reverse order; straighten them\n-     out now.  */\n-  return nreverse (inits);\n+  /* The initializers for virtual functions were built up in reverse\n+     order; straighten them out now.  */\n+  vfun_inits = nreverse (vfun_inits);\n+  \n+  /* The complete initializer is the INITS, followed by the\n+     VFUN_INITS.  */\n+  return chainon (inits, vfun_inits);\n }\n \n-/* Called from build_vbase_offset_vtbl_entries via dfs_walk.  */\n+/* Sets vod->inits to be the initializers for the vbase and vcall\n+   offsets in BINFO, which is in the hierarchy dominated by T.  */\n \n-static tree\n-dfs_build_vbase_offset_vtbl_entries (binfo, data)\n+static void\n+build_vcall_and_vbase_vtbl_entries (binfo, vod)\n      tree binfo;\n-     void *data;\n+     vcall_offset_data *vod;\n {\n-  tree list = (tree) data;\n-\n-  if (TREE_TYPE (list) == binfo)\n-    /* The TREE_TYPE of LIST is the base class from which we started\n-       walking.  If that BINFO is virtual it's not a virtual baseclass\n-       of itself.  */\n-    ;\n-  else if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree init;\n-      tree vbase;\n-\n-      /* Remember the index to the vbase offset for this virtual\n-\t base.  */\n-      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n-      if (!TREE_VALUE (list))\n-\tBINFO_VPTR_FIELD (vbase) = build_int_2 (-3, 0);\n-      else\n-\t{\n-\t  BINFO_VPTR_FIELD (vbase) = TREE_PURPOSE (TREE_VALUE (list));\n-\t  BINFO_VPTR_FIELD (vbase)\n-\t    = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t   BINFO_VPTR_FIELD (vbase), integer_one_node));\n-\t}\n-\n-      /* And record the offset at which this virtual base lies in the\n-\t vtable.  */\n-      init = BINFO_OFFSET (binfo);\n-      TREE_VALUE (list) = tree_cons (BINFO_VPTR_FIELD (vbase),\n-\t\t\t\t     init, TREE_VALUE (list));\n-    }\n+  tree b;\n+  tree inits;\n \n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-  \n-  return NULL_TREE;\n+  /* If this is a derived class, we must first create entries\n+     corresponding to the base class.  These entries must go closer to\n+     the vptr, so we save them up and add them to the end of the list\n+     later.  */\n+  inits = vod->inits;\n+  vod->inits = NULL_TREE;\n+  b = BINFO_PRIMARY_BINFO (binfo);\n+  if (b)\n+    build_vcall_and_vbase_vtbl_entries (b, vod);\n+\n+  /* Add the vbase entries for this base.  */\n+  build_vbase_offset_vtbl_entries (binfo, vod);\n+  /* Add the vcall entries for this base.  */\n+  build_vcall_offset_vtbl_entries (binfo, vod);\n+\n+  vod->inits = chainon (vod->inits, inits);\n }\n \n /* Returns the initializers for the vbase offset entries in the vtable\n    for BINFO (which is part of the class hierarchy dominated by T), in\n-   reverse order.  */\n+   reverse order.  VBASE_OFFSET_INDEX gives the vtable index\n+   where the next vbase offset will go.  */\n \n-static tree\n-build_vbase_offset_vtbl_entries (binfo, t)\n+static void\n+build_vbase_offset_vtbl_entries (binfo, vod)\n      tree binfo;\n-     tree t;\n+     vcall_offset_data *vod;\n {\n-  tree inits;\n-  tree init;\n-  tree list;\n+  tree vbase;\n+  tree t;\n \n   /* Under the old ABI, pointers to virtual bases are stored in each\n      object.  */\n   if (!vbase_offsets_in_vtable_p ())\n-    return NULL_TREE;\n+    return;\n \n   /* If there are no virtual baseclasses, then there is nothing to\n      do.  */\n   if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n-    return NULL_TREE;\n+    return;\n \n-  inits = NULL_TREE;\n+  t = vod->derived;\n \n-  /* The offsets are allocated in the reverse order of a\n-     depth-first left-to-right traversal of the hierarchy.  We use\n-     BINFO_VTABLE_PATH_MARKED because we are ourselves during a\n-     dfs_walk, and so BINFO_MARKED is already in use.  */\n-  list = build_tree_list (t, NULL_TREE);\n-  TREE_TYPE (list) = binfo;\n-  dfs_walk (binfo,\n-\t    dfs_build_vbase_offset_vtbl_entries,\n-\t    unmarked_vtable_pathp,\n-\t    list);\n-  dfs_walk (binfo,\n-\t    dfs_vtable_path_unmark,\n-\t    marked_vtable_pathp,\n-\t    list);\n-  inits = nreverse (TREE_VALUE (list));\n-\n-  /* We've now got offsets in the right order.  However, the offsets\n-     we've stored are offsets from the beginning of the complete\n-     object, and we need offsets from this BINFO.  */\n-  for (init = inits; init; init = TREE_CHAIN (init))\n-    {\n-      /* The dfs_build_vbase_offset_vtbl_entries routine uses the\n-\t TREE_PURPOSE to scribble in.  But, we need to clear it now so\n-\t that the values are not perceived as labeled initializers.  */\n-      TREE_PURPOSE (init) = NULL_TREE;\n-      TREE_VALUE (init)\n-\t= fold (build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\tsize_diffop (TREE_VALUE (init),\n-\t\t\t\t     BINFO_OFFSET (binfo))));\n-    }\n+  /* Go through the virtual bases, adding the offsets.  */\n+  for (vbase = TYPE_BINFO (BINFO_TYPE (binfo));\n+       vbase;\n+       vbase = TREE_CHAIN (vbase))\n+    {\n+      tree b;\n+      tree delta;\n+      \n+      if (!TREE_VIA_VIRTUAL (vbase))\n+\tcontinue;\n \n-  return inits;\n+      /* Find the instance of this virtual base in the complete\n+\t object.  */\n+      b = BINFO_FOR_VBASE (BINFO_TYPE (vbase), t);\n+\n+      /* If we've already got an offset for this virtual base, we\n+\t don't need another one.  */\n+      if (BINFO_VTABLE_PATH_MARKED (b))\n+\tcontinue;\n+      SET_BINFO_VTABLE_PATH_MARKED (b);\n+\n+      /* Figure out where we can find this vbase offset.  */\n+      delta = size_binop (MULT_EXPR, \n+\t\t\t  convert (ssizetype, vod->index),\n+\t\t\t  convert (ssizetype,\n+\t\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n+      if (vod->primary_p)\n+\tBINFO_VPTR_FIELD (b) = delta;\n+\n+      if (binfo != TYPE_BINFO (t))\n+\t{\n+\t  tree orig_vbase;\n+\n+\t  /* Find the instance of this virtual base in the type of BINFO.  */\n+\t  orig_vbase = BINFO_FOR_VBASE (BINFO_TYPE (vbase),\n+\t\t\t\t\tBINFO_TYPE (binfo));\n+\n+\t  /* The vbase offset had better be the same.  */\n+\t  if (!tree_int_cst_equal (delta,\n+\t\t\t\t   BINFO_VPTR_FIELD (orig_vbase)))\n+\t    my_friendly_abort (20000403);\n+\t}\n+\n+      /* The next vbase will come at a more negative offset.  */\n+      vod->index = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\tvod->index, integer_one_node));\n+\n+      /* The initializer is the delta from BINFO to this virtual base.\n+\t   The vbase offsets go in reverse inheritance-graph order, and\n+\t   we are walking in inheritance graph order so these end up in\n+\t   the right order.  */\n+      delta = size_diffop (BINFO_OFFSET (b), BINFO_OFFSET (binfo));\n+      vod->inits = tree_cons (NULL_TREE, \n+\t\t\t      fold (build1 (NOP_EXPR, \n+\t\t\t\t\t    vtable_entry_type,\n+\t\t\t\t\t    delta)),\n+\t\t\t      vod->inits);\n+    }\n }\n \n /* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n@@ -6402,20 +6528,22 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n   vcall_offset_data* vod;\n   tree virtuals;\n   tree binfo_inits;\n-\n-  /* Primary bases are not interesting; all of the virtual\n-     function table entries have been overridden.  */\n-  if (BINFO_PRIMARY_MARKED_P (binfo))\n-     return NULL_TREE;\n+  tree b;\n+  int i;\n \n   vod = (vcall_offset_data *) data;\n   binfo_inits = NULL_TREE;\n+  \n+  /* Skip virtuals that we have already handled in a primary base\n+     class.  */\n+  virtuals = BINFO_VIRTUALS (binfo);\n+  b = BINFO_PRIMARY_BINFO (binfo);\n+  if (b)\n+    for (i = 0; i < CLASSTYPE_VSIZE (BINFO_TYPE (b)); ++i)\n+      virtuals = TREE_CHAIN (virtuals);\n \n-  /* We chain the offsets on in reverse order.  That's correct --\n-     build_vtbl_initializer will straighten them out.  */\n-  for (virtuals = BINFO_VIRTUALS (binfo);\n-       virtuals;\n-       virtuals = TREE_CHAIN (virtuals))\n+  /* Make entries for the rest of the virtuals.  */\n+  while (virtuals)\n     {\n       /* Figure out what function we're looking at.  */\n       tree fn = TREE_VALUE (virtuals);\n@@ -6430,34 +6558,48 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \t\t\t\t   size_diffop (BINFO_OFFSET (base_binfo),\n \t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n \t\t     binfo_inits);\n+      vod->index = fold (build (MINUS_EXPR, integer_type_node,\n+\t\t\t\tvod->index, integer_one_node));\n+      virtuals = TREE_CHAIN (virtuals);\n     }\n \n-  /* Now add the initializers we've just created to the list that will\n-     be returned to our caller.  */\n-  vod->inits = chainon (vod->inits, binfo_inits);\n+  /* The offests are built up in reverse order, so we straighten them\n+     here.  We simultaneously add them to VOD->INITS; we're walking\n+     the bases in inheritance graph order, and the initializers are\n+     supposed to appear in reverse inheritance order, so that's\n+     correct.  */\n+  while (binfo_inits)\n+    {\n+      tree next;\n+\n+      next = TREE_CHAIN (binfo_inits);\n+      TREE_CHAIN (binfo_inits) = vod->inits;\n+      vod->inits = binfo_inits;\n+      binfo_inits = next;\n+    }\n \n   return NULL_TREE;\n }\n \n-/* Returns the initializers for the vcall offset entries in the vtable\n-   for BINFO (which is part of the class hierarchy dominated by T), in\n-   reverse order.  */\n+/* Adds the initializers for the vcall offset entries in the vtable\n+   for BINFO (which is part of the class hierarchy dominated by T) to\n+   VOD->INITS.  */\n \n-static tree\n-build_vcall_offset_vtbl_entries (binfo, t)\n+static void\n+build_vcall_offset_vtbl_entries (binfo, vod)\n      tree binfo;\n-     tree t;\n+     vcall_offset_data *vod;\n {\n-  vcall_offset_data vod;\n+  tree inits;\n \n   /* Under the old ABI, the adjustments to the `this' pointer were made\n      elsewhere.  */\n   if (!vcall_offsets_in_vtable_p ())\n-    return NULL_TREE;\n+    return;\n \n   /* We only need these entries if this base is a virtual base.  */\n   if (!TREE_VIA_VIRTUAL (binfo))\n-    return NULL_TREE;\n+    return;\n \n   /* We need a vcall offset for each of the virtual functions in this\n      vtable.  For example:\n@@ -6481,15 +6623,15 @@ build_vcall_offset_vtbl_entries (binfo, t)\n      in our non-virtual bases vtables.  For each base, the entries\n      appear in the same order as in the base; but the bases themselves\n      appear in reverse depth-first, left-to-right order.  */\n-  vod.derived = t;\n-  vod.vbase = binfo;\n-  vod.inits = NULL_TREE;\n-  dfs_walk (binfo,\n-\t    dfs_build_vcall_offset_vtbl_entries,\n-\t    dfs_vcall_offset_queue_p,\n-\t    &vod);\n-\n-  return vod.inits;\n+  vod->vbase = binfo;\n+  inits = vod->inits;\n+  vod->inits = NULL_TREE;\n+  dfs_walk_real (binfo,\n+\t\t dfs_build_vcall_offset_vtbl_entries,\n+\t\t NULL,\n+\t\t dfs_vcall_offset_queue_p,\n+\t\t vod);\n+  vod->inits = chainon (vod->inits, inits);\n }\n \n /* Return vtbl initializers for the RTTI entries coresponding to the\n@@ -6503,10 +6645,10 @@ build_rtti_vtbl_entries (binfo, t)\n {\n   tree b;\n   tree basetype;\n-  tree inits;\n   tree offset;\n   tree decl;\n   tree init;\n+  tree inits;\n \n   basetype = BINFO_TYPE (binfo);\n   inits = NULL_TREE;\n@@ -6519,19 +6661,15 @@ build_rtti_vtbl_entries (binfo, t)\n      primary base, and then add the offset in the vtbl to that value.  */\n   b = binfo;\n   while (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (b)))\n-    b = BINFO_BASETYPE (b, \n-\t\t\tCLASSTYPE_VFIELD_PARENT (BINFO_TYPE (b)));\n-  offset = size_diffop (size_zero_node, BINFO_OFFSET (b));\n-\n-  /* Add the offset-to-top entry.  */\n-  if (flag_vtable_thunks)\n     {\n-      /* Convert the offset to look like a function pointer, so that\n-\t we can put it in the vtable.  */\n-      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-      TREE_CONSTANT (init) = 1;\n-      inits = tree_cons (NULL_TREE, init, inits);\n+      tree primary_base;\n+\n+      primary_base = BINFO_PRIMARY_BINFO (b);\n+      if (!BINFO_PRIMARY_MARKED_P (primary_base))\n+\tbreak;\n+      b = primary_base;\n     }\n+  offset = size_diffop (size_zero_node, BINFO_OFFSET (b));\n \n   /* The second entry is, in the case of the new ABI, the address of\n      the typeinfo object, or, in the case of the old ABI, a function\n@@ -6561,10 +6699,19 @@ build_rtti_vtbl_entries (binfo, t)\n       TREE_CONSTANT (init) = 1;\n       init = build_vtable_entry (offset, integer_zero_node, init);\n     }\n-\n-  /* Hook the RTTI declaration onto the list.  */\n   inits = tree_cons (NULL_TREE, init, inits);\n \n+  /* Add the offset-to-top entry.  It comes earlier in the vtable that\n+     the the typeinfo entry.  */\n+  if (flag_vtable_thunks)\n+    {\n+      /* Convert the offset to look like a function pointer, so that\n+\t we can put it in the vtable.  */\n+      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+      TREE_CONSTANT (init) = 1;\n+      inits = tree_cons (NULL_TREE, init, inits);\n+    }\n+\n   return inits;\n }\n "}, {"sha": "07b867567e458859e198c73bb8e07e592e68a088", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -55,8 +55,6 @@ Boston, MA 02111-1307, USA.  */\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       STMT_IS_FULL_EXPR_P (in _STMT)\n    2: IDENTIFIER_OPNAME_P.\n-      BINFO_VBASE_MARKED.\n-      BINFO_FIELDS_MARKED.\n       TYPE_POLYMORHPIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n       STMT_LINENO_FOR_FN_P (in _STMT)\n@@ -130,6 +128,13 @@ Boston, MA 02111-1307, USA.  */\n      this function.  (This binfo's BINFO_TYPE will always be the same\n      as the DECL_CLASS_CONTEXT for the function.)\n \n+   BINFO_VTABLE\n+     Sometimes this is a VAR_DECL.  Under the new ABI, it is instead\n+     an expression with POINTER_TYPE pointing that gives the value\n+     to which the vptr should be initialized.  Use get_vtbl_decl_for_binfo\n+     to extract the VAR_DECL for the complete vtable; that macro works\n+     in both ABIs.\n+\n    DECL_ARGUMENTS\n      For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  \n \n@@ -1356,24 +1361,17 @@ struct lang_type\n   int vsize;\n   int vfield_parent;\n \n-  union tree_node *vfields;\n-  union tree_node *vbases;\n-\n-  union tree_node *tags;\n-\n-  union tree_node *search_slot;\n-\n-  union tree_node *size;\n-  union tree_node *size_unit;\n-\n-  union tree_node *pure_virtuals;\n-  union tree_node *friend_classes;\n-\n-  union tree_node *rtti;\n-\n-  union tree_node *methods;\n-\n-  union tree_node *template_info;\n+  tree vfields;\n+  tree vbases;\n+  tree tags;\n+  tree search_slot;\n+  tree size;\n+  tree size_unit;\n+  tree pure_virtuals;\n+  tree friend_classes;\n+  tree rtti;\n+  tree methods;\n+  tree template_info;\n   tree befriending_classes;\n };\n \n@@ -1538,21 +1536,29 @@ struct lang_type\n #define CLASSTYPE_PRIMARY_BINFO(NODE) \\\n   (BINFO_PRIMARY_BINFO (TYPE_BINFO (NODE)))\n \n-/* If non-NULL, this is the binfo for the primary base of BINFO.  */\n+/* If non-NULL, this is the binfo for the primary base of BINFO.  Note\n+   that in a complex hierarchy the resulting BINFO may not actually\n+   *be* primary.  In particular if the resulting BINFO is a virtual\n+   base, and it occurs elsewhere in the hierarchy, then this\n+   occurrence may not actually be a primary base in the complete\n+   object.  Check BINFO_PRIMARY_MARKED_P to be sure.  */\n #define BINFO_PRIMARY_BINFO(NODE)\t\t\t\t\t\\\n   (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (NODE))\t\t\t\\\n    ? BINFO_BASETYPE (NODE, \t\t\t\t\t\t\\\n \t\t     CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (NODE)))\t\\\n    : NULL_TREE)\n \n-/* The number of virtual functions present in this classes virtual\n+/* The number of virtual functions present in this class' virtual\n    function table.  */\n #define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)\n \n /* A chain of BINFOs for the direct and indirect virtual base classes\n-   that this type uses in depth-first left-to-right order.  These\n-   BINFOs are distinct from those in the TYPE_BINFO hierarchy.  So,\n-   given: \n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)\n+\n+   These BINFOs are distinct from those in the TYPE_BINFO hierarchy.\n+   So, given:\n \n      struct A {};\n      struct B : public A {};\n@@ -1683,9 +1689,7 @@ struct lang_type\n \n    We use TREE_VIA_PROTECTED and TREE_VIA_PUBLIC, but private\n    inheritance is indicated by the absence of the other two flags, not\n-   by TREE_VIA_PRIVATE, which is unused.\n-\n-   The TREE_CHAIN is for scratch space in search.c.  */\n+   by TREE_VIA_PRIVATE, which is unused.  */\n \n /* Nonzero means marked by DFS or BFS search, including searches\n    by `get_binfo' and `get_base_distance'.  */\n@@ -1695,18 +1699,6 @@ struct lang_type\n #define SET_BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_0(NODE)=1))\n #define CLEAR_BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_0(NODE)=0))\n \n-/* Nonzero means marked in search through virtual inheritance hierarchy.  */\n-#define BINFO_VBASE_MARKED(NODE) CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n-/* Modifier macros */\n-#define SET_BINFO_VBASE_MARKED(NODE) SET_CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n-#define CLEAR_BINFO_VBASE_MARKED(NODE) CLEAR_CLASSTYPE_MARKED2 (BINFO_TYPE (NODE))\n-\n-/* Nonzero means marked in search for members or member functions.  */\n-#define BINFO_FIELDS_MARKED(NODE) \\\n-  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED2 (BINFO_TYPE (NODE)):TREE_LANG_FLAG_2(NODE))\n-#define SET_BINFO_FIELDS_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED2(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_2(NODE)=1))\n-#define CLEAR_BINFO_FIELDS_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED2(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_2(NODE)=0))\n-\n /* Nonzero means that this class is on a path leading to a new vtable.  */\n #define BINFO_VTABLE_PATH_MARKED(NODE) \\\n   (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):TREE_LANG_FLAG_3(NODE))\n@@ -3081,6 +3073,17 @@ typedef enum tmpl_spec_kind {\n   tsk_expl_inst            /* An explicit instantiation.  */\n } tmpl_spec_kind;\n \n+/* The various kinds of access.  BINFO_ACCESS depends on these being\n+   two bit quantities.  The numerical values are important; they are\n+   used to initialize RTTI data structures, so chaning them changes\n+   the ABI.  */\n+typedef enum access_kind {\n+  ak_none = 0,             /* Inaccessible.  */\n+  ak_public = 1,           /* Accessible, as a `public' thing.  */\n+  ak_protected = 2,        /* Accessible, as a `protected' thing.  */\n+  ak_private = 3           /* Accessible, as a `private' thing.  */\n+} access_kind;\n+\n /* Zero means prototype weakly, as in ANSI C (no args means nothing).\n    Each language context defines how this variable should be set.  */\n extern int strict_prototype;\n@@ -3694,8 +3697,7 @@ extern void unreverse_member_declarations       PARAMS ((tree));\n extern void invalidate_class_lookup_cache       PARAMS ((void));\n extern void maybe_note_name_used_in_class       PARAMS ((tree, tree));\n extern void note_name_declared_in_class         PARAMS ((tree, tree));\n-extern tree num_extra_vtbl_entries              PARAMS ((tree));\n-extern tree size_extra_vtbl_entries             PARAMS ((tree));\n+extern tree get_vtbl_decl_for_binfo           PARAMS ((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n@@ -4203,7 +4205,6 @@ extern tree dfs_walk_real                      PARAMS ((tree,\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       void *));\n extern tree dfs_unmark                          PARAMS ((tree, void *));\n-extern tree dfs_vbase_unmark                    PARAMS ((tree, void *));\n extern tree dfs_vtable_path_unmark              PARAMS ((tree, void *));\n extern tree markedp                             PARAMS ((tree, void *));\n extern tree unmarkedp                           PARAMS ((tree, void *));\n@@ -4214,7 +4215,6 @@ extern tree dfs_marked_real_bases_queue_p       PARAMS ((tree, void *));\n extern tree dfs_skip_vbases                     PARAMS ((tree, void *));\n extern tree marked_vtable_pathp                 PARAMS ((tree, void *));\n extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n-extern void mark_primary_bases                  PARAMS ((tree));\n extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n "}, {"sha": "be51512e2663f73123cb71714780fb132cccd7ac", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -2544,7 +2544,7 @@ output_vtable_inherit (vars)\n     op[1] = const0_rtx;\n   else if (parent)\n     {\n-      parent = TYPE_BINFO_VTABLE (BINFO_TYPE (parent));\n+      parent = get_vtbl_decl_for_binfo (TYPE_BINFO (BINFO_TYPE (parent)));\n       op[1] = XEXP (DECL_RTL (parent), 0);  /* strip the mem ref  */\n     }\n   else"}, {"sha": "4623abf6fa9bd0bd59d0882ac35a03b9d60ce23d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -653,31 +653,23 @@ expand_virtual_init (binfo, decl)\n   tree type = BINFO_TYPE (binfo);\n   tree vtbl, vtbl_ptr;\n   tree vtype, vtype_binfo;\n+  tree b;\n \n   /* Compute the location of the vtable.  */\n   vtype = DECL_CONTEXT (TYPE_VFIELD (type));\n   vtype_binfo = get_binfo (vtype, TREE_TYPE (TREE_TYPE (decl)), 0);\n-  vtbl = BINFO_VTABLE (binfo_value (DECL_FIELD_CONTEXT (TYPE_VFIELD (type)), binfo));\n+  b = binfo_value (DECL_FIELD_CONTEXT (TYPE_VFIELD (type)), binfo);\n \n+  /* Figure out what vtable BINFO's vtable is based on, and mark it as\n+     used.  */\n+  vtbl = get_vtbl_decl_for_binfo (b);\n+  assemble_external (vtbl);\n+  TREE_USED (vtbl) = 1;\n+\n+  /* Now compute the address to use when initializing the vptr.  */\n+  vtbl = BINFO_VTABLE (b);\n   if (TREE_CODE (vtbl) == VAR_DECL)\n-    {\n-      assemble_external (vtbl);\n-      TREE_USED (vtbl) = 1;\n-      vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n-    }\n-  else\n-    /* Under the new ABI, secondary vtables are stored with the\n-       primary vtable.  So, the BINFO_VTABLE may be an expression for\n-       computing the secondary vtable, rather than the secondary\n-       vtable itself.  */\n-    my_friendly_assert (merge_primary_and_secondary_vtables_p (), \n-\t\t\t20000220);\n-\n-  /* Under the new ABI, we need to point into the middle of the\n-     vtable.  */\n-  if (vbase_offsets_in_vtable_p ())\n-    vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, \n-\t\t  size_extra_vtbl_entries (binfo));\n+    vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n \n   /* Compute the location of the vtpr.  */\n   decl = convert_pointer_to_real (vtype_binfo, decl);"}, {"sha": "0d3879eebb2105eb624ffafc5bb815f97f344542", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -103,7 +103,7 @@ repo_get_id (t)\n       if (!COMPLETE_TYPE_P (t) || TYPE_BEING_DEFINED (t))\n \tmy_friendly_abort (981113);\n \n-      t = TYPE_BINFO_VTABLE (t);\n+      t = get_vtbl_decl_for_binfo (TYPE_BINFO (t));\n       if (t == NULL_TREE)\n \treturn t;\n     }"}, {"sha": "a5429ecfcc615c22167ce79f658c0b2ea17cdfbb", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -1640,11 +1640,14 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n \n   /* Under the new ABI, we need to point into the middle of the\n      vtable.  */\n-  if (vbase_offsets_in_vtable_p ())\n+  if (flag_new_abi)\n     {\n-      vtable_decl = build (PLUS_EXPR, TREE_TYPE (vtable_decl), \n+      vtable_decl = build (PLUS_EXPR,\n+\t\t\t   TREE_TYPE (vtable_decl),\n \t\t\t   vtable_decl,\n-\t\t\t   size_extra_vtbl_entries (TYPE_BINFO (real_type)));\n+\t\t\t   size_binop (MULT_EXPR,\n+\t\t\t\t       size_int (2),\n+\t\t\t\t       TYPE_SIZE_UNIT (vtable_entry_type)));\n       TREE_CONSTANT (vtable_decl) = 1;\n     }\n "}, {"sha": "4c4b600659f3e3a106a0ee2d17b741d392b6dc8d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 79, "deletions": 146, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -143,7 +143,7 @@ static int  dependent_base_p PARAMS ((tree));\n static tree dfs_accessible_queue_p PARAMS ((tree, void *));\n static tree dfs_accessible_p PARAMS ((tree, void *));\n static tree dfs_access_in_type PARAMS ((tree, void *));\n-static tree access_in_type PARAMS ((tree, tree));\n+static access_kind access_in_type PARAMS ((tree, tree));\n static tree dfs_canonical_queue PARAMS ((tree, void *));\n static tree dfs_assert_unmarked_p PARAMS ((tree, void *));\n static void assert_canonical_unmarked PARAMS ((tree));\n@@ -152,7 +152,6 @@ static int friend_accessible_p PARAMS ((tree, tree, tree));\n static void setup_class_bindings PARAMS ((tree, int));\n static int template_self_reference_p PARAMS ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PARAMS ((tree, tree));\n-static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n static tree get_shared_vbase_if_not_primary PARAMS ((tree, void *));\n static tree dfs_find_vbase_instance PARAMS ((tree, void *));\n static tree dfs_get_pure_virtuals PARAMS ((tree, void *));\n@@ -811,6 +810,18 @@ shared_unmarked_p (binfo, data)\n   return unmarkedp (binfo, data);\n }\n \n+/* The accessibility routines use BINFO_ACCESS for scratch space\n+   during the computation of the accssibility of some declaration.  */\n+\n+#define BINFO_ACCESS(NODE) \\\n+  ((access_kind) ((TREE_LANG_FLAG_1 (NODE) << 1) | TREE_LANG_FLAG_6 (NODE)))\n+\n+/* Set the access associated with NODE to ACCESS.  */\n+\n+#define SET_BINFO_ACCESS(NODE, ACCESS)\t\t\t\\\n+  ((TREE_LANG_FLAG_1 (NODE) = (ACCESS & 2) != 0),\t\\\n+   (TREE_LANG_FLAG_6 (NODE) = (ACCESS & 1) != 0))\n+\n /* Called from access_in_type via dfs_walk.  Calculate the access to\n    DATA (which is really a DECL) in BINFO.  */\n \n@@ -821,18 +832,18 @@ dfs_access_in_type (binfo, data)\n {\n   tree decl = (tree) data;\n   tree type = BINFO_TYPE (binfo);\n-  tree access = NULL_TREE;\n+  access_kind access = ak_none;\n \n   if (context_for_name_lookup (decl) == type)\n     {\n       /* If we have desceneded to the scope of DECL, just note the\n \t appropriate access.  */\n       if (TREE_PRIVATE (decl))\n-\taccess = access_private_node;\n+\taccess = ak_private;\n       else if (TREE_PROTECTED (decl))\n-\taccess = access_protected_node;\n+\taccess = ak_protected;\n       else\n-\taccess = access_public_node;\n+\taccess = ak_public;\n     }\n   else \n     {\n@@ -842,9 +853,10 @@ dfs_access_in_type (binfo, data)\n \t DECL_ACCESS.  */\n       if (DECL_LANG_SPECIFIC (decl))\n \t{\n-\t  access = purpose_member (type, DECL_ACCESS (decl));\n-\t  if (access)\n-\t    access = TREE_VALUE (access);\n+\t  tree decl_access = purpose_member (type, DECL_ACCESS (decl));\n+\t  if (decl_access)\n+\t    access = ((access_kind) \n+\t\t      TREE_INT_CST_LOW (TREE_VALUE (decl_access)));\n \t}\n \n       if (!access)\n@@ -860,43 +872,44 @@ dfs_access_in_type (binfo, data)\n \t  for (i = 0; i < n_baselinks; ++i)\n \t    {\n \t      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-\t      tree base_access = TREE_CHAIN (canonical_binfo (base_binfo));\n+\t      access_kind base_access \n+\t\t= BINFO_ACCESS (canonical_binfo (base_binfo));\n \n-\t      if (!base_access || base_access == access_private_node)\n+\t      if (base_access == ak_none || base_access == ak_private)\n \t\t/* If it was not accessible in the base, or only\n \t\t   accessible as a private member, we can't access it\n \t\t   all.  */\n-\t\tbase_access = NULL_TREE;\n+\t\tbase_access = ak_none;\n \t      else if (TREE_VIA_PROTECTED (base_binfo))\n \t\t/* Public and protected members in the base are\n \t\t   protected here.  */\n-\t\tbase_access = access_protected_node;\n+\t\tbase_access = ak_protected;\n \t      else if (!TREE_VIA_PUBLIC (base_binfo))\n \t\t/* Public and protected members in the base are\n \t\t   private here.  */\n-\t\tbase_access = access_private_node;\n+\t\tbase_access = ak_private;\n \n \t      /* See if the new access, via this base, gives more\n \t\t access than our previous best access.  */\n-\t      if (base_access &&\n-\t\t  (base_access == access_public_node\n-\t\t   || (base_access == access_protected_node\n-\t\t       && access != access_public_node)\n-\t\t   || (base_access == access_private_node\n-\t\t       && !access)))\n+\t      if (base_access != ak_none\n+\t\t  && (base_access == ak_public\n+\t\t      || (base_access == ak_protected\n+\t\t\t  && access != ak_public)\n+\t\t      || (base_access == ak_private \n+\t\t\t  && access == ak_none)))\n \t\t{\n \t\t  access = base_access;\n \n \t\t  /* If the new access is public, we can't do better.  */\n-\t\t  if (access == access_public_node)\n+\t\t  if (access == ak_public)\n \t\t    break;\n \t\t}\n \t    }\n \t}\n     }\n \n   /* Note the access to DECL in TYPE.  */\n-  TREE_CHAIN (binfo) = access;\n+  SET_BINFO_ACCESS (binfo, access);\n \n   /* Mark TYPE as visited so that if we reach it again we do not\n      duplicate our efforts here.  */\n@@ -907,7 +920,7 @@ dfs_access_in_type (binfo, data)\n \n /* Return the access to DECL in TYPE.  */\n \n-static tree \n+static access_kind\n access_in_type (type, decl)\n      tree type;\n      tree decl;\n@@ -929,7 +942,7 @@ access_in_type (type, decl)\n   dfs_walk (binfo, dfs_unmark, shared_marked_p,  0);\n   assert_canonical_unmarked (binfo);\n \n-  return TREE_CHAIN (binfo);\n+  return BINFO_ACCESS (binfo);\n }\n \n /* Called from dfs_accessible_p via dfs_walk.  */\n@@ -960,17 +973,14 @@ dfs_accessible_p (binfo, data)\n      void *data;\n {\n   int protected_ok = data != 0;\n-  tree access;\n+  access_kind access;\n \n-  /* We marked the binfos while computing the access in each type.\n-     So, we unmark as we go now.  */\n   SET_BINFO_MARKED (binfo);\n-\n-  access = TREE_CHAIN (binfo);\n-  if (access == access_public_node\n-      || (access == access_protected_node && protected_ok))\n+  access = BINFO_ACCESS (binfo);\n+  if (access == ak_public || (access == ak_protected && protected_ok))\n     return binfo;\n-  else if (access && is_friend (BINFO_TYPE (binfo), current_scope ()))\n+  else if (access != ak_none\n+\t   && is_friend (BINFO_TYPE (binfo), current_scope ()))\n     return binfo;\n \n   return NULL_TREE;\n@@ -985,7 +995,7 @@ protected_accessible_p (decl, derived, binfo)\n      tree derived;\n      tree binfo;\n {\n-  tree access;\n+  access_kind access;\n \n   /* We're checking this clause from [class.access.base]\n \n@@ -1010,7 +1020,7 @@ protected_accessible_p (decl, derived, binfo)\n   access = access_in_type (derived, decl);\n \n   /* If m is inaccessible in DERIVED, then it's not a P.  */\n-  if (access == NULL_TREE)\n+  if (access == ak_none)\n     return 0;\n   \n   /* [class.protected]\n@@ -1752,12 +1762,11 @@ lookup_fnfields_1 (type, name)\n    If it ever returns a non-NULL value, that value is immediately\n    returned and the walk is terminated.  At each node FN, is passed a\n    BINFO indicating the path from the curently visited base-class to\n-   TYPE.  The TREE_CHAINs of the BINFOs may be used for scratch space;\n-   they are otherwise unused.  Before each base-class is walked QFN is\n-   called.  If the value returned is non-zero, the base-class is\n-   walked; otherwise it is not.  If QFN is NULL, it is treated as a\n-   function which always returns 1.  Both FN and QFN are passed the\n-   DATA whenever they are called.  */\n+   TYPE.  Before each base-class is walked QFN is called.  If the\n+   value returned is non-zero, the base-class is walked; otherwise it\n+   is not.  If QFN is NULL, it is treated as a function which always\n+   returns 1.  Both FN and QFN are passed the DATA whenever they are\n+   called.  */\n \n static tree\n bfs_walk (binfo, fn, qfn, data)\n@@ -2194,97 +2203,6 @@ dfs_skip_nonprimary_vbases_markedp (binfo, data)\n   return markedp (binfo, NULL);\n }\n \n-/* Called via dfs_walk from mark_primary_bases.  */\n-\n-static tree\n-dfs_mark_primary_bases (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  int i;\n-  tree base_binfo;\n-\n-  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n-    return NULL_TREE;\n-\n-  i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-  base_binfo = BINFO_BASETYPE (binfo, i);\n-\n-  if (!TREE_VIA_VIRTUAL (base_binfo))\n-    /* Non-virtual base classes are easy.  */\n-    BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n-  else\n-    {\n-      tree shared_binfo;\n-\n-      shared_binfo \n-\t= BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), (tree) data);\n-\n-      /* If this virtual base is not already primary somewhere else in\n-\t the hiearchy, then we'll be using this copy.  */\n-      if (!BINFO_VBASE_PRIMARY_P (shared_binfo)\n-\t  && !BINFO_VBASE_MARKED (shared_binfo))\n-\t{\n-\t  BINFO_VBASE_PRIMARY_P (shared_binfo) = 1;\n-\t  BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Set BINFO_PRIMARY_MARKED_P for all binfos in the hierarchy\n-   dominated by BINFO that are primary bases.  */\n-\n-void\n-mark_primary_bases (type)\n-     tree type;\n-{\n-  tree vbase;\n-\n-  /* Mark the TYPE_BINFO hierarchy.  We need to mark primary bases in\n-     pre-order to deal with primary virtual bases.  (The virtual base\n-     would be skipped if it were not marked as primary, and that\n-     requires getting to dfs_mark_primary_bases before\n-     dfs_skip_nonprimary_vbases_unmarkedp has a chance to skip the\n-     virtual base.)  */\n-  dfs_walk_real (TYPE_BINFO (type), dfs_mark_primary_bases, NULL,\n-\t\t dfs_skip_nonprimary_vbases_unmarkedp, type);\n-\n-  /* Now go through the virtual base classes.  Any that are not\n-     already primary will need to be allocated in TYPE, and so we need\n-     to mark their primary bases.  */\n-  for (vbase = CLASSTYPE_VBASECLASSES (type); \n-       vbase; \n-       vbase = TREE_CHAIN (vbase))\n-    {\n-      if (BINFO_VBASE_PRIMARY_P (vbase))\n-\t/* This virtual base was already included in the hierarchy, so\n-\t   there's nothing to do here.  */\n-\tcontinue;\n-\n-      /* Temporarily pretend that VBASE is primary so that its bases\n-\t will be walked; this is the real copy of VBASE.  */\n-      BINFO_PRIMARY_MARKED_P (vbase) = 1;\n-\n-      /* Now, walk its bases.  */\n-      dfs_walk (vbase, dfs_mark_primary_bases,\n-\t\tdfs_skip_nonprimary_vbases_unmarkedp, type);\n-\n-      /* VBASE wasn't really primary.  */\n-      BINFO_PRIMARY_MARKED_P (vbase) = 0;\n-      /* And we don't want to allow it to *become* primary if it is a\n-\t base of some subsequent base class.  */\n-      SET_BINFO_VBASE_MARKED (vbase);\n-    }\n-\n-  /* Clear the VBASE_MARKED bits we set above.  */\n-  for (vbase = CLASSTYPE_VBASECLASSES (type); \n-       vbase; \n-       vbase = TREE_CHAIN (vbase))\n-    CLEAR_BINFO_VBASE_MARKED (vbase);\n-}\n-\n /* If BINFO is a non-primary virtual baseclass (in the hierarchy\n    dominated by TYPE), and no primary copy appears anywhere in the\n    hierarchy, return the shared copy.  If a primary copy appears\n@@ -2577,17 +2495,6 @@ dfs_unmark (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Clear both BINFO_MARKED and BINFO_VBASE_MARKED.  */\n-\n-tree\n-dfs_vbase_unmark (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  CLEAR_BINFO_VBASE_MARKED (binfo);\n-  return dfs_unmark (binfo, data);\n-}\n-\n /* Clear BINFO_VTABLE_PATH_MARKED.  */\n \n tree\n@@ -2781,7 +2688,7 @@ virtual_context (fndecl, t, vbase)\n   while (path)\n     {\n       if (TREE_VIA_VIRTUAL (path))\n-\treturn binfo_member (BINFO_TYPE (path), CLASSTYPE_VBASECLASSES (t));\n+\treturn BINFO_FOR_VBASE (BINFO_TYPE (path), t);\n       path = BINFO_INHERITANCE_CHAIN (path);\n     }\n   return 0;\n@@ -3072,7 +2979,7 @@ dfs_get_vbase_types (binfo, data)\n {\n   tree type = (tree) data;\n \n-  if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo))\n     {\n       tree new_vbase = make_binfo (size_zero_node, \n \t\t\t\t   BINFO_TYPE (binfo),\n@@ -3083,24 +2990,50 @@ dfs_get_vbase_types (binfo, data)\n       BINFO_INHERITANCE_CHAIN (new_vbase) = TYPE_BINFO (type);\n       TREE_CHAIN (new_vbase) = CLASSTYPE_VBASECLASSES (type);\n       CLASSTYPE_VBASECLASSES (type) = new_vbase;\n-      SET_BINFO_VBASE_MARKED (binfo);\n     }\n   SET_BINFO_MARKED (binfo);\n   return NULL_TREE;\n }\n \n+/* Called via dfs_walk from mark_primary_bases.  Builds the\n+   inheritance graph order list of BINFOs.  */\n+\n+static tree\n+dfs_build_inheritance_graph_order (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree *last_binfo = (tree *) data;\n+\n+  if (*last_binfo)\n+    TREE_CHAIN (*last_binfo) = binfo;\n+  *last_binfo = binfo;\n+  SET_BINFO_MARKED (binfo);\n+  return NULL_TREE;\n+}\n+\n /* Set CLASSTYPE_VBASECLASSES for TYPE.  */\n \n void\n get_vbase_types (type)\n      tree type;\n {\n+  tree last_binfo;\n+\n   CLASSTYPE_VBASECLASSES (type) = NULL_TREE;\n   dfs_walk (TYPE_BINFO (type), dfs_get_vbase_types, unmarkedp, type);\n   /* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now\n      reverse it so that we get normal dfs ordering.  */\n   CLASSTYPE_VBASECLASSES (type) = nreverse (CLASSTYPE_VBASECLASSES (type));\n-  dfs_walk (TYPE_BINFO (type), dfs_vbase_unmark, markedp, 0);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, 0);\n+  /* Thread the BINFOs in inheritance-graph order.  */\n+  last_binfo = NULL;\n+  dfs_walk_real (TYPE_BINFO (type),\n+\t\t dfs_build_inheritance_graph_order,\n+\t\t NULL,\n+\t\t unmarkedp,\n+\t\t &last_binfo);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, NULL);\n }\n \n /* Called from find_vbase_instance via dfs_walk.  */"}, {"sha": "fbc498b5d7d0aae434e6164f66ecb4bb1ccb2178", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -590,6 +590,14 @@ adjust_pointer (const void *base, ptrdiff_t offset)\n     (reinterpret_cast <const char *> (base) + offset);\n }\n \n+inline ptrdiff_t\n+get_vbase_offset (const void *object, ptrdiff_t offset)\n+{\n+  const char *vtable = *reinterpret_cast <const char *const *> (object);\n+  vtable += offset;\n+  return *reinterpret_cast <const ptrdiff_t *> (vtable);\n+}\n+\n // some predicate functions for __class_type_info::sub_kind\n inline bool contained_p (__class_type_info::sub_kind access_path)\n {\n@@ -718,9 +726,7 @@ do_find_public_src (ptrdiff_t src2dst,\n         {\n           if (src2dst == -3)\n             continue; // Not a virtual base, so can't be here.\n-  \t  const ptrdiff_t *vtable = *static_cast <const ptrdiff_t *const *> (base);\n-          \n-\t  offset = vtable[offset];\n+\t  offset = get_vbase_offset (base, offset);\n         }\n       base = adjust_pointer <void> (base, offset);\n       \n@@ -841,9 +847,7 @@ do_dyncast (ptrdiff_t src2dst,\n       if (base_list[i].is_virtual_p ())\n         {\n           base_access = sub_kind (base_access | contained_virtual_mask);\n-  \t  const ptrdiff_t *vtable = *static_cast <const ptrdiff_t *const *> (base);\n-          \n-\t  offset = vtable[offset];\n+\t  offset = get_vbase_offset (base, offset);\n \t}\n       base = adjust_pointer <void> (base, offset);\n \n@@ -1041,10 +1045,7 @@ do_upcast (sub_kind access_path,\n       \t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n           \n           if (base)\n-            {\n-    \t      const ptrdiff_t *vtable = *static_cast <const ptrdiff_t *const *> (base);\n-\t      offset = vtable[offset];\n-\t    }\n+\t    offset = get_vbase_offset (base, offset);\n         }\n       if (base)\n         base = adjust_pointer <void> (base, offset);"}, {"sha": "d5e0a5d667afa5c2ecc88e11f044d82da1856673", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -921,7 +921,7 @@ debug_binfo (elem)\n   debug_tree (BINFO_TYPE (elem));\n   if (BINFO_VTABLE (elem))\n     fprintf (stderr, \"vtable decl \\\"%s\\\"\\n\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (BINFO_VTABLE (elem))));\n+\t     IDENTIFIER_POINTER (DECL_NAME (get_vtbl_decl_for_binfo (elem))));\n   else\n     fprintf (stderr, \"no vtable decl yet\\n\");\n   fprintf (stderr, \"virtuals:\\n\");"}, {"sha": "a37ef07e75f2a358b2174499a6971f1c6365aaee", "filename": "gcc/testsuite/g++.old-deja/g++.abi/layout1.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Flayout1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Flayout1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Flayout1.C?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -0,0 +1,51 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+\n+struct R\n+{\n+  virtual void r ();\n+};\n+\n+struct S \n+{\n+  virtual void f ();\n+};\n+\n+struct T : virtual public S\n+{\n+  virtual void g ();\n+};\n+\n+struct U : public R, virtual public T\n+{\n+  virtual void h ();\n+};\n+\n+struct V : public R, virtual public S, virtual public T\n+{\n+  virtual void v ();\n+};\n+\n+struct U1\n+{\n+  R r;\n+  T t;\n+};\n+\n+int main ()\n+{\n+  if (sizeof (U) != sizeof (U1))\n+    return 1;\n+  if (sizeof (V) != sizeof (U1))\n+    return 2;\n+}\n+\n+#else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */\n+\n+int main ()\n+{\n+}\n+\n+#endif /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */\n+"}, {"sha": "4c811a8c5abd37c65852db8ba29d28eb165ca3e4", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable.C?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -65,7 +65,7 @@ int main ()\n   \n   if (vtable (&s4) != vtable (s2))\n     return 1;\n-    if (vtable (s2) >= vtable (s3))\n+  if (vtable (s2) >= vtable (s3))\n     return 2;\n   if (vtable (s3) >= vtable (s1))\n     return 3;"}, {"sha": "5d8cf9d019786ccc895443e8590b55f8d76e20be", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable2.C", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable2.C?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -0,0 +1,179 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+\n+#include <stddef.h>\n+\n+struct S0\n+{\n+  virtual void s0 ();\n+};\n+\n+struct S1 : virtual public S0\n+{\n+  virtual void s1 ();\n+};\n+\n+struct S2 : virtual public S1\n+{\n+  virtual void s1 ();\n+  virtual void s0 ();\n+};\n+\n+struct S3\n+{\n+  virtual void s3 ();\n+};\n+\n+struct S4 : public S3, virtual public S2\n+{\n+  virtual void s1 ();\n+};\n+\n+void S0::s0 ()\n+{\n+}\n+\n+void S1::s1 ()\n+{\n+}\n+\n+void S2::s1 ()\n+{\n+}\n+\n+void S2::s0 ()\n+{\n+}\n+\n+void S3::s3 ()\n+{\n+}\n+\n+void S4::s1 ()\n+{\n+}\n+\n+/* The vtables should look like:\n+\n+   S0 primary vtable\n+   \n+     S0 offset to top\n+     S0 RTTI\n+     S0::s0\n+\n+   =================\n+\n+   S1 primary vtable\n+\n+     S0::s0 vcall offset\n+     S0 vbase offset\n+     S1 offset to top\n+     S1 RTTI\n+     S0::s0\n+     S1::s1\n+\n+   =================\n+\n+   S2 primary vtable\n+   \n+     S2::s1 vcall offset\n+     S1 vbase offset\n+     S2::s0 vcall offset\n+     S0 vbase offset\n+     S2 offset to top\n+     S2 RTTI\n+     S2::s0\n+     S2::s1\n+\n+   =================\n+\n+   S3 primary vtable\n+\n+     S3 offset to top\n+     S3 RTTI\n+     S3::s3\n+\n+   =================\n+\n+   S4 primary vtable\n+\n+     vbase offset for S0\n+     vbase offset for S1\n+     vbase offset for S2\n+     S4 offset to top\n+     S4 RTTI\n+     S3::s3\n+     S4::s1\n+\n+   S2-in-S4 secondary vtable\n+\n+     S4::s1 vcall offset\n+     S1 vbase offset\n+     S2:s0 vcall offset\n+     S0 vbase offset\n+     S2 offset to top\n+     S4 RTTI\n+     S2::s0\n+     S4::s1\n+\n+*/\n+\n+// These are tricks to allow us to get raw function pointers for\n+// member functions.\n+extern \"C\" {\n+void s3__2S3 ();\n+void s1__2S4 ();\n+}\n+\n+int main ()\n+{\n+  S4 s4;\n+  ptrdiff_t **vptr;\n+  ptrdiff_t *vtbl;\n+\n+  // Set vtbl to point at the beginning of S4's primary vtable.\n+  vptr = (ptrdiff_t **) &s4;\n+  vtbl = *vptr;\n+  vtbl -= 5;\n+\n+  if (*vtbl++ != ((char*) (S0*) &s4) - (char*) &s4)\n+    return 1;\n+  if (*vtbl++ != ((char*) (S1*) &s4) - (char*) &s4)\n+    return 2;\n+  if (*vtbl++ != ((char*) (S2*) &s4) - (char*) &s4)\n+    return 3;\n+  if (*vtbl++ != 0)\n+    return 4;\n+  // Skip the RTTI entry.\n+  vtbl++;\n+  if (*vtbl++ != (ptrdiff_t) &s3__2S3)\n+    return 5;\n+  if (*vtbl++ != (ptrdiff_t) &s1__2S4)\n+    return 6;\n+  // All the vcall and vbase offsets should be zero.\n+  if (*vtbl++ != 0)\n+    return 7;\n+  if (*vtbl++ != 0)\n+    return 8;\n+  if (*vtbl++ != 0)\n+    return 9;\n+  if (*vtbl++ != 0)\n+    return 10;\n+  // Now we're at the S2 offset to top entry.\n+  if (*vtbl++ != ((char*) &s4 - (char*) (S2*) &s4))\n+    return 11;\n+  // Skip the RTTI entry.\n+  vtbl++;\n+  // Skip the remaining virtual functions -- they are thunks.\n+  vtbl++;\n+  vtbl++;\n+}\n+\n+#else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */\n+\n+int main ()\n+{\n+}\n+\n+#endif /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}, {"sha": "a67a1ddc9dc4e22048311086e2891ee7c4d2600e", "filename": "gcc/testsuite/g++.old-deja/g++.jason/dcast3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fdcast3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c35cce41daad1894587834b71c9342669ecf3fa7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fdcast3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fdcast3.C?ref=c35cce41daad1894587834b71c9342669ecf3fa7", "patch": "@@ -28,5 +28,5 @@ int main ()\n   ap = (C2*)&e2;\n   // ap points to base subobject shared by two Bs; fails\n   if (dynamic_cast <B2*> (ap) != 0)\n-    return 1;\n+    return 2;\n }"}]}