{"sha": "4ee16841d49a370564703362a152dfd75412d6ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVlMTY4NDFkNDlhMzcwNTY0NzAzMzYyYTE1MmRmZDc1NDEyZDZhZA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-08T21:16:01Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-08T21:16:01Z"}, "message": "(extract_split_bit_field): Set UNIT to BITS_PER_WORD for register values.\n\n(store_split_bit_field): Likewise.  Call operand_subword_force.\n\nFrom-SVN: r7684", "tree": {"sha": "7b38a047710daa2eae4fd979fa453c32e0cac87d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b38a047710daa2eae4fd979fa453c32e0cac87d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ee16841d49a370564703362a152dfd75412d6ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee16841d49a370564703362a152dfd75412d6ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee16841d49a370564703362a152dfd75412d6ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee16841d49a370564703362a152dfd75412d6ad/comments", "author": null, "committer": null, "parents": [{"sha": "9fd5bb6267ca1d3bca69e58b121fad23e9a45308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fd5bb6267ca1d3bca69e58b121fad23e9a45308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fd5bb6267ca1d3bca69e58b121fad23e9a45308"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "5b2d61ef270c6db9344c28a39fcd79bcf589ce5a", "filename": "gcc/expmed.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee16841d49a370564703362a152dfd75412d6ad/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee16841d49a370564703362a152dfd75412d6ad/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=4ee16841d49a370564703362a152dfd75412d6ad", "patch": "@@ -694,10 +694,15 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n      rtx value;\n      int align;\n {\n+  int unit;\n+  int bitsdone = 0;\n+\n   /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n      much at a time.  */\n-  int unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n-  int bitsdone = 0;\n+  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+    unit = BITS_PER_WORD;\n+  else\n+    unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n \n   /* If VALUE is a constant other than a CONST_INT, get it into a register in\n      WORD_MODE.  If we can do this using gen_lowpart_common, do so.  Note\n@@ -767,22 +772,19 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n \t the current word starting from the base register.  */\n       if (GET_CODE (op0) == SUBREG)\n \t{\n-\t  word = operand_subword (SUBREG_REG (op0),\n-\t\t\t\t  SUBREG_WORD (op0) + offset, 1,\n-\t\t\t\t  GET_MODE (SUBREG_REG (op0)));\n+\t  word = operand_subword_force (SUBREG_REG (op0),\n+\t\t\t\t\tSUBREG_WORD (op0) + offset,\n+\t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n \t  offset = 0;\n \t}\n       else if (GET_CODE (op0) == REG)\n \t{\n-\t  word = operand_subword (op0, offset, 1, GET_MODE (op0));\n+\t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n \t  offset = 0;\n \t}\n       else\n \tword = op0;\n \n-      if (word == 0)\n-\tabort ();\n-\n       /* OFFSET is in UNITs, and UNIT is in bits.\n          store_fixed_bit_field wants offset in bytes.  */\n       store_fixed_bit_field (word, offset * unit / BITS_PER_UNIT,\n@@ -1503,13 +1505,18 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n      rtx op0;\n      int bitsize, bitpos, unsignedp, align;\n {\n-  /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n-     much at a time.  */\n-  int unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n+  int unit;\n   int bitsdone = 0;\n   rtx result;\n   int first = 1;\n \n+  /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n+     much at a time.  */\n+  if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n+    unit = BITS_PER_WORD;\n+  else\n+    unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n+\n   while (bitsdone < bitsize)\n     {\n       int thissize;\n@@ -1547,9 +1554,6 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n       else\n \tword = op0;\n \n-      if (word == 0)\n-\tabort ();\n-\n       /* Extract the parts in bit-counting order,\n \t whose meaning is determined by BYTES_PER_UNIT.\n \t OFFSET is in UNITs, and UNIT is in bits."}]}