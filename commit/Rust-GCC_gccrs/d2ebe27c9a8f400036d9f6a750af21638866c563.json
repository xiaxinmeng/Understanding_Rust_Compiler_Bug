{"sha": "d2ebe27c9a8f400036d9f6a750af21638866c563", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJlYmUyN2M5YThmNDAwMDM2ZDlmNmE3NTBhZjIxNjM4ODY2YzU2Mw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-01-23T04:51:28Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-01-23T04:51:28Z"}, "message": "re PR target/19378 (ICE during bootstrap compiling __fixdfdi)\n\n\n\tPR middle-end/19378\n\t* config/avr/avr.c (avr_hard_regno_mode_ok): Rewrite.\n\nFrom-SVN: r94102", "tree": {"sha": "986473ca6fe688ccd6093f364c63d788bd1c2ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/986473ca6fe688ccd6093f364c63d788bd1c2ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2ebe27c9a8f400036d9f6a750af21638866c563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ebe27c9a8f400036d9f6a750af21638866c563", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ebe27c9a8f400036d9f6a750af21638866c563", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ebe27c9a8f400036d9f6a750af21638866c563/comments", "author": null, "committer": null, "parents": [{"sha": "0e69bba9fc926fd529f51aa9e7f585c27b88c1e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e69bba9fc926fd529f51aa9e7f585c27b88c1e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e69bba9fc926fd529f51aa9e7f585c27b88c1e3"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "07c5b17c5f2cd965edd8e6dd8d19607dc353478c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ebe27c9a8f400036d9f6a750af21638866c563/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ebe27c9a8f400036d9f6a750af21638866c563/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2ebe27c9a8f400036d9f6a750af21638866c563", "patch": "@@ -1,3 +1,8 @@\n+2005-01-22  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR middle-end/19378\n+\t* config/avr/avr.c (avr_hard_regno_mode_ok): Rewrite.\n+\n 2005-01-22  Richard Henderson  <rth@redhat.com>\n \n \tPR target/19506"}, {"sha": "0f6b2dee90af7ae926cf34ed1967cc029e8c4c9d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ebe27c9a8f400036d9f6a750af21638866c563/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ebe27c9a8f400036d9f6a750af21638866c563/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=d2ebe27c9a8f400036d9f6a750af21638866c563", "patch": "@@ -5121,23 +5121,22 @@ jump_over_one_insn_p (rtx insn, rtx dest)\n int\n avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n {\n-  /* Bug workaround: recog.c (peep2_find_free_register) and probably\n-     a few other places assume that the frame pointer is a single hard\n-     register, so r29 may be allocated and overwrite the high byte of\n-     the frame pointer.  Do not allow any value to start in r29.  */\n-  if (regno == REG_Y + 1)\n-    return 0;\n+  /* The only thing that can go into registers r28:r29 is a Pmode.  */\n+  if (regno == REG_Y && mode == Pmode)\n+    return 1;\n \n-  /* Reload can use r28:r29 for reload register and for frame pointer\n-   in one insn. It's wrong. We must disable it.  */\n-  if (mode != Pmode && reload_in_progress && frame_pointer_required_p ()\n-      && regno <= REG_Y && (regno + GET_MODE_SIZE (mode)) >= (REG_Y + 1))\n+  /* Otherwise disallow all regno/mode combinations that span r28:r29.  */\n+  if (regno <= (REG_Y + 1) && (regno + GET_MODE_SIZE (mode)) >= (REG_Y + 1))\n     return 0;\n \n   if (mode == QImode)\n     return 1;\n-  /*  if (regno < 24 && !AVR_ENHANCED)\n-      return 1;*/\n+\n+  /* Modes larger than QImode occupy consecutive registers.  */\n+  if (regno + GET_MODE_SIZE (mode) > FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  /* All modes larger than QImode should start in an even register.  */\n   return !(regno & 1);\n }\n "}]}