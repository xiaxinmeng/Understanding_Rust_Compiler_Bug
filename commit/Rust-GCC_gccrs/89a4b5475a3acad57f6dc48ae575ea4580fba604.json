{"sha": "89a4b5475a3acad57f6dc48ae575ea4580fba604", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlhNGI1NDc1YTNhY2FkNTdmNmRjNDhhZTU3NWVhNDU4MGZiYTYwNA==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-07-04T07:31:24Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-07-04T07:31:24Z"}, "message": "Move cost calculation to nds32-cost.c module.\n\ngcc/\n\t* config/nds32/nds32.c (nds32_rtx_costs): Move implementation to ...\n\t(nds32_address_cost): Move implementation to ...\n\t* config/nds32/nds32-cost.c: ... here.\n\t* config/nds32/nds32-protos.h (nds32_rtx_costs_impl): Declare.\n\t(nds32_address_cost_impl): Declare.\n\nCo-Authored-By: Kito Cheng <kito@0xlab.org>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r212284", "tree": {"sha": "e1125460ae7bf9c91443b30e3e3d94658da5d842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1125460ae7bf9c91443b30e3e3d94658da5d842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89a4b5475a3acad57f6dc48ae575ea4580fba604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89a4b5475a3acad57f6dc48ae575ea4580fba604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89a4b5475a3acad57f6dc48ae575ea4580fba604", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89a4b5475a3acad57f6dc48ae575ea4580fba604/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a2a98b1a658893ecb790c90614900d7bf8bd022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2a98b1a658893ecb790c90614900d7bf8bd022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2a98b1a658893ecb790c90614900d7bf8bd022"}], "stats": {"total": 463, "additions": 268, "deletions": 195}, "files": [{"sha": "d2d1ec7f557cc315a2cf2a5a221f1ae9bae929ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89a4b5475a3acad57f6dc48ae575ea4580fba604", "patch": "@@ -1,3 +1,13 @@\n+2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito@0xlab.org>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_rtx_costs): Move implementation to ...\n+\t(nds32_address_cost): Move implementation to ...\n+\t* config/nds32/nds32-cost.c: ... here.\n+\t* config/nds32/nds32-protos.h (nds32_rtx_costs_impl): Declare.\n+\t(nds32_address_cost_impl): Declare.\n+\n 2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Kito Cheng  <kito@0xlab.org>\n \t    Monk Chiang  <sh.chiang04@gmail.com>"}, {"sha": "b1792d59726f6e1788af05c69ae4ed34f0249ebd", "filename": "gcc/config/nds32/nds32-cost.c", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-cost.c?ref=89a4b5475a3acad57f6dc48ae575ea4580fba604", "patch": "@@ -17,3 +17,251 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\t/* Required by recog.h.  */\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\t\t/* For DFA state_t.  */\n+#include \"insn-codes.h\"\t\t/* For CODE_FOR_xxx.  */\n+#include \"reload.h\"\t\t/* For push_reload().  */\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"ggc.h\"\n+#include \"builtins.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+bool\n+nds32_rtx_costs_impl (rtx x,\n+\t\t      int code,\n+\t\t      int outer_code,\n+\t\t      int opno ATTRIBUTE_UNUSED,\n+\t\t      int *total,\n+\t\t      bool speed)\n+{\n+  /* According to 'speed', goto suitable cost model section.  */\n+  if (speed)\n+    goto performance_cost;\n+  else\n+    goto size_cost;\n+\n+\n+performance_cost:\n+  /* This is section for performance cost model.  */\n+\n+  /* In gcc/rtl.h, the default value of COSTS_N_INSNS(N) is N*4.\n+     We treat it as 4-cycle cost for each instruction\n+     under performance consideration.  */\n+  switch (code)\n+    {\n+    case SET:\n+      /* For 'SET' rtx, we need to return false\n+         so that it can recursively calculate costs.  */\n+      return false;\n+\n+    case USE:\n+      /* Used in combine.c as a marker.  */\n+      *total = 0;\n+      break;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (1);\n+      break;\n+\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      *total = COSTS_N_INSNS (7);\n+      break;\n+\n+    default:\n+      *total = COSTS_N_INSNS (1);\n+      break;\n+    }\n+\n+  return true;\n+\n+\n+size_cost:\n+  /* This is section for size cost model.  */\n+\n+  /* In gcc/rtl.h, the default value of COSTS_N_INSNS(N) is N*4.\n+     We treat it as 4-byte cost for each instruction\n+     under code size consideration.  */\n+  switch (code)\n+    {\n+    case SET:\n+      /* For 'SET' rtx, we need to return false\n+         so that it can recursively calculate costs.  */\n+      return false;\n+\n+    case USE:\n+      /* Used in combine.c as a marker.  */\n+      *total = 0;\n+      break;\n+\n+    case CONST_INT:\n+      /* All instructions involving constant operation\n+         need to be considered for cost evaluation.  */\n+      if (outer_code == SET)\n+\t{\n+\t  /* (set X imm5s), use movi55, 2-byte cost.\n+\t     (set X imm20s), use movi, 4-byte cost.\n+\t     (set X BIG_INT), use sethi/ori, 8-byte cost.  */\n+\t  if (satisfies_constraint_Is05 (x))\n+\t    *total = COSTS_N_INSNS (1) - 2;\n+\t  else if (satisfies_constraint_Is20 (x))\n+\t    *total = COSTS_N_INSNS (1);\n+\t  else\n+\t    *total = COSTS_N_INSNS (2);\n+\t}\n+      else if (outer_code == PLUS || outer_code == MINUS)\n+\t{\n+\t  /* Possible addi333/subi333 or subi45/addi45, 2-byte cost.\n+\t     General case, cost 1 instruction with 4-byte.  */\n+\t  if (satisfies_constraint_Iu05 (x))\n+\t    *total = COSTS_N_INSNS (1) - 2;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t}\n+      else if (outer_code == ASHIFT)\n+\t{\n+\t  /* Possible slli333, 2-byte cost.\n+\t     General case, cost 1 instruction with 4-byte.  */\n+\t  if (satisfies_constraint_Iu03 (x))\n+\t    *total = COSTS_N_INSNS (1) - 2;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t}\n+      else if (outer_code == ASHIFTRT || outer_code == LSHIFTRT)\n+\t{\n+\t  /* Possible srai45 or srli45, 2-byte cost.\n+\t     General case, cost 1 instruction with 4-byte.  */\n+\t  if (satisfies_constraint_Iu05 (x))\n+\t    *total = COSTS_N_INSNS (1) - 2;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t}\n+      else\n+\t{\n+\t  /* For other cases, simply set it 4-byte cost.  */\n+\t  *total = COSTS_N_INSNS (1);\n+\t}\n+      break;\n+\n+    case CONST_DOUBLE:\n+      /* It requires high part and low part processing, set it 8-byte cost.  */\n+      *total = COSTS_N_INSNS (2);\n+      break;\n+\n+    default:\n+      /* For other cases, generally we set it 4-byte cost\n+         and stop resurively traversing.  */\n+      *total = COSTS_N_INSNS (1);\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+int\n+nds32_address_cost_impl (rtx address,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t addr_space_t as ATTRIBUTE_UNUSED,\n+\t\t\t bool speed)\n+{\n+  rtx plus0, plus1;\n+  enum rtx_code code;\n+\n+  code = GET_CODE (address);\n+\n+  /* According to 'speed', goto suitable cost model section.  */\n+  if (speed)\n+    goto performance_cost;\n+  else\n+    goto size_cost;\n+\n+performance_cost:\n+  /* This is section for performance cost model.  */\n+\n+  /* FALLTHRU, currently we use same cost model as size_cost.  */\n+\n+size_cost:\n+  /* This is section for size cost model.  */\n+\n+  switch (code)\n+    {\n+    case POST_MODIFY:\n+    case POST_INC:\n+    case POST_DEC:\n+      /* We encourage that rtx contains\n+         POST_MODIFY/POST_INC/POST_DEC behavior.  */\n+      return 0;\n+\n+    case SYMBOL_REF:\n+      /* We can have gp-relative load/store for symbol_ref.\n+         Have it 4-byte cost.  */\n+      return COSTS_N_INSNS (1);\n+\n+    case CONST:\n+      /* It is supposed to be the pattern (const (plus symbol_ref const_int)).\n+         Have it 4-byte cost.  */\n+      return COSTS_N_INSNS (1);\n+\n+    case REG:\n+      /* Simply return 4-byte costs.  */\n+      return COSTS_N_INSNS (1);\n+\n+    case PLUS:\n+      /* We do not need to check if the address is a legitimate address,\n+         because this hook is never called with an invalid address.\n+         But we better check the range of\n+         const_int value for cost, if it exists.  */\n+      plus0 = XEXP (address, 0);\n+      plus1 = XEXP (address, 1);\n+\n+      if (REG_P (plus0) && CONST_INT_P (plus1))\n+        {\n+\t  /* If it is possible to be lwi333/swi333 form,\n+\t     make it 2-byte cost.  */\n+\t  if (satisfies_constraint_Iu05 (plus1))\n+\t    return (COSTS_N_INSNS (1) - 2);\n+\t  else\n+\t    return COSTS_N_INSNS (1);\n+\t}\n+\n+      /* For other 'plus' situation, make it cost 4-byte.  */\n+      return COSTS_N_INSNS (1);\n+\n+    default:\n+      break;\n+    }\n+\n+  return COSTS_N_INSNS (4);\n+}\n+\n+/* ------------------------------------------------------------------------ */"}, {"sha": "2bebaa6299118da6318635036333515504465179", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=89a4b5475a3acad57f6dc48ae575ea4580fba604", "patch": "@@ -138,4 +138,9 @@ extern void nds32_construct_isr_vectors_information (tree, const char *);\n extern void nds32_asm_file_start_for_isr (void);\n extern void nds32_asm_file_end_for_isr (void);\n \n+/* Auxiliary functions for cost calculation.  */\n+\n+extern bool nds32_rtx_costs_impl (rtx, int, int, int, int *, bool);\n+extern int nds32_address_cost_impl (rtx, enum machine_mode, addr_space_t, bool);\n+\n /* ------------------------------------------------------------------------ */"}, {"sha": "7361912575742ba094d44552e6dae9bd4a4ebee0", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 5, "deletions": 195, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a4b5475a3acad57f6dc48ae575ea4580fba604/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=89a4b5475a3acad57f6dc48ae575ea4580fba604", "patch": "@@ -1853,209 +1853,19 @@ static bool\n nds32_rtx_costs (rtx x,\n \t\t int code,\n \t\t int outer_code,\n-\t\t int opno ATTRIBUTE_UNUSED,\n+\t\t int opno,\n \t\t int *total,\n \t\t bool speed)\n {\n-  /* According to 'speed', goto suitable cost model section.  */\n-  if (speed)\n-    goto performance_cost;\n-  else\n-    goto size_cost;\n-\n-\n-performance_cost:\n-  /* This is section for performance cost model.  */\n-\n-  /* In gcc/rtl.h, the default value of COSTS_N_INSNS(N) is N*4.\n-     We treat it as 4-cycle cost for each instruction\n-     under performance consideration.  */\n-  switch (code)\n-    {\n-    case SET:\n-      /* For 'SET' rtx, we need to return false\n-         so that it can recursively calculate costs.  */\n-      return false;\n-\n-    case USE:\n-      /* Used in combine.c as a marker.  */\n-      *total = 0;\n-      break;\n-\n-    case MULT:\n-      *total = COSTS_N_INSNS (1);\n-      break;\n-\n-    case DIV:\n-    case UDIV:\n-    case MOD:\n-    case UMOD:\n-      *total = COSTS_N_INSNS (7);\n-      break;\n-\n-    default:\n-      *total = COSTS_N_INSNS (1);\n-      break;\n-    }\n-\n-  return true;\n-\n-\n-size_cost:\n-  /* This is section for size cost model.  */\n-\n-  /* In gcc/rtl.h, the default value of COSTS_N_INSNS(N) is N*4.\n-     We treat it as 4-byte cost for each instruction\n-     under code size consideration.  */\n-  switch (code)\n-    {\n-    case SET:\n-      /* For 'SET' rtx, we need to return false\n-         so that it can recursively calculate costs.  */\n-      return false;\n-\n-    case USE:\n-      /* Used in combine.c as a marker.  */\n-      *total = 0;\n-      break;\n-\n-    case CONST_INT:\n-      /* All instructions involving constant operation\n-         need to be considered for cost evaluation.  */\n-      if (outer_code == SET)\n-\t{\n-\t  /* (set X imm5s), use movi55, 2-byte cost.\n-\t     (set X imm20s), use movi, 4-byte cost.\n-\t     (set X BIG_INT), use sethi/ori, 8-byte cost.  */\n-\t  if (satisfies_constraint_Is05 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n-\t  else if (satisfies_constraint_Is20 (x))\n-\t    *total = COSTS_N_INSNS (1);\n-\t  else\n-\t    *total = COSTS_N_INSNS (2);\n-\t}\n-      else if (outer_code == PLUS || outer_code == MINUS)\n-\t{\n-\t  /* Possible addi333/subi333 or subi45/addi45, 2-byte cost.\n-\t     General case, cost 1 instruction with 4-byte.  */\n-\t  if (satisfies_constraint_Iu05 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n-\t  else\n-\t    *total = COSTS_N_INSNS (1);\n-\t}\n-      else if (outer_code == ASHIFT)\n-\t{\n-\t  /* Possible slli333, 2-byte cost.\n-\t     General case, cost 1 instruction with 4-byte.  */\n-\t  if (satisfies_constraint_Iu03 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n-\t  else\n-\t    *total = COSTS_N_INSNS (1);\n-\t}\n-      else if (outer_code == ASHIFTRT || outer_code == LSHIFTRT)\n-\t{\n-\t  /* Possible srai45 or srli45, 2-byte cost.\n-\t     General case, cost 1 instruction with 4-byte.  */\n-\t  if (satisfies_constraint_Iu05 (x))\n-\t    *total = COSTS_N_INSNS (1) - 2;\n-\t  else\n-\t    *total = COSTS_N_INSNS (1);\n-\t}\n-      else\n-\t{\n-\t  /* For other cases, simply set it 4-byte cost.  */\n-\t  *total = COSTS_N_INSNS (1);\n-\t}\n-      break;\n-\n-    case CONST_DOUBLE:\n-      /* It requires high part and low part processing, set it 8-byte cost.  */\n-      *total = COSTS_N_INSNS (2);\n-      break;\n-\n-    default:\n-      /* For other cases, generally we set it 4-byte cost\n-         and stop resurively traversing.  */\n-      *total = COSTS_N_INSNS (1);\n-      break;\n-    }\n-\n-  return true;\n+  return nds32_rtx_costs_impl (x, code, outer_code, opno, total, speed);\n }\n \n static int nds32_address_cost (rtx address,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t       addr_space_t as ATTRIBUTE_UNUSED,\n+\t\t\t       enum machine_mode mode,\n+\t\t\t       addr_space_t as,\n \t\t\t       bool speed)\n {\n-  rtx plus0, plus1;\n-  enum rtx_code code;\n-\n-  code = GET_CODE (address);\n-\n-  /* According to 'speed', goto suitable cost model section.  */\n-  if (speed)\n-    goto performance_cost;\n-  else\n-    goto size_cost;\n-\n-performance_cost:\n-  /* This is section for performance cost model.  */\n-\n-  /* FALLTHRU, currently we use same cost model as size_cost.  */\n-\n-size_cost:\n-  /* This is section for size cost model.  */\n-\n-  switch (code)\n-    {\n-    case POST_MODIFY:\n-    case POST_INC:\n-    case POST_DEC:\n-      /* We encourage that rtx contains\n-         POST_MODIFY/POST_INC/POST_DEC behavior.  */\n-      return 0;\n-\n-    case SYMBOL_REF:\n-      /* We can have gp-relative load/store for symbol_ref.\n-         Have it 4-byte cost.  */\n-      return COSTS_N_INSNS (1);\n-\n-    case CONST:\n-      /* It is supposed to be the pattern (const (plus symbol_ref const_int)).\n-         Have it 4-byte cost.  */\n-      return COSTS_N_INSNS (1);\n-\n-    case REG:\n-      /* Simply return 4-byte costs.  */\n-      return COSTS_N_INSNS (1);\n-\n-    case PLUS:\n-      /* We do not need to check if the address is a legitimate address,\n-         because this hook is never called with an invalid address.\n-         But we better check the range of\n-         const_int value for cost, if it exists.  */\n-      plus0 = XEXP (address, 0);\n-      plus1 = XEXP (address, 1);\n-\n-      if (REG_P (plus0) && CONST_INT_P (plus1))\n-        {\n-\t  /* If it is possible to be lwi333/swi333 form,\n-\t     make it 2-byte cost.  */\n-\t  if (satisfies_constraint_Iu05 (plus1))\n-\t    return (COSTS_N_INSNS (1) - 2);\n-\t  else\n-\t    return COSTS_N_INSNS (1);\n-\t}\n-\n-      /* For other 'plus' situation, make it cost 4-byte.  */\n-      return COSTS_N_INSNS (1);\n-\n-    default:\n-      break;\n-    }\n-\n-  return COSTS_N_INSNS (4);\n+  return nds32_address_cost_impl (address, mode, as, speed);\n }\n \n \f"}]}