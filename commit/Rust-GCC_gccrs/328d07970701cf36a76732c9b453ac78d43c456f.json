{"sha": "328d07970701cf36a76732c9b453ac78d43c456f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI4ZDA3OTcwNzAxY2YzNmE3NjczMmM5YjQ1M2FjNzhkNDNjNDU2Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-10T19:26:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-10T19:26:27Z"}, "message": "(HARD_REG_ELT_TYPE): New unsigned type to avoid signed arithmetic overflow.\n\n(HARD_REG_ELT_TYPE): New unsigned type to\navoid signed arithmetic overflow.\n(HARD_REG_SET): Define as HARD_REG_ELT_TYPE, or array thereof.\n(HARD_CONST): Always cast to HARD_REG_ELT_TYPE.\n(*_HARD_REG_*): Use unsigned HARD_CONST and HARD_REG_ELT_TYPE\ntypes instead of assuming HOST_WIDE_INT.\n\nFrom-SVN: r4901", "tree": {"sha": "1e67a7c622cd4f2a90e11db0c2d6fa21a34d96ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e67a7c622cd4f2a90e11db0c2d6fa21a34d96ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/328d07970701cf36a76732c9b453ac78d43c456f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328d07970701cf36a76732c9b453ac78d43c456f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/328d07970701cf36a76732c9b453ac78d43c456f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328d07970701cf36a76732c9b453ac78d43c456f/comments", "author": null, "committer": null, "parents": [{"sha": "344080e610264212214a5a3d1b562de6fbd03dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/344080e610264212214a5a3d1b562de6fbd03dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/344080e610264212214a5a3d1b562de6fbd03dea"}], "stats": {"total": 67, "additions": 35, "deletions": 32}, "files": [{"sha": "e8d88df49eb8fe21468942451937638c0b7346d2", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/328d07970701cf36a76732c9b453ac78d43c456f/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/328d07970701cf36a76732c9b453ac78d43c456f/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=328d07970701cf36a76732c9b453ac78d43c456f", "patch": "@@ -20,38 +20,40 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Define the type of a set of hard registers.  */\n \n-/* If HARD_REG_SET is a macro, its definition is a scalar type\n-   that has enough bits for all the target machine's hard registers.\n-   Otherwise, it is a typedef for a suitable array of HOST_WIDE_INTs,\n-   and HARD_REG_SET_LONGS is how many.\n+/* HARD_REG_ELT_TYPE is a typedef of the unsigned integral type which\n+   will be used for hard reg sets, either alone or in an array.\n+\n+   If HARD_REG_SET is a macro, its definition is HARD_REG_ELT_TYPE,\n+   and it has enough bits to represent all the target machine's hard\n+   registers.  Otherwise, it is a typedef for a suitably sized array\n+   of HARD_REG_ELT_TYPEs.  HARD_REG_SET_LONGS is defined as how many.\n \n    Note that lots of code assumes that the first part of a regset is\n    the same format as a HARD_REG_SET.  To help make sure this is true,\n    we only try the widest integer mode (HOST_WIDE_INT) instead of all the\n-   smaller types.  This only loses if there are a very few registers and\n-   then only in the few cases where we have an array of HARD_REG_SETs,\n-   so it isn't worth making this as complex as it used to be.  */\n+   smaller types.  This approach loses only if there are a very few\n+   registers and then only in the few cases where we have an array of\n+   HARD_REG_SETs, so it needn't be as complex as it used to be.  */\n+\n+typedef unsigned HOST_WIDE_INT HARD_REG_ELT_TYPE;\n \n #if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDE_INT\n-#define HARD_REG_SET HOST_WIDE_INT\n+\n+#define HARD_REG_SET HARD_REG_ELT_TYPE\n \n #else\n \n #define HARD_REG_SET_LONGS \\\n  ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDE_INT - 1)\t\\\n   / HOST_BITS_PER_WIDE_INT)\n-typedef HOST_WIDE_INT HARD_REG_SET[HARD_REG_SET_LONGS];\n+typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n \n #endif\n \n-/* HARD_CONST is used to cast a constant to a HARD_REG_SET\n-   if that is a scalar wider than an integer.  */\n+/* HARD_CONST is used to cast a constant to the appropriate type\n+   for use with a HARD_REG_SET.  */\n \n-#ifdef HARD_REG_SET\n-#define HARD_CONST(X) ((HARD_REG_SET) (X))\n-#else\n-#define HARD_CONST(X) (X)\n-#endif\n+#define HARD_CONST(X) ((HARD_REG_ELT_TYPE) (X))\n \n /* Define macros SET_HARD_REG_BIT, CLEAR_HARD_REG_BIT and TEST_HARD_REG_BIT\n    to set, clear or test one bit in a hard reg set of type HARD_REG_SET.\n@@ -90,7 +92,7 @@ typedef HOST_WIDE_INT HARD_REG_SET[HARD_REG_SET_LONGS];\n  ((SET) & (HARD_CONST (1) << (BIT)))\n \n #define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n-#define SET_HARD_REG_SET(TO) ((TO) = HARD_CONST (-1))\n+#define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n \n #define COPY_HARD_REG_SET(TO, FROM) ((TO) = (FROM))\n #define COMPL_HARD_REG_SET(TO, FROM) ((TO) = ~(FROM))\n@@ -103,82 +105,83 @@ typedef HOST_WIDE_INT HARD_REG_SET[HARD_REG_SET_LONGS];\n #define GO_IF_HARD_REG_SUBSET(X,Y,TO) if (HARD_CONST (0) == ((X) & ~(Y))) goto TO\n \n #define GO_IF_HARD_REG_EQUAL(X,Y,TO) if ((X) == (Y)) goto TO\n+\n #else\n \n #define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDE_INT)\n \n #define SET_HARD_REG_BIT(SET, BIT)\t\t\\\n   ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n-   |= (HOST_WIDE_INT) 1 << ((BIT) % UHOST_BITS_PER_WIDE_INT))\n+   |= HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))\n \n #define CLEAR_HARD_REG_BIT(SET, BIT)\t\t\\\n   ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n-   &= ~((HOST_WIDE_INT) 1 << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n+   &= ~(HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n \n #define TEST_HARD_REG_BIT(SET, BIT)\t\t\\\n   ((SET)[(BIT) / UHOST_BITS_PER_WIDE_INT]\t\\\n-   & ((HOST_WIDE_INT) 1 << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n+   & (HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n \n #define CLEAR_HARD_REG_SET(TO)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO);\t\t\t\\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = 0; } while (0)\n \n #define SET_HARD_REG_SET(TO)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO);\t\t\t\\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = -1; } while (0)\n \n #define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = *scan_fp_++; } while (0)\n \n #define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = ~ *scan_fp_++; } while (0)\n \n #define AND_HARD_REG_SET(TO, FROM)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ &= *scan_fp_++; } while (0)\n \n #define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n \n #define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ |= *scan_fp_++; } while (0)\n \n #define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HOST_WIDE_INT *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n \n #define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { register HOST_WIDE_INT *scan_xp_ = (X), *scan_yp_ = (Y);\t\\\n+do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       if (0 != (*scan_xp_++ & ~*scan_yp_++)) break;\t\t\\\n+       if (0 != (*scan_xp_++ & ~ *scan_yp_++)) break;\t\t\\\n      if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n \n #define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { register HOST_WIDE_INT *scan_xp_ = (X), *scan_yp_ = (Y);\t\\\n+do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n      register int i;\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n-       if (*scan_xp_++ != ~*scan_yp_++)) break;\t\t\t\\\n+       if (*scan_xp_++ != ~ *scan_yp_++)) break;\t\t\\\n      if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n \n #endif"}]}