{"sha": "adba512db0e12d215961958b522b8b2f0ab94ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiYTUxMmRiMGUxMmQyMTU5NjE5NThiNTIyYjhiMmYwYWI5NGFiMA==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2016-01-26T00:19:20Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2016-01-26T00:19:20Z"}, "message": "new scop schedule for isl-0.15\n\nKeep unchanged the implementation for isl-0.14.\n\n\t* graphite-poly.c (apply_poly_transforms): Simplify.\n\t(print_isl_set): Use more readable format: ISL_YAML_STYLE_BLOCK.\n\t(print_isl_map): Same.\n\t(print_isl_union_map): Same.\n\t(print_isl_schedule): New.\n\t(debug_isl_schedule): New.\n\t* graphite-dependences.c (scop_get_reads): Do not call\n\tisl_union_map_add_map that is undocumented isl functionality.\n\t(scop_get_must_writes): Same.\n\t(scop_get_may_writes): Same.\n\t(scop_get_original_schedule): Remove.\n\t(scop_get_dependences): Do not call isl_union_map_compute_flow that\n\tis deprecated in isl 0.15.  Instead, use isl_union_access_* interface.\n\t(compute_deps): Remove.\n\t* graphite-isl-ast-to-gimple.c (print_schedule_ast): New.\n\t(debug_schedule_ast): New.\n\t(translate_isl_ast_to_gimple::scop_to_isl_ast): Call set_separate_option.\n\t(graphite_regenerate_ast_isl): Add dump.\n\t(translate_isl_ast_to_gimple::scop_to_isl_ast): Generate code\n\tfrom scop->transformed_schedule.\n\t(graphite_regenerate_ast_isl): Add more dump.\n\t* graphite-optimize-isl.c (optimize_isl): Set\n\tscop->transformed_schedule.  Check whether schedules are equal.\n\t(apply_poly_transforms): Move here.\n\t* graphite-poly.c (apply_poly_transforms): ... from here.\n\t(free_poly_bb): Static.\n\t(free_scop): Static.\n\t(pbb_number_of_iterations_at_time): Remove.\n\t(print_isl_ast): New.\n\t(debug_isl_ast): New.\n\t(debug_scop_pbb): New.\n\t* graphite-scop-detection.c (print_edge): Move.\n\t(print_sese): Move.\n\t* graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons): Remove.\n\t(build_scop_scattering): Remove.\n\t(create_pw_aff_from_tree): Assert instead of bailing out.\n\t(add_condition_to_pbb): Remove unused code, do not fail.\n\t(add_conditions_to_domain): Same.\n\t(add_conditions_to_constraints): Remove.\n\t(build_scop_context): New.\n\t(add_iter_domain_dimension): New.\n\t(build_iteration_domains): Initialize pbb->iterators.\n\tCall add_conditions_to_domain.\n\t(nested_in): New.\n\t(loop_at): New.\n\t(index_outermost_in_loop): New.\n\t(index_pbb_in_loop): New.\n\t(outermost_pbb_in): New.\n\t(add_in_sequence): New.\n\t(add_outer_projection): New.\n\t(outer_projection_mupa): New.\n\t(add_loop_schedule): New.\n\t(build_schedule_pbb): New.\n\t(build_schedule_loop): New.\n\t(embed_in_surrounding_loops): New.\n\t(build_schedule_loop_nest): New.\n\t(build_original_schedule): New.\n\t(build_poly_scop): Call build_original_schedule.\n\t* graphite.h: Declare print_isl_schedule and debug_isl_schedule.\n\t(free_poly_dr): Remove.\n\t(struct poly_bb): Add iterators.  Remove schedule, transformed, saved.\n\t(free_poly_bb): Remove.\n\t(debug_loop_vec): Remove.\n\t(print_isl_ast): Declare.\n\t(debug_isl_ast): Declare.\n\t(scop_do_interchange): Remove.\n\t(scop_do_strip_mine): Remove.\n\t(scop_do_block): Remove.\n\t(flatten_all_loops): Remove.\n\t(optimize_isl): Remove.\n\t(pbb_number_of_iterations_at_time): Remove.\n\t(debug_scop_pbb): Declare.\n\t(print_schedule_ast): Declare.\n\t(debug_schedule_ast): Declare.\n\t(struct scop): Remove schedule.  Add original_schedule,\n\ttransformed_schedule.\n\t(free_gimple_poly_bb): Remove.\n\t(print_generated_program): Remove.\n\t(debug_generated_program): Remove.\n\t(unify_scattering_dimensions): Remove.\n\t* sese.c (print_edge): ... here.\n\t(print_sese): ... here.\n\t(debug_edge): ... here.\n\t(debug_sese): ... here.\n\t* sese.h (print_edge): Declare.\n\t(print_sese): Declare.\n\t(dump_edge): Declare.\n\t(dump_sese): Declare.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r232812", "tree": {"sha": "6ebff12ef5a02acdce4dfc118ac2c131d99e9cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ebff12ef5a02acdce4dfc118ac2c131d99e9cd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adba512db0e12d215961958b522b8b2f0ab94ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adba512db0e12d215961958b522b8b2f0ab94ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adba512db0e12d215961958b522b8b2f0ab94ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adba512db0e12d215961958b522b8b2f0ab94ab0/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e050c90812529ced914e94ef584d3774b66a360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e050c90812529ced914e94ef584d3774b66a360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e050c90812529ced914e94ef584d3774b66a360"}], "stats": {"total": 1222, "additions": 928, "deletions": 294}, "files": [{"sha": "9f124dcb59fb84e2a7c5eadc69be6c3750c3a0bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -1,3 +1,95 @@\n+2016-01-25  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-poly.c (apply_poly_transforms): Simplify.\n+\t(print_isl_set): Use more readable format: ISL_YAML_STYLE_BLOCK.\n+\t(print_isl_map): Same.\n+\t(print_isl_union_map): Same.\n+\t(print_isl_schedule): New.\n+\t(debug_isl_schedule): New.\n+\t* graphite-dependences.c (scop_get_reads): Do not call\n+\tisl_union_map_add_map that is undocumented isl functionality.\n+\t(scop_get_must_writes): Same.\n+\t(scop_get_may_writes): Same.\n+\t(scop_get_original_schedule): Remove.\n+\t(scop_get_dependences): Do not call isl_union_map_compute_flow that\n+\tis deprecated in isl 0.15.  Instead, use isl_union_access_* interface.\n+\t(compute_deps): Remove.\n+\t* graphite-isl-ast-to-gimple.c (print_schedule_ast): New.\n+\t(debug_schedule_ast): New.\n+\t(translate_isl_ast_to_gimple::scop_to_isl_ast): Call set_separate_option.\n+\t(graphite_regenerate_ast_isl): Add dump.\n+\t(translate_isl_ast_to_gimple::scop_to_isl_ast): Generate code\n+\tfrom scop->transformed_schedule.\n+\t(graphite_regenerate_ast_isl): Add more dump.\n+\t* graphite-optimize-isl.c (optimize_isl): Set\n+\tscop->transformed_schedule.  Check whether schedules are equal.\n+\t(apply_poly_transforms): Move here.\n+\t* graphite-poly.c (apply_poly_transforms): ... from here.\n+\t(free_poly_bb): Static.\n+\t(free_scop): Static.\n+\t(pbb_number_of_iterations_at_time): Remove.\n+\t(print_isl_ast): New.\n+\t(debug_isl_ast): New.\n+\t(debug_scop_pbb): New.\n+\t* graphite-scop-detection.c (print_edge): Move.\n+\t(print_sese): Move.\n+\t* graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons): Remove.\n+\t(build_scop_scattering): Remove.\n+\t(create_pw_aff_from_tree): Assert instead of bailing out.\n+\t(add_condition_to_pbb): Remove unused code, do not fail.\n+\t(add_conditions_to_domain): Same.\n+\t(add_conditions_to_constraints): Remove.\n+\t(build_scop_context): New.\n+\t(add_iter_domain_dimension): New.\n+\t(build_iteration_domains): Initialize pbb->iterators.\n+\tCall add_conditions_to_domain.\n+\t(nested_in): New.\n+\t(loop_at): New.\n+\t(index_outermost_in_loop): New.\n+\t(index_pbb_in_loop): New.\n+\t(outermost_pbb_in): New.\n+\t(add_in_sequence): New.\n+\t(add_outer_projection): New.\n+\t(outer_projection_mupa): New.\n+\t(add_loop_schedule): New.\n+\t(build_schedule_pbb): New.\n+\t(build_schedule_loop): New.\n+\t(embed_in_surrounding_loops): New.\n+\t(build_schedule_loop_nest): New.\n+\t(build_original_schedule): New.\n+\t(build_poly_scop): Call build_original_schedule.\n+\t* graphite.h: Declare print_isl_schedule and debug_isl_schedule.\n+\t(free_poly_dr): Remove.\n+\t(struct poly_bb): Add iterators.  Remove schedule, transformed, saved.\n+\t(free_poly_bb): Remove.\n+\t(debug_loop_vec): Remove.\n+\t(print_isl_ast): Declare.\n+\t(debug_isl_ast): Declare.\n+\t(scop_do_interchange): Remove.\n+\t(scop_do_strip_mine): Remove.\n+\t(scop_do_block): Remove.\n+\t(flatten_all_loops): Remove.\n+\t(optimize_isl): Remove.\n+\t(pbb_number_of_iterations_at_time): Remove.\n+\t(debug_scop_pbb): Declare.\n+\t(print_schedule_ast): Declare.\n+\t(debug_schedule_ast): Declare.\n+\t(struct scop): Remove schedule.  Add original_schedule,\n+\ttransformed_schedule.\n+\t(free_gimple_poly_bb): Remove.\n+\t(print_generated_program): Remove.\n+\t(debug_generated_program): Remove.\n+\t(unify_scattering_dimensions): Remove.\n+\t* sese.c (print_edge): ... here.\n+\t(print_sese): ... here.\n+\t(debug_edge): ... here.\n+\t(debug_sese): ... here.\n+\t* sese.h (print_edge): Declare.\n+\t(print_sese): Declare.\n+\t(dump_edge): Declare.\n+\t(dump_sese): Declare.\n+\n 2016-01-25  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "f9d5bc309101cdfcc13e4ec180cbd67a3b2fd5d4", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 111, "deletions": 12, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -66,15 +66,15 @@ add_pdr_constraints (poly_dr_p pdr, poly_bb_p pbb)\n /* Returns all the memory reads in SCOP.  */\n \n static isl_union_map *\n-scop_get_reads (scop_p scop, vec<poly_bb_p> pbbs)\n+scop_get_reads (scop_p scop)\n {\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n   isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n-  FOR_EACH_VEC_ELT (pbbs, i, pbb)\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n     {\n       FOR_EACH_VEC_ELT (PBB_DRS (pbb), j, pdr)\n \tif (pdr_read_p (pdr))\n@@ -84,7 +84,9 @@ scop_get_reads (scop_p scop, vec<poly_bb_p> pbbs)\n \t\tfprintf (dump_file, \"Adding read to depedence graph: \");\n \t\tprint_pdr (dump_file, pdr);\n \t      }\n-\t    res = isl_union_map_add_map (res, add_pdr_constraints (pdr, pbb));\n+\t    isl_union_map *um\n+\t      = isl_union_map_from_map (add_pdr_constraints (pdr, pbb));\n+\t    res = isl_union_map_union (res, um);\n \t    if (dump_file)\n \t      {\n \t\tfprintf (dump_file, \"Reads depedence graph: \");\n@@ -99,15 +101,15 @@ scop_get_reads (scop_p scop, vec<poly_bb_p> pbbs)\n /* Returns all the memory must writes in SCOP.  */\n \n static isl_union_map *\n-scop_get_must_writes (scop_p scop, vec<poly_bb_p> pbbs)\n+scop_get_must_writes (scop_p scop)\n {\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n   isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n-  FOR_EACH_VEC_ELT (pbbs, i, pbb)\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n     {\n       FOR_EACH_VEC_ELT (PBB_DRS (pbb), j, pdr)\n \tif (pdr_write_p (pdr))\n@@ -117,7 +119,9 @@ scop_get_must_writes (scop_p scop, vec<poly_bb_p> pbbs)\n \t\tfprintf (dump_file, \"Adding must write to depedence graph: \");\n \t\tprint_pdr (dump_file, pdr);\n \t      }\n-\t    res = isl_union_map_add_map (res, add_pdr_constraints (pdr, pbb));\n+\t    isl_union_map *um\n+\t      = isl_union_map_from_map (add_pdr_constraints (pdr, pbb));\n+\t    res = isl_union_map_union (res, um);\n \t    if (dump_file)\n \t      {\n \t\tfprintf (dump_file, \"Must writes depedence graph: \");\n@@ -132,15 +136,15 @@ scop_get_must_writes (scop_p scop, vec<poly_bb_p> pbbs)\n /* Returns all the memory may writes in SCOP.  */\n \n static isl_union_map *\n-scop_get_may_writes (scop_p scop, vec<poly_bb_p> pbbs)\n+scop_get_may_writes (scop_p scop)\n {\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n   isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n-  FOR_EACH_VEC_ELT (pbbs, i, pbb)\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n     {\n       FOR_EACH_VEC_ELT (PBB_DRS (pbb), j, pdr)\n \tif (pdr_may_write_p (pdr))\n@@ -150,7 +154,9 @@ scop_get_may_writes (scop_p scop, vec<poly_bb_p> pbbs)\n \t\tfprintf (dump_file, \"Adding may write to depedence graph: \");\n \t\tprint_pdr (dump_file, pdr);\n \t      }\n-\t    res = isl_union_map_add_map (res, add_pdr_constraints (pdr, pbb));\n+\t    isl_union_map *um\n+\t      = isl_union_map_from_map (add_pdr_constraints (pdr, pbb));\n+\t    res = isl_union_map_union (res, um);\n \t    if (dump_file)\n \t      {\n \t\tfprintf (dump_file, \"May writes depedence graph: \");\n@@ -162,6 +168,7 @@ scop_get_may_writes (scop_p scop, vec<poly_bb_p> pbbs)\n   return isl_union_map_coalesce (res);\n }\n \n+#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n /* Returns all the original schedules in SCOP.  */\n \n static isl_union_map *\n@@ -181,6 +188,7 @@ scop_get_original_schedule (scop_p scop, vec<poly_bb_p> pbbs)\n \n   return isl_union_map_coalesce (res);\n }\n+#endif\n \n /* Helper function used on each MAP of a isl_union_map.  Computes the\n    maximal output dimension.  */\n@@ -303,6 +311,95 @@ carries_deps (__isl_keep isl_union_map *schedule,\n   return res;\n }\n \n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+/* Compute the dependence relations for the SCOP:\n+   RAW are read after write dependences,\n+   WAR are write after read dependences,\n+   WAW are write after write dependences.  */\n+\n+void\n+scop_get_dependences (scop_p scop)\n+{\n+  if (scop->dependence)\n+    return;\n+\n+  isl_union_map *reads = scop_get_reads (scop);\n+  isl_union_map *must_writes = scop_get_must_writes (scop);\n+  isl_union_map *may_writes = scop_get_may_writes (scop);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n--- Documentation for datarefs dump: ---\\n\");\n+      fprintf (dump_file, \"Statements on the iteration domain are mapped to\"\n+\t       \" array references.\\n\");\n+      fprintf (dump_file, \"  To read the following data references:\\n\\n\");\n+      fprintf (dump_file, \"  S_5[i0] -> [106] : i0 >= 0 and i0 <= 3\\n\");\n+      fprintf (dump_file, \"  S_8[i0] -> [1, i0] : i0 >= 0 and i0 <= 3\\n\\n\");\n+\n+      fprintf (dump_file, \"  S_5[i0] is the dynamic instance of statement\"\n+\t       \" bb_5 in a loop that accesses all iterations 0 <= i0 <= 3.\\n\");\n+      fprintf (dump_file, \"  [1, i0] is a 'memref' with alias set 1\"\n+\t       \" and first subscript access i0.\\n\");\n+      fprintf (dump_file, \"  [106] is a 'scalar reference' which is the sum of\"\n+\t       \" SSA_NAME_VERSION 6\"\n+\t       \" and --param graphite-max-arrays-per-scop=100\\n\");\n+      fprintf (dump_file, \"-----------------------\\n\\n\");\n+\n+      fprintf (dump_file, \"data references (\\n\");\n+      fprintf (dump_file, \"  reads: \");\n+      print_isl_union_map (dump_file, reads);\n+      fprintf (dump_file, \"  must_writes: \");\n+      print_isl_union_map (dump_file, must_writes);\n+      fprintf (dump_file, \"  may_writes: \");\n+      print_isl_union_map (dump_file, may_writes);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n+  gcc_assert (scop->original_schedule);\n+\n+  isl_union_access_info *ai;\n+  ai = isl_union_access_info_from_sink (isl_union_map_copy (reads));\n+  ai = isl_union_access_info_set_must_source (ai, isl_union_map_copy (must_writes));\n+  ai = isl_union_access_info_set_may_source (ai, may_writes);\n+  ai = isl_union_access_info_set_schedule\n+    (ai, isl_schedule_copy (scop->original_schedule));\n+  isl_union_flow *flow = isl_union_access_info_compute_flow (ai);\n+  isl_union_map *raw = isl_union_flow_get_must_dependence (flow);\n+  isl_union_flow_free (flow);\n+\n+  ai = isl_union_access_info_from_sink (isl_union_map_copy (must_writes));\n+  ai = isl_union_access_info_set_must_source (ai, must_writes);\n+  ai = isl_union_access_info_set_may_source (ai, reads);\n+  ai = isl_union_access_info_set_schedule\n+    (ai, isl_schedule_copy (scop->original_schedule));\n+  flow = isl_union_access_info_compute_flow (ai);\n+\n+  isl_union_map *waw = isl_union_flow_get_must_dependence (flow);\n+  isl_union_map *war = isl_union_flow_get_may_dependence (flow);\n+  war = isl_union_map_subtract (war, isl_union_map_copy (waw));\n+  isl_union_flow_free (flow);\n+\n+  raw = isl_union_map_coalesce (raw);\n+  waw = isl_union_map_coalesce (waw);\n+  war = isl_union_map_coalesce (war);\n+\n+  isl_union_map *dependences = raw;\n+  dependences = isl_union_map_union (dependences, war);\n+  dependences = isl_union_map_union (dependences, waw);\n+  dependences = isl_union_map_coalesce (dependences);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"data dependences (\\n\");\n+      print_isl_union_map (dump_file, dependences);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n+  scop->dependence = dependences;\n+}\n+\n+#else\n+\n /* Compute the original data dependences in SCOP for all the reads and\n    writes in PBBS.  */\n \n@@ -321,9 +418,9 @@ compute_deps (scop_p scop, vec<poly_bb_p> pbbs,\n \t      isl_union_map **must_waw_no_source,\n \t      isl_union_map **may_waw_no_source)\n {\n-  isl_union_map *reads = scop_get_reads (scop, pbbs);\n-  isl_union_map *must_writes = scop_get_must_writes (scop, pbbs);\n-  isl_union_map *may_writes = scop_get_may_writes (scop, pbbs);\n+  isl_union_map *reads = scop_get_reads (scop);\n+  isl_union_map *must_writes = scop_get_must_writes (scop);\n+  isl_union_map *may_writes = scop_get_may_writes (scop);\n   isl_union_map *all_writes = isl_union_map_union\n     (isl_union_map_copy (must_writes), isl_union_map_copy (may_writes));\n   all_writes = isl_union_map_coalesce (all_writes);\n@@ -428,4 +525,6 @@ scop_get_dependences (scop_p scop)\n   return dependences;\n }\n \n+#endif /* HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS */\n+\n #endif /* HAVE_isl */"}, {"sha": "0f585032b1ccd20a71ebce1aa22f27fbde040066", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 117, "deletions": 86, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -105,7 +105,7 @@ typedef std::map<isl_id *, tree> ivs_params;\n \n /* Free all memory allocated for isl's identifiers.  */\n \n-void ivs_params_clear (ivs_params &ip)\n+static void ivs_params_clear (ivs_params &ip)\n {\n   std::map<isl_id *, tree>::iterator it;\n   for (it = ip.begin ();\n@@ -119,7 +119,7 @@ void ivs_params_clear (ivs_params &ip)\n \n /* Set the \"separate\" option for the schedule node.  */\n \n-static __isl_give isl_schedule_node *\n+static isl_schedule_node *\n set_separate_option (__isl_take isl_schedule_node *node, void *user)\n {\n   if (user)\n@@ -136,6 +136,27 @@ set_separate_option (__isl_take isl_schedule_node *node, void *user)\n \n   return node;\n }\n+\n+/* Print SCHEDULE under an AST form on file F.  */\n+\n+void\n+print_schedule_ast (FILE *f, __isl_keep isl_schedule *schedule, scop_p scop)\n+{\n+  isl_set *set = isl_set_params (isl_set_copy (scop->param_context));\n+  isl_ast_build *context = isl_ast_build_from_context (set);\n+  isl_ast_node *ast\n+    = isl_ast_build_node_from_schedule (context, isl_schedule_copy (schedule));\n+  isl_ast_build_free (context);\n+  print_isl_ast (f, ast);\n+  isl_ast_node_free (ast);\n+}\n+\n+DEBUG_FUNCTION void\n+debug_schedule_ast (__isl_keep isl_schedule *s, scop_p scop)\n+{\n+  print_schedule_ast (stderr, s, scop);\n+}\n+\n #endif\n \n enum phi_node_kind\n@@ -288,48 +309,50 @@ class translate_isl_ast_to_gimple\n \n   void add_parameters_to_ivs_params (scop_p scop, ivs_params &ip);\n \n-  /* Get the maximal number of schedule dimensions in the scop SCOP.  */\n-\n-  int get_max_schedule_dimensions (scop_p scop);\n-\n   /* Generates a build, which specifies the constraints on the parameters.  */\n \n   __isl_give isl_ast_build *generate_isl_context (scop_p scop);\n \n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  /* Generate isl AST from schedule of SCOP.  */\n+  __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop);\n+#else\n+  /* Get the maximal number of schedule dimensions in the scop SCOP.  */\n+  int get_max_schedule_dimensions (scop_p scop);\n+\n   /* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.\n \n      For schedules with different dimensionality, the isl AST generator can not\n      define an order and will just randomly choose an order.  The solution to\n      this problem is to extend all schedules to the maximal number of schedule\n      dimensions (using '0's for the remaining values).  */\n-\n   __isl_give isl_map *extend_schedule (__isl_take isl_map *schedule,\n \t\t\t\t       int nb_schedule_dims);\n \n   /* Generates a schedule, which specifies an order used to\n      visit elements in a domain.  */\n-\n   __isl_give isl_union_map *generate_isl_schedule (scop_p scop);\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-  /* Set the \"separate\" option for all schedules.  This helps reducing control\n-     overhead.  */\n-\n-  __isl_give isl_schedule *\n-    set_options_for_schedule_tree (__isl_take isl_schedule *schedule);\n-#endif\n-\n   /* Set the separate option for all dimensions.\n      This helps to reduce control overhead.  */\n-\n-  __isl_give isl_ast_build * set_options (__isl_take isl_ast_build *control,\n-\t\t\t\t\t  __isl_keep isl_union_map *schedule);\n+  __isl_give isl_ast_build *set_options (__isl_take isl_ast_build *control,\n+\t\t\t\t\t __isl_keep isl_union_map *schedule);\n \n   /* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in\n      IP.  */\n+  __isl_give isl_ast_node *scop_to_isl_ast (scop_p scop, ivs_params &ip);\n \n-  __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop, ivs_params &ip);\n-\n+  /* Prints NODE to FILE.  */\n+  void print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node,\n+\t\t\t   __isl_keep isl_ctx *ctx) const\n+  {\n+    isl_printer *prn = isl_printer_to_file (ctx, file);\n+    prn = isl_printer_set_output_format (prn, ISL_FORMAT_C);\n+    prn = isl_printer_print_ast_node (prn, node);\n+    prn = isl_printer_print_str (prn, \"\\n\");\n+    isl_printer_free (prn);\n+  }\n+#endif\n \n   /* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n      definition should flow into use, and the use should respect the loop-closed\n@@ -485,11 +508,6 @@ class translate_isl_ast_to_gimple\n   bool codegen_error_p () const\n   { return codegen_error; }\n \n-  /* Prints NODE to FILE.  */\n-\n-  void print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node,\n-\t\t\t   __isl_keep isl_ctx *ctx) const;\n-\n   /* Return true when OP is a constant tree.  */\n \n   bool is_constant (tree op) const\n@@ -1389,7 +1407,7 @@ is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n     {\n       if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"[codegen] rename not in loop closed ssa:\");\n+\t  fprintf (dump_file, \"[codegen] rename not in loop closed ssa: \");\n \t  print_generic_expr (dump_file, rename, 0);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n@@ -3110,20 +3128,6 @@ translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n     }\n }\n \n-/* Prints NODE to FILE.  */\n-\n-void\n-translate_isl_ast_to_gimple::print_isl_ast_node (FILE *file,\n-\t\t\t\t\t\t __isl_keep isl_ast_node *node,\n-\t\t\t\t\t\t __isl_keep isl_ctx *ctx) const\n-{\n-  isl_printer *prn = isl_printer_to_file (ctx, file);\n-  prn = isl_printer_set_output_format (prn, ISL_FORMAT_C);\n-  prn = isl_printer_print_ast_node (prn, node);\n-  prn = isl_printer_print_str (prn, \"\\n\");\n-  isl_printer_free (prn);\n-}\n-\n /* Add isl's parameter identifiers and corresponding trees to ivs_params.  */\n \n void\n@@ -3152,6 +3156,52 @@ translate_isl_ast_to_gimple::generate_isl_context (scop_p scop)\n   return isl_ast_build_from_context (context_isl);\n }\n \n+/* This method is executed before the construction of a for node.  */\n+__isl_give isl_id *\n+ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n+{\n+  isl_union_map *dependences = (isl_union_map *) user;\n+  ast_build_info *for_info = XNEW (struct ast_build_info);\n+  isl_union_map *schedule = isl_ast_build_get_schedule (build);\n+  isl_space *schedule_space = isl_ast_build_get_schedule_space (build);\n+  int dimension = isl_space_dim (schedule_space, isl_dim_out);\n+  for_info->is_parallelizable =\n+    !carries_deps (schedule, dependences, dimension);\n+  isl_union_map_free (schedule);\n+  isl_space_free (schedule_space);\n+  isl_id *id = isl_id_alloc (isl_ast_build_get_ctx (build), \"\", for_info);\n+  return id;\n+}\n+\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+\n+/* Generate isl AST from schedule of SCOP.  */\n+\n+__isl_give isl_ast_node *\n+translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop)\n+{\n+  gcc_assert (scop->transformed_schedule);\n+\n+  /* Set the separate option to reduce control flow overhead.  */\n+  isl_schedule *schedule = isl_schedule_map_schedule_node_bottom_up\n+    (isl_schedule_copy (scop->transformed_schedule), set_separate_option, NULL);\n+  isl_ast_build *context_isl = generate_isl_context (scop);\n+\n+  if (flag_loop_parallelize_all)\n+    {\n+      scop_get_dependences (scop);\n+      context_isl =\n+\tisl_ast_build_set_before_each_for (context_isl, ast_build_before_for,\n+\t\t\t\t\t   scop->dependence);\n+    }\n+\n+  isl_ast_node *ast_isl = isl_ast_build_node_from_schedule\n+    (context_isl, schedule);\n+  isl_ast_build_free (context_isl);\n+  return ast_isl;\n+}\n+\n+#else\n /* Get the maximal number of schedule dimensions in the scop SCOP.  */\n \n int\n@@ -3229,36 +3279,6 @@ translate_isl_ast_to_gimple::generate_isl_schedule (scop_p scop)\n   return schedule_isl;\n }\n \n-/* This method is executed before the construction of a for node.  */\n-__isl_give isl_id *\n-ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n-{\n-  isl_union_map *dependences = (isl_union_map *) user;\n-  ast_build_info *for_info = XNEW (struct ast_build_info);\n-  isl_union_map *schedule = isl_ast_build_get_schedule (build);\n-  isl_space *schedule_space = isl_ast_build_get_schedule_space (build);\n-  int dimension = isl_space_dim (schedule_space, isl_dim_out);\n-  for_info->is_parallelizable =\n-    !carries_deps (schedule, dependences, dimension);\n-  isl_union_map_free (schedule);\n-  isl_space_free (schedule_space);\n-  isl_id *id = isl_id_alloc (isl_ast_build_get_ctx (build), \"\", for_info);\n-  return id;\n-}\n-\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-/* Set the separate option for all schedules.  This helps reducing control\n-   overhead.  */\n-\n-__isl_give isl_schedule *\n-translate_isl_ast_to_gimple::set_options_for_schedule_tree\n-(__isl_take isl_schedule *schedule)\n-{\n-  return isl_schedule_map_schedule_node_bottom_up\n-    (schedule, set_separate_option, NULL);\n-}\n-#endif\n-\n /* Set the separate option for all dimensions.\n    This helps to reduce control overhead.  */\n \n@@ -3283,7 +3303,6 @@ translate_isl_ast_to_gimple::set_options (__isl_take isl_ast_build *control,\n __isl_give isl_ast_node *\n translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop, ivs_params &ip)\n {\n-  isl_ast_node *ast_isl = NULL;\n   /* Generate loop upper bounds that consist of the current loop iterator, an\n      operator (< or <=) and an expression not involving the iterator.  If this\n      option is not set, then the current loop iterator may appear several times\n@@ -3302,23 +3321,18 @@ translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop, ivs_params &ip)\n \t\t\t\t\t   dependence);\n     }\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  isl_ast_node *ast_isl = isl_ast_build_ast_from_schedule (context_isl,\n+\t\t\t\t\t\t\t   schedule_isl);\n   if (scop->schedule)\n     {\n-      scop->schedule = set_options_for_schedule_tree (scop->schedule);\n-      ast_isl = isl_ast_build_node_from_schedule (context_isl, scop->schedule);\n-      isl_union_map_free(schedule_isl);\n+      isl_schedule_free (scop->schedule);\n+      scop->schedule = NULL;\n     }\n-  else\n-    ast_isl = isl_ast_build_ast_from_schedule (context_isl, schedule_isl);\n-#else\n-  ast_isl = isl_ast_build_ast_from_schedule (context_isl, schedule_isl);\n-  isl_schedule_free (scop->schedule);\n-#endif\n \n   isl_ast_build_free (context_isl);\n   return ast_isl;\n }\n+#endif\n \n /* Copy def from sese REGION to the newly created TO_REGION. TR is defined by\n    DEF_STMT. GSI points to entry basic block of the TO_REGION.  */\n@@ -3401,12 +3415,26 @@ graphite_regenerate_ast_isl (scop_p scop)\n   ivs_params ip;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  t.add_parameters_to_ivs_params (scop, ip);\n+  root_node = t.scop_to_isl_ast (scop);\n+#else\n   root_node = t.scop_to_isl_ast (scop, ip);\n+#endif\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"AST generated by isl: \\n\");\n-      t.print_isl_ast_node (dump_file, root_node, scop->isl_context);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+      fprintf (dump_file, \"[scheduler] original schedule:\\n\");\n+      print_isl_schedule (dump_file, scop->original_schedule);\n+      fprintf (dump_file, \"[scheduler] isl transformed schedule:\\n\");\n+      print_isl_schedule (dump_file, scop->transformed_schedule);\n+\n+      fprintf (dump_file, \"[scheduler] original ast:\\n\");\n+      print_schedule_ast (dump_file, scop->original_schedule, scop);\n+#endif\n+      fprintf (dump_file, \"[scheduler] AST generated by isl:\\n\");\n+      print_isl_ast (dump_file, root_node);\n     }\n \n   recompute_all_dominators ();\n@@ -3431,8 +3459,8 @@ graphite_regenerate_ast_isl (scop_p scop)\n   if (t.codegen_error_p ())\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"[codegen] unsuccessful,\"\n-\t\t \" reverting back to the original code.\\n\");\n+\tfprintf (dump_file, \"codegen error: \"\n+\t\t \"reverting back to the original code.\\n\");\n       set_ifsese_condition (if_region, integer_zero_node);\n     }\n   else\n@@ -3452,6 +3480,9 @@ graphite_regenerate_ast_isl (scop_p scop)\n \t  scev_reset ();\n \t  recompute_all_dominators ();\n \t  graphite_verify ();\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"[codegen] isl AST to Gimple succeeded.\\n\");\n \t}\n       else\n \t{"}, {"sha": "d1620d5f1d8096fc93de5d6958be5367c5ec5e4f", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 137, "deletions": 40, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -92,24 +92,120 @@ get_schedule_for_node_st (__isl_take isl_schedule_node *node, void *user)\n   return node;\n }\n \n-/* get_schedule_map_st - Improve the schedule by performing other loop\n-   optimizations. _st ending is for schedule tree version of this\n-   function (see get_schedule_map below for the band forest version).\n+static isl_union_set *\n+scop_get_domains (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  isl_space *space = isl_set_get_space (scop->param_context);\n+  isl_union_set *res = isl_union_set_empty (space);\n \n-   Do a depth-first post-order traversal of the nodes in a schedule\n-   tree and apply get_schedule_for_node_st on them to improve the schedule.\n-  */\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    res = isl_union_set_add_set (res, isl_set_copy (pbb->domain));\n+\n+  return res;\n+}\n+\n+/* Compute the schedule for SCOP based on its parameters, domain and set of\n+   constraints.  Then apply the schedule to SCOP.  */\n \n-static __isl_give isl_union_map *\n-get_schedule_map_st (__isl_keep isl_schedule *schedule)\n+static bool\n+optimize_isl (scop_p scop)\n {\n+  int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);\n+  int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);\n+  if (max_operations)\n+    isl_ctx_set_max_operations (scop->isl_context, max_operations);\n+  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_CONTINUE);\n \n-  schedule = isl_schedule_map_schedule_node_bottom_up (schedule,\n-\t\t\t\t\t\t       get_schedule_for_node_st,\n-\t\t\t\t\t\t       NULL);\n-  isl_union_map *schedule_map = isl_schedule_get_map (schedule);\n-  return schedule_map;\n+  isl_union_set *domain = scop_get_domains (scop);\n+\n+  /* Simplify the dependences on the domain.  */\n+  scop_get_dependences (scop);\n+  isl_union_map *dependences\n+    = isl_union_map_gist_domain (isl_union_map_copy (scop->dependence),\n+\t\t\t\t isl_union_set_copy (domain));\n+  isl_union_map *validity\n+    = isl_union_map_gist_range (dependences, isl_union_set_copy (domain));\n+\n+  /* FIXME: proximity should not be validity.  */\n+  isl_union_map *proximity = isl_union_map_copy (validity);\n+\n+  isl_schedule_constraints *sc = isl_schedule_constraints_on_domain (domain);\n+  sc = isl_schedule_constraints_set_proximity (sc, proximity);\n+  sc = isl_schedule_constraints_set_validity (sc, isl_union_map_copy (validity));\n+  sc = isl_schedule_constraints_set_coincidence (sc, validity);\n+\n+  isl_options_set_schedule_serialize_sccs (scop->isl_context, 0);\n+  isl_options_set_schedule_maximize_band_depth (scop->isl_context, 1);\n+  isl_options_set_schedule_max_constant_term (scop->isl_context, 20);\n+  isl_options_set_schedule_max_coefficient (scop->isl_context, 20);\n+  isl_options_set_tile_scale_tile_loops (scop->isl_context, 0);\n+  /* Generate loop upper bounds that consist of the current loop iterator, an\n+     operator (< or <=) and an expression not involving the iterator.  If this\n+     option is not set, then the current loop iterator may appear several times\n+     in the upper bound.  See the isl manual for more details.  */\n+  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, 1);\n+\n+  scop->transformed_schedule = isl_schedule_constraints_compute_schedule (sc);\n+  scop->transformed_schedule =\n+    isl_schedule_map_schedule_node_bottom_up (scop->transformed_schedule,\n+\t\t\t\t\t      get_schedule_for_node_st, NULL);\n+  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_ABORT);\n+\n+  isl_ctx_reset_operations (scop->isl_context);\n+  isl_ctx_set_max_operations (scop->isl_context, old_max_operations);\n+  if (!scop->transformed_schedule\n+      || isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n+    {\n+      if (dump_file && dump_flags)\n+\tfprintf (dump_file, \"isl timed out --param max-isl-operations=%d\\n\",\n+\t\t max_operations);\n+      return false;\n+    }\n+\n+  gcc_assert (scop->original_schedule);\n+  isl_union_map *original = isl_schedule_get_map (scop->original_schedule);\n+  isl_union_map *transformed = isl_schedule_get_map (scop->transformed_schedule);\n+  bool same_schedule = isl_union_map_is_equal (original, transformed);\n+  isl_union_map_free (original);\n+  isl_union_map_free (transformed);\n+\n+  if (same_schedule)\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"[scheduler] isl optimized schedule is \"\n+\t\t   \"identical to the original schedule.\\n\");\n+\t  print_schedule_ast (dump_file, scop->original_schedule, scop);\n+\t}\n+      isl_schedule_free (scop->transformed_schedule);\n+      scop->transformed_schedule = isl_schedule_copy (scop->original_schedule);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Apply graphite transformations to all the basic blocks of SCOP.  */\n+\n+bool\n+apply_poly_transforms (scop_p scop)\n+{\n+  if (flag_loop_nest_optimize)\n+    return optimize_isl (scop);\n+\n+  if (!flag_graphite_identity && !flag_loop_parallelize_all)\n+    return false;\n+\n+  /* Generate code even if we did not apply any real transformation.\n+     This also allows to check the performance for the identity\n+     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */\n+  gcc_assert (scop->original_schedule);\n+  scop->transformed_schedule = isl_schedule_copy (scop->original_schedule);\n+  return true;\n }\n+\n #else\n \n /* get_tile_map - Create a map that describes a n-dimensonal tiling.\n@@ -304,7 +400,6 @@ get_schedule_map (isl_schedule *schedule)\n   isl_band_list_free (band_list);\n   return schedule_map;\n }\n-#endif\n \n static isl_stat\n get_single_map (__isl_take isl_map *map, void *user)\n@@ -350,12 +445,10 @@ scop_get_domains (scop_p scop)\n   return res;\n }\n \n-static const int CONSTANT_BOUND = 20;\n-\n /* Compute the schedule for SCOP based on its parameters, domain and set of\n    constraints.  Then apply the schedule to SCOP.  */\n \n-bool\n+static bool\n optimize_isl (scop_p scop)\n {\n   int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);\n@@ -373,24 +466,10 @@ optimize_isl (scop_p scop)\n   isl_union_map *validity = isl_union_map_copy (scop->dependence);\n   isl_union_map *proximity = isl_union_map_copy (validity);\n \n-  isl_options_set_schedule_max_constant_term (scop->isl_context, CONSTANT_BOUND);\n-  isl_options_set_schedule_maximize_band_depth (scop->isl_context, 1);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-  /* isl 0.15 or later.  */\n-  isl_options_set_schedule_serialize_sccs (scop->isl_context, 0);\n-  isl_options_set_schedule_maximize_band_depth (scop->isl_context, 1);\n-  isl_options_set_schedule_max_constant_term (scop->isl_context, 20);\n-  isl_options_set_schedule_max_coefficient (scop->isl_context, 20);\n-  isl_options_set_tile_scale_tile_loops (scop->isl_context, 0);\n-  isl_options_set_coalesce_bounded_wrapping (scop->isl_context, 1);\n-  isl_options_set_ast_build_exploit_nested_bounds (scop->isl_context, 1);\n-  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, 1);\n-#else\n   isl_options_set_schedule_fuse (scop->isl_context, ISL_SCHEDULE_FUSE_MIN);\n-#endif\n-\n   isl_schedule *schedule\n     = isl_union_set_compute_schedule (domain, validity, proximity);\n+\n   isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_ABORT);\n \n   isl_ctx_reset_operations (scop->isl_context);\n@@ -405,20 +484,38 @@ optimize_isl (scop_p scop)\n       return false;\n     }\n \n-  /* Attach the schedule to scop so that it can be used in code generation.\n-     schedule freeing will occur in code generation.  */\n   scop->schedule = schedule;\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-  /* isl 0.15 or later.  */\n-  isl_union_map *schedule_map = get_schedule_map_st (schedule);\n-#else\n   isl_union_map *schedule_map = get_schedule_map (schedule);\n-#endif\n   apply_schedule_map_to_scop (scop, schedule_map);\n-\n   isl_union_map_free (schedule_map);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"isl end schedule:\\n\");\n+      print_isl_schedule (dump_file, scop->schedule);\n+    }\n+\n   return true;\n }\n \n+/* Apply graphite transformations to all the basic blocks of SCOP.  */\n+\n+bool\n+apply_poly_transforms (scop_p scop)\n+{\n+  if (flag_loop_nest_optimize)\n+    return optimize_isl (scop);\n+\n+  if (!flag_graphite_identity && !flag_loop_parallelize_all)\n+    return false;\n+\n+  /* Generate code even if we did not apply any real transformation.\n+     This also allows to check the performance for the identity\n+     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */\n+  return true;\n+}\n+\n+#endif /* HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS */\n+\n #endif /* HAVE_isl */"}, {"sha": "4c3f55027a7491ea8ec0f7782ba2e6bbbeeff800", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 85, "deletions": 69, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -86,28 +86,6 @@ debug_iteration_domains (scop_p scop)\n   print_iteration_domains (stderr, scop);\n }\n \n-/* Apply graphite transformations to all the basic blocks of SCOP.  */\n-\n-bool\n-apply_poly_transforms (scop_p scop)\n-{\n-  bool transform_done = false;\n-\n-  /* Generate code even if we did not apply any real transformation.\n-     This also allows to check the performance for the identity\n-     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */\n-  if (flag_graphite_identity)\n-    transform_done = true;\n-\n-  if (flag_loop_parallelize_all)\n-    transform_done = true;\n-\n-  if (flag_loop_nest_optimize)\n-    transform_done |= optimize_isl (scop);\n-\n-  return transform_done;\n-}\n-\n /* Create a new polyhedral data reference and add it to PBB.  It is\n    defined by its ACCESSES, its TYPE, and the number of subscripts\n    NB_SUBSCRIPTS.  */\n@@ -142,7 +120,7 @@ new_poly_dr (poly_bb_p pbb, gimple *stmt, enum poly_dr_type type,\n \n /* Free polyhedral data reference PDR.  */\n \n-void\n+static void\n free_poly_dr (poly_dr_p pdr)\n {\n   isl_map_free (pdr->accesses);\n@@ -158,9 +136,13 @@ new_poly_bb (scop_p scop, gimple_poly_bb_p black_box)\n   poly_bb_p pbb = XNEW (struct poly_bb);\n \n   pbb->domain = NULL;\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  pbb->iterators = NULL;\n+#else\n   pbb->schedule = NULL;\n   pbb->transformed = NULL;\n   pbb->saved = NULL;\n+#endif\n   PBB_SCOP (pbb) = scop;\n   pbb_set_black_box (pbb, black_box);\n   PBB_DRS (pbb).create (3);\n@@ -171,16 +153,25 @@ new_poly_bb (scop_p scop, gimple_poly_bb_p black_box)\n \n /* Free polyhedral black box.  */\n \n-void\n+static void\n free_poly_bb (poly_bb_p pbb)\n {\n   int i;\n   poly_dr_p pdr;\n \n   isl_set_free (pbb->domain);\n+  pbb->domain = NULL;\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  isl_set_free (pbb->iterators);\n+  pbb->iterators = NULL;\n+#else\n   isl_map_free (pbb->schedule);\n+  pbb->schedule = NULL;\n   isl_map_free (pbb->transformed);\n+  pbb->transformed = NULL;\n   isl_map_free (pbb->saved);\n+  pbb->saved = NULL;\n+#endif\n \n   if (PBB_DRS (pbb).exists ())\n     FOR_EACH_VEC_ELT (PBB_DRS (pbb), i, pdr)\n@@ -251,7 +242,7 @@ new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs,\n \n /* Frees GBB.  */\n \n-void\n+static void\n free_gimple_poly_bb (gimple_poly_bb_p gbb)\n {\n   free_data_refs (GBB_DATA_REFS (gbb));\n@@ -282,7 +273,12 @@ new_scop (edge entry, edge exit)\n   sese_info_p region = new_sese_info (entry, exit);\n   scop_p s = XNEW (struct scop);\n \n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  s->original_schedule = NULL;\n+  s->transformed_schedule = NULL;\n+#else\n   s->schedule = NULL;\n+#endif\n   s->param_context = NULL;\n   scop_set_region (s, region);\n   s->pbbs.create (3);\n@@ -309,8 +305,17 @@ free_scop (scop_p scop)\n   scop->drs.release ();\n \n   isl_set_free (scop->param_context);\n+  scop->param_context = NULL;\n   isl_union_map_free (scop->dependence);\n   scop->dependence = NULL;\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  isl_schedule_free (scop->original_schedule);\n+  scop->original_schedule = NULL;\n+  isl_schedule_free (scop->transformed_schedule);\n+  scop->transformed_schedule = NULL;\n+#else\n+\n+#endif\n   XDELETE (scop);\n }\n \n@@ -535,53 +540,61 @@ debug_scop_params (scop_p scop)\n \n extern isl_ctx *the_isl_ctx;\n void\n-print_isl_set (FILE *f, isl_set *set)\n+print_isl_set (FILE *f, __isl_keep isl_set *set)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n+#endif\n   p = isl_printer_print_set (p, set);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n DEBUG_FUNCTION void\n-debug_isl_set (isl_set *set)\n+debug_isl_set (__isl_keep isl_set *set)\n {\n   print_isl_set (stderr, set);\n }\n \n void\n-print_isl_map (FILE *f, isl_map *map)\n+print_isl_map (FILE *f, __isl_keep isl_map *map)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n+#endif\n   p = isl_printer_print_map (p, map);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n DEBUG_FUNCTION void\n-debug_isl_map (isl_map *map)\n+debug_isl_map (__isl_keep isl_map *map)\n {\n   print_isl_map (stderr, map);\n }\n \n void\n-print_isl_union_map (FILE *f, isl_union_map *map)\n+print_isl_union_map (FILE *f, __isl_keep isl_union_map *map)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n+#endif\n   p = isl_printer_print_union_map (p, map);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n }\n \n DEBUG_FUNCTION void\n-debug_isl_union_map (isl_union_map *map)\n+debug_isl_union_map (__isl_keep isl_union_map *map)\n {\n   print_isl_union_map (stderr, map);\n }\n \n-\n void\n-print_isl_aff (FILE *f, isl_aff *aff)\n+print_isl_aff (FILE *f, __isl_keep isl_aff *aff)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n   p = isl_printer_print_aff (p, aff);\n@@ -590,13 +603,13 @@ print_isl_aff (FILE *f, isl_aff *aff)\n }\n \n DEBUG_FUNCTION void\n-debug_isl_aff (isl_aff *aff)\n+debug_isl_aff (__isl_keep isl_aff *aff)\n {\n   print_isl_aff (stderr, aff);\n }\n \n void\n-print_isl_constraint (FILE *f, isl_constraint *c)\n+print_isl_constraint (FILE *f, __isl_keep isl_constraint *c)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n   p = isl_printer_print_constraint (p, c);\n@@ -605,46 +618,49 @@ print_isl_constraint (FILE *f, isl_constraint *c)\n }\n \n DEBUG_FUNCTION void\n-debug_isl_constraint (isl_constraint *c)\n+debug_isl_constraint (__isl_keep isl_constraint *c)\n {\n   print_isl_constraint (stderr, c);\n }\n \n-/* Returns the number of iterations RES of the loop around PBB at\n-   time(scattering) dimension TIME_DEPTH.  */\n+void\n+print_isl_schedule (FILE *f, __isl_keep isl_schedule *s)\n+{\n+  isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n+#endif\n+  p = isl_printer_print_schedule (p, s);\n+  p = isl_printer_print_str (p, \"\\n\");\n+  isl_printer_free (p);\n+}\n+\n+DEBUG_FUNCTION void\n+debug_isl_schedule (__isl_keep isl_schedule *s)\n+{\n+  print_isl_schedule (stderr, s);\n+}\n \n void\n-pbb_number_of_iterations_at_time (poly_bb_p pbb,\n-\t\t\t\t  graphite_dim_t time_depth,\n-\t\t\t\t  mpz_t res)\n-{\n-  isl_set *transdomain;\n-  isl_space *dc;\n-  isl_aff *aff;\n-  isl_val *isllb, *islub;\n-\n-  /* Map the iteration domain through the current scatter, and work\n-     on the resulting set.  */\n-  transdomain = isl_set_apply (isl_set_copy (pbb->domain),\n-\t\t\t       isl_map_copy (pbb->transformed));\n-\n-  /* Select the time_depth' dimension via an affine expression.  */\n-  dc = isl_set_get_space (transdomain);\n-  aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n-  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, time_depth, 1);\n-\n-  /* And find the min/max for that function.  */\n-  /* XXX isl check results?  */\n-  isllb = isl_set_min_val (transdomain, aff);\n-  islub = isl_set_max_val (transdomain, aff);\n-\n-  islub = isl_val_sub (islub, isllb);\n-  islub = isl_val_add_ui (islub, 1);\n-  isl_val_get_num_gmp (islub, res);\n-\n-  isl_val_free (islub);\n-  isl_aff_free (aff);\n-  isl_set_free (transdomain);\n+print_isl_ast (FILE *file, __isl_keep isl_ast_node *n)\n+{\n+  isl_printer *prn = isl_printer_to_file (the_isl_ctx, file);\n+  prn = isl_printer_set_output_format (prn, ISL_FORMAT_C);\n+  prn = isl_printer_print_ast_node (prn, n);\n+  prn = isl_printer_print_str (prn, \"\\n\");\n+  isl_printer_free (prn);\n+}\n+\n+DEBUG_FUNCTION void\n+debug_isl_ast (isl_ast_node *n)\n+{\n+  print_isl_ast (stderr, n);\n+}\n+\n+DEBUG_FUNCTION void\n+debug_scop_pbb (scop_p scop, int i)\n+{\n+  debug_pbb (scop->pbbs[i]);\n }\n \n #endif  /* HAVE_isl */"}, {"sha": "03b1c49d728eb28d2050ad03bd8fcfe8060c58d9", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -533,21 +533,6 @@ class scop_detection\n \n   static edge get_nearest_pdom_with_single_exit (basic_block dom);\n \n-\n-  /* Pretty printers.  */\n-\n-  static void print_edge (FILE *file, const_edge e)\n-  {\n-    fprintf (file, \"edge (bb_%d, bb_%d)\", e->src->index, e->dest->index);\n-  }\n-\n-  static void print_sese (FILE *file, sese_l s)\n-  {\n-    fprintf (file, \"(entry_\"); print_edge (file, s.entry);\n-    fprintf (file, \", exit_\"); print_edge (file, s.exit);\n-    fprintf (file, \")\\n\");\n-  }\n-\n   /* Merge scops at same loop depth and returns the new sese.\n      Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n "}, {"sha": "b62789f84c63c570cd392048d72b5f63a95350f8", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 316, "deletions": 49, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -77,6 +77,7 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n   return isl_id_alloc (s->isl_context, name, pbb);\n }\n \n+#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n /* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.\n    We generate SCATTERING_DIMENSIONS scattering dimensions.\n \n@@ -221,6 +222,7 @@ build_scop_scattering (scop_p scop)\n \n   isl_aff_free (static_sched);\n }\n+#endif\n \n static isl_pw_aff *extract_affine (scop_p, tree, __isl_take isl_space *space);\n \n@@ -440,10 +442,7 @@ create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n \n   t = scalar_evolution_in_region (scop->scop_info->region, pbb_loop (pbb), t);\n \n-  /* Bail out as we do not know the scev.  */\n-  if (chrec_contains_undetermined (t))\n-    return NULL;\n-\n+  gcc_assert (!chrec_contains_undetermined (t));\n   gcc_assert (!automatically_generated_chrec_p (t));\n \n   return extract_affine (scop, t, isl_set_get_space (pbb->domain));\n@@ -453,19 +452,11 @@ create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n    operator.  This allows us to invert the condition or to handle\n    inequalities.  */\n \n-static bool\n+static void\n add_condition_to_pbb (poly_bb_p pbb, gcond *stmt, enum tree_code code)\n {\n   isl_pw_aff *lhs = create_pw_aff_from_tree (pbb, gimple_cond_lhs (stmt));\n-  if (!lhs)\n-    return false;\n-\n   isl_pw_aff *rhs = create_pw_aff_from_tree (pbb, gimple_cond_rhs (stmt));\n-  if (!rhs)\n-    {\n-      isl_pw_aff_free (lhs);\n-      return false;\n-    }\n \n   isl_set *cond;\n   switch (code)\n@@ -495,28 +486,25 @@ add_condition_to_pbb (poly_bb_p pbb, gcond *stmt, enum tree_code code)\n \tbreak;\n \n       default:\n-\tisl_pw_aff_free (lhs);\n-\tisl_pw_aff_free (rhs);\n-\treturn true;\n+\tgcc_unreachable ();\n     }\n \n   cond = isl_set_coalesce (cond);\n   cond = isl_set_set_tuple_id (cond, isl_set_get_tuple_id (pbb->domain));\n   pbb->domain = isl_set_coalesce (isl_set_intersect (pbb->domain, cond));\n-  return true;\n }\n \n /* Add conditions to the domain of PBB.  */\n \n-static bool\n+static void\n add_conditions_to_domain (poly_bb_p pbb)\n {\n   unsigned int i;\n   gimple *stmt;\n   gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n \n   if (GBB_CONDITIONS (gbb).is_empty ())\n-    return true;\n+    return;\n \n   FOR_EACH_VEC_ELT (GBB_CONDITIONS (gbb), i, stmt)\n     switch (gimple_code (stmt))\n@@ -534,36 +522,14 @@ add_conditions_to_domain (poly_bb_p pbb)\n \t    if (!GBB_CONDITION_CASES (gbb)[i])\n \t      code = invert_tree_comparison (code, false);\n \n-\t    if (!add_condition_to_pbb (pbb, cond_stmt, code))\n-\t      return false;\n+\t    add_condition_to_pbb (pbb, cond_stmt, code);\n \t    break;\n \t  }\n \n-      case GIMPLE_SWITCH:\n-\t/* Switch statements are not supported right now - fall through.  */\n-\n       default:\n \tgcc_unreachable ();\n \tbreak;\n       }\n-\n-  return true;\n-}\n-\n-/* Traverses all the GBBs of the SCOP and add their constraints to the\n-   iteration domains.  */\n-\n-static bool\n-add_conditions_to_constraints (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    if (!add_conditions_to_domain (pbb))\n-      return false;\n-\n-  return true;\n }\n \n /* Add constraints on the possible values of parameter P from the type\n@@ -898,6 +864,19 @@ build_scop_drs (scop_p scop)\n     build_poly_sr (pbb);\n }\n \n+/* Add to the iteration DOMAIN one extra dimension for LOOP->num.  */\n+\n+static isl_set *\n+add_iter_domain_dimension (__isl_take isl_set *domain, loop_p loop, scop_p scop)\n+{\n+  int loop_index = isl_set_dim (domain, isl_dim_set);\n+  domain = isl_set_add_dims (domain, isl_dim_set, 1);\n+  char name[50];\n+  snprintf (name, sizeof(name), \"i%d\", loop->num);\n+  isl_id *label = isl_id_alloc (scop->isl_context, name, NULL);\n+  return isl_set_set_dim_id (domain, isl_dim_set, loop_index, label);\n+}\n+\n /* Add constraints to DOMAIN for each loop from LOOP up to CONTEXT.  */\n \n static isl_set *\n@@ -919,7 +898,7 @@ add_loop_constraints (scop_p scop, __isl_take isl_set *domain, loop_p loop,\n   if (dump_file)\n     fprintf (dump_file, \"[sese-to-poly] adding one extra dimension to the \"\n \t     \"domain for loop_%d.\\n\", loop->num);\n-  domain = isl_set_add_dims (domain, isl_dim_set, 1);\n+  domain = add_iter_domain_dimension (domain, loop, scop);\n   isl_space *space = isl_set_get_space (domain);\n \n   /* 0 <= loop_i */\n@@ -1014,8 +993,8 @@ add_loop_constraints (scop_p scop, __isl_take isl_set *domain, loop_p loop,\n /* Builds the original iteration domains for each pbb in the SCOP.  */\n \n static int\n-build_iteration_domains (scop_p scop, __isl_keep isl_set *context, int index,\n-\t\t\t loop_p context_loop)\n+build_iteration_domains (scop_p scop, __isl_keep isl_set *context,\n+\t\t\t int index, loop_p context_loop)\n {\n   loop_p current = pbb_loop (scop->pbbs[index]);\n   isl_set *domain = isl_set_copy (context);\n@@ -1029,9 +1008,14 @@ build_iteration_domains (scop_p scop, __isl_keep isl_set *context, int index,\n       loop_p loop = pbb_loop (pbb);\n       if (current == loop)\n \t{\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+\t  pbb->iterators = isl_set_copy (domain);\n+#endif\n \t  pbb->domain = isl_set_copy (domain);\n \t  pbb->domain = isl_set_set_tuple_id (pbb->domain,\n \t\t\t\t\t      isl_id_for_pbb (scop, pbb));\n+\t  add_conditions_to_domain (pbb);\n+\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"[sese-to-poly] set pbb_%d->domain: \",\n@@ -1061,7 +1045,6 @@ build_iteration_domains (scop_p scop, __isl_keep isl_set *context, int index,\n   return i;\n }\n \n-\n /* Assign dimension for each parameter in SCOP and add constraints for the\n    parameters.  */\n \n@@ -1085,6 +1068,289 @@ build_scop_context (scop_p scop)\n     add_param_constraints (scop, p);\n }\n \n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+\n+/* Return true when loop A is nested in loop B.  */\n+\n+static bool\n+nested_in (loop_p a, loop_p b)\n+{\n+  return b == find_common_loop (a, b);\n+}\n+\n+/* Return the loop at a specific SCOP->pbbs[*INDEX].  */\n+static loop_p\n+loop_at (scop_p scop, int *index)\n+{\n+  return pbb_loop (scop->pbbs[*index]);\n+}\n+\n+/* Return the index of any pbb belonging to loop or a subloop of A.  */\n+\n+static int\n+index_outermost_in_loop (loop_p a, scop_p scop)\n+{\n+  int i, outermost = -1;\n+  int last_depth = -1;\n+  poly_bb_p pbb;\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    if (nested_in (pbb_loop (pbb), a)\n+\t&& (last_depth == -1\n+\t    || last_depth > (int) loop_depth (pbb_loop (pbb))))\n+      {\n+\toutermost = i;\n+\tlast_depth = loop_depth (pbb_loop (pbb));\n+      }\n+  return outermost;\n+}\n+\n+/* Return the index of any pbb belonging to loop or a subloop of A.  */\n+\n+static int\n+index_pbb_in_loop (loop_p a, scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    if (pbb_loop (pbb) == a)\n+      return i;\n+  return -1;\n+}\n+\n+static poly_bb_p\n+outermost_pbb_in (loop_p loop, scop_p scop)\n+{\n+  int x = index_pbb_in_loop (loop, scop);\n+  if (x == -1)\n+    x = index_outermost_in_loop (loop, scop);\n+  return scop->pbbs[x];\n+}\n+\n+static isl_schedule *\n+add_in_sequence (__isl_take isl_schedule *a, __isl_take isl_schedule *b)\n+{\n+  gcc_assert (a || b);\n+\n+  if (!a)\n+    return b;\n+\n+  if (!b)\n+    return a;\n+\n+  return isl_schedule_sequence (a, b);\n+}\n+\n+struct map_to_dimension_data {\n+  int n;\n+  isl_union_pw_multi_aff *res;\n+};\n+\n+/* Create a function that maps the elements of SET to its N-th dimension and add\n+   it to USER->res.  */\n+\n+static isl_stat\n+add_outer_projection (__isl_take isl_set *set, void *user)\n+{\n+  struct map_to_dimension_data *data = (struct map_to_dimension_data *) user;\n+  int dim = isl_set_dim (set, isl_dim_set);\n+  isl_space *space = isl_set_get_space (set);\n+\n+  gcc_assert (dim >= data->n);\n+  isl_pw_multi_aff *pma\n+    = isl_pw_multi_aff_project_out_map (space, isl_dim_set, data->n,\n+\t\t\t\t\tdim - data->n);\n+  data->res = isl_union_pw_multi_aff_add_pw_multi_aff (data->res, pma);\n+\n+  isl_set_free (set);\n+  return isl_stat_ok;\n+}\n+\n+/* Return SET in which all inner dimensions above N are removed.  */\n+\n+static isl_multi_union_pw_aff *\n+outer_projection_mupa (__isl_take isl_union_set *set, int n)\n+{\n+  gcc_assert (n >= 0);\n+  gcc_assert (set);\n+  gcc_assert (!isl_union_set_is_empty (set));\n+\n+  isl_space *space = isl_union_set_get_space (set);\n+  isl_union_pw_multi_aff *pwaff = isl_union_pw_multi_aff_empty (space);\n+\n+  struct map_to_dimension_data data = {n, pwaff};\n+\n+  if (isl_union_set_foreach_set (set, &add_outer_projection, &data) < 0)\n+    data.res = isl_union_pw_multi_aff_free (data.res);\n+\n+  isl_union_set_free (set);\n+  return isl_multi_union_pw_aff_from_union_pw_multi_aff (data.res);\n+}\n+\n+/* Embed SCHEDULE in the constraints of the LOOP domain.  */\n+\n+static isl_schedule *\n+add_loop_schedule (__isl_take isl_schedule *schedule, loop_p loop,\n+\t\t   scop_p scop)\n+{\n+  poly_bb_p pbb = outermost_pbb_in (loop, scop);\n+  isl_set *iterators = pbb->iterators;\n+\n+  int empty = isl_set_is_empty (iterators);\n+  if (empty < 0 || empty)\n+    return empty < 0 ? isl_schedule_free (schedule) : schedule;\n+\n+  isl_space *space = isl_set_get_space (iterators);\n+  int loop_index = isl_space_dim (space, isl_dim_set) - 1;\n+\n+  loop_p ploop = pbb_loop (pbb);\n+  while (loop != ploop)\n+    {\n+      --loop_index;\n+      ploop = loop_outer (ploop);\n+    }\n+\n+  isl_local_space *ls = isl_local_space_from_space (space);\n+  isl_aff *aff = isl_aff_var_on_domain (ls, isl_dim_set, loop_index);\n+  isl_multi_aff *prefix = isl_multi_aff_from_aff (aff);\n+  char name[50];\n+  snprintf (name, sizeof(name), \"L_%d\", loop->num);\n+  isl_id *label = isl_id_alloc (isl_schedule_get_ctx (schedule),\n+\t\t\t\tname, NULL);\n+  prefix = isl_multi_aff_set_tuple_id (prefix, isl_dim_out, label);\n+\n+  int n = isl_multi_aff_dim (prefix, isl_dim_in);\n+  isl_union_set *domain = isl_schedule_get_domain (schedule);\n+  isl_multi_union_pw_aff *mupa = outer_projection_mupa (domain, n);\n+  mupa = isl_multi_union_pw_aff_apply_multi_aff (mupa, prefix);\n+  return isl_schedule_insert_partial_schedule (schedule, mupa);\n+}\n+\n+/* Build schedule for the pbb at INDEX.  */\n+\n+static isl_schedule *\n+build_schedule_pbb (scop_p scop, int *index)\n+{\n+  poly_bb_p pbb = scop->pbbs[*index];\n+  ++*index;\n+  isl_set *domain = isl_set_copy (pbb->domain);\n+  isl_union_set *ud = isl_union_set_from_set (domain);\n+  return isl_schedule_from_domain (ud);\n+}\n+\n+static isl_schedule *build_schedule_loop_nest (scop_p, int *, loop_p);\n+\n+/* Build the schedule of the loop containing the SCOP pbb at INDEX.  */\n+\n+static isl_schedule *\n+build_schedule_loop (scop_p scop, int *index)\n+{\n+  int max = scop->pbbs.length ();\n+  gcc_assert (*index < max);\n+  loop_p loop = loop_at (scop, index);\n+\n+  isl_schedule *s = NULL;\n+  while (nested_in (loop_at (scop, index), loop))\n+    {\n+      if (loop == loop_at (scop, index))\n+\ts = add_in_sequence (s, build_schedule_pbb (scop, index));\n+      else\n+\ts = add_in_sequence (s, build_schedule_loop_nest (scop, index, loop));\n+\n+      if (*index == max)\n+\tbreak;\n+    }\n+\n+  return add_loop_schedule (s, loop, scop);\n+}\n+\n+/* S is the schedule of the loop LOOP.  Embed the schedule S in all outer loops.\n+   When CONTEXT_LOOP is null, embed the schedule in all loops contained in the\n+   SCOP surrounding LOOP.  When CONTEXT_LOOP is non null, only embed S in the\n+   maximal loop nest contained within CONTEXT_LOOP.  */\n+\n+static isl_schedule *\n+embed_in_surrounding_loops (__isl_take isl_schedule *s, scop_p scop,\n+\t\t\t    loop_p loop, int *index, loop_p context_loop)\n+{\n+  loop_p outer = loop_outer (loop);\n+  sese_l region = scop->scop_info->region;\n+  if (context_loop == outer\n+      || !loop_in_sese_p (outer, region))\n+    return s;\n+\n+  int max = scop->pbbs.length ();\n+  if (*index == max\n+      || (context_loop && !nested_in (loop_at (scop, index), context_loop))\n+      || (!context_loop\n+\t  && !loop_in_sese_p (find_common_loop (outer, loop_at (scop, index)),\n+\t\t\t      region)))\n+    return embed_in_surrounding_loops (add_loop_schedule (s, outer, scop),\n+\t\t\t\t       scop, outer, index, context_loop);\n+\n+  bool a_pbb;\n+  while ((a_pbb = (outer == loop_at (scop, index)))\n+\t || nested_in (loop_at (scop, index), outer))\n+    {\n+      if (a_pbb)\n+\ts = add_in_sequence (s, build_schedule_pbb (scop, index));\n+      else\n+\ts = add_in_sequence (s, build_schedule_loop (scop, index));\n+\n+      if (*index == max)\n+\tbreak;\n+    }\n+\n+  /* We reached the end of the OUTER loop: embed S in OUTER.  */\n+  return embed_in_surrounding_loops (add_loop_schedule (s, outer, scop), scop,\n+\t\t\t\t     outer, index, context_loop);\n+}\n+\n+/* Build schedule for the full loop nest containing the pbb at INDEX.  When\n+   CONTEXT_LOOP is null, build the schedule of all loops contained in the SCOP\n+   surrounding the pbb.  When CONTEXT_LOOP is non null, only build the maximal loop\n+   nest contained within CONTEXT_LOOP.  */\n+\n+static isl_schedule *\n+build_schedule_loop_nest (scop_p scop, int *index, loop_p context_loop)\n+{\n+  gcc_assert (*index != (int) scop->pbbs.length ());\n+\n+  loop_p loop = loop_at (scop, index);\n+  isl_schedule *s = build_schedule_loop (scop, index);\n+  return embed_in_surrounding_loops (s, scop, loop, index, context_loop);\n+}\n+\n+/* Build the schedule of the SCOP.  */\n+\n+static bool\n+build_original_schedule (scop_p scop)\n+{\n+  int i = 0;\n+  int n = scop->pbbs.length ();\n+  while (i < n)\n+    {\n+      poly_bb_p pbb = scop->pbbs[i];\n+      isl_schedule *s = NULL;\n+      if (!loop_in_sese_p (pbb_loop (pbb), scop->scop_info->region))\n+\ts = build_schedule_pbb (scop, &i);\n+      else\n+\ts = build_schedule_loop_nest (scop, &i, NULL);\n+\n+      scop->original_schedule = add_in_sequence (scop->original_schedule, s);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"[sese-to-poly] original schedule:\\n\");\n+      print_isl_schedule (dump_file, scop->original_schedule);\n+    }\n+  if (!scop->original_schedule)\n+    return false;\n+  return true;\n+}\n+\n+#endif\n+\n /* Builds the polyhedral representation for a SESE region.  */\n \n bool\n@@ -1097,11 +1363,12 @@ build_poly_scop (scop_p scop)\n   while (i < n)\n     i = build_iteration_domains (scop, scop->param_context, i, NULL);\n \n-  if (!add_conditions_to_constraints (scop))\n-    return false;\n-\n   build_scop_drs (scop);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  build_original_schedule (scop);\n+#else\n   build_scop_scattering (scop);\n+#endif\n   return true;\n }\n #endif  /* HAVE_isl */"}, {"sha": "578fa1a6d98c0c9d0538d6d1b473ce8afc91a403", "filename": "gcc/graphite.h", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -209,7 +209,6 @@ struct poly_dr\n \n void new_poly_dr (poly_bb_p, gimple *, enum poly_dr_type,\n \t\t  isl_map *, isl_set *);\n-void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p);\n void print_pdr (FILE *, poly_dr_p);\n \n@@ -268,10 +267,9 @@ struct poly_bb\n      The number of variables in the DOMAIN may change and is not\n      related to the number of loops in the original code.  */\n   isl_set *domain;\n-\n-  /* The data references we access.  */\n-  vec<poly_dr_p> drs;\n-\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  isl_set *iterators;\n+#else\n   /* The original scattering.  */\n   isl_map *schedule;\n \n@@ -280,6 +278,10 @@ struct poly_bb\n \n   /* A copy of the transformed scattering.  */\n   isl_map *saved;\n+#endif\n+\n+  /* The data references we access.  */\n+  vec<poly_dr_p> drs;\n \n   /* The last basic block generated for this pbb.  */\n   basic_block new_bb;\n@@ -290,8 +292,6 @@ struct poly_bb\n #define PBB_DRS(PBB) (PBB->drs)\n \n extern poly_bb_p new_poly_bb (scop_p, gimple_poly_bb_p);\n-extern void free_poly_bb (poly_bb_p);\n-extern void debug_loop_vec (poly_bb_p);\n extern void print_pbb_domain (FILE *, poly_bb_p);\n extern void print_pbb (FILE *, poly_bb_p);\n extern void print_scop_context (FILE *, scop_p);\n@@ -313,18 +313,19 @@ extern void print_isl_map (FILE *, isl_map *);\n extern void print_isl_union_map (FILE *, isl_union_map *);\n extern void print_isl_aff (FILE *, isl_aff *);\n extern void print_isl_constraint (FILE *, isl_constraint *);\n+extern void print_isl_schedule (FILE *, isl_schedule *);\n+extern void debug_isl_schedule (isl_schedule *);\n+extern void print_isl_ast (FILE *, isl_ast_node *);\n+extern void debug_isl_ast (isl_ast_node *);\n extern void debug_isl_set (isl_set *);\n extern void debug_isl_map (isl_map *);\n extern void debug_isl_union_map (isl_union_map *);\n extern void debug_isl_aff (isl_aff *);\n extern void debug_isl_constraint (isl_constraint *);\n-extern int scop_do_interchange (scop_p);\n-extern int scop_do_strip_mine (scop_p, int);\n-extern bool scop_do_block (scop_p);\n-extern bool flatten_all_loops (scop_p);\n-extern bool optimize_isl (scop_p);\n-extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n extern void debug_gmp_value (mpz_t);\n+extern void debug_scop_pbb (scop_p scop, int i);\n+extern void print_schedule_ast (FILE *, __isl_keep isl_schedule *, scop_p);\n+extern void debug_schedule_ast (__isl_keep isl_schedule *, scop_p);\n \n /* The basic block of the PBB.  */\n \n@@ -424,8 +425,16 @@ struct scop\n   /* The context used internally by isl.  */\n   isl_ctx *isl_context;\n \n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+  /* SCoP original schedule.  */\n+  isl_schedule *original_schedule;\n+\n+  /* SCoP transformed schedule.  */\n+  isl_schedule *transformed_schedule;\n+#else\n   /* SCoP final schedule.  */\n   isl_schedule *schedule;\n+#endif\n \n   /* The data dependence relation among the data references in this scop.  */\n   isl_union_map *dependence;\n@@ -435,10 +444,6 @@ extern scop_p new_scop (edge, edge);\n extern void free_scop (scop_p);\n extern gimple_poly_bb_p new_gimple_poly_bb (basic_block, vec<data_reference_p>,\n \t\t\t\t\t    vec<scalar_use>, vec<tree>);\n-extern void free_gimple_poly_bb (gimple_poly_bb_p);\n-extern void print_generated_program (FILE *, scop_p);\n-extern void debug_generated_program (scop_p);\n-extern int unify_scattering_dimensions (scop_p);\n extern bool apply_poly_transforms (scop_p);\n \n /* Set the region of SCOP to REGION.  */\n@@ -465,8 +470,11 @@ scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n   scop->nb_params = nb_params;\n }\n \n-isl_union_map *\n-scop_get_dependences (scop_p scop);\n+#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n+extern void scop_get_dependences (scop_p scop);\n+#else\n+extern isl_union_map *scop_get_dependences (scop_p scop);\n+#endif\n \n bool\n carries_deps (__isl_keep isl_union_map *schedule,\n@@ -475,9 +483,9 @@ carries_deps (__isl_keep isl_union_map *schedule,\n \n extern bool build_poly_scop (scop_p);\n extern bool graphite_regenerate_ast_isl (scop_p);\n-\n extern void build_scops (vec<scop_p> *);\n extern void dot_all_sese (FILE *, vec<sese_l> &);\n extern void dot_sese (sese_l &);\n extern void dot_cfg ();\n+\n #endif"}, {"sha": "08ea47d010d5947fb209771912d9ab008c03a1bc", "filename": "gcc/sese.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -585,3 +585,37 @@ scalar_evolution_in_region (const sese_l &region, loop_p loop, tree t)\n \n   return instantiate_scev (before, loop, t);\n }\n+\n+/* Pretty print edge E to FILE.  */\n+\n+void\n+print_edge (FILE *file, const_edge e)\n+{\n+  fprintf (file, \"edge (bb_%d, bb_%d)\", e->src->index, e->dest->index);\n+}\n+\n+/* Pretty print sese S to FILE.  */\n+\n+void\n+print_sese (FILE *file, const sese_l &s)\n+{\n+  fprintf (file, \"(entry_\"); print_edge (file, s.entry);\n+  fprintf (file, \", exit_\"); print_edge (file, s.exit);\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Pretty print edge E to STDERR.  */\n+\n+DEBUG_FUNCTION void\n+debug_edge (const_edge e)\n+{\n+  print_edge (stderr, e);\n+}\n+\n+/* Pretty print sese S to STDERR.  */\n+\n+DEBUG_FUNCTION void\n+debug_sese (const sese_l &s)\n+{\n+  print_sese (stderr, s);\n+}"}, {"sha": "c2fe79e55f15039af77d84b6f6eae9424052fb9c", "filename": "gcc/sese.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -43,6 +43,11 @@ struct sese_l\n   edge exit;\n };\n \n+void print_edge (FILE *file, const_edge e);\n+void print_sese (FILE *file, const sese_l &s);\n+void dump_edge (const_edge e);\n+void dump_sese (const sese_l &);\n+\n /* Get the entry of an sese S.  */\n \n static inline basic_block\n@@ -207,7 +212,7 @@ loop_in_sese_p (struct loop *loop, const sese_l &region)\n     loop_2 is completely contained -> depth 1  */\n \n static inline unsigned int\n-sese_loop_depth (sese_l &region, loop_p loop)\n+sese_loop_depth (const sese_l &region, loop_p loop)\n {\n   unsigned int depth = 0;\n "}, {"sha": "649302b049e4dadb075055b17e7d2002ed4c92f9", "filename": "gcc/testsuite/gcc.dg/graphite/pr35356-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr35356-1.c?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -34,4 +34,4 @@ if (n >= k + 1 && k >= 0) {\n \n */\n \n-/* { dg-final { scan-tree-dump-times \"if \\\\\\(P_9 >= P_10 \\\\\\+ 1 && P_10 >= 0\\\\\\) \\\\\\{\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump \"if \\\\\\(P_9 >= P_10 \\\\\\+ 1 && P_10 >= 0\\\\\\) \\\\\\{\" \"graphite\" } } */"}, {"sha": "f20eaa971cf333228f1e6c2fd33e7464f8d7a785", "filename": "gcc/testsuite/gfortran.dg/graphite/interchange-3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adba512db0e12d215961958b522b8b2f0ab94ab0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Finterchange-3.f90?ref=adba512db0e12d215961958b522b8b2f0ab94ab0", "patch": "@@ -24,4 +24,4 @@ Program FOO\n \n end Program FOO\n \n-! { dg-final { scan-tree-dump-times \"unsuccessful, reverting back to the original code.\" \"1\" \"graphite\" } }\n+! { dg-final { scan-tree-dump-times \"codegen error: reverting back to the original code.\" \"1\" \"graphite\" } }"}]}