{"sha": "5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3ZjZhYWFhZjEzMWNhYjNkNDI3MDQ1YTcwYzMyZTVkYmI1Zjc0Zg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2013-06-19T12:25:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2013-06-19T12:25:26Z"}, "message": "arm.md (split for eq(reg, 0)): Add variants for ARMv5 and Thumb2.\n\n\t(peepholes for eq(reg, not-0)): Ensure condition register is dead after\n\tpattern.  Use more efficient sequences on ARMv5 and Thumb2.\n\nFrom-SVN: r200197", "tree": {"sha": "221c6a91d68f4fe67cc31f61ffb45637877f378b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/221c6a91d68f4fe67cc31f61ffb45637877f378b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f/comments", "author": null, "committer": null, "parents": [{"sha": "5fdc1e5d8ae28adbb39e9e3ef0a05385a355de12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fdc1e5d8ae28adbb39e9e3ef0a05385a355de12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fdc1e5d8ae28adbb39e9e3ef0a05385a355de12"}], "stats": {"total": 94, "additions": 84, "deletions": 10}, "files": [{"sha": "3d89e3e6834f3d60264140f892a74ff1b9bc3228", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "patch": "@@ -1,3 +1,9 @@\n+2013-06-19  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tarm.md (split for eq(reg, 0)): Add variants for ARMv5 and Thumb2.\n+\t(peepholes for eq(reg, not-0)): Ensure condition register is dead after\n+\tpattern.  Use more efficient sequences on ARMv5 and Thumb2.\n+\n 2013-06-19  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR target/57609"}, {"sha": "42c21098db83f663b9a5f0326454c509f1c67fdf", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "patch": "@@ -10016,6 +10016,16 @@\n   [(set (match_dup 0) (not:SI (match_dup 1)))\n    (set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 31)))])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(eq:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n+\t       (const_int 0)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"arm_arch5 && TARGET_32BIT\"\n+  [(set (match_dup 0) (clz:SI (match_dup 1)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 5)))]\n+)\n+\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(eq:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n@@ -10090,29 +10100,87 @@\n \n ;; Attempt to improve the sequence generated by the compare_scc splitters\n ;; not to use conditional execution.\n+\n+;; Rd = (eq (reg1) (const_int0))  // ARMv5\n+;;\tclz Rd, reg1\n+;;\tlsr Rd, Rd, #5\n (define_peephole2\n   [(set (reg:CC CC_REGNUM)\n \t(compare:CC (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 2 \"arm_rhs_operand\" \"\")))\n+\t\t    (const_int 0)))\n+   (cond_exec (ne (reg:CC CC_REGNUM) (const_int 0))\n+\t      (set (match_operand:SI 0 \"register_operand\" \"\") (const_int 0)))\n+   (cond_exec (eq (reg:CC CC_REGNUM) (const_int 0))\n+\t      (set (match_dup 0) (const_int 1)))]\n+  \"arm_arch5 && TARGET_32BIT && peep2_regno_dead_p (3, CC_REGNUM)\"\n+  [(set (match_dup 0) (clz:SI (match_dup 1)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 5)))]\n+)\n+\n+;; Rd = (eq (reg1) (const_int0))  // !ARMv5\n+;;\tnegs Rd, reg1\n+;;\tadc  Rd, Rd, reg1\n+(define_peephole2\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t    (const_int 0)))\n    (cond_exec (ne (reg:CC CC_REGNUM) (const_int 0))\n \t      (set (match_operand:SI 0 \"register_operand\" \"\") (const_int 0)))\n    (cond_exec (eq (reg:CC CC_REGNUM) (const_int 0))\n \t      (set (match_dup 0) (const_int 1)))\n-   (match_scratch:SI 3 \"r\")]\n-  \"TARGET_32BIT\"\n+   (match_scratch:SI 2 \"r\")]\n+  \"TARGET_32BIT && peep2_regno_dead_p (3, CC_REGNUM)\"\n   [(parallel\n     [(set (reg:CC CC_REGNUM)\n-\t  (compare:CC (match_dup 1) (match_dup 2)))\n-     (set (match_dup 3) (minus:SI (match_dup 1) (match_dup 2)))])\n+\t  (compare:CC (const_int 0) (match_dup 1)))\n+     (set (match_dup 2) (minus:SI (const_int 0) (match_dup 1)))])\n+   (set (match_dup 0)\n+\t(plus:SI (plus:SI (match_dup 1) (match_dup 2))\n+\t\t (geu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n+)\n+\n+;; Rd = (eq (reg1) (reg2/imm))\t// ARMv5\n+;;\tsub  Rd, Reg1, reg2\n+;;\tclz  Rd, Rd\n+;;\tlsr  Rd, Rd, #5\n+(define_peephole2\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"arm_rhs_operand\" \"\")))\n+   (cond_exec (ne (reg:CC CC_REGNUM) (const_int 0))\n+\t      (set (match_operand:SI 0 \"register_operand\" \"\") (const_int 0)))\n+   (cond_exec (eq (reg:CC CC_REGNUM) (const_int 0))\n+\t      (set (match_dup 0) (const_int 1)))]\n+  \"arm_arch5 && TARGET_32BIT && peep2_regno_dead_p (3, CC_REGNUM)\"\n+  [(set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (clz:SI (match_dup 0)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 5)))]\n+)\n+\n+\n+;; Rd = (eq (reg1) (reg2/imm))\t// ! ARMv5\n+;;\tsub  T1, Reg1, reg2\n+;;\tnegs Rd, T1\n+;;\tadc  Rd, Rd, T1\n+(define_peephole2\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"arm_rhs_operand\" \"\")))\n+   (cond_exec (ne (reg:CC CC_REGNUM) (const_int 0))\n+\t      (set (match_operand:SI 0 \"register_operand\" \"\") (const_int 0)))\n+   (cond_exec (eq (reg:CC CC_REGNUM) (const_int 0))\n+\t      (set (match_dup 0) (const_int 1)))\n+   (match_scratch:SI 3 \"r\")]\n+  \"TARGET_32BIT && peep2_regno_dead_p (3, CC_REGNUM)\"\n+  [(set (match_dup 3) (minus:SI (match_dup 1) (match_dup 2)))\n    (parallel\n     [(set (reg:CC CC_REGNUM)\n \t  (compare:CC (const_int 0) (match_dup 3)))\n      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 3)))])\n-   (parallel\n-    [(set (match_dup 0)\n-\t  (plus:SI (plus:SI (match_dup 0) (match_dup 3))\n-\t\t   (geu:SI (reg:CC CC_REGNUM) (const_int 0))))\n-     (clobber (reg:CC CC_REGNUM))])])\n+   (set (match_dup 0)\n+\t(plus:SI (plus:SI (match_dup 0) (match_dup 3))\n+\t\t (geu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n+)\n \n (define_insn \"*cond_move\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r\")"}]}