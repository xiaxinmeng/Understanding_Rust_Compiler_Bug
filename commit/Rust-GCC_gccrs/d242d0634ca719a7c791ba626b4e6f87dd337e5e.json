{"sha": "d242d0634ca719a7c791ba626b4e6f87dd337e5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI0MmQwNjM0Y2E3MTlhN2M3OTFiYTYyNmI0ZTZmODdkZDMzN2U1ZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-09-09T23:38:23Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-09-09T23:38:23Z"}, "message": "re PR tree-optimization/44972 (ICE: in load_assign_lhs_subreplacements, at tree-sra.c:2475)\n\n2010-09-10  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/44972\n\t* tree-sra.c: Include toplev.h.\n\t(build_ref_for_offset): Entirely reimplemented.\n\t(build_ref_for_model): New function.\n\t(build_user_friendly_ref_for_offset): New function.\n\t(analyze_access_subtree): Removed build_ref_for_offset check.\n\t(propagate_subaccesses_across_link): Likewise.\n\t(create_artificial_child_access): Use\n\tbuild_user_friendly_ref_for_offset.\n\t(propagate_subaccesses_across_link): Likewise.\n\t(ref_expr_for_all_replacements_p): Removed.\n\t(generate_subtree_copies): Updated comment.  Use build_ref_for_model.\n\t(sra_modify_expr): Use build_ref_for_model.\n\t(load_assign_lhs_subreplacements): Likewise.\n\t(sra_modify_assign): Removed ref_expr_for_all_replacements_p checks,\n\tchecks for return values of build_ref_for_offset.\n\t* ipa-cp.c (ipcp_lattice_from_jfunc): No need to check return value of\n\tbuild_ref_for_offset.\n\t* ipa-prop.h: Include gimple.h\n\t* ipa-prop.c (ipa_compute_jump_functions): Update to look for MEM_REFs.\n\t(ipa_analyze_indirect_call_uses): Update comment.\n\t* Makefile.in (tree-sra.o): Add $(GIMPLE_H) to dependencies.\n\t(IPA_PROP_H): Likewise.\n\n\t* testsuite/gcc.dg/ipa/ipa-sra-1.c: Adjust scanning expressions.\n\t* testsuite/gcc.dg/tree-ssa/pr45144.c: Likewise.\n\t* testsuite/gcc.dg/tree-ssa/forwprop-5.c: Likewise and scan optimzed\n\tdump instead.\n        * testsuite/g++.dg/torture/pr44972.C: New test.\n\nFrom-SVN: r164136", "tree": {"sha": "951106b686b0e34fa68f8a0a3c5bed5ca6806875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/951106b686b0e34fa68f8a0a3c5bed5ca6806875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d242d0634ca719a7c791ba626b4e6f87dd337e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d242d0634ca719a7c791ba626b4e6f87dd337e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d242d0634ca719a7c791ba626b4e6f87dd337e5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d242d0634ca719a7c791ba626b4e6f87dd337e5e/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fffe1e4064df4724b2e5e7c57d8e478bd3ab22fe"}], "stats": {"total": 548, "additions": 351, "deletions": 197}, "files": [{"sha": "22c53c069f0d2d212874856001afdc31ec61719e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -1,3 +1,29 @@\n+2010-09-10  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/44972\n+\t* tree-sra.c: Include toplev.h.\n+\t(build_ref_for_offset): Entirely reimplemented.\n+\t(build_ref_for_model): New function.\n+\t(build_user_friendly_ref_for_offset): New function.\n+\t(analyze_access_subtree): Removed build_ref_for_offset check.\n+\t(propagate_subaccesses_across_link): Likewise.\n+\t(create_artificial_child_access): Use\n+\tbuild_user_friendly_ref_for_offset.\n+\t(propagate_subaccesses_across_link): Likewise.\n+\t(ref_expr_for_all_replacements_p): Removed.\n+\t(generate_subtree_copies): Updated comment.  Use build_ref_for_model.\n+\t(sra_modify_expr): Use build_ref_for_model.\n+\t(load_assign_lhs_subreplacements): Likewise.\n+\t(sra_modify_assign): Removed ref_expr_for_all_replacements_p checks,\n+\tchecks for return values of build_ref_for_offset.\n+\t* ipa-cp.c (ipcp_lattice_from_jfunc): No need to check return value of\n+\tbuild_ref_for_offset.\n+\t* ipa-prop.h: Include gimple.h\n+\t* ipa-prop.c (ipa_compute_jump_functions): Update to look for MEM_REFs.\n+\t(ipa_analyze_indirect_call_uses): Update comment.\n+\t* Makefile.in (tree-sra.o): Add $(GIMPLE_H) to dependencies.\n+\t(IPA_PROP_H): Likewise.\n+\n 2010-09-10  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/44972"}, {"sha": "1bf35f1e9f56811ee37d131b766ab51cbb80f481", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -968,7 +968,7 @@ EBITMAP_H = ebitmap.h sbitmap.h\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n \t\t$(CGRAPH_H) $(VEC_H) vecprim.h $(TREE_H) $(GIMPLE_H)\n TREE_VECTORIZER_H = tree-vectorizer.h $(TREE_DATA_REF_H)\n-IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H)\n+IPA_PROP_H = ipa-prop.h $(TREE_H) $(VEC_H) $(CGRAPH_H) $(GIMPLE_H)\n GSTAB_H = gstab.h stab.def\n BITMAP_H = bitmap.h $(HASHTAB_H) statistics.h\n GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h $(CONFIG_H) $(SYSTEM_H) \\\n@@ -3143,10 +3143,10 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    tree-ssa-propagate.h value-prof.h $(FLAGS_H) $(TARGET_H) $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) \\\n    $(DBGCNT_H) tree-pretty-print.h gimple-pretty-print.h\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \\\n-   $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n-   $(DIAGNOSTIC_H) statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) $(PARAMS_H) \\\n-   $(TARGET_H) $(FLAGS_H) $(EXPR_H) tree-pretty-print.h $(DBGCNT_H) \\\n-   $(TREE_INLINE_H) gimple-pretty-print.h\n+   $(TM_H) $(TOPLEV_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) \\\n+   $(IPA_PROP_H) $(DIAGNOSTIC_H) statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) \\\n+   $(PARAMS_H) $(TARGET_H) $(FLAGS_H) $(EXPR_H) tree-pretty-print.h \\\n+   $(DBGCNT_H) $(TREE_INLINE_H) gimple-pretty-print.h\n tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n     $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \\"}, {"sha": "0680e3254d68b073ea9146ef1bbfba3fa28b865e", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -327,7 +327,6 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n     {\n       struct ipcp_lattice *caller_lat;\n       tree t;\n-      bool ok;\n \n       caller_lat = ipcp_get_lattice (info, jfunc->value.ancestor.formal_id);\n       lat->type = caller_lat->type;\n@@ -340,16 +339,9 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n \t  return;\n \t}\n       t = TREE_OPERAND (caller_lat->constant, 0);\n-      ok = build_ref_for_offset (&t, TREE_TYPE (t),\n-\t\t\t\t jfunc->value.ancestor.offset,\n-\t\t\t\t jfunc->value.ancestor.type, false);\n-      if (!ok)\n-\t{\n-\t  lat->type = IPA_BOTTOM;\n-\t  lat->constant = NULL_TREE;\n-\t}\n-      else\n-\tlat->constant = build_fold_addr_expr (t);\n+      t = build_ref_for_offset (t, jfunc->value.ancestor.offset,\n+\t\t\t\tjfunc->value.ancestor.type, NULL, false);\n+      lat->constant = build_fold_addr_expr (t);\n     }\n   else\n     lat->type = IPA_BOTTOM;"}, {"sha": "ec45d7c5271057229c45e9622e9ac0220b4f2b0f", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -916,23 +916,27 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n static tree\n ipa_get_member_ptr_load_param (tree rhs, bool use_delta)\n {\n-  tree rec, fld;\n+  tree rec, ref_offset, fld_offset;\n   tree ptr_field;\n   tree delta_field;\n \n-  if (TREE_CODE (rhs) != COMPONENT_REF)\n+  if (TREE_CODE (rhs) != MEM_REF)\n     return NULL_TREE;\n-\n   rec = TREE_OPERAND (rhs, 0);\n+  if (TREE_CODE (rec) != ADDR_EXPR)\n+    return NULL_TREE;\n+  rec = TREE_OPERAND (rec, 0);\n   if (TREE_CODE (rec) != PARM_DECL\n       || !type_like_member_ptr_p (TREE_TYPE (rec), &ptr_field, &delta_field))\n     return NULL_TREE;\n \n-  fld = TREE_OPERAND (rhs, 1);\n-  if (use_delta ? (fld == delta_field) : (fld == ptr_field))\n-    return rec;\n+  ref_offset = TREE_OPERAND (rhs, 1);\n+  if (use_delta)\n+    fld_offset = byte_position (delta_field);\n   else\n-    return NULL_TREE;\n+    fld_offset = byte_position (ptr_field);\n+\n+  return tree_int_cst_equal (ref_offset, fld_offset) ? rec : NULL_TREE;\n }\n \n /* If STMT looks like a statement loading a value from a member pointer formal\n@@ -999,8 +1003,8 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt,\n    below, the call is on the last line:\n \n      <bb 2>:\n-       f$__delta_5 = f.__delta;\n-       f$__pfn_24 = f.__pfn;\n+       f$__delta_5 = MEM[(struct  *)&f];\n+       f$__pfn_24 = MEM[(struct  *)&f + 4B];\n \n      ...\n "}, {"sha": "210a8638a40e75e688f53738e683444796b4b0e9", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"vec.h\"\n #include \"cgraph.h\"\n+#include \"gimple.h\"\n \n /* The following definitions and interfaces are used by\n    interprocedural analyses or parameters.  */\n@@ -511,6 +512,7 @@ void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n \n /* From tree-sra.c:  */\n-bool build_ref_for_offset (tree *, tree, HOST_WIDE_INT, tree, bool);\n+tree build_ref_for_offset (tree, HOST_WIDE_INT, tree, gimple_stmt_iterator *,\n+\t\t\t   bool);\n \n #endif /* IPA_PROP_H */"}, {"sha": "e4c2c9aba02b056bac4c2d34c29c6db8afffd872", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -1,3 +1,12 @@\n+2010-09-10  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/44972\n+\t* gcc.dg/ipa/ipa-sra-1.c: Adjust scanning expressions.\n+\t* gcc.dg/tree-ssa/pr45144.c: Likewise.\n+\t* gcc.dg/tree-ssa/forwprop-5.c: Likewise and scan optimzed dump\n+\tinstead.\n+        * g++.dg/torture/pr44972.C: New test.\n+\n 2010-09-10  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/44972"}, {"sha": "81806076c58c623c9ea201f5eb4f68cd49cbf89b", "filename": "gcc/testsuite/g++.dg/torture/pr44972.C", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44972.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44972.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44972.C?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -0,0 +1,142 @@\n+/* { dg-do compile } */\n+\n+#include<cassert>\n+#include<new>\n+#include<utility>\n+\n+namespace boost {\n+\n+template<class T>\n+class optional;\n+\n+class aligned_storage\n+{\n+\tchar data[ 1000 ];\n+  public:\n+    void const* address() const { return &data[0]; }\n+    void      * address()       { return &data[0]; }\n+} ;\n+\n+\n+template<class T>\n+class optional_base\n+{\n+  protected :\n+    optional_base(){}\n+    optional_base ( T const& val )\n+    {\n+      construct(val);\n+    }\n+\n+    template<class U>\n+    void assign ( optional<U> const& rhs )\n+    {\n+      if (!is_initialized())\n+        if ( rhs.is_initialized() )\n+          construct(T());\n+    }\n+\n+  public :\n+\n+    bool is_initialized() const { return m_initialized ; }\n+\n+  protected :\n+\n+    void construct ( T const& val )\n+     {\n+       new (m_storage.address()) T(val) ;\n+     }\n+\n+    T const* get_ptr_impl() const\n+    { return static_cast<T const*>(m_storage.address()); }\n+\n+  private :\n+\n+    bool m_initialized ;\n+    aligned_storage  m_storage ;\n+} ;\n+\n+\n+template<class T>\n+class optional : public optional_base<T>\n+{\n+    typedef optional_base<T> base ;\n+\n+  public :\n+\n+    optional() : base() {}\n+    optional ( T const& val ) : base(val) {}\n+    optional& operator= ( optional const& rhs )\n+      {\n+        this->assign( rhs ) ;\n+        return *this ;\n+      }\n+\n+    T const& get() const ;\n+\n+    T const* operator->() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail (\"this->is_initialized()\", \"pr44972.C\", 78, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }\n+\n+} ;\n+\n+\n+} // namespace boost\n+\n+\n+namespace std\n+{\n+\n+  template<typename _Tp, std::size_t _Nm>\n+    struct array\n+    {\n+      typedef _Tp \t    \t\t\t      value_type;\n+      typedef const value_type*\t\t\t      const_iterator;\n+\n+      value_type _M_instance[_Nm];\n+\n+    };\n+}\n+\n+\n+class NT\n+{\n+  double _inf, _sup;\n+};\n+\n+\n+template < typename T > inline\n+std::array<T, 1>\n+make_array(const T& b1)\n+{\n+  std::array<T, 1> a = { { b1 } };\n+  return a;\n+}\n+\n+class V\n+{\n+  typedef std::array<NT, 1>               Base;\n+  Base base;\n+\n+public:\n+  V() {}\n+  V(const NT &x)\n+    : base(make_array(x)) {}\n+\n+};\n+\n+using boost::optional ;\n+\n+optional< std::pair< NT, NT > >\n+  linsolve_pointC2() ;\n+\n+optional< V > construct_normal_offset_lines_isecC2 ( )\n+{\n+  optional< std::pair<NT,NT> > ip;\n+\n+  ip = linsolve_pointC2();\n+\n+  V a(ip->first) ;\n+  return a;\n+}\n+\n+\n+"}, {"sha": "2c05347c641df2fa4ee0940c7efc9ffbf2c1eeed", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-sra-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-sra-1.c?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -36,6 +36,5 @@ main (int argc, char *argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"About to replace expr cow.green with ISRA\" \"eipa_sra\"  } } */\n-/* { dg-final { scan-tree-dump \"About to replace expr cow.blue with ISRA\" \"eipa_sra\"  } } */\n+/* { dg-final { scan-tree-dump-times \"About to replace expr\" 2 \"eipa_sra\" } } */\n /* { dg-final { cleanup-tree-dump \"eipa_sra\" } } */"}, {"sha": "f2ddab2535b9d0377b42c0803a278d7bb6cb894e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-5.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-5.c?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-esra -w\" } */\n+/* { dg-options \"-O1 -fdump-tree-optimized -w\" } */\n \n #define vector __attribute__((vector_size(16) ))\n struct VecClass\n@@ -11,12 +11,9 @@ vector float foo( vector float v )\n {\n     vector float x = v;\n     x = x + x;\n-    struct VecClass y = *(struct VecClass*)&x;\n-    return y.v;\n+    struct VecClass disappear = *(struct VecClass*)&x;\n+    return disappear.v;\n }\n \n-/* We should be able to remove the intermediate struct and directly\n-   return x.  As we do not fold VIEW_CONVERT_EXPR<struct VecClass>(x).v\n-   that doesn't happen right now.  */\n-/* { dg-final { scan-tree-dump-times \"VIEW_CONVERT_EXPR\" 1 \"esra\"} } */\n-/* { dg-final { cleanup-tree-dump \"esra\" } } */\n+/* { dg-final { scan-tree-dump-times \"disappear\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1e0dabdee8b14da53cbcaba00e6f36d0e0868221", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr45144.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45144.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45144.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45144.c?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -42,5 +42,5 @@ bar (unsigned orig, unsigned *new)\n   *new = foo (&a);\n }\n \n-/* { dg-final { scan-tree-dump \"x = a;\" \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \" = VIEW_CONVERT_EXPR<unsigned int>\\\\(a\\\\);\" \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "83a515515dfc71e1917e5b97765460d2a3212f91", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 143, "deletions": 160, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d242d0634ca719a7c791ba626b4e6f87dd337e5e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d242d0634ca719a7c791ba626b4e6f87dd337e5e", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"alloc-pool.h\"\n #include \"tm.h\"\n+#include \"toplev.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"cgraph.h\"\n@@ -1320,15 +1321,106 @@ make_fancy_name (tree expr)\n   return XOBFINISH (&name_obstack, char *);\n }\n \n-/* Helper function for build_ref_for_offset.\n+/* Construct a MEM_REF that would reference a part of aggregate BASE of type\n+   EXP_TYPE at the given OFFSET.  If BASE is something for which\n+   get_addr_base_and_unit_offset returns NULL, gsi must be non-NULL and is used\n+   to insert new statements either before or below the current one as specified\n+   by INSERT_AFTER.  This function is not capable of handling bitfields.  */\n \n-   FIXME: Eventually this should be rewritten to either re-use the\n-   original access expression unshared (which is good for alias\n-   analysis) or to build a MEM_REF expression.  */\n+tree\n+build_ref_for_offset (tree base, HOST_WIDE_INT offset,\n+\t\t      tree exp_type, gimple_stmt_iterator *gsi,\n+\t\t      bool insert_after)\n+{\n+  tree prev_base = base;\n+  tree off;\n+  location_t loc = EXPR_LOCATION (base);\n+  HOST_WIDE_INT base_offset;\n+\n+  gcc_checking_assert (offset % BITS_PER_UNIT == 0);\n+\n+  base = get_addr_base_and_unit_offset (base, &base_offset);\n+\n+  /* get_addr_base_and_unit_offset returns NULL for references with a variable\n+     offset such as array[var_index].  */\n+  if (!base)\n+    {\n+      gimple stmt;\n+      tree tmp, addr;\n+\n+      gcc_checking_assert (gsi);\n+      tmp = create_tmp_reg (build_pointer_type (TREE_TYPE (prev_base)), NULL);\n+      add_referenced_var (tmp);\n+      tmp = make_ssa_name (tmp, NULL);\n+      addr = build_fold_addr_expr (unshare_expr (prev_base));\n+      stmt = gimple_build_assign (tmp, addr);\n+      SSA_NAME_DEF_STMT (tmp) = stmt;\n+      if (insert_after)\n+\tgsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n+      else\n+\tgsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+      update_stmt (stmt);\n+\n+      off = build_int_cst (reference_alias_ptr_type (prev_base),\n+\t\t\t   offset / BITS_PER_UNIT);\n+      base = tmp;\n+    }\n+  else if (TREE_CODE (base) == MEM_REF)\n+    {\n+      off = build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)),\n+\t\t\t   base_offset + offset / BITS_PER_UNIT);\n+      off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1), off, 0);\n+      base = unshare_expr (TREE_OPERAND (base, 0));\n+    }\n+  else\n+    {\n+      off = build_int_cst (reference_alias_ptr_type (base),\n+\t\t\t   base_offset + offset / BITS_PER_UNIT);\n+      base = build_fold_addr_expr (unshare_expr (base));\n+    }\n+\n+  return fold_build2_loc (loc, MEM_REF, exp_type, base, off);\n+}\n+\n+/* Construct a memory reference to a part of an aggregate BASE at the given\n+   OFFSET and of the same type as MODEL.  In case this is a reference to a\n+   bit-field, the function will replicate the last component_ref of model's\n+   expr to access it.  GSI and INSERT_AFTER have the same meaning as in\n+   build_ref_for_offset.  */\n+\n+static tree\n+build_ref_for_model (tree base, HOST_WIDE_INT offset,\n+\t\t     struct access *model, gimple_stmt_iterator *gsi,\n+\t\t     bool insert_after)\n+{\n+  if (TREE_CODE (model->expr) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (model->expr, 1)))\n+    {\n+      /* This access represents a bit-field.  */\n+      tree t, exp_type;\n+\n+      offset -= int_bit_position (TREE_OPERAND (model->expr, 1));\n+      exp_type = TREE_TYPE (TREE_OPERAND (model->expr, 0));\n+      t = build_ref_for_offset (base, offset, exp_type, gsi, insert_after);\n+      return fold_build3_loc (EXPR_LOCATION (base), COMPONENT_REF,\n+\t\t\t      model->type, t, TREE_OPERAND (model->expr, 1),\n+\t\t\t      NULL_TREE);\n+    }\n+  else\n+    return build_ref_for_offset (base, offset, model->type, gsi, insert_after);\n+}\n+\n+/* Construct a memory reference consisting of component_refs and array_refs to\n+   a part of an aggregate *RES (which is of type TYPE).  The requested part\n+   should have type EXP_TYPE at be the given OFFSET.  This function might not\n+   succeed, it returns true when it does and only then *RES points to something\n+   meaningful.  This function should be used only to build expressions that we\n+   might need to present to user (e.g. in warnings).  In all other situations,\n+   build_ref_for_model or build_ref_for_offset should be used instead.  */\n \n static bool\n-build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n-\t\t\ttree exp_type)\n+build_user_friendly_ref_for_offset (tree *res, tree type, HOST_WIDE_INT offset,\n+\t\t\t\t    tree exp_type)\n {\n   while (1)\n     {\n@@ -1367,19 +1459,13 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n \t      else if (pos > offset || (pos + size) <= offset)\n \t\tcontinue;\n \n-\t      if (res)\n+\t      expr = build3 (COMPONENT_REF, TREE_TYPE (fld), *res, fld,\n+\t\t\t     NULL_TREE);\n+\t      expr_ptr = &expr;\n+\t      if (build_user_friendly_ref_for_offset (expr_ptr, TREE_TYPE (fld),\n+\t\t\t\t\t\t      offset - pos, exp_type))\n \t\t{\n-\t\t  expr = build3 (COMPONENT_REF, TREE_TYPE (fld), *res, fld,\n-\t\t\t\t NULL_TREE);\n-\t\t  expr_ptr = &expr;\n-\t\t}\n-\t      else\n-\t\texpr_ptr = NULL;\n-\t      if (build_ref_for_offset_1 (expr_ptr, TREE_TYPE (fld),\n-\t\t\t\t\t  offset - pos, exp_type))\n-\t\t{\n-\t\t  if (res)\n-\t\t    *res = expr;\n+\t\t  *res = expr;\n \t\t  return true;\n \t\t}\n \t    }\n@@ -1394,14 +1480,11 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n \t  minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n \t  if (TREE_CODE (minidx) != INTEGER_CST || el_size == 0)\n \t    return false;\n-\t  if (res)\n-\t    {\n-\t      index = build_int_cst (TYPE_DOMAIN (type), offset / el_size);\n-\t      if (!integer_zerop (minidx))\n-\t\tindex = int_const_binop (PLUS_EXPR, index, minidx, 0);\n-\t      *res = build4 (ARRAY_REF, TREE_TYPE (type), *res, index,\n-\t\t\t     NULL_TREE, NULL_TREE);\n-\t    }\n+\t  index = build_int_cst (TYPE_DOMAIN (type), offset / el_size);\n+\t  if (!integer_zerop (minidx))\n+\t    index = int_const_binop (PLUS_EXPR, index, minidx, 0);\n+\t  *res = build4 (ARRAY_REF, TREE_TYPE (type), *res, index,\n+\t\t\t NULL_TREE, NULL_TREE);\n \t  offset = offset % el_size;\n \t  type = TREE_TYPE (type);\n \t  break;\n@@ -1418,31 +1501,6 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n     }\n }\n \n-/* Construct an expression that would reference a part of aggregate *EXPR of\n-   type TYPE at the given OFFSET of the type EXP_TYPE.  If EXPR is NULL, the\n-   function only determines whether it can build such a reference without\n-   actually doing it, otherwise, the tree it points to is unshared first and\n-   then used as a base for furhter sub-references.  */\n-\n-bool\n-build_ref_for_offset (tree *expr, tree type, HOST_WIDE_INT offset,\n-\t\t      tree exp_type, bool allow_ptr)\n-{\n-  location_t loc = expr ? EXPR_LOCATION (*expr) : UNKNOWN_LOCATION;\n-\n-  if (expr)\n-    *expr = unshare_expr (*expr);\n-\n-  if (allow_ptr && POINTER_TYPE_P (type))\n-    {\n-      type = TREE_TYPE (type);\n-      if (expr)\n-\t*expr = build_simple_mem_ref_loc (loc, *expr);\n-    }\n-\n-  return build_ref_for_offset_1 (expr, type, offset, exp_type);\n-}\n-\n /* Return true iff TYPE is stdarg va_list type.  */\n \n static inline bool\n@@ -1823,13 +1881,7 @@ analyze_access_subtree (struct access *root, bool allow_replacements,\n \n   if (allow_replacements && scalar && !root->first_child\n       && (root->grp_hint\n-\t  || (root->grp_write && (direct_read || root->grp_assignment_read)))\n-      /* We must not ICE later on when trying to build an access to the\n-\t original data within the aggregate even when it is impossible to do in\n-\t a defined way like in the PR 42703 testcase.  Therefore we check\n-\t pre-emptively here that we will be able to do that.  */\n-      && build_ref_for_offset (NULL, TREE_TYPE (root->base), root->offset,\n-\t\t\t       root->type, false))\n+\t  || (root->grp_write && (direct_read || root->grp_assignment_read))))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1914,12 +1966,11 @@ create_artificial_child_access (struct access *parent, struct access *model,\n {\n   struct access *access;\n   struct access **child;\n-  tree expr = parent->base;;\n+  tree expr = parent->base;\n \n   gcc_assert (!model->grp_unscalarizable_region);\n-\n-  if (!build_ref_for_offset (&expr, TREE_TYPE (expr), new_offset,\n-\t\t\t     model->type, false))\n+  if (!build_user_friendly_ref_for_offset (&expr, TREE_TYPE (expr), new_offset,\n+\t\t\t\t\t   model->type))\n     return NULL;\n \n   access = (struct access *) pool_alloc (access_pool);\n@@ -1964,8 +2015,8 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n     {\n       tree t = lacc->base;\n \n-      if (build_ref_for_offset (&t, TREE_TYPE (t), lacc->offset, racc->type,\n-\t\t\t\tfalse))\n+      if (build_user_friendly_ref_for_offset (&t, TREE_TYPE (t), lacc->offset,\n+\t\t\t\t\t      racc->type))\n \t{\n \t  lacc->expr = t;\n \t  lacc->type = racc->type;\n@@ -1994,13 +2045,6 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n \t  continue;\n \t}\n \n-      /* If a (part of) a union field is on the RHS of an assignment, it can\n-\t have sub-accesses which do not make sense on the LHS (PR 40351).\n-\t Check that this is not the case.  */\n-      if (!build_ref_for_offset (NULL, TREE_TYPE (lacc->base), norm_offset,\n-\t\t\t\t rchild->type, false))\n-\tcontinue;\n-\n       rchild->grp_hint = 1;\n       new_acc = create_artificial_child_access (lacc, rchild, norm_offset);\n       if (new_acc)\n@@ -2124,48 +2168,19 @@ analyze_all_variable_accesses (void)\n     return false;\n }\n \n-/* Return true iff a reference statement into aggregate AGG can be built for\n-   every single to-be-replaced accesses that is a child of ACCESS, its sibling\n-   or a child of its sibling. TOP_OFFSET is the offset from the processed\n-   access subtree that has to be subtracted from offset of each access.  */\n-\n-static bool\n-ref_expr_for_all_replacements_p (struct access *access, tree agg,\n-\t\t\t\t HOST_WIDE_INT top_offset)\n-{\n-  do\n-    {\n-      if (access->grp_to_be_replaced\n-\t  && !build_ref_for_offset (NULL, TREE_TYPE (agg),\n-\t\t\t\t    access->offset - top_offset,\n-\t\t\t\t    access->type, false))\n-\treturn false;\n-\n-      if (access->first_child\n-\t  && !ref_expr_for_all_replacements_p (access->first_child, agg,\n-\t\t\t\t\t       top_offset))\n-\treturn false;\n-\n-      access = access->next_sibling;\n-    }\n-  while (access);\n-\n-  return true;\n-}\n-\n /* Generate statements copying scalar replacements of accesses within a subtree\n    into or out of AGG.  ACCESS is the first child of the root of the subtree to\n    be processed.  AGG is an aggregate type expression (can be a declaration but\n-   does not have to be, it can for example also be an indirect_ref).\n-   TOP_OFFSET is the offset of the processed subtree which has to be subtracted\n-   from offsets of individual accesses to get corresponding offsets for AGG.\n-   If CHUNK_SIZE is non-null, copy only replacements in the interval\n-   <start_offset, start_offset + chunk_size>, otherwise copy all.  GSI is a\n-   statement iterator used to place the new statements.  WRITE should be true\n-   when the statements should write from AGG to the replacement and false if\n-   vice versa.  if INSERT_AFTER is true, new statements will be added after the\n-   current statement in GSI, they will be added before the statement\n-   otherwise.  */\n+   does not have to be, it can for example also be a mem_ref or a series of\n+   handled components).  TOP_OFFSET is the offset of the processed subtree\n+   which has to be subtracted from offsets of individual accesses to get\n+   corresponding offsets for AGG.  If CHUNK_SIZE is non-null, copy only\n+   replacements in the interval <start_offset, start_offset + chunk_size>,\n+   otherwise copy all.  GSI is a statement iterator used to place the new\n+   statements.  WRITE should be true when the statements should write from AGG\n+   to the replacement and false if vice versa.  if INSERT_AFTER is true, new\n+   statements will be added after the current statement in GSI, they will be\n+   added before the statement otherwise.  */\n \n static void\n generate_subtree_copies (struct access *access, tree agg,\n@@ -2176,23 +2191,18 @@ generate_subtree_copies (struct access *access, tree agg,\n {\n   do\n     {\n-      tree expr = agg;\n-\n       if (chunk_size && access->offset >= start_offset + chunk_size)\n \treturn;\n \n       if (access->grp_to_be_replaced\n \t  && (chunk_size == 0\n \t      || access->offset + access->size > start_offset))\n \t{\n-\t  tree repl = get_access_replacement (access);\n-\t  bool ref_found;\n+\t  tree expr, repl = get_access_replacement (access);\n \t  gimple stmt;\n \n-\t  ref_found = build_ref_for_offset (&expr, TREE_TYPE (agg),\n-\t\t\t\t\t     access->offset - top_offset,\n-\t\t\t\t\t     access->type, false);\n-\t  gcc_assert (ref_found);\n+\t  expr = build_ref_for_model (agg, access->offset - top_offset,\n+\t\t\t\t      access, gsi, insert_after);\n \n \t  if (write)\n \t    {\n@@ -2329,12 +2339,10 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n          in assembler statements (see PR42398).  */\n       if (!useless_type_conversion_p (type, access->type))\n \t{\n-\t  tree ref = access->base;\n-\t  bool ok;\n+\t  tree ref;\n \n-\t  ok = build_ref_for_offset (&ref, TREE_TYPE (ref),\n-\t\t\t\t     access->offset, access->type, false);\n-\t  gcc_assert (ok);\n+\t  ref = build_ref_for_model (access->base, access->offset, access,\n+\t\t\t\t     NULL, false);\n \n \t  if (write)\n \t    {\n@@ -2458,25 +2466,11 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\t\t\t\t\t\t\t  lhs, old_gsi);\n \n \t      if (*refreshed == SRA_UDH_LEFT)\n-\t\t{\n-\t\t  bool repl_found;\n-\n-\t\t  rhs = lacc->base;\n-\t\t  repl_found = build_ref_for_offset (&rhs, TREE_TYPE (rhs),\n-\t\t\t\t\t\t     lacc->offset, lacc->type,\n-\t\t\t\t\t\t     false);\n-\t\t  gcc_assert (repl_found);\n-\t\t}\n+\t\trhs = build_ref_for_model (lacc->base, lacc->offset, lacc,\n+\t\t\t\t\t    new_gsi, true);\n \t      else\n-\t\t{\n-\t\t  bool repl_found;\n-\n-\t\t  rhs = top_racc->base;\n-\t\t  repl_found = build_ref_for_offset (&rhs,\n-\t\t\t\t\t\t     TREE_TYPE (top_racc->base),\n-\t\t\t\t\t\t     offset, lacc->type, false);\n-\t\t  gcc_assert (repl_found);\n-\t\t}\n+\t\trhs = build_ref_for_model (top_racc->base, offset, lacc,\n+\t\t\t\t\t    new_gsi, true);\n \t    }\n \n \t  stmt = gimple_build_assign (get_access_replacement (lacc), rhs);\n@@ -2633,25 +2627,18 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (lhs))\n \t      && !access_has_children_p (lacc))\n \t    {\n-\t      tree expr = lhs;\n-\t      if (build_ref_for_offset (&expr, TREE_TYPE (lhs), 0,\n-\t\t\t\t\tTREE_TYPE (rhs), false))\n-\t\t{\n-\t\t  lhs = expr;\n-\t\t  gimple_assign_set_lhs (*stmt, expr);\n-\t\t}\n+\t      lhs = build_ref_for_offset (lhs, 0, TREE_TYPE (rhs), gsi, false);\n+\t      gimple_assign_set_lhs (*stmt, lhs);\n \t    }\n \t  else if (AGGREGATE_TYPE_P (TREE_TYPE (rhs))\n+\t\t   && !contains_view_convert_expr_p (rhs)\n \t\t   && !access_has_children_p (racc))\n-\t    {\n-\t      tree expr = rhs;\n-\t      if (build_ref_for_offset (&expr, TREE_TYPE (rhs), 0,\n-\t\t\t\t\tTREE_TYPE (lhs), false))\n-\t\trhs = expr;\n-\t    }\n+\t    rhs = build_ref_for_offset (rhs, 0, TREE_TYPE (lhs), gsi, false);\n+\n \t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t    {\n-\t      rhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n+\t      rhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, TREE_TYPE (lhs),\n+\t\t\t\t     rhs);\n \t      if (is_gimple_reg_type (TREE_TYPE (lhs))\n \t\t  && TREE_CODE (lhs) != SSA_NAME)\n \t\tforce_gimple_rhs = true;\n@@ -2694,11 +2681,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \n   if (gimple_has_volatile_ops (*stmt)\n       || contains_view_convert_expr_p (rhs)\n-      || contains_view_convert_expr_p (lhs)\n-      || (access_has_children_p (racc)\n-\t  && !ref_expr_for_all_replacements_p (racc, lhs, racc->offset))\n-      || (access_has_children_p (lacc)\n-\t  && !ref_expr_for_all_replacements_p (lacc, rhs, lacc->offset)))\n+      || contains_view_convert_expr_p (lhs))\n     {\n       if (access_has_children_p (racc))\n \tgenerate_subtree_copies (racc->first_child, racc->base, 0, 0, 0,"}]}