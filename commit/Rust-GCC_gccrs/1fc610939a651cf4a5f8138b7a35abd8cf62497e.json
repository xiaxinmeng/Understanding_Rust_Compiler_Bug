{"sha": "1fc610939a651cf4a5f8138b7a35abd8cf62497e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZjNjEwOTM5YTY1MWNmNGE1ZjgxMzhiN2EzNWFiZDhjZjYyNDk3ZQ==", "commit": {"author": {"name": "Stephen M. Webb", "email": "stephen@bregmasoft.com", "date": "2001-11-22T19:19:23Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-11-22T19:19:23Z"}, "message": "list_capacity.cc: New file.\n\n\n2001-11-22  Stephen M. Webb  <stephen@bregmasoft.com>\n\n        * testsuite/23_containers/list_capacity.cc: New file.\n        * testsuite/23_containers/list_ctor.cc: New file.\n        * testsuite/23_containers/list_modifiers.cc: New file.\n        * testsuite/23_containers/list_operators.cc: New file.\n\n2001-11-22  Stephen M. Webb  <stephen@bregmasoft.com>\n\n\t* include/bits/stl_list.h: Reformatted according to C++STYLE rules.\n\t(size): Replaced nonstandard distance() call with the standard one.\n\t(transfer): Uglified to _M_transfer.\n\nFrom-SVN: r47277", "tree": {"sha": "36bc809793f598fcd022e9374735407ff34e0669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36bc809793f598fcd022e9374735407ff34e0669"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fc610939a651cf4a5f8138b7a35abd8cf62497e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc610939a651cf4a5f8138b7a35abd8cf62497e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc610939a651cf4a5f8138b7a35abd8cf62497e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc610939a651cf4a5f8138b7a35abd8cf62497e/comments", "author": null, "committer": null, "parents": [{"sha": "60f4621c9af2e74db77e26265c0e0d87431e66fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f4621c9af2e74db77e26265c0e0d87431e66fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f4621c9af2e74db77e26265c0e0d87431e66fc"}], "stats": {"total": 2453, "additions": 1799, "deletions": 654}, "files": [{"sha": "802b0bb2ffe89c90d35f8563bf4e84e74044cac2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1fc610939a651cf4a5f8138b7a35abd8cf62497e", "patch": "@@ -1,3 +1,16 @@\n+2001-11-22  Stephen M. Webb  <stephen@bregmasoft.com>\n+\n+        * testsuite/23_containers/list_capacity.cc: New file.\n+        * testsuite/23_containers/list_ctor.cc: New file.\n+        * testsuite/23_containers/list_modifiers.cc: New file.\n+        * testsuite/23_containers/list_operators.cc: New file.\n+\n+2001-11-22  Stephen M. Webb  <stephen@bregmasoft.com>\n+\n+\t* include/bits/stl_list.h: Reformatted according to C++STYLE rules.\n+\t(size): Replaced nonstandard distance() call with the standard one.\n+\t(transfer): Uglified to _M_transfer.\n+\n 2001-11-21  Paolo Carlini  <pcarlini@unitus.it>\n \n \tPR libstdc++/4548"}, {"sha": "3d787a0d5c060668b039d4cb078414a77f578bac", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 848, "deletions": 654, "changes": 1502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=1fc610939a651cf4a5f8138b7a35abd8cf62497e", "patch": "@@ -66,718 +66,912 @@\n namespace std\n {\n \n-struct _List_node_base {\n-  _List_node_base* _M_next;\n-  _List_node_base* _M_prev;\n-};\n+  struct _List_node_base\n+  {\n+    _List_node_base* _M_next;\n+    _List_node_base* _M_prev;\n+  };\n \n-template <class _Tp>\n-struct _List_node : public _List_node_base {\n-  _Tp _M_data;\n-};\n+  template<typename _Tp>\n+    struct _List_node : public _List_node_base\n+    {\n+      _Tp _M_data;\n+    };\n \n-struct _List_iterator_base {\n-  typedef size_t                     size_type;\n-  typedef ptrdiff_t                  difference_type;\n-  typedef bidirectional_iterator_tag iterator_category;\n+  struct _List_iterator_base\n+  {\n+    typedef size_t                     size_type;\n+    typedef ptrdiff_t                  difference_type;\n+    typedef bidirectional_iterator_tag iterator_category;\n \n-  _List_node_base* _M_node;\n+    _List_node_base* _M_node;\n \n-  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}\n-  _List_iterator_base() {}\n+    _List_iterator_base(_List_node_base* __x)\n+    : _M_node(__x)\n+    { }\n \n-  void _M_incr() { _M_node = _M_node->_M_next; }\n-  void _M_decr() { _M_node = _M_node->_M_prev; }\n+    _List_iterator_base()\n+    { }\n \n-  bool operator==(const _List_iterator_base& __x) const {\n-    return _M_node == __x._M_node;\n-  }\n-  bool operator!=(const _List_iterator_base& __x) const {\n-    return _M_node != __x._M_node;\n-  }\n-};  \n+    void\n+    _M_incr()\n+    { _M_node = _M_node->_M_next; }\n \n-template<class _Tp, class _Ref, class _Ptr>\n-struct _List_iterator : public _List_iterator_base {\n-  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-  typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n+    void\n+    _M_decr()\n+    { _M_node = _M_node->_M_prev; }\n \n-  typedef _Tp value_type;\n-  typedef _Ptr pointer;\n-  typedef _Ref reference;\n-  typedef _List_node<_Tp> _Node;\n+    bool\n+    operator==(const _List_iterator_base& __x) const\n+    { return _M_node == __x._M_node; }\n \n-  _List_iterator(_Node* __x) : _List_iterator_base(__x) {}\n-  _List_iterator() {}\n-  _List_iterator(const iterator& __x) : _List_iterator_base(__x._M_node) {}\n+    bool\n+    operator!=(const _List_iterator_base& __x) const\n+    { return _M_node != __x._M_node; }\n+  };  \n \n-  reference operator*() const { return ((_Node*) _M_node)->_M_data; }\n-  pointer operator->() const { return &(operator*()); }\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n+    struct _List_iterator : public _List_iterator_base\n+    {\n+      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+      typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n \n-  _Self& operator++() { \n-    this->_M_incr();\n-    return *this;\n-  }\n-  _Self operator++(int) { \n-    _Self __tmp = *this;\n-    this->_M_incr();\n-    return __tmp;\n-  }\n-  _Self& operator--() { \n-    this->_M_decr();\n-    return *this;\n-  }\n-  _Self operator--(int) { \n-    _Self __tmp = *this;\n-    this->_M_decr();\n-    return __tmp;\n-  }\n-};\n-\n-\n-// Base class that encapsulates details of allocators.  Three cases:\n-// an ordinary standard-conforming allocator, a standard-conforming\n-// allocator with no non-static data, and an SGI-style allocator.\n-// This complexity is necessary only because we're worrying about backward\n-// compatibility and because we want to avoid wasting storage on an \n-// allocator instance if it isn't necessary.\n-\n-\n-// Base for general standard-conforming allocators.\n-template <class _Tp, class _Allocator, bool _IsStatic>\n-class _List_alloc_base {\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return _Node_allocator; }\n-\n-  _List_alloc_base(const allocator_type& __a) : _Node_allocator(__a) {}\n-\n-protected:\n-  _List_node<_Tp>* _M_get_node()\n-   { return _Node_allocator.allocate(1); }\n-  void _M_put_node(_List_node<_Tp>* __p)\n-    { _Node_allocator.deallocate(__p, 1); }\n-\n-protected:\n-  typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n-           _Node_allocator;\n-  _List_node<_Tp>* _M_node;\n-};\n-\n-// Specialization for instanceless allocators.\n-\n-template <class _Tp, class _Allocator>\n-class _List_alloc_base<_Tp, _Allocator, true> {\n-public:\n-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n-          allocator_type;\n-  allocator_type get_allocator() const { return allocator_type(); }\n-\n-  _List_alloc_base(const allocator_type&) {}\n-\n-protected:\n-  typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n-          _Alloc_type;\n-  _List_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }\n-  void _M_put_node(_List_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }\n-\n-protected:\n-  _List_node<_Tp>* _M_node;\n-};\n-\n-template <class _Tp, class _Alloc>\n-class _List_base \n-  : public _List_alloc_base<_Tp, _Alloc,\n-                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-{\n-public:\n-  typedef _List_alloc_base<_Tp, _Alloc,\n-                           _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n-          _Base; \n-  typedef typename _Base::allocator_type allocator_type;\n-\n-  _List_base(const allocator_type& __a) : _Base(__a) {\n-    _M_node = _M_get_node();\n-    _M_node->_M_next = _M_node;\n-    _M_node->_M_prev = _M_node;\n-  }\n-  ~_List_base() {\n-    clear();\n-    _M_put_node(_M_node);\n-  }\n+      typedef _Tp value_type;\n+      typedef _Ptr pointer;\n+      typedef _Ref reference;\n+      typedef _List_node<_Tp> _Node;\n \n-  void clear();\n-};\n+      _List_iterator(_Node* __x)\n+      : _List_iterator_base(__x)\n+      { }\n \n+      _List_iterator()\n+      { }\n \n-template <class _Tp, class _Alloc>\n-void \n-_List_base<_Tp,_Alloc>::clear() \n-{\n-  _List_node<_Tp>* __cur = (_List_node<_Tp>*) _M_node->_M_next;\n-  while (__cur != _M_node) {\n-    _List_node<_Tp>* __tmp = __cur;\n-    __cur = (_List_node<_Tp>*) __cur->_M_next;\n-    _Destroy(&__tmp->_M_data);\n-    _M_put_node(__tmp);\n-  }\n-  _M_node->_M_next = _M_node;\n-  _M_node->_M_prev = _M_node;\n-}\n+      _List_iterator(const iterator& __x)\n+      : _List_iterator_base(__x._M_node)\n+      { }\n \n-template <class _Tp, class _Alloc = allocator<_Tp> >\n-class list : protected _List_base<_Tp, _Alloc>\n-{\n-  // concept requirements\n-  __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-\n-  typedef _List_base<_Tp, _Alloc> _Base;\n-protected:\n-  typedef void* _Void_pointer;\n-\n-public:      \n-  typedef _Tp value_type;\n-  typedef value_type* pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n-  typedef _List_node<_Tp> _Node;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n-\n-public:\n-  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-\n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator>       reverse_iterator;\n-\n-protected:\n-  using _Base::_M_node;\n-  using _Base::_M_put_node;\n-  using _Base::_M_get_node;\n-\n-protected:\n-  _Node* _M_create_node(const _Tp& __x)\n-  {\n-    _Node* __p = _M_get_node();\n-    try {\n-      _Construct(&__p->_M_data, __x);\n-    }\n-    catch(...)\n+      reference\n+      operator*() const\n+      { return ((_Node*) _M_node)->_M_data; }\n+\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+\n+      _Self&\n+      operator++()\n       { \n-\t_M_put_node(__p);\n-\t__throw_exception_again; \n+        this->_M_incr();\n+        return *this;\n       }\n-    return __p;\n-  }\n \n-  _Node* _M_create_node()\n-  {\n-    _Node* __p = _M_get_node();\n-    try {\n-      _Construct(&__p->_M_data);\n-    }\n-    catch(...)\n+      _Self\n+      operator++(int)\n       { \n-\t_M_put_node(__p);\n-\t__throw_exception_again; \n+        _Self __tmp = *this;\n+        this->_M_incr();\n+        return __tmp;\n       }\n-    return __p;\n-  }\n \n-public:\n-  explicit list(const allocator_type& __a = allocator_type()) : _Base(__a) {}\n+      _Self&\n+      operator--()\n+      { \n+        this->_M_decr();\n+        return *this;\n+      }\n \n-  iterator begin()             { return (_Node*)(_M_node->_M_next); }\n-  const_iterator begin() const { return (_Node*)(_M_node->_M_next); }\n+      _Self\n+      operator--(int)\n+      { \n+        _Self __tmp = *this;\n+        this->_M_decr();\n+        return __tmp;\n+      }\n+    };\n+\n+\n+  // Base class that encapsulates details of allocators.  Three cases:\n+  // an ordinary standard-conforming allocator, a standard-conforming\n+  // allocator with no non-static data, and an SGI-style allocator.\n+  // This complexity is necessary only because we're worrying about backward\n+  // compatibility and because we want to avoid wasting storage on an \n+  // allocator instance if it isn't necessary.\n+\n+\n+  // Base for general standard-conforming allocators.\n+  template<typename _Tp, typename _Allocator, bool _IsStatic>\n+    class _List_alloc_base\n+    {\n+    public:\n+      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+              allocator_type;\n+\n+      allocator_type\n+      get_allocator() const\n+      { return _Node_allocator; }\n+\n+      _List_alloc_base(const allocator_type& __a)\n+      : _Node_allocator(__a)\n+      { }\n+\n+    protected:\n+      _List_node<_Tp>*\n+      _M_get_node()\n+      { return _Node_allocator.allocate(1); }\n+\n+      void\n+      _M_put_node(_List_node<_Tp>* __p)\n+      { _Node_allocator.deallocate(__p, 1); }\n+\n+    protected:\n+      typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n+               _Node_allocator;\n+\n+      _List_node<_Tp>* _M_node;\n+    };\n+\n+  // Specialization for instanceless allocators.\n+\n+  template<typename _Tp, typename _Allocator>\n+    class _List_alloc_base<_Tp, _Allocator, true>\n+    {\n+    public:\n+      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type\n+              allocator_type;\n+\n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(); }\n+\n+      _List_alloc_base(const allocator_type&)\n+      { }\n+\n+    protected:\n+      typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type\n+              _Alloc_type;\n+\n+      _List_node<_Tp>*\n+      _M_get_node()\n+      { return _Alloc_type::allocate(1); }\n+\n+      void\n+      _M_put_node(_List_node<_Tp>* __p)\n+      { _Alloc_type::deallocate(__p, 1); }\n+\n+    protected:\n+      _List_node<_Tp>* _M_node;\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    class _List_base \n+      : public _List_alloc_base<_Tp, _Alloc,\n+                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+    {\n+    public:\n+      typedef _List_alloc_base<_Tp, _Alloc,\n+                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n+              _Base; \n+      typedef typename _Base::allocator_type allocator_type;\n+\n+      _List_base(const allocator_type& __a)\n+      : _Base(__a)\n+      {\n+        _M_node = _M_get_node();\n+        _M_node->_M_next = _M_node;\n+        _M_node->_M_prev = _M_node;\n+      }\n \n-  iterator end()             { return _M_node; }\n-  const_iterator end() const { return _M_node; }\n+      ~_List_base()\n+      {\n+        clear();\n+        _M_put_node(_M_node);\n+      }\n \n-  reverse_iterator rbegin() \n-    { return reverse_iterator(end()); }\n-  const_reverse_iterator rbegin() const \n-    { return const_reverse_iterator(end()); }\n+      void clear();\n+    };\n+\n+\n+  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n+    class list : protected _List_base<_Tp, _Alloc>\n+    {\n+      // concept requirements\n+      __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n+\n+      typedef _List_base<_Tp, _Alloc> _Base;\n+    protected:\n+      typedef void* _Void_pointer;\n+\n+    public:      \n+      typedef _Tp value_type;\n+      typedef value_type* pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type& reference;\n+      typedef const value_type& const_reference;\n+      typedef _List_node<_Tp> _Node;\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+\n+      typedef typename _Base::allocator_type allocator_type;\n+\n+      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+\n+      typedef reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef reverse_iterator<iterator>       reverse_iterator;\n+\n+    protected:\n+      using _Base::_M_node;\n+      using _Base::_M_put_node;\n+      using _Base::_M_get_node;\n+\n+    protected:\n+      _Node*\n+      _M_create_node(const _Tp& __x)\n+      {\n+        _Node* __p = _M_get_node();\n+        try {\n+          _Construct(&__p->_M_data, __x);\n+        }\n+        catch(...)\n+        { \n+          _M_put_node(__p);\n+          __throw_exception_again; \n+        }\n+        return __p;\n+      }\n \n-  reverse_iterator rend()\n-    { return reverse_iterator(begin()); }\n-  const_reverse_iterator rend() const\n-    { return const_reverse_iterator(begin()); }\n+      _Node*\n+      _M_create_node()\n+      {\n+        _Node* __p = _M_get_node();\n+        try {\n+          _Construct(&__p->_M_data);\n+        }\n+        catch(...)\n+        { \n+          _M_put_node(__p);\n+          __throw_exception_again; \n+        }\n+        return __p;\n+      }\n \n-  bool empty() const { return _M_node->_M_next == _M_node; }\n-  size_type size() const {\n-    size_type __result = 0;\n-    distance(begin(), end(), __result);\n-    return __result;\n-  }\n-  size_type max_size() const { return size_type(-1); }\n-\n-  reference front() { return *begin(); }\n-  const_reference front() const { return *begin(); }\n-  reference back() { return *(--end()); }\n-  const_reference back() const { return *(--end()); }\n-\n-  void swap(list<_Tp, _Alloc>& __x) { std::swap(_M_node, __x._M_node); }\n-\n-  iterator insert(iterator __position, const _Tp& __x) {\n-    _Node* __tmp = _M_create_node(__x);\n-    __tmp->_M_next = __position._M_node;\n-    __tmp->_M_prev = __position._M_node->_M_prev;\n-    __position._M_node->_M_prev->_M_next = __tmp;\n-    __position._M_node->_M_prev = __tmp;\n-    return __tmp;\n-  }\n-  iterator insert(iterator __position) { return insert(__position, _Tp()); }\n+    public:\n+      allocator_type\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n+\n+      explicit\n+      list(const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n+      { }\n+\n+      iterator\n+      begin()\n+      { return static_cast<_Node*>(_M_node->_M_next); }\n+\n+      const_iterator\n+      begin() const\n+      { return static_cast<_Node*>(_M_node->_M_next); }\n+\n+      iterator\n+      end()\n+      { return _M_node; }\n+\n+      const_iterator\n+      end() const\n+      { return _M_node; }\n+\n+      reverse_iterator\n+      rbegin() \n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const \n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+      bool\n+      empty() const\n+      { return _M_node->_M_next == _M_node; }\n+\n+      size_type\n+      size() const\n+      { return distance(begin(), end()); }\n+\n+      size_type\n+      max_size() const\n+      { return size_type(-1); }\n+\n+      reference\n+      front()\n+      { return *begin(); }\n+\n+      const_reference\n+      front() const\n+      { return *begin(); }\n+\n+      reference\n+      back()\n+      { return *(--end()); }\n+\n+      const_reference\n+      back() const\n+      { return *(--end()); }\n+\n+      void\n+      swap(list<_Tp, _Alloc>& __x)\n+      { std::swap(_M_node, __x._M_node); }\n+\n+      iterator\n+      insert(iterator __position, const _Tp& __x)\n+      {\n+        _Node* __tmp = _M_create_node(__x);\n+        __tmp->_M_next = __position._M_node;\n+        __tmp->_M_prev = __position._M_node->_M_prev;\n+        __position._M_node->_M_prev->_M_next = __tmp;\n+        __position._M_node->_M_prev = __tmp;\n+        return __tmp;\n+      }\n \n-  // Check whether it's an integral type.  If so, it's not an iterator.\n-  template<class _Integer>\n-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                          __true_type) {\n-    _M_fill_insert(__pos, (size_type) __n, (_Tp) __x);\n-  }\n+      iterator\n+      insert(iterator __position)\n+      { return insert(__position, _Tp()); }\n+\n+      // Check whether it's an integral type.  If so, it's not an iterator.\n+      template<typename _Integer>\n+        void\n+        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n+        { _M_fill_insert(__pos, (size_type) __n, (_Tp) __x); }\n+\n+      template<typename _InputIterator>\n+        void\n+        _M_insert_dispatch(iterator __pos,\n+                           _InputIterator __first, _InputIterator __last,\n+                           __false_type);\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+        {\n+          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+          _M_insert_dispatch(__pos, __first, __last, _Integral());\n+        }\n+\n+      void\n+      insert(iterator __pos, size_type __n, const _Tp& __x)\n+      { _M_fill_insert(__pos, __n, __x); }\n+\n+      void\n+      _M_fill_insert(iterator __pos, size_type __n, const _Tp& __x); \n+\n+      void\n+      push_front(const _Tp& __x)\n+      { insert(begin(), __x); }\n+\n+      void\n+      push_front()\n+      { insert(begin()); }\n+\n+      void\n+      push_back(const _Tp& __x)\n+      { insert(end(), __x); }\n+\n+      void\n+      push_back()\n+      { insert(end()); }\n+\n+      iterator\n+      erase(iterator __position)\n+      {\n+        _List_node_base* __next_node = __position._M_node->_M_next;\n+        _List_node_base* __prev_node = __position._M_node->_M_prev;\n+        _Node* __n = static_cast<_Node*>(__position._M_node);\n+        __prev_node->_M_next = __next_node;\n+        __next_node->_M_prev = __prev_node;\n+        _Destroy(&__n->_M_data);\n+        _M_put_node(__n);\n+        return iterator(static_cast<_Node*>(__next_node));\n+      }\n \n-  template <class _InputIterator>\n-  void _M_insert_dispatch(iterator __pos,\n-                          _InputIterator __first, _InputIterator __last,\n-                          __false_type);\n+      iterator\n+      erase(iterator __first, iterator __last);\n \n-  template <class _InputIterator>\n-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_insert_dispatch(__pos, __first, __last, _Integral());\n-  }\n+      void\n+      clear()\n+      { _Base::clear(); }\n \n-  void insert(iterator __pos, size_type __n, const _Tp& __x)\n-    { _M_fill_insert(__pos, __n, __x); }\n-  void _M_fill_insert(iterator __pos, size_type __n, const _Tp& __x); \n-\n-  void push_front(const _Tp& __x) { insert(begin(), __x); }\n-  void push_front() {insert(begin());}\n-  void push_back(const _Tp& __x) { insert(end(), __x); }\n-  void push_back() {insert(end());}\n-\n-  iterator erase(iterator __position) {\n-    _List_node_base* __next_node = __position._M_node->_M_next;\n-    _List_node_base* __prev_node = __position._M_node->_M_prev;\n-    _Node* __n = (_Node*) __position._M_node;\n-    __prev_node->_M_next = __next_node;\n-    __next_node->_M_prev = __prev_node;\n-    _Destroy(&__n->_M_data);\n-    _M_put_node(__n);\n-    return iterator((_Node*) __next_node);\n-  }\n-  iterator erase(iterator __first, iterator __last);\n-  void clear() { _Base::clear(); }\n+      void\n+      resize(size_type __new_size, const _Tp& __x);\n+      \n+      void\n+      resize(size_type __new_size)\n+      { this->resize(__new_size, _Tp()); }\n \n-  void resize(size_type __new_size, const _Tp& __x);\n-  void resize(size_type __new_size) { this->resize(__new_size, _Tp()); }\n+      void\n+      pop_front()\n+      { erase(begin()); }\n \n-  void pop_front() { erase(begin()); }\n-  void pop_back() { \n-    iterator __tmp = end();\n-    erase(--__tmp);\n-  }\n-  list(size_type __n, const _Tp& __value,\n-       const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    { insert(begin(), __n, __value); }\n-  explicit list(size_type __n)\n-    : _Base(allocator_type())\n-    { insert(begin(), __n, _Tp()); }\n-\n-  // We don't need any dispatching tricks here, because insert does all of\n-  // that anyway.  \n-  template <class _InputIterator>\n-  list(_InputIterator __first, _InputIterator __last,\n-       const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-    { insert(begin(), __first, __last); }\n-\n-  list(const list<_Tp, _Alloc>& __x) : _Base(__x.get_allocator())\n-    { insert(begin(), __x.begin(), __x.end()); }\n-\n-  ~list() { }\n-\n-  list<_Tp, _Alloc>& operator=(const list<_Tp, _Alloc>& __x);\n-\n-public:\n-  // assign(), a generalized assignment member function.  Two\n-  // versions: one that takes a count, and one that takes a range.\n-  // The range version is a member template, so we dispatch on whether\n-  // or not the type is an integer.\n-\n-  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n-\n-  void _M_fill_assign(size_type __n, const _Tp& __val);\n-\n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n+      void\n+      pop_back()\n+      { \n+        iterator __tmp = end();\n+        erase(--__tmp);\n+      }\n+\n+      list(size_type __n, const _Tp& __value,\n+           const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n+      { insert(begin(), __n, __value); }\n+\n+      explicit\n+      list(size_type __n)\n+      : _Base(allocator_type())\n+      { insert(begin(), __n, _Tp()); }\n+\n+      // We don't need any dispatching tricks here, because insert does all of\n+      // that anyway.  \n+      template<typename _InputIterator>\n+      list(_InputIterator __first, _InputIterator __last,\n+           const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n+      { insert(begin(), __first, __last); }\n+\n+      list(const list<_Tp, _Alloc>& __x)\n+      : _Base(__x.get_allocator())\n+      { insert(begin(), __x.begin(), __x.end()); }\n+\n+      ~list()\n+      { }\n+\n+      list<_Tp, _Alloc>&\n+      operator=(const list<_Tp, _Alloc>& __x);\n+\n+    public:\n+      // assign(), a generalized assignment member function.  Two\n+      // versions: one that takes a count, and one that takes a range.\n+      // The range version is a member template, so we dispatch on whether\n+      // or not the type is an integer.\n+\n+      void\n+      assign(size_type __n, const _Tp& __val)\n+      { _M_fill_assign(__n, __val); }\n+\n+      void\n+      _M_fill_assign(size_type __n, const _Tp& __val);\n+\n+      template<typename _InputIterator>\n+        void\n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+          _M_assign_dispatch(__first, __last, _Integral());\n+        }\n+\n+      template<typename _Integer>\n+        void\n+        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+        { _M_fill_assign((size_type) __n, (_Tp) __val); }\n+\n+      template<typename _InputIterator>\n+        void\n+        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+                           __false_type);\n+\n+    protected:\n+      void\n+      _M_transfer(iterator __position, iterator __first, iterator __last)\n+      {\n+        if (__position != __last) {\n+          // Remove [first, last) from its old position.\n+          __last._M_node->_M_prev->_M_next     = __position._M_node;\n+          __first._M_node->_M_prev->_M_next    = __last._M_node;\n+          __position._M_node->_M_prev->_M_next = __first._M_node; \n+\n+          // Splice [first, last) into its new position.\n+          _List_node_base* __tmp      = __position._M_node->_M_prev;\n+          __position._M_node->_M_prev = __last._M_node->_M_prev;\n+          __last._M_node->_M_prev     = __first._M_node->_M_prev; \n+          __first._M_node->_M_prev    = __tmp;\n+        }\n+      }\n+\n+    public:\n+      void\n+      splice(iterator __position, list& __x)\n+      {\n+        if (!__x.empty()) \n+          this->_M_transfer(__position, __x.begin(), __x.end());\n+      }\n+\n+      void\n+      splice(iterator __position, list&, iterator __i)\n+      {\n+        iterator __j = __i;\n+        ++__j;\n+        if (__position == __i || __position == __j) return;\n+        this->_M_transfer(__position, __i, __j);\n+      }\n+\n+      void\n+      splice(iterator __position, list&, iterator __first, iterator __last)\n+      {\n+        if (__first != __last) \n+          this->_M_transfer(__position, __first, __last);\n+      }\n+\n+      void\n+      remove(const _Tp& __value);\n+\n+      void\n+      unique();\n+\n+      void\n+      merge(list& __x);\n+\n+      void\n+      reverse();\n+\n+      void\n+      sort();\n+\n+      template<typename _Predicate>\n+        void\n+        remove_if(_Predicate);\n+\n+      template<typename _BinaryPredicate>\n+        void\n+        unique(_BinaryPredicate);\n+\n+      template<typename _StrictWeakOrdering>\n+        void\n+        merge(list&, _StrictWeakOrdering);\n \n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_type) __n, (_Tp) __val); }\n-\n-  template <class _InputIterator>\n-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-                          __false_type);\n-\n-protected:\n-  void transfer(iterator __position, iterator __first, iterator __last) {\n-    if (__position != __last) {\n-      // Remove [first, last) from its old position.\n-      __last._M_node->_M_prev->_M_next     = __position._M_node;\n-      __first._M_node->_M_prev->_M_next    = __last._M_node;\n-      __position._M_node->_M_prev->_M_next = __first._M_node; \n-\n-      // Splice [first, last) into its new position.\n-      _List_node_base* __tmp      = __position._M_node->_M_prev;\n-      __position._M_node->_M_prev = __last._M_node->_M_prev;\n-      __last._M_node->_M_prev     = __first._M_node->_M_prev; \n-      __first._M_node->_M_prev    = __tmp;\n+      template<typename _StrictWeakOrdering>\n+        void\n+        sort(_StrictWeakOrdering);\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool \n+    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    {\n+      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n+      const_iterator __end1 = __x.end();\n+      const_iterator __end2 = __y.end();\n+\n+      const_iterator __i1 = __x.begin();\n+      const_iterator __i2 = __y.begin();\n+      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n+        ++__i1;\n+        ++__i2;\n+      }\n+      return __i1 == __end1 && __i2 == __end2;\n     }\n-  }\n \n-public:\n-  void splice(iterator __position, list& __x) {\n-    if (!__x.empty()) \n-      this->transfer(__position, __x.begin(), __x.end());\n-  }\n-  void splice(iterator __position, list&, iterator __i) {\n-    iterator __j = __i;\n-    ++__j;\n-    if (__position == __i || __position == __j) return;\n-    this->transfer(__position, __i, __j);\n-  }\n-  void splice(iterator __position, list&, iterator __first, iterator __last) {\n-    if (__first != __last) \n-      this->transfer(__position, __first, __last);\n-  }\n-  void remove(const _Tp& __value);\n-  void unique();\n-  void merge(list& __x);\n-  void reverse();\n-  void sort();\n-\n-  template <class _Predicate> void remove_if(_Predicate);\n-  template <class _BinaryPredicate> void unique(_BinaryPredicate);\n-  template <class _StrictWeakOrdering> void merge(list&, _StrictWeakOrdering);\n-  template <class _StrictWeakOrdering> void sort(_StrictWeakOrdering);\n-};\n-\n-template <class _Tp, class _Alloc>\n-inline bool \n-operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n-{\n-  typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n-  const_iterator __end1 = __x.end();\n-  const_iterator __end2 = __y.end();\n-\n-  const_iterator __i1 = __x.begin();\n-  const_iterator __i2 = __y.begin();\n-  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n-    ++__i1;\n-    ++__i2;\n-  }\n-  return __i1 == __end1 && __i2 == __end2;\n-}\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    {\n+      return lexicographical_compare(__x.begin(), __x.end(),\n+                                     __y.begin(), __y.end());\n+    }\n \n-template <class _Tp, class _Alloc>\n-inline bool operator<(const list<_Tp,_Alloc>& __x,\n-                      const list<_Tp,_Alloc>& __y)\n-{\n-  return lexicographical_compare(__x.begin(), __x.end(),\n-                                 __y.begin(), __y.end());\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool operator!=(const list<_Tp,_Alloc>& __x,\n-                       const list<_Tp,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool operator>(const list<_Tp,_Alloc>& __x,\n-                      const list<_Tp,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool operator<=(const list<_Tp,_Alloc>& __x,\n-                       const list<_Tp,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline bool operator>=(const list<_Tp,_Alloc>& __x,\n-                       const list<_Tp,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline void \n-swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n-{\n-  __x.swap(__y);\n-}\n-\n-template <class _Tp, class _Alloc> template <class _InputIter>\n-void \n-list<_Tp, _Alloc>::_M_insert_dispatch(iterator __position,\n-                                      _InputIter __first, _InputIter __last,\n-                                      __false_type)\n-{\n-  for ( ; __first != __last; ++__first)\n-    insert(__position, *__first);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void \n-list<_Tp, _Alloc>::_M_fill_insert(iterator __position,\n-                                  size_type __n, const _Tp& __x)\n-{\n-  for ( ; __n > 0; --__n)\n-    insert(__position, __x);\n-}\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return !(__x == __y); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return __y < __x; }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return !(__y < __x); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    { return !(__x < __y); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void \n+    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n+    { __x.swap(__y); }\n+\n+  // move these to stl_list.tcc\n+\n+  template<typename _Tp, typename _Alloc>\n+    void _List_base<_Tp,_Alloc>::\n+    clear() \n+    {\n+      _List_node<_Tp>* __cur = static_cast<_List_node<_Tp>*>(_M_node->_M_next);\n+      while (__cur != _M_node) {\n+        _List_node<_Tp>* __tmp = __cur;\n+        __cur = static_cast<_List_node<_Tp>*>(__cur->_M_next);\n+        _Destroy(&__tmp->_M_data);\n+        _M_put_node(__tmp);\n+      }\n+      _M_node->_M_next = _M_node;\n+      _M_node->_M_prev = _M_node;\n+    }\n \n-template <class _Tp, class _Alloc>\n-typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::erase(iterator __first, \n-                                                             iterator __last)\n-{\n-  while (__first != __last)\n-    erase(__first++);\n-  return __last;\n-}\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _InputIter>\n+      void list<_Tp, _Alloc>::\n+      _M_insert_dispatch(iterator __position, _InputIter __first, _InputIter __last,\n+                                            __false_type)\n+      {\n+        for ( ; __first != __last; ++__first)\n+          insert(__position, *__first);\n+      \n+      }\n \n-template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::resize(size_type __new_size, const _Tp& __x)\n-{\n-  iterator __i = begin();\n-  size_type __len = 0;\n-  for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n-    ;\n-  if (__len == __new_size)\n-    erase(__i, end());\n-  else                          // __i == end()\n-    insert(end(), __new_size - __len, __x);\n-}\n-\n-template <class _Tp, class _Alloc>\n-list<_Tp, _Alloc>& list<_Tp, _Alloc>::operator=(const list<_Tp, _Alloc>& __x)\n-{\n-  if (this != &__x) {\n-    iterator __first1 = begin();\n-    iterator __last1 = end();\n-    const_iterator __first2 = __x.begin();\n-    const_iterator __last2 = __x.end();\n-    while (__first1 != __last1 && __first2 != __last2) \n-      *__first1++ = *__first2++;\n-    if (__first2 == __last2)\n-      erase(__first1, __last1);\n-    else\n-      insert(__last1, __first2, __last2);\n-  }\n-  return *this;\n-}\n-\n-template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n-  iterator __i = begin();\n-  for ( ; __i != end() && __n > 0; ++__i, --__n)\n-    *__i = __val;\n-  if (__n > 0)\n-    insert(end(), __n, __val);\n-  else\n-    erase(__i, end());\n-}\n-\n-template <class _Tp, class _Alloc> template <class _InputIter>\n-void\n-list<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first2, _InputIter __last2,\n-                                      __false_type)\n-{\n-  iterator __first1 = begin();\n-  iterator __last1 = end();\n-  for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n-    *__first1 = *__first2;\n-  if (__first2 == __last2)\n-    erase(__first1, __last1);\n-  else\n-    insert(__last1, __first2, __last2);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::remove(const _Tp& __value)\n-{\n-  iterator __first = begin();\n-  iterator __last = end();\n-  while (__first != __last) {\n-    iterator __next = __first;\n-    ++__next;\n-    if (*__first == __value) erase(__first);\n-    __first = __next;\n-  }\n-}\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    _M_fill_insert(iterator __position, size_type __n, const _Tp& __x)\n+    {\n+      for ( ; __n > 0; --__n)\n+        insert(__position, __x);\n+    }\n \n-template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::unique()\n-{\n-  iterator __first = begin();\n-  iterator __last = end();\n-  if (__first == __last) return;\n-  iterator __next = __first;\n-  while (++__next != __last) {\n-    if (*__first == *__next)\n-      erase(__next);\n-    else\n-      __first = __next;\n-    __next = __first;\n-  }\n-}\n+  template<typename _Tp, typename _Alloc>\n+    typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::\n+    erase(iterator __first, iterator __last)\n+    {\n+      while (__first != __last)\n+        erase(__first++);\n+      return __last;\n+    }\n \n-template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x)\n-{\n-  iterator __first1 = begin();\n-  iterator __last1 = end();\n-  iterator __first2 = __x.begin();\n-  iterator __last2 = __x.end();\n-  while (__first1 != __last1 && __first2 != __last2)\n-    if (*__first2 < *__first1) {\n-      iterator __next = __first2;\n-      transfer(__first1, __first2, ++__next);\n-      __first2 = __next;\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    resize(size_type __new_size, const _Tp& __x)\n+    {\n+      iterator __i = begin();\n+      size_type __len = 0;\n+      for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n+        ;\n+      if (__len == __new_size)\n+        erase(__i, end());\n+      else                          // __i == end()\n+        insert(end(), __new_size - __len, __x);\n     }\n-    else\n-      ++__first1;\n-  if (__first2 != __last2) transfer(__last1, __first2, __last2);\n-}\n \n-inline void __List_base_reverse(_List_node_base* __p)\n-{\n-  _List_node_base* __tmp = __p;\n-  do {\n-    std::swap(__tmp->_M_next, __tmp->_M_prev);\n-    __tmp = __tmp->_M_prev;     // Old next node is now prev.\n-  } while (__tmp != __p);\n-}\n-\n-template <class _Tp, class _Alloc>\n-inline void list<_Tp, _Alloc>::reverse() \n-{\n-  __List_base_reverse(this->_M_node);\n-}    \n+  template<typename _Tp, typename _Alloc>\n+    list<_Tp, _Alloc>& list<_Tp, _Alloc>::\n+    operator=(const list<_Tp, _Alloc>& __x)\n+    {\n+      if (this != &__x) {\n+        iterator __first1 = begin();\n+        iterator __last1 = end();\n+        const_iterator __first2 = __x.begin();\n+        const_iterator __last2 = __x.end();\n+        while (__first1 != __last1 && __first2 != __last2) \n+          *__first1++ = *__first2++;\n+        if (__first2 == __last2)\n+          erase(__first1, __last1);\n+        else\n+          insert(__last1, __first2, __last2);\n+      }\n+      return *this;\n+    }\n \n-template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::sort()\n-{\n-  // Do nothing if the list has length 0 or 1.\n-  if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n-    list<_Tp, _Alloc> __carry;\n-    list<_Tp, _Alloc> __counter[64];\n-    int __fill = 0;\n-    while (!empty()) {\n-      __carry.splice(__carry.begin(), *this, begin());\n-      int __i = 0;\n-      while(__i < __fill && !__counter[__i].empty()) {\n-        __counter[__i].merge(__carry);\n-        __carry.swap(__counter[__i++]);\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    _M_fill_assign(size_type __n, const _Tp& __val) {\n+      iterator __i = begin();\n+      for ( ; __i != end() && __n > 0; ++__i, --__n)\n+        *__i = __val;\n+      if (__n > 0)\n+        insert(end(), __n, __val);\n+      else\n+        erase(__i, end());\n+    }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _InputIter>\n+      void list<_Tp, _Alloc>::\n+      _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n+      {\n+        iterator __first1 = begin();\n+        iterator __last1 = end();\n+        for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+          *__first1 = *__first2;\n+        if (__first2 == __last2)\n+          erase(__first1, __last1);\n+        else\n+          insert(__last1, __first2, __last2);\n       }\n-      __carry.swap(__counter[__i]);         \n-      if (__i == __fill) ++__fill;\n-    } \n \n-    for (int __i = 1; __i < __fill; ++__i)\n-      __counter[__i].merge(__counter[__i-1]);\n-    swap(__counter[__fill-1]);\n-  }\n-}\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    remove(const _Tp& __value)\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      while (__first != __last) {\n+        iterator __next = __first;\n+        ++__next;\n+        if (*__first == __value) erase(__first);\n+        __first = __next;\n+      }\n+    }\n \n-template <class _Tp, class _Alloc> template <class _Predicate>\n-void list<_Tp, _Alloc>::remove_if(_Predicate __pred)\n-{\n-  iterator __first = begin();\n-  iterator __last = end();\n-  while (__first != __last) {\n-    iterator __next = __first;\n-    ++__next;\n-    if (__pred(*__first)) erase(__first);\n-    __first = __next;\n-  }\n-}\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    unique()\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      if (__first == __last) return;\n+      iterator __next = __first;\n+      while (++__next != __last) {\n+        if (*__first == *__next)\n+          erase(__next);\n+        else\n+          __first = __next;\n+        __next = __first;\n+      }\n+    }\n \n-template <class _Tp, class _Alloc> template <class _BinaryPredicate>\n-void list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)\n-{\n-  iterator __first = begin();\n-  iterator __last = end();\n-  if (__first == __last) return;\n-  iterator __next = __first;\n-  while (++__next != __last) {\n-    if (__binary_pred(*__first, *__next))\n-      erase(__next);\n-    else\n-      __first = __next;\n-    __next = __first;\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    merge(list<_Tp, _Alloc>& __x)\n+    {\n+      iterator __first1 = begin();\n+      iterator __last1 = end();\n+      iterator __first2 = __x.begin();\n+      iterator __last2 = __x.end();\n+      while (__first1 != __last1 && __first2 != __last2)\n+        if (*__first2 < *__first1) {\n+          iterator __next = __first2;\n+          _M_transfer(__first1, __first2, ++__next);\n+          __first2 = __next;\n+        }\n+        else\n+          ++__first1;\n+      if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n+    }\n+\n+  inline void\n+  __List_base_reverse(_List_node_base* __p)\n+  {\n+    _List_node_base* __tmp = __p;\n+    do {\n+      std::swap(__tmp->_M_next, __tmp->_M_prev);\n+      __tmp = __tmp->_M_prev;     // Old next node is now prev.\n+    } while (__tmp != __p);\n   }\n-}\n \n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n-void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x,\n-                              _StrictWeakOrdering __comp)\n-{\n-  iterator __first1 = begin();\n-  iterator __last1 = end();\n-  iterator __first2 = __x.begin();\n-  iterator __last2 = __x.end();\n-  while (__first1 != __last1 && __first2 != __last2)\n-    if (__comp(*__first2, *__first1)) {\n-      iterator __next = __first2;\n-      transfer(__first1, __first2, ++__next);\n-      __first2 = __next;\n+  template<typename _Tp, typename _Alloc>\n+  inline void list<_Tp, _Alloc>::\n+  reverse() \n+  { __List_base_reverse(this->_M_node); }    \n+\n+  template<typename _Tp, typename _Alloc>\n+    void list<_Tp, _Alloc>::\n+    sort()\n+    {\n+      // Do nothing if the list has length 0 or 1.\n+      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n+        list<_Tp, _Alloc> __carry;\n+        list<_Tp, _Alloc> __counter[64];\n+        int __fill = 0;\n+        while (!empty()) {\n+          __carry.splice(__carry.begin(), *this, begin());\n+          int __i = 0;\n+          while(__i < __fill && !__counter[__i].empty()) {\n+            __counter[__i].merge(__carry);\n+            __carry.swap(__counter[__i++]);\n+          }\n+          __carry.swap(__counter[__i]);         \n+          if (__i == __fill) ++__fill;\n+        } \n+\n+        for (int __i = 1; __i < __fill; ++__i)\n+          __counter[__i].merge(__counter[__i-1]);\n+        swap(__counter[__fill-1]);\n+      }\n     }\n-    else\n-      ++__first1;\n-  if (__first2 != __last2) transfer(__last1, __first2, __last2);\n-}\n \n-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n-void list<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)\n-{\n-  // Do nothing if the list has length 0 or 1.\n-  if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n-    list<_Tp, _Alloc> __carry;\n-    list<_Tp, _Alloc> __counter[64];\n-    int __fill = 0;\n-    while (!empty()) {\n-      __carry.splice(__carry.begin(), *this, begin());\n-      int __i = 0;\n-      while(__i < __fill && !__counter[__i].empty()) {\n-        __counter[__i].merge(__carry, __comp);\n-        __carry.swap(__counter[__i++]);\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _Predicate>\n+      void list<_Tp, _Alloc>::\n+      remove_if(_Predicate __pred)\n+      {\n+        iterator __first = begin();\n+        iterator __last = end();\n+        while (__first != __last) {\n+          iterator __next = __first;\n+          ++__next;\n+          if (__pred(*__first)) erase(__first);\n+          __first = __next;\n+        }\n       }\n-      __carry.swap(__counter[__i]);         \n-      if (__i == __fill) ++__fill;\n-    } \n \n-    for (int __i = 1; __i < __fill; ++__i) \n-      __counter[__i].merge(__counter[__i-1], __comp);\n-    swap(__counter[__fill-1]);\n-  }\n-}\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _BinaryPredicate>\n+      void list<_Tp, _Alloc>::\n+      unique(_BinaryPredicate __binary_pred)\n+      {\n+        iterator __first = begin();\n+        iterator __last = end();\n+        if (__first == __last) return;\n+        iterator __next = __first;\n+        while (++__next != __last) {\n+          if (__binary_pred(*__first, *__next))\n+            erase(__next);\n+          else\n+            __first = __next;\n+          __next = __first;\n+        }\n+      }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+      void list<_Tp, _Alloc>::\n+      merge(list<_Tp, _Alloc>& __x, _StrictWeakOrdering __comp)\n+      {\n+        iterator __first1 = begin();\n+        iterator __last1 = end();\n+        iterator __first2 = __x.begin();\n+        iterator __last2 = __x.end();\n+        while (__first1 != __last1 && __first2 != __last2)\n+          if (__comp(*__first2, *__first1)) {\n+            iterator __next = __first2;\n+            _M_transfer(__first1, __first2, ++__next);\n+            __first2 = __next;\n+          }\n+          else\n+            ++__first1;\n+        if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n+      }\n+\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+    void list<_Tp, _Alloc>::\n+    sort(_StrictWeakOrdering __comp)\n+    {\n+      // Do nothing if the list has length 0 or 1.\n+      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n+        list<_Tp, _Alloc> __carry;\n+        list<_Tp, _Alloc> __counter[64];\n+        int __fill = 0;\n+        while (!empty()) {\n+          __carry.splice(__carry.begin(), *this, begin());\n+          int __i = 0;\n+          while(__i < __fill && !__counter[__i].empty()) {\n+            __counter[__i].merge(__carry, __comp);\n+            __carry.swap(__counter[__i++]);\n+          }\n+          __carry.swap(__counter[__i]);         \n+          if (__i == __fill) ++__fill;\n+        } \n+\n+        for (int __i = 1; __i < __fill; ++__i) \n+          __counter[__i].merge(__counter[__i-1], __comp);\n+        swap(__counter[__fill-1]);\n+      }\n+    }\n \n } // namespace std \n \n #endif /* __SGI_STL_INTERNAL_LIST_H */\n \n+// vi:set ts=2 sw=2:\n // Local Variables:\n // mode:C++\n // End:"}, {"sha": "133fecd5423be5429d96aabcfc396423920e91a4", "filename": "libstdc++-v3/testsuite/23_containers/list_capacity.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_capacity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_capacity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_capacity.cc?ref=1fc610939a651cf4a5f8138b7a35abd8cf62497e", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.2.2 list capacity [lib.list.capacity]\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+\n+bool test = true;\n+\n+// This test verifies the following.\n+//\n+// 23.2.2       bool empty() const\n+// 23.2.2       size_type size() const\n+// 23.2.2       iterator begin()\n+// 23.2.2       iterator end()\n+// 23.2.2.3     void push_back(const T&)\n+// 23.2.2       size_type max_size() const\n+// 23.2.2.2     void resize(size_type s, T c = T())\n+//\n+void\n+test01()\n+{\n+  std::list<int> list0101;\n+  VERIFY(list0101.empty());\n+  VERIFY(list0101.size() == 0);\n+\n+  list0101.push_back(1);\n+  VERIFY(!list0101.empty());\n+  VERIFY(list0101.size() == 1);\n+\n+  list0101.resize(3, 2);\n+  VERIFY(!list0101.empty());\n+  VERIFY(list0101.size() == 3);\n+\n+  std::list<int>::iterator i = list0101.begin();\n+  VERIFY(*i == 1); ++i;\n+  VERIFY(*i == 2); ++i;\n+  VERIFY(*i == 2); ++i;\n+  VERIFY(i == list0101.end());\n+\n+  list0101.resize(0);\n+  VERIFY(list0101.empty());\n+  VERIFY(list0101.size() == 0);\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+\n+    return !test;\n+}\n+\n+// vi:set sw=2 ts=2:"}, {"sha": "e358e7a9fe4bc409e3c954a2252f51557728488b", "filename": "libstdc++-v3/testsuite/23_containers/list_ctor.cc", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_ctor.cc?ref=1fc610939a651cf4a5f8138b7a35abd8cf62497e", "patch": "@@ -0,0 +1,332 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.2.1 list constructors, copy, and assignment\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+\n+bool test = true;\n+\n+// A nontrivial type.\n+template<typename T>\n+  struct A { };\n+\n+// Another nontrivial type\n+struct B { };\n+\n+// A nontrivial type convertible from an int\n+struct C {\n+  C(int i) : i_(i) { }\n+  bool operator==(const C& rhs) { return i_ == rhs.i_; }\n+  int i_;\n+};\n+\n+// Default constructor, basic properties\n+//\n+// This test verifies the following.\n+// 23.2.2.1     explicit list(const a& = Allocator())\n+// 23.1 (7)     iterator behaviour of empty containers\n+// 23.2.2       iterator begin()\n+// 23.2.2       iterator end()\n+// 23.2.2       size_type size() const\n+// 23.2.2\texistence of required typedefs\n+//\n+void\n+test01()\n+{\n+  std::list< A<B> > list0101;\n+  VERIFY(list0101.begin() == list0101.end());\n+  VERIFY(list0101.size() == 0);\n+\n+  // check type definitions -- will fail compile if missing\n+  typedef std::list< A<B> >::reference              reference;\n+  typedef std::list< A<B> >::const_reference        const_reference;\n+  typedef std::list< A<B> >::iterator               iterator;\n+  typedef std::list< A<B> >::const_iterator         const_iterator;\n+  typedef std::list< A<B> >::size_type              size_type;\n+  typedef std::list< A<B> >::difference_type        difference_type;\n+  typedef std::list< A<B> >::value_type             value_type;\n+  typedef std::list< A<B> >::allocator_type         allocator_type;\n+  typedef std::list< A<B> >::pointer                pointer;\n+  typedef std::list< A<B> >::const_pointer          const_pointer;\n+  typedef std::list< A<B> >::reverse_iterator       reverse_iterator;\n+  typedef std::list< A<B> >::const_reverse_iterator const_reverse_iterator;\n+\n+  // allocator checks?\n+}\n+\n+// Fill constructor\n+//\n+// This test verifies the following.\n+// 23.2.2.1     explicit list(size_type n, const T& v = T(), const a& = Allocator())\n+// 23.2.2       const_iterator begin() const\n+// 23.2.2       const_iterator end() const\n+// 23.2.2       size_type size() const\n+//\n+void\n+test02()\n+{\n+  const int LIST_SIZE = 5;\n+  const int INIT_VALUE = 7;\n+  int count;\n+  std::list<int>::const_iterator i;\n+\n+  // nontrivial value_type\n+  std::list< A<B> > list0201(LIST_SIZE);\n+\n+  // default value\n+  std::list<int> list0202(LIST_SIZE);\n+  for (i = list0202.begin(), count = 0;\n+       i != list0202.end();\n+       ++i, ++count)\n+    VERIFY(*i == 0);\n+  VERIFY(count == LIST_SIZE);\n+  VERIFY(list0202.size() == LIST_SIZE);\n+\n+  // explicit value\n+  std::list<int> list0203(LIST_SIZE, INIT_VALUE);\n+  for (i = list0203.begin(), count = 0;\n+       i != list0203.end();\n+       ++i, ++count)\n+    VERIFY(*i == INIT_VALUE);\n+  VERIFY(count == LIST_SIZE);\n+  VERIFY(list0203.size() == LIST_SIZE);\n+}\n+\n+// Fill constructor disguised as a range constructor\n+void\n+test02D()\n+{\n+  const int LIST_SIZE = 5;\n+  const int INIT_VALUE = 7;\n+  int count = 0;\n+  std::list<C> list0204(LIST_SIZE, INIT_VALUE);\n+  std::list<C>::iterator i = list0204.begin();\n+  for (; i != list0204.end(); ++i, ++count)\n+    VERIFY(*i == INIT_VALUE);\n+  VERIFY(count == LIST_SIZE);\n+  VERIFY(list0204.size() == LIST_SIZE);\n+}\n+\n+// Range constructor\n+//\n+// This test verifies the following.\n+// 23.2.2.1     template list(InputIterator f, InputIterator l, const Allocator& a = Allocator())\n+// 23.2.2       const_iterator begin() const\n+// 23.2.2       const_iterator end() const\n+// 23.2.2       size_type size() const\n+//\n+void\n+test03()\n+{\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int N = sizeof(A) / sizeof(int);\n+  int count;\n+  std::list<int>::const_iterator i;\n+\n+  // construct from a dissimilar range\n+  std::list<int> list0301(A, A + N);\n+  for (i = list0301.begin(), count = 0;\n+       i != list0301.end();\n+       ++i, ++count)\n+    VERIFY(*i == A[count]);\n+  VERIFY(count == N);\n+  VERIFY(list0301.size() == N);\n+\n+  // construct from a similar range\n+  std::list<int> list0302(list0301.begin(), list0301.end());\n+  for (i = list0302.begin(), count = 0;\n+       i != list0302.end();\n+       ++i, ++count)\n+    VERIFY(*i == A[count]);\n+  VERIFY(count == N);\n+  VERIFY(list0302.size() == N);\n+}\n+\n+// Copy constructor\n+//\n+// This test verifies the following.\n+// 23.2.2.1     list(const list& x)\n+// 23.2.2       reverse_iterator rbegin() \n+// 23.2.2       reverse_iterator rend()\n+// 23.2.2       size_type size() const\n+//\n+void\n+test04()\n+{\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int N = sizeof(A) / sizeof(int);\n+  int count;\n+  std::list<int>::reverse_iterator i;\n+  std::list<int> list0401(A, A + N);\n+\n+  std::list<int> list0402(list0401);\n+  for (i = list0401.rbegin(), count = N - 1;\n+       i != list0401.rend();\n+       ++i, --count)\n+    VERIFY(*i == A[count]);\n+  VERIFY(count == -1);\n+  VERIFY(list0401.size() == N);\n+}\n+\n+// Range assign\n+//\n+// This test verifies the following.\n+// 23.2.2.1     void assign(InputIterator f, InputIterator l)\n+// 23.2.2       const_iterator begin() const\n+// 23.2.2       const_iterator end() const\n+// 23.2.2       size_type size() const\n+//\n+void\n+test05()\n+{\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int B[] = {101, 102, 103, 104, 105};\n+  const int N = sizeof(A) / sizeof(int);\n+  const int M = sizeof(B) / sizeof(int);\n+  int count;\n+  std::list<int>::const_iterator i;\n+\n+  std::list<int> list0501;\n+\n+  // make it bigger\n+  list0501.assign(A, A + N);\n+  for (i = list0501.begin(), count = 0;\n+       i != list0501.end();\n+       ++i, ++count)\n+    VERIFY(*i == A[count]);\n+  VERIFY(count == N);\n+  VERIFY(list0501.size() == N);\n+\n+  // make it smaller\n+  list0501.assign(B, B + M);\n+  for (i = list0501.begin(), count = 0;\n+       i != list0501.end();\n+       ++i, ++count)\n+    VERIFY(*i == B[count]);\n+  VERIFY(count == M);\n+  VERIFY(list0501.size() == M);\n+}\n+\n+// Fill assign\n+//\n+// This test verifies the following.\n+// 23.2.2.1     void assign(size_type n, const T& v)\n+// 23.2.2       const_iterator begin() const\n+// 23.2.2       const_iterator end() const\n+// 23.2.2       size_type size() const\n+//\n+void\n+test06()\n+{\n+  const int BIG_LIST_SIZE = 11;\n+  const int BIG_INIT_VALUE = 7;\n+  const int SMALL_LIST_SIZE = 5;\n+  const int SMALL_INIT_VALUE = 17;\n+  int count;\n+  std::list<int>::const_iterator i;\n+\n+  std::list<int> list0601;\n+  VERIFY(list0601.size() == 0);\n+\n+  // make it bigger\n+  list0601.assign(BIG_LIST_SIZE, BIG_INIT_VALUE);\n+  for (i = list0601.begin(), count = 0;\n+       i != list0601.end();\n+       ++i, ++count)\n+    VERIFY(*i == BIG_INIT_VALUE);\n+  VERIFY(count == BIG_LIST_SIZE);\n+  VERIFY(list0601.size() == BIG_LIST_SIZE);\n+\n+  // make it shrink\n+  list0601.assign(SMALL_LIST_SIZE, SMALL_INIT_VALUE);\n+  for (i = list0601.begin(), count = 0;\n+       i != list0601.end();\n+       ++i, ++count)\n+    VERIFY(*i == SMALL_INIT_VALUE);\n+  VERIFY(count == SMALL_LIST_SIZE);\n+  VERIFY(list0601.size() == SMALL_LIST_SIZE);\n+}\n+\n+// Fill Assignment disguised as a Range Assignment\n+void\n+test06D()\n+{\n+  const int LIST_SIZE = 5;\n+  const int INIT_VALUE = 7;\n+  int count = 0;\n+  std::list<C> list0604;\n+  VERIFY(list0604.size() == 0);\n+  \n+  list0604.assign(LIST_SIZE, INIT_VALUE);\n+  std::list<C>::iterator i = list0604.begin();\n+  for (; i != list0604.end(); ++i, ++count)\n+    VERIFY(*i == INIT_VALUE);\n+  VERIFY(count == LIST_SIZE);\n+  VERIFY(list0604.size() == LIST_SIZE);\n+}\n+\n+// Assignment operator\n+//\n+// This test verifies the following.\n+// 23.2.2       operator=(const list& x)\n+// 23.2.2       iterator begin()\n+// 23.2.2       iterator end()\n+// 23.2.2       size_type size() const\n+// 23.2.2       bool operator==(const list& x, const list& y)\n+//\n+void\n+test07()\n+{\n+  const int A[] = {701, 702, 703, 704, 705};\n+  const int N = sizeof(A) / sizeof(int);\n+  int count;\n+  std::list<int>::iterator i;\n+\n+  std::list<int> list0701(A, A + N);\n+  VERIFY(list0701.size() == N);\n+\n+  std::list<int> list0702;\n+  VERIFY(list0702.size() == 0);\n+\n+  list0702 = list0701;\n+  VERIFY(list0702.size() == N);\n+  for (i = list0702.begin(), count = 0;\n+       i != list0702.end();\n+       ++i, ++count)\n+    VERIFY(*i == A[count]);\n+  VERIFY(count == N);\n+  VERIFY(list0702 == list0701);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02(); \n+  test02D(); \n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test06D();\n+  test07();\n+\n+  return !test;\n+}\n+// vi:set sw=2 ts=2:"}, {"sha": "9ce078143ad030755162d3312e64ea65dcc53d14", "filename": "libstdc++-v3/testsuite/23_containers/list_modifiers.cc", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_modifiers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_modifiers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_modifiers.cc?ref=1fc610939a651cf4a5f8138b7a35abd8cf62497e", "patch": "@@ -0,0 +1,325 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.2.3 list modifiers [lib.list.modifiers]\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+\n+bool test = true;\n+\n+// Here's a class with nontrivial ctor/dtor that provides\n+// the ability to track the number of copy ctors and dtors\n+// and will throw on demand during copy.\n+class T\n+{\n+public:\n+  // default constructor\n+  T(int anId, bool throwOnDemand = false)\n+  : itsId(anId), willThrow(throwOnDemand)\n+  { }\n+\n+  // copy constructor\n+  T(const T& rhs)\n+  : itsId(rhs.id()), willThrow(rhs.willThrow)\n+  {\n+    ++itsCopyCount;\n+    if (willThrow) \n+      throw \"exception\";\n+  }\n+\n+  ~T()\n+  { ++itsDtorCount; }\n+\n+  int\n+  id() const\n+  { return itsId; }\n+\n+private:\n+  const int  itsId;\n+  const bool willThrow;\n+\n+public:\n+  static void\n+  reset()\n+  { itsCopyCount = 0; itsDtorCount = 0; }\n+\n+  static int\n+  copyCount() \n+  { return itsCopyCount; }\n+\n+  static int\n+  dtorCount() \n+  { return itsDtorCount; }\n+\n+private:\n+  static int itsCopyCount;\n+  static int itsDtorCount;\n+};\n+\n+int T::itsCopyCount = 0;\n+int T::itsDtorCount = 0;\n+\n+\n+// This test verifies the following.\n+//\n+// 23.2.2.3     void push_front(const T& x)\n+// 23.2.2.3     void push_back(const T& x)\n+// 23.2.2.3 (1) iterator and reference non-invalidation \n+// 23.2.2.3 (1) exception effects\n+// 23.2.2.3 (2) complexity requirements\n+//\n+// 23.2.2.3     void pop_front()\n+// 23.2.2.3     void pop_back()\n+// 23.2.2.3 (3) iterator and reference non-invalidation \n+// 23.2.2.3 (5) complexity requirements\n+//\n+// 23.2.2       const_iterator begin() const\n+// 23.2.2       iterator end() \n+// 23.2.2       const_reverse_iterator rbegin() const\n+// 23.2.2       _reference front() \n+// 23.2.2       const_reference front() const\n+// 23.2.2       reference back() \n+// 23.2.2       const_reference back() const\n+//\n+void\n+test01()\n+{\n+  std::list<T> list0101;\n+  std::list<T>::const_iterator i;\n+  std::list<T>::const_reverse_iterator j;\n+  std::list<T>::iterator k;\n+  T::reset();\n+\n+  list0101.push_back(T(1));     // list should be [1]\n+  VERIFY(list0101.size() == 1);\n+  VERIFY(T::copyCount() == 1);\n+\n+  k = list0101.end();\n+  --k;\n+  VERIFY(k->id() == 1);\n+  VERIFY(k->id() == list0101.front().id());\n+  VERIFY(k->id() == list0101.back().id());\n+\n+  list0101.push_front(T(2));    // list should be [2 1]\n+  VERIFY(list0101.size() == 2);\n+  VERIFY(T::copyCount() == 2);\n+  VERIFY(k->id() == 1);\n+\n+  list0101.push_back(T(3));     // list should be [2 1 3]\n+  VERIFY(list0101.size() == 3);\n+  VERIFY(T::copyCount() == 3);\n+  VERIFY(k->id() == 1);\n+\n+  try\n+  {\n+    list0101.push_back(T(4, true));\n+    VERIFY((\"no exception thrown\", false));\n+  }\n+  catch (...)\n+  {\n+    VERIFY(list0101.size() == 3);\n+    VERIFY(T::copyCount() == 4);\n+  }\n+\n+  i = list0101.begin();\n+  VERIFY(i->id() == 2);\n+  VERIFY(i->id() == list0101.front().id());\n+\n+  j = list0101.rbegin();\n+  VERIFY(j->id() == 3);\n+  VERIFY(j->id() == list0101.back().id());\n+\n+  ++i;\n+  VERIFY(i->id() == 1);\n+\n+  ++j;\n+  VERIFY(j->id() == 1);\n+\n+  T::reset();\n+\n+  list0101.pop_back();          // list should be [2 1]\n+  VERIFY(list0101.size() == 2);\n+  VERIFY(T::dtorCount() == 1);\n+  VERIFY(i->id() == 1);\n+  VERIFY(j->id() == 1);\n+  VERIFY(k->id() == 1);\n+\n+  list0101.pop_front();          // list should be [1]\n+  VERIFY(list0101.size() == 1);\n+  VERIFY(T::dtorCount() == 2);\n+  VERIFY(i->id() == 1);\n+  VERIFY(j->id() == 1);\n+  VERIFY(k->id() == 1);\n+}\n+\n+// general single insert/erase + swap\n+void\n+test02()\n+{\n+  std::list<T> list0201;\n+  T::reset();\n+\n+  list0201.insert(list0201.begin(), T(1));     // list should be [1]\n+  VERIFY(list0201.size() == 1);\n+  VERIFY(T::copyCount() == 1);\n+\n+  list0201.insert(list0201.end(), T(2));     // list should be [1 2]\n+  VERIFY(list0201.size() == 2);\n+  VERIFY(T::copyCount() == 2);\n+\n+  std::list<T>::iterator i = list0201.begin();\n+  std::list<T>::const_iterator j = i;\n+  VERIFY(i->id() == 1); ++i;\n+  VERIFY(i->id() == 2);\n+\n+  list0201.insert(i, T(3));     // list should be [1 3 2]\n+  VERIFY(list0201.size() == 3);\n+  VERIFY(T::copyCount() == 3);\n+\n+  std::list<T>::const_iterator k = i;\n+  VERIFY(i->id() == 2); --i;\n+  VERIFY(i->id() == 3); --i;\n+  VERIFY(i->id() == 1); \n+  VERIFY(j->id() == 1); \n+\n+  ++i; // will point to '3'\n+  T::reset();\n+  list0201.erase(i); // should be [1 2]\n+  VERIFY(list0201.size() == 2);\n+  VERIFY(T::dtorCount() == 1);\n+  VERIFY(k->id() == 2);\n+  VERIFY(j->id() == 1); \n+\n+  std::list<T> list0202;\n+  T::reset();\n+  VERIFY(list0202.size() == 0);\n+  VERIFY(T::copyCount() == 0);\n+  VERIFY(T::dtorCount() == 0);\n+\n+  // member swap\n+  list0202.swap(list0201);\n+  VERIFY(list0201.size() == 0);\n+  VERIFY(list0202.size() == 2);\n+  VERIFY(T::copyCount() == 0);\n+  VERIFY(T::dtorCount() == 0);\n+\n+  // specialized swap\n+  swap(list0201, list0202);\n+  VERIFY(list0201.size() == 2);\n+  VERIFY(list0202.size() == 0);\n+  VERIFY(T::copyCount() == 0);\n+  VERIFY(T::dtorCount() == 0);\n+}\n+\n+// range and fill insert/erase + clear\n+// missing: o  fill insert disguised as a range insert in all its variants\n+//          o  exception effects\n+void\n+test03()\n+{\n+  std::list<T> list0301;\n+  T::reset();\n+\n+  // fill insert at beginning of list / empty list\n+  list0301.insert(list0301.begin(), 3, T(11)); // should be [11 11 11]\n+  VERIFY(list0301.size() == 3);\n+  VERIFY(T::copyCount() == 3);\n+\n+  // save iterators to verify post-insert validity\n+  std::list<T>::iterator b = list0301.begin();          \n+  std::list<T>::iterator m = list0301.end(); --m;          \n+  std::list<T>::iterator e = list0301.end();\n+\n+  // fill insert at end of list\n+  T::reset();\n+  list0301.insert(list0301.end(), 3, T(13)); // should be [11 11 11 13 13 13]\n+  VERIFY(list0301.size() == 6);\n+  VERIFY(T::copyCount() == 3);\n+  VERIFY(b == list0301.begin() && b->id() == 11);\n+  VERIFY(e == list0301.end());\n+  VERIFY(m->id() == 11);\n+\n+  // fill insert in the middle of list\n+  ++m;\n+  T::reset();\n+  list0301.insert(m, 3, T(12)); // should be [11 11 11 12 12 12 13 13 13]\n+  VERIFY(list0301.size() == 9);\n+  VERIFY(T::copyCount() == 3);\n+  VERIFY(b == list0301.begin() && b->id() == 11);\n+  VERIFY(e == list0301.end());\n+  VERIFY(m->id() == 13);\n+\n+  // single erase\n+  T::reset();\n+  m = list0301.erase(m); // should be [11 11 11 12 12 12 13 13]\n+  VERIFY(list0301.size() == 8);\n+  VERIFY(T::dtorCount() == 1);\n+  VERIFY(b == list0301.begin() && b->id() == 11);\n+  VERIFY(e == list0301.end());\n+  VERIFY(m->id() == 13);\n+\n+  // range erase\n+  T::reset();\n+  m = list0301.erase(list0301.begin(), m); // should be [13 13]\n+  VERIFY(list0301.size() == 2);\n+  VERIFY(T::dtorCount() == 6);\n+  VERIFY(m->id() == 13);\n+\n+  // range fill at beginning\n+  const int A[] = {321, 322, 333};\n+  const int N = sizeof(A) / sizeof(int);\n+  T::reset();\n+  b = list0301.begin();          \n+  list0301.insert(b, A, A + N); // should be [321 322 333 13 13]\n+  VERIFY(list0301.size() == 5);\n+  VERIFY(T::copyCount() == 3);\n+  VERIFY(m->id() == 13);\n+  \n+  // range fill at end\n+  T::reset();\n+  list0301.insert(e, A, A + N); // should be [321 322 333 13 13 321 322 333]\n+  VERIFY(list0301.size() == 8);\n+  VERIFY(T::copyCount() == 3);\n+  VERIFY(e == list0301.end());\n+  VERIFY(m->id() == 13);\n+  \n+  // range fill in middle\n+  T::reset();\n+  list0301.insert(m, A, A + N); \n+  VERIFY(list0301.size() == 11);\n+  VERIFY(T::copyCount() == 3);\n+  VERIFY(e == list0301.end());\n+  VERIFY(m->id() == 13);\n+\n+  T::reset();\n+  list0301.clear();\n+  VERIFY(list0301.size() == 0);\n+  VERIFY(T::dtorCount() == 11);\n+  VERIFY(e == list0301.end());\n+}\n+\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+    test03();\n+\n+    return !test;\n+}\n+// vi:set sw=2 ts=2:"}, {"sha": "69a59943e1e747ca370b7227b4468b1ca1423af8", "filename": "libstdc++-v3/testsuite/23_containers/list_operators.cc", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc610939a651cf4a5f8138b7a35abd8cf62497e/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_operators.cc?ref=1fc610939a651cf4a5f8138b7a35abd8cf62497e", "patch": "@@ -0,0 +1,211 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.2.4 list operations [lib.list.ops]\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+\n+bool test = true;\n+\n+// splice(p, x) + remove + reverse\n+void\n+test01()\n+{\n+  const int K = 417;\n+  const int A[] = {1, 2, 3, 4, 5};\n+  const int B[] = {K, K, K, K, K};\n+  const int N = sizeof(A) / sizeof(int);\n+  const int M = sizeof(B) / sizeof(int);\n+\n+  std::list<int> list0101(A, A + N);\n+  std::list<int> list0102(B, B + M);\n+  std::list<int>::iterator p = list0101.begin();\n+\n+  VERIFY(list0101.size() == N);\n+  VERIFY(list0102.size() == M);\n+\n+  ++p;\n+  list0101.splice(p, list0102); // [1 K K K K K 2 3 4 5]\n+  VERIFY(list0101.size() == N + M);\n+  VERIFY(list0102.size() == 0);\n+\n+  // remove range from middle\n+  list0101.remove(K);\n+  VERIFY(list0101.size() == N);\n+\n+  // remove first element\n+  list0101.remove(1);\n+  VERIFY(list0101.size() == N - 1);\n+\n+  // remove last element\n+  list0101.remove(5);\n+  VERIFY(list0101.size() == N - 2);\n+\n+  // reverse\n+  list0101.reverse();\n+  p = list0101.begin();\n+  VERIFY(*p == 4); ++p;\n+  VERIFY(*p == 3); ++p;\n+  VERIFY(*p == 2); ++p;\n+  VERIFY(p == list0101.end());\n+}\n+\n+// splice(p, x, i) + remove_if + operator==\n+void\n+test02()\n+{\n+  const int A[] = {1, 2, 3, 4, 5};\n+  const int B[] = {2, 1, 3, 4, 5};\n+  const int C[] = {1, 3, 4, 5, 2};\n+  const int N = sizeof(A) / sizeof(int);\n+  std::list<int> list0201(A, A + N);\n+  std::list<int> list0202(A, A + N);\n+  std::list<int> list0203(B, B + N);\n+  std::list<int> list0204(C, C + N);\n+  std::list<int>::iterator i = list0201.begin();\n+\n+  // result should be unchanged\n+  list0201.splice(list0201.begin(), list0201, i);\n+  VERIFY(list0201 == list0202);\n+\n+  // result should be [2 1 3 4 5]\n+  ++i;\n+  list0201.splice(list0201.begin(), list0201, i);\n+  VERIFY(list0201 != list0202);\n+  VERIFY(list0201 == list0203);\n+\n+  // result should be [1 3 4 5 2]\n+  list0201.splice(list0201.end(), list0201, i);\n+  VERIFY(list0201 == list0204);\n+}\n+\n+// splice(p, x, f, l) + sort + merge + unique\n+void\n+test03()\n+{\n+  const int A[] = {103, 203, 603, 303, 403, 503};\n+  const int B[] = {417, 417, 417, 417, 417};\n+  const int E[] = {103, 417, 417, 203, 603, 303, 403, 503};\n+  const int F[] = {103, 203, 303, 403, 417, 417, 503, 603};\n+  const int C[] = {103, 203, 303, 403, 417, 417, 417, 417, 417, 503, 603};\n+  const int D[] = {103, 203, 303, 403, 417, 503, 603};\n+  const int N = sizeof(A) / sizeof(int);\n+  const int M = sizeof(B) / sizeof(int);\n+  const int P = sizeof(C) / sizeof(int);\n+  const int Q = sizeof(D) / sizeof(int);\n+  const int R = sizeof(E) / sizeof(int);\n+\n+  std::list<int> list0301(A, A + N);\n+  std::list<int> list0302(B, B + M);\n+  std::list<int> list0303(C, C + P);\n+  std::list<int> list0304(D, D + Q);\n+  std::list<int> list0305(E, E + R);\n+  std::list<int> list0306(F, F + R);\n+  std::list<int>::iterator p = list0301.begin();\n+  std::list<int>::iterator q = list0302.begin();\n+\n+  ++p; ++q; ++q;\n+  list0301.splice(p, list0302, list0302.begin(), q);\n+  VERIFY(list0301 == list0305);\n+  VERIFY(list0301.size() == N + 2);\n+  VERIFY(list0302.size() == M - 2);\n+\n+  list0301.sort();\n+  VERIFY(list0301 == list0306);\n+\n+  list0301.merge(list0302);\n+  VERIFY(list0301.size() == N + M);\n+  VERIFY(list0302.size() == 0);\n+  VERIFY(list0301 == list0303);\n+\n+  list0301.unique();\n+  VERIFY(list0301 == list0304);\n+}\n+\n+// A comparison predicate to order by rightmost digit.  Tracks call counts for\n+// performance checks.\n+struct CompLastLt\n+{\n+  bool operator()(const int x, const int y) { ++itsCount; return x % 10 < y % 10; }\n+  static int count() { return itsCount; }\n+  static void reset() { itsCount = 0; }\n+  static int itsCount;\n+};\n+\n+int CompLastLt::itsCount;\n+\n+struct CompLastEq\n+{\n+  bool operator()(const int x, const int y) { ++itsCount; return x % 10 == y % 10; }\n+  static int count() { return itsCount; }\n+  static void reset() { itsCount = 0; }\n+  static int itsCount;\n+};\n+\n+int CompLastEq::itsCount;\n+\n+// sort(pred) + merge(pred) + unique(pred)\n+// also checks performance requirements\n+void\n+test04()\n+{\n+  const int A[] = {1, 2, 3, 4, 5, 6};\n+  const int B[] = {12, 15, 13, 14, 11};\n+  const int C[] = {11, 12, 13, 14, 15};\n+  const int D[] = {1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6};\n+  const int N = sizeof(A) / sizeof(int);\n+  const int M = sizeof(B) / sizeof(int);\n+  const int Q = sizeof(D) / sizeof(int);\n+\n+  std::list<int> list0401(A, A + N);\n+  std::list<int> list0402(B, B + M);\n+  std::list<int> list0403(C, C + M);\n+  std::list<int> list0404(D, D + Q);\n+  std::list<int> list0405(A, A + N);\n+\n+  // sort B\n+  CompLastLt lt;\n+\n+  CompLastLt::reset();\n+  list0402.sort(lt);\n+  VERIFY(list0402 == list0403);\n+\n+  CompLastLt::reset();\n+  list0401.merge(list0402, lt);\n+  VERIFY(list0401 == list0404);\n+  VERIFY(lt.count() <= (N + M - 1));\n+\n+  CompLastEq eq;\n+\n+  CompLastEq::reset();\n+  list0401.unique(eq);\n+  VERIFY(list0401 == list0405);\n+  VERIFY(eq.count() == (N + M - 1));\n+}\n+\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+    test03();\n+    test04();\n+\n+    return !test;\n+}\n+// vi:set sw=2 ts=2:"}]}