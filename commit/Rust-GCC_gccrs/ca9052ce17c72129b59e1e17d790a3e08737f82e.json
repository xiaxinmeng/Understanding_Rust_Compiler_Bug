{"sha": "ca9052ce17c72129b59e1e17d790a3e08737f82e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E5MDUyY2UxN2M3MjEyOWI1OWUxZTE3ZDc5MGEzZTA4NzM3ZjgyZQ==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-03-06T00:21:34Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-03-06T00:21:34Z"}, "message": "fwprop.c (update_df): Support width and offset parameters of df_ref_create.\n\n2008-03-05  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* fwprop.c (update_df): Support width and offset parameters of\n\tdf_ref_create.\n\t* ra-conflict.c (mark_reg_store, clear_reg_in_live,\n\tglobal_conflicts): Change DF_REF_EXTRACT to either\n\tDF_REF_ZERO_EXTRACT or DF_REF_SIGN_EXTRACT.  Change\n\tDF_REF_STRICT_LOWER_PART to DF_REF_STRICT_LOW_PART.\n\t* df-scan.c (df_ref_record, df_defs_record,\n\tdf_ref_create_structure, df_def_record_1, df_uses_record,\n\tdf_get_conditional_uses, df_get_call_refs, df_insn_refs_collect,\n\tdf_bb_refs_collect, df_entry_block_defs_collect,\n\tdf_exit_block_uses_collect): Support new width and offset fields.\n\t(ref_extract_pool): New storage pool.\n\t(df_free_ref): New function.\n\t(df_reg_chain_unlink, df_free_collection_rec,\n\tdf_sort_and_compress_refs): Call df_free_ref.\n\t(df_ref_equal_p, df_ref_compare): Compare offset and width fields\n\tof df_ref_extract.\n\t(df_ref_create_structure): Allocate df_ref_extract if offset and\n\twidth fields are used.\n\t(df_def_record_1): Get offset and width from ZERO_EXTRACT.\n\t(df_uses_record): Get offset and width from ZERO_EXTRACT \n\tand SIGN_EXTRACT.\n\t* global.c (build_insn_chain): Change DF_REF_EXTRACT to either\n\tDF_REF_ZERO_EXTRACT or DF_REF_SIGN_EXTRACT.  Change\n\tDF_REF_STRICT_LOWER_PART to DF_REF_STRICT_LOW_PART.\n\t* df.h (df_ref_flags): Change DF_REF_EXTRACT to either\n\tDF_REF_ZERO_EXTRACT or DF_REF_SIGN_EXTRACT.  Change\n\tDF_REF_STRICT_LOWER_PART to DF_REF_STRICT_LOW_PART.\n\t(df_ref_extract): New structure.\n\t(DF_REF_WIDTH, DF_REF_OFFSET): New macros.\n\t(df_ref_create): Add width and offset parameters.\n\nFrom-SVN: r132962", "tree": {"sha": "81a4fa5e0fbdeae7d436872de34208dd812b0bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81a4fa5e0fbdeae7d436872de34208dd812b0bd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca9052ce17c72129b59e1e17d790a3e08737f82e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9052ce17c72129b59e1e17d790a3e08737f82e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca9052ce17c72129b59e1e17d790a3e08737f82e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9052ce17c72129b59e1e17d790a3e08737f82e/comments", "author": null, "committer": null, "parents": [{"sha": "256fe3d795af429bc68d6f9d94c6c3e871a69736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/256fe3d795af429bc68d6f9d94c6c3e871a69736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/256fe3d795af429bc68d6f9d94c6c3e871a69736"}], "stats": {"total": 391, "additions": 290, "deletions": 101}, "files": [{"sha": "8d2bd72c053baeac352875a336dab2f42d71d480", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca9052ce17c72129b59e1e17d790a3e08737f82e", "patch": "@@ -1,3 +1,37 @@\n+2008-03-05  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* fwprop.c (update_df): Support width and offset parameters of\n+\tdf_ref_create.\n+\t* ra-conflict.c (mark_reg_store, clear_reg_in_live,\n+\tglobal_conflicts): Change DF_REF_EXTRACT to either\n+\tDF_REF_ZERO_EXTRACT or DF_REF_SIGN_EXTRACT.  Change\n+\tDF_REF_STRICT_LOWER_PART to DF_REF_STRICT_LOW_PART.\n+\t* df-scan.c (df_ref_record, df_defs_record,\n+\tdf_ref_create_structure, df_def_record_1, df_uses_record,\n+\tdf_get_conditional_uses, df_get_call_refs, df_insn_refs_collect,\n+\tdf_bb_refs_collect, df_entry_block_defs_collect,\n+\tdf_exit_block_uses_collect): Support new width and offset fields.\n+\t(ref_extract_pool): New storage pool.\n+\t(df_free_ref): New function.\n+\t(df_reg_chain_unlink, df_free_collection_rec,\n+\tdf_sort_and_compress_refs): Call df_free_ref.\n+\t(df_ref_equal_p, df_ref_compare): Compare offset and width fields\n+\tof df_ref_extract.\n+\t(df_ref_create_structure): Allocate df_ref_extract if offset and\n+\twidth fields are used.\n+\t(df_def_record_1): Get offset and width from ZERO_EXTRACT.\n+\t(df_uses_record): Get offset and width from ZERO_EXTRACT \n+\tand SIGN_EXTRACT.\n+\t* global.c (build_insn_chain): Change DF_REF_EXTRACT to either\n+\tDF_REF_ZERO_EXTRACT or DF_REF_SIGN_EXTRACT.  Change\n+\tDF_REF_STRICT_LOWER_PART to DF_REF_STRICT_LOW_PART.\n+\t* df.h (df_ref_flags): Change DF_REF_EXTRACT to either\n+\tDF_REF_ZERO_EXTRACT or DF_REF_SIGN_EXTRACT.  Change\n+\tDF_REF_STRICT_LOWER_PART to DF_REF_STRICT_LOW_PART.\n+\t(df_ref_extract): New structure.\n+\t(DF_REF_WIDTH, DF_REF_OFFSET): New macros.\n+\t(df_ref_create): Add width and offset parameters.\n+\t\n 2008-03-05  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n@@ -135,6 +169,7 @@\n \ttransformations for modes that have signed zeros.\n \t* ifcvt.c (noce_try_abs): Ditto.\n \n+>>>>>>> .r132956\n 2008-03-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/i386/i386.c (override_options): Force"}, {"sha": "b5d88f3aa5834ef5aadfdcf3547eecaaa917c9d4", "filename": "gcc/df-scan.c", "status": "modified", "additions": 202, "deletions": 80, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=ca9052ce17c72129b59e1e17d790a3e08737f82e", "patch": "@@ -95,7 +95,7 @@ static struct df_mw_hardreg * df_null_mw_rec[1];\n static void df_ref_record (struct df_collection_rec *,\n \t\t\t   rtx, rtx *, \n \t\t\t   basic_block, rtx, enum df_ref_type, \n-\t\t\t   enum df_ref_flags);\n+\t\t\t   enum df_ref_flags, int, int);\n static void df_def_record_1 (struct df_collection_rec *,\n \t\t\t     rtx, basic_block, rtx,\n \t\t\t     enum df_ref_flags);\n@@ -104,11 +104,11 @@ static void df_defs_record (struct df_collection_rec *,\n \t\t\t    enum df_ref_flags);\n static void df_uses_record (struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n-\t\t\t    basic_block, rtx, enum df_ref_flags);\n+\t\t\t    basic_block, rtx, enum df_ref_flags, int, int);\n \n static struct df_ref *df_ref_create_structure (struct df_collection_rec *, rtx, rtx *, \n \t\t\t\t\t       basic_block, rtx, enum df_ref_type, \n-\t\t\t\t\t       enum df_ref_flags);\n+\t\t\t\t\t       enum df_ref_flags, int, int);\n \n static void df_insn_refs_collect (struct df_collection_rec*, \n \t\t\t\t  basic_block, rtx); \n@@ -160,6 +160,7 @@ static bool regs_ever_live[FIRST_PSEUDO_REGISTER];\n struct df_scan_problem_data\n {\n   alloc_pool ref_pool;\n+  alloc_pool ref_extract_pool;\n   alloc_pool insn_pool;\n   alloc_pool reg_pool;\n   alloc_pool mw_reg_pool;\n@@ -214,6 +215,7 @@ df_scan_free_internal (void)\n \n   free_alloc_pool (df_scan->block_pool);\n   free_alloc_pool (problem_data->ref_pool);\n+  free_alloc_pool (problem_data->ref_extract_pool);\n   free_alloc_pool (problem_data->insn_pool);\n   free_alloc_pool (problem_data->reg_pool);\n   free_alloc_pool (problem_data->mw_reg_pool);\n@@ -296,6 +298,9 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   problem_data->ref_pool \n     = create_alloc_pool (\"df_scan_ref pool\", \n \t\t\t sizeof (struct df_ref), block_size);\n+  problem_data->ref_extract_pool \n+    = create_alloc_pool (\"df_scan_ref extract pool\", \n+\t\t\t sizeof (struct df_ref_extract), block_size);\n   problem_data->insn_pool \n     = create_alloc_pool (\"df_scan_insn pool\", \n \t\t\t sizeof (struct df_insn_info), block_size);\n@@ -608,13 +613,19 @@ df_scan_blocks (void)\n \n \n /* Create a new ref of type DF_REF_TYPE for register REG at address\n-   LOC within INSN of BB.  */\n+   LOC within INSN of BB.  This function is only used externally. \n+\n+   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n+   DF_REF_ZERO_EXTRACT.  WIDTH and OFFSET are used to access the fields\n+   if they were constants.  Otherwise they should be -1 if those flags\n+   were set.  */\n \n struct df_ref *\n df_ref_create (rtx reg, rtx *loc, rtx insn, \n \t       basic_block bb,\n \t       enum df_ref_type ref_type, \n-\t       enum df_ref_flags ref_flags)\n+\t       enum df_ref_flags ref_flags,\n+\t       int width, int offset)\n {\n   struct df_ref *ref;\n   struct df_reg_info **reg_info;\n@@ -629,7 +640,7 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n   /* You cannot hack artificial refs.  */\n   gcc_assert (insn);\n   ref = df_ref_create_structure (NULL, reg, loc, bb, insn,\n-                                 ref_type, ref_flags);\n+                                 ref_type, ref_flags, width, offset);\n \n   if (DF_REF_TYPE (ref) == DF_REF_REG_DEF)\n     {\n@@ -727,6 +738,18 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n    UTILITIES TO CREATE AND DESTROY REFS AND CHAINS.\n ----------------------------------------------------------------------------*/\n \n+static void\n+df_free_ref (struct df_ref *ref)\n+{\n+  struct df_scan_problem_data *problem_data\n+    = (struct df_scan_problem_data *) df_scan->problem_data;\n+\n+  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+    pool_free (problem_data->ref_extract_pool, (struct df_ref_extract *)ref);\n+  else\n+    pool_free (problem_data->ref_pool, ref);\n+}\n+\n \n /* Unlink and delete REF at the reg_use, reg_eq_use or reg_def chain.\n    Also delete the def-use or use-def chain if it exists.  */\n@@ -736,8 +759,6 @@ df_reg_chain_unlink (struct df_ref *ref)\n {\n   struct df_ref *next = DF_REF_NEXT_REG (ref);  \n   struct df_ref *prev = DF_REF_PREV_REG (ref);\n-  struct df_scan_problem_data *problem_data\n-    = (struct df_scan_problem_data *) df_scan->problem_data;\n   int id = DF_REF_ID (ref);\n   struct df_reg_info *reg_info;\n   struct df_ref **refs = NULL;\n@@ -808,7 +829,7 @@ df_reg_chain_unlink (struct df_ref *ref)\n   if (next)\n     DF_REF_PREV_REG (next) = prev;\n \n-  pool_free (problem_data->ref_pool, ref);\n+  df_free_ref (ref);\n }\n \n \n@@ -1058,13 +1079,13 @@ df_free_collection_rec (struct df_collection_rec *collection_rec)\n \n   if (collection_rec->def_vec)\n     for (ref = collection_rec->def_vec; *ref; ref++)\n-      pool_free (problem_data->ref_pool, *ref);\n+      df_free_ref (*ref);\n   if (collection_rec->use_vec)\n     for (ref = collection_rec->use_vec; *ref; ref++)\n-      pool_free (problem_data->ref_pool, *ref);\n+      df_free_ref (*ref);\n   if (collection_rec->eq_use_vec)\n     for (ref = collection_rec->eq_use_vec; *ref; ref++)\n-      pool_free (problem_data->ref_pool, *ref);\n+      df_free_ref (*ref);\n   if (collection_rec->mw_vec)\n     for (mw = collection_rec->mw_vec; *mw; mw++)\n       pool_free (problem_data->mw_reg_pool, *mw);\n@@ -2045,7 +2066,7 @@ df_notes_rescan (rtx insn)\n \t    case REG_EQUAL:\n \t      df_uses_record (&collection_rec,\n \t\t\t      &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t      bb, insn, DF_REF_IN_NOTE);\n+\t\t\t      bb, insn, DF_REF_IN_NOTE, -1, -1);\n \t    default:\n \t      break;\n \t    }\n@@ -2115,6 +2136,16 @@ df_ref_equal_p (struct df_ref *ref1, struct df_ref *ref2)\n {\n   if (!ref2)\n     return false;\n+\n+  /* The two flag tests here are only to make sure we do not look at\n+     the offset and width if they are not there.  The flags are\n+     compared in the next set of tests.  */\n+  if ((DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+      && (DF_REF_FLAGS_IS_SET (ref2, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+      && ((DF_REF_OFFSET (ref1) != DF_REF_OFFSET (ref2))\n+\t  || (DF_REF_WIDTH (ref1) != DF_REF_WIDTH (ref2))))\n+    return false;\n+\n   return (ref1 == ref2) ||\n     (DF_REF_REG (ref1) == DF_REF_REG (ref2)\n      && DF_REF_REGNO (ref1) == DF_REF_REGNO (ref2)\n@@ -2163,6 +2194,16 @@ df_ref_compare (const void *r1, const void *r2)\n       else\n \treturn 1;\n     }\n+\n+  /* The flags are the same at this point so it is safe to only look\n+     at ref1.  */\n+  if (DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+    {\n+      if (DF_REF_OFFSET (ref1) != DF_REF_OFFSET (ref2))\n+\treturn DF_REF_OFFSET (ref1) - DF_REF_OFFSET (ref2);\n+      if (DF_REF_WIDTH (ref1) != DF_REF_WIDTH (ref2))\n+\treturn DF_REF_WIDTH (ref1) - DF_REF_WIDTH (ref2);\n+    }\n   return 0;\n }\n \n@@ -2179,8 +2220,6 @@ df_swap_refs (struct df_ref **ref_vec, int i, int j)\n static unsigned int\n df_sort_and_compress_refs (struct df_ref **ref_vec, unsigned int count)\n {\n-  struct df_scan_problem_data *problem_data \n-    = (struct df_scan_problem_data *) df_scan->problem_data;\n   unsigned int i;\n   unsigned int dist = 0;\n \n@@ -2215,7 +2254,7 @@ df_sort_and_compress_refs (struct df_ref **ref_vec, unsigned int count)\n       /* Find the next ref that is not equal to the current ref.  */\n       while (df_ref_equal_p (ref_vec[i], ref_vec[i + dist + 1]))\n \t{\n-\t  pool_free (problem_data->ref_pool, ref_vec[i + dist + 1]);\n+\t  df_free_ref (ref_vec[i + dist + 1]);\n \t  dist++;\n \t}\n       /* Copy it down to the next position.  */\n@@ -2541,21 +2580,34 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n }\n \n \n-/* Allocate a ref and initialize its fields. */\n+/* Allocate a ref and initialize its fields. \n+\n+   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n+   DF_REF_ZERO_EXTRACT.  WIDTH and OFFSET are used to access the fields\n+   if they were constants.  Otherwise they should be -1 if those flags\n+   were set.  */\n \n static struct df_ref *\n df_ref_create_structure (struct df_collection_rec *collection_rec,\n \t\t\t rtx reg, rtx *loc, \n \t\t\t basic_block bb, rtx insn, \n \t\t\t enum df_ref_type ref_type, \n-\t\t\t enum df_ref_flags ref_flags)\n+\t\t\t enum df_ref_flags ref_flags,\n+\t\t\t int width, int offset)\n {\n   struct df_ref *this_ref;\n   int regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n   struct df_scan_problem_data *problem_data\n     = (struct df_scan_problem_data *) df_scan->problem_data;\n \n-  this_ref = pool_alloc (problem_data->ref_pool);\n+  if (ref_flags & (DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+    {\n+      this_ref = pool_alloc (problem_data->ref_extract_pool);\n+      DF_REF_WIDTH (this_ref) = width;\n+      DF_REF_OFFSET (this_ref) = offset;\n+    }\n+  else\n+    this_ref = pool_alloc (problem_data->ref_pool);\n   DF_REF_ID (this_ref) = -1;\n   DF_REF_REG (this_ref) = reg;\n   DF_REF_REGNO (this_ref) =  regno;\n@@ -2604,14 +2656,21 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n \n \n /* Create new references of type DF_REF_TYPE for each part of register REG\n-   at address LOC within INSN of BB.  */\n+   at address LOC within INSN of BB. \n+\n+   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n+   DF_REF_ZERO_EXTRACT.  WIDTH and OFFSET are used to access the fields\n+   if they were constants.  Otherwise they should be -1 if those flags\n+   were set.  */\n+\n \n static void\n df_ref_record (struct df_collection_rec *collection_rec,\n                rtx reg, rtx *loc, \n \t       basic_block bb, rtx insn, \n \t       enum df_ref_type ref_type, \n-\t       enum df_ref_flags ref_flags) \n+\t       enum df_ref_flags ref_flags,\n+\t       int width, int offset) \n {\n   unsigned int regno;\n \n@@ -2660,7 +2719,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n       for (i = regno; i < endregno; i++)\n \t{\n \t  ref = df_ref_create_structure (collection_rec, regno_reg_rtx[i], loc, \n-\t\t\t\t\t bb, insn, ref_type, ref_flags);\n+\t\t\t\t\t bb, insn, ref_type, ref_flags, width, offset);\n \n           gcc_assert (ORIGINAL_REGNO (DF_REF_REG (ref)) == i);\n \t}\n@@ -2669,7 +2728,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n     {\n       struct df_ref *ref;\n       ref = df_ref_create_structure (collection_rec, reg, loc, bb, insn, \n-                                     ref_type, ref_flags);\n+                                     ref_type, ref_flags, width, offset);\n     }\n }\n \n@@ -2703,6 +2762,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n {\n   rtx *loc;\n   rtx dst;\n+  int offset = -1;\n+  int width = -1;\n \n  /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n      construct.  */\n@@ -2730,16 +2791,24 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n       return;\n     }\n \n-  /* Maybe, we should flag the use of STRICT_LOW_PART somehow.  It might\n-     be handy for the reg allocator.  */\n-  while (GET_CODE (dst) == STRICT_LOW_PART\n-\t || GET_CODE (dst) == ZERO_EXTRACT)\n+  if (GET_CODE (dst) == STRICT_LOW_PART)\n     {\n-      flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL;\n-      if (GET_CODE (dst) == ZERO_EXTRACT)\n-\tflags |= DF_REF_EXTRACT;\n-      else\n-\tflags |= DF_REF_STRICT_LOWER_PART;\n+      flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_STRICT_LOW_PART;\n+\n+      loc = &XEXP (dst, 0);\n+      dst = *loc;\n+    }\n+\n+  if (GET_CODE (dst) == ZERO_EXTRACT)\n+    {\n+      flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_ZERO_EXTRACT;\n+      \n+      if (GET_CODE (XEXP (dst, 1)) == CONST_INT\n+\t  && GET_CODE (XEXP (dst, 2)) == CONST_INT)\n+\t{\n+\t  width = INTVAL (XEXP (dst, 1));\n+\t  offset = INTVAL (XEXP (dst, 2));\n+\t}\n \n       loc = &XEXP (dst, 0);\n       dst = *loc;\n@@ -2749,13 +2818,13 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   if (REG_P (dst))\n     {\n       df_ref_record (collection_rec, \n-\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags);\n+\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, width, offset);\n \n       /* We want to keep sp alive everywhere - by making all\n \t writes to sp also use of sp. */\n       if (REGNO (dst) == STACK_POINTER_REGNUM)\n \tdf_ref_record (collection_rec,\n-\t\t       dst, NULL, bb, insn, DF_REF_REG_USE, flags);\n+\t\t       dst, NULL, bb, insn, DF_REF_REG_USE, flags, width, offset);\n     }\n   else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n     {\n@@ -2765,7 +2834,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n       flags |= DF_REF_SUBREG;\n \n       df_ref_record (collection_rec, \n-\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags);\n+\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, width, offset);\n     }\n }\n \n@@ -2801,12 +2870,18 @@ df_defs_record (struct df_collection_rec *collection_rec,\n }\n \n \n-/* Process all the registers used in the rtx at address LOC.  */\n+/* Process all the registers used in the rtx at address LOC.  \n+\n+   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n+   DF_REF_ZERO_EXTRACT.  WIDTH and LOWER are used to access the fields\n+   if they were constants.  Otherwise they should be -1 if those flags\n+   were set.  */\n \n static void\n df_uses_record (struct df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n-\t\tbasic_block bb, rtx insn, enum df_ref_flags flags)\n+\t\tbasic_block bb, rtx insn, enum df_ref_flags flags,\n+\t\tint width, int offset)\n {\n   RTX_CODE code;\n   rtx x;\n@@ -2837,15 +2912,15 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (MEM_P (XEXP (x, 0)))\n \tdf_uses_record (collection_rec,\n \t\t\t&XEXP (XEXP (x, 0), 0),\n-\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags);\n+\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags, width, offset);\n \n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n     case MEM:\n       df_uses_record (collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD, \n-\t\t      bb, insn, flags & DF_REF_IN_NOTE);\n+\t\t      bb, insn, flags & DF_REF_IN_NOTE, width, offset);\n       return;\n \n     case SUBREG:\n@@ -2855,22 +2930,46 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (collection_rec, loc, ref_type, bb, insn, flags);\n+\t  df_uses_record (collection_rec, loc, ref_type, bb, insn, flags, width, offset);\n \t  return;\n \t}\n       /* ... Fall through ...  */\n \n     case REG:\n       df_ref_record (collection_rec, \n-\t\t     x, loc, bb, insn, ref_type, flags);\n+\t\t     x, loc, bb, insn, ref_type, flags, width, offset);\n       return;\n \n+    case SIGN_EXTRACT:\n+    case ZERO_EXTRACT:\n+      {\n+\t/* If the parameters to the zero or sign extract are\n+\t   constants, strip them off and recurse, otherwise there is\n+\t   no information that we can gain from this operation.  */\n+\tif (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t    && GET_CODE (XEXP (x, 2)) == CONST_INT)\n+\t  {\n+\t    width = INTVAL (XEXP (x, 1));\n+\t    offset = INTVAL (XEXP (x, 2));\n+\n+\t    if (code == ZERO_EXTRACT)\n+\t      flags |= DF_REF_ZERO_EXTRACT;\n+\t    else\n+\t      flags |= DF_REF_SIGN_EXTRACT;\n+\n+\t    df_uses_record (collection_rec,\n+\t\t\t    &XEXP (x, 0), ref_type, bb, insn, flags, width, offset);\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n     case SET:\n       {\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n \tdf_uses_record (collection_rec,\n-\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn, flags);\n+\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn, flags, width, offset);\n \n \tswitch (GET_CODE (dst))\n \t  {\n@@ -2879,7 +2978,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\t{\n \t\t  df_uses_record (collection_rec, &SUBREG_REG (dst), \n \t\t\t\t  DF_REF_REG_USE, bb, insn, \n-\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG);\n+\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG, width, offset);\n \t\t  break;\n \t\t}\n \t      /* Fall through.  */\n@@ -2891,7 +2990,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tbreak;\n \t    case MEM:\n \t      df_uses_record (collection_rec, &XEXP (dst, 0),\n-\t\t\t      DF_REF_REG_MEM_STORE, bb, insn, flags);\n+\t\t\t      DF_REF_REG_MEM_STORE, bb, insn, flags, width, offset);\n \t      break;\n \t    case STRICT_LOW_PART:\n \t      {\n@@ -2902,20 +3001,31 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tdf_uses_record (collection_rec, \n \t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp, \n \t\t\t\tDF_REF_REG_USE, bb, insn, \n-\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOWER_PART);\n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART, width, offset);\n \t      }\n \t      break;\n \t    case ZERO_EXTRACT:\n-\t    case SIGN_EXTRACT:\n-\t      df_uses_record (collection_rec, &XEXP (dst, 0), \n-\t\t\t      DF_REF_REG_USE, bb, insn, \n-\t\t\t      DF_REF_READ_WRITE | DF_REF_EXTRACT);\n-\t      df_uses_record (collection_rec, &XEXP (dst, 1), \n-\t\t\t      DF_REF_REG_USE, bb, insn, flags);\n-\t      df_uses_record (collection_rec, &XEXP (dst, 2), \n-\t\t\t      DF_REF_REG_USE, bb, insn, flags);\n-\t      dst = XEXP (dst, 0);\n+\t      {\n+\t\tif (GET_CODE (XEXP (dst, 1)) == CONST_INT\n+\t\t    && GET_CODE (XEXP (dst, 2)) == CONST_INT)\n+\t\t  {\n+\t\t    width = INTVAL (XEXP (dst, 1));\n+\t\t    offset = INTVAL (XEXP (dst, 2));\n+\t\t  }\n+\t\telse \n+\t\t  {\n+\t\t    df_uses_record (collection_rec, &XEXP (dst, 1), \n+\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, width, offset);\n+\t\t    df_uses_record (collection_rec, &XEXP (dst, 2), \n+\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, width, offset);\n+\t\t  }\n+\n+\t\tdf_uses_record (collection_rec, &XEXP (dst, 0), \n+\t\t\t\tDF_REF_REG_USE, bb, insn, \n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, width, offset);\n+\t      }\n \t      break;\n+\n \t    default:\n \t      gcc_unreachable ();\n \t  }\n@@ -2962,7 +3072,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n \t      df_uses_record (collection_rec, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn, flags);\n+\t\t\t      DF_REF_REG_USE, bb, insn, flags, width, offset);\n \t    return;\n \t  }\n \tbreak;\n@@ -2977,7 +3087,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       /* Catch the def of the register being modified.  */\n       df_ref_record (collection_rec, XEXP (x, 0), &XEXP (x, 0), bb, insn, \n \t\t     DF_REF_REG_DEF,\n-                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY);\n+                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY, width, offset);\n \n       /* ... Fall through to handle uses ...  */\n \n@@ -3000,14 +3110,16 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tloc = &XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    df_uses_record (collection_rec, &XEXP (x, i), ref_type, bb, insn, flags);\n+\t    df_uses_record (collection_rec, &XEXP (x, i), ref_type, \n+\t\t\t    bb, insn, flags, width, offset);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      df_uses_record (collection_rec,\n-\t\t\t      &XVECEXP (x, i, j), ref_type, bb, insn, flags);\n+\t\t\t      &XVECEXP (x, i, j), ref_type, \n+\t\t\t      bb, insn, flags, width, offset);\n \t  }\n       }\n   }\n@@ -3027,11 +3139,21 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n       struct df_ref *ref = collection_rec->def_vec[i];\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_CONDITIONAL))\n         {\n-          struct df_ref *use \n-\t    = df_ref_create_structure (collection_rec, DF_REF_REG (ref),\n-\t\t\t\t       DF_REF_LOC (ref), DF_REF_BB (ref),\n-\t\t\t\t       DF_REF_INSN (ref), DF_REF_REG_USE,\n-\t\t\t\t       DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL);\n+\t  int width = -1;\n+\t  int offset = -1;\n+          struct df_ref *use;\n+\n+\t  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+\t    {\n+\t      width = DF_REF_WIDTH (ref);\n+\t      offset = DF_REF_OFFSET (ref);\n+\t    }\n+\n+          use = df_ref_create_structure (collection_rec, DF_REF_REG (ref),\n+\t\t\t\t\t DF_REF_LOC (ref), DF_REF_BB (ref),\n+\t\t\t\t\t DF_REF_INSN (ref), DF_REF_REG_USE,\n+\t\t\t\t\t DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL,\n+\t\t\t\t\t width, offset);\n           DF_REF_REGNO (use) = DF_REF_REGNO (ref);\n         }\n     }\n@@ -3069,7 +3191,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n     {\n       if (GET_CODE (XEXP (note, 0)) == USE)\n         df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n-\t\t\tDF_REF_REG_USE, bb, insn, flags);\n+\t\t\tDF_REF_REG_USE, bb, insn, flags, -1, -1);\n       else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n \t{\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n@@ -3081,23 +3203,23 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t    }\n \t  else\n \t    df_uses_record (collection_rec, &XEXP (note, 0),\n-\t\t            DF_REF_REG_USE, bb, insn, flags);\n+\t\t            DF_REF_REG_USE, bb, insn, flags, -1, -1);\n \t}\n     }\n \n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n   df_ref_record (collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n-\t\t NULL, bb, insn, DF_REF_REG_USE, DF_REF_CALL_STACK_USAGE | flags);\n+\t\t NULL, bb, insn, DF_REF_REG_USE, DF_REF_CALL_STACK_USAGE | flags, -1, -1);\n \n   /* Calls may also reference any of the global registers,\n      so they are recorded as used.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i])\n       {\n \tdf_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn, DF_REF_REG_USE, flags);\n+\t\t       NULL, bb, insn, DF_REF_REG_USE, flags, -1, -1);\n \tdf_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn, DF_REF_REG_DEF, flags);\n+\t\t       NULL, bb, insn, DF_REF_REG_DEF, flags, -1, -1);\n       }\n \n   is_sibling_call = SIBLING_CALL_P (insn);\n@@ -3110,7 +3232,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t      || refers_to_regno_p (ui, ui+1, \n \t\t\t\t    current_function_return_rtx, NULL)))\n         df_ref_record (collection_rec, regno_reg_rtx[ui], \n-\t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags);\n+\t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags, -1, -1);\n     }\n \n   BITMAP_FREE (defs_generated);\n@@ -3148,21 +3270,21 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         case REG_EQUAL:\n           df_uses_record (collection_rec,\n                           &XEXP (note, 0), DF_REF_REG_USE,\n-                          bb, insn, DF_REF_IN_NOTE);\n+                          bb, insn, DF_REF_IN_NOTE, -1, -1);\n           break;\n         case REG_NON_LOCAL_GOTO:\n           /* The frame ptr is used by a non-local goto.  */\n           df_ref_record (collection_rec,\n                          regno_reg_rtx[FRAME_POINTER_REGNUM],\n                          NULL,\n                          bb, insn, \n-                         DF_REF_REG_USE, 0);\n+                         DF_REF_REG_USE, 0, -1, -1);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n           df_ref_record (collection_rec,\n                          regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n                          NULL,\n                          bb, insn, \n-                         DF_REF_REG_USE, 0);\n+                         DF_REF_REG_USE, 0, -1, -1);\n #endif\n           break;\n         default:\n@@ -3176,7 +3298,7 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n \n   /* Record the register uses.  */\n   df_uses_record (collection_rec,\n-\t\t  &PATTERN (insn), DF_REF_REG_USE, bb, insn, 0);\n+\t\t  &PATTERN (insn), DF_REF_REG_USE, bb, insn, 0, -1, -1);\n \n   /* DF_REF_CONDITIONAL needs corresponding USES. */\n   if (is_cond_exec)\n@@ -3259,7 +3381,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n \t  df_ref_record (collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP);\n+\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1);\n \t}\n     }\n #endif\n@@ -3283,15 +3405,15 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (EH_USES (i))\n \t  df_ref_record (collection_rec, regno_reg_rtx[i], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_USE, DF_REF_AT_TOP);\n+\t\t\t bb, NULL, DF_REF_REG_USE, DF_REF_AT_TOP, -1, -1);\n     }\n #endif\n \n   /* Add the hard_frame_pointer if this block is the target of a\n      non-local goto.  */\n   if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n     df_ref_record (collection_rec, hard_frame_pointer_rtx, NULL,\n-\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP);\n+\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1);\n  \n   /* Add the artificial uses.  */\n   if (bb->index >= NUM_FIXED_BLOCKS)\n@@ -3305,7 +3427,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n \t{\n \t  df_ref_record (collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_USE, 0);\n+\t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1);\n \t}\n     }\n \n@@ -3598,7 +3720,7 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n       df_ref_record (collection_rec, regno_reg_rtx[i], NULL, \n-\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0);\n+\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1);\n     }\n \n   df_canonize_collection_rec (collection_rec);\n@@ -3759,7 +3881,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n     df_ref_record (collection_rec, regno_reg_rtx[i], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n   /* It is deliberate that this is not put in the exit block uses but\n@@ -3769,7 +3891,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n       && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n     df_ref_record (collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1);\n #endif\n \n   df_canonize_collection_rec (collection_rec);"}, {"sha": "cf113aefd50e7852a63a1ce226cc3e9b507afce6", "filename": "gcc/df.h", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=ca9052ce17c72129b59e1e17d790a3e08737f82e", "patch": "@@ -117,14 +117,18 @@ enum df_ref_flags\n     DF_REF_MUST_CLOBBER = 1 << 7,\n \n \n-    /* This flag is set if this ref is inside a pre/post modify.  */\n-    DF_REF_PRE_POST_MODIFY = 1 << 8,\n+    /* If the ref has one of the following two flags set, then the\n+       struct df_ref can be cast to struct df_ref_extract to access\n+       the width and offset fields.  */\n+ \n+    /* This flag is set if the ref contains a SIGN_EXTRACT.  */\n+    DF_REF_SIGN_EXTRACT = 1 << 8,\n \n-    /* This flag is set if the ref contains a ZERO_EXTRACT or SIGN_EXTRACT.  */\n-    DF_REF_EXTRACT = 1 << 9,\n+    /* This flag is set if the ref contains a ZERO_EXTRACT.  */\n+    DF_REF_ZERO_EXTRACT = 1 << 9,\n \n-    /* This flag is set if the ref contains a STRICT_LOWER_PART.  */\n-    DF_REF_STRICT_LOWER_PART = 1 << 10,\n+    /* This flag is set if the ref contains a STRICT_LOW_PART.  */\n+    DF_REF_STRICT_LOW_PART = 1 << 10,\n \n     /* This flag is set if the ref contains a SUBREG.  */\n     DF_REF_SUBREG = 1 << 11,\n@@ -138,7 +142,11 @@ enum df_ref_flags\n     DF_REF_CALL_STACK_USAGE = 1 << 13,\n \n     /* This flag is used for verification of existing refs. */\n-    DF_REF_REG_MARKER = 1 << 14\n+    DF_REF_REG_MARKER = 1 << 14,\n+\n+    /* This flag is set if this ref is inside a pre/post modify.  */\n+    DF_REF_PRE_POST_MODIFY = 1 << 15\n+\n   };\n \n /* The possible ordering of refs within the df_ref_info.  */\n@@ -381,6 +389,17 @@ struct df_ref\n   struct df_ref *prev_reg;     /* Prev ref with same regno and type.  */\n };\n \n+/* A df_ref_extract is just a df_ref with a width and offset field at\n+   the end of it.  It is used to hold this information if the ref was\n+   wrapped by a SIGN_EXTRACT or a ZERO_EXTRACT and to pass this info\n+   to passes that wish to process partial regs precisely.  */\n+struct df_ref_extract\n+{\n+  struct df_ref ref;\n+  int width;\n+  int offset;\n+};\n+\n /* These links are used for two purposes:\n    1) def-use or use-def chains. \n    2) Multiword hard registers that underly a single hardware register.  */\n@@ -598,7 +617,10 @@ struct df\n #define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_NEXT_REG(REF) ((REF)->next_reg)\n #define DF_REF_PREV_REG(REF) ((REF)->prev_reg)\n-\n+/* The following two macros may only be applied if one of \n+   DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT is true. */ \n+#define DF_REF_WIDTH(REF) (((struct df_ref_extract *)(REF))->width)\n+#define DF_REF_OFFSET(REF) (((struct df_ref_extract *)(REF))->offset)\n /* Macros to determine the reference type.  */\n \n #define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)\n@@ -862,7 +884,8 @@ extern void df_grow_reg_info (void);\n extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n extern struct df_ref *df_ref_create (rtx, rtx *, rtx,basic_block, \n-\t\t\t\t     enum df_ref_type, enum df_ref_flags);\n+\t\t\t\t     enum df_ref_type, enum df_ref_flags,\n+\t\t\t\t     int, int);\n extern void df_ref_remove (struct df_ref *);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);\n extern void df_insn_delete (basic_block, unsigned int);"}, {"sha": "089c571a635d87ac60ba95c30aa6850d209ff880", "filename": "gcc/fwprop.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=ca9052ce17c72129b59e1e17d790a3e08737f82e", "patch": "@@ -642,17 +642,25 @@ update_df (rtx insn, rtx *loc, struct df_ref **use_rec, enum df_ref_type type,\n     {\n       struct df_ref *use = *use_rec;\n       struct df_ref *orig_use = use, *new_use;\n+      int width = -1;\n+      int offset = -1;\n       rtx *new_loc = find_occurrence (loc, DF_REF_REG (orig_use));\n       use_rec++;\n \n       if (!new_loc)\n \tcontinue;\n \n+      if (DF_REF_FLAGS_IS_SET (orig_use, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n+\t{\n+\t  width = DF_REF_WIDTH (orig_use);\n+\t  offset = DF_REF_OFFSET (orig_use);\n+\t}\n+\n       /* Add a new insn use.  Use the original type, because it says if the\n          use was within a MEM.  */\n       new_use = df_ref_create (DF_REF_REG (orig_use), new_loc,\n \t\t\t       insn, BLOCK_FOR_INSN (insn),\n-\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags);\n+\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags, width, offset);\n \n       /* Set up the use-def chain.  */\n       df_chain_copy (new_use, DF_REF_CHAIN (orig_use));"}, {"sha": "ca9f4fb1a8a20c7acf17f7f2603fa90aa9512695", "filename": "gcc/global.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=ca9052ce17c72129b59e1e17d790a3e08737f82e", "patch": "@@ -1490,7 +1490,7 @@ build_insn_chain (void)\n \t\t\t/* We can model subregs, but not if they are\n \t\t\t   wrapped in ZERO_EXTRACTS.  */\n \t\t\tif (GET_CODE (reg) == SUBREG\n-\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT))\n+\t\t\t    && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n \t\t\t  {\n \t\t\t    unsigned int start = SUBREG_BYTE (reg);\n \t\t\t    unsigned int last = start \n@@ -1503,7 +1503,7 @@ build_insn_chain (void)\n \t\t\t\t\t\t  regno, reg);\n \n \t\t\t    if (!DF_REF_FLAGS_IS_SET\n-\t\t\t\t(def, DF_REF_STRICT_LOWER_PART))\n+\t\t\t\t(def, DF_REF_STRICT_LOW_PART))\n \t\t\t      {\n \t\t\t\t/* Expand the range to cover entire words.\n \t\t\t\t   Bytes added here are \"don't care\".  */\n@@ -1566,7 +1566,7 @@ build_insn_chain (void)\n \t\t       precisely so we do not need to look at the\n \t\t       fabricated use. */\n \t\t    if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n-\t\t\t&& !DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT) \n+\t\t\t&& !DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT) \n \t\t\t&& DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n \t\t      continue;\n \t\t    \n@@ -1585,7 +1585,8 @@ build_insn_chain (void)\n \t\t    if (regno < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n \t\t      {\n \t\t\tif (GET_CODE (reg) == SUBREG\n-\t\t\t    && !DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT)) \n+\t\t\t    && !DF_REF_FLAGS_IS_SET (use,\n+\t\t\t\t\t\t     DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT)) \n \t\t\t  {\n \t\t\t    unsigned int start = SUBREG_BYTE (reg);\n \t\t\t    unsigned int last = start "}, {"sha": "a4f9e5f4ea17d3b2921446a808b277d720434aad", "filename": "gcc/ra-conflict.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fra-conflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9052ce17c72129b59e1e17d790a3e08737f82e/gcc%2Fra-conflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-conflict.c?ref=ca9052ce17c72129b59e1e17d790a3e08737f82e", "patch": "@@ -297,7 +297,7 @@ mark_reg_store (sparseset allocnos_live,\n     {\n       unsigned int start = regno;\n       unsigned int last = end_hard_regno (mode, regno);\n-      if ((GET_CODE (reg) == SUBREG) && !DF_REF_FLAGS_IS_SET (ref, DF_REF_EXTRACT))\n+      if ((GET_CODE (reg) == SUBREG) && !DF_REF_FLAGS_IS_SET (ref, DF_REF_ZERO_EXTRACT))\n \t{\n \t  start += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n \t\t\t\t\tSUBREG_BYTE (reg), GET_MODE (reg));\n@@ -457,15 +457,15 @@ clear_reg_in_live (sparseset allocnos_live,\n   if (allocnum >= 0)\n     {\n       if (GET_CODE (reg) == SUBREG\n-\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT))\n+\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n \t{\n \t  unsigned int start = SUBREG_BYTE (reg);\n \t  unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));\n \n \t  ra_init_live_subregs (sparseset_bit_p (allocnos_live, allocnum), \n \t\t\t\tlive_subregs, live_subregs_used, allocnum, reg);\n \n-\t  if (!DF_REF_FLAGS_IS_SET (def, DF_REF_STRICT_LOWER_PART))\n+\t  if (!DF_REF_FLAGS_IS_SET (def, DF_REF_STRICT_LOW_PART))\n \t    {\n \t      /* Expand the range to cover entire words.\n \t\t Bytes added here are \"don't care\".  */\n@@ -511,7 +511,7 @@ clear_reg_in_live (sparseset allocnos_live,\n     {\n       unsigned int start = regno;\n       if (GET_CODE (reg) == SUBREG\n-\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT))\n+\t  && !DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT))\n \t{\n \t  unsigned int last;\n \t  start += SUBREG_BYTE (reg);\n@@ -864,7 +864,7 @@ global_conflicts (void)\n \t\t  rtx reg = DF_REF_REG (def);\n \t\t  set_reg_in_live (allocnos_live, live_subregs, live_subregs_used, \n \t\t\t\t   &hard_regs_live, reg, \n-\t\t\t\t   DF_REF_FLAGS_IS_SET (def, DF_REF_EXTRACT));\n+\t\t\t\t   DF_REF_FLAGS_IS_SET (def, DF_REF_ZERO_EXTRACT));\n \t\t  if (dump_file)\n \t\t    dump_ref (dump_file, \"  adding def\", \"\\n\",\n \t\t\t      reg, DF_REF_REGNO (def), live_subregs, live_subregs_used);\n@@ -946,7 +946,7 @@ global_conflicts (void)\n \t\t use unless that set also happens to wrapped in a\n \t\t ZERO_EXTRACT. */\n \t      if (DF_REF_FLAGS_IS_SET (use, DF_REF_READ_WRITE) \n-\t\t  && (!DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT)) \n+\t\t  && (!DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT)) \n \t\t  && DF_REF_FLAGS_IS_SET (use, DF_REF_SUBREG))\n \t\tcontinue;\n \t      \n@@ -957,7 +957,7 @@ global_conflicts (void)\n \t      if (allocnum >= 0)\n \t\t{\n \t\t  if (GET_CODE (reg) == SUBREG\n-\t\t      && !DF_REF_FLAGS_IS_SET (use, DF_REF_EXTRACT)) \n+\t\t      && !DF_REF_FLAGS_IS_SET (use, DF_REF_ZERO_EXTRACT)) \n \t\t    {\n \t\t      unsigned int start = SUBREG_BYTE (reg);\n \t\t      unsigned int last = start + GET_MODE_SIZE (GET_MODE (reg));"}]}