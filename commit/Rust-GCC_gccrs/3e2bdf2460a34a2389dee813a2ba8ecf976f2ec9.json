{"sha": "3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9", "node_id": "C_kwDOANBUbNoAKDNlMmJkZjI0NjBhMzRhMjM4OWRlZTgxM2EyYmE4ZWNmOTc2ZjJlYzk", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-11-04T10:15:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-11-04T14:14:50Z"}, "message": "Do not use subword paradoxical subregs in emit_group_store\n\nThe goal of the trick is to make life easier for the combiner, but subword\nparadoxical subregs make it harder for the register allocator instead.\n\ngcc/\n\t* expr.cc (emit_group_store): Do not use subword paradoxical subregs", "tree": {"sha": "bbb61cdd604298c8ba3893e53f2c554a314aa2fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbb61cdd604298c8ba3893e53f2c554a314aa2fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9/comments", "author": null, "committer": null, "parents": [{"sha": "418999fe382c608facf57f96b53a9cb12d2fdd20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418999fe382c608facf57f96b53a9cb12d2fdd20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/418999fe382c608facf57f96b53a9cb12d2fdd20"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "c6917fbf7bdb2783da3c92b767dbafbf66b9046d", "filename": "gcc/expr.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=3e2bdf2460a34a2389dee813a2ba8ecf976f2ec9", "patch": "@@ -2901,19 +2901,19 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n       if (!REG_P (dst) || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n \tdst = gen_reg_rtx (outer);\n \n-      /* Make life a bit easier for combine.  */\n-      /* If the first element of the vector is the low part\n-\t of the destination mode, use a paradoxical subreg to\n-\t initialize the destination.  */\n+      /* Make life a bit easier for combine: if the first element of the\n+\t vector is the word (or larger) low part of the destination mode,\n+\t use a paradoxical subreg to initialize the destination.  */\n       if (start < finish)\n \t{\n \t  inner = GET_MODE (tmps[start]);\n \t  bytepos = subreg_lowpart_offset (inner, outer);\n-\t  if (known_eq (rtx_to_poly_int64 (XEXP (XVECEXP (src, 0, start), 1)),\n-\t\t\tbytepos))\n+\t  if (known_ge (GET_MODE_BITSIZE (inner), BITS_PER_WORD)\n+\t      && known_eq (rtx_to_poly_int64 (XEXP (XVECEXP (src, 0,\n+\t\t\t\t\t\t\t     start), 1)),\n+\t\t\t   bytepos))\n \t    {\n-\t      temp = simplify_gen_subreg (outer, tmps[start],\n-\t\t\t\t\t  inner, 0);\n+\t      temp = simplify_gen_subreg (outer, tmps[start], inner, 0);\n \t      if (temp)\n \t\t{\n \t\t  emit_move_insn (dst, temp);\n@@ -2929,12 +2929,12 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n \t{\n \t  inner = GET_MODE (tmps[finish - 1]);\n \t  bytepos = subreg_lowpart_offset (inner, outer);\n-\t  if (known_eq (rtx_to_poly_int64 (XEXP (XVECEXP (src, 0,\n-\t\t\t\t\t\t\t  finish - 1), 1)),\n-\t\t\tbytepos))\n+\t  if (known_ge (GET_MODE_BITSIZE (inner), BITS_PER_WORD)\n+\t      && known_eq (rtx_to_poly_int64 (XEXP (XVECEXP (src, 0,\n+\t\t\t\t\t\t\t     finish - 1), 1)),\n+\t\t\t   bytepos))\n \t    {\n-\t      temp = simplify_gen_subreg (outer, tmps[finish - 1],\n-\t\t\t\t\t  inner, 0);\n+\t      temp = simplify_gen_subreg (outer, tmps[finish - 1], inner, 0);\n \t      if (temp)\n \t\t{\n \t\t  emit_move_insn (dst, temp);"}]}