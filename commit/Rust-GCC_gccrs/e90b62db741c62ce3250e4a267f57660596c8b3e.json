{"sha": "e90b62db741c62ce3250e4a267f57660596c8b3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwYjYyZGI3NDFjNjJjZTMyNTBlNGEyNjdmNTc2NjA1OTZjOGIzZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-07T22:02:43Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-07T22:02:43Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r12911", "tree": {"sha": "262325e16082c51f3f12860bb46c33262f26cfcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/262325e16082c51f3f12860bb46c33262f26cfcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90b62db741c62ce3250e4a267f57660596c8b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90b62db741c62ce3250e4a267f57660596c8b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90b62db741c62ce3250e4a267f57660596c8b3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90b62db741c62ce3250e4a267f57660596c8b3e/comments", "author": null, "committer": null, "parents": [{"sha": "85f8926ee5b22248d538d46afe3f859a4593346d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f8926ee5b22248d538d46afe3f859a4593346d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f8926ee5b22248d538d46afe3f859a4593346d"}], "stats": {"total": 317, "additions": 277, "deletions": 40}, "files": [{"sha": "98556cdc2a4ef0295fff18984b3c27ce09af9c59", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90b62db741c62ce3250e4a267f57660596c8b3e/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90b62db741c62ce3250e4a267f57660596c8b3e/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=e90b62db741c62ce3250e4a267f57660596c8b3e", "patch": "@@ -193,6 +193,10 @@ enum dwarf_attribute\n     DW_AT_MIPS_loop_unroll_factor = 0x2005,\n     DW_AT_MIPS_software_pipeline_depth = 0x2006,\n     DW_AT_MIPS_linkage_name = 0x2007,\n+    DW_AT_MIPS_stride = 0x2008,\n+    DW_AT_MIPS_abstract_name = 0x2009,\n+    DW_AT_MIPS_clone_origin = 0x200a,\n+    DW_AT_MIPS_has_inlines = 0x200b,\n     /* GNU extensions.  */\n     DW_AT_sf_names = 0x2101,\n     DW_AT_src_info = 0x2102,"}, {"sha": "fe3db1e6d5023d2270fa268cb555c659c8abd343", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 273, "deletions": 40, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90b62db741c62ce3250e4a267f57660596c8b3e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90b62db741c62ce3250e4a267f57660596c8b3e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e90b62db741c62ce3250e4a267f57660596c8b3e", "patch": "@@ -105,6 +105,7 @@ typedef struct die_struct *dw_die_ref;\n typedef struct dw_attr_struct *dw_attr_ref;\n typedef struct dw_val_struct *dw_val_ref;\n typedef struct dw_line_info_struct *dw_line_info_ref;\n+typedef struct dw_separate_line_info_struct *dw_separate_line_info_ref;\n typedef struct dw_loc_descr_struct *dw_loc_descr_ref;\n typedef struct dw_cfi_struct *dw_cfi_ref;\n typedef struct dw_fde_struct *dw_fde_ref;\n@@ -129,6 +130,16 @@ typedef struct dw_line_info_struct\n   }\n dw_line_info_entry;\n \n+/* Line information for functions in separate sections; each one gets its\n+   own sequence.  */\n+typedef struct dw_separate_line_info_struct\n+  {\n+    unsigned long dw_file_num;\n+    unsigned long dw_line_num;\n+    unsigned long function;\n+  }\n+dw_separate_line_info_entry;\n+\n /* The dw_val_node describes an attibute's value, as it is\n    represnted internally.  */\n typedef struct dw_val_struct\n@@ -448,12 +459,22 @@ static unsigned abbrev_die_table_in_use;\n #define ABBREV_DIE_TABLE_INCREMENT 256\n \n /* A pointer to the base of a table that contains line information\n-   for each source code line in the compilation unit.  */\n+   for each source code line in .text in the compilation unit.  */\n static dw_line_info_ref line_info_table;\n \n /* Number of elements currently allocated for line_info_table.  */\n static unsigned line_info_table_allocated;\n \n+/* Number of elements in separate_line_info_table currently in use.  */\n+static unsigned separate_line_info_table_in_use;\n+\n+/* A pointer to the base of a table that contains line information\n+   for each source code line outside of .text in the compilation unit.  */\n+static dw_separate_line_info_ref separate_line_info_table;\n+\n+/* Number of elements currently allocated for separate_line_info_table.  */\n+static unsigned separate_line_info_table_allocated;\n+\n /* Number of elements in line_info_table currently in use.  */\n static unsigned line_info_table_in_use;\n \n@@ -703,6 +724,9 @@ static unsigned lookup_filename ();\n #ifndef LINE_CODE_LABEL_FMT\n #define LINE_CODE_LABEL_FMT\t\".L_LC%u\"\n #endif\n+#ifndef SEPARATE_LINE_CODE_LABEL_FMT\n+#define SEPARATE_LINE_CODE_LABEL_FMT\t\".L_SLC%u\"\n+#endif\n #ifndef SFNAMES_ENTRY_LABEL_FMT\n #define SFNAMES_ENTRY_LABEL_FMT\t\".L_F%u\"\n #endif\n@@ -2212,7 +2236,7 @@ remove_AT (die, attr_kind)\n \t    if (die->die_attr_last == a->dw_attr_next)\n \t      die->die_attr_last = a;\n \t    a->dw_attr_next = a->dw_attr_next->dw_attr_next;\n-\t    return;\n+\t    break;\n \t  }\n       if (removed)\n \tfree (removed);\n@@ -2952,12 +2976,12 @@ static unsigned long\n size_of_line_info ()\n {\n   register unsigned long size;\n-  register dw_line_info_ref line_info;\n   register unsigned long lt_index;\n   register unsigned long current_line;\n   register long line_offset;\n   register long line_delta;\n   register unsigned long current_file;\n+  register unsigned long function;\n   /* Version number.  */\n   size = 2;\n   /* Prolog length specifier.  */\n@@ -2971,6 +2995,7 @@ size_of_line_info ()\n   current_line = 1;\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n+      register dw_line_info_ref line_info;\n       /* Advance pc instruction.  */\n       size += 1 + 2;\n       line_info = &line_info_table[lt_index];\n@@ -3005,6 +3030,65 @@ size_of_line_info ()\n   size += 1 + 2;\n   /* End of line number info. marker.  */\n   size += 1 + size_of_uleb128 (1) + 1;\n+  function = 0;\n+  current_file = 1;\n+  current_line = 1;\n+  for (lt_index = 0; lt_index < separate_line_info_table_in_use; )\n+    {\n+      register dw_separate_line_info_ref line_info\n+\t= &separate_line_info_table[lt_index];\n+      if (function != line_info->function)\n+\t{\n+\t  function = line_info->function;\n+\t  /* Set address register instruction.  */\n+\t  size += 1 + size_of_uleb128 (1 + PTR_SIZE)\n+\t    + 1 + PTR_SIZE;\n+\t}\n+      else\n+\t{\n+\t  /* Advance pc instruction.  */\n+\t  size += 1 + 2;\n+\t}\n+      if (line_info->dw_file_num != current_file)\n+\t{\n+\t  /* Set file number instruction.  */\n+\t  size += 1;\n+\t  current_file = line_info->dw_file_num;\n+\t  size += size_of_uleb128 (current_file);\n+\t}\n+      if (line_info->dw_line_num != current_line)\n+\t{\n+\t  line_offset = line_info->dw_line_num - current_line;\n+\t  line_delta = line_offset - DWARF_LINE_BASE;\n+\t  current_line = line_info->dw_line_num;\n+\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n+\t    {\n+\t      /* 1-byte special line number instruction.  */\n+\t      size += 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Advance line instruction.  */\n+\t      size += 1;\n+\t      size += size_of_sleb128 (line_offset);\n+\t      /* Generate line entry instruction.  */\n+\t      size += 1;\n+\t    }\n+\t}\n+      ++lt_index;\n+\n+      /* If we're done with a function, end its sequence.  */\n+      if (lt_index == separate_line_info_table_in_use\n+\t  || separate_line_info_table[lt_index].function != function)\n+\t{\n+\t  current_file = 1;\n+\t  current_line = 1;\n+\t  /* Advance pc instruction.  */\n+\t  size += 1 + 2;\n+\t  /* End of line number info. marker.  */\n+\t  size += 1 + size_of_uleb128 (1) + 1;\n+\t}\n+    }\n   return size;\n }\n \n@@ -3999,21 +4083,18 @@ output_aranges ()\n static void\n output_line_info ()\n {\n-  register unsigned long line_info_len;\n-  register unsigned long line_info_prolog_len;\n   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char prev_line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register unsigned opc;\n   register unsigned n_op_args;\n-  register dw_line_info_ref line_info;\n   register unsigned long ft_index;\n   register unsigned long lt_index;\n   register unsigned long current_line;\n   register long line_offset;\n   register long line_delta;\n   register unsigned long current_file;\n-  line_info_len = size_of_line_info ();\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, line_info_len);\n+  register unsigned long function;\n+  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, size_of_line_info ());\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Length of Source Line Info.\",\n@@ -4027,8 +4108,7 @@ output_line_info ()\n \t       ASM_COMMENT_START);\n     }\n   fputc ('\\n', asm_out_file);\n-  line_info_prolog_len = size_of_line_prolog ();\n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, line_info_prolog_len);\n+  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, size_of_line_prolog ());\n   if (flag_verbose_asm)\n     {\n       fprintf (asm_out_file, \"\\t%s Prolog Length\",\n@@ -4149,6 +4229,7 @@ output_line_info ()\n   strcpy (prev_line_label, TEXT_SECTION);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n+      register dw_line_info_ref line_info;\n       ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n       if (flag_verbose_asm)\n \t{\n@@ -4234,6 +4315,121 @@ output_line_info ()\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_end_sequence);\n   fputc ('\\n', asm_out_file);\n+\n+  function = 0;\n+  current_file = 1;\n+  current_line = 1;\n+  for (lt_index = 0; lt_index < separate_line_info_table_in_use; )\n+    {\n+      register dw_separate_line_info_ref line_info\n+\t= &separate_line_info_table[lt_index];\n+      sprintf (line_label, SEPARATE_LINE_CODE_LABEL_FMT, lt_index);\n+      if (function != line_info->function)\n+\t{\n+\t  function = line_info->function;\n+\t  /* Set the address register to the first line in the function */\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNE_set_address\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t  output_uleb128 (1 + PTR_SIZE);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_set_address);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, line_label);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      else\n+\t{\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      if (line_info->dw_file_num != current_file)\n+\t{\n+\t  current_file = line_info->dw_file_num;\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_set_file);\n+\t  if (flag_verbose_asm)\n+\t    {\n+\t      fprintf (asm_out_file,\n+\t\t       \"\\t%s DW_LNS_set_file\", ASM_COMMENT_START);\n+\t    }\n+\t  fputc ('\\n', asm_out_file);\n+\t  output_uleb128 (current_file);\n+\t  if (flag_verbose_asm)\n+\t    {\n+\t      fprintf (asm_out_file, \"\\t%s \\\"%s\\\"\",\n+\t\t       ASM_COMMENT_START, file_table[current_file]);\n+\t    }\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+      if (line_info->dw_line_num != current_line)\n+\t{\n+\t  line_offset = line_info->dw_line_num - current_line;\n+\t  line_delta = line_offset - DWARF_LINE_BASE;\n+\t  current_line = line_info->dw_line_num;\n+\t  if (line_delta >= 0 && line_delta < (DWARF_LINE_RANGE - 1))\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n+\t\t\t\t      DWARF_LINE_OPCODE_BASE + line_delta);\n+\t      if (flag_verbose_asm)\n+\t\t{\n+\t\t  fprintf (asm_out_file,\n+\t\t\t   \"\\t%s line %d\", ASM_COMMENT_START, current_line);\n+\t\t}\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n+\t  else\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_advance_line);\n+\t      if (flag_verbose_asm)\n+\t\t{\n+\t\t  fprintf (asm_out_file,\n+\t\t\t   \"\\t%s advance to line %d\",\n+\t\t\t   ASM_COMMENT_START, current_line);\n+\t\t}\n+\t      fputc ('\\n', asm_out_file);\n+\t      output_sleb128 (line_offset);\n+\t      fputc ('\\n', asm_out_file);\n+\t      ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_copy);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n+\t}\n+      ++lt_index;\n+      strcpy (prev_line_label, line_label);\n+\n+      /* If we're done with a function, end its sequence.  */\n+      if (lt_index == separate_line_info_table_in_use\n+\t  || separate_line_info_table[lt_index].function != function)\n+\t{\n+\t  current_file = 1;\n+\t  current_line = 1;\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNS_fixed_advance_pc);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNS_fixed_advance_pc\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t  sprintf (line_label, FUNC_END_LABEL_FMT, function);\n+\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, line_label, prev_line_label);\n+\t  fputc ('\\n', asm_out_file);\n+\n+\t  /* Output the marker for the end of this sequence.  */\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s DW_LNE_end_sequence\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t  output_uleb128 (1);\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, DW_LNE_end_sequence);\n+\t  fputc ('\\n', asm_out_file);\n+\t}\n+    }\n }\n \f\n /**************** attribute support utilities ********************************/\n@@ -6562,15 +6758,9 @@ gen_compile_unit_die (main_input_filename)\n     {\n       add_AT_unsigned (comp_unit_die, DW_AT_language, DW_LANG_C89);\n     }\n-  add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, TEXT_SECTION);\n-  add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, TEXT_END_LABEL);\n-  if (debug_info_level >= DINFO_LEVEL_NORMAL)\n+  if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n-      add_AT_section_offset (comp_unit_die, DW_AT_stmt_list, LINE_SECTION);\n-      if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-\t{\n-\t  add_AT_unsigned (comp_unit_die, DW_AT_macro_info, 0);\n-\t}\n+      add_AT_unsigned (comp_unit_die, DW_AT_macro_info, 0);\n     }\n }\n \n@@ -6800,7 +6990,7 @@ gen_type_die (type, context_die)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      /* For a non-file-scope tagged type, we can always go ahead and output\n+      /* For a function-scope tagged type, we can always go ahead and output\n          a Dwarf description of this type right now, even if the type in\n          question is still incomplete, because if this local type *was* ever\n          completed anywhere within its scope, that complete definition would\n@@ -6827,7 +7017,8 @@ gen_type_die (type, context_die)\n          ever going to know, so at that point in time, we can safely generate \n          correct Dwarf descriptions for these file-scope tagged types.  */\n       is_complete = TYPE_SIZE (type) != 0\n-\t|| TYPE_CONTEXT (type) != NULL\n+\t|| (TYPE_CONTEXT (type) != NULL\n+\t    && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) != 't')\n \t|| finalizing;\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n \t{\n@@ -7569,27 +7760,57 @@ dwarfout_line (filename, line)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register unsigned this_file_entry_num = lookup_filename (filename);\n-  register dw_line_info_ref line_info;\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n       function_section (current_function_decl);\n-      sprintf (label, LINE_CODE_LABEL_FMT, line_info_table_in_use);\n-      ASM_OUTPUT_LABEL (asm_out_file, label);\n-      fputc ('\\n', asm_out_file);\n \n-      /* expand the line info table if necessary */\n-      if (line_info_table_in_use == line_info_table_allocated)\n+      if (DECL_SECTION_NAME (current_function_decl))\n \t{\n-\t  line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n-\t  line_info_table\n-\t    = (dw_line_info_ref)\n-\t    xrealloc (line_info_table,\n-\t\t   line_info_table_allocated * sizeof (dw_line_info_entry));\n+\t  register dw_separate_line_info_ref line_info;\n+\t  sprintf (label, SEPARATE_LINE_CODE_LABEL_FMT,\n+\t\t   separate_line_info_table_in_use);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\t  fputc ('\\n', asm_out_file);\n+\n+\t  /* expand the line info table if necessary */\n+\t  if (separate_line_info_table_in_use\n+\t      == separate_line_info_table_allocated)\n+\t    {\n+\t      separate_line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n+\t      separate_line_info_table\n+\t\t= (dw_separate_line_info_ref) xrealloc\n+\t\t(separate_line_info_table,\n+\t\t separate_line_info_table_allocated\n+\t\t * sizeof (dw_separate_line_info_entry));\n+\t    }\n+\t  /* add the new entry at the end of the line_info_table.  */\n+\t  line_info\n+\t    = &separate_line_info_table[separate_line_info_table_in_use++];\n+\t  line_info->dw_file_num = lookup_filename (filename);\n+\t  line_info->dw_line_num = line;\n+\t  line_info->function = current_funcdef_number;\n+\t}\n+      else\n+\t{\n+\t  register dw_line_info_ref line_info;\n+\t  sprintf (label, LINE_CODE_LABEL_FMT, line_info_table_in_use);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\t  fputc ('\\n', asm_out_file);\n+\n+\t  /* expand the line info table if necessary */\n+\t  if (line_info_table_in_use == line_info_table_allocated)\n+\t    {\n+\t      line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n+\t      line_info_table\n+\t\t= (dw_line_info_ref) xrealloc\n+\t\t(line_info_table,\n+\t\t line_info_table_allocated * sizeof (dw_line_info_entry));\n+\t    }\n+\t  /* add the new entry at the end of the line_info_table.  */\n+\t  line_info = &line_info_table[line_info_table_in_use++];\n+\t  line_info->dw_file_num = lookup_filename (filename);\n+\t  line_info->dw_line_num = line;\n \t}\n-      /* add the new entry at the end of the line_info_table.  */\n-      line_info = &line_info_table[line_info_table_in_use++];\n-      line_info->dw_file_num = lookup_filename (filename);\n-      line_info->dw_line_num = line;\n     }\n }\n \n@@ -7762,17 +7983,29 @@ dwarfout_finish ()\n   ASM_OUTPUT_LABEL (asm_out_file, BSS_END_LABEL);\n #endif\n \n+  /* Output the source line correspondence table.  */\n+  if (line_info_table_in_use > 1 || separate_line_info_table_in_use)\n+    {\n+      fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_SECTION (asm_out_file, LINE_SECTION);\n+      output_line_info ();\n+\n+      /* We can only use the low/high_pc attributes if all of the code\n+\t was in .text.  */\n+      if (separate_line_info_table_in_use == 0)\n+\t{\n+\t  add_AT_lbl_id (comp_unit_die, DW_AT_low_pc, TEXT_SECTION);\n+\t  add_AT_lbl_id (comp_unit_die, DW_AT_high_pc, TEXT_END_LABEL);\n+\t}\n+      add_AT_section_offset (comp_unit_die, DW_AT_stmt_list, LINE_SECTION);\n+    }\n+\n   /* Output the abbreviation table.  */\n   fputc ('\\n', asm_out_file);\n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);\n   build_abbrev_table (comp_unit_die);\n   output_abbrev_section ();\n \n-  /* Output the source line correspondence table.  */\n-  fputc ('\\n', asm_out_file);\n-  ASM_OUTPUT_SECTION (asm_out_file, LINE_SECTION);\n-  output_line_info ();\n-\n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.   */\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n   calc_die_sizes (comp_unit_die);"}]}