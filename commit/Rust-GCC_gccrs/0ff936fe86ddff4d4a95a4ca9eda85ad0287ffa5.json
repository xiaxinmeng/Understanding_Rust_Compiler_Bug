{"sha": "0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "node_id": "C_kwDOANBUbNoAKDBmZjkzNmZlODZkZGZmNGQ0YTk1YTRjYTllZGE4NWFkMDI4N2ZmYTU", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2022-06-29T21:06:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-12T12:24:14Z"}, "message": "[Ada] Ada 2020: Allow declarative items mixed with statements\n\nThis patch implements a syntactic language extension that allows\ndeclarative items to appear in a sequence of statements.  For example:\n\n    for X in S'Range loop\n        Item : Character renames S (X);\n        Item := Transform (Item);\n    end loop;\n\nPreviously, declare/begin/end was required, which is just noise.\n\ngcc/ada/\n\n\t* par.adb (P_Declarative_Items): New function to parse a\n\tsequence of declarative items.\n\t(P_Sequence_Of_Statements): Add Handled flag, to indicate\n\twhether to wrap the result in a block statement.\n\t* par-ch3.adb (P_Declarative_Item): Rename P_Declarative_Items\n\tto be P_Declarative_Item, because it really only parses a single\n\tdeclarative item, and to avoid conflict with the new\n\tP_Declarative_Items. Add In_Statements.  We keep the old\n\terror-recovery mechanisms in place when In_Statements is False.\n\tWhen True, we don't want to complain about statements, because\n\twe are parsing a sequence of statements.\n\t(P_Identifier_Declarations): If In_Statements, and we see what\n\tlooks like a statement, we no longer give an error. We return to\n\tP_Sequence_Of_Statements with Done = True, so it can parse the\n\tstatement.\n\t* par-ch5.adb (P_Sequence_Of_Statements): Call\n\tP_Declarative_Items to parse declarative items that appear in\n\tthe statement list.  Remove error handling code that complained\n\tabout such items.  Check some errors conservatively.  Wrap the\n\tresult in a block statement when necessary.\n\t* par-ch11.adb (P_Handled_Sequence_Of_Statements): Pass\n\tHandled => True to P_Sequence_Of_Statements.\n\t* types.ads (No, Present): New functions for querying\n\tSource_Ptrs (equal, not equal No_Location).", "tree": {"sha": "68fc6f0d4c7fd847c7dabfc99864192cd14cb828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68fc6f0d4c7fd847c7dabfc99864192cd14cb828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b98bb583fbf9110e7282c1221448c15efb4bd2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b98bb583fbf9110e7282c1221448c15efb4bd2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b98bb583fbf9110e7282c1221448c15efb4bd2e"}], "stats": {"total": 478, "additions": 354, "deletions": 124}, "files": [{"sha": "33c668d3c256a12dadf1957383ffbe53c0d02f74", "filename": "gcc/ada/par-ch11.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar-ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar-ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch11.adb?ref=0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "patch": "@@ -61,7 +61,8 @@ package body Ch11 is\n       Handled_Stmt_Seq_Node :=\n         New_Node (N_Handled_Sequence_Of_Statements, Token_Ptr);\n       Set_Statements\n-        (Handled_Stmt_Seq_Node, P_Sequence_Of_Statements (SS_Extm_Sreq));\n+        (Handled_Stmt_Seq_Node,\n+         P_Sequence_Of_Statements (SS_Extm_Sreq, Handled => True));\n \n       if Token = Tok_Exception then\n          Scan; -- past EXCEPTION"}, {"sha": "82df4cf9ce2c712101b97eb4dcfcf2fa76309786", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 182, "deletions": 78, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "patch": "@@ -77,40 +77,33 @@ package body Ch3 is\n    --  are enabled, to remove the ambiguity of \"when X in A | B\". We consider\n    --  it very unlikely that this will ever arise in practice.\n \n-   procedure P_Declarative_Items\n+   procedure P_Declarative_Item\n      (Decls              : List_Id;\n       Done               : out Boolean;\n       Declare_Expression : Boolean;\n-      In_Spec            : Boolean);\n-   --  Scans out a single declarative item, or, in the case of a declaration\n-   --  with a list of identifiers, a list of declarations, one for each of the\n-   --  identifiers in the list. The declaration or declarations scanned are\n-   --  appended to the given list. Done indicates whether or not there may be\n-   --  additional declarative items to scan. If Done is True, then a decision\n-   --  has been made that there are no more items to scan. If Done is False,\n-   --  then there may be additional declarations to scan.\n-   --\n-   --  Declare_Expression is true if we are parsing a declare_expression, in\n-   --  which case we want to suppress certain style checking.\n-   --\n-   --  In_Spec is true if we are scanning a package declaration, and is used to\n-   --  generate an appropriate message if a statement is encountered in such a\n-   --  context.\n+      In_Spec            : Boolean;\n+      In_Statements      : Boolean);\n+   --  Parses a single declarative item. The parameters have the same meaning\n+   --  as for P_Declarative_Items. If the declarative item has multiple\n+   --  identifiers, as in \"X, Y, Z : ...\", then one declaration is appended to\n+   --  Decls for each of the identifiers.\n \n    procedure P_Identifier_Declarations\n-     (Decls   : List_Id;\n-      Done    : out Boolean;\n-      In_Spec : Boolean);\n-   --  Scans out a set of declarations for an identifier or list of\n-   --  identifiers, and appends them to the given list. The parameters have\n-   --  the same significance as for P_Declarative_Items.\n+     (Decls         : List_Id;\n+      Done          : out Boolean;\n+      In_Spec       : Boolean;\n+      In_Statements : Boolean);\n+   --  Parses a sequence of declarations for an identifier or list of\n+   --  identifiers, and appends them to the given list. The parameters\n+   --  have the same meaning as for P_Declarative_Items.\n \n    procedure Statement_When_Declaration_Expected\n      (Decls   : List_Id;\n       Done    : out Boolean;\n       In_Spec : Boolean);\n    --  Called when a statement is found at a point where a declaration was\n-   --  expected. The parameters are as described for P_Declarative_Items.\n+   --  expected. The parameters have the same meaning as for\n+   --  P_Declarative_Items.\n \n    procedure Set_Declaration_Expected;\n    --  Posts a \"declaration expected\" error messages at the start of the\n@@ -1307,9 +1300,10 @@ package body Ch3 is\n    --  Error recovery: can raise Error_Resync\n \n    procedure P_Identifier_Declarations\n-     (Decls   : List_Id;\n-      Done    : out Boolean;\n-      In_Spec : Boolean)\n+     (Decls         : List_Id;\n+      Done          : out Boolean;\n+      In_Spec       : Boolean;\n+      In_Statements : Boolean)\n    is\n       Acc_Node         : Node_Id;\n       Decl_Node        : Node_Id;\n@@ -1331,6 +1325,13 @@ package body Ch3 is\n       Num_Idents : Nat := 1;\n       --  Number of identifiers stored in Idents\n \n+      function Identifier_Starts_Statement return Boolean;\n+      --  Called with Token being an identifier that might start a declaration\n+      --  or a statement. True if we are parsing declarations in a sequence of\n+      --  statements, and this identifier is the start of a statement. If this\n+      --  is true, we quit parsing declarations, and return Done = True so the\n+      --  caller will switch to parsing statements.\n+\n       procedure No_List;\n       --  This procedure is called in renames cases to make sure that we do\n       --  not have more than one identifier. If we do have more than one\n@@ -1342,6 +1343,55 @@ package body Ch3 is\n       --  returns True, otherwise returns False. Includes checking for some\n       --  common error cases.\n \n+      ---------------------------------\n+      -- Identifier_Starts_Statement --\n+      ---------------------------------\n+\n+      function Identifier_Starts_Statement return Boolean is\n+         pragma Assert (Token = Tok_Identifier);\n+         Scan_State : Saved_Scan_State;\n+         Result : Boolean := False;\n+      begin\n+         if not In_Statements then\n+            return False;\n+         end if;\n+\n+         Save_Scan_State (Scan_State);\n+         Scan;\n+\n+         case Token is\n+            when Tok_Comma => -- \"X, ...\" is a declaration\n+               null;\n+\n+            when Tok_Colon =>\n+               --  \"X : ...\" is usually a declaration, but \"X : begin...\"  is\n+               --  not. We return true for things like \"X : Y : begin...\",\n+               --  which is a syntax error, because that gives better error\n+               --  recovery for some ACATS.\n+\n+               Scan;\n+\n+               if Token in Token_Class_Labeled_Stmt then\n+                  Result := True;\n+\n+               elsif Token = Tok_Identifier then\n+                  Scan;\n+                  if Token = Tok_Colon then\n+                     Scan;\n+                     if Token in Token_Class_Labeled_Stmt then\n+                        Result := True;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+            when others =>\n+               Result := True;\n+         end case;\n+\n+         Restore_Scan_State (Scan_State);\n+         return Result;\n+      end Identifier_Starts_Statement;\n+\n       -------------\n       -- No_List --\n       -------------\n@@ -1395,6 +1445,11 @@ package body Ch3 is\n    --  Start of processing for P_Identifier_Declarations\n \n    begin\n+      if Identifier_Starts_Statement then\n+         Done := True;\n+         return;\n+      end if;\n+\n       Ident_Sloc := Token_Ptr;\n       Save_Scan_State (Scan_State); -- at first identifier\n       Idents (1) := P_Defining_Identifier (C_Comma_Colon);\n@@ -1514,6 +1569,10 @@ package body Ch3 is\n          --  Otherwise we definitely have an ordinary identifier with a junk\n          --  token after it.\n \n+         elsif In_Statements then\n+            Done := True;\n+            return;\n+\n          else\n             --  If in -gnatd.2 mode, try for statements\n \n@@ -4464,13 +4523,11 @@ package body Ch3 is\n \n    --  DECLARATIVE_PART ::= {DECLARATIVE_ITEM}\n \n-   --  Error recovery: cannot raise Error_Resync (because P_Declarative_Items\n+   --  Error recovery: cannot raise Error_Resync (because P_Declarative_Item\n    --  handles errors, and returns cleanly after an error has occurred)\n \n    function P_Declarative_Part return List_Id is\n-      Decls : List_Id;\n-      Done  : Boolean;\n-\n+      Decls : constant List_Id := New_List;\n    begin\n       --  Indicate no bad declarations detected yet. This will be reset by\n       --  P_Declarative_Items if a bad declaration is discovered.\n@@ -4482,15 +4539,10 @@ package body Ch3 is\n       --  discussion in Par for further details\n \n       SIS_Entry_Active := False;\n-      Decls := New_List;\n \n-      --  Loop to scan out the declarations\n-\n-      loop\n-         P_Declarative_Items\n-           (Decls, Done, Declare_Expression => False, In_Spec => False);\n-         exit when Done;\n-      end loop;\n+      P_Declarative_Items\n+        (Decls, Declare_Expression => False,\n+         In_Spec => False, In_Statements => False);\n \n       --  Get rid of active SIS entry which is left set only if we scanned a\n       --  procedure declaration and have not found the body. We could give\n@@ -4514,11 +4566,12 @@ package body Ch3 is\n    --  Error recovery: cannot raise Error_Resync. If an error resync occurs,\n    --  then the scan is set past the next semicolon and Error is returned.\n \n-   procedure P_Declarative_Items\n+   procedure P_Declarative_Item\n      (Decls              : List_Id;\n       Done               : out Boolean;\n       Declare_Expression : Boolean;\n-      In_Spec            : Boolean)\n+      In_Spec            : Boolean;\n+      In_Statements      : Boolean)\n    is\n       Scan_State : Saved_Scan_State;\n \n@@ -4549,20 +4602,38 @@ package body Ch3 is\n             Save_Scan_State (Scan_State);\n             Scan; -- past FOR\n \n-            if Token = Tok_Identifier then\n-               Scan; -- past identifier\n-\n-               if Token = Tok_In then\n-                  Restore_Scan_State (Scan_State);\n-                  Statement_When_Declaration_Expected (Decls, Done, In_Spec);\n-                  return;\n+            declare\n+               Is_Statement : Boolean := True;\n+            begin\n+               if Token = Tok_Identifier then\n+                  Scan; -- past identifier\n+                  if Token in Tok_Use | Tok_Apostrophe then\n+                     Is_Statement := False;\n+                  elsif Token = Tok_Dot then\n+                     Scan;\n+                     if Token = Tok_Identifier then\n+                        Scan;\n+                        Is_Statement := Token in Tok_In | Tok_Of;\n+                     end if;\n+                  end if;\n+               else\n+                  Is_Statement := False;\n                end if;\n-            end if;\n \n-            --  Not a loop, so must be rep clause\n+               Restore_Scan_State (Scan_State);\n \n-            Restore_Scan_State (Scan_State);\n-            Append (P_Representation_Clause, Decls);\n+               if Is_Statement then\n+                  if not In_Statements then\n+                     Statement_When_Declaration_Expected\n+                       (Decls, Done, In_Spec);\n+                  end if;\n+\n+                  Done := True;\n+                  return;\n+               else\n+                  Append (P_Representation_Clause, Decls);\n+               end if;\n+            end;\n \n          when Tok_Generic =>\n             Check_Bad_Layout;\n@@ -4585,15 +4656,22 @@ package body Ch3 is\n             --  Normal case, no overriding, or overriding followed by colon\n \n             else\n-               P_Identifier_Declarations (Decls, Done, In_Spec);\n+               P_Identifier_Declarations (Decls, Done, In_Spec, In_Statements);\n             end if;\n \n          when Tok_Package =>\n             Check_Bad_Layout;\n             Append (P_Package (Pf_Decl_Gins_Pbod_Rnam_Stub_Pexp), Decls);\n \n          when Tok_Pragma =>\n-            Append (P_Pragma, Decls);\n+            --  If we see a pragma and In_Statements is true, we want to let\n+            --  the statement-parser deal with it.\n+\n+            if In_Statements then\n+               Done := True;\n+            else\n+               Append (P_Pragma, Decls);\n+            end if;\n \n          when Tok_Protected =>\n             Check_Bad_Layout;\n@@ -4779,10 +4857,16 @@ package body Ch3 is\n             | Tok_Select\n             | Tok_While\n          =>\n-            --  But before we decide that it's a statement, let's check for\n-            --  a reserved word misused as an identifier.\n+            --  If we parsing declarations in a sequence of statements, we want\n+            --  to let the caller continue parsing statements.\n \n-            if Is_Reserved_Identifier then\n+            if In_Statements then\n+               Done := True;\n+\n+            --  Otherwise, give an error. But before we decide that it's a\n+            --  statement, check for a reserved word misused as an identifier.\n+\n+            elsif Is_Reserved_Identifier then\n                Save_Scan_State (Scan_State);\n                Scan; -- past the token\n \n@@ -4799,23 +4883,31 @@ package body Ch3 is\n                else\n                   Restore_Scan_State (Scan_State);\n                   Scan_Reserved_Identifier (Force_Msg => True);\n-                  P_Identifier_Declarations (Decls, Done, In_Spec);\n+                  P_Identifier_Declarations\n+                    (Decls, Done, In_Spec, In_Statements);\n                end if;\n \n-            --  If not reserved identifier, then it's definitely a statement\n+            --  If not reserved identifier, then it's an incorrectly placed a\n+            --  statement.\n \n             else\n                Statement_When_Declaration_Expected (Decls, Done, In_Spec);\n                return;\n             end if;\n \n          --  The token RETURN may well also signal a missing BEGIN situation,\n-         --  however, we never let it end the declarative part, because it may\n-         --  also be part of a half-baked function declaration.\n+         --  however, we never let it end the declarative part, because it\n+         --  might also be part of a half-baked function declaration. If we are\n+         --  In_Statements, then let the caller parse it; otherwise, it's an\n+         --  error.\n \n          when Tok_Return =>\n-            Error_Msg_SC (\"misplaced RETURN statement\");\n-            raise Error_Resync;\n+            if In_Statements then\n+               Done := True;\n+            else\n+               Error_Msg_SC (\"misplaced RETURN statement\");\n+               raise Error_Resync;\n+            end if;\n \n          --  PRIVATE definitely terminates the declarations in a spec,\n          --  and is an error in a body.\n@@ -4838,6 +4930,10 @@ package body Ch3 is\n          --  But first check for misuse of a reserved identifier.\n \n          when others =>\n+            if In_Statements then\n+               Done := True;\n+               return;\n+            end if;\n \n             --  Here we check for a reserved identifier\n \n@@ -4853,7 +4949,8 @@ package body Ch3 is\n                   Restore_Scan_State (Scan_State);\n                   Scan_Reserved_Identifier (Force_Msg => True);\n                   Check_Bad_Layout;\n-                  P_Identifier_Declarations (Decls, Done, In_Spec);\n+                  P_Identifier_Declarations\n+                    (Decls, Done, In_Spec, In_Statements);\n                end if;\n \n             else\n@@ -4869,6 +4966,21 @@ package body Ch3 is\n    exception\n       when Error_Resync =>\n          Resync_Past_Semicolon;\n+   end P_Declarative_Item;\n+\n+   procedure P_Declarative_Items\n+     (Decls              : List_Id;\n+      Declare_Expression : Boolean;\n+      In_Spec            : Boolean;\n+      In_Statements      : Boolean)\n+   is\n+      Done  : Boolean;\n+   begin\n+      loop\n+         P_Declarative_Item\n+           (Decls, Done, Declare_Expression, In_Spec, In_Statements);\n+         exit when Done;\n+      end loop;\n    end P_Declarative_Items;\n \n    ----------------------------------\n@@ -4888,9 +5000,8 @@ package body Ch3 is\n      (Declare_Expression : Boolean) return List_Id\n    is\n       Decl  : Node_Id;\n-      Decls : List_Id;\n+      Decls : constant List_Id := New_List;\n       Kind  : Node_Kind;\n-      Done  : Boolean;\n \n    begin\n       --  Indicate no bad declarations detected yet in the current context:\n@@ -4904,15 +5015,8 @@ package body Ch3 is\n \n       SIS_Entry_Active := False;\n \n-      --  Loop to scan out declarations\n-\n-      Decls := New_List;\n-\n-      loop\n-         P_Declarative_Items\n-           (Decls, Done, Declare_Expression, In_Spec => True);\n-         exit when Done;\n-      end loop;\n+      P_Declarative_Items\n+        (Decls, Declare_Expression, In_Spec => True, In_Statements => False);\n \n       --  Get rid of active SIS entry. This is set only if we have scanned a\n       --  procedure declaration and have not found the body. We could give\n@@ -5007,11 +5111,11 @@ package body Ch3 is\n    ----------------------\n \n    procedure Skip_Declaration (S : List_Id) is\n-      Dummy_Done : Boolean;\n-      pragma Warnings (Off, Dummy_Done);\n+      Ignored_Done : Boolean;\n    begin\n-      P_Declarative_Items\n-        (S, Dummy_Done, Declare_Expression => False, In_Spec => False);\n+      P_Declarative_Item\n+        (S, Ignored_Done, Declare_Expression => False, In_Spec => False,\n+         In_Statements => False);\n    end Skip_Declaration;\n \n    -----------------------------------------"}, {"sha": "3835588fa8d47841848129b0599b3bfd2fb0fdb4", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 141, "deletions": 44, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "patch": "@@ -144,8 +144,9 @@ package body Ch5 is\n    --  parsing a statement, then the scan pointer is advanced past the next\n    --  semicolon and the parse continues.\n \n-   function P_Sequence_Of_Statements (SS_Flags : SS_Rec) return List_Id is\n-\n+   function P_Sequence_Of_Statements\n+     (SS_Flags : SS_Rec; Handled : Boolean := False) return List_Id\n+   is\n       Statement_Required : Boolean;\n       --  This flag indicates if a subsequent statement (other than a pragma)\n       --  is required. It is initialized from the Sreq flag, and modified as\n@@ -158,11 +159,6 @@ package body Ch5 is\n       --  sequence cannot contain only labels. This flag is set whenever a\n       --  label is encountered, to enforce this rule at the end of a sequence.\n \n-      Declaration_Found : Boolean := False;\n-      --  This flag is set True if a declaration is encountered, so that the\n-      --  error message about declarations in the statement part is only\n-      --  given once for a given sequence of statements.\n-\n       Scan_State_Label : Saved_Scan_State;\n       Scan_State       : Saved_Scan_State;\n \n@@ -171,28 +167,12 @@ package body Ch5 is\n       Id_Node        : Node_Id;\n       Name_Node      : Node_Id;\n \n-      procedure Junk_Declaration;\n-      --  Procedure called to handle error of declaration encountered in\n-      --  statement sequence.\n+      Decl_Loc, Label_Loc : Source_Ptr := No_Location;\n+      --  Sloc of the first declaration/label encountered, if any.\n \n       procedure Test_Statement_Required;\n       --  Flag error if Statement_Required flag set\n \n-      ----------------------\n-      -- Junk_Declaration --\n-      ----------------------\n-\n-      procedure Junk_Declaration is\n-      begin\n-         if (not Declaration_Found) or All_Errors_Mode then\n-            Error_Msg_SC -- CODEFIX\n-              (\"declarations must come before BEGIN\");\n-            Declaration_Found := True;\n-         end if;\n-\n-         Skip_Declaration (Statement_List);\n-      end Junk_Declaration;\n-\n       -----------------------------\n       -- Test_Statement_Required --\n       -----------------------------\n@@ -243,9 +223,10 @@ package body Ch5 is\n                   Append_To (Statement_List, Null_Stm);\n                end;\n \n-            --  If not Ada 2012, or not special case above, give error message\n+            --  If not Ada 2012, or not special case above, and no declaration\n+            --  seen (as allowed in Ada 2020), give error message.\n \n-            else\n+            elsif No (Decl_Loc) then\n                Error_Msg_BC -- CODEFIX\n                  (\"statement expected\");\n             end if;\n@@ -259,9 +240,45 @@ package body Ch5 is\n       Statement_Required := SS_Flags.Sreq;\n       Statement_Seen     := False;\n \n+      --  In Ada 2022, we allow declarative items to be mixed with\n+      --  statements. The loop below alternates between calling\n+      --  P_Declarative_Items to parse zero or more declarative items, and\n+      --  parsing a statement.\n+\n       loop\n          Ignore (Tok_Semicolon);\n \n+         declare\n+            Num_Statements : constant Nat := List_Length (Statement_List);\n+         begin\n+            P_Declarative_Items\n+              (Statement_List, Declare_Expression => False,\n+               In_Spec => False, In_Statements => True);\n+\n+            --  Use the length of the list to determine whether we parsed any\n+            --  declarative items. If so, it's an error pre-2022. ???We should\n+            --  be calling Error_Msg_Ada_2022_Feature below, to advertise the\n+            --  new feature, but that causes a lot of test diffs, so for now,\n+            --  we mimic the old \"...before begin\" message.\n+\n+            if List_Length (Statement_List) > Num_Statements then\n+               if All_Errors_Mode or else No (Decl_Loc) then\n+                  Decl_Loc := Sloc (Pick (Statement_List, Num_Statements + 1));\n+\n+                  if False then\n+                     Error_Msg_Ada_2022_Feature\n+                       (\"declarations mixed with statements\",\n+                        Sloc (Pick (Statement_List, Num_Statements + 1)));\n+                  else\n+                     if Ada_Version < Ada_2022 then\n+                        Error_Msg\n+                          (\"declarations must come before BEGIN\", Decl_Loc);\n+                     end if;\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n+\n          begin\n             if Style_Check then\n                Style.Check_Indentation;\n@@ -613,14 +630,6 @@ package body Ch5 is\n                         Append_To (Statement_List,\n                           P_For_Statement (Id_Node));\n \n-                     --  Improper statement follows label. If we have an\n-                     --  expression token, then assume the colon was part\n-                     --  of a misplaced declaration.\n-\n-                     elsif Token not in Token_Class_Eterm then\n-                        Restore_Scan_State (Scan_State_Label);\n-                        Junk_Declaration;\n-\n                      --  Otherwise complain we have inappropriate statement\n \n                      else\n@@ -811,6 +820,10 @@ package body Ch5 is\n                   Append_To (Statement_List, P_Label);\n                   Statement_Required := True;\n \n+                  if No (Label_Loc) then\n+                     Label_Loc := Sloc (Last (Statement_List));\n+                  end if;\n+\n                --  Pragma appearing as a statement in a statement sequence\n \n                when Tok_Pragma =>\n@@ -941,14 +954,9 @@ package body Ch5 is\n                --  handling of a bad statement.\n \n                when others =>\n-                  if Token in Token_Class_Declk then\n-                     Junk_Declaration;\n-\n-                  else\n-                     Error_Msg_BC -- CODEFIX\n-                       (\"statement expected\");\n-                     raise Error_Resync;\n-                  end if;\n+                  Error_Msg_BC -- CODEFIX\n+                    (\"statement expected\");\n+                  raise Error_Resync;\n             end case;\n \n          --  On error resynchronization, skip past next semicolon, and, since\n@@ -966,7 +974,96 @@ package body Ch5 is\n          exit when SS_Flags.Unco;\n       end loop;\n \n-      return Statement_List;\n+      --  If there are no declarative items in the list, or if the list is part\n+      --  of a handled sequence of statements, we just return the list.\n+      --  Otherwise, we wrap the list in a block statement, so the declarations\n+      --  will have a proper scope. In the Handled case, it would be wrong to\n+      --  wrap, because we want the code before and after \"begin\" to be in the\n+      --  same scope. Example:\n+      --\n+      --     if ... then\n+      --        use Some_Package;\n+      --        Do_Something (...);\n+      --     end if;\n+      --\n+      --  is tranformed into:\n+      --\n+      --     if ... then\n+      --        begin\n+      --           use Some_Package;\n+      --           Do_Something (...);\n+      --        end;\n+      --     end if;\n+      --\n+      --  But we don't wrap this:\n+      --\n+      --     declare\n+      --        X : Integer;\n+      --     begin\n+      --        X : Integer;\n+      --\n+      --  Otherwise, we would fail to detect the error (conflicting X's).\n+      --  Similarly, if a representation clause appears in the statement\n+      --  part, we don't want it to appear more nested than the declarative\n+      --  part -- that would cause an unwanted error.\n+\n+      if Present (Decl_Loc) then\n+         --  Forbid labels and declarative items from coexisting. Otherwise,\n+         --  one could jump past a declaration, leading to chaos. Jumping\n+         --  backward past a declaration is also questionable -- does the\n+         --  declaration get elaborated again? Is secondary stack storage\n+         --  reclaimed? (A more liberal rule was proposed, but this is what\n+         --  we're doing for now.)\n+\n+         if Present (Label_Loc) then\n+            Error_Msg (\"declarative item in same list as label\", Decl_Loc);\n+            Error_Msg (\"label in same list as declarative item\", Label_Loc);\n+         end if;\n+\n+         --  Forbid exception handlers and declarative items from\n+         --  coexisting. Example:\n+         --\n+         --     X : Integer := 123;\n+         --     procedure P is\n+         --     begin\n+         --        X : Integer := 456;\n+         --     exception\n+         --        when Cain =>\n+         --           Put(X);\n+         --     end P;\n+         --\n+         --  It was proposed that in the handler, X should refer to the outer\n+         --  X, but that's just confusing.\n+\n+         if Token = Tok_Exception then\n+            Error_Msg\n+              (\"declarative item in statements conflicts with \" &\n+               \"exception handler below\",\n+               Decl_Loc);\n+            Error_Msg\n+              (\"exception handler conflicts with \" &\n+               \"declarative item in statements above\",\n+               Token_Ptr);\n+         end if;\n+\n+         if Handled then\n+            return Statement_List;\n+         else\n+            declare\n+               Loc : constant Source_Ptr := Sloc (First (Statement_List));\n+               Block : constant Node_Id :=\n+                 Make_Block_Statement\n+                   (Loc,\n+                    Handled_Statement_Sequence =>\n+                      Make_Handled_Sequence_Of_Statements\n+                        (Loc, Statements => Statement_List));\n+            begin\n+               return New_List (Block);\n+            end;\n+         end if;\n+      else\n+         return Statement_List;\n+      end if;\n    end P_Sequence_Of_Statements;\n \n    --------------------"}, {"sha": "b6ffdae90829fd390e45911d8edeb4d4d5a22e7f", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "patch": "@@ -701,6 +701,28 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Subtype_Mark_Resync                  return Node_Id;\n       function P_Unknown_Discriminant_Part_Opt        return Boolean;\n \n+      procedure P_Declarative_Items\n+        (Decls              : List_Id;\n+         Declare_Expression : Boolean;\n+         In_Spec            : Boolean;\n+         In_Statements      : Boolean);\n+      --  Parses a sequence of zero or more declarative items, and appends them\n+      --  to Decls. Done indicates whether or not there might be additional\n+      --  declarative items to parse. If Done is True, then there are no more\n+      --  to parse; otherwise there might be more.\n+      --\n+      --  Declare_Expression is true if we are parsing a declare_expression, in\n+      --  which case we want to suppress certain style checking.\n+      --\n+      --  In_Spec is true if we are scanning a package declaration, and is used\n+      --  to generate an appropriate message if a statement is encountered in\n+      --  such a context.\n+      --\n+      --  In_Statements is true if we are called to parse declarative items in\n+      --  a sequence of statements. In this case, we do not give an error upon\n+      --  encountering a statement, but return to the caller with Done = True,\n+      --  so the caller can resume parsing statements.\n+\n       function P_Basic_Declarative_Items\n         (Declare_Expression : Boolean) return List_Id;\n       --  Used to parse the declarative items in a package visible or\n@@ -858,9 +880,11 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Loop_Parameter_Specification return Node_Id;\n       --  Used in loop constructs and quantified expressions.\n \n-      function P_Sequence_Of_Statements (SS_Flags : SS_Rec) return List_Id;\n+      function P_Sequence_Of_Statements\n+        (SS_Flags : SS_Rec; Handled : Boolean := False) return List_Id;\n       --  The argument indicates the acceptable termination tokens.\n       --  See body in Par.Ch5 for details of the use of this parameter.\n+      --  Handled is true if we are parsing a handled sequence of statements.\n \n       procedure Parse_Decls_Begin_End (Parent : Node_Id);\n       --  Parses declarations and handled statement sequence, setting"}, {"sha": "aae51a2def6b776ffb1f10d105afcadf28536242", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=0ff936fe86ddff4d4a95a4ca9eda85ad0287ffa5", "patch": "@@ -247,6 +247,10 @@ package Types is\n    --  (very often we conditionalize so that we set No_Location in normal mode\n    --  and the corresponding source line in -gnatD mode).\n \n+   function No (Loc : Source_Ptr) return Boolean is (Loc = No_Location);\n+   function Present (Loc : Source_Ptr) return Boolean is (not No (Loc));\n+   --  Tests for No_Location / not No_Location\n+\n    Standard_Location : constant Source_Ptr := -2;\n    --  Used for all nodes in the representation of package Standard other than\n    --  nodes representing the contents of Standard.ASCII. Note that testing for"}]}