{"sha": "f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "node_id": "C_kwDOANBUbNoAKGY5ZTkwMGNlOWIxN2RjN2QzYTM4MDlkMGIwNjQ4ZWJlNTI5YTg3YzU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-06T10:16:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-06T10:16:29Z"}, "message": "c++: Further address_compare fixes [PR89074]\n\nThis patch introduces folding_cxx_constexpr, folding_initializer is used\nfor both C and C++ initializer/constant expression folding and enables more\noptimizations over what we do normally at runtime, while folding_cxx_constexpr\nis used only during C++ constant expression folding and disables some optimizations.\n\nThe patch improves STRING_CST vs. STRING_CST folding, for folding_initializer\nFUNCTION_DECL vs. FUNCTION_DECL folding, disables some optimizations like\nis_global_var != is_global_var or STRING_CST vs. DECL_P for folding_cxx_constexpr\netc.\n\n2022-02-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/89074\n\tPR c++/104033\n\t* fold-const.h (folding_initializer): Adjust comment.\n\t(folding_cxx_constexpr): Declare.\n\t* fold-const.cc (folding_initializer): Adjust comment.\n\t(folding_cxx_constexpr): New variable.\n\t(address_compare): Restrict the decl vs. STRING_CST\n\tor vice versa or STRING_CST vs. STRING_CST or\n\tis_global_var != is_global_var optimizations to !folding_cxx_constexpr.\n\tPunt for FUNCTION_DECLs with non-zero offsets.  If folding_initializer,\n\tassume non-aliased functions have non-zero size and have different\n\taddresses.  For folding_cxx_constexpr, punt on comparisons of start\n\tof some object and end of another one, regardless whether it is a decl\n\tor string literal.  Also punt for folding_cxx_constexpr on\n\tSTRING_CST vs. STRING_CST comparisons if the two literals could be\n\toverlapping.\n\n\t* constexpr.cc (cxx_eval_binary_expression): Temporarily set\n\tfolding_cxx_constexpr.\n\n\t* g++.dg/cpp1y/constexpr-89074-3.C: New test.", "tree": {"sha": "262e687be417a4cc508b4138e66606766d593aa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/262e687be417a4cc508b4138e66606766d593aa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "661109b024488eed91cc9006da25e9b8d795d409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661109b024488eed91cc9006da25e9b8d795d409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661109b024488eed91cc9006da25e9b8d795d409"}], "stats": {"total": 299, "additions": 264, "deletions": 35}, "files": [{"sha": "fd051172e00a51c2e7d6b8dd98ddcad13d01080e", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "patch": "@@ -3413,7 +3413,10 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n       if (ctx->manifestly_const_eval\n \t  && (flag_constexpr_fp_except\n \t      || TREE_CODE (type) != REAL_TYPE))\n-\tr = fold_binary_initializer_loc (loc, code, type, lhs, rhs);\n+\t{\n+\t  auto ofcc = make_temp_override (folding_cxx_constexpr, true);\n+\t  r = fold_binary_initializer_loc (loc, code, type, lhs, rhs);\n+\t}\n       else\n \tr = fold_binary_loc (loc, code, type, lhs, rhs);\n     }"}, {"sha": "386d5732ea0c719248076775d95555378e388833", "filename": "gcc/fold-const.cc", "status": "modified", "additions": 119, "deletions": 32, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Ffold-const.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Ffold-const.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.cc?ref=f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "patch": "@@ -86,9 +86,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range.h\"\n \n /* Nonzero if we are folding constants inside an initializer or a C++\n-   manifestly-constant-evaluated context; zero otherwise.  */\n+   manifestly-constant-evaluated context; zero otherwise.\n+   Should be used when folding in initializer enables additional\n+   optimizations.  */\n int folding_initializer = 0;\n \n+/* Nonzero if we are folding C++ manifestly-constant-evaluated context; zero\n+   otherwise.\n+   Should be used when certain constructs shouldn't be optimized\n+   during folding in that context.  */\n+bool folding_cxx_constexpr = false;\n+\n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n    on relational comparison operators, such as AND and OR.  */\n@@ -16572,6 +16580,7 @@ tree_nonzero_bits (const_tree t)\n \n /* Helper function for address compare simplifications in match.pd.\n    OP0 and OP1 are ADDR_EXPR operands being compared by CODE.\n+   TYPE is the type of comparison operands.\n    BASE0, BASE1, OFF0 and OFF1 are set by the function.\n    GENERIC is true if GENERIC folding and false for GIMPLE folding.\n    Returns 0 if OP0 is known to be unequal to OP1 regardless of OFF{0,1},\n@@ -16648,44 +16657,66 @@ address_compare (tree_code code, tree type, tree op0, tree op1,\n   if (code != EQ_EXPR && code != NE_EXPR)\n     return 2;\n \n+  /* At this point we know (or assume) the two pointers point at\n+     different objects.  */\n   HOST_WIDE_INT ioff0 = -1, ioff1 = -1;\n   off0.is_constant (&ioff0);\n   off1.is_constant (&ioff1);\n-  if ((DECL_P (base0) && TREE_CODE (base1) == STRING_CST)\n-       || (TREE_CODE (base0) == STRING_CST && DECL_P (base1))\n-       || (TREE_CODE (base0) == STRING_CST\n-\t   && TREE_CODE (base1) == STRING_CST\n-\t   && ioff0 >= 0 && ioff1 >= 0\n-\t   && ioff0 < TREE_STRING_LENGTH (base0)\n-\t   && ioff1 < TREE_STRING_LENGTH (base1)\n-\t  /* This is a too conservative test that the STRING_CSTs\n-\t     will not end up being string-merged.  */\n-\t   && strncmp (TREE_STRING_POINTER (base0) + ioff0,\n-\t\t       TREE_STRING_POINTER (base1) + ioff1,\n-\t\t       MIN (TREE_STRING_LENGTH (base0) - ioff0,\n-\t\t\t    TREE_STRING_LENGTH (base1) - ioff1)) != 0))\n-    ;\n-  else if (!DECL_P (base0) || !DECL_P (base1))\n+  /* Punt on non-zero offsets from functions.  */\n+  if ((TREE_CODE (base0) == FUNCTION_DECL && ioff0)\n+      || (TREE_CODE (base1) == FUNCTION_DECL && ioff1))\n     return 2;\n-  /* If this is a pointer comparison, ignore for now even\n-     valid equalities where one pointer is the offset zero\n-     of one object and the other to one past end of another one.  */\n-  else if (!folding_initializer && !INTEGRAL_TYPE_P (type))\n-    ;\n-  /* Assume that automatic variables can't be adjacent to global\n-     variables.  */\n-  else if (is_global_var (base0) != is_global_var (base1))\n-    ;\n+  /* Or if the bases are neither decls nor string literals.  */\n+  if (!DECL_P (base0) && TREE_CODE (base0) != STRING_CST)\n+    return 2;\n+  if (!DECL_P (base1) && TREE_CODE (base1) != STRING_CST)\n+    return 2;\n+  /* For initializers, assume addresses of different functions are\n+     different.  */\n+  if (folding_initializer\n+      && TREE_CODE (base0) == FUNCTION_DECL\n+      && TREE_CODE (base1) == FUNCTION_DECL)\n+    return 0;\n+\n+  /* Compute whether one address points to the start of one\n+     object and another one to the end of another one.  */\n+  poly_int64 size0 = 0, size1 = 0;\n+  if (TREE_CODE (base0) == STRING_CST)\n+    {\n+      if (ioff0 < 0 || ioff0 > TREE_STRING_LENGTH (base0))\n+\tequal = 2;\n+      else\n+\tsize0 = TREE_STRING_LENGTH (base0);\n+    }\n+  else if (TREE_CODE (base0) == FUNCTION_DECL)\n+    size0 = 1;\n   else\n     {\n       tree sz0 = DECL_SIZE_UNIT (base0);\n+      if (!tree_fits_poly_int64_p (sz0))\n+\tequal = 2;\n+      else\n+\tsize0 = tree_to_poly_int64 (sz0);\n+    }\n+  if (TREE_CODE (base1) == STRING_CST)\n+    {\n+      if (ioff1 < 0 || ioff1 > TREE_STRING_LENGTH (base1))\n+\tequal = 2;\n+      else\n+\tsize1 = TREE_STRING_LENGTH (base1);\n+    }\n+  else if (TREE_CODE (base1) == FUNCTION_DECL)\n+    size1 = 1;\n+  else\n+    {\n       tree sz1 = DECL_SIZE_UNIT (base1);\n-      /* If sizes are unknown, e.g. VLA or not representable, punt.  */\n-      if (!tree_fits_poly_int64_p (sz0) || !tree_fits_poly_int64_p (sz1))\n-\treturn 2;\n-\n-      poly_int64 size0 = tree_to_poly_int64 (sz0);\n-      poly_int64 size1 = tree_to_poly_int64 (sz1);\n+      if (!tree_fits_poly_int64_p (sz1))\n+\tequal = 2;\n+      else\n+\tsize1 = tree_to_poly_int64 (sz1);\n+    }\n+  if (equal == 0)\n+    {\n       /* If one offset is pointing (or could be) to the beginning of one\n \t object and the other is pointing to one past the last byte of the\n \t other object, punt.  */\n@@ -16701,7 +16732,63 @@ address_compare (tree_code code, tree type, tree op0, tree op1,\n \t  && (known_ne (off0, 0)\n \t      || (known_ne (size0, 0) && known_ne (size1, 0))))\n \tequal = 0;\n-     }\n+    }\n+\n+  /* At this point, equal is 2 if either one or both pointers are out of\n+     bounds of their object, or one points to start of its object and the\n+     other points to end of its object.  This is unspecified behavior\n+     e.g. in C++.  Otherwise equal is 0.  */\n+  if (folding_cxx_constexpr && equal)\n+    return equal;\n+\n+  /* When both pointers point to string literals, even when equal is 0,\n+     due to tail merging of string literals the pointers might be the same.  */\n+  if (TREE_CODE (base0) == STRING_CST && TREE_CODE (base1) == STRING_CST)\n+    {\n+      if (ioff0 < 0\n+\t  || ioff1 < 0\n+\t  || ioff0 > TREE_STRING_LENGTH (base0)\n+\t  || ioff1 > TREE_STRING_LENGTH (base1))\n+\treturn 2;\n+\n+      /* If the bytes in the string literals starting at the pointers\n+\t differ, the pointers need to be different.  */\n+      if (memcmp (TREE_STRING_POINTER (base0) + ioff0,\n+\t\t  TREE_STRING_POINTER (base1) + ioff1,\n+\t\t  MIN (TREE_STRING_LENGTH (base0) - ioff0,\n+\t\t       TREE_STRING_LENGTH (base1) - ioff1)) == 0)\n+\t{\n+\t  HOST_WIDE_INT ioffmin = MIN (ioff0, ioff1);\n+\t  if (memcmp (TREE_STRING_POINTER (base0) + ioff0 - ioffmin,\n+\t\t      TREE_STRING_POINTER (base1) + ioff1 - ioffmin,\n+\t\t      ioffmin) == 0)\n+\t    /* If even the bytes in the string literal before the\n+\t       pointers are the same, the string literals could be\n+\t       tail merged.  */\n+\t    return 2;\n+\t}\n+      return 0;\n+    }\n+\n+  if (folding_cxx_constexpr)\n+    return 0;\n+\n+  /* If this is a pointer comparison, ignore for now even\n+     valid equalities where one pointer is the offset zero\n+     of one object and the other to one past end of another one.  */\n+  if (!INTEGRAL_TYPE_P (type))\n+    return 0;\n+\n+  /* Assume that string literals can't be adjacent to variables\n+     (automatic or global).  */\n+  if (TREE_CODE (base0) == STRING_CST || TREE_CODE (base1) == STRING_CST)\n+    return 0;\n+\n+  /* Assume that automatic variables can't be adjacent to global\n+     variables.  */\n+  if (is_global_var (base0) != is_global_var (base1))\n+    return 0;\n+\n   return equal;\n }\n "}, {"sha": "f217598d06af22b41fa6ccce908a1d36ba7eb1ef", "filename": "gcc/fold-const.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "patch": "@@ -20,9 +20,16 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_FOLD_CONST_H\n #define GCC_FOLD_CONST_H\n \n-/* Non-zero if we are folding constants inside an initializer; zero\n-   otherwise.  */\n+/* Nonzero if we are folding constants inside an initializer or a C++\n+   manifestly-constant-evaluated context; zero otherwise.\n+   Should be used when folding in initializer enables additional\n+   optimizations.  */\n extern int folding_initializer;\n+/* Nonzero if we are folding C++ manifestly-constant-evaluated context; zero\n+   otherwise.\n+   Should be used when certain constructs shouldn't be optimized\n+   during folding in that context.  */\n+extern bool folding_cxx_constexpr;\n \n /* Convert between trees and native memory representation.  */\n extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);"}, {"sha": "91a2e99c38f4a5b41f65abbf853cf86fc68b5f88", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-89074-3.C", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89074-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89074-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89074-3.C?ref=f9e900ce9b17dc7d3a3809d0b0648ebe529a87c5", "patch": "@@ -0,0 +1,132 @@\n+// PR c++/89074\n+// { dg-do compile { target c++14 } }\n+\n+int fn1 (void) { return 0; }\n+int fn2 (void) { return 1; }\n+\n+constexpr bool\n+f1 ()\n+{\n+  char a[] = { 1, 2, 3, 4 };\n+\n+  if (&a[1] == \"foo\")\n+    return false;\n+\n+  if (&a[1] == &\"foo\"[4])\n+    return false;\n+\n+  if (&\"foo\"[1] == &a[0])\n+    return false;\n+\n+  if (&\"foo\"[3] == &a[4])\n+    return false;\n+\n+  if (&a[0] == \"foo\")\n+    return false;\n+\n+  // Pointer to start of one object (var) and end of another one (literal)\n+  if (&a[0] == &\"foo\"[4])\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+f2 ()\n+{\n+  char a[] = { 1, 2, 3, 4 };\n+\n+  // Pointer to end of one object (var) and start of another one (literal)\n+  if (&a[4] == \"foo\")\t\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+char v[] = { 1, 2, 3, 4 };\n+\n+constexpr bool\n+f3 ()\n+{\n+  char a[] = { 1, 2, 3, 4 };\n+\n+  if (&a[1] == &v[1])\n+    return false;\n+\n+  if (&a[0] == &v[3])\n+    return false;\n+\n+  if (&a[2] == &v[4])\n+    return false;\n+\n+  // Pointer to start of one object (automatic var) and end of another one (non-automagic var)\n+  if (&a[0] == &v[4])\t\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+f4 ()\n+{\n+  char a[] = { 1, 2, 3, 4, 5 };\n+\n+  // Pointer to end of one object (automatic var) and start of another one (non-automagic var)\n+  if (&a[5] == &v[0])\t\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+f5 ()\n+{\n+  if (fn1 != fn1)\n+    return false;\n+\n+  if (fn1 == fn2)\n+    return false;\n+\n+  if (&\"abcde\"[0] == &\"edcba\"[1])\n+    return false;\n+\n+  if (&\"abcde\"[1] == &\"edcba\"[6])\n+    return false;\n+\n+  // Pointer to start of one object (literal) and end of another one (literal)\n+  if (&\"abcde\"[0] == &\"edcba\"[6])\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+f6 ()\n+{\n+  // Pointer to start of one object (literal) and end of another one (literal)\n+  if (&\"abcde\"[6] == &\"edcba\"[0])\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+f7 ()\n+{\n+  if (&\"abcde\"[3] == &\"fabcde\"[3])\n+    return false;\n+\n+  // These could be suffix merged, with &\"abcde\"[0] == &\"fabcde\"[1].\n+  if (&\"abcde\"[3] == &\"fabcde\"[4])\t// { dg-error \"is not a constant expression\" }\n+    return false;\n+\n+  return true;\n+}\n+\n+constexpr bool a = f1 ();\n+constexpr bool b = f2 ();\n+constexpr bool c = f3 ();\n+constexpr bool d = f4 ();\n+constexpr bool e = f5 ();\n+constexpr bool f = f6 ();\n+constexpr bool g = f7 ();"}]}