{"sha": "3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5ZjU2ZThjODM1YjBkMjZlNTMzZWI3OGQzZjRjYWVjODIwNTBjZQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-12-18T08:56:46Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-12-18T08:56:46Z"}, "message": "re PR libffi/29152 (64-bit darwin ppc port needed for libffi)\n\n\nlibffi:\n\tPR libffi/29152\n\tPR libffi/42378\n\t* src/powerpc/darwin_closure.S: Provide Darwin64 implementation,\n\tupdate comments.\n\t* src/powerpc/ffitarget.h (POWERPC_DARWIN64): New,\n\t(FFI_TRAMPOLINE_SIZE): Update for Darwin64.\n\t* src/powerpc/darwin.S: Provide Darwin64 implementation,\n\tupdate comments.\n\t* src/powerpc/ffi_darwin.c: Likewise.\n\nFrom-SVN: r168016", "tree": {"sha": "5e1ea68d7e4d5231a31ebe7754c7f6706f67a71f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e1ea68d7e4d5231a31ebe7754c7f6706f67a71f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1ea31e3a56b860b19443fdc83497342bd75eda6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ea31e3a56b860b19443fdc83497342bd75eda6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ea31e3a56b860b19443fdc83497342bd75eda6"}], "stats": {"total": 1540, "additions": 1193, "deletions": 347}, "files": [{"sha": "a8438a33e9c29d630540a93245c32af216a18134", "filename": "libffi/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "patch": "@@ -1,3 +1,15 @@\n+2010-12-18  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tPR libffi/29152\n+\tPR libffi/42378\n+\t* src/powerpc/darwin_closure.S: Provide Darwin64 implementation,\n+\tupdate comments.\n+\t* src/powerpc/ffitarget.h (POWERPC_DARWIN64): New,\n+\t(FFI_TRAMPOLINE_SIZE): Update for Darwin64.\n+\t* src/powerpc/darwin.S: Provide Darwin64 implementation,\n+\tupdate comments.\n+\t* src/powerpc/ffi_darwin.c: Likewise.\n+\t\n 2010-12-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (libffi_cv_as_ascii_pseudo_op): Use double"}, {"sha": "3b425da78b83f078aead536a9398ace0f5050941", "filename": "libffi/src/powerpc/darwin.S", "status": "modified", "additions": 214, "deletions": 76, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S?ref=3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n    darwin.S - Copyright (c) 2000 John Hornkvist\n-\t      Copyright (c) 2004 Free Software Foundation, Inc.\n+\t      Copyright (c) 2004, 2010 Free Software Foundation, Inc.\n \n    PowerPC Assembly glue.\n \n@@ -24,51 +24,92 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n+#define LIBFFI_ASM\n #if defined(__ppc64__)\n #define MODE_CHOICE(x, y) y\n #else\n #define MODE_CHOICE(x, y) x\n #endif\n \n-#define g_long  MODE_CHOICE(long, quad)         /* usage is \".g_long\" */\n+#define machine_choice\tMODE_CHOICE(ppc7400,ppc64)\n \n-#define LOG2_GPR_BYTES  MODE_CHOICE(2,3)        /* log2(GPR_BYTES) */\n+; Define some pseudo-opcodes for size-independent load & store of GPRs ...\n+#define lgu\t\tMODE_CHOICE(lwzu, ldu)\n+#define lg\t\tMODE_CHOICE(lwz,ld)\n+#define sg\t\tMODE_CHOICE(stw,std)\n+#define sgu\t\tMODE_CHOICE(stwu,stdu)\n+#define sgux\t\tMODE_CHOICE(stwux,stdux)\n+\n+; ... and the size of GPRs and their storage indicator.\n+#define GPR_BYTES\tMODE_CHOICE(4,8)\n+#define LOG2_GPR_BYTES\tMODE_CHOICE(2,3)\t/* log2(GPR_BYTES) */\n+#define g_long\t\tMODE_CHOICE(long, quad)\t/* usage is \".g_long\" */\n+\n+; From the ABI doc: \"Mac OS X ABI Function Call Guide\" Version 2009-02-04.\n+#define LINKAGE_SIZE\tMODE_CHOICE(24,48)\n+#define PARAM_AREA\tMODE_CHOICE(32,64)\n+#define SAVED_LR_OFFSET\tMODE_CHOICE(8,16)\t/* save position for lr */\n+\n+/* If there is any FP stuff we make space for all of the regs.  */\n+#define SAVED_FPR_COUNT 13\n+#define FPR_SIZE\t8\n+#define RESULT_BYTES\t16\n+\n+/* This should be kept in step with the same value in ffi_darwin.c.  */\n+#define ASM_NEEDS_REGISTERS 4\n+#define SAVE_REGS_SIZE (ASM_NEEDS_REGISTERS * GPR_BYTES)\n \n-#define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n+\n #define JUMPTARGET(name) name\n #define L(x) x\n-.text\n-\t.align 2\n-.globl _ffi_prep_args\n \n-.text\n+\t.text\n \t.align 2\n-.globl _ffi_call_DARWIN\n-.text\n+\t.globl _ffi_prep_args\n+\n \t.align 2\n+\t.globl _ffi_call_DARWIN\n+\n+\t/* We arrive here with:\n+\t   r3 = ptr to extended cif.\n+\t   r4 = -bytes.\n+\t   r5 = cif flags.\n+\t   r6 = ptr to return value.\n+\t   r7 = fn pointer (user func).\n+\t   r8 = fn pointer (ffi_prep_args).\n+\t   r9 = ffi_type* for the ret val.  */\n+\n _ffi_call_DARWIN:\n-LFB0:\n+Lstartcode:\n \tmr   \tr12,r8\t/* We only need r12 until the call,\n-\t\t\t   so it doesn't have to be saved.  */\n+\t\t\t   so it does not have to be saved.  */\n LFB1:\n \t/* Save the old stack pointer as AP.  */\n \tmr\tr8,r1\n LCFI0:\n+\t\n+\t/* Save the retval type in parents frame.  */\n+\tsg\tr9,(LINKAGE_SIZE+6*GPR_BYTES)(r8)\n+\n \t/* Allocate the stack space we need.  */\n-\tstwux\tr1,r1,r4\n+\tsgux\tr1,r1,r4\n \n \t/* Save registers we use.  */\n \tmflr\tr9\n+\tsg\tr9,SAVED_LR_OFFSET(r8)\n+\n+\tsg\tr28,-(4 * GPR_BYTES)(r8)\t\n+\tsg\tr29,-(3 * GPR_BYTES)(r8)\n+\tsg\tr30,-(2 * GPR_BYTES)(r8)\n+\tsg\tr31,-(    GPR_BYTES)(r8)\n \n-\tstw\tr28,-16(r8)\t\n-\tstw\tr29,-12(r8)\n-\tstw\tr30,-8(r8)\n-\tstw\tr31,-4(r8)\n+#if !defined(POWERPC_DARWIN)\n+\t/* The TOC slot is reserved in the Darwin ABI and r2 is volatile.  */\n+\tsg\tr2,(5 * GPR_BYTES)(r1)\n+#endif\n \n-\tstw\tr9,8(r8)\n-\tstw\tr2,20(r1)\n LCFI1:\n \n \t/* Save arguments over call.  */\n@@ -77,86 +118,148 @@ LCFI1:\n \tmr\tr29,r7\t/* function address,  */\n \tmr\tr28,r8\t/* our AP.  */\n LCFI2:\n-\t/* Call ffi_prep_args.  */\n+\t/* Call ffi_prep_args. r3 = extended cif, r4 = stack ptr copy.  */\n \tmr\tr4,r1\n \tli\tr9,0\n \n \tmtctr\tr12 /* r12 holds address of _ffi_prep_args.  */\n \tbctrl\n-\tlwz     r2,20(r1)\n \n+#if !defined(POWERPC_DARWIN)\n+\t/* The TOC slot is reserved in the Darwin ABI and r2 is volatile.  */\n+\tlg     r2,(5 * GPR_BYTES)(r1)\n+#endif\n \t/* Now do the call.\n \t   Set up cr1 with bits 4-7 of the flags.  */\n \tmtcrf\t0x40,r31\n \t/* Get the address to call into CTR.  */\n \tmtctr\tr29\n \t/* Load all those argument registers.\n \t   We have set up a nice stack frame, just load it into registers.  */\n-\tlwz     r3,20+(1*4)(r1)\n-\tlwz     r4,20+(2*4)(r1)\n-\tlwz     r5,20+(3*4)(r1)\n-\tlwz     r6,20+(4*4)(r1)\n+\tlg     r3, (LINKAGE_SIZE                )(r1)\n+\tlg     r4, (LINKAGE_SIZE +     GPR_BYTES)(r1)\n+\tlg     r5, (LINKAGE_SIZE + 2 * GPR_BYTES)(r1)\n+\tlg     r6, (LINKAGE_SIZE + 3 * GPR_BYTES)(r1)\n \tnop\n-\tlwz     r7,20+(5*4)(r1)\n-\tlwz     r8,20+(6*4)(r1)\n-\tlwz     r9,20+(7*4)(r1)\n-\tlwz     r10,20+(8*4)(r1)\n+\tlg     r7, (LINKAGE_SIZE + 4 * GPR_BYTES)(r1)\n+\tlg     r8, (LINKAGE_SIZE + 5 * GPR_BYTES)(r1)\n+\tlg     r9, (LINKAGE_SIZE + 6 * GPR_BYTES)(r1)\n+\tlg     r10,(LINKAGE_SIZE + 7 * GPR_BYTES)(r1)\n \n L1:\n-\t/* Load all the FP registers.  */\n+\t/* ... Load all the FP registers.  */\n \tbf\t6,L2\t/* No floats to load.  */\n-\tlfd\tf1,-16-(13*8)(r28)\n-\tlfd\tf2,-16-(12*8)(r28)\n-\tlfd\tf3,-16-(11*8)(r28)\n-\tlfd\tf4,-16-(10*8)(r28)\n+\tlfd\tf1, -SAVE_REGS_SIZE-(13*FPR_SIZE)(r28)\n+\tlfd\tf2, -SAVE_REGS_SIZE-(12*FPR_SIZE)(r28)\n+\tlfd\tf3, -SAVE_REGS_SIZE-(11*FPR_SIZE)(r28)\n+\tlfd\tf4, -SAVE_REGS_SIZE-(10*FPR_SIZE)(r28)\n \tnop\n-\tlfd\tf5,-16-(9*8)(r28)\n-\tlfd\tf6,-16-(8*8)(r28)\n-\tlfd\tf7,-16-(7*8)(r28)\n-\tlfd\tf8,-16-(6*8)(r28)\n+\tlfd\tf5, -SAVE_REGS_SIZE-( 9*FPR_SIZE)(r28)\n+\tlfd\tf6, -SAVE_REGS_SIZE-( 8*FPR_SIZE)(r28)\n+\tlfd\tf7, -SAVE_REGS_SIZE-( 7*FPR_SIZE)(r28)\n+\tlfd\tf8, -SAVE_REGS_SIZE-( 6*FPR_SIZE)(r28)\n \tnop\n-\tlfd     f9,-16-(5*8)(r28)\n-\tlfd     f10,-16-(4*8)(r28)\n-\tlfd     f11,-16-(3*8)(r28)\n-\tlfd     f12,-16-(2*8)(r28)\n+\tlfd     f9, -SAVE_REGS_SIZE-( 5*FPR_SIZE)(r28)\n+\tlfd     f10,-SAVE_REGS_SIZE-( 4*FPR_SIZE)(r28)\n+\tlfd     f11,-SAVE_REGS_SIZE-( 3*FPR_SIZE)(r28)\n+\tlfd     f12,-SAVE_REGS_SIZE-( 2*FPR_SIZE)(r28)\n \tnop\n-\tlfd     f13,-16-(1*8)(r28)\n+\tlfd     f13,-SAVE_REGS_SIZE-( 1*FPR_SIZE)(r28)\n \n L2:\n \tmr\tr12,r29\t/* Put the target address in r12 as specified.  */\n \tmtctr  \tr12\n \tnop\n \tnop\n+\n \t/* Make the call.  */\n \tbctrl\n \n \t/* Now, deal with the return value.  */\n-\tmtcrf\t0x01,r31\n \n-\tbt\t30,L(done_return_value)\n-\tbt\t29,L(fp_return_value)\n-\tstw\tr3,0(r30)\n-\tbf\t28,L(done_return_value)\n-\tstw\tr4,4(r30)\n+\t/* m64 structure returns can occupy the same set of registers as\n+\t   would be used to pass such a structure as arg0 - so take care \n+\t   not to step on any possibly hot regs.  */\n \n-\t/* Fall through.  */\n+\t/* Get the flags.. */\n+\tmtcrf\t0x03,r31 ; we need c6 & cr7 now.\n+\t; FLAG_RETURNS_NOTHING also covers struct ret-by-ref.\n+\tbt\t30,L(done_return_value)\t  ; FLAG_RETURNS_NOTHING\n+\tbf\t27,L(scalar_return_value) ; not FLAG_RETURNS_STRUCT\n+\t\n+\t/* OK, so we have a struct.  */\n+#if defined(__ppc64__)\n+\tbt\t31,L(maybe_return_128) ; FLAG_RETURNS_128BITS, special case \n \n-L(done_return_value):\n-\t/* Restore the registers we used and return.  */\n-\tlwz\tr9,8(r28)\n-\tlwz\tr31,-4(r28)\n-\tmtlr\tr9\n-\tlwz\tr30,-8(r28)\n-\tlwz\tr29,-12(r28)\n-\tlwz\tr28,-16(r28)\n-\tlwz\tr1,0(r1)\n-\tblr\n+\t/* OK, we have to map the return back to a mem struct.\n+\t   We are about to trample the parents param area, so recover the\n+\t   return type.  r29 is free, since the call is done.  */\n+\tlg\tr29,(LINKAGE_SIZE + 6 * GPR_BYTES)(r28)\n+\n+\tsg\tr3, (LINKAGE_SIZE                )(r28)\n+\tsg\tr4, (LINKAGE_SIZE +     GPR_BYTES)(r28)\n+\tsg\tr5, (LINKAGE_SIZE + 2 * GPR_BYTES)(r28)\n+\tsg\tr6, (LINKAGE_SIZE + 3 * GPR_BYTES)(r28)\n+\tnop\n+\tsg\tr7, (LINKAGE_SIZE + 4 * GPR_BYTES)(r28)\n+\tsg\tr8, (LINKAGE_SIZE + 5 * GPR_BYTES)(r28)\n+\tsg\tr9, (LINKAGE_SIZE + 6 * GPR_BYTES)(r28)\n+\tsg\tr10,(LINKAGE_SIZE + 7 * GPR_BYTES)(r28)\n+\t/* OK, so do the block move - we trust that memcpy will not trample\n+\t   the fprs...  */\n+\tmr \tr3,r30 ; dest\n+\taddi\tr4,r28,LINKAGE_SIZE ; source\n+\t/* The size is a size_t, should be long.  */\n+\tlg\tr5,0(r29)\n+\t/* Figure out small structs */\n+\tcmpi\t0,r5,4\n+\tbgt\tL3\t; 1, 2 and 4 bytes have special rules.\n+\tcmpi\t0,r5,3\n+\tbeq\tL3\t; not 3\n+\taddi\tr4,r4,8\n+\tsubf\tr4,r5,r4\n+L3:\n+\tbl\t_memcpy\n+\t\n+\t/* ... do we need the FP registers? - recover the flags.. */\n+\tmtcrf\t0x03,r31 ; we need c6 & cr7 now.\n+\tbf\t29,L(done_return_value)\t/* No floats in the struct.  */\n+\tstfd\tf1, -SAVE_REGS_SIZE-(13*FPR_SIZE)(r28)\n+\tstfd\tf2, -SAVE_REGS_SIZE-(12*FPR_SIZE)(r28)\n+\tstfd\tf3, -SAVE_REGS_SIZE-(11*FPR_SIZE)(r28)\n+\tstfd\tf4, -SAVE_REGS_SIZE-(10*FPR_SIZE)(r28)\n+\tnop\n+\tstfd\tf5, -SAVE_REGS_SIZE-( 9*FPR_SIZE)(r28)\n+\tstfd\tf6, -SAVE_REGS_SIZE-( 8*FPR_SIZE)(r28)\n+\tstfd\tf7, -SAVE_REGS_SIZE-( 7*FPR_SIZE)(r28)\n+\tstfd\tf8, -SAVE_REGS_SIZE-( 6*FPR_SIZE)(r28)\n+\tnop\n+\tstfd\tf9, -SAVE_REGS_SIZE-( 5*FPR_SIZE)(r28)\n+\tstfd\tf10,-SAVE_REGS_SIZE-( 4*FPR_SIZE)(r28)\n+\tstfd\tf11,-SAVE_REGS_SIZE-( 3*FPR_SIZE)(r28)\n+\tstfd\tf12,-SAVE_REGS_SIZE-( 2*FPR_SIZE)(r28)\n+\tnop\n+\tstfd\tf13,-SAVE_REGS_SIZE-( 1*FPR_SIZE)(r28)\n+\n+\tmr\tr3,r29\t; ffi_type *\n+\tmr\tr4,r30\t; dest\n+\taddi\tr5,r28,-SAVE_REGS_SIZE-(13*FPR_SIZE) ; fprs\n+\txor\tr6,r6,r6\n+\tsg\tr6,(LINKAGE_SIZE + 7 * GPR_BYTES)(r28)\n+\taddi\tr6,r28,(LINKAGE_SIZE + 7 * GPR_BYTES) ; point to a zeroed counter.\n+\tbl \t_darwin64_struct_floats_to_mem\n+\n+\tb L(done_return_value)\n+#else\n+\tstw\tr3,0(r30) ; m32 the only struct return in reg is 4 bytes.\n+#endif\n+\tb L(done_return_value)\n \n L(fp_return_value):\n \t/* Do we have long double to store?  */\n-\tbf\t31,L(fd_return_value)\n+\tbf\t31,L(fd_return_value) ; FLAG_RETURNS_128BITS\n \tstfd\tf1,0(r30)\n-\tstfd\tf2,8(r30)\n+\tstfd\tf2,FPR_SIZE(r30)\n \tb\tL(done_return_value)\n \n L(fd_return_value):\n@@ -170,21 +273,57 @@ L(float_return_value):\n \tstfs\tf1,0(r30)\n \tb\tL(done_return_value)\n \n+L(scalar_return_value):\n+\tbt\t29,L(fp_return_value)\t; FLAG_RETURNS_FP\n+\t; ffi_arg is defined as unsigned long. \n+\tsg\tr3,0(r30)\t\t; Save the reg.\n+\tbf\t28,L(done_return_value) ; not FLAG_RETURNS_64BITS \n+\n+#if defined(__ppc64__)\n+L(maybe_return_128):\n+\tstd\tr3,0(r30)\n+\tbf\t31,L(done_return_value) ; not FLAG_RETURNS_128BITS \n+\tstd\tr4,8(r30)\n+#else\n+\tstw\tr4,4(r30)\n+#endif\n+\n+\t/* Fall through.  */\n+\t/* We want this at the end to simplify eh epilog computation.  */\n+\n+L(done_return_value):\n+\t/* Restore the registers we used and return.  */\n+\tlg\tr29,SAVED_LR_OFFSET(r28)\n+\t; epilog\n+\tlg\tr31,-(1 * GPR_BYTES)(r28)\n+\tmtlr\tr29\n+\tlg\tr30,-(2 * GPR_BYTES)(r28)\n+\tlg\tr29,-(3 * GPR_BYTES)(r28)\n+\tlg\tr28,-(4 * GPR_BYTES)(r28)\n+\tlg\tr1,0(r1)\n+\tblr\n LFE1:\n+\t.align\t1\n /* END(_ffi_call_DARWIN)  */\n \n /* Provide a null definition of _ffi_call_AIX.  */\n-.text\n-\t.align 2\n-.globl _ffi_call_AIX\n-.text\n+\t.text\n+\t.globl _ffi_call_AIX\n \t.align 2\n _ffi_call_AIX:\n \tblr\n /* END(_ffi_call_AIX)  */\n \n-.data\n-.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms\n+/* EH stuff.  */\n+\n+#define EH_DATA_ALIGN_FACT MODE_CHOICE(0x7c,0x78)\n+\n+\t.static_data\n+\t.align LOG2_GPR_BYTES\n+LLFB0$non_lazy_ptr:\n+\t.g_long Lstartcode\n+\n+\t.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n EH_frame1:\n \t.set\tL$set$0,LECIE1-LSCIE1\n \t.long\tL$set$0\t; Length of Common Information Entry\n@@ -193,7 +332,7 @@ LSCIE1:\n \t.byte\t0x1\t; CIE Version\n \t.ascii\t\"zR\\0\"\t; CIE Augmentation\n \t.byte\t0x1\t; uleb128 0x1; CIE Code Alignment Factor\n-\t.byte\t0x7c\t; sleb128 -4; CIE Data Alignment Factor\n+\t.byte\tEH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n \t.byte\t0x90\t; FDE Encoding (indirect pcrel)\n@@ -202,19 +341,20 @@ LSCIE1:\n \t.byte\t0x0\t; uleb128 0x0\n \t.align\tLOG2_GPR_BYTES\n LECIE1:\n-.globl _ffi_call_DARWIN.eh\n+\n+\t.globl _ffi_call_DARWIN.eh\n _ffi_call_DARWIN.eh:\n LSFDE1:\n \t.set\tL$set$1,LEFDE1-LASFDE1\n \t.long\tL$set$1\t; FDE Length\n LASFDE1:\n \t.long\tLASFDE1-EH_frame1 ; FDE CIE offset\n \t.g_long\tLLFB0$non_lazy_ptr-.\t; FDE initial location\n-\t.set\tL$set$3,LFE1-LFB0\n+\t.set\tL$set$3,LFE1-Lstartcode\n \t.g_long\tL$set$3\t; FDE address range\n \t.byte   0x0     ; uleb128 0x0; Augmentation size\n \t.byte\t0x4\t; DW_CFA_advance_loc4\n-\t.set\tL$set$4,LCFI0-LFB1\n+\t.set\tL$set$4,LCFI0-Lstartcode\n \t.long\tL$set$4\n \t.byte\t0xd\t; DW_CFA_def_cfa_register\n \t.byte\t0x08\t; uleb128 0x08\n@@ -239,7 +379,5 @@ LASFDE1:\n \t.byte\t0x1c\t; uleb128 0x1c\n \t.align LOG2_GPR_BYTES\n LEFDE1:\n-.data\n-\t.align LOG2_GPR_BYTES\n-LLFB0$non_lazy_ptr:\n-\t.g_long LFB0\n+\t.align 1\n+"}, {"sha": "8c0e11a18444b7eb351d02a29c44c190e7a09f2f", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 357, "deletions": 99, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n-   darwin_closure.S - Copyright (c) 2002, 2003, 2004, Free Software Foundation,\n-   Inc. based on ppc_closure.S\n+   darwin_closure.S - Copyright (c) 2002, 2003, 2004, 2010, \n+   Free Software Foundation, Inc. \n+   based on ppc_closure.S\n \n    PowerPC Assembly glue.\n \n@@ -33,91 +34,177 @@\n #define MODE_CHOICE(x, y) x\n #endif\n \n-#define lgu     MODE_CHOICE(lwzu, ldu)\n-\n-#define g_long  MODE_CHOICE(long, quad)         /* usage is \".g_long\" */\n+#define machine_choice\tMODE_CHOICE(ppc7400,ppc64)\n+\n+; Define some pseudo-opcodes for size-independent load & store of GPRs ...\n+#define lgu\t\tMODE_CHOICE(lwzu, ldu)\n+#define lg\t\tMODE_CHOICE(lwz,ld)\n+#define sg\t\tMODE_CHOICE(stw,std)\n+#define sgu\t\tMODE_CHOICE(stwu,stdu)\n+\n+; ... and the size of GPRs and their storage indicator.\n+#define GPR_BYTES\tMODE_CHOICE(4,8)\n+#define LOG2_GPR_BYTES\tMODE_CHOICE(2,3)\t/* log2(GPR_BYTES) */\n+#define g_long\t\tMODE_CHOICE(long, quad)\t/* usage is \".g_long\" */\n+\n+; From the ABI doc: \"Mac OS X ABI Function Call Guide\" Version 2009-02-04.\n+#define LINKAGE_SIZE\tMODE_CHOICE(24,48)\n+#define PARAM_AREA\tMODE_CHOICE(32,64)\n+\n+#define SAVED_CR_OFFSET\tMODE_CHOICE(4,8)\t/* save position for CR */\n+#define SAVED_LR_OFFSET\tMODE_CHOICE(8,16)\t/* save position for lr */\n+\n+/* WARNING: if ffi_type is changed... here be monsters.  \n+   Offsets of items within the result type.  */\n+#define FFI_TYPE_TYPE\tMODE_CHOICE(6,10)\n+#define FFI_TYPE_ELEM\tMODE_CHOICE(8,16)\n+\n+#define SAVED_FPR_COUNT 13\n+#define FPR_SIZE\t8\n+/* biggest m64 struct ret is 8GPRS + 13FPRS = 168 bytes - rounded to 16bytes = 176. */\n+#define RESULT_BYTES\tMODE_CHOICE(16,176)\n+\n+; The whole stack frame **MUST** be 16byte-aligned.\n+#define SAVE_SIZE (((LINKAGE_SIZE+PARAM_AREA+SAVED_FPR_COUNT*FPR_SIZE+RESULT_BYTES)+15) & -16LL)\n+#define PAD_SIZE (SAVE_SIZE-(LINKAGE_SIZE+PARAM_AREA+SAVED_FPR_COUNT*FPR_SIZE+RESULT_BYTES))\n+\n+#define PARENT_PARM_BASE (SAVE_SIZE+LINKAGE_SIZE)\n+#define FP_SAVE_BASE (LINKAGE_SIZE+PARAM_AREA)\n+\n+#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1050\n+; We no longer need the pic symbol stub for Darwin >= 9.\n+#define BLCLS_HELP _ffi_closure_helper_DARWIN\n+#define STRUCT_RETVALUE_P _darwin64_struct_ret_by_value_p\n+#define PASS_STR_FLOATS _darwin64_pass_struct_floats\n+#undef WANT_STUB\n+#else\n+#define BLCLS_HELP L_ffi_closure_helper_DARWIN$stub\n+#define STRUCT_RETVALUE_P L_darwin64_struct_ret_by_value_p$stub\n+#define PASS_STR_FLOATS L_darwin64_pass_struct_floats$stub\n+#define WANT_STUB\n+#endif\n \n-#define LOG2_GPR_BYTES  MODE_CHOICE(2,3)        /* log2(GPR_BYTES) */\n+/* m32/m64\n+\n+   The stack layout looks like this:\n+\n+   |   Additional params...\t\t\t| |     Higher address\n+   ~\t\t\t\t\t\t~ ~\n+   |   Parameters      (at least 8*4/8=32/64)\t| | NUM_GPR_ARG_REGISTERS\n+   |--------------------------------------------| |\n+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8\t| |\n+   |--------------------------------------------| |\n+   |   Reserved                       2*4/8\t| |\n+   |--------------------------------------------| |\n+   |   Space for callee`s LR\t\t4/8\t| |\n+   |--------------------------------------------| |\n+   |   Saved CR [low word for m64]      4/8\t| |\n+   |--------------------------------------------| |\n+   |   Current backchain pointer\t4/8\t|-/ Parent`s frame.\n+   |--------------------------------------------| <+ <<< on entry to\n+   |   Result Bytes\t\t       16/176\t| |\n+   |--------------------------------------------| |\n+   ~   padding to 16-byte alignment\t\t~ ~\n+   |--------------------------------------------| |\n+   |   NUM_FPR_ARG_REGISTERS slots\t\t| |\n+   |   here fp13 .. fp1\t\t       13*8\t| |\n+   |--------------------------------------------| |\n+   |   R3..R10\t\t\t  8*4/8=32/64\t| | NUM_GPR_ARG_REGISTERS\n+   |--------------------------------------------| |\n+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8\t| |\n+   |--------------------------------------------| |\tstack\t|\n+   |   Reserved [compiler,binder]     2*4/8\t| |\tgrows\t|\n+   |--------------------------------------------| |\tdown\tV\n+   |   Space for callees LR\t\t4/8\t| |\n+   |--------------------------------------------| |\tlower addresses\n+   |   Saved CR [low word for m64]      4/8\t| |\n+   |--------------------------------------------| |     stack pointer here\n+   |   Current backchain pointer\t4/8\t|-/\tduring\n+   |--------------------------------------------|   <<<\tcall.\n+\n+*/\n \n \t.file\t\"darwin_closure.S\"\n-.text\n-\t.align LOG2_GPR_BYTES\n-.globl _ffi_closure_ASM\n \n-.text\n+\t.machine machine_choice\n+\n+\t.text\n+\t.globl _ffi_closure_ASM\n \t.align LOG2_GPR_BYTES\n _ffi_closure_ASM:\n LFB1:\n-\tmflr\tr0\t\t/* extract return address  */\n-\tstw\tr0,8(r1)\t/* save the return address  */\n+Lstartcode:\n+\tmflr\tr0\t\t\t/* extract return address  */\n+\tsg\tr0,SAVED_LR_OFFSET(r1)\t/* save the return address  */\n LCFI0:\n-\t/* 24 Bytes (Linkage Area)\n-\t   32 Bytes (outgoing parameter area, always reserved)\n-\t   104 Bytes (13*8 from FPR)\n-\t   16 Bytes (result)\n-\t   176 Bytes  */\n-\n-\tstwu\tr1,-176(r1)\t/* skip over caller save area\n-\t\t\t\tkeep stack aligned to 16.  */\n+\tsgu\tr1,-SAVE_SIZE(r1)\t/* skip over caller save area\n+\t\t\t\t\tkeep stack aligned to 16.  */\n LCFI1:\n \t/* We want to build up an area for the parameters passed\n \t   in registers. (both floating point and integer)  */\n \n-\t/* We store gpr 3 to gpr 10 (aligned to 4)\n-\t   in the parents outgoing area.  */\n-\tstw   r3,200(r1)\n-\tstw   r4,204(r1)\n-\tstw   r5,208(r1)\n-\tstw   r6,212(r1)\n-\tstw   r7,216(r1)\n-\tstw   r8,220(r1)\n-\tstw   r9,224(r1)\n-\tstw   r10,228(r1)\n-\n-\t/* We save fpr 1 to fpr 13. (aligned to 8)  */\n-\tstfd  f1,56(r1)\n-\tstfd  f2,64(r1)\n-\tstfd  f3,72(r1)\n-\tstfd  f4,80(r1)\n-\tstfd  f5,88(r1)\n-\tstfd  f6,96(r1)\n-\tstfd  f7,104(r1)\n-\tstfd  f8,112(r1)\n-\tstfd  f9,120(r1)\n-\tstfd  f10,128(r1)\n-\tstfd  f11,136(r1)\n-\tstfd  f12,144(r1)\n-\tstfd  f13,152(r1)\n+\t/* Put gpr 3 to gpr 10 in the parents outgoing area...\n+\t   ... the remainder of any params that overflowed the regs will\n+\t   follow here.  */\n+\tsg\tr3, (PARENT_PARM_BASE                )(r1)\n+\tsg\tr4, (PARENT_PARM_BASE + GPR_BYTES    )(r1)\n+\tsg\tr5, (PARENT_PARM_BASE + GPR_BYTES * 2)(r1)\n+\tsg\tr6, (PARENT_PARM_BASE + GPR_BYTES * 3)(r1)\n+\tsg\tr7, (PARENT_PARM_BASE + GPR_BYTES * 4)(r1)\n+\tsg\tr8, (PARENT_PARM_BASE + GPR_BYTES * 5)(r1)\n+\tsg\tr9, (PARENT_PARM_BASE + GPR_BYTES * 6)(r1)\n+\tsg\tr10,(PARENT_PARM_BASE + GPR_BYTES * 7)(r1)\n+\n+\t/* We save fpr 1 to fpr 14 in our own save frame.  */\n+\tstfd\tf1, (FP_SAVE_BASE                 )(r1)\n+\tstfd\tf2, (FP_SAVE_BASE +  FPR_SIZE     )(r1)\n+\tstfd\tf3, (FP_SAVE_BASE +  FPR_SIZE * 2 )(r1)\n+\tstfd\tf4, (FP_SAVE_BASE +  FPR_SIZE * 3 )(r1)\n+\tstfd\tf5, (FP_SAVE_BASE +  FPR_SIZE * 4 )(r1)\n+\tstfd\tf6, (FP_SAVE_BASE +  FPR_SIZE * 5 )(r1)\n+\tstfd\tf7, (FP_SAVE_BASE +  FPR_SIZE * 6 )(r1)\n+\tstfd\tf8, (FP_SAVE_BASE +  FPR_SIZE * 7 )(r1)\n+\tstfd\tf9, (FP_SAVE_BASE +  FPR_SIZE * 8 )(r1)\n+\tstfd\tf10,(FP_SAVE_BASE +  FPR_SIZE * 9 )(r1)\n+\tstfd\tf11,(FP_SAVE_BASE +  FPR_SIZE * 10)(r1)\n+\tstfd\tf12,(FP_SAVE_BASE +  FPR_SIZE * 11)(r1)\n+\tstfd\tf13,(FP_SAVE_BASE +  FPR_SIZE * 12)(r1)\n \n \t/* Set up registers for the routine that actually does the work\n \t   get the context pointer from the trampoline.  */\n-\tmr r3,r11\n+\tmr\tr3,r11\n \n \t/* Now load up the pointer to the result storage.  */\n-\taddi r4,r1,160\n+\taddi\tr4,r1,(SAVE_SIZE-RESULT_BYTES)\n \n \t/* Now load up the pointer to the saved gpr registers.  */\n-\taddi r5,r1,200\n+\taddi\tr5,r1,PARENT_PARM_BASE\n \n \t/* Now load up the pointer to the saved fpr registers.  */\n-\taddi r6,r1,56\n+\taddi\tr6,r1,FP_SAVE_BASE\n \n \t/* Make the call.  */\n-\tbl\tLffi_closure_helper_DARWIN$stub\n+\tbl\tBLCLS_HELP\n+\n+\t/* r3 contains the rtype pointer... save it since we will need\n+\t   it later.  */\n+\tsg\tr3,LINKAGE_SIZE(r1)\t; ffi_type * result_type\n+\tlg\tr0,0(r3)\t\t; size => r0\n+\tlhz\tr3,FFI_TYPE_TYPE(r3)\t; type => r3\n \n-\t/* Now r3 contains the return type\n-\t   so use it to look up in a table\n+\t/* The helper will have intercepted struture returns and inserted\n+\t   the caller`s destination address for structs returned by ref.  */\n+\n+\t/* r3 contains the return type  so use it to look up in a table\n \t   so we know how to deal with each type.  */\n \n-\t/* Look up the proper starting point in table\n-\t   by using return type as offset.  */\n-\taddi  r5,r1,160\t\t  /* Get pointer to results area.  */\n-\tbl    Lget_ret_type0_addr /* Get pointer to Lret_type0 into LR.  */\n-\tmflr  r4\t\t  /* Move to r4.  */\n-\tslwi  r3,r3,4\t\t  /* Now multiply return type by 16.  */\n-\tadd   r3,r3,r4\t\t  /* Add contents of table to table address.  */\n-\tmtctr r3\n-\tbctr\t\t\t  /* Jump to it.  */\n+\taddi\tr5,r1,(SAVE_SIZE-RESULT_BYTES) /* Otherwise, our return is here.  */\n+\tbl\tLget_ret_type0_addr\t/* Get pointer to Lret_type0 into LR.  */\n+\tmflr\tr4\t\t\t/* Move to r4.  */\n+\tslwi\tr3,r3,4\t\t\t/* Now multiply return type by 16.  */\n+\tadd\tr3,r3,r4\t\t/* Add contents of table to table address.  */\n+\tmtctr\tr3\n+\tbctr\t\t\t \t /* Jump to it.  */\n LFE1:\n /* Each of the ret_typeX code fragments has to be exactly 16 bytes long\n    (4 instructions). For cache effectiveness we align to a 16 byte boundary\n@@ -140,7 +227,7 @@ Lret_type0:\n \n /* case FFI_TYPE_INT  */\n Lret_type1:\n-\tlwz\tr3,0(r5)\n+\tlg\tr3,0(r5)\n \tb\tLfinish\n \tnop\n \tnop\n@@ -168,85 +255,224 @@ Lret_type4:\n \n /* case FFI_TYPE_UINT8  */\n Lret_type5:\n+#if defined(__ppc64__)\n+\tlbz\tr3,7(r5)\n+#else\n \tlbz\tr3,3(r5)\n+#endif\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_SINT8  */\n Lret_type6:\n+#if defined(__ppc64__)\n+\tlbz\tr3,7(r5)\n+#else\n \tlbz\tr3,3(r5)\n+#endif\n \textsb\tr3,r3\n \tb\tLfinish\n \tnop\n \n /* case FFI_TYPE_UINT16  */\n Lret_type7:\n+#if defined(__ppc64__)\n+\tlhz\tr3,6(r5)\n+#else\n \tlhz\tr3,2(r5)\n+#endif\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_SINT16  */\n Lret_type8:\n+#if defined(__ppc64__)\n+\tlha\tr3,6(r5)\n+#else\n \tlha\tr3,2(r5)\n+#endif\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_UINT32  */\n Lret_type9:\n+#if defined(__ppc64__)\n+\tlwz\tr3,4(r5)\n+#else\n \tlwz\tr3,0(r5)\n+#endif\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_SINT32  */\n Lret_type10:\n+#if defined(__ppc64__)\n+\tlwz\tr3,4(r5)\n+#else\n \tlwz\tr3,0(r5)\n+#endif\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_UINT64  */\n Lret_type11:\n+#if defined(__ppc64__)\n+\tlg\tr3,0(r5)\n+\tb\tLfinish\n+\tnop\n+#else\n \tlwz\tr3,0(r5)\n \tlwz\tr4,4(r5)\n \tb\tLfinish\n+#endif\n \tnop\n \n /* case FFI_TYPE_SINT64  */\n Lret_type12:\n+#if defined(__ppc64__)\n+\tlg\tr3,0(r5)\n+\tb\tLfinish\n+\tnop\n+#else\n \tlwz\tr3,0(r5)\n \tlwz\tr4,4(r5)\n \tb\tLfinish\n+#endif\n \tnop\n \n /* case FFI_TYPE_STRUCT  */\n Lret_type13:\n+#if defined(__ppc64__)\n+\tlg\tr3,0(r5)\t\t; we need at least this...\n+\tcmpi\t0,r0,4\n+\tbgt\tLstructend\t\t; not a special small case\n+\tb\tLsmallstruct\t\t; see if we need more.\n+#else\n+\tcmpi\t0,r0,4\n+\tbgt\tLfinish\t\t; not by value\n+\tlg\tr3,0(r5)\n \tb\tLfinish\n-\tnop\n-\tnop\n-\tnop\n-\n+#endif\n /* case FFI_TYPE_POINTER  */\n Lret_type14:\n-\tlwz\tr3,0(r5)\n+\tlg\tr3,0(r5)\n \tb\tLfinish\n \tnop\n \tnop\n \n+#if defined(__ppc64__)\n+Lsmallstruct:\n+\tbeq\tLfour\t\t\t; continuation of Lret13.\n+\tcmpi\t0,r0,3\n+\tbeq\tLfinish\t\t\t; don`t adjust this - can`t be any floats here...\n+\tsrdi\tr3,r3,48\n+\tcmpi\t0,r0,2\n+\tbeq\tLfinish\t\t\t; .. or here ..\n+\tsrdi\tr3,r3,8\n+\tb \tLfinish\t\t\t; .. or here.\n+\n+Lfour:\n+\tlg\tr6,LINKAGE_SIZE(r1)\t; get the result type\n+\tlg\tr6,FFI_TYPE_ELEM(r6)\t; elements array pointer\n+\tlg\tr6,0(r6)\t\t; first element\n+\tlhz\tr0,FFI_TYPE_TYPE(r6)\t; OK go the type\n+\tcmpi\t0,r0,2\t\t\t; FFI_TYPE_FLOAT\n+\tbne\tLfourint\n+\tlfs\tf1,0(r5)\t\t; just one float in the struct.\n+\tb \tLfinish\n+\n+Lfourint:\n+\tsrdi\tr3,r3,32\t\t; four bytes.\n+\tb \tLfinish\n+\n+Lstructend:\n+\tlg\tr3,LINKAGE_SIZE(r1)\t; get the result type\n+\tbl\tSTRUCT_RETVALUE_P\n+\tcmpi\t0,r3,0\n+\tbeq\tLfinish\t\t\t; nope.\n+\t/* Recover a pointer to the results.  */\n+\taddi\tr11,r1,(SAVE_SIZE-RESULT_BYTES)\n+\tlg\tr3,0(r11)\t\t; we need at least this...\n+\tlg\tr4,8(r11)\n+\tcmpi\t0,r0,16\n+\tbeq\tLfinish\t\t; special case 16 bytes we don't consider floats.\n+\n+\t/* OK, frustratingly, the process of saving the struct to mem might have\n+\t   messed with the FPRs, so we have to re-load them :(.\n+\t   We`ll use our FPRs space again - calling: \n+\t   void darwin64_pass_struct_floats (ffi_type *s, char *src, \n+\t\t\t\t\t     unsigned *nfpr, double **fprs) \n+\t   We`ll temporarily pinch the first two slots of the param area for local\n+\t   vars used by the routine.  */\n+\txor\tr6,r6,r6\n+\taddi\tr5,r1,PARENT_PARM_BASE\t\t; some space\n+\tsg\tr6,0(r5)\t\t\t; *nfpr zeroed.\n+\taddi\tr6,r5,8\t\t\t\t; **fprs\n+\taddi\tr3,r1,FP_SAVE_BASE\t\t; pointer to FPRs space\n+\tsg\tr3,0(r6)\n+\tmr\tr4,r11\t\t\t\t; the struct is here...\n+\tlg\tr3,LINKAGE_SIZE(r1)\t\t; ffi_type * result_type.\n+\tbl\tPASS_STR_FLOATS\t\t\t; get struct floats into FPR save space.\n+\t/* See if we used any floats  */\n+\tlwz\tr0,(SAVE_SIZE-RESULT_BYTES)(r1)\t\n+\tcmpi\t0,r0,0\n+\tbeq\tLstructints\t\t\t; nope.\n+\t/* OK load `em up... */\n+\tlfd\tf1, (FP_SAVE_BASE                 )(r1)\n+\tlfd\tf2, (FP_SAVE_BASE +  FPR_SIZE     )(r1)\n+\tlfd\tf3, (FP_SAVE_BASE +  FPR_SIZE * 2 )(r1)\n+\tlfd\tf4, (FP_SAVE_BASE +  FPR_SIZE * 3 )(r1)\n+\tlfd\tf5, (FP_SAVE_BASE +  FPR_SIZE * 4 )(r1)\n+\tlfd\tf6, (FP_SAVE_BASE +  FPR_SIZE * 5 )(r1)\n+\tlfd\tf7, (FP_SAVE_BASE +  FPR_SIZE * 6 )(r1)\n+\tlfd\tf8, (FP_SAVE_BASE +  FPR_SIZE * 7 )(r1)\n+\tlfd\tf9, (FP_SAVE_BASE +  FPR_SIZE * 8 )(r1)\n+\tlfd\tf10,(FP_SAVE_BASE +  FPR_SIZE * 9 )(r1)\n+\tlfd\tf11,(FP_SAVE_BASE +  FPR_SIZE * 10)(r1)\n+\tlfd\tf12,(FP_SAVE_BASE +  FPR_SIZE * 11)(r1)\n+\tlfd\tf13,(FP_SAVE_BASE +  FPR_SIZE * 12)(r1)\n+\n+\t/* point back at our saved struct.  */\n+Lstructints:\n+\taddi\tr11,r1,(SAVE_SIZE-RESULT_BYTES)\n+\tlg\tr3,0(r11)\t\t\t; we end up picking the\n+\tlg\tr4,8(r11)\t\t\t; first two again.\n+\tlg\tr5,16(r11)\n+\tlg\tr6,24(r11)\n+\tlg\tr7,32(r11)\n+\tlg\tr8,40(r11)\n+\tlg\tr9,48(r11)\n+\tlg\tr10,56(r11)\n+#endif\n+\n /* case done  */\n Lfinish:\n-\taddi\tr1,r1,176\t/* Restore stack pointer.  */\n-\tlwz\tr0,8(r1)\t/* Get return address.  */\n-\tmtlr\tr0\t\t/* Reset link register.  */\n+\taddi\tr1,r1,SAVE_SIZE\t\t/* Restore stack pointer.  */\n+\tlg\tr0,SAVED_LR_OFFSET(r1)\t/* Get return address.  */\n+\tmtlr\tr0\t\t\t/* Reset link register.  */\n \tblr\n-\n+Lendcode:\n+\t.align 1\n+\t\n /* END(ffi_closure_ASM)  */\n \n-.data\n-.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n+/* EH frame stuff.  */\n+#define EH_DATA_ALIGN_FACT MODE_CHOICE(0x7c,0x78)\n+/* 176, 400 */\n+#define EH_FRAME_OFFSETA MODE_CHOICE(176,0x90)\n+#define EH_FRAME_OFFSETB MODE_CHOICE(1,3)\n+\n+\t.static_data\n+\t.align LOG2_GPR_BYTES\n+LLFB1$non_lazy_ptr:\n+\t.g_long Lstartcode\n+\n+\t.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n EH_frame1:\n \t.set\tL$set$0,LECIE1-LSCIE1\n \t.long\tL$set$0\t; Length of Common Information Entry\n@@ -255,7 +481,7 @@ LSCIE1:\n \t.byte\t0x1\t; CIE Version\n \t.ascii\t\"zR\\0\"\t; CIE Augmentation\n \t.byte\t0x1\t; uleb128 0x1; CIE Code Alignment Factor\n-\t.byte\t0x7c\t; sleb128 -4; CIE Data Alignment Factor\n+\t.byte\tEH_DATA_ALIGN_FACT ; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n \t.byte\t0x90\t; FDE Encoding (indirect pcrel)\n@@ -264,7 +490,7 @@ LSCIE1:\n \t.byte\t0x0\t; uleb128 0x0\n \t.align\tLOG2_GPR_BYTES\n LECIE1:\n-.globl _ffi_closure_ASM.eh\n+\t.globl _ffi_closure_ASM.eh\n _ffi_closure_ASM.eh:\n LSFDE1:\n \t.set\tL$set$1,LEFDE1-LASFDE1\n@@ -273,45 +499,77 @@ LSFDE1:\n LASFDE1:\n \t.long\tLASFDE1-EH_frame1\t; FDE CIE offset\n \t.g_long\tLLFB1$non_lazy_ptr-.\t; FDE initial location\n-\t.set\tL$set$3,LFE1-LFB1\n+\t.set\tL$set$3,LFE1-Lstartcode\n \t.g_long\tL$set$3\t; FDE address range\n \t.byte   0x0     ; uleb128 0x0; Augmentation size\n \t.byte\t0x4\t; DW_CFA_advance_loc4\n \t.set\tL$set$3,LCFI1-LCFI0\n \t.long\tL$set$3\n \t.byte\t0xe\t; DW_CFA_def_cfa_offset\n-\t.byte\t176,1\t; uleb128 176\n+\t.byte\tEH_FRAME_OFFSETA,EH_FRAME_OFFSETB\t; uleb128 176,1/190,3\n \t.byte\t0x4\t; DW_CFA_advance_loc4\n-\t.set\tL$set$4,LCFI0-LFB1\n+\t.set\tL$set$4,LCFI0-Lstartcode\n \t.long\tL$set$4\n \t.byte   0x11    ; DW_CFA_offset_extended_sf\n \t.byte\t0x41\t; uleb128 0x41\n \t.byte   0x7e    ; sleb128 -2\n \t.align\tLOG2_GPR_BYTES\n LEFDE1:\n-.data\n-\t.align\tLOG2_GPR_BYTES\n-LDFCM0:\n-.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n-\t.align\tLOG2_GPR_BYTES\n-Lffi_closure_helper_DARWIN$stub:\n-#if 1\n+\t.align \t1\n+\n+#ifdef WANT_STUB\n+\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n+\t.align 5\n+L_ffi_closure_helper_DARWIN$stub:\n \t.indirect_symbol _ffi_closure_helper_DARWIN\n-\tmflr\tr0\n-\tbcl\t20,31,LO$ffi_closure_helper_DARWIN\n-LO$ffi_closure_helper_DARWIN:\n-\tmflr\tr11\n-\taddis\tr11,r11,ha16(L_ffi_closure_helper_DARWIN$lazy_ptr - LO$ffi_closure_helper_DARWIN)\n-\tmtlr\tr0\n-\tlgu\tr12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr - LO$ffi_closure_helper_DARWIN)(r11)\n-\tmtctr\tr12\n+\tmflr r0\n+\tbcl 20,31,\"L00000000001$spb\"\n+\"L00000000001$spb\":\n+\tmflr r11\n+\taddis r11,r11,ha16(L_ffi_closure_helper_DARWIN$lazy_ptr-\"L00000000001$spb\")\n+\tmtlr r0\n+\tlwzu r12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr-\"L00000000001$spb\")(r11)\n+\tmtctr r12\n \tbctr\n-.lazy_symbol_pointer\n+\t.lazy_symbol_pointer\n L_ffi_closure_helper_DARWIN$lazy_ptr:\n \t.indirect_symbol _ffi_closure_helper_DARWIN\n-\t.g_long dyld_stub_binding_helper\n+\t.long\tdyld_stub_binding_helper\n+\n+#if defined(__ppc64__)\n+\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n+\t.align 5\n+L_darwin64_struct_ret_by_value_p$stub:\n+\t.indirect_symbol _darwin64_struct_ret_by_value_p\n+\tmflr r0\n+\tbcl 20,31,\"L00000000002$spb\"\n+\"L00000000002$spb\":\n+\tmflr r11\n+\taddis r11,r11,ha16(L_darwin64_struct_ret_by_value_p$lazy_ptr-\"L00000000002$spb\")\n+\tmtlr r0\n+\tlwzu r12,lo16(L_darwin64_struct_ret_by_value_p$lazy_ptr-\"L00000000002$spb\")(r11)\n+\tmtctr r12\n+\tbctr\n+\t.lazy_symbol_pointer\n+L_darwin64_struct_ret_by_value_p$lazy_ptr:\n+\t.indirect_symbol _darwin64_struct_ret_by_value_p\n+\t.long\tdyld_stub_binding_helper\n+\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n+\t.align 5\n+L_darwin64_pass_struct_floats$stub:\n+\t.indirect_symbol _darwin64_pass_struct_floats\n+\tmflr r0\n+\tbcl 20,31,\"L00000000003$spb\"\n+\"L00000000003$spb\":\n+\tmflr r11\n+\taddis r11,r11,ha16(L_darwin64_pass_struct_floats$lazy_ptr-\"L00000000003$spb\")\n+\tmtlr r0\n+\tlwzu r12,lo16(L_darwin64_pass_struct_floats$lazy_ptr-\"L00000000003$spb\")(r11)\n+\tmtctr r12\n+\tbctr\n+\t.lazy_symbol_pointer\n+L_darwin64_pass_struct_floats$lazy_ptr:\n+\t.indirect_symbol _darwin64_pass_struct_floats\n+\t.long\tdyld_stub_binding_helper\n+#  endif\n #endif\n-.data\n-\t.align LOG2_GPR_BYTES\n-LLFB1$non_lazy_ptr:\n-\t.g_long LFB1"}, {"sha": "ee03dab698981e0bc43d94f0396e28af414c2e13", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 599, "deletions": 168, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "patch": "@@ -3,7 +3,7 @@\n \n    Copyright (C) 1998 Geoffrey Keating\n    Copyright (C) 2001 John Hornkvist\n-   Copyright (C) 2002, 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2006, 2007, 2009, 2010 Free Software Foundation, Inc.\n \n    FFI support for Darwin and AIX.\n    \n@@ -35,11 +35,17 @@\n extern void ffi_closure_ASM (void);\n \n enum {\n-  /* The assembly depends on these exact flags.  */\n-  FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7  */\n-  FLAG_RETURNS_FP       = 1 << (31-29),\n-  FLAG_RETURNS_64BITS   = 1 << (31-28),\n-  FLAG_RETURNS_128BITS  = 1 << (31-31),\n+  /* The assembly depends on these exact flags.  \n+     For Darwin64 (when FLAG_RETURNS_STRUCT is set):\n+       FLAG_RETURNS_FP indicates that the structure embeds FP data.\n+       FLAG_RETURNS_128BITS signals a special struct size that is not\n+       expanded for float content.  */\n+  FLAG_RETURNS_128BITS\t= 1 << (31-31), /* These go in cr7  */\n+  FLAG_RETURNS_NOTHING\t= 1 << (31-30),\n+  FLAG_RETURNS_FP\t= 1 << (31-29),\n+  FLAG_RETURNS_64BITS\t= 1 << (31-28),\n+\n+  FLAG_RETURNS_STRUCT\t= 1 << (31-27), /* This goes in cr6  */\n \n   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),\n   FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI  */\n@@ -50,62 +56,81 @@ enum {\n /* About the DARWIN ABI.  */\n enum {\n   NUM_GPR_ARG_REGISTERS = 8,\n-  NUM_FPR_ARG_REGISTERS = 13\n+  NUM_FPR_ARG_REGISTERS = 13,\n+  LINKAGE_AREA_GPRS = 6\n };\n-enum { ASM_NEEDS_REGISTERS = 4 };\n+\n+enum { ASM_NEEDS_REGISTERS = 4 }; /* r28-r31 */\n \n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments.\n+   \n+   m32/m64\n \n    The stack layout we want looks like this:\n \n    |   Return address from ffi_call_DARWIN      |\thigher addresses\n    |--------------------------------------------|\n-   |   Previous backchain pointer\t4\t|\tstack pointer here\n+   |   Previous backchain pointer\t4/8\t|\tstack pointer here\n    |--------------------------------------------|<+ <<<\ton entry to\n-   |   Saved r28-r31\t\t\t4*4\t| |\tffi_call_DARWIN\n+   |   ASM_NEEDS_REGISTERS=r28-r31   4*(4/8)\t| |\tffi_call_DARWIN\n    |--------------------------------------------| |\n-   |   Parameters             (at least 8*4=32) | |\n+   |   When we have any FP activity... the\t| |\n+   |   FPRs occupy NUM_FPR_ARG_REGISTERS slots\t| |\n+   |   here fp13 .. fp1 from high to low addr.\t| |\n+   ~\t\t\t\t\t\t~ ~\n+   |   Parameters      (at least 8*4/8=32/64)\t| | NUM_GPR_ARG_REGISTERS\n    |--------------------------------------------| |\n-   |   Space for GPR2                   4       | |\n+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8\t| |\n    |--------------------------------------------| |\tstack\t|\n-   |   Reserved                       2*4       | |\tgrows\t|\n+   |   Reserved                       2*4/8\t| |\tgrows\t|\n    |--------------------------------------------| |\tdown\tV\n-   |   Space for callee's LR\t\t4\t| |\n+   |   Space for callee's LR\t\t4/8\t| |\n    |--------------------------------------------| |\tlower addresses\n-   |   Saved CR                         4       | |\n+   |   Saved CR [low word for m64]      4/8\t| |\n    |--------------------------------------------| |     stack pointer here\n-   |   Current backchain pointer\t4\t|-/\tduring\n+   |   Current backchain pointer\t4/8\t|-/\tduring\n    |--------------------------------------------|   <<<\tffi_call_DARWIN\n \n    */\n \n+#if defined(POWERPC_DARWIN64)\n+static void\n+darwin64_pass_struct_by_value \n+  (ffi_type *, char *, unsigned, unsigned *, double **, unsigned long **);\n+#endif\n+\n+/* This depends on GPR_SIZE = sizeof (unsigned long) */\n+\n void\n ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n   const unsigned nargs = ecif->cif->nargs;\n+#if !defined(POWERPC_DARWIN64) \n   const ffi_abi abi = ecif->cif->abi;\n+#endif\n \n   /* 'stacktop' points at the previous backchain pointer.  */\n   unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));\n \n   /* 'fpr_base' points at the space for fpr1, and grows upwards as\n      we use FPR registers.  */\n   double *fpr_base = (double *) (stacktop - ASM_NEEDS_REGISTERS) - NUM_FPR_ARG_REGISTERS;\n-  int fparg_count = 0;\n-\n+  int gp_count = 0, fparg_count = 0;\n \n   /* 'next_arg' grows up as we put parameters in it.  */\n-  unsigned long *next_arg = stack + 6; /* 6 reserved positions.  */\n+  unsigned long *next_arg = stack + LINKAGE_AREA_GPRS; /* 6 reserved positions.  */\n \n   int i;\n   double double_tmp;\n   void **p_argv = ecif->avalue;\n   unsigned long gprvalue;\n   ffi_type** ptr = ecif->cif->arg_types;\n+#if !defined(POWERPC_DARWIN64) \n   char *dest_cpy;\n+#endif\n   unsigned size_al = 0;\n \n   /* Check that everything starts aligned properly.  */\n@@ -130,25 +155,30 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n \t   the size of the floating-point parameter are skipped.  */\n \tcase FFI_TYPE_FLOAT:\n \t  double_tmp = *(float *) *p_argv;\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-\t    *(double *)next_arg = double_tmp;\n-\t  else\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n \t    *fpr_base++ = double_tmp;\n+#if defined(POWERPC_DARWIN)\n+\t  *(float *)next_arg = *(float *) *p_argv;\n+#else\n+\t  *(double *)next_arg = double_tmp;\n+#endif\n \t  next_arg++;\n+\t  gp_count++;\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n \t  double_tmp = *(double *) *p_argv;\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-\t    *(double *)next_arg = double_tmp;\n-\t  else\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n \t    *fpr_base++ = double_tmp;\n+\t  *(double *)next_arg = double_tmp;\n #ifdef POWERPC64\n \t  next_arg++;\n+\t  gp_count++;\n #else\n \t  next_arg += 2;\n+\t  gp_count += 2;\n #endif\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n@@ -157,30 +187,41 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \n \tcase FFI_TYPE_LONGDOUBLE:\n-#ifdef POWERPC64\n+#  if defined(POWERPC64) && !defined(POWERPC_DARWIN64)\n+\t  /* ??? This will exceed the regs count when the value starts at fp13\n+\t     and it will not put the extra bit on the stack.  */\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n \t    *(long double *) fpr_base++ = *(long double *) *p_argv;\n \t  else\n \t    *(long double *) next_arg = *(long double *) *p_argv;\n \t  next_arg += 2;\n \t  fparg_count += 2;\n-#else\n+#  else\n \t  double_tmp = ((double *) *p_argv)[0];\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n \t    *fpr_base++ = double_tmp;\n-\t  else\n-\t    *(double *) next_arg = double_tmp;\n+\t  *(double *) next_arg = double_tmp;\n+#    if defined(POWERPC_DARWIN64)\n+\t  next_arg++;\n+\t  gp_count++;\n+#    else\n \t  next_arg += 2;\n+\t  gp_count += 2;\n+#    endif\n \t  fparg_count++;\n-\n \t  double_tmp = ((double *) *p_argv)[1];\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n \t    *fpr_base++ = double_tmp;\n-\t  else\n-\t    *(double *) next_arg = double_tmp;\n+\t  *(double *) next_arg = double_tmp;\n+#    if defined(POWERPC_DARWIN64)\n+\t  next_arg++;\n+\t  gp_count++;\n+#    else\n \t  next_arg += 2;\n+\t  gp_count += 2;\n+#    endif\n \t  fparg_count++;\n-#endif\n+#  endif\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n #endif\n@@ -192,6 +233,7 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n #else\n \t  *(long long *) next_arg = *(long long *) *p_argv;\n \t  next_arg += 2;\n+\t  gp_count += 2;\n #endif\n \t  break;\n \tcase FFI_TYPE_POINTER:\n@@ -211,32 +253,35 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n \t  goto putgpr;\n \n \tcase FFI_TYPE_STRUCT:\n-#ifdef POWERPC64\n-\t  dest_cpy = (char *) next_arg;\n \t  size_al = (*ptr)->size;\n-\t  if ((*ptr)->elements[0]->type == 3)\n+#if defined(POWERPC_DARWIN64)\n+\t  next_arg = (unsigned long *)ALIGN((char *)next_arg, (*ptr)->alignment);\n+\t  darwin64_pass_struct_by_value (*ptr, (char *) *p_argv, \n+\t\t\t\t\t (unsigned) size_al,\n+\t\t\t\t\t (unsigned int *) &fparg_count,\n+\t\t\t\t\t &fpr_base, &next_arg);\n+#else\n+\t  dest_cpy = (char *) next_arg;\n+\n+\t  /* If the first member of the struct is a double, then include enough\n+\t     padding in the struct size to align it to double-word.  */\n+\t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n \t    size_al = ALIGN((*ptr)->size, 8);\n-\t  if (size_al < 3 && abi == FFI_DARWIN)\n-\t    dest_cpy += 4 - size_al;\n \n+#  if defined(POWERPC64) \n+\t  FFI_ASSERT (abi != FFI_DARWIN);\n \t  memcpy ((char *) dest_cpy, (char *) *p_argv, size_al);\n \t  next_arg += (size_al + 7) / 8;\n-#else\n-\t  dest_cpy = (char *) next_arg;\n-\n+#  else\n \t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n \t     SI 4 bytes) are aligned as if they were those modes.\n \t     Structures with 3 byte in size are padded upwards.  */\n-\t  size_al = (*ptr)->size;\n-\t  /* If the first member of the struct is a double, then align\n-\t     the struct to double-word.  */\n-\t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n-\t    size_al = ALIGN((*ptr)->size, 8);\n \t  if (size_al < 3 && abi == FFI_DARWIN)\n \t    dest_cpy += 4 - size_al;\n \n \t  memcpy((char *) dest_cpy, (char *) *p_argv, size_al);\n \t  next_arg += (size_al + 3) / 4;\n+#  endif\n #endif\n \t  break;\n \n@@ -249,6 +294,7 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n \t  gprvalue = *(unsigned int *) *p_argv;\n \tputgpr:\n \t  *next_arg++ = gprvalue;\n+\t  gp_count++;\n \t  break;\n \tdefault:\n \t  break;\n@@ -262,8 +308,269 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n   //FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n }\n \n+#if defined(POWERPC_DARWIN64)\n+\n+/* See if we can put some of the struct into fprs.\n+   This should not be called for structures of size 16 bytes, since these are not\n+   broken out this way.  */\n+static void\n+darwin64_scan_struct_for_floats (ffi_type *s, unsigned *nfpr)\n+{\n+  int i;\n+\n+  FFI_ASSERT (s->type == FFI_TYPE_STRUCT)\n+\n+  for (i = 0; s->elements[i] != NULL; i++)\n+    {\n+      ffi_type *p = s->elements[i];\n+      switch (p->type)\n+\t{\n+\t  case FFI_TYPE_STRUCT:\n+\t    darwin64_scan_struct_for_floats (p, nfpr);\n+\t    break;\n+\t  case FFI_TYPE_LONGDOUBLE:\n+\t    (*nfpr) += 2;\n+\t    break;\n+\t  case FFI_TYPE_DOUBLE:\n+\t  case FFI_TYPE_FLOAT:\n+\t    (*nfpr) += 1;\n+\t    break;\n+\t  default:\n+\t    break;    \n+\t}\n+    }\n+}\n+\n+static int\n+darwin64_struct_size_exceeds_gprs_p (ffi_type *s, char *src, unsigned *nfpr)\n+{\n+  unsigned struct_offset=0, i;\n+\n+  for (i = 0; s->elements[i] != NULL; i++)\n+    {\n+      char *item_base;\n+      ffi_type *p = s->elements[i];\n+      /* Find the start of this item (0 for the first one).  */\n+      if (i > 0)\n+        struct_offset = ALIGN(struct_offset, p->alignment);\n+\n+      item_base = src + struct_offset;\n+\n+      switch (p->type)\n+\t{\n+\t  case FFI_TYPE_STRUCT:\n+\t    if (darwin64_struct_size_exceeds_gprs_p (p, item_base, nfpr))\n+\t      return 1;\n+\t    break;\n+\t  case FFI_TYPE_LONGDOUBLE:\n+\t    if (*nfpr >= NUM_FPR_ARG_REGISTERS)\n+\t      return 1;\n+\t    (*nfpr) += 1;\n+\t    item_base += 8;\n+\t  /* FALL THROUGH */\n+\t  case FFI_TYPE_DOUBLE:\n+\t    if (*nfpr >= NUM_FPR_ARG_REGISTERS)\n+\t      return 1;\n+\t    (*nfpr) += 1;\n+\t    break;\n+\t  case FFI_TYPE_FLOAT:\n+\t    if (*nfpr >= NUM_FPR_ARG_REGISTERS)\n+\t      return 1;\n+\t    (*nfpr) += 1;\n+\t    break;\n+\t  default:\n+\t    /* If we try and place any item, that is non-float, once we've\n+\t       exceeded the 8 GPR mark, then we can't fit the struct.  */\n+\t    if ((unsigned long)item_base >= 8*8) \n+\t      return 1;\n+\t    break;    \n+\t}\n+      /* now count the size of what we just used.  */\n+      struct_offset += p->size;\n+    }\n+  return 0;\n+}\n+\n+/* Can this struct be returned by value?  */\n+int \n+darwin64_struct_ret_by_value_p (ffi_type *s)\n+{\n+  unsigned nfp = 0;\n+\n+  FFI_ASSERT (s && s->type == FFI_TYPE_STRUCT);\n+  \n+  /* The largest structure we can return is 8long + 13 doubles.  */\n+  if (s->size > 168)\n+    return 0;\n+  \n+  /* We can't pass more than 13 floats.  */\n+  darwin64_scan_struct_for_floats (s, &nfp);\n+  if (nfp > 13)\n+    return 0;\n+  \n+  /* If there are not too many floats, and the struct is\n+     small enough to accommodate in the GPRs, then it must be OK.  */\n+  if (s->size <= 64)\n+    return 1;\n+  \n+  /* Well, we have to look harder.  */\n+  nfp = 0;\n+  if (darwin64_struct_size_exceeds_gprs_p (s, NULL, &nfp))\n+    return 0;\n+  \n+  return 1;\n+}\n+\n+void\n+darwin64_pass_struct_floats (ffi_type *s, char *src, \n+\t\t\t     unsigned *nfpr, double **fprs)\n+{\n+  int i;\n+  double *fpr_base = *fprs;\n+  unsigned struct_offset = 0;\n+\n+  /* We don't assume anything about the alignment of the source.  */\n+  for (i = 0; s->elements[i] != NULL; i++)\n+    {\n+      char *item_base;\n+      ffi_type *p = s->elements[i];\n+      /* Find the start of this item (0 for the first one).  */\n+      if (i > 0)\n+        struct_offset = ALIGN(struct_offset, p->alignment);\n+      item_base = src + struct_offset;\n+\n+      switch (p->type)\n+\t{\n+\t  case FFI_TYPE_STRUCT:\n+\t    darwin64_pass_struct_floats (p, item_base, nfpr,\n+\t\t\t\t\t   &fpr_base);\n+\t    break;\n+\t  case FFI_TYPE_LONGDOUBLE:\n+\t    if (*nfpr < NUM_FPR_ARG_REGISTERS)\n+\t      *fpr_base++ = *(double *)item_base;\n+\t    (*nfpr) += 1;\n+\t    item_base += 8;\n+\t  /* FALL THROUGH */\n+\t  case FFI_TYPE_DOUBLE:\n+\t    if (*nfpr < NUM_FPR_ARG_REGISTERS)\n+\t      *fpr_base++ = *(double *)item_base;\n+\t    (*nfpr) += 1;\n+\t    break;\n+\t  case FFI_TYPE_FLOAT:\n+\t    if (*nfpr < NUM_FPR_ARG_REGISTERS)\n+\t      *fpr_base++ = (double) *(float *)item_base;\n+\t    (*nfpr) += 1;\n+\t    break;\n+\t  default:\n+\t    break;    \n+\t}\n+      /* now count the size of what we just used.  */\n+      struct_offset += p->size;\n+    }\n+  /* Update the scores.  */\n+  *fprs = fpr_base;\n+}\n+\n+/* Darwin64 special rules.\n+   Break out a struct into params and float registers.  */\n+static void\n+darwin64_pass_struct_by_value (ffi_type *s, char *src, unsigned size,\n+\t\t\t       unsigned *nfpr, double **fprs, unsigned long **arg)\n+{\n+  unsigned long *next_arg = *arg;\n+  char *dest_cpy = (char *)next_arg;\n+\n+  FFI_ASSERT (s->type == FFI_TYPE_STRUCT)\n+\n+  if (!size)\n+    return;\n+\n+  /* First... special cases.  */\n+  if (size < 3\n+      || (size == 4 \n+\t  && s->elements[0] \n+\t  && s->elements[0]->type != FFI_TYPE_FLOAT))\n+    {\n+      /* Must be at least one GPR, padding is unspecified in value, \n+\t let's make it zero.  */\n+      *next_arg = 0UL; \n+      dest_cpy += 8 - size;\n+      memcpy ((char *) dest_cpy, src, size);\n+      next_arg++;\n+    }\n+  else if (size == 16)\n+    {\n+      memcpy ((char *) dest_cpy, src, size);\n+      next_arg += 2;\n+    }\n+  else\n+    {\n+      /* now the general case, we consider embedded floats.  */\n+      memcpy ((char *) dest_cpy, src, size);\n+      darwin64_pass_struct_floats (s, src, nfpr, fprs);\n+      next_arg += (size+7)/8;\n+    }\n+    \n+  *arg = next_arg;\n+}\n+\n+double *\n+darwin64_struct_floats_to_mem (ffi_type *s, char *dest, double *fprs, unsigned *nf)\n+{\n+  int i;\n+  unsigned struct_offset = 0;\n+\n+  /* We don't assume anything about the alignment of the source.  */\n+  for (i = 0; s->elements[i] != NULL; i++)\n+    {\n+      char *item_base;\n+      ffi_type *p = s->elements[i];\n+      /* Find the start of this item (0 for the first one).  */\n+      if (i > 0)\n+        struct_offset = ALIGN(struct_offset, p->alignment);\n+      item_base = dest + struct_offset;\n+\n+      switch (p->type)\n+\t{\n+\t  case FFI_TYPE_STRUCT:\n+\t    fprs = darwin64_struct_floats_to_mem (p, item_base, fprs, nf);\n+\t    break;\n+\t  case FFI_TYPE_LONGDOUBLE:\n+\t    if (*nf < NUM_FPR_ARG_REGISTERS)\n+\t      {\n+\t\t*(double *)item_base = *fprs++ ;\n+\t\t(*nf) += 1;\n+\t      }\n+\t    item_base += 8;\n+\t  /* FALL THROUGH */\n+\t  case FFI_TYPE_DOUBLE:\n+\t    if (*nf < NUM_FPR_ARG_REGISTERS)\n+\t      {\n+\t\t*(double *)item_base = *fprs++ ;\n+\t\t(*nf) += 1;\n+\t      }\n+\t    break;\n+\t  case FFI_TYPE_FLOAT:\n+\t    if (*nf < NUM_FPR_ARG_REGISTERS)\n+\t      {\n+\t\t*(float *)item_base = (float) *fprs++ ;\n+\t\t(*nf) += 1;\n+\t      }\n+\t    break;\n+\t  default:\n+\t    break;    \n+\t}\n+      /* now count the size of what we just used.  */\n+      struct_offset += p->size;\n+    }\n+  return fprs;\n+}\n+\n+#endif\n+\n /* Adjust the size of S to be correct for Darwin.\n-   On Darwin, the first field of a structure has natural alignment.  */\n+   On Darwin m32, the first field of a structure has natural alignment.  \n+   On Darwin m64, all fields have natural alignment.  */\n \n static void\n darwin_adjust_aggregate_sizes (ffi_type *s)\n@@ -280,22 +587,29 @@ darwin_adjust_aggregate_sizes (ffi_type *s)\n       int align;\n       \n       p = s->elements[i];\n-      darwin_adjust_aggregate_sizes (p);\n-      if (i == 0\n-\t  && (p->type == FFI_TYPE_UINT64\n-\t      || p->type == FFI_TYPE_SINT64\n-\t      || p->type == FFI_TYPE_DOUBLE\n-\t      || p->alignment == 8))\n-\talign = 8;\n+      if (p->type == FFI_TYPE_STRUCT)\n+\tdarwin_adjust_aggregate_sizes (p);\n+#if defined(POWERPC_DARWIN64)\n+      /* Natural alignment for all items.  */\n+      align = p->alignment;\n+#else\n+      /* Natrual alignment for the first item... */\n+      if (i == 0)\n+\talign = p->alignment;\n       else if (p->alignment == 16 || p->alignment < 4)\n+\t/* .. subsequent items with vector or align < 4 have natural align.  */\n \talign = p->alignment;\n       else\n+\t/* .. or align is 4.  */\n \talign = 4;\n+#endif\n+      /* Pad, if necessary, before adding the current item.  */\n       s->size = ALIGN(s->size, align) + p->size;\n     }\n   \n   s->size = ALIGN(s->size, s->alignment);\n   \n+  /* This should not be necessary on m64, but harmless.  */\n   if (s->elements[0]->type == FFI_TYPE_UINT64\n       || s->elements[0]->type == FFI_TYPE_SINT64\n       || s->elements[0]->type == FFI_TYPE_DOUBLE\n@@ -347,7 +661,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   unsigned i;\n   ffi_type **ptr;\n   unsigned bytes;\n-  int fparg_count = 0, intarg_count = 0;\n+  unsigned fparg_count = 0, intarg_count = 0;\n   unsigned flags = 0;\n   unsigned size_al = 0;\n \n@@ -372,16 +686,25 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   /* Space for the frame pointer, callee's LR, CR, etc, and for\n      the asm's temp regs.  */\n \n-  bytes = (6 + ASM_NEEDS_REGISTERS) * sizeof(long);\n+  bytes = (LINKAGE_AREA_GPRS + ASM_NEEDS_REGISTERS) * sizeof(unsigned long);\n \n-  /* Return value handling.  The rules are as follows:\n+  /* Return value handling.  \n+    The rules m32 are as follows:\n      - 32-bit (or less) integer values are returned in gpr3;\n-     - Structures of size <= 4 bytes also returned in gpr3;\n-     - 64-bit integer values and structures between 5 and 8 bytes are returned\n-       in gpr3 and gpr4;\n+     - structures of size <= 4 bytes also returned in gpr3;\n+     - 64-bit integer values [??? and structures between 5 and 8 bytes] are\n+       returned in gpr3 and gpr4;\n      - Single/double FP values are returned in fpr1;\n      - Long double FP (if not equivalent to double) values are returned in\n        fpr1 and fpr2;\n+     m64:\n+     - 64-bit or smaller integral values are returned in GPR3\n+     - Single/double FP values are returned in fpr1;\n+     - Long double FP values are returned in fpr1 and fpr2;\n+     m64 Structures:\n+     - If the structure could be accommodated in registers were it to be the\n+       first argument to a routine, then it is returned in those registers.\n+     m32/m64 structures otherwise:\n      - Larger structures values are allocated space and a pointer is passed\n        as the first argument.  */\n   switch (cif->rtype->type)\n@@ -410,9 +733,42 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n       break;\n \n     case FFI_TYPE_STRUCT:\n+#if defined(POWERPC_DARWIN64)\n+      {\n+\t/* Can we fit the struct into regs?  */\n+\tif (darwin64_struct_ret_by_value_p (cif->rtype))\n+\t  {\n+\t    unsigned nfpr = 0;\n+\t    flags |= FLAG_RETURNS_STRUCT;\n+\t    if (cif->rtype->size != 16)\n+\t      darwin64_scan_struct_for_floats (cif->rtype, &nfpr) ;\n+\t    else\n+\t      flags |= FLAG_RETURNS_128BITS;\n+\t    /* Will be 0 for 16byte struct.  */\n+\t    if (nfpr)\n+\t      flags |= FLAG_RETURNS_FP;\n+\t  }\n+\telse /* By ref. */\n+\t  {\n+\t    flags |= FLAG_RETVAL_REFERENCE;\n+\t    flags |= FLAG_RETURNS_NOTHING;\n+\t    intarg_count++;\n+\t  }\n+      }\n+#elif defined(DARWIN_PPC)\n+      if (cif->rtype->size <= 4)\n+\tflags |= FLAG_RETURNS_STRUCT;\n+      else /* else by reference.  */\n+\t{\n+\t  flags |= FLAG_RETVAL_REFERENCE;\n+\t  flags |= FLAG_RETURNS_NOTHING;\n+\t  intarg_count++;\n+\t}\n+#else /* assume we pass by ref.  */\n       flags |= FLAG_RETVAL_REFERENCE;\n       flags |= FLAG_RETURNS_NOTHING;\n       intarg_count++;\n+#endif\n       break;\n     case FFI_TYPE_VOID:\n       flags |= FLAG_RETURNS_NOTHING;\n@@ -425,57 +781,83 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n   /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the\n      first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest\n-     goes on the stack.  Structures are passed as a pointer to a copy of\n-     the structure. Stuff on the stack needs to keep proper alignment.  */\n+     goes on the stack.  \n+     ??? Structures are passed as a pointer to a copy of the structure. \n+     Stuff on the stack needs to keep proper alignment.  \n+     For m64 the count is effectively of half-GPRs.  */\n   for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n     {\n+      unsigned align_words;\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n \tcase FFI_TYPE_DOUBLE:\n \t  fparg_count++;\n+#if !defined(POWERPC_DARWIN64)\n \t  /* If this FP arg is going on the stack, it must be\n \t     8-byte-aligned.  */\n \t  if (fparg_count > NUM_FPR_ARG_REGISTERS\n-\t      && intarg_count%2 != 0)\n+\t      && (intarg_count & 0x01) != 0)\n \t    intarg_count++;\n+#endif\n \t  break;\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\n \tcase FFI_TYPE_LONGDOUBLE:\n \t  fparg_count += 2;\n \t  /* If this FP arg is going on the stack, it must be\n-\t     8-byte-aligned.  */\n-\t  if (fparg_count > NUM_FPR_ARG_REGISTERS\n-\t      && intarg_count%2 != 0)\n-\t    intarg_count++;\n-\t  intarg_count +=2;\n+\t     16-byte-aligned.  */\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+#if defined (POWERPC64)\n+\t    intarg_count = ALIGN(intarg_count, 2);\n+#else\n+\t    intarg_count = ALIGN(intarg_count, 4);\n+#endif\n \t  break;\n #endif\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n+#if defined(POWERPC64)\n+\t  intarg_count++;\n+#else\n \t  /* 'long long' arguments are passed as two words, but\n \t     either both words must fit in registers or both go\n \t     on the stack.  If they go on the stack, they must\n \t     be 8-byte-aligned.  */\n \t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n-\t      || (intarg_count >= NUM_GPR_ARG_REGISTERS && intarg_count%2 != 0))\n+\t      || (intarg_count >= NUM_GPR_ARG_REGISTERS \n+\t          && (intarg_count & 0x01) != 0))\n \t    intarg_count++;\n \t  intarg_count += 2;\n+#endif\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n \t  size_al = (*ptr)->size;\n+#if defined(POWERPC_DARWIN64)\n+\t  align_words = (*ptr)->alignment >> 3;\n+\t  if (align_words)\n+\t    intarg_count = ALIGN(intarg_count, align_words);\n+\t  /* Base size of the struct.  */\n+\t  intarg_count += (size_al + 7) / 8;\n+\t  /* If 16 bytes then don't worry about floats.  */\n+\t  if (size_al != 16)\n+\t    /* Scan through for floats to be placed in regs.  */\n+\t    darwin64_scan_struct_for_floats (*ptr, &fparg_count) ;\n+#else\n+\t  align_words = (*ptr)->alignment >> 2;\n+\t  if (align_words)\n+\t    intarg_count = ALIGN(intarg_count, align_words);\n \t  /* If the first member of the struct is a double, then align\n-\t     the struct to double-word.  */\n+\t     the struct to double-word. \n \t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n-\t    size_al = ALIGN((*ptr)->size, 8);\n-#ifdef POWERPC64\n+\t    size_al = ALIGN((*ptr)->size, 8); */\n+#  ifdef POWERPC64\n \t  intarg_count += (size_al + 7) / 8;\n-#else\n+#  else\n \t  intarg_count += (size_al + 3) / 4;\n+#  endif\n #endif\n \t  break;\n \n@@ -490,9 +872,18 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   if (fparg_count != 0)\n     flags |= FLAG_FP_ARGUMENTS;\n \n+#if defined(POWERPC_DARWIN64)\n+  /* Space to image the FPR registers, if needed - which includes when they might be\n+     used in a struct return.  */\n+  if (fparg_count != 0 \n+      || ((flags & FLAG_RETURNS_STRUCT)\n+\t   && (flags & FLAG_RETURNS_FP)))\n+    bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n+#else\n   /* Space for the FPR registers, if needed.  */\n   if (fparg_count != 0)\n     bytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n+#endif\n \n   /* Stack space.  */\n #ifdef POWERPC64\n@@ -506,7 +897,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n     bytes += NUM_GPR_ARG_REGISTERS * sizeof(long);\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n-  bytes = (bytes + 15) & ~0xF;\n+  bytes = ALIGN(bytes, 16) ;\n \n   cif->flags = flags;\n   cif->bytes = bytes;\n@@ -516,8 +907,9 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n extern void ffi_call_AIX(extended_cif *, long, unsigned, unsigned *,\n \t\t\t void (*fn)(void), void (*fn2)(void));\n+\n extern void ffi_call_DARWIN(extended_cif *, long, unsigned, unsigned *,\n-\t\t\t    void (*fn)(void), void (*fn2)(void));\n+\t\t\t    void (*fn)(void), void (*fn2)(void), ffi_type*);\n \n void\n ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n@@ -546,7 +938,7 @@ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n       break;\n     case FFI_DARWIN:\n       ffi_call_DARWIN(&ecif, -(long)cif->bytes, cif->flags, ecif.rvalue, fn,\n-\t\t      FFI_FN(ffi_prep_args));\n+\t\t      FFI_FN(ffi_prep_args), cif->rtype);\n       break;\n     default:\n       FFI_ASSERT(0);\n@@ -566,58 +958,48 @@ typedef struct aix_fd_struct {\n } aix_fd;\n \n /* here I'd like to add the stack frame layout we use in darwin_closure.S\n-   and aix_clsoure.S\n-\n-   SP previous -> +---------------------------------------+ <--- child frame\n-\t\t  | back chain to caller 4                |\n-\t\t  +---------------------------------------+ 4\n-\t\t  | saved CR 4                            |\n-\t\t  +---------------------------------------+ 8\n-\t\t  | saved LR 4                            |\n-\t\t  +---------------------------------------+ 12\n-\t\t  | reserved for compilers 4              |\n-\t\t  +---------------------------------------+ 16\n-\t\t  | reserved for binders 4                |\n-\t\t  +---------------------------------------+ 20\n-\t\t  | saved TOC pointer 4                   |\n-\t\t  +---------------------------------------+ 24\n-\t\t  | always reserved 8*4=32 (previous GPRs)|\n-\t\t  | according to the linkage convention   |\n-\t\t  | from AIX                              |\n-\t\t  +---------------------------------------+ 56\n-\t\t  | our FPR area 13*8=104                 |\n-\t\t  | f1                                    |\n-\t\t  | .                                     |\n-\t\t  | f13                                   |\n-\t\t  +---------------------------------------+ 160\n-\t\t  | result area 8                         |\n-\t\t  +---------------------------------------+ 168\n-\t\t  | alignement to the next multiple of 16 |\n-SP current -->    +---------------------------------------+ 176 <- parent frame\n-\t\t  | back chain to caller 4                |\n-\t\t  +---------------------------------------+ 180\n-\t\t  | saved CR 4                            |\n-\t\t  +---------------------------------------+ 184\n-\t\t  | saved LR 4                            |\n-\t\t  +---------------------------------------+ 188\n-\t\t  | reserved for compilers 4              |\n-\t\t  +---------------------------------------+ 192\n-\t\t  | reserved for binders 4                |\n-\t\t  +---------------------------------------+ 196\n-\t\t  | saved TOC pointer 4                   |\n-\t\t  +---------------------------------------+ 200\n-\t\t  | always reserved 8*4=32  we store our  |\n-\t\t  | GPRs here                             |\n-\t\t  | r3                                    |\n-\t\t  | .                                     |\n-\t\t  | r10                                   |\n-\t\t  +---------------------------------------+ 232\n-\t\t  | overflow part                         |\n-\t\t  +---------------------------------------+ xxx\n-\t\t  | ????                                  |\n-\t\t  +---------------------------------------+ xxx\n+   and aix_closure.S\n+\n+   m32/m64\n+\n+   The stack layout looks like this:\n+\n+   |   Additional params...\t\t\t| |     Higher address\n+   ~\t\t\t\t\t\t~ ~\n+   |   Parameters      (at least 8*4/8=32/64)\t| | NUM_GPR_ARG_REGISTERS\n+   |--------------------------------------------| |\n+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8\t| |\n+   |--------------------------------------------| |\n+   |   Reserved                       2*4/8\t| |\n+   |--------------------------------------------| |\n+   |   Space for callee's LR\t\t4/8\t| |\n+   |--------------------------------------------| |\n+   |   Saved CR [low word for m64]      4/8\t| |\n+   |--------------------------------------------| |\n+   |   Current backchain pointer\t4/8\t|-/ Parent's frame.\n+   |--------------------------------------------| <+ <<< on entry to ffi_closure_ASM\n+   |   Result Bytes\t\t\t16\t| |\n+   |--------------------------------------------| |\n+   ~   padding to 16-byte alignment\t\t~ ~\n+   |--------------------------------------------| |\n+   |   NUM_FPR_ARG_REGISTERS slots\t\t| |\n+   |   here fp13 .. fp1\t\t       13*8\t| |\n+   |--------------------------------------------| |\n+   |   R3..R10\t\t\t  8*4/8=32/64\t| | NUM_GPR_ARG_REGISTERS\n+   |--------------------------------------------| |\n+   |   TOC=R2 (AIX) Reserved (Darwin)   4/8\t| |\n+   |--------------------------------------------| |\tstack\t|\n+   |   Reserved [compiler,binder]     2*4/8\t| |\tgrows\t|\n+   |--------------------------------------------| |\tdown\tV\n+   |   Space for callee's LR\t\t4/8\t| |\n+   |--------------------------------------------| |\tlower addresses\n+   |   Saved CR [low word for m64]      4/8\t| |\n+   |--------------------------------------------| |     stack pointer here\n+   |   Current backchain pointer\t4/8\t|-/\tduring\n+   |--------------------------------------------|   <<<\tffi_closure_ASM.\n \n */\n+\n ffi_status\n ffi_prep_closure_loc (ffi_closure* closure,\n \t\t      ffi_cif* cif,\n@@ -631,30 +1013,44 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n   switch (cif->abi)\n     {\n-    case FFI_DARWIN:\n-\n-      FFI_ASSERT (cif->abi == FFI_DARWIN);\n-\n-      tramp = (unsigned int *) &closure->tramp[0];\n-      tramp[0] = 0x7c0802a6;  /*   mflr    r0  */\n-      tramp[1] = 0x429f000d;  /*   bcl-    20,4*cr7+so,0x10  */\n-      tramp[4] = 0x7d6802a6;  /*   mflr    r11  */\n-      tramp[5] = 0x818b0000;  /*   lwz     r12,0(r11) function address  */\n-      tramp[6] = 0x7c0803a6;  /*   mtlr    r0   */\n-      tramp[7] = 0x7d8903a6;  /*   mtctr   r12  */\n-      tramp[8] = 0x816b0004;  /*   lwz     r11,4(r11) static chain  */\n-      tramp[9] = 0x4e800420;  /*   bctr  */\n-      tramp[2] = (unsigned long) ffi_closure_ASM; /* function  */\n-      tramp[3] = (unsigned long) codeloc; /* context  */\n-\n-      closure->cif = cif;\n-      closure->fun = fun;\n-      closure->user_data = user_data;\n+      case FFI_DARWIN:\n+\n+\tFFI_ASSERT (cif->abi == FFI_DARWIN);\n+\n+\ttramp = (unsigned int *) &closure->tramp[0];\n+#if defined(POWERPC_DARWIN64)\n+\ttramp[0] = 0x7c0802a6;  /*   mflr    r0  */\n+\ttramp[1] = 0x429f0015;  /*   bcl-    20,4*cr7+so,  +0x18 (L1)  */\n+\t/* We put the addresses here.  */\n+\ttramp[6] = 0x7d6802a6;  /*L1:   mflr    r11  */\n+\ttramp[7] = 0xe98b0000;  /*   ld     r12,0(r11) function address  */\n+\ttramp[8] = 0x7c0803a6;  /*   mtlr    r0   */\n+\ttramp[9] = 0x7d8903a6;  /*   mtctr   r12  */\n+\ttramp[10] = 0xe96b0008;  /*   lwz     r11,8(r11) static chain  */\n+\ttramp[11] = 0x4e800420;  /*   bctr  */\n+\n+\t*((unsigned long *)&tramp[2]) = (unsigned long) ffi_closure_ASM; /* function  */\n+\t*((unsigned long *)&tramp[4]) = (unsigned long) codeloc; /* context  */\n+#else\n+\ttramp[0] = 0x7c0802a6;  /*   mflr    r0  */\n+\ttramp[1] = 0x429f000d;  /*   bcl-    20,4*cr7+so,0x10  */\n+\ttramp[4] = 0x7d6802a6;  /*   mflr    r11  */\n+\ttramp[5] = 0x818b0000;  /*   lwz     r12,0(r11) function address  */\n+\ttramp[6] = 0x7c0803a6;  /*   mtlr    r0   */\n+\ttramp[7] = 0x7d8903a6;  /*   mtctr   r12  */\n+\ttramp[8] = 0x816b0004;  /*   lwz     r11,4(r11) static chain  */\n+\ttramp[9] = 0x4e800420;  /*   bctr  */\n+\ttramp[2] = (unsigned long) ffi_closure_ASM; /* function  */\n+\ttramp[3] = (unsigned long) codeloc; /* context  */\n+#endif\n+\tclosure->cif = cif;\n+\tclosure->fun = fun;\n+\tclosure->user_data = user_data;\n \n-      /* Flush the icache. Only necessary on Darwin.  */\n-      flush_range(codeloc, FFI_TRAMPOLINE_SIZE);\n+\t/* Flush the icache. Only necessary on Darwin.  */\n+\tflush_range(codeloc, FFI_TRAMPOLINE_SIZE);\n \n-      break;\n+\tbreak;\n \n     case FFI_AIX:\n \n@@ -708,7 +1104,7 @@ typedef union\n   double d;\n } ffi_dblfl;\n \n-int\n+ffi_type *\n ffi_closure_helper_DARWIN (ffi_closure *, void *,\n \t\t\t   unsigned long *, ffi_dblfl *);\n \n@@ -719,7 +1115,7 @@ ffi_closure_helper_DARWIN (ffi_closure *, void *,\n    up space for a return value, ffi_closure_ASM invokes the\n    following helper function to do most of the work.  */\n \n-int\n+ffi_type *\n ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \t\t\t   unsigned long *pgr, ffi_dblfl *pfr)\n {\n@@ -741,16 +1137,32 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n   ffi_cif *        cif;\n   ffi_dblfl *      end_pfr = pfr + NUM_FPR_ARG_REGISTERS;\n   unsigned         size_al;\n+#if defined(POWERPC_DARWIN64)\n+  unsigned \t   fpsused = 0;\n+#endif\n \n   cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof(void *));\n \n-  /* Copy the caller's structure return value address so that the closure\n-     returns the data directly to the caller.  */\n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n+#if defined(POWERPC_DARWIN64)\n+      if (!darwin64_struct_ret_by_value_p (cif->rtype))\n+\t{\n+    \t  /* Won't fit into the regs - return by ref.  */\n+\t  rvalue = (void *) *pgr;\n+\t  pgr++;\n+\t}\n+#elif defined(DARWIN_PPC)\n+      if (cif->rtype->size > 4)\n+\t{\n+\t  rvalue = (void *) *pgr;\n+\t  pgr++;\n+\t}\n+#else /* assume we return by ref.  */\n       rvalue = (void *) *pgr;\n       pgr++;\n+#endif\n     }\n \n   i = 0;\n@@ -764,7 +1176,7 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \t{\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n-#ifdef POWERPC64\n+#if  defined(POWERPC64)\n \t  avalue[i] = (char *) pgr + 7;\n #else\n \t  avalue[i] = (char *) pgr + 3;\n@@ -774,7 +1186,7 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n-#ifdef POWERPC64\n+#if  defined(POWERPC64)\n \t  avalue[i] = (char *) pgr + 6;\n #else\n \t  avalue[i] = (char *) pgr + 2;\n@@ -784,7 +1196,7 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n-#ifdef POWERPC64\n+#if  defined(POWERPC64)\n \t  avalue[i] = (char *) pgr + 4;\n #else\n \tcase FFI_TYPE_POINTER:\n@@ -794,34 +1206,53 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-#ifdef POWERPC64\n \t  size_al = arg_types[i]->size;\n-\t  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)\n-\t    size_al = ALIGN (arg_types[i]->size, 8);\n-\t  if (size_al < 3 && cif->abi == FFI_DARWIN)\n-\t    avalue[i] = (char *) pgr + 8 - size_al;\n-\t  else\n-\t    avalue[i] = pgr;\n+#if defined(POWERPC_DARWIN64)\n+\t  pgr = (unsigned long *)ALIGN((char *)pgr, arg_types[i]->alignment);\n+\t  if (size_al < 3 || size_al == 4)\n+\t    {\n+\t      avalue[i] = ((char *)pgr)+8-size_al;\n+\t      if (arg_types[i]->elements[0]->type == FFI_TYPE_FLOAT\n+\t\t  && fpsused < NUM_FPR_ARG_REGISTERS)\n+\t\t{\n+\t\t  *(float *)pgr = (float) *(double *)pfr;\n+\t\t  pfr++;\n+\t\t  fpsused++;\n+\t\t}\n+\t    }\n+\t  else \n+\t    {\n+\t      if (size_al != 16)\n+\t\tpfr = (ffi_dblfl *) \n+\t\t    darwin64_struct_floats_to_mem (arg_types[i], (char *)pgr,\n+\t\t\t\t\t\t   (double *)pfr, &fpsused);\n+\t      avalue[i] = pgr;\n+\t    }\n \t  pgr += (size_al + 7) / 8;\n #else\n-\t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n-\t     SI 4 bytes) are aligned as if they were those modes.  */\n-\t  size_al = arg_types[i]->size;\n \t  /* If the first member of the struct is a double, then align\n \t     the struct to double-word.  */\n \t  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)\n \t    size_al = ALIGN(arg_types[i]->size, 8);\n+#  if defined(POWERPC64)\n+\t  FFI_ASSERT (cif->abi != FFI_DARWIN)\n+\t  avalue[i] = pgr;\n+\t  pgr += (size_al + 7) / 8;\n+#  else\n+\t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n+\t     SI 4 bytes) are aligned as if they were those modes.  */\n \t  if (size_al < 3 && cif->abi == FFI_DARWIN)\n \t    avalue[i] = (char*) pgr + 4 - size_al;\n \t  else\n \t    avalue[i] = pgr;\n \t  pgr += (size_al + 3) / 4;\n+#  endif\n #endif\n \t  break;\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n-#ifdef POWERPC64\n+#if  defined(POWERPC64)\n \tcase FFI_TYPE_POINTER:\n \t  avalue[i] = pgr;\n \t  pgr++;\n@@ -924,5 +1355,5 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n   /* Tell ffi_closure_ASM to perform return type promotions.  */\n-  return cif->rtype->type;\n+  return cif->rtype;\n }"}, {"sha": "d17f7312d814161b66fe996677c371835b8d0eb0", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a9f56e8c835b0d26e533eb78d3f4caec82050ce/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=3a9f56e8c835b0d26e533eb78d3f4caec82050ce", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n    ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc\n+   Copyright (C) 2007, 2008, 2010 Free Software Foundation, Inc\n    Target configuration macros for PowerPC.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -34,10 +34,13 @@\n #ifndef POWERPC64\n #define POWERPC64\n #endif\n-#elif defined (POWERPC_DARWIN) && defined (__ppc64__)\t/* Darwin */\n+#elif defined (POWERPC_DARWIN) && defined (__ppc64__)\t/* Darwin64 */\n #ifndef POWERPC64\n #define POWERPC64\n #endif\n+#ifndef POWERPC_DARWIN64\n+#define POWERPC_DARWIN64\n+#endif\n #elif defined (POWERPC_AIX) && defined (__64BIT__)\t/* AIX64 */\n #ifndef POWERPC64\n #define POWERPC64\n@@ -114,9 +117,13 @@ typedef enum ffi_abi {\n #define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_TYPE_LAST + 2)\n \n #if defined(POWERPC64) || defined(POWERPC_AIX)\n-#define FFI_TRAMPOLINE_SIZE 24\n+#  if defined(POWERPC_DARWIN64)\n+#    define FFI_TRAMPOLINE_SIZE 48\n+#  else\n+#    define FFI_TRAMPOLINE_SIZE 24\n+#  endif\n #else /* POWERPC || POWERPC_AIX */\n-#define FFI_TRAMPOLINE_SIZE 40\n+#  define FFI_TRAMPOLINE_SIZE 40\n #endif\n \n #ifndef LIBFFI_ASM"}]}