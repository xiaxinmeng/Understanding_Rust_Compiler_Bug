{"sha": "80db34d85bec3c9378bfeeb7bd5793cb2e35c043", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBkYjM0ZDg1YmVjM2M5Mzc4YmZlZWI3YmQ1NzkzY2IyZTM1YzA0Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-09-23T13:28:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-09-23T13:28:53Z"}, "message": "alpha.c (get_aligned_mem): Revert Sep 20 change.\n\n        * alpha.c (get_aligned_mem): Revert Sep 20 change.\n        (alpha_set_memflags, alpha_set_memflags_1): Likewise.\n        (alpha_align_insns): Properly calculate initial offset wrt max_align.\n\nFrom-SVN: r22559", "tree": {"sha": "9b81b6f3e633692572ce0181ae51bcbf8284f2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b81b6f3e633692572ce0181ae51bcbf8284f2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80db34d85bec3c9378bfeeb7bd5793cb2e35c043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80db34d85bec3c9378bfeeb7bd5793cb2e35c043", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80db34d85bec3c9378bfeeb7bd5793cb2e35c043", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80db34d85bec3c9378bfeeb7bd5793cb2e35c043/comments", "author": null, "committer": null, "parents": [{"sha": "7551cbc77e43285ce0903106daf4c1e653a8357e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7551cbc77e43285ce0903106daf4c1e653a8357e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7551cbc77e43285ce0903106daf4c1e653a8357e"}], "stats": {"total": 53, "additions": 34, "deletions": 19}, "files": [{"sha": "c022fc6697e277b9876d8176620eb2888582e50f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80db34d85bec3c9378bfeeb7bd5793cb2e35c043/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80db34d85bec3c9378bfeeb7bd5793cb2e35c043/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80db34d85bec3c9378bfeeb7bd5793cb2e35c043", "patch": "@@ -1,3 +1,9 @@\n+Wed Sep 23 13:26:02 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (get_aligned_mem): Revert Sep 20 change.\n+        (alpha_set_memflags, alpha_set_memflags_1): Likewise.\n+\t(alpha_align_insns): Properly calculate initial offset wrt max_align.\n+\n Wed Sep 23 10:45:44 1998  Richard Earnshaw (rearnsha@arm.com)\n \n \t* arm.c (find_barrier): Revert change of Apr 23.  Handle table"}, {"sha": "5f738b599b2caf37d027680a6e2baa25c4013172", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80db34d85bec3c9378bfeeb7bd5793cb2e35c043/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80db34d85bec3c9378bfeeb7bd5793cb2e35c043/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=80db34d85bec3c9378bfeeb7bd5793cb2e35c043", "patch": "@@ -106,7 +106,7 @@ static int alpha_sr_alias_set;\n \n /* Declarations of static functions.  */\n static void alpha_set_memflags_1\n-  PROTO((rtx, int, int, int, int));\n+  PROTO((rtx, int, int, int));\n static rtx alpha_emit_set_const_1\n   PROTO((rtx, enum machine_mode, HOST_WIDE_INT, int));\n static void alpha_expand_unaligned_load_words\n@@ -877,8 +877,14 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n \n-  *paligned_mem = change_address (ref, SImode, \n-\t\t\t\t  plus_constant (base, offset & ~3));\n+  *paligned_mem = gen_rtx_MEM (SImode, plus_constant (base, offset & ~3));\n+  MEM_IN_STRUCT_P (*paligned_mem) = MEM_IN_STRUCT_P (ref);\n+  MEM_VOLATILE_P (*paligned_mem) = MEM_VOLATILE_P (ref);\n+  RTX_UNCHANGING_P (*paligned_mem) = RTX_UNCHANGING_P (ref);\n+\n+  /* Sadly, we cannot use alias sets here because we may overlap other\n+     data in a different alias set.  */\n+  /* MEM_ALIAS_SET (*paligned_mem) = MEM_ALIAS_SET (ref); */\n \n   *pbitnum = GEN_INT ((offset & 3) * 8);\n }\n@@ -922,9 +928,9 @@ get_unaligned_address (ref, extra_offset)\n    found in part of X.  */\n \n static void\n-alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p, alias_set)\n+alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p)\n      rtx x;\n-     int in_struct_p, volatile_p, unchanging_p, alias_set;\n+     int in_struct_p, volatile_p, unchanging_p;\n {\n   int i;\n \n@@ -934,26 +940,31 @@ alpha_set_memflags_1 (x, in_struct_p, volatile_p, unchanging_p, alias_set)\n     case PARALLEL:\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \talpha_set_memflags_1 (XVECEXP (x, 0, i), in_struct_p, volatile_p,\n-\t\t\t      unchanging_p, alias_set);\n+\t\t\t      unchanging_p);\n       break;\n \n     case INSN:\n       alpha_set_memflags_1 (PATTERN (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p, alias_set);\n+\t\t\t    unchanging_p);\n       break;\n \n     case SET:\n       alpha_set_memflags_1 (SET_DEST (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p, alias_set);\n+\t\t\t    unchanging_p);\n       alpha_set_memflags_1 (SET_SRC (x), in_struct_p, volatile_p,\n-\t\t\t    unchanging_p, alias_set);\n+\t\t\t    unchanging_p);\n       break;\n \n     case MEM:\n       MEM_IN_STRUCT_P (x) = in_struct_p;\n       MEM_VOLATILE_P (x) = volatile_p;\n       RTX_UNCHANGING_P (x) = unchanging_p;\n-      MEM_ALIAS_SET (x) = alias_set;\n+      /* Sadly, we cannot use alias sets because the extra aliasing\n+\t produced by the AND interferes.  Given that two-byte quantities\n+\t are the only thing we would be able to differentiate anyway,\n+\t there does not seem to be any point in convoluting the early\n+\t out of the alias check.  */\n+      /* MEM_ALIAS_SET (x) = alias_set; */\n       break;\n \n     default:\n@@ -972,24 +983,22 @@ alpha_set_memflags (insn, ref)\n      rtx insn;\n      rtx ref;\n {\n-  int in_struct_p, volatile_p, unchanging_p, alias_set;\n+  int in_struct_p, volatile_p, unchanging_p;\n \n   if (GET_CODE (ref) != MEM)\n     return;\n \n   in_struct_p = MEM_IN_STRUCT_P (ref);\n   volatile_p = MEM_VOLATILE_P (ref);\n   unchanging_p = RTX_UNCHANGING_P (ref);\n-  alias_set = MEM_ALIAS_SET (ref);\n \n   /* This is only called from alpha.md, after having had something \n      generated from one of the insn patterns.  So if everything is\n      zero, the pattern is already up-to-date.  */\n-  if (! in_struct_p && ! volatile_p && ! unchanging_p && ! alias_set)\n+  if (! in_struct_p && ! volatile_p && ! unchanging_p)\n     return;\n \n-  alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p,\n-\t\t\talias_set);\n+  alpha_set_memflags_1 (insn, in_struct_p, volatile_p, unchanging_p);\n }\n \f\n /* Try to output insns to set TARGET equal to the constant C if it can be\n@@ -4721,18 +4730,18 @@ alpha_align_insns (insns, max_align, next_group, next_nop, gp_in_use)\n   /* Let shorten branches care for assigning alignments to code labels.  */\n   shorten_branches (insns);\n \n+  align = (FUNCTION_BOUNDARY/BITS_PER_UNIT < max_align\n+\t   ? FUNCTION_BOUNDARY/BITS_PER_UNIT : max_align);\n+\n   /* Account for the initial GP load, which happens before the scheduled\n      prologue we emitted as RTL.  */\n   ofs = prev_in_use = 0;\n   if (alpha_does_function_need_gp())\n     {\n-      ofs = 8;\n+      ofs = 8 & (align - 1);\n       prev_in_use = gp_in_use;\n     }\n \n-  align = (FUNCTION_BOUNDARY/BITS_PER_UNIT < max_align\n-\t   ? FUNCTION_BOUNDARY/BITS_PER_UNIT : max_align);\n-\n   i = insns;\n   if (GET_CODE (i) == NOTE)\n     i = next_nonnote_insn (i);"}]}