{"sha": "cdd2559cec98c587afc243a2850a329861487013", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RkMjU1OWNlYzk4YzU4N2FmYzI0M2EyODUwYTMyOTg2MTQ4NzAxMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-01-17T13:07:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-01-17T13:07:27Z"}, "message": "decl.c (begin_constructor_body, [...]): New fns.\n\n        * decl.c (begin_constructor_body, begin_destructor_body): New fns.\n        (begin_function_body): Call them and keep_next_level.\n        * init.c (emit_base_init): Call keep_next_level.\n        * semantics.c (setup_vtbl_ptr): Lose.\n        * cp-tree.h (struct cp_language_function): Remove vtbls_set_up_p.\n        (vtbls_set_up_p): Lose.\n        * pt.c (tsubst_expr, CTOR_INITIALIZER): Call emit_base_init.\n        * method.c (do_build_copy_constructor): Likewise.\n        (synthesize_method): Call finish_mem_initializers.\n        * parse.y (nodecls): Likewise.\n\nFrom-SVN: r48948", "tree": {"sha": "b2c6bd1d58c0b1dcac0f229dacc4f67ceb858610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2c6bd1d58c0b1dcac0f229dacc4f67ceb858610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdd2559cec98c587afc243a2850a329861487013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd2559cec98c587afc243a2850a329861487013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdd2559cec98c587afc243a2850a329861487013", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd2559cec98c587afc243a2850a329861487013/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad6b1795b1171d94d24abb31dfe515d311531794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6b1795b1171d94d24abb31dfe515d311531794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6b1795b1171d94d24abb31dfe515d311531794"}], "stats": {"total": 202, "additions": 106, "deletions": 96}, "files": [{"sha": "abb6417663cfcf42d85aa43a6878f9b1b1765c78", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -1,4 +1,15 @@\n-2002-01-16  Jason Merrill  <jason@redhat.com>\n+2002-01-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* decl.c (begin_constructor_body, begin_destructor_body): New fns.\n+\t(begin_function_body): Call them and keep_next_level.\n+\t* init.c (emit_base_init): Call keep_next_level.\n+\t* semantics.c (setup_vtbl_ptr): Lose.\n+\t* cp-tree.h (struct cp_language_function): Remove vtbls_set_up_p.\n+\t(vtbls_set_up_p): Lose.\n+\t* pt.c (tsubst_expr, CTOR_INITIALIZER): Call emit_base_init.\n+\t* method.c (do_build_copy_constructor): Likewise.\n+\t(synthesize_method): Call finish_mem_initializers.\n+\t* parse.y (nodecls): Likewise.\n \n \t* error.c (dump_type_suffix): Print the exception specs before\n \trecursing."}, {"sha": "99f7bf71b7432c7b588f704ff7650321f6cb325c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -821,7 +821,6 @@ struct cp_language_function\n   int returns_null;\n   int in_function_try_handler;\n   int x_expanding_p;\n-  int vtbls_set_up_p;\n \n   struct named_label_use_list *x_named_label_uses;\n   struct named_label_list *x_named_labels;\n@@ -881,11 +880,6 @@ struct cp_language_function\n \n #define current_function_returns_null cp_function_chain->returns_null\n \n-/* Nonzero if we have already generated code to initialize virtual\n-   function tables in this function.  */\n-\n-#define vtbls_set_up_p cp_function_chain->vtbls_set_up_p\n-\n /* Non-zero if we should generate RTL for functions that we process.\n    When this is zero, we just accumulate tree structure, without\n    interacting with the back end.  */"}, {"sha": "2a4eaeacb43a3ea7a7dce4ddd7422e508d19de59", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -133,7 +133,9 @@ static void mark_lang_function PARAMS ((struct cp_language_function *));\n static void save_function_data PARAMS ((tree));\n static void check_function_type PARAMS ((tree, tree));\n static void destroy_local_var PARAMS ((tree));\n+static void begin_constructor_body PARAMS ((void));\n static void finish_constructor_body PARAMS ((void));\n+static void begin_destructor_body PARAMS ((void));\n static void finish_destructor_body PARAMS ((void));\n static tree create_array_type_for_decl PARAMS ((tree, tree, tree));\n static tree get_atexit_node PARAMS ((void));\n@@ -13931,6 +13933,18 @@ save_function_data (decl)\n     }\n }\n \n+/* Add a note to mark the beginning of the main body of the constructor.\n+   This is used to set up the data structures for the cleanup regions for\n+   fully-constructed bases and members.  */\n+\n+static void\n+begin_constructor_body ()\n+{\n+  tree ctor_stmt = build_stmt (CTOR_STMT);\n+  CTOR_BEGIN_P (ctor_stmt) = 1;\n+  add_stmt (ctor_stmt);\n+}\n+\n /* Add a note to mark the end of the main body of the constructor.  This is\n    used to end the cleanup regions for fully-constructed bases and\n    members.  */\n@@ -13946,6 +13960,54 @@ finish_constructor_body ()\n   add_stmt (build_stmt (CTOR_STMT));\n }\n \n+/* Do all the processing for the beginning of a destructor; set up the\n+   vtable pointers and cleanups for bases and members.  */\n+\n+static void\n+begin_destructor_body ()\n+{\n+  tree if_stmt;\n+  tree compound_stmt;\n+\n+  /* If the dtor is empty, and we know there is not any possible\n+     way we could use any vtable entries, before they are possibly\n+     set by a base class dtor, we don't have to setup the vtables,\n+     as we know that any base class dtor will set up any vtables\n+     it needs.  We avoid MI, because one base class dtor can do a\n+     virtual dispatch to an overridden function that would need to\n+     have a non-related vtable set up, we cannot avoid setting up\n+     vtables in that case.  We could change this to see if there\n+     is just one vtable.\n+\n+     ??? In the destructor for a class, the vtables are set\n+     appropriately for that class.  There will be no non-related\n+     vtables.  jason 2001-12-11.  */\n+  if_stmt = begin_if_stmt ();\n+\n+  /* If it is not safe to avoid setting up the vtables, then\n+     someone will change the condition to be boolean_true_node.  \n+     (Actually, for now, we do not have code to set the condition\n+     appropriately, so we just assume that we always need to\n+     initialize the vtables.)  */\n+  finish_if_stmt_cond (boolean_true_node, if_stmt);\n+  current_vcalls_possible_p = &IF_COND (if_stmt);\n+\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+\n+  /* Make all virtual function table pointers in non-virtual base\n+     classes point to CURRENT_CLASS_TYPE's virtual function\n+     tables.  */\n+  initialize_vtbl_ptrs (current_class_ptr);\n+\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt ();\n+\n+  /* And insert cleanups for our bases and members so that they\n+     will be properly destroyed if we throw.  */\n+  push_base_cleanups ();\n+}\n+\n /* At the end of every destructor we generate code to delete the object if\n    necessary.  Do that now.  */\n \n@@ -13990,8 +14052,23 @@ finish_destructor_body ()\n tree\n begin_function_body ()\n {\n-  tree stmt = begin_compound_stmt (0);\n+  tree stmt;\n+\n+  stmt = begin_compound_stmt (0);\n   COMPOUND_STMT_BODY_BLOCK (stmt) = 1;\n+\n+  if (processing_template_decl)\n+    /* Do nothing now.  */;\n+  else if (DECL_CONSTRUCTOR_P (current_function_decl))\n+    begin_constructor_body ();\n+  else if (DECL_DESTRUCTOR_P (current_function_decl))\n+    begin_destructor_body ();\n+\n+  /* Always keep the BLOCK node associated with the outermost pair of\n+     curly braces of a function.  These are needed for correct\n+     operation of dwarfout.c.  */\n+  keep_next_level (1);\n+\n   return stmt;\n }\n "}, {"sha": "3aaedafdd932c0b77f1c61523edde1cb71300c96", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -668,6 +668,11 @@ emit_base_init (mem_init_list, base_init_list)\n   int i;\n   int n_baseclasses = BINFO_N_BASETYPES (t_binfo);\n \n+  /* We did a keep_next_level (1) in begin_function_body.  We don't want\n+     that to apply to any blocks generated for member initializers, so\n+     clear it out.  */\n+  keep_next_level (0);\n+  \n   mem_init_list = sort_member_init (t, mem_init_list);\n   sort_base_init (t, base_init_list, &rbase_init_list, &vbase_init_list);\n \n@@ -748,6 +753,9 @@ emit_base_init (mem_init_list, base_init_list)\n       perform_member_init (member, init, from_init_list);\n       mem_init_list = TREE_CHAIN (mem_init_list);\n     }\n+\n+  /* And restore it.  */\n+  keep_next_level (1);\n }\n \n /* Returns the address of the vtable (i.e., the value that should be"}, {"sha": "8cb30a81de7d5a9580f656bd6cc0586150d1a5d0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -624,7 +624,7 @@ do_build_copy_constructor (fndecl)\n \t}\n       member_init_list = nreverse (member_init_list);\n       base_init_list = nreverse (base_init_list);\n-      setup_vtbl_ptr (member_init_list, base_init_list);\n+      emit_base_init (member_init_list, base_init_list);\n     }\n }\n \n@@ -770,15 +770,13 @@ synthesize_method (fndecl)\n       do_build_assign_ref (fndecl);\n       need_body = 0;\n     }\n-  else if (DECL_DESTRUCTOR_P (fndecl))\n-    setup_vtbl_ptr (NULL_TREE, NULL_TREE);\n-  else\n+  else if (DECL_CONSTRUCTOR_P (fndecl))\n     {\n       tree arg_chain = FUNCTION_FIRST_USER_PARMTYPE (fndecl);\n       if (arg_chain != void_list_node)\n \tdo_build_copy_constructor (fndecl);\n       else if (TYPE_NEEDS_CONSTRUCTING (current_class_type))\n-\tsetup_vtbl_ptr (NULL_TREE, NULL_TREE);\n+\tfinish_mem_initializers (NULL_TREE);\n     }\n \n   /* If we haven't yet generated the body of the function, just"}, {"sha": "31fc850d601fbec87709c0c8d32318f4245026cb", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -1765,7 +1765,8 @@ string:\n nodecls:\n \t  /* empty */\n \t\t{\n-\t\t  setup_vtbl_ptr (NULL_TREE, NULL_TREE);\n+\t\t  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+\t\t    finish_mem_initializers (NULL_TREE);\n \t\t}\n \t;\n "}, {"sha": "0f0d93bbdfce8bcded5217c2162619275556140b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -7274,7 +7274,7 @@ tsubst_expr (t, args, complain, in_decl)\n \t  = tsubst_initializer_list (TREE_OPERAND (t, 0), args);\n \tbase_init_list\n \t  = tsubst_initializer_list (TREE_OPERAND (t, 1), args);\n-\tsetup_vtbl_ptr (member_init_list, base_init_list);\n+\temit_base_init (member_init_list, base_init_list);\n \tbreak;\n       }\n "}, {"sha": "eade7004f2fc7bd2cf0ef27c098256a1134f33de", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 81, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd2559cec98c587afc243a2850a329861487013/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cdd2559cec98c587afc243a2850a329861487013", "patch": "@@ -1141,90 +1141,11 @@ finish_mem_initializers (init_list)\n \t}\n     }\n \n-  setup_vtbl_ptr (member_init_list, base_init_list);\n-}\n-\n-/* Do the initialization work necessary at the beginning of a constructor\n-   or destructor.  This means processing member initializers and setting\n-   vtable pointers.\n-\n-   ??? The call to keep_next_level at the end applies to all functions, but\n-   should probably go somewhere else.  */\n-\n-void\n-setup_vtbl_ptr (member_init_list, base_init_list)\n-     tree member_init_list;\n-     tree base_init_list;\n-{\n-  my_friendly_assert (doing_semantic_analysis_p (), 19990919);\n-  my_friendly_assert (!vtbls_set_up_p, 20011220);\n-\n   if (processing_template_decl)\n     add_stmt (build_min_nt (CTOR_INITIALIZER,\n \t\t\t    member_init_list, base_init_list));\n-  else if (DECL_CONSTRUCTOR_P (current_function_decl))\n-    {\n-      tree ctor_stmt;\n-\n-      /* Mark the beginning of the constructor.  */\n-      ctor_stmt = build_stmt (CTOR_STMT);\n-      CTOR_BEGIN_P (ctor_stmt) = 1;\n-      add_stmt (ctor_stmt);\n-\t  \n-      /* And actually initialize the base-classes and members.  */\n-      emit_base_init (member_init_list, base_init_list);\n-    }\n-  else if (DECL_DESTRUCTOR_P (current_function_decl))\n-    {\n-      tree if_stmt;\n-      tree compound_stmt;\n-\n-      /* If the dtor is empty, and we know there is not any possible\n-\t way we could use any vtable entries, before they are possibly\n-\t set by a base class dtor, we don't have to setup the vtables,\n-\t as we know that any base class dtor will set up any vtables\n-\t it needs.  We avoid MI, because one base class dtor can do a\n-\t virtual dispatch to an overridden function that would need to\n-\t have a non-related vtable set up, we cannot avoid setting up\n-\t vtables in that case.  We could change this to see if there\n-\t is just one vtable.\n-\n-         ??? In the destructor for a class, the vtables are set\n-         appropriately for that class.  There will be no non-related\n-         vtables.  jason 2001-12-11.  */\n-      if_stmt = begin_if_stmt ();\n-\n-      /* If it is not safe to avoid setting up the vtables, then\n-\t someone will change the condition to be boolean_true_node.  \n-         (Actually, for now, we do not have code to set the condition\n-\t appropriately, so we just assume that we always need to\n-\t initialize the vtables.)  */\n-      finish_if_stmt_cond (boolean_true_node, if_stmt);\n-      current_vcalls_possible_p = &IF_COND (if_stmt);\n-\n-      compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n-\n-      /* Make all virtual function table pointers in non-virtual base\n-\t classes point to CURRENT_CLASS_TYPE's virtual function\n-\t tables.  */\n-      initialize_vtbl_ptrs (current_class_ptr);\n-\n-      finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n-\n-      /* And insert cleanups for our bases and members so that they\n-         will be properly destroyed if we throw.  */\n-      push_base_cleanups ();\n-    }\n-\n-  /* Always keep the BLOCK node associated with the outermost pair of\n-     curly braces of a function.  These are needed for correct\n-     operation of dwarfout.c.  */\n-  keep_next_level (1);\n-\n-  /* The virtual function tables are set up now.  */\n-  vtbls_set_up_p = 1;\n+  else\n+    emit_base_init (member_init_list, base_init_list);\n }\n \n /* Returns the stack of SCOPE_STMTs for the current function.  */"}]}