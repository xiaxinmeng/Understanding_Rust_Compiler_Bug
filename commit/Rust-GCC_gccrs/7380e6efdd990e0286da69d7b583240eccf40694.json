{"sha": "7380e6efdd990e0286da69d7b583240eccf40694", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM4MGU2ZWZkZDk5MGUwMjg2ZGE2OWQ3YjU4MzI0MGVjY2Y0MDY5NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-08-11T03:04:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-08-11T03:04:35Z"}, "message": "cgraph.h (vector types for symtab_node): Add.\n\n\n\t* cgraph.h (vector types for symtab_node): Add.\n\t* ipa-reference.c (ipa_reference_write_optimization_summary): Update\n\tfor new symtab encoder.\n\t(ipa_reference_read_optimization_summary): Likewise.\n\t* lto-cgraph.c (output_varpool): Remove.\n\t(input_cgraph_opt_summary): Take symtab nodes vector as argument.\n\t(LTO_cgraph_tags): Rename to ...\n\t(LTO_symtab_tags): ... this one; add LTO_symtab_variable.\n\t(lto_cgraph_encoder_new): Rename to ...\n\t(lto_symtab_encoder_new): ... this on.\n\t(lto_cgraph_encoder_encode): Rename to ...\n\t(lto_symtab_encoder_encode): ... this one.\n\t(lto_cgraph_encoder_delete): Rename to ...\n\t(lto_symtab_encoder_delete): ... this one.\n\t(lto_cgraph_encoder_deref): Rename to ...\n\t(lto_symtab_encoder_deref): ... this one.\n\t(lto_cgraph_encoder_encode_body_p): Rename to ...\n\t(lto_symtab_encoder_encode_body_p): ... this one.\n\t(lto_varpool_encoder_new, lto_varpool_encoder_delete,\n\tlto_varpool_encoder_encode, lto_varpool_encoder_lookup,\n\tlto_varpool_encoder_deref): Remove.\n\t(lto_varpool_encoder_encode_initializer_p): Rename to ...\n\t(lto_symtab_encoder_encode_initializer_p): ... this one.\n\t(lto_set_varpool_encoder_encode_initializer): Rename to ...\n\t(lto_set_symtab_encoder_encode_initializer): ... this one.\n\t(lto_output_edge): Update.\n\t(lto_output_node): Update.\n\t(lto_output_varpool_node): Update; stream out LTO_symtab_variable tag.\n\t(lto_output_ref): Drop varpool_encoder; update.\n\t(add_node_to): Update.\n\t(add_references): Update.\n\t(output_outgoing_cgraph_edges): Update.\n\t(output_refs): Update.\t\n\t(compute_ltrans_boundary): Update.\n\t(output_cgraph): Update; output varpools too.\n\t(input_overwrite_node): Update.\n\t(output_varpool): Remove.\n\t(input_node): Update.\n\t(input_ref): Update.\n\t(input_edge): Update.\n\t(input_cgraph_1): Update; input varpool too; unify fixup code.\n\t(input_varpool_1): Remove.\n\t(input_refs): Update.\n\t(input_cgraph): Update.\n\t(output_node_opt_summary): Update.\n\t(input_cgraph_opt_section): Update.\n\t(input_cgraph_opt_summary): Update.\n\t* ipa-pure-const.c (pure_const_write_summary): Update.\n\t(pure_const_read_summary): Update.\n\t* lto-streamer-out.c (lto_write_tree): Update.\n\t(lto_output): Likewise.\n\t(produce_symtab): Update.\n\t(produce_asm_for_decls): Update.\n\t* ipa-inline-analysis.c (inline_read_section): Update.\n\t(inline_write_summary): Update.\n\t* ipa-prop.c (ipa_write_node_info): Update.\n\t(ipa_prop_read_section): Update.\n\t* lto-streamer.h (lto_cgraph_encoder_d): Rename to ...\n\t(lto_symtab_encoder_d): ... this one;  add initializer.\n\t(lto_cgraph_encoder_t): Rename to ...\n\t(lto_symtab_encoder_t): ... this one.\n\t(lto_cgraph_encoder_size): Rename to ...\n\t(lto_symtab_encoder_size): ... this one.\n\t(lto_varpool_encoder_d): ... remove.\n\t(lto_varpool_encoder_t): Remove.\n\t(lto_out_decl_state): Remove cgraph_node_encoder, varpool_node_encoder\n\tadd symtab_node_encoder.\n\t(lto_file_decl_data): Likewise.\n\t(lto_cgraph_encoder_deref, lto_cgraph_encoder_lookup,\n\tlto_cgraph_encoder_new, lto_cgraph_encoder_encode, lto_cgraph_encoder_delete,\n\tlto_cgraph_encoder_encode_body_p, lto_varpool_encoder_encode_body_p,\n\tlto_varpool_encoder_deref, lto_varpool_encoder_lookup, lto_varpool_encoder_new,\n\tlto_varpool_encoder_encode, lto_varpool_encoder_delete,\n\tlto_varpool_encoder_encode_initializer_p): Remove.\n\t(lto_symtab_encoder_deref, lto_symtab_encoder_lookup,\n\tlto_symtab_encoder_t, lto_symtab_encoder_encode, lto_symtab_encoder_delete,\n\tlto_symtab_encoder_encode_body_p, lto_symtab_encoder_encode_initializer_p):\n\tNew.\n\nFrom-SVN: r190309", "tree": {"sha": "9ecc46e97e1f006538b5fc2f9be799708d6b205c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ecc46e97e1f006538b5fc2f9be799708d6b205c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7380e6efdd990e0286da69d7b583240eccf40694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7380e6efdd990e0286da69d7b583240eccf40694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7380e6efdd990e0286da69d7b583240eccf40694", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7380e6efdd990e0286da69d7b583240eccf40694/comments", "author": null, "committer": null, "parents": [{"sha": "46b496e99705471904aae92d26d77158a62365a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b496e99705471904aae92d26d77158a62365a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b496e99705471904aae92d26d77158a62365a7"}], "stats": {"total": 794, "additions": 356, "deletions": 438}, "files": [{"sha": "4717f31d994f6da8d87f277464eb076c228eb675", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -1,3 +1,84 @@\n+2012-08-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (vector types for symtab_node): Add.\n+\t* ipa-reference.c (ipa_reference_write_optimization_summary): Update\n+\tfor new symtab encoder.\n+\t(ipa_reference_read_optimization_summary): Likewise.\n+\t* lto-cgraph.c (output_varpool): Remove.\n+\t(input_cgraph_opt_summary): Take symtab nodes vector as argument.\n+\t(LTO_cgraph_tags): Rename to ...\n+\t(LTO_symtab_tags): ... this one; add LTO_symtab_variable.\n+\t(lto_cgraph_encoder_new): Rename to ...\n+\t(lto_symtab_encoder_new): ... this on.\n+\t(lto_cgraph_encoder_encode): Rename to ...\n+\t(lto_symtab_encoder_encode): ... this one.\n+\t(lto_cgraph_encoder_delete): Rename to ...\n+\t(lto_symtab_encoder_delete): ... this one.\n+\t(lto_cgraph_encoder_deref): Rename to ...\n+\t(lto_symtab_encoder_deref): ... this one.\n+\t(lto_cgraph_encoder_encode_body_p): Rename to ...\n+\t(lto_symtab_encoder_encode_body_p): ... this one.\n+\t(lto_varpool_encoder_new, lto_varpool_encoder_delete,\n+\tlto_varpool_encoder_encode, lto_varpool_encoder_lookup,\n+\tlto_varpool_encoder_deref): Remove.\n+\t(lto_varpool_encoder_encode_initializer_p): Rename to ...\n+\t(lto_symtab_encoder_encode_initializer_p): ... this one.\n+\t(lto_set_varpool_encoder_encode_initializer): Rename to ...\n+\t(lto_set_symtab_encoder_encode_initializer): ... this one.\n+\t(lto_output_edge): Update.\n+\t(lto_output_node): Update.\n+\t(lto_output_varpool_node): Update; stream out LTO_symtab_variable tag.\n+\t(lto_output_ref): Drop varpool_encoder; update.\n+\t(add_node_to): Update.\n+\t(add_references): Update.\n+\t(output_outgoing_cgraph_edges): Update.\n+\t(output_refs): Update.\t\n+\t(compute_ltrans_boundary): Update.\n+\t(output_cgraph): Update; output varpools too.\n+\t(input_overwrite_node): Update.\n+\t(output_varpool): Remove.\n+\t(input_node): Update.\n+\t(input_ref): Update.\n+\t(input_edge): Update.\n+\t(input_cgraph_1): Update; input varpool too; unify fixup code.\n+\t(input_varpool_1): Remove.\n+\t(input_refs): Update.\n+\t(input_cgraph): Update.\n+\t(output_node_opt_summary): Update.\n+\t(input_cgraph_opt_section): Update.\n+\t(input_cgraph_opt_summary): Update.\n+\t* ipa-pure-const.c (pure_const_write_summary): Update.\n+\t(pure_const_read_summary): Update.\n+\t* lto-streamer-out.c (lto_write_tree): Update.\n+\t(lto_output): Likewise.\n+\t(produce_symtab): Update.\n+\t(produce_asm_for_decls): Update.\n+\t* ipa-inline-analysis.c (inline_read_section): Update.\n+\t(inline_write_summary): Update.\n+\t* ipa-prop.c (ipa_write_node_info): Update.\n+\t(ipa_prop_read_section): Update.\n+\t* lto-streamer.h (lto_cgraph_encoder_d): Rename to ...\n+\t(lto_symtab_encoder_d): ... this one;  add initializer.\n+\t(lto_cgraph_encoder_t): Rename to ...\n+\t(lto_symtab_encoder_t): ... this one.\n+\t(lto_cgraph_encoder_size): Rename to ...\n+\t(lto_symtab_encoder_size): ... this one.\n+\t(lto_varpool_encoder_d): ... remove.\n+\t(lto_varpool_encoder_t): Remove.\n+\t(lto_out_decl_state): Remove cgraph_node_encoder, varpool_node_encoder\n+\tadd symtab_node_encoder.\n+\t(lto_file_decl_data): Likewise.\n+\t(lto_cgraph_encoder_deref, lto_cgraph_encoder_lookup,\n+\tlto_cgraph_encoder_new, lto_cgraph_encoder_encode, lto_cgraph_encoder_delete,\n+\tlto_cgraph_encoder_encode_body_p, lto_varpool_encoder_encode_body_p,\n+\tlto_varpool_encoder_deref, lto_varpool_encoder_lookup, lto_varpool_encoder_new,\n+\tlto_varpool_encoder_encode, lto_varpool_encoder_delete,\n+\tlto_varpool_encoder_encode_initializer_p): Remove.\n+\t(lto_symtab_encoder_deref, lto_symtab_encoder_lookup,\n+\tlto_symtab_encoder_t, lto_symtab_encoder_encode, lto_symtab_encoder_delete,\n+\tlto_symtab_encoder_encode_body_p, lto_symtab_encoder_encode_initializer_p):\n+\tNew.\n+\n 2012-08-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (isa): Add fma and fma4."}, {"sha": "0d2ad41c43afdbeb12d5c971307069bf20220ba9", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -273,6 +273,10 @@ struct GTY(()) cgraph_node {\n   unsigned tm_clone : 1;\n };\n \n+DEF_VEC_P(symtab_node);\n+DEF_VEC_ALLOC_P(symtab_node,heap);\n+DEF_VEC_ALLOC_P(symtab_node,gc);\n+\n typedef struct cgraph_node *cgraph_node_ptr;\n \n DEF_VEC_P(cgraph_node_ptr);"}, {"sha": "474f2a9af195b41410c0ff9ce67756a21d378ac3", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -3053,13 +3053,13 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       unsigned int index;\n       struct cgraph_node *node;\n       struct inline_summary *info;\n-      lto_cgraph_encoder_t encoder;\n+      lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n \n       index = streamer_read_uhwi (&ib);\n-      encoder = file_data->cgraph_node_encoder;\n-      node = lto_cgraph_encoder_deref (encoder, index);\n+      encoder = file_data->symtab_node_encoder;\n+      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n       info = inline_summary (node);\n \n       info->estimated_stack_size\n@@ -3186,20 +3186,22 @@ inline_write_summary (cgraph_node_set set,\n \t\t      varpool_node_set vset ATTRIBUTE_UNUSED)\n {\n   struct cgraph_node *node;\n+  symtab_node snode;\n   struct output_block *ob = create_output_block (LTO_section_inline_summary);\n-  lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   unsigned int count = 0;\n   int i;\n \n-  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n-    if (lto_cgraph_encoder_deref (encoder, i)->analyzed)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n+    if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n+\t&& cgraph (snode)->analyzed)\n       count++;\n   streamer_write_uhwi (ob, count);\n \n-  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lto_cgraph_encoder_deref (encoder, i);\n-      if (node->analyzed)\n+      if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n+\t  && (node = cgraph (snode))->analyzed)\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n \t  struct bitpack_d bp;\n@@ -3208,7 +3210,7 @@ inline_write_summary (cgraph_node_set set,\n \t  size_time_entry *e;\n \t  struct condition *c;\n \n-\t  streamer_write_uhwi (ob, lto_cgraph_encoder_encode (encoder, node));\n+\t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, (symtab_node)node));\n \t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n \t  streamer_write_hwi (ob, info->self_size);\n \t  streamer_write_hwi (ob, info->self_time);"}, {"sha": "6c5f24131d002adc13db345ef2cf3bb57713b25a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -3303,14 +3303,14 @@ static void\n ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n {\n   int node_ref;\n-  lto_cgraph_encoder_t encoder;\n+  lto_symtab_encoder_t encoder;\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int j;\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n \n-  encoder = ob->decl_state->cgraph_node_encoder;\n-  node_ref = lto_cgraph_encoder_encode (encoder, node);\n+  encoder = ob->decl_state->symtab_node_encoder;\n+  node_ref = lto_symtab_encoder_encode (encoder, (symtab_node) node);\n   streamer_write_uhwi (ob, node_ref);\n \n   bp = bitpack_create (ob->main_stream);\n@@ -3454,11 +3454,11 @@ ipa_prop_read_section (struct lto_file_decl_data *file_data, const char *data,\n     {\n       unsigned int index;\n       struct cgraph_node *node;\n-      lto_cgraph_encoder_t encoder;\n+      lto_symtab_encoder_t encoder;\n \n       index = streamer_read_uhwi (&ib_main);\n-      encoder = file_data->cgraph_node_encoder;\n-      node = lto_cgraph_encoder_deref (encoder, index);\n+      encoder = file_data->symtab_node_encoder;\n+      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n       gcc_assert (node->analyzed);\n       ipa_read_node_info (&ib_main, node, data_in);\n     }"}, {"sha": "db3f9a84b915e0171178a2fa7a8346f7bdd03135", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -962,12 +962,12 @@ pure_const_write_summary (cgraph_node_set set,\n \t  struct bitpack_d bp;\n \t  funct_state fs;\n \t  int node_ref;\n-\t  lto_cgraph_encoder_t encoder;\n+\t  lto_symtab_encoder_t encoder;\n \n \t  fs = get_function_state (node);\n \n-\t  encoder = ob->decl_state->cgraph_node_encoder;\n-\t  node_ref = lto_cgraph_encoder_encode (encoder, node);\n+\t  encoder = ob->decl_state->symtab_node_encoder;\n+\t  node_ref = lto_symtab_encoder_encode (encoder, (symtab_node)node);\n \t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t  /* Note that flags will need to be read in the opposite\n@@ -1015,12 +1015,12 @@ pure_const_read_summary (void)\n \t      struct cgraph_node *node;\n \t      struct bitpack_d bp;\n \t      funct_state fs;\n-\t      lto_cgraph_encoder_t encoder;\n+\t      lto_symtab_encoder_t encoder;\n \n \t      fs = XCNEW (struct funct_state_d);\n \t      index = streamer_read_uhwi (ib);\n-\t      encoder = file_data->cgraph_node_encoder;\n-\t      node = lto_cgraph_encoder_deref (encoder, index);\n+\t      encoder = file_data->symtab_node_encoder;\n+\t      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n \t      set_function_state (node, fs);\n \n \t      /* Note that the flags must be read in the opposite"}, {"sha": "371148dbc30b44c8919d5cad2c9d65c0a0dd2604", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -1029,21 +1029,25 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \t\t\t\t\t  varpool_node_set vset)\n {\n   struct cgraph_node *node;\n+  symtab_node snode;\n   struct lto_simple_output_block *ob\n     = lto_create_simple_output_block (LTO_section_ipa_reference);\n   unsigned int count = 0;\n   int ltrans_statics_bitcount = 0;\n-  lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n-  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   bitmap ltrans_statics = BITMAP_ALLOC (NULL);\n   int i;\n \n   reference_vars_to_consider = splay_tree_new (splay_tree_compare_ints, 0, 0);\n \n   /* See what variables we are interested in.  */\n-  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      struct varpool_node *vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n+      struct varpool_node *vnode;\n+      snode = lto_symtab_encoder_deref (encoder, i);\n+      if (!symtab_variable_p (snode))\n+\tcontinue;\n+      vnode = varpool (snode);\n       if (bitmap_bit_p (all_module_statics, DECL_UID (vnode->symbol.decl))\n \t  && referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset))\n \t{\n@@ -1057,8 +1061,9 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \n \n   if (ltrans_statics_bitcount)\n-    for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n-      if (write_node_summary_p (lto_cgraph_encoder_deref (encoder, i),\n+    for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n+      if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n+\t  && write_node_summary_p (cgraph (snode),\n \t\t\t\tset, vset, ltrans_statics))\n \t  count++;\n \n@@ -1069,16 +1074,19 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n \n   /* Process all of the functions.  */\n   if (ltrans_statics_bitcount)\n-    for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+    for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       {\n-\tnode = lto_cgraph_encoder_deref (encoder, i);\n+\tsnode = lto_symtab_encoder_deref (encoder, i);\n+\tif (!symtab_function_p (snode))\n+\t  continue;\n+\tnode = cgraph (snode);\n \tif (write_node_summary_p (node, set, vset, ltrans_statics))\n \t  {\n \t    ipa_reference_optimization_summary_t info;\n \t    int node_ref;\n \n \t    info = get_reference_optimization_summary (node);\n-\t    node_ref = lto_cgraph_encoder_encode (encoder, node);\n+\t    node_ref = lto_symtab_encoder_encode (encoder, (symtab_node) node);\n \t    streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t    stream_out_bitmap (ob, info->statics_not_read, ltrans_statics,\n@@ -1144,11 +1152,11 @@ ipa_reference_read_optimization_summary (void)\n \t      struct cgraph_node *node;\n \t      ipa_reference_optimization_summary_t info;\n \t      int v_count;\n-\t      lto_cgraph_encoder_t encoder;\n+\t      lto_symtab_encoder_t encoder;\n \n \t      index = streamer_read_uhwi (ib);\n-\t      encoder = file_data->cgraph_node_encoder;\n-\t      node = lto_cgraph_encoder_deref (encoder, index);\n+\t      encoder = file_data->symtab_node_encoder;\n+\t      node = cgraph (lto_symtab_encoder_deref (encoder, index));\n \t      info = XCNEW (struct ipa_reference_optimization_summary_d);\n \t      set_reference_optimization_summary (node, info);\n \t      info->statics_not_read = BITMAP_ALLOC (&optimization_summary_obstack);"}, {"sha": "9ba21e089a56955b0eb034941ba8f33be16482a1", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 183, "deletions": 335, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -46,9 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"gcov-io.h\"\n \n-static void output_varpool (cgraph_node_set, varpool_node_set);\n static void output_cgraph_opt_summary (cgraph_node_set set);\n-static void input_cgraph_opt_summary (VEC (cgraph_node_ptr, heap) * nodes);\n+static void input_cgraph_opt_summary (VEC (symtab_node, heap) * nodes);\n \n /* Number of LDPR values known to GCC.  */\n #define LDPR_NUM_KNOWN (LDPR_PREVAILING_DEF_IRONLY_EXP + 1)\n@@ -58,63 +57,66 @@ static int order_base;\n \n /* Cgraph streaming is organized as set of record whose type\n    is indicated by a tag.  */\n-enum LTO_cgraph_tags\n+enum LTO_symtab_tags\n {\n   /* Must leave 0 for the stopper.  */\n \n   /* Cgraph node without body available.  */\n-  LTO_cgraph_unavail_node = 1,\n+  LTO_symtab_unavail_node = 1,\n   /* Cgraph node with function body.  */\n-  LTO_cgraph_analyzed_node,\n+  LTO_symtab_analyzed_node,\n   /* Cgraph edges.  */\n-  LTO_cgraph_edge,\n-  LTO_cgraph_indirect_edge,\n-  LTO_cgraph_last_tag\n+  LTO_symtab_edge,\n+  LTO_symtab_indirect_edge,\n+  LTO_symtab_variable,\n+  LTO_symtab_last_tag\n };\n \n-/* Create a new cgraph encoder.  */\n+/* Create a new symtab encoder.  */\n \n-lto_cgraph_encoder_t\n-lto_cgraph_encoder_new (void)\n+lto_symtab_encoder_t\n+lto_symtab_encoder_new (void)\n {\n-  lto_cgraph_encoder_t encoder = XCNEW (struct lto_cgraph_encoder_d);\n+  lto_symtab_encoder_t encoder = XCNEW (struct lto_symtab_encoder_d);\n   encoder->map = pointer_map_create ();\n   encoder->nodes = NULL;\n   encoder->body = pointer_set_create ();\n+  encoder->initializer = pointer_set_create ();\n   return encoder;\n }\n \n \n /* Delete ENCODER and its components.  */\n \n void\n-lto_cgraph_encoder_delete (lto_cgraph_encoder_t encoder)\n+lto_symtab_encoder_delete (lto_symtab_encoder_t encoder)\n {\n-   VEC_free (cgraph_node_ptr, heap, encoder->nodes);\n+   VEC_free (symtab_node, heap, encoder->nodes);\n    pointer_map_destroy (encoder->map);\n    pointer_set_destroy (encoder->body);\n+   pointer_set_destroy (encoder->initializer);\n    free (encoder);\n }\n \n \n-/* Return the existing reference number of NODE in the cgraph encoder in\n+/* Return the existing reference number of NODE in the symtab encoder in\n    output block OB.  Assign a new reference if this is the first time\n    NODE is encoded.  */\n \n int\n-lto_cgraph_encoder_encode (lto_cgraph_encoder_t encoder,\n-\t\t\t   struct cgraph_node *node)\n+lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n+\t\t\t   symtab_node node)\n {\n   int ref;\n   void **slot;\n \n   slot = pointer_map_contains (encoder->map, node);\n   if (!slot)\n     {\n-      ref = VEC_length (cgraph_node_ptr, encoder->nodes);\n+      ref = VEC_length (symtab_node, encoder->nodes);\n       slot = pointer_map_insert (encoder->map, node);\n       *slot = (void *) (intptr_t) ref;\n-      VEC_safe_push (cgraph_node_ptr, heap, encoder->nodes, node);\n+      VEC_safe_push (symtab_node, heap, encoder->nodes, node);\n     }\n   else\n     ref = (int) (intptr_t) *slot;\n@@ -128,8 +130,8 @@ lto_cgraph_encoder_encode (lto_cgraph_encoder_t encoder,\n    or LCC_NOT_FOUND if it is not there.  */\n \n int\n-lto_cgraph_encoder_lookup (lto_cgraph_encoder_t encoder,\n-\t\t\t   struct cgraph_node *node)\n+lto_symtab_encoder_lookup (lto_symtab_encoder_t encoder,\n+\t\t\t   symtab_node node)\n {\n   void **slot = pointer_map_contains (encoder->map, node);\n   return (slot ? (int) (intptr_t) *slot : LCC_NOT_FOUND);\n@@ -138,20 +140,20 @@ lto_cgraph_encoder_lookup (lto_cgraph_encoder_t encoder,\n \n /* Return the cgraph node corresponding to REF using ENCODER.  */\n \n-struct cgraph_node *\n-lto_cgraph_encoder_deref (lto_cgraph_encoder_t encoder, int ref)\n+symtab_node\n+lto_symtab_encoder_deref (lto_symtab_encoder_t encoder, int ref)\n {\n   if (ref == LCC_NOT_FOUND)\n     return NULL;\n \n-  return VEC_index (cgraph_node_ptr, encoder->nodes, ref);\n+  return VEC_index (symtab_node, encoder->nodes, ref);\n }\n \n \n /* Return TRUE if we should encode initializer of NODE (if any).  */\n \n bool\n-lto_cgraph_encoder_encode_body_p (lto_cgraph_encoder_t encoder,\n+lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t encoder,\n \t\t\t\t  struct cgraph_node *node)\n {\n   return pointer_set_contains (encoder->body, node);\n@@ -160,100 +162,26 @@ lto_cgraph_encoder_encode_body_p (lto_cgraph_encoder_t encoder,\n /* Return TRUE if we should encode body of NODE (if any).  */\n \n static void\n-lto_set_cgraph_encoder_encode_body (lto_cgraph_encoder_t encoder,\n+lto_set_symtab_encoder_encode_body (lto_symtab_encoder_t encoder,\n \t\t\t\t    struct cgraph_node *node)\n {\n   pointer_set_insert (encoder->body, node);\n }\n \n-/* Create a new varpool encoder.  */\n-\n-lto_varpool_encoder_t\n-lto_varpool_encoder_new (void)\n-{\n-  lto_varpool_encoder_t encoder = XCNEW (struct lto_varpool_encoder_d);\n-  encoder->map = pointer_map_create ();\n-  encoder->initializer = pointer_set_create ();\n-  encoder->nodes = NULL;\n-  return encoder;\n-}\n-\n-\n-/* Delete ENCODER and its components.  */\n-\n-void\n-lto_varpool_encoder_delete (lto_varpool_encoder_t encoder)\n-{\n-   VEC_free (varpool_node_ptr, heap, encoder->nodes);\n-   pointer_map_destroy (encoder->map);\n-   pointer_set_destroy (encoder->initializer);\n-   free (encoder);\n-}\n-\n-\n-/* Return the existing reference number of NODE in the varpool encoder in\n-   output block OB.  Assign a new reference if this is the first time\n-   NODE is encoded.  */\n-\n-int\n-lto_varpool_encoder_encode (lto_varpool_encoder_t encoder,\n-\t\t\t   struct varpool_node *node)\n-{\n-  int ref;\n-  void **slot;\n-\n-  slot = pointer_map_contains (encoder->map, node);\n-  if (!slot)\n-    {\n-      ref = VEC_length (varpool_node_ptr, encoder->nodes);\n-      slot = pointer_map_insert (encoder->map, node);\n-      *slot = (void *) (intptr_t) ref;\n-      VEC_safe_push (varpool_node_ptr, heap, encoder->nodes, node);\n-    }\n-  else\n-    ref = (int) (intptr_t) *slot;\n-\n-  return ref;\n-}\n-\n-/* Look up NODE in encoder.  Return NODE's reference if it has been encoded\n-   or LCC_NOT_FOUND if it is not there.  */\n-\n-int\n-lto_varpool_encoder_lookup (lto_varpool_encoder_t encoder,\n-\t\t\t   struct varpool_node *node)\n-{\n-  void **slot = pointer_map_contains (encoder->map, node);\n-  return (slot ? (int) (intptr_t) *slot : LCC_NOT_FOUND);\n-}\n-\n-\n-/* Return the varpool node corresponding to REF using ENCODER.  */\n-\n-struct varpool_node *\n-lto_varpool_encoder_deref (lto_varpool_encoder_t encoder, int ref)\n-{\n-  if (ref == LCC_NOT_FOUND)\n-    return NULL;\n-\n-  return VEC_index (varpool_node_ptr, encoder->nodes, ref);\n-}\n-\n-\n /* Return TRUE if we should encode initializer of NODE (if any).  */\n \n bool\n-lto_varpool_encoder_encode_initializer_p (lto_varpool_encoder_t encoder,\n-\t\t\t\t\t  struct varpool_node *node)\n+lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t encoder,\n+\t\t\t\t\t struct varpool_node *node)\n {\n   return pointer_set_contains (encoder->initializer, node);\n }\n \n /* Return TRUE if we should encode initializer of NODE (if any).  */\n \n static void\n-lto_set_varpool_encoder_encode_initializer (lto_varpool_encoder_t encoder,\n-\t\t\t\t\t    struct varpool_node *node)\n+lto_set_symtab_encoder_encode_initializer (lto_symtab_encoder_t encoder,\n+\t\t\t\t\t   struct varpool_node *node)\n {\n   pointer_set_insert (encoder->initializer, node);\n }\n@@ -262,26 +190,26 @@ lto_set_varpool_encoder_encode_initializer (lto_varpool_encoder_t encoder,\n \n static void\n lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n-\t\t lto_cgraph_encoder_t encoder)\n+\t\t lto_symtab_encoder_t encoder)\n {\n   unsigned int uid;\n   intptr_t ref;\n   struct bitpack_d bp;\n \n   if (edge->indirect_unknown_callee)\n-    streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n-\t\t\t LTO_cgraph_indirect_edge);\n+    streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n+\t\t\t LTO_symtab_indirect_edge);\n   else\n-    streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n-\t\t\t LTO_cgraph_edge);\n+    streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n+\t\t\t LTO_symtab_edge);\n \n-  ref = lto_cgraph_encoder_lookup (encoder, edge->caller);\n+  ref = lto_symtab_encoder_lookup (encoder, (symtab_node)edge->caller);\n   gcc_assert (ref != LCC_NOT_FOUND);\n   streamer_write_hwi_stream (ob->main_stream, ref);\n \n   if (!edge->indirect_unknown_callee)\n     {\n-      ref = lto_cgraph_encoder_lookup (encoder, edge->callee);\n+      ref = lto_symtab_encoder_lookup (encoder, (symtab_node)edge->callee);\n       gcc_assert (ref != LCC_NOT_FOUND);\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n@@ -408,7 +336,7 @@ reachable_from_this_partition_p (struct cgraph_node *node, cgraph_node_set set)\n \n static void\n lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n-\t\t lto_cgraph_encoder_t encoder, cgraph_node_set set,\n+\t\t lto_symtab_encoder_t encoder, cgraph_node_set set,\n \t\t varpool_node_set vset)\n {\n   unsigned int tag;\n@@ -421,11 +349,11 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   boundary_p = !cgraph_node_in_set_p (node, set);\n \n   if (node->analyzed && !boundary_p)\n-    tag = LTO_cgraph_analyzed_node;\n+    tag = LTO_symtab_analyzed_node;\n   else\n-    tag = LTO_cgraph_unavail_node;\n+    tag = LTO_symtab_unavail_node;\n \n-  streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n+  streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n \t\t       tag);\n   streamer_write_hwi_stream (ob->main_stream, node->symbol.order);\n \n@@ -454,13 +382,13 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   clone_of = node->clone_of;\n   while (clone_of\n-\t && (ref = lto_cgraph_encoder_lookup (encoder, clone_of)) == LCC_NOT_FOUND)\n+\t && (ref = lto_symtab_encoder_lookup (encoder, (symtab_node)clone_of)) == LCC_NOT_FOUND)\n     if (clone_of->prev_sibling_clone)\n       clone_of = clone_of->prev_sibling_clone;\n     else\n       clone_of = clone_of->clone_of;\n \n-  if (LTO_cgraph_analyzed_node)\n+  if (LTO_symtab_analyzed_node)\n     gcc_assert (clone_of || !node->clone_of);\n   if (!clone_of)\n     streamer_write_hwi_stream (ob->main_stream, LCC_NOT_FOUND);\n@@ -472,11 +400,11 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   streamer_write_hwi_stream (ob->main_stream, node->count);\n   streamer_write_hwi_stream (ob->main_stream, node->count_materialization_scale);\n \n-  if (tag == LTO_cgraph_analyzed_node)\n+  if (tag == LTO_symtab_analyzed_node)\n     {\n       if (node->global.inlined_to)\n \t{\n-\t  ref = lto_cgraph_encoder_lookup (encoder, node->global.inlined_to);\n+\t  ref = lto_symtab_encoder_lookup (encoder, (symtab_node)node->global.inlined_to);\n \t  gcc_assert (ref != LCC_NOT_FOUND);\n \t}\n       else\n@@ -487,8 +415,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   if (node->symbol.same_comdat_group && !boundary_p)\n     {\n-      ref = lto_cgraph_encoder_lookup (encoder,\n-\t\t\t\t       cgraph (node->symbol.same_comdat_group));\n+      ref = lto_symtab_encoder_lookup (encoder,\n+\t\t\t\t       node->symbol.same_comdat_group);\n       gcc_assert (ref != LCC_NOT_FOUND);\n     }\n   else\n@@ -505,7 +433,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->symbol.force_output, 1);\n   bp_pack_value (&bp, node->symbol.address_taken, 1);\n   bp_pack_value (&bp, node->abstract_and_needed, 1);\n-  bp_pack_value (&bp, tag == LTO_cgraph_analyzed_node\n+  bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n \t\t && !DECL_EXTERNAL (node->symbol.decl)\n \t\t && !DECL_COMDAT (node->symbol.decl)\n \t\t && (reachable_from_other_partition_p (node, set)\n@@ -554,13 +482,15 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n-\t\t\t lto_varpool_encoder_t varpool_encoder,\n+\t\t\t lto_symtab_encoder_t encoder,\n \t\t         cgraph_node_set set, varpool_node_set vset)\n {\n   bool boundary_p = !varpool_node_in_set_p (node, vset) && node->analyzed;\n   struct bitpack_d bp;\n   int ref;\n \n+  streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n+\t\t       LTO_symtab_variable);\n   streamer_write_hwi_stream (ob->main_stream, node->symbol.order);\n   lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->symbol.decl);\n   bp = bitpack_create (ob->main_stream);\n@@ -593,8 +523,8 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n     lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->alias_of);\n   if (node->symbol.same_comdat_group && !boundary_p)\n     {\n-      ref = lto_varpool_encoder_lookup (varpool_encoder,\n-\t\t\t\t\tvarpool (node->symbol.same_comdat_group));\n+      ref = lto_symtab_encoder_lookup (encoder,\n+\t\t\t\t       node->symbol.same_comdat_group);\n       gcc_assert (ref != LCC_NOT_FOUND);\n     }\n   else\n@@ -609,27 +539,17 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n \n static void\n lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n-\t\tlto_cgraph_encoder_t encoder,\n-\t\tlto_varpool_encoder_t varpool_encoder)\n+\t\tlto_symtab_encoder_t encoder)\n {\n   struct bitpack_d bp;\n+  int nref;\n+\n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, symtab_function_p (ref->referred), 1);\n   bp_pack_value (&bp, ref->use, 2);\n   streamer_write_bitpack (&bp);\n-  if (symtab_function_p (ref->referred))\n-    {\n-      int nref = lto_cgraph_encoder_lookup (encoder, ipa_ref_node (ref));\n-      gcc_assert (nref != LCC_NOT_FOUND);\n-      streamer_write_hwi_stream (ob->main_stream, nref);\n-    }\n-  else\n-    {\n-      int nref = lto_varpool_encoder_lookup (varpool_encoder,\n-\t\t\t\t             ipa_ref_varpool_node (ref));\n-      gcc_assert (nref != LCC_NOT_FOUND);\n-      streamer_write_hwi_stream (ob->main_stream, nref);\n-    }\n+  nref = lto_symtab_encoder_lookup (encoder, ref->referred);\n+  gcc_assert (nref != LCC_NOT_FOUND);\n+  streamer_write_hwi_stream (ob->main_stream, nref);\n }\n \n /* Stream out profile_summary to OB.  */\n@@ -654,21 +574,20 @@ output_profile_summary (struct lto_simple_output_block *ob)\n    Do it in a way so clones appear first.  */\n \n static void\n-add_node_to (lto_cgraph_encoder_t encoder, struct cgraph_node *node,\n+add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n \t     bool include_body)\n {\n   if (node->clone_of)\n     add_node_to (encoder, node->clone_of, include_body);\n   else if (include_body)\n-    lto_set_cgraph_encoder_encode_body (encoder, node);\n-  lto_cgraph_encoder_encode (encoder, node);\n+    lto_set_symtab_encoder_encode_body (encoder, node);\n+  lto_symtab_encoder_encode (encoder, (symtab_node)node);\n }\n \n /* Add all references in LIST to encoders.  */\n \n static void\n-add_references (lto_cgraph_encoder_t encoder,\n-\t\tlto_varpool_encoder_t varpool_encoder,\n+add_references (lto_symtab_encoder_t encoder,\n \t\tstruct ipa_ref_list *list)\n {\n   int i;\n@@ -679,7 +598,7 @@ add_references (lto_cgraph_encoder_t encoder,\n     else\n       {\n \tstruct varpool_node *vnode = ipa_ref_varpool_node (ref);\n-        lto_varpool_encoder_encode (varpool_encoder, vnode);\n+        lto_symtab_encoder_encode (encoder, (symtab_node)vnode);\n       }\n }\n \n@@ -689,7 +608,7 @@ add_references (lto_cgraph_encoder_t encoder,\n static void\n output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n \t\t\t      struct lto_simple_output_block *ob,\n-\t\t\t      lto_cgraph_encoder_t encoder)\n+\t\t\t      lto_symtab_encoder_t encoder)\n {\n   if (!edge)\n     return;\n@@ -706,8 +625,7 @@ output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n \n static void\n output_refs (cgraph_node_set set, varpool_node_set vset,\n-\t     lto_cgraph_encoder_t encoder,\n-\t     lto_varpool_encoder_t varpool_encoder)\n+\t     lto_symtab_encoder_t encoder)\n {\n   cgraph_node_set_iterator csi;\n   varpool_node_set_iterator vsi;\n@@ -727,10 +645,11 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n \t{\n \t  streamer_write_uhwi_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n-\t\t\t\t     lto_cgraph_encoder_lookup (encoder, node));\n+\t\t\t\t     lto_symtab_encoder_lookup (encoder, \n+\t\t\t\t\t\t\t\t(symtab_node)node));\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n \t\t\t\t\t\t      i, ref); i++)\n-\t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n+\t    lto_output_ref (ob, ref, encoder);\n \t}\n     }\n \n@@ -745,11 +664,11 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n \t{\n \t  streamer_write_uhwi_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n-\t\t\t\t     lto_varpool_encoder_lookup (varpool_encoder,\n-\t\t\t\t\t\t\t\t node));\n+\t\t\t\t     lto_symtab_encoder_lookup (encoder,\n+\t\t\t\t\t\t\t\t(symtab_node)node));\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n \t\t\t\t\t\t      i, ref); i++)\n-\t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n+\t    lto_output_ref (ob, ref, encoder);\n \t}\n     }\n \n@@ -769,43 +688,45 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n   varpool_node_set_iterator vsi;\n   struct cgraph_edge *edge;\n   int i;\n-  lto_cgraph_encoder_t encoder;\n-  lto_varpool_encoder_t varpool_encoder;\n+  lto_symtab_encoder_t encoder;\n \n-  encoder = state->cgraph_node_encoder = lto_cgraph_encoder_new ();\n-  varpool_encoder = state->varpool_node_encoder = lto_varpool_encoder_new ();\n+  encoder = state->symtab_node_encoder = lto_symtab_encoder_new ();\n \n   /* Go over all the nodes in SET and assign references.  */\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n       add_node_to (encoder, node, true);\n-      add_references (encoder, varpool_encoder, &node->symbol.ref_list);\n+      add_references (encoder, &node->symbol.ref_list);\n     }\n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n     {\n       struct varpool_node *vnode = vsi_node (vsi);\n       gcc_assert (!vnode->alias || vnode->alias_of);\n-      lto_varpool_encoder_encode (varpool_encoder, vnode);\n-      lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n-      add_references (encoder, varpool_encoder, &vnode->symbol.ref_list);\n+      lto_symtab_encoder_encode (encoder, (symtab_node)vnode);\n+      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n+      add_references (encoder, &vnode->symbol.ref_list);\n     }\n   /* Pickle in also the initializer of all referenced readonly variables\n      to help folding.  Constant pool variables are not shared, so we must\n      pickle those too.  */\n-  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      struct varpool_node *vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n-      if (DECL_INITIAL (vnode->symbol.decl)\n-\t  && !lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n-\t\t\t\t\t\t        vnode)\n-\t  && const_value_known_p (vnode->symbol.decl))\n+      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      if (symtab_variable_p (node))\n \t{\n-\t  lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n-\t  add_references (encoder, varpool_encoder, &vnode->symbol.ref_list);\n-\t}\n-      else if (vnode->alias || vnode->alias_of)\n-        add_references (encoder, varpool_encoder, &vnode->symbol.ref_list);\n+\t  struct varpool_node *vnode = varpool (node);\n+\t  if (DECL_INITIAL (vnode->symbol.decl)\n+\t      && !lto_symtab_encoder_encode_initializer_p (encoder,\n+\t\t\t\t\t\t\t   vnode)\n+\t      && const_value_known_p (vnode->symbol.decl))\n+\t    {\n+\t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n+\t      add_references (encoder, &vnode->symbol.ref_list);\n+\t    }\n+\t  else if (vnode->alias || vnode->alias_of)\n+\t    add_references (encoder, &vnode->symbol.ref_list);\n+       }\n     }\n \n   /* Go over all the nodes again to include callees that are not in\n@@ -835,8 +756,7 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n   struct lto_simple_output_block *ob;\n   cgraph_node_set_iterator csi;\n   int i, n_nodes;\n-  lto_cgraph_encoder_t encoder;\n-  lto_varpool_encoder_t varpool_encoder;\n+  lto_symtab_encoder_t encoder;\n   static bool asm_nodes_output = false;\n \n   if (flag_wpa)\n@@ -848,19 +768,22 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n \n   /* An encoder for cgraph nodes should have been created by\n      ipa_write_summaries_1.  */\n-  gcc_assert (ob->decl_state->cgraph_node_encoder);\n-  gcc_assert (ob->decl_state->varpool_node_encoder);\n-  encoder = ob->decl_state->cgraph_node_encoder;\n-  varpool_encoder = ob->decl_state->varpool_node_encoder;\n+  gcc_assert (ob->decl_state->symtab_node_encoder);\n+  encoder = ob->decl_state->symtab_node_encoder;\n \n   /* Write out the nodes.  We must first output a node and then its clones,\n      otherwise at a time reading back the node there would be nothing to clone\n      from.  */\n-  n_nodes = lto_cgraph_encoder_size (encoder);\n+  n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n     {\n-      node = lto_cgraph_encoder_deref (encoder, i);\n-      lto_output_node (ob, node, encoder, set, vset);\n+      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      if (symtab_function_p (node))\n+        lto_output_node (ob, cgraph (node), encoder, set, vset);\n+      else\n+        lto_output_varpool_node (ob, varpool (node), encoder,\n+\t\t\t         set, vset);\n+\t\n     }\n \n   /* Go over the nodes in SET again to write edges.  */\n@@ -885,8 +808,7 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n       lto_output_toplevel_asms ();\n     }\n \n-  output_varpool (set, vset);\n-  output_refs (set, vset, encoder, varpool_encoder);\n+  output_refs (set, vset, encoder);\n }\n \n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n@@ -899,7 +821,7 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n static void\n input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      struct cgraph_node *node,\n-\t\t      enum LTO_cgraph_tags tag,\n+\t\t      enum LTO_symtab_tags tag,\n \t\t      struct bitpack_d *bp)\n {\n   node->symbol.aux = (void *) tag;\n@@ -916,7 +838,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->abstract_and_needed = bp_unpack_value (bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n-  node->analyzed = tag == LTO_cgraph_analyzed_node;\n+  node->analyzed = tag == LTO_symtab_analyzed_node;\n   node->symbol.in_other_partition = bp_unpack_value (bp, 1);\n   if (node->symbol.in_other_partition\n       /* Avoid updating decl when we are seeing just inline clone.\n@@ -942,38 +864,14 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t\t\t     LDPR_NUM_KNOWN);\n }\n \n-/* Output the part of the cgraph in SET.  */\n-\n-static void\n-output_varpool (cgraph_node_set set, varpool_node_set vset)\n-{\n-  struct lto_simple_output_block *ob = lto_create_simple_output_block (LTO_section_varpool);\n-  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n-  int len = lto_varpool_encoder_size (varpool_encoder), i;\n-\n-  streamer_write_uhwi_stream (ob->main_stream, len);\n-\n-  /* Write out the nodes.  We must first output a node and then its clones,\n-     otherwise at a time reading back the node there would be nothing to clone\n-     from.  */\n-  for (i = 0; i < len; i++)\n-    {\n-      lto_output_varpool_node (ob, lto_varpool_encoder_deref (varpool_encoder, i),\n-      \t\t\t       varpool_encoder,\n-\t\t\t       set, vset);\n-    }\n-\n-  lto_destroy_simple_output_block (ob);\n-}\n-\n /* Read a node from input_block IB.  TAG is the node's tag just read.\n    Return the node read or overwriten.  */\n \n static struct cgraph_node *\n input_node (struct lto_file_decl_data *file_data,\n \t    struct lto_input_block *ib,\n-\t    enum LTO_cgraph_tags tag,\n-\t    VEC(cgraph_node_ptr, heap) *nodes)\n+\t    enum LTO_symtab_tags tag,\n+\t    VEC(symtab_node, heap) *nodes)\n {\n   tree fn_decl;\n   struct cgraph_node *node;\n@@ -991,7 +889,7 @@ input_node (struct lto_file_decl_data *file_data,\n \n   if (clone_ref != LCC_NOT_FOUND)\n     {\n-      node = cgraph_clone_node (VEC_index (cgraph_node_ptr, nodes, clone_ref), fn_decl,\n+      node = cgraph_clone_node (cgraph (VEC_index (symtab_node, nodes, clone_ref)), fn_decl,\n \t\t\t\t0, CGRAPH_FREQ_BASE, false, NULL, false);\n     }\n   else\n@@ -1004,7 +902,7 @@ input_node (struct lto_file_decl_data *file_data,\n   node->count = streamer_read_hwi (ib);\n   node->count_materialization_scale = streamer_read_hwi (ib);\n \n-  if (tag == LTO_cgraph_analyzed_node)\n+  if (tag == LTO_symtab_analyzed_node)\n     ref = streamer_read_hwi (ib);\n \n   ref2 = streamer_read_hwi (ib);\n@@ -1107,25 +1005,16 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n static void\n input_ref (struct lto_input_block *ib,\n \t   symtab_node referring_node,\n-\t   VEC(cgraph_node_ptr, heap) *nodes,\n-\t   VEC(varpool_node_ptr, heap) *varpool_nodes_vec)\n+\t   VEC(symtab_node, heap) *nodes)\n {\n-  struct cgraph_node *node = NULL;\n-  struct varpool_node *varpool_node = NULL;\n+  symtab_node node = NULL;\n   struct bitpack_d bp;\n-  int type;\n   enum ipa_ref_use use;\n \n   bp = streamer_read_bitpack (ib);\n-  type = bp_unpack_value (&bp, 1);\n   use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n-  if (type)\n-    node = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n-  else\n-    varpool_node = VEC_index (varpool_node_ptr, varpool_nodes_vec,\n-\t\t\t      streamer_read_hwi (ib));\n-  ipa_record_reference (referring_node,\n-\t\t        node ? (symtab_node) node : (symtab_node) varpool_node, use, NULL);\n+  node = VEC_index (symtab_node, nodes, streamer_read_hwi (ib));\n+  ipa_record_reference (referring_node, node, use, NULL);\n }\n \n /* Read an edge from IB.  NODES points to a vector of previously read nodes for\n@@ -1134,7 +1023,7 @@ input_ref (struct lto_input_block *ib,\n    indirect_unknown_callee set).  */\n \n static void\n-input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n+input_edge (struct lto_input_block *ib, VEC(symtab_node, heap) *nodes,\n \t    bool indirect)\n {\n   struct cgraph_node *caller, *callee;\n@@ -1146,13 +1035,13 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   struct bitpack_d bp;\n   int ecf_flags = 0;\n \n-  caller = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n+  caller = cgraph (VEC_index (symtab_node, nodes, streamer_read_hwi (ib)));\n   if (caller == NULL || caller->symbol.decl == NULL_TREE)\n     internal_error (\"bytecode stream: no caller found while reading edge\");\n \n   if (!indirect)\n     {\n-      callee = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n+      callee = cgraph (VEC_index (symtab_node, nodes, streamer_read_hwi (ib)));\n       if (callee == NULL || callee->symbol.decl == NULL_TREE)\n \tinternal_error (\"bytecode stream: no callee found while reading edge\");\n     }\n@@ -1197,117 +1086,85 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n \n /* Read a cgraph from IB using the info in FILE_DATA.  */\n \n-static VEC(cgraph_node_ptr, heap) *\n+static VEC(symtab_node, heap) *\n input_cgraph_1 (struct lto_file_decl_data *file_data,\n \t\tstruct lto_input_block *ib)\n {\n-  enum LTO_cgraph_tags tag;\n-  VEC(cgraph_node_ptr, heap) *nodes = NULL;\n-  struct cgraph_node *node;\n+  enum LTO_symtab_tags tag;\n+  VEC(symtab_node, heap) *nodes = NULL;\n+  symtab_node node;\n   unsigned i;\n \n-  tag = streamer_read_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n+  tag = streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n   order_base = symtab_order;\n   while (tag)\n     {\n-      if (tag == LTO_cgraph_edge)\n+      if (tag == LTO_symtab_edge)\n         input_edge (ib, nodes, false);\n-      else if (tag == LTO_cgraph_indirect_edge)\n+      else if (tag == LTO_symtab_indirect_edge)\n         input_edge (ib, nodes, true);\n+      else if (tag == LTO_symtab_variable)\n+        {\n+\t  node = (symtab_node)input_varpool_node (file_data, ib);\n+          VEC_safe_push (symtab_node, heap, nodes, node);\n+\t  lto_symtab_encoder_encode (file_data->symtab_node_encoder, node);\n+        }\n       else\n \t{\n-\t  node = input_node (file_data, ib, tag,nodes);\n+\t  node = (symtab_node)input_node (file_data, ib, tag, nodes);\n \t  if (node == NULL || node->symbol.decl == NULL_TREE)\n \t    internal_error (\"bytecode stream: found empty cgraph node\");\n-\t  VEC_safe_push (cgraph_node_ptr, heap, nodes, node);\n-\t  lto_cgraph_encoder_encode (file_data->cgraph_node_encoder, node);\n+\t  VEC_safe_push (symtab_node, heap, nodes, node);\n+\t  lto_symtab_encoder_encode (file_data->symtab_node_encoder, node);\n \t}\n \n-      tag = streamer_read_enum (ib, LTO_cgraph_tags, LTO_cgraph_last_tag);\n+      tag = streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n     }\n \n   lto_input_toplevel_asms (file_data, order_base);\n \n-  /* AUX pointers should be all non-zero for nodes read from the stream.  */\n+  /* AUX pointers should be all non-zero for function nodes read from the stream.  */\n #ifdef ENABLE_CHECKING\n-  FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n-    gcc_assert (node->symbol.aux);\n+  FOR_EACH_VEC_ELT (symtab_node, nodes, i, node)\n+    gcc_assert (node->symbol.aux || !symtab_function_p (node));\n #endif\n-  FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n+  FOR_EACH_VEC_ELT (symtab_node, nodes, i, node)\n     {\n-      int ref = (int) (intptr_t) node->global.inlined_to;\n-\n-      /* We share declaration of builtins, so we may read same node twice.  */\n-      if (!node->symbol.aux)\n-\tcontinue;\n-      node->symbol.aux = NULL;\n-\n-      /* Fixup inlined_to from reference to pointer.  */\n-      if (ref != LCC_NOT_FOUND)\n-\tnode->global.inlined_to = VEC_index (cgraph_node_ptr, nodes, ref);\n-      else\n-\tnode->global.inlined_to = NULL;\n+      int ref;\n+      if (symtab_function_p (node))\n+\t{\n+\t  ref = (int) (intptr_t) cgraph (node)->global.inlined_to;\n+\n+\t  /* We share declaration of builtins, so we may read same node twice.  */\n+\t  if (!node->symbol.aux)\n+\t    continue;\n+\t  node->symbol.aux = NULL;\n+\n+\t  /* Fixup inlined_to from reference to pointer.  */\n+\t  if (ref != LCC_NOT_FOUND)\n+\t    cgraph (node)->global.inlined_to = cgraph (VEC_index (symtab_node, nodes, ref));\n+\t  else\n+\t    cgraph (node)->global.inlined_to = NULL;\n+\t}\n \n       ref = (int) (intptr_t) node->symbol.same_comdat_group;\n \n       /* Fixup same_comdat_group from reference to pointer.  */\n       if (ref != LCC_NOT_FOUND)\n-\tnode->symbol.same_comdat_group = (symtab_node)VEC_index (cgraph_node_ptr, nodes, ref);\n+\tnode->symbol.same_comdat_group = VEC_index (symtab_node, nodes, ref);\n       else\n \tnode->symbol.same_comdat_group = NULL;\n     }\n-  FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n-    node->symbol.aux = (void *)1;\n+  FOR_EACH_VEC_ELT (symtab_node, nodes, i, node)\n+    node->symbol.aux = symtab_function_p (node) ? (void *)1 : NULL;\n   return nodes;\n }\n \n-/* Read a varpool from IB using the info in FILE_DATA.  */\n-\n-static VEC(varpool_node_ptr, heap) *\n-input_varpool_1 (struct lto_file_decl_data *file_data,\n-\t\tstruct lto_input_block *ib)\n-{\n-  unsigned HOST_WIDE_INT len;\n-  VEC(varpool_node_ptr, heap) *varpool = NULL;\n-  int i;\n-  struct varpool_node *node;\n-\n-  len = streamer_read_uhwi (ib);\n-  while (len)\n-    {\n-      VEC_safe_push (varpool_node_ptr, heap, varpool,\n-\t\t     input_varpool_node (file_data, ib));\n-      len--;\n-    }\n-#ifdef ENABLE_CHECKING\n-  FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n-    gcc_assert (!node->symbol.aux);\n-#endif\n-  FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n-    {\n-      int ref = (int) (intptr_t) node->symbol.same_comdat_group;\n-      /* We share declaration of builtins, so we may read same node twice.  */\n-      if (node->symbol.aux)\n-\tcontinue;\n-      node->symbol.aux = (void *)1;\n-\n-      /* Fixup same_comdat_group from reference to pointer.  */\n-      if (ref != LCC_NOT_FOUND)\n-\tnode->symbol.same_comdat_group = (symtab_node)VEC_index (varpool_node_ptr, varpool, ref);\n-      else\n-\tnode->symbol.same_comdat_group = NULL;\n-    }\n-  FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n-    node->symbol.aux = NULL;\n-  return varpool;\n-}\n-\n /* Input ipa_refs.  */\n \n static void\n input_refs (struct lto_input_block *ib,\n-\t    VEC(cgraph_node_ptr, heap) *nodes,\n-\t    VEC(varpool_node_ptr, heap) *varpool)\n+\t    VEC(symtab_node, heap) *nodes)\n {\n   int count;\n   int idx;\n@@ -1318,10 +1175,10 @@ input_refs (struct lto_input_block *ib,\n       if (!count)\n \tbreak;\n       idx = streamer_read_uhwi (ib);\n-      node = VEC_index (cgraph_node_ptr, nodes, idx);\n+      node = cgraph (VEC_index (symtab_node, nodes, idx));\n       while (count)\n \t{\n-\t  input_ref (ib, (symtab_node) node, nodes, varpool);\n+\t  input_ref (ib, (symtab_node) node, nodes);\n \t  count--;\n \t}\n     }\n@@ -1331,11 +1188,11 @@ input_refs (struct lto_input_block *ib,\n       count = streamer_read_uhwi (ib);\n       if (!count)\n \tbreak;\n-      node = VEC_index (varpool_node_ptr, varpool,\n-\t\t\tstreamer_read_uhwi (ib));\n+      node = varpool (VEC_index (symtab_node, nodes,\n+\t\t      streamer_read_uhwi (ib)));\n       while (count)\n \t{\n-\t  input_ref (ib, (symtab_node) node, nodes, varpool);\n+\t  input_ref (ib, (symtab_node) node, nodes);\n \t  count--;\n \t}\n     }\n@@ -1462,38 +1319,28 @@ input_cgraph (void)\n       const char *data;\n       size_t len;\n       struct lto_input_block *ib;\n-      VEC(cgraph_node_ptr, heap) *nodes;\n-      VEC(varpool_node_ptr, heap) *varpool;\n+      VEC(symtab_node, heap) *nodes;\n \n       ib = lto_create_simple_input_block (file_data, LTO_section_cgraph,\n \t\t\t\t\t  &data, &len);\n       if (!ib) \n \tfatal_error (\"cannot find LTO cgraph in %s\", file_data->file_name);\n       input_profile_summary (ib, file_data);\n-      file_data->cgraph_node_encoder = lto_cgraph_encoder_new ();\n+      file_data->symtab_node_encoder = lto_symtab_encoder_new ();\n       nodes = input_cgraph_1 (file_data, ib);\n       lto_destroy_simple_input_block (file_data, LTO_section_cgraph,\n \t\t\t\t      ib, data, len);\n \n-      ib = lto_create_simple_input_block (file_data, LTO_section_varpool,\n-\t\t\t\t\t  &data, &len);\n-      if (!ib)\n-\tfatal_error (\"cannot find LTO varpool in %s\", file_data->file_name);\n-      varpool = input_varpool_1 (file_data, ib);\n-      lto_destroy_simple_input_block (file_data, LTO_section_varpool,\n-\t\t\t\t      ib, data, len);\n-\n       ib = lto_create_simple_input_block (file_data, LTO_section_refs,\n \t\t\t\t\t  &data, &len);\n       if (!ib)\n \tfatal_error(\"cannot find LTO section refs in %s\", file_data->file_name);\n-      input_refs (ib, nodes, varpool);\n+      input_refs (ib, nodes);\n       lto_destroy_simple_input_block (file_data, LTO_section_refs,\n \t\t\t\t      ib, data, len);\n       if (flag_ltrans)\n \tinput_cgraph_opt_summary (nodes);\n-      VEC_free (cgraph_node_ptr, heap, nodes);\n-      VEC_free (varpool_node_ptr, heap, varpool);\n+      VEC_free (symtab_node, heap, nodes);\n     }\n \n   merge_profile_summaries (file_data_vec);\n@@ -1598,27 +1445,28 @@ output_node_opt_summary (struct output_block *ob,\n static void\n output_cgraph_opt_summary (cgraph_node_set set)\n {\n-  struct cgraph_node *node;\n+  symtab_node node;\n   int i, n_nodes;\n-  lto_cgraph_encoder_t encoder;\n+  lto_symtab_encoder_t encoder;\n   struct output_block *ob = create_output_block (LTO_section_cgraph_opt_sum);\n   unsigned count = 0;\n \n   ob->cgraph_node = NULL;\n-  encoder = ob->decl_state->cgraph_node_encoder;\n-  n_nodes = lto_cgraph_encoder_size (encoder);\n+  encoder = ob->decl_state->symtab_node_encoder;\n+  n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n-    if (output_cgraph_opt_summary_p (lto_cgraph_encoder_deref (encoder, i),\n-\t\t\t\t     set))\n+    if (symtab_function_p (node = lto_symtab_encoder_deref (encoder, i))\n+\t&& output_cgraph_opt_summary_p (cgraph (node), set))\n       count++;\n   streamer_write_uhwi (ob, count);\n   for (i = 0; i < n_nodes; i++)\n     {\n-      node = lto_cgraph_encoder_deref (encoder, i);\n-      if (output_cgraph_opt_summary_p (node, set))\n+      node = lto_symtab_encoder_deref (encoder, i);\n+      if (symtab_function_p (node)\n+\t  && output_cgraph_opt_summary_p (cgraph (node), set))\n \t{\n \t  streamer_write_uhwi (ob, i);\n-\t  output_node_opt_summary (ob, node, set);\n+\t  output_node_opt_summary (ob, cgraph (node), set);\n \t}\n     }\n   produce_asm (ob, NULL);\n@@ -1690,7 +1538,7 @@ input_node_opt_summary (struct cgraph_node *node,\n \n static void\n input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n-\t\t\t  const char *data, size_t len, VEC (cgraph_node_ptr,\n+\t\t\t  const char *data, size_t len, VEC (symtab_node,\n \t\t\t\t\t\t\t     heap) * nodes)\n {\n   const struct lto_function_header *header =\n@@ -1714,7 +1562,7 @@ input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n   for (i = 0; i < count; i++)\n     {\n       int ref = streamer_read_uhwi (&ib_main);\n-      input_node_opt_summary (VEC_index (cgraph_node_ptr, nodes, ref),\n+      input_node_opt_summary (cgraph (VEC_index (symtab_node, nodes, ref)),\n \t\t\t      &ib_main, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_cgraph_opt_sum, NULL, data,\n@@ -1725,7 +1573,7 @@ input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n /* Input optimization summary of cgraph.  */\n \n static void\n-input_cgraph_opt_summary (VEC (cgraph_node_ptr, heap) * nodes)\n+input_cgraph_opt_summary (VEC (symtab_node, heap) * nodes)\n {\n   struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n   struct lto_file_decl_data *file_data;"}, {"sha": "5a691003a1c4325a6506c0e927d0df8557488f0c", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -348,13 +348,13 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n \t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n \t  && initial)\n \t{\n-\t  lto_varpool_encoder_t varpool_encoder;\n+\t  lto_symtab_encoder_t encoder;\n \t  struct varpool_node *vnode;\n \n-\t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n+\t  encoder = ob->decl_state->symtab_node_encoder;\n \t  vnode = varpool_get_node (expr);\n \t  if (!vnode\n-\t      || !lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t      || !lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\t    vnode))\n \t    initial = error_mark_node;\n \t}\n@@ -983,17 +983,20 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n   bitmap output = lto_bitmap_alloc ();\n #endif\n   int i, n_nodes;\n-  lto_cgraph_encoder_t encoder = lto_get_out_decl_state ()->cgraph_node_encoder;\n+  lto_symtab_encoder_t encoder = lto_get_out_decl_state ()->symtab_node_encoder;\n \n   /* Initialize the streamer.  */\n   lto_streamer_init ();\n \n-  n_nodes = lto_cgraph_encoder_size (encoder);\n+  n_nodes = lto_symtab_encoder_size (encoder);\n   /* Process only the functions with bodies.  */\n   for (i = 0; i < n_nodes; i++)\n     {\n-      node = lto_cgraph_encoder_deref (encoder, i);\n-      if (lto_cgraph_encoder_encode_body_p (encoder, node)\n+      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      if (!symtab_function_p (snode))\n+\tcontinue;\n+      node = cgraph (snode);\n+      if (lto_symtab_encoder_encode_body_p (encoder, node)\n \t  && !node->alias\n \t  && !node->thunk.thunk_p)\n \t{\n@@ -1290,8 +1293,7 @@ produce_symtab (struct output_block *ob)\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n   struct lto_output_stream stream;\n-  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n-  lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n+  lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   int i;\n \n   lto_begin_section (section_name, false);\n@@ -1303,9 +1305,11 @@ produce_symtab (struct output_block *ob)\n   /* Write all functions. \n      First write all defined functions and then write all used functions.\n      This is done so only to handle duplicated symbols in cgraph.  */\n-  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lto_cgraph_encoder_deref (encoder, i);\n+      if (!symtab_function_p (lto_symtab_encoder_deref (encoder, i)))\n+\tcontinue;\n+      node = cgraph (lto_symtab_encoder_deref (encoder, i));\n       if (DECL_EXTERNAL (node->symbol.decl))\n \tcontinue;\n       if (DECL_COMDAT (node->symbol.decl)\n@@ -1315,9 +1319,11 @@ produce_symtab (struct output_block *ob)\n \tcontinue;\n       write_symbol (cache, &stream, node->symbol.decl, seen, false);\n     }\n-  for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      node = lto_cgraph_encoder_deref (encoder, i);\n+      if (!symtab_function_p (lto_symtab_encoder_deref (encoder, i)))\n+\tcontinue;\n+      node = cgraph (lto_symtab_encoder_deref (encoder, i));\n       if (!DECL_EXTERNAL (node->symbol.decl))\n \tcontinue;\n       /* We keep around unused extern inlines in order to be able to inline\n@@ -1334,9 +1340,11 @@ produce_symtab (struct output_block *ob)\n     }\n \n   /* Write all variables.  */\n-  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n+      if (!symtab_variable_p (lto_symtab_encoder_deref (encoder, i)))\n+\tcontinue;\n+      vnode = varpool (lto_symtab_encoder_deref (encoder, i));\n       if (DECL_EXTERNAL (vnode->symbol.decl))\n \tcontinue;\n       /* COMDAT virtual tables can be unshared.  Do not declare them\n@@ -1351,9 +1359,11 @@ produce_symtab (struct output_block *ob)\n \tcontinue;\n       write_symbol (cache, &stream, vnode->symbol.decl, seen, false);\n     }\n-  for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n+  for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n+      if (!symtab_variable_p (lto_symtab_encoder_deref (encoder, i)))\n+\tcontinue;\n+      vnode = varpool (lto_symtab_encoder_deref (encoder, i));\n       if (!DECL_EXTERNAL (vnode->symbol.decl))\n \tcontinue;\n       if (DECL_COMDAT (vnode->symbol.decl)\n@@ -1482,8 +1492,7 @@ produce_asm_for_decls (cgraph_node_set set ATTRIBUTE_UNUSED,\n \tVEC_index (lto_out_decl_state_ptr, lto_function_decl_states, idx);\n       lto_delete_out_decl_state (fn_out_state);\n     }\n-  lto_cgraph_encoder_delete (ob->decl_state->cgraph_node_encoder);\n-  lto_varpool_encoder_delete (ob->decl_state->varpool_node_encoder);\n+  lto_symtab_encoder_delete (ob->decl_state->symtab_node_encoder);\n   VEC_free (lto_out_decl_state_ptr, heap, lto_function_decl_states);\n   lto_function_decl_states = NULL;\n   destroy_output_block (ob);"}, {"sha": "39a40a45e9d6416866ac0188e25562be6fc31f08", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 16, "deletions": 50, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7380e6efdd990e0286da69d7b583240eccf40694/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=7380e6efdd990e0286da69d7b583240eccf40694", "patch": "@@ -423,49 +423,28 @@ struct lto_stats_d\n };\n \n /* Encoder data structure used to stream callgraph nodes.  */\n-struct lto_cgraph_encoder_d\n+struct lto_symtab_encoder_d\n {\n   /* Map nodes to reference number. */\n   struct pointer_map_t *map;\n \n   /* Map reference number to node. */\n-  VEC(cgraph_node_ptr,heap) *nodes;\n+  VEC(symtab_node,heap) *nodes;\n \n   /* Map of nodes where we want to output body.  */\n   struct pointer_set_t *body;\n-};\n-\n-typedef struct lto_cgraph_encoder_d *lto_cgraph_encoder_t;\n-\n-/* Return number of encoded nodes in ENCODER.  */\n-\n-static inline int\n-lto_cgraph_encoder_size (lto_cgraph_encoder_t encoder)\n-{\n-  return VEC_length (cgraph_node_ptr, encoder->nodes);\n-}\n-\n-\n-/* Encoder data structure used to stream callgraph nodes.  */\n-struct lto_varpool_encoder_d\n-{\n-  /* Map nodes to reference number. */\n-  struct pointer_map_t *map;\n-\n-  /* Map reference number to node. */\n-  VEC(varpool_node_ptr,heap) *nodes;\n-\n   /* Map of nodes where we want to output initializer.  */\n   struct pointer_set_t *initializer;\n };\n-typedef struct lto_varpool_encoder_d *lto_varpool_encoder_t;\n+\n+typedef struct lto_symtab_encoder_d *lto_symtab_encoder_t;\n \n /* Return number of encoded nodes in ENCODER.  */\n \n static inline int\n-lto_varpool_encoder_size (lto_varpool_encoder_t encoder)\n+lto_symtab_encoder_size (lto_symtab_encoder_t encoder)\n {\n-  return VEC_length (varpool_node_ptr, encoder->nodes);\n+  return VEC_length (symtab_node, encoder->nodes);\n }\n \n /* Mapping from indices to trees.  */\n@@ -520,10 +499,7 @@ struct lto_out_decl_state\n   struct lto_tree_ref_encoder streams[LTO_N_DECL_STREAMS];\n \n   /* Encoder for cgraph nodes.  */\n-  lto_cgraph_encoder_t cgraph_node_encoder;\n-\n-  /* Encoder for varpool nodes.  */\n-  lto_varpool_encoder_t varpool_node_encoder;\n+  lto_symtab_encoder_t symtab_node_encoder;\n \n   /* If this out-decl state belongs to a function, fn_decl points to that\n      function.  Otherwise, it is NULL. */\n@@ -549,10 +525,7 @@ struct GTY(()) lto_file_decl_data\n   struct lto_in_decl_state *global_decl_state;\n \n   /* Table of cgraph nodes present in this file.  */\n-  lto_cgraph_encoder_t GTY((skip)) cgraph_node_encoder;\n-\n-  /* Table of varpool nodes present in this file.  */\n-  lto_varpool_encoder_t GTY((skip)) varpool_node_encoder;\n+  lto_symtab_encoder_t GTY((skip)) symtab_node_encoder;\n \n   /* Hash table maps lto-related section names to location in file.  */\n   htab_t GTY((param_is (struct lto_in_decl_state))) function_decl_states;\n@@ -837,23 +810,16 @@ void lto_output_location (struct output_block *, location_t);\n \n \n /* In lto-cgraph.c  */\n-struct cgraph_node *lto_cgraph_encoder_deref (lto_cgraph_encoder_t, int);\n-int lto_cgraph_encoder_lookup (lto_cgraph_encoder_t, struct cgraph_node *);\n-lto_cgraph_encoder_t lto_cgraph_encoder_new (void);\n-int lto_cgraph_encoder_encode (lto_cgraph_encoder_t, struct cgraph_node *);\n-void lto_cgraph_encoder_delete (lto_cgraph_encoder_t);\n-bool lto_cgraph_encoder_encode_body_p (lto_cgraph_encoder_t,\n+symtab_node lto_symtab_encoder_deref (lto_symtab_encoder_t, int);\n+int lto_symtab_encoder_lookup (lto_symtab_encoder_t, symtab_node);\n+lto_symtab_encoder_t lto_symtab_encoder_new (void);\n+int lto_symtab_encoder_encode (lto_symtab_encoder_t, symtab_node);\n+void lto_symtab_encoder_delete (lto_symtab_encoder_t);\n+bool lto_symtab_encoder_encode_body_p (lto_symtab_encoder_t,\n \t\t\t\t       struct cgraph_node *);\n \n-bool lto_varpool_encoder_encode_body_p (lto_varpool_encoder_t,\n-\t\t\t\t        struct varpool_node *);\n-struct varpool_node *lto_varpool_encoder_deref (lto_varpool_encoder_t, int);\n-int lto_varpool_encoder_lookup (lto_varpool_encoder_t, struct varpool_node *);\n-lto_varpool_encoder_t lto_varpool_encoder_new (void);\n-int lto_varpool_encoder_encode (lto_varpool_encoder_t, struct varpool_node *);\n-void lto_varpool_encoder_delete (lto_varpool_encoder_t);\n-bool lto_varpool_encoder_encode_initializer_p (lto_varpool_encoder_t,\n-\t\t\t\t\t       struct varpool_node *);\n+bool lto_symtab_encoder_encode_initializer_p (lto_symtab_encoder_t,\n+\t\t\t\t\t      struct varpool_node *);\n void output_cgraph (cgraph_node_set, varpool_node_set);\n void input_cgraph (void);\n bool referenced_from_other_partition_p (struct ipa_ref_list *,"}]}