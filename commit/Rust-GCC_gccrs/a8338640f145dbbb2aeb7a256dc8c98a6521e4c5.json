{"sha": "a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgzMzg2NDBmMTQ1ZGJiYjJhZWI3YTI1NmRjOGM5OGE2NTIxZTRjNQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-07-22T15:30:50Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-07-22T15:30:50Z"}, "message": "re PR tree-optimization/35229 (Vectorizer doesn't  support dependence created by predictive commoning or PRE)\n\n        PR tree-optimization/35229\n        PR tree-optimization/39300\n\n        * tree-ssa-pre.c (includes): Include tree-scalar-evolution.h.\n        (inhibit_phi_insertion): New function.\n        (insert_into_preds_of_block): Call it for REFERENCEs.\n        (init_pre): Initialize and finalize scalar evolutions.\n        * Makefile.in (tree-ssa-pre.o): Depend on tree-scalar-evolution.h .\n\ntestsuite/\n        * gcc.dg/vect/vect-pre-interact.c: New test.\n\nFrom-SVN: r149942", "tree": {"sha": "121461434108d582e12f2dda2ade5c31fd269733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/121461434108d582e12f2dda2ade5c31fd269733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa031669cdf8b013ba14a0e37c3fbce9de0a080e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa031669cdf8b013ba14a0e37c3fbce9de0a080e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa031669cdf8b013ba14a0e37c3fbce9de0a080e"}], "stats": {"total": 100, "additions": 97, "deletions": 3}, "files": [{"sha": "018e805b90035990a6570d63257be75886b82b69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "patch": "@@ -1,3 +1,14 @@\n+2009-07-22  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/35229\n+\tPR tree-optimization/39300\n+\n+\t* tree-ssa-pre.c (includes): Include tree-scalar-evolution.h.\n+\t(inhibit_phi_insertion): New function.\n+\t(insert_into_preds_of_block): Call it for REFERENCEs.\n+\t(init_pre): Initialize and finalize scalar evolutions.\n+\t* Makefile.in (tree-ssa-pre.o): Depend on tree-scalar-evolution.h .\n+\n 2009-07-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/predicates.md (zero_extended_scalar_load_operand):"}, {"sha": "efad8ee55e605becbfe31560ff0762237323c9f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "patch": "@@ -1,3 +1,9 @@\n+2009-07-22  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/35229\n+\tPR tree-optimization/39300\n+\t* gcc.dg/vect/vect-pre-interact.c: New test.\n+\n 2009-07-22  Richard Guenther  <rguenther@suse.de>\n \n \t* g++.dg/lookup/using21.C: Fix duplicate paste."}, {"sha": "96d50e9359c14551dbc847d77b44dc3f815fb3d2", "filename": "gcc/testsuite/gcc.dg/vect/vect-pre-interact.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-pre-interact.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-pre-interact.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-pre-interact.c?ref=a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O3 -ftree-pre -fdump-tree-vect-details\" } */\n+\n+/* This checks that PRE doesn't create situations that prevent vectorization.\n+   I.e. PR39300, PR35229.  */\n+float res[1024], data[1025];\n+\n+void foo (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; ++i)\n+    res[i] = data[i] + data[i + 1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9e3754b37fcf2c82e4bbfe00922bb86733b17f9d", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8338640f145dbbb2aeb7a256dc8c98a6521e4c5/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=a8338640f145dbbb2aeb7a256dc8c98a6521e4c5", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"cfgloop.h\"\n #include \"tree-ssa-sccvn.h\"\n+#include \"tree-scalar-evolution.h\"\n #include \"params.h\"\n #include \"dbgcnt.h\"\n \n@@ -3081,6 +3082,62 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n }\n \n \n+/* Returns true if we want to inhibit the insertions of PHI nodes\n+   for the given EXPR for basic block BB (a member of a loop).\n+   We want to do this, when we fear that the induction variable we\n+   create might inhibit vectorization.  */\n+\n+static bool\n+inhibit_phi_insertion (basic_block bb, pre_expr expr)\n+{\n+  vn_reference_t vr = PRE_EXPR_REFERENCE (expr);\n+  VEC (vn_reference_op_s, heap) *ops = vr->operands;\n+  vn_reference_op_t op;\n+  unsigned i;\n+\n+  /* If we aren't going to vectorize we don't inhibit anything.  */\n+  if (!flag_tree_vectorize)\n+    return false;\n+\n+  /* Otherwise we inhibit the insertion when the address of the\n+     memory reference is a simple induction variable.  In other\n+     cases the vectorizer won't do anything anyway (either it's\n+     loop invariant or a complicated expression).  */\n+  for (i = 0; VEC_iterate (vn_reference_op_s, ops, i, op); ++i)\n+    {\n+      switch (op->opcode)\n+\t{\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  if (TREE_CODE (op->op0) != SSA_NAME)\n+\t    break;\n+\t  /* Fallthru.  */\n+\tcase SSA_NAME:\n+\t  {\n+\t    basic_block defbb = gimple_bb (SSA_NAME_DEF_STMT (op->op0));\n+\t    affine_iv iv;\n+\t    /* Default defs are loop invariant.  */\n+\t    if (!defbb)\n+\t      break;\n+\t    /* Defined outside this loop, also loop invariant.  */\n+\t    if (!flow_bb_inside_loop_p (bb->loop_father, defbb))\n+\t      break;\n+\t    /* If it's a simple induction variable inhibit insertion,\n+\t       the vectorizer might be interested in this one.  */\n+\t    if (simple_iv (bb->loop_father, bb->loop_father,\n+\t\t\t   op->op0, &iv, true))\n+\t      return true;\n+\t    /* No simple IV, vectorizer can't do anything, hence no\n+\t       reason to inhibit the transformation for this operand.  */\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Insert the to-be-made-available values of expression EXPRNUM for each\n    predecessor, stored in AVAIL, into the predecessors of BLOCK, and\n    merge the result with a phi node, given the same value number as\n@@ -3111,8 +3168,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n     }\n \n   /* Make sure we aren't creating an induction variable.  */\n-  if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2\n-      && expr->kind != REFERENCE)\n+  if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2)\n     {\n       bool firstinsideloop = false;\n       bool secondinsideloop = false;\n@@ -3121,7 +3177,9 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n       secondinsideloop = flow_bb_inside_loop_p (block->loop_father,\n \t\t\t\t\t\tEDGE_PRED (block, 1)->src);\n       /* Induction variables only have one edge inside the loop.  */\n-      if (firstinsideloop ^ secondinsideloop)\n+      if ((firstinsideloop ^ secondinsideloop)\n+\t  && (expr->kind != REFERENCE\n+\t      || inhibit_phi_insertion (block, expr)))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"Skipping insertion of phi for partial redundancy: Looks like an induction variable\\n\");\n@@ -4504,6 +4562,7 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)\n       return 0;\n     }\n   init_pre (do_fre);\n+  scev_initialize ();\n \n \n   /* Collect and value number expressions computed in each basic block.  */\n@@ -4555,6 +4614,7 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)\n   if (!do_fre)\n     remove_dead_inserted_code ();\n \n+  scev_finalize ();\n   fini_pre (do_fre);\n \n   return todo;"}]}