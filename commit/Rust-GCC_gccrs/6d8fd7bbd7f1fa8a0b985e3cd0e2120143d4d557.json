{"sha": "6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4ZmQ3YmJkN2YxZmE4YTBiOTg1ZTNjZDBlMjEyMDE0M2Q0ZDU1Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-04T04:06:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-06-04T04:06:38Z"}, "message": "alpha.c (reg_or_const_int_operand): New.\n\n        * config/alpha/alpha.c (reg_or_const_int_operand): New.\n        (some_operand, input_operand): Accept CONST_VECTOR.\n        (alpha_extra_constraint): Add 'W'.\n        (alpha_expand_zap_mask): New.\n        (alpha_expand_builtin_vector_binop): New.\n        (enum alpha_builtin): New.\n        (zero_arg_builtins, one_arg_builtins, two_arg_builtins): New.\n        (alpha_init_builtins, alpha_expand_builtin): New.\n        (TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): New.\n        * config/alpha/alpha.h (VECTOR_MODE_SUPPORTED_P): New.\n        (PREDICATE_CODES): Update.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/alpha.md (UNSPEC_CMPBGE, UNSPEC_ZAP,\n        UNSPEC_AMASK, UNSPEC_IMPLVER, UNSPEC_PERR, UNSPECV_RPCC): New.\n        (movv8qi, movv8qi_fix, movv8qi_nofix): New.\n        (movv4hi, movv4hi_fix, movv4hi_nofix): New.\n        (movv2si, movv2si_fix, movv2si_nofix): New.\n        (uminv8qi3, sminv8qi3, uminv4hi3, sminv4hi3): New.\n        (umaxv8qi3, smaxv8qi3, umaxv4hi3, smaxv4hi3): New.\n        (builtin_cmpbge, builtin_extql, builtin_extqh, builtin_zap,\n        builtin_zap_1, builtin_zapnot, builtin_zapnot_1, builtin_amask,\n        builtin_implver, builtin_rpcc, builtin_minub8, builtin_minsb8,\n        builtin_minuw4, builtin_minsw4, builtin_maxub8, builtin_maxsb8,\n        builtin_maxuw4, builtin_maxsw4, builtin_perr, builtin_pklb,\n        pklb, builtin_pkwb, pkwb, builtin_unpkbl, unpkbl,\n        builtin_unpkbw, unpkbw): New.\n        * doc/extend.texi (Alpha Built-in Functions): New.\n\n        * gcc.dg/alpha-base-1.c, gcc.dg/alpha-base-2.c: New.\n        * gcc.dg/alpha-max-1.c, gcc.dg/alpha-max-2.c: New.\n\nFrom-SVN: r54229", "tree": {"sha": "746fbf6770987cdd4f33bdefab1d56212eff1733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/746fbf6770987cdd4f33bdefab1d56212eff1733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/comments", "author": null, "committer": null, "parents": [{"sha": "618939dec269cc6143e873f996d551ef9a319a2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618939dec269cc6143e873f996d551ef9a319a2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618939dec269cc6143e873f996d551ef9a319a2d"}], "stats": {"total": 1081, "additions": 1074, "deletions": 7}, "files": [{"sha": "fcbc473da404d6de4880179c8b251d11df245bdb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -1,3 +1,34 @@\n+2002-06-03  Falk Hueffner  <falk.hueffner@student.uni-tuebingen.de>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (reg_or_const_int_operand): New.\n+\t(some_operand, input_operand): Accept CONST_VECTOR.\n+\t(alpha_extra_constraint): Add 'W'.\n+\t(alpha_expand_zap_mask): New.\n+\t(alpha_expand_builtin_vector_binop): New.\n+\t(enum alpha_builtin): New.\n+\t(zero_arg_builtins, one_arg_builtins, two_arg_builtins): New.\n+\t(alpha_init_builtins, alpha_expand_builtin): New.\n+\t(TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN): New.\n+\t* config/alpha/alpha.h (VECTOR_MODE_SUPPORTED_P): New.\n+\t(PREDICATE_CODES): Update.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.md (UNSPEC_CMPBGE, UNSPEC_ZAP,\n+\tUNSPEC_AMASK, UNSPEC_IMPLVER, UNSPEC_PERR, UNSPECV_RPCC): New.\n+\t(movv8qi, movv8qi_fix, movv8qi_nofix): New.\n+\t(movv4hi, movv4hi_fix, movv4hi_nofix): New.\n+\t(movv2si, movv2si_fix, movv2si_nofix): New.\n+\t(uminv8qi3, sminv8qi3, uminv4hi3, sminv4hi3): New.\n+\t(umaxv8qi3, smaxv8qi3, umaxv4hi3, smaxv4hi3): New.\n+\t(builtin_cmpbge, builtin_extql, builtin_extqh, builtin_zap,\n+\tbuiltin_zap_1, builtin_zapnot, builtin_zapnot_1, builtin_amask,\n+\tbuiltin_implver, builtin_rpcc, builtin_minub8, builtin_minsb8,\n+\tbuiltin_minuw4, builtin_minsw4, builtin_maxub8, builtin_maxsb8,\n+\tbuiltin_maxuw4, builtin_maxsw4, builtin_perr, builtin_pklb,\n+\tpklb, builtin_pkwb, pkwb, builtin_unpkbl, unpkbl,\n+\tbuiltin_unpkbw, unpkbw): New.\n+\t* doc/extend.texi (Alpha Built-in Functions): New.\n+\n 2002-06-03  Richard Henderson  <rth@redhat.com>\n \n \t* crtstuff.c (__EH_FRAME_BEGIN__): Conditionalize on"}, {"sha": "8f5d2d828cef7abbe3e08df595b8ce005b15a07c", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -37,6 +37,7 @@ extern void alpha_output_lineno PARAMS ((FILE *, int));\n extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_6bit_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_8bit_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_const_int_operand PARAMS ((rtx, enum machine_mode));\n extern int cint8_operand PARAMS ((rtx, enum machine_mode));\n extern int add_operand PARAMS ((rtx, enum machine_mode));\n extern int sext_add_operand PARAMS ((rtx, enum machine_mode));\n@@ -122,6 +123,10 @@ extern void alpha_expand_unaligned_store PARAMS ((rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t\t HOST_WIDE_INT));\n extern int alpha_expand_block_move PARAMS ((rtx []));\n extern int alpha_expand_block_clear PARAMS ((rtx []));\n+extern rtx alpha_expand_zap_mask PARAMS ((HOST_WIDE_INT));\n+extern void alpha_expand_builtin_vector_binop PARAMS ((rtx (*)(rtx, rtx, rtx),\n+\t\t\t\t\t\t       enum machine_mode,\n+\t\t\t\t\t\t       rtx, rtx, rtx));\n extern rtx alpha_return_addr PARAMS ((int, rtx));\n extern rtx alpha_gp_save_rtx PARAMS ((void));\n extern void print_operand PARAMS ((FILE *, rtx, int));"}, {"sha": "ab02990241543ff0b77aef3865ff5a4d03122359", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 306, "deletions": 4, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -142,6 +142,10 @@ static void alpha_expand_unaligned_load_words\n   PARAMS ((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n static void alpha_expand_unaligned_store_words\n   PARAMS ((rtx *out_regs, rtx smem, HOST_WIDE_INT words, HOST_WIDE_INT ofs));\n+static void alpha_init_builtins\n+  PARAMS ((void));\n+static rtx alpha_expand_builtin\n+  PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n static void alpha_sa_mask\n   PARAMS ((unsigned long *imaskP, unsigned long *fmaskP));\n static int find_lo_sum\n@@ -278,6 +282,11 @@ static void unicosmk_unique_section PARAMS ((tree, int));\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS HAVE_AS_TLS\n \n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS alpha_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN alpha_expand_builtin\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Parse target option strings.  */\n@@ -610,6 +619,16 @@ reg_or_8bit_operand (op, mode)\n \t  || register_operand (op, mode));\n }\n \n+/* Return 1 if OP is a constant or any register.  */\n+\n+int\n+reg_or_const_int_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n+}\n+\n /* Return 1 if OP is an 8-bit constant.  */\n \n int\n@@ -813,8 +832,15 @@ some_operand (op, mode)\n \n   switch (GET_CODE (op))\n     {\n-    case REG:  case MEM:  case CONST_DOUBLE:  case CONST_INT:  case LABEL_REF:\n-    case SYMBOL_REF:  case CONST:  case HIGH:\n+    case REG:\n+    case MEM:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_VECTOR:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+    case HIGH:\n       return 1;\n \n     case SUBREG:\n@@ -893,7 +919,8 @@ input_operand (op, mode)\n \t      && general_operand (op, mode));\n \n     case CONST_DOUBLE:\n-      return GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode);\n+    case CONST_VECTOR:\n+      return op == CONST0_RTX (mode);\n \n     case CONST_INT:\n       return mode == QImode || mode == HImode || add_operand (op, mode);\n@@ -1615,7 +1642,9 @@ alpha_extra_constraint (value, c)\n       return GET_CODE (value) == HIGH;\n     case 'U':\n       return TARGET_ABI_UNICOSMK && symbolic_operand (value, VOIDmode);\n-\n+    case 'W':\n+      return (GET_CODE (value) == CONST_VECTOR\n+\t      && value == CONST0_RTX (GET_MODE (value)));\n     default:\n       return false;\n     }\n@@ -5147,6 +5176,74 @@ alpha_expand_block_clear (operands)\n \n   return 1;\n }\n+\n+/* Returns a mask so that zap(x, value) == x & mask.  */\n+\n+rtx\n+alpha_expand_zap_mask (value)\n+     HOST_WIDE_INT value;\n+{\n+  rtx result;\n+  int i;\n+\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    {\n+      HOST_WIDE_INT mask = 0;\n+\n+      for (i = 7; i >= 0; --i)\n+\t{\n+\t  mask <<= 8;\n+\t  if (!((value >> i) & 1))\n+\t    mask |= 0xff;\n+\t}\n+\n+      result = gen_int_mode (mask, DImode);\n+    }\n+  else if (HOST_BITS_PER_WIDE_INT == 32)\n+    {\n+      HOST_WIDE_INT mask_lo = 0, mask_hi = 0;\n+\n+      for (i = 7; i >= 4; --i)\n+\t{\n+\t  mask_hi <<= 8;\n+\t  if (!((value >> i) & 1))\n+\t    mask_hi |= 0xff;\n+\t}\n+\n+      for (i = 3; i >= 0; --i)\n+\t{\n+\t  mask_lo <<= 8;\n+\t  if (!((value >> i) & 1))\n+\t    mask_lo |= 0xff;\n+\t}\n+\n+      result = immed_double_const (mask_lo, mask_hi, DImode);\n+    }\n+  else\n+    abort ();\n+\n+  return result;\n+}\n+\n+void\n+alpha_expand_builtin_vector_binop (gen, mode, op0, op1, op2)\n+     rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+     enum machine_mode mode;\n+     rtx op0, op1, op2;\n+{\n+  op0 = gen_lowpart (mode, op0);\n+\n+  if (op1 == const0_rtx)\n+    op1 = CONST0_RTX (mode);\n+  else\n+    op1 = gen_lowpart (mode, op1);\n+  if (op1 == const0_rtx)\n+    op2 = CONST0_RTX (mode);\n+  else\n+    op2 = gen_lowpart (mode, op2);\n+\n+  emit_insn ((*gen) (op0, op1, op2));\n+}\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n@@ -6261,6 +6358,211 @@ alpha_va_arg (valist, type)\n   return addr;\n }\n \f\n+/* Builtins.  */\n+\n+enum alpha_builtin\n+{\n+  ALPHA_BUILTIN_CMPBGE,\n+  ALPHA_BUILTIN_EXTQL,\n+  ALPHA_BUILTIN_EXTQH,\n+  ALPHA_BUILTIN_ZAP,\n+  ALPHA_BUILTIN_ZAPNOT,\n+  ALPHA_BUILTIN_AMASK,\n+  ALPHA_BUILTIN_IMPLVER,\n+  ALPHA_BUILTIN_RPCC,\n+\n+  /* TARGET_MAX */\n+  ALPHA_BUILTIN_MINUB8,\n+  ALPHA_BUILTIN_MINSB8,\n+  ALPHA_BUILTIN_MINUW4,\n+  ALPHA_BUILTIN_MINSW4,\n+  ALPHA_BUILTIN_MAXUB8,\n+  ALPHA_BUILTIN_MAXSB8,\n+  ALPHA_BUILTIN_MAXUW4,\n+  ALPHA_BUILTIN_MAXSW4,\n+  ALPHA_BUILTIN_PERR,\n+  ALPHA_BUILTIN_PKLB,\n+  ALPHA_BUILTIN_PKWB,\n+  ALPHA_BUILTIN_UNPKBL,\n+  ALPHA_BUILTIN_UNPKBW,\n+\n+  ALPHA_BUILTIN_max\n+};\n+\n+struct alpha_builtin_def\n+{\n+  const char *name;\n+  enum alpha_builtin code;\n+  unsigned int target_mask;\n+};\n+\n+static struct alpha_builtin_def const zero_arg_builtins[] = {\n+  { \"__builtin_alpha_implver\",\tALPHA_BUILTIN_IMPLVER,\t0 },\n+  { \"__builtin_alpha_rpcc\",\tALPHA_BUILTIN_RPCC,\t0 }\n+};\n+\n+static struct alpha_builtin_def const one_arg_builtins[] = {\n+  { \"__builtin_alpha_amask\",\tALPHA_BUILTIN_AMASK,\t0 },\n+  { \"__builtin_alpha_pklb\",\tALPHA_BUILTIN_PKLB,\tMASK_MAX },\n+  { \"__builtin_alpha_pkwb\",\tALPHA_BUILTIN_PKWB,\tMASK_MAX },\n+  { \"__builtin_alpha_unpkbl\",\tALPHA_BUILTIN_UNPKBL,\tMASK_MAX },\n+  { \"__builtin_alpha_unpkbw\",\tALPHA_BUILTIN_UNPKBW,\tMASK_MAX }\n+};\n+\n+static struct alpha_builtin_def const two_arg_builtins[] = {\n+  { \"__builtin_alpha_cmpbge\",\tALPHA_BUILTIN_CMPBGE,\t0 },\n+  { \"__builtin_alpha_extql\",\tALPHA_BUILTIN_EXTQL,\t0 },\n+  { \"__builtin_alpha_extqh\",\tALPHA_BUILTIN_EXTQH,\t0 },\n+  { \"__builtin_alpha_zap\",\tALPHA_BUILTIN_ZAP,\t0 },\n+  { \"__builtin_alpha_zapnot\",\tALPHA_BUILTIN_ZAPNOT,\t0 },\n+  { \"__builtin_alpha_minub8\",\tALPHA_BUILTIN_MINUB8,\tMASK_MAX },\n+  { \"__builtin_alpha_minsb8\",\tALPHA_BUILTIN_MINSB8,\tMASK_MAX },\n+  { \"__builtin_alpha_minuw4\",\tALPHA_BUILTIN_MINUW4,\tMASK_MAX },\n+  { \"__builtin_alpha_minsw4\",\tALPHA_BUILTIN_MINSW4,\tMASK_MAX },\n+  { \"__builtin_alpha_maxub8\",\tALPHA_BUILTIN_MAXUB8,\tMASK_MAX },\n+  { \"__builtin_alpha_maxsb8\",\tALPHA_BUILTIN_MAXSB8,\tMASK_MAX },\n+  { \"__builtin_alpha_maxuw4\",\tALPHA_BUILTIN_MAXUW4,\tMASK_MAX },\n+  { \"__builtin_alpha_maxsw4\",\tALPHA_BUILTIN_MAXSW4,\tMASK_MAX },\n+  { \"__builtin_alpha_perr\",\tALPHA_BUILTIN_PERR,\tMASK_MAX }\n+};\n+\n+static void\n+alpha_init_builtins ()\n+{\n+  const struct alpha_builtin_def *p;\n+  tree ftype;\n+  size_t i;\n+\n+  ftype = build_function_type (long_integer_type_node, void_list_node);\n+\n+  p = zero_arg_builtins;\n+  for (i = 0; i < ARRAY_SIZE (zero_arg_builtins); ++i, ++p)\n+    if ((target_flags & p->target_mask) == p->target_mask)\n+      builtin_function (p->name, ftype, p->code, BUILT_IN_MD, NULL);\n+\n+  ftype = build_function_type (long_integer_type_node,\n+\t\t\t       tree_cons (NULL_TREE,\n+\t\t\t\t\t  long_integer_type_node,\n+\t\t\t\t\t  void_list_node));\n+\n+  p = one_arg_builtins;\n+  for (i = 0; i < ARRAY_SIZE (one_arg_builtins); ++i, ++p)\n+    if ((target_flags & p->target_mask) == p->target_mask)\n+      builtin_function (p->name, ftype, p->code, BUILT_IN_MD, NULL);\n+\n+  ftype = build_function_type (long_integer_type_node,\n+\t\t\t       tree_cons (NULL_TREE,\n+\t\t\t\t\t  long_integer_type_node,\n+\t\t\t\t\t  tree_cons (NULL_TREE,\n+\t\t\t\t\t\t     long_integer_type_node,\n+\t\t\t\t\t\t     void_list_node)));\n+\n+  p = two_arg_builtins;\n+  for (i = 0; i < ARRAY_SIZE (two_arg_builtins); ++i, ++p)\n+    if ((target_flags & p->target_mask) == p->target_mask)\n+      builtin_function (p->name, ftype, p->code, BUILT_IN_MD, NULL);\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+alpha_expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n+{\n+  static unsigned int const code_for_builtin[ALPHA_BUILTIN_max] = {\n+    CODE_FOR_builtin_cmpbge,\n+    CODE_FOR_builtin_extql,\n+    CODE_FOR_builtin_extqh,\n+    CODE_FOR_builtin_zap,\n+    CODE_FOR_builtin_zapnot,\n+    CODE_FOR_builtin_amask,\n+    CODE_FOR_builtin_implver,\n+    CODE_FOR_builtin_rpcc,\n+    CODE_FOR_builtin_minub8,\n+    CODE_FOR_builtin_minsb8,\n+    CODE_FOR_builtin_minuw4,\n+    CODE_FOR_builtin_minsw4,\n+    CODE_FOR_builtin_maxub8,\n+    CODE_FOR_builtin_maxsb8,\n+    CODE_FOR_builtin_maxuw4,\n+    CODE_FOR_builtin_maxsw4,\n+    CODE_FOR_builtin_perr,\n+    CODE_FOR_builtin_pklb,\n+    CODE_FOR_builtin_pkwb,\n+    CODE_FOR_builtin_unpkbl,\n+    CODE_FOR_builtin_unpkbw,\n+  };\n+\n+#define MAX_ARGS 2\n+\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum insn_code icode;\n+  rtx op[MAX_ARGS], pat;\n+  int arity;\n+  enum machine_mode tmode;\n+\n+  if (fcode >= ALPHA_BUILTIN_max)\n+    internal_error (\"bad builtin fcode\");\n+  icode = code_for_builtin[fcode];\n+  if (icode == 0)\n+    internal_error (\"bad builtin fcode\");\n+\n+  for (arglist = TREE_OPERAND (exp, 1), arity = 0;\n+       arglist;\n+       arglist = TREE_CHAIN (arglist), arity++)\n+    {\n+      const struct insn_operand_data *insn_op;\n+\n+      tree arg = TREE_VALUE (arglist);\n+      if (arg == error_mark_node)\n+\treturn NULL_RTX;\n+      if (arity > MAX_ARGS)\n+\treturn NULL_RTX;\n+\n+      op[arity] = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n+\n+      insn_op = &insn_data[icode].operand[arity];\n+      if (!(*insn_op->predicate) (op[arity], insn_op->mode))\n+\top[arity] = copy_to_mode_reg (insn_op->mode, op[arity]);\n+    }\n+\n+  tmode = insn_data[icode].operand[0].mode;\n+  if (!target\n+      || GET_MODE (target) != tmode\n+      || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  switch (arity)\n+    {\n+    case 0:\n+      pat = GEN_FCN (icode) (target);\n+      break;\n+    case 1:\n+      pat = GEN_FCN (icode) (target, op[0]);\n+      break;\n+    case 2:\n+      pat = GEN_FCN (icode) (target, op[0], op[1]);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (!pat)\n+    return NULL_RTX;\n+  emit_insn (pat);\n+\n+  return target;\n+}\n+\f\n /* This page contains routines that are used to determine what the function\n    prologue and epilogue code will do and write them out.  */\n "}, {"sha": "8d47493c2e49236493b09197779c0f352e9d4cf4", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -615,6 +615,12 @@ extern const char *alpha_tls_size_string; /* For -mtls-size= */\n    ? GET_MODE_UNIT_SIZE (MODE) == 8 || GET_MODE_UNIT_SIZE (MODE) == 4\t\\\n    : 1)\n \n+/* Value is 1 if MODE is a supported vector mode.  */\n+\n+#define VECTOR_MODE_SUPPORTED_P(MODE) \\\n+  (TARGET_MAX \\\n+   && ((MODE) == V8QImode || (MODE) == V4HImode || (MODE) == V2SImode))\n+\n /* A C expression that is nonzero if a value of mode\n    MODE1 is accessible in mode MODE2 without copying.\n \n@@ -789,7 +795,9 @@ enum reg_class {\n \n    'T' is a HIGH.\n \n-   'U' is a symbolic operand.  */\n+   'U' is a symbolic operand.\n+\n+   'W' is a vector zero.   */\n \n #define EXTRA_CONSTRAINT  alpha_extra_constraint\n \n@@ -1923,6 +1931,7 @@ do {\t\t\t\t\t\t\\\n \t\t\tCONST_VECTOR}},\t\t\t\t\t\\\n   {\"reg_or_6bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"reg_or_const_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"cint8_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n@@ -1953,9 +1962,9 @@ do {\t\t\t\t\t\t\\\n   {\"gottp_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n   {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\t\\\n   {\"input_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\t\\\n+\t\t     CONST_VECTOR, SYMBOL_REF, CONST, LABEL_REF, HIGH}},\\\n   {\"some_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t    SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\t\\\n+\t\t    CONST_VECTOR, SYMBOL_REF, CONST, LABEL_REF, HIGH}},\t\\\n   {\"some_ni_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n   {\"aligned_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"unaligned_memory_operand\", {MEM}},\t\t\t\t\t\\"}, {"sha": "a63ba9ce53396f6008fa87ed254e6685bf936f1b", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 587, "deletions": 0, "changes": 587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -49,6 +49,13 @@\n    (UNSPEC_DTPREL\t19)\n    (UNSPEC_TPREL\t20)\n    (UNSPEC_TP\t\t21)\n+\n+   ;; Builtins\n+   (UNSPEC_CMPBGE\t22)\n+   (UNSPEC_ZAP\t\t23)\n+   (UNSPEC_AMASK\t24)\n+   (UNSPEC_IMPLVER\t25)\n+   (UNSPEC_PERR\t\t26)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -67,6 +74,7 @@\n    (UNSPECV_LDGP1\t10)\n    (UNSPECV_PLDGP2\t11)\t; prologue ldgp\n    (UNSPECV_SET_TP\t12)\n+   (UNSPECV_RPCC\t13)\n   ])\n \n ;; Where necessary, the suffixes _le and _be are used to distinguish between\n@@ -6111,6 +6119,195 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   DONE;\n })\n \f\n+;; Vector operations\n+\n+(define_expand \"movv8qi\"\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V8QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (alpha_expand_mov (V8QImode, operands))\n+    DONE;\n+})\n+\n+(define_insn \"*movv8qi_fix\"\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m,r,*f\")\n+\t(match_operand:V8QI 1 \"input_operand\" \"rW,m,rW,*fW,m,*f,*f,r\"))]\n+  \"TARGET_FIX\n+   && (register_operand (operands[0], V8QImode)\n+       || reg_or_0_operand (operands[1], V8QImode))\"\n+  \"@\n+   bis $31,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %R1,%R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\n+   ftoit %1,%0\n+   itoft %1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+\n+(define_insn \"*movv8qi_nofix\"\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m\")\n+\t(match_operand:V8QI 1 \"input_operand\" \"rW,m,rW,*fW,m,*f\"))]\n+  \"! TARGET_FIX\n+   && (register_operand (operands[0], V8QImode)\n+       || reg_or_0_operand (operands[1], V8QImode))\"\n+  \"@\n+   bis $31,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %R1,%R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst\")])\n+\n+(define_expand \"movv4hi\"\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V4HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (alpha_expand_mov (V4HImode, operands))\n+    DONE;\n+})\n+\n+(define_insn \"*movv4hi_fix\"\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m,r,*f\")\n+\t(match_operand:V4HI 1 \"input_operand\" \"rW,m,rW,*fW,m,*f,*f,r\"))]\n+  \"TARGET_FIX\n+   && (register_operand (operands[0], V4HImode)\n+       || reg_or_0_operand (operands[1], V4HImode))\"\n+  \"@\n+   bis $31,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %R1,%R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\n+   ftoit %1,%0\n+   itoft %1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+\n+(define_insn \"*movv4hi_nofix\"\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m\")\n+\t(match_operand:V4HI 1 \"input_operand\" \"rW,m,rW,*fW,m,*f\"))]\n+  \"! TARGET_FIX\n+   && (register_operand (operands[0], V4HImode)\n+       || reg_or_0_operand (operands[1], V4HImode))\"\n+  \"@\n+   bis $31,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %R1,%R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst\")])\n+\n+(define_expand \"movv2si\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:V2SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (alpha_expand_mov (V2SImode, operands))\n+    DONE;\n+})\n+\n+(define_insn \"*movv2si_fix\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m,r,*f\")\n+\t(match_operand:V2SI 1 \"input_operand\" \"rW,m,rW,*fW,m,*f,*f,r\"))]\n+  \"TARGET_FIX\n+   && (register_operand (operands[0], V2SImode)\n+       || reg_or_0_operand (operands[1], V2SImode))\"\n+  \"@\n+   bis $31,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %R1,%R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\n+   ftoit %1,%0\n+   itoft %1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+\n+(define_insn \"*movv2si_nofix\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m\")\n+\t(match_operand:V2SI 1 \"input_operand\" \"rW,m,rW,*fW,m,*f\"))]\n+  \"! TARGET_FIX\n+   && (register_operand (operands[0], V2SImode)\n+       || reg_or_0_operand (operands[1], V2SImode))\"\n+  \"@\n+   bis $31,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %R1,%R1,%0\n+   ldt %0,%1\n+   stt %R1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst\")])\n+\n+(define_insn \"uminv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(umin:V8QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V8QI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"minub8 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"sminv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(smin:V8QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V8QI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"minsb8 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"uminv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(umin:V4HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V4HI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"minuw4 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"sminv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(smin:V4HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V4HI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"minsw4 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"umaxv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(umax:V8QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V8QI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"maxub8 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"smaxv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(smax:V8QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V8QI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"maxsb8 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"umaxv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(umax:V4HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V4HI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"maxuw4 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_insn \"smaxv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(smax:V4HI (match_operand:V4HI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t   (match_operand:V4HI 2 \"reg_or_0_operand\" \"rW\")))]\n+  \"TARGET_MAX\"\n+  \"maxsw4 %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\f\n ;; Bit field extract patterns which use ext[wlq][lh]\n \n (define_expand \"extv\"\n@@ -6779,7 +6976,397 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi,none\"\n   else\n     return \".align %0 #realign\";\n })\n+\f\n+;; Instructions to be emitted from __builtins.\n+\n+(define_insn \"builtin_cmpbge\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t    (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")]\n+\t\t   UNSPEC_CMPBGE))]\n+  \"\"\n+  \"cmpbge %r1,%2,%0\"\n+  ;; The EV6 data sheets list this as ILOG.  OTOH, EV6 doesn't \n+  ;; actually differentiate between ILOG and ICMP in the schedule.\n+  [(set_attr \"type\" \"icmp\")])\n+\n+(define_expand \"builtin_extql\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n+  \"\"\n+{\n+  rtx (*gen) PARAMS ((rtx, rtx, rtx, rtx));\n+  if (WORDS_BIG_ENDIAN)\n+    gen = gen_extxl_be;\n+  else\n+    gen = gen_extxl_le;\n+  emit_insn ((*gen) (operands[0], operands[1], GEN_INT (64), operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"builtin_extqh\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_8bit_operand\" \"\")]\n+  \"\"\n+{\n+  rtx (*gen) PARAMS ((rtx, rtx, rtx));\n+  if (WORDS_BIG_ENDIAN)\n+    gen = gen_extqh_be;\n+  else\n+    gen = gen_extqh_le;\n+  emit_insn ((*gen) (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n \n+(define_expand \"builtin_zap\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (unspec:DI\n+\t\t  [(match_operand:DI 2 \"reg_or_const_int_operand\" \"\")]\n+\t\t  UNSPEC_ZAP)\n+\t\t(match_operand:DI 1 \"reg_or_const_int_operand\" \"\")))]\n+  \"\"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      rtx mask = alpha_expand_zap_mask (INTVAL (operands[2]));\n+\n+      if (operands[1] == const0_rtx)\n+\t{\n+\t  emit_move_insn (operands[0], const0_rtx);\n+\t  DONE;\n+\t}\n+      if (operands[1] == constm1_rtx)\n+\t{\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  DONE;\n+\t}\n+\n+      operands[1] = force_reg (DImode, operands[1]);\n+      emit_insn (gen_anddi3 (operands[0], operands[1], mask));\n+      DONE;\n+    }\n+\n+  operands[1] = force_reg (DImode, operands[1]);\n+  operands[2] = gen_lowpart (QImode, operands[2]);\n+})\n+\n+(define_insn \"*builtin_zap_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(and:DI (unspec:DI\n+\t\t  [(match_operand:QI 2 \"reg_or_const_int_operand\" \"n,n,r,r\")]\n+\t\t  UNSPEC_ZAP)\n+\t\t(match_operand:DI 1 \"reg_or_const_int_operand\" \"n,r,J,r\")))]\n+  \"\"\n+  \"@\n+   #\n+   #\n+   bis $31,$31,%0\n+   zap %r1,%2,%0\"\n+  [(set_attr \"type\" \"shift,shift,ilog,shift\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (unspec:DI\n+\t\t  [(match_operand:QI 2 \"const_int_operand\" \"\")]\n+\t\t  UNSPEC_ZAP)\n+\t\t(match_operand:DI 1 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  rtx mask = alpha_expand_zap_mask (INTVAL (operands[2]));\n+  if (HOST_BITS_PER_WIDE_INT >= 64 || GET_CODE (mask) == CONST_INT)\n+    operands[1] = gen_int_mode (INTVAL (operands[1]) & INTVAL (mask), DImode);\n+  else\n+    {\n+      HOST_WIDE_INT c_lo = INTVAL (operands[1]);\n+      HOST_WIDE_INT c_hi = (c_lo < 0 ? -1 : 0);\n+      operands[1] = immed_double_const (c_lo & CONST_DOUBLE_LOW (mask),\n+\t\t\t\t\tc_hi & CONST_DOUBLE_HIGH (mask),\n+\t\t\t\t\tDImode);\n+    }\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (unspec:DI\n+\t\t  [(match_operand:QI 2 \"const_int_operand\" \"\")]\n+\t\t  UNSPEC_ZAP)\n+\t\t(match_operand:DI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 0)\n+\t(and:DI (match_dup 1) (match_dup 2)))]\n+{\n+  operands[2] = alpha_expand_zap_mask (INTVAL (operands[2]));\n+  if (operands[2] == const0_rtx)\n+    {\n+      emit_move_insn (operands[0], const0_rtx);\n+      DONE;\n+    }\n+  if (operands[2] == constm1_rtx)\n+    {\n+      emit_move_insn (operands[0], operands[1]);\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"builtin_zapnot\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (unspec:DI\n+\t\t  [(not:QI (match_operand:QI 2 \"reg_or_const_int_operand\" \"\"))]\n+\t\t  UNSPEC_ZAP)\n+\t\t(match_operand:DI 1 \"reg_or_const_int_operand\" \"\")))]\n+  \"\"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      rtx mask = alpha_expand_zap_mask (~ INTVAL (operands[2]));\n+\n+      if (operands[1] == const0_rtx)\n+\t{\n+\t  emit_move_insn (operands[0], const0_rtx);\n+\t  DONE;\n+\t}\n+      if (operands[1] == constm1_rtx)\n+\t{\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  DONE;\n+\t}\n+\n+      operands[1] = force_reg (DImode, operands[1]);\n+      emit_insn (gen_anddi3 (operands[0], operands[1], mask));\n+      DONE;\n+    }\n+\n+  operands[1] = force_reg (DImode, operands[1]);\n+  operands[2] = gen_lowpart (QImode, operands[2]);\n+})\n+\n+(define_insn \"*builtin_zapnot_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (unspec:DI\n+                  [(not:QI (match_operand:QI 2 \"register_operand\" \"r\"))]\n+                  UNSPEC_ZAP)\n+\t\t(match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")))]\n+  \"\"\n+  \"zapnot %r1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"builtin_amask\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"reg_or_8bit_operand\" \"rI\")]\n+\t\t   UNSPEC_AMASK))]\n+  \"\"\n+  \"amask %1,%0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n+(define_insn \"builtin_implver\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+  \t(unspec:DI [(const_int 0)] UNSPEC_IMPLVER))]\n+  \"\"\n+  \"implver %0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n+(define_insn \"builtin_rpcc\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+  \t(unspec_volatile:DI [(const_int 0)] UNSPECV_RPCC))]\n+  \"\"\n+  \"rpcc %0\"\n+  [(set_attr \"type\" \"ilog\")])\n+\n+(define_expand \"builtin_minub8\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_uminv8qi3, V8QImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_minsb8\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_sminv8qi3, V8QImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_minuw4\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_uminv4hi3, V4HImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_minsw4\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_sminv4hi3, V4HImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_maxub8\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_umaxv8qi3, V8QImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_maxsb8\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_smaxv8qi3, V8QImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_maxuw4\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_umaxv4hi3, V4HImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_expand \"builtin_maxsw4\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"reg_or_0_operand\" \"\")\n+   (match_operand:DI 2 \"reg_or_0_operand\" \"\")]\n+  \"TARGET_MAX\"\n+{\n+  alpha_expand_builtin_vector_binop (gen_smaxv4hi3, V4HImode, operands[0],\n+\t\t\t\t     operands[1], operands[2]);\n+  DONE;\n+})\n+\n+(define_insn \"builtin_perr\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"reg_or_0_operand\" \"%rJ\")\n+\t\t    (match_operand:DI 2 \"reg_or_8bit_operand\" \"rJ\")]\n+\t\t   UNSPEC_PERR))]\n+  \"TARGET_MAX\"\n+  \"perr %r1,%r2,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_expand \"builtin_pklb\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(vec_concat:V8QI\n+\t  (vec_concat:V4QI\n+\t    (truncate:V2QI (match_operand:DI 1 \"register_operand\" \"\"))\n+\t    (match_dup 2))\n+\t  (match_dup 3)))]\n+  \"TARGET_MAX\"\n+{\n+  operands[0] = gen_lowpart (V8QImode, operands[0]);\n+  operands[1] = gen_lowpart (V2SImode, operands[1]);\n+  operands[2] = CONST0_RTX (V2QImode);\n+  operands[3] = CONST0_RTX (V4QImode);\n+})\n+\n+(define_insn \"*pklb\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")\n+\t(vec_concat:V8QI\n+\t  (vec_concat:V4QI\n+\t    (truncate:V2QI (match_operand:V2SI 1 \"register_operand\" \"r\"))\n+\t    (match_operand:V2QI 2 \"const0_operand\" \"\"))\n+\t  (match_operand:V4QI 3 \"const0_operand\" \"\")))]\n+  \"TARGET_MAX\"\n+  \"pklb %r1,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_expand \"builtin_pkwb\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(vec_concat:V8QI\n+\t  (truncate:V4QI (match_operand:DI 1 \"register_operand\" \"\"))\n+\t  (match_dup 2)))]\n+  \"TARGET_MAX\"\n+{\n+  operands[0] = gen_lowpart (V8QImode, operands[0]);\n+  operands[1] = gen_lowpart (V4HImode, operands[1]);\n+  operands[2] = CONST0_RTX (V4QImode);\n+})\n+\n+(define_insn \"*pkwb\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"\")\n+\t(vec_concat:V8QI\n+\t  (truncate:V4QI (match_operand:V4HI 1 \"register_operand\" \"\"))\n+\t  (match_operand:V4QI 2 \"const0_operand\" \"\")))]\n+  \"TARGET_MAX\"\n+  \"pkwb %r1,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_expand \"builtin_unpkbl\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:V2SI\n+\t  (vec_select:V2QI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t   (parallel [(const_int 0) (const_int 1)]))))]\n+  \"TARGET_MAX\"\n+{\n+  operands[0] = gen_lowpart (V2SImode, operands[0]);\n+  operands[1] = gen_lowpart (V8QImode, operands[1]);\n+})\n+\n+(define_insn \"*unpkbl\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:V2SI\n+\t  (vec_select:V2QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t\t   (parallel [(const_int 0) (const_int 1)]))))]\n+  \"TARGET_MAX\"\n+  \"unpkbl %r1,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\n+(define_expand \"builtin_unpkbw\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:V4HI\n+\t  (vec_select:V4QI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t\t   (parallel [(const_int 0)\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 3)]))))]\n+  \"TARGET_MAX\"\n+{\n+  operands[0] = gen_lowpart (V4HImode, operands[0]);\n+  operands[1] = gen_lowpart (V8QImode, operands[1]);\n+})\n+\n+(define_insn \"*unpkbw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:V4HI\n+\t  (vec_select:V4QI (match_operand:V8QI 1 \"reg_or_0_operand\" \"rW\")\n+\t\t\t   (parallel [(const_int 0)\n+\t\t\t\t      (const_int 1)\n+\t\t\t\t      (const_int 2)\n+\t\t\t\t      (const_int 3)]))))]\n+  \"TARGET_MAX\"\n+  \"unpkbw %r1,%0\"\n+  [(set_attr \"type\" \"mvi\")])\n+\f\n ;; The call patterns are at the end of the file because their\n ;; wildcard operand0 interferes with nice recognition.\n "}, {"sha": "88786e4b144f6a97e133e0a5fc0a4b105d9110a6", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -4754,10 +4754,52 @@ to those machines.  Generally these generate calls to specific machine\n instructions, but allow the compiler to schedule those calls.\n \n @menu\n+* Alpha Built-in Functions::\n * X86 Built-in Functions::\n * PowerPC AltiVec Built-in Functions::\n @end menu\n \n+@node Alpha Built-in Functions\n+@subsection Alpha Built-in Functions\n+\n+These built-in functions are available for the Alpha family of\n+processors, depending on the command-line switches used.\n+\n+The following built-in functions are always available.  They \n+all generate the machine instruction that is part of the name.\n+\n+@example\n+long __builtin_alpha_implver (void)\n+long __builtin_alpha_rpcc (void)\n+long __builtin_alpha_amask (long)\n+long __builtin_alpha_cmpbge (long, long)\n+long __builtin_alpha_extql (long, long)\n+long __builtin_alpha_extqh (long, long)\n+long __builtin_alpha_zap (long, long)\n+long __builtin_alpha_zapnot (long, long)\n+@end example\n+\n+The following built-in functions are always with @option{-mmax}\n+or @option{-mcpu=@var{cpu}} where @var{cpu} is @code{pca56} or\n+later.  They all generate the machine instruction that is part\n+of the name.\n+\n+@example\n+long __builtin_alpha_pklb (long)\n+long __builtin_alpha_pkwb (long)\n+long __builtin_alpha_unpkbl (long)\n+long __builtin_alpha_unpkbw (long)\n+long __builtin_alpha_minub8 (long, long)\n+long __builtin_alpha_minsb8 (long, long)\n+long __builtin_alpha_minuw4 (long, long)\n+long __builtin_alpha_minsw4 (long, long)\n+long __builtin_alpha_maxub8 (long, long)\n+long __builtin_alpha_maxsb8 (long, long)\n+long __builtin_alpha_maxuw4 (long, long)\n+long __builtin_alpha_maxsw4 (long, long)\n+long __builtin_alpha_perr (long, long)\n+@end example\n+\n @node X86 Built-in Functions\n @subsection X86 Built-in Functions\n "}, {"sha": "87b8d1c132678ba84afba342aafd952a1fec7cec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -1,3 +1,8 @@\n+2002-06-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/alpha-base-1.c, gcc.dg/alpha-base-2.c: New.\n+\t* gcc.dg/alpha-max-1.c, gcc.dg/alpha-max-2.c: New.\n+\n 2002-06-02  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.c-torture/execute/pure-1.c: Don't mark any of the "}, {"sha": "bca7409f44b1f741509f8b2aa822b71b8f62d0b5", "filename": "gcc/testsuite/gcc.dg/alpha-base-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-base-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-base-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-base-1.c?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -0,0 +1,49 @@\n+/* Test that the base isa builtins compile.  */\n+/* { dg-do link { target alpha*-*-* } } */\n+/* { dg-options \"-mcpu=ev4\" } */\n+\n+void test_BASE (long x, long y)\n+{\n+  volatile long sink;\n+  long z;\n+\n+  sink = __builtin_alpha_implver ();\n+  sink = __builtin_alpha_rpcc ();\n+\n+  sink = __builtin_alpha_amask (-1);\n+  sink = __builtin_alpha_amask (x);\n+\n+  sink = __builtin_alpha_cmpbge (x, y);\n+  sink = __builtin_alpha_cmpbge (-1, x);\n+  sink = __builtin_alpha_extql (x, y);\n+  sink = __builtin_alpha_extqh (x, y);\n+}\n+\n+void test_zap (long x, long y)\n+{\n+  volatile long sink;\n+  long z;\n+  sink = __builtin_alpha_zap (x, y);\n+  sink = __builtin_alpha_zap (x, 0xaa);\n+  z = 0xaa;\n+  sink = __builtin_alpha_zap (x, z);\n+  z = 0;\n+  sink = __builtin_alpha_zap (z, x);\n+  sink = __builtin_alpha_zap (x, z);\n+}\n+\n+void test_zapnot (long x, long y)\n+{\n+  volatile long sink;\n+  long z;\n+\n+  sink = __builtin_alpha_zapnot (x, y);\n+  sink = __builtin_alpha_zapnot (x, 0xaa);\n+  z = 0xaa;\n+  sink = __builtin_alpha_zapnot (x, z);\n+  z = 0;\n+  sink = __builtin_alpha_zapnot (z, x);\n+  sink = __builtin_alpha_zapnot (x, z);\n+}\n+\n+int main() { return 0; }"}, {"sha": "895cdb0a98c7f65fefbc7b0e57c2176eddc8c2b8", "filename": "gcc/testsuite/gcc.dg/alpha-base-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-base-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-base-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-base-2.c?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -0,0 +1,5 @@\n+/* Test that alpha-base-1.c compiles with optimization.  */\n+/* { dg-do link { target alpha*-*-* } } */\n+/* { dg-options \"-mcpu=ev4 -O2\" } */\n+\n+#include \"alpha-base-1.c\""}, {"sha": "5d670e673af3dc8bd1ea04717712c800eb97bc36", "filename": "gcc/testsuite/gcc.dg/alpha-max-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-max-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-max-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-max-1.c?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -0,0 +1,27 @@\n+/* Test that the MAX isa builtins compile.  */\n+/* { dg-do link { target alpha*-*-* } } */\n+/* { dg-options \"-mmax\" } */\n+\n+void test_MAX (long x, long y)\n+{\n+  volatile long sink;\n+\n+  sink = __builtin_alpha_pklb (x);\n+  sink = __builtin_alpha_pkwb (x);\n+  sink = __builtin_alpha_unpkbl (x);\n+  sink = __builtin_alpha_unpkbw (x);\n+\n+  sink = __builtin_alpha_minub8 (0, x);\n+  sink = __builtin_alpha_minub8 (1, x);\n+  sink = __builtin_alpha_minub8 (x, y);\n+  sink = __builtin_alpha_minsb8 (x, y);\n+  sink = __builtin_alpha_minuw4 (x, y);\n+  sink = __builtin_alpha_minsw4 (x, y);\n+  sink = __builtin_alpha_maxub8 (x, y);\n+  sink = __builtin_alpha_maxsb8 (x, y);\n+  sink = __builtin_alpha_maxuw4 (x, y);\n+  sink = __builtin_alpha_maxsw4 (x, y);\n+  sink = __builtin_alpha_perr (x, y);\n+}\n+\n+int main() { return 0; }"}, {"sha": "5e1ea0528cc1db75686f2c8a3e3ef4e6427b72cc", "filename": "gcc/testsuite/gcc.dg/alpha-max-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-max-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-max-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falpha-max-2.c?ref=6d8fd7bbd7f1fa8a0b985e3cd0e2120143d4d557", "patch": "@@ -0,0 +1,5 @@\n+/* Test that alpha-max-1.c compiles with optimization.  */\n+/* { dg-do link { target alpha*-*-* } } */\n+/* { dg-options \"-mmax -O2\" } */\n+\n+#include \"alpha-max-1.c\""}]}