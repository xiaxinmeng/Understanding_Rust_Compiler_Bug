{"sha": "65a550b46e5d9759fae0e5af17a494e1f9f5d821", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVhNTUwYjQ2ZTVkOTc1OWZhZTBlNWFmMTdhNDk0ZTFmOWY1ZDgyMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-07-08T20:25:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-07-08T20:25:38Z"}, "message": "P0145R2: Refining Expression Order for C++ (assignment 2).\n\n\t* cp-gimplify.c (lvalue_has_side_effects): New.\n\t(cp_gimplify_expr): Implement assignment ordering.\n\nFrom-SVN: r238177", "tree": {"sha": "8707e60263a18e96bb37bf0ec77d166f7960e5f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8707e60263a18e96bb37bf0ec77d166f7960e5f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65a550b46e5d9759fae0e5af17a494e1f9f5d821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a550b46e5d9759fae0e5af17a494e1f9f5d821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65a550b46e5d9759fae0e5af17a494e1f9f5d821", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a550b46e5d9759fae0e5af17a494e1f9f5d821/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0cf395a999499cfdc785cdb920bfdf401a628aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cf395a999499cfdc785cdb920bfdf401a628aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cf395a999499cfdc785cdb920bfdf401a628aa"}], "stats": {"total": 98, "additions": 94, "deletions": 4}, "files": [{"sha": "0d6ce94a4db98fda4d185f8281ee0e76f268fd03", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=65a550b46e5d9759fae0e5af17a494e1f9f5d821", "patch": "@@ -1,6 +1,8 @@\n 2016-07-08  Jason Merrill  <jason@redhat.com>\n \n \tP0145R2: Refining Expression Order for C++.\n+\t* cp-gimplify.c (lvalue_has_side_effects): New.\n+\t(cp_gimplify_expr): Implement assignment ordering.\n \t* call.c (op_is_ordered, build_over_call): Adjust for\n \t-fargs-in-order renaming to -fstrong-eval-order.\n \t* cp-gimplify.c (cp_gimplify_expr): Likewise."}, {"sha": "8496d7cfee70ac2436e0876b860adda7a352f3c5", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=65a550b46e5d9759fae0e5af17a494e1f9f5d821", "patch": "@@ -559,6 +559,33 @@ simple_empty_class_p (tree type, tree op)\n     && is_really_empty_class (type);\n }\n \n+/* Returns true if evaluating E as an lvalue has side-effects;\n+   specifically, a volatile lvalue has TREE_SIDE_EFFECTS, but it doesn't really\n+   have side-effects until there is a read or write through it.  */\n+\n+static bool\n+lvalue_has_side_effects (tree e)\n+{\n+  if (!TREE_SIDE_EFFECTS (e))\n+    return false;\n+  while (handled_component_p (e))\n+    {\n+      if (TREE_CODE (e) == ARRAY_REF\n+\t  && TREE_SIDE_EFFECTS (TREE_OPERAND (e, 1)))\n+\treturn true;\n+      e = TREE_OPERAND (e, 0);\n+    }\n+  if (DECL_P (e))\n+    /* Just naming a variable has no side-effects.  */\n+    return false;\n+  else if (INDIRECT_REF_P (e))\n+    /* Similarly, indirection has no side-effects.  */\n+    return TREE_SIDE_EFFECTS (TREE_OPERAND (e, 0));\n+  else\n+    /* For anything else, trust TREE_SIDE_EFFECTS.  */\n+    return TREE_SIDE_EFFECTS (e);\n+}\n+\n /* Do C++-specific gimplification.  Args are as for gimplify_expr.  */\n \n int\n@@ -659,8 +686,6 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t    /* Remove any copies of empty classes.  Also drop volatile\n \t       variables on the RHS to avoid infinite recursion from\n \t       gimplify_expr trying to load the value.  */\n-\t    gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t   is_gimple_lvalue, fb_lvalue);\n \t    if (TREE_SIDE_EFFECTS (op1))\n \t      {\n \t\tif (TREE_THIS_VOLATILE (op1)\n@@ -669,8 +694,29 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \n \t\tgimplify_and_add (op1, pre_p);\n \t      }\n+\t    gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t   is_gimple_lvalue, fb_lvalue);\n \t    *expr_p = TREE_OPERAND (*expr_p, 0);\n \t  }\n+\t/* P0145 says that the RHS is sequenced before the LHS.\n+\t   gimplify_modify_expr gimplifies the RHS before the LHS, but that\n+\t   isn't quite strong enough in two cases:\n+\n+\t   1) gimplify.c wants to leave a CALL_EXPR on the RHS, which would\n+\t   mean it's evaluated after the LHS.\n+\n+\t   2) the value calculation of the RHS is also sequenced before the\n+\t   LHS, so for scalar assignment we need to preevaluate if the\n+\t   RHS could be affected by LHS side-effects even if it has no\n+\t   side-effects of its own.  We don't need this for classes because\n+\t   class assignment takes its RHS by reference.  */\n+       else if (flag_strong_eval_order > 1\n+                && TREE_CODE (*expr_p) == MODIFY_EXPR\n+                && lvalue_has_side_effects (op0)\n+\t\t&& (TREE_CODE (op1) == CALL_EXPR\n+\t\t    || (SCALAR_TYPE_P (TREE_TYPE (op1))\n+\t\t\t&& !TREE_CONSTANT (op1))))\n+\t TREE_OPERAND (*expr_p, 1) = get_formal_tmp_var (op1, pre_p);\n       }\n       ret = GS_OK;\n       break;"}, {"sha": "ca8c1b43002c3f0659a32998af7e2673509d3f1d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=65a550b46e5d9759fae0e5af17a494e1f9f5d821", "patch": "@@ -4080,6 +4080,13 @@ diagnosed by this option, and it may give an occasional false positive\n result, but in general it has been found fairly effective at detecting\n this sort of problem in programs.\n \n+The C++17 standard will define the order of evaluation of operands in\n+more cases: in particular it requires that the right-hand side of an\n+assignment be evaluated before the left-hand side, so the above\n+examples are no longer undefined.  But this warning will still warn\n+about them, to help people avoid writing code that is undefined in C\n+and earlier revisions of C++.\n+\n The standard is worded confusingly, therefore there is some debate\n over the precise meaning of the sequence point rules in subtle cases.\n Links to discussions of the problem, including proposed formal"}, {"sha": "e87dce4006c2a2b9a5393de9257baafd3e8867aa", "filename": "gcc/testsuite/g++.dg/cpp1z/eval-order3.C", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a550b46e5d9759fae0e5af17a494e1f9f5d821/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order3.C?ref=65a550b46e5d9759fae0e5af17a494e1f9f5d821", "patch": "@@ -31,6 +31,13 @@ struct A\n   A& operator+=(int i) { return *this; }\n };\n \n+struct B\n+{\n+  int _i;\n+  B(): _i(0) {}\n+  B(int i): _i(f(i)) { }\n+};\n+\n int operator>>(A&, int i) { }\n \n A a(0);\n@@ -46,6 +53,18 @@ A& aref(int i)\n   return a;\n }\n \n+B b;\n+B bval(int i)\n+{\n+  return B(i);\n+}\n+\n+B& bref(int i)\n+{\n+  f(i);\n+  return b;\n+}\n+\n static int si;\n int* ip (int i)\n {\n@@ -84,10 +103,18 @@ template <class T> void f()\n \n   // b @= a\n   aref(19)=A(18);\n-  //iref(21)=f(20);\n+  iref(21)=f(20);\n   aref(23)+=f(22);\n+  bref(25)=bval(24);\n+  (f(27), b) = bval(26);\n   last = 0;\n \n+  int ar[4] = {};\n+  int i = 0;\n+  ar[i++] = i;\n+  if (ar[0] != 0)\n+    __builtin_abort();\n+\n   // a[b]\n   afn(20)[f(21)-21].memfn(f(22),23);\n   ip(24)[f(25)-25] = 0;\n@@ -123,10 +150,18 @@ void g()\n \n   // b @= a\n   aref(19)=A(18);\n-  //iref(21)=f(20);\n+  iref(21)=f(20);\n   aref(23)+=f(22);\n+  bref(25)=bval(24);\n+  (f(27), b) = bval(26);\n   last = 0;\n \n+  int ar[4] = {};\n+  int i = 0;\n+  ar[i++] = i;\n+  if (ar[0] != 0)\n+    __builtin_abort();\n+\n   // a[b]\n   afn(20)[f(21)-21].memfn(f(22),23);\n   ip(24)[f(25)-25] = 0;"}]}